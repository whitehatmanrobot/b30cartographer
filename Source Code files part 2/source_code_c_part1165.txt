har FAR* WINAPI GlobalLock(HGLOBAL);
#endif

BOOL    WINAPI GlobalUnlock(HGLOBAL);

DWORD   WINAPI GlobalSize(HGLOBAL);
DWORD   WINAPI GlobalHandle(UINT);

/* GlobalFlags return flags (in addition to GMEM_DISCARDABLE) */
#define GMEM_DISCARDED	    0x4000
#define GMEM_LOCKCOUNT	    0x00FF
UINT    WINAPI GlobalFlags(HGLOBAL);

#ifdef STRICT
void FAR* WINAPI GlobalWire(HGLOBAL);
#else
char FAR* WINAPI GlobalWire(HGLOBAL);
#endif

BOOL    WINAPI GlobalUnWire(HGLOBAL);

UINT    WINAPI GlobalPageLock(HGLOBAL);
UINT    WINAPI GlobalPageUnlock(HGLOBAL);

void    WINAPI GlobalFix(HGLOBAL);
void    WINAPI GlobalUnfix(HGLOBAL);

HGLOBAL WINAPI GlobalLRUNewest(HGLOBAL);
HGLOBAL WINAPI GlobalLRUOldest(HGLOBAL);

DWORD   WINAPI GlobalCompact(DWORD);

#ifdef STRICT
typedef BOOL (CALLBACK* GNOTIFYPROC)(HGLOBAL);
#else
typedef FARPROC GNOTIFYPROC;
#endif

void    WINAPI GlobalNotify(GNOTIFYPROC);

HGLOBAL WINAPI LockSegment(UINT);
void    WINAPI UnlockSegment(UINT);

#define LockData(dummy)     LockSegment((UINT)-1)
#define UnlockData(dummy)   UnlockSegment((UINT)-1)

UINT    WINAPI AllocSelector(UINT);
UINT    WINAPI FreeSelector(UINT);
UINT    WINAPI AllocDStoCSAlias(UINT);
UINT    WINAPI PrestoChangoSelector(UINT sourceSel, UINT destSel);
DWORD   WINAPI GetSelectorBase(UINT);
UINT    WINAPI SetSelectorBase(UINT, DWORD);
DWORD   WINAPI GetSelectorLimit(UINT);
UINT    WINAPI SetSelectorLimit(UINT, DWORD);

void    WINAPI LimitEmsPages(DWORD);

void    WINAPI ValidateFreeSpaces(void);

/* Low system memory notification message */
#define WM_COMPACTING       0x0041

/***** Local Memory Management */

/* Local Memory Flags */
#define LMEM_FIXED	    0x0000
#define LMEM_MOVEABLE	    0x0002
#define LMEM_NOCOMPACT	    0x0010
#define LMEM_NODISCARD	    0x0020
#define LMEM_ZEROINIT	    0x0040
#define LMEM_MODIFY	    0x0080
#define LMEM_DISCARDABLE    0x0F00

#define LHND		    (LMEM_MOVEABLE | LMEM_ZEROINIT)
#define LPTR		    (LMEM_FIXED | LMEM_ZEROINIT)

#define NONZEROLHND	    (LMEM_MOVEABLE)
#define NONZEROLPTR	    (LMEM_FIXED)


#define LocalDiscard(h)     LocalReAlloc(h, 0, LMEM_MOVEABLE)


HLOCAL  WINAPI LocalAlloc(UINT, UINT);
HLOCAL  WINAPI LocalReAlloc(HLOCAL, UINT, UINT);
HLOCAL  WINAPI LocalFree(HLOCAL);

#ifdef STRICT
void NEAR* WINAPI LocalLock(HLOCAL);
#else
char NEAR* WINAPI LocalLock(HLOCAL);
#endif

BOOL    WINAPI LocalUnlock(HLOCAL);

UINT    WINAPI LocalSize(HLOCAL);
#ifdef STRICT
HLOCAL  WINAPI LocalHandle(void NEAR*);
#else
HLOCAL  WINAPI LocalHandle(UINT);
#endif

/* LocalFlags return flags (in addition to LMEM_DISCARDABLE) */
#define LMEM_DISCARDED	    0x4000
#define LMEM_LOCKCOUNT	    0x00FF

UINT    WINAPI LocalFlags(HLOCAL);

BOOL    WINAPI LocalInit(UINT, UINT, UINT);
UINT    WINAPI LocalCompact(UINT);
UINT    WINAPI LocalShrink(HLOCAL, UINT);

#endif  /* NOMEMMGR */

/****** File I/O ************************************************************/

#ifndef NOLFILEIO

typedef int HFILE;      /* Polymorphic with C runtime file handle type */

#define HFILE_ERROR ((HFILE)-1)

#ifndef NOOPENFILE

/* OpenFile() Structure */
typedef struct tagOFSTRUCT
{
    BYTE cBytes;
    BYTE fFixedDisk;
    UINT nErrCode;
    BYTE reserved[4];
    char szPathName[128];
} OFSTRUCT;
typedef OFSTRUCT*       POFSTRUCT;
typedef OFSTRUCT NEAR* NPOFSTRUCT;
typedef OFSTRUCT FAR*  LPOFSTRUCT;

/* OpenFile() Flags */
#define OF_READ 	    0x0000
#define OF_WRITE	    0x0001
#define OF_READWRITE	    0x0002
#define OF_SHARE_COMPAT	    0x0000
#define OF_SHARE_EXCLUSIVE  0x0010
#define OF_SHARE_DENY_WRITE 0x0020
#define OF_SHARE_DENY_READ  0x0030
#define OF_SHARE_DENY_NONE  0x0040
#define OF_PARSE	    0x0100
#define OF_DELETE	    0x0200
#define OF_VERIFY	    0x0400      /* Used with OF_REOPEN */
#define OF_SEARCH	    0x0400	/* Used without OF_REOPEN */
#define OF_CANCEL	    0x0800
#define OF_CREATE	    0x1000
#define OF_PROMPT	    0x2000
#define OF_EXIST	    0x4000
#define OF_REOPEN	    0x8000

HFILE   WINAPI OpenFile(LPCSTR, OFSTRUCT FAR*, UINT);

#endif  /* NOOPENFILE */

/* _lopen() flags */
#define READ	    0
#define WRITE       1
#define READ_WRITE  2

HFILE   WINAPI _lopen(LPCSTR, int);
HFILE   WINAPI _lcreat(LPCSTR, int);

HFILE   WINAPI _lclose(HFILE);

LONG    WINAPI _llseek(HFILE, LONG, int);

/* _llseek origin values */
#define SEEK_SET 0
#define SEEK_CUR 1
#define SEEK_END 2

UINT    WINAPI _lread(HFILE, void _huge*, UINT);
UINT    WINAPI _lwrite(HFILE, const void _huge*, UINT);

#if (WINVER >= 0x030a)
long	WINAPI _hread(HFILE, void _huge*, long);
long	WINAPI _hwrite(HFILE, const void _huge*, long);
#endif	/* WINVER >= 0x030a */


#endif	/* NOLFILEIO */

/* GetTempFileName() Flags */
#define TF_FORCEDRIVE	    (BYTE)0x80

int     WINAPI GetTempFileName(BYTE, LPCSTR, UINT, LPSTR);
BYTE    WINAPI GetTempDrive(char);

/* GetDriveType return values */
#define DRIVE_REMOVABLE 2
#define DRIVE_FIXED     3
#define DRIVE_REMOTE    4
UINT    WINAPI GetDriveType(int);

UINT    WINAPI SetHandleCount(UINT);

/****** Network support *****************************************************/
UINT WINAPI WNetAddConnection(LPSTR, LPSTR, LPSTR);
UINT WINAPI WNetGetConnection(LPSTR, LPSTR, UINT FAR*);
UINT WINAPI WNetCancelConnection(LPSTR, BOOL);
/* Errors */
#define WN_SUCCESS			0x0000
#define WN_NOT_SUPPORTED		0x0001
#define WN_NET_ERROR			0x0002
#define WN_MORE_DATA			0x0003
#define WN_BAD_POINTER			0x0004
#define WN_BAD_VALUE			0x0005
#define WN_BAD_PASSWORD                 0x0006
#define WN_ACCESS_DENIED		0x0007
#define WN_FUNCTION_BUSY		0x0008
#define WN_WINDOWS_ERROR		0x0009
#define WN_BAD_USER			0x000A
#define WN_OUT_OF_MEMORY		0x000B
#define WN_CANCEL			0x000C
#define WN_CONTINUE			0x000D

/* Connection errors */
#define WN_NOT_CONNECTED		0x0030
#define WN_OPEN_FILES			0x0031
#define WN_BAD_NETNAME			0x0032
#define WN_BAD_LOCALNAME		0x0033
#define WN_ALREADY_CONNECTED		0x0034
#define WN_DEVICE_ERROR 		0x0035
#define WN_CONNECTION_CLOSED		0x0036

/****** Resource Management *************************************************/

DECLARE_HANDLE(HRSRC);

HRSRC   WINAPI FindResource(HINSTANCE, LPCSTR, LPCSTR);
HGLOBAL WINAPI LoadResource(HINSTANCE, HRSRC);
BOOL    WINAPI FreeResource(HGLOBAL);

#ifdef STRICT
void FAR* WINAPI LockResource(HGLOBAL);
#else
char FAR* WINAPI LockResource(HGLOBAL);
#endif

#define     UnlockResource(h)	    GlobalUnlock(h)

DWORD   WINAPI SizeofResource(HINSTANCE, HRSRC);

int     WINAPI AccessResource(HINSTANCE, HRSRC);

HGLOBAL WINAPI AllocResource(HINSTANCE, HRSRC, DWORD);

#ifdef STRICT
typedef HGLOBAL (CALLBACK* RSRCHDLRPROC)(HGLOBAL, HINSTANCE, HRSRC);
#else
typedef FARPROC RSRCHDLRPROC;
#endif

RSRCHDLRPROC WINAPI SetResourceHandler(HINSTANCE, LPCSTR, RSRCHDLRPROC);

#define MAKEINTRESOURCE(i)  ((LPCSTR)MAKELP(0, (i)))

#ifndef NORESOURCE

/* Predefined Resource Types */
#define RT_CURSOR	    MAKEINTRESOURCE(1)
#define RT_BITMAP	    MAKEINTRESOURCE(2)
#define RT_ICON 	    MAKEINTRESOURCE(3)
#define RT_MENU 	    MAKEINTRESOURCE(4)
#define RT_DIALOG	    MAKEINTRESOURCE(5)
#define RT_STRING	    MAKEINTRESOURCE(6)
#define RT_FONTDIR	    MAKEINTRESOURCE(7)
#define RT_FONT 	    MAKEINTRESOURCE(8)
#define RT_ACCELERATOR	    MAKEINTRESOURCE(9)
#define RT_RCDATA	    MAKEINTRESOURCE(10)

#define RT_GROUP_CURSOR     MAKEINTRESOURCE(12)
#define RT_GROUP_ICON	    MAKEINTRESOURCE(14)

#endif  /* NORESOURCE */

#ifdef OEMRESOURCE

/* OEM Resource Ordinal Numbers */
#define OBM_CLOSE	    32754
#define OBM_UPARROW         32753
#define OBM_DNARROW         32752
#define OBM_RGARROW         32751
#define OBM_LFARROW         32750
#define OBM_REDUCE          32749
#define OBM_ZOOM            32748
#define OBM_RESTORE         32747
#define OBM_REDUCED         32746
#define OBM_ZOOMD           32745
#define OBM_RESTORED        32744
#define OBM_UPARROWD        32743
#define OBM_DNARROWD        32742
#define OBM_RGARROWD        32741
#define OBM_LFARROWD        32740
#define OBM_MNARROW         32739
#define OBM_COMBO           32738
#if (WINVER >= 0x030a)
#define OBM_UPARROWI	    32737
#define OBM_DNARROWI	    32736
#define OBM_RGARROWI	    32735
#define OBM_LFARROWI	    32734
#endif  /* WINVER >= 0x030a */

#define OBM_OLD_CLOSE       32767
#define OBM_SIZE            32766
#define OBM_OLD_UPARROW     32765
#define OBM_OLD_DNARROW     32764
#define OBM_OLD_RGARROW     32763
#define OBM_OLD_LFARROW     32762
#define OBM_BTSIZE          32761
#define OBM_CHECK           32760
#define OBM_CHECKBOXES      32759
#define OBM_BTNCORNERS      32758
#define OBM_OLD_REDUCE      32757
#define OBM_OLD_ZOOM        32756
#define OBM_OLD_RESTORE     32755

#define OCR_NORMAL	    32512
#define OCR_IBEAM	    32513
#define OCR_WAIT	    32514
#define OCR_CROSS	    32515
#define OCR_UP		    32516
#define OCR_SIZE	    32640
#define OCR_ICON	    32641
#define OCR_SIZENWSE	    32642
#define OCR_SIZENESW	    32643
#define OCR_SIZEWE	    32644
#define OCR_SIZENS	    32645
#define OCR_SIZEALL	    32646
#define OCR_ICOCUR	    32647

#define OIC_SAMPLE	    32512
#define OIC_HAND	    32513
#define OIC_QUES	    32514
#define OIC_BANG	    32515
#define OIC_NOTE	    32516

#endif  /* OEMRESOURCE */

/****** Atom Management *****************************************************/

#define MAKEINTATOM(i)      ((LPCSTR)MAKELP(0, (i)))

#ifndef NOATOM

BOOL    WINAPI InitAtomTable(int);
ATOM    WINAPI AddAtom(LPCSTR);
ATOM    WINAPI DeleteAtom(ATOM);
ATOM    WINAPI FindAtom(LPCSTR);
UINT    WINAPI GetAtomName(ATOM, LPSTR, int);
ATOM    WINAPI GlobalAddAtom(LPCSTR);
ATOM    WINAPI GlobalDeleteAtom(ATOM);
ATOM    WINAPI GlobalFindAtom(LPCSTR);
UINT    WINAPI GlobalGetAtomName(ATOM, LPSTR, int);
HLOCAL  WINAPI GetAtomHandle(ATOM);

#endif  /* NOATOM */

/****** WIN.INI Support *****************************************************/

/* User Profile Routines */
UINT    WINAPI GetProfileInt(LPCSTR, LPCSTR, int);
int     WINAPI GetProfileString(LPCSTR, LPCSTR, LPCSTR, LPSTR, int);
BOOL    WINAPI WriteProfileString(LPCSTR, LPCSTR, LPCSTR);

UINT    WINAPI GetPrivateProfileInt(LPCSTR, LPCSTR, int, LPCSTR);
int     WINAPI GetPrivateProfileString(LPCSTR, LPCSTR, LPCSTR, LPSTR, int, LPCSTR);
BOOL    WINAPI WritePrivateProfileString(LPCSTR, LPCSTR, LPCSTR, LPCSTR);

#define WM_WININICHANGE	    0x001A

/****** International & Char Translation Support ****************************/

void    WINAPI AnsiToOem(const char _huge*, char _huge*);
void    WINAPI OemToAnsi(const char _huge*, char _huge*);

void    WINAPI AnsiToOemBuff(LPCSTR, LPSTR, UINT);
void    WINAPI OemToAnsiBuff(LPCSTR, LPSTR, UINT);

LPSTR   WINAPI AnsiNext(LPCSTR);
LPSTR   WINAPI AnsiPrev(LPCSTR, LPCSTR);

LPSTR   WINAPI AnsiUpper(LPSTR);
LPSTR   WINAPI AnsiLower(LPSTR);

UINT    WINAPI AnsiUpperBuff(LPSTR, UINT);
UINT    WINAPI AnsiLowerBuff(LPSTR, UINT);


#ifndef  NOLANGUAGE
BOOL    WINAPI IsCharAlpha(char);
BOOL    WINAPI IsCharAlphaNumeric(char);
BOOL    WINAPI IsCharUpper(char);
BOOL    WINAPI IsCharLower(char);
#endif

#ifndef NOLSTRING
int     WINAPI lstrcmp(LPCSTR, LPCSTR);
int     WINAPI lstrcmpi(LPCSTR, LPCSTR);
LPSTR   WINAPI lstrcpy(LPSTR, LPCSTR);
LPSTR   WINAPI lstrcat(LPSTR, LPCSTR);
int     WINAPI lstrlen(LPCSTR);
#if (WINVER >= 0x030a)
LPSTR   WINAPI lstrcpyn(LPSTR, LPCSTR, int);
void    WINAPI hmemcpy(void _huge*, const void _huge*, long);
#endif	/* WINVER >= 0x030a */
#endif	/* NOLSTRING */

#if (WINVER >= 0x030a)
#ifndef NODBCS
BOOL    WINAPI IsDBCSLeadByte(BYTE);
#endif	/* NODBCS */
#endif  /* WINVER >= 0x030a */

int     WINAPI LoadString(HINSTANCE, UINT, LPSTR, int);

/****** Keyboard Driver Functions *******************************************/

#ifndef	NOKEYBOARDINFO

DWORD   WINAPI OemKeyScan(UINT);
UINT    WINAPI VkKeyScan(UINT);
int     WINAPI GetKeyboardType(int);
UINT    WINAPI MapVirtualKey(UINT, UINT);
int     WINAPI GetKBCodePage(void);
int     WINAPI GetKeyNameText(LONG, LPSTR, int);
int     WINAPI ToAscii(UINT wVirtKey, UINT wScanCode, BYTE FAR* lpKeyState, DWORD FAR* lpChar, UINT wFlags);

#endif

#endif  /* NOKERNEL */

/****** GDI typedefs, structures, and functions *****************************/

DECLARE_HANDLE(HDC);

#ifndef NOGDI

#ifdef STRICT
typedef const void NEAR* HGDIOBJ;
#else
DECLARE_HANDLE(HGDIOBJ);
#endif

#endif	/* NOGDI */

DECLARE_HANDLE(HBITMAP);
DECLARE_HANDLE(HPEN);
DECLARE_HANDLE(HBRUSH);
DECLARE_HANDLE(HRGN);
DECLARE_HANDLE(HPALETTE);
DECLARE_HANDLE(HFONT);

typedef struct tagRECT
{
    int left;
    int top;
    int right;
    int bottom;
} RECT;
typedef RECT*      PRECT;
typedef RECT NEAR* NPRECT;
typedef RECT FAR*  LPRECT;

typedef struct tagPOINT
{
    int x;
    int y;
} POINT;
typedef POINT*       PPOINT;
typedef POINT NEAR* NPPOINT;
typedef POINT FAR*  LPPOINT;

#if (WINVER >= 0x030a)
typedef struct tagSIZE
{
    int cx;
    int cy;
} SIZE;
typedef SIZE*       PSIZE;
typedef SIZE NEAR* NPSIZE;
typedef SIZE FAR*  LPSIZE;
#endif  /* WINVER >= 0x030a */

#define MAKEPOINT(l)	    (*((POINT FAR*)&(l)))

#ifndef NOGDI

/****** DC Management *******************************************************/

HDC     WINAPI CreateDC(LPCSTR, LPCSTR, LPCSTR, const void FAR*);
HDC     WINAPI CreateIC(LPCSTR, LPCSTR, LPCSTR, const void FAR*);
HDC     WINAPI CreateCompatibleDC(HDC);

BOOL    WINAPI DeleteDC(HDC);

DWORD   WINAPI GetDCOrg(HDC);

int     WINAPI SaveDC(HDC);
BOOL    WINAPI RestoreDC(HDC, int);

int     WINAPI SetEnvironment(LPCSTR, const void FAR*, UINT);
int     WINAPI GetEnvironment(LPCSTR, void FAR*, UINT);

int     WINAPI MulDiv(int, int, int);

#if (WINVER >= 0x030a)
/* Drawing bounds accumulation APIs */
UINT    WINAPI SetBoundsRect(HDC hDC, const RECT FAR* lprcBounds, UINT flags);
UINT    WINAPI GetBoundsRect(HDC hDC, RECT FAR* lprcBounds, UINT flags);

#define DCB_RESET       0x0001
#define DCB_ACCUMULATE  0x0002
#define DCB_DIRTY	DCB_ACCUMULATE
#define DCB_SET 	(DCB_RESET | DCB_ACCUMULATE)
#define DCB_ENABLE      0x0004
#define DCB_DISABLE     0x0008
#endif  /* WINVER >= 0x030a */

/****** Device Capabilities *************************************************/

int WINAPI GetDeviceCaps(HDC, int);

/* Device Parameters for GetDeviceCaps() */
#define DRIVERVERSION 0
#define TECHNOLOGY    2
#define HORZSIZE      4
#define VERTSIZE      6
#define HORZRES       8
#define VERTRES       10
#define BITSPIXEL     12
#define PLANES        14
#define NUMBRUSHES    16
#define NUMPENS       18
#define NUMMARKERS    20
#define NUMFONTS      22
#define NUMCOLORS     24
#define PDEVICESIZE   26
#define CURVECAPS     28
#define LINECAPS      30
#define POLYGONALCAPS 32
#define TEXTCAPS      34
#define CLIPCAPS      36
#define RASTERCAPS    38
#define ASPECTX       40
#define ASPECTY       42
#define ASPECTXY      44

#define LOGPIXELSX    88
#define LOGPIXELSY    90

#define SIZEPALETTE  104
#define NUMRESERVED  106
#define COLORRES     108

#ifndef NOGDICAPMASKS

/* GetDeviceCaps() return value masks */

/* TECHNOLOGY */
#define DT_PLOTTER          0
#define DT_RASDISPLAY       1
#define DT_RASPRINTER       2
#define DT_RASCAMERA        3
#define DT_CHARSTREAM       4
#define DT_METAFILE         5
#define DT_DISPFILE         6

/* CURVECAPS */
#define CC_NONE             0x0000
#define CC_CIRCLES          0x0001
#define CC_PIE              0x0002
#define CC_CHORD            0x0004
#define CC_ELLIPSES         0x0008
#define CC_WIDE             0x0010
#define CC_STYLED           0x0020
#define CC_WIDESTYLED       0x0040
#define CC_INTERIORS        0x0080
#define CC_ROUNDRECT        0x0100

/* LINECAPS */
#define LC_NONE             0x0000
#define LC_POLYLINE         0x0002
#define LC_MARKER           0x0004
#define LC_POLYMARKER       0x0008
#define LC_WIDE             0x0010
#define LC_STYLED           0x0020
#define LC_WIDESTYLED       0x0040
#define LC_INTERIORS        0x0080

/* POLYGONALCAPS */
#define PC_NONE             0x0000
#define PC_POLYGON          0x0001
#define PC_RECTANGLE        0x0002
#define PC_WINDPOLYGON      0x0004
#define PC_SCANLINE         0x0008
#define PC_WIDE             0x0010
#define PC_STYLED           0x0020
#define PC_WIDESTYLED       0x0040
#define PC_INTERIORS        0x0080

/* TEXTCAPS */
#define TC_OP_CHARACTER     0x0001
#define TC_OP_STROKE        0x0002
#define TC_CP_STROKE        0x0004
#define TC_CR_90            0x0008
#define TC_CR_ANY           0x0010
#define TC_SF_X_YINDEP      0x0020
#define TC_SA_DOUBLE        0x0040
#define TC_SA_INTEGER       0x0080
#define TC_SA_CONTIN        0x0100
#define TC_EA_DOUBLE        0x0200
#define TC_IA_ABLE          0x0400
#define TC_UA_ABLE          0x0800
#define TC_SO_ABLE          0x1000
#define TC_RA_ABLE          0x2000
#define TC_VA_ABLE          0x4000
#define TC_RESERVED         0x8000

/* CLIPCAPS */
#define CP_NONE             0x0000
#define CP_RECTANGLE        0x0001
#define CP_REGION           0x0002

/* RASTERCAPS */
#define RC_NONE
#define RC_BITBLT           0x0001
#define RC_BANDING          0x0002
#define RC_SCALING          0x0004
#define RC_BITMAP64         0x0008
#define RC_GDI20_OUTPUT     0x0010
#define RC_GDI20_STATE      0x0020
#define RC_SAVEBITMAP       0x0040
#define RC_DI_BITMAP        0x0080
#define RC_PALETTE          0x0100
#define RC_DIBTODEV         0x0200
#define RC_BIGFONT          0x0400
#define RC_STRETCHBLT       0x0800
#define RC_FLOODFILL        0x1000
#define RC_STRETCHDIB       0x2000
#define RC_OP_DX_OUTPUT     0x4000
#define RC_DEVBITS          0x8000

#endif  /* NOGDICAPMASKS */

/****** Coordinate transformation support ***********************************/

int     WINAPI SetMapMode(HDC, int);
int     WINAPI GetMapMode(HDC);

/* Map modes */
#define MM_TEXT		    1
#define MM_LOMETRIC	    2
#define MM_HIMETRIC	    3
#define MM_LOENGLISH	    4
#define MM_HIENGLISH	    5
#define MM_TWIPS	    6
#define MM_ISOTROPIC	    7
#define MM_ANISOTROPIC	    8

DWORD   WINAPI SetWindowOrg(HDC, int, int);
DWORD   WINAPI GetWindowOrg(HDC);

DWORD   WINAPI SetWindowExt(HDC, int, int);
DWORD   WINAPI GetWindowExt(HDC);

DWORD   WINAPI OffsetWindowOrg(HDC, int, int);
DWORD   WINAPI ScaleWindowExt(HDC, int, int, int, int);

DWORD   WINAPI SetViewportOrg(HDC, int, int);
DWORD   WINAPI GetViewportOrg(HDC);

DWORD   WINAPI SetViewportExt(HDC, int, int);
DWORD   WINAPI GetViewportExt(HDC);

DWORD   WINAPI OffsetViewportOrg(HDC, int, int);
DWORD   WINAPI ScaleViewportExt(HDC, int, int, int, int);

#if (WINVER >= 0x030a)
BOOL    WINAPI SetWindowOrgEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI GetWindowOrgEx(HDC, POINT FAR*);

BOOL    WINAPI SetWindowExtEx(HDC, int, int, SIZE FAR*);
BOOL    WINAPI GetWindowExtEx(HDC, SIZE FAR*);

BOOL    WINAPI OffsetWindowOrgEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI ScaleWindowExtEx(HDC, int, int, int, int, SIZE FAR*);

BOOL    WINAPI SetViewportExtEx(HDC, int, int, SIZE FAR*);
BOOL    WINAPI GetViewportExtEx(HDC, SIZE FAR*);

BOOL    WINAPI SetViewportOrgEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI GetViewportOrgEx(HDC, POINT FAR*);

BOOL    WINAPI OffsetViewportOrgEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI ScaleViewportExtEx(HDC, int, int, int, int, SIZE FAR*);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI DPtoLP(HDC, POINT FAR*, int);
BOOL    WINAPI LPtoDP(HDC, POINT FAR*, int);


/* Coordinate Modes */
#define ABSOLUTE    1
#define RELATIVE    2

/****** Color support *******************************************************/

typedef DWORD COLORREF;

#define RGB(r,g,b)          ((COLORREF)(((BYTE)(r)|((WORD)(g)<<8))|(((DWORD)(BYTE)(b))<<16)))

#define GetRValue(rgb)	    ((BYTE)(rgb))
#define GetGValue(rgb)      ((BYTE)(((WORD)(rgb)) >> 8))
#define GetBValue(rgb)	    ((BYTE)((rgb)>>16))

COLORREF WINAPI GetNearestColor(HDC, COLORREF);

#ifndef NOCOLOR

COLORREF WINAPI GetSysColor(int);
void    WINAPI SetSysColors(int, const int FAR*, const COLORREF FAR*);

#define COLOR_SCROLLBAR		   0
#define COLOR_BACKGROUND	   1
#define COLOR_ACTIVECAPTION	   2
#define COLOR_INACTIVECAPTION	   3
#define COLOR_MENU		   4
#define COLOR_WINDOW		   5
#define COLOR_WINDOWFRAME	   6
#define COLOR_MENUTEXT		   7
#define COLOR_WINDOWTEXT	   8
#define COLOR_CAPTIONTEXT  	   9
#define COLOR_ACTIVEBORDER	  10
#define COLOR_INACTIVEBORDER	  11
#define COLOR_APPWORKSPACE	  12
#define COLOR_HIGHLIGHT		  13
#define COLOR_HIGHLIGHTTEXT	  14
#define COLOR_BTNFACE             15
#define COLOR_BTNSHADOW           16
#define COLOR_GRAYTEXT            17
#define COLOR_BTNTEXT		  18
#if (WINVER >= 0x030a)
#define COLOR_INACTIVECAPTIONTEXT 19
#define COLOR_BTNHIGHLIGHT        20
#endif  /* WINVER >= 0x030a */

#endif  /* NOCOLOR */

#define WM_SYSCOLORCHANGE   0x0015

/****** GDI Object Support **************************************************/

#ifndef NOGDIOBJ

HGDIOBJ WINAPI GetStockObject(int);

BOOL    WINAPI IsGDIObject(HGDIOBJ);

BOOL    WINAPI DeleteObject(HGDIOBJ);
HGDIOBJ WINAPI SelectObject(HDC, HGDIOBJ);
int     WINAPI GetObject(HGDIOBJ, int, void FAR*);
BOOL    WINAPI UnrealizeObject(HGDIOBJ);

#ifdef STRICT
typedef (CALLBACK* GOBJENUMPROC)(void FAR*, LPARAM);
#else
typedef FARPROC GOBJENUMPROC;
#endif

#ifdef STRICT
int     WINAPI EnumObjects(HDC, int, GOBJENUMPROC, LPARAM);
#else
int     WINAPI EnumObjects(HDC, int, GOBJENUMPROC, LPSTR);
#endif

/* Object types for EnumObjects() */
#define OBJ_PEN 	    1
#define OBJ_BRUSH	    2

/****** Pen support *********************************************************/

/* Logical Pen */
typedef struct tagLOGPEN
{
    UINT    lopnStyle;
    POINT   lopnWidth;
    COLORREF lopnColor;
} LOGPEN;
typedef LOGPEN*       PLOGPEN;
typedef LOGPEN NEAR* NPLOGPEN;
typedef LOGPEN FAR*  LPLOGPEN;

/* Pen Styles */
#define PS_SOLID	    0
#define PS_DASH             1
#define PS_DOT              2
#define PS_DASHDOT          3
#define PS_DASHDOTDOT       4
#define PS_NULL 	    5
#define PS_INSIDEFRAME 	    6

HPEN    WINAPI CreatePen(int, int, COLORREF);
HPEN    WINAPI CreatePenIndirect(LOGPEN FAR*);

/* Stock pens for use with GetStockObject(); */
#define WHITE_PEN	    6
#define BLACK_PEN	    7
#define NULL_PEN	    8

/****** Brush support *******************************************************/

/* Brush Styles */
#define BS_SOLID	    0
#define BS_NULL		    1
#define BS_HOLLOW	    BS_NULL
#define BS_HATCHED	    2
#define BS_PATTERN	    3
#define BS_INDEXED	    4
#define	BS_DIBPATTERN	    5

/* Hatch Styles */
#define HS_HORIZONTAL       0
#define HS_VERTICAL         1
#define HS_FDIAGONAL        2
#define HS_BDIAGONAL        3
#define HS_CROSS            4
#define HS_DIAGCROSS        5

/* Logical Brush (or Pattern) */
typedef struct tagLOGBRUSH
{
    UINT     lbStyle;
    COLORREF lbColor;
    int      lbHatch;
} LOGBRUSH;
typedef LOGBRUSH*       PLOGBRUSH;
typedef LOGBRUSH NEAR* NPLOGBRUSH;
typedef LOGBRUSH FAR*  LPLOGBRUSH;

typedef LOGBRUSH	    PATTERN;
typedef PATTERN*       PPATTERN;
typedef PATTERN NEAR* NPPATTERN;
typedef PATTERN FAR*  LPPATTERN;

HBRUSH  WINAPI CreateSolidBrush(COLORREF);
HBRUSH  WINAPI CreateHatchBrush(int, COLORREF);
HBRUSH  WINAPI CreatePatternBrush(HBITMAP);
HBRUSH  WINAPI CreateDIBPatternBrush(HGLOBAL, UINT);
HBRUSH  WINAPI CreateBrushIndirect(LOGBRUSH FAR*);

/* Stock brushes for use with GetStockObject() */
#define WHITE_BRUSH	    0
#define LTGRAY_BRUSH	    1
#define GRAY_BRUSH	    2
#define DKGRAY_BRUSH	    3
#define BLACK_BRUSH	    4
#define NULL_BRUSH	    5
#define HOLLOW_BRUSH	    NULL_BRUSH

DWORD   WINAPI SetBrushOrg(HDC, int, int);
DWORD   WINAPI GetBrushOrg(HDC);

#if (WINVER >= 0x030a)
BOOL    WINAPI GetBrushOrgEx(HDC, POINT FAR*);
#endif  /* WINVER >= 0x030a */
#endif	/* NOGDIOBJ */

/****** Region support ******************************************************/

HRGN    WINAPI CreateRectRgn(int, int, int, int);
HRGN    WINAPI CreateRectRgnIndirect(const RECT FAR*);
HRGN    WINAPI CreateEllipticRgnIndirect(const RECT FAR*);
HRGN    WINAPI CreateEllipticRgn(int, int, int, int);
HRGN    WINAPI CreatePolygonRgn(const POINT FAR*, int, int);
HRGN    WINAPI CreatePolyPolygonRgn(const POINT FAR*, const int FAR*, int, int);
HRGN    WINAPI CreateRoundRectRgn(int, int, int, int, int, int);

/* Region type flags */
#define ERROR		    0
#define NULLREGION	    1
#define SIMPLEREGION	    2
#define COMPLEXREGION	    3

void    WINAPI SetRectRgn(HRGN, int, int, int, int);

int     WINAPI CombineRgn(HRGN, HRGN, HRGN, int);

/* CombineRgn() command values */
#define RGN_AND 	    1
#define RGN_OR		    2
#define RGN_XOR 	    3
#define RGN_DIFF	    4
#define RGN_COPY	    5

BOOL    WINAPI EqualRgn(HRGN, HRGN);
int     WINAPI OffsetRgn(HRGN, int, int);

int     WINAPI GetRgnBox(HRGN, RECT FAR*);

BOOL    WINAPI RectInRegion(HRGN, const RECT FAR*);
BOOL    WINAPI PtInRegion(HRGN, int, int);

/****** Color palette Support ************************************************/

#define PALETTERGB(r,g,b)   (0x02000000L | RGB(r,g,b))
#define PALETTEINDEX(i)     ((COLORREF)(0x01000000L | (DWORD)(WORD)(i)))

typedef struct tagPALETTEENTRY
{
    BYTE    peRed;
    BYTE    peGreen;
    BYTE    peBlue;
    BYTE    peFlags;
} PALETTEENTRY;
typedef PALETTEENTRY FAR* LPPALETTEENTRY;

/* Palette entry flags */
#define PC_RESERVED	0x01	/* palette index used for animation */
#define PC_EXPLICIT	0x02	/* palette index is explicit to device */
#define	PC_NOCOLLAPSE	0x04	/* do not match color to system palette */

/* Logical Palette */
typedef struct tagLOGPALETTE
{
    WORD    palVersion;
    WORD    palNumEntries;
    PALETTEENTRY palPalEntry[1];
} LOGPALETTE;
typedef LOGPALETTE*       PLOGPALETTE;
typedef LOGPALETTE NEAR* NPLOGPALETTE;
typedef LOGPALETTE FAR*  LPLOGPALETTE;

HPALETTE WINAPI CreatePalette(const LOGPALETTE FAR*);

HPALETTE WINAPI SelectPalette(HDC, HPALETTE, BOOL);

UINT    WINAPI RealizePalette(HDC);

int     WINAPI UpdateColors(HDC);
void    WINAPI AnimatePalette(HPALETTE, UINT, UINT, const PALETTEENTRY FAR*);

UINT    WINAPI SetPaletteEntries(HPALETTE, UINT, UINT, const PALETTEENTRY FAR*);
UINT    WINAPI GetPaletteEntries(HPALETTE, UINT, UINT, PALETTEENTRY FAR*);

UINT    WINAPI GetNearestPaletteIndex(HPALETTE, COLORREF);

BOOL    WINAPI ResizePalette(HPALETTE, UINT);

UINT    WINAPI GetSystemPaletteEntries(HDC, UINT, UINT, PALETTEENTRY FAR*);

UINT    WINAPI GetSystemPaletteUse(HDC);
UINT    WINAPI SetSystemPaletteUse(HDC, UINT);

/* Get/SetSystemPaletteUse() values */
#define	SYSPAL_STATIC	1
#define	SYSPAL_NOSTATIC 2

/* Palette window messages */
#define WM_QUERYNEWPALETTE  0x030F
#define WM_PALETTEISCHANGING 0x0310
#define WM_PALETTECHANGED   0x0311

/****** Clipping support *****************************************************/

int     WINAPI SelectClipRgn(HDC, HRGN);
int     WINAPI GetClipBox(HDC, RECT FAR*);

int     WINAPI IntersectClipRect(HDC, int, int, int, int);
int     WINAPI OffsetClipRgn(HDC, int, int);
int     WINAPI ExcludeClipRect(HDC, int, int, int, int);

BOOL    WINAPI PtVisible(HDC, int, int);
BOOL    WINAPI RectVisible(HDC, const RECT FAR*);


/****** General drawing support ********************************************/

DWORD   WINAPI MoveTo(HDC, int, int);
DWORD   WINAPI GetCurrentPosition(HDC);

#if (WINVER >= 0x030a)
BOOL    WINAPI MoveToEx(HDC, int, int, POINT FAR*);
BOOL    WINAPI GetCurrentPositionEx(HDC, POINT FAR*);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI LineTo(HDC, int, int);
BOOL    WINAPI Polyline(HDC, const POINT FAR*, int);

#ifdef STRICT
typedef void (CALLBACK* LINEDDAPROC)(int, int, LPARAM);
#else
typedef FARPROC LINEDDAPROC;
#endif

void    WINAPI LineDDA(int, int, int, int, LINEDDAPROC, LPARAM);

BOOL    WINAPI Rectangle(HDC, int, int, int, int);
BOOL    WINAPI RoundRect(HDC, int, int, int, int, int, int);

BOOL    WINAPI Ellipse(HDC, int, int, int, int);
BOOL    WINAPI Arc(HDC, int, int, int, int, int, int, int, int);
BOOL    WINAPI Chord(HDC, int, int, int, int, int, int, int, int);
BOOL    WINAPI Pie(HDC, int, int, int, int, int, int, int, int);

BOOL    WINAPI Polygon(HDC, const POINT FAR*, int);
BOOL    WINAPI PolyPolygon(HDC, const POINT FAR*, int FAR*, int);

/* PolyFill Modes */
#define ALTERNATE   1
#define WINDING     2

int     WINAPI SetPolyFillMode(HDC, int);
int     WINAPI GetPolyFillMode(HDC);

BOOL    WINAPI FloodFill(HDC, int, int, COLORREF);
BOOL    WINAPI ExtFloodFill(HDC, int, int, COLORREF, UINT);

/* ExtFloodFill style flags */
#define  FLOODFILLBORDER   0
#define  FLOODFILLSURFACE  1

BOOL    WINAPI FillRgn(HDC, HRGN, HBRUSH);
BOOL    WINAPI FrameRgn(HDC, HRGN, HBRUSH, int, int);
BOOL    WINAPI InvertRgn(HDC, HRGN);
BOOL    WINAPI PaintRgn(HDC, HRGN);

/* Rectangle output routines */
int     WINAPI FillRect(HDC, const RECT FAR*, HBRUSH);
int     WINAPI FrameRect(HDC, const RECT FAR*, HBRUSH);
void    WINAPI InvertRect(HDC, const RECT FAR*);

void    WINAPI DrawFocusRect(HDC, const RECT FAR*);


/****** Text support ********************************************************/

BOOL    WINAPI TextOut(HDC, int, int, LPCSTR, int);
LONG    WINAPI TabbedTextOut(HDC, int, int, LPCSTR, int, int, int FAR*, int);
BOOL    WINAPI ExtTextOut(HDC, int, int, UINT, const RECT FAR*, LPCSTR, UINT, int FAR*);

#define ETO_GRAYED	0x0001
#define ETO_OPAQUE	0x0002
#define ETO_CLIPPED	0x0004

DWORD   WINAPI GetTextExtent(HDC, LPCSTR, int);
DWORD   WINAPI GetTabbedTextExtent(HDC, LPCSTR, int, int, int FAR*);

#if (WINVER >= 0x030a)
BOOL    WINAPI GetTextExtentPoint(HDC, LPCSTR, int, SIZE FAR*);
#endif  /* WINVER >= 0x030a */

/* DrawText() Format Flags */
#ifndef NODRAWTEXT
#define DT_TOP		    0x0000
#define DT_LEFT 	    0x0000
#define DT_CENTER	    0x0001
#define DT_RIGHT	    0x0002
#define DT_VCENTER	    0x0004
#define DT_BOTTOM	    0x0008
#define DT_WORDBREAK        0x0010
#define DT_SINGLELINE	    0x0020
#define DT_EXPANDTABS	    0x0040
#define DT_TABSTOP	    0x0080
#define DT_NOCLIP	    0x0100
#define DT_EXTERNALLEADING  0x0200
#define DT_CALCRECT	    0x0400
#define DT_NOPREFIX	    0x0800
#define DT_INTERNAL	    0x1000

int     WINAPI DrawText(HDC, LPCSTR, int, RECT FAR*, UINT);
#endif  /* NODRAWTEXT */

#ifdef STRICT
typedef BOOL (CALLBACK* GRAYSTRINGPROC)(HDC, LPARAM, int);
#else
typedef FARPROC GRAYSTRINGPROC;
#endif

BOOL    WINAPI GrayString(HDC, HBRUSH, GRAYSTRINGPROC, LPARAM, int, int, int, int, int);

BOOL    WINAPI GetCharWidth(HDC, UINT, UINT, int FAR*);

COLORREF WINAPI SetTextColor(HDC, COLORREF);
COLORREF WINAPI GetTextColor(HDC);

COLORREF WINAPI SetBkColor(HDC, COLORREF);
COLORREF WINAPI GetBkColor(HDC);

int     WINAPI SetBkMode(HDC, int);
int     WINAPI GetBkMode(HDC);

/* Background Modes */
#define TRANSPARENT     1
#define OPAQUE          2

UINT    WINAPI SetTextAlign(HDC, UINT);
UINT    WINAPI GetTextAlign(HDC);

/* Text Alignment Options */
#define TA_NOUPDATECP		     0x0000
#define TA_UPDATECP		     0x0001
#define TA_LEFT 		     0x0000
#define TA_RIGHT		     0x0002
#define TA_CENTER		     0x0006
#define TA_TOP			     0x0000
#define TA_BOTTOM		     0x0008
#define TA_BASELINE		     0x0018

int     WINAPI SetTextCharacterExtra(HDC, int);
int     WINAPI GetTextCharacterExtra(HDC);

int     WINAPI SetTextJustification(HDC, int, int);

/****** Font support ********************************************************/

#ifndef NOGDIOBJ
/* Logical Font */
#define LF_FACESIZE	    32
typedef struct tagLOGFONT
{
    int     lfHeight;
    int     lfWidth;
    int     lfEscapement;
    int     lfOrientation;
    int     lfWeight;
    BYTE    lfItalic;
    BYTE    lfUnderline;
    BYTE    lfStrikeOut;
    BYTE    lfCharSet;
    BYTE    lfOutPrecision;
    BYTE    lfClipPrecision;
    BYTE    lfQuality;
    BYTE    lfPitchAndFamily;
    char    lfFaceName[LF_FACESIZE];
} LOGFONT;
typedef LOGFONT*       PLOGFONT;
typedef LOGFONT NEAR* NPLOGFONT;
typedef LOGFONT FAR*  LPLOGFONT;

/* weight values */
#define FW_DONTCARE	    0
#define FW_THIN 	    100
#define FW_EXTRALIGHT	    200
#define FW_LIGHT	    300
#define FW_NORMAL	    400
#define FW_MEDIUM	    500
#define FW_SEMIBOLD	    600
#define FW_BOLD 	    700
#define FW_EXTRABOLD	    800
#define FW_HEAVY	    900

#define FW_ULTRALIGHT	    FW_EXTRALIGHT
#define FW_REGULAR	    FW_NORMAL
#define FW_DEMIBOLD	    FW_SEMIBOLD
#define FW_ULTRABOLD	    FW_EXTRABOLD
#define FW_BLACK	    FW_HEAVY

/* CharSet values */
#define ANSI_CHARSET	    0
#define DEFAULT_CHARSET     1
#define SYMBOL_CHARSET	    2
#define SHIFTJIS_CHARSET    128
#define HANGEUL_CHARSET     129
#define CHINESEBIG5_CHARSET 136
#define OEM_CHARSET	    255

/* OutPrecision values */
#define OUT_DEFAULT_PRECIS	0
#define OUT_STRING_PRECIS	1
#define OUT_CHARACTER_PRECIS	2
#define OUT_STROKE_PRECIS	3
#if (WINVER >= 0x030a)
#define OUT_TT_PRECIS		4
#define OUT_DEVICE_PRECIS	5
#define OUT_RASTER_PRECIS	6
#define OUT_TT_ONLY_PRECIS	7
#endif  /* WINVER >= 0x030a */

/* ClipPrecision values */
#define CLIP_DEFAULT_PRECIS     0x00
#define CLIP_CHARACTER_PRECIS   0x01
#define CLIP_STROKE_PRECIS      0x02
#define CLIP_MASK		0x0F
#if (WINVER >= 0x030a)
#define CLIP_LH_ANGLES		0x10
#define CLIP_TT_ALWAYS		0x20
#define CLIP_EMBEDDED		0x80
#endif  /* WINVER >= 0x030a */

/* Quality values */
#define DEFAULT_QUALITY     0
#define DRAFT_QUALITY       1
#define PROOF_QUALITY       2

/* PitchAndFamily pitch values (low 4 bits) */
#define DEFAULT_PITCH       0x00
#define FIXED_PITCH         0x01
#define VARIABLE_PITCH      0x02

/* PitchAndFamily family values (high 4 bits) */
#define FF_DONTCARE         0x00
#define FF_ROMAN            0x10
#define FF_SWISS            0x20
#define FF_MODERN           0x30
#define FF_SCRIPT           0x40
#define FF_DECORATIVE       0x50

HFONT   WINAPI CreateFont(int, int, int, int, int, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, BYTE, LPCSTR);
HFONT   WINAPI CreateFontIndirect(const LOGFONT FAR*);

/* Stock fonts for use with GetStockObject() */
#define OEM_FIXED_FONT	    10
#define ANSI_FIXED_FONT     11
#define ANSI_VAR_FONT	    12
#define SYSTEM_FONT	    13
#define DEVICE_DEFAULT_FONT 14
#define DEFAULT_PALETTE     15
#define SYSTEM_FIXED_FONT   16


DWORD   WINAPI SetMapperFlags(HDC, DWORD);
#define ASPECT_FILTERING	     0x00000001L

int     WINAPI AddFontResource(LPCSTR);
BOOL    WINAPI RemoveFontResource(LPCSTR);

#define WM_FONTCHANGE	    0x001D

int     WINAPI GetTextFace(HDC, int, LPSTR);

DWORD   WINAPI GetAspectRatioFilter(HDC);
#if (WINVER >= 0x030a)
BOOL    WINAPI GetAspectRatioFilterEx(HDC, SIZE FAR*);
#endif  /* WINVER >= 0x030a */

#endif	/* NOGDIOBJ */

#ifndef NOTEXTMETRIC

typedef struct tagTEXTMETRIC
{
    int     tmHeight;
    int     tmAscent;
    int     tmDescent;
    int     tmInternalLeading;
    int     tmExternalLeading;
    int     tmAveCharWidth;
    int     tmMaxCharWidth;
    int     tmWeight;
    BYTE    tmItalic;
    BYTE    tmUnderlined;
    BYTE    tmStruckOut;
    BYTE    tmFirstChar;
    BYTE    tmLastChar;
    BYTE    tmDefaultChar;
    BYTE    tmBreakChar;
    BYTE    tmPitchAndFamily;
    BYTE    tmCharSet;
    int     tmOverhang;
    int     tmDigitizedAspectX;
    int     tmDigitizedAspectY;
} TEXTMETRIC;
typedef TEXTMETRIC*       PTEXTMETRIC;
typedef TEXTMETRIC NEAR* NPTEXTMETRIC;
typedef TEXTMETRIC FAR*  LPTEXTMETRIC;

/* tmPitchAndFamily values */
#define TMPF_FIXED_PITCH    0x01
#define TMPF_VECTOR	    0x02
#define TMPF_DEVICE	    0x08
#if (WINVER >= 0x030a)
#define TMPF_TRUETYPE	    0x04
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI GetTextMetrics(HDC, TEXTMETRIC FAR*);

#if (WINVER >= 0x030a)
#ifndef NOSCALABLEFONT

typedef struct tagPANOSE
{
    BYTE    bFamilyType;
    BYTE    bSerifStyle;
    BYTE    bWeight;
    BYTE    bProportion;
    BYTE    bContrast;
    BYTE    bStrokeVariation;
    BYTE    bArmStyle;
    BYTE    bLetterform;
    BYTE    bMidline;
    BYTE    bXHeight;
} PANOSE, FAR* LPPANOSE;

typedef struct tagOUTLINETEXTMETRIC
{
    UINT    otmSize;
    TEXTMETRIC otmTextMetrics;
    BYTE    otmFiller;
    PANOSE  otmPanoseNumber;
    UINT    otmfsSelection;
    UINT    otmfsType;
    int     otmsCharSlopeRise;
    int     otmsCharSlopeRun;
    int     otmItalicAngle;
    UINT    otmEMSquare;
    int     otmAscent;
    int     otmDescent;
    UINT    otmLineGap;
    UINT    otmsCapEmHeight;
    UINT    otmsXHeight;
    RECT    otmrcFontBox;
    int     otmMacAscent;
    int     otmMacDescent;
    UINT    otmMacLineGap;
    UINT    otmusMinimumPPEM;
    POINT   otmptSubscriptSize;
    POINT   otmptSubscriptOffset;
    POINT   otmptSuperscriptSize;
    POINT   otmptSuperscriptOffset;
    UINT    otmsStrikeoutSize;
    int     otmsStrikeoutPosition;
    int     otmsUnderscorePosition;
    int     otmsUnderscoreSize;
    PSTR    otmpFamilyName;
    PSTR    otmpFaceName;
    PSTR    otmpStyleName;
    PSTR    otmpFullName;
} OUTLINETEXTMETRIC, FAR* LPOUTLINETEXTMETRIC;

WORD    WINAPI GetOutlineTextMetrics(HDC, UINT, OUTLINETEXTMETRIC FAR*);

#endif  /* WINVER >= 0x030a */
#endif  /* NOSCALABLEFONT */

#ifndef NOGDIOBJ
#if (WINVER >= 0x030a)

/* Structure passed to FONTENUMPROC */
/* NOTE: NEWTEXTMETRIC is the same as TEXTMETRIC plus 4 new fields */
typedef struct tagNEWTEXTMETRIC
{
    int     tmHeight;
    int     tmAscent;
    int     tmDescent;
    int     tmInternalLeading;
    int     tmExternalLeading;
    int     tmAveCharWidth;
    int     tmMaxCharWidth;
    int     tmWeight;
    BYTE    tmItalic;
    BYTE    tmUnderlined;
    BYTE    tmStruckOut;
    BYTE    tmFirstChar;
    BYTE    tmLastChar;
    BYTE    tmDefaultChar;
    BYTE    tmBreakChar;
    BYTE    tmPitchAndFamily;
    BYTE    tmCharSet;
    int     tmOverhang;
    int     tmDigitizedAspectX;
    int     tmDigitizedAspectY;
    DWORD   ntmFlags;
    UINT    ntmSizeEM;
    UINT    ntmCellHeight;
    UINT    ntmAvgWidth;
} NEWTEXTMETRIC;
typedef NEWTEXTMETRIC*       PNEWTEXTMETRIC;
typedef NEWTEXTMETRIC NEAR* NPNEWTEXTMETRIC;
typedef NEWTEXTMETRIC FAR*  LPNEWTEXTMETRIC;

/* ntmFlags field flags */
#define NTM_REGULAR	0x00000040L
#define NTM_BOLD	0x00000020L
#define NTM_ITALIC	0x00000001L

#define LF_FULLFACESIZE     64

/* Structure passed to FONTENUMPROC */
typedef struct tagENUMLOGFONT
{
    LOGFONT elfLogFont;
    char    elfFullName[LF_FULLFACESIZE];
    char    elfStyle[LF_FACESIZE];
} ENUMLOGFONT, FAR* LPENUMLOGFONT;

#endif  /* WINVER >= 0x030a */
#endif  /* NOGDIOBJ */

#ifdef STRICT
#ifndef NOGDIOBJ

typedef int (CALLBACK* OLDFONTENUMPROC)(const LOGFONT FAR*, const TEXTMETRIC FAR*, int, LPARAM);

#if (WINVER >= 0x030a)
typedef int (CALLBACK* FONTENUMPROC)(const ENUMLOGFONT FAR*, const NEWTEXTMETRIC FAR*, int, LPARAM);

int     WINAPI EnumFontFamilies(HDC, LPCSTR, FONTENUMPROC, LPARAM);

#else   /* WINVER >= 0x030a */
typedef OLDFONTENUMPROC FONTENUMPROC;
#endif  /* WINVER >= 0x030a) */

int     WINAPI EnumFonts(HDC, LPCSTR, OLDFONTENUMPROC, LPARAM);
#endif  /* NOGDIOBJ */

#else   /* STRICT */

typedef FARPROC OLDFONTENUMPROC;
typedef FARPROC FONTENUMPROC;

int     WINAPI EnumFonts(HDC, LPCSTR, OLDFONTENUMPROC, LPSTR);

#if (WINVER >= 0x030a)
int     WINAPI EnumFontFamilies(HDC, LPCSTR, FONTENUMPROC, LPSTR);
#endif  /* WINVER >= 0x030a */

#endif  /* !STRICT */

/* EnumFonts font type values */
#define RASTER_FONTTYPE     0x0001
#define DEVICE_FONTTYPE     0X0002
#if (WINVER >= 0x030a)
#define TRUETYPE_FONTTYPE   0x0004
#endif  /* WINVER >= 0x030a */

#endif  /* NOTEXTMETRIC */

#ifndef NOSCALABLEFONT
#if (WINVER >= 0x030a)

DWORD   WINAPI GetFontData(HDC, DWORD, DWORD, void FAR*, DWORD);
BOOL	WINAPI CreateScalableFontResource(UINT, LPCSTR, LPCSTR, LPCSTR);

typedef struct tagGLYPHMETRICS
{
    UINT    gmBlackBoxX;
    UINT    gmBlackBoxY;
    POINT   gmptGlyphOrigin;
    int     gmCellIncX;
    int     gmCellIncY;
} GLYPHMETRICS, FAR* LPGLYPHMETRICS;

typedef struct tagFIXED
{
    UINT    fract;
    int     value;
} FIXED, FAR* LPFIXED;

typedef struct tagMAT2
{
    FIXED  eM11;
    FIXED  eM12;
    FIXED  eM21;
    FIXED  eM22;
} MAT2, FAR* LPMAT2;

DWORD   WINAPI GetGlyphOutline(HDC, UINT, UINT, GLYPHMETRICS FAR*, DWORD, void FAR*, const MAT2 FAR*);

/* GetGlyphOutline constants */
#define GGO_METRICS        0
#define GGO_BITMAP         1
#define GGO_NATIVE         2

#define TT_POLYGON_TYPE   24

#define TT_PRIM_LINE       1
#define TT_PRIM_QSPLINE    2

typedef struct tagPOINTFX
{
    FIXED x;
    FIXED y;
} POINTFX, FAR* LPPOINTFX;

typedef struct tagTTPOLYCURVE
{
    UINT    wType;
    UINT    cpfx;
    POINTFX apfx[1];
} TTPOLYCURVE, FAR* LPTTPOLYCURVE;

typedef struct tagTTPOLYGONHEADER
{
    DWORD   cb;
    DWORD   dwType;
    POINTFX pfxStart;
} TTPOLYGONHEADER, FAR* LPTTPOLYGONHEADER;

typedef struct tagABC
{
    int   abcA;
    UINT  abcB;
    int   abcC;
} ABC;
typedef ABC FAR* LPABC;

BOOL    WINAPI GetCharABCWidths(HDC, UINT, UINT, ABC FAR*);

typedef struct tagKERNINGPAIR
{
    WORD wFirst;
    WORD wSecond;
    int  iKernAmount;
} KERNINGPAIR, FAR* LPKERNINGPAIR;

int     WINAPI GetKerningPairs(HDC, int, KERNINGPAIR FAR*);

typedef struct tagRASTERIZER_STATUS
{
    int   nSize;
    int   wFlags;
    int   nLanguageID;
} RASTERIZER_STATUS;
typedef RASTERIZER_STATUS FAR* LPRASTERIZER_STATUS;

/* bits defined in wFlags of RASTERIZER_STATUS */
#define TT_AVAILABLE	0x0001
#define TT_ENABLED	0x0002

BOOL    WINAPI GetRasterizerCaps(RASTERIZER_STATUS FAR*, int);

#endif  /* WINVER >= 0x030a */
#endif  /* NOSCALABLEFONT */

/****** Bitmap support ******************************************************/

#ifndef NOBITMAP
typedef struct tagBITMAP
{
    int     bmType;
    int     bmWidth;
    int     bmHeight;
    int     bmWidthBytes;
    BYTE    bmPlanes;
    BYTE    bmBitsPixel;
    void FAR* bmBits;
} BITMAP;
typedef BITMAP*       PBITMAP;
typedef BITMAP NEAR* NPBITMAP;
typedef BITMAP FAR*  LPBITMAP;

/* Bitmap Header structures */
typedef struct tagRGBTRIPLE
{
    BYTE    rgbtBlue;
    BYTE    rgbtGreen;
    BYTE    rgbtRed;
} RGBTRIPLE;
typedef RGBTRIPLE FAR* LPRGBTRIPLE;

typedef struct tagRGBQUAD
{
    BYTE    rgbBlue;
    BYTE    rgbGreen;
    BYTE    rgbRed;
    BYTE    rgbReserved;
} RGBQUAD;
typedef RGBQUAD FAR* LPRGBQUAD;

/* structures for defining DIBs */
typedef struct tagBITMAPCOREHEADER
{
    DWORD   bcSize;
    short   bcWidth;
    short   bcHeight;
    WORD    bcPlanes;
    WORD    bcBitCount;
} BITMAPCOREHEADER;
typedef BITMAPCOREHEADER*      PBITMAPCOREHEADER;
typedef BITMAPCOREHEADER FAR* LPBITMAPCOREHEADER;

typedef struct tagBITMAPINFOHEADER
{
    DWORD   biSize;
    LONG    biWidth;
    LONG    biHeight;
    WORD    biPlanes;
    WORD    biBitCount;
    DWORD   biCompression;
    DWORD   biSizeImage;
    LONG    biXPelsPerMeter;
    LONG    biYPelsPerMeter;
    DWORD   biClrUsed;
    DWORD   biClrImportant;
} BITMAPINFOHEADER;
typedef BITMAPINFOHEADER*      PBITMAPINFOHEADER;
typedef BITMAPINFOHEADER FAR* LPBITMAPINFOHEADER;

/* constants for the biCompression field */
#define BI_RGB      0L
#define BI_RLE8     1L
#define BI_RLE4     2L

typedef struct tagBITMAPINFO
{
    BITMAPINFOHEADER bmiHeader;
    RGBQUAD	     bmiColors[1];
} BITMAPINFO;
typedef BITMAPINFO*     PBITMAPINFO;
typedef BITMAPINFO FAR* LPBITMAPINFO;

typedef struct tagBITMAPCOREINFO
{
    BITMAPCOREHEADER bmciHeader;
    RGBTRIPLE	     bmciColors[1];
} BITMAPCOREINFO;
typedef BITMAPCOREINFO*      PBITMAPCOREINFO;
typedef BITMAPCOREINFO FAR* LPBITMAPCOREINFO;

typedef struct tagBITMAPFILEHEADER
{
    UINT    bfType;
    DWORD   bfSize;
    UINT    bfReserved1;
    UINT    bfReserved2;
    DWORD   bfOffBits;
} BITMAPFILEHEADER;
typedef BITMAPFILEHEADER*      PBITMAPFILEHEADER;
typedef BITMAPFILEHEADER FAR* LPBITMAPFILEHEADER;


HBITMAP WINAPI CreateBitmap(int, int, UINT, UINT, const void FAR*);
HBITMAP WINAPI CreateBitmapIndirect(BITMAP FAR* );
HBITMAP WINAPI CreateCompatibleBitmap(HDC, int, int);
HBITMAP WINAPI CreateDiscardableBitmap(HDC, int, int);
HBITMAP WINAPI CreateDIBitmap(HDC, BITMAPINFOHEADER FAR*, DWORD, const void FAR*, BITMAPINFO FAR*, UINT);

HBITMAP WINAPI LoadBitmap(HINSTANCE, LPCSTR);

/* DIB color table identifiers */
#define DIB_RGB_COLORS  0
#define DIB_PAL_COLORS  1

/* constants for CreateDIBitmap */
#define CBM_INIT        0x00000004L
#endif	/* NOBITMAP */

#ifndef NORASTEROPS

/* Binary raster ops */
#define R2_BLACK            1
#define R2_NOTMERGEPEN      2
#define R2_MASKNOTPEN       3
#define R2_NOTCOPYPEN       4
#define R2_MASKPENNOT       5
#define R2_NOT              6
#define R2_XORPEN           7
#define R2_NOTMASKPEN       8
#define R2_MASKPEN          9
#define R2_NOTXORPEN        10
#define R2_NOP              11
#define R2_MERGENOTPEN      12
#define R2_COPYPEN          13
#define R2_MERGEPENNOT      14
#define R2_MERGEPEN         15
#define R2_WHITE            16

/* Ternary raster operations */
#define SRCCOPY             0x00CC0020L
#define SRCPAINT            0x00EE0086L
#define SRCAND              0x008800C6L
#define SRCINVERT           0x00660046L
#define SRCERASE            0x00440328L
#define NOTSRCCOPY          0x00330008L
#define NOTSRCERASE         0x001100A6L
#define MERGECOPY           0x00C000CAL
#define MERGEPAINT          0x00BB0226L
#define PATCOPY             0x00F00021L
#define PATPAINT            0x00FB0A09L
#define PATINVERT           0x005A0049L
#define DSTINVERT           0x00550009L
#define BLACKNESS           0x00000042L
#define WHITENESS           0x00FF0062L

#endif  /* NORASTEROPS */

#ifndef NOBITMAP
BOOL    WINAPI BitBlt(HDC, int, int, int, int, HDC, int, int, DWORD);

BOOL    WINAPI PatBlt(HDC, int, int, int, int, DWORD);

BOOL    WINAPI StretchBlt(HDC, int, int, int, int, HDC, int, int, int, int, DWORD);
int     WINAPI StretchDIBits(HDC, int, int, int, int, int,
                        int, int, int, const void FAR*, LPBITMAPINFO, UINT, DWORD);

COLORREF WINAPI SetPixel(HDC, int, int, COLORREF);
COLORREF WINAPI GetPixel(HDC, int, int);

/* StretchBlt() Modes */
#define BLACKONWHITE	1
#define WHITEONBLACK	2
#define COLORONCOLOR	3

/* new StretchBlt() Modes (simpler names) */
#define STRETCH_ANDSCANS        1
#define STRETCH_ORSCANS         2
#define STRETCH_DELETESCANS     3

int     WINAPI SetStretchBltMode(HDC, int);
int     WINAPI GetStretchBltMode(HDC);

DWORD   WINAPI SetBitmapDimension(HBITMAP, int, int);
DWORD   WINAPI GetBitmapDimension(HBITMAP);
#if (WINVER >= 0x030a)
BOOL    WINAPI SetBitmapDimensionEx(HBITMAP, int, int, SIZE FAR*);
BOOL    WINAPI GetBitmapDimensionEx(HBITMAP, SIZE FAR*);
#endif  /* WINVER >= 0x030a */
int     WINAPI SetROP2(HDC, int);
int     WINAPI GetROP2(HDC);

LONG    WINAPI SetBitmapBits(HBITMAP, DWORD, const void FAR*);
LONG    WINAPI GetBitmapBits(HBITMAP, LONG, void FAR*);

int     WINAPI SetDIBits(HDC, HBITMAP, UINT, UINT, const void FAR*, BITMAPINFO FAR*, UINT);
int     WINAPI GetDIBits(HDC, HBITMAP, UINT, UINT, void FAR*, BITMAPINFO FAR*, UINT);

int     WINAPI SetDIBitsToDevice(HDC, int, int, int, int, int, int, UINT, UINT,
                    void FAR*, BITMAPINFO FAR*, UINT);
#endif	/* NOBITMAP */

/****** Metafile support ****************************************************/

#ifndef NOMETAFILE

DECLARE_HANDLE(HMETAFILE);

HDC     WINAPI CreateMetaFile(LPCSTR);
HMETAFILE WINAPI CloseMetaFile(HDC);

HMETAFILE WINAPI GetMetaFile(LPCSTR);
BOOL      WINAPI DeleteMetaFile(HMETAFILE);
HMETAFILE WINAPI CopyMetaFile(HMETAFILE, LPCSTR);

BOOL    WINAPI PlayMetaFile(HDC, HMETAFILE);

HGLOBAL WINAPI GetMetaFileBits(HMETAFILE);
HMETAFILE WINAPI SetMetaFileBits(HGLOBAL);
#if (WINVER >= 0x030a)
HMETAFILE WINAPI SetMetaFileBitsBetter(HGLOBAL);
#endif  /* WINVER >= 0x030a */

/* Clipboard Metafile Picture Structure */
typedef struct tagMETAFILEPICT
{
    int     mm;
    int     xExt;
    int     yExt;
    HMETAFILE hMF;
} METAFILEPICT;
typedef METAFILEPICT FAR* LPMETAFILEPICT;

typedef struct tagMETAHEADER
{
    UINT    mtType;
    UINT    mtHeaderSize;
    UINT    mtVersion;
    DWORD   mtSize;
    UINT    mtNoObjects;
    DWORD   mtMaxRecord;
    UINT    mtNoParameters;
} METAHEADER;

typedef struct tagHANDLETABLE
{
    HGDIOBJ objectHandle[1];
} HANDLETABLE;
typedef HANDLETABLE*      PHANDLETABLE;
typedef HANDLETABLE FAR* LPHANDLETABLE;

typedef struct tagMETARECORD
{
    DWORD   rdSize;
    UINT    rdFunction;
    UINT    rdParm[1];
} METARECORD;
typedef METARECORD*      PMETARECORD;
typedef METARECORD FAR* LPMETARECORD;

/* Metafile Functions */
#define META_SETBKCOLOR		     0x0201
#define META_SETBKMODE		     0x0102
#define META_SETMAPMODE		     0x0103
#define META_SETROP2		     0x0104
#define META_SETRELABS		     0x0105
#define META_SETPOLYFILLMODE	     0x0106
#define META_SETSTRETCHBLTMODE	     0x0107
#define META_SETTEXTCHAREXTRA	     0x0108
#define META_SETTEXTCOLOR	     0x0209
#define META_SETTEXTJUSTIFICATION    0x020A
#define META_SETWINDOWORG	     0x020B
#define META_SETWINDOWEXT	     0x020C
#define META_SETVIEWPORTORG	     0x020D
#define META_SETVIEWPORTEXT	     0x020E
#define META_OFFSETWINDOWORG	     0x020F
#define META_SCALEWINDOWEXT	     0x0410
#define META_OFFSETVIEWPORTORG	     0x0211
#define META_SCALEVIEWPORTEXT	     0x0412
#define META_LINETO		     0x0213
#define META_MOVETO		     0x0214
#define META_EXCLUDECLIPRECT	     0x0415
#define META_INTERSECTCLIPRECT	     0x0416
#define META_ARC		     0x0817
#define META_ELLIPSE		     0x0418
#define META_FLOODFILL		     0x0419
#define META_PIE		     0x081A
#define META_RECTANGLE		     0x041B
#define META_ROUNDRECT		     0x061C
#define META_PATBLT		     0x061D
#define META_SAVEDC		     0x001E
#define META_SETPIXEL		     0x041F
#define META_OFFSETCLIPRGN	     0x0220
#define META_TEXTOUT		     0x0521
#define META_BITBLT		     0x0922
#define META_STRETCHBLT		     0x0B23
#define META_POLYGON		     0x0324
#define META_POLYLINE		     0x0325
#define META_ESCAPE		     0x0626
#define META_RESTOREDC		     0x0127
#define META_FILLREGION		     0x0228
#define META_FRAMEREGION	     0x0429
#define META_INVERTREGION	     0x012A
#define META_PAINTREGION	     0x012B
#define META_SELECTCLIPREGION	     0x012C
#define META_SELECTOBJECT	     0x012D
#define META_SETTEXTALIGN	     0x012E
#define META_DRAWTEXT		     0x062F

#define	META_CHORD		     0x0830
#define	META_SETMAPPERFLAGS	     0x0231
#define	META_EXTTEXTOUT		     0x0a32
#define	META_SETDIBTODEV	     0x0d33
#define	META_SELECTPALETTE	     0x0234
#define	META_REALIZEPALETTE	     0x0035
#define	META_ANIMATEPALETTE	     0x0436
#define	META_SETPALENTRIES	     0x0037
#define	META_POLYPOLYGON	     0x0538
#define	META_RESIZEPALETTE	     0x0139

#define	META_DIBBITBLT		     0x0940
#define	META_DIBSTRETCHBLT	     0x0b41
#define	META_DIBCREATEPATTERNBRUSH   0x0142
#define	META_STRETCHDIB		     0x0f43

#define META_EXTFLOODFILL	     0x0548

#define META_RESETDC		     0x014C
#define META_STARTDOC		     0x014D
#define META_STARTPAGE		     0x004F
#define META_ENDPAGE		     0x0050
#define META_ABORTDOC		     0x0052
#define META_ENDDOC		     0x005E

#define	META_DELETEOBJECT	     0x01f0

#define	META_CREATEPALETTE	     0x00f7
#define META_CREATEBRUSH	     0x00F8
#define META_CREATEPATTERNBRUSH	     0x01F9
#define META_CREATEPENINDIRECT	     0x02FA
#define META_CREATEFONTINDIRECT	     0x02FB
#define META_CREATEBRUSHINDIRECT     0x02FC
#define META_CREATEBITMAPINDIRECT    0x02FD
#define META_CREATEBITMAP	     0x06FE
#define META_CREATEREGION	     0x06FF

void    WINAPI PlayMetaFileRecord(HDC, HANDLETABLE FAR*, METARECORD FAR*, UINT);

#ifdef STRICT
typedef int (CALLBACK* MFENUMPROC)(HDC, HANDLETABLE FAR*, METARECORD FAR*, int, LPARAM);
#else
typedef FARPROC MFENUMPROC;
#endif

BOOL    WINAPI EnumMetaFile(HDC, HMETAFILE, MFENUMPROC, LPARAM);

#endif  /* NOMETAFILE */

/****** Printing support ****************************************************/

#ifdef STRICT
typedef BOOL (CALLBACK* ABORTPROC)(HDC, int);
#else
typedef FARPROC ABORTPROC;
#endif

#if (WINVER >= 0x030a)

typedef struct
{
    int     cbSize;
    LPCSTR  lpszDocName;
    LPCSTR  lpszOutput;
}   DOCINFO;
typedef DOCINFO FAR* LPDOCINFO;

int     WINAPI StartDoc(HDC, DOCINFO FAR*);
int     WINAPI StartPage(HDC);
int     WINAPI EndPage(HDC);
int     WINAPI EndDoc(HDC);
int     WINAPI AbortDoc(HDC);

int     WINAPI SetAbortProc(HDC, ABORTPROC);
HANDLE  WINAPI SpoolFile(LPSTR, LPSTR, LPSTR, LPSTR);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI QueryAbort(HDC, int);

/* Spooler Error Codes */
#define SP_NOTREPORTED		     0x4000
#define SP_ERROR		     (-1)
#define SP_APPABORT		     (-2)
#define SP_USERABORT		     (-3)
#define SP_OUTOFDISK		     (-4)
#define SP_OUTOFMEMORY		     (-5)

#define PR_JOBSTATUS		     0x0000

#endif  /* NOGDI  */

/* Spooler status notification message */
#define WM_SPOOLERSTATUS	    0x002A

#ifndef NOGDI

/******* GDI Escape support *************************************************/

int     WINAPI Escape(HDC, int, int, LPCSTR, void FAR*);

/* GDI Escapes */
#define NEWFRAME		     1
#define ABORTDOC		     2
#define NEXTBAND		     3
#define SETCOLORTABLE		     4
#define GETCOLORTABLE		     5
#define FLUSHOUTPUT		     6
#define DRAFTMODE		     7
#define QUERYESCSUPPORT 	     8
#define SETABORTPROC		     9
#define STARTDOC		     10
#define ENDDOC			     11
#define GETPHYSPAGESIZE 	     12
#define GETPRINTINGOFFSET	     13
#define GETSCALINGFACTOR	     14
#define MFCOMMENT		     15
#define GETPENWIDTH		     16
#define SETCOPYCOUNT		     17
#define SELECTPAPERSOURCE	     18
#define DEVICEDATA		     19
#define PASSTHROUGH		     19
#define GETTECHNOLGY		     20
#define GETTECHNOLOGY		     20
#define SETLINECAP		     21
#define SETLINEJOIN		     22
#define SETMITERLIMIT		     23
#define BANDINFO		     24
#define DRAWPATTERNRECT 	     25
#define GETVECTORPENSIZE	     26
#define GETVECTORBRUSHSIZE	     27
#define ENABLEDUPLEX		     28
#define GETSETPAPERBINS 	     29
#define GETSETPRINTORIENT	     30
#define ENUMPAPERBINS		     31
#define SETDIBSCALING		     32
#define EPSPRINTING        	     33
#define ENUMPAPERMETRICS   	     34
#define GETSETPAPERMETRICS 	     35
#define POSTSCRIPT_DATA		     37
#define POSTSCRIPT_IGNORE	     38
#define MOUSETRAILS		     39

#define GETEXTENDEDTEXTMETRICS	     256
#define GETEXTENTTABLE		     257
#define GETPAIRKERNTABLE	     258
#define GETTRACKKERNTABLE	     259
#define EXTTEXTOUT		     512
#define GETFACENAME		     513
#define ENABLERELATIVEWIDTHS	     768
#define ENABLEPAIRKERNING	     769
#define SETKERNTRACK		     770
#define SETALLJUSTVALUES	     771
#define SETCHARSET		     772

#define STRETCHBLT		     2048

#define GETSETSCREENPARAMS           3072

#define BEGIN_PATH		     4096
#define CLIP_TO_PATH		     4097
#define END_PATH		     4098
#define EXT_DEVICE_CAPS		     4099
#define RESTORE_CTM		     4100
#define SAVE_CTM	             4101
#define SET_ARC_DIRECTION	     4102
#define SET_BACKGROUND_COLOR	     4103
#define SET_POLY_MODE		     4104
#define SET_SCREEN_ANGLE	     4105
#define SET_SPREAD		     4106
#define TRANSFORM_CTM		     4107
#define SET_CLIP_BOX		     4108
#define SET_BOUNDS                   4109

#endif  /* NOGDI */

/****** USER typedefs, structures, and functions *****************************/

DECLARE_HANDLE(HWND);

#ifndef NOUSER

DECLARE_HANDLE(HMENU);

DECLARE_HANDLE(HICON);
typedef HICON HCURSOR;	    /* HICONs & HCURSORs are polymorphic */

/****** System Metrics *******************************************************/

#ifndef NOSYSMETRICS

int WINAPI GetSystemMetrics(int);

/* GetSystemMetrics() codes */
#define SM_CXSCREEN	     0
#define SM_CYSCREEN	     1
#define SM_CXVSCROLL	     2
#define SM_CYHSCROLL	     3
#define SM_CYCAPTION	     4
#define SM_CXBORDER	     5
#define SM_CYBORDER	     6
#define SM_CXDLGFRAME	     7
#define SM_CYDLGFRAME	     8
#define SM_CYVTHUMB	     9
#define SM_CXHTHUMB	     10
#define SM_CXICON	     11
#define SM_CYICON	     12
#define SM_CXCURSOR	     13
#define SM_CYCURSOR	     14
#define SM_CYMENU	     15
#define SM_CXFULLSCREEN      16
#define SM_CYFULLSCREEN      17
#define SM_CYKANJIWINDOW     18
#define SM_MOUSEPRESENT      19
#define SM_CYVSCROLL	     20
#define SM_CXHSCROLL	     21
#define SM_DEBUG	     22
#define SM_SWAPBUTTON	     23
#define SM_RESERVED1	     24
#define SM_RESERVED2	     25
#define SM_RESERVED3	     26
#define SM_RESERVED4	     27
#define SM_CXMIN	     28
#define SM_CYMIN	     29
#define SM_CXSIZE	     30
#define SM_CYSIZE	     31
#define SM_CXFRAME	     32
#define SM_CYFRAME	     33
#define SM_CXMINTRACK	     34
#define SM_CYMINTRACK	     35

#if (WINVER >= 0x030a)
#define SM_CXDOUBLECLK       36
#define SM_CYDOUBLECLK       37
#define SM_CXICONSPACING     38
#define SM_CYICONSPACING     39
#define SM_MENUDROPALIGNMENT 40
#define SM_PENWINDOWS        41
#define SM_DBCSENABLED       42
#endif  /* WINVER >= 0x030a */

#define SM_CMETRICS	     43

#endif  /* NOSYSMETRICS */

UINT    WINAPI GetDoubleClickTime(void);
void    WINAPI SetDoubleClickTime(UINT);

#define WM_DEVMODECHANGE    0x001B
#define WM_TIMECHANGE	    0x001E

/****** System Parameters support ********************************************/

#if (WINVER >= 0x030a)
#ifndef NOSYSTEMPARAMSINFO

BOOL    WINAPI SystemParametersInfo(UINT, UINT, VOID FAR*, UINT);

#define SPI_GETBEEP		    1
#define SPI_SETBEEP		    2
#define SPI_GETMOUSE		    3
#define SPI_SETMOUSE		    4
#define SPI_GETBORDER		    5
#define SPI_SETBORDER		    6
#define SPI_GETKEYBOARDSPEED	    10
#define SPI_SETKEYBOARDSPEED	    11
#define SPI_LANGDRIVER		    12
#define SPI_ICONHORIZONTALSPACING   13
#define SPI_GETSCREENSAVETIMEOUT    14
#define SPI_SETSCREENSAVETIMEOUT    15
#define SPI_GETSCREENSAVEACTIVE     16
#define SPI_SETSCREENSAVEACTIVE     17
#define SPI_GETGRIDGRANULARITY	    18
#define SPI_SETGRIDGRANULARITY	    19
#define SPI_SETDESKWALLPAPER	    20
#define SPI_SETDESKPATTERN	    21
#define SPI_GETKEYBOARDDELAY	    22
#define SPI_SETKEYBOARDDELAY	    23
#define SPI_ICONVERTICALSPACING     24
#define SPI_GETICONTITLEWRAP	    25
#define SPI_SETICONTITLEWRAP	    26
#define SPI_GETMENUDROPALIGNMENT    27
#define SPI_SETMENUDROPALIGNMENT    28
#define SPI_SETDOUBLECLKWIDTH	    29
#define SPI_SETDOUBLECLKHEIGHT	    30
#define SPI_GETICONTITLELOGFONT     31
#define SPI_SETDOUBLECLICKTIME	    32
#define SPI_SETMOUSEBUTTONSWAP	    33
#define SPI_SETICONTITLELOGFONT     34
#define SPI_GETFASTTASKSWITCH       35
#define SPI_SETFASTTASKSWITCH       36

/* SystemParametersInfo flags */
#define SPIF_UPDATEINIFILE	    0x0001
#define SPIF_SENDWININICHANGE	    0x0002

#endif  /* NOSYSTEMPARAMSINFO  */
#endif  /* WINVER >= 0x030a */

/****** Rectangle support ****************************************************/

void    WINAPI SetRect(RECT FAR*, int, int, int, int);
void    WINAPI SetRectEmpty(RECT FAR*);

void    WINAPI CopyRect(RECT FAR*, const RECT FAR*);

BOOL    WINAPI IsRectEmpty(const RECT FAR*);

BOOL    WINAPI EqualRect(const RECT FAR*, const RECT FAR*);

BOOL    WINAPI IntersectRect(RECT FAR*, const RECT FAR*, const RECT FAR*);
BOOL    WINAPI UnionRect(RECT FAR*, const RECT FAR*, const RECT FAR*);
BOOL    WINAPI SubtractRect(RECT FAR*, const RECT FAR*, const RECT FAR*);

void    WINAPI OffsetRect(RECT FAR*, int, int);
void    WINAPI InflateRect(RECT FAR*, int, int);

BOOL    WINAPI PtInRect(const RECT FAR*, POINT);

/****** Window message support ***********************************************/

UINT WINAPI RegisterWindowMessage(LPCSTR);

#define WM_NULL		    0x0000

/* NOTE: All messages below 0x0400 are RESERVED by Windows */
#define WM_USER		    0x0400

#ifndef NOMSG

/* Queued message structure */
typedef struct tagMSG
{
    HWND	hwnd;
    UINT        message;
    WPARAM	wParam;
    LPARAM	lParam;
    DWORD       time;
    POINT	pt;
} MSG;
typedef MSG* PMSG;
typedef MSG NEAR* NPMSG;
typedef MSG FAR* LPMSG;

BOOL    WINAPI GetMessage(MSG FAR*, HWND, UINT, UINT);
BOOL    WINAPI PeekMessage(MSG FAR*, HWND, UINT, UINT, UINT);

/* PeekMessage() options */
#define PM_NOREMOVE	0x0000
#define PM_REMOVE	0x0001
#define PM_NOYIELD	0x0002

void    WINAPI WaitMessage(void);

DWORD   WINAPI GetMessagePos(void);
LONG    WINAPI GetMessageTime(void);
#if (WINVER >= 0x030a)
LPARAM  WINAPI GetMessageExtraInfo(void);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI TranslateMessage(const MSG FAR*);
LONG    WINAPI DispatchMessage(const MSG FAR*);

BOOL    WINAPI SetMessageQueue(int);

BOOL    WINAPI GetInputState(void);

#if (WINVER >= 0x030a)
DWORD   WINAPI GetQueueStatus(UINT flags);

/* GetQueueStatus flags */
#define QS_KEY		0x0001
#define QS_MOUSEMOVE	0x0002
#define QS_MOUSEBUTTON	0x0004
#define QS_MOUSE	(QS_MOUSEMOVE | QS_MOUSEBUTTON)
#define QS_POSTMESSAGE	0x0008
#define QS_TIMER	0x0010
#define QS_PAINT	0x0020
#define QS_SENDMESSAGE	0x0040

#define QS_ALLINPUT     0x007f
#endif  /* WINVER >= 0x030a */

#endif  /* NOMSG */

BOOL    WINAPI PostMessage(HWND, UINT, WPARAM, LPARAM);
LRESULT WINAPI SendMessage(HWND, UINT, WPARAM, LPARAM);

#ifndef NOMSG

BOOL    WINAPI PostAppMessage(HTASK, UINT, WPARAM, LPARAM);

void    WINAPI ReplyMessage(LRESULT);
BOOL    WINAPI InSendMessage(void);

/* Special HWND value for use with PostMessage() and SendMessage() */
#define HWND_BROADCAST	((HWND)0xffff)

BOOL WINAPI CallMsgFilter(MSG FAR*, int);

#define WH_GETMESSAGE	    3

#define WH_CALLWNDPROC	    4

#define WH_MSGFILTER	    (-1)
#define WH_SYSMSGFILTER	    6

/* CallMsgFilter() and WH_SYS/MSGFILTER context codes */
#define MSGF_DIALOGBOX		 0
#define MSGF_MENU		 2
#define MSGF_MOVE		 3
#define MSGF_SIZE		 4
#define MSGF_SCROLLBAR		 5
#define MSGF_NEXTWINDOW 	 6
#define MSGF_MAINLOOP            8
#define MSGF_USER                4096
#endif  /* NOMSG */

/* Standard window messages */
/* PenWindows specific messages */
#define WM_PENWINFIRST	    0x0380
#define WM_PENWINLAST	    0x038F

/* Coalescing messages */
#define WM_COALESCE_FIRST   0x0390
#define WM_COALESCE_LAST    0x039F


#if (WINVER >= 0x030a)
/****** Power management ****************************************************/
#define WM_POWER	    0x0048

/* wParam for WM_POWER window message and DRV_POWER driver notification */
#define PWR_OK              1
#define PWR_FAIL            (-1)
#define PWR_SUSPENDREQUEST  1
#define PWR_SUSPENDRESUME   2
#define PWR_CRITICALRESUME  3
#endif  /* WINVER >= 0x030a */

/****** Application termination *********************************************/

#define WM_QUERYENDSESSION  0x0011
#define WM_ENDSESSION	    0x0016

#define WM_QUIT		    0x0012

void    WINAPI PostQuitMessage(int);

#define WM_SYSTEMERROR	    0x0017

/****** Window class management *********************************************/

typedef LRESULT (CALLBACK* WNDPROC)(HWND, UINT, WPARAM, LPARAM);

typedef struct tagWNDCLASS
{
    UINT        style;
    WNDPROC	lpfnWndProc;
    int         cbClsExtra;
    int         cbWndExtra;
    HINSTANCE	hInstance;
    HICON	hIcon;
    HCURSOR	hCursor;
    HBRUSH	hbrBackground;
    LPCSTR	lpszMenuName;
    LPCSTR	lpszClassName;
} WNDCLASS;
typedef WNDCLASS* PWNDCLASS;
typedef WNDCLASS NEAR* NPWNDCLASS;
typedef WNDCLASS FAR* LPWNDCLASS;

ATOM    WINAPI RegisterClass(const WNDCLASS FAR*);
BOOL    WINAPI UnregisterClass(LPCSTR, HINSTANCE);

BOOL    WINAPI GetClassInfo(HINSTANCE, LPCSTR, WNDCLASS FAR*);
int     WINAPI GetClassName(HWND, LPSTR, int);

#ifndef NOWINSTYLES

/* Class styles */
#define CS_VREDRAW	    0x0001
#define CS_HREDRAW	    0x0002

#define CS_OWNDC	    0x0020
#define CS_CLASSDC	    0x0040
#define CS_PARENTDC	    0x0080

#define CS_SAVEBITS	    0x0800

#define CS_DBLCLKS	    0x0008

#define CS_BYTEALIGNCLIENT  0x1000
#define CS_BYTEALIGNWINDOW  0x2000

#define CS_NOCLOSE	    0x0200

#define CS_KEYCVTWINDOW     0x0004
#define CS_NOKEYCVT	    0x0100

#define CS_GLOBALCLASS	    0x4000
#endif	/* NOWINSTYLES */

#ifndef NOWINOFFSETS

WORD    WINAPI GetClassWord(HWND, int);
WORD    WINAPI SetClassWord(HWND, int, WORD);
LONG    WINAPI GetClassLong(HWND, int);
LONG    WINAPI SetClassLong(HWND, int, LONG);

/* Class field offsets for GetClassLong() and GetClassWord() */
#define GCL_MENUNAME	    (-8)
#define GCW_HBRBACKGROUND   (-10)
#define GCW_HCURSOR	    (-12)
#define GCW_HICON	    (-14)
#define GCW_HMODULE	    (-16)
#define GCW_CBWNDEXTRA	    (-18)
#define GCW_CBCLSEXTRA	    (-20)
#define GCL_WNDPROC	    (-24)
#define GCW_STYLE	    (-26)

#if (WINVER >= 0x030a)
#define GCW_ATOM            (-32)
#endif  /* WINVER >= 0x030a */

#endif	/* NOWINOFFSETS */

/****** Window creation/destroy *********************************************/

/* Window Styles */
#ifndef NOWINSTYLES

/* Basic window types */
#define WS_OVERLAPPED	    0x00000000L
#define WS_POPUP	    0x80000000L
#define WS_CHILD	    0x40000000L

/* Clipping styles */
#define WS_CLIPSIBLINGS     0x04000000L
#define WS_CLIPCHILDREN     0x02000000L

/* Generic window states */
#define WS_VISIBLE	    0x10000000L
#define WS_DISABLED	    0x08000000L

/* Main window states */
#define WS_MINIMIZE	    0x20000000L
#define WS_MAXIMIZE	    0x01000000L

/* Main window styles */
#define WS_CAPTION	    0x00C00000L     /* WS_BORDER | WS_DLGFRAME	*/
#define WS_BORDER	    0x00800000L
#define WS_DLGFRAME	    0x00400000L
#define WS_VSCROLL	    0x00200000L
#define WS_HSCROLL	    0x00100000L
#define WS_SYSMENU	    0x00080000L
#define WS_THICKFRAME	    0x00040000L
#define WS_MINIMIZEBOX	    0x00020000L
#define WS_MAXIMIZEBOX	    0x00010000L

/* Control window styles */
#define WS_GROUP	    0x00020000L
#define WS_TABSTOP	    0x00010000L

/* Common Window Styles */
#define WS_OVERLAPPEDWINDOW (WS_OVERLAPPED | WS_CAPTION | WS_SYSMENU | WS_THICKFRAME | WS_MINIMIZEBOX | WS_MAXIMIZEBOX)
#define WS_POPUPWINDOW	    (WS_POPUP | WS_BORDER | WS_SYSMENU)
#define WS_CHILDWINDOW	    (WS_CHILD)

/* Extended Window Styles */
#define WS_EX_DLGMODALFRAME  0x00000001L
#define WS_EX_NOPARENTNOTIFY 0x00000004L

#if (WINVER >= 0x030a)
#define WS_EX_TOPMOST	     0x00000008L
#define WS_EX_ACCEPTFILES    0x00000010L
#define WS_EX_TRANSPARENT    0x00000020L
#endif  /* WINVER >= 0x030a */

/* Obsolete style names */
#define WS_TILED	    WS_OVERLAPPED
#define WS_ICONIC	    WS_MINIMIZE
#define WS_SIZEBOX	    WS_THICKFRAME
#define WS_TILEDWINDOW	    WS_OVERLAPPEDWINDOW


#endif  /* NOWINSTYLES */

/* Special value for CreateWindow, et al. */
#define HWND_DESKTOP        ((HWND)0)

BOOL    WINAPI IsWindow(HWND);

HWND    WINAPI CreateWindowEx(DWORD, LPCSTR, LPCSTR, DWORD, int, int, int, int, HWND, HMENU, HINSTANCE, void FAR*);
HWND    WINAPI CreateWindow(LPCSTR, LPCSTR, DWORD, int, int, int, int, HWND, HMENU, HINSTANCE, void FAR*);

#define WM_CREATE	    0x0001
#define WM_NCCREATE	    0x0081

/* WM_CREATE/WM_NCCREATE lParam struct */
typedef struct tagCREATESTRUCT
{
    void FAR* lpCreateParams;
    HINSTANCE hInstance;
    HMENU     hMenu;
    HWND      hwndParent;
    int       cy;
    int       cx;
    int       y;
    int       x;
    LONG      style;
    LPCSTR    lpszName;
    LPCSTR    lpszClass;
    DWORD     dwExStyle;
} CREATESTRUCT;
typedef CREATESTRUCT FAR* LPCREATESTRUCT;

BOOL    WINAPI DestroyWindow(HWND);

#define WM_DESTROY	    0x0002
#define WM_NCDESTROY	    0x0082

/* Basic window attributes */

HTASK   WINAPI GetWindowTask(HWND);

BOOL    WINAPI IsChild(HWND, HWND);

HWND    WINAPI GetParent(HWND);
HWND    WINAPI SetParent(HWND, HWND);

BOOL    WINAPI IsWindowVisible(HWND);

BOOL    WINAPI ShowWindow(HWND, int);


#ifndef NOSHOWWINDOW

#define SW_HIDE		    0
#define SW_SHOWNORMAL	    1
#define SW_NORMAL	    1
#define SW_SHOWMINIMIZED    2
#define SW_SHOWMAXIMIZED    3
#define SW_MAXIMIZE	    3
#define SW_SHOWNOACTIVATE   4
#define SW_SHOW		    5
#define SW_MINIMIZE	    6
#define SW_SHOWMINNOACTIVE  7
#define SW_SHOWNA	    8
#define SW_RESTORE          9

/* Obsolete ShowWindow() command names */
#define HIDE_WINDOW	    0
#define SHOW_OPENWINDOW     1
#define SHOW_ICONWINDOW     2
#define SHOW_FULLSCREEN     3
#define SHOW_OPENNOACTIVATE 4

#define WM_SHOWWINDOW	    0x0018

/* WM_SHOWWINDOW wParam codes */
#define SW_PARENTCLOSING    1
#define SW_OTHERMAXIMIZED   2
#define SW_PARENTOPENING    3
#define SW_OTHERRESTORED    4

/* Obsolete constant names */
#define SW_OTHERZOOM        SW_OTHERMAXIMIZED
#define SW_OTHERUNZOOM	    SW_OTHERRESTORED
#endif	/* NOSHOWWINDOW */

#define WM_SETREDRAW	    0x000B

/* Enabled state */
BOOL    WINAPI EnableWindow(HWND,BOOL);
BOOL    WINAPI IsWindowEnabled(HWND);

#define WM_ENABLE	    0x000A

/* Window text */
void    WINAPI SetWindowText(HWND, LPCSTR);
int     WINAPI GetWindowText(HWND, LPSTR, int);
int     WINAPI GetWindowTextLength(HWND);

#define WM_SETTEXT	    0x000C
#define WM_GETTEXT	    0x000D
#define WM_GETTEXTLENGTH    0x000E

/* Window words */
WORD    WINAPI GetWindowWord(HWND, int);
WORD    WINAPI SetWindowWord(HWND, int, WORD);
LONG    WINAPI GetWindowLong(HWND, int);
LONG    WINAPI SetWindowLong(HWND, int, LONG);

/* Window field offsets for GetWindowLong() and GetWindowWord() */
#ifndef NOWINOFFSETS
#define GWL_WNDPROC	    (-4)
#define GWW_HINSTANCE	    (-6)
#define GWW_HWNDPARENT	    (-8)
#define GWW_ID		    (-12)
#define GWL_STYLE	    (-16)
#define GWL_EXSTYLE	    (-20)
#endif  /* NOWINOFFSETS */

/****** Window size, position, Z-order, and visibility **********************/

#define CW_USEDEFAULT	    ((int)0x8000)

void    WINAPI GetClientRect(HWND, RECT FAR*);
void    WINAPI GetWindowRect(HWND, RECT FAR*);


#if (WINVER >= 0x030a)
typedef struct tagWINDOWPLACEMENT
{
    UINT  length;
    UINT  flags;
    UINT  showCmd;
    POINT ptMinPosition;
    POINT ptMaxPosition;
    RECT  rcNormalPosition;
} WINDOWPLACEMENT;
typedef WINDOWPLACEMENT     *PWINDOWPLACEMENT;
typedef WINDOWPLACEMENT FAR* LPWINDOWPLACEMENT;

#define WPF_SETMINPOSITION      0x0001
#define WPF_RESTORETOMAXIMIZED  0x0002

BOOL    WINAPI GetWindowPlacement(HWND, WINDOWPLACEMENT FAR*);
BOOL    WINAPI SetWindowPlacement(HWND, const WINDOWPLACEMENT FAR*);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI SetWindowPos(HWND, HWND, int, int, int, int, UINT);

/* SetWindowPos() and WINDOWPOS flags */
#define SWP_NOSIZE	    0x0001
#define SWP_NOMOVE	    0x0002
#define SWP_NOZORDER	    0x0004
#define SWP_NOREDRAW	    0x0008
#define SWP_NOACTIVATE	    0x0010
#define SWP_FRAMECHANGED    0x0020  /* The frame changed: send WM_NCCALCSIZE */
#define SWP_SHOWWINDOW	    0x0040
#define SWP_HIDEWINDOW	    0x0080
#define SWP_NOCOPYBITS	    0x0100
#define SWP_NOOWNERZORDER   0x0200  /* Don't do owner Z ordering */

#define SWP_DRAWFRAME	    SWP_FRAMECHANGED
#define SWP_NOREPOSITION    SWP_NOOWNERZORDER

#define SWP_NOSENDCHANGING  0x0400
#define SWP_DEFERERASE      0x2000

/* SetWindowPos() hwndInsertAfter field values */
#define HWND_TOP            ((HWND)0)
#define HWND_BOTTOM	    ((HWND)1)
#define HWND_TOPMOST        ((HWND)-1)
#define HWND_NOTOPMOST      ((HWND)-2)

#ifndef NODEFERWINDOWPOS

DECLARE_HANDLE(HDWP);

HDWP    WINAPI BeginDeferWindowPos(int);
HDWP    WINAPI DeferWindowPos(HDWP, HWND, HWND, int, int, int, int, UINT);
BOOL    WINAPI EndDeferWindowPos(HDWP);

#endif  /* NODEFERWINDOWPOS */

BOOL    WINAPI MoveWindow(HWND, int, int, int, int, BOOL);
BOOL    WINAPI BringWindowToTop(HWND);

#if (WINVER >= 0x030a)

#define WM_WINDOWPOSCHANGING 0x0046
#define WM_WINDOWPOSCHANGED 0x0047

/* WM_WINDOWPOSCHANGING/CHANGED struct pointed to by lParam */
typedef struct tagWINDOWPOS
{
    HWND    hwnd;
    HWND    hwndInsertAfter;
    int     x;
    int     y;
    int     cx;
    int     cy;
    UINT    flags;
} WINDOWPOS;
typedef WINDOWPOS FAR* LPWINDOWPOS;
#endif  /* WINVER >= 0x030a */

#define WM_MOVE		    0x0003
#define WM_SIZE		    0x0005

/* WM_SIZE message wParam values */
#define SIZE_RESTORED	    0
#define SIZE_MINIMIZED	    1
#define SIZE_MAXIMIZED	    2
#define SIZE_MAXSHOW	    3
#define SIZE_MAXHIDE	    4

/* Obsolete constant names */
#define SIZENORMAL	    SIZE_RESTORED
#define SIZEICONIC	    SIZE_MINIMIZED
#define SIZEFULLSCREEN	    SIZE_MAXIMIZED
#define SIZEZOOMSHOW	    SIZE_MAXSHOW
#define SIZEZOOMHIDE	    SIZE_MAXHIDE

/****** Window proc implementation & subclassing support *********************/

LRESULT WINAPI DefWindowProc(HWND, UINT, WPARAM, LPARAM);

#ifdef STRICT
LRESULT WINAPI CallWindowProc(WNDPROC, HWND, UINT, WPARAM, LPARAM);
#else
LRESULT WINAPI CallWindowProc(FARPROC, HWND, UINT, WPARAM, LPARAM);
#endif

/****** Main window support **************************************************/

void    WINAPI AdjustWindowRect(RECT FAR*, DWORD, BOOL);
void    WINAPI AdjustWindowRectEx(RECT FAR*, DWORD, BOOL, DWORD);

#define WM_QUERYOPEN	    0x0013
#define WM_CLOSE	    0x0010

/* Struct pointed to by WM_GETMINMAXINFO lParam */
typedef struct tagMINMAXINFO
{
    POINT ptReserved;
    POINT ptMaxSize;
    POINT ptMaxPosition;
    POINT ptMinTrackSize;
    POINT ptMaxTrackSize;
} MINMAXINFO;
#define WM_GETMINMAXINFO    0x0024


BOOL    WINAPI FlashWindow(HWND, BOOL);

void    WINAPI ShowOwnedPopups(HWND, BOOL);

/* Obsolete functions */
BOOL    WINAPI OpenIcon(HWND);
void    WINAPI CloseWindow(HWND);
BOOL    WINAPI AnyPopup(void);
BOOL    WINAPI IsIconic(HWND);
BOOL    WINAPI IsZoomed(HWND);

/****** Window coordinate mapping and hit-testing ***************************/

void    WINAPI ClientToScreen(HWND, POINT FAR*);
void    WINAPI ScreenToClient(HWND, POINT FAR*);

#if (WINVER >= 0x030a)
void    WINAPI MapWindowPoints(HWND hwndFrom, HWND hwndTo, POINT FAR* lppt, UINT cpt);
#endif  /* WINVER >= 0x030a */

HWND    WINAPI WindowFromPoint(POINT);
HWND    WINAPI ChildWindowFromPoint(HWND, POINT);

/****** Window query and enumeration ****************************************/

HWND    WINAPI GetDesktopWindow(void);

HWND    WINAPI FindWindow(LPCSTR, LPCSTR);

#ifdef STRICT
typedef BOOL (CALLBACK* WNDENUMPROC)(HWND, LPARAM);
#else
typedef FARPROC WNDENUMPROC;
#endif

BOOL    WINAPI EnumWindows(WNDENUMPROC, LPARAM);
BOOL    WINAPI EnumChildWindows(HWND, WNDENUMPROC, LPARAM);
BOOL    WINAPI EnumTaskWindows(HTASK, WNDENUMPROC, LPARAM);

HWND    WINAPI GetTopWindow(HWND);

HWND    WINAPI GetWindow(HWND, UINT);
HWND    WINAPI GetNextWindow(HWND, UINT);

/* GetWindow() constants */
#define GW_HWNDFIRST	0
#define GW_HWNDLAST	1
#define GW_HWNDNEXT	2
#define GW_HWNDPREV	3
#define GW_OWNER	4
#define GW_CHILD	5


/****** Window property support *********************************************/

BOOL    WINAPI SetProp(HWND, LPCSTR, HANDLE);
HANDLE  WINAPI GetProp(HWND, LPCSTR);
HANDLE  WINAPI RemoveProp(HWND, LPCSTR);

#ifdef STRICT
typedef BOOL (CALLBACK* PROPENUMPROC)(HWND, LPCSTR, HANDLE);
#else
typedef FARPROC PROPENUMPROC;
#endif

int     WINAPI EnumProps(HWND, PROPENUMPROC);

/****** Window drawing support **********************************************/

HDC     WINAPI GetDC(HWND);
int     WINAPI ReleaseDC(HWND, HDC);

HDC     WINAPI GetWindowDC(HWND);

#if (WINVER >= 0x030a)
HDC     WINAPI GetDCEx(register HWND hwnd, HRGN hrgnClip, DWORD flags);

#define DCX_WINDOW	    0x00000001L
#define DCX_CACHE	    0x00000002L
#define DCX_CLIPCHILDREN    0x00000008L
#define DCX_CLIPSIBLINGS    0x00000010L
#define DCX_PARENTCLIP	    0x00000020L

#define DCX_EXCLUDERGN	    0x00000040L
#define DCX_INTERSECTRGN    0x00000080L


#define DCX_LOCKWINDOWUPDATE 0x00000400L


#define DCX_USESTYLE	    0x00010000L

#endif  /* WINVER >= 0x030a */

/****** Window repainting ***************************************************/

#define WM_PAINT	    0x000F
#define WM_ERASEBKGND	    0x0014
#define WM_ICONERASEBKGND   0x0027

/* BeginPaint() return structure */
typedef struct tagPAINTSTRUCT
{
    HDC 	hdc;
    BOOL	fErase;
    RECT	rcPaint;
    BOOL	fRestore;
    BOOL	fIncUpdate;
    BYTE	rgbReserved[16];
} PAINTSTRUCT;
typedef PAINTSTRUCT* PPAINTSTRUCT;
typedef PAINTSTRUCT NEAR* NPPAINTSTRUCT;
typedef PAINTSTRUCT FAR* LPPAINTSTRUCT;

HDC     WINAPI BeginPaint(HWND, PAINTSTRUCT FAR*);
void    WINAPI EndPaint(HWND, const PAINTSTRUCT FAR*);

void    WINAPI UpdateWindow(HWND);

int     WINAPI ExcludeUpdateRgn(HDC, HWND);

#if (WINVER >= 0x030a)
BOOL    WINAPI LockWindowUpdate(HWND hwndLock);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI GetUpdateRect(HWND, RECT FAR*, BOOL);
int     WINAPI GetUpdateRgn(HWND, HRGN, BOOL);

void    WINAPI InvalidateRect(HWND, const RECT FAR*, BOOL);
void    WINAPI ValidateRect(HWND, const RECT FAR*);

void    WINAPI InvalidateRgn(HWND, HRGN, BOOL);
void    WINAPI ValidateRgn(HWND, HRGN);

#if (WINVER >= 0x030a)
BOOL    WINAPI RedrawWindow(HWND hwnd, const RECT FAR* lprcUpdate, HRGN hrgnUpdate, UINT flags);

#define RDW_INVALIDATE		0x0001
#define RDW_INTERNALPAINT	0x0002
#define RDW_ERASE		0x0004

#define RDW_VALIDATE		0x0008
#define RDW_NOINTERNALPAINT	0x0010
#define RDW_NOERASE		0x0020

#define RDW_NOCHILDREN		0x0040
#define RDW_ALLCHILDREN 	0x0080

#define RDW_UPDATENOW		0x0100
#define RDW_ERASENOW		0x0200

#define RDW_FRAME               0x0400
#define RDW_NOFRAME             0x0800

#endif  /* WINVER >= 0x030a */

/****** Window scrolling ****************************************************/

void    WINAPI ScrollWindow(HWND, int, int, const RECT FAR*, const RECT FAR*);
BOOL    WINAPI ScrollDC(HDC, int, int, const RECT FAR*, const RECT FAR*, HRGN, RECT FAR*);

#if (WINVER >= 0x030a)

int     WINAPI ScrollWindowEx(HWND hwnd, int dx, int dy,
                const RECT FAR* prcScroll, const RECT FAR* prcClip,
                HRGN hrgnUpdate, RECT FAR* prcUpdate, UINT flags);

#define SW_SCROLLCHILDREN   0x0001
#define SW_INVALIDATE       0x0002
#define SW_ERASE            0x0004


#endif  /* WINVER >= 0x030a */

/****** Non-client window area management ************************************/

#define WM_NCPAINT	    0x0085

#define WM_NCCALCSIZE	    0x0083

#if (WINVER >= 0x030a)
/* WM_NCCALCSIZE return flags */
#define WVR_ALIGNTOP	    0x0010
#define WVR_ALIGNLEFT	    0x0020
#define WVR_ALIGNBOTTOM     0x0040
#define WVR_ALIGNRIGHT	    0x0080
#define WVR_HREDRAW	    0x0100
#define WVR_VREDRAW	    0x0200
#define WVR_REDRAW	    (WVR_HREDRAW | WVR_VREDRAW)
#define WVR_VALIDRECTS	    0x0400


/* WM_NCCALCSIZE parameter structure */
typedef struct tagNCCALCSIZE_PARAMS
{
    RECT	   rgrc[3];
    WINDOWPOS FAR* lppos;
} NCCALCSIZE_PARAMS;
#else   /* WINVER >= 0x030a */
typedef struct tagNCCALCSIZE_PARAMS
{
    RECT    rgrc[2];
} NCCALCSIZE_PARAMS;
#endif  /* WINVER >= 0x030a */
typedef NCCALCSIZE_PARAMS FAR* LPNCCALCSIZE_PARAMS;

#define WM_NCHITTEST	    0x0084

/* WM_NCHITTEST return codes */
#define HTERROR 	    (-2)
#define HTTRANSPARENT	    (-1)
#define HTNOWHERE	    0
#define HTCLIENT	    1
#define HTCAPTION	    2
#define HTSYSMENU	    3
#define HTSIZE		    4
#define HTMENU		    5
#define HTHSCROLL	    6
#define HTVSCROLL	    7
#define HTMINBUTTON	    8
#define HTMAXBUTTON	    9
#define HTLEFT		    10
#define HTRIGHT 	    11
#define HTTOP		    12
#define HTTOPLEFT	    13
#define HTTOPRIGHT	    14
#define HTBOTTOM	    15
#define HTBOTTOMLEFT	    16
#define HTBOTTOMRIGHT	    17
#define HTBORDER	    18
#define HTGROWBOX	    HTSIZE
#define HTREDUCE	    HTMINBUTTON
#define HTZOOM		    HTMAXBUTTON

/****** Drag-and-drop support ***********************************************/

#define WM_QUERYDRAGICON    0x0037
#define WM_DROPFILES	    0x0233

/****** Window activation ***************************************************/

HWND    WINAPI SetActiveWindow(HWND);
HWND    WINAPI GetActiveWindow(void);

HWND    WINAPI GetLastActivePopup(HWND);

/* WM_ACTIVATE state values */
#define WA_INACTIVE	    0
#define WA_ACTIVE	    1
#define WA_CLICKACTIVE	    2

#define WM_ACTIVATE	    0x0006
#define WM_ACTIVATEAPP	    0x001C
#define WM_NCACTIVATE	    0x0086

/****** Keyboard input support **********************************************/

HWND    WINAPI SetFocus(HWND);
HWND    WINAPI GetFocus(void);

int     WINAPI GetKeyState(int);
int     WINAPI GetAsyncKeyState(int);

void    WINAPI GetKeyboardState(BYTE FAR* );
void    WINAPI SetKeyboardState(BYTE FAR* );

#define WM_SETFOCUS	    0x0007
#define WM_KILLFOCUS	    0x0008

#define WM_KEYDOWN	    0x0100
#define WM_KEYUP	    0x0101

#define WM_CHAR		    0x0102
#define WM_DEADCHAR	    0x0103

#define WM_SYSKEYDOWN	    0x0104
#define WM_SYSKEYUP	    0x0105

#define WM_SYSCHAR	    0x0106
#define WM_SYSDEADCHAR	    0x0107


/* Keyboard message range */
#define WM_KEYFIRST	    0x0100
#define WM_KEYLAST	    0x0108

/* WM_KEYUP/DOWN/CHAR HIWORD(lParam) flags */
#define KF_EXTENDED	    0x0100
#define KF_DLGMODE	    0x0800
#define KF_MENUMODE	    0x1000
#define KF_ALTDOWN	    0x2000
#define KF_REPEAT	    0x4000
#define KF_UP		    0x8000

/* Virtual key codes */
#ifndef NOVIRTUALKEYCODES
#define VK_LBUTTON	    0x01
#define VK_RBUTTON	    0x02
#define VK_CANCEL	    0x03
#define VK_MBUTTON          0x04
#define VK_BACK 	    0x08
#define VK_TAB		    0x09
#define VK_CLEAR	    0x0C
#define VK_RETURN	    0x0D
#define VK_SHIFT	    0x10
#define VK_CONTROL	    0x11
#define VK_MENU 	    0x12
#define VK_PAUSE	    0x13
#define VK_CAPITAL	    0x14
#define VK_ESCAPE	    0x1B
#define VK_SPACE	    0x20
#define VK_PRIOR	    0x21
#define VK_NEXT 	    0x22
#define VK_END		    0x23
#define VK_HOME 	    0x24
#define VK_LEFT 	    0x25
#define VK_UP		    0x26
#define VK_RIGHT	    0x27
#define VK_DOWN 	    0x28
#define VK_SELECT	    0x29
#define VK_PRINT	    0x2A
#define VK_EXECUTE	    0x2B
#define VK_SNAPSHOT	    0x2C
#define VK_INSERT	    0x2D
#define VK_DELETE	    0x2E
#define VK_HELP 	    0x2F
#define VK_NUMPAD0	    0x60
#define VK_NUMPAD1	    0x61
#define VK_NUMPAD2	    0x62
#define VK_NUMPAD3	    0x63
#define VK_NUMPAD4	    0x64
#define VK_NUMPAD5	    0x65
#define VK_NUMPAD6	    0x66
#define VK_NUMPAD7	    0x67
#define VK_NUMPAD8	    0x68
#define VK_NUMPAD9	    0x69
#define VK_MULTIPLY	    0x6A
#define VK_ADD		    0x6B
#define VK_SEPARATOR	    0x6C
#define VK_SUBTRACT	    0x6D
#define VK_DECIMAL	    0x6E
#define VK_DIVIDE	    0x6F
#define VK_F1		    0x70
#define VK_F2		    0x71
#define VK_F3		    0x72
#define VK_F4		    0x73
#define VK_F5		    0x74
#define VK_F6		    0x75
#define VK_F7		    0x76
#define VK_F8		    0x77
#define VK_F9		    0x78
#define VK_F10		    0x79
#define VK_F11		    0x7A
#define VK_F12		    0x7B
#define VK_F13		    0x7C
#define VK_F14		    0x7D
#define VK_F15		    0x7E
#define VK_F16		    0x7F
#define VK_F17		    0x80
#define VK_F18		    0x81
#define VK_F19		    0x82
#define VK_F20		    0x83
#define VK_F21		    0x84
#define VK_F22		    0x85
#define VK_F23		    0x86
#define VK_F24		    0x87
#define VK_NUMLOCK	    0x90
#define VK_SCROLL           0x91

/* VK_A thru VK_Z are the same as their ASCII equivalents: 'A' thru 'Z' */
/* VK_0 thru VK_9 are the same as their ASCII equivalents: '0' thru '0' */

#endif  /* NOVIRTUALKEYCODES */


/* SetWindowsHook() keyboard hook */
#define WH_KEYBOARD	    2

/****** Mouse input support *************************************************/

HWND    WINAPI SetCapture(HWND);
void    WINAPI ReleaseCapture(void);
HWND    WINAPI GetCapture(void);

BOOL    WINAPI SwapMouseButton(BOOL);

/* Mouse input messages */
#define WM_MOUSEMOVE	    0x0200
#define WM_LBUTTONDOWN	    0x0201
#define WM_LBUTTONUP	    0x0202
#define WM_LBUTTONDBLCLK    0x0203
#define WM_RBUTTONDOWN	    0x0204
#define WM_RBUTTONUP	    0x0205
#define WM_RBUTTONDBLCLK    0x0206
#define WM_MBUTTONDOWN	    0x0207
#define WM_MBUTTONUP	    0x0208
#define WM_MBUTTONDBLCLK    0x0209

/* Mouse input message range */
#define WM_MOUSEFIRST	    0x0200
#define WM_MOUSELAST	    0x0209

/* Mouse message wParam key states */
#ifndef NOKEYSTATES
#define MK_LBUTTON	    0x0001
#define MK_RBUTTON	    0x0002
#define MK_SHIFT	    0x0004
#define MK_CONTROL	    0x0008
#define MK_MBUTTON	    0x0010
#endif  /* NOKEYSTATES */

/* Non-client mouse messages */
#define WM_NCMOUSEMOVE	    0x00A0
#define WM_NCLBUTTONDOWN    0x00A1
#define WM_NCLBUTTONUP	    0x00A2
#define WM_NCLBUTTONDBLCLK  0x00A3
#define WM_NCRBUTTONDOWN    0x00A4
#define WM_NCRBUTTONUP	    0x00A5
#define WM_NCRBUTTONDBLCLK  0x00A6
#define WM_NCMBUTTONDOWN    0x00A7
#define WM_NCMBUTTONUP	    0x00A8
#define WM_NCMBUTTONDBLCLK  0x00A9

/* Mouse click activation support */
#define WM_MOUSEACTIVATE    0x0021

/* WM_MOUSEACTIVATE return codes */
#define MA_ACTIVATE	    1
#define MA_ACTIVATEANDEAT   2
#define MA_NOACTIVATE	    3
#if (WINVER >= 0x030a)
#define MA_NOACTIVATEANDEAT 4
#endif  /* WINVER >= 0x030a */

/* SetWindowsHook() mouse hook */
#ifndef NOWH
#define WH_MOUSE	    7

typedef struct tagMOUSEHOOKSTRUCT
{
    POINT   pt;
    HWND    hwnd;
    UINT    wHitTestCode;
    DWORD   dwExtraInfo;
} MOUSEHOOKSTRUCT;
typedef MOUSEHOOKSTRUCT  FAR* LPMOUSEHOOKSTRUCT;
#endif	/* NOWH */

/****** Mode control ********************************************************/

#define WM_CANCELMODE	    0x001F

/****** System modal window support *****************************************/

HWND    WINAPI GetSysModalWindow(void);
HWND    WINAPI SetSysModalWindow(HWND);

/****** Timer support *******************************************************/

#ifdef STRICT
typedef void (CALLBACK* TIMERPROC)(HWND, UINT, UINT, DWORD);
#else
typedef FARPROC TIMERPROC;
#endif

UINT    WINAPI SetTimer(HWND, UINT, UINT, TIMERPROC);

BOOL    WINAPI KillTimer(HWND, UINT);

#define WM_TIMER	    0x0113

/****** Accelerator support *************************************************/

DECLARE_HANDLE(HACCEL);

HACCEL  WINAPI LoadAccelerators(HINSTANCE, LPCSTR);

#ifndef NOMSG
int     WINAPI TranslateAccelerator(HWND, HACCEL, MSG FAR*);
#endif

/****** Menu support ********************************************************/

#ifndef NOMENUS

/* Menu template header */
typedef struct
{
    UINT    versionNumber;
    UINT    offset;
} MENUITEMTEMPLATEHEADER;

/* Menu template item struct */
typedef struct
{
    UINT    mtOption;
    UINT    mtID;
    char    mtString[1];
} MENUITEMTEMPLATE;

#if (WINVER >= 0x030a)
BOOL    WINAPI IsMenu(HMENU);
#endif  /* WINVER >= 0x030a */

HMENU   WINAPI CreateMenu(void);
HMENU   WINAPI CreatePopupMenu(void);
HMENU   WINAPI LoadMenu(HINSTANCE, LPCSTR);
HMENU   WINAPI LoadMenuIndirect(const void FAR*);

BOOL    WINAPI DestroyMenu(HMENU);

HMENU   WINAPI GetMenu(HWND);
BOOL    WINAPI SetMenu(HWND, HMENU);

HMENU   WINAPI GetSystemMenu(HWND, BOOL);

void    WINAPI DrawMenuBar(HWND);

BOOL    WINAPI HiliteMenuItem(HWND, HMENU, UINT, UINT);

BOOL    WINAPI InsertMenu(HMENU, UINT, UINT, UINT, LPCSTR);
BOOL    WINAPI AppendMenu(HMENU, UINT, UINT, LPCSTR);
BOOL    WINAPI ModifyMenu(HMENU, UINT, UINT, UINT, LPCSTR);
BOOL    WINAPI RemoveMenu(HMENU, UINT, UINT);
BOOL    WINAPI DeleteMenu(HMENU, UINT, UINT);

BOOL    WINAPI ChangeMenu(HMENU, UINT, LPCSTR, UINT, UINT);

#define MF_INSERT	    0x0000
#define MF_CHANGE	    0x0080
#define MF_APPEND	    0x0100
#define MF_DELETE	    0x0200
#define MF_REMOVE	    0x1000

/* Menu flags for Add/Check/EnableMenuItem() */
#define MF_BYCOMMAND	    0x0000
#define MF_BYPOSITION	    0x0400

#define MF_SEPARATOR	    0x0800

#define MF_ENABLED	    0x0000
#define MF_GRAYED	    0x0001
#define MF_DISABLED	    0x0002

#define MF_UNCHECKED	    0x0000
#define MF_CHECKED	    0x0008
#define MF_USECHECKBITMAPS  0x0200

#define MF_STRING	    0x0000
#define MF_BITMAP	    0x0004
#define MF_OWNERDRAW	    0x0100

#define MF_POPUP	    0x0010
#define MF_MENUBARBREAK     0x0020
#define MF_MENUBREAK	    0x0040

#define MF_UNHILITE	    0x0000
#define MF_HILITE	    0x0080

#define MF_SYSMENU	    0x2000
#define MF_HELP 	    0x4000
#define MF_MOUSESELECT	    0x8000


#define MF_END		    0x0080  /* Only valid in menu resource templates */

BOOL    WINAPI EnableMenuItem(HMENU, UINT, UINT);
BOOL    WINAPI CheckMenuItem(HMENU, UINT, UINT);

HMENU   WINAPI GetSubMenu(HMENU, int);

int     WINAPI GetMenuItemCount(HMENU);
UINT    WINAPI GetMenuItemID(HMENU, int);

int     WINAPI GetMenuString(HMENU, UINT, LPSTR, int, UINT);
UINT    WINAPI GetMenuState(HMENU, UINT, UINT);

BOOL    WINAPI SetMenuItemBitmaps(HMENU, UINT, UINT, HBITMAP, HBITMAP);
DWORD   WINAPI GetMenuCheckMarkDimensions(void);

BOOL    WINAPI TrackPopupMenu(HMENU, UINT, int, int, int, HWND, const RECT FAR*);

/* Flags for TrackPopupMenu */
#define TPM_LEFTBUTTON  0x0000
#if (WINVER >= 0x030a)
#define TPM_RIGHTBUTTON 0x0002
#define TPM_LEFTALIGN   0x0000
#define TPM_CENTERALIGN 0x0004
#define TPM_RIGHTALIGN  0x0008
#endif  /* WINVER >= 0x030a */

#endif  /* NOMENUS */

/* Menu messages */
#define WM_INITMENU	    0x0116
#define WM_INITMENUPOPUP    0x0117

#ifndef NOMENUS

#define WM_MENUSELECT	    0x011F
#define WM_MENUCHAR	    0x0120

#endif  /* NOMENUS */

/* Menu and control command messages */
#define WM_COMMAND	    0x0111

/****** Scroll bar support **************************************************/

#ifndef NOSCROLL

#define WM_HSCROLL	    0x0114
#define WM_VSCROLL	    0x0115

/* WM_H/VSCROLL commands */
#define SB_LINEUP	    0
#define SB_LINELEFT	    0
#define SB_LINEDOWN	    1
#define SB_LINERIGHT	    1
#define SB_PAGEUP	    2
#define SB_PAGELEFT	    2
#define SB_PAGEDOWN	    3
#define SB_PAGERIGHT	    3
#define SB_THUMBPOSITION    4
#define SB_THUMBTRACK	    5
#define SB_TOP		    6
#define SB_LEFT 	    6
#define SB_BOTTOM	    7
#define SB_RIGHT	    7
#define SB_ENDSCROLL	    8

/* Scroll bar selection constants */
#define SB_HORZ		    0
#define SB_VERT		    1
#define SB_CTL		    2
#define SB_BOTH		    3

int     WINAPI SetScrollPos(HWND, int, int, BOOL);
int     WINAPI GetScrollPos(HWND, int);
void    WINAPI SetScrollRange(HWND, int, int, int, BOOL);
void    WINAPI GetScrollRange(HWND, int, int FAR*, int FAR*);
void    WINAPI ShowScrollBar(HWND, int, BOOL);
BOOL    WINAPI EnableScrollBar(HWND, int, UINT);

/* EnableScrollBar() flags */
#define ESB_ENABLE_BOTH     0x0000
#define ESB_DISABLE_BOTH    0x0003

#define ESB_DISABLE_LEFT    0x0001
#define ESB_DISABLE_RIGHT   0x0002

#define ESB_DISABLE_UP      0x0001
#define ESB_DISABLE_DOWN    0x0002

#define ESB_DISABLE_LTUP    ESB_DISABLE_LEFT
#define ESB_DISABLE_RTDN    ESB_DISABLE_RIGHT

#endif  /* NOSCROLL */

/******* Clipboard manager **************************************************/

#ifndef NOCLIPBOARD

/* Predefined Clipboard Formats */
#define CF_TEXT 	     1
#define CF_BITMAP	     2
#define CF_METAFILEPICT      3
#define CF_SYLK 	     4
#define CF_DIF		     5
#define CF_TIFF 	     6
#define CF_OEMTEXT	     7
#define CF_DIB		     8
#define CF_PALETTE	     9
#define CF_PENDATA          10
#define CF_RIFF             11
#define CF_WAVE             12

#define CF_OWNERDISPLAY     0x0080
#define CF_DSPTEXT	    0x0081
#define CF_DSPBITMAP	    0x0082
#define CF_DSPMETAFILEPICT  0x0083

/* "Private" formats don't get GlobalFree()'d */
#define CF_PRIVATEFIRST     0x0200
#define CF_PRIVATELAST	    0x02FF

/* "GDIOBJ" formats do get DeleteObject()'d */
#define CF_GDIOBJFIRST	    0x0300
#define CF_GDIOBJLAST	    0x03FF

/* Clipboard Manager Functions */
BOOL    WINAPI OpenClipboard(HWND);
BOOL    WINAPI CloseClipboard(void);
BOOL    WINAPI EmptyClipboard(void);

#if (WINVER >= 0x030a)
HWND    WINAPI GetOpenClipboardWindow(void);
#endif  /* WINVER >= 0x030a */

HWND    WINAPI GetClipboardOwner(void);

HWND    WINAPI SetClipboardViewer(HWND);
HWND    WINAPI GetClipboardViewer(void);

HANDLE  WINAPI SetClipboardData(UINT, HANDLE);
HANDLE  WINAPI GetClipboardData(UINT);

BOOL    WINAPI IsClipboardFormatAvailable(UINT);
int     WINAPI GetPriorityClipboardFormat(UINT FAR*, int);

UINT    WINAPI RegisterClipboardFormat(LPCSTR);
int     WINAPI CountClipboardFormats(void);
UINT    WINAPI EnumClipboardFormats(UINT);
int     WINAPI GetClipboardFormatName(UINT, LPSTR, int);

BOOL    WINAPI ChangeClipboardChain(HWND, HWND);

/* Clipboard command messages */
#define WM_CUT		    0x0300
#define WM_COPY		    0x0301
#define WM_PASTE	    0x0302
#define WM_CLEAR	    0x0303
#define WM_UNDO		    0x0304

/* Clipboard owner messages */
#define WM_RENDERFORMAT	    0x0305
#define WM_RENDERALLFORMATS 0x0306
#define WM_DESTROYCLIPBOARD 0x0307

/* Clipboard viewer messages */
#define WM_DRAWCLIPBOARD    0x0308
#define WM_PAINTCLIPBOARD   0x0309
#define WM_SIZECLIPBOARD    0x030B
#define WM_VSCROLLCLIPBOARD 0x030A
#define WM_HSCROLLCLIPBOARD 0x030E
#define WM_ASKCBFORMATNAME  0x030C
#define WM_CHANGECBCHAIN    0x030D

#endif  /* NOCLIPBOARD */

/****** Mouse cursor support *************************************************/

HCURSOR WINAPI LoadCursor(HINSTANCE, LPCSTR);
HCURSOR WINAPI CreateCursor(HINSTANCE, int, int, int, int, const void FAR*, const void FAR*);
BOOL    WINAPI DestroyCursor(HCURSOR);

#if (WINVER >= 0x030a)
HCURSOR WINAPI CopyCursor(HINSTANCE, HCURSOR);
#endif  /* WINVER >= 0x030a */

int     WINAPI ShowCursor(BOOL);

void    WINAPI SetCursorPos(int, int);
void    WINAPI GetCursorPos(POINT FAR*);

HCURSOR WINAPI SetCursor(HCURSOR);

#if (WINVER >= 0x030a)
HCURSOR WINAPI GetCursor(void);
#endif  /* WINVER >= 0x030a */

void    WINAPI ClipCursor(const RECT FAR*);
#if (WINVER >= 0x030a)
void    WINAPI GetClipCursor(RECT FAR*);
#endif  /* WINVER >= 0x030a */

/* Standard cursor resource IDs */
#define IDC_ARROW	    MAKEINTRESOURCE(32512)
#define IDC_IBEAM	    MAKEINTRESOURCE(32513)
#define IDC_WAIT	    MAKEINTRESOURCE(32514)
#define IDC_CROSS	    MAKEINTRESOURCE(32515)
#define IDC_UPARROW	    MAKEINTRESOURCE(32516)
#define IDC_SIZE	    MAKEINTRESOURCE(32640)
#define IDC_ICON	    MAKEINTRESOURCE(32641)
#define IDC_SIZENWSE	    MAKEINTRESOURCE(32642)
#define IDC_SIZENESW	    MAKEINTRESOURCE(32643)
#define IDC_SIZEWE	    MAKEINTRESOURCE(32644)
#define IDC_SIZENS	    MAKEINTRESOURCE(32645)

#define WM_SETCURSOR	    0x0020

/****** Icon support *********************************************************/

HICON   WINAPI LoadIcon(HINSTANCE, LPCSTR);
HICON   WINAPI CreateIcon(HINSTANCE, int, int, BYTE, BYTE, const void FAR*, const void FAR*);
BOOL    WINAPI DestroyIcon(HICON);

#if (WINVER >= 0x030a)
HICON   WINAPI CopyIcon(HINSTANCE, HICON);
#endif  /* WINVER >= 0x030a */

BOOL    WINAPI DrawIcon(HDC, int, int, HICON);

#ifndef NOICONS

/* Standard icon resource IDs */
#define IDI_APPLICATION     MAKEINTRESOURCE(32512)
#define IDI_HAND	    MAKEINTRESOURCE(32513)
#define IDI_QUESTION	    MAKEINTRESOURCE(32514)
#define IDI_EXCLAMATION     MAKEINTRESOURCE(32515)
#define IDI_ASTERISK	    MAKEINTRESOURCE(32516)

#endif  /* NOICONS */

/****** Message Box support *************************************************/

#ifndef NOMB

int     WINAPI MessageBox(HWND, LPCSTR, LPCSTR, UINT);
void    WINAPI MessageBeep(UINT);

#define MB_OK		    0x0000
#define MB_OKCANCEL	    0x0001
#define MB_ABORTRETRYIGNORE 0x0002
#define MB_YESNOCANCEL	    0x0003
#define MB_YESNO	    0x0004
#define MB_RETRYCANCEL	    0x0005
#define MB_TYPEMASK	    0x000F

#define MB_ICONHAND	    0x0010
#define MB_ICONQUESTION	    0x0020
#define MB_ICONEXCLAMATION  0x0030
#define MB_ICONASTERISK     0x0040
#define MB_ICONMASK	    0x00F0

#define MB_ICONINFORMATION  MB_ICONASTERISK
#define MB_ICONSTOP         MB_ICONHAND

#define MB_DEFBUTTON1	    0x0000
#define MB_DEFBUTTON2	    0x0100
#define MB_DEFBUTTON3	    0x0200
#define MB_DEFMASK	    0x0F00

#define MB_APPLMODAL	    0x0000
#define MB_SYSTEMMODAL	    0x1000
#define MB_TASKMODAL	    0x2000

#define MB_NOFOCUS	    0x8000



#endif  /* NOMB */

/****** Caret support ********************************************************/

void    WINAPI CreateCaret(HWND, HBITMAP, int, int);
void    WINAPI DestroyCaret(void);

void    WINAPI SetCaretPos(int, int);
void    WINAPI GetCaretPos(POINT FAR*);

void    WINAPI HideCaret(HWND);
void    WINAPI ShowCaret(HWND);

UINT    WINAPI GetCaretBlinkTime(void);
void    WINAPI SetCaretBlinkTime(UINT);

/****** WM_SYSCOMMAND support ***********************************************/

#define WM_SYSCOMMAND	0x0112

#ifndef NOSYSCOMMANDS

/* System Menu Command Values */
#define SC_SIZE		0xF000
#define SC_MOVE		0xF010
#define SC_MINIMIZE	0xF020
#define SC_MAXIMIZE	0xF030
#define SC_NEXTWINDOW	0xF040
#define SC_PREVWINDOW	0xF050
#define SC_CLOSE	0xF060
#define SC_VSCROLL	0xF070
#define SC_HSCROLL	0xF080
#define SC_MOUSEMENU	0xF090
#define SC_KEYMENU	0xF100
#define SC_ARRANGE	0xF110
#define SC_RESTORE	0xF120
#define SC_TASKLIST	0xF130
#define SC_SCREENSAVE   0xF140
#define SC_HOTKEY       0xF150

/* Obsolete names */
#define SC_ICON		SC_MINIMIZE
#define SC_ZOOM 	SC_MAXIMIZE


#endif  /* NOSYSCOMMANDS */

/****** MDI Support *********************************************************/

#ifndef NOMDI

/* CreateWindow lpParams structure for creating MDI client */
typedef struct tagCLIENTCREATESTRUCT
{
    HMENU  hWindowMenu;
    UINT   idFirstChild;
} CLIENTCREATESTRUCT;
typedef CLIENTCREATESTRUCT FAR* LPCLIENTCREATESTRUCT;

/* MDI client style bits */
#if (WINVER >= 0x030a)
#define MDIS_ALLCHILDSTYLES 0x0001
#endif  /* WINVER >= 0x030a */

/* MDI messages */
#define WM_MDICREATE	    0x0220
#define WM_MDIDESTROY	    0x0221
#define WM_MDIACTIVATE	    0x0222
#define WM_MDIRESTORE	    0x0223
#define WM_MDINEXT	    0x0224
#define WM_MDIMAXIMIZE	    0x0225
#define WM_MDITILE	    0x0226
#define WM_MDICASCADE	    0x0227
#define WM_MDIICONARRANGE   0x0228
#define WM_MDIGETACTIVE     0x0229
#define WM_MDISETMENU	    0x0230

/* WM_MDICREATE message structure */
typedef struct tagMDICREATESTRUCT
{
    LPCSTR  szClass;
    LPCSTR  szTitle;
    HINSTANCE hOwner;
    int     x;
    int     y;
    int     cx;
    int     cy;
    DWORD   style;
    LPARAM  lParam;
} MDICREATESTRUCT;
typedef MDICREATESTRUCT FAR*  LPMDICREATESTRUCT;

#if (WINVER >= 0x030a)
/* wParam values for WM_MDITILE and WM_MDICASCADE messages. */
#define MDITILE_VERTICAL	0x0000
#define MDITILE_HORIZONTAL	0x0001
#define MDITILE_SKIPDISABLED	0x0002
#endif  /* WINVER >= 0x030a */

#define WM_CHILDACTIVATE    0x0022

LRESULT WINAPI DefFrameProc(HWND, HWND, UINT, WPARAM, LPARAM);
LRESULT WINAPI DefMDIChildProc(HWND, UINT, WPARAM, LPARAM);

#ifndef NOMSG
BOOL    WINAPI TranslateMDISysAccel(HWND, MSG FAR*);
#endif

UINT    WINAPI ArrangeIconicWindows(HWND);

#endif  /* NOMDI */

/****** Dialog and Control Management ***************************************/

#ifndef NOCTLMGR

/* Dialog window class */
#define WC_DIALOG	(MAKEINTATOM(0x8002))

/* cbWndExtra bytes needed by dialog manager for dialog classes */
#define DLGWINDOWEXTRA	30

/* Dialog styles */
#define DS_ABSALIGN	    0x01L
#define DS_SYSMODAL	    0x02L
#define DS_LOCALEDIT        0x20L
#define DS_SETFONT          0x40L
#define DS_MODALFRAME       0x80L
#define DS_NOIDLEMSG        0x100L

/* Dialog messages */
#define DM_GETDEFID	    (WM_USER+0)
#define DM_SETDEFID	    (WM_USER+1)

/* Returned in HIWORD() of DM_GETDEFID result if msg is supported */
#define DC_HASDEFID	    0x534B

#endif  /* NOCTLMGR */

/* Dialog notification messages */
#define WM_INITDIALOG	    0x0110
#define WM_NEXTDLGCTL	    0x0028

#define WM_PARENTNOTIFY     0x0210

#define WM_ENTERIDLE	    0x0121


#ifndef NOCTLMGR

#ifdef STRICT
typedef BOOL (CALLBACK* DLGPROC)(HWND, UINT, WPARAM, LPARAM);
#else
typedef FARPROC DLGPROC;
#endif

/* Get/SetWindowWord/Long offsets for use with WC_DIALOG windows */
#define DWL_MSGRESULT	0
#define DWL_DLGPROC	4
#define DWL_USER	8

#ifndef NOMSG
BOOL    WINAPI IsDialogMessage(HWND, MSG FAR*);
#endif

LRESULT WINAPI DefDlgProc(HWND, UINT, WPARAM, LPARAM);

HWND    WINAPI CreateDialog(HINSTANCE, LPCSTR, HWND, DLGPROC);
HWND    WINAPI CreateDialogIndirect(HINSTANCE, const void FAR*, HWND, DLGPROC);
HWND    WINAPI CreateDialogParam(HINSTANCE, LPCSTR, HWND, DLGPROC, LPARAM);
HWND    WINAPI CreateDialogIndirectParam(HINSTANCE, const void FAR*, HWND, DLGPROC, LPARAM);

int     WINAPI DialogBox(HINSTANCE, LPCSTR, HWND, DLGPROC);
int     WINAPI DialogBoxIndirect(HINSTANCE, HGLOBAL, HWND, DLGPROC);
int     WINAPI DialogBoxParam(HINSTANCE, LPCSTR, HWND, DLGPROC, LPARAM);
int     WINAPI DialogBoxIndirectParam(HINSTANCE, HGLOBAL, HWND, DLGPROC, LPARAM);

void    WINAPI EndDialog(HWND, int);

int     WINAPI GetDlgCtrlID(HWND);
HWND    WINAPI GetDlgItem(HWND, int);
LRESULT WINAPI SendDlgItemMessage(HWND, int, UINT, WPARAM, LPARAM);

void    WINAPI SetDlgItemInt(HWND, int, UINT, BOOL);
UINT    WINAPI GetDlgItemInt(HWND, int, BOOL FAR* , BOOL);

void    WINAPI SetDlgItemText(HWND, int, LPCSTR);
int     WINAPI GetDlgItemText(HWND, int, LPSTR, int);

void    WINAPI CheckDlgButton(HWND, int, UINT);
void    WINAPI CheckRadioButton(HWND, int, int, int);
UINT    WINAPI IsDlgButtonChecked(HWND, int);

HWND    WINAPI GetNextDlgGroupItem(HWND, HWND, BOOL);
HWND    WINAPI GetNextDlgTabItem(HWND, HWND, BOOL);

void    WINAPI MapDialogRect(HWND, RECT FAR*);
DWORD   WINAPI GetDialogBaseUnits(void);

#define WM_GETDLGCODE	    0x0087

/* dialog codes */
#define DLGC_WANTARROWS     0x0001
#define DLGC_WANTTAB        0x0002
#define DLGC_WANTALLKEYS    0x0004
#define DLGC_WANTMESSAGE    0x0004
#define DLGC_HASSETSEL      0x0008
#define DLGC_DEFPUSHBUTTON  0x0010
#define DLGC_UNDEFPUSHBUTTON 0x0020
#define DLGC_RADIOBUTTON    0x0040
#define DLGC_WANTCHARS      0x0080
#define DLGC_STATIC         0x0100
#define DLGC_BUTTON         0x2000

#define WM_CTLCOLOR	    0x0019

/* WM_CTLCOLOR control IDs */
#define CTLCOLOR_MSGBOX     0
#define CTLCOLOR_EDIT	    1
#define CTLCOLOR_LISTBOX    2
#define CTLCOLOR_BTN	    3
#define CTLCOLOR_DLG	    4
#define CTLCOLOR_SCROLLBAR  5
#define CTLCOLOR_STATIC     6

#define WM_SETFONT          0x0030
#define WM_GETFONT	    0x0031

#endif  /* NOCTLMGR */

/* Standard dialog button IDs */
#define IDOK		    1
#define IDCANCEL	    2
#define IDABORT 	    3
#define IDRETRY 	    4
#define IDIGNORE	    5
#define IDYES		    6
#define IDNO		    7

/****** Owner draw control support ******************************************/

/* Owner draw control types */
#define ODT_MENU	1
#define ODT_LISTBOX	2
#define ODT_COMBOBOX	3
#define ODT_BUTTON	4

/* Owner draw actions */
#define ODA_DRAWENTIRE	0x0001
#define ODA_SELECT	0x0002
#define ODA_FOCUS	0x0004

/* Owner draw state */
#define ODS_SELECTED	0x0001
#define ODS_GRAYED	0x0002
#define ODS_DISABLED	0x0004
#define ODS_CHECKED	0x0008
#define ODS_FOCUS	0x0010

#define WM_DRAWITEM         0x002B

typedef struct tagDRAWITEMSTRUCT
{
    UINT        CtlType;
    UINT        CtlID;
    UINT        itemID;
    UINT        itemAction;
    UINT        itemState;
    HWND	hwndItem;
    HDC		hDC;
    RECT	rcItem;
    DWORD       itemData;
} DRAWITEMSTRUCT;
typedef DRAWITEMSTRUCT NEAR* PDRAWITEMSTRUCT;
typedef DRAWITEMSTRUCT FAR* LPDRAWITEMSTRUCT;

#define WM_MEASUREITEM      0x002C

typedef struct tagMEASUREITEMSTRUCT
{
    UINT        CtlType;
    UINT        CtlID;
    UINT        itemID;
    UINT        itemWidth;
    UINT        itemHeight;
    DWORD       itemData;
} MEASUREITEMSTRUCT;
typedef MEASUREITEMSTRUCT NEAR* PMEASUREITEMSTRUCT;
typedef MEASUREITEMSTRUCT FAR* LPMEASUREITEMSTRUCT;

#define WM_DELETEITEM       0x002D

typedef struct tagDELETEITEMSTRUCT
{
    UINT       CtlType;
    UINT       CtlID;
    UINT       itemID;
    HWND       hwndItem;
    DWORD      itemData;
} DELETEITEMSTRUCT;
typedef DELETEITEMSTRUCT NEAR* PDELETEITEMSTRUCT;
typedef DELETEITEMSTRUCT FAR* LPDELETEITEMSTRUCT;

#define WM_COMPAREITEM	    0x0039

typedef struct tagCOMPAREITEMSTRUCT
{
    UINT        CtlType;
    UINT        CtlID;
    HWND	hwndItem;
    UINT        itemID1;
    DWORD       itemData1;
    UINT        itemID2;
    DWORD       itemData2;
} COMPAREITEMSTRUCT;
typedef COMPAREITEMSTRUCT NEAR* PCOMPAREITEMSTRUCT;
typedef COMPAREITEMSTRUCT FAR* LPCOMPAREITEMSTRUCT;

/****** Static control ******************************************************/

#ifndef NOCTLMGR

/* Static Control Styles */
#define SS_LEFT 	    0x00000000L
#define SS_CENTER	    0x00000001L
#define SS_RIGHT	    0x00000002L
#define SS_ICON 	    0x00000003L
#define SS_BLACKRECT	    0x00000004L
#define SS_GRAYRECT	    0x00000005L
#define SS_WHITERECT	    0x00000006L
#define SS_BLACKFRAME	    0x00000007L
#define SS_GRAYFRAME	    0x00000008L
#define SS_WHITEFRAME	    0x00000009L
#define SS_SIMPLE	    0x0000000BL
#define SS_LEFTNOWORDWRAP   0x0000000CL
#define SS_NOPREFIX         0x00000080L

#if (WINVER >= 0x030a)
#ifndef NOWINMESSAGES
/* Static Control Mesages */
#define STM_SETICON	    (WM_USER+0)
#define STM_GETICON	    (WM_USER+1)
#endif  /* NOWINMESSAGES */
#endif  /* WINVER >= 0x030a */

#endif  /* NOCTLMGR */

/****** Button control *****************************************************/

#ifndef NOCTLMGR

/* Button Control Styles */
#define BS_PUSHBUTTON	    0x00000000L
#define BS_DEFPUSHBUTTON    0x00000001L
#define BS_CHECKBOX	    0x00000002L
#define BS_AUTOCHECKBOX     0x00000003L
#define BS_RADIOBUTTON	    0x00000004L
#define BS_3STATE	    0x00000005L
#define BS_AUTO3STATE	    0x00000006L
#define BS_GROUPBOX	    0x00000007L
#define BS_USERBUTTON	    0x00000008L
#define BS_AUTORADIOBUTTON  0x00000009L
#define BS_OWNERDRAW	    0x0000000BL
#define BS_LEFTTEXT	    0x00000020L

/* Button Control Messages  */
#define BM_GETCHECK	    (WM_USER+0)
#define BM_SETCHECK	    (WM_USER+1)
#define BM_GETSTATE	    (WM_USER+2)
#define BM_SETSTATE	    (WM_USER+3)
#define BM_SETSTYLE	    (WM_USER+4)

/* User Button Notification Codes */
#define BN_CLICKED	    0
#define BN_PAINT	    1
#define BN_HILITE	    2
#define BN_UNHILITE	    3
#define BN_DISABLE	    4
#define BN_DOUBLECLICKED    5

#endif  /* NOCTLMGR */

/****** Edit control *******************************************************/

#ifndef NOCTLMGR

/* Edit control styles */
#ifndef NOWINSTYLES
#define ES_LEFT 	    0x00000000L
#define ES_CENTER	    0x00000001L
#define ES_RIGHT	    0x00000002L
#define ES_MULTILINE	    0x00000004L
#define ES_UPPERCASE	    0x00000008L
#define ES_LOWERCASE	    0x00000010L
#define ES_PASSWORD         0x00000020L
#define ES_AUTOVSCROLL	    0x00000040L
#define ES_AUTOHSCROLL	    0x00000080L
#define ES_NOHIDESEL	    0x00000100L
#define ES_OEMCONVERT	    0x00000400L
#if (WINVER >= 0x030a)
#define ES_READONLY	    0x00000800L
#define ES_WANTRETURN       0x00001000L
#endif  /* WINVER >= 0x030a */
#endif  /* NOWINSTYLES */

/* Edit control messages */
#ifndef NOWINMESSAGES
#define EM_GETSEL	        (WM_USER+0)
#define EM_SETSEL	        (WM_USER+1)
#define EM_GETRECT	        (WM_USER+2)
#define EM_SETRECT	        (WM_USER+3)
#define EM_SETRECTNP	        (WM_USER+4)
#define EM_LINESCROLL	        (WM_USER+6)
#define EM_GETMODIFY	        (WM_USER+8)
#define EM_SETMODIFY	        (WM_USER+9)
#define EM_GETLINECOUNT         (WM_USER+10)
#define EM_LINEINDEX	        (WM_USER+11)
#define EM_SETHANDLE	        (WM_USER+12)
#define EM_GETHANDLE	        (WM_USER+13)
#define EM_LINELENGTH	        (WM_USER+17)
#define EM_REPLACESEL	        (WM_USER+18)
#define EM_SETFONT              (WM_USER+19)    /* NOT IMPLEMENTED: use WM_SETFONT */
#define EM_GETLINE	        (WM_USER+20)
#define EM_LIMITTEXT	        (WM_USER+21)
#define EM_CANUNDO	        (WM_USER+22)
#define EM_UNDO 	        (WM_USER+23)
#define EM_FMTLINES	        (WM_USER+24)
#define EM_LINEFROMCHAR         (WM_USER+25)
#define EM_SETWORDBREAK         (WM_USER+26)    /* NOT IMPLEMENTED: use EM_SETWORDBREAK */
#define EM_SETTABSTOPS	        (WM_USER+27)
#define EM_SETPASSWORDCHAR      (WM_USER+28)
#define EM_EMPTYUNDOBUFFER      (WM_USER+29)
#if (WINVER >= 0x030a)
#define EM_GETFIRSTVISIBLELINE	(WM_USER+30)
#define EM_SETREADONLY	        (WM_USER+31)
#define EM_SETWORDBREAKPROC     (WM_USER+32)
#define EM_GETWORDBREAKPROC     (WM_USER+33)
#define EM_GETPASSWORDCHAR      (WM_USER+34)
#endif  /* WINVER >= 0x030a */
#endif  /* NOWINMESSAGES */

#if (WINVER >= 0x030a)
typedef int   (CALLBACK* EDITWORDBREAKPROC)(LPSTR lpch, int ichCurrent, int cch, int code);

/* EDITWORDBREAKPROC code values */
#define WB_LEFT		   0
#define WB_RIGHT	   1
#define WB_ISDELIMITER     2
#endif  /* WINVER >= 0x030a */

/* Edit control notification codes */
#define EN_SETFOCUS	    0x0100
#define EN_KILLFOCUS	    0x0200
#define EN_CHANGE	    0x0300
#define EN_UPDATE	    0x0400
#define EN_ERRSPACE	    0x0500
#define EN_MAXTEXT	    0x0501
#define EN_HSCROLL	    0x0601
#define EN_VSCROLL	    0x0602

#endif  /* NOCTLMGR */

/****** Scroll bar control *************************************************/
/* Also see scrolling support */

#ifndef NOCTLMGR

#ifndef NOWINSTYLES

/* Scroll bar styles */
#define SBS_HORZ		    0x0000L
#define SBS_VERT		    0x0001L
#define SBS_TOPALIGN		    0x0002L
#define SBS_LEFTALIGN		    0x0002L
#define SBS_BOTTOMALIGN		    0x0004L
#define SBS_RIGHTALIGN		    0x0004L
#define SBS_SIZEBOXTOPLEFTALIGN	    0x0002L
#define SBS_SIZEBOXBOTTOMRIGHTALIGN 0x0004L
#define SBS_SIZEBOX		    0x0008L

#endif  /* NOWINSTYLES */

#endif  /* NOCTLMGR */

/****** Listbox control ****************************************************/

#ifndef NOCTLMGR

/* Listbox styles */
#ifndef NOWINSTYLES
#define LBS_NOTIFY	      0x0001L
#define LBS_SORT	      0x0002L
#define LBS_NOREDRAW	      0x0004L
#define LBS_MULTIPLESEL       0x0008L
#define LBS_OWNERDRAWFIXED    0x0010L
#define LBS_OWNERDRAWVARIABLE 0x0020L
#define LBS_HASSTRINGS        0x0040L
#define LBS_USETABSTOPS       0x0080L
#define LBS_NOINTEGRALHEIGHT  0x0100L
#define LBS_MULTICOLUMN       0x0200L
#define LBS_WANTKEYBOARDINPUT 0x0400L
#define LBS_EXTENDEDSEL	      0x0800L
#if (WINVER >= 0x030a)
#define LBS_DISABLENOSCROLL   0x1000L
#endif  /* WINVER >= 0x030a */
#define LBS_STANDARD	      (LBS_NOTIFY | LBS_SORT | WS_VSCROLL | WS_BORDER)
#endif  /* NOWINSTYLES */

/* Listbox messages */
#ifndef NOWINMESSAGES
#define LB_ADDSTRING	       (WM_USER+1)
#define LB_INSERTSTRING        (WM_USER+2)
#define LB_DELETESTRING        (WM_USER+3)
#define LB_RESETCONTENT        (WM_USER+5)
#define LB_SETSEL	       (WM_USER+6)
#define LB_SETCURSEL	       (WM_USER+7)
#define LB_GETSEL	       (WM_USER+8)
#define LB_GETCURSEL	       (WM_USER+9)
#define LB_GETTEXT	       (WM_USER+10)
#define LB_GETTEXTLEN	       (WM_USER+11)
#define LB_GETCOUNT	       (WM_USER+12)
#define LB_SELECTSTRING        (WM_USER+13)
#define LB_DIR		       (WM_USER+14)
#define LB_GETTOPINDEX	       (WM_USER+15)
#define LB_FINDSTRING	       (WM_USER+16)
#define LB_GETSELCOUNT	       (WM_USER+17)
#define LB_GETSELITEMS	       (WM_USER+18)
#define LB_SETTABSTOPS         (WM_USER+19)
#define LB_GETHORIZONTALEXTENT (WM_USER+20)
#define LB_SETHORIZONTALEXTENT (WM_USER+21)
#define LB_SETCOLUMNWIDTH      (WM_USER+22)
#define LB_SETTOPINDEX	       (WM_USER+24)
#define LB_GETITEMRECT	       (WM_USER+25)
#define LB_GETITEMDATA         (WM_USER+26)
#define LB_SETITEMDATA         (WM_USER+27)
#define LB_SELITEMRANGE        (WM_USER+28)
#define LB_SETCARETINDEX       (WM_USER+31)
#define LB_GETCARETINDEX       (WM_USER+32)

#if (WINVER >= 0x030a)
#define LB_SETITEMHEIGHT       (WM_USER+33)
#define LB_GETITEMHEIGHT       (WM_USER+34)
#define LB_FINDSTRINGEXACT     (WM_USER+35)
#endif  /* WINVER >= 0x030a */

#endif  /* NOWINMESSAGES */

/* Listbox notification codes */
#define LBN_ERRSPACE	    (-2)
#define LBN_SELCHANGE	    1
#define LBN_DBLCLK	    2
#define LBN_SELCANCEL       3
#define LBN_SETFOCUS        4
#define LBN_KILLFOCUS       5

/* Listbox notification messages */
#define WM_VKEYTOITEM       0x002E
#define WM_CHARTOITEM       0x002F

/* Listbox message return values */
#define LB_OKAY 	    0
#define LB_ERR		    (-1)
#define LB_ERRSPACE	    (-2)

#define LB_CTLCODE	    0L

/****** Dialog directory support ********************************************/

int     WINAPI DlgDirList(HWND, LPSTR, int, int, UINT);
BOOL    WINAPI DlgDirSelect(HWND, LPSTR, int);

int     WINAPI DlgDirListComboBox(HWND, LPSTR, int, int, UINT);
BOOL    WINAPI DlgDirSelectComboBox(HWND, LPSTR, int);

#if (WINVER >= 0x030a)
BOOL    WINAPI DlgDirSelectEx(HWND, LPSTR, int, int);
BOOL    WINAPI DlgDirSelectComboBoxEx(HWND, LPSTR, int, int);
#endif  /* WINVER >= 0x030a */


/* DlgDirList, DlgDirListComboBox flags values */
#define DDL_READWRITE       0x0000
#define DDL_READONLY        0x0001
#define DDL_HIDDEN          0x0002
#define DDL_SYSTEM          0x0004
#define DDL_DIRECTORY	    0x0010
#define DDL_ARCHIVE	    0x0020

#define DDL_POSTMSGS	    0x2000
#define DDL_DRIVES	    0x4000
#define DDL_EXCLUSIVE	    0x8000

#endif  /* NOCTLMGR */

/****** Combo box control **************************************************/

#ifndef NOCTLMGR

/* Combo box styles */
#ifndef NOWINSTYLES
#define CBS_SIMPLE	      0x0001L
#define CBS_DROPDOWN	      0x0002L
#define CBS_DROPDOWNLIST      0x0003L
#define CBS_OWNERDRAWFIXED    0x0010L
#define CBS_OWNERDRAWVARIABLE 0x0020L
#define CBS_AUTOHSCROLL       0x0040L
#define CBS_OEMCONVERT        0x0080L
#define CBS_SORT              0x0100L
#define CBS_HASSTRINGS        0x0200L
#define CBS_NOINTEGRALHEIGHT  0x0400L
#if (WINVER >= 0x030a)
#define CBS_DISABLENOSCROLL   0x0800L
#endif  /* WINVER >= 0x030a */
#endif  /* NOWINSTYLES */

/* Combo box messages */
#ifndef NOWINMESSAGES
#define CB_GETEDITSEL	         (WM_USER+0)
#define CB_LIMITTEXT	         (WM_USER+1)
#define CB_SETEDITSEL	         (WM_USER+2)
#define CB_ADDSTRING	         (WM_USER+3)
#define CB_DELETESTRING	         (WM_USER+4)
#define CB_DIR                   (WM_USER+5)
#define CB_GETCOUNT	         (WM_USER+6)
#define CB_GETCURSEL	         (WM_USER+7)
#define CB_GETLBTEXT	         (WM_USER+8)
#define CB_GETLBTEXTLEN	         (WM_USER+9)
#define CB_INSERTSTRING          (WM_USER+10)
#define CB_RESETCONTENT	         (WM_USER+11)
#define CB_FINDSTRING	         (WM_USER+12)
#define CB_SELECTSTRING	         (WM_USER+13)
#define CB_SETCURSEL	         (WM_USER+14)
#define CB_SHOWDROPDOWN          (WM_USER+15)
#define CB_GETITEMDATA           (WM_USER+16)
#define CB_SETITEMDATA           (WM_USER+17)
#if (WINVER >= 0x030a)
#define CB_GETDROPPEDCONTROLRECT (WM_USER+18)
#define CB_SETITEMHEIGHT         (WM_USER+19)
#define CB_GETITEMHEIGHT         (WM_USER+20)
#define CB_SETEXTENDEDUI         (WM_USER+21)
#define CB_GETEXTENDEDUI         (WM_USER+22)
#define CB_GETDROPPEDSTATE       (WM_USER+23)
#define CB_FINDSTRINGEXACT       (WM_USER+24)
#endif  /* WINVER >= 0x030a */

#endif  /* NOWINMESSAGES */

/* Combo box notification codes */
#define CBN_ERRSPACE	    (-1)
#define CBN_SELCHANGE	    1
#define CBN_DBLCLK	    2
#define CBN_SETFOCUS	    3
#define CBN_KILLFOCUS	    4
#define CBN_EDITCHANGE      5
#define CBN_EDITUPDATE      6
#define CBN_DROPDOWN        7
#if (WINVER >= 0x030a)
#define CBN_CLOSEUP         8
#define CBN_SELENDOK        9
#define CBN_SELENDCANCEL    10
#endif  /* WINVER >= 0x030a */

/* Combo box message return values */
#define CB_OKAY 	    0
#define CB_ERR		    (-1)
#define CB_ERRSPACE	    (-2)

#endif	/* NOCTLMGR */

/******* Windows hook support **********************************************/

#ifndef NOWH

DECLARE_HANDLE32(HHOOK);

#ifdef STRICT
typedef LRESULT (CALLBACK* HOOKPROC)(int code, WPARAM wParam, LPARAM lParam);
#else
typedef FARPROC HOOKPROC;
#endif

#ifdef STRICT
HHOOK   WINAPI SetWindowsHook(int, HOOKPROC);
LRESULT WINAPI DefHookProc(int, WPARAM, LPARAM, HHOOK FAR*);
#else
HOOKPROC WINAPI SetWindowsHook(int, HOOKPROC);
LRESULT WINAPI DefHookProc(int, WPARAM, LPARAM, HOOKPROC FAR*);
#endif
BOOL    WINAPI UnhookWindowsHook(int, HOOKPROC);

#if (WINVER >= 0x030a)

HHOOK   WINAPI SetWindowsHookEx(int idHook, HOOKPROC lpfn, HINSTANCE hInstance, HTASK hTask);
BOOL    WINAPI UnhookWindowsHookEx(HHOOK hHook);
LRESULT WINAPI CallNextHookEx(HHOOK hHook, int code, WPARAM wParam, LPARAM lParam);

#endif  /* WINVER >= 0x030a */


/* Standard hook code */
#define HC_ACTION	    0

/* Obsolete hook codes (NO LONGER SUPPORTED) */
#define HC_GETLPLPFN	    (-3)
#define HC_LPLPFNNEXT	    (-2)
#define HC_LPFNNEXT	    (-1)

#endif	/* NOWH */

/****** Computer-based-training (CBT) support *******************************/

#define WM_QUEUESYNC        0x0023

#ifndef NOWH

/* SetWindowsHook() code */
#define WH_CBT		    5

#define HCBT_MOVESIZE	    0
#define HCBT_MINMAX	    1
#define HCBT_QS 	    2
#define HCBT_CREATEWND	    3
#define HCBT_DESTROYWND	    4
#define HCBT_ACTIVATE	    5
#define HCBT_CLICKSKIPPED   6
#define HCBT_KEYSKIPPED     7
#define HCBT_SYSCOMMAND	    8
#define HCBT_SETFOCUS	    9

#if (WINVER >= 0x030a)
/* HCBT_CREATEWND parameters pointed to by lParam */
typedef struct tagCBT_CREATEWND
{
    CREATESTRUCT FAR* lpcs;
    HWND    hwndInsertAfter;
} CBT_CREATEWND;
typedef CBT_CREATEWND FAR* LPCBT_CREATEWND;

/* HCBT_ACTIVATE structure pointed to by lParam */
typedef struct tagCBTACTIVATESTRUCT
{
    BOOL    fMouse;
    HWND    hWndActive;
} CBTACTIVATESTRUCT;

#endif  /* WINVER >= 0x030a */
#endif	/* NOWH */

/****** Hardware hook support ***********************************************/

#ifndef NOWH
#if (WINVER >= 0x030a)
#define WH_HARDWARE	    8

typedef struct tagHARDWAREHOOKSTRUCT
{
    HWND    hWnd;
    UINT    wMessage;
    WPARAM  wParam;
    LPARAM  lParam;
} HARDWAREHOOKSTRUCT;
#endif  /* WINVER >= 0x030a */
#endif  /* NOWH */

/****** Shell support *******************************************************/

#ifndef NOWH
#if (WINVER >= 0x030a)
/* SetWindowsHook() Shell hook code */
#define WH_SHELL           10

#define HSHELL_WINDOWCREATED       1
#define HSHELL_WINDOWDESTROYED     2
#define HSHELL_ACTIVATESHELLWINDOW 3

#endif  /* WINVER >= 0x030a */
#endif  /* NOWH */

/****** Journalling support *************************************************/

#ifndef NOWH
#define WH_JOURNALRECORD    0
#define WH_JOURNALPLAYBACK  1

/* Journalling hook codes */
#define HC_GETNEXT	    1
#define HC_SKIP 	    2
#define HC_NOREMOVE	    3
#define HC_NOREM	    HC_NOREMOVE
#define HC_SYSMODALON       4
#define HC_SYSMODALOFF	    5

/* Journalling message structure */
typedef struct tagEVENTMSG
{
    UINT    message;
    UINT    paramL;
    UINT    paramH;
    DWORD   time;
} EVENTMSG;
typedef EVENTMSG *PEVENTMSG;
typedef EVENTMSG NEAR* NPEVENTMSG;
typedef EVENTMSG FAR* LPEVENTMSG;

BOOL    WINAPI EnableHardwareInput(BOOL);

#endif	/* NOWH */


/****** Debugger support ****************************************************/

#if (WINVER >= 0x030a)
/* SetWindowsHook debug hook support */
#define WH_DEBUG	    9

typedef struct tagDEBUGHOOKINFO
{
    HMODULE	hModuleHook;
    LPARAM	reserved;
    LPARAM	lParam;
    WPARAM	wParam;
    int         code;
} DEBUGHOOKINFO;
typedef DEBUGHOOKINFO FAR* LPDEBUGHOOKINFO;

#ifndef NOMSG
BOOL WINAPI QuerySendMessage(HANDLE h1, HANDLE h2, HANDLE h3, LPMSG lpmsg);
#endif  /* NOMSG */

BOOL WINAPI LockInput(HANDLE h1, HWND hwndInput, BOOL fLock);

LONG WINAPI GetSystemDebugState(void);
/* Flags returned by GetSystemDebugState.
 */
#define SDS_MENU        0x0001
#define SDS_SYSMODAL    0x0002
#define SDS_NOTASKQUEUE 0x0004
#define SDS_DIALOG      0x0008
#define SDS_TASKLOCKED  0x0010
#endif  /* WINVER >= 0x030a */

/****** Help support ********************************************************/

#ifndef NOHELP

BOOL WINAPI WinHelp(HWND hwndMain, LPCSTR lpszHelp, UINT usCommand, DWORD ulData);

/* WinHelp() commands */
#define HELP_CONTEXT      0x0001
#define HELP_QUIT         0x0002
#define HELP_INDEX        0x0003
#define HELP_CONTENTS     0x0003
#define HELP_HELPONHELP   0x0004
#define HELP_SETINDEX     0x0005
#define HELP_SETCONTENTS  0x0005
#define HELP_CONTEXTPOPUP 0x0008
#define HELP_FORCEFILE    0x0009
#define HELP_KEY          0x0101
#define HELP_COMMAND      0x0102
#define HELP_PARTIALKEY   0x0105
#define HELP_MULTIKEY     0x0201
#define HELP_SETWINPOS    0x0203

typedef struct tagMULTIKEYHELP
{
    UINT    mkSize;
    BYTE    mkKeylist;
    BYTE    szKeyphrase[1];
} MULTIKEYHELP;


typedef struct
{
    int  wStructSize;
    int  x;
    int  y;
    int  dx;
    int  dy;
    int  wMax;
    char rgchMember[2];
} HELPWININFO;
typedef HELPWININFO NEAR* PHELPWININFO;
typedef HELPWININFO FAR* LPHELPWININFO;

#endif  /* NOHELP */

/****** Sound support ******************************************************/

#ifndef NOSOUND

int     WINAPI OpenSound(void);
void    WINAPI CloseSound(void);

int     WINAPI StartSound(void);
int     WINAPI StopSound(void);

int     WINAPI SetVoiceQueueSize(int, int);
int     WINAPI SetVoiceNote(int, int, int, int);
int     WINAPI SetVoiceAccent(int, int, int, int, int);
int     WINAPI SetVoiceEnvelope(int, int, int);
int     WINAPI SetVoiceSound(int, DWORD, int);

int     WINAPI SetVoiceThreshold(int, int);
int FAR* WINAPI GetThresholdEvent(void);
int     WINAPI GetThresholdStatus(void);

int     WINAPI SetSoundNoise(int, int);

/* SetSoundNoise() Sources */
#define S_PERIOD512   0
#define S_PERIOD1024  1
#define S_PERIOD2048  2
#define S_PERIODVOICE 3
#define S_WHITE512    4
#define S_WHITE1024   5
#define S_WHITE2048   6
#define S_WHITEVOICE  7

int     WINAPI WaitSoundState(int);

/* WaitSoundState() constants */
#define S_QUEUEEMPTY	    0
#define S_THRESHOLD	    1
#define S_ALLTHRESHOLD	    2

int     WINAPI SyncAllVoices(void);
int     WINAPI CountVoiceNotes(int);

/* Accent Modes */
#define S_NORMAL      0
#define S_LEGATO      1
#define S_STACCATO    2

/* Error return values */
#define S_SERDVNA     (-1)
#define S_SEROFM      (-2)
#define S_SERMACT     (-3)
#define S_SERQFUL     (-4)
#define S_SERBDNT     (-5)
#define S_SERDLN      (-6)
#define S_SERDCC      (-7)
#define S_SERDTP      (-8)
#define S_SERDVL      (-9)
#define S_SERDMD      (-10)
#define S_SERDSH      (-11)
#define S_SERDPT      (-12)
#define S_SERDFQ      (-13)
#define S_SERDDR      (-14)
#define S_SERDSR      (-15)
#define S_SERDST      (-16)

#endif  /* NOSOUND */

/****** Comm support ******************************************************/

#ifndef NOCOMM

#define NOPARITY	    0
#define ODDPARITY	    1
#define EVENPARITY	    2
#define MARKPARITY	    3
#define SPACEPARITY	    4

#define ONESTOPBIT	    0
#define ONE5STOPBITS	    1
#define TWOSTOPBITS	    2

#define IGNORE              0
#define INFINITE            0xFFFF

/* Error Flags */
#define CE_RXOVER           0x0001
#define CE_OVERRUN          0x0002
#define CE_RXPARITY         0x0004
#define CE_FRAME            0x0008
#define CE_BREAK            0x0010
#define CE_CTSTO            0x0020
#define CE_DSRTO            0x0040
#define CE_RLSDTO           0x0080
#define CE_TXFULL           0x0100
#define CE_PTO              0x0200
#define CE_IOE              0x0400
#define CE_DNS              0x0800
#define CE_OOP              0x1000
#define CE_MODE             0x8000

#define IE_BADID            (-1)
#define IE_OPEN             (-2)
#define IE_NOPEN            (-3)
#define IE_MEMORY           (-4)
#define IE_DEFAULT          (-5)
#define IE_HARDWARE         (-10)
#define IE_BYTESIZE         (-11)
#define IE_BAUDRATE         (-12)

/* Events */
#define EV_RXCHAR           0x0001
#define EV_RXFLAG           0x0002
#define EV_TXEMPTY          0x0004
#define EV_CTS              0x0008
#define EV_DSR              0x0010
#define EV_RLSD             0x0020
#define EV_BREAK            0x0040
#define EV_ERR              0x0080
#define EV_RING             0x0100
#define EV_PERR             0x0200
#define EV_CTSS             0x0400
#define EV_DSRS             0x0800
#define EV_RLSDS            0x1000
#define EV_RingTe           0x2000
#define EV_RINGTE	    EV_RingTe

/* Escape Functions */
#define SETXOFF             1
#define SETXON              2
#define SETRTS              3
#define CLRRTS              4
#define SETDTR              5
#define CLRDTR              6
#define RESETDEV            7

#define LPTx                0x80

#if (WINVER >= 0x030a)

/* new escape functions */
#define GETMAXLPT           8
#define GETMAXCOM           9
#define GETBASEIRQ          10

/* Comm Baud Rate indices */
#define CBR_110	     0xFF10
#define CBR_300      0xFF11
#define CBR_600      0xFF12
#define CBR_1200     0xFF13
#define CBR_2400     0xFF14
#define CBR_4800     0xFF15
#define CBR_9600     0xFF16
#define CBR_14400    0xFF17
#define CBR_19200    0xFF18
#define CBR_38400    0xFF1B
#define CBR_56000    0xFF1F
#define CBR_128000   0xFF23
#define CBR_256000   0xFF27

/* notifications passed in low word of lParam on WM_COMMNOTIFY messages */
#define CN_RECEIVE  0x0001
#define CN_TRANSMIT 0x0002
#define CN_EVENT    0x0004

#endif  /* WINVER >= 0x030a */

typedef struct tagDCB
{
    BYTE Id;
    UINT BaudRate;
    BYTE ByteSize;
    BYTE Parity;
    BYTE StopBits;
    UINT RlsTimeout;
    UINT CtsTimeout;
    UINT DsrTimeout;

    UINT fBinary        :1;
    UINT fRtsDisable    :1;
    UINT fParity        :1;
    UINT fOutxCtsFlow   :1;
    UINT fOutxDsrFlow   :1;
    UINT fDummy         :2;
    UINT fDtrDisable    :1;

    UINT fOutX          :1;
    UINT fInX           :1;
    UINT fPeChar        :1;
    UINT fNull          :1;
    UINT fChEvt         :1;
    UINT fDtrflow       :1;
    UINT fRtsflow       :1;
    UINT fDummy2        :1;

    char XonChar;
    char XoffChar;
    UINT XonLim;
    UINT XoffLim;
    char PeChar;
    char EofChar;
    char EvtChar;
    UINT TxDelay;
} DCB;
typedef DCB FAR* LPDCB;

#if (defined(STRICT) | (WINVER >= 0x030a))

typedef struct tagCOMSTAT
{
    BYTE status;
    UINT cbInQue;
    UINT cbOutQue;
} COMSTAT;

#define CSTF_CTSHOLD    0x01
#define CSTF_DSRHOLD    0x02
#define CSTF_RLSDHOLD   0x04
#define CSTF_XOFFHOLD   0x08
#define CSTF_XOFFSENT   0x10
#define CSTF_EOF        0x20
#define CSTF_TXIM       0x40

#else   /* (STRICT | WINVER >= 0x030a) */

/* NOTE: This structure declaration is not ANSI compatible! */
typedef struct tagCOMSTAT
{
    BYTE fCtsHold  :1;
    BYTE fDsrHold  :1;
    BYTE fRlsdHold :1;
    BYTE fXoffHold :1;
    BYTE fXoffSent :1;
    BYTE fEof      :1;
    BYTE fTxim     :1;
    UINT cbInQue;
    UINT cbOutQue;
} COMSTAT;

#endif  /* !(STRICT | WINVER >= 0x030a */

int     WINAPI BuildCommDCB(LPCSTR, DCB FAR*);

int     WINAPI OpenComm(LPCSTR, UINT, UINT);
int     WINAPI CloseComm(int);

int     WINAPI ReadComm(int, void FAR*, int);
int     WINAPI WriteComm(int, const void FAR*, int);
int     WINAPI UngetCommChar(int, char);
int     WINAPI FlushComm(int, int);
int     WINAPI TransmitCommChar(int, char);

int     WINAPI SetCommState(const DCB FAR*);
int     WINAPI GetCommState(int, DCB FAR*);
int     WINAPI GetCommError(int, COMSTAT FAR* );

int     WINAPI SetCommBreak(int);
int     WINAPI ClearCommBreak(int);

UINT FAR* WINAPI SetCommEventMask(int, UINT);
UINT    WINAPI GetCommEventMask(int, int);

LONG    WINAPI EscapeCommFunction(int, int);

#if (WINVER >= 0x030a)
BOOL    WINAPI EnableCommNotification(int, HWND, int, int);

#define WM_COMMNOTIFY		0x0044
#endif  /* WINVER >= 0x030a */

#endif  /* NOCOMM */

/****** String formatting support *******************************************/

int     WINAPI wvsprintf(LPSTR lpszOut, LPCSTR lpszFmt, const void FAR* lpParams);

int	FAR CDECL wsprintf(LPSTR lpszOut, LPCSTR lpszFmt, ...);


/****** Driver support ******************************************************/

#if (WINVER >= 0x030a)

#ifndef NODRIVERS

DECLARE_HANDLE(HDRVR);

typedef LRESULT (CALLBACK* DRIVERPROC)(DWORD, HDRVR, UINT, LPARAM, LPARAM);

/* Driver messages */
#define DRV_LOAD		0x0001
#define DRV_ENABLE		0x0002
#define DRV_OPEN		0x0003
#define DRV_CLOSE		0x0004
#define DRV_DISABLE		0x0005
#define DRV_FREE		0x0006
#define DRV_CONFIGURE		0x0007
#define DRV_QUERYCONFIGURE	0x0008
#define DRV_INSTALL		0x0009
#define DRV_REMOVE		0x000A
#define DRV_EXITSESSION         0x000B
#define DRV_EXITAPPLICATION     0x000C
#define DRV_POWER		0x000F

#define DRV_RESERVED		0x0800
#define DRV_USER		0x4000

/* LPARAM of DRV_CONFIGURE message */
typedef struct tagDRVCONFIGINFO
{
    DWORD   dwDCISize;
    LPCSTR  lpszDCISectionName;
    LPCSTR  lpszDCIAliasName;
} DRVCONFIGINFO;
typedef DRVCONFIGINFO NEAR* PDRVCONFIGINFO;
typedef DRVCONFIGINFO FAR* LPDRVCONFIGINFO;

/* Supported return values for DRV_CONFIGURE message */
#define DRVCNF_CANCEL		0x0000
#define DRVCNF_OK		0x0001
#define DRVCNF_RESTART		0x0002

/* Supported lParam1 of DRV_EXITAPPLICATION notification */
#define DRVEA_NORMALEXIT            0x0001
#define DRVEA_ABNORMALEXIT          0x0002

LRESULT WINAPI DefDriverProc(DWORD dwDriverIdentifier, HDRVR driverID, UINT message, LPARAM lParam1, LPARAM lParam2);

HDRVR   WINAPI OpenDriver(LPCSTR szDriverName, LPCSTR szSectionName, LPARAM lParam2);
LRESULT WINAPI CloseDriver(HDRVR hDriver, LPARAM lParam1, LPARAM lParam2);

LRESULT WINAPI SendDriverMessage(HDRVR hDriver, UINT message, LPARAM lParam1, LPARAM lParam2);

HINSTANCE WINAPI GetDriverModuleHandle(HDRVR hDriver);

HDRVR   WINAPI GetNextDriver(HDRVR, DWORD);

/* GetNextDriver flags */
#define GND_FIRSTINSTANCEONLY	0x00000001

#define GND_FORWARD             0x00000000
#define GND_REVERSE		0x00000002

typedef struct tagDRIVERINFOSTRUCT
{
    UINT    length;
    HDRVR   hDriver;
    HINSTANCE hModule;
    char    szAliasName[128];
} DRIVERINFOSTRUCT;
typedef DRIVERINFOSTRUCT FAR* LPDRIVERINFOSTRUCT;

BOOL    WINAPI GetDriverInfo(HDRVR, DRIVERINFOSTRUCT FAR*);

#endif  /* !NODRIVERS */
#endif  /* WINVER >= 0x030a */
#endif  /* NOUSER */

#ifndef RC_INVOKED
#pragma pack()          /* Revert to default packing */
#endif  /* RC_INVOKED */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif	/* __cplusplus */

#endif  /* _INC_WINDOWS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\inc\chicago\verinfo.h ===
#ifdef RC_INVOKED

#include <ver.h>

#define VER_FILEVERSION_STR      "2.3\0"
#define VER_FILEVERSION          2,0030,0041,0060

#define VER_PRODUCTNAME_STR      "Microsoft OLE 2.3 16/32 Interoperability for Windows 95\0"
#define VER_COMPANYNAME_STR      "Microsoft Corporation\0"
#define VER_LEGALTRADEMARKS_STR  "Microsoft\256 is a registered trademark of Microsoft Corporation. Windows(TM) is a trademark of Microsoft Corporation\0"
#define VER_LEGALCOPYRIGHT_STR   "Copyright \251 Microsoft Corp. 1992 - 1995\0"
#define VER_PRODUCTVERSION_STR   "2.3\0"
#define VER_PRODUCTVERSION       2,0030,0041,0060
#define VER_COMMENT_STR          "Windows 95 OLE 16/32 Interoperability DLLs\0"
#define VER_FILETYPE             VFT_DLL
#define VER_FILESUBTYPE          0
#define VER_FILEFLAGSMASK        VS_FFI_FILEFLAGSMASK
#define VER_FILEFLAGS            0L
#define VER_FILEOS               VOS_DOS_WINDOWS32
#define VER_FILEDESCRIPTION_STR  "OLE 2.3 16/32 Interoperability Library\0"

#endif /* RC_INVOKED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\ole2\headers.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	headers.cxx
//
//  Contents:	Precompiled header file
//
//  History:	18-Feb-94	DrewB	Created
//
//----------------------------------------------------------------------------

#include <windows.h>
#include <string.h>
#include <compobj.h>
#include <storage.h>
#include <ole2.h>

#include <interop.hxx>
#include <wow16fn.h>
#include <io16.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\ole2\cdebug.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:		OleAPIs.cxx	(16 bit target)
//
//  Contents:	OLE2 APIs 
//
//  Functions:	
//
//  History:	17-Dec-93 Johann Posch (johannp)    Created
//
//--------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

// cdebug.cpp - implemention of debugstream and IDebug interface/class
/*
#include <olerem.h>	//for RemLookupSHUnk

#pragma SEG(cdebug)
#include <string.h>
#include <toolhelp.h>
*/

//some constants used only in this file
#define DBGMARGIN	45
#define DBGTABSIZE	4
#define HEADER		1
#define NOHEADER	0


#define DBGLOGFILENAME	"debug.log"
static void GetCurDateTime(LPSTR lpsz);


STDAPI_(HFILE) DbgLogOpen(LPSTR lpszFile, LPSTR lpszMode)
{
#ifdef _DEBUG
#ifndef _MAC
	HFILE fh;

	AssertSz( lpszFile && lpszMode, "Invalid arguments to DbgLogOpen");
	
	switch (lpszMode[0]) {
		case 'w':
			// Open for writing (overwrite if exists)
			fh = _lcreat(lpszFile, 0);
			break;

		case 'r':
			// Open for reading
			fh = _lopen(lpszFile, OF_READ);
			break;

		case 'a':
			// Open for appending
			// to append to log file seek to end before writing
			if ((fh = _lopen(lpszFile, OF_READWRITE)) != -1) {
				_llseek(fh, 0L, SEEK_END);
			} else {
				// file does not exist, create a new one.
				fh = _lcreat(lpszFile, 0);
			}
			break;
	}
	return fh;
#endif	//_MAC
#else
 	(void) lpszFile;
	(void) lpszMode;
	return -1;
#endif	//_DEBUG
}


STDAPI_(void) DbgLogClose(HFILE fh)
{
#ifdef _DEBUG
#ifndef _MAC
	if (fh != -1) 
		_lclose(fh);
#endif
#else
	(void) fh;
#endif
}


STDAPI_(void) DbgLogWrite(HFILE fh, LPSTR lpsz)
{
#ifdef _DEBUG
#ifndef _MAC
	if (fh != -1 && lpsz) 
		_lwrite(fh, lpsz, lstrlen(lpsz));
#endif
#else
	(void) fh;
	(void) lpsz;
#endif
}


STDAPI_(void) DbgLogTimeStamp(HFILE fh, LPSTR lpsz)
{
#ifdef _DEBUG
	char buffer[80];

	GetCurDateTime(buffer);
	
	DbgLogOutputDebugString(fh, "\n***************************************\n");
	if (lpsz) DbgLogOutputDebugString(fh, lpsz);
	DbgLogOutputDebugString(fh, ": ");
	DbgLogOutputDebugString(fh, buffer);
	DbgLogOutputDebugString(fh, "\n");
	DbgLogOutputDebugString(fh, ".......................................\n\n");
#else
	(void) fh;
	(void) lpsz;
#endif
}


STDAPI_(void) DbgLogWriteBanner(HFILE fh, LPSTR lpsz)
{
#ifdef _DEBUG
	DbgLogOutputDebugString(fh, "\n***************************************\n");
	if (lpsz) DbgLogOutputDebugString(fh, lpsz);
	DbgLogOutputDebugString(fh, "\n");
	DbgLogOutputDebugString(fh, ".......................................\n\n");
#else
	(void) fh;
	(void) lpsz;
#endif
}


STDAPI_(void) DbgLogOutputDebugString(HFILE fh, LPSTR lpsz)
{
#ifdef _DEBUG
#ifndef _MAC
	if (fh != -1)   
		DbgLogWrite(fh, lpsz);
	OutputDebugString(lpsz);
#endif
#else
	(void)fh;
	(void)lpsz;
#endif
}


#ifdef _DEBUG

static void GetCurDateTime(LPSTR lpsz)
{
	unsigned year, month, day, dayOfweek, hours, min, sec;
    static char FAR* dayNames[7] =
		{ "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat" };
	static char FAR* monthNames[12] = 
        { "Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec" };

#ifndef _MAC
#ifdef WIN32
    SYSTEMTIME st;
    GetLocalTime(&st);
    year = st.wYear;
    month = st.wMonth - 1;
    dayOfweek = st.wDayOfWeek;
    day = st.wDay;
    hours = st.wHour;
    min = st.wMinute;
    sec = st.wSecond;
#else
    _asm {
		// Call GetDate
		mov ah, 0x2a
		int 0x21
		mov year, cx
		mov month, dx
		mov day, dx
		mov dayOfweek, ax

		// Call GetTime
		mov ah, 0x2c
		int 0x21
		mov hours, cx
		mov min, cx
		mov sec, dx
	}
			
	month >>= 8;
	month -= 1;
	day &= 0xFF;
	dayOfweek &= 0xFF;
	hours >>= 8;
	min &= 0xFF;
    sec >>= 8;
#endif	//_WIN32
#else // defined(_MAC)

	// REVIEW MAC -- need function here to get current date & time
	day = 9;
	month = 1;
	year = 1960;
	hours = 12;
	min = 30;
	sec = 17;
	
#endif	//_MAC	

	// Format time as: Wed Jan 02 02:03:55 1990
	// Format time as: Wed 05/02/1992 02:03:55

	wsprintf(lpsz, "%s %s %02d %02d:%02d:%02d %d", 
		dayNames[dayOfweek],monthNames[month], day, hours, min, sec, year);
}


class FAR CDebugLog
{
private:
	HFILE m_fhLog;

public:
	CDebugLog( ) { m_fhLog = -1; }
	CDebugLog( LPSTR lpszFileName );
	~CDebugLog() { DbgLogClose(m_fhLog); }
	HFILE Open(LPSTR lpszFileName, LPSTR lpszMode) 
		{ return (m_fhLog = DbgLogOpen(lpszFileName, lpszMode)); }
	void Close(void) { DbgLogClose(m_fhLog); m_fhLog = -1; }
	void OutputDebugString(LPSTR lpsz) { DbgLogOutputDebugString(m_fhLog, lpsz); }
	void TimeStamp(LPSTR lpsz) { DbgLogTimeStamp(m_fhLog, lpsz); }
	void WriteBanner(LPSTR lpsz) { DbgLogWriteBanner(m_fhLog, lpsz); }

};

#if 0

class FAR CDebugStream
{

public:
	OLESTATIC_(IDebugStream FAR *) Create( // no aggregation
		int margin, int tabsize, BOOL fHeader);

private:
	CDebugStream( int margin, int tabsize, BOOL fHeader );
	~CDebugStream();
	void OutputDebugString( LPSTR lpsz ) {m_DbgLog.OutputDebugString(lpsz);}


implementations:
	implement CDSImpl :  IDebugStream
	{

	public:
		CDSImpl( CDebugStream FAR * pDebugStream )
			{ m_pDebugStream = pDebugStream; }
		~CDSImpl( void ) ; //{ if (m_pDebugStream->m_pendingReturn) ForceReturn(); }
		void PrintString( LPSTR );
		void ForceReturn( void );
		void ReturnIfPending( void );
		OLEMETHOD(QueryInterface)(REFIID iid, LPVOID FAR* ppvObj );
		OLEMETHOD_(ULONG,AddRef)( void );
		OLEMETHOD_(ULONG,Release)( void );

		OLEMETHOD_(IDebugStream&, operator << ) ( IUnknown FAR * pDebug );
		OLEMETHOD_(IDebugStream&, operator << ) ( REFCLSID rclsid );
		OLEMETHOD_(IDebugStream&, operator << ) ( int n );
		OLEMETHOD_(IDebugStream&, operator << ) ( long l );
		OLEMETHOD_(IDebugStream&, operator << ) ( ULONG l );
		OLEMETHOD_(IDebugStream&, operator << ) ( LPSTR sz );
		OLEMETHOD_(IDebugStream&, operator << ) ( char ch );
		OLEMETHOD_(IDebugStream&, operator << ) ( void FAR * pv );
		OLEMETHOD_(IDebugStream&, operator << ) ( CBool b );
		OLEMETHOD_(IDebugStream&, operator << ) ( CAtom atom );
		OLEMETHOD_(IDebugStream&, operator << ) ( CHwnd hwnd );
		OLEMETHOD_(IDebugStream&, Tab) ( void );
		OLEMETHOD_(IDebugStream&, Indent) ( void );
		OLEMETHOD_(IDebugStream&, UnIndent) ( void );
		OLEMETHOD_(IDebugStream&, Return) ( void );
		OLEMETHOD_(IDebugStream&, LF) ( void );
		CDebugStream FAR * m_pDebugStream;
	};
	DECLARE_NC(CDebugStream,CDSImpl)

	CDSImpl m_DebugStream;

shared_state:
	ULONG m_refs;
	int m_indent;
	int m_position;
	int m_margin;
	int m_tabsize;
	BOOL m_pendingReturn;
	CDebugLog m_DbgLog;
};
#endif

#endif // _DEBUG



/*
 *	The member variable m_pendingReturn is a hack to allow
 *	the sequence of operations Return, UnIndent put the character
 *	at the *beginning of the unindented line*  The debugwindow does
 *	not seem to support going to the beginning of the line or
 *	backspacing, so we do not actually do a Return until we know
 *	that the next operation is not UnIndent.
 *	
 */



/*
 *	Implementation of per process list heads
 */

#ifdef NEVER		// per-proces debug lists not used

static IDebug FAR * GetIDHead()
{
	if this gets enabled, the map should be in the etask
}

static void SetIDHead(IDebug FAR* pIDHead)
{
	if this gets enabled, the map should be in the etask
}

#endif // NEVER


/*
 *	Implementation of IDebug constructor and destructor
 */


#ifdef NEVER
__export IDebug::IDebug( void )
{
    SETPVTBL(IDebug);
//#ifdef _DEBUG
	BOOL fIsShared = (SHARED == PlacementOf(this));
	IDebug FAR* pIDHead = (fIsShared ? pIDHeadShared : GetIDHead());

	pIDPrev = NULL;
	if (pIDHead)
		pIDHead->pIDPrev = this;
	pIDNext = pIDHead;
	if (fIsShared) pIDHeadShared = this;
	else SetIDHead(this);
}
#endif	//NEVER	


#ifdef NEVER
__export IDebug::~IDebug( void )
{
//#ifdef _DEBUG
	BOOL fIsShared = (SHARED == PlacementOf(this));
	if (pIDPrev)
		pIDPrev->pIDNext = pIDNext;
	else
		if (fIsShared) pIDHeadShared = pIDNext;
		else
			SetIDHead(pIDNext);
	if (pIDNext)
		pIDNext->pIDPrev = pIDPrev;
}
#endif	//NEVER	
 
//REVIEW:  maybe we should expose this later
STDAPI OleGetClassID( LPUNKNOWN pUnk, LPCLSID lpclsid )
{
	HRESULT hresult = NOERROR;
#if 0
	LPRUNNABLEOBJECT lpRunnableObject = NULL;
	LPPERSIST lpPersist = NULL;
	
	VDATEIFACE(pUnk);
	VDATEPTROUT(lpclsid, LPCLSID);

	*lpclsid = CLSID_NULL;
				
	pUnk->QueryInterface(IID_IRunnableObject, (LPLPVOID)&lpRunnableObject);
	if( lpRunnableObject ){
		hresult = lpRunnableObject->GetRunningClass(lpclsid);
		lpRunnableObject->Release();
	} else {	
		pUnk->QueryInterface(IID_IPersist, (LPLPVOID)&lpPersist);
		if( lpPersist ){
			hresult = lpPersist->GetClassID( lpclsid );
			lpPersist->Release();
		}
	}
#endif
	return hresult;
}

#ifdef _DEBUG

CDebugStream::CDebugStream( int margin, int tabsize, BOOL fHeader) : m_DebugStream(this)
{
#ifndef _MAC
	static BOOL fAppendFile = FALSE;
	
	// Create the debug log file. Overwrite the existing file if it exists.
	m_DbgLog.Open(DBGLOGFILENAME, (fAppendFile ? "a" : "w"));

	if( fHeader )	
		// only add creation timestamp to top of file.
		if (! fAppendFile) {
			m_DbgLog.TimeStamp("Created");
			fAppendFile = TRUE;
		} else {
			m_DbgLog.WriteBanner(NULL);
		}
#endif
	m_indent = 0;
	m_position = m_indent;
	m_margin = margin;
	m_tabsize = tabsize;
	m_refs = 1;
	m_pendingReturn = FALSE;
}


CDebugStream::~CDebugStream()
{
	m_DbgLog.Close();
}


NC(CDebugStream,CDSImpl)::~CDSImpl(void)
{
	 if (m_pDebugStream->m_pendingReturn) ForceReturn(); 
}


OLEMETHODIMP NC(CDebugStream,CDSImpl)::QueryInterface(REFIID iidInterface,
	void FAR* FAR* ppvObj )
{
	VDATEPTROUT(ppvObj, LPLPVOID);

	if (iidInterface == IID_IUnknown || iidInterface == IID_IDebugStream) {
		*ppvObj = (void FAR *)this;
		return NOERROR;
	} else {
		*ppvObj = NULL;
		return ReportResult(0, E_NOINTERFACE, 0, 0);
	}
}


OLEMETHODIMP_(ULONG) NC(CDebugStream,CDSImpl)::AddRef( void )
{
	return ++m_pDebugStream->m_refs;
}


OLEMETHODIMP_(ULONG) NC(CDebugStream,CDSImpl)::Release( void )
{
	if (--m_pDebugStream->m_refs == 0) {
		delete m_pDebugStream;
		return 0;
	}

	return m_pDebugStream->m_refs;
}


OLEMETHODIMP_(IDebugStream&) NC(CDebugStream,CDSImpl)::operator << (int n)
{
	char buffer[12];
	ReturnIfPending();
	buffer[wsprintf(buffer, "%d", n)] = '\0';
	PrintString(buffer);
	return *this;
}

OLEMETHODIMP_(IDebugStream&) NC(CDebugStream,CDSImpl)::operator << (long l)
{
	char buffer[16];
	ReturnIfPending();
	buffer[wsprintf(buffer, "%ld", l)] = '\0';
	PrintString(buffer);
	return *this;
}

OLEMETHODIMP_(IDebugStream&) NC(CDebugStream,CDSImpl)::operator << (ULONG l)
{
	char buffer[16];
	ReturnIfPending();
	buffer[wsprintf(buffer, "%lu", l)] = '\0';
	PrintString(buffer);
	return *this;
}

OLEMETHODIMP_(IDebugStream&) NC(CDebugStream,CDSImpl)::operator << (CAtom atom)
{
	char buffer[128];
	ReturnIfPending();
	
	if( (ATOM)atom ){
		if( !GetAtomName((ATOM)atom, (LPSTR)buffer, sizeof(buffer)) )
			buffer[wsprintf(buffer, "Invalid atom")] = '\0';
	}else
		buffer[wsprintf(buffer, "NULL atom")] = '\0';
		
	PrintString(buffer);
	return *this;
}

OLEMETHODIMP_(IDebugStream&) NC(CDebugStream,CDSImpl)::operator << (CHwnd hwnd)
{
	char szBuf[128];
	
	ReturnIfPending();

	if( (HWND)hwnd )
		szBuf[wsprintf(szBuf, "window handle: %x", (HWND)hwnd)] = '\0';
	else
		szBuf[wsprintf(szBuf, "NULL window handle")] = '\0';

	PrintString(szBuf);		
	return *this;
}

LPSTR FindBreak( LPSTR sz, int currentPosition, int margin )
{
	LPSTR szBreak = sz;
	LPSTR szPtr = sz;

	if( !sz )
		return NULL;
	
	while (*szPtr)
	{
		while (*(szPtr) && *(szPtr++) <= ' ');
		while (*(szPtr) && *(szPtr++) > ' ');
		if (currentPosition+(szPtr-sz) < margin)
		{
			szBreak = szPtr;
		}
		else return szBreak;
	}
	return szPtr;
}

/*
 *	PrintString is an internal utility routine that can assume that
 *	everything in the string (other than the null at the end) is >=
 *	' '.  Thus it knows that when it prints a single character, the
 *	position on the debug terminal advances a single columm.  This
 *	would not be the case if the string could contain tabs,
 *	returns, etc.
 */


void NC(CDebugStream,CDSImpl)::PrintString (LPSTR sz)
{
	//	assert sz != NULL
	LPSTR szUnprinted = sz;
	LPSTR szPtr = sz;
	char chSave;

	#ifdef _MAC
	Puts(sz);
	return;
	#endif
	
	if( !sz )
		return;
	
	while (*szUnprinted)
	{
		szPtr = FindBreak( szUnprinted, m_pDebugStream->m_position, m_pDebugStream->m_margin );
		if (szPtr == szUnprinted && m_pDebugStream->m_position > m_pDebugStream->m_indent)
		{
			Return();
			szPtr = FindBreak( szUnprinted, m_pDebugStream->m_position, m_pDebugStream->m_margin );
			if (szPtr == szUnprinted)	//	text won't fit even after word wrapping
			{
				m_pDebugStream->OutputDebugString(szUnprinted);
				m_pDebugStream->m_position += _fstrlen(szUnprinted);
				return;
			}
		}
		chSave = *szPtr;
		*szPtr = '\0';
		if (m_pDebugStream->m_position == m_pDebugStream->m_indent)		//	no text on line, skip blanks
		{
			while (*szUnprinted == ' ') szUnprinted++;
		}
		m_pDebugStream->OutputDebugString(szUnprinted);
		*szPtr = chSave;
		m_pDebugStream->m_position += (szPtr - szUnprinted);
		szUnprinted = szPtr;
	}
}


OLEMETHODIMP_(IDebugStream&) NC(CDebugStream,CDSImpl)::operator << (char ch)
{
	char buffer[2] = "a";
	if (ch=='\n') Return();
	else if (ch=='\t') Tab();
	else if (ch >= ' ')
	{
		ReturnIfPending();
		if (m_pDebugStream->m_position >= m_pDebugStream->m_margin) Return();
		*buffer = ch;
		m_pDebugStream->OutputDebugString(buffer);
		m_pDebugStream->m_position++;
	}
	return *this;
}


OLEMETHODIMP_(IDebugStream&) NC(CDebugStream,CDSImpl)::operator << (LPSTR sz)
{
	LPSTR szCopy;
	char chSave;
	LPSTR szPtr;
	LPSTR szPtrSave;

	ReturnIfPending();
	
	if (!sz)
		return *this;

	szCopy = new FAR (TASK) char[2+_fstrlen(sz)];
	if (!szCopy)
	{
		Return();
		PrintString("Memory allocation error in DebugStream");
		Return();
		return *this;
	}
	
	_fstrcpy( szCopy, sz );	
	for (szPtr = szCopy, szPtrSave = szCopy; *szPtr; szPtr++)
	{
		if ( *szPtr < ' ')	// we hit a control character or the end
		{
			chSave = *szPtr;
			*szPtr = '\0';
			PrintString( szPtrSave );
			if (chSave != '\0')
				*szPtr = chSave;
			szPtrSave = szPtr+1;
			switch (chSave)
			{
				case '\t':  Tab();
							break;
				case '\n':	Return();
							break;
				case '\r':	m_pDebugStream->OutputDebugString("\r");
							break;
				default:
							break;
			}
		}
	}
	PrintString( szPtrSave );

	delete szCopy;

	return *this;
}

OLEMETHODIMP_(IDebugStream&) NC(CDebugStream,CDSImpl)::operator << (CBool b)
{
	ReturnIfPending();
	if (b) PrintString("TRUE");
	else PrintString("FALSE");
	return *this;
}


OLEMETHODIMP_(IDebugStream&) NC(CDebugStream,CDSImpl)::operator << ( void FAR * pv )
{
	char buffer[12];
	LPSTR sz = "NULL";
	ReturnIfPending();
	if (pv != NULL)
	{
		buffer[wsprintf(buffer, "%lX", pv)] = '\0';
		sz = buffer;
	}
	PrintString(sz);
	return *this;
}


OLEMETHODIMP_(IDebugStream&) NC(CDebugStream,CDSImpl)::operator <<
	( REFCLSID rclsid )
{
	char sz[256];
	
	// REVIEW: do lookup in reg.dat for user type name
 
 	if( rclsid == CLSID_NULL )
 		_fstrcpy(sz, "NULL CLSID");
	else if (StringFromCLSID2(rclsid, sz, sizeof(sz)) == 0)
		_fstrcpy(sz, "Unknown CLSID");

	*this << sz;

	return *this;
}


OLEMETHODIMP_(IDebugStream&) NC(CDebugStream,CDSImpl)::operator <<
	( IUnknown FAR * pUnk )
{
	IDebug FAR * pDebug = NULL;
	CLSID	clsid = CLSID_NULL;

	ReturnIfPending();
	
	if( IsValidInterface(pUnk) ){
		pUnk->QueryInterface(IID_IDebug, (void FAR* FAR*)&pDebug);
		if (pDebug) {
			pDebug->Dump( this );
			if ( !pDebug->IsValid( 0 ) )
				*this << "Object is not valid" << '\n';
			/*
			 * NB: Debug interfaces are *not* ref counted (so as not to skew the
			 * counts of the objects they are debugging! :)
			 */
		 } else {
		 	OleGetClassID(pUnk, (LPCLSID)&clsid);
			*this << clsid << " @ "<<(VOID FAR *)pUnk << " doesn't support debug dumping";
		}
	} else if (!pUnk)
		*this << "NULL interface";
	else
		*this << "Invalid interface @ " << (VOID FAR *)pUnk;
		
	return *this;
}

OLEMETHODIMP_(IDebugStream&) NC(CDebugStream,CDSImpl)::Tab( void )
{
	ReturnIfPending();
	int advance = m_pDebugStream->m_tabsize * ( 1 + m_pDebugStream->m_position/m_pDebugStream->m_tabsize) - m_pDebugStream->m_position;

	if (m_pDebugStream->m_position + advance < m_pDebugStream->m_margin)
	{
		for (int i = 0; i < advance; i++) 
			m_pDebugStream->OutputDebugString(" ");
		m_pDebugStream->m_position += advance;
	}
	return *this;
}

OLEMETHODIMP_(IDebugStream&) NC(CDebugStream,CDSImpl)::Indent( void )
{
	if (m_pDebugStream->m_indent + m_pDebugStream->m_tabsize < m_pDebugStream->m_margin)
		m_pDebugStream->m_indent += m_pDebugStream->m_tabsize;
	if (!m_pDebugStream->m_pendingReturn)
		while (m_pDebugStream->m_position < m_pDebugStream->m_indent)
			operator<<(' ');
		
	return *this;
}

OLEMETHODIMP_(IDebugStream&) NC(CDebugStream,CDSImpl)::UnIndent( void )
{
	if (m_pDebugStream->m_indent > 0) m_pDebugStream->m_indent -= m_pDebugStream->m_tabsize;
	return *this;
}


void NC(CDebugStream,CDSImpl)::ForceReturn( void )
{
	m_pDebugStream->OutputDebugString("\n");
	for (int i = 0; i<m_pDebugStream->m_indent; i++) 
		m_pDebugStream->OutputDebugString(" ");
	m_pDebugStream->m_position = m_pDebugStream->m_indent;
	m_pDebugStream->m_pendingReturn = FALSE;
}

void NC(CDebugStream,CDSImpl)::ReturnIfPending( void )
{
	if (m_pDebugStream->m_pendingReturn) ForceReturn();
}



OLEMETHODIMP_(IDebugStream&) NC(CDebugStream,CDSImpl)::Return( void )
{
	ReturnIfPending();
	m_pDebugStream->m_pendingReturn = TRUE;
    Yield();           // let dbwin get control
	return *this;
}

OLEMETHODIMP_(IDebugStream&) NC(CDebugStream,CDSImpl)::LF( void )
{
	return Return();
}

OLESTATICIMP_(IDebugStream FAR *) CDebugStream::Create( // no aggregation
		int margin, int tabsize, BOOL fHeader )
{
	CDebugStream FAR * pcds = new FAR (TASK)CDebugStream( margin, tabsize, fHeader );
	if( !pcds ){
		AssertSz( pcds, "Out of Memory");
		return NULL;
	}
	return &(pcds->m_DebugStream);
}
#endif // _DEBUG


#if 0
STDAPI_(IDebugStream FAR *) MakeDebugStream( short margin, short tabsize, BOOL fHeader)
{
#ifdef _DEBUG
	return CDebugStream::Create( margin, tabsize, fHeader );
#else
	(void) margin;
	(void) tabsize;
	(void) fHeader;
	return NULL;
#endif // _DEBUG
}
#else
STDAPI_(void FAR *) MakeDebugStream( short margin, short tabsize, BOOL fHeader)
{
	return NULL;
}
#endif


//
// IDebug helpers
//

STDAPI_(void) DbgDumpObject( IUnknown FAR * pUnk, DWORD dwReserved )
{
#ifdef _DEBUG
	IDebugStream FAR * pcds = MakeDebugStream( DBGMARGIN, DBGTABSIZE, NOHEADER );
 	(void)dwReserved;
 	
	if( pcds ) {	
		*pcds << pUnk;
		pcds->Return();
		pcds->Release();
	}
#else
	(void) pUnk;
	(void) dwReserved;
#endif	
}
 
STDAPI_(void) DbgDumpExternalObject( IUnknown FAR * pUnk, DWORD dwReserved )
{ 
#ifdef _DEBUG
	SHREG shreg;
	
	(void) dwReserved;

	if( IsValidInterface(pUnk) ){
		if( RemLookupSHUnk(pUnk, NULL, &shreg) == NOERROR ){
			DbgDumpObject(shreg.m_pSM, 0);
			shreg.m_pSM->Release();
		}
	}

#else
	(void) dwReserved;
	(void) pUnk;
#endif
}

STDAPI_(BOOL) DbgIsObjectValid( IUnknown FAR * pUnk )
{
#ifdef _DEBUG
	BOOL	fReturn = TRUE;	//	default value for objects that don't
							//	support IDebug
	IDebug FAR * pDebug = NULL;
	
	if( IsValidInterface(pUnk) ){
		pUnk->QueryInterface( IID_IDebug, (void FAR* FAR*)&pDebug);
		if (pDebug)
			fReturn = pDebug->IsValid();
		//IDebug is not addref'd
		return fReturn;
	}
	return FALSE;
#else
	(void) pUnk;
	return TRUE;
#endif
}


STDAPI_(void) DbgDumpClassName( IUnknown FAR * pUnk )
{
#ifdef _DEBUG
	CLSID clsid;

	IDebugStream FAR * pcds = MakeDebugStream( DBGMARGIN, DBGTABSIZE, NOHEADER );
	
	if( pcds ) {
        if( IsValidInterface(pUnk) ){
 			OleGetClassID( pUnk, (LPCLSID)&clsid);
			*pcds << clsid << " @ " << (void FAR* )pUnk << '\n';
		}else if (!pUnk)
			*pcds << "NULL interface" << '\n';
		else
			*pcds << (void FAR *)pUnk << " is not a valid interface" << '\n';
		pcds->Release();
	}
#else
	(void)pUnk;
#endif
}

STDAPI_(void) DumpAllObjects( void )
{
//#ifdef _DEBUG
#ifdef NEVER
	IDebug FAR * pID = GetIDHead();
	IDebugStream FAR * pcds = MakeDebugStream( DBGMARGIN, DBGTABSIZE, NOHEADER );

	*pcds << "----TASK OBJECTS-------\n";
	while (pID)
	{
		pID->Dump( pcds );
		pID = pID->pIDNext;
	}
	*pcds << "----SHARED OBJECTS-------\n";
	pID = pIDHeadShared;
	while (pID)
	{
		pID->Dump( pcds );
		pID = pID->pIDNext;
	}

	pcds->Release();
#endif
}


STDAPI_(BOOL) ValidateAllObjects( BOOL fSuspicious )
{
//#ifdef _DEBUG
#ifdef NEVER
	IDebug FAR * pID = GetIDHead();
	int pass = 0;
	IDebugStream FAR * pcds = MakeDebugStream( DBGMARGIN, DBGTABSIZE, NOHEADER);
	BOOL fReturn = TRUE;

	while (pID)
	{
		if (!(pID->IsValid(fSuspicious)))
		{
			fReturn = FALSE;
			if (pass == 0)
				*pcds <<
					"\n****INVALID OBJECT*****\n";
			else
				*pcds << "\n****INVALID SHARED MEMORY OBJECT*****\n";
			pID->Dump( pcds );
			pcds->Return();
		}
		pID = pID->pIDNext;
		if ((pID == NULL) && (pass++ == 0))
			pID = pIDHeadShared;
	}
	pcds->Release();
	return fReturn;
#endif 	//NEVER
	(void) fSuspicious;
    return TRUE;
}


#ifdef _DEBUG


extern "C"
BOOL CALLBACK __loadds DebCallBack(WORD wID, DWORD dwData)
{
//    char rgchBuf[50];
////    BOOL    fTraceStack = FALSE;
////    STACKTRACEENTRY ste;
////    WORD wSS, wCS, wIP, wBP;
//    NFYLOADSEG FAR* pNFY = (NFYLOADSEG FAR *)dwData;
//
//    if (wID == NFY_LOADSEG)
//    {
//        if (0 == _fstrcmp(pNFY->lpstrModuleName,"OLE2"))
//        {
//            wsprintf(rgchBuf, "Load seg %02x(%#04x), module %s", pNFY->wSegNum,
//                pNFY->wSelector, pNFY->lpstrModuleName);
//            OutputDebugString(rgchBuf);
//            _asm int 3
////            if (fTraceStack)
////            {
////                _asm mov wSS, SS
////                _asm mov wCS, CS
////                _asm mov wIP, IP
////                _asm mov wBP, BP
////                ste.dwSize = sizeof(STACKTRACEENTRY);
////                if (StackTraceCSIPFirst(&ste, wSS, wCS, wIP, wBP))
////                {
////                    while (fTraceStack && StackTraceNext(&ste));
////                }
////        
////            }
//        }
//    }
//    else if (wID == NFY_FREESEG)
//    {
//    }
	(void) wID;
	(void) dwData;
    return FALSE;
}

BOOL InstallHooks(void)
{
//    return NotifyRegister(NULL, (LPFNNOTIFYCALLBACK)DebCallBack, NF_NORMAL);
return TRUE;
}

BOOL UnInstallHooks()
{
//    return NotifyUnRegister(NULL);
return TRUE;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\ole2\inplace.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	inplace.h
//
//  Contents:	inplace.h from OLE2
//
//  History:	11-Apr-94	DrewB	Copied from OLE2
//
//----------------------------------------------------------------------------

#if !defined( _INPLACE_H_ )
#define _INPLACE_H_

// This ACCEL structure and the related constants definitions come with WIN32.
// Win31 also uses the same stuff internally but it's not exposed in the 
// header files. 

#ifndef FVIRTKEY 

#define FVIRTKEY  TRUE		// Assumed to be == TRUE
#define FLASTKEY  0x80		// Indicates last key in the table
#define FNOINVERT 0x02
#define FSHIFT	  0x04
#define FCONTROL  0x08
#define FALT	  0x10

#pragma pack(1)
typedef struct tagACCEL {	// Accelerator Table structure
	BYTE	fVirt;
	WORD	key;
	WORD	cmd;
} ACCEL, FAR* LPACCEL;
#pragma pack()

#endif // FVIRTKEY


typedef struct tagOLEMENUITEM {
	UINT	item;
	WORD	fwPopup;
	BOOL	fObjectMenu;
} OLEMENUITEM;
typedef OLEMENUITEM FAR* LPOLEMENUITEM;

typedef struct tagOLEMENU {
	WORD						wSignature;
	HWND						hwndFrame;
	HMENU						hmenuCombined;
	OLEMENUGROUPWIDTHS			MenuWidths;
	LONG						lMenuCnt;
	OLEMENUITEM					menuitem[1];
} OLEMENU;
typedef OLEMENU FAR* LPOLEMENU;


class FAR CFrameFilter 
{
public:
	static HRESULT Create(HOLEMENU hOleMenu, HMENU hmenuCombined, 
				HWND hwndFrame,	HWND hwndActiveObj,	
				LPOLEINPLACEFRAME lpFrame, 
				LPOLEINPLACEACTIVEOBJECT lpActiveObj);
		
	CFrameFilter (HWND hwndFrame, HWND hwndActiveObj);		
	~CFrameFilter(void);
	
	inline LRESULT	OnSysCommand(UINT uParam, LONG lParam);
	inline void		OnEnterMenuMode(void);
	inline void		OnExitMenuMode(void);
	inline void		OnEnterAltTabMode(void);
	inline void		OnExitAltTabMode(void);	
	inline LRESULT	OnMessage(UINT msg, UINT uParam, LONG lParam);	
	inline void		IsObjectMenu (UINT uMenuItem, UINT fwMenu);
	inline BOOL		IsMenuCollision(UINT uParam, LONG lParam);	
	inline BOOL		DoContextSensitiveHelp();
		
private:
	HWND						m_hwndObject;
	HWND						m_hwndFrame;
	LPOLEINPLACEFRAME			m_lpFrame;
	LPOLEINPLACEACTIVEOBJECT	m_lpObject;
	WNDPROC						m_lpfnPrevWndProc;
	BOOL						m_fObjectMenu;
	BOOL						m_fCurItemPopup;
	BOOL						m_fInMenuMode;
	BOOL						m_fDiscardWmCommand;
	BOOL						m_fGotMenuCloseEvent;
	UINT						m_cmdId;
	UINT						m_uCurItemID;
	HOLEMENU					m_hOleMenu;
	HMENU						m_hmenuCombined;
	HWND						m_hwndFocusOnEnter;
	int							m_cAltTab;
};

typedef CFrameFilter FAR* PCFRAMEFILTER;


OLEAPI_(LRESULT) FrameWndFilterProc (HWND hwnd, UINT msg, UINT uParam, 	LONG lParam);
OLEAPI_(LRESULT) MessageFilterProc(int nCode, WPARAM wParam, LPARAM lParam);

BOOL IsMDIAccelerator(LPMSG lpMsg, WORD FAR* cmd);

inline PCFRAMEFILTER wGetFrameFilterPtr(HWND hwndFrame);

LPOLEMENU	wGetOleMenuPtr(HOLEMENU holemenu);
inline void	wReleaseOleMenuPtr(HOLEMENU holemenu);

inline UINT wSysKeyToKey(LPMSG lpMsg);

#endif // _INPLACE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\ole2\icon.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	icon.cxx
//
//  Contents:	icon.cpp from OLE2
//
//  History:	11-Apr-94	DrewB	Copied from OLE2
//
//----------------------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

/*
 *  ICON.CPP
 *
 *  Functions to create DVASPECT_ICON metafile from filename or classname.
 *
 *  OleGetIconOfFile
 *  OleGetIconOfClass
 *  OleMetafilePictFromIconAndLabel
 *
 *  HIconAndSourceFromClass Extracts the first icon in a class's server path
 *                          and returns the path and icon index to caller.
 *  FIconFileFromClass      Retrieves the path to the exe/dll containing the
 *                           default icon, and the index of the icon.
 *  OleStdIconLabelTextOut
 *  PointerToNthField
 *  XformWidthInPixelsToHimetric  Converts an int width into HiMetric units
 *  XformWidthInHimetricToPixels  Converts an int width from HiMetric units
 *  XformHeightInPixelsToHimetric Converts an int height into HiMetric units
 *  XformHeightInHimetricToPixels Converts an int height from HiMetric units
 *
 *    (c) Copyright Microsoft Corp. 1992-1993 All Rights Reserved
 */

#include <ole2int.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <commdlg.h>
#include <memory.h>
#include <cderr.h>

#include "icon.h"

static char szMaxWidth[] ="WWWWWWWWWW";

//Strings for metafile comments.
static char szIconOnly[]="IconOnly";        //Where to stop to exclude label.

#define OLEUI_CCHKEYMAX      256
#define OLEUI_CCHPATHMAX     256
#define OLEUI_CCHLABELMAX     40

#define ICONINDEX              0

#define AUXUSERTYPE_SHORTNAME  USERCLASSTYPE_SHORT  // short name
#define HIMETRIC_PER_INCH   2540      // number HIMETRIC units per inch
#define PTS_PER_INCH          72      // number points (font size) per inch

#define MAP_PIX_TO_LOGHIM(x,ppli)   MulDiv(HIMETRIC_PER_INCH, (x), (ppli))
#define MAP_LOGHIM_TO_PIX(x,ppli)   MulDiv((ppli), (x), HIMETRIC_PER_INCH)

static char szVanillaDocIcon[] = "DefIcon";

static char szDocument[OLEUI_CCHLABELMAX] = "";
static char szSeparators[] = " \t\\/!:";
static const char szDefIconLabelKey[] = "Software\\Microsoft\\OLE2\\DefaultIconLabel";

#define IS_SEPARATOR(c)         ( (c) == ' ' || (c) == '\\' || (c) == '/' || (c) == '\t' || (c) == '!' || (c) == ':' )
#define IS_FILENAME_DELIM(c)    ( (c) == '\\' || (c) == '/' || (c) == ':' )

#define LSTRCPYN(lpdst, lpsrc, cch) \
(\
	lpdst[cch-1] = '\0', \
	lstrcpyn(lpdst, lpsrc, cch-1)\
)


/*******
 *
 * ICON METAFILE FORMAT:
 *
 * The metafile generated with OleMetafilePictFromIconAndLabel contains
 * the following records which are used by the functions in DRAWICON.C
 * to draw the icon with and without the label and to extract the icon,
 * label, and icon source/index.
 *
 *  SetWindowOrg
 *  SetWindowExt
 *  DrawIcon:
 *      Inserts records of DIBBITBLT or DIBSTRETCHBLT, once for the
 *      AND mask, one for the image bits.
 *  Escape with the comment "IconOnly"
 *      This indicates where to stop record enumeration to draw only
 *      the icon.
 *  SetTextColor
 *  SetBkColor
 *  CreateFont
 *  SelectObject on the font.
 *  ExtTextOut
 *      One or more ExtTextOuts occur if the label is wrapped.  The
 *      text in these records is used to extract the label.
 *  SelectObject on the old font.
 *  DeleteObject on the font.
 *  Escape with a comment that contains the path to the icon source.
 *  Escape with a comment that is the ASCII of the icon index.
 *
 *******/




/*
 * OleGetIconOfFile(LPSTR lpszPath, BOOL fUseFileAsLabel)
 *
 * Purpose:
 *  Returns a hMetaPict containing an icon and label (filename) for the
 *  specified filename.
 *
 * Parameters:
 *  lpszPath        LPSTR path including filename to use
 *  fUseFileAsLabel BOOL TRUE if the icon's label is the filename, FALSE if
 *                  there should be no label.
 *
 * Return Value:
 *  HGLOBAL         hMetaPict containing the icon and label - if there's no
 *                  class in reg db for the file in lpszPath, then we use
 *                  Document.  If lpszPath is NULL, then we return NULL.
 */

STDAPI_(HGLOBAL) OleGetIconOfFile(LPSTR lpszPath, BOOL fUseFileAsLabel)
{


  char     szIconFile[OLEUI_CCHPATHMAX];
  char     szLabel[OLEUI_CCHLABELMAX];
  LPSTR    lpszClsid = NULL;
  CLSID    clsid;
  HICON    hDefIcon = NULL;
  UINT     IconIndex = 0;
  HGLOBAL  hMetaPict;
  HRESULT  hResult;

  if (NULL == lpszPath)  // even if fUseFileAsLabel is FALSE, we still
    return NULL;             // need a valid filename to get the class.

  hResult = GetClassFile(lpszPath, &clsid);

  if (NOERROR == hResult)  // use the clsid we got to get to the icon
  {
      hDefIcon = HIconAndSourceFromClass(clsid,
                                         (LPSTR)szIconFile,
                                         &IconIndex);
  }

  if ( (NOERROR != hResult) || (NULL == hDefIcon) )
  {
     // Here, either GetClassFile failed or HIconAndSourceFromClass failed.

     LPSTR lpszTemp;

     lpszTemp = lpszPath;

     while ((*lpszTemp != '.') && (*lpszTemp != '\0'))
        lpszTemp++;


     if ('.' != *lpszTemp)
       goto UseVanillaDocument;


     if (FALSE == GetAssociatedExecutable(lpszTemp, (LPSTR)szIconFile))
       goto UseVanillaDocument;

     hDefIcon = ExtractIcon(hmodOLE2, szIconFile, IconIndex);
  }

  if (hDefIcon <= (HICON)1) // ExtractIcon returns 1 if szExecutable is not exe,
  {                         // 0 if there are no icons.
UseVanillaDocument:

	GetModuleFileName(hmodOLE2, (LPSTR)szIconFile, OLEUI_CCHPATHMAX);
    IconIndex = ICONINDEX;
    hDefIcon = LoadIcon(hmodOLE2, (LPSTR)szVanillaDocIcon);
  }

  // Now let's get the label we want to use.

  if (fUseFileAsLabel)   // strip off path, so we just have the filename.
  {
     int istrlen;
     LPSTR lpszBeginFile;

     istrlen = lstrlen(lpszPath);

     // set pointer to END of path, so we can walk backwards through it.
     lpszBeginFile = lpszPath + istrlen -1;

     while ( (lpszBeginFile >= lpszPath)
             && (!IS_FILENAME_DELIM(*lpszBeginFile)) )
      lpszBeginFile--;


     lpszBeginFile++;  // step back over the delimiter


     LSTRCPYN(szLabel, lpszBeginFile, sizeof(szLabel));
  }

  else   // use the short user type (AuxUserType2) for the label
  {

      if (0 == OleStdGetAuxUserType(clsid, AUXUSERTYPE_SHORTNAME,
                                   (LPSTR)szLabel, OLEUI_CCHLABELMAX, NULL)) {

         if ('\0'==szDocument[0]) {
		 	LONG cb = sizeof (szDocument);
		 	RegQueryValue (HKEY_CLASSES_ROOT, szDefIconLabelKey, szDocument,
							&cb);
			// if szDocument is not big enough, RegQueryValue puts a NULL
			// at the end so we are safe.
			// if RegQueryValue fails, szDocument[0]=='\0' so we'll use that.
         }
         lstrcpy(szLabel, szDocument);
      }
  }


  hMetaPict = OleMetafilePictFromIconAndLabel(hDefIcon,
                                                szLabel,
                                                (LPSTR)szIconFile,
                                                IconIndex);

  DestroyIcon(hDefIcon);

  return hMetaPict;

}

/*
 * GetAssociatedExecutable
 *
 * Purpose:  Finds the executable associated with the provided extension
 *
 * Parameters:
 *   lpszExtension   LPSTR points to the extension we're trying to find an exe
 *                   for. Does **NO** validation.
 *
 *   lpszExecutable  LPSTR points to where the exe name will be returned.
 *                   No validation here either - pass in 128 char buffer.
 *
 * Return:
 *   BOOL            TRUE if we found an exe, FALSE if we didn't.
 *
 */

BOOL FAR PASCAL GetAssociatedExecutable(LPSTR lpszExtension, LPSTR lpszExecutable)

{
   HKEY    hKey;
   LONG	   dw;
   LRESULT lRet;
   char    szValue[OLEUI_CCHKEYMAX];
   char    szKey[OLEUI_CCHKEYMAX];
   LPSTR   lpszTemp, lpszExe;


   lRet = RegOpenKey(HKEY_CLASSES_ROOT, NULL, &hKey);

   if (ERROR_SUCCESS != lRet)
      return FALSE;

   dw = OLEUI_CCHPATHMAX;
   lRet = RegQueryValue(hKey, lpszExtension, (LPSTR)szValue, &dw);  //ProgId

   if (ERROR_SUCCESS != lRet)
   {
      RegCloseKey(hKey);
      return FALSE;
   }


   // szValue now has ProgID
   lstrcpy(szKey, szValue);
   lstrcat(szKey, "\\Shell\\Open\\Command");


   dw = OLEUI_CCHPATHMAX;
   lRet = RegQueryValue(hKey, (LPSTR)szKey, (LPSTR)szValue, &dw);

   if (ERROR_SUCCESS != lRet)
   {
      RegCloseKey(hKey);
      return FALSE;
   }

   // szValue now has an executable name in it.  Let's null-terminate
   // at the first post-executable space (so we don't have cmd line
   // args.

   lpszTemp = (LPSTR)szValue;

   while (('\0' != *lpszTemp) && (isspace(*lpszTemp)))
      lpszTemp++;     // Strip off leading spaces

   lpszExe = lpszTemp;

   while (('\0' != *lpszTemp) && (!isspace(*lpszTemp)))
      lpszTemp++;     // Set through exe name

   *lpszTemp = '\0';  // null terminate at first space (or at end).


   lstrcpy(lpszExecutable, lpszExe);

   return TRUE;

}





/*
 * OleGetIconOfClass(REFCLSID rclsid, LPSTR lpszLabel, BOOL fUseTypeAsLabel)
 *
 * Purpose:
 *  Returns a hMetaPict containing an icon and label (human-readable form
 *  of class) for the specified clsid.
 *
 * Parameters:
 *  rclsid          REFCLSID pointing to clsid to use.
 *  lpszLabel       label to use for icon.
 *  fUseTypeAsLabel Use the clsid's user type name as the icon's label.
 *
 * Return Value:
 *  HGLOBAL         hMetaPict containing the icon and label - if we
 *                  don't find the clsid in the reg db then we
 *                  return NULL.
 */

STDAPI_(HGLOBAL) OleGetIconOfClass(REFCLSID rclsid, LPSTR lpszLabel, BOOL fUseTypeAsLabel)
{

  char    szLabel[OLEUI_CCHLABELMAX];
  char    szIconFile[OLEUI_CCHPATHMAX];
  HICON   hDefIcon;
  UINT    IconIndex;
  HGLOBAL hMetaPict;

  if (!fUseTypeAsLabel)  // Use string passed in as label
  {
    if (NULL != lpszLabel)
       LSTRCPYN(szLabel, lpszLabel, sizeof(szLabel));
    else
       *szLabel = '\0';
  }
  else   // Use AuxUserType2 (short name) as label
  {

      if (0 == OleStdGetAuxUserType(rclsid,
                                    AUXUSERTYPE_SHORTNAME,
                                    (LPSTR)szLabel,
                                    OLEUI_CCHLABELMAX,
                                    NULL))

       // If we can't get the AuxUserType2, then try the long name
       if (0 == OleStdGetUserTypeOfClass(rclsid, szLabel, OLEUI_CCHKEYMAX, NULL)) {
         if ('\0'==szDocument[0]) {
		 	LONG cb = sizeof (szDocument);
		 	RegQueryValue (HKEY_CLASSES_ROOT, szDefIconLabelKey, szDocument,
							&cb);
			// if RegQueryValue fails, szDocument=="" so we'll use that.
         }
         lstrcpy(szLabel, szDocument);  // last resort
       }
  }

  // Get the icon, icon index, and path to icon file
  hDefIcon = HIconAndSourceFromClass(rclsid,
                  (LPSTR)szIconFile,
                  &IconIndex);

  if (NULL == hDefIcon)  // Use Vanilla Document
  {
    GetModuleFileName(hmodOLE2, (LPSTR)szIconFile, OLEUI_CCHPATHMAX);
    IconIndex = ICONINDEX;
    hDefIcon = LoadIcon(hmodOLE2, (LPSTR)szVanillaDocIcon);
  }

  // Create the metafile
  hMetaPict = OleMetafilePictFromIconAndLabel(hDefIcon, szLabel,
                                                (LPSTR)szIconFile, IconIndex);

  DestroyIcon(hDefIcon);

  return hMetaPict;

}





/*
 * HIconAndSourceFromClass
 *
 * Purpose:
 *  Given an object class name, finds an associated executable in the
 *  registration database and extracts the first icon from that
 *  executable.  If none is available or the class has no associated
 *  executable, this function returns NULL.
 *
 * Parameters:
 *  rclsid          pointer to clsid to look up.
 *  pszSource       LPSTR in which to place the source of the icon.
 *                  This is assumed to be OLEUI_CCHPATHMAX
 *  puIcon          UINT FAR * in which to store the index of the
 *                  icon in pszSource.
 *
 * Return Value:
 *  HICON           Handle to the extracted icon if there is a module
 *                  associated to pszClass.  NULL on failure to either
 *                  find the executable or extract and icon.
 */

HICON FAR PASCAL HIconAndSourceFromClass(REFCLSID rclsid, LPSTR pszSource, UINT FAR *puIcon)
    {
    HICON           hIcon;
    UINT            IconIndex;

    if (CLSID_NULL==rclsid || NULL==pszSource)
        return NULL;

    if (!FIconFileFromClass(rclsid, pszSource, OLEUI_CCHPATHMAX, &IconIndex))
        return NULL;

    hIcon=ExtractIcon(hmodOLE2, pszSource, IconIndex);

    if ((HICON)32 > hIcon)
        hIcon=NULL;
    else
        *puIcon= IconIndex;

    return hIcon;
    }



/*
 * FIconFileFromClass
 *
 * Purpose:
 *  Looks up the path to executable that contains the class default icon.
 *
 * Parameters:
 *  rclsid          pointer to CLSID to look up.
 *  pszEXE          LPSTR at which to store the server name
 *  cch             UINT size of pszEXE
 *  lpIndex         LPUINT to index of icon within executable
 *
 * Return Value:
 *  BOOL            TRUE if one or more characters were loaded into pszEXE.
 *                  FALSE otherwise.
 */

BOOL FAR PASCAL FIconFileFromClass(REFCLSID rclsid, LPSTR pszEXE, UINT cch, UINT FAR *lpIndex)
{

    LONG          dw;
    LONG          lRet;
    HKEY          hKey;
    LPMALLOC      lpIMalloc;
    HRESULT       hrErr;
    LPSTR         lpBuffer;
    LPSTR         lpIndexString;
    UINT          cBufferSize = 136;  // room for 128 char path and icon's index
    char          szKey[64];
    LPSTR         pszClass;


    if (CLSID_NULL==rclsid || NULL==pszEXE || 0==cch)
        return FALSE;

    //Here, we use CoGetMalloc and alloc a buffer (maxpathlen + 8) to
    //pass to RegQueryValue.  Then, we copy the exe to pszEXE and the
    //index to *lpIndex.

    hrErr = CoGetMalloc(MEMCTX_TASK, &lpIMalloc);

    if (NOERROR != hrErr)
      return FALSE;

    lpBuffer = (LPSTR)lpIMalloc->Alloc(cBufferSize);

    if (NULL == lpBuffer)
    {
      lpIMalloc->Release();
      return FALSE;
    }


    if (CoIsOle1Class(rclsid))
    {

      LPSTR lpszProgID;

      // we've got an ole 1.0 class on our hands, so we look at
      // progID\protocol\stdfileedting\server to get the
      // name of the executable.

      ProgIDFromCLSID(rclsid, &lpszProgID);

      //Open up the class key
      lRet=RegOpenKey(HKEY_CLASSES_ROOT, lpszProgID, &hKey);

      if (ERROR_SUCCESS != lRet)
      {
         lpIMalloc->Free(lpszProgID);
         lpIMalloc->Free(lpBuffer);
         lpIMalloc->Release();
         return FALSE;
      }

      dw=(LONG)cBufferSize;
      lRet = RegQueryValue(hKey, "Protocol\\StdFileEditing\\Server", lpBuffer, &dw);

      if (ERROR_SUCCESS != lRet)
      {

         RegCloseKey(hKey);
         lpIMalloc->Free(lpszProgID);
         lpIMalloc->Free(lpBuffer);
         lpIMalloc->Release();
         return FALSE;
      }


      // Use server and 0 as the icon index
      LSTRCPYN(pszEXE, lpBuffer, cch);

      *lpIndex = 0;

      RegCloseKey(hKey);
      lpIMalloc->Free(lpszProgID);
      lpIMalloc->Free(lpBuffer);
      lpIMalloc->Release();
      return TRUE;

    }



    /*
     * We have to go walking in the registration database under the
     * classname, so we first open the classname key and then check
     * under "\\DefaultIcon" to get the file that contains the icon.
     */

    StringFromCLSID(rclsid, &pszClass);

    lstrcpy(szKey, "CLSID\\");
    lstrcat(szKey, pszClass);

    //Open up the class key
    lRet=RegOpenKey(HKEY_CLASSES_ROOT, szKey, &hKey);

    if (ERROR_SUCCESS != lRet)
    {
        lpIMalloc->Free(lpBuffer);
        lpIMalloc->Free(pszClass);
        lpIMalloc->Release();
        return FALSE;
    }

    //Get the executable path and icon index.

    dw=(LONG)cBufferSize;
    lRet=RegQueryValue(hKey, "DefaultIcon", lpBuffer, &dw);

    if (ERROR_SUCCESS != lRet)
    {
      // no DefaultIcon  key...try LocalServer

      dw=(LONG)cBufferSize;
      lRet=RegQueryValue(hKey, "LocalServer", lpBuffer, &dw);

      if (ERROR_SUCCESS != lRet)
      {
         // no LocalServer entry either...they're outta luck.

         RegCloseKey(hKey);
         lpIMalloc->Free(lpBuffer);
         lpIMalloc->Free(pszClass);
         lpIMalloc->Release();
         return FALSE;
      }


      // Use server from LocalServer or Server and 0 as the icon index
      LSTRCPYN(pszEXE, lpBuffer, cch);

      *lpIndex = 0;

      RegCloseKey(hKey);
      lpIMalloc->Free(lpBuffer);
      lpIMalloc->Free(pszClass);
      lpIMalloc->Release();
      return TRUE;
    }

    RegCloseKey(hKey);

    // lpBuffer contains a string that looks like "<pathtoexe>,<iconindex>",
    // so we need to separate the path and the icon index.

    lpIndexString = PointerToNthField(lpBuffer, 2, ',');

    if ('\0' == *lpIndexString)  // no icon index specified - use 0 as default.
    {
       *lpIndex = 0;

    }
    else
    {
       LPSTR lpTemp;
       static char  szTemp[16];

       lstrcpy((LPSTR)szTemp, lpIndexString);

       // Put the icon index part into *pIconIndex
       *lpIndex = atoi((const char *)szTemp);

       // Null-terminate the exe part.
       lpTemp = AnsiPrev(lpBuffer, lpIndexString);
       *lpTemp = '\0';
    }

    if (!LSTRCPYN(pszEXE, lpBuffer, cch))
    {
       lpIMalloc->Free(lpBuffer);
       lpIMalloc->Free(pszClass);
       lpIMalloc->Release();
       return FALSE;
    }

    // Free the memory we alloc'd and leave.
    lpIMalloc->Free(lpBuffer);
    lpIMalloc->Free(pszClass);
    lpIMalloc->Release();
    return TRUE;
}




/*
 * OleMetafilePictFromIconAndLabel
 *
 * Purpose:
 *  Creates a METAFILEPICT structure that container a metafile in which
 *  the icon and label are drawn.  A comment record is inserted between
 *  the icon and the label code so our special draw function can stop
 *  playing before the label.
 *
 * Parameters:
 *  hIcon           HICON to draw into the metafile
 *  pszLabel        LPSTR to the label string.
 *  pszSourceFile   LPSTR containing the local pathname of the icon
 *                  as we either get from the user or from the reg DB.
 *  iIcon           UINT providing the index into pszSourceFile where
 *                  the icon came from.
 *
 * Return Value:
 *  HGLOBAL         Global memory handle containing a METAFILEPICT where
 *                  the metafile uses the MM_ANISOTROPIC mapping mode.  The
 *                  extents reflect both icon and label.
 */

STDAPI_(HGLOBAL) OleMetafilePictFromIconAndLabel(HICON hIcon, LPSTR pszLabel
    , LPSTR pszSourceFile, UINT iIcon)
    {
    HDC             hDC, hDCScreen;
    HMETAFILE       hMF;
    HGLOBAL         hMem;
    LPMETAFILEPICT  pMF;
    UINT            cxIcon, cyIcon;
    UINT            cxText, cyText;
    UINT            cx, cy;
    UINT            cchLabel = 0;
    HFONT           hFont, hSysFont, hFontT;
    int             cyFont;
    char            szIndex[10];
    RECT            TextRect;
    SIZE            size;
    POINT           point;
    LOGFONT         logfont;

    if (NULL==hIcon)  // null icon is valid
        return NULL;

    //Create a memory metafile
    hDC=(HDC)CreateMetaFile(NULL);

    if (NULL==hDC)
        return NULL;

    //Allocate the metafilepict
    hMem=GlobalAlloc(GMEM_MOVEABLE | GMEM_DDESHARE, sizeof(METAFILEPICT));

    if (NULL==hMem)
        {
        hMF=CloseMetaFile(hDC);
        DeleteMetaFile(hMF);
        return NULL;
        }


    if (NULL!=pszLabel)
        {
        cchLabel=lstrlen(pszLabel);

        if (cchLabel >= OLEUI_CCHLABELMAX)
           pszLabel[cchLabel] = '\0';   // truncate string
        }

    //Need to use the screen DC for these operations
    hDCScreen=GetDC(NULL);
    cyFont=-(8*GetDeviceCaps(hDCScreen, LOGPIXELSY))/72;

    //cyFont was calculated to give us 8 point.

    //  We use the system font as the basis for the character set,
    //  allowing us to handle DBCS strings better
    hSysFont = GetStockObject( SYSTEM_FONT );
    GetObject(hSysFont, sizeof(LOGFONT), &logfont);
    hFont=CreateFont(cyFont, 5, 0, 0, FW_NORMAL, 0, 0, 0, logfont.lfCharSet
             , OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, PROOF_QUALITY
             , FF_SWISS, "MS Sans Serif");

    hFontT=SelectObject(hDCScreen, hFont);

    GetTextExtentPoint(hDCScreen,szMaxWidth,lstrlen(szMaxWidth),&size);
    SelectObject(hDCScreen, hFontT);

    cxText = size.cx;
    cyText = size.cy * 2;

    cxIcon = GetSystemMetrics(SM_CXICON);
    cyIcon = GetSystemMetrics(SM_CYICON);


    // If we have no label, then we want the metafile to be the width of
    // the icon (plus margin), not the width of the fattest string.
    if ( (NULL == pszLabel) || (NULL == *pszLabel) )
        cx = cxIcon + cxIcon / 4;
    else
        cx = max(cxText, cxIcon);

    cy=cyIcon+cyText+4;

    //Set the metafile size to fit the icon and label
    SetWindowOrgEx(hDC, 0, 0, &point);
    SetWindowExtEx(hDC, cx, cy, &size);

    //Set up rectangle to pass to OleStdIconLabelTextOut
    SetRectEmpty(&TextRect);

    TextRect.right = cx;
    TextRect.bottom = cy;

    //Draw the icon and the text, centered with respect to each other.
    DrawIcon(hDC, (cx-cxIcon)/2, 0, hIcon);

    //String that indicates where to stop if we're only doing icons
    Escape(hDC, MFCOMMENT, lstrlen(szIconOnly)+1, szIconOnly, NULL);

    SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT));
    SetBkMode(hDC, TRANSPARENT);

    OleStdIconLabelTextOut(hDC,
                           hFont,
                           0,
                           cy - cyText,
                           ETO_CLIPPED,
                           &TextRect,
                           pszLabel,
                           cchLabel,
                           NULL);

    //Write comments containing the icon source file and index.
    if (NULL!=pszSourceFile)
        {
        //+1 on string lengths insures the null terminator is embedded.
        Escape(hDC, MFCOMMENT, lstrlen(pszSourceFile)+1, pszSourceFile, NULL);

        cchLabel=wsprintf(szIndex, "%u", iIcon);
        Escape(hDC, MFCOMMENT, cchLabel+1, szIndex, NULL);
        }

    //All done with the metafile, now stuff it all into a METAFILEPICT.
    hMF=CloseMetaFile(hDC);

    if (NULL==hMF)
        {
        GlobalFree(hMem);
		ReleaseDC(NULL, hDCScreen);
        return NULL;
        }

    //Fill out the structure
    pMF=(LPMETAFILEPICT)GlobalLock(hMem);

    //Transform to HIMETRICS
    cx=XformWidthInPixelsToHimetric(hDCScreen, cx);
    cy=XformHeightInPixelsToHimetric(hDCScreen, cy);
	ReleaseDC(NULL, hDCScreen);
	
    pMF->mm=MM_ANISOTROPIC;
    pMF->xExt=cx;
    pMF->yExt=cy;
    pMF->hMF=hMF;

    GlobalUnlock(hMem);

    DeleteObject(hFont);

    return hMem;
    }



/*
 * OleStdIconLabelTextOut
 *
 * Purpose:
 *  Replacement for DrawText to be used in the "Display as Icon" metafile.
 *  Uses ExtTextOut to output a string center on (at most) two lines.
 *  Uses a very simple word wrap algorithm to split the lines.
 *
 * Parameters:  (same as for ExtTextOut, except for hFont)
 *  hDC           device context to draw into; if this is NULL, then we don't
 *                ETO the text, we just return the index of the beginning
 *                of the second line
 *  hFont         font to use
 *  nXStart       x-coordinate of starting position
 *  nYStart       y-coordinate of starting position
 *  fuOptions     rectangle type
 *  lpRect        rect far * containing rectangle to draw text in.
 *  lpszString    string to draw
 *  cchString     length of string (truncated if over OLEUI_CCHLABELMAX)
 *  lpDX          spacing between character cells
 *
 * Return Value:
 *  UINT          Index of beginning of last line (0 if there's only one
 *                line of text).
 *
 */

STDAPI_(UINT) OleStdIconLabelTextOut(HDC        hDC,
                                     HFONT      hFont,
                                     int        nXStart,
                                     int        nYStart,
                                     UINT       fuOptions,
                                     RECT FAR * lpRect,
                                     LPSTR      lpszString,
                                     UINT       cchString,
                                     int FAR *  lpDX)
{

  HDC          hDCScreen;
  static char  szTempBuff[OLEUI_CCHLABELMAX];
  int          cxString, cyString, cxMaxString;
  int          cxFirstLine, cyFirstLine, cxSecondLine;
  int          index;
  int          cch = cchString;
  char         chKeep;
  LPSTR        lpszSecondLine;
  HFONT        hFontT;
  BOOL         fPrintText = TRUE;
  UINT         iLastLineStart = 0;
  SIZE         size;

  // Initialization stuff...

  if (NULL == hDC)  // If we got NULL as the hDC, then we don't actually call ETO
    fPrintText = FALSE;


  // Make a copy of the string (NULL or non-NULL) that we're using
  if (NULL == lpszString)
    *szTempBuff = '\0';

  else
    LSTRCPYN(szTempBuff, lpszString, sizeof(szTempBuff));

  // set maximum width
  cxMaxString = lpRect->right - lpRect->left;

  // get screen DC to do text size calculations
  hDCScreen = GetDC(NULL);

  hFontT=SelectObject(hDCScreen, hFont);

  // get the extent of our label
  GetTextExtentPoint(hDCScreen, szTempBuff, cch, &size);

  cxString = size.cx;
  cyString = size.cy;

  // Select in the font we want to use
  if (fPrintText)
     SelectObject(hDC, hFont);

  // String is smaller than max string - just center, ETO, and return.
  if (cxString <= cxMaxString)
  {

    if (fPrintText)
       ExtTextOut(hDC,
                  nXStart + (lpRect->right - cxString) / 2,
                  nYStart,
                  fuOptions,
                  lpRect,
                  szTempBuff,
                  cch,
                  NULL);

    iLastLineStart = 0;  // only 1 line of text
    goto CleanupAndLeave;
  }

  // String is too long...we've got to word-wrap it.


  // Are there any spaces, slashes, tabs, or bangs in string?

  if (lstrlen(szTempBuff) != (int)strcspn(szTempBuff, szSeparators))
  {
     // Yep, we've got spaces, so we'll try to find the largest
     // space-terminated string that will fit on the first line.

     index = cch;


     while (index >= 0)
     {

       char cchKeep;

       // scan the string backwards for spaces, slashes, tabs, or bangs

       while (!IS_SEPARATOR(szTempBuff[index]) )
         index--;


       if (index <= 0)
         break;

       cchKeep = szTempBuff[index];  // remember what char was there

       szTempBuff[index] = '\0';  // just for now

       GetTextExtentPoint(
               hDCScreen, (LPSTR)szTempBuff,lstrlen((LPSTR)szTempBuff),&size);

       cxFirstLine = size.cx;
       cyFirstLine = size.cy;

       szTempBuff[index] = cchKeep;   // put the right char back

       if (cxFirstLine <= cxMaxString)
       {

           iLastLineStart = index + 1;

           if (!fPrintText)
             goto CleanupAndLeave;

           ExtTextOut(hDC,
                      nXStart +  (lpRect->right - cxFirstLine) / 2,
                      nYStart,
                      fuOptions,
                      lpRect,
                      (LPSTR)szTempBuff,
                      index + 1,
                      lpDX);

           lpszSecondLine = (LPSTR)szTempBuff;

           lpszSecondLine += index + 1;

           GetTextExtentPoint(hDCScreen,
                                    lpszSecondLine,
                                    lstrlen(lpszSecondLine),
                                    &size);

           // If the second line is wider than the rectangle, we
           // just want to clip the text.
           cxSecondLine = min(size.cx, cxMaxString);

           ExtTextOut(hDC,
                      nXStart + (lpRect->right - cxSecondLine) / 2,
                      nYStart + cyFirstLine,
                      fuOptions,
                      lpRect,
                      lpszSecondLine,
                      lstrlen(lpszSecondLine),
                      lpDX);

           goto CleanupAndLeave;

       }  // end if

       index--;

     }  // end while

  }  // end if

  // Here, there are either no spaces in the string (strchr(szTempBuff, ' ')
  // returned NULL), or there spaces in the string, but they are
  // positioned so that the first space terminated string is still
  // longer than one line. So, we walk backwards from the end of the
  // string until we find the largest string that will fit on the first
  // line , and then we just clip the second line.

  cch = lstrlen((LPSTR)szTempBuff);

  chKeep = szTempBuff[cch];
  szTempBuff[cch] = '\0';

  GetTextExtentPoint(hDCScreen, szTempBuff, lstrlen(szTempBuff),&size);

  cxFirstLine = size.cx;
  cyFirstLine = size.cy;

  while (cxFirstLine > cxMaxString)
  {
     // We allow 40 characters in the label, but the metafile is
     // only as wide as 10 W's (for aesthetics - 20 W's wide looked
     // dumb.  This means that if we split a long string in half (in
     // terms of characters), then we could still be wider than the
     // metafile.  So, if this is the case, we just step backwards
     // from the halfway point until we get something that will fit.
     // Since we just let ETO clip the second line

     szTempBuff[cch--] = chKeep;
     if (0 == cch)
       goto CleanupAndLeave;

     chKeep = szTempBuff[cch];
     szTempBuff[cch] = '\0';

     GetTextExtentPoint(
             hDCScreen, szTempBuff, lstrlen(szTempBuff), &size);
     cxFirstLine = size.cx;
  }

  iLastLineStart = cch;

  if (!fPrintText)
    goto CleanupAndLeave;

  ExtTextOut(hDC,
             nXStart + (lpRect->right - cxFirstLine) / 2,
             nYStart,
             fuOptions,
             lpRect,
             (LPSTR)szTempBuff,
             lstrlen((LPSTR)szTempBuff),
             lpDX);

  szTempBuff[cch] = chKeep;
  lpszSecondLine = szTempBuff;
  lpszSecondLine += cch;

  GetTextExtentPoint(
          hDCScreen, (LPSTR)lpszSecondLine, lstrlen(lpszSecondLine), &size);

  // If the second line is wider than the rectangle, we
  // just want to clip the text.
  cxSecondLine = min(size.cx, cxMaxString);

  ExtTextOut(hDC,
             nXStart + (lpRect->right - cxSecondLine) / 2,
             nYStart + cyFirstLine,
             fuOptions,
             lpRect,
             lpszSecondLine,
             lstrlen(lpszSecondLine),
             lpDX);

CleanupAndLeave:
  SelectObject(hDCScreen, hFontT);
  ReleaseDC(NULL, hDCScreen);
  return iLastLineStart;

}


/*
 * OleStdGetUserTypeOfClass(REFCLSID, LPSTR, UINT, HKEY)
 *
 * Purpose:
 *  Returns the user type (human readable class name) of the specified class.
 *
 * Parameters:
 *  rclsid          pointer to the clsid to retrieve user type of.
 *  lpszUserType    pointer to buffer to return user type in.
 *  cch             length of buffer pointed to by lpszUserType
 *  hKey            hKey for reg db - if this is NULL, then we
 *                   open and close the reg db within this function.  If it
 *                   is non-NULL, then we assume it's a valid key to the
 *                   \ root and use it without closing it. (useful
 *                   if you're doing lots of reg db stuff).
 *
 * Return Value:
 *  UINT            Number of characters in returned string.  0 on error.
 *
 */
STDAPI_(UINT) OleStdGetUserTypeOfClass(REFCLSID rclsid, LPSTR lpszUserType, UINT cch, HKEY hKey)
{

   LONG     dw;
   LONG     lRet;
   LPSTR    lpszCLSID, lpszProgID;
   BOOL     fFreeProgID = FALSE;
   BOOL     bCloseRegDB = FALSE;
   char     szKey[128];
   LPMALLOC lpIMalloc;

   if (hKey == NULL)
   {

     //Open up the root key.
     lRet=RegOpenKey(HKEY_CLASSES_ROOT, NULL, &hKey);

     if ((LONG)ERROR_SUCCESS!=lRet)
       return (UINT)FALSE;

     bCloseRegDB = TRUE;
   }

   // Get a string containing the class name
   StringFromCLSID(rclsid, &lpszCLSID);

   wsprintf(szKey, "CLSID\\%s", lpszCLSID);


   dw=cch;
   lRet = RegQueryValue(hKey, szKey, lpszUserType, &dw);

   if ((LONG)ERROR_SUCCESS!=lRet)
       dw = 0;

   if ( ((LONG)ERROR_SUCCESS!=lRet) && (CoIsOle1Class(rclsid)) )
   {
      // We've got an OLE 1.0 class, so let's try to get the user type
      // name from the ProgID entry.

      ProgIDFromCLSID(rclsid, &lpszProgID);
      fFreeProgID = TRUE;

      dw = cch;
      lRet = RegQueryValue(hKey, lpszProgID, lpszUserType, &dw);

      if ((LONG)ERROR_SUCCESS != lRet)
        dw = 0;
   }


   if (NOERROR == CoGetMalloc(MEMCTX_TASK, &lpIMalloc))
   {
       if (fFreeProgID)
         lpIMalloc->Free((LPVOID)lpszProgID);

       lpIMalloc->Free((LPVOID)lpszCLSID);
       lpIMalloc->Release();
   }

   if (bCloseRegDB)
      RegCloseKey(hKey);

   return (UINT)dw;

}



/*
 * OleStdGetAuxUserType(RCLSID, WORD, LPSTR, int, HKEY)
 *
 * Purpose:
 *  Returns the specified AuxUserType from the reg db.
 *
 * Parameters:
 *  rclsid          pointer to the clsid to retrieve aux user type of.
 *  hKey            hKey for reg db - if this is NULL, then we
 *                   open and close the reg db within this function.  If it
 *                   is non-NULL, then we assume it's a valid key to the
 *                   \ root and use it without closing it. (useful
 *                   if you're doing lots of reg db stuff).
 *  wAuxUserType    which aux user type field to look for.  In 4/93 release
 *                  2 is short name and 3 is exe name.
 *  lpszUserType    pointer to buffer to return user type in.
 *  cch             length of buffer pointed to by lpszUserType
 *
 * Return Value:
 *  UINT            Number of characters in returned string.  0 on error.
 *
 */
STDAPI_(UINT) OleStdGetAuxUserType(REFCLSID rclsid,
                                   WORD     wAuxUserType,
                                   LPSTR    lpszAuxUserType,
                                   int      cch,
                                   HKEY     hKey)
{
   HKEY     hThisKey;
   BOOL     fCloseRegDB = FALSE;
   LONG     dw;
   LRESULT  lRet;
   LPSTR    lpszCLSID;
   LPMALLOC lpIMalloc;
   char     szKey[OLEUI_CCHKEYMAX];
   char     szTemp[32];

   lpszAuxUserType[0] = '\0';

   if (NULL == hKey)
   {
      lRet = RegOpenKey(HKEY_CLASSES_ROOT, NULL, &hThisKey);

      if (ERROR_SUCCESS != lRet)
          return 0;
   }
   else
      hThisKey = hKey;

   StringFromCLSID(rclsid, &lpszCLSID);

   lstrcpy(szKey, "CLSID\\");
   lstrcat(szKey, lpszCLSID);
   wsprintf(szTemp, "\\AuxUserType\\%d", wAuxUserType);
   lstrcat(szKey, szTemp);

   dw = cch;

   lRet = RegQueryValue(hThisKey, szKey, lpszAuxUserType, &dw);

   if (ERROR_SUCCESS != lRet) {
     dw = 0;
     lpszAuxUserType[0] = '\0';
   }


   if (fCloseRegDB)
      RegCloseKey(hThisKey);

   if (NOERROR == CoGetMalloc(MEMCTX_TASK, &lpIMalloc))
   {
       lpIMalloc->Free((LPVOID)lpszCLSID);
       lpIMalloc->Release();
   }

   return (UINT)dw;
}



/*
 * PointerToNthField
 *
 * Purpose:
 *  Returns a pointer to the beginning of the nth field.
 *  Assumes null-terminated string.
 *
 * Parameters:
 *  lpszString        string to parse
 *  nField            field to return starting index of.
 *  chDelimiter       char that delimits fields
 *
 * Return Value:
 *  LPSTR             pointer to beginning of nField field.
 *                    NOTE: If the null terminator is found
 *                          Before we find the Nth field, then
 *                          we return a pointer to the null terminator -
 *                          calling app should be sure to check for
 *                          this case.
 *
 */
LPSTR FAR PASCAL PointerToNthField(LPSTR lpszString, int nField, char chDelimiter)
{
   LPSTR lpField = lpszString;
   int   cFieldFound = 1;

   if (1 ==nField)
      return lpszString;

   while (*lpField != '\0')
   {

      if (*lpField++ == chDelimiter)
      {

         cFieldFound++;

         if (nField == cFieldFound)
            return lpField;
      }
   }

   return lpField;

}



/*
 * XformWidthInPixelsToHimetric
 * XformWidthInHimetricToPixels
 * XformHeightInPixelsToHimetric
 * XformHeightInHimetricToPixels
 *
 * Functions to convert an int between a device coordinate system and
 * logical HiMetric units.
 *
 * Parameters:
 *  hDC             HDC providing reference to the pixel mapping.  If
 *                  NULL, a screen DC is used.
 *
 *  Size Functions:
 *  lpSizeSrc       LPSIZEL providing the structure to convert.  This
 *                  contains pixels in XformSizeInPixelsToHimetric and
 *                  logical HiMetric units in the complement function.
 *  lpSizeDst       LPSIZEL providing the structure to receive converted
 *                  units.  This contains pixels in
 *                  XformSizeInPixelsToHimetric and logical HiMetric
 *                  units in the complement function.
 *
 *  Width Functions:
 *  iWidth          int containing the value to convert.
 *
 * Return Value:
 *  Size Functions:     None
 *  Width Functions:    Converted value of the input parameters.
 *
 * NOTE:
 *  When displaying on the screen, Window apps display everything enlarged
 *  from its actual size so that it is easier to read. For example, if an
 *  app wants to display a 1in. horizontal line, that when printed is
 *  actually a 1in. line on the printed page, then it will display the line
 *  on the screen physically larger than 1in. This is described as a line
 *  that is "logically" 1in. along the display width. Windows maintains as
 *  part of the device-specific information about a given display device:
 *      LOGPIXELSX -- no. of pixels per logical in along the display width
 *      LOGPIXELSY -- no. of pixels per logical in along the display height
 *
 *  The following formula converts a distance in pixels into its equivalent
 *  logical HIMETRIC units:
 *
 *      DistInHiMetric = (HIMETRIC_PER_INCH * DistInPix)
 *                       -------------------------------
 *                           PIXELS_PER_LOGICAL_IN
 *
 */
STDAPI_(int) XformWidthInPixelsToHimetric(HDC hDC, int iWidthInPix)
    {
    int     iXppli;     //Pixels per logical inch along width
    int     iWidthInHiMetric;
    BOOL    fSystemDC=FALSE;

    if (NULL==hDC)
        {
        hDC=GetDC(NULL);
        fSystemDC=TRUE;
        }

    iXppli = GetDeviceCaps (hDC, LOGPIXELSX);

    //We got pixel units, convert them to logical HIMETRIC along the display
    iWidthInHiMetric = MAP_PIX_TO_LOGHIM(iWidthInPix, iXppli);

    if (fSystemDC)
        ReleaseDC(NULL, hDC);

    return iWidthInHiMetric;
    }


STDAPI_(int) XformWidthInHimetricToPixels(HDC hDC, int iWidthInHiMetric)
    {
    int     iXppli;     //Pixels per logical inch along width
    int     iWidthInPix;
    BOOL    fSystemDC=FALSE;

    if (NULL==hDC)
        {
        hDC=GetDC(NULL);
        fSystemDC=TRUE;
        }

    iXppli = GetDeviceCaps (hDC, LOGPIXELSX);

    //We got logical HIMETRIC along the display, convert them to pixel units
    iWidthInPix = MAP_LOGHIM_TO_PIX(iWidthInHiMetric, iXppli);

    if (fSystemDC)
        ReleaseDC(NULL, hDC);

    return iWidthInPix;
    }


STDAPI_(int) XformHeightInPixelsToHimetric(HDC hDC, int iHeightInPix)
    {
    int     iYppli;     //Pixels per logical inch along height
    int     iHeightInHiMetric;
    BOOL    fSystemDC=FALSE;

    if (NULL==hDC)
        {
        hDC=GetDC(NULL);
        fSystemDC=TRUE;
        }

    iYppli = GetDeviceCaps (hDC, LOGPIXELSY);

    //* We got pixel units, convert them to logical HIMETRIC along the display
    iHeightInHiMetric = MAP_PIX_TO_LOGHIM(iHeightInPix, iYppli);

    if (fSystemDC)
        ReleaseDC(NULL, hDC);

    return iHeightInHiMetric;
    }


STDAPI_(int) XformHeightInHimetricToPixels(HDC hDC, int iHeightInHiMetric)
    {
    int     iYppli;     //Pixels per logical inch along height
    int     iHeightInPix;
    BOOL    fSystemDC=FALSE;

    if (NULL==hDC)
        {
        hDC=GetDC(NULL);
        fSystemDC=TRUE;
        }

    iYppli = GetDeviceCaps (hDC, LOGPIXELSY);

    //* We got logical HIMETRIC along the display, convert them to pixel units
    iHeightInPix = MAP_LOGHIM_TO_PIX(iHeightInHiMetric, iYppli);

    if (fSystemDC)
        ReleaseDC(NULL, hDC);

    return iHeightInPix;
    }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\ole2\inplace.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	inplace.cxx
//
//  Contents:	Stripped-down OLE2 inplace.cpp
//
//  History:	11-Apr-94	DrewB	Copied from OLE2
//
//----------------------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

#include <ole2int.h>

#ifndef _MAC
#include "inplace.h"
#endif

#ifndef _MAC

WORD	wSignature; //    =  (WORD) {'S', 'K'};

UINT uOleMessage;
 
#define OM_CLEAR_MENU_STATE		0	// lParam is NULL
#define OM_COMMAND_ID			1	// LOWORD(lParam) contains the command ID

OLEAPI OleTranslateAccelerator
   (LPOLEINPLACEFRAME lpFrame, LPOLEINPLACEFRAMEINFO lpFrameInfo, LPMSG lpMsg)
{
	WORD cmd;
	BOOL fFound;

	fFound = IsAccelerator(lpFrameInfo->haccel, lpFrameInfo->cAccelEntries,
					lpMsg, &cmd);
					
	if (!fFound && lpFrameInfo->fMDIApp)
		fFound = IsMDIAccelerator(lpMsg, &cmd);

	if (fFound) {
		AssertSz(lpFrameInfo->hwndFrame, 
			"OleTranslateAccelerator: Invalid lpFrameInfo->hwndFrame");
		SendMessage(lpFrameInfo->hwndFrame, uOleMessage, OM_COMMAND_ID, 
				MAKELONG(cmd, 0)); 	
#ifdef _DEBUG				
		OutputDebugString((LPSTR)"IOleInPlaceFrame::TranslateAccelerator called\r\n");
#endif		
		return lpFrame->TranslateAccelerator(lpMsg, cmd);
		
	} else {
		if (wSysKeyToKey(lpMsg) == WM_SYSCHAR) { 
			// Eat the message if it is "Alt -". This is supposed to bring 
			// MDI system menu down. But we can not support it. And we also
			// don't want the message to be Translated by the object 
			// application either. So, we return as if it has been accepted by
			// the container as an accelerator.
			
			// If the container wants to support this it can have an 
			// accelerator for this. This is not an issue for SDI apps, 
			// because it will be thrown away by USER anyway.
			
			if (lpMsg->wParam != '-')
				SendMessage(lpFrameInfo->hwndFrame, lpMsg->message, 
					lpMsg->wParam, lpMsg->lParam);
#ifdef _DEBUG
			else
				OutputDebugString((LPSTR)"OleTranslateAccelerator: Alt+ - key is discarded\r\n");
#endif					
					
			return NOERROR;
		}
	}
	
	return ResultFromScode(S_FALSE);
}

inline UINT wSysKeyToKey(LPMSG lpMsg)
{
	UINT message = lpMsg->message;
	
	// if the ALT key is down when a key is pressed, then the 29th bit of the
	// LPARAM will be set
	
	// If the message was not made with the ALT key down, convert the message
	// from a WM_SYSKEY* to a WM_KEY* message.

	if (!(HIWORD(lpMsg->lParam) & 0x2000) 
			&& (message >= WM_SYSKEYDOWN && message <= WM_SYSDEADCHAR))
		message -= (WM_SYSKEYDOWN - WM_KEYDOWN);	
	
	return message;
}


OLEAPI_(BOOL) IsAccelerator
	(HACCEL hAccel, int cAccelEntries, LPMSG lpMsg, WORD FAR* lpwCmd)
{
	WORD		cmd = NULL;
	WORD		flags;	
	BOOL		fFound = FALSE;
	BOOL		fVirt;
	LPACCEL		lpAccel = NULL;
	UINT		message;

	message = wSysKeyToKey(lpMsg);

	switch (message) {
	case WM_KEYDOWN:
	case WM_SYSKEYDOWN:
		fVirt = TRUE;
		break;

	case WM_CHAR:
	case WM_SYSCHAR:
		fVirt = FALSE;
		break;

	default:
		goto errRtn;
	}

	if (! (hAccel && (lpAccel = (LPACCEL) LockResource(hAccel))))
		goto errRtn;

	if (! cAccelEntries)
		goto errRtn;
			
	do {
		flags = lpAccel->fVirt;
		if ((lpAccel->key != (WORD) lpMsg->wParam) ||
				((fVirt != 0) != ((flags & FVIRTKEY) != 0)))
			goto Next;

		if (fVirt) {
			if ((GetKeyState(VK_SHIFT) < 0) != ((flags & FSHIFT) != 0))
				goto Next;
			if ((GetKeyState(VK_CONTROL) < 0) != ((flags & FCONTROL) != 0))
				goto Next;
	    }

		if ((GetKeyState(VK_MENU) < 0) != ((flags & FALT) != 0))
			goto Next;

		if (cmd = lpAccel->cmd)
			fFound = TRUE;

		goto errRtn;
		
Next:
		lpAccel++;

	} while (--cAccelEntries);
	
	
errRtn:
	if (lpAccel)  
		UnlockResource(hAccel);
	
	if (lpwCmd)
		*lpwCmd = cmd;

	return fFound;
}



BOOL IsMDIAccelerator(LPMSG lpMsg, WORD FAR* lpCmd)
{
	if (lpMsg->message != WM_KEYDOWN && lpMsg->message != WM_SYSKEYDOWN)
		return FALSE;

	/* All of these have the control key down */
	if (GetKeyState(VK_CONTROL) >= 0)
		return FALSE;

	if (GetKeyState(VK_MENU) < 0)
		return FALSE;

	switch ((WORD)lpMsg->wParam) {
	case VK_F4:
		*lpCmd = SC_CLOSE;

	case VK_F6:
	case VK_TAB:
		if (GetKeyState(VK_SHIFT) < 0)
			*lpCmd = SC_PREVWINDOW;
		else
			*lpCmd = SC_NEXTWINDOW;
		break;
		
    default:
		return FALSE;
    }

	return TRUE;
}

LPOLEMENU wGetOleMenuPtr(HOLEMENU holemenu)
{
	LPOLEMENU lpOleMenu;
	
	if (! (holemenu 
			&& (lpOleMenu = (LPOLEMENU) GlobalLock((HGLOBAL) holemenu))))
		return NULL;
		
	if (lpOleMenu->wSignature != wSignature) {
		AssertSz(FALSE, "Error - handle is not a HOLEMENU");
		GlobalUnlock((HGLOBAL) holemenu);
		return NULL;
	}
	
	return lpOleMenu;
}	

inline void	wReleaseOleMenuPtr(HOLEMENU holemenu)
{
	GlobalUnlock((HGLOBAL) holemenu);
}

#endif // !_MAC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\ole2\icon.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	icon.h
//
//  Contents:	icon.h from OLE2
//
//  History:	11-Apr-94	DrewB	Copied from OLE2
//
//----------------------------------------------------------------------------

/*
 * ICON.H
 *
 * This file contains definitions and function prototypes used in geticon.c
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 */

#if !defined( _ICON_H )
#define _ICON_H_

#if !defined( IDS_DEFICONLABEL )
#define IDS_DEFICONLABEL    310
#endif

STDAPI_(int)        XformWidthInHimetricToPixels(HDC, int);
STDAPI_(int)        XformWidthInPixelsToHimetric(HDC, int);
STDAPI_(int)        XformHeightInHimetricToPixels(HDC, int);
STDAPI_(int)        XformHeightInPixelsToHimetric(HDC, int);

HICON FAR PASCAL    HIconAndSourceFromClass(REFCLSID, LPSTR, UINT FAR *);

BOOL FAR PASCAL		FIconFileFromClass(REFCLSID, LPSTR, UINT, UINT FAR *);

LPSTR FAR PASCAL    PointerToNthField(LPSTR, int, char);

BOOL FAR PASCAL		GetAssociatedExecutable(LPSTR, LPSTR);


STDAPI_(UINT)		OleStdGetAuxUserType(REFCLSID rclsid,
                                      WORD   wAuxUserType, 
                                      LPSTR  lpszAuxUserType, 
                                      int    cch,
                                      HKEY   hKey);

STDAPI_(UINT)		OleStdGetUserTypeOfClass(REFCLSID rclsid, 
                                           LPSTR lpszUserType, 
                                           UINT cch, 
                                           HKEY hKey);

STDAPI_(UINT)		OleStdIconLabelTextOut(HDC        hDC, 
                                         HFONT      hFont,
                                         int        nXStart, 
                                         int        nYStart, 
                                         UINT       fuOptions, 
                                         RECT FAR * lpRect, 
                                         LPSTR      lpszString, 
                                         UINT       cchString, 
                                         int FAR *  lpDX);

#endif // _ICON_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\ole2\lockbyte.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	lockbyte.cxx
//
//  Contents:	lockbyte.cpp from OLE2
//
//  History:	11-Apr-94	DrewB	Copied from OLE2
//
//----------------------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

#include <ole2int.h>

#include "memstm.h"
#include <reterr.h>

// CreateILockBytesOnHGlobal
//

OLEAPI CreateILockBytesOnHGlobal
	(HGLOBAL			hGlobal, 
	BOOL				fDeleteOnRelease, 
	LPLOCKBYTES FAR*	pplkbyt)
{
	HANDLE				 hMem	  = NULL; // point to
    struct MEMSTM FAR*   pData 	  = NULL; //   a struct MEMSTM
    ILockBytes FAR* 	 pBytes	  = NULL;  
	DWORD 		 		 cbSize   = -1L;

	VDATEPTRIN (pplkbyt, LPLOCKBYTES);
	*pplkbyt = NULL;

    if (NULL==hGlobal)
	{
		hGlobal = GlobalAlloc(GMEM_DDESHARE | GMEM_MOVEABLE, 0);
	    if (hGlobal == NULL)
    	    goto ErrorExit;
    	cbSize = 0;

		// REVIEW: need to free this block if error below
	}
	else
	{
		cbSize = GlobalSize (hGlobal);
		// Is there a way to verify a zero-sized handle?
		if (cbSize!=0)
		{
			// verify validity of passed-in handle
			if (NULL==GlobalLock(hGlobal))
			{
				// bad handle
				return ResultFromScode (E_INVALIDARG);
			}
			GlobalUnlock (hGlobal);
		}
	}

	hMem = GlobalAlloc (GMEM_DDESHARE | GMEM_MOVEABLE, sizeof (MEMSTM));
    if (hMem == NULL)
   	    goto ErrorExit;

	pData = (MEMSTM FAR*)MAKELONG(0, HIWORD(GlobalHandle(hMem)));
    if (pData == NULL)
   	    goto FreeMem;

	pData->cRef = 0;
   	pData->cb = cbSize;
	pData->fDeleteOnRelease = fDeleteOnRelease;
	pData->hGlobal = hGlobal;

    pBytes = CMemBytes::Create(hMem); // Create the ILockBytes
    if (pBytes == NULL)
        goto FreeMem;

    *pplkbyt = pBytes;
	return NOERROR;
	
FreeMem:	
	if (hMem)
	    GlobalFree(hMem);
ErrorExit:
	Assert (0);
    return ReportResult(0, E_OUTOFMEMORY, 0, 0);
}




OLEAPI GetHGlobalFromILockBytes
	(LPLOCKBYTES 	plkbyt, 
	HGLOBAL	FAR*	phglobal)
{
	VDATEIFACE (plkbyt);
	VDATEPTRIN (phglobal, HANDLE);
	*phglobal = NULL;
	CMemBytes FAR* pCMemByte = (CMemBytes FAR*)plkbyt;

	if (IsBadReadPtr (&(pCMemByte->m_dwSig), sizeof(ULONG))
		|| pCMemByte->m_dwSig != LOCKBYTE_SIG)
	{
		// we were passed someone else's implementation of ILockBytes
		return ResultFromScode (E_INVALIDARG);
	}

	MEMSTM FAR* pMem= pCMemByte->m_pData;
	if (NULL==pMem)
	{
		Assert (0);
		return ResultFromScode (E_OUTOFMEMORY);
	}
	Assert (pMem->cb <= GlobalSize (pMem->hGlobal));
	Verify (*phglobal = pMem->hGlobal);

	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\ole2\memstm.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	memstm.h
//
//  Contents:	memstm.h from OLE2
//
//  History:	11-Apr-94	DrewB	Copied from OLE2
//
//----------------------------------------------------------------------------

#if !defined( _MEMSTM_H_ )
#define _MEMSTM_H_

// These defines shorten the class name so that the compiler doesn't
// choke on really long decorated names for MarshalInterface
#define CMarshalMemStm CMMS
#define CMarshalMemBytes CMMB

class FAR CMarshalMemStm;
class FAR CMarshalMemBytes;

// CMemStm is a stream implementation on top of global shared memory MEMSTM
//
// CMemStm
// +---------+
// + pvtf    +    Shared  memory
// +---------+   +--------------+
// + m_pMem  +-->|cb            |
// +---------+   |cRef          |
//               |hGlobal       |--->+--------------+
//               +--------------+	 | Actual Data	|
// CMemStm             MEMSTM		 +--------------+
//
struct MEMSTM {             // Data in shared memory
    DWORD  cb;              // Size of hGlobal
    DWORD  cRef;            // See below
    HANDLE hGlobal;         // The data
	BOOL   fDeleteOnRelease;
};

// cRef counts all CMemStm pointers to this MEMSTM plus the number of times
// a hMem handle to MEMSTM had been returned
//
#define STREAM_SIG (0x4d525453L)

class FAR CMemStm : public IStream { // Shared emmory stream
public:
    OLEMETHOD(QueryInterface) (REFIID iidInterface, void FAR* FAR* ppvObj);
    OLEMETHOD_(ULONG,AddRef) (void);
    OLEMETHOD_(ULONG,Release) (void);
    OLEMETHOD(Read) (VOID HUGEP* pv, ULONG cb, ULONG FAR* pcbRead);
    OLEMETHOD(Write) (VOID const HUGEP* pv, ULONG cb, ULONG FAR* pcbWritten);
    OLEMETHOD(Seek) (LARGE_INTEGER dlibMove, 
                                DWORD dwOrigin, ULARGE_INTEGER FAR* plibNewPosition);
    OLEMETHOD(SetSize) (ULARGE_INTEGER cb);
    OLEMETHOD(CopyTo) (IStream FAR* pstm, 
                       ULARGE_INTEGER cb, ULARGE_INTEGER FAR* pcbRead, ULARGE_INTEGER FAR* pcbWritten);
    OLEMETHOD(Commit) (DWORD grfCommitFlags);
    OLEMETHOD(Revert) (void);
    OLEMETHOD(LockRegion) (ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    OLEMETHOD(UnlockRegion) (ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    OLEMETHOD(Stat) (STATSTG FAR* pstatstg, DWORD statflag);
    OLEMETHOD(Clone)(IStream FAR * FAR *ppstm);

    OLESTATIC_(CMemStm FAR*) Create(HANDLE hMem);

ctor_dtor:
    CMemStm() { GET_A5(); m_hMem = NULL; m_pData = NULL; m_pos = 0; m_refs = 0; }
    ~CMemStm() {}

private:
 	DWORD m_dwSig;				   	// Signature indicating this is our
									// implementation of IStream: STREAM_SIG
    ULONG m_refs;                   // Number of references to this CmemStm
    ULONG m_pos;                    // Seek pointer for Read/Write
    HANDLE m_hMem;                  // Memory Handle passed on creation
    MEMSTM FAR* m_pData;            // Pointer to that memroy

 	friend HRESULT STDAPICALLTYPE GetHGlobalFromStream (LPSTREAM, HGLOBAL FAR*);
 	friend LPSTREAM STDAPICALLTYPE CreateMemStm (DWORD, LPHANDLE);
    friend class CMarshalMemStm;
	SET_A5;
};




// CMemBytes is an ILockBytes implementation on top of global shared
// memory MEMSTM
//
// CMemBytes
// +---------+
// + pvtf    +    Shared  memory
// +---------+   +--------------+
// + m_pData +-->| cb           |	 
// +---------+   | cRef         |	 
//               | hGlobal      |--->+-------------+
//               +--------------+	 | Actual data |
// CMemBytes         MEMSTM  	  	 +-------------+
//

#define LOCKBYTE_SIG (0x0046574A)

// cRef counts all CMemBytes pointers to this MEMSTM. 
// It and fDeleteOnRelease control the GlobalFree'ing of the hGlobal.

class FAR CMemBytes : public ILockBytes { // Shared memory lock bytes
public:
    OLEMETHOD(QueryInterface) (REFIID iidInterface, void FAR* FAR* ppvObj);
    OLEMETHOD_(ULONG,AddRef) (void);
    OLEMETHOD_(ULONG,Release) (void);
    OLEMETHOD(ReadAt) (ULARGE_INTEGER ulOffset, VOID HUGEP *pv, ULONG cb,
                                                    ULONG FAR *pcbRead);
    OLEMETHOD(WriteAt) (ULARGE_INTEGER ulOffset, VOID const HUGEP *pv, ULONG cb,
                                                    ULONG FAR *pcbWritten);
    OLEMETHOD(Flush) (void);
    OLEMETHOD(SetSize) (ULARGE_INTEGER cb);
    OLEMETHOD(LockRegion) (ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    OLEMETHOD(UnlockRegion) (ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    OLEMETHOD(Stat) (THIS_ STATSTG FAR *pstatstg, DWORD statflag);

    OLESTATIC_(CMemBytes FAR*) Create(HANDLE hMem);

ctor_dtor:
    CMemBytes() { GET_A5(); m_hMem = NULL; m_pData = NULL; m_refs = 0; }
    ~CMemBytes() {}

private:
	 DWORD m_dwSig;				   	// Signature indicating this is our
												// implementation of ILockBytes: LOCKBYTE_SIG
    ULONG m_refs;                   // Normal reference count
    HANDLE m_hMem;                  // Handle for bookeeping info (MEMSTM)
    MEMSTM FAR* m_pData;	        // Pointer to that memroy

 	friend HRESULT STDAPICALLTYPE GetHGlobalFromILockBytes	(LPLOCKBYTES, HGLOBAL FAR*);
    friend class CMarshalMemBytes;
	SET_A5;
};


// CMarshalMemStm can Marshal, Unmarshal CMemStm.  It is impletented as
// a seperate object accessible from CMemStm, CMemBytes: QueryIntreface of
// IMarshal on CMemStm's IStream will return an IMarshal pointer to
// CMarshalMemStm, but QueryInterface of IStream on that IMarshal will
// fail.
// Also QueryInterface of IUnknown on IMarshal will not return the same value
// As QueryInterface of IUnkown on the original IStream.
//
class FAR CMarshalMemStm : public IMarshal {
public:
    OLEMETHOD(QueryInterface) (REFIID riid, LPVOID FAR* ppvObj);
    OLEMETHOD_(ULONG,AddRef) (void);
    OLEMETHOD_(ULONG,Release) (void);

    OLEMETHOD(GetUnmarshalClass)(THIS_ REFIID riid, LPVOID pv, 
						DWORD dwDestContext, LPVOID pvDestContext,
						DWORD mshlflags, LPCLSID pCid);
    OLEMETHOD(GetMarshalSizeMax)(THIS_ REFIID riid, LPVOID pv, 
						DWORD dwDestContext, LPVOID pvDestContext,
						DWORD mshlflags, LPDWORD pSize);
    OLEMETHOD(MarshalInterface)(THIS_ IStream FAR* pStm, REFIID riid,
						LPVOID pv, DWORD dwDestContext, LPVOID pvDestContext,
						DWORD mshlflags);
    OLEMETHOD(UnmarshalInterface)(THIS_ IStream FAR* pStm, REFIID riid,
                        LPVOID FAR* ppv);
    OLEMETHOD(ReleaseMarshalData)(THIS_ IStream FAR* pStm);
    OLEMETHOD(DisconnectObject)(THIS_ DWORD dwReserved);

    OLESTATIC_(CMarshalMemStm FAR*) Create(CMemStm FAR* pMemStm);

ctor_dtor:
    CMarshalMemStm() { GET_A5();m_pMemStm = NULL; m_refs = 0; }
    ~CMarshalMemStm() {}

private:
    ULONG m_refs;                   // Number of references to this CmemStm
    CMemStm FAR* m_pMemStm;         // Pointer to object [Un]Marshalled
    CLSID m_clsid;                      // Class of object pointed by pUnk
	SET_A5;
};


// CMarshalMemBytes can Marshal, Unmarshal CMemBytes.  It is impletented as
// a seperate object accessible from CMemBytes, CMemBytes: QueryIntreface of
// IMarshal on CMemBytes's ILocBytes will return an IMarshal pointer to
// CMarshalMemBytes, but QueryInterface of ILockBytes on that IMarshal will
// fail.
// Also QueryInterface of IUnknown on IMarshal will not return the same value
// As QueryInterface of IUnkown on the original ILockBytes.
//
class FAR CMarshalMemBytes : public IMarshal {
public:
    OLEMETHOD(QueryInterface) (REFIID riid, LPVOID FAR* ppvObj);
    OLEMETHOD_(ULONG,AddRef) (void);
    OLEMETHOD_(ULONG,Release) (void);

    OLEMETHOD(GetUnmarshalClass)(THIS_ REFIID riid, LPVOID pv, 
						DWORD dwDestContext, LPVOID pvDestContext,
						DWORD mshlflags, LPCLSID pCid);
    OLEMETHOD(GetMarshalSizeMax)(THIS_ REFIID riid, LPVOID pv, 
						DWORD dwDestContext, LPVOID pvDestContext,
						DWORD mshlflags, LPDWORD pSize);
    OLEMETHOD(MarshalInterface)(THIS_ IStream FAR* pStm, REFIID riid,
						LPVOID pv, DWORD dwDestContext, LPVOID pvDestContext,
						DWORD mshlflags);
    OLEMETHOD(UnmarshalInterface)(THIS_ IStream FAR* pStm, REFIID riid,
                        LPVOID FAR* ppv);
    OLEMETHOD(ReleaseMarshalData)(THIS_ IStream FAR* pStm);
    OLEMETHOD(DisconnectObject)(THIS_ DWORD dwReserved);

    OLESTATIC_(CMarshalMemBytes FAR*) Create(CMemBytes FAR* pMemBytes);

ctor_dtor:
    CMarshalMemBytes() { GET_A5();m_pMemBytes = NULL; m_refs = 0; }
    ~CMarshalMemBytes() {}

private:
    ULONG m_refs;                   // Number of references to this CMemBytes
    CMemBytes FAR* m_pMemBytes;     // Pointer to object [Un]Marshalled
    CLSID m_clsid;                      // Class of object pointed by pUnk
	SET_A5;
};


#endif // _MemBytes_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\ole2\ole2guid.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:		OLE2GUID.cxx	(16 bit target)
//
//  Contents:	GUIDs for OLE2
//
//  Functions:	
//
//  History:	17-Dec-93 JohannP    Created
//
//--------------------------------------------------------------------------

#pragma hdrstop
#define  INITGUID
#include <string.h>
#include "compobj.h"
#include "initguid.h"
#include "oleguid.h"
#include "privguid.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\ole2\memstm.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	memstm.cxx
//
//  Contents:	memstm.cpp from OLE2
//
//  History:	11-Apr-94	DrewB	Copied from OLE2
//
//----------------------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

#include <ole2int.h>

#include "memstm.h"
#include <reterr.h>

static const UINT grfMem = GMEM_SHARE | GMEM_MOVEABLE;

// REVIEW: there is a lot of duplicate code.  There used to be two separate
// but identical structs: MEMSTM and MEMBYTES; the structs have be merged and
// common code should be pulled out including: Release, AddRef, marshal, SetSize


// Shared memory IStream implementation
//

OLEMETHODIMP CMemStm::QueryInterface(REFIID iidInterface, void FAR* FAR* ppvObj)
{
    M_PROLOG(this);
    HRESULT error;

    VDATEPTROUT( ppvObj, LPVOID );
    *ppvObj = NULL;
    VDATEIID( iidInterface );

    // Two interfaces supported: IUnknown, IStream

    if (m_pData != NULL &&
            (iidInterface == IID_IStream || iidInterface == IID_IUnknown)) {

        m_refs++;   // A pointer to this object is returned
        *ppvObj = this;
        error = NOERROR;
    } else
//
// BUGBUG - Renable this once CraigWi seperates Custom Marshalling stuff from
// standard identity stuff. (Right now you can't get in between the standard
// marshaller and the code which calls it, you're either completely custom
// marshalling, or your not).  Once it is better organized, we could marshall
// a heap handle and the custom marshalling stuff. Then when unmarshalling in
// the same wow, we unmarshal the heap handle, when not in the same wow, then
// use the standard marshalling stuff.
// Same goes for ILockBytesonHglobal below...
//
#define BOBDAY_DISABLE_MARSHAL_FOR_NOW
#ifdef BOBDAY_DISABLE_MARSHAL_FOR_NOW
#else
    if (iidInterface == IID_IMarshal) {
        *ppvObj = (LPVOID) CMarshalMemStm::Create(this);
        if (*ppvObj != NULL)
            error = NOERROR;
        else
            error = ReportResult(0, E_OUTOFMEMORY, 0, 0);
    }
    else
#endif
    {                 // Not accessible or unsupported interface
        *ppvObj = NULL;
        error = ReportResult(0, E_NOINTERFACE, 0, 0);
    }

    return error;
}


// Called when CMemStm is referenced by an additional pointer.
//

OLEMETHODIMP_(ULONG) CMemStm::AddRef(void)
{
	M_PROLOG(this);
    return ++m_refs;
}

// Called when a pointer to this CMemStm is discarded
//

OLEMETHODIMP_(ULONG) CMemStm::Release(void)
{
	M_PROLOG(this);

    if (--m_refs != 0) // Still used by others
        return m_refs;

	ReleaseMemStm(&m_hMem);

    delete this; // Free storage
    return 0;
}


OLEMETHODIMP CMemStm::Read(void HUGEP* pb, ULONG cb, ULONG FAR* pcbRead)
{
	M_PROLOG(this);
    thkDebugOut((DEB_ITRACE,
		 "%p _IN CMemStm16::Read(pb=%p,cb=%lx)\n",
		 this,pb,cb));
    HRESULT error = NOERROR;
    ULONG cbRead = cb;

    VDATEPTROUT( pb, char);
    if (pcbRead) {
        VDATEPTROUT( pcbRead, ULONG );
        *pcbRead = 0L;
    }
	
    if (pcbRead != NULL)
        *pcbRead = 0;

    if (cbRead + m_pos > m_pData->cb)
	{
		// Caller is asking for more bytes than we have left
        cbRead = m_pData->cb - m_pos;
    }

	if (cbRead > 0)
	{
	   	Assert (m_pData->hGlobal);
		char HUGEP* pGlobal = GlobalLock (m_pData->hGlobal);
		if (NULL==pGlobal)
		{
			Assert (0);
			error =  ResultFromScode (STG_E_READFAULT);
			goto exitRtn;
		}
	    UtMemCpy (pb, pGlobal + m_pos, cbRead);
		GlobalUnlock (m_pData->hGlobal);
	    m_pos += cbRead;
	}

    if (pcbRead != NULL)
        *pcbRead = cbRead;
exitRtn:
    thkDebugOut((DEB_ITRACE,
		 "%p OUT CMemStm16::Read() returns %lx\n",
		 this,error));
    return error;
}


OLEMETHODIMP CMemStm::Write(void const HUGEP* pb, ULONG cb, ULONG FAR* pcbWritten)
{
	A5_PROLOG(this);
    HRESULT error = NOERROR;
    thkDebugOut((DEB_ITRACE,
		 "%p _IN CMemStm16::Write(pb=%p,cb=%lx)\n",
		 this,pb,cb));

    ULONG cbWritten = cb;
	ULARGE_INTEGER ularge_integer;
	char HUGEP* pGlobal;

    if ( pcbWritten ) {
        VDATEPTROUT( pcbWritten, ULONG );
        *pcbWritten = 0L;
    }
    VDATEPTRIN( pb , char );

    if (pcbWritten != NULL)
        *pcbWritten = 0;

    if (cbWritten + m_pos > m_pData->cb) {
		ULISet32( ularge_integer, m_pos+cbWritten );
        error = SetSize(ularge_integer);
        if (error != NOERROR)
            goto Exit;
    }

	pGlobal = GlobalLock (m_pData->hGlobal);
	if (NULL==pGlobal)
	{
		Assert (0);
		error =  ResultFromScode (STG_E_WRITEFAULT);
		goto Exit;
	}
    UtMemCpy (pGlobal + m_pos, pb, cbWritten);
	GlobalUnlock (m_pData->hGlobal);

    m_pos += cbWritten;

    if (pcbWritten != NULL)
        *pcbWritten = cbWritten;

Exit:
    RESTORE_A5();
    thkDebugOut((DEB_ITRACE,
		 "%p OUT CMemStm16::Write() returns %lx\n",
		 this,error));

    return error;
}

OLEMETHODIMP CMemStm::Seek(LARGE_INTEGER dlibMoveIN, DWORD dwOrigin, ULARGE_INTEGER FAR* plibNewPosition)
{
    M_PROLOG(this);
    thkDebugOut((DEB_ITRACE,"%p _IN CMemStm16::Seek()\n",this));

    HRESULT error  = NOERROR;
    LONG  dlibMove = dlibMoveIN.LowPart ;
    ULONG cbNewPos = dlibMove;

    if (plibNewPosition != NULL){
        VDATEPTROUT( plibNewPosition, ULONG );
        ULISet32(*plibNewPosition, m_pos);
    }

    switch(dwOrigin) {

        case STREAM_SEEK_SET:
            if (dlibMove >= 0)
                m_pos = dlibMove;
            else
                error = ReportResult(0, E_UNSPEC, 0, 0); // should return invalid seek
        break;

        case STREAM_SEEK_CUR:
            if (!(dlibMove < 0 && ((ULONG) -dlibMove) > m_pos))
                m_pos += dlibMove;
            else
                error = ReportResult(0, E_UNSPEC, 0, 0); // should return invalid seek
        break;

        case STREAM_SEEK_END:
            if (!(dlibMove < 0 && ((ULONG) -dlibMove) > m_pData->cb))
                m_pos = m_pData->cb + dlibMove;
            else
                error = ReportResult(0, E_UNSPEC, 0, 0); // should return invalid seek
        break;

        default:
            error = ReportResult(0, E_UNSPEC, 0, 0); // should return invalid seek mode
    }

    if (plibNewPosition != NULL)
        ULISet32(*plibNewPosition, m_pos);

    thkDebugOut((DEB_ITRACE,"%p OUT CMemStm16::Seek() returns %lx\n",this,error));

    return error;
}



OLEMETHODIMP CMemStm::SetSize(ULARGE_INTEGER cb)
{
	M_PROLOG(this);
    thkDebugOut((DEB_ITRACE,
		 "%p _IN CMemStm16::SetSize(cb=%lx%lx)\n",
		 this,cb.HighPart,cb.LowPart));
    HANDLE hMemNew;
    HRESULT hresult = NOERROR;

    if (m_pData->cb == cb.LowPart)
    {
	goto errRtn;
    }


    hMemNew = GlobalReAlloc(m_pData->hGlobal,max (cb.LowPart,1),grfMem);

    if (hMemNew == NULL)
    {
	hresult =  ResultFromScode (E_OUTOFMEMORY);
	goto errRtn;
    }

    m_pData->hGlobal = hMemNew;
    m_pData->cb = cb.LowPart;

errRtn:
    thkDebugOut((DEB_ITRACE,
		 "%p OUT CMemStm16::SetSize() returns %lx\n",
		 this,
		 hresult));

    return hresult;
}


OLEMETHODIMP CMemStm::CopyTo(IStream FAR *pstm,
			     ULARGE_INTEGER cb,
			     ULARGE_INTEGER FAR * pcbRead,
			     ULARGE_INTEGER FAR * pcbWritten)
{
    thkDebugOut((DEB_ITRACE,
		 "%p _IN CMemStm16::CopyTo(pstm=%p)\n",
		 this,
		 pstm));
		
    ULONG	cbRead  	= cb.LowPart;
    ULONG	cbWritten	= 0;
    HRESULT hresult		= NOERROR;

    // pstm cannot be NULL

    VDATEPTRIN(pstm, LPSTREAM);
	
    // the spec says that if cb is it's maximum value (all bits set,
    // since it's unsigned), then we will simply read the copy of
    // this stream

    if ( ~(cb.LowPart) == 0 && ~(cb.HighPart) == 0 )
    {
    	cbRead = m_pData->cb - m_pos;
    }
    else if ( cb.HighPart > 0 )
    {
    	// we assume that our memory stream cannot
    	// be large enough to accomodate very large (>32bit)
    	// copy to requests.  Since this is probably an error
    	// on the caller's part, we assert.

    	thkAssert(!"WARNING: CopyTo request exceeds 32 bits");

    	// set the Read value to what's left, so that "Ignore"ing
    	// the assert works properly.
    	
    	cbRead = m_pData->cb - m_pos;
    }
    else if ( cbRead + m_pos > m_pData->cb )
    {
    	// more bytes were requested to read than we had left.
    	// cbRead is set to the amount remaining.

    	cbRead = m_pData->cb - m_pos;
    }

    // now write the data to the stream

    if ( cbRead > 0 )
    {	
    	BYTE HUGEP* pGlobal = (BYTE HUGEP *)GlobalLock(
    			m_pData->hGlobal);

    	if( pGlobal == NULL )
    	{
    		thkAssert(!"GlobalLock failed");
		hresult = (HRESULT)STG_E_INSUFFICIENTMEMORY;
		goto errRtn;
    	}
    	
    	hresult = pstm->Write(pGlobal + m_pos, cbRead, &cbWritten);

    	// in the error case, the spec says that the return values
    	// may be meaningless, so we do not need to do any special
    	// error handling here
    	
    	GlobalUnlock(m_pData->hGlobal);
    }

    // increment our seek pointer and set the out parameters

    m_pos += cbRead;

    if( pcbRead )
    {
    	ULISet32(*pcbRead, cbRead);
    }

    if( pcbWritten )
    {
    	ULISet32(*pcbWritten, cbWritten);
    }

errRtn:
    thkDebugOut((DEB_ITRACE,
		 "%p OUT CMemStm16::CopyTo(pstm=%p) returns %lx\n",
		 this,
		 pstm,
		 hresult));
    return hresult;

}

OLEMETHODIMP CMemStm::Commit(DWORD grfCommitFlags)
{
    M_PROLOG(this);
    return NOERROR;			// since this stream is not transacted, no error
}

OLEMETHODIMP CMemStm::Revert(void)
{
    M_PROLOG(this);
    return NOERROR;			// nothing done
}

OLEMETHODIMP CMemStm::LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
	M_PROLOG(this);
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}

OLEMETHODIMP CMemStm::UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
	M_PROLOG(this);
    return ResultFromScode(STG_E_INVALIDFUNCTION);
}

OLEMETHODIMP CMemStm::Stat(STATSTG FAR *pstatstg, DWORD statflag)
{
	M_PROLOG(this);
    VDATEPTROUT( pstatstg, STATSTG );

    pstatstg->pwcsName = NULL;
    pstatstg->type = 0;
    pstatstg->cbSize.HighPart = 0;
    pstatstg->cbSize.LowPart = m_pData->cb;
    pstatstg->mtime.dwLowDateTime = 0;
    pstatstg->mtime.dwHighDateTime = 0;
    pstatstg->ctime.dwLowDateTime = 0;
    pstatstg->ctime.dwHighDateTime = 0;
    pstatstg->atime.dwLowDateTime = 0;
    pstatstg->atime.dwHighDateTime = 0;
    pstatstg->grfMode = 0;
    pstatstg->grfLocksSupported = 0;
    pstatstg->clsid = CLSID_NULL;
    pstatstg->grfStateBits = 0;
    pstatstg->reserved = 0;

    return NOERROR;
}


// returns new instance of pstm pointing to same data at same position.
OLEMETHODIMP CMemStm::Clone(IStream FAR * FAR *ppstm)
{
	M_PROLOG(this);
    CMemStm FAR* pCMemStm;

	VDATEPTROUT (ppstm, LPSTREAM);

	*ppstm = pCMemStm = CMemStm::Create(m_hMem);
	if (pCMemStm == NULL)
		return ResultFromScode(E_OUTOFMEMORY);

	pCMemStm->m_pos = m_pos;
	return NOERROR;
}


// Create CMemStm.  Handle must be a MEMSTM block.
//

OLESTATICIMP_(CMemStm FAR*) CMemStm::Create(HANDLE hMem)
{
    CMemStm FAR* pCMemStm;
    struct MEMSTM FAR* pData;

	pData = (MEMSTM FAR*)MAKELONG(0, HIWORD(GlobalHandle(hMem)));
    if (pData == NULL)
        return NULL;

    pCMemStm = new CMemStm;

    if (pCMemStm == NULL)
        return NULL;

    // Initialize CMemStm
    //
    pCMemStm->m_hMem = hMem;
    (pCMemStm->m_pData = pData)->cRef++;	// AddRefMemStm
    pCMemStm->m_refs = 1;
	pCMemStm->m_dwSig = STREAM_SIG;

    return pCMemStm;
}




// Allocate shared memory and create CMemStm on top of it.
// Return pointer to the stream if done, NULL if error.
// If the handle is returned, it must be free with ReleaseMemStm
// (because of ref counting and the nested global handle).
//


OLEAPI_(LPSTREAM) CreateMemStm(DWORD cb, LPHANDLE phMem)
{
	HANDLE h;
    thkDebugOut((DEB_ITRACE,
		 "%p _IN CreateMemStm16(cb=%lx,phMem=%p\n",0,cb,phMem));


    LPSTREAM pstm = NULL;

    if (phMem)
    {
    	*phMem = NULL;
    }


    h = GlobalAlloc (grfMem, cb);
    if (NULL==h)
    {
	goto errRtn;
    }

    if (CreateStreamOnHGlobal (h, TRUE, &pstm) != NOERROR)
    {
	pstm = NULL;
	goto errRtn;
    }
    if (phMem)
    {
    	// retrieve handle from just-created CMemStm
    	*phMem = ((CMemStm FAR*)pstm)->m_hMem;

    	// use pointer to bump ref count
    	Assert(((CMemStm FAR*)pstm)->m_pData != NULL);
    	((CMemStm FAR*)pstm)->m_pData->cRef++;	// AddRefMemStm
    }

errRtn:
    thkDebugOut((DEB_ITRACE,
	     "%p OUT CreateMemStm16(cb=%lx,phMem=%p) returns %p\n",0,pstm));

    return pstm;
}


// Create CMemStm on top of the specified hMem (which must be a MEMSTM block).
// Return pointer to the stream if done, NULL if error.
//
OLEAPI_(LPSTREAM) CloneMemStm(HANDLE hMem)
{
    return CMemStm::Create(hMem); // Create the stream
}



OLEAPI_(void) ReleaseMemStm (LPHANDLE phMem, BOOL fInternalOnly)
{
    struct MEMSTM FAR* pData;

	pData = (MEMSTM FAR*)MAKELONG(0, HIWORD(GlobalHandle(*phMem)));

	// check for NULL pointer in case handle got freed already
	// decrement ref count and free if no refs left
    if (pData != NULL && --pData->cRef == 0)
	{
		if (pData->fDeleteOnRelease)
		{
			Verify (0==GlobalFree (pData->hGlobal));
		}

		if (!fInternalOnly)
		{
			Verify (0==GlobalFree(*phMem));
		}
    }
	*phMem = NULL;
}



OLEAPI CreateStreamOnHGlobal
	(HANDLE hGlobal,
	BOOL fDeleteOnRelease,
	LPSTREAM FAR* ppstm)
{
    thkDebugOut((DEB_ITRACE,
		 "%p _IN CreateStreamOnHGlobal16(hGlobal=%x)\n",0,hGlobal));

	HANDLE				hMem	  = NULL; // point to
    struct MEMSTM FAR* 	pData 	  = NULL; //   a struct MEMSTM
    LPSTREAM 			pstm	  = NULL;
	DWORD 		 		cbSize   = -1L;

	VDATEPTRIN (ppstm, LPSTREAM);
	*ppstm = NULL;
    if (NULL==hGlobal)
	{
		hGlobal = GlobalAlloc(grfMem, 0);
	    if (hGlobal == NULL)
    	    goto ErrorExit;
    	cbSize = 0;
	}
	else
	{
		cbSize = GlobalSize (hGlobal);
		// Is there a way to verify a zero-sized handle?
		if (cbSize!=0)
		{
			// verify validity of passed-in handle
			if (NULL==GlobalLock(hGlobal))
			{
				// bad handle
				return ResultFromScode (E_INVALIDARG);
			}
			GlobalUnlock (hGlobal);
		}
	}

	hMem = GlobalAlloc (grfMem, sizeof (MEMSTM));
    if (hMem == NULL)
   	    goto ErrorExit;

	pData = (MEMSTM FAR*)MAKELONG(0, HIWORD(GlobalHandle(hMem)));
    if (pData == NULL)
   	    goto FreeMem;

	pData->cRef = 0;
   	pData->cb = cbSize;
	pData->fDeleteOnRelease = fDeleteOnRelease;
	pData->hGlobal = hGlobal;

    pstm = CMemStm::Create(hMem);
    if (pstm == NULL)
        goto FreeMem;

    *ppstm = pstm;
    thkDebugOut((DEB_ITRACE,
		 "%p OUT CreateStreamOnHGlobal16() returns NOERROR\n",0));
	return NOERROR;
	
FreeMem:	
	if (hMem)
	{
	    Verify(0==GlobalFree(hMem));
	}
ErrorExit:
	Assert (0);
    thkDebugOut((DEB_ITRACE,
		 "%p OUT CreateStreamOnHGlobal16() returns E_OUTOFMEMORY\n",0));

    return ReportResult(0, E_OUTOFMEMORY, 0, 0);
}


OLEAPI GetHGlobalFromStream
	(LPSTREAM 		pstm,
	HGLOBAL	FAR*	phglobal)
{
	VDATEIFACE (pstm);
	VDATEPTRIN (phglobal, HANDLE);

	CMemStm FAR* pCMemStm = (CMemStm FAR*) pstm;
	if (IsBadReadPtr (&(pCMemStm->m_dwSig), sizeof(ULONG))
		|| pCMemStm->m_dwSig != STREAM_SIG)
	{
		// we were passed someone else's implementation of ILockBytes
		return ResultFromScode (E_INVALIDARG);
	}

	MEMSTM FAR* pMem= pCMemStm->m_pData;
	if (NULL==pMem)
	{
		Assert (0);
		return ResultFromScode (E_OUTOFMEMORY);
	}
	Assert (pMem->cb <= GlobalSize (pMem->hGlobal));
	Verify (*phglobal = pMem->hGlobal);

	return NOERROR;
}


//////////////////////////////////////////////////////////////////////////
//
// Shared memory ILockBytes implementation
//

OLEMETHODIMP CMemBytes::QueryInterface(REFIID iidInterface,
                                                    void FAR* FAR* ppvObj)
{
	M_PROLOG(this);
    HRESULT error;
    VDATEPTROUT( ppvObj, LPVOID );
    *ppvObj = NULL;
    VDATEIID( iidInterface );

    // Two interfaces supported: IUnknown, ILockBytes

    if (m_pData != NULL &&
            (iidInterface == IID_ILockBytes || iidInterface == IID_IUnknown)) {

        m_refs++;   // A pointer to this object is returned
        *ppvObj = this;
        error = NOERROR;
    } else
//
// BUGBUG - See comment above for CMemStm::Queryinterface and IID_IMarshal
//
#ifdef BOBDAY_DISABLE_MARSHAL_FOR_NOW
#else
    if (iidInterface == IID_IMarshal) {
        *ppvObj = (LPVOID) CMarshalMemBytes::Create(this);
        if (*ppvObj != NULL)
            error = NOERROR;
        else
            error = ReportResult(0, E_OUTOFMEMORY, 0, 0);
    }
    else
#endif
    {                 // Not accessible or unsupported interface
        *ppvObj = NULL;
        error = ReportResult(0, E_NOINTERFACE, 0, 0);
    }

    return error;
}


// Called when CMemBytes is referenced by an additional pointer.
//
OLEMETHODIMP_(ULONG) CMemBytes::AddRef(void)
{
	M_PROLOG(this);
    return ++m_refs;
}

// Called when a pointer to this CMemBytes is discarded
//
OLEMETHODIMP_(ULONG) CMemBytes::Release(void)
{
	M_PROLOG(this);
    if (--m_refs != 0) // Still used by others
        return m_refs;

	ReleaseMemStm(&m_hMem);

    delete this; // Free storage
    return 0;
}


OLEMETHODIMP CMemBytes::ReadAt(ULARGE_INTEGER ulOffset, void HUGEP* pb,
                                              ULONG cb, ULONG FAR* pcbRead)
{
	M_PROLOG(this);
    HRESULT error = NOERROR;
    ULONG cbRead = cb;

    VDATEPTROUT( pb, char );
    if (pcbRead) {
        VDATEPTROUT( pcbRead, ULONG );
        *pcbRead = 0L;
    }

    if (cbRead + ulOffset.LowPart > m_pData->cb) {

        if (ulOffset.LowPart > m_pData->cb)
            cbRead = 0;
        else
            cbRead = m_pData->cb - ulOffset.LowPart;
    }

	if (cbRead > 0)
	{
		char HUGEP* pGlobal = GlobalLock (m_pData->hGlobal);
		if (NULL==pGlobal)
		{
			Assert (0);
			return ResultFromScode (STG_E_READFAULT);
		}
	    UtMemCpy (pb, pGlobal + ulOffset.LowPart, cbRead);
		GlobalUnlock (m_pData->hGlobal);
	}

    if (pcbRead != NULL)
        *pcbRead = cbRead;

    return error;
}


OLEMETHODIMP CMemBytes::WriteAt(ULARGE_INTEGER ulOffset, void const HUGEP* pb,
                                              ULONG cb, ULONG FAR* pcbWritten)
{
	A5_PROLOG(this);
    HRESULT error = NOERROR;
    ULONG cbWritten = cb;
	char HUGEP* pGlobal;

    VDATEPTRIN( pb, char );

    if (pcbWritten) {
        VDATEPTROUT( pcbWritten, ULONG );
        *pcbWritten = 0;
    }

    if (cbWritten + ulOffset.LowPart > m_pData->cb) {
		ULARGE_INTEGER ularge_integer;
		ULISet32( ularge_integer, ulOffset.LowPart + cbWritten);
        error = SetSize( ularge_integer );
        if (error != NOERROR)
            goto Exit;
    }

	pGlobal = GlobalLock (m_pData->hGlobal);
	if (NULL==pGlobal)
	{
		Assert (0);
		return ResultFromScode (STG_E_WRITEFAULT);
	}
    UtMemCpy (pGlobal + ulOffset.LowPart, pb, cbWritten);
	GlobalUnlock (m_pData->hGlobal);
	

    if (pcbWritten != NULL)
        *pcbWritten = cbWritten;

Exit:
	RESTORE_A5();
    return error;
}

OLEMETHODIMP CMemBytes::Flush(void)
{
	M_PROLOG(this);
    return NOERROR;
}


OLEMETHODIMP CMemBytes::SetSize(ULARGE_INTEGER cb)
{
	M_PROLOG(this);
    HANDLE hMemNew;

    if (m_pData->cb == cb.LowPart)
        return NOERROR;

    hMemNew = GlobalReAlloc(m_pData->hGlobal,
							max (cb.LowPart, 1),
							grfMem);

    if (hMemNew == NULL)
        return ReportResult(0, E_OUTOFMEMORY, 0, 0);

    m_pData->hGlobal = hMemNew;
    m_pData->cb = cb.LowPart;

    return NOERROR;
}


OLEMETHODIMP CMemBytes::LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
    // REVIEW - Docfile bug. Must return NOERROR for StgCreateDocfileOnILockbytes
	M_PROLOG(this);
    return NOERROR;
}

OLEMETHODIMP CMemBytes::UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb,
                                                      DWORD dwLockType)
{
    // REVIEW - Docfiel bug. Must return NOERROR for StgCreateDocfileOnILockbytes
	M_PROLOG(this);
    return NOERROR;
}


OLEMETHODIMP CMemBytes::Stat(STATSTG FAR *pstatstg, DWORD statflag)
{
	M_PROLOG(this);
    VDATEPTROUT( pstatstg, STATSTG );

    pstatstg->pwcsName = NULL;
    pstatstg->type = 0;
    pstatstg->cbSize.HighPart = 0;
    pstatstg->cbSize.LowPart = m_pData->cb;
    pstatstg->mtime.dwLowDateTime = 0;
    pstatstg->mtime.dwHighDateTime = 0;
    pstatstg->ctime.dwLowDateTime = 0;
    pstatstg->ctime.dwHighDateTime = 0;
    pstatstg->atime.dwLowDateTime = 0;
    pstatstg->atime.dwHighDateTime = 0;
    pstatstg->grfMode = 0;
    pstatstg->grfLocksSupported = 0;
    pstatstg->clsid = CLSID_NULL;
    pstatstg->grfStateBits = 0;
    pstatstg->reserved = 0;

    return NOERROR;
}


// Create CMemBytes.  Handle must be a MEMSTM block.
//
OLESTATICIMP_(CMemBytes FAR*) CMemBytes::Create(HANDLE hMem)
{
    CMemBytes FAR* pCMemBytes;
    struct MEMSTM FAR* pData;

	pData = (MEMSTM FAR*)MAKELONG(0, HIWORD(GlobalHandle(hMem)));
    if (pData == NULL)
        return NULL;
	Assert (pData->hGlobal);

    pCMemBytes = new CMemBytes;

    if (pCMemBytes == NULL)
        return NULL;

    // Initialize CMemBytes
    //
	pCMemBytes->m_dwSig = LOCKBYTE_SIG;
    pCMemBytes->m_hMem = hMem;
    (pCMemBytes->m_pData = pData)->cRef++;	// AddRefMemStm
    pCMemBytes->m_refs = 1;

    return pCMemBytes;
}



// CMemStm object's IMarshal implementation
//

OLEMETHODIMP CMarshalMemStm::QueryInterface(REFIID iidInterface,
                                                    void FAR* FAR* ppvObj)
{
	M_PROLOG(this);
    HRESULT error;

    VDATEPTROUT( ppvObj, LPVOID );
    *ppvObj = NULL;
    VDATEIID( iidInterface );

    // Two interfaces supported: IUnknown, IMarshal

    if (iidInterface == IID_IMarshal || iidInterface == IID_IUnknown) {
        m_refs++;           // A pointer to this object is returned
        *ppvObj = this;
        error = NOERROR;
    }
    else {                  // Not accessible or unsupported interface
        *ppvObj = NULL;
        error = ResultFromScode (E_NOINTERFACE);
    }

    return error;
}


// Called when CMarshalMemStm is referenced by an additional pointer.
//

OLEMETHODIMP_(ULONG) CMarshalMemStm::AddRef(void)
{
 	M_PROLOG(this);
   return ++m_refs;
}

// Called when a pointer to this CMarshalMemStm is discarded
//


OLEMETHODIMP_(ULONG) CMarshalMemStm::Release(void)
{
	M_PROLOG(this);
    if (--m_refs != 0) // Still used by others
        return m_refs;

    if (m_pMemStm != NULL)
        m_pMemStm->Release();

    delete this; // Free storage
    return 0;
}


// Returns the clsid of the object that created this CMarshalMemStm.
//

OLEMETHODIMP CMarshalMemStm::GetUnmarshalClass(REFIID riid, LPVOID pv,
    DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags, CLSID FAR* pCid)
{
	M_PROLOG(this);
    VDATEPTROUT( pCid, CLSID);
    VDATEIID( riid );

    *pCid = m_clsid;
    return NOERROR;
}


OLEMETHODIMP CMarshalMemStm::GetMarshalSizeMax(REFIID riid, LPVOID pv,
    DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags, DWORD FAR* pSize)
{
	M_PROLOG(this);
    VDATEIID( riid );
    VDATEIFACE( pv );
    if (pSize) {
        VDATEPTROUT( pSize, DWORD );
        *pSize = NULL;
    }

    *pSize = sizeof(m_pMemStm->m_hMem);
    return NOERROR;
}


OLEMETHODIMP CMarshalMemStm::MarshalInterface(IStream FAR* pStm,
		  REFIID riid, void FAR* pv,
		  DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags)
{
	M_PROLOG(this);
    VDATEPTRIN( pStm, IStream );
    VDATEIID( riid );
    VDATEIFACE( pv );

    if (m_pMemStm == NULL)
        return ReportResult(0, E_UNSPEC, 0, 0);

    if ((riid != IID_IStream && riid != IID_IUnknown) || pv != m_pMemStm)
        return ReportResult(0, E_INVALIDARG, 0, 0);

	// increase ref count on hglobal (ReleaseMarshalData has -- to match)
	HRESULT error;
	if ((error = pStm->Write(&m_pMemStm->m_hMem, sizeof(m_pMemStm->m_hMem),
				NULL)) == NOERROR)
		m_pMemStm->m_pData->cRef++;	// AddRefMemStm

	return error;
}


OLEMETHODIMP CMarshalMemStm::UnmarshalInterface(IStream FAR* pStm,
                                 REFIID riid, void FAR* FAR* ppv)
{
	M_PROLOG(this);
    HRESULT error;
    HANDLE hMem;

    VDATEPTROUT( ppv, LPVOID );
    *ppv = NULL;
    VDATEPTRIN( pStm, IStream );
    VDATEIID( riid );

    if (riid != IID_IStream && riid != IID_IUnknown)
        return ReportResult(0, E_INVALIDARG, 0, 0);

    error = pStm->Read(&hMem,sizeof(hMem),NULL);
    if (error != NOERROR)
        return error;

    if (m_pMemStm != NULL) {

        if (hMem != m_pMemStm->m_hMem)
            return ReportResult(0, E_UNSPEC, 0, 0);
    }
    else {
        m_pMemStm = (CMemStm FAR*) CloneMemStm(hMem);
        if (m_pMemStm == NULL)
            return ReportResult(0, E_OUTOFMEMORY, 0, 0);
    }

    m_pMemStm->AddRef();
    *ppv = (LPVOID) m_pMemStm;
    return NOERROR;
}


OLEMETHODIMP CMarshalMemStm::ReleaseMarshalData(IStream FAR* pStm)
{
	M_PROLOG(this);
	// reduce ref count on hglobal (matches that done in MarshalInterface)
	HRESULT error;
	HANDLE hMem;

    VDATEIFACE( pStm );

    error = pStm->Read(&hMem,sizeof(hMem),NULL);
    if (error == NOERROR)
		ReleaseMemStm(&hMem);

	return error;
}


OLEMETHODIMP CMarshalMemStm::DisconnectObject(DWORD dwReserved)
{
	M_PROLOG(this);
	return NOERROR;
}


OLESTATICIMP_(CMarshalMemStm FAR*) CMarshalMemStm::Create(CMemStm FAR* pMemStm)
{
    CMarshalMemStm FAR* pMMS;

	//VDATEPTRIN rejects NULL
	if( pMemStm )
    	GEN_VDATEPTRIN( pMemStm, CMemStm, (CMarshalMemStm FAR *) NULL );

    pMMS = new CMarshalMemStm;

    if (pMMS == NULL)
        return NULL;

    if (pMemStm != NULL) {
        pMMS->m_pMemStm = pMemStm;
        pMMS->m_pMemStm->AddRef();
    }

    pMMS->m_clsid = CLSID_StdMemStm;

    pMMS->m_refs = 1;

    return pMMS;
}


OLEAPI_(IUnknown FAR*) CMemStmUnMarshal(void)
{
    return CMarshalMemStm::Create(NULL);
}



// CMemBytes object's IMarshal implementation
//

OLEMETHODIMP CMarshalMemBytes::QueryInterface(REFIID iidInterface,
                                                    void FAR* FAR* ppvObj)
{
	M_PROLOG(this);
    HRESULT error;

    VDATEIID( iidInterface );
    VDATEPTROUT( ppvObj, LPVOID );
    *ppvObj = NULL;

    // Two interfaces supported: IUnknown, IMarshal

    if (iidInterface == IID_IMarshal || iidInterface == IID_IUnknown) {
        m_refs++;           // A pointer to this object is returned
        *ppvObj = this;
        error = NOERROR;
    }
    else {                  // Not accessible or unsupported interface
        *ppvObj = NULL;
        error = ReportResult(0, E_NOINTERFACE, 0, 0);
    }

    return error;
}


// Called when CMarshalMemBytes is referenced by an additional pointer.
//

OLEMETHODIMP_(ULONG) CMarshalMemBytes::AddRef(void)
{
	M_PROLOG(this);
    return ++m_refs;
}

// Called when a pointer to this CMarshalMemBytes is discarded
//
OLEMETHODIMP_(ULONG) CMarshalMemBytes::Release(void)
{
	M_PROLOG(this);
    if (--m_refs != 0) // Still used by others
        return m_refs;

    if (m_pMemBytes != NULL)
        m_pMemBytes->Release();

    delete this; // Free storage
    return 0;
}


// Returns the clsid of the object that created this CMarshalMemBytes.
//
OLEMETHODIMP CMarshalMemBytes::GetUnmarshalClass(REFIID riid, LPVOID pv,
    DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags, CLSID FAR* pCid)
{
	M_PROLOG(this);
    VDATEIID( riid );
    VDATEIFACE( pv );

    *pCid = m_clsid;
    return NOERROR;
}


OLEMETHODIMP CMarshalMemBytes::GetMarshalSizeMax(REFIID riid, LPVOID pv,
    DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags, DWORD FAR* pSize)
{
 	M_PROLOG(this);
    VDATEPTROUT( pSize, DWORD );
    VDATEIID( riid );
    VDATEIFACE( pv );

   *pSize = sizeof(m_pMemBytes->m_hMem);
    return NOERROR;
}


OLEMETHODIMP CMarshalMemBytes::MarshalInterface(IStream FAR* pStm,
    REFIID riid, void FAR* pv, DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags)
{
	M_PROLOG(this);
    VDATEPTRIN(pStm, IStream );
    VDATEIID( riid );
    if ( pv )
        VDATEPTRIN( pv , char );

    if (m_pMemBytes == NULL)
        return ReportResult(0, E_UNSPEC, 0, 0);

    if ((riid != IID_ILockBytes && riid != IID_IUnknown) || pv != m_pMemBytes)
        return ReportResult(0, E_INVALIDARG, 0, 0);

	// increase ref count on hglobal (ReleaseMarshalData has -- to match)
	HRESULT error;
	if ((error = pStm->Write(&m_pMemBytes->m_hMem, sizeof(m_pMemBytes->m_hMem),
				NULL)) == NOERROR)
		m_pMemBytes->m_pData->cRef++;	// AddRefMemStm

	return error;
}


OLEMETHODIMP CMarshalMemBytes::UnmarshalInterface(IStream FAR* pStm,
                                 REFIID riid, void FAR* FAR* ppv)
{
	M_PROLOG(this);
    HRESULT error;
    HANDLE hMem;

    VDATEPTROUT( ppv , LPVOID );
    *ppv = NULL;
    VDATEIFACE( pStm );
    VDATEIID( riid );


    if (riid != IID_ILockBytes && riid != IID_IUnknown)
        return ReportResult(0, E_INVALIDARG, 0, 0);

    error = pStm->Read(&hMem,sizeof(hMem),NULL);
    if (error != NOERROR)
        return error;

    if (m_pMemBytes != NULL) {

        if (hMem != m_pMemBytes->m_hMem)
            return ReportResult(0, E_UNSPEC, 0, 0);
    }
    else {
        m_pMemBytes = CMemBytes::Create(hMem); // Create the lockbytes

        if (m_pMemBytes == NULL)
            return ReportResult(0, E_OUTOFMEMORY, 0, 0);
    }

    m_pMemBytes->AddRef();
    *ppv = (LPVOID) m_pMemBytes;
    return NOERROR;
}


OLEMETHODIMP CMarshalMemBytes::ReleaseMarshalData(IStream FAR* pStm)
{
    // reduce ref count on hglobal (matches that done in MarshalInterface)
	M_PROLOG(this);
    HRESULT error;
    MEMSTM FAR* pData;
	HANDLE hMem;

    VDATEIFACE( pStm );

    error = pStm->Read(&hMem,sizeof(hMem),NULL);
    if (error == NOERROR)
		ReleaseMemStm(&hMem);

	return error;
}


OLEMETHODIMP CMarshalMemBytes::DisconnectObject(DWORD dwReserved)
{
	M_PROLOG(this);
	return NOERROR;
}


OLESTATICIMP_(CMarshalMemBytes FAR*) CMarshalMemBytes::Create(
                                                      CMemBytes FAR* pMemBytes)
{
    CMarshalMemBytes FAR* pMMB;

 	//VDATEPTRIN rejects NULL
 	if( pMemBytes )
    	GEN_VDATEPTRIN( pMemBytes, CMemBytes, (CMarshalMemBytes FAR *)NULL );

    pMMB = new CMarshalMemBytes;

    if (pMMB == NULL)
        return NULL;

    if (pMemBytes != NULL) {
        pMMB->m_pMemBytes = pMemBytes;
        pMMB->m_pMemBytes->AddRef();
    }

    pMMB->m_clsid = CLSID_StdMemBytes;

    pMMB->m_refs = 1;

    return pMMB;
}

OLEAPI_(IUnknown FAR*) CMemBytesUnMarshal(void)
{
    return CMarshalMemBytes::Create(NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\ole2\ole2.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	ole2.cxx
//
//  Contents:	Thunk ole2.dll common code
//
//  History:	07-Mar-94	DrewB	Created
//
//----------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#include <call32.hxx>
#include <apilist.hxx>

#include <ole2int.h>

DECLARE_INFOLEVEL(thk1);

// Not in any OLE2 header
extern UINT uOleMessage;

HMODULE hmodOLE2 = NULL;

//+---------------------------------------------------------------------------
//
//  Function:	LibMain, public, Local
//
//  Synopsis:	DLL initialization function
//
//  Arguments:	[hinst] - Instance handle
//              [wDataSeg] - Current DS
//              [cbHeapSize] - Heap size for the DLL
//              [lpszCmdLine] - Command line information
//
//  Returns:	One for success, zero for failure
//
//  History:	21-Feb-94	DrewB	Created
//
//----------------------------------------------------------------------------

#if DBG == 1
static char achInfoLevel[32];
#endif

extern "C" int CALLBACK LibMain(HINSTANCE hinst,
                                WORD wDataSeg,
                                WORD cbHeapSize,
                                LPSTR lpszCmdLine)
{
#if DBG == 1
    if (GetProfileString("olethk32", "ole2", "3", achInfoLevel,
                         sizeof(achInfoLevel)) > 0)
    {
        thk1InfoLevel = strtoul(achInfoLevel, NULL, 0);
    }


    if ((thk1InfoLevel == 3) &&
	 GetProfileString("olethk32", "Infolevel", "3", achInfoLevel,
                         sizeof(achInfoLevel)) > 0)
    {
        thk1InfoLevel = strtoul(achInfoLevel, NULL, 0);
    }
#endif

#if defined(_CHICAGO_)
    //
    //  The Chicago debugger doesn't like hinst not being wired.
    //
    GlobalWire(hinst);
#endif

    // The original OLE2 code does not check for success on this call
    // so neither do we
    uOleMessage		 = RegisterWindowMessage("OLE_MESSAHE");

    hmodOLE2 = hinst;

    return 1;
}

//+---------------------------------------------------------------------------
//
//  Function:	WEP, public, Local
//
//  Synopsis:	Windows Exit Point routine, for receiving DLL unload
//              notification
//
//  Arguments:	[nExitType] - Type of exit occurring
//
//  Returns:	One for success, zero for failure
//
//  History:	21-Feb-94	DrewB	Created
//
//----------------------------------------------------------------------------

extern "C" int CALLBACK WEP(int nExitType)
{
    // Clean up thunk objects?
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\ole2\ole2dthk.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       ole2dthk.cxx    (16 bit target)
//
//  Contents:   OLE2 APIs that are directly thunked
//
//  History:    17-Dec-93 Johann Posch (johannp)    Created
//
//--------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#include <ole2ver.h>

#include <call32.hxx>
#include <apilist.hxx>

STDAPI_(HOLEMENU) OleCreateMenuDescriptor (HMENU hmenuCombined,
                                           LPOLEMENUGROUPWIDTHS lplMenuWidths)
{
    return (HOLEMENU)CallObjectInWOW(THK_API_METHOD(THK_API_OleCreateMenuDescriptor),
                                     PASCAL_STACK_PTR(hmenuCombined));
}

STDAPI OleDestroyMenuDescriptor (HOLEMENU holemenu)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleDestroyMenuDescriptor),
                                    PASCAL_STACK_PTR(holemenu));
}

//+---------------------------------------------------------------------------
//
//  Function:   DllGetClassObject, Remote
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [clsid] --
//      [iid] --
//      [ppv] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  DllGetClassObject(REFCLSID clsid, REFIID iid, void FAR* FAR* ppv)
{
    /* Relies on the fact that storage and ole2.dll both use the
       same DllGetClassObject in ole32.dll */
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_DllGetClassObject),
                                    PASCAL_STACK_PTR(clsid));
}

/* helper functions */
//+---------------------------------------------------------------------------
//
//  Function:   ReadClassStg, Remote
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pStg] --
//      [pclsid] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI ReadClassStg(LPSTORAGE pStg, CLSID FAR* pclsid)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_ReadClassStg),
                                    PASCAL_STACK_PTR(pStg));
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteClassStg, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pStg] --
//      [rclsid] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI WriteClassStg(LPSTORAGE pStg, REFCLSID rclsid)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_WriteClassStg),
                                    PASCAL_STACK_PTR(pStg));
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteFmtUserTypeStg, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pstg] --
//      [cf] --
//      [lpszUserType] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI WriteFmtUserTypeStg (LPSTORAGE pstg, CLIPFORMAT cf, LPSTR lpszUserType)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_WriteFmtUserTypeStg),
                                    PASCAL_STACK_PTR(pstg));
}

//+---------------------------------------------------------------------------
//
//  Function:   ReadFmtUserTypeStg, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pstg] --
//      [pcf] --
//      [lplpszUserType] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI ReadFmtUserTypeStg (LPSTORAGE pstg, CLIPFORMAT FAR* pcf,
                           LPSTR FAR* lplpszUserType)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_ReadFmtUserTypeStg),
                                    PASCAL_STACK_PTR(pstg));
}

/* APIs to query whether (Embedded/Linked) object can be created from
   the data object */

//+---------------------------------------------------------------------------
//
//  Function:   OleQueryLinkFromData, Unknown
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pSrcDataObject] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  OleQueryLinkFromData(LPDATAOBJECT pSrcDataObject)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleQueryLinkFromData),
                                    PASCAL_STACK_PTR(pSrcDataObject));
}

//+---------------------------------------------------------------------------
//
//  Function:   OleQueryCreateFromData, Unknown
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pSrcDataObject] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  OleQueryCreateFromData(LPDATAOBJECT pSrcDataObject)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleQueryCreateFromData),
                                    PASCAL_STACK_PTR(pSrcDataObject) );
}



/* Object creation APIs */

//+---------------------------------------------------------------------------
//
//  Function:   OleCreate, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [rclsid] --
//      [riid] --
//      [renderopt] --
//      [pFormatEtc] --
//      [pClientSite] --
//      [pStg] --
//      [ppvObj] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  OleCreate(REFCLSID rclsid, REFIID riid, DWORD renderopt,
                  LPFORMATETC pFormatEtc, LPOLECLIENTSITE pClientSite,
                  LPSTORAGE pStg, LPVOID FAR* ppvObj)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleCreate),
                                    PASCAL_STACK_PTR(rclsid));
}


//+---------------------------------------------------------------------------
//
//  Function:   OleCreateFromData, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pSrcDataObj] --
//      [riid] --
//      [renderopt] --
//      [pFormatEtc] --
//      [pClientSite] --
//      [pStg] --
//      [ppvObj] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  OleCreateFromData(LPDATAOBJECT pSrcDataObj, REFIID riid,
                          DWORD renderopt, LPFORMATETC pFormatEtc,
                          LPOLECLIENTSITE pClientSite, LPSTORAGE pStg,
                          LPVOID FAR* ppvObj)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleCreateFromData),
                                    PASCAL_STACK_PTR(pSrcDataObj));
}


//+---------------------------------------------------------------------------
//
//  Function:   OleCreateLinkFromData, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pSrcDataObj] --
//      [riid] --
//      [renderopt] --
//      [pFormatEtc] --
//      [pClientSite] --
//      [pStg] --
//      [ppvObj] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  OleCreateLinkFromData(LPDATAOBJECT pSrcDataObj, REFIID riid,
                              DWORD renderopt, LPFORMATETC pFormatEtc,
                              LPOLECLIENTSITE pClientSite, LPSTORAGE pStg,
                              LPVOID FAR* ppvObj)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleCreateLinkFromData),
                                    PASCAL_STACK_PTR(pSrcDataObj));
}


//+---------------------------------------------------------------------------
//
//  Function:   OleCreateStaticFromData, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pSrcDataObj] --
//      [iid] --
//      [renderopt] --
//      [pFormatEtc] --
//      [pClientSite] --
//      [pStg] --
//      [ppvObj] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  OleCreateStaticFromData(LPDATAOBJECT pSrcDataObj, REFIID iid,
                DWORD renderopt, LPFORMATETC pFormatEtc,
                LPOLECLIENTSITE pClientSite, LPSTORAGE pStg,
                LPVOID FAR* ppvObj)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleCreateStaticFromData),
                                    PASCAL_STACK_PTR(pSrcDataObj));
}



//+---------------------------------------------------------------------------
//
//  Function:   OleCreateLink, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pmkLinkSrc] --
//      [riid] --
//      [renderopt] --
//      [lpFormatEtc] --
//      [pClientSite] --
//      [pStg] --
//      [ppvObj] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  OleCreateLink(LPMONIKER pmkLinkSrc, REFIID riid,
                      DWORD renderopt, LPFORMATETC lpFormatEtc,
                      LPOLECLIENTSITE pClientSite, LPSTORAGE pStg,
                      LPVOID FAR* ppvObj)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleCreateLink),
                                    PASCAL_STACK_PTR(pmkLinkSrc));
}


//+---------------------------------------------------------------------------
//
//  Function:   OleCreateLinkToFile, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [lpszFileName] --
//      [riid] --
//      [renderopt] --
//      [lpFormatEtc] --
//      [pClientSite] --
//      [pStg] --
//      [ppvObj] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  OleCreateLinkToFile(LPCSTR lpszFileName, REFIID riid,
            DWORD renderopt, LPFORMATETC lpFormatEtc,
            LPOLECLIENTSITE pClientSite, LPSTORAGE pStg, LPVOID FAR* ppvObj)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleCreateLinkToFile),
                                    PASCAL_STACK_PTR(lpszFileName));
}


//+---------------------------------------------------------------------------
//
//  Function:   OleCreateFromFile, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [rclsid] --
//      [lpszFileName] --
//      [riid] --
//      [renderopt] --
//      [lpFormatEtc] --
//      [pClientSite] --
//      [pStg] --
//      [ppvObj] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  OleCreateFromFile(REFCLSID rclsid, LPCSTR lpszFileName, REFIID riid,
                          DWORD renderopt, LPFORMATETC lpFormatEtc,
                          LPOLECLIENTSITE pClientSite, LPSTORAGE pStg,
                          LPVOID FAR* ppvObj)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleCreateFromFile),
                                    PASCAL_STACK_PTR(rclsid));
}


//+---------------------------------------------------------------------------
//
//  Function:   OleLoad, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pStg] --
//      [riid] --
//      [pClientSite] --
//      [ppvObj] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  OleLoad(LPSTORAGE pStg, REFIID riid, LPOLECLIENTSITE pClientSite,
                LPVOID FAR* ppvObj)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleLoad),
                                    PASCAL_STACK_PTR(pStg));
}


//+---------------------------------------------------------------------------
//
//  Function:   OleSave, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pPS] --
//      [pStg] --
//      [fSameAsLoad] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  OleSave(LPPERSISTSTORAGE pPS, LPSTORAGE pStg, BOOL fSameAsLoad)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleSave),
                                    PASCAL_STACK_PTR(pPS));
}


//+---------------------------------------------------------------------------
//
//  Function:   OleLoadFromStream, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pStm] --
//      [iidInterface] --
//      [ppvObj] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  OleLoadFromStream( LPSTREAM pStm, REFIID iidInterface,
                           LPVOID FAR* ppvObj)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleLoadFromStream),
                                    PASCAL_STACK_PTR(pStm));
}

//+---------------------------------------------------------------------------
//
//  Function:   OleSaveToStream, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pPStm] --
//      [pStm] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  OleSaveToStream( LPPERSISTSTREAM pPStm, LPSTREAM pStm )
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleSaveToStream),
                                    PASCAL_STACK_PTR(pPStm));
}



//+---------------------------------------------------------------------------
//
//  Function:   OleSetContainedObject, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pUnknown] --
//      [fContained] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  OleSetContainedObject(LPUNKNOWN pUnknown, BOOL fContained)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleSetContainedObject),
                                    PASCAL_STACK_PTR(pUnknown));
}

//+---------------------------------------------------------------------------
//
//  Function:   OleNoteObjectVisible, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pUnknown] --
//      [fVisible] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  OleNoteObjectVisible(LPUNKNOWN pUnknown, BOOL fVisible)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleNoteObjectVisible),
                                    PASCAL_STACK_PTR(pUnknown));
}


/* Drag/Drop APIs */

//+---------------------------------------------------------------------------
//
//  Function:   RegisterDragDrop, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [hwnd] --
//      [pDropTarget] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  RegisterDragDrop(HWND hwnd, LPDROPTARGET pDropTarget)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_RegisterDragDrop),
                                    PASCAL_STACK_PTR(hwnd));
}

//+---------------------------------------------------------------------------
//
//  Function:   RevokeDragDrop, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [hwnd] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  RevokeDragDrop(HWND hwnd)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_RevokeDragDrop),
                                    PASCAL_STACK_PTR(hwnd));
}

//+---------------------------------------------------------------------------
//
//  Function:   DoDragDrop, Unknown
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pDataObj] --
//      [pDropSource] --
//      [dwOKEffects] --
//      [pdwEffect] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  DoDragDrop(LPDATAOBJECT pDataObj, LPDROPSOURCE pDropSource,
            DWORD dwOKEffects, LPDWORD pdwEffect)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_DoDragDrop),
                                    PASCAL_STACK_PTR(pDataObj));
}


/* Clipboard APIs */

//+---------------------------------------------------------------------------
//
//  Function:   OleSetClipboard, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pDataObj] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  OleSetClipboard(LPDATAOBJECT pDataObj)
{
    if (pDataObj != NULL)
    {
        HRESULT hr;
        IDataObject FAR *pdoNull = NULL;

        /* If we are setting the clipboard's data object we first force
           the clipboard to an empty state.  This avoids a problem with
           Word where it always uses the same data object pointer in
           every clipboard call which results in the reference counts
           being too high since we reuse the proxy and addref it on
           the way in */
        hr = (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleSetClipboard),
                                      PASCAL_STACK_PTR(pdoNull));
        if (FAILED(GetScode(hr)))
        {
            return hr;
        }
    }

    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleSetClipboard),
                                    PASCAL_STACK_PTR(pDataObj));
}

//+---------------------------------------------------------------------------
//
//  Function:   OleGetClipboard, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [ppDataObj] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  OleGetClipboard(LPDATAOBJECT FAR* ppDataObj)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleGetClipboard),
                                    PASCAL_STACK_PTR(ppDataObj));
}

//+---------------------------------------------------------------------------
//
//  Function:   OleFlushClipboard, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [void] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  OleFlushClipboard(void)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleFlushClipboard),
                                    NULL);
}

//+---------------------------------------------------------------------------
//
//  Function:   OleIsCurrentClipboard, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pDataObj] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  OleIsCurrentClipboard(LPDATAOBJECT pDataObj)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleIsCurrentClipboard),
                                    PASCAL_STACK_PTR(pDataObj));
}


/* InPlace Editing APIs */

//+---------------------------------------------------------------------------
//
//  Function:   OleSetMenuDescriptor, Unknown
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [holemenu] --
//      [hwndFrame] --
//      [hwndActiveObject] --
//      [lpFrame] --
//      [lpActiveObj] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI OleSetMenuDescriptor (HOLEMENU holemenu, HWND hwndFrame,
                             HWND hwndActiveObject,
                             LPOLEINPLACEFRAME lpFrame,
                             LPOLEINPLACEACTIVEOBJECT lpActiveObj)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleSetMenuDescriptor),
                                    PASCAL_STACK_PTR(holemenu));
}

//+---------------------------------------------------------------------------
//
//  Function:   OleDraw, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pUnknown] --
//      [dwAspect] --
//      [hdcDraw] --
//      [lprcBounds] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI OleDraw (LPUNKNOWN pUnknown, DWORD dwAspect, HDC hdcDraw,
                LPCRECT lprcBounds)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleDraw),
                                    PASCAL_STACK_PTR(pUnknown));
}


//+---------------------------------------------------------------------------
//
//  Function:   OleRun, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pUnknown] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI          OleRun(LPUNKNOWN pUnknown)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleRun),
                                    PASCAL_STACK_PTR(pUnknown));
}


//+---------------------------------------------------------------------------
//
//  Function:   OleIsRunning
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pObject] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI_(BOOL) OleIsRunning(LPOLEOBJECT pObject)
{
    return (BOOL)CallObjectInWOW(THK_API_METHOD(THK_API_OleIsRunning),
                                 PASCAL_STACK_PTR(pObject));
}

//+---------------------------------------------------------------------------
//
//  Function:   OleLockRunning, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pUnknown] --
//      [fLock] --
//      [fLastUnlockCloses] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI OleLockRunning(LPUNKNOWN pUnknown, BOOL fLock, BOOL fLastUnlockCloses)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleLockRunning),
                                    PASCAL_STACK_PTR(pUnknown));
}

//+---------------------------------------------------------------------------
//
//  Function:   CreateOleAdviseHolder, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [ppOAHolder] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI          CreateOleAdviseHolder(LPOLEADVISEHOLDER FAR* ppOAHolder)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_CreateOleAdviseHolder),
                                    PASCAL_STACK_PTR(ppOAHolder));
}


//+---------------------------------------------------------------------------
//
//  Function:   OleCreateDefaultHandler, Unknown
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [clsid] --
//      [pUnkOuter] --
//      [riid] --
//      [lplpObj] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI OleCreateDefaultHandler(REFCLSID clsid, LPUNKNOWN pUnkOuter,
                               REFIID riid, LPVOID FAR* lplpObj)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleCreateDefaultHandler),
                                    PASCAL_STACK_PTR(clsid));
}


//+---------------------------------------------------------------------------
//
//  Function:   OleCreateEmbeddingHelper, Unknown
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [clsid] --
//      [pUnkOuter] --
//      [flags] --
//      [pCF] --
//      [riid] --
//      [lplpObj] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI OleCreateEmbeddingHelper(REFCLSID clsid, LPUNKNOWN pUnkOuter,
                                DWORD flags, LPCLASSFACTORY pCF,
                                REFIID riid, LPVOID FAR* lplpObj)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleCreateEmbeddingHelper),
                                    PASCAL_STACK_PTR(clsid));
}

/* Registration Database Helper APIs */

//+---------------------------------------------------------------------------
//
//  Function:   OleRegGetUserType, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [clsid] --
//      [dwFormOfType] --
//      [pszUserType] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI OleRegGetUserType (REFCLSID clsid, DWORD dwFormOfType,
                          LPSTR FAR* pszUserType)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleRegGetUserType),
                                    PASCAL_STACK_PTR(clsid));
}


//+---------------------------------------------------------------------------
//
//  Function:   OleRegGetMiscStatus, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [clsid] --
//      [dwAspect] --
//      [pdwStatus] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI OleRegGetMiscStatus(REFCLSID clsid, DWORD dwAspect,
                           DWORD FAR* pdwStatus)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleRegGetMiscStatus),
                                    PASCAL_STACK_PTR(clsid));
}


//+---------------------------------------------------------------------------
//
//  Function:   OleRegEnumFormatEtc, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [clsid] --
//      [dwDirection] --
//      [ppenum] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI OleRegEnumFormatEtc(REFCLSID clsid, DWORD dwDirection,
                           LPENUMFORMATETC FAR* ppenum)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleRegEnumFormatEtc),
                                    PASCAL_STACK_PTR(clsid));
}


//+---------------------------------------------------------------------------
//
//  Function:   OleRegEnumVerbs, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [clsid] --
//      [ppenum] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI OleRegEnumVerbs(REFCLSID clsid, LPENUMOLEVERB FAR* ppenum)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleRegEnumVerbs),
                                    PASCAL_STACK_PTR(clsid));
}

/* OLE 1.0 conversion APIS */

//+---------------------------------------------------------------------------
//
//  Function:   OleConvertIStorageToOLESTREAM, Unknown
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pstg] --
//      [polestm] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI OleConvertIStorageToOLESTREAM(LPSTORAGE pstg,
                                     LPOLESTREAM polestm)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleConvertIStorageToOLESTREAM),
                                    PASCAL_STACK_PTR(pstg));
}


//+---------------------------------------------------------------------------
//
//  Function:   OleConvertOLESTREAMToIStorage, Unknown
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [polestm] --
//      [pstg] --
//      [ptd] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI OleConvertOLESTREAMToIStorage(LPOLESTREAM polestm,
                                     LPSTORAGE pstg,
                                     const DVTARGETDEVICE FAR* ptd)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleConvertOLESTREAMToIStorage),
                                    PASCAL_STACK_PTR(polestm));
}


//+---------------------------------------------------------------------------
//
//  Function:   OleConvertIStorageToOLESTREAMEx, Unknown
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pstg] --
//      [cfFormat] --
//      [lWidth] --
//      [lHeight] --
//      [dwSize] --
//      [pmedium] --
//      [polestm] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI OleConvertIStorageToOLESTREAMEx(
        LPSTORAGE       pstg,           // Presentation data to OLESTREAM
        CLIPFORMAT      cfFormat,       //              format
        LONG            lWidth,         //              width
        LONG            lHeight,        //              height
        DWORD           dwSize,         //              size in bytes
        LPSTGMEDIUM     pmedium,        //              bits
        LPOLESTREAM     polestm)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleConvertIStorageToOLESTREAMEx),
                                    PASCAL_STACK_PTR(pstg));
}


//+---------------------------------------------------------------------------
//
//  Function:   OleConvertOLESTREAMToIStorageEx, Unknown
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [polestm] --
//      [pstg] --
//      [pcfFormat] --
//      [plwWidth] --
//      [plHeight] --
//      [pdwSize] --
//      [pmedium] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI OleConvertOLESTREAMToIStorageEx(
        LPOLESTREAM     polestm,
        LPSTORAGE       pstg,           // Presentation data from OLESTREAM
        CLIPFORMAT FAR* pcfFormat,      //              format
        LONG FAR*       plwWidth,       //              width
        LONG FAR*       plHeight,       //              height
        DWORD FAR*      pdwSize,        //              size in bytes
        LPSTGMEDIUM     pmedium)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleConvertOLESTREAMToIStorageEx),
                                    PASCAL_STACK_PTR(polestm));
}

/* ConvertTo APIS */

//+---------------------------------------------------------------------------
//
//  Function:   OleGetAutoConvert, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [clsidOld] --
//      [pClsidNew] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI OleGetAutoConvert(REFCLSID clsidOld, LPCLSID pClsidNew)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleGetAutoConvert),
                                    PASCAL_STACK_PTR(clsidOld));
}

//+---------------------------------------------------------------------------
//
//  Function:   OleSetAutoConvert, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [clsidOld] --
//      [clsidNew] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI OleSetAutoConvert(REFCLSID clsidOld, REFCLSID clsidNew)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleSetAutoConvert),
                                    PASCAL_STACK_PTR(clsidOld));
}

//+---------------------------------------------------------------------------
//
//  Function:   GetConvertStg, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pStg] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI GetConvertStg(LPSTORAGE pStg)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_GetConvertStg),
                                    PASCAL_STACK_PTR(pStg));
}

//+---------------------------------------------------------------------------
//
//  Function:   SetConvertStg, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pStg] --
//      [fConvert] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI SetConvertStg(LPSTORAGE pStg, BOOL fConvert)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_SetConvertStg),
                                    PASCAL_STACK_PTR(pStg));
}

//+---------------------------------------------------------------------------
//
//  Function:   CreateDataAdviseHolder, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [ppDAHolder] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CreateDataAdviseHolder(LPDATAADVISEHOLDER FAR* ppDAHolder)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_CreateDataAdviseHolder),
                                    PASCAL_STACK_PTR(ppDAHolder));
}

//+---------------------------------------------------------------------------
//
//  Function:   CreateDataCache, Unknown
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pUnkOuter] --
//      [rclsid] --
//      [iid] --
//      [ppv] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI CreateDataCache(LPUNKNOWN pUnkOuter, REFCLSID rclsid,
                       REFIID iid, LPVOID FAR* ppv)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_CreateDataCache),
                                    PASCAL_STACK_PTR(pUnkOuter));
}

//+---------------------------------------------------------------------------
//
//  Function:   Utility functions not in the spec; in ole2.dll.
//
//  History:    20-Apr-94       DrewB   Taken from OLE2 sources
//
//----------------------------------------------------------------------------

STDAPI ReadOleStg
   (LPSTORAGE pstg, DWORD FAR* pdwFlags, DWORD FAR* pdwOptUpdate,
    DWORD FAR* pdwReserved, LPMONIKER FAR* ppmk, LPSTREAM FAR* ppstmOut)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_ReadOleStg),
                                    PASCAL_STACK_PTR(pstg));
}

STDAPI WriteOleStg
   (LPSTORAGE pstg, IOleObject FAR* pOleObj,
    DWORD dwReserved, LPSTREAM FAR* ppstmOut)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_WriteOleStg),
                                    PASCAL_STACK_PTR(pstg));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\ole2\ole2lcl.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	ole2lcl.cxx	(16 bit target)
//
//  Contents:	OLE2 APIs implemented locally
//
//  Functions:	
//
//  History:	17-Dec-93 Johann Posch (johannp)    Created
//
//--------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#include <limits.h>

#include <ole2sp.h>
#include <ole2ver.h>
#include <valid.h>
#include <ole2int.h>

#include <call32.hxx>
#include <apilist.hxx>

DWORD gdwOleVersion = MAKELONG(OLE_STREAM_VERSION, OLE_PRODUCT_VERSION);

//+---------------------------------------------------------------------------
//
//  Function:   OleGetMalloc, Local
//
//----------------------------------------------------------------------------
STDAPI OleGetMalloc(DWORD dwContext, IMalloc FAR* FAR* ppMalloc)
{
    return CoGetMalloc(dwContext, ppMalloc);
}

//+---------------------------------------------------------------------------
//
//  Function:   OleBuildVersion, Local
//
//----------------------------------------------------------------------------

STDAPI_(DWORD) OleBuildVersion( VOID )
{
    return CoBuildVersion();
}

//+---------------------------------------------------------------------------
//
//  Function:	OleDuplicateData, Local
//
//  Synopsis:	Duplicates the given data
//
//  History:	11-Apr-94	DrewB	Copied from various places in OLE2
//
//----------------------------------------------------------------------------

FARINTERNAL_(HBITMAP) BmDuplicate 
	(HBITMAP hold, DWORD FAR* lpdwSize, LPBITMAP lpBm)
{
    HBITMAP     hnew = NULL;
    HANDLE      hMem;
    LPSTR       lpMem;
    DWORD       dwSize;
    BITMAP      bm;
    SIZE		extents;

    extents.cx = extents.cy = 0;

    GetObject (hold, sizeof(BITMAP), (LPSTR) &bm);
    dwSize = ((DWORD) bm.bmHeight) * ((DWORD) bm.bmWidthBytes) * 
             ((DWORD) bm.bmPlanes);

    if (!(hMem = GlobalAlloc (GMEM_MOVEABLE, dwSize)))
        return NULL;

    if (!(lpMem = (LPSTR) GlobalLock (hMem)))
		goto errRtn;
	GlobalUnlock (hMem);
    
    GetBitmapBits (hold, dwSize, lpMem);
    if (hnew = CreateBitmap (bm.bmWidth, bm.bmHeight, 
                    bm.bmPlanes, bm.bmBitsPixel, NULL)) {
        if (!SetBitmapBits (hnew, dwSize, lpMem)) {
			DeleteObject (hnew);
			hnew = NULL;
			goto errRtn;
		}
	}

	if (lpdwSize)
		*lpdwSize = dwSize;
    
	if (lpBm)
        *lpBm = bm;
    
    if (GetBitmapDimensionEx(hold, &extents) && extents.cx && extents.cy)
        SetBitmapDimensionEx(hnew, extents.cx, extents.cy, NULL);
        
errRtn:
	if (hMem)
		GlobalFree (hMem);
        
	return hnew;
}

FARINTERNAL_(HPALETTE) UtDupPalette
	(HPALETTE hpalette) 
{
	WORD 			cEntries = 0;
	HANDLE 			hLogPal = NULL;
	LPLOGPALETTE 	pLogPal = NULL;
	HPALETTE		hpaletteNew = NULL;

	if (0==GetObject (hpalette, sizeof(cEntries), &cEntries))
		return NULL;

	if (NULL==(hLogPal = GlobalAlloc (GMEM_MOVEABLE, sizeof (LOGPALETTE) + 
										cEntries * sizeof (PALETTEENTRY))))
		return NULL;

	if (NULL==(pLogPal = (LPLOGPALETTE) GlobalLock (hLogPal)))
		goto errRtn;
		
	if (0==GetPaletteEntries (hpalette, 0, cEntries, pLogPal->palPalEntry))
		goto errRtn;

	pLogPal->palVersion    = 0x300;
	pLogPal->palNumEntries = cEntries;

	if (NULL==(hpaletteNew = CreatePalette (pLogPal)))
		goto errRtn;

errRtn:
	if (pLogPal)
		GlobalUnlock (hLogPal);
	if (hLogPal)
		GlobalFree (hLogPal);
	AssertSz (hpaletteNew, "Warning: UtDupPalette Failed");
	return hpaletteNew;
}
	
FARINTERNAL_(HANDLE) UtDupGlobal (HANDLE hsrc, UINT uiFlags)
{
    HANDLE  hdst;
    DWORD   dwSize;
#ifndef _MAC
    LPSTR   lpdst = NULL;
    LPSTR   lpsrc = NULL;
#endif

    if (!hsrc)
        return NULL;

#ifdef _MAC
	if (!(hdst = NewHandle(dwSize = GetHandleSize(hsrc))))
		return NULL;
	BlockMove(*hsrc, *hdst, dwSize);
	return hdst;
#else
    if (!(lpsrc = GlobalLock (hsrc)))
	return NULL;

    hdst = GlobalAlloc (uiFlags, (dwSize = GlobalSize(hsrc)));
    if (hdst == NULL || (lpdst = GlobalLock (hdst)) == NULL)
	goto errRtn;
	
    UtMemCpy (lpdst, lpsrc, dwSize);
    GlobalUnlock (hsrc);
    GlobalUnlock (hdst);
    return hdst;
	
errRtn:
    if (hdst) 
        GlobalFree (hdst);
    
    return NULL;
#endif
}

OLEAPI_(HANDLE) OleDuplicateData 
	(HANDLE hSrc, CLIPFORMAT cfFormat, UINT uiFlags)
{
#ifndef _MAC	
	if (!hSrc) 
		return NULL;

	if (cfFormat == CF_BITMAP)
		return (HANDLE) BmDuplicate ((HBITMAP)hSrc, NULL, NULL);

	if (cfFormat == CF_PALETTE)
  		return (HANDLE) UtDupPalette ((HPALETTE)hSrc);

	if (uiFlags == NULL)
		uiFlags = GMEM_MOVEABLE;

	if (cfFormat == CF_METAFILEPICT) {
		HANDLE	hDst;

		LPMETAFILEPICT lpmfpSrc;
		LPMETAFILEPICT lpmfpDst;

		if (!(lpmfpSrc = (LPMETAFILEPICT) GlobalLock (hSrc)))
			return NULL;
		
		if (!(hDst = UtDupGlobal (hSrc, uiFlags)))
			return NULL;
		
		if (!(lpmfpDst = (LPMETAFILEPICT) GlobalLock (hDst))) {
			GlobalFree (hDst);
			return NULL;
		}			
		
		*lpmfpDst = *lpmfpSrc;
		lpmfpDst->hMF = CopyMetaFile (lpmfpSrc->hMF, NULL);
		GlobalUnlock (hSrc);	
		GlobalUnlock (hDst);			
		return hDst;
	
	} else {
		return  UtDupGlobal (hSrc, uiFlags);
	}
#else
	AssertSz(0,"OleDuplicateData NYI");
	return NULL;
#endif
}

//+---------------------------------------------------------------------------
//
//  Function:	SetBitOleStg, private
//
//  Synopsis:   Sets bit in ole stream; doc bit preserved even when stream
//              rewritten above; the value written is (old & mask) | value.
//
//  Arguments:	[pstg] - Storage
//              [mask] - Mask
//              [value] - Value
//
//  Returns:	Appropriate status code
//
//  History:	11-Mar-94	DrewB	Created
//
//  Notes:	Taken straight from OLE2 source
//
//----------------------------------------------------------------------------

static INTERNAL SetBitOleStg(LPSTORAGE pstg, DWORD mask, DWORD value)
{
    IStream FAR *   pstm = NULL;
    HRESULT	    error;
    DWORD	    objflags = 0;
    LARGE_INTEGER   large_integer;
    ULONG           cbRead;

    VDATEIFACE( pstg );

    if (error = pstg->OpenStream(OLE_STREAM, NULL, STGM_SALL, 0, &pstm))
    {
        if (STG_E_FILENOTFOUND != GetScode(error))
        {
            goto errRtn;
        }

        if (error = pstg->CreateStream(OLE_STREAM, STGM_SALL, 0, 0, &pstm))
        {
            goto errRtn;
        }

        DWORD dwBuf[5];
        		
        dwBuf[0] = gdwOleVersion;
        dwBuf[1] = objflags;
        dwBuf[2] = 0L;
        dwBuf[3] = 0L;
        dwBuf[4] = 0L;
		
        if ((error = pstm->Write(dwBuf, 5*sizeof(DWORD), NULL)) != NOERROR)
        {
            goto errRtn;
        }
    }

    // seek directly to word, read, modify, seek back and write.
    LISet32( large_integer, sizeof(DWORD) );
    if ((error = pstm->Seek(large_integer, STREAM_SEEK_SET, NULL)) != NOERROR)
    {
        goto errRtn;
    }

    if ((error = pstm->Read(&objflags, sizeof(objflags), &cbRead)) != NOERROR)
    {
        goto errRtn;
    }
    if (cbRead != sizeof(objflags))
    {
        goto errRtn;
    }

    objflags = (objflags & mask) | value;

    LISet32( large_integer, sizeof(DWORD) );
    if ((error = pstm->Seek(large_integer, STREAM_SEEK_SET, NULL)) != NOERROR)
    {
        goto errRtn;
    }

    error = pstm->Write(&objflags, sizeof(DWORD), NULL);
	
 errRtn:
    // close and return error code.
    if (pstm)
    {
        pstm->Release();
    }
    
    return error;
}

//+---------------------------------------------------------------------------
//
//  Function:	GetFlagsOleStg, private
//
//  Synopsis:	Return long word of flags from the ole stream
//
//  Arguments:	[pstg] - Storage
//              [lpobjflags] - Flags return
//
//  Returns:	Appropriate status code
//
//  Modifies:	[lpobjflags]
//
//  History:	11-Mar-94	DrewB	Created
//
//  Notes:	Taken straight from OLE2 source
//
//----------------------------------------------------------------------------

static INTERNAL GetFlagsOleStg(LPSTORAGE pstg, LPDWORD lpobjflags)
{
    IStream FAR *   pstm = NULL;
    HRESULT	    error;
    LARGE_INTEGER   large_integer;
    ULONG           cbRead;

    VDATEIFACE( pstg );

    if ((error = pstg->OpenStream(OLE_STREAM, NULL, 
                                  (STGM_READ | STGM_SHARE_EXCLUSIVE), 
                                  0, &pstm)) != NOERROR)
    {
        goto errRtn;
    }

    // seek directly to word, read, modify, seek back and write.
    LISet32( large_integer, sizeof(DWORD) );
    if ((error =  pstm->Seek(large_integer, STREAM_SEEK_SET, NULL)) != NOERROR)
    {
        goto errRtn;
    }

    error = pstm->Read(lpobjflags, sizeof(*lpobjflags), &cbRead);
    if (SUCCEEDED(GetScode(error)) && cbRead != sizeof(*lpobjflags))
    {
        error = ResultFromScode(STG_E_READFAULT);
    }

 errRtn:
    // close and return error NOERROR (document)/S_FALSE (embedding);
    if (pstm)
    {
        pstm->Release();
    }
    
    return error == NOERROR ? NOERROR : ReportResult(0, S_FALSE, 0, 0);
}

//+---------------------------------------------------------------------------
//
//  Function:	GetDocumentBitStg, semi-private
//
//  Synopsis:   Get doc bit; return NOERROR if on; S_FALSE if off
//
//  Arguments:	[pStg] - Storage
//
//  Returns:	Appropriate status code
//
//  History:	11-Mar-94	DrewB	Created
//
//  Notes:	Taken straight from OLE2 source
//
//----------------------------------------------------------------------------

STDAPI GetDocumentBitStg(LPSTORAGE pStg)
{
    DWORD objflags;
    HRESULT error;

    if ((error = GetFlagsOleStg(pStg, &objflags)) != NOERROR)
    {
        return error;
    }

    return (objflags&OBJFLAGS_DOCUMENT) ? NOERROR : ResultFromScode(S_FALSE);
}

//+---------------------------------------------------------------------------
//
//  Function:	SetDocumentBitStg, semi-private
//
//  Synopsis:	Set doc bit according to fDocument
//
//  Arguments:	[pStg] - Storage
//              [fDocument] - Document flag
//
//  Returns:	Appropriate status code
//
//  History:	11-Mar-94	DrewB	Created
//
//  Notes:	Taken straight from OLE2 source
//
//----------------------------------------------------------------------------

STDAPI SetDocumentBitStg(LPSTORAGE pStg, BOOL fDocument)
{
    return SetBitOleStg(pStg, fDocument ? -1L : ~OBJFLAGS_DOCUMENT, 
                        fDocument ? OBJFLAGS_DOCUMENT : 0);
}

//+---------------------------------------------------------------------------
//
//  Function:	ReleaseStgMedium, public
//
//  History:	18-Mar-94	Taken straight from OLE2 source
//
//----------------------------------------------------------------------------

STDAPI_(void) ReleaseStgMedium(LPSTGMEDIUM pMedium)
{
    if (pMedium)
    {
        //VDATEPTRIN rejects NULL
        VOID_VDATEPTRIN( pMedium, STGMEDIUM );
        BOOL fPunkRel = pMedium->pUnkForRelease != NULL;

        switch (pMedium->tymed)
        {
        case TYMED_HGLOBAL:	
            if (pMedium->hGlobal != NULL && !fPunkRel)
                Verify(GlobalFree(pMedium->hGlobal) == 0);
            break;

        case TYMED_GDI:
            if (pMedium->hGlobal != NULL && !fPunkRel)
                DeleteObject(pMedium->hGlobal);
            break;

        case TYMED_MFPICT:
            if (pMedium->hGlobal != NULL && !fPunkRel)
            {
                LPMETAFILEPICT  pmfp;

                if ((pmfp = (LPMETAFILEPICT)GlobalLock(pMedium->hGlobal)) ==
                    NULL)
                    break;
                
                DeleteMetaFile(pmfp->hMF);
                GlobalUnlock(pMedium->hGlobal);
                Verify(GlobalFree(pMedium->hGlobal) == 0);
            }
            break;

        case TYMED_FILE:		
            if (pMedium->lpszFileName != NULL)
            {
                if (!IsValidPtrIn(pMedium->lpszFileName, 1))
                    break;
                if (!fPunkRel)
                {
#ifdef WIN32
                    DeleteFile(pMedium->lpszFileName);
#else
#ifdef _MAC
                    /* the libraries are essentially small model on the MAC */
                    Verify(0==remove(pMedium->lpszFileName));
#else
#ifdef OLD_AND_NICE_ASSEMBLER_VERSION
                    /* Win 3.1 specific code to call DOS to delete the file
                       given a far pointer to the file name */
                    extern void WINAPI DOS3Call(void);
                    _asm
                    {
                        mov ah,41H
                        push ds
                        lds bx,pMedium
                        lds dx,[bx].lpszFileName
                        call DOS3Call
                        pop ds
                    }
#else
                {
                    OFSTRUCT of;
                    OpenFile(pMedium->lpszFileName, &of, OF_DELETE);
                }
#endif
#endif
#endif
                    delete pMedium->lpszFileName;
                }
            }
            break;
			
        case TYMED_ISTREAM:	
            if (pMedium->pstm != NULL && 
                IsValidInterface(pMedium->pstm))
                pMedium->pstm->Release(); 
            break;
			
        case TYMED_ISTORAGE:	
            if (pMedium->pstg != NULL && 
                IsValidInterface(pMedium->pstg))
                pMedium->pstg->Release(); 
            break;
			
        case TYMED_NULL:		
            break;
			
        default:
            thkAssert(!"Invalid medium in ReleaseStgMedium");
        }

        // NULL out to prevent unwanted use of just freed data
        pMedium->tymed = TYMED_NULL;

        if (pMedium->pUnkForRelease)
        {
            if (IsValidInterface(pMedium->pUnkForRelease))
                pMedium->pUnkForRelease->Release();
            pMedium->pUnkForRelease = NULL;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:	OleDoAutoConvert, local
//
//  Synopsis:	Taken from ole32 code
//
//  History:	06-Oct-94	DrewB	Created
//
//  Notes:	This routine must be local because it can return
//              information through pClsidNew even when it is
//              returning an error
//
//----------------------------------------------------------------------------

STDAPI OleDoAutoConvert(LPSTORAGE pStg, LPCLSID pClsidNew)
{
    HRESULT error;
    CLSID clsidOld;
    CLIPFORMAT cfOld;
    LPSTR lpszOld = NULL;
    LPSTR lpszNew = NULL;
    LPMALLOC pma;
    
    if ((error = ReadClassStg(pStg, &clsidOld)) != NOERROR)
    {
        clsidOld = CLSID_NULL;
        goto errRtn;
    }

    if ((error = OleGetAutoConvert(clsidOld, pClsidNew)) != NOERROR)
    {
        goto errRtn;
    }

    // read old fmt/old user type; sets out params to NULL on error
    error = ReadFmtUserTypeStg(pStg, &cfOld, &lpszOld);
    Assert(error == NOERROR || (cfOld == NULL && lpszOld == NULL));

    // get new user type name; if error, set to NULL string
    if ((error = OleRegGetUserType(*pClsidNew, USERCLASSTYPE_FULL,
                                   &lpszNew)) != NOERROR)
    {
        lpszNew = NULL;
    }

    // write class stg
    if ((error = WriteClassStg(pStg, *pClsidNew)) != NOERROR)
    {
        goto errRtn;
    }

    // write old fmt/new user type;
    if ((error = WriteFmtUserTypeStg(pStg, cfOld, lpszNew)) != NOERROR)
    {
        goto errRewriteInfo;
    }

    // set convert bit
    if ((error = SetConvertStg(pStg, TRUE)) != NOERROR)
    {
        goto errRewriteInfo;
    }

    goto okRtn;

 errRewriteInfo:
    (void)WriteClassStg(pStg, clsidOld);
    (void)WriteFmtUserTypeStg(pStg, cfOld, lpszOld);

 errRtn:
    *pClsidNew = clsidOld;

 okRtn:
    if (CoGetMalloc(MEMCTX_TASK, &pma) == NOERROR)
    {
        pma->Free(lpszOld);
        pma->Free(lpszNew);
        pma->Release();
    }

    return error;
}

/****** Other API defintions **********************************************/

//+---------------------------------------------------------------------------
//
//  Function:	Utility functions not in the spec; in ole2.dll.
//
//  History:	20-Apr-94	DrewB	Taken from OLE2 sources
//
//----------------------------------------------------------------------------

#define AVERAGE_STR_SIZE	64

FARINTERNAL_(HRESULT) StRead (IStream FAR * lpstream, LPVOID lpBuf, ULONG ulLen)
{
    HRESULT error;
    ULONG cbRead;

    if ((error = lpstream->Read( lpBuf, ulLen, &cbRead)) != NOERROR)
        return error;
	
    return ((cbRead != ulLen) ? ResultFromScode(STG_E_READFAULT) : NOERROR);
}

// returns S_OK when string read and allocated (even if zero length) 
OLEAPI  ReadStringStream( LPSTREAM pstm, LPSTR FAR * ppsz )
{
    ULONG cb;
    HRESULT hresult;
	
    *ppsz = NULL;

    if ((hresult = StRead(pstm, (void FAR *)&cb, sizeof(ULONG))) != NOERROR)
        return hresult;

    if (cb == NULL)
        // NULL string case
        return NOERROR;

    if ((LONG)cb < 0 || cb > INT_MAX)
        // out of range
        return ReportResult(0, E_UNSPEC, 0, 0);
	
    if (!(*ppsz = new FAR char[(int)cb]))
        return ReportResult(0, E_OUTOFMEMORY, 0, 0);

    if ((hresult = StRead(pstm, (void FAR *)(*ppsz), cb)) != NOERROR)
        goto errRtn;
	
    return NOERROR;

errRtn:	
    delete *ppsz;
    *ppsz = NULL;
    return hresult;
}

OLEAPI	WriteStringStream(LPSTREAM pstm, LPCSTR psz)
{
    HRESULT error;
    ULONG cb = NULL;

    if (psz) { 
        cb = 1 + _fstrlen(psz);

        // if possible, do a single write instead of two
		
        if (cb <= AVERAGE_STR_SIZE-4) {
            char szBuf[AVERAGE_STR_SIZE];
		
            *((ULONG FAR*) szBuf) = cb;
            lstrcpy(szBuf+sizeof(ULONG), psz);
			
            return pstm->Write((VOID FAR *)szBuf, cb+sizeof(ULONG), NULL);
        }
    }
	
    if (error = pstm->Write((VOID FAR *)&cb, sizeof(ULONG), NULL))
        return error;
	
    if (psz == NULL)
        // we are done writing the string
        return NOERROR;
		
    return pstm->Write((VOID FAR *)psz, cb, NULL);
}

OLEAPI	OpenOrCreateStream( IStorage FAR * pstg, char const FAR * pwcsName,
	IStream FAR* FAR* ppstm)
{
    HRESULT error;
    error = pstg->CreateStream(pwcsName,
                               STGM_SALL | STGM_FAILIFTHERE, 0, 0, ppstm);
    if (GetScode(error) == STG_E_FILEALREADYEXISTS)
        error = pstg->OpenStream(pwcsName, NULL, STGM_SALL, 0, ppstm);
    
    return error;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\ole2\mondthk.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       mondthk.c       (16 bit target)
//
//  Contents:   Moniker APIs that are directly thunked
//
//  History:    17-Dec-93 Johann Posch (johannp)    Created
//
//--------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#include <call32.hxx>
#include <apilist.hxx>

//+---------------------------------------------------------------------------
//
//  Function:   BindMoniker,    Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pmk] --
//      [grfOpt] --
//      [iidResult] --
//      [ppvResult] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI BindMoniker(LPMONIKER pmk, DWORD grfOpt, REFIID iidResult,
                   LPVOID FAR* ppvResult)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_BindMoniker),
                                    PASCAL_STACK_PTR(pmk));
}

//+---------------------------------------------------------------------------
//
//  Function:   MkParseDisplayName, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pbc] --
//      [szUserName] --
//      [pchEaten] --
//      [ppmk] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  MkParseDisplayName(LPBC pbc, LPSTR szUserName,
                           ULONG FAR * pchEaten, LPMONIKER FAR * ppmk)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_MkParseDisplayName),
                                    PASCAL_STACK_PTR(pbc));
}

//+---------------------------------------------------------------------------
//
//  Function:   MonikerRelativePathTo, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pmkSrc] --
//      [pmkDest] --
//      [ppmkRelPath] --
//      [fCalledFromMethod] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  MonikerRelativePathTo(LPMONIKER pmkSrc, LPMONIKER pmkDest, LPMONIKER
                              FAR* ppmkRelPath, BOOL fCalledFromMethod)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_MonikerRelativePathTo),
                                    PASCAL_STACK_PTR(pmkSrc));
}

//+---------------------------------------------------------------------------
//
//  Function:   MonikerCommonPrefixWith, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pmkThis] --
//      [pmkOther] --
//      [ppmkCommon] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  MonikerCommonPrefixWith(LPMONIKER pmkThis, LPMONIKER pmkOther,
                                LPMONIKER FAR* ppmkCommon)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_MonikerCommonPrefixWith),
                                    PASCAL_STACK_PTR(pmkThis));
}

//+---------------------------------------------------------------------------
//
//  Function:   CreateBindCtx, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [reserved] --
//      [ppbc] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  CreateBindCtx(DWORD reserved, LPBC FAR* ppbc)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_CreateBindCtx),
                                    PASCAL_STACK_PTR(reserved));
}

//+---------------------------------------------------------------------------
//
//  Function:   CreateGenericComposite, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pmkFirst] --
//      [pmkRest] --
//      [ppmkComposite] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  CreateGenericComposite(LPMONIKER pmkFirst, LPMONIKER pmkRest,
                               LPMONIKER FAR* ppmkComposite)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_CreateGenericComposite),
                                    PASCAL_STACK_PTR(pmkFirst));
}

//+---------------------------------------------------------------------------
//
//  Function:   GetClassFile, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [szFilename] --
//      [pclsid] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  GetClassFile (LPCSTR szFilename, CLSID FAR* pclsid)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_GetClassFile),
                                    PASCAL_STACK_PTR(szFilename));
}


//+---------------------------------------------------------------------------
//
//  Function:   CreateFileMoniker, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [lpszPathName] --
//      [ppmk] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//		3-15-95	  alexgo    Added hack for CorelDraw
//
//  Notes:	When Corel5.0 starts up, it creates a file moniker
//		with it's string clsid as the name.  If the path name
//		is really CorelDraw, then call into olethk32 to set
//		an app compatibility flag.
//
//		The flag that we set disables paste-link to yourself.  CorelDraw
//		does not support this feature (because of a trashed memory
//		bug in 16bit OLE).
//
//----------------------------------------------------------------------------
STDAPI  CreateFileMoniker(LPSTR lpszPathName, LPMONIKER FAR* ppmk)
{
    static const char szCorelDraw[] =
	"{11A11440-0394-101B-A72E-04021C007002}";


    // just do a quick, manual string compare so we don't have to load
    // the c runtime.

    if( lpszPathName )
    {
	LPCSTR lpszCD = szCorelDraw;
	LPSTR lpszPN = lpszPathName;

	while( *lpszPN != '\0' && *lpszPN == *lpszCD && *lpszCD != '\0' )
	{
	    lpszPN++;
	    lpszCD++;
	}

	if( *lpszCD == '\0' && *lpszPN == '\0' )
	{
	    // the strings matched!  Set the compatibility flag for CorelDraw
	    AddAppCompatFlag(OACF_CORELTRASHMEM);
	}
    }

    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_CreateFileMoniker),
                                    PASCAL_STACK_PTR(lpszPathName));
}

//+---------------------------------------------------------------------------
//
//  Function:   CreateItemMoniker, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [lpszDelim] --
//      [lpszItem] --
//      [ppmk] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  CreateItemMoniker(LPSTR lpszDelim, LPSTR lpszItem,
                          LPMONIKER FAR* ppmk)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_CreateItemMoniker),
                                    PASCAL_STACK_PTR(lpszDelim));
}

//+---------------------------------------------------------------------------
//
//  Function:   CreateAntiMoniker, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [ppmk] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  CreateAntiMoniker(LPMONIKER FAR* ppmk)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_CreateAntiMoniker),
                                    PASCAL_STACK_PTR(ppmk));
}

//+---------------------------------------------------------------------------
//
//  Function:   CreatePointerMoniker, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [punk] --
//      [ppmk] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  CreatePointerMoniker(LPUNKNOWN punk, LPMONIKER FAR* ppmk)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_CreatePointerMoniker),
                                    PASCAL_STACK_PTR(punk));
}


//+---------------------------------------------------------------------------
//
//  Function:   GetRunningObjectTable, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [reserved] --
//      [pprot] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI  GetRunningObjectTable( DWORD reserved, LPRUNNINGOBJECTTABLE FAR* pprot)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_GetRunningObjectTable),
                                    PASCAL_STACK_PTR(reserved));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\ole2\ole2splt.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       ole2splt.cxx
//
//  Contents:   OLE2 API whose implementation is split between 16/32
//
//  History:    07-Mar-94       DrewB   Created
//
//----------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#include <ole2sp.h>
#include <ole2int.h>
#include <ole2ver.h>
#include <olecoll.h>
#include <map_kv.h>
#include <map_htsk.h>
#include <etask.hxx>

#include <call32.hxx>
#include <apilist.hxx>

// MFC HACK ALERT!!!  The followind constant is needed
// for an MFC workaround.  See OleInitialize for details

#define CLIPBOARDWNDCLASS "CLIPBOARDWNDCLASS"

//+---------------------------------------------------------------------------
//
//  Function:   OleInitialize, Split
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pMalloc] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//              05-26-94  AlexT     Return correct success code
//		08-22-94  AlexGo    added MFC CreateWindow hack
//
//  Notes:
//
//----------------------------------------------------------------------------

STDAPI OleInitialize(LPMALLOC pMalloc)
{
    HTASK htask;
    Etask etask;
    HRESULT hrCoInit, hrOleInit;
    static BOOL fCreatedClipWindowClass = FALSE;

    /* This version of ole2.dll simply needs to work with the same major build
       of compobj.dll.  Future versions of ole2.dll might be restricted to
       certain builds of compobj.dll. */
    if (HIWORD(CoBuildVersion()) != rmm)
    {
        return ResultFromScode(OLE_E_WRONGCOMPOBJ);
    }

    /* if already initialize one or more times, just bump count and return. */
    if (LookupEtask(htask, etask) && etask.m_oleinits != 0)
    {
        etask.m_oleinits++;
        thkVerify(SetEtask(htask, etask));
        return ResultFromScode(S_FALSE);
    }

    /* Initialize the 16-bit side of compobj */
    hrCoInit = CoInitialize(pMalloc);
    if (SUCCEEDED(GetScode(hrCoInit)))
    {
        /* Thunk OleInitialize
           Never pass on the IMalloc */
        pMalloc = NULL;
        hrOleInit = (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_OleInitialize),
                                      PASCAL_STACK_PTR(pMalloc) );
        if (FAILED(GetScode(hrOleInit)))
        {
            CoUninitialize();
            return(hrOleInit);
        }

        thkVerify(LookupEtask(htask, etask) && etask.m_oleinits == 0);
        etask.m_oleinits++;
        thkVerify(SetEtask(htask, etask));
    }

    //  Since we call 32-bit CoInitialize and then call 32-bit OleInitialize,
    //  and since the latter internally calls CoInitialize (a second time), we
    //  want to return the HRESULT of the call to CoInitialize since some
    //  applications look for S_OK (and our call to OleInitialize will return
    //  S_FALSE since it will be the second call to CoInitialize).


    //  MFC HACK ALERT!!  MFC2.5 (16bit) has a hack where they scan the
    //  window hierarchy for a window named "CLIPBOARDWNDCLASS".  They then
    //  subclass this window and do their own processing for clipboard
    //  windows messages.
    //
    //  In order to make them work, we create a dummy window for MFC to party
    //  on.  This allows them to successfully subclass and not interfere
    //  with 32bit OLE processing.  (since it's a dummy window)
    //
    //  NB!!  We do not bother with resource cleanup; we'll leave this window
    //  around until the process exits.  We also don't care about errors
    //  here.  In the off chance that one of the calls fails and we *don't*
    //  create a window that MFC can party on, then MFC *debug* apps will
    //  popup an assert dialog.  You can safely click 'OK' on this dialog
    //  and the app will proceed without undue trauma.

    if( !fCreatedClipWindowClass )
    {
	WNDCLASS	wc;

        // Register Clipboard window class
        //
        wc.style = 0;
        wc.lpfnWndProc = DefWindowProc;
        wc.cbClsExtra = 0;
        wc.cbWndExtra = 4;
        wc.hInstance = hmodOLE2;
        wc.hIcon = NULL;
        wc.hCursor = NULL;
        wc.hbrBackground = NULL;
        wc.lpszMenuName =  NULL;
        wc.lpszClassName = CLIPBOARDWNDCLASS;

	// don't bother checking for errors
        RegisterClass(&wc);
	fCreatedClipWindowClass = TRUE;
    }
	
    CreateWindow(CLIPBOARDWNDCLASS,"",WS_POPUP,CW_USEDEFAULT,
			CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,
			NULL,NULL,hmodOLE2,NULL);

    return hrOleInit;
}

//+---------------------------------------------------------------------------
//
//  Function:   OleUninitialize, Split
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [void] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI_(void) OleUninitialize(void)
{
    HTASK htask;
    Etask etask;

    /* If not init, just return */
    if (!LookupEtask(htask, etask) || etask.m_oleinits == 0)
    {
        return;
    }

    /* Must always decrement count and set since compobj may still be init'd */
    etask.m_oleinits--;
    thkVerify(SetEtask(htask, etask));

    /* if not last uninit, now return */
    if (etask.m_oleinits != 0)
    {
        return;
    }

    /* After this point, the uninit should not fail (because we don't have
       code to redo the init). */

    CallObjectInWOW(THK_API_METHOD(THK_API_OleUninitialize), NULL );
    CoUninitialize();
}

//+---------------------------------------------------------------------------
//
//  Function:   ReadClassStm, Split
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pStm] --
//      [pclsid] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI ReadClassStm(LPSTREAM pStm, CLSID FAR* pclsid)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_ReadClassStm),
                                    PASCAL_STACK_PTR(pStm) );
}

//+---------------------------------------------------------------------------
//
//  Function:   WriteClassStm, Split
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pStm] --
//      [rclsid] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI WriteClassStm(LPSTREAM pStm, REFCLSID rclsid)
{
    return (HRESULT)CallObjectInWOW(THK_API_METHOD(THK_API_WriteClassStm) ,
                                    PASCAL_STACK_PTR(pStm) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\storage\headers.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	headers.cxx
//
//  Contents:	Precompiled header file
//
//  History:	18-Feb-94	DrewB	Created
//
//----------------------------------------------------------------------------

#include <windows.h>
#include <string.h>
#include <compobj.h>
#include <storage.h>

#include <interop.hxx>
#include <wow16fn.h>
#include <io16.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\storage\stgdthk.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       stgdthk.cxx     (16 bit target)
//
//  Contents:   Storage APIs that are directly thunked
//
//  History:    17-Dec-93 JohannP    Created
//
//--------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#include <call32.hxx>
#include <apilist.hxx>

//+---------------------------------------------------------------------------
//
//  Function:   Straight thunk routines
//
//  Synopsis:   The following routines thunk straight through
//
//  History:    24-Feb-94       DrewB   Created
//
//----------------------------------------------------------------------------

STDAPI DllGetClassObject(REFCLSID clsid, REFIID iid, void FAR* FAR* ppv)
{
    /* Relies on the fact that storage and ole2.dll both use the
       same DllGetClassObject in ole32.dll */
    return (HRESULT)CallObjectInWOWCheckThkMgr(THK_API_METHOD(THK_API_DllGetClassObject),
                                    PASCAL_STACK_PTR(clsid));
}

//+---------------------------------------------------------------------------
//
//  Function:   StgCreateDocfile, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pwcsName] --
//      [grfMode] --
//      [reserved] --
//      [ppstgOpen] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   DrewB   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI StgCreateDocfile(const char FAR* pwcsName,
                        DWORD grfMode,
                        DWORD reserved,
                        IStorage FAR * FAR *ppstgOpen)
{
    return (HRESULT)CallObjectInWOWCheckThkMgr(THK_API_METHOD(THK_API_StgCreateDocfile),
                                    PASCAL_STACK_PTR(pwcsName));
}

//+---------------------------------------------------------------------------
//
//  Function:   StgCreateDocfileOnILockBytes, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [plkbyt] --
//      [grfMode] --
//      [reserved] --
//      [ppstgOpen] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   DrewB   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI StgCreateDocfileOnILockBytes(ILockBytes FAR *plkbyt,
                                    DWORD grfMode,
                                    DWORD reserved,
                                    IStorage FAR * FAR *ppstgOpen)
{
    return (HRESULT)CallObjectInWOWCheckThkMgr(THK_API_METHOD(THK_API_StgCreateDocfileOnILockBytes),
                                    PASCAL_STACK_PTR(plkbyt));
}

//+---------------------------------------------------------------------------
//
//  Function:   StgOpenStorage, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pwcsName] --
//      [pstgPriority] --
//      [grfMode] --
//      [snbExclude] --
//      [reserved] --
//      [ppstgOpen] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   DrewB   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI StgOpenStorage(const char FAR* pwcsName,
                      IStorage FAR *pstgPriority,
                      DWORD grfMode,
                      SNB snbExclude,
                      DWORD reserved,
                      IStorage FAR * FAR *ppstgOpen)
{
    // STGM_CREATE and STGM_CONVERT are illegal for open calls
    // 16-bit code did not enforce this, so mask out these flags
    // before passing grfMode on
    grfMode &= ~(STGM_CREATE | STGM_CONVERT);

    return (HRESULT)CallObjectInWOWCheckThkMgr(THK_API_METHOD(THK_API_StgOpenStorage),
                                    PASCAL_STACK_PTR(pwcsName));
}

//+---------------------------------------------------------------------------
//
//  Function:   StgOpenStorageOnILockBytes, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [plkbyt] --
//      [pstgPriority] --
//      [grfMode] --
//      [snbExclude] --
//      [reserved] --
//      [ppstgOpen] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   DrewB   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI StgOpenStorageOnILockBytes(ILockBytes FAR *plkbyt,
                                  IStorage FAR *pstgPriority,
                                  DWORD grfMode,
                                  SNB snbExclude,
                                  DWORD reserved,
                                  IStorage FAR * FAR *ppstgOpen)
{
    // STGM_CREATE and STGM_CONVERT are illegal for open calls
    // 16-bit code did not enforce this, so mask out these flags
    // before passing grfMode on
    grfMode &= ~(STGM_CREATE | STGM_CONVERT);

    return
       (HRESULT)CallObjectInWOWCheckThkMgr(THK_API_METHOD(THK_API_StgOpenStorageOnILockBytes),
                                 PASCAL_STACK_PTR(plkbyt));
}

//+---------------------------------------------------------------------------
//
//  Function:   StgIsStorageFile, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [pwcsName] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   DrewB   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI StgIsStorageFile(const char FAR* pwcsName)
{
    //
    // MSPUB 2.0a hack - We call the "CheckInit" version because they forgot
    // to call CoInitialize/OleInitialize first.
    //
    return
        (HRESULT)CallObjectInWOWCheckThkMgr(THK_API_METHOD(THK_API_StgIsStorageFile),
                                          PASCAL_STACK_PTR(pwcsName));
}

//+---------------------------------------------------------------------------
//
//  Function:   StgIsStorageILockBytes, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [plkbyt] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   DrewB   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI StgIsStorageILockBytes(ILockBytes FAR* plkbyt)
{
    return (HRESULT)CallObjectInWOWCheckThkMgr(THK_API_METHOD(THK_API_StgIsStorageILockBytes),
                                    PASCAL_STACK_PTR(plkbyt));
}

//+---------------------------------------------------------------------------
//
//  Function:   StgSetTimes, Remoted
//
//  Synopsis:
//
//  Effects:
//
//  Arguments:  [lpszName] --
//      [pctime] --
//      [patime] --
//      [pmtime] --
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    2-28-94   DrewB   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI StgSetTimes(char const FAR* lpszName,
                   FILETIME const FAR* pctime,
                   FILETIME const FAR* patime,
                   FILETIME const FAR* pmtime)
{
    return (HRESULT)CallObjectInWOWCheckThkMgr(THK_API_METHOD(THK_API_StgSetTimes),
                                    PASCAL_STACK_PTR(lpszName));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\storage\storage.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	storage.c	(16 bit target)
//
//  Contents:	Storage.dll common code
//
//  History:	17-Dec-93 JohannP    Created
//
//--------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#include <call32.hxx>
#include <apilist.hxx>

DECLARE_INFOLEVEL(thk1);

//+---------------------------------------------------------------------------
//
//  Function:	LibMain, public
//
//  Synopsis:	DLL initialization function
//
//  Arguments:	[hinst] - Instance handle
//              [wDataSeg] - Current DS
//              [cbHeapSize] - Heap size for the DLL
//              [lpszCmdLine] - Command line information
//
//  Returns:	One for success, zero for failure
//
//  History:	21-Feb-94	DrewB	Created
//
//----------------------------------------------------------------------------

#if DBG == 1
static char achInfoLevel[32];
#endif

int CALLBACK LibMain(HINSTANCE hinst,
                     WORD wDataSeg,
                     WORD cbHeapSize,
                     LPSTR lpszCmdLine)
{
#if DBG == 1
    if (GetProfileString("olethk32", "InfoLevel", "3", achInfoLevel,
                         sizeof(achInfoLevel)) > 0)
    {
        thk1InfoLevel = strtoul(achInfoLevel, NULL, 0);
    }
#endif

#if defined(_CHICAGO_)
    //
    //  The Chicago debugger doesn't like hinst not being wired.
    //
    GlobalWire(hinst);
#endif

    return 1;
}

//+---------------------------------------------------------------------------
//
//  Function:	WEP, public
//
//  Synopsis:	Windows Exit Point routine, for receiving DLL unload
//              notification
//
//  Arguments:	[nExitType] - Type of exit occurring
//
//  Returns:	One for success, zero for failure
//
//  History:	21-Feb-94	DrewB	Created
//
//----------------------------------------------------------------------------

int CALLBACK WEP(int nExitType)
{
    // Clean up thunk objects?
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\utest\basic\base16.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       base16.cxx
//
//  Contents:   Base 16 bit thunk test
//
//  Classes:
//
//  Functions:
//
//  History:    3-04-94   kevinro   Created
//
//----------------------------------------------------------------------------


#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <windows.h>
#include <compobj.h>
#include <storage.h>

void _cdecl main (int argc, char *argv[])
{
    HRESULT hr;
    IStorage FAR *pstg;

    printf("Start test\n");
    hr = CoInitialize(NULL);
    if (FAILED(hr))
    {
	printf("CoInitialize failed, 0x%08lX\n", hr);
    }


    CoUninitialize();
    printf("End test\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\ole16\utest\triv\triv.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	triv.cxx
//
//  Contents:	Trivial thunking test
//
//  History:	24-Feb-94	DrewB	Created
//
//----------------------------------------------------------------------------

#include <stdarg.h>
#include <stdio.h>
#include <string.h>
#include <windows.h>
#include <compobj.h>
#include <storage.h>

void DbgOut(char *fmt, ...)
{
    va_list args;
    char str[80];

    va_start(args, fmt);
    wvsprintf(str, fmt, args);
    OutputDebugString(str);
    va_end(args);
}

int PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
                   LPSTR lpszCmdLine, int nCmdShow)
{
    HRESULT hr;
    IStorage FAR *pstg;

    hr = CoInitialize(NULL);
    if (FAILED(GetScode(hr)))
    {
	DbgOut("CoInitialize failed, 0x%08lX\n", hr);
    }
    else
    {
	hr = StgCreateDocfile("test.dfl", STGM_DIRECT | STGM_READWRITE |
		STGM_SHARE_EXCLUSIVE | STGM_CREATE, 0, &pstg);
	if (FAILED(GetScode(hr)))
	{
	    DbgOut("StgCreateDocfile failed, 0x%08lX\n", hr);
	}
	else
	{
	    pstg->Release();
	}

	CoUninitialize();
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\olethk32\alias.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	alias.cxx
//
//  Contents:	Alias implementations
//
//  History:	26-May-94	DrewB	Created
//
//----------------------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Member:	CAliasBlock::CAliasBlock, public
//
//  Synopsis:	Constructor
//
//  History:	26-May-94	DrewB	Created
//
//----------------------------------------------------------------------------

CAliasBlock::CAliasBlock(ALIAS aliasBase,
                         CAliasBlock *pabNext)
{
    _aliasBase = aliasBase;
    _iFilled = 0;
    _pabNext = pabNext;

    // Since INVALID_VALUE is a DWORD we can't directly memset it,
    // but we'd like to use memset so assert that it's a known value
    // and go ahead
    thkAssert(INVALID_VALUE == 0);
    memset(_dwValues, 0, sizeof(_dwValues));
}

//+---------------------------------------------------------------------------
//
//  Member:	CAliasBlock::ValueAlias, public
//
//  Synopsis:	Find the alias for a value
//
//  Arguments:	[dwValue] - Value
//
//  Returns:    Alias or INVALID_ALIAS
//
//  History:	26-May-94	DrewB	Created
//
//----------------------------------------------------------------------------

ALIAS CAliasBlock::ValueAlias(DWORD dwValue)
{
    int i;
    DWORD *pdw;

    thkAssert(dwValue != INVALID_VALUE);

#if DBG == 1
    CheckFree();
#endif

    if (_iFilled == 0)
    {
        return INVALID_ALIAS;
    }

    pdw = _dwValues;
    for (i = 0; i < ALIAS_BLOCK_SIZE; i++)
    {
        if (*pdw == dwValue)
        {
            return IndexAlias(i);
        }

        pdw++;
    }

    return INVALID_ALIAS;
}

//+---------------------------------------------------------------------------
//
//  Member:	CAliasBlock::AddValue, public
//
//  Synopsis:	Adds a new value
//
//  Arguments:	[dwValue] - New value
//
//  Returns:	Alias for block or INVALID_ALIAS
//
//  History:	26-May-94	DrewB	Created
//
//  Notes:      Duplicates are not allowed
//
//----------------------------------------------------------------------------

ALIAS CAliasBlock::AddValue(DWORD dwValue)
{
    int i;
    DWORD *pdw;

    thkAssert(dwValue != INVALID_VALUE);

#if DBG == 1
    CheckFree();
#endif

    if (_iFilled == ALIAS_BLOCK_SIZE)
    {
        return INVALID_ALIAS;
    }

    // Check for duplicates
    thkAssert(ValueAlias(dwValue) == INVALID_ALIAS);

    pdw = _dwValues;
    for (i = 0; i < ALIAS_BLOCK_SIZE; i++)
    {
        if (*pdw == INVALID_VALUE)
        {
            break;
        }

        pdw++;
    }

    thkAssert(i < ALIAS_BLOCK_SIZE);

    _iFilled++;
    _dwValues[i] = dwValue;

    return IndexAlias(i);
}

//+---------------------------------------------------------------------------
//
//  Member:	CAliasBlock::CheckFree, public debug
//
//  Synopsis:	Checks to make sure that _iFilled is correct
//
//  History:	30-May-94	DrewB	Created
//
//----------------------------------------------------------------------------

#if DBG == 1
void CAliasBlock::CheckFree(void)
{
    int i, iFilled;
    DWORD *pdw;

    iFilled = 0;
    pdw = _dwValues;
    for (i = 0; i < ALIAS_BLOCK_SIZE; i++)
    {
        if (*pdw != INVALID_VALUE)
        {
            iFilled++;
        }

        pdw++;
    }

    thkAssert(iFilled == _iFilled);
}
#endif

//+---------------------------------------------------------------------------
//
//  Function:	CAliases::~CAliases, public
//
//  Synopsis:	Destructor
//
//  History:	26-May-94	DrewB	Created
//
//----------------------------------------------------------------------------

CAliases::~CAliases(void)
{
    CAliasBlock *pab;

    while (_pabAliases)
    {
        pab = _pabAliases->GetNext();
	//
	// The first alias block added to the list is a static one. We
	// cannot call the heap to deallocate it.
	//
	if (_pabAliases != &_abStatic)
	{
	    delete _pabAliases;
	}

        _pabAliases = pab;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:	CAliases::AliasValue, public
//
//  Synopsis:	Returns the value for an alias
//
//  Arguments:	[alias] - Alias
//
//  Returns:	Value
//
//  History:	26-May-94	DrewB	Created
//
//  Notes:      Alias must be valid
//
//----------------------------------------------------------------------------

DWORD CAliases::AliasValue(ALIAS alias)
{
    CAliasBlock *pab;

    for (pab = _pabAliases; pab; pab = pab->GetNext())
    {
        if (pab->ContainsAlias(alias))
        {
            return pab->AliasValue(alias);
        }
    }

    thkAssert(!"Invalid alias in CAliases::AliasValue");

    return 0xffffffff;
}

//+---------------------------------------------------------------------------
//
//  Function:	CAliases::ValueAlias, public
//
//  Synopsis:	Returns the alias for a value
//
//  Arguments:	[dwValue] - Value
//
//  Returns:	Alias
//
//  History:	26-May-94	DrewB	Created
//
//----------------------------------------------------------------------------

ALIAS CAliases::ValueAlias(DWORD dwValue)
{
    CAliasBlock *pab;
    ALIAS alias;

    for (pab = _pabAliases; pab; pab = pab->GetNext())
    {
        alias = pab->ValueAlias(dwValue);
        if (alias != INVALID_ALIAS)
        {
            return alias;
        }
    }

    return INVALID_ALIAS;
}

//+---------------------------------------------------------------------------
//
//  Function:	CAliases::AddValue, public
//
//  Synopsis:	Adds a value and returns its alias
//
//  Arguments:	[dwValue] - Value
//
//  Returns:	Alias or INVALID_ALIAS
//
//  History:	26-May-94	DrewB	Created
//
//----------------------------------------------------------------------------

ALIAS CAliases::AddValue(DWORD dwValue)
{
    CAliasBlock *pab;
    ALIAS alias;

    for (pab = _pabAliases; pab; pab = pab->GetNext())
    {
        alias = pab->AddValue(dwValue);
        if (alias != INVALID_ALIAS)
        {
            return alias;
        }
    }

    if ((long)_aliasBase+ALIAS_BLOCK_SIZE >= INVALID_ALIAS)
    {
        return INVALID_ALIAS;
    }

    pab = new CAliasBlock(_aliasBase+ALIAS_BLOCK_SIZE, _pabAliases);
    if (pab == NULL)
    {
        return INVALID_ALIAS;
    }

    _aliasBase += ALIAS_BLOCK_SIZE;
    _pabAliases = pab;

    alias = pab->AddValue(dwValue);

    thkAssert(alias != INVALID_ALIAS);

    return alias;
}

//+---------------------------------------------------------------------------
//
//  Function:	CAliases::RemoveAlias, public
//
//  Synopsis:	Removes an alias
//
//  Arguments:	[alias] - Alias
//
//  History:	26-May-94	DrewB	Created
//
//----------------------------------------------------------------------------

void CAliases::RemoveAlias(ALIAS alias)
{
    CAliasBlock *pab, *pabPrev;

    pabPrev = NULL;
    for (pab = _pabAliases; pab; pabPrev = pab, pab = pab->GetNext())
    {
        if (pab->ContainsAlias(alias))
        {
            pab->RemoveAlias(alias);

            if (pab->AliasesFilled() == 0)
            {
                DeleteBlock(pab, pabPrev);
            }

            return;
        }
    }

    thkAssert(!"Invalid alias in CAliases::RemoveAlias");
}

//+---------------------------------------------------------------------------
//
//  Function:	CAliases::SetValue, public
//
//  Synopsis:	Sets the value for an alias
//
//  Arguments:	[alias] - Alias
//              [dwValue] - Value
//
//  History:	26-May-94	DrewB	Created
//
//----------------------------------------------------------------------------

void CAliases::SetValue(ALIAS alias, DWORD dwValue)
{
    CAliasBlock *pab;

    for (pab = _pabAliases; pab; pab = pab->GetNext())
    {
        if (pab->ContainsAlias(alias))
        {
            pab->SetValue(alias, dwValue);
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:	CAliases::DeleteBlock, private
//
//  Synopsis:	Deletes an alias block if it's not the static block
//
//  Arguments:	[pab] - Alias block
//              [pabPrev] - Previous alias block
//
//  History:	27-May-94	DrewB	Created
//
//----------------------------------------------------------------------------

void CAliases::DeleteBlock(CAliasBlock *pab, CAliasBlock *pabPrev)
{
    if (pab == &_abStatic)
    {
        return;
    }

    if (pabPrev)
    {
        pabPrev->SetNext(pab->GetNext());
    }
    else
    {
        _pabAliases = pab->GetNext();
    }

    delete pab;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\olethk32\dbgapi.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	dbgapi.cxx
//
//  Notes:	This file is automatically generated
//		Do not modify by hand
//
//  History:	Fri May 27 10:39:02 1994	Generated
//
//----------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#if DBG == 1

char *apszApiNames[] =
{
    "CoInitialize"
,    "CoUninitialize"
,    "CoGetClassObject"
,    "CoRegisterClassObject"
,    "CoRevokeClassObject"
,    "CoMarshalInterface"
,    "CoUnmarshalInterface"
,    "CoReleaseMarshalData"
,    "CoDisconnectObject"
,    "CoLockObjectExternal"
,    "CoGetStandardMarshal"
,    "CoIsHandlerConnected"
,    "CoFreeAllLibraries"
,    "CoFreeUnusedLibraries"
,    "CoCreateInstance"
,    "CLSIDFromString"
,    "CoIsOle1Class"
,    "ProgIDFromCLSID"
,    "CLSIDFromProgID"
,    "CoCreateGuid"
,    "CoFileTimeToDosDateTime"
,    "CoDosDateTimeToFileTime"
,    "CoFileTimeNow"
,    "CoRegisterMessageFilter"
,    "CoGetTreatAsClass"
,    "CoTreatAsClass"
,    "DllGetClassObject"
,    "StgCreateDocfile"
,    "StgCreateDocfileOnILockBytes"
,    "StgOpenStorage"
,    "StgOpenStorageOnILockBytes"
,    "StgIsStorageFile"
,    "StgIsStorageILockBytes"
,    "StgSetTimes"
,    "CreateDataAdviseHolder"
,    "CreateDataCache"
,    "BindMoniker"
,    "MkParseDisplayName"
,    "MonikerRelativePathTo"
,    "MonikerCommonPrefixWith"
,    "CreateBindCtx"
,    "CreateGenericComposite"
,    "GetClassFile"
,    "CreateFileMoniker"
,    "CreateItemMoniker"
,    "CreateAntiMoniker"
,    "CreatePointerMoniker"
,    "GetRunningObjectTable"
,    "ReadClassStg"
,    "WriteClassStg"
,    "ReadClassStm"
,    "WriteClassStm"
,    "WriteFmtUserTypeStg"
,    "ReadFmtUserTypeStg"
,    "OleInitialize"
,    "OleUninitialize"
,    "OleQueryLinkFromData"
,    "OleQueryCreateFromData"
,    "OleCreate"
,    "OleCreateFromData"
,    "OleCreateLinkFromData"
,    "OleCreateStaticFromData"
,    "OleCreateLink"
,    "OleCreateLinkToFile"
,    "OleCreateFromFile"
,    "OleLoad"
,    "OleSave"
,    "OleLoadFromStream"
,    "OleSaveToStream"
,    "OleSetContainedObject"
,    "OleNoteObjectVisible"
,    "RegisterDragDrop"
,    "RevokeDragDrop"
,    "DoDragDrop"
,    "OleSetClipboard"
,    "OleGetClipboard"
,    "OleFlushClipboard"
,    "OleIsCurrentClipboard"
,    "OleCreateMenuDescriptor"
,    "OleSetMenuDescriptor"
,    "OleDestroyMenuDescriptor"
,    "OleDraw"
,    "OleRun"
,    "OleIsRunning"
,    "OleLockRunning"
,    "CreateOleAdviseHolder"
,    "OleCreateDefaultHandler"
,    "OleCreateEmbeddingHelper"
,    "OleRegGetUserType"
,    "OleRegGetMiscStatus"
,    "OleRegEnumFormatEtc"
,    "OleRegEnumVerbs"
,    "OleConvertIStorageToOLESTREAM"
,    "OleConvertOLESTREAMToIStorage"
,    "OleConvertIStorageToOLESTREAMEx"
,    "OleConvertOLESTREAMToIStorageEx"
,    "OleDoAutoConvert"
,    "OleGetAutoConvert"
,    "OleSetAutoConvert"
,    "GetConvertStg"
,    "SetConvertStg"
,    "ReadOleStg"
,    "WriteOleStg"
};

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\olethk32\apinot.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       apinot.cxx
//
//  Contents:   Implementation of non-API thunks
//
//  History:    11-Mar-94   BobDay  Created
//
//----------------------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

#include <thunkapi.hxx>
#include <wownt32.h>
#include "olethk32.hxx"
#include "apinot.hxx"
#include "tlsthk.hxx"

//
// The following is a global static used by OLE32 to call back into
// this DLL. There is no static data associated with the static, so
// it merely defines a virtual interface that OLE32 can use.
//

OleThunkWOW g_thkOleThunkWOW;

//
// The following API is exported from WOW32.DLL. There is no global include
// file that it exists in yet.
//
#if defined(_CHICAGO_)
/* Not supported under Chicago yet.         */
/* But it's probably not important anymore. */
#define WOWFreeMetafile(x) (0) 
#else
extern "C" BOOL WINAPI WOWFreeMetafile( HANDLE h32 );
#endif

//+---------------------------------------------------------------------------
//
//  Function:   CoInitializeNot, public
//
//  Synopsis:   Thunks for the 16-bit applications call to CoInitialize
//
//  Arguments:  [lpmalloc] - Parameter from the 16-bit world
//
//  Returns:    Appropriate status code
//
//  History:    11-Mar-94   BobDay  Created
//
//----------------------------------------------------------------------------

STDAPI_(DWORD) CoInitializeNot( LPMALLOC lpMalloc )
{
    HRESULT     hresult;

    hresult = CoInitializeWOW( lpMalloc, &g_thkOleThunkWOW );

    return (DWORD)hresult;
}

//+---------------------------------------------------------------------------
//
//  Function:   OleInitializeNot, public
//
//  Synopsis:   Thunks for the 16-bit applications call to OleInitialize
//
//  Arguments:  [lpmalloc] - Parameter from the 16-bit world
//
//  Returns:    Appropriate status code
//
//  History:    11-Mar-94   BobDay  Created
//
//----------------------------------------------------------------------------

STDAPI_(DWORD) OleInitializeNot( LPMALLOC lpMalloc )
{
    HRESULT     hresult;

    hresult = OleInitializeWOW( lpMalloc, &g_thkOleThunkWOW );

    return (DWORD)hresult;
}

//+---------------------------------------------------------------------------
//
//  Function:   RegisterDelayedClassFactories
//
//  Synopsis:   This function is called to actually do the registration of
//		the delayed class factories.
//
//  Effects:    When the application specific 'trigger' is hit
//		(ie OleRegGetUserType for WordPerfect), this routine is
//		called to actually do all of the delayed class factory
//		registrations.
//
//  Arguments:  (none)
//
//  Requires:
//
//  Returns:	nothing
//
//  History:    4-18-95   kevinro   Created
//
//----------------------------------------------------------------------------
void RegisterDelayedClassFactories()
{
    thkDebugOut((DEB_ITRACE,
		 "_IN RegisterDelayedClassFactories()\n"));

    PThreadData pdata;
    IUnknown *punk;
    HRESULT hr;
    DelayedRegistrationTable *pTable = NULL;
    DelayRegistration *pdelayed;
    DWORD dwReg;

    int i;
    //
    // Get the thread specific data and table to determine if there are
    // any delayed registrations. If not, just call the real routine.
    //
    pdata = TlsThkGetData();

    if (pdata == NULL)
    {
	goto exitRtn;
    }

    if ((pTable = pdata->pDelayedRegs) == NULL)
    {
	goto exitRtn;
    }

    //
    //
    //
    for (i = 0 ; i < MAX_DELAYED_REGISTRATIONS ; i++)
    {
	pdelayed = &(pTable->_Entries[i]);

	if((pdelayed->_punk != NULL) && (pdelayed->_dwRealKey == 0))
	{
	    hr    = CoRegisterClassObject(pdelayed->_clsid,
					  pdelayed->_punk,
					  pdelayed->_dwClsContext,
					  pdelayed->_flags,
					  &(pdelayed->_dwRealKey));
            if (FAILED(hr))
	    {
		thkDebugOut((DEB_ERROR,
			     "RegisterDelayedClassFactory gets %x\n",hr));
	    }
	}
    }

exitRtn:

    thkDebugOut((DEB_ITRACE,
		 "OUT RegisterDelayedClassFactories()\n"));

}
//+---------------------------------------------------------------------------
//
//  Function:   CoRevokeClassObjectNot
//
//  Synopsis:   Unregisters a class object that might have been delayed
//
//  Effects:	The 16-bit API CoRevokeClassObject has been directed to this
//		routine. This routine will check the list of interfaces that
//		have been registered, and will try to determine if the key
//		needs to be translated.
//
//  Arguments:  [dwKey] -- Key to revoke
//
//  History:    4-18-95   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CoRevokeClassObjectNot( DWORD dwKey)
{
    thkDebugOut((DEB_ITRACE,
		 "_IN CoRevokeClassObjectNot(dwKey = %x)\n",
		 dwKey));

    PThreadData pdata;
    IUnknown *punk;
    HRESULT hr;
    DelayedRegistrationTable *pTable = NULL;

    DWORD dwReg = ~dwKey;

    //
    // Get the thread specific data and table to determine if there are
    // any delayed registrations. If not, just call the real routine.
    //
    pdata = TlsThkGetData();

    if (pdata == NULL)
    {
	goto exitRtn;
    }

    if ((pTable = pdata->pDelayedRegs) == NULL)
    {
	goto exitRtn;
    }

    //
    // the 'fake' key is really the bitwise not of the index
    //

    if ( dwReg >= MAX_DELAYED_REGISTRATIONS)
    {
	goto exitRtn;
    }

    if(pTable->_Entries[dwReg]._punk != NULL)
    {
	punk = pTable->_Entries[dwReg]._punk;
	pTable->_Entries[dwReg]._punk = NULL;

	dwKey = pTable->_Entries[dwReg]._dwRealKey;
	pTable->_Entries[dwReg]._dwRealKey = 0;

	//
	// The class object table normally does an addref on the class factory.
	// We are also holding an addref on the punk. Release it.
	//
	if (punk != NULL)
	{
	    punk->Release();

	    //
	    // If the real key is zero, then we never did actually finish
	    // the registration. In this case, we return S_OK, because we
	    // are faking the app out anyway. This might happen if the app
	    // decides to shutdown for some reason without triggering the
	    // operation that causes us to register its class objects
	    //
	    if (dwKey == 0)
	    {
		hr = S_OK;
                goto exitNow;
	    }
	}
    }

exitRtn:

    hr = CoRevokeClassObject(dwKey);

exitNow:
    thkDebugOut((DEB_ITRACE,"OUT CoRevokeClassObjectNot():%x\n",hr));
    return(hr);

}
//+---------------------------------------------------------------------------
//
//  Function:   CoRegisterClassObjectDelayed
//
//  Synopsis:   Delay the registration of class objects. Some applications,
//		such as Word Perfect 6.1, register their class objects then
//		do peek message operations BEFORE they are fully initialized.
//		This causes problems because we can call in and do
//		CreateInstance calls before they are ready for them. This
//		wonderful hack will delay the registration of class objects
//		until someone calls RegisterClassObjectsNow(), which is
//		called when we know it is safe.
//
//		Novell knows about this hack, and promised not to change
//		the 16-bit code on us.
//
//  Effects:	Store all of the registration information in an array, and
//		return a special key value.
//		
//
//  Arguments:  ( Same as CoRegisterClassObject)
//
//  Requires:	The associated routine CoUnregisterClassObjectDelayed needs
//		to be called in the CoRevokeClassObject path to check to see
//		if the key being passed in is a special key. That way we
//		can translate the key before calling the real routine.
//
//		The special key value is not of the key
//
//  Returns:	S_OK or E_UNEXPECTED
//
//  History:    4-14-95   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
HRESULT CoRegisterClassObjectDelayed( REFCLSID refclsid, LPUNKNOWN punk,
                                  DWORD dwClsContext, DWORD flags, DWORD *pdwReg)
{
    thkDebugOut((DEB_ITRACE,"_IN CoRegisterClassObjectDelayed\n"));
    PThreadData pdata;
    int i;
    DelayedRegistrationTable *pTable = NULL;

    //
    // Assume this is going to fail
    //
    HRESULT hr = E_UNEXPECTED;
    *pdwReg = 0;

    pdata = TlsThkGetData();
    if (pdata == NULL)
    {
	goto exitRtn;
    }

    if ((pTable = pdata->pDelayedRegs) == NULL)
    {
	pTable = pdata->pDelayedRegs = new DelayedRegistrationTable();
    }

    if (pTable != NULL)
    {
	for (i = 0 ; i < MAX_DELAYED_REGISTRATIONS ; i++)
	{
	    if(pTable->_Entries[i]._punk == NULL)
	    {
		pTable->_Entries[i]._punk = punk;
		pTable->_Entries[i]._clsid = refclsid;
		pTable->_Entries[i]._dwClsContext = dwClsContext;
		pTable->_Entries[i]._flags = flags;
		//
		// The class object table normally does an
		// addref on the class factory. We will hang on to this
		// to keep the class factory and the 3216 proxy alive
		//
		punk->AddRef();
		*pdwReg = ~i;
		hr = S_OK;
		break;
	    }
	}
    }

exitRtn:
    thkDebugOut((DEB_ITRACE,"OUT CoRegisterClassObjectDelayed() : %x\n",hr));
    return(hr);
}


//+---------------------------------------------------------------------------
//
//  Function:   CoRegisterClassObjectNot, public
//
//  Synopsis:   Thunks for the 16-bit applications call CoRegisterClassObject
//              Here we check for the registered class objects to set the
//              thread's compatability bits.
//
//  Arguments:  [refclsid] - CLSID for the class to register
//              [punk]     - ClassFactory interface
//              [dwClsContext] - Class context
//              [flags]        - flags
//              [lpdwreg]      - register
//
//  Returns:    Appropriate status code
//
//  History:    18-Jul-94   BobDay  Created
//
//----------------------------------------------------------------------------

EXTERN_C const CLSID CDECL CLSID_EXCEL5_WORKSHEET =
     { 0x020810, 0, 0, {0xC0, 0, 0, 0, 0, 0, 0, 0x46}};

EXTERN_C const CLSID CDECL CLSID_WORD6_DOCUMENT =
     { 0x020900, 0, 0, {0xC0, 0, 0, 0, 0, 0, 0, 0x46}};

EXTERN_C const CLSID CDECL CLSID_WPWIN61 =
     { 0x89FE3FE3, 0x9FF6, 0x101B, {0xB6, 0x78, 0x04, 0x02, 0x1C, 0x00, 0x70, 0x02}};

EXTERN_C const CLSID CDECL CLSID_WPWIN61_FILE =
     { 0x1395F281, 0x4326, 0x101b, {0x8B, 0x9A, 0xCE, 0x29, 0x3E, 0xF3, 0x84, 0x49}};

EXTERN_C const CLSID CDECL CLSID_IKITARO_130 =
     { 0x02B501, 0, 0, {0xC0, 0, 0, 0, 0, 0, 0, 0x46}};


DEFINE_OLEGUID(CLSID_EXCEL5_WORKSHEET, 0x20810, 0, 0);



STDAPI_(DWORD) CoRegisterClassObjectNot( REFCLSID refclsid, LPUNKNOWN punk,
                                         DWORD dwClsContext, DWORD flags,
                                         LPDWORD lpdwreg )
{
    //
    // Excel didn't AddRef the IOleObjectClientSite returned from
    // the IOleObject::GetClientSite method.
    //
    if ( IsEqualCLSID(refclsid,CLSID_EXCEL5_WORKSHEET) )
    {
        DWORD   dw;

        dw = TlsThkGetAppCompatFlags();
        TlsThkSetAppCompatFlags(dw | OACF_CLIENTSITE_REF);

        thkDebugOut((DEB_WARN,"AppCompatFlag: OACF_CLIENTSITE_REF enabled\n"));
    }

    //
    // WinWord didn't call OleSetMenuDescriptor(NULL) during
    // IOleInPlaceFrame::RemoveMenus.  We do it for them.
    //
    // Also WinWord thinks GDI objects like palettes and bitmaps can be
    // transferred on HGLOBALs during GetData calls.  In order to thunk
    // them properly, we need to patch up the STGMEDIUMS given to use
    // by word.  This is controlled by OACF_USEGDI.
    //
    // YAWC: Word chokes and dies because it fails to disconnect some of its
    // objects. During shutdown of a link, for example, cleaning up the stdid
    // table causes WORD to fault.
    //
    else if ( IsEqualCLSID(refclsid,CLSID_WORD6_DOCUMENT) )
    {
        DWORD   dw;

        dw = TlsThkGetAppCompatFlags();
        TlsThkSetAppCompatFlags(dw | OACF_RESETMENU | OACF_USEGDI | OACF_NO_UNINIT_CLEANUP);

        thkDebugOut((DEB_WARN,"AppCompatFlag: OACF_RESETMENU enabled\n"));
	thkDebugOut((DEB_WARN,"AppCompatFlag: OACF_USEGDI enabled\n"));
	thkDebugOut((DEB_WARN,"AppCompatFlag: OACF_NO_UNINIT_CLEANUP enabled\n"));
    }
    else if ( IsEqualCLSID(refclsid,CLSID_WPWIN61) )
    {
        thkDebugOut((DEB_WARN,"WordPerfect hack triggered\n"));
        thkDebugOut((DEB_WARN,"Intercepting CoRegisterClassObject(WPWIN61)\n"));

	return CoRegisterClassObjectDelayed( refclsid,punk,dwClsContext,flags,lpdwreg);

    }
    else if ( IsEqualCLSID(refclsid,CLSID_WPWIN61_FILE) )
    {
        thkDebugOut((DEB_WARN,"WordPerfect hack triggered\n"));
        thkDebugOut((DEB_WARN,"Intercepting CoRegisterClassObject(WPWIN61_FILE)\n"));
	return CoRegisterClassObjectDelayed( refclsid,punk,dwClsContext,flags,lpdwreg);
    }
    else if ( IsEqualCLSID(refclsid,CLSID_IKITARO_130) )
    {
	// Note: Ikitaro queries for IViewObject and uses it as IViewObject2
        DWORD   dw = TlsThkGetAppCompatFlags();
        thkDebugOut((DEB_WARN,"Ikitaro hack triggered\n"));
        TlsThkSetAppCompatFlags(dw | OACF_IVIEWOBJECT2);
    }

    return (DWORD)CoRegisterClassObject( refclsid, punk, dwClsContext,
                                     flags, lpdwreg );
}


//+---------------------------------------------------------------------------
//
//  Function:   OleRegGetUserTypeNot
//
//  Synopsis:	Adds a hook for a WordPerfect hack. Check out the functions
//		CoRegisterClassObjectDelayed and
//		RegisterDelayedClassFactories for details. In essence, when
//		this function is called for the WPWIN61 classID, we know
//		that it is safe to register all of the delayed class objects.
//		This determination was done by debugging Wordperfect. When
//		they call this API, then are actually done initializing the
//		internals of their app.
//
//  Effects:
//
//  History:    4-18-95   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI_(DWORD)
OleRegGetUserTypeNot(REFCLSID clsid,DWORD dwFormOfType,LPOLESTR *pszUserType)
{
    //
    // Wordperfect has a bug. When they call OleRegGetUserType for their
    // classid, we know that it is safe to register their class objects for
    // real.
    //
    // See CoRegisterClassObjectDelayed for details
    //
    if ( IsEqualCLSID(clsid,CLSID_WPWIN61) )
    {
	thkDebugOut((DEB_WARN,"Registering WordPerfects class objects\n"));
	RegisterDelayedClassFactories();
    }
    return OleRegGetUserType(clsid,dwFormOfType,pszUserType);
}
//+---------------------------------------------------------------------------
//
//  Member:     OleThunkWOW::LoadProcDll, public
//
//  Synopsis:   Callback function for 32-bit OLE to load a 16-bit DLL
//
//  Arguments:  [pszDllName] - Name of 16-bit DLL
//              [lpvpfnGetClassObject] - returned 16:16 address of
//                                                      "DllGetClassObject"
//              [lpvpfnCanUnloadNow] - returned 16:16 address of
//                                                      "DllCanUnloadNow"
//              [lpvhmodule] - returned 16-bit hmodule
//
//  Returns:    Appropriate status code
//
//  History:    11-Mar-94   BobDay  Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
OleThunkWOW::LoadProcDll(
    LPCTSTR pszDllName,
    LPDWORD lpvpfnGetClassObject,
    LPDWORD lpvpfnCanUnloadNow,
    LPDWORD lpvhmodule
)
{
    HRESULT hr;
    UINT    uiSize;
    VPSTR   vpstr16;
    VPVOID  vplpds16;
    LOADPROCDLLSTRUCT UNALIGNED *lplpds16;
    char string[256];

    // Ensure that Interop is enabled
    Win4Assert(gfIteropEnabled);
    // Ensure that callbacks are allowed on this thread
    Win4Assert(TlsThkGetThkMgr()->AreCallbacksAllowed());

    uiSize = lstrlen(pszDllName) + 1;

    vpstr16 = STACKALLOC16(uiSize*sizeof(TCHAR));
    if (vpstr16 == 0)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

#ifndef _CHICAGO_
    hr = Convert_LPOLESTR_to_VPSTR(pszDllName, vpstr16,
                                   uiSize, uiSize*sizeof(TCHAR));
#else
    hr = Convert_LPSTR_to_VPSTR(pszDllName, vpstr16,
                                   uiSize, uiSize*sizeof(TCHAR));
#endif

    if (FAILED(hr))
    {
        goto EH_vpstr16;
    }

    vplpds16 = STACKALLOC16(sizeof(LOADPROCDLLSTRUCT));
    if (vplpds16 == 0)
    {
        hr = E_OUTOFMEMORY;
        goto EH_vpstr16;
    }

    lplpds16 = FIXVDMPTR(vplpds16, LOADPROCDLLSTRUCT);

    lplpds16->vpDllName          = vpstr16;
    lplpds16->vpfnGetClassObject = 0;
    lplpds16->vpfnCanUnloadNow   = 0;
    lplpds16->vhmodule           = 0;

    RELVDMPTR(vplpds16);

    hr = CallbackTo16( gdata16Data.fnLoadProcDll, vplpds16 );

    if (SUCCEEDED(hr))
    {
        lplpds16 = FIXVDMPTR(vplpds16, LOADPROCDLLSTRUCT);
        *lpvpfnGetClassObject = lplpds16->vpfnGetClassObject;
        *lpvpfnCanUnloadNow = lplpds16->vpfnCanUnloadNow;
        *lpvhmodule = lplpds16->vhmodule;
        RELVDMPTR(vplpds16);
#ifdef _CHICAGO_
        thkDebugOut((DEB_WARN, "Loaded COM DLL: %s with HMODULE: 0x%x\n",
                     pszDllName, *lpvhmodule));
#else
        thkDebugOut((DEB_WARN, "Loaded COM DLL: %ws with HMODULE: 0x%x\n",
                     pszDllName, *lpvhmodule));
#endif
    }
    else
    {
        hr = CO_E_DLLNOTFOUND;
    }

    STACKFREE16(vplpds16, sizeof(LOADPROCDLLSTRUCT));

 EH_vpstr16:
    STACKFREE16(vpstr16,uiSize*sizeof(TCHAR));

 Exit:
    return hr;
}

//+---------------------------------------------------------------------------
//
//  Member:     OleThunkWOW::UnloadProcDll, public
//
//  Synopsis:   Callback function for 32-bit OLE to unload a 16-bit DLL
//
//  Arguments:  [vhmodule] - 16-bit hmodule
//
//  Returns:    Appropriate status code
//
//  History:    11-Mar-94   BobDay  Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
OleThunkWOW::UnloadProcDll(
    HMODULE   vhmodule
)
{
    HRESULT hr = S_OK;

    // Ensure that Interop is enabled and callbacks are 
    // not allowed on this thread
    if(gfIteropEnabled && TlsThkGetThkMgr()->AreCallbacksAllowed())
        hr = CallbackTo16(gdata16Data.fnUnloadProcDll, HandleToUlong(vhmodule));

    return(hr); 
}

//+---------------------------------------------------------------------------
//
//  Member:     OleThunkWOW::CallGetClassObject, public
//
//  Synopsis:   Callback function for 32-bit OLE to call 16-bit
//              DllGetClassObject
//
//  Arguments:  [vpfnGetClassObject] - 16:16 address of DllGetClassObject
//              [rclsid] - CLSID of object
//              [riid] - IID of interface on object
//              [ppv] - returned object interface
//
//  Returns:    Appropriate status code
//
//  History:    11-Mar-94   BobDay  Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
OleThunkWOW::CallGetClassObject(
    DWORD       vpfnGetClassObject,
    REFCLSID    rclsid,
    REFIID      riid,
    LPVOID FAR *ppv
)
{
    DWORD       dwResult;
    VPVOID      vpcgcos16;
    CALLGETCLASSOBJECTSTRUCT UNALIGNED *lpcgcos16;
    VPVOID      iface16;
    IIDIDX      iidx;
    IUnknown    *punkThis32;
    CThkMgr     *pThkMgr;
    ThreadData  *ptd;

    // Ensure that Interop is enabled
    Win4Assert(gfIteropEnabled);
    // Ensure that callbacks are allowed on this thread
    Win4Assert(TlsThkGetThkMgr()->AreCallbacksAllowed());

    ptd = TlsThkGetData();
    if (ptd == NULL)
    {
        thkDebugOut((DEB_WARN, "WARNING: CallGetClassObject refused\n"));

        dwResult = (DWORD)E_FAIL;
        goto Exit;
    }
    pThkMgr = ptd->pCThkMgr;

    vpcgcos16 = STACKALLOC16(sizeof(CALLGETCLASSOBJECTSTRUCT));
    if (vpcgcos16 == 0)
    {
        dwResult = (DWORD)E_OUTOFMEMORY;
        goto Exit;
    }

    lpcgcos16 = FIXVDMPTR(vpcgcos16, CALLGETCLASSOBJECTSTRUCT);

    lpcgcos16->vpfnGetClassObject = vpfnGetClassObject;
    lpcgcos16->clsid              = rclsid;
    lpcgcos16->iid                = riid;
    lpcgcos16->iface              = 0;

    RELVDMPTR(vpcgcos16);

    dwResult = CallbackTo16( gdata16Data.fnCallGetClassObject, vpcgcos16 );


    if ( SUCCEEDED(dwResult) )
    {
        lpcgcos16 = FIXVDMPTR(vpcgcos16, CALLGETCLASSOBJECTSTRUCT);
        iface16 = lpcgcos16->iface;

        iidx = IidToIidIdx(riid);

        // We're on the way out creating a proxy so set the state
        // appropriately
        pThkMgr->SetThkState(THKSTATE_INVOKETHKOUT32);

        // Get a 32-bit proxy object for the 16-bit object
        punkThis32 = pThkMgr->FindProxy3216(NULL, iface16, NULL, iidx, FALSE, NULL);

        pThkMgr->SetThkState(THKSTATE_NOCALL);

        // Set the out param
        *(IUnknown **)ppv = punkThis32;

        // As this is an OUT parameter, release the actual 16-bit interface
        // This could be the last release on the 16-bit interface, if the
        // proxy was not successfully created
        ReleaseOnObj16(iface16);

        if(punkThis32 == NULL) {
            dwResult = (DWORD)E_OUTOFMEMORY;
        }

        RELVDMPTR(vpcgcos16);
    }
    else {  // need to map dwResult only for failure cases (see hmMappings)
        dwResult = TransformHRESULT_1632( dwResult );
    }

    STACKFREE16(vpcgcos16, sizeof(CALLGETCLASSOBJECTSTRUCT));

 Exit:
    return dwResult;
}

//+---------------------------------------------------------------------------
//
//  Member:     OleThunkWOW::CallCanUnloadNow, public
//
//  Synopsis:   Callback function for 32-bit OLE to call 16-bit
//              CanUnloadNow
//
//  Arguments:  [vpfnCanUnloadNow] - 16:16 address of DllCanUnloadNow
//
//  Returns:    Appropriate status code
//
//  History:    11-Mar-94   BobDay  Created
//
//----------------------------------------------------------------------------

STDMETHODIMP OleThunkWOW::CallCanUnloadNow(
    DWORD       vpfnCanUnloadNow)
{
    HRESULT hr = S_OK;

    // Ensure that Interop is enabled and callbacks are 
    // not allowed on this thread
    if(gfIteropEnabled && TlsThkGetThkMgr()->AreCallbacksAllowed())
        hr = CallbackTo16(gdata16Data.fnCallCanUnloadNow, vpfnCanUnloadNow);

    return(hr);
}

//+---------------------------------------------------------------------------
//
//  Member:     OleThunkWOW::GetThunkManager, public
//
//  Synopsis:   Callback function for 32-bit OLE to retrieve the thunkmanager
//
//  Arguments:  [ppThkMgr] - Thunk manager return
//
//  Returns:    Appropriate status code
//
//  History:    11-May-94   JohannP  Created
//
//----------------------------------------------------------------------------

STDMETHODIMP OleThunkWOW::GetThunkManager(IThunkManager **ppThkMgr)
{
    thkDebugOut((DEB_THUNKMGR, "%sIn OleThunkWOW::GetThunkManager\n",
                 NestingLevelString()));

    thkAssert(ppThkMgr != NULL);

    IUnknown *pUnk = TlsThkGetThkMgr();
    thkAssert(pUnk && "Invalid Thunkmanager");

    *ppThkMgr = (IThunkManager *)pUnk;
    pUnk->AddRef();

    thkDebugOut((DEB_THUNKMGR, "%sOut OleThunkWOW::GetThunkManager: (%p)\n",
                 NestingLevelString(), pUnk));

    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Member:     OleThunkWOW::WinExec16, public
//
//  Synopsis:   Callback function for 32-bit OLE to run an application
//
//  Arguments:  [pszCommandLine] - command line for WinExec
//              [usShow] - fShow for WinExec
//
//  Returns:    Appropriate status code
//
//  History:    27-Jul-94   AlexT   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP OleThunkWOW::WinExec16(
    LPCOLESTR pszCommandLine,
    USHORT usShow
)
{
    HRESULT hr;
    UINT    uiSize;
    VPSTR   vpstr16;
    VPVOID  vplpds16;
    WINEXEC16STRUCT UNALIGNED *lpwes16;
    ULONG   ulRet;

    // Ensure that Interop is enabled
    Win4Assert(gfIteropEnabled);
    // Ensure that callbacks are allowed on this thread
    Win4Assert(TlsThkGetThkMgr()->AreCallbacksAllowed());

    uiSize = lstrlenW(pszCommandLine) + 1;

    vpstr16 = STACKALLOC16(uiSize*2);
    if (vpstr16 == 0)
    {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    hr = Convert_LPOLESTR_to_VPSTR(pszCommandLine, vpstr16,
                                   uiSize, uiSize*2);
    if (FAILED(hr))
    {
        goto EH_vpstr16;
    }

    vplpds16 = STACKALLOC16(sizeof(WINEXEC16STRUCT));
    if (vplpds16 == 0)
    {
        hr = E_OUTOFMEMORY;
        goto EH_vpstr16;
    }

    lpwes16 = FIXVDMPTR(vplpds16, WINEXEC16STRUCT);

    lpwes16->vpCommandLine       = vpstr16;
    lpwes16->vusShow             = usShow;

    RELVDMPTR(vplpds16);

    ulRet = CallbackTo16( gdata16Data.fnWinExec16, vplpds16 );
    thkDebugOut((DEB_ITRACE,
                 "CallbackTo16(WinExec16) returned %ld\n", ulRet));

    //  According to the Windows spec, return values greater than 31 indicate
    //  success.

    if (ulRet > 31)
    {
        hr = S_OK;
    }
    else if (0 == ulRet)
    {
        //  0 indicates lack of some kind of resource
        hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = HRESULT_FROM_WIN32(ulRet);
    }

    STACKFREE16(vplpds16, sizeof(WINEXEC16STRUCT));

 EH_vpstr16:
    STACKFREE16(vpstr16, uiSize*2);

 Exit:
    return hr;
}


//+---------------------------------------------------------------------------
//
//  Method:     OleThunkWOW::ConvertHwndToFullHwnd
//
//  Synopsis:   Converts a 16 bit HWND into a 32-bit HWND
//
//  Effects:    Since OLE32 doesn't directly link to WOW, this function allows
//		the DDE layer to access the routine that maps 16 bit HWND to
//		full 32-bit HWND's.
//
//  Arguments:  [hwnd] -- HWND to convert
//
//  History:    8-03-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(HWND) OleThunkWOW::ConvertHwndToFullHwnd(HWND hwnd)
{
    return(FULLHWND_32((USHORT)hwnd));
}

//+---------------------------------------------------------------------------
//
//  Method:     OleThunkWOW::FreeMetaFile
//
//  Synopsis:   Calls wow to delete a metafile that has memory reserved in
//		the 16 bit address space
//
//  Effects:    Since OLE32 doesn't directly link to WOW, this function allows
//		the DDE layer to access the routine in WOW
//
//  Arguments:  [hmf] -- HANDLE to delete
//
//  History:    8-03-94   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(BOOL) OleThunkWOW::FreeMetaFile(HANDLE hmf)
{
    return(WOWFreeMetafile(hmf));
}



//+---------------------------------------------------------------------------
//
//  Member:     OleThunkWOW::YieldTask16, public
//
//  Synopsis:   Callback function for 32-bit OLE to yield
//
//  History:    08-Aug-94   Ricksa  Created
//
//----------------------------------------------------------------------------
STDMETHODIMP OleThunkWOW::YieldTask16(void)
{
    WOWYield16();
    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:	OleThunkWOW::DirectedYield, public
//
//  Synopsis:	Does a directed yield in the VDM.
//
//  History:	08-Aug-94   Rickhi  Created
//
//----------------------------------------------------------------------------
STDMETHODIMP OleThunkWOW::DirectedYield(DWORD dwCalleeTID)
{
    WORD hTask16 = WOWHandle16((void *)dwCalleeTID, WOW_TYPE_HTASK);

    thkDebugOut((DEB_ITRACE, "WOWDirectedYield16(%x)\n", hTask16));

    WOWDirectedYield16(hTask16);

    thkDebugOut((DEB_ITRACE, "WOWDirectedYield16() returned\n"));

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Method:     OleThunkWOW::PrepareForCleanup
//
//  Synopsis:   Prepares OLETHK32 for OLE32.DLL's cleanup.
//
//  Effects:    It does this by taking all of the remaining 3216 proxies
//              and marking them such that no callbacks into the 16-bit
//              world are possible.
//
//  Arguments:  -none-
//
//  History:    24-Aug-94   bobday    Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDMETHODIMP_(void) OleThunkWOW::PrepareForCleanup(void)
{
    CThkMgr *pcthkmgr;

    if ( TlsThkGetData() != NULL )
    {
        pcthkmgr = (CThkMgr*)TlsThkGetThkMgr();

        //
        // Tell the thkmgr to prepare for cleaning itself up
        //
        pcthkmgr->PrepareForCleanup();
    }
}


//+---------------------------------------------------------------------------
//
//  Method:     OleThunkWOW::GetAppCompatibilityFlags
//
//  Synopsis:   Used to return the current THK app compatibility flags to
//		OLE32.DLL
//  Arguments:  [void] --
//
//  Requires:
//
//  Returns:    Flags defined in ih\thunkapi.hxx
//
//  History:    1-11-96   kevinro   Created
//
//----------------------------------------------------------------------------
STDMETHODIMP_(DWORD) OleThunkWOW::GetAppCompatibilityFlags(void)
{
    return(TlsThkGetAppCompatFlags());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\olethk32\cthkmgr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       cthkmgr.cxx
//
//  Contents:   cthunkmanager for an apartment
//
//  Classes:    CThkMgr derived from IThunkManager
//
//  Functions:
//
//  History:    5-18-94   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include "headers.cxx"
#pragma hdrstop
#include <olepfn.hxx>
#if DBG == 1
BOOL fDebugDump = FALSE;
#define DBG_DUMP(x) if (fDebugDump) { x; }
#else
#define DBG_DUMP(x)
#endif

#define PprxNull(pprx) (((pprx).wType = PPRX_NONE), ((pprx).dwPtrVal = 0))
#define PprxIsNull(pprx) ((pprx).dwPtrVal == 0)
#define Pprx16(vpv) PROXYPTR((DWORD)vpv, PPRX_16)
#define Pprx32(pto) PROXYPTR((DWORD)pto, PPRX_32)

//+---------------------------------------------------------------------------
//
//  Function:   ResolvePprx, public
//
//  Synopsis:   Converts a PROXYPTR to a CProxy *
//
//  Arguments:  [ppprx] - PROXYPTR
//
//  Returns:    Pointer or NULL
//
//  History:    15-Jul-94       DrewB   Created
//
//----------------------------------------------------------------------------

CProxy *ResolvePprx(PROXYPTR *ppprx)
{
    if (ppprx->wType == PPRX_32)
    {
        return (CProxy *)ppprx->dwPtrVal;
    }
    else
    {
        // Get a pointer to all of the proxy rather than just the CProxy part
        return FIXVDMPTR(ppprx->dwPtrVal, THUNK1632OBJ);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ReleasePprx, public
//
//  Synopsis:   Releases a resolved PROXYPTR
//
//  Arguments:  [ppprx] - PROXYPTR
//
//  History:    10-Oct-94       DrewB   Created
//
//----------------------------------------------------------------------------

void ReleasePprx(PROXYPTR *ppprx)
{
    if (ppprx->wType == PPRX_16)
    {
        RELVDMPTR(ppprx->dwPtrVal);
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CThkMgr::NewHolder, public
//
//  Synopsis:   Creates a new proxy holder
//
//  Arguments:  [pUnk]      - IUnknown ptr
//              [punkProxy] - IUnknown proxy
//              [dwFlags]   - Flags
//
//  Returns:    Holder or NULL
//
//  History:    19-Mar-97       Gopalk    Rewritten to support object identity
//
//----------------------------------------------------------------------------
PROXYHOLDER *CThkMgr::NewHolder(VPVOID pUnk, PROXYPTR unkProxy, DWORD dwFlags)
{
    thkDebugOut((DEB_THUNKMGR, "%sIn  CThkMgr::NewHolder(0x%X)\n",
                 NestingLevelString(), dwFlags));
    DebugIncrementNestingLevel();

    // Local variables
    PROXYHOLDER *pph;
    CProxy *proxy;

    // Allocate a new holder
    pph = (PROXYHOLDER *)flHolderFreeList.AllocElement();
    if(pph) {
        // Initialize
        pph->dwFlags = dwFlags;
        pph->cProxies = 0;
        pph->unkProxy = unkProxy;
        PprxNull(pph->pprxProxies);

        // Establish the identity of the new holder
        if(_pHolderTbl->SetAt((DWORD)pUnk, pph)) {
            // Add the IUnknown proxy to the new holder
            proxy = ResolvePprx(&unkProxy);
			if (proxy) {
				AddProxyToHolder(pph, proxy, unkProxy);
				ReleasePprx(&unkProxy);
			}
			else {
				_pHolderTbl->RemoveKey((DWORD)pUnk);
				flHolderFreeList.FreeElement((DWORD)pph);
			}
        }
        else {
            // Free the newly allocated holder
            flHolderFreeList.FreeElement((DWORD)pph);
        }
    }

    DebugDecrementNestingLevel();
    thkDebugOut((DEB_THUNKMGR, "%sOut CThkMgr::NewHolder => %p\n",
                 NestingLevelString(), pph));
    return pph;
}

//+---------------------------------------------------------------------------
//
//  Member:     CThkMgr::AddProxyToHolder, public
//
//  Synopsis:   Adds a new proxy to a holder
//
//  Arguments:  [pph] - Holder
//              [pprxReal] - Proxy
//              [pprx] - Abstract pointer
//
//  History:    07-Jul-94       DrewB   Extracted
//
//----------------------------------------------------------------------------

void CThkMgr::AddProxyToHolder(PROXYHOLDER *pph, CProxy *pprxReal, PROXYPTR &pprx)
{

    thkDebugOut((DEB_THUNKMGR, "%sIn AddProxyToHolder(%p, %p) cProxies %d\n",
                 NestingLevelString(), pph, pprx.dwPtrVal, pph->cProxies));
    DebugIncrementNestingLevel();

    thkAssert(ResolvePprx(&pprx) == pprxReal &&
              (ReleasePprx(&pprx), TRUE));

    // Bump count of held proxies
    AddRefHolder(pph);

    // Add proxy into list of object proxies
    thkAssert(PprxIsNull(pprxReal->pprxObject));
    pprxReal->pprxObject = pph->pprxProxies;
    pph->pprxProxies = pprx;

    thkAssert(pprxReal->pphHolder == NULL);
    pprxReal->pphHolder = pph;

    DebugDecrementNestingLevel();
    thkDebugOut((DEB_THUNKMGR, "%sout AddProxyToHolder(%p, %p) cProxies %d\n",
                 NestingLevelString(), pph, pprx.dwPtrVal, pph->cProxies));
}

//+---------------------------------------------------------------------------
//
//  Member:     CThkMgr::AddRefHolder, public
//
//  Synopsis:   Increments the proxy count for a holder
//
//  Arguments:  [pph] - Holder
//
//  History:    07-Jul-94       DrewB   Created
//
//----------------------------------------------------------------------------

void CThkMgr::AddRefHolder(PROXYHOLDER *pph)
{
    pph->cProxies++;

    thkDebugOut((DEB_THUNKMGR, "%sAddRefHolder(%p) cProxies %d\n",
                 NestingLevelString(), pph, pph->cProxies));
}

//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::ReleaseHolder, public
//
//  Synopsis:   Releases a proxy reference on the holder
//              Cleans up the holder if it was the last reference
//
//  Arguments:  [pph] - Holder
//
//  History:    19-Mar-97       Gopalk    Rewritten to support object identity
//
//----------------------------------------------------------------------------
void CThkMgr::ReleaseHolder(PROXYHOLDER *pph, DWORD ProxyType)
{
    thkDebugOut((DEB_THUNKMGR, "%sIn ReleaseHolder(%p) pre cProxies %d\n",
                 NestingLevelString(), pph, pph->cProxies));
    DebugIncrementNestingLevel();

    // Validation checks
    thkAssert(pph->cProxies > 0);
    if(ProxyType == PROXYFLAG_PUNKINNER) {
        thkAssert(pph->dwFlags & PH_AGGREGATEE);
    }

    // Decrement holder proxy count
    pph->cProxies--;

    if(pph->cProxies==0 && !(pph->dwFlags & PH_IDREVOKED)) {
        // All interfaces on the object have been released
        DWORD dwUnk;

        // Mark the holder as zombie
        pph->dwFlags |= PH_IDREVOKED;

        // Revoke the identity of the holder
        if(pph->dwFlags & PH_AGGREGATEE) {
            dwUnk = pph->unkProxy.dwPtrVal;
        }
        else if(pph->unkProxy.wType == PPRX_16) {
            THUNK1632OBJ UNALIGNED *Id1632;

            Id1632 = FIXVDMPTR(pph->unkProxy.dwPtrVal, THUNK1632OBJ);
            thkAssert(Id1632);
            dwUnk = (DWORD) Id1632->punkThis32;
            RELVDMPTR(pph->unkProxy.dwPtrVal);
        }
        else {
            thkAssert(pph->unkProxy.wType == PPRX_32);
            dwUnk = ((THUNK3216OBJ *) pph->unkProxy.dwPtrVal)->vpvThis16;
        }
#if DBG==1
        thkAssert(_pHolderTbl->RemoveKey(dwUnk));
#else
        _pHolderTbl->RemoveKey(dwUnk);
#endif
    }

    if(pph->cProxies==0 && ProxyType!=PROXYFLAG_NONE) {
        // Not a nested release
        CProxy *pprxReal;
        PROXYPTR pprx, pprxNext;

        // Release all the proxies under the holder
        pprx = pph->pprxProxies;
        while(!PprxIsNull(pprx)) {
            pprxReal = ResolvePprx(&pprx);
			thkAssert(pprxReal && "pprx points to an invalid address!");
			if (pprxReal) {
				pprxNext = pprxReal->pprxObject;

				thkAssert(pprxReal->cRefLocal == 0);
				thkAssert(pprxReal->pphHolder == pph);

				// Remove the proxy
				if(pprx.wType == PPRX_16) {
					// 1632 proxy
					RemoveProxy1632((VPVOID)pprx.dwPtrVal, (THUNK1632OBJ *)pprxReal);
				}
				else {
					// 3216 proxy
					RemoveProxy3216((THUNK3216OBJ *)pprxReal);
				}

				pprx = pprxNext;
			}
			else
				break;
        }

        // By now, proxy count should be zero
        thkAssert(pph->cProxies == 0);

        // Return holder to free list
        flHolderFreeList.FreeElement((DWORD)pph);
    }

    DebugDecrementNestingLevel();
    thkDebugOut((DEB_THUNKMGR, "%sOUT ReleaseHolder\n", NestingLevelString()));
    return;
}

//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::Create
//
//  Synopsis:   static member - creates complete thunkmanager
//
//  Arguments:  [void] --
//
//  Returns:    pointer to cthkmgr
//
//  History:    6-01-94   JohannP (Johann Posch)   Created
//              3-14-97   Gopalk                   Added Holder table
//
//  Notes:
//
//----------------------------------------------------------------------------
CThkMgr *CThkMgr::Create(void)
{
    CThkMgr *pcthkmgr = NULL;
    CMapDwordPtr *pPT1632 = new CMapDwordPtr(MEMCTX_TASK);
    CMapDwordPtr *pPT3216 = new CMapDwordPtr(MEMCTX_TASK);
    CMapDwordPtr *pHT = new CMapDwordPtr(MEMCTX_TASK);

    if (   (pPT1632 != NULL)
        && (pPT3216 != NULL)
        && (pHT != NULL)
        && (pcthkmgr = new CThkMgr( pPT1632, pPT3216, pHT )) )
    {
        // install the new thunkmanager
        TlsThkSetThkMgr(pcthkmgr);
    }
    else
    {
        if (pPT1632)
        {
            delete pPT1632;
        }
        if (pPT3216)
        {
            delete pPT3216;
        }
        if(pHT)
        {
            delete pHT;
        }

    }
    return pcthkmgr;
}

//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::CThkMgr
//
//  Synopsis:   private constructor - called by Create
//
//  Arguments:  [pPT1632] -- 16/32 proxy table
//              [pPT3216] -- 32/16 proxy table
//
//  History:    6-01-94   JohannP (Johann Posch)   Created
//              3-14-97   Gopalk                   Added Holder table
//
//----------------------------------------------------------------------------
CThkMgr::CThkMgr(CMapDwordPtr *pPT1632,
                 CMapDwordPtr *pPT3216,
                 CMapDwordPtr *pHT)

{
    _cRefs = 1;
    _thkstate = THKSTATE_NOCALL;
    _dwState = CALLBACK_ALLOWED;

    _piidnode = NULL;

    _pProxyTbl1632 = pPT1632;
    _pProxyTbl3216 = pPT3216;
    _pHolderTbl = pHT;

    _pphHolders = NULL;
}

//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::~CThkMgr
//
//  Synopsis:   destructor
//
//  History:    6-01-94   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
CThkMgr::~CThkMgr()
{
    PROXYHOLDER *pph;
    PIIDNODE pin;

    thkDebugOut((DEB_ITRACE, "_IN CThkMgr::~CThkMgr()\n"));

    RemoveAllProxies();
    thkAssert(_pHolderTbl->GetCount() == 0);
    delete _pProxyTbl1632;
    delete _pProxyTbl3216;

    // Clean up IID requests
#if DBG == 1
    if (_piidnode != NULL)
    {
        thkDebugOut((DEB_WARN, "WARNING: IID requests active at shutdown\n"));
    }
#endif

    while (_piidnode != NULL)
    {
        pin = _piidnode->pNextNode;

        thkDebugOut((DEB_IWARN, "IID request leak: %p {%s}\n",
                     _piidnode, IidOrInterfaceString(_piidnode->piid)));

        flRequestFreeList.FreeElement((DWORD)_piidnode);

        _piidnode = pin;
    }

    thkDebugOut((DEB_ITRACE, "OUT CThkMgr::~CThkMgr()\n"));
}

//+---------------------------------------------------------------------------
//
//  Member:	CThkMgr::RemoveAllProxies, public
//
//  Synopsis:	Removes all live proxies from the proxy tables
//
//  History:	01-Dec-94	DrewB	Created
//
//----------------------------------------------------------------------------

void CThkMgr::RemoveAllProxies(void)
{
    POSITION pos;
    DWORD dwKey;
    VPVOID vpv;

    thkDebugOut((DEB_ITRACE, "_IN CThkMgr::RemoveAllProxies()\n"));

    // Make sure that we disable 3216 proxies first to guard against calling
    // back into 16 bit land.

#if DBG == 1
    DWORD dwCount;

    dwCount = _pProxyTbl3216->GetCount();

    if (dwCount > 0)
    {
        thkDebugOut((DEB_WARN, "WARNING: %d 3216 proxies left\n", dwCount));
    }
#endif

    // delete the 3216 proxy table
    while (pos = _pProxyTbl3216->GetStartPosition())
    {
        THUNK3216OBJ *pto3216 = NULL;

        _pProxyTbl3216->GetNextAssoc(pos, dwKey, (void FAR* FAR&) pto3216);

		thkAssert(pto3216 && "CThkMgr::RemoveAllProxies-- found NULL proxy!");
		if (pto3216)
		{
			thkDebugOut((DEB_IWARN, "3216: %p {%d,%d, %p, %p} %s\n",
						 pto3216, pto3216->cRefLocal, pto3216->cRef,
						 pto3216->vpvThis16, pto3216->pphHolder,
						 IidIdxString(pto3216->iidx)));

			pto3216->grfFlags |= PROXYFLAG_CLEANEDUP;

			RemoveProxy3216(pto3216);
		}
    }

#if DBG == 1
    dwCount = _pProxyTbl1632->GetCount();

    if (dwCount > 0)
    {
        thkDebugOut((DEB_WARN, "WARNING: %d 1632 proxies left\n", dwCount));
    }
#endif

    // delete the 1632 proxy table
    while (pos = _pProxyTbl1632->GetStartPosition())
    {
        THUNK1632OBJ *pto1632;

        _pProxyTbl1632->GetNextAssoc(pos, dwKey, (void FAR* FAR&) vpv);

        pto1632 = FIXVDMPTR(vpv, THUNK1632OBJ);

#if DBG == 1
        thkDebugOut((DEB_IWARN, "1632: %p {%d,%d, %p, %p} %s\n",
                     vpv, pto1632->cRefLocal, pto1632->cRef,
                     pto1632->punkThis32, pto1632->pphHolder,
                     IidIdxString(pto1632->iidx)));
#endif
        //
        // Determine if this is a 'special' object that we know we want
        // to release. If it is, then remove all of the references this
        // proxy has on it.
        //
        if (CoQueryReleaseObject(pto1632->punkThis32) == NOERROR)
        {
            thkDebugOut((DEB_WARN,
                         "1632: %p is recognized Releasing object %d times\n",
                         pto1632->punkThis32,pto1632->cRef));

            while (pto1632->cRef)
            {
                IUnknown *punk;

                pto1632->cRef--;
                punk = pto1632->punkThis32;

                RELVDMPTR(vpv);

                if (punk->Release() == 0)
                {
                    break;
                }

                pto1632 = FIXVDMPTR(vpv, THUNK1632OBJ);
            }
        }

        // Releases pointer
        RemoveProxy1632(vpv, pto1632);
    }

    thkDebugOut((DEB_ITRACE, "OUT CThkMgr::RemoveAllProxies()\n"));
}

// *** IUnknown methods ***
//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::QueryInterface
//
//  Synopsis:   QueryInterface on the thunkmanager itself
//
//  Arguments:  [riid] -- IID of interface to return
//              [ppvObj] -- Interface return
//
//  Returns:    HRESULT
//
//  History:    6-01-94   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
STDMETHODIMP CThkMgr::QueryInterface (REFIID riid, LPVOID FAR* ppvObj)
{
    if (IsBadWritePtr(ppvObj, sizeof(void *)))
    {
        return E_INVALIDARG;
    }

    *ppvObj = NULL;

    // There is no IID_IThunkManager because nobody needs it

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = (IUnknown *) this;
        AddRef();
        return S_OK;
    }

    return E_NOINTERFACE;
}

//+---------------------------------------------------------------------------
//
//  Methode:    CThkMgr::AddRef
//
//  Synopsis:   Adds a reference
//
//  Returns:    New ref count
//
//  History:    6-01-94   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CThkMgr::AddRef ()
{
    InterlockedIncrement( &_cRefs );
    return _cRefs;
}

//+---------------------------------------------------------------------------
//
//  Methode:    CThkMgr::Release
//
//  Synopsis:   Releases a reference
//
//  Returns:    New ref count
//
//  History:    6-01-94   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
STDMETHODIMP_(ULONG) CThkMgr::Release()
{
    if (InterlockedDecrement( &_cRefs ) == 0)
    {

        return 0;
    }
    return _cRefs;
}

// *** IThunkManager methods ***
//
//
//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::IsIIDRequested
//
//  Synopsis:   checks if given refiid was requested by WOW
//
//  Arguments:  [riid] -- refiid
//
//  Returns:    true if requested by 16 bit
//
//  History:    6-01-94   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
STDMETHODIMP_ (BOOL) CThkMgr::IsIIDRequested(REFIID riid)
{
    PIIDNODE piidnode = _piidnode;
    BOOL fRet = FALSE;

    while (piidnode)
    {
        if (*piidnode->piid == riid)
        {
            fRet = TRUE;
            break;
        }

        piidnode = piidnode->pNextNode;
    }

    thkDebugOut((DEB_THUNKMGR, "IsIIDRequested(%s) => %d\n",
                 GuidString(&riid), fRet));

    return fRet;
}

//+---------------------------------------------------------------------------
//
//  Member:     CThkMgr::IsCustom3216Proxy, public
//
//  Synopsis:   Attempts to identify the given IUnknown as a 32->16 proxy
//              and also checks whether it is a thunked interface or not
//
//  Arguments:  [punk] - Object
//
//  Returns:    BOOL
//
//  History:    11-Jul-94       DrewB   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(BOOL) CThkMgr::IsCustom3216Proxy(IUnknown *punk,
                                               REFIID riid)
{
    return !IsIIDSupported(riid) && IsProxy3216(punk) != 0;
}

//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::IsIIDSupported
//
//  Synopsis:   Return whether the given interface is thunked or not
//
//  Arguments:  [riid] -- Interface
//
//  Returns:    BOOL
//
//  History:    6-01-94   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
BOOL CThkMgr::IsIIDSupported(REFIID riid)
{
    return IIDIDX_IS_INDEX(IidToIidIdx(riid));
}

//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::AddIIDRequest
//
//  Synopsis:   adds the refiid to the request list
//
//  Arguments:  [riid] -- Interface
//
//  Returns:    true on success
//
//  History:    6-01-94   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
BOOL CThkMgr::AddIIDRequest(REFIID riid)
{
    PIIDNODE piidnode = _piidnode;

    thkAssert(!IsIIDSupported(riid));

    // create a new node and add at front
    piidnode = (PIIDNODE)flRequestFreeList.AllocElement();
    if (piidnode == NULL)
    {
        return FALSE;
    }

    piidnode->pNextNode = _piidnode;
    _piidnode = piidnode;

    // IID requests are only valid for the lifetime of the call that
    // requested a custom interface, so there's no need to copy
    // the IID's memory since it must remain valid for the same time
    // period
    piidnode->piid = (IID *)&riid;

    thkDebugOut((DEB_THUNKMGR, "AddIIDRequest(%s)\n", GuidString(&riid)));

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::RemoveIIDRequest
//
//  Synopsis:   removes a request for the request list
//
//  Arguments:  [riid] -- Interface
//
//  Returns:    true on success
//
//  History:    6-01-94   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
void CThkMgr::RemoveIIDRequest(REFIID riid)
{
    PIIDNODE piidnode;
    PIIDNODE pinPrev;

    thkAssert(!IsIIDSupported(riid));

    pinPrev = NULL;
    piidnode = _piidnode;
    while (piidnode)
    {
        if (*piidnode->piid == riid)
        {
            break;
        }

        pinPrev = piidnode;
        piidnode = piidnode->pNextNode;
    }

    thkAssert(piidnode != NULL && "RemoveIIDRequest: IID not found");

    thkDebugOut((DEB_THUNKMGR, "RemoveIIDRequest(%s)\n", GuidString(&riid)));

    if (pinPrev == NULL)
    {
        _piidnode = piidnode->pNextNode;
    }
    else
    {
        pinPrev->pNextNode = piidnode->pNextNode;
    }

    flRequestFreeList.FreeElement((DWORD)piidnode);
}

//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::CanGetNewProxy1632
//
//  Synopsis:   Preallocates proxy memory
//
//  Arguments:  [iidx] - Custom interface or known index
//
//  Returns:    vpv pointer if proxy is available, fails otherwise
//
//  History:    6-01-94   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
VPVOID CThkMgr::CanGetNewProxy1632(IIDIDX iidx)
{
    VPVOID vpv;
    THUNK1632OBJ UNALIGNED *pto;

    thkDebugOut((DEB_THUNKMGR, "%sIn  CanGetNewProxy1632(%s)\n",
                 NestingLevelString(), IidIdxString(iidx)));

    // Allocate proxy memory
    vpv = (VPVOID)flFreeList16.AllocElement();

    if (vpv == NULL)
    {
        thkDebugOut((DEB_WARN, "WARNING: Failed to allocate memory "
                     "for 16-bit proxies\n"));
        goto Exit;
    }

    // Add custom interface request if necessary
    if (vpv && IIDIDX_IS_IID(iidx))
    {
        // add the request for the unknown interface
        if ( !AddIIDRequest(*IIDIDX_IID(iidx)) )
        {
            flFreeList16.FreeElement( (DWORD)vpv );
            vpv = 0;
        }
    }

    // Set up the preallocated proxy as a temporary proxy so that
    // we can hand it out for nested callbacks
    pto = FIXVDMPTR(vpv, THUNK1632OBJ);
    thkAssert(pto != NULL);

    pto->pfnVtbl = gdata16Data.atfnProxy1632Vtbl;
    pto->cRefLocal = 0;
    pto->cRef = 0;
    pto->iidx = iidx;
    pto->punkThis32 = NULL;
    pto->pphHolder = NULL;
    PprxNull(pto->pprxObject);
    pto->grfFlags = PROXYFLAG_TEMPORARY;
#if DBG == 1
    // Deliberately make this an invalid proxy.  We want it to be used
    // in as few places as possible
    pto->dwSignature = PSIG1632TEMP;
#endif

    RELVDMPTR(vpv);

 Exit:
    thkDebugOut((DEB_THUNKMGR, "%sOut CanGetNewProxy1632: %p\n",
                 NestingLevelString(), vpv));

    return vpv;
}

//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::FreeNewProxy1632
//
//  Synopsis:   frees unused preallocated proxies
//
//  Arguments:  [iidx] - Custom interface or known index
//
//  History:    6-01-94   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
void CThkMgr::FreeNewProxy1632(VPVOID vpv, IIDIDX iidx)
{
    thkDebugOut((DEB_THUNKMGR, "%sIn FreeNewProxy1632(%s)\n",
                 NestingLevelString(), IidIdxString(iidx)));

    thkAssert(vpv != 0);

    if (IIDIDX_IS_IID(iidx))
    {
        // remove the request for the unknown interface
        RemoveIIDRequest(*IIDIDX_IID(iidx));
    }

#if DBG == 1
    // Ensure that we're not getting rid of a temporary proxy that's
    // in use
    THUNK1632OBJ UNALIGNED *pto;

    pto = FIXVDMPTR(vpv, THUNK1632OBJ);
    if (pto->grfFlags & PROXYFLAG_TEMPORARY)
    {
        thkAssert(pto->cRefLocal == 0 && pto->cRef == 0);
    }
    RELVDMPTR(vpv);
#endif

    // add element to free list
    flFreeList16.FreeElement( (DWORD)vpv );

    thkDebugOut((DEB_THUNKMGR, "%sOut FreeNewProxy1632\n",
                 NestingLevelString()));
}

//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::IsProxy1632
//
//  Synopsis:   checks if given object is an 16/32 object
//
//  Arguments:  [vpvObj16] -- Object to check
//
//  Returns:    32-bit interface being proxied or NULL
//
//  History:    Mar 14,97   Gopalk      Rewritten to support aggregation and
//                                      proper thunking of IN/OUT interfaces
//----------------------------------------------------------------------------
IUnknown *CThkMgr::IsProxy1632(VPVOID vpvThis16)
{
    // Local variables
    THUNK1632OBJ UNALIGNED *ptoThis16;
    IUnknown *punkThis32 = NULL;
    THUNKINFO ti;

    // Check if the pointer points to valid VDM memory of
    // 1632 proxy type
    ptoThis16 = (THUNK1632OBJ UNALIGNED *) GetReadPtr16(&ti, vpvThis16, sizeof(THUNK1632OBJ));
    if(ptoThis16) {
        // Check its vtable
        if(ptoThis16->pfnVtbl == gdata16Data.atfnProxy1632Vtbl) {
            // Check whether it is alive
            if(ptoThis16->pphHolder) {
                // Assert that the proxy is indeed alive
                thkAssert(ptoThis16->dwSignature == PSIG1632);

#if DBG==1
                // In debug builds, ensure that proxy is under its holder
                // and that there is atleast one active proxy under the holder
                BOOL fFound = FALSE, fActive = FALSE;
                CProxy *pProxy;
                PROXYPTR PrxCur, PrxPrev;

	        PrxCur = ptoThis16->pphHolder->pprxProxies;
                while(!(fFound && fActive) && !PprxIsNull(PrxCur)) {
	            // Remember the current proxy and resolve its reference
                    PrxPrev = PrxCur;
                    pProxy = ResolvePprx(&PrxCur);

                    // Assert that the holders match
                    thkAssert(ptoThis16->pphHolder == pProxy->pphHolder);

                    if(PrxCur.wType == PPRX_16) {
                        // Assert that the current 1632 proxy is alive
                        thkAssert(pProxy->dwSignature == PSIG1632);

                        // Check if the given and current proxies are same
                        if(PrxCur.dwPtrVal == vpvThis16)
                            fFound = TRUE;
                    }
                    else {
                        // Assert that the current proxy is 3216 proxy
                        thkAssert(PrxCur.wType == PPRX_32);

                        // Assert that the current proxy is alive
                        thkAssert(pProxy->dwSignature == PSIG3216);
                    }

                    // Check if the current proxy is active
                    if(pProxy->cRefLocal)
                        fActive = TRUE;

                    // Obtain the next proxy under this identity
                    PrxCur = pProxy->pprxObject;
                    ReleasePprx(&PrxPrev);
                }

                thkAssert(fFound && fActive);
#endif
                // Initialize the return value
                punkThis32 = ptoThis16->punkThis32;
            }
        }

        // Release the VDM pointer
        RELVDMPTR(vpvThis16);
    }

    return punkThis32;
}

//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::FindProxy1632
//
//  Synopsis:   Finds/Generates a 16/32 proxy for a given 32-bit interface.
//              If the given 32-bit interface itself is a proxy, returns
//              the actual 16-bit Interface
//
//  Arguments:  [vpvPrealloc] -- Preallocated 16/32 proxy
//              [punkThis32]  -- 32-bit Interface to be proxied
//              [iidx]        -- Interface index or IID
//              [pfst]        -- Return value to hold the kind proxy object
//
//  Returns:    16/32 proxy object or the actual 16-bit Interface
//
//  History:    Mar 14,97   Gopalk      Rewritten to support aggregation and
//                                      proper thunking of IN/OUT interfaces
//----------------------------------------------------------------------------
VPVOID CThkMgr::FindProxy1632(VPVOID vpvPrealloc, IUnknown *punkThis32,
                              PROXYHOLDER *pgHolder, IIDIDX iidx, DWORD *pfst)
{
    thkDebugOut((DEB_THUNKMGR, "%sIn  FindProxy1632(%p, %p, %s)\n",
                 NestingLevelString(), vpvPrealloc, punkThis32, IidIdxString(iidx)));
    DebugIncrementNestingLevel();

    // Local variables
    THUNK1632OBJ UNALIGNED *pto;
    VPVOID vpv, vpvUnk = NULL;
    DWORD fst, Fail = FALSE;

    // Validation checks
    thkAssert(punkThis32 != NULL);
#if DBG == 1
    // Ensure that the preallocated proxy is not in use
    if (vpvPrealloc) {
        pto = FIXVDMPTR(vpvPrealloc, THUNK1632OBJ);
        if(pto->grfFlags & PROXYFLAG_TEMPORARY)
            thkAssert(pto->cRefLocal == 0 && pto->cRef == 0);
        RELVDMPTR(vpvPrealloc);
    }
#endif

    // Initialize return value
    fst = FST_ERROR;

    // If proxy was preallocated for this IID using CanGetNewProxy, it would
    // have added it to the requested IID list.
    if (vpvPrealloc != 0 && IIDIDX_IS_IID(iidx))
        RemoveIIDRequest(*IIDIDX_IID(iidx));

    if(vpv = LookupProxy1632(punkThis32)) {
        // Found an existing proxy
        thkDebugOut((DEB_THUNKMGR, "%sFindProxy1632 found existing proxy,(%p)->%p\n",
                     NestingLevelString(), punkThis32, vpv));

        // Fix the VDM pointer
        pto = FIXVDMPTR(vpv, THUNK1632OBJ);

        // Assert that holders match
        thkAssert(pto->pphHolder);
        if(pgHolder && pto->pphHolder!=pgHolder) {
            thkAssert(pto->pphHolder->dwFlags & PH_AGGREGATEE);
        }

        // Check the proxy IID against the given IID. If the server has passed
        // the same 32-bit interface pointer against another IID, it is possible
        // for the IID's to be different. If the Interface2 derives from Interface1,
        // the interface pointers for them would be the same in C or C++. An
        // excellant example would be IPersistStorage deriving from IPersist.

        // IIDIDXs are related to interfaces in thunk tables, which are organized
        // such that more derived interfaces have higher indices than the less
        // derived ones. Custom interfaces have an IID rather than an index, and
        // consequently are not affected by the following statement.
        if(IIDIDX_IS_INDEX(iidx)) {
            // Check if the new IID is more derived than the existing one
            if(IIDIDX_INDEX(iidx) > IIDIDX_INDEX(pto->iidx)) {
                // As all 16-bit proxy vtables are the same, there is no need
                // to change  the vtable pointer.
                pto->iidx = iidx;
            }
        }

        // Release the VDM pointer
        RELVDMPTR(vpv);

        // AddRef the proxy
        AddRefProxy1632(vpv);

        // Set the type of proxy being returned
        fst = FST_USED_EXISTING;
    }
    else if(vpv = IsProxy3216(punkThis32)) {
        // The given 32-bit interface itself is a proxy to a 16-bit
        // interface
        thkDebugOut((DEB_THUNKMGR, "%sFindProxy1632 shortcut proxy,(%p)->%p\n",
                     NestingLevelString(), punkThis32, vpv));
        THUNK3216OBJ *pProxy3216;

        // Assert that the holders match
        pProxy3216 = (THUNK3216OBJ *) punkThis32;
        thkAssert(pProxy3216->pphHolder);
        if(pgHolder && pProxy3216->pphHolder!=pgHolder) {
            thkAssert(pProxy3216->pphHolder->dwFlags & PH_AGGREGATEE);
        }

        // Avoid creating a proxy to another proxy
        THKSTATE thkstate;

        // Remember the current thunk state
        thkstate = GetThkState();

        // Set the thunk state to THKSTATE_NOCALL
        SetThkState(THKSTATE_NOCALL);

        // AddRef actual the 16-bit interface
        AddRefOnObj16(vpv);

        // Restore previous thunk state
        SetThkState(thkstate);

        // Set the type of proxy being returned
        fst = FST_SHORTCUT;
    }
    else {
        // An existing proxy has not been found and the interface to proxied
        // is a real 32-bit interface.

        // Check if holder has not been given
        if(!pgHolder) {
            // This interface is being obtained through a method call
            PROXYPTR unkPPtr;
            SCODE error;

            // Obtain the identity of 32-bit object
            error = Object32Identity(punkThis32, &unkPPtr, &fst);
            if(error == NOERROR) {
                // Check for aggregation case
                if(unkPPtr.wType == PPRX_16) {
                    // Check if vpvThis32 itself is an IUnknown interface
                    if(iidx == THI_IUnknown) {
                        // Initialize the return value
                        vpv = unkPPtr.dwPtrVal;

                        // Check if the identity has been switched
                        if(fst == FST_USED_EXISTING) {
                            // The IUnknown identity has already been established
                            // The app was trying to pass someother 32-bit interface
                            // as IUnknown. Switch to correct identity
                            thkAssert(!"Switched to correct Identity");

                            // AddRef the proxy being returned
                            AddRefProxy1632(vpv);
                        }
                        else {
                            thkAssert(fst==FST_CREATED_NEW);
                        }
                    }
                    else {
                        THUNK1632OBJ UNALIGNED *Id1632;

                        // Fix the VDM pointer
                        Id1632 = FIXVDMPTR(unkPPtr.dwPtrVal, THUNK1632OBJ);

                        // Check if the identity has just been established
                        if(fst == FST_CREATED_NEW) {
                            // Check if the Identity and current IID share the same
                            // 32-bit interface pointer
                            if(Id1632->punkThis32 == punkThis32) {
                                // Check if the new IID is more derived than
                                // the existing one
                                if(IIDIDX_IS_INDEX(iidx) && iidx>Id1632->iidx) {
                                    // As all 16-bit proxy vtables are the same,
                                    // there is no need to change the vtable pointer
                                    Id1632->iidx = iidx;
                                }

                                // Initialize the return value
                                vpv = unkPPtr.dwPtrVal;
                            }
                            else {
                                // We need to release the IUnknown proxy after adding
                                // the proxy representing vpvThis16 to the its holder
                                vpvUnk = unkPPtr.dwPtrVal;
                            }
                        }
                        else {
                            thkAssert(fst == FST_USED_EXISTING);
                        }

                        // Obtain the holder of the identity
                        pgHolder = Id1632->pphHolder;

                        // Release the VDM pointer
                        RELVDMPTR(unkPPtr.dwPtrVal);
                    }
                }
                else {
                    // Obtain the holder of the identity
                    pgHolder = ((THUNK3216OBJ *)(unkPPtr.dwPtrVal))->pphHolder;

                    // Sanity checks
                    thkAssert(fst == FST_USED_EXISTING);
                    thkAssert(pgHolder->dwFlags & PH_AGGREGATEE);

                    // Check if vpvThis32 itself is an IUnknown interface
                    if(iidx == THI_IUnknown) {
                        // The IUnknown identity has already been established
                        // The app was trying to pass someother 32-bit interface
                        // as IUnknown. Switch to correct identity
                        thkAssert(!"Switched to correct Identity");

                        // Initialize the return value
                        vpv = ((THUNK3216OBJ *)(unkPPtr.dwPtrVal))->vpvThis16;

                        // AddRef the actual 16-bit interface being returned
                        AddRefOnObj16(vpv);
                    }
                }
            }
            else {
                // Failed to obtain the identity
                Fail = TRUE;
            }
        }
    }

    if(!vpv && !Fail) {
        // Assert that we have holder
        thkAssert(pgHolder);
        // Reset the fst value
        fst = FST_ERROR;

        // Obtain either a preallocated or a new proxy
        if(vpvPrealloc) {
            // Use the preallocated proxy
            vpv = vpvPrealloc;
            vpvPrealloc = NULL;
        }
        else {
            // Create a new proxy
            vpv = flFreeList16.AllocElement();
	}

        // Ensure that we have a proxy
        if(vpv) {
            // Put the new proxy in the proxy list
            if(_pProxyTbl1632->SetAt((DWORD)punkThis32, (void *)vpv)) {
                // Convert a custom IID to THI_IUnknown as we thunk only its IUnknown
                // methods
                if(IIDIDX_IS_IID(iidx))
                    iidx = INDEX_IIDIDX(THI_IUnknown);

                // AddRef the 32-bit interface
                punkThis32->AddRef();

                // Update proxy fields
                pto = FIXVDMPTR(vpv, THUNK1632OBJ);
                thkAssert(pto != NULL);
                pto->pfnVtbl = gdata16Data.atfnProxy1632Vtbl;
                pto->cRefLocal = 1;
                pto->cRef = 1;
                pto->iidx = iidx;
                pto->punkThis32 = punkThis32;
                pto->grfFlags = PROXYFLAG_PIFACE;
                PprxNull(pto->pprxObject);
                pto->pphHolder = NULL;
                AddProxyToHolder(pgHolder, pto, Pprx16(vpv));
#if DBG == 1
                pto->dwSignature = PSIG1632;
#endif
                thkDebugOut((DEB_THUNKMGR,
                             "%sFindProxy1632 added new proxy, %s (%p)->%p (%d,%d)\n",
                             NestingLevelString(), inInterfaceNames[pto->iidx].pszInterface,
                             punkThis32, vpv, pto->cRefLocal, pto->cRef));
                RELVDMPTR(vpv);

                // Set the type of proxy being returned
                fst = FST_CREATED_NEW;
            }
            else {
                // Cleanup the proxy only if was newly created
                if(fst == FST_CREATED_NEW)
                    flFreeList16.FreeElement(vpv);
                vpv = NULL;
                fst = 0;
            }
        }
    }
    else {
        if(Fail) {
            thkAssert(vpv == 0 && fst == FST_ERROR);
        }
    }

    // Cleanup the allocated proxy if it has not been used
    if(vpvPrealloc)
        flFreeList16.FreeElement(vpvPrealloc);

    // Release the IUnknown proxy. If it was newly created for establishing
    // the identity of the given 16-bit interface , the following release
    // would be the last release on the IUnknown proxy and consequently,
    // would destroy it along with its holder
    if(vpvUnk)
        ReleaseProxy1632(vpvUnk);

    // Set the return value
    if(pfst)
        *pfst = fst;

    DebugDecrementNestingLevel();
    thkDebugOut((DEB_THUNKMGR, "%sOut FindProxy1632: (%p)->%p\n",
                 NestingLevelString(), punkThis32, vpv));

    return vpv;
}

//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::QueryInterfaceProxy1632
//
//  Synopsis:   QueryInterface on the  given proxy
//
//  Arguments:  [ptoThis] -- Proxy to a 32-bit interface
//              [refiid]  -- Interface IID
//              [ppv]     -- Place where the new interface is returned
//
//  Returns:    SCODE
//
//  History:    Mar 14,97   Gopalk      Rewritten to support aggregation and
//                                      proper thunking of IN/OUT interfaces
//----------------------------------------------------------------------------
SCODE CThkMgr::QueryInterfaceProxy1632(VPVOID vpvThis16, REFIID refiid,
                                       LPVOID *ppv)
{
    thkDebugOut((DEB_THUNKMGR, "%sIn QueryInterfaceProxy1632(%p)\n",
                 NestingLevelString(), vpvThis16));
    DebugIncrementNestingLevel();

    // Local variables
    SCODE scRet;
    THUNK1632OBJ UNALIGNED *ptoThis;
    IUnknown *punkThis, *punkNew;
    PROXYHOLDER *pph;
    VPVOID vpv;
    DWORD fst, dwFlags;

    // Validation checks
    DebugValidateProxy1632(vpvThis16);

    // Initialize
    *ppv = NULL;

    // Perform app compatiblity hacks
    // Ikitaro queries for IViewObject and uses it as IViewObject2
    REFIID newiid = ((TlsThkGetAppCompatFlags() & OACF_IVIEWOBJECT2) &&
                     IsEqualIID(refiid, IID_IViewObject)) ?
                     IID_IViewObject2 : refiid;

    // Convert interface IID to an IIDIDX
    IIDIDX iidx = IidToIidIdx(newiid);

    // Check if a custom interface has been requested
    if(IIDIDX_IS_IID(iidx)) {
        thkDebugOut((DEB_THUNKMGR, "%sQueryInterfaceProxy1632: unknown iid %s\n",
                     NestingLevelString(), IidIdxString(iidx)));

        // Add the request for the unknown interface
        if(!AddIIDRequest(newiid))
            return E_OUTOFMEMORY;
    }

    // Obtain the 32-bit interface
    ptoThis = FIXVDMPTR(vpvThis16, THUNK1632OBJ);
    dwFlags = ptoThis->grfFlags;
    pph = ptoThis->pphHolder;
    if(dwFlags & PROXYFLAG_TEMPORARY) {
        // QI on a temporary proxy
        punkThis = *(IUnknown **) ptoThis->punkThis32;
        thkAssert(!pph);
    }
    else {
        // QI on a normal proxy
        punkThis = ptoThis->punkThis32;
        Win4Assert(pph);
    }
    thkAssert(punkThis);
    RELVDMPTR(vpvThis16);

    // Ensure that the aggregatee identity gets correctly established
    if(dwFlags & PROXYFLAG_PUNKOUTER && iidx == THI_IUnknown) {
        // QI by the aggregatee for identity
        thkAssert(pph->unkProxy.dwPtrVal == vpvThis16);

        // AddRef and return outer proxy
        AddRefProxy1632(vpvThis16);
        *ppv = (void *) vpvThis16;
    }
    else {
        // Execute the QI on the 32-bit interface
        scRet = punkThis->QueryInterface(newiid, (void **) &punkNew);
        if(SUCCEEDED(scRet)) {
            if(punkNew) {

                // Check if this is a QI on an interface on the aggregatee
                if(pph && (pph->dwFlags & PH_AGGREGATEE)) {
                    if(dwFlags & PROXYFLAG_PIFACE) {
                        // QI on an interface on the aggregatee which
                        // delegates to the aggregator

                        // Note the above QI call can be short circuited as
                        // an optimization. It will be carried out in future
                        // after ensuring that apps do not break due to such
                        // short circuiting
                        thkAssert(pph->unkProxy.wType == PPRX_32);
                    }
                    else if(dwFlags & PROXYFLAG_PUNKOUTER) {
                        // QI by the aggregatee on aggregator
                        thkAssert(pph->unkProxy.dwPtrVal == vpvThis16);
                    }
                    else {
                        // QI by the aggregator on the aggregatee
                        thkAssert(dwFlags & PROXYFLAG_PUNKINNER);
                        thkAssert(pph->unkProxy.wType == PPRX_32);
                    }

                    // As aggregation is involved, we cannot be certain of
                    // identity of the returned interface
                    pph = NULL;
                }

                // Set the thunk status
                SetThkState(THKSTATE_INVOKETHKOUT32);

                vpv = FindProxy1632(NULL, punkNew, pph, iidx, &fst);

                if(vpv) {
                    // Set the return value
                    *ppv = (void *)vpv;
#if DBG==1
                    if(pph) {
                        // Ensure that the given and new proxies either have the same
                        // holder or point to same identity
                        if(fst & FST_PROXY_STATUS) {
                            THUNK1632OBJ UNALIGNED *ptoNew;

                            ptoThis = FIXVDMPTR(vpvThis16, THUNK1632OBJ);
                            ptoNew = FIXVDMPTR(vpv, THUNK1632OBJ);
                            thkAssert(ptoNew->pphHolder == ptoThis->pphHolder);
                            RELVDMPTR(vpvThis16);
                            RELVDMPTR(vpv);
                        }
                        else {
                            THUNK3216OBJ *ptoNew = (THUNK3216OBJ *) punkNew;

                            ptoThis = FIXVDMPTR(vpvThis16, THUNK1632OBJ);
                            thkAssert(fst == FST_SHORTCUT);
                            thkAssert(ptoNew->pphHolder != ptoThis->pphHolder);
                            thkAssert(ptoNew->pphHolder->dwFlags & PH_AGGREGATEE);
                            thkAssert(ptoNew->pphHolder->unkProxy.wType == PPRX_16);
                            RELVDMPTR(vpvThis16);
                        }
                    }
#endif

                    // Check for 32-bit custom interfaces that are not supported
                    if((fst & FST_PROXY_STATUS) && IIDIDX_IS_IID(iidx)) {
                        // Release proxy and fake E_NOINTERFACE
                        ReleaseProxy1632(vpv);
                        scRet = E_NOINTERFACE;
                    }
                }
                else {
                    scRet = E_OUTOFMEMORY;
                }

                // As the new interface is an OUT parameter, release the actual
                // 32-bit interface. This would counter the AddRef made by
                // a successfule FindProxy3216, else it would clean up the
                // reference count
                punkNew->Release();

                // Resert thunk status
                SetThkState(THKSTATE_NOCALL);
            }
            else {
                // Corel draw returns NOERROR while setting returned interface to NULL
                // We modify the returned value to suit 32-bit QI semantics.
                scRet = E_NOINTERFACE;
            }
        }
    }

    if(IIDIDX_IS_IID(iidx)) {
        // Clean up custom interface request
        RemoveIIDRequest(refiid);
    }

    DebugDecrementNestingLevel();
    thkDebugOut((DEB_THUNKMGR, "%sOut QueryInterfaceProxy1632(%p) => %p, 0x%08lX\n",
                 NestingLevelString(), ptoThis, *ppv, scRet));

    return scRet;
}

//+---------------------------------------------------------------------------
//
//  Member:     CThkMgr::LockProxy, public
//
//  Synopsis:   Locks a proxy so that it can't be freed
//
//  Arguments:  [pprx] - Proxy
//
//  History:    11-Aug-94       DrewB   Created
//
//----------------------------------------------------------------------------

void CThkMgr::LockProxy(CProxy *pprx)
{
    pprx->grfFlags |= PROXYFLAG_LOCKED;
}

//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::TransferLocalRefs1632
//
//  Synopsis:   Transfer the all local references maintained by the proxy
//              to the actual object
//
//  Arguments:  [vpvProxy] -- 16/32 proxy
//
//  Returns:    refcount
//
//  History:    Mar 12,96   Gopalk         Created
//
//----------------------------------------------------------------------------
DWORD CThkMgr::TransferLocalRefs1632(VPVOID vpvProxy)
{
    // Debug output
    thkDebugOut((DEB_THUNKMGR, "%sIn TransferLocalRefs1632(%p)\n",
                 NestingLevelString(), vpvProxy));
    DebugIncrementNestingLevel();

    // Validation check
    DebugValidateProxy1632(vpvProxy);

    // Local variables
    THUNK1632OBJ UNALIGNED *pProxy1632;
    IUnknown *pUnk32;
    DWORD cRef;

    // Fix memory pointed to by 16:16 pointer
    pProxy1632 = FIXVDMPTR(vpvProxy, THUNK1632OBJ);
    pUnk32 = pProxy1632->punkThis32;

    // Transfer all local references maintained by the proxy
    while(pProxy1632->cRefLocal > pProxy1632->cRef) {
        // Increment actual ref count before AddRef on the actual object
        ++pProxy1632->cRef;

        // The following AddRef could cause callbacks to 16-bit world
        // and hence unfix the memory pointed to by 16:16 pointer
        RELVDMPTR(vpvProxy);

        // AddRef the actual object
        pUnk32->AddRef();

        // Refix memory pointed to by 16:16 pointer
        pProxy1632 = FIXVDMPTR(vpvProxy, THUNK1632OBJ);
    }

    // Debug output
    DebugDecrementNestingLevel();
    thkDebugOut((DEB_THUNKMGR, "%sOut TransferLocalRefs1632(%p)(%ld,%ld)\n",
                 NestingLevelString(), vpvProxy, pProxy1632->cRefLocal,
                 pProxy1632->cRef));

    // Cleanup
    cRef = pProxy1632->cRefLocal;
    RELVDMPTR(vpvProxy);

    // Debug validation
    DebugValidateProxy1632(vpvProxy);
    return cRef;
}

//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::TransferLocalRefs3216
//
//  Synopsis:   Transfer the all local references maintained by the proxy
//              to the actual object
//
//  Arguments:  [vpvProxy1632] -- 16/32 proxy
//
//  Returns:    refcount
//
//  History:    Mar 12,96   Gopalk         Created
//
//----------------------------------------------------------------------------
DWORD CThkMgr::TransferLocalRefs3216(VPVOID vpvProxy)
{
    // Debug output
    thkDebugOut((DEB_THUNKMGR, "%sIn TransferLocalRefs3216(%p)\n",
                 NestingLevelString(), vpvProxy));
    DebugIncrementNestingLevel();

    // Local variables
    THUNK3216OBJ *pProxy3216 = (THUNK3216OBJ *) vpvProxy;
    DWORD cRef;

    // Validation check
    DebugValidateProxy3216(pProxy3216);

    // Transfer all local references maintained by the proxy
    while(pProxy3216->cRefLocal > pProxy3216->cRef) {
        // Increment actual ref count before AddRef on the actual object
        ++pProxy3216->cRef;

        // AddRef the actual object
        AddRefOnObj16(pProxy3216->vpvThis16);
    }

    // Validation check
    DebugValidateProxy3216(pProxy3216);

    // Initialize return value
    cRef = pProxy3216->cRefLocal;

    // Debug output
    DebugDecrementNestingLevel();
    thkDebugOut((DEB_THUNKMGR, "%sOut TransferLocalRefs3216(%p)(%ld,%ld)\n",
                 NestingLevelString(), vpvProxy, pProxy3216->cRefLocal,
                 pProxy3216->cRef));
    return cRef;
}

//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::AddRefProxy1632
//
//  Synopsis:   addrefs proxy object - delegate call on to real object
//
//  Arguments:  [vpvThis16] -- 16/32 proxy
//
//  Returns:    local refcount
//
//  History:    Mar 14,97   Gopalk      Rewritten to support aggregation and
//                                      proper thunking of IN/OUT interfaces
//
//  Notes: cRef is the addref passed on to the real object
//         cRefLocal is the addref collected locally
//----------------------------------------------------------------------------
DWORD CThkMgr::AddRefProxy1632(VPVOID vpvThis16)
{
    thkDebugOut((DEB_THUNKMGR, "%sIn AddRefProxy1632(%p)\n",
                 NestingLevelString(), vpvThis16));
    DebugIncrementNestingLevel();

    // Local variable
    THUNK1632OBJ UNALIGNED *ptoThis;
    DWORD cRef;

    // Validation checks
    DebugValidateProxy1632(vpvThis16);

    // Fix the VDM pointer
    ptoThis = FIXVDMPTR(vpvThis16, THUNK1632OBJ);
    // Assert that proxy has a holder
    thkAssert(ptoThis->pphHolder);

    // Increment local refcount
    thkAssert(ptoThis->cRefLocal >= 0);
    ptoThis->cRefLocal++;

    // Check for the need to AddRef the holder
    if(ptoThis->cRefLocal == 1) {
        // Assert that an aggregatee is not being revived
        thkAssert(!(ptoThis->grfFlags & PROXYFLAG_PUNKINNER));

        // AddRef the holder
        AddRefHolder(ptoThis->pphHolder);

        // Mark the proxy as revived
        ptoThis->grfFlags |= PROXYFLAG_REVIVED;
    }

    // Check for the need to forward AddRef to the actual 32-bit interface
    if(ptoThis->cRefLocal==1 || (ptoThis->pphHolder->dwFlags & PH_AGGREGATEE)) {
        IUnknown *punk;
#if DBG==1
        DWORD refsBefore, refsAfter;
        PROXYHOLDER *pph;
        THUNK3216OBJ *punkOuter;

        // Check if the object is an aggregatee
        pph = ptoThis->pphHolder;
        if((pph->dwFlags & PH_AGGREGATEE) && (ptoThis->grfFlags & PROXYFLAG_PIFACE)) {
            // Assert that identity is in the 16-bit world
            thkAssert(pph->unkProxy.wType == PPRX_32);

            // Obtain the references on the outer proxy
            punkOuter = (THUNK3216OBJ *) pph->unkProxy.dwPtrVal;
            thkAssert(punkOuter->cRef == punkOuter->cRefLocal);
            refsBefore = punkOuter->cRefLocal;
        }
#endif

        // Increment before calling the actual 32-bit interface
        ptoThis->cRef++;

        // Release VDM pointer before calling app code
        punk = ptoThis->punkThis32;
        RELVDMPTR(vpvThis16);

        // AddRef the actual 32-bit interface
        punk->AddRef();

        // Refix the VDM pointer
        ptoThis = FIXVDMPTR(vpvThis16, THUNK1632OBJ);

#if DBG==1
        // Check if the object is an aggregatee
        if((pph->dwFlags & PH_AGGREGATEE) && (ptoThis->grfFlags & PROXYFLAG_PIFACE)) {
            // Ensure that the above AddRef translated to a AddRef on the
            // outer proxy
            punkOuter = (THUNK3216OBJ *) pph->unkProxy.dwPtrVal;
            thkAssert(punkOuter->cRef == punkOuter->cRefLocal);
            refsAfter = punkOuter->cRefLocal;
            thkAssert(refsBefore == refsAfter-1);
        }
#endif
    }

    DebugDecrementNestingLevel();
    thkDebugOut((DEB_THUNKMGR, "%sOut AddRefProxy1632(%p), (%ld,%ld)\n",
                 NestingLevelString(), vpvThis16,
                 ptoThis->cRefLocal, ptoThis->cRef));

    cRef = ptoThis->cRefLocal;
    RELVDMPTR(vpvThis16);
    DebugValidateProxy1632(vpvThis16);

    return cRef;
}

//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::ReleaseProxy1632
//
//  Synopsis:   release on 16/32 proxy - delegate call on to real object
//
//  Arguments:  [vpvThis16] -- proxy
//
//  Returns:    local refcount
//
//  History:    Mar 14,97   Gopalk      Rewritten to support aggregation and
//                                      proper thunking of IN/OUT interfaces
//----------------------------------------------------------------------------
DWORD CThkMgr::ReleaseProxy1632(VPVOID vpvThis16)
{

    thkDebugOut((DEB_THUNKMGR, "%sIn ReleaseProxy1632(%p)\n",
                 NestingLevelString(), vpvThis16));
    DebugIncrementNestingLevel();

    // Local variables
    THUNK1632OBJ UNALIGNED *ptoThis;
    DWORD dwLocalRefs, dwRefs, dwRet;
    PROXYHOLDER *pph;
    DWORD ProxyType;

    // Validation checks
    DebugValidateProxy1632(vpvThis16);

    // Fix the VDM pointer
    ptoThis = FIXVDMPTR(vpvThis16, THUNK1632OBJ);
    // Assert that proxy has a holder
    thkAssert(ptoThis->pphHolder);

    // Check for the need to forward the release to the actual
    // 32-bit interface
    if(ptoThis->cRef == ptoThis->cRefLocal) {
        IUnknown *punk;
#if DBG==1
        DWORD refsBefore, refsAfter;
        THUNK3216OBJ *punkOuter;

        // Check if the object is an aggregatee
        pph = ptoThis->pphHolder;
        if((pph->dwFlags & PH_AGGREGATEE) && (ptoThis->grfFlags & PROXYFLAG_PIFACE)) {
            // Assert that identity is in the 16-bit world
            thkAssert(pph->unkProxy.wType == PPRX_32);

            // Obtain the references on the outer proxy
            punkOuter = (THUNK3216OBJ *) pph->unkProxy.dwPtrVal;
            thkAssert(punkOuter->cRef == punkOuter->cRefLocal);
            refsBefore = punkOuter->cRefLocal;
        }
#endif

        // Assert that proxy holds references on the 32-bit interface
        thkAssert(ptoThis->cRef);

        // Release the VDM pointer before calling app code
        punk = ptoThis->punkThis32;
        RELVDMPTR(vpvThis16);

        // Release the actual 32-bit interface
        dwRet = punk->Release();

#if DBG==1
        if(dwRet==0 && TlsThkGetThkMgr()->GetThkState()==THKSTATE_VERIFY32INPARAM) {
            thkDebugOut((DEB_WARN, "WARINING: 32-bit 0x%x IN parameter with zero "
                                   "ref count\n", punk));

            if(thkInfoLevel & DEB_FAILURES)
                thkAssert(!"Wish to Debug");
        }
#endif

        // Refix the VDM pointer
	ptoThis = FIXVDMPTR(vpvThis16, THUNK1632OBJ);

        // Decrement after calling the actual 32-bit interface
        --ptoThis->cRef;

#if DBG==1
        // Check if the object is an aggregatee
        if((pph->dwFlags & PH_AGGREGATEE) && (ptoThis->grfFlags & PROXYFLAG_PIFACE)) {
            // Ensure that the above release translated to a release on the
            // outer proxy
            punkOuter = (THUNK3216OBJ *) pph->unkProxy.dwPtrVal;
            thkAssert(punkOuter->cRef == punkOuter->cRefLocal);
            refsAfter = punkOuter->cRefLocal;
            thkAssert(refsBefore == refsAfter+1);
        }
#endif
    }

    // Decrement the local refcount
    dwLocalRefs = --ptoThis->cRefLocal;
    thkAssert(ptoThis->cRefLocal>=0);
    dwRefs = ptoThis->cRef;
    pph = ptoThis->pphHolder;
    ProxyType = ptoThis->grfFlags & PROXYFLAG_TYPE;

    // Release the VDM pointer
    RELVDMPTR(vpvThis16);

    // Check if the proxy needs to be cleaned up
    if(dwLocalRefs == 0) {
        // Debug dump
        thkAssert(dwRefs == 0);
        DBG_DUMP(DebugDump1632());

        // Release the holder. If this is the last release on
        // the holder, the proxy would be destroyed. Hence,
        // we should not use any member variables hereafter.
        ReleaseHolder(pph, ProxyType);
    }

    DebugDecrementNestingLevel();
    thkDebugOut((DEB_THUNKMGR, "%sOut ReleaseProxy1632(%p) => %ld,%ld\n",
                 NestingLevelString(), vpvThis16, dwLocalRefs, dwRefs));

    return dwLocalRefs;
}

//+---------------------------------------------------------------------------
//
//  Member:     CThkMgr::RemoveProxy1632, public
//
//  Synopsis:   Destroys the given proxy
//
//  Arguments:  [vpv] - 16-bit proxy pointer
//              [pto] - Flat proxy pointer
//
//  History:    Mar 14,97   Gopalk      Rewritten to support aggregation and
//                                      proper thunking of IN/OUT interfaces
//
//  Notes:      Also unfixes VDM pointer passed
//
//----------------------------------------------------------------------------
void CThkMgr::RemoveProxy1632(VPVOID vpv, THUNK1632OBJ *pto)
{
    // Revoke the assosiation between the proxy and
    // the 32-bit interface
    if(!(pto->grfFlags & PROXYFLAG_PUNKOUTER)) {
#if DBG==1
        thkAssert(_pProxyTbl1632->RemoveKey((DWORD) pto->punkThis32));
#else
        _pProxyTbl1632->RemoveKey((DWORD) pto->punkThis32);
#endif
    }

    // Release the holder if needed
    if(pto->cRefLocal)
        ReleaseHolder(pto->pphHolder, PROXYFLAG_NONE);

    // Check if the proxy is locked
    if(!(pto->grfFlags & PROXYFLAG_LOCKED)) {
        // In debug builds, mark the proxy dead
#if DBG == 1
        pto->dwSignature = PSIG1632DEAD;

        // Return the proxy to free list
        if (!fSaveProxy)
#endif
        {
            thkAssert(pto->pphHolder);
            pto->pphHolder = NULL;
            flFreeList16.FreeElement((DWORD)vpv);
        }
    }

    // Release the VDM pointer
    RELVDMPTR(vpv);

    return;
}

//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::CanGetNewProxy3216
//
//  Synopsis:   checks if new proxy is available
//
//  Arguments:  [iidx] - Custom interface or known index
//
//  Returns:    Preallocated proxy or NULL
//
//  History:    6-01-94   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
THUNK3216OBJ *CThkMgr::CanGetNewProxy3216(IIDIDX iidx)
{
    thkDebugOut((DEB_THUNKMGR, "%sIn CanGetNewProxy3216(%s)\n",
                 NestingLevelString(), IidIdxString(iidx)));

    LPVOID pvoid;

    pvoid = (LPVOID)flFreeList32.AllocElement();
    if ( pvoid == NULL)
    {
        thkDebugOut((DEB_WARN, "WARNING: CThkMgr::CanGetNewProxy3216, "
                     "AllocElement failed\n"));
        return NULL;
    }

    // check if the proxy is requested for a no-thop-interface
    if (pvoid && IIDIDX_IS_IID(iidx))
    {
        // add the request for the unknown interface
        if ( !AddIIDRequest(*IIDIDX_IID(iidx)) )
        {
            flFreeList32.FreeElement( (DWORD)pvoid );
            pvoid = NULL;
        }
    }

    thkDebugOut((DEB_THUNKMGR, "%sOut CanGetNewProxy3216: %p \n",
                 NestingLevelString(), pvoid));

    return (THUNK3216OBJ *)pvoid;
}

//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::FreeNewProxy3216
//
//  Synopsis:   frees previous reserved proxy
//
//  Arguments:  [pto] - Proxy
//              [iidx] - Custom interface or known index
//
//  History:    6-01-94   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
void CThkMgr::FreeNewProxy3216(THUNK3216OBJ *pto, IIDIDX iidx)
{
    thkDebugOut((DEB_THUNKMGR, "%sIn FreeNewProxy3216(%p, %s)\n",
                 NestingLevelString(), pto, IidIdxString(iidx)));

    thkAssert(pto != NULL);

    if (IIDIDX_IS_IID(iidx))
    {
        // add the request for the unknown interface
        RemoveIIDRequest(*IIDIDX_IID(iidx));
    }

    thkAssert(pto != NULL);
    flFreeList32.FreeElement( (DWORD)pto );

    thkDebugOut((DEB_THUNKMGR, "%sOut FreeNewProxy3216\n",
                 NestingLevelString()));
}

//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::IsProxy3216
//
//  Synopsis:   checks if the given object is a 32/16 proxy
//
//  Arguments:  [punk] -- punk of 32 bit object
//
//  Returns:    16-bit interface being proxied or NULL
//
//  History:    Mar 14,97   Gopalk      Rewritten to support aggregation and
//                                      proper thunking of IN/OUT interfaces
//----------------------------------------------------------------------------
VPVOID CThkMgr::IsProxy3216(IUnknown *punkThis32)
{
    // Local variables
    THUNK3216OBJ *ptoThis32;
    VPVOID vpvThis16 = NULL;

    // Check if the pointer points to valid memory of 3216 proxy type
    if(!IsBadWritePtr(punkThis32, sizeof(THUNK3216OBJ))) {
        ptoThis32 = (THUNK3216OBJ *) punkThis32;
        // Check its vtable
        if(*((void **)ptoThis32->pfnVtbl) == ::QueryInterfaceProxy3216 &&
           *((void **)ptoThis32->pfnVtbl + 1) == ::AddRefProxy3216 &&
           *((void **)ptoThis32->pfnVtbl + 2) == ::ReleaseProxy3216) {
            // Check whether it is alive
            if(ptoThis32->pphHolder) {
                // Assert that the given proxy is indeed alive
                thkAssert(ptoThis32->dwSignature == PSIG3216);

#if DBG==1
                // In debug builds, ensure that proxy is under its holder
                // and that there is atleast one active proxy under the holder
                BOOL fFound = FALSE, fActive = FALSE;
                CProxy *pProxy;
                PROXYPTR PrxCur, PrxPrev;

	        PrxCur = ptoThis32->pphHolder->pprxProxies;
                while(!(fFound && fActive) && !PprxIsNull(PrxCur)) {
	            // Remember the proxy and resolve its reference
                    PrxPrev = PrxCur;
                    pProxy = ResolvePprx(&PrxCur);

                    // Assert that the holders match
                    thkAssert(ptoThis32->pphHolder == pProxy->pphHolder);

                    if(PrxCur.wType == PPRX_32) {
                        // Assert that the current 3216 proxy is alive
                        thkAssert(pProxy->dwSignature == PSIG3216);

                        // Check if the given and current proxies are same
                        if(PrxCur.dwPtrVal == (DWORD) punkThis32)
                            fFound = TRUE;
                    }
                    else {
                        // Assert that the current proxy is 1632 proxy
                        thkAssert(PrxCur.wType == PPRX_16);

                        // Assert that the current proxy is alive
                        thkAssert(pProxy->dwSignature == PSIG1632);
                    }

                    // Check if the current proxy is active
                    if(pProxy->cRefLocal)
                        fActive = TRUE;

                    // Obtain the next proxy under this identity
                    PrxCur = pProxy->pprxObject;
                    ReleasePprx(&PrxPrev);
                }

                thkAssert(fFound && fActive);
#endif
                // Initialize the return value
                vpvThis16 = ptoThis32->vpvThis16;
            }
        }
    }

    return vpvThis16;
}

//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::CreateOuter32
//
//  Synopsis:   Generates a new 3216 proxy for a given 16-bit outer IUnknown
//              If the given 16-bit IUnknown itself is a proxy, returns
//              the actual 32-bit interface
//
//  Arguments:  [vpvOuter16] -- Outer IUnknown
//              [ppAggHolder] -- Pointer to the proxy holder returned here
//              [pfst]       -- Proxy type is returned here
//
//  Returns:    3216 proxy or the actual 32-bit Interface
//
//  History:    Mar 14,97   Gopalk      Created to support aggregation
//              Feb 11, 98  MPrabhu     Change to pass back pUnkOuter's holder
//
//----------------------------------------------------------------------------
IUnknown *CThkMgr::CreateOuter32(VPVOID vpvOuter16, PROXYHOLDER **ppAggHolder, DWORD *pfst)
{
    thkDebugOut((DEB_THUNKMGR, "%sIn  CreateOuter32(%p)\n",
                 NestingLevelString(), vpvOuter16));
    DebugIncrementNestingLevel();

    // Local variables
    IUnknown *punkOuter32;
    THUNK1632OBJ UNALIGNED *Id1632;
    THUNK3216OBJ *Id3216;
    PROXYHOLDER *pph = NULL;
    DWORD fst = FST_ERROR;
    BOOL fFail = FALSE;

    if(punkOuter32 = IsProxy1632(vpvOuter16)) {
        // The given 16-bit interface itself is a proxy to a 32-bit interface
        Id1632 = FIXVDMPTR(vpvOuter16, THUNK1632OBJ);
        pph = Id1632->pphHolder;
        RELVDMPTR(vpvOuter16);

    /* rm: nested aggregation
        if(pph->dwFlags & PH_AGGREGATEE) {
            // Nested aggregation
            thkAssert(pph->unkProxy.wType == PPRX_16);
            thkAssert(!"Nested aggregation case");

            // If proxies for PUNKOUTER and PUNKINNER are modfied to coordinate
            // transfer of references during QI calls on PUNKINNER, creation of
            // proxy to a proxy can be avoided for nested aggreagtion

            // Ensure that the user passed the true identity
            if(pph->unkProxy.dwPtrVal != vpvOuter16) {
                // Identity needs to be switched
                thkAssert(!"Switching to True Identity for Aggregation");

                // Obtain the true identity
                vpvOuter16 = pph->unkProxy.dwPtrVal;
            }

            // Reset the return value to create a identity proxy
            punkOuter32 = NULL;
        }
        else {
    */
            // Aggregation through delegation
            thkAssert(!"Aggregation through delegation");
            punkOuter32->AddRef();

            // Initialize return value
            fst = FST_SHORTCUT;
    /* rm: nested aggregation
        }
    */
    }
    else if(Id3216 = LookupProxy3216(vpvOuter16)) {
        // Found an existing proxy
        thkDebugOut((DEB_THUNKMGR, "%sCreateOuter32 found existing proxy,(%p)->%p\n",
                     NestingLevelString(), vpvOuter16, Id3216));

        // Validate the proxy
        DebugValidateProxy3216(Id3216);

        // Obtain its holder
        pph = Id3216->pphHolder;

        // Assert that the holder represents a 16-bit identity
        thkAssert(pph->unkProxy.wType == PPRX_32);
        thkAssert(pph->dwFlags & PH_NORMAL);

        // Ensure that the user passed the true identity
        if(pph->unkProxy.dwPtrVal != (DWORD) Id3216) {
            // Identity needs to be switched
            thkAssert(!"Switching to True Identity for Aggregation");

            // Obtain the true identity
            vpvOuter16 = Id3216->vpvThis16;
        }
    }
    else {
        // No interface on the identity has crossed thunking layer
        // Ensure that the user passed the true identity
        SCODE scRet;
        VPVOID vpvUnk;

        scRet = QueryInterfaceOnObj16(vpvOuter16, IID_IUnknown, (void **)&vpvUnk);
        if(SUCCEEDED(scRet) && vpvUnk) {
            // Fix up the reference count
            ReleaseOnObj16(vpvOuter16);

            // Switch the identity if needed
            if(vpvOuter16 != vpvUnk) {
                // Identity needs to be switched
                thkAssert(!"Switching to True Identity for Aggregation");

                // Obtain the true identity
                vpvOuter16 = vpvUnk;
            }
        }
        else {
            // This is pretty nasty.
            Win4Assert(!"QI for IUnknown on the 16-bit interface failed");
            Win4Assert(!vpvUnk);

            // But I am allowing the behavior as some 16-bit apps like
            // VB4.0 pass interfaces that do not respond to QI for
            // IUnknown
        }
    }

    // Create a new 1632 proxy
    if(!punkOuter32 && vpvOuter16)  {
        Id3216 = (THUNK3216OBJ *) flFreeList32.AllocElement();
        if(Id3216) {
            // AddRef the 16-bit IUnknown
            AddRefOnObj16(vpvOuter16);

            // Update proxy fields
            Id3216->pfnVtbl = (DWORD) athopiInterfaceThopis[THI_IUnknown].pt3216fn;
            Id3216->cRefLocal = 1;
            Id3216->cRef = 1;
            Id3216->iidx = THI_IUnknown;
            Id3216->vpvThis16 = vpvOuter16;
            Id3216->grfFlags = PROXYFLAG_PUNKOUTER;
            PprxNull(Id3216->pprxObject);
            Id3216->pphHolder = NULL;
#if DBG == 1
            Id3216->dwSignature = PSIG3216;
#endif

            // Create a new AGGREGATE holder
            pph = NewHolder((DWORD)Id3216, PROXYPTR((DWORD)Id3216, PPRX_32),
                             PH_AGGREGATEE);
            if(pph) {
                // Initialize the return values
                fst = FST_CREATED_NEW;
                punkOuter32 = (IUnknown *) Id3216;
            }
            else {
                flFreeList32.FreeElement((DWORD) Id3216);
                ReleaseOnObj16(vpvOuter16);
            }
        }
    }

    // Set the return value
    if(pfst)
        *pfst = fst;

    if (pph)
        *ppAggHolder = pph;

    DebugDecrementNestingLevel();
    thkDebugOut((DEB_THUNKMGR, "%sOut CreateOuter32(%p)->%p\n",
                 NestingLevelString(), punkOuter32, vpvOuter16));

    // This may be a proxy or a real 16-bit interface
    return punkOuter32;
}

//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::CreateOuter16
//
//  Synopsis:   Generates a new 1632 proxy for a given 32-bit outer IUnknown
//              If the given 32-bit IUnknown itself is a proxy, returns
//              the actual 16-bit interface
//
//  Arguments:  [punkOuter32] -- Outer IUnknown
//              [ppAggHolder] -- Pointer to the proxy holder returned here
//              [pfst]       -- Proxy type is returned here
//
//  Returns:    1632 proxy or the actual 16-bit Interface
//
//  History:    Mar 14,97   Gopalk      Created to support aggregation
//              Feb 11, 98  MPrabhu     Change to pass back pUnkOuter's holder
//
//----------------------------------------------------------------------------
VPVOID CThkMgr::CreateOuter16(IUnknown *punkOuter32, PROXYHOLDER **ppAggHolder, DWORD *pfst)
{
    thkDebugOut((DEB_THUNKMGR, "%sIn  CreateOuter16(%p)\n",
                 NestingLevelString(), punkOuter32));
    DebugIncrementNestingLevel();

    // Local variables
    VPVOID vpvOuter16;
    THUNK1632OBJ UNALIGNED *Id1632;
    PROXYHOLDER *pph = NULL;
    DWORD fst = FST_ERROR;

    if(vpvOuter16 = IsProxy3216(punkOuter32)) {
        // The given 32-bit interface itself is a proxy to a 16-bit interface
        pph = ((THUNK3216OBJ *) punkOuter32)->pphHolder;

    /* rm: nested aggregation
        if(pph->dwFlags & PH_AGGREGATEE) {
            // Nested aggregation
            thkAssert(pph->unkProxy.wType == PPRX_32);
            thkAssert(!"Nested aggregation case");

            // If proxies for PUNKOUTER and PUNKINNER are modfied to coordinate
            // transfer of references during QI calls on PUNKINNER, creation of
            // proxy to a proxy can be avoided for nested aggreagtion

            // Ensure that the user passed the true identity
            if(pph->unkProxy.dwPtrVal != (DWORD) punkOuter32) {
                // Identity needs to be switched
                thkAssert(!"Switching to True Identity for Aggregation");

                // Obtain the true identity
                punkOuter32 = (IUnknown *) pph->unkProxy.dwPtrVal;
            }

            // Reset the return value to create a identity proxy
            vpvOuter16 = NULL;
        }
        else {
    */
            // Aggregation through delegation
            thkAssert(!"Aggregation through delegation");
            AddRefOnObj16(vpvOuter16);

            // Initialize return value
            fst = FST_SHORTCUT;
    /* rm: nested aggregation
        }
    */
    }
    else if(vpvOuter16 = LookupProxy1632(punkOuter32)) {
        // Found an existing proxy
        thkDebugOut((DEB_THUNKMGR, "%sCreateOuter16 found existing proxy,(%p)->%p\n",
                     NestingLevelString(), punkOuter32, vpvOuter16));

        // Validate the proxy
        DebugValidateProxy1632(vpvOuter16);

        // Obtain its holder
        Id1632 = FIXVDMPTR(vpvOuter16, THUNK1632OBJ);
        pph = Id1632->pphHolder;
        RELVDMPTR(vpvOuter16);

        // Assert that the holder represents a 32-bit identity
        thkAssert(pph->unkProxy.wType == PPRX_16);
        thkAssert(pph->dwFlags & PH_NORMAL);

        // Ensure that the user passed the true identity
        if(pph->unkProxy.dwPtrVal != vpvOuter16) {
            // Identity needs to be switched
            thkAssert(!"Switching to True Identity for Aggregation");

            // Obtain the true identity
            Id1632 = FIXVDMPTR(pph->unkProxy.dwPtrVal, THUNK1632OBJ);
            punkOuter32 = Id1632->punkThis32;
            RELVDMPTR(pph->unkProxy.dwPtrVal);
        }

        // Reset the return value to create a identity proxy
        vpvOuter16 = NULL;
    }
    else {
        // No interface on the identity has crossed thunking layer
        // Ensure that the user passed the true identity
        SCODE scRet;
        IUnknown *pUnk;

        scRet = punkOuter32->QueryInterface(IID_IUnknown, (void **) &pUnk);
        if(SUCCEEDED(scRet) && pUnk) {
            // Fix up the reference count
            punkOuter32->Release();

            // Switch the identity if needed
            if(punkOuter32 != pUnk) {
                // Identity needs to be switched
                thkAssert(!"Switching to True Identity for Aggregation");

                // Obtain the true identity
                punkOuter32 = pUnk;
            }
        }
        else {
            // This is pretty nasty.
            Win4Assert(!"QI for IUnknown on the 32-bit interface failed");
            Win4Assert(!pUnk);
            punkOuter32 = NULL;
        }
    }

    // Create a new 1632 proxy
    if(!vpvOuter16 && punkOuter32) {
        vpvOuter16 = flFreeList16.AllocElement();
        if(vpvOuter16) {
            // AddRef the 32-bit IUnknown
            punkOuter32->AddRef();

            Id1632 = FIXVDMPTR(vpvOuter16, THUNK1632OBJ);
            thkAssert(Id1632);

            // Update proxy fields
            Id1632->pfnVtbl = gdata16Data.atfnProxy1632Vtbl;
            Id1632->cRefLocal = 1;
            Id1632->cRef = 1;
            Id1632->iidx = THI_IUnknown;
            Id1632->punkThis32 = punkOuter32;
            Id1632->grfFlags = PROXYFLAG_PUNKOUTER;
            PprxNull(Id1632->pprxObject);
            Id1632->pphHolder = NULL;
#if DBG == 1
            Id1632->dwSignature = PSIG1632;
#endif
            RELVDMPTR(vpvOuter16);

            // Create a new AGGREGATEE holder
            pph = NewHolder(vpvOuter16, PROXYPTR(vpvOuter16, PPRX_16), PH_AGGREGATEE);
            if(pph) {
                // Initialize return value
                fst = FST_CREATED_NEW;
            }
            else {
                flFreeList16.FreeElement(vpvOuter16);
                punkOuter32->Release();

                // Initialize the return value
                vpvOuter16 = NULL;
            }
        }
    }

    // Set the return value
    if(pfst)
        *pfst = fst;

    if (pph)
        *ppAggHolder = pph;

    DebugDecrementNestingLevel();
    thkDebugOut((DEB_THUNKMGR, "%sOut CreateOuter16(%p)->%p\n",
                 NestingLevelString(), punkOuter32, vpvOuter16));

    // This may be a 1632 proxy or a real 16-bit interface
    return vpvOuter16;
}

//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::Object32Identity
//
//  Synopsis:   Finds/Creates a 32/16 IUnknown proxy on a given 16-bit object
//              to establish its identity.
//
//  Arguments:  [punkThis32] -- 32-bit Object
//              [pProxy]     -- Proxy representing Identity
//              [pfst]       -- Search result is returned here
//
//  Returns:    Proxy representing object identity. In addition, the
//              returned proxy is AddRefed only if it represents a
//              16-bit identity
//
//  History:    Mar 14,97   Gopalk      Created to support aggregation and
//                                      proper thunking of IN/OUT interfaces
//----------------------------------------------------------------------------
SCODE CThkMgr::Object32Identity(IUnknown *punkThis32, PROXYPTR *pProxy, DWORD *pfst)
{
    // Local variables
    DWORD fst = FST_ERROR;
    SCODE scRet;
    VPVOID vpvProxy = NULL;
    IUnknown *pUnk;
    THUNK1632OBJ UNALIGNED *ptoProxy;
    PROXYHOLDER *pph = NULL;

    // QI for IUnknown on the 32-bit interface
    scRet = punkThis32->QueryInterface(IID_IUnknown, (void **) &pUnk);
    if(SUCCEEDED(scRet) && pUnk) {
        // Lookup the indentity
        if(_pHolderTbl->Lookup((VPVOID) pUnk, (void *&)pph)) {
            // Identity exists for IUnknown
            thkAssert(pph);
			if (pph)
			{
				thkAssert(pph->unkProxy.dwPtrVal);
				if(pph->dwFlags & PH_AGGREGATEE) {
					thkAssert(pph->unkProxy.wType == PPRX_32);
					DebugValidateProxy3216((THUNK3216OBJ *) pph->unkProxy.dwPtrVal);
				}
				else {
					thkAssert(pph->unkProxy.wType == PPRX_16);
					DebugValidateProxy1632(pph->unkProxy.dwPtrVal);
				}

				// Fix up the reference count
				pUnk->Release();

				// Initialize return values
				*pProxy = pph->unkProxy;
				fst = FST_USED_EXISTING;
			}
			else
			{
				scRet = E_FAIL;
				fst = FST_ERROR;
			}
        }
        else {
            // Identity does not exist for IUnknown which means that
            // the IUnknown is indeed a 32-bit interface that has
            // not been seen till now. Establish its identity
            thkAssert(!pph);

            // Create the proxy for 32-bit IUnknown
            vpvProxy = flFreeList16.AllocElement();
            if(vpvProxy) {
                // Put the new proxy in the proxy list
                if(_pProxyTbl1632->SetAt((DWORD) pUnk, (void *)vpvProxy)) {
                    ptoProxy = FIXVDMPTR(vpvProxy, THUNK1632OBJ);
                    thkAssert(ptoProxy);

                    // Update proxy fields
                    ptoProxy->pfnVtbl = gdata16Data.atfnProxy1632Vtbl;
                    ptoProxy->cRefLocal = 1;
                    ptoProxy->cRef = 1;
                    ptoProxy->iidx = THI_IUnknown;
                    ptoProxy->punkThis32 = pUnk;
                    ptoProxy->grfFlags = PROXYFLAG_PUNK;
                    PprxNull(ptoProxy->pprxObject);
                    ptoProxy->pphHolder = NULL;
#if DBG == 1
                    ptoProxy->dwSignature = PSIG1632;
#endif
                    RELVDMPTR(vpvProxy);

                    // Initialize return value
                    pProxy->dwPtrVal = vpvProxy;
                    pProxy->wType = PPRX_16;

                    // Create a new NONAGGREGATE holder
                    pph = NewHolder((VPVOID) pUnk, *pProxy, PH_NORMAL);
                    if(pph) {
                        // Initialize return value
                        fst = FST_CREATED_NEW;
                    }
                    else {
                        // Remove the key from the 1632 proxy table
#if DBG==1
                        thkAssert(_pProxyTbl1632->RemoveKey((DWORD) pUnk));
#else
                        _pProxyTbl1632->RemoveKey((DWORD) pUnk);
#endif
                    }
                }
            }
        }
    }
    else {
        // This is pretty nasty.
        Win4Assert(!"QI for IUnknown on the 32-bit interface failed");
        Win4Assert(!pUnk);
    }

    // Cleanup if something has gone wrong
    if(fst == FST_ERROR) {
        if(vpvProxy) {
            flFreeList16.FreeElement(vpvProxy);
        }
        if(pUnk) {
            pUnk->Release();
            scRet = E_OUTOFMEMORY;
        }

        // Reset return value
        pProxy->dwPtrVal = NULL;
        pProxy->wType = PPRX_NONE;
    }
    else {
        scRet = NOERROR;
    }

    // Indicate the type being returned
    if(pfst)
        *pfst = fst;

    return scRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::Object16Identity
//
//  Synopsis:   Finds/Creates a 32/16 IUnknown proxy on a given 16-bit object
//              to establish its identity.
//
//  Arguments:  [vpvThis16] -- 16-bit Object
//              [pProxy]     -- Proxy representing Identity
//              [pfst]      -- Search result is returned here
//
//  Returns:    Proxy representing object identity. In addition, the
//              returned proxy is AddRefed only if it represents a
//              16-bit identity
//
//  History:    Mar 14,97   Gopalk      Created to support aggregation and
//                                      proper thunking of IN/OUT interfaces
//----------------------------------------------------------------------------
SCODE CThkMgr::Object16Identity(VPVOID vpvThis16, PROXYPTR *pProxy, DWORD *pfst, BOOL bCallQI, BOOL bExtraAddRef)
{
    // Local variables
    DWORD fst = FST_ERROR;
    SCODE scRet;
    THUNK3216OBJ *punkProxy = NULL;
    VPVOID vpvUnk = NULL;
    PROXYHOLDER *pph = NULL;

    if (bCallQI) {
        // QI for IUnknown on the 16-bit interface
        scRet = QueryInterfaceOnObj16(vpvThis16, IID_IUnknown, (void **)&vpvUnk);
    }
    else {
        scRet = E_FAIL; // this will force the QI workaround below
    }

    if(FAILED(scRet)) {
        // This is pretty nasty.
        Win4Assert(!"QI for IUnknown on the 16-bit interface failed");
        Win4Assert(!vpvUnk);

        // But I am allowing the behavior as VB4.0 16-bit passes an
        // IStorage to WriteClassStg api that does not respond to QI
        // for IUnknown. See NT Raid Bug #82195
        scRet = NOERROR;
        vpvUnk = vpvThis16;

        // AddRef the 16-bit interface
        AddRefOnObj16(vpvUnk);
    }
    else {
        // Assert that identity has been established
        Win4Assert(vpvUnk);
    }


    // Lookup the indentity
    if(_pHolderTbl->Lookup(vpvUnk, (void *&)pph)) {
        // Identity exists for IUnknown
        thkAssert(pph);
		if (pph)
		{
			thkAssert(pph->unkProxy.dwPtrVal);
			if(pph->dwFlags & PH_AGGREGATEE) {
				thkAssert(pph->unkProxy.wType == PPRX_16);
				DebugValidateProxy1632(pph->unkProxy.dwPtrVal);
			}
			else {
				thkAssert(pph->unkProxy.wType == PPRX_32);
				DebugValidateProxy3216((THUNK3216OBJ *) pph->unkProxy.dwPtrVal);
			}

			// Fix up the reference count
			ReleaseOnObj16(vpvUnk);

			// Initialize return values
			*pProxy = pph->unkProxy;
			fst = FST_USED_EXISTING;
		}
		else
		{
			fst = FST_ERROR;
			scRet = E_FAIL;
		}
    }
    else {
        // Identity does not exist for IUnknown which means that
        // the IUnknown is indeed a 16-bit interface that has
        // not been seen till now. Establish its identity
        thkAssert(!pph);

        // Create the proxy for 16-bit IUnknown
        punkProxy = (THUNK3216OBJ *) flFreeList32.AllocElement();
        if(punkProxy) {
            // Put the new proxy in the proxy list
            if(_pProxyTbl3216->SetAt(vpvUnk, punkProxy)) {
                // Update proxy fields
                punkProxy->pfnVtbl = (DWORD)athopiInterfaceThopis[THI_IUnknown].pt3216fn;
                punkProxy->cRefLocal = 1;
                punkProxy->cRef = 1;
                punkProxy->iidx = THI_IUnknown;
                punkProxy->vpvThis16 = vpvUnk;
                punkProxy->grfFlags = PROXYFLAG_PUNK;
                PprxNull(punkProxy->pprxObject);
                punkProxy->pphHolder = NULL;
#if DBG == 1
                punkProxy->dwSignature = PSIG3216;
#endif

                // Initialize return value
                pProxy->dwPtrVal = (DWORD) punkProxy;
                pProxy->wType = PPRX_32;

                // Create a new NONAGGREGATE holder
                pph = NewHolder(vpvUnk, *pProxy, PH_NORMAL);
                if(pph) {
                    // Initialize return value
                    fst = FST_CREATED_NEW;
                    if (bExtraAddRef) {         //Hack
                        AddRefOnObj16(vpvUnk);
                    }
                }
                else {
                    // Remove the key from the 3216 proxy table
#if DBG==1
                    thkAssert(_pProxyTbl3216->RemoveKey(vpvUnk));
#else
                    _pProxyTbl3216->RemoveKey(vpvUnk);
#endif
                }
            }
        }
    }

    // Cleanup if something has gone wrong
    if(fst == FST_ERROR) {
        if(punkProxy) {
            flFreeList32.FreeElement((DWORD) punkProxy);
        }
        if(vpvUnk) {
            ReleaseOnObj16(vpvUnk);
            scRet = E_OUTOFMEMORY;
        }

        // Reset return value
        pProxy->dwPtrVal = NULL;
        pProxy->wType = PPRX_NONE;
    }
    else {
        scRet = NOERROR;
    }

    // Indicate the type being returned
    if(pfst)
        *pfst = fst;

    return scRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::FindProxy3216
//
//  Synopsis:   Finds/Creates a 32/16 proxy for a given 16-bit interface.
//              If the given 16-bit interface itself is a proxy, returns
//              the actual 32-bit Interface
//
//  Arguments:  [vpvPrealloc] -- Preallocated 32/16 proxy
//              [vpvThis16]   -- 16-bit Interface to be proxied
//              [iidx]        -- Interface index or IID
//              [pfst]        -- Return value to hold the kind proxy object
//
//  Returns:    32/16 proxy object or the actual 32-bit Interface
//
//  History:    Mar 14,97   Gopalk      Rewritten to support aggregation and
//                                      proper thunking of IN/OUT interfaces
//----------------------------------------------------------------------------
IUnknown *CThkMgr::FindProxy3216(THUNK3216OBJ *ptoPrealloc, VPVOID vpvThis16,
                                 PROXYHOLDER *pgHolder, IIDIDX iidx,
                                 BOOL bExtraAddRef, DWORD *pfst)
{
    thkDebugOut((DEB_THUNKMGR, "%sIn  FindProxy3216(%p, %p, %s)\n",
                 NestingLevelString(), ptoPrealloc, vpvThis16, IidIdxString(iidx)));
    DebugIncrementNestingLevel();

    // Local variables
    THUNK3216OBJ *pto = NULL, *punkProxy = NULL;
    IUnknown *pProxy;
    DWORD fst, Fail = FALSE;

    // Validation checks
    thkAssert(vpvThis16);
#if DBG == 1
    // Ensure that the preallocated proxy is not in use
    if(ptoPrealloc) {
        if(ptoPrealloc->grfFlags & PROXYFLAG_TEMPORARY)
            thkAssert(ptoPrealloc->cRefLocal == 0 && ptoPrealloc->cRef == 0);
    }
#endif

    // Initialize the fst value
    fst = FST_ERROR;

    // If proxy was preallocated for this IID using CanGetNewProxy, it would
    // have added it to the requested IID list.
    if (ptoPrealloc != 0 && IIDIDX_IS_IID(iidx))
        RemoveIIDRequest(*IIDIDX_IID(iidx));

    if(pto = LookupProxy3216(vpvThis16)) {
        // Found an existing proxy
        thkDebugOut((DEB_THUNKMGR, "%sFindProxy3216 found existing proxy,(%p)->%p\n",
                     NestingLevelString(), vpvThis16, pto));

        // Assert that the holders match
        thkAssert(pto->pphHolder);
        thkAssert(!(pto->grfFlags & PROXYFLAG_PUNKINNER));
        if(pgHolder && pto->pphHolder!=pgHolder) {
            thkAssert(pto->pphHolder->dwFlags & PH_AGGREGATEE);
        }

        // Check the proxy IID against the given IID. If the server has passed
        // the same 32-bit interface pointer against another IID, it is possible
        // for the IID's to be different. If the Interface2 derives from Interface1,
        // the interface pointers for them would be the same in C or C++. An
        // excellant example would be IPersistStorage deriving from IPersist.

        // IIDIDXs are related to interfaces in thunk tables, which are organized
        // such that more derived interfaces have higher indices than the less
        // derived ones. Custom interfaces have an IID rather than an index, and
        // consequently are not affected by the following statement.
        if(IIDIDX_IS_INDEX(iidx)) {
            // Check if the new IID is more derived than the existing one
            if(IIDIDX_INDEX(iidx) > IIDIDX_INDEX(pto->iidx)) {
                // Change the vtable pointer to the more derived interface
                pto->pfnVtbl = (DWORD)athopiInterfaceThopis[IIDIDX_INDEX(iidx)].pt3216fn;
                pto->iidx = iidx;
            }
        }

        // AddRef the proxy
        AddRefProxy3216(pto);

        // Set return values
        fst = FST_USED_EXISTING;
        pProxy = (IUnknown *)pto;
    }
    else if(pProxy = IsProxy1632(vpvThis16)) {
        // The given 16-bit interface itself is a proxy to a 32-bit
        // interface
        thkDebugOut((DEB_THUNKMGR, "%sFindProxy3216 shortcut proxy,(%p)->%p\n",
                     NestingLevelString(), vpvThis16, pProxy));
        THUNK1632OBJ UNALIGNED *pProxy1632;

        // Fix the VDM pointer
        pProxy1632 = FIXVDMPTR(vpvThis16, THUNK1632OBJ);

        // Assert that the holders match
        thkAssert(pProxy1632->pphHolder);
        thkAssert(!(pProxy1632->grfFlags & PROXYFLAG_PUNKINNER));
        if(pgHolder && pProxy1632->pphHolder!=pgHolder) {
            thkAssert(pProxy1632->pphHolder->dwFlags & PH_AGGREGATEE);
        }

        // Release the VDM pointer
        RELVDMPTR(vpvThis16);

        // Avoid creating a proxie to another proxie
        THKSTATE thkstate;

        // Remember the current thunk state
        thkstate = GetThkState();

        // Set the thunk state to THKSTATE_NOCALL
        SetThkState(THKSTATE_NOCALL);

        // AddRef actual the 32-bit interface
        pProxy->AddRef();

        // Restore previous thunk state. Remember the Excel Hack
        SetThkState(thkstate);

        // Set the type of proxy being returned
        fst = FST_SHORTCUT;
    }
    else {
        // An existing proxy has not been found and the interface to proxied
        // is a real 16-bit interface.

        // Check if holder has not been given
        if(!pgHolder) {
            // This interface is being obtained through a method call
            PROXYPTR unkPPtr;
            SCODE error;
            BOOL bCallQI = TRUE;

            if((TlsThkGetAppCompatFlags() & OACF_CRLPNTPERSIST) &&
               (iidx==THI_IPersistStorage)) {
                thkDebugOut((DEB_WARN,"CorelPaint Hack Used\n"));
                bCallQI = FALSE;
            }

            // Obtain the identity of 16-bit object
            error = Object16Identity(vpvThis16, &unkPPtr, &fst, bCallQI, bExtraAddRef);
            if(error == NOERROR) {
                // Check for aggregation case
                if(unkPPtr.wType==PPRX_32) {
                    // Check if vpvThis16 itself is an IUnknown interface
                    if(iidx == THI_IUnknown) {
                        // Initialize the return value
                        pProxy = (IUnknown *) unkPPtr.dwPtrVal;

                        // Check if the identity has been switched
                        if(fst == FST_USED_EXISTING) {
                            // The IUnknown identity has already been established
                            // The app was trying to pass someother 16-bit interface
                            // as IUnknown.
                            thkDebugOut((DEB_WARN, "Switched to correct Identity\n"));

                            // AddRef the proxy being returned
                            AddRefProxy3216((THUNK3216OBJ *) pProxy);
                        }
                        else {
                            thkAssert(fst == FST_CREATED_NEW);
                        }
                    }
                    else {
                        THUNK3216OBJ *Id3216 = (THUNK3216OBJ *) unkPPtr.dwPtrVal;

                        // Check if the identity has just been established
                        if(fst == FST_CREATED_NEW) {
                            // Check if the Identity and current IID share the same
                            // interface pointer
                            if(Id3216->vpvThis16==vpvThis16) {
                                // Check if the new IID is more derived than the existing one
                                if(IIDIDX_IS_INDEX(iidx) && iidx>Id3216->iidx) {
                                    // Change the vtable pointer to the more derived interface
                                    Id3216->pfnVtbl = (DWORD)athopiInterfaceThopis[iidx].pt3216fn;
                                    Id3216->iidx = iidx;
                                }

                                // Initialize the return value
                                pProxy = (IUnknown *) Id3216;
                            }
                            else {
                                // We need to release the IUnknown proxy after adding
                                // the proxy representing vpvThis16 to the its holder
                                punkProxy = Id3216;
                            }
                        }
                        else {
                            thkAssert(fst == FST_USED_EXISTING);
                        }

                        // Obtain the holder of the identity
                        pgHolder = Id3216->pphHolder;
                    }
                }
                else {
                    // Obtain the holder of the identity
                    THUNK1632OBJ UNALIGNED *Id1632;
                    IUnknown *punkTemp;

                    Id1632 = FIXVDMPTR(unkPPtr.dwPtrVal, THUNK1632OBJ);
                    pgHolder = Id1632->pphHolder;
                    punkTemp = Id1632->punkThis32;
                    RELVDMPTR(unkPPtr.dwPtrVal);

                    // Sanity checks
                    thkAssert(fst == FST_USED_EXISTING);
                    thkAssert(pgHolder->dwFlags & PH_AGGREGATEE);

                    // Check if vpvThis16 itself is an IUnknown interface
                    if(iidx == THI_IUnknown) {
                        // The IUnknown identity has already been established
                        // The app was trying to pass someother 16-bit interface
                        // as IUnknown. Switch to correct identity
                        thkAssert(!"Switched to correct Identity");

                        // Initialize the return value
                        pProxy = punkTemp;

                        // AddRef the actual 32-bit interface being returned
                        pProxy->AddRef();
                    }
                }
            }
            else {
                // Failed to obtain the identity
                Fail = TRUE;
            }
        }
    }

    if(!pProxy && !Fail) {
        // Assert that we have holder
        thkAssert(pgHolder);
        // Reset the fst value
        fst = FST_ERROR;

        // Obtain either a preallocated or a new proxy
        if(ptoPrealloc) {
            // Use the preallocated proxy
            pto = ptoPrealloc;
            ptoPrealloc = NULL;
        }
        else {
            // Create a new proxy
            pto = (THUNK3216OBJ *) flFreeList32.AllocElement();
        }

        // Ensure that we have a proxy
        if(pto) {
            // Put the new proxy in the proxy list
            if(_pProxyTbl3216->SetAt(vpvThis16, pto)) {
                // Convert a custom IID to THI_IUnknown as we thunk
                // only its IUnknown methods
                if(IIDIDX_IS_IID(iidx))
                    iidx = INDEX_IIDIDX(THI_IUnknown);

                // AddRef the 16-bit interface
                AddRefOnObj16(vpvThis16);

                // Update proxy fields
                pto->pfnVtbl = (DWORD)athopiInterfaceThopis[iidx].pt3216fn;
                pto->cRefLocal = 1;
                pto->cRef = 1;
                pto->iidx = iidx;
                pto->vpvThis16 = vpvThis16;
                pto->grfFlags = PROXYFLAG_PIFACE;
                PprxNull(pto->pprxObject);
                pto->pphHolder = NULL;
                AddProxyToHolder(pgHolder, pto, Pprx32(pto));
#if DBG == 1
                pto->dwSignature = PSIG3216;
#endif
                thkDebugOut((DEB_THUNKMGR,
                             "%sFindProxy3216 added new proxy, %s (%p)->%p (%d,%d)\n",
                             NestingLevelString(), inInterfaceNames[pto->iidx].pszInterface,
                             vpvThis16, pto, pto->cRefLocal, pto->cRef));

                // Set the return values
                pProxy = (IUnknown *) pto;
                fst = FST_CREATED_NEW;
            }
            else {
                // Cleanup the proxy only if it was newly created
                if(fst == FST_CREATED_NEW)
                    flFreeList32.FreeElement((DWORD) pto);
                pProxy = NULL;
                fst = 0;
            }
        }
    }
    else {
        if(Fail) {
            thkAssert(pProxy == NULL && fst == FST_ERROR);
        }
    }

    // Cleanup the allocated proxy if it has not been used
    if(ptoPrealloc)
        flFreeList32.FreeElement((DWORD)ptoPrealloc);

    // Release the IUnknown proxy. If it was newly created for establishing
    // the identity of the given 16-bit interface , the following release
    // would be the last release on the IUnknown proxy and consequently,
    // would destroy it along with its holder
    if(punkProxy)
        ReleaseProxy3216(punkProxy);

    // Set the return value
    if(pfst)
        *pfst = fst;

    DebugDecrementNestingLevel();
    thkDebugOut((DEB_THUNKMGR, "%sOut FindProxy3216: (%p)->%p\n",
                 NestingLevelString(), vpvThis16, pProxy));

    return pProxy;
}

//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::FindAggregate3216
//
//  Synopsis:   Finds/Generates a 32/16 proxy for a given 16-bit interface
//              that is aggregated with the given outer unknown.
//              If the given 16-bit interface itself is a proxy, returns
//              the actual 32-bit Interface
//
//  Arguments:  [ptoPrealloc] -- Preallocated proxy or NULL
//              [vpvOuter16]  -- controlling unknown that was passed to
//                               16-bit world
//              [vpvThis16]   -- 16-bit interface to be proxied
//              [iidx]        -- Interface index or IID
//              [pAggHolder]  -- Proxy holder of pUnkOuter
//              [pfst]        -- Return value to hold the kind proxy object
//
//  Returns:    32/16 proxy object or the actual 32-bit Interface
//
//  History:    Mar 14,97   Gopalk      Rewritten to support aggregation and
//                                      proper thunking of IN/OUT interfaces
//              Feb 11, 98  MPrabhu     Change to use pUnkOuter's holder
//----------------------------------------------------------------------------
IUnknown *CThkMgr::FindAggregate3216(THUNK3216OBJ *ptoPrealloc, VPVOID vpvOuter16,
                                    VPVOID vpvThis16, IIDIDX iidx, PROXYHOLDER *pAggHolder, DWORD *pfst)
{
    thkDebugOut((DEB_THUNKMGR, "%sIn  FindAggregate3216(%p, %p, %p, %s)\n",
                 NestingLevelString(), ptoPrealloc, vpvOuter16, vpvThis16,
                 IidIdxString(iidx)));
    DebugIncrementNestingLevel();

    // Local variables
    THUNK1632OBJ UNALIGNED *p1632ProxyOuter;
    THUNK3216OBJ *p3216ProxyOuter;
    PROXYHOLDER *pph;
    IUnknown *pUnk = NULL;
    DWORD fstPrx = FST_ERROR;

    // Validation checks
    thkAssert(vpvThis16 != NULL && vpvOuter16 != NULL);

    // Obtain the identity holder
    // Check if the outer IUnknown is a 32-bit interface
#if DBG == 1
    if(IsProxy1632(vpvOuter16)) {
        // The outer IUnknown is a 32-bit interface
        p1632ProxyOuter = FIXVDMPTR(vpvOuter16, THUNK1632OBJ);
        pph = p1632ProxyOuter->pphHolder;
        thkAssert(pph == pAggHolder);

        // Ensure that the holder is marked PH_AGGREGATEE
        thkAssert(pph);
        thkAssert(pph->dwFlags & PH_AGGREGATEE);
        RELVDMPTR(vpvOuter16);
    }
#endif
    // Aggregation through delegation.
    pph = pAggHolder;

    // Find/Generate the proxy for the given 16-bit interface
    pUnk = FindProxy3216(ptoPrealloc, vpvThis16, pph, iidx, FALSE, &fstPrx);

    // Initialize the return value
    if(pfst)
        *pfst = fstPrx;

    DebugDecrementNestingLevel();
    thkDebugOut((DEB_THUNKMGR, "%sOut FindAggregate3216,(%p)->%p\n",
                 NestingLevelString(), vpvThis16, pUnk));

    // This may be a proxy or a real 32-bit interface
    return(pUnk);
}

//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::FindAggregate1632
//
//  Synopsis:   Finds/Generates a 16/32 proxy for a given 32-bit interface
//              that is aggregated with the given outer unknown.
//              If the given 32-bit interface itself is a proxy, returns
//              the actual 16-bit Interface
//
//  Arguments:  [ptoPrealloc] -- Preallocated proxy or NULL
//              [punkOuter32] -- controlling unknown that was passed to
//                               32-bit world
//              [punkThis32]  -- 16-bit interface to be proxied
//              [iidx]        -- Interface index or IID
//              [pAggHolder]  -- Proxy holder of pUnkOuter
//              [pfst]        -- Return value to hold the kind proxy object
//
//  Returns:    32/16 proxy object or the actual 32-bit Interface
//
//  History:    Mar 14,97   Gopalk      Rewritten to support aggregation and
//                                      proper thunking of IN/OUT interfaces
//              Feb 11, 98  MPrabhu     Change to use pUnkOuter's holder
//----------------------------------------------------------------------------
VPVOID CThkMgr::FindAggregate1632(VPVOID vpvPrealloc, IUnknown *punkOuter32,
                                  IUnknown *punkThis32, IIDIDX iidx, PROXYHOLDER *pAggHolder, DWORD *pfst)
{
    thkDebugOut((DEB_THUNKMGR, "%sIn  FindAggregate1632(%p, %p, %p, %s)\n",
                 NestingLevelString(), vpvPrealloc, punkOuter32, punkThis32,
                 IidIdxString(iidx)));
    DebugIncrementNestingLevel();

    // Local variables
    THUNK1632OBJ UNALIGNED *p1632ProxyOuter;
    THUNK3216OBJ *p3216ProxyOuter;
    PROXYHOLDER *pph;
    VPVOID vpvProxy = NULL;
    DWORD fstPrx = FST_ERROR;

    // Validation checks
    thkAssert(punkThis32 != NULL && punkOuter32 != NULL);

    // Obtain the identity holder
    // Check if the outer IUnknown is a 16-bit interface
#if DBG == 1
    if(IsProxy3216(punkOuter32)) {
        // The outer IUnknown is a 16-bit interface
        p3216ProxyOuter = (THUNK3216OBJ *) punkOuter32;
        pph = p3216ProxyOuter->pphHolder;
        thkAssert(pph == pAggHolder);

        // Ensure that the holder is marked PH_AGGREGATEE
        thkAssert(pph);
        thkAssert(pph->dwFlags & PH_AGGREGATEE);
    }
#endif
    // Aggregation through delegation.
    // The outer IUnknown must be a 32-bit interface
    pph = pAggHolder;

    // Find/Generate the proxy for the given 32-bit interface
    vpvProxy = FindProxy1632(vpvPrealloc, punkThis32, pph, iidx, &fstPrx);

    // Initialize the return value
    if(pfst)
        *pfst = fstPrx;

    DebugDecrementNestingLevel();
    thkDebugOut((DEB_THUNKMGR, "%sOut FindAggregate1632,(%p)->%p\n",
                 NestingLevelString(), punkThis32, vpvProxy));

    // This may be a proxy or a real 16-bit interface
    return(vpvProxy);
}

//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::QueryInterfaceProxy3216
//
//  Synopsis:   QueryInterface on the  given proxy
//
//  Arguments:  [ptoThis] -- Proxy to a 16-bit interface
//              [refiid]  -- Interface IID
//              [ppv]     -- Place where the new interface is returned
//
//  Returns:    HRESULT
//
//  History:    Mar 14,97   Gopalk      Rewritten to support aggregation and
//                                      proper thunking of IN/OUT interfaces
//----------------------------------------------------------------------------
SCODE CThkMgr::QueryInterfaceProxy3216(THUNK3216OBJ *ptoThis, REFIID refiid,
                                       LPVOID *ppv)
{
    thkDebugOut((DEB_THUNKMGR, "%sIn QueryInterfaceProxy3216(%p)\n",
                 NestingLevelString(), ptoThis));
    DebugIncrementNestingLevel();

    // Local variables
    SCODE scRet = S_OK;
    IUnknown *punkProxy;
    PROXYHOLDER *pph;
    VPVOID vpvUnk;
    DWORD fst;

    // Validation checks
    DebugValidateProxy3216(ptoThis);

    // Initialize the return value
    *ppv = NULL;

    // Convert interface IID to an IIDIDX
    IIDIDX iidx = IidToIidIdx(refiid);

    // Check if a custom interface has been requested
    if(IIDIDX_IS_IID(iidx)) {
        thkDebugOut((DEB_THUNKMGR, "%sQueryInterfaceProxy3216: unknown iid %s\n",
                     NestingLevelString(), IidIdxString(iidx)));

        // Add the request for the unknown interface
        if(!AddIIDRequest(refiid))
            return E_OUTOFMEMORY;
    }
    thkAssert(ptoThis->vpvThis16);

    // Ensure that the aggregatee identity gets correctly established
    if(ptoThis->grfFlags & PROXYFLAG_PUNKOUTER && iidx == THI_IUnknown) {
        // QI by the aggregatee for identity
        thkAssert(ptoThis->pphHolder->unkProxy.dwPtrVal == (DWORD) ptoThis);

        // AddRef and return outer proxy
        AddRefProxy3216(ptoThis);
        *ppv = (void *) ptoThis;
    }
    else {
        // Execute the QI on the 16-bit interface
        scRet = QueryInterfaceOnObj16(ptoThis->vpvThis16, refiid, (void **)&vpvUnk);
        if(SUCCEEDED(scRet)) {
            if(vpvUnk) {
                // Obtain the identity holder
                pph = ptoThis->pphHolder;

                // Check if this is a QI on an interface on the aggregatee
                if(pph->dwFlags & PH_AGGREGATEE) {
                    if(ptoThis->grfFlags & PROXYFLAG_PIFACE) {
                        // QI on an interface on the aggregatee which
                        // delegates to the aggregator

                        // Note the above QI call can be short circuited as
                        // an optimization. It will be carried out in future
                        // after ensuring that apps do not break due to such
                        // short circuiting
                        thkAssert(pph->unkProxy.wType == PPRX_16);
                    }
                    else if(ptoThis->grfFlags & PROXYFLAG_PUNKOUTER) {
                        // QI by the aggregatee on aggregator
                        thkAssert(pph->unkProxy.dwPtrVal == (DWORD) ptoThis);
                    }
                    else {
                        // QI by the aggregator on the aggregatee
                        thkAssert(ptoThis->grfFlags & PROXYFLAG_PUNKINNER);
                        thkAssert(pph->unkProxy.wType == PPRX_16);
                    }

                    // As aggregation is involved, we cannot be certain of
                    // identity of the returned interface
                    pph = NULL;
                }

                // Set the thunk status
                SetThkState(THKSTATE_INVOKETHKOUT32);

                punkProxy = FindProxy3216(NULL, vpvUnk, pph, iidx, FALSE, &fst);

                if(punkProxy) {
                    // Set the return value
                    *ppv = punkProxy;
#if DBG==1
                    if(pph) {
                        // Ensure that the given and new proxies either have the same
                        // holder or point to same identity
                        if(fst & FST_PROXY_STATUS) {
                            THUNK3216OBJ *ptoNew = (THUNK3216OBJ *) punkProxy;

                            thkAssert(ptoNew->pphHolder == ptoThis->pphHolder);
                        }
                        else {
                            THUNK1632OBJ UNALIGNED *ptoNew;

                            ptoNew = FIXVDMPTR(vpvUnk, THUNK1632OBJ);
                            thkAssert(fst == FST_SHORTCUT);
                            thkAssert(ptoNew->pphHolder != ptoThis->pphHolder);
                            thkAssert(ptoNew->pphHolder->dwFlags & PH_AGGREGATEE);
                            thkAssert(ptoNew->pphHolder->unkProxy.wType == PPRX_32);
                            RELVDMPTR(vpvUnk);
                        }
                    }
#endif
                }
                else {
                    scRet = E_OUTOFMEMORY;
                }

                // As the new interface is an OUT parameter, release the actual
                // 16-bit interface. This would counter the AddRef made by
                // a successfull FindProxy3216, else it would clean up the
                // reference count
                ReleaseOnObj16(vpvUnk);

                // Reset thunk status
                SetThkState(THKSTATE_NOCALL);
            }
            else {
                // Corel draw returns NOERROR while setting returned interface to NULL
                // We modify the returned value to suit 32-bit QI semantics.
                scRet = E_NOINTERFACE;
            }
        }
    }

    if(IIDIDX_IS_IID(iidx)) {
        // Clean up custom interface request
        RemoveIIDRequest(refiid);
    }

    DebugDecrementNestingLevel();
    thkDebugOut((DEB_THUNKMGR, "%sOut QueryInterfaceProxy3216(%p) => %p, 0x%08lX\n",
                 NestingLevelString(), ptoThis, *ppv, scRet));

    return scRet;
}

//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::AddRefProxy3216
//
//  Synopsis:   addref on the given object - can addref the real object
//
//  Arguments:  [ptoThis] -- proxy object
//
//  Returns:    local refcount
//
//  History:    Mar 14,97   Gopalk      Rewritten to support aggregation and
//                                      proper thunking of IN/OUT interfaces
//----------------------------------------------------------------------------
DWORD CThkMgr::AddRefProxy3216(THUNK3216OBJ *ptoThis)
{
    thkDebugOut((DEB_THUNKMGR, "%sIn AddRefProxy3216(%p)\n",
                 NestingLevelString(), ptoThis));
    DebugIncrementNestingLevel();

    // Validation checks
    DebugValidateProxy3216(ptoThis);
    thkAssert(ptoThis->pphHolder);

    // Increment local refcount
    thkAssert(ptoThis->cRefLocal >= 0);
    ptoThis->cRefLocal++;

    // Check for the need to AddRef the holder
    if(ptoThis->cRefLocal == 1) {
        // Assert that an aggregatee is not being revived
        thkAssert(!(ptoThis->grfFlags & PROXYFLAG_PUNKINNER));

        // AddRef the holder
        AddRefHolder(ptoThis->pphHolder);

        // Mark the proxy as revived
        ptoThis->grfFlags |= PROXYFLAG_REVIVED;
    }

    // Check for the need to forward AddRef to the actual 16-bit interface
    if(ptoThis->cRefLocal==1 || (ptoThis->pphHolder->dwFlags & PH_AGGREGATEE)) {
#if DBG==1
        DWORD refsBefore, refsAfter;
        PROXYHOLDER *pph;
        THUNK1632OBJ UNALIGNED *punkOuter;

        // Check if the object is an aggregatee
        pph = ptoThis->pphHolder;
        if((pph->dwFlags & PH_AGGREGATEE) && (ptoThis->grfFlags & PROXYFLAG_PIFACE)) {
            // Assert that identity is in the 32-bit world
            thkAssert(pph->unkProxy.wType == PPRX_16);

            // Obtain the references on the outer proxy
            punkOuter = FIXVDMPTR(pph->unkProxy.dwPtrVal, THUNK1632OBJ);
            thkAssert(punkOuter->cRef == punkOuter->cRefLocal);
            refsBefore = punkOuter->cRefLocal;
            RELVDMPTR(pph->unkProxy.dwPtrVal);
        }
#endif
        // Increment before calling the actual 16-bit interface
        ptoThis->cRef++;

        // AddRef the actual 16-bit interface
        AddRefOnObj16(ptoThis->vpvThis16);

#if DBG==1
        // Check if the object is an aggregatee
        if((pph->dwFlags & PH_AGGREGATEE) && (ptoThis->grfFlags & PROXYFLAG_PIFACE)) {
            // Ensure that the above AddRef translated to a AddRef on the
            // outer proxy
            punkOuter = FIXVDMPTR(pph->unkProxy.dwPtrVal, THUNK1632OBJ);
            thkAssert(punkOuter->cRef == punkOuter->cRefLocal);
            refsAfter = punkOuter->cRefLocal;
            thkAssert(refsBefore == refsAfter-1);
            RELVDMPTR(pph->unkProxy.dwPtrVal);
        }
#endif
    }

    DebugValidateProxy3216(ptoThis);
    DebugDecrementNestingLevel();
    thkDebugOut((DEB_THUNKMGR, "%sOut AddRefProxy3216(%p),(%ld,%ld)\n",
                 NestingLevelString(), ptoThis, ptoThis->cRefLocal,
                 ptoThis->cRef));

    return ptoThis->cRefLocal;
}

//+---------------------------------------------------------------------------
//
//  Method:     CThkMgr::ReleaseProxy3216
//
//  Synopsis:   release on the proxy or aggregate
//
//  Arguments:  [ptoThis] -- proxy object
//
//  Returns:    local refcount
//
//  History:    Mar 14,97   Gopalk      Rewritten to support aggregation and
//                                      proper thunking of IN/OUT interfaces
//----------------------------------------------------------------------------
DWORD CThkMgr::ReleaseProxy3216(THUNK3216OBJ *ptoThis)
{
    thkDebugOut((DEB_THUNKMGR, "%sIn ReleaseProxy3216(%p)\n",
                 NestingLevelString(), ptoThis));
    DebugIncrementNestingLevel();

    // Local variables
    DWORD dwLocalRefs, dwRefs;
    DWORD ProxyType;

    // Validation checks
    DebugValidateProxy3216(ptoThis);
    thkAssert(ptoThis->pphHolder);

    // Check for the need to forward the release to the actual
    // 16-bit interface
    if(ptoThis->cRef == ptoThis->cRefLocal) {
#if DBG==1
        DWORD refsBefore, refsAfter;
        PROXYHOLDER *pph;
        THUNK1632OBJ UNALIGNED *punkOuter;

        // Check if the object is an aggregatee
        pph = ptoThis->pphHolder;
        if((pph->dwFlags & PH_AGGREGATEE) && (ptoThis->grfFlags & PROXYFLAG_PIFACE)) {
            // Assert that identity is in the 32-bit world
            thkAssert(pph->unkProxy.wType == PPRX_16);

            // Obtain the references on the outer proxy
            punkOuter = FIXVDMPTR(pph->unkProxy.dwPtrVal, THUNK1632OBJ);
            thkAssert(punkOuter->cRef == punkOuter->cRefLocal);
            refsBefore = punkOuter->cRefLocal;
            RELVDMPTR(pph->unkProxy.dwPtrVal);
        }
#endif

        // Release the actual 16-bit interface
        thkAssert(ptoThis->cRef);
        ReleaseOnObj16(ptoThis->vpvThis16);

        // Decrement after calling the actual 16-bit interface
        --ptoThis->cRef;

#if DBG==1
        // Check if the object is an aggregatee
        if((pph->dwFlags & PH_AGGREGATEE) && (ptoThis->grfFlags & PROXYFLAG_PIFACE)) {
            // Ensure that the above release translated to a release on the
            // outer proxy
            punkOuter = FIXVDMPTR(pph->unkProxy.dwPtrVal, THUNK1632OBJ);
            thkAssert(punkOuter->cRef == punkOuter->cRefLocal);
            refsAfter = punkOuter->cRefLocal;
            thkAssert(refsBefore == refsAfter+1);
            RELVDMPTR(pph->unkProxy.dwPtrVal);
        }
#endif
    }

    // Decrement the local refcount
    thkAssert(ptoThis->cRefLocal > 0);
    dwLocalRefs = --ptoThis->cRefLocal;
    dwRefs = ptoThis->cRef;
    ProxyType = ptoThis->grfFlags & PROXYFLAG_TYPE;

    // Check if the proxy needs to be cleaned up
    if(dwLocalRefs == 0) {
        // Debug dump
        thkAssert(dwRefs == 0);
        DBG_DUMP(DebugDump3216());

        // Release the holder. If this is the last release on
        // the holder, the proxy would be destroyed. Hence,
        // we should not use any member variables hereafter.
        ReleaseHolder(ptoThis->pphHolder, ProxyType);
    }

    DebugDecrementNestingLevel();
    thkDebugOut((DEB_THUNKMGR, "%sOut ReleaseProxy3216(%p) => %ld,%ld\n",
                 NestingLevelString(), ptoThis, dwLocalRefs, dwRefs));

    return dwLocalRefs;
}


//+---------------------------------------------------------------------------
//
//  Member:     CThkMgr::RemoveProxy3216, public
//
//  Synopsis:   Destroys the given proxy
//
//  Arguments:  [pto] - Flat proxy pointer
//
//  History:    Mar 14,97   Gopalk      Rewritten to support aggregation and
//                                      proper thunking of IN/OUT interfaces
//----------------------------------------------------------------------------
void CThkMgr::RemoveProxy3216(THUNK3216OBJ *pto)
{
    // Revoke the assosiation between the proxy and
    // the 16-bit interface
    if(!(pto->grfFlags & PROXYFLAG_PUNKOUTER)) {
#if DBG==1
        thkAssert(_pProxyTbl3216->RemoveKey(pto->vpvThis16));
#else
        _pProxyTbl3216->RemoveKey(pto->vpvThis16);
#endif
    }

    // Release the holder if needed
    if(pto->cRefLocal > 0)
        ReleaseHolder(pto->pphHolder, PROXYFLAG_NONE);

    // Check if the proxy is locked
    if(!(pto->grfFlags & PROXYFLAG_LOCKED)) {
#if DBG == 1
        // In debug builds, mark the proxy dead
        pto->dwSignature = PSIG3216DEAD;

        // Return the proxy to free list
        if (!fSaveProxy)
#endif
        {
            thkAssert(pto->pphHolder);
            pto->pphHolder = NULL;
            flFreeList32.FreeElement((DWORD)pto);
        }
    }

    return;
}

//+---------------------------------------------------------------------------
//
//  Member:     CThkMgr::PrepareForCleanup, public
//
//  Synopsis:   Marks the 3216 Proxies so that OLE32 cannot call them.
//
//  Arguments:  -none-
//
//  History:    24-Aug-94       BobDay  Created
//
//----------------------------------------------------------------------------

void CThkMgr::PrepareForCleanup( void )
{
    POSITION pos;
    DWORD dwKey;
    THUNK3216OBJ *pto3216;

    //
    // CODEWORK: OLE32 should be setup so that it doesn't callback while the
    // thread is detaching.  Then this function becomes obsolete.
    //

    // Check if callbacks were disabled earlier
    if(AreCallbacksAllowed())
    {
        // Disable callbacks on this thread as the 16-bit TASK state has
        // been reclaimed by NTVDM by now
        DisableCallbacks();

        // delete the 3216 proxy table
        pos = _pProxyTbl3216->GetStartPosition();

        while (pos)
        {
			pto3216 = NULL;

            _pProxyTbl3216->GetNextAssoc(pos, dwKey, (void FAR* FAR&) pto3216);

			if (pto3216 != NULL)
			{
				thkDebugOut((DEB_IWARN, "Preparing 3216 Proxy for cleanup: "
							 "%08lX %08lX %s\n",
							 pto3216,
							 pto3216->vpvThis16,
							 IidIdxString(pto3216->iidx)));

				pto3216->grfFlags |= PROXYFLAG_CLEANEDUP;
			}
        }
    }
}

#if DBG == 1
void CThkMgr::DebugDump3216()
{
    THUNK3216OBJ *pto3216;
    DWORD dwKey;
    POSITION pos;

    thkDebugOut((DEB_THUNKMGR, "%s DebugDump3216\n",NestingLevelString()));

    pos = _pProxyTbl3216->GetStartPosition();
    while (pos)
    {
        _pProxyTbl3216->GetNextAssoc(pos, dwKey, (void FAR* FAR&) pto3216);
        thkDebugOut((DEB_THUNKMGR,
                     "%s Proxy3216:Key:%p->%p, (%s) (%d,%d)\n",
                     NestingLevelString(), dwKey, pto3216,
                     IidIdxString(pto3216->iidx), pto3216->cRefLocal,
                     pto3216->cRef));
    }
}


void CThkMgr::DebugDump1632()
{
    THUNK1632OBJ UNALIGNED *pto1632;
    DWORD dwKey;
    VPVOID vpv;
    POSITION pos;

    thkDebugOut((DEB_THUNKMGR, "%s DebugDump1632\n",NestingLevelString()));

    pos = _pProxyTbl1632->GetStartPosition();
    while (pos)
    {
        _pProxyTbl1632->GetNextAssoc(pos, dwKey, (void FAR* FAR&) vpv);
        pto1632 = FIXVDMPTR(vpv, THUNK1632OBJ);
        thkDebugOut((DEB_THUNKMGR,
                     "%s Proxy1632:key:%p->%p, (%s) (%d,%d)\n",
                     NestingLevelString(), dwKey, pto1632,
                     IidIdxString(pto1632->iidx), pto1632->cRefLocal,
                     pto1632->cRef));
        RELVDMPTR(vpv);
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\olethk32\dbgitbl.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	dbgitbl.cxx
//
//  Notes:	This file is automatically generated
//		Do not modify by hand
//
//  History:	Fri May 27 10:39:02 1994	Generated
//
//----------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#include "dbgint.cxx"
#if DBG == 1

INTERFACENAMES inInterfaceNames[] =
{
    "IUnknown", apszIUnknownNames
,    "IClassFactory", apszIClassFactoryNames
,    "IMarshal", apszIMarshalNames
,    "IStdMarshalInfo", apszIStdMarshalInfoNames
,    "IMessageFilter", apszIMessageFilterNames
,    "IExternalConnection", apszIExternalConnectionNames
,    "IEnumString", apszIEnumStringNames
,    "IEnumUnknown", apszIEnumUnknownNames
,    "IEnumSTATSTG", apszIEnumSTATSTGNames
,    "ILockBytes", apszILockBytesNames
,    "IStream", apszIStreamNames
,    "IStorage", apszIStorageNames
,    "IRootStorage", apszIRootStorageNames
,    "IEnumFORMATETC", apszIEnumFORMATETCNames
,    "IEnumSTATDATA", apszIEnumSTATDATANames
,    "IDataObject", apszIDataObjectNames
,    "IViewObject", apszIViewObjectNames
,    "IViewObject2", apszIViewObject2Names
,    "IAdviseSink", apszIAdviseSinkNames
,    "IAdviseSink2", apszIAdviseSink2Names
,    "IDataAdviseHolder", apszIDataAdviseHolderNames
,    "IOleCache", apszIOleCacheNames
,    "IOleCache2", apszIOleCache2Names
,    "IOleCacheControl", apszIOleCacheControlNames
,    "IDropTarget", apszIDropTargetNames
,    "IDropSource", apszIDropSourceNames
,    "IPersist", apszIPersistNames
,    "IPersistStorage", apszIPersistStorageNames
,    "IPersistStream", apszIPersistStreamNames
,    "IPersistFile", apszIPersistFileNames
,    "IBindCtx", apszIBindCtxNames
,    "IMoniker", apszIMonikerNames
,    "IRunningObjectTable", apszIRunningObjectTableNames
,    "IEnumMoniker", apszIEnumMonikerNames
,    "IEnumOLEVERB", apszIEnumOLEVERBNames
,    "IOleObject", apszIOleObjectNames
,    "IOleClientSite", apszIOleClientSiteNames
,    "IRunnableObject", apszIRunnableObjectNames
,    "IParseDisplayName", apszIParseDisplayNameNames
,    "IOleContainer", apszIOleContainerNames
,    "IOleItemContainer", apszIOleItemContainerNames
,    "IOleAdviseHolder", apszIOleAdviseHolderNames
,    "IOleLink", apszIOleLinkNames
,    "IOleWindow", apszIOleWindowNames
,    "IOleInPlaceObject", apszIOleInPlaceObjectNames
,    "IOleInPlaceActiveObject", apszIOleInPlaceActiveObjectNames
,    "IOleInPlaceUIWindow", apszIOleInPlaceUIWindowNames
,    "IOleInPlaceFrame", apszIOleInPlaceFrameNames
,    "IOleInPlaceSite", apszIOleInPlaceSiteNames
,    "IRpcChannelBuffer", apszIRpcChannelBufferNames
,    "IRpcProxyBuffer", apszIRpcProxyBufferNames
,    "IRpcStubBuffer", apszIRpcStubBufferNames
,    "IPSFactoryBuffer", apszIPSFactoryBufferNames
,    "IRpcChannel", apszIRpcChannelNames
,    "IRpcProxy", apszIRpcProxyNames
,    "IRpcStub", apszIRpcStubNames
,    "IPSFactory", apszIPSFactoryNames
};

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\olethk32\dbgint.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	dbgint.cxx
//
//  Notes:	This file is automatically generated
//		Do not modify by hand
//
//  History:	Fri May 27 10:39:02 1994	Generated
//
//----------------------------------------------------------------------------

#if DBG == 1

char *apszIUnknownNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
};
char *apszIClassFactoryNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "CreateInstance"
,    "LockServer"
};
char *apszIMarshalNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetUnmarshalClass"
,    "GetMarshalSizeMax"
,    "MarshalInterface"
,    "UnmarshalInterface"
,    "ReleaseMarshalData"
,    "DisconnectObject"
};
char *apszIStdMarshalInfoNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetClassForHandler"
};
char *apszIMessageFilterNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "HandleInComingCall"
,    "RetryRejectedCall"
,    "MessagePending"
};
char *apszIExternalConnectionNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "AddConnection"
,    "ReleaseConnection"
};
char *apszIEnumStringNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Next"
,    "Skip"
,    "Reset"
,    "Clone"
};
char *apszIEnumUnknownNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Next"
,    "Skip"
,    "Reset"
,    "Clone"
};
char *apszIEnumSTATSTGNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Next"
,    "Skip"
,    "Reset"
,    "Clone"
};
char *apszILockBytesNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "ReadAt"
,    "WriteAt"
,    "Flush"
,    "SetSize"
,    "LockRegion"
,    "UnlockRegion"
,    "Stat"
};
char *apszIStreamNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Read"
,    "Write"
,    "Seek"
,    "SetSize"
,    "CopyTo"
,    "Commit"
,    "Revert"
,    "LockRegion"
,    "UnlockRegion"
,    "Stat"
,    "Clone"
};
char *apszIStorageNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "CreateStream"
,    "OpenStream"
,    "CreateStorage"
,    "OpenStorage"
,    "CopyTo"
,    "MoveElementTo"
,    "Commit"
,    "Revert"
,    "EnumElements"
,    "DestroyElement"
,    "RenameElement"
,    "SetElementTimes"
,    "SetClass"
,    "SetStateBits"
,    "Stat"
};
char *apszIRootStorageNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "SwitchToFile"
};
char *apszIEnumFORMATETCNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Next"
,    "Skip"
,    "Reset"
,    "Clone"
};
char *apszIEnumSTATDATANames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Next"
,    "Skip"
,    "Reset"
,    "Clone"
};
char *apszIDataObjectNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetData"
,    "GetDataHere"
,    "QueryGetData"
,    "GetCanonicalFormatEtc"
,    "SetData"
,    "EnumFormatEtc"
,    "DAdvise"
,    "DUnadvise"
,    "EnumDAdvise"
};
char *apszIViewObjectNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Draw"
,    "GetColorSet"
,    "Freeze"
,    "Unfreeze"
,    "SetAdvise"
,    "GetAdvise"
};
char *apszIViewObject2Names[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Draw"
,    "GetColorSet"
,    "Freeze"
,    "Unfreeze"
,    "SetAdvise"
,    "GetAdvise"
,    "GetExtent"
};
char *apszIAdviseSinkNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "OnDataChange"
,    "OnViewChange"
,    "OnRename"
,    "OnSave"
,    "OnClose"
};
char *apszIAdviseSink2Names[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "OnDataChange"
,    "OnViewChange"
,    "OnRename"
,    "OnSave"
,    "OnClose"
,    "OnLinkSrcChange"
};
char *apszIDataAdviseHolderNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Advise"
,    "Unadvise"
,    "EnumAdvise"
,    "SendOnDataChange"
};
char *apszIOleCacheNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Cache"
,    "Uncache"
,    "EnumCache"
,    "InitCache"
,    "SetData"
};
char *apszIOleCache2Names[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Cache"
,    "Uncache"
,    "EnumCache"
,    "InitCache"
,    "SetData"
,    "UpdateCache"
,    "DiscardCache"
};
char *apszIOleCacheControlNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "OnRun"
,    "OnStop"
};
char *apszIDropTargetNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "DragEnter"
,    "DragOver"
,    "DragLeave"
,    "Drop"
};
char *apszIDropSourceNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "QueryContinueDrag"
,    "GiveFeedback"
};
char *apszIPersistNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetClassID"
};
char *apszIPersistStorageNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetClassID"
,    "IsDirty"
,    "InitNew"
,    "Load"
,    "Save"
,    "SaveCompleted"
,    "HandsOffStorage"
};
char *apszIPersistStreamNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetClassID"
,    "IsDirty"
,    "Load"
,    "Save"
,    "GetSizeMax"
};
char *apszIPersistFileNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetClassID"
,    "IsDirty"
,    "Load"
,    "Save"
,    "SaveCompleted"
,    "GetCurFile"
};
char *apszIBindCtxNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "RegisterObjectBound"
,    "RevokeObjectBound"
,    "ReleaseBoundObjects"
,    "SetBindOptions"
,    "GetBindOptions"
,    "GetRunningObjectTable"
,    "RegisterObjectParam"
,    "GetObjectParam"
,    "EnumObjectParam"
,    "RevokeObjectParam"
};
char *apszIMonikerNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetClassID"
,    "IsDirty"
,    "Load"
,    "Save"
,    "GetSizeMax"
,    "BindToObject"
,    "BindToStorage"
,    "Reduce"
,    "ComposeWith"
,    "Enum"
,    "IsEqual"
,    "Hash"
,    "IsRunning"
,    "GetTimeOfLastChange"
,    "Inverse"
,    "CommonPrefixWith"
,    "RelativePathTo"
,    "GetDisplayName"
,    "ParseDisplayName"
,    "IsSystemMoniker"
};
char *apszIRunningObjectTableNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Register"
,    "Revoke"
,    "IsRunning"
,    "GetObject"
,    "NoteChangeTime"
,    "GetTimeOfLastChange"
,    "EnumRunning"
};
char *apszIEnumMonikerNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Next"
,    "Skip"
,    "Reset"
,    "Clone"
};
char *apszIEnumOLEVERBNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Next"
,    "Skip"
,    "Reset"
,    "Clone"
};
char *apszIOleObjectNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "SetClientSite"
,    "GetClientSite"
,    "SetHostNames"
,    "Close"
,    "SetMoniker"
,    "GetMoniker"
,    "InitFromData"
,    "GetClipboardData"
,    "DoVerb"
,    "EnumVerbs"
,    "Update"
,    "IsUpToDate"
,    "GetUserClassID"
,    "GetUserType"
,    "SetExtent"
,    "GetExtent"
,    "Advise"
,    "Unadvise"
,    "EnumAdvise"
,    "GetMiscStatus"
,    "SetColorScheme"
};
char *apszIOleClientSiteNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "SaveObject"
,    "GetMoniker"
,    "GetContainer"
,    "ShowObject"
,    "OnShowWindow"
,    "RequestNewObjectLayout"
};
char *apszIRunnableObjectNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetRunningClass"
,    "Run"
,    "IsRunning"
,    "LockRunning"
,    "SetContainedObject"
};
char *apszIParseDisplayNameNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "ParseDisplayName"
};
char *apszIOleContainerNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "ParseDisplayName"
,    "EnumObjects"
,    "LockContainer"
};
char *apszIOleItemContainerNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "ParseDisplayName"
,    "EnumObjects"
,    "LockContainer"
,    "GetObject"
,    "GetObjectStorage"
,    "IsRunning"
};
char *apszIOleAdviseHolderNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Advise"
,    "Unadvise"
,    "EnumAdvise"
,    "SendOnRename"
,    "SendOnSave"
,    "SendOnClose"
};
char *apszIOleLinkNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "SetUpdateOptions"
,    "GetUpdateOptions"
,    "SetSourceMoniker"
,    "GetSourceMoniker"
,    "SetSourceDisplayName"
,    "GetSourceDisplayName"
,    "BindToSource"
,    "BindIfRunning"
,    "GetBoundSource"
,    "UnbindSource"
,    "Update"
};
char *apszIOleWindowNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetWindow"
,    "ContextSensitiveHelp"
};
char *apszIOleInPlaceObjectNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetWindow"
,    "ContextSensitiveHelp"
,    "InPlaceDeactivate"
,    "UIDeactivate"
,    "SetObjectRects"
,    "ReactivateAndUndo"
};
char *apszIOleInPlaceActiveObjectNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetWindow"
,    "ContextSensitiveHelp"
,    "TranslateAccelerator"
,    "OnFrameWindowActivate"
,    "OnDocWindowActivate"
,    "ResizeBorder"
,    "EnableModeless"
};
char *apszIOleInPlaceUIWindowNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetWindow"
,    "ContextSensitiveHelp"
,    "GetBorder"
,    "RequestBorderSpace"
,    "SetBorderSpace"
,    "SetActiveObject"
};
char *apszIOleInPlaceFrameNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetWindow"
,    "ContextSensitiveHelp"
,    "GetBorder"
,    "RequestBorderSpace"
,    "SetBorderSpace"
,    "SetActiveObject"
,    "InsertMenus"
,    "SetMenu"
,    "RemoveMenus"
,    "SetStatusText"
,    "EnableModeless"
,    "TranslateAccelerator"
};
char *apszIOleInPlaceSiteNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetWindow"
,    "ContextSensitiveHelp"
,    "CanInPlaceActivate"
,    "OnInPlaceActivate"
,    "OnUIActivate"
,    "GetWindowContext"
,    "Scroll"
,    "OnUIDeactivate"
,    "OnInPlaceDeactivate"
,    "DiscardUndoState"
,    "DeactivateAndUndo"
,    "OnPosRectChange"
};
char *apszIRpcChannelBufferNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetBuffer"
,    "SendReceive"
,    "FreeBuffer"
,    "GetDestCtx"
,    "IsConnected"
};
char *apszIRpcProxyBufferNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Connect"
,    "Disconnect"
};
char *apszIRpcStubBufferNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Connect"
,    "Disconnect"
,    "Invoke"
,    "IsIIDSupported"
,    "CountRefs"
,    "DebugServerQueryInterface"
,    "DebugServerRelease"
};
char *apszIPSFactoryBufferNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "CreateProxy"
,    "CreateStub"
};
char *apszIRpcChannelNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "GetStream"
,    "Call"
,    "GetDestCtx"
,    "IsConnected"
};
char *apszIRpcProxyNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Connect"
,    "Disconnect"
};
char *apszIRpcStubNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "Connect"
,    "Disconnect"
,    "Invoke"
,    "IsIIDSupported"
,    "CountRefs"
};
char *apszIPSFactoryNames[] =
{
    "QueryInterface"
,    "AddRef"
,    "Release"
,    "CreateProxy"
,    "CreateStub"
};

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\olethk32\dllentry.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	dllentry.cxx
//
//  Contents:	DLL entry point code
//
//  History:	24-Feb-94	DrewB	Created
//
//----------------------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

extern "C"
{
BOOL WINAPI _CRT_INIT (HANDLE hDll, DWORD dwReason, LPVOID lpReserved);
BOOL __cdecl LibMain (HANDLE hDll, DWORD dwReason, LPVOID lpReserved);
};

extern "C" BOOL __stdcall DllEntryPoint (HANDLE hDll, DWORD dwReason,
                                         LPVOID lpReserved)
{
    BOOL fRc;

    if ((dwReason == DLL_PROCESS_ATTACH) || (dwReason == DLL_THREAD_ATTACH))
    {
        // If this is an attach, initialize the Cruntimes first
        if (fRc = _CRT_INIT(hDll, dwReason, lpReserved))
        {
            fRc = LibMain(hDll, dwReason, lpReserved);
        }
    }
    else
    {
        // This is a detach so call the Cruntimes second
        LibMain(hDll, dwReason, lpReserved);
        fRc = _CRT_INIT(hDll, dwReason, lpReserved);
    }

    return fRc;
}

extern "C" BOOL __stdcall DllMain (HANDLE hDll, DWORD dwReason,
                                         LPVOID lpReserved)
{
    //  This is not currently used...but must be present to avoid
    //  an undefined symbol

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\olethk32\headers.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       headers.cxx
//
//  Contents:   Precompiled headers file
//
//  History:    21-Feb-94       DrewB   Created
//
//----------------------------------------------------------------------------

extern "C" {
#include <malloc.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wownt32.h>
}

#include <ole2.h>
#include <olecoll.h>
#include <privguid.h>
#include <ole2sp.h>
#include <ole2com.h>
#include <utils.h>
#include <memapi.hxx>

#include <interop.hxx>
#include <wow32fn.h>
#include <thunkapi.hxx>
#include <stksw.hxx>
#include "mmodel.hxx"
#include "stalloc.hxx"
#include "nest.hxx"
#include "olethk32.hxx"
#include "map_kv.h"
#include "map_dwp.h"
#include "obj16.hxx"
#include "thkmgr.hxx"
#include "freelist.hxx"
#include "cthkmgr.hxx"

#include "tlsthk.hxx"
#include "thop.hxx"
#include "thi.hxx"
#include "the.hxx"
#include "thopapi.hxx"
#include "thopint.hxx"
#include "inv16.hxx"
#include "alias.hxx"
#include "thoputil.hxx"
#include "apinot.hxx"

#if DBG == 1
#include "dbginv.hxx"
#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\olethk32\freelist.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	freelist.cxx
//
//  Contents:	CFreeList implementations
//
//  History:	07-Jul-94	BobDay	Created
//
//----------------------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

//
// Each element, when it is free, has a pointer stored within it that
// points to the next free element.  We can do this because we know that
// the element is free, all of its data is unused. These pointers are used
// as DWORDs since they can be virtual pointers (16:16).
//
#define CALC_NEXTPTR(lpElement) \
            ((LPDWORD)((DWORD)(lpElement) + m_iNextPtrOffset))

//
// Each block of elements has a pointer to the next block of elements. We
// allocate extra room for this pointer just after all of the elements within
// the block.  These pointers are used as DWORDs since they can be virtual
// pointers (16:16).

#define CALC_BLOCKNEXTPTR(lpBlock,dwElementSectionSize) \
            ((LPDWORD)((DWORD)(lpBlock) + (dwElementSectionSize)))

//
// Here are our global free lists, created on DLL load
// The block sizes are generally -1 to allow space for block
// list overhead
//
CFreeList flFreeList16(       // THUNK1632OBJ free list
    &mmodel16Public,
    sizeof(THUNK1632OBJ),
    63,
    FIELD_OFFSET(THUNK1632OBJ, pphHolder));

CFreeList flFreeList32(       // THUNK3216OBJ free list
    &mmodel32,
    sizeof(THUNK3216OBJ),
    63,
    FIELD_OFFSET(THUNK3216OBJ, pphHolder));

CFreeList flHolderFreeList(   // PROXYHOLDER free list
    &mmodel32,
    sizeof(PROXYHOLDER),
    63,
    FIELD_OFFSET(PROXYHOLDER, dwFlags));

CFreeList flRequestFreeList(  // IID request free list
    &mmodel32,
    sizeof(IIDNODE),
    7,
    FIELD_OFFSET(IIDNODE, pNextNode));

//+---------------------------------------------------------------------------
//
//  Method:     CFreeList::CFreeList
//
//  Arguments:  pmm - Memory model to use
//              iElementSize - The size of the structure being made into a
//                             free list. e.g. sizeof THUNK1632OBJ
//              iElementsPerBlock - How many elements to allocate at a time
//                                  (a block contains this many elements).
//              iNextPtrOffset - Offset within the element's structure for
//                               the place to store the free list's next
//                               element pointer.  Sometimes (for debugging,
//                               etc.) it is desirable to make this NOT 0
//                               (the beginning of the element structure).
//
//  Synopsis:   constructor for CFreeList class
//
//  History:    6-01-94   JohannP (Johann Posch)   Created
//              7-05-94   BobDay (Bob Day)   Changed it to be list based
//
//----------------------------------------------------------------------------
CFreeList::CFreeList( CMemoryModel *pmm,
                      UINT iElementSize,
                      UINT iElementsPerBlock,
                      UINT iNextPtrOffset )
{
    //
    // Save away the allocator information
    //
    m_pmm = pmm;
    m_iElementSize = iElementSize;
    m_iElementsPerBlock = iElementsPerBlock;
    m_iNextPtrOffset = iNextPtrOffset;

    //
    // Set the list of elements to empty
    //
    m_dwHeadElement = 0;
    m_dwTailElement = 0;

    //
    // Set the list of blocks to empty
    //
    m_dwHeadBlock  = 0;
}

//+---------------------------------------------------------------------------
//
//  Method:     CFreeList::AllocElement
//
//  Synopsis:   Allocates an element from the various blocks of elements
//              and allocates a new block if necessary.
//
//  Returns:    0 if failed to alloc an element,
//              otherwise the DWORD representing the alloc'd element.
//
//  History:    7-05-94   BobDay (Bob Day) Created
//
//----------------------------------------------------------------------------
DWORD CFreeList::AllocElement( void )
{
    DWORD   dwNewHeadBlock;
    DWORD   dwElementSectionSize;
    DWORD   dwBlockSize;
    LPVOID  lpBlock;
    UINT    iCnt;
    DWORD   dwElement;
    LPVOID  lpElement;
    LPDWORD lpElementNextPtr;

    //
    // If the list of available elements is empty, callback to the derived
    // class and make them add an entire new block of elements.
    //
    if ( m_dwHeadElement == 0 )
    {
        //
        // Allocate a new block
        //
        iCnt = m_iElementsPerBlock;
        dwElementSectionSize = m_iElementSize * m_iElementsPerBlock;

        //
        // Here we allocate an extra DWORD so that we can store in the block
        // the address of the next block.  In this way we have a list of
        // blocks so that when the time comes to free them, we can find them
        // all.
        //
        dwBlockSize = dwElementSectionSize + sizeof(DWORD);

        dwNewHeadBlock = m_pmm->AllocMemory( dwBlockSize );

        if ( dwNewHeadBlock == 0 )
        {
            //
            // Yikes, the block allocator failed!
            //
            thkDebugOut((DEB_ERROR,
                         "CFreeList::AllocElement, AllocMemory failed\n"));
            return 0;
        }
        //
        // Now initialize the block and link it into the block list.
        //

        lpBlock = m_pmm->ResolvePtr( dwNewHeadBlock, dwBlockSize );
        if ( lpBlock == NULL )
        {
            //
            // Couldn't get a pointer to the block, some memory mapping
            // problem?
            //
            thkDebugOut((DEB_ERROR,
                         "CFreeList::AllocElement, "
                         "ResolvePtr for block failed "
                         "for address %08lX, size %08lX\n",
                         dwNewHeadBlock, dwBlockSize ));
            // Try to return bad block to pool
            m_pmm->FreeMemory( dwNewHeadBlock );
            return 0;
        }

#if DBG == 1
        // 0xDE = Alloc'd but not init'd
        memset( lpBlock, 0xDE, dwBlockSize );
#endif

        //
        // Make this block point to the previous block
        //
        *CALC_BLOCKNEXTPTR(lpBlock,dwElementSectionSize) = m_dwHeadBlock;
        m_dwHeadBlock = dwNewHeadBlock;     // Update block list

        m_pmm->ReleasePtr(dwNewHeadBlock);

        //
        // Now initialize all of the elements within the block to be free.
        //
        // The below loop skips the first element, free's all of the remaining
        // ones.  This way we can return the first one and all of the rest will
        // be in accending order; The order doesn't really matter, but its
        // nice.
        //
        dwElement = dwNewHeadBlock;

        while ( iCnt > 1 )              // Free n-1 items (we skip the first)
        {
            --iCnt;
            dwElement += m_iElementSize;    // Skip to next one (miss 1st one)

            FreeElement( dwElement );
        }

        dwElement = dwNewHeadBlock;     // Use the first one as our alloc'd one
    }
    else
    {
        // We better have some blocks by now
        thkAssert( m_dwHeadBlock != 0 );

        // Better have a "end of list" too!
        thkAssert( m_dwTailElement != 0 );

        //
        // Grab an available element off the top (head) of the list.
        //
        dwElement = m_dwHeadElement;

        lpElement = m_pmm->ResolvePtr( dwElement, m_iElementSize );
        if ( lpElement == NULL )
        {
            //
            // Yikes, we weren't able to get a pointer to the element!
            //
            thkDebugOut((DEB_ERROR,
                         "CFreeList::AllocElement, "
                         "ResolvePtr for element failed "
                         "for address %08lX, size %08lX\n",
                         dwElement, m_iElementSize ));
            return 0;
        }

        //
        // Update the list to reflect the fact that we just removed the head
        // and replace it with the one which was pointed to by the head.
        //
        lpElementNextPtr = CALC_NEXTPTR(lpElement);
        m_dwHeadElement = *lpElementNextPtr;

        m_pmm->ReleasePtr(dwElement);

        //
        // Also, if we are now at the end of the list, then the tail element
        // should point to nowhere (i.e. there is nothing to insert after).
        //
        if ( m_dwHeadElement == 0 )
        {
            m_dwTailElement = 0;
        }
    }

#if DBG == 1
    // Erase the memory being returned to highlight reuse of dead values

    lpElement = m_pmm->ResolvePtr( dwElement, m_iElementSize );
    memset( lpElement, 0xED, m_iElementSize );
    m_pmm->ReleasePtr(dwElement);

    thkDebugOut((DEB_ITRACE,
                 "CFreeList::AllocElement, allocated element at %08lX\n",
                 dwElement ));
#endif

    return dwElement;
}

//+---------------------------------------------------------------------------
//
//  Method:     CFreeList::FreeElement
//
//  Synopsis:   Un-Allocates an element from the various blocks of elements,
//              basically put the element back on the free list.
//
//  Arguments:  dwElement - Element to free
//
//  Returns:    -none-  Asserts if failed.
//
//  History:    7-05-94   BobDay (Bob Day) Created
//
//----------------------------------------------------------------------------
void CFreeList::FreeElement( DWORD dwElement )
{
    LPVOID  lpElement;
    LPDWORD lpElementNextPtr;
    DWORD   dwResolved;

    //
    // First, make sure we can set this new element's next element pointer
    // to zero (he's going to be a the end of the list).
    //
    lpElement = m_pmm->ResolvePtr( dwElement, m_iElementSize );
    if ( lpElement == NULL )
    {
        //
        // Yikes, we couldn't get a pointer to this element's place to store
        // its next pointer.
        //
        thkDebugOut((DEB_ERROR,
                     "CFreeList::FreeElement, "
                     "ResolvePtr failed for free'd element\n"
                     "for address %08lX, size %08lX\n",
                     dwElement, m_iElementSize ));
        thkAssert(FALSE && "CFreeList::FreeElement, "
                  "Resolve Ptr failed for free'd element\n");
        return;
    }

#if DBG == 1
    // Fill memory so its values can't be reused
    if ( fZapProxy )        // Not doing this is important for
                            // the "PrepareForCleanup" processing the OLE32
                            // does on thread detach.  ZapProxy can be used
                            // to turn it back on.
    {
        memset(lpElement, 0xDD, m_iElementSize);
    }
#endif

    lpElementNextPtr = CALC_NEXTPTR(lpElement);

    *lpElementNextPtr = 0;  // Zap his next pointer since he'll be on the end

    m_pmm->ReleasePtr(dwElement);

    //
    // Add this element back onto the end (tail) of the list.
    //
    if ( m_dwTailElement == 0 )
    {
        //
        // Well, the list was empty, time to set it up
        //
        thkAssert( m_dwHeadElement == 0 );

        lpElementNextPtr = &m_dwHeadElement;
        dwResolved = 0;
    }
    else
    {
        //
        // Ok, the list wasn't empty, so we add this new one onto the end.
        //
        thkAssert( m_dwHeadElement != 0 );

        dwResolved = m_dwTailElement;
        lpElement = m_pmm->ResolvePtr( m_dwTailElement, m_iElementSize );
        if ( lpElement == NULL )
        {
            //
            // Oh no, we couldn't get a pointer to the next element pointer for
            // the guy who is currently the tail of the list.
            //
            thkDebugOut((DEB_ERROR,
                         "CFreeList::FreeElement, "
                         "ResolvePtr failed for last element\n"
                         "for address %08lX, size %08lX\n",
                         m_dwTailElement, m_iElementSize ));
            thkAssert(FALSE && "CFreeList::FreeElement, "
                               "Resolve Ptr failed for last element\n");
            return;
        }

        lpElementNextPtr = CALC_NEXTPTR(lpElement);
    }

    //
    // Update our tail pointer to point to our newly free'd guy.
    //
    m_dwTailElement = dwElement;

    //
    // Make the last guy point to this newly free'd guy
    //
    *lpElementNextPtr = dwElement;

    if (dwResolved != 0)
    {
        m_pmm->ReleasePtr(dwResolved);
    }

    thkDebugOut((DEB_ITRACE,
                 "CFreeList::FreeElement, free'd element at %08lX\n",
                 dwElement ));
}

//+---------------------------------------------------------------------------
//
//  Method:     CFreeList::FreeMemoryBlocks
//
//  Arguments:  -none-
//
//  Returns:    -nothing-
//
//  Synopsis:   Called by derived destructors to allow them to free up their
//              contents before going away.
//
//  History:    7-05-94   BobDay (Bob Day)   Created it
//
//----------------------------------------------------------------------------

void CFreeList::FreeMemoryBlocks( void )
{
    DWORD   dwBlock;
    DWORD   dwElementSectionSize;
    DWORD   dwBlockSize;
    DWORD   dwNextBlock;
    LPVOID  lpBlock;

    //
    // Compute some constants for this list ahead of time
    //
    dwElementSectionSize = m_iElementSize * m_iElementsPerBlock;

    //
    // Add room for that extra DWORD, block next pointer. (See comment in
    // AllocElement where it allocates an extra DWORD)
    //
    dwBlockSize = dwElementSectionSize + sizeof(DWORD);

    //
    // Iterate through the list of blocks free'ing them
    //
    dwBlock = m_dwHeadBlock;

    while( dwBlock != 0 )
    {
        //
        // Find the next block ptr
        //
        lpBlock = m_pmm->ResolvePtr( dwBlock, dwBlockSize );
        if ( lpBlock == NULL )
        {
            //
            // If we get an error here, we just drop out of loop
            //
            dwNextBlock = 0;
        }
        else
        {
            dwNextBlock = *CALC_BLOCKNEXTPTR(lpBlock,dwElementSectionSize);

#if DBG == 1
            memset(lpBlock, 0xEE, dwBlockSize);
#endif

            m_pmm->ReleasePtr(dwBlock);
            m_pmm->FreeMemory( dwBlock );
        }
        dwBlock = dwNextBlock;
    }

    m_dwHeadElement = 0;
    m_dwTailElement = 0;
    m_dwHeadBlock = 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\olethk32\heap.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1995.
//
//  File:       heap.cxx
//
//  Contents:   memory management
//
//  Classes:
//
//  Functions:  operator new
//              operator delete
//
//  History:    5-Dec-95 JeffE    Created
//
//--------------------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   operator new, public
//
//  Synopsis:   Global operator new which does not throw exceptions.
//
//  Arguments:  [size] -- Size of the memory to allocate.
//
//  Returns:	A pointer to the allocated memory.  Is *NOT* initialized to 0!
//
//  Notes:	We override new to make delete easier.
//
//----------------------------------------------------------------------------
void* __cdecl
operator new (size_t size)
{
    return(CoTaskMemAlloc(size));
}


//+-------------------------------------------------------------------------
//
//  Function:	::operator delete
//
//  Synopsis:	Free a block of memory
//
//  Arguments:	[lpv] - block to free.
//
//  History:	18-Nov-92 Ricksa    Created
//
//--------------------------------------------------------------------------

void __cdecl operator delete(void FAR* lpv)
{
    CoTaskMemFree (lpv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\olethk32\iidtothi.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	iidtothi.cxx
//
//  Notes:	This file is automatically generated
//		Do not modify by hand
//
//  History:	Fri May 27 10:39:02 1994	Generated
//
//----------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#include <coguid.h>
#include <oleguid.h>
IIDTOTHI CONST aittIidToThi[] =
{
    &IID_IUnknown, THI_IUnknown
,    &IID_IClassFactory, THI_IClassFactory
,    &IID_IMarshal, THI_IMarshal
,    &IID_IStdMarshalInfo, THI_IStdMarshalInfo
,    &IID_IMessageFilter, THI_IMessageFilter
,    &IID_IExternalConnection, THI_IExternalConnection
,    &IID_IEnumString, THI_IEnumString
,    &IID_IEnumUnknown, THI_IEnumUnknown
,    &IID_IEnumSTATSTG, THI_IEnumSTATSTG
,    &IID_ILockBytes, THI_ILockBytes
,    &IID_IStream, THI_IStream
,    &IID_IStorage, THI_IStorage
,    &IID_IRootStorage, THI_IRootStorage
,    &IID_IEnumFORMATETC, THI_IEnumFORMATETC
,    &IID_IEnumSTATDATA, THI_IEnumSTATDATA
,    &IID_IDataObject, THI_IDataObject
,    &IID_IViewObject, THI_IViewObject
,    &IID_IViewObject2, THI_IViewObject2
,    &IID_IAdviseSink, THI_IAdviseSink
,    &IID_IAdviseSink2, THI_IAdviseSink2
,    &IID_IDataAdviseHolder, THI_IDataAdviseHolder
,    &IID_IOleCache, THI_IOleCache
,    &IID_IOleCache2, THI_IOleCache2
,    &IID_IOleCacheControl, THI_IOleCacheControl
,    &IID_IDropTarget, THI_IDropTarget
,    &IID_IDropSource, THI_IDropSource
,    &IID_IPersist, THI_IPersist
,    &IID_IPersistStorage, THI_IPersistStorage
,    &IID_IPersistStream, THI_IPersistStream
,    &IID_IPersistFile, THI_IPersistFile
,    &IID_IBindCtx, THI_IBindCtx
,    &IID_IMoniker, THI_IMoniker
,    &IID_IRunningObjectTable, THI_IRunningObjectTable
,    &IID_IEnumMoniker, THI_IEnumMoniker
,    &IID_IEnumOLEVERB, THI_IEnumOLEVERB
,    &IID_IOleObject, THI_IOleObject
,    &IID_IOleClientSite, THI_IOleClientSite
,    &IID_IRunnableObject, THI_IRunnableObject
,    &IID_IParseDisplayName, THI_IParseDisplayName
,    &IID_IOleContainer, THI_IOleContainer
,    &IID_IOleItemContainer, THI_IOleItemContainer
,    &IID_IOleAdviseHolder, THI_IOleAdviseHolder
,    &IID_IOleLink, THI_IOleLink
,    &IID_IOleWindow, THI_IOleWindow
,    &IID_IOleInPlaceObject, THI_IOleInPlaceObject
,    &IID_IOleInPlaceActiveObject, THI_IOleInPlaceActiveObject
,    &IID_IOleInPlaceUIWindow, THI_IOleInPlaceUIWindow
,    &IID_IOleInPlaceFrame, THI_IOleInPlaceFrame
,    &IID_IOleInPlaceSite, THI_IOleInPlaceSite
,    &IID_IRpcChannelBuffer, THI_IRpcChannelBuffer
,    &IID_IRpcProxyBuffer, THI_IRpcProxyBuffer
,    &IID_IRpcStubBuffer, THI_IRpcStubBuffer
,    &IID_IPSFactoryBuffer, THI_IPSFactoryBuffer
,    &IID_IRpcChannel, THI_IRpcChannel
,    &IID_IRpcProxy, THI_IRpcProxy
,    &IID_IRpcStub, THI_IRpcStub
,    &IID_IPSFactory, THI_IPSFactory
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\olethk32\inv16.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       inv16.cxx
//
//  Contents:   32->16 Call thunking
//
//  History:    25-Feb-94       DrewB   Created
//
//----------------------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

#include "..\..\ole232\inc\le2int.h"        // Include le2int.h before inplace.h
#include "..\..\ole232\inplace\inplace.h"   // We need CFrameFilter for
                                            // WinWord 6 Hack

//+---------------------------------------------------------------------------
//
//  Function:   InvokeOn16, public
//
//  Synopsis:   Sets up the THUNKINFO and starts thunking for a 32->16 call
//
//  Arguments:  [iidx] - Custom interface or known interface index
//              [dwMethod] - Method index
//              [pvStack32] - 32-bit stack
//
//  Returns:    Appropriate status code
//
//  History:    25-Feb-94       DrewB   Created
//
//----------------------------------------------------------------------------

#if DBG == 1
extern "C"
{
ULONG InvokeOn16_count = 0;
ULONG InvokeOn16_break = 0;

int _iInvokeOn16BreakIidx = -1;
int _iInvokeOn16BreakMethod = -1;
};
#endif

// InvokeOn16 uses a lot of local variables so allocate its locals
// rather than declaring them on the stack.  This saves roughly
// 150 bytes of stack per call

struct INVOKE16RECORD
{
    THOP CONST        *pThop;
    THOP CONST        * CONST *ppThop;
    UINT        uiThop;
    VTBLFN UNALIGNED CONST *pvfnVtbl;
    VPVOID      vpvThis16;
    VPVOID      vpvVtbl16;
    VPVOID UNALIGNED CONST *pvpvThis16;
    DWORD       dwStack16[MAX_PARAMS];
    THUNKINFO   ti;
    THUNK3216OBJ *ptoThis32;
    ThreadData  *ptd;
};

DWORD InvokeOn16(IIDIDX iidx, DWORD dwMethod, LPVOID pvStack32)
{
    // NOTE: Do not declare local variables in this routine
    // except for debug builds
    INVOKE16RECORD *pir;
    DWORD dwResult;

#if DBG == 1
    ULONG ulInvokeOn16_count = ++InvokeOn16_count;
    if (InvokeOn16_count == InvokeOn16_break)
    {
        DebugBreak();
    }

    thkDebugOut((DEB_ITRACE, "%sInvokeOn16(0x%x, 0x%x, %p)\n",
                 NestingLevelString(), iidx, dwMethod, pvStack32));
#endif

    pir = (INVOKE16RECORD *)STACKALLOC32(sizeof(INVOKE16RECORD));
    if (pir == NULL)
    {
        // This error isn't guaranteed to mean anything for
        // this call.  Not much else we can do, though
        return (DWORD)E_OUTOFMEMORY;
    }

    // pvStack32 is a pointer to an array of arguments from the
    // 32-bit call.  It's always laid out with the first
    // argument low and increasing from there

    pir->ti.s32.pbStart = (BYTE *)pvStack32;
    pir->ti.s32.pbCurrent = pir->ti.s32.pbStart;

    pir->ti.s16.pbStart = (BYTE *)pir->dwStack16;
    pir->ti.s16.pbCurrent = pir->ti.s16.pbStart;

    pir->ti.scResult = S_OK;
    pir->ti.fResultThunked = FALSE;

    pir->ptd = TlsThkGetData();
    if (pir->ptd == NULL)
    {
        thkDebugOut((DEB_WARN, "WARNING: InvokeOn16: Call refused\n"));

        STACKFREE32(pir, sizeof(INVOKE16RECORD));
        return (DWORD)E_FAIL;
    }

    pir->ti.pThkMgr = pir->ptd->pCThkMgr;
    thkAssert(pir->ti.pThkMgr != NULL);

    thkAssert(iidx < THI_COUNT);

    // For each interface there is an array of thop strings, one for
    // each method.  The IUnknown methods don't have thop strings so
    // bias the thop string pointer to account for that

    thkAssert(dwMethod >= SMI_COUNT);

    pir->ppThop = athopiInterfaceThopis[iidx].ppThops-SMI_COUNT;
    pir->uiThop = athopiInterfaceThopis[iidx].uiSize;

    // Methods are cdecl so we need to move upwards in memory to
    // get to the next parameter
    pir->ti.s16.iDir = 1;

    // We need to look up the appropriate method pointer by
    // looking in the 16-bit object's vtable
    GET_STACK32(&pir->ti, pir->ptoThis32, THUNK3216OBJ *);

    thkDebugOut((DEB_INVOKES,
                 "InvokeOn16: ptoThis32 = %08lX\n", pir->ptoThis32 ));

    if ( pir->ptoThis32->grfFlags & PROXYFLAG_CLEANEDUP )
    {
        thkDebugOut((DEB_WARN,
                     "InvokeOn16: Attempt to call %s::%s"
                     "on cleaned-up proxy %08lX for 16-bit object %08lX\n",
                     inInterfaceNames[iidx].pszInterface,
                     inInterfaceNames[iidx].ppszMethodNames[dwMethod],
                     pir->ptoThis32, pir->ptoThis32->vpvThis16));
        STACKFREE32(pir, sizeof(INVOKE16RECORD));
        return (DWORD)E_FAIL;
    }

    // check PROXYFLAG_CLEANEDUP before calling DebugValidateProxy3216.
    // Otherwise we might get asserts on checked OLE.
    DebugValidateProxy3216(pir->ptoThis32);

    pir->ti.dwCallerProxy = (DWORD)pir->ptoThis32;
    pir->vpvThis16 = pir->ptoThis32->vpvThis16;
    pir->pvpvThis16 = (VPVOID UNALIGNED *)
        GetReadPtr16(&pir->ti, pir->vpvThis16, sizeof(VPVOID));
    if (pir->pvpvThis16 == NULL)
    {
        dwResult = pir->ti.scResult;
        STACKFREE32(pir, sizeof(INVOKE16RECORD));
        return dwResult;
    }

    pir->vpvVtbl16 = *pir->pvpvThis16;
    pir->pvfnVtbl = (VTBLFN UNALIGNED *)
        GetReadPtr16(&pir->ti, pir->vpvVtbl16, sizeof(VPVOID)*pir->uiThop);

    WOWRELVDMPTR(pir->vpvThis16);

    if (pir->pvfnVtbl == NULL)
    {
        dwResult = pir->ti.scResult;
        STACKFREE32(pir, sizeof(INVOKE16RECORD));
        return dwResult;
    }

    // Push the 16-bit this pointer on the stack first
    TO_STACK16(&pir->ti, pir->vpvThis16, VPVOID);

    thkAssert(dwMethod < pir->uiThop);

    pir->pThop = pir->ppThop[dwMethod];

    thkAssert(pir->pThop != NULL);

    pir->ti.pThop = pir->pThop;
    pir->ti.pvfn  = pir->pvfnVtbl[dwMethod];
    pir->ti.iidx  = iidx;
    pir->ti.dwMethod = dwMethod;
    pir->ti.this32   = (IUnknown *)pir->ptoThis32;

    WOWRELVDMPTR(pir->vpvVtbl16);

    thkDebugOut((DEB_INVOKES, "%s#(%04X):InvokeOn16 on %p:%p, %s::%s\n",
                 NestingLevelString(), ulInvokeOn16_count,
                 pir->vpvThis16, pir->ti.pvfn,
                 inInterfaceNames[iidx].pszInterface,
                 inInterfaceNames[iidx].ppszMethodNames[dwMethod]));

    DebugIncrementNestingLevel();

    pir->ti.pThkMgr->SetThkState(THKSTATE_INVOKETHKIN16);

#if DBG == 1
    SStackRecord sr;

    RecordStackState16(&sr);
#endif

#if DBG == 1
    if ((_iInvokeOn16BreakIidx > 0 && _iInvokeOn16BreakIidx == (int)iidx) &&
        (_iInvokeOn16BreakMethod < 0 ||
         _iInvokeOn16BreakMethod == (int)dwMethod))
    {
        DebugBreak();
    }
#endif

    dwResult = EXECUTE_THOP3216(&pir->ti);

#if DBG == 1

    if ( !pir->ti.fResultThunked && FAILED(dwResult) )
    {
        thkDebugOut((DEB_FAILURES,
                     "InvokeOn16 probable failure %s::%s sc = %08lX\n",
                     inInterfaceNames[iidx].pszInterface,
                     inInterfaceNames[iidx].ppszMethodNames[dwMethod],
                     dwResult));
        if(thkInfoLevel & DEB_DBGFAIL)
            thkAssert(!"Wish to Debug");
    }

    CheckStackState16(&sr);

#endif

    pir->ti.pThkMgr->SetThkState(THKSTATE_NOCALL);

    DebugDecrementNestingLevel();

    thkDebugOut((DEB_INVOKES,
                 "%s#(%04X):InvokeOn16 on %p:%p, %s::%s returns 0x%08lX\n",
                 NestingLevelString(), ulInvokeOn16_count,
                 pir->vpvThis16, pir->ti.pvfn,
                 inInterfaceNames[iidx].pszInterface,
                 inInterfaceNames[iidx].ppszMethodNames[dwMethod],
                 dwResult));

    STACKFREE32(pir, sizeof(INVOKE16RECORD));

    return dwResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   Call3216, private
//
//  Synopsis:   Sets up stack and transitions to 16-bit
//
//  Arguments:  [pvfn] - Function to call
//              [pbStack] - Stack in 32-bits
//              [cbStack] - Size of stack
//
//  Returns:    Appropriate status code
//
//  History:    04-Mar-94       DrewB   Created
//
//----------------------------------------------------------------------------
#if DBG == 1
extern "C" ULONG Call3216_count = 0;
extern "C" ULONG Call3216_break = 0;
#endif

DWORD Call3216(VPVOID pvfn, BYTE *pbStack, UINT cbStack)
{
#if DBG == 1
    ULONG ulCall3216_count = ++Call3216_count;
    if (Call3216_count == Call3216_break)
    {
	DebugBreak();
    }
#endif

    VPVOID vpvStack16;
    DWORD dwResult;
    void *pvStack16;

    dwResult = (DWORD)S_OK;

    if (cbStack <= WCB16_MAX_CBARGS)
    {
        thkDebugOut((DEB_ITRACE, "%sCallbackTo16Ex(%p, %lu, %p) #(%x)\n",
                     NestingLevelString(), pvfn, cbStack, pbStack, 
                     ulCall3216_count));

        // pbStack must have at least WCB16_MAX_CBARGS bytes of valid memory
        // since 16V always copies that many bytes

        // In our case pbStack is from InvokeOn16 which should be large enough
        thkAssert(MAX_PARAMS*sizeof(DWORD) >= WCB16_MAX_CBARGS);

        if (!CallbackTo16Ex(pvfn, WCB16_CDECL, cbStack, pbStack,
                             &dwResult))
        {
            dwResult = (DWORD)E_UNEXPECTED;
        }
    }
    else
    {
        CALLDATA UNALIGNED *pcd;
        UINT cbAlloc;

        cbAlloc = cbStack+sizeof(CALLDATA);

        vpvStack16 = STACKALLOC16(cbAlloc);
        if (vpvStack16 == 0)
        {
            dwResult = (DWORD)E_OUTOFMEMORY;
        }
        else
        {
            pvStack16 = (void *)WOWFIXVDMPTR(vpvStack16, cbAlloc);

            pcd = (CALLDATA UNALIGNED *)((BYTE *)pvStack16+cbStack);
            pcd->vpfn = (DWORD)pvfn;
            pcd->vpvStack16 = vpvStack16;
            pcd->cbStack = cbStack;

            memcpy(pvStack16, pbStack, cbStack);

            WOWRELVDMPTR(vpvStack16);

            thkDebugOut((DEB_ITRACE, "%sCallbackTo16(%p, (%p, %p, %lu)) #(%x)\n",
                         NestingLevelString(), gdata16Data.fnCallStub16, pvfn, 
                         vpvStack16, cbStack, ulCall3216_count));
            dwResult = CallbackTo16(gdata16Data.fnCallStub16,
                                     vpvStack16+cbStack);

            STACKFREE16(vpvStack16, cbAlloc);
        }
    }

    return dwResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   ThunkCall3216, public
//
//  Synopsis:   Sets up the 16-bit stack and makes a 32->16 call
//
//  Arguments:  [pti] - Thunk state info
//
//  Returns:    Appropriate status code
//
//  History:    25-Feb-94       DrewB   Created
//              08-Aug-94       AlexT   Add IOleClientSite::OnShowWindow code
//
//----------------------------------------------------------------------------

#if DBG == 1
extern "C" ULONG ThunkCall3216_count = 0;
extern "C" ULONG ThunkCall3216_break = 0;
#endif

DWORD ThunkCall3216(THUNKINFO *pti)
{
    DWORD dwReturn;
    UINT cbStack;
    DWORD dwCallerTID;
    HRESULT hrCaller;
    BOOL fFail = FALSE;

#if DBG == 1
    ULONG ulThunkCall3216_count = ++ThunkCall3216_count;
    thkAssert( (ThunkCall3216_count != ThunkCall3216_break) &&
               "Break Count Hit");
#endif

    thkAssert(*pti->pThop == THOP_END);
    pti->pThop++;
    thkAssert(*pti->pThop == THOP_ROUTINEINDEX);
    pti->pThop++;

    thkDebugOut((DEB_ITRACE, "%sIn ThunkCall3216 #(%x) %p, index %d\n",
                 NestingLevelString(), ulThunkCall3216_count, 
                 pti->pvfn, *pti->pThop));
    DebugIncrementNestingLevel();

    cbStack = (ULONG) (pti->s16.pbCurrent-pti->s16.pbStart);

    // The this pointer should always be on the stack
    thkAssert(cbStack >= sizeof(VPVOID));

    //
    // Hacks for specific interface member functions.
    // The placement of these hacks here is by no means an optimal solution.
    // It just happens to be convienient for now since everything goes through
    // here.  This section is for pre-processing.
    //
    if ( IIDIDX_IS_INDEX(pti->iidx) )
    {
        switch( IIDIDX_INDEX(pti->iidx) )
        {
        case THI_IOleClientSite:
#define METHOD_ONSHOWWINDOW 7
            if ( pti->dwMethod == METHOD_ONSHOWWINDOW )
            {
                //
                // Here we merge the input queues for the sole reason so that
                // we can link the object's window activations into the calling
                // thread's window z-order.
                //

                hrCaller = CoGetCallerTID( &dwCallerTID );

                if ( hrCaller == S_FALSE )
                {
                    AttachThreadInput( dwCallerTID, GetCurrentThreadId(),
                                       TRUE );
                }
            }
            break;

        case THI_IOleObject:
#define METHOD_DOVERB   11
            if ( pti->dwMethod == METHOD_DOVERB )
            {
                //
                // Here we merge the input queues for the sole reason so
                // that we can link the object's window activations into
                // the calling thread's window z-order.
                //

                hrCaller = CoGetCallerTID( &dwCallerTID );

                if ( hrCaller == S_FALSE )
                {
                    AttachThreadInput( dwCallerTID, GetCurrentThreadId(),
                                       TRUE );
                }
            }
            break;

        case THI_IRpcStubBuffer:
#define METHOD_DEBUGSERVER_QUERYINTERFACE   8
#define METHOD_DEBUGSERVER_RELEASE          9
            if(pti->dwMethod == METHOD_DEBUGSERVER_QUERYINTERFACE)
            {
                // This is badly designed method in the sense that
                // we do not know how to thunk the OUT interface
                // parameter returned by this method. The interface
                // may have been addrefed and may be not. We also do
                // not know the IID of the interface. At best, we can
                // thunk it as an IUnknown and not call release on the
                // actual interface when building it. We can then release
                // the proxy built above when DebugServerRelease is called
                // later. But, it will lead to an AV if the invoker of this
                // method invokes a non-IUnknown method on the thunked 
                // interface. In view of the above, I am failing the call
                // to this method. This is a more desirable behavior and 
                // Wx86 thunking also would not get affected by it.
                //         GopalK        Aug 18, 97.
                thkDebugOut((DEB_FAILURES, "Call on IRpcStubBuffer::DebugServerQueryInterface\n"));
                dwReturn = E_NOINTERFACE;
                fFail = TRUE;
            }
            else if(pti->dwMethod == METHOD_DEBUGSERVER_RELEASE)
            {
                // See comment for DebugServerQueryInterface
                thkAssert(!"Call on IRpcStubBuffer::DebugServerRelease");
                thkDebugOut((DEB_ERROR, "Call on IRpcStubBuffer::DebugServerRelease\n"));
                dwReturn = S_OK;
                fFail = TRUE;
            }
        
        default:
            break;
        }
    }

    if(!fFail)
    {
        pti->pThkMgr->SetThkState(THKSTATE_NOCALL);

        dwReturn = Call3216((VPVOID)pti->pvfn, pti->s16.pbStart, cbStack);

        pti->pThkMgr->SetThkState(THKSTATE_INVOKETHKOUT16);

        //
        // Hacks for specific interface member functions.
        // Again, the placement of these is by no means an optimal solution.
        // They can be moved as long as they have the same effect for just these
        // interfaces.  This section is for post-processing.
        //
        if ( IIDIDX_IS_INDEX(pti->iidx) )
        {
            switch( IIDIDX_INDEX(pti->iidx) )
            {
            case THI_IOleClientSite:
                if ( pti->dwMethod == METHOD_ONSHOWWINDOW )
                {
                    //
                    // Unmerge the input queues afterward.
                    //
                    if ( hrCaller == S_FALSE )
                    {
                        AttachThreadInput( dwCallerTID, GetCurrentThreadId(),
                                           FALSE );
                    }
                }
                break;

            case THI_IOleObject:
                if ( pti->dwMethod == METHOD_DOVERB )
                {
                    //
                    // Unmerge the input queues afterward.
                    //
                    if ( hrCaller == S_FALSE )
                    {
                        AttachThreadInput( dwCallerTID, GetCurrentThreadId(),
                                           FALSE );
                    }
                }

#define METHOD_GETCLIENTSITE    4
                if ( pti->dwMethod == METHOD_GETCLIENTSITE )
                {
                    //
                    // Excel 5.0a needs to perform some special processing
                    // on the way out of a IOleObject::GetClientSite call.
                    //  See CTHKMGR.CXX and APINOT.CXX for more details.
                    //
                    if ( TlsThkGetAppCompatFlags() & OACF_CLIENTSITE_REF )
                    {
                        //
                        // Tell the thkmgr that we are thunking a bad
                        // IOleObject::GetClientSite reference on the way out.
                        //
                        thkDebugOut((DEB_WARN,"TC3216: OACF_CLIENTSITE_REF used: "
                                     "Setting to clientsite thunk state\n"));

                        pti->pThkMgr->SetThkState(
                                THKSTATE_INVOKETHKOUT16_CLIENTSITE);
                    }
                }
                break;

            case THI_IOleInPlaceFrame:
#define METHOD_REMOVEMENUS  11
                //
                // Winword 6.0a didn't call OleSetMenuDescriptor(NULL)
                // during its IOleInPlaceFrame::RemoveMenus.  This leaves
                // OLE's frame filter in place.  The frame filter holds references
                // to some objects so everybody's refcounting gets thrown off
                // Here, when we see a RemoveMenus call completing we force
                // the OleSetMenuDescriptor(NULL) call to occur.  This shuts
                // down the frame filter and corrects the reference counts.
                //
                // There is one other hack necessary: Word unsubclasses the
                // window itself directly rather than going through
                // OleSetMenuDescriptor.  Therefore the frame filter code
                // is patched to only unhook if it detects that it is the
                // current hook
                //
                // See APINOT.CXX for more hack code.
                //
                if (pti->dwMethod == METHOD_REMOVEMENUS)
                {
                    if ( TlsThkGetAppCompatFlags() & OACF_RESETMENU )
                    {
                        HRESULT hr;
                        HWND    hwnd;
                        LPOLEINPLACEFRAME lpoipf;

                        pti->pThkMgr->SetThkState(THKSTATE_NOCALL);

                        lpoipf = (LPOLEINPLACEFRAME)pti->this32;
                        hr = lpoipf->GetWindow( &hwnd );

                        pti->pThkMgr->SetThkState(THKSTATE_INVOKETHKOUT16);

                        if ( FAILED(hr) )
                        {
                            break;
                        }

                        thkDebugOut((DEB_WARN,
                                     "TC3216: OACF_RESETMENU used: "
                                     "Setting menu descriptor "
                                     "to NULL on %p\n", hwnd));

                        OleSetMenuDescriptor(NULL, hwnd, NULL, NULL, NULL);
                    }
                }
                break;

            default:
                break;
            }
        }

        if ( !pti->fResultThunked )
        {
            dwReturn = TransformHRESULT_1632( dwReturn );

#if DBG == 1
            if (FAILED(dwReturn) )
            {
                thkDebugOut((DEB_FAILURES,
                             "Call3216 pvfn = %08lX Probably failed hr = %08lX\n",
                             pti->pvfn, dwReturn));
                if(thkInfoLevel & DEB_DBGFAIL)
                    thkAssert(!"Wish to Debug");
            }
#endif
        }
    }

    DebugDecrementNestingLevel();
    thkDebugOut((DEB_ITRACE, "%sOut ThunkCall3216 #(%x) returns 0x%08lX\n",
                 NestingLevelString(), ulThunkCall3216_count, dwReturn));
    return dwReturn;
}

//+---------------------------------------------------------------------------
//
//  Function:   SetOwnerPublicHMEM16, public
//
//  Synopsis:   Changes the 16-bit memory handle into a public selector, owned
//              by nobody.  This prevents any app from taking it away when it
//              is cleaned up.
//
//  Arguments:  [hmem] - 16-bit memory handle
//
//  Returns:    Appropriate status code
//
//  History:    13-Jul-94       BobDay      Created it
//
//----------------------------------------------------------------------------
void SetOwnerPublicHMEM16( DWORD hmem )
{
    CallbackTo16(gdata16Data.fnSetOwnerPublic16, hmem );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\olethk32\ichannel.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       ichannel.cxx
//
//  Contents:   Maps the RpcChannel to RpcChannelBuffer
//              This is required to support custom interface marshalling.
//
//  History:    24-Mar-94       JohannP   Created
//
//--------------------------------------------------------------------------


//
// the new 32 bit channel interface - buffer based
// 
class CRpcChannelBuffer : public IPpcChannelBuffer
{
public:
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid,void **ppvObject);
    ULONG STDMETHODCALLTYPE AddRef(void);
    ULONG STDMETHODCALLTYPE Release(void);

    HRESULT STDMETHODCALLTYPE GetBuffer(RPCOLEMESSAGE *pMessage,REFIID riid);
    HRESULT STDMETHODCALLTYPE SendReceive(RPCOLEMESSAGE *pMessage,ULONG *pStatus);
    HRESULT STDMETHODCALLTYPE FreeBuffer(RPCOLEMESSAGE *pMessage);
    HRESULT STDMETHODCALLTYPE GetDestCtx(DWORD *pdwDestContext,void **ppvDestContext);
    HRESULT STDMETHODCALLTYPE IsConnected( void);
};

// 16 bit channel interface - stream based
// class see by the 16 bit implemantation
// needs to be mapped to the RpcChannelBuffer
class CRpcChannel : public IRpcChannel  
{
    HRESULT STDMETHODCALLTYPE QueryInterface(REFIID riid,void **ppvObject);
    ULONG STDMETHODCALLTYPE AddRef(void);
    ULONG STDMETHODCALLTYPE Release(void);

    STDMETHOD(GetStream)(REFIID iid, int iMethod, BOOL fSend,
                     BOOL fNoWait, DWORD size, IStream FAR* FAR* ppIStream);
    STDMETHOD(Call)(IStream FAR* pIStream);
    STDMETHOD(GetDestCtx)(DWORD FAR* lpdwDestCtx, LPVOID FAR* lplpvDestCtx);
    STDMETHOD(IsConnected)(void);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\olethk32\fntomthd.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	fntomthd.cxx
//
//  Notes:	This file is automatically generated
//		Do not modify by hand
//
//  History:	Fri May 27 10:39:02 1994	Generated
//
//----------------------------------------------------------------------------

BYTE CONST ftmIClassFactory[] =
{
    3,
    4
};
BYTE CONST ftmIMarshal[] =
{
    6,
    0,
    0,
    0,
    8,
    7,
    0,
    3,
    4,
    5
};
BYTE CONST ftmIStdMarshalInfo[] =
{
    3,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};
BYTE CONST ftmIMessageFilter[] =
{
    4,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    3,
    5
};
BYTE CONST ftmIExternalConnection[] =
{
    0,
    0,
    3,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    4
};
BYTE CONST ftmIEnumString[] =
{
    0,
    0,
    0,
    0,
    6,
    4,
    5,
    0,
    0,
    0,
    0,
    3
};
BYTE CONST ftmIEnumUnknown[] =
{
    0,
    0,
    0,
    0,
    6,
    4,
    5,
    0,
    0,
    0,
    0,
    3
};
BYTE CONST ftmIEnumSTATSTG[] =
{
    0,
    0,
    0,
    0,
    6,
    4,
    5,
    0,
    0,
    0,
    0,
    3
};
BYTE CONST ftmILockBytes[] =
{
    0,
    0,
    9,
    0,
    0,
    0,
    5,
    0,
    0,
    0,
    0,
    0,
    3,
    4,
    6,
    7,
    8
};
BYTE CONST ftmIStream[] =
{
    4,
    0,
    12,
    0,
    13,
    8,
    9,
    0,
    0,
    0,
    0,
    3,
    0,
    0,
    6,
    11,
    10,
    5,
    7
};
BYTE CONST ftmIStorage[] =
{
    0,
    0,
    13,
    15,
    12,
    9,
    10,
    0,
    0,
    6,
    7,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    3,
    4,
    5,
    8,
    11,
    14,
    16,
    17
};
BYTE CONST ftmIRootStorage[] =
{
    0,
    0,
    0,
    0,
    0,
    3,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};
BYTE CONST ftmIEnumFORMATETC[] =
{
    0,
    0,
    0,
    0,
    6,
    4,
    5,
    0,
    0,
    0,
    0,
    3,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};
BYTE CONST ftmIEnumSTATDATA[] =
{
    0,
    0,
    0,
    0,
    6,
    4,
    5,
    0,
    0,
    0,
    0,
    3,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};
BYTE CONST ftmIDataObject[] =
{
    0,
    0,
    6,
    11,
    10,
    5,
    0,
    0,
    0,
    0,
    0,
    7,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    9,
    4,
    3,
    8
};
BYTE CONST ftmIViewObject[] =
{
    8,
    0,
    0,
    0,
    0,
    6,
    0,
    0,
    0,
    4,
    0,
    7,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    5,
    0,
    0,
    0,
    3
};
BYTE CONST ftmIViewObject2[] =
{
    8,
    0,
    0,
    0,
    0,
    6,
    0,
    0,
    0,
    4,
    0,
    7,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    9,
    5,
    0,
    0,
    0,
    3
};
BYTE CONST ftmIAdviseSink[] =
{
    0,
    0,
    0,
    0,
    0,
    5,
    6,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    4,
    3,
    0,
    7
};
BYTE CONST ftmIAdviseSink2[] =
{
    0,
    0,
    0,
    0,
    8,
    5,
    7,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    4,
    3,
    0,
    6
};
BYTE CONST ftmIDataAdviseHolder[] =
{
    0,
    0,
    0,
    0,
    5,
    4,
    0,
    0,
    0,
    0,
    0,
    6,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    3,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};
BYTE CONST ftmIOleCache[] =
{
    7,
    0,
    0,
    6,
    5,
    4,
    0,
    0,
    0,
    0,
    0,
    3,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};
BYTE CONST ftmIOleCache2[] =
{
    7,
    9,
    0,
    6,
    5,
    4,
    0,
    0,
    0,
    0,
    0,
    3,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    8
};
BYTE CONST ftmIOleCacheControl[] =
{
    0,
    0,
    0,
    0,
    0,
    3,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    4,
    0
};
BYTE CONST ftmIDropTarget[] =
{
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    5,
    0,
    3,
    4,
    6
};
BYTE CONST ftmIDropSource[] =
{
    0,
    0,
    0,
    0,
    0,
    4,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    3,
    0,
    0,
    0,
    0,
    0,
    0
};
BYTE CONST ftmIPersist[] =
{
    0,
    0,
    0,
    0,
    0,
    3,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};
BYTE CONST ftmIPersistStorage[] =
{
    0,
    8,
    0,
    6,
    5,
    3,
    9,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    7,
    0,
    4,
    0,
    0,
    0,
    0
};
BYTE CONST ftmIPersistStream[] =
{
    0,
    0,
    0,
    7,
    5,
    3,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    6,
    0,
    4,
    0,
    0,
    0,
    0
};
BYTE CONST ftmIPersistFile[] =
{
    0,
    0,
    0,
    8,
    7,
    3,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    6,
    5,
    0,
    4,
    0,
    0,
    0,
    0
};
BYTE CONST ftmIBindCtx[] =
{
    0,
    7,
    0,
    6,
    4,
    3,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    10,
    9,
    0,
    5,
    0,
    0,
    0,
    0,
    8,
    11,
    12
};
BYTE CONST ftmIMoniker[] =
{
    16,
    22,
    19,
    17,
    14,
    13,
    0,
    0,
    0,
    0,
    0,
    15,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    21,
    10,
    9,
    8,
    18,
    12,
    6,
    0,
    4,
    11,
    0,
    0,
    0,
    7,
    5,
    3,
    20
};
BYTE CONST ftmIRunningObjectTable[] =
{
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    3,
    8,
    7,
    6,
    0,
    0,
    0,
    0,
    0,
    0,
    9,
    5,
    4,
    0
};
BYTE CONST ftmIEnumMoniker[] =
{
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    5,
    0,
    0,
    0,
    0,
    0,
    6,
    4,
    3
};
BYTE CONST ftmIEnumOLEVERB[] =
{
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    5,
    0,
    0,
    0,
    0,
    0,
    6,
    4,
    3
};
BYTE CONST ftmIOleObject[] =
{
    0,
    21,
    16,
    20,
    15,
    12,
    14,
    0,
    0,
    11,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    10,
    7,
    5,
    0,
    13,
    9,
    0,
    0,
    0,
    6,
    4,
    3,
    8,
    17,
    18,
    19,
    22,
    23
};
BYTE CONST ftmIOleClientSite[] =
{
    0,
    0,
    0,
    0,
    0,
    0,
    6,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    3,
    0,
    0,
    0,
    0,
    0,
    0,
    7,
    4,
    0,
    0,
    0,
    0,
    5,
    8
};
BYTE CONST ftmIRunnableObject[] =
{
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    7,
    4,
    0,
    0,
    0,
    0,
    6,
    3,
    5
};
BYTE CONST ftmIParseDisplayName[] =
{
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    3,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};
BYTE CONST ftmIOleContainer[] =
{
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    3,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    4,
    5,
    0
};
BYTE CONST ftmIOleItemContainer[] =
{
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    6,
    0,
    7,
    3,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    8,
    0,
    0,
    0,
    0,
    4,
    5,
    0
};
BYTE CONST ftmIOleAdviseHolder[] =
{
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    8,
    0,
    0,
    0,
    0,
    0,
    6,
    5,
    0,
    0,
    0,
    0,
    3,
    4,
    7
};
BYTE CONST ftmIOleLink[] =
{
    0,
    0,
    0,
    13,
    11,
    8,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    12,
    0,
    0,
    0,
    0,
    7,
    6,
    4,
    0,
    0,
    0,
    9,
    5,
    3,
    10
};
BYTE CONST ftmIOleWindow[] =
{
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    4,
    0,
    0,
    0,
    0,
    0,
    3,
    0
};
BYTE CONST ftmIOleInPlaceObject[] =
{
    0,
    0,
    0,
    0,
    0,
    0,
    8,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    6,
    0,
    0,
    0,
    0,
    0,
    0,
    4,
    0,
    0,
    0,
    0,
    7,
    3,
    5
};
BYTE CONST ftmIOleInPlaceActiveObject[] =
{
    0,
    0,
    0,
    0,
    9,
    7,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    6,
    5,
    4,
    8,
    0,
    0,
    0,
    0,
    3,
    0
};
BYTE CONST ftmIOleInPlaceUIWindow[] =
{
    0,
    0,
    0,
    0,
    0,
    7,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    6,
    5,
    4,
    0,
    0,
    0,
    0,
    8,
    3,
    0
};
BYTE CONST ftmIOleInPlaceFrame[] =
{
    0,
    13,
    0,
    12,
    11,
    7,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    6,
    5,
    4,
    10,
    0,
    0,
    9,
    8,
    3,
    0,
    14
};
BYTE CONST ftmIOleInPlaceSite[] =
{
    0,
    0,
    0,
    0,
    0,
    0,
    7,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    8,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    6,
    0,
    0,
    0,
    0,
    14,
    10,
    4,
    0,
    0,
    0,
    0,
    0,
    3,
    5,
    0,
    9,
    11,
    12,
    13
};
BYTE CONST ftmIRpcChannelBuffer[] =
{
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    6,
    4,
    3,
    5,
    0,
    0,
    0,
    0,
    0,
    7
};
BYTE CONST ftmIRpcProxyBuffer[] =
{
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    3,
    0,
    0,
    0,
    0,
    0,
    4
};
BYTE CONST ftmIRpcStubBuffer[] =
{
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    9,
    8,
    6,
    0,
    0,
    0,
    0,
    5,
    3,
    0,
    0,
    0,
    0,
    7,
    4
};
BYTE CONST ftmIPSFactoryBuffer[] =
{
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    3,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    4,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};
BYTE CONST ftmIRpcChannel[] =
{
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    3,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    5,
    4,
    0,
    0,
    0,
    0,
    0,
    6
};
BYTE CONST ftmIRpcProxy[] =
{
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    3,
    0,
    0,
    0,
    0,
    0,
    4
};
BYTE CONST ftmIRpcStub[] =
{
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    5,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    6,
    0,
    0,
    0,
    0,
    0,
    3,
    0,
    0,
    0,
    0,
    7,
    4
};
BYTE CONST ftmIPSFactory[] =
{
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    3,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    4,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\olethk32\inv32.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       inv32.cxx
//
//  Contents:   Implementation of InvokeOn32
//
//  History:    22-Feb-94       DrewB   Created
//
//----------------------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

STDAPI_(BOOL) IsValidInterface( void FAR* pv );

#include <apilist.hxx>

//+---------------------------------------------------------------------------
//
//  Function:   InvokeOn32, public
//
//  Synopsis:   Sets up the THUNKINFO and starts thunking for a 16->32 call
//
//  Arguments:  [dw1] - Ignored
//              [dwMethod] - Method index
//              [pvStack32] - 32-bit stack
//
//  Returns:    Appropriate status code
//
//  History:    18-Dec-93       JohannP Created
//              21-Feb-94       DrewB   Modified
//		09-Dec-94	JohannP added stack switching
//
//  Note:	On WIN95 this function get is executed on the 32 bit stack.
//
//----------------------------------------------------------------------------

#if DBG == 1
extern "C"
{
ULONG InvokeOn32_count = 0;
ULONG InvokeOn32_break = 0;

int _iInvokeOn32BreakIidx = -1;
int _iInvokeOn32BreakMethod = -1;
};
#endif


// InvokeOn32 uses a lot of local variables so allocate its locals
// rather than declaring them on the stack.  This saves roughly
// 150 bytes of stack per call

struct INVOKE32RECORD
{
    THOP CONST  *pThop;
    THOP CONST  * CONST *ppThop;
    UINT        uiThop;
    VTBLFN CONST *pvfnVtbl;
    VTBLFN CONST * CONST *ppvfnThis32;
    DWORD       dwStack32[MAX_PARAMS];
    THUNKINFO   ti;
    VPVOID      vpvThis16;
    THUNK1632OBJ UNALIGNED *pto;
    IIDIDX      iidx;
    ThreadData  *ptd;
};

STDAPI_(DWORD) SSAPI(InvokeOn32)(DWORD dw1, DWORD dwMethod, LPVOID pvStack16)
{
    // NOTE: Do not declare local variables in this routine
    // except for debug builds
    INVOKE32RECORD *pir;
    DWORD dwResult;

#if DBG == 1
    ULONG ulInvokeOn32_count = ++InvokeOn32_count;

    if (InvokeOn32_count == InvokeOn32_break)
    {
	DebugBreak();
    }

    thkDebugOut((DEB_ITRACE, "%sInvokeOn32(0x%08x, %p)\n",
                 NestingLevelString(),
                 dwMethod, pvStack16));
#endif // DBG

    if(!TlsThkGetData())
        return(CO_E_NOTINITIALIZED);

    pir = (INVOKE32RECORD *)STACKALLOC32(sizeof(INVOKE32RECORD));
    if (pir == NULL)
    {
        // This error isn't guaranteed to mean anything for
        // this call.  Not much else we can do, though
        return (DWORD)E_OUTOFMEMORY;
    }

    // pvStack16 is the pointer to the first parameter of the 16-bit
    // routine.  The compiler will adjust it appropriately according
    // to the calling convention of the routine so for PASCAL APIs
    // it will be high and for CDECL methods it will be low

    pir->ti.s16.pbStart = (BYTE *)pvStack16;
    pir->ti.s16.pbCurrent = pir->ti.s16.pbStart;

    pir->ti.s32.pbStart = (BYTE *)pir->dwStack32;
    pir->ti.s32.pbCurrent = pir->ti.s32.pbStart;

    pir->ti.scResult = S_OK;
    pir->ti.fResultThunked = FALSE;

    if (dwMethod >= THK_API_BASE)
    {
        dwMethod -= THK_API_BASE;
        pir->iidx = IIDIDX_INVALID;

        // APIs are handled as if there were a giant interface which
        // contains all the APIs as methods.
        pir->ppThop = apthopsApiThops;
        pir->uiThop = THK_API_COUNT;

        pir->pvfnVtbl = apfnApiFunctions;

        // APIs are pascal so we need to move downward in memory to
        // get to the next parameter
        pir->ti.s16.iDir = -1;

        pir->ti.dwCallerProxy = 0;
    }
    else
    {
        // For each interface there is an array of thop strings, one for
        // each method.  The IUnknown methods don't have thop strings so
        // bias the thop string pointer to account for that

        thkAssert(dwMethod >= SMI_COUNT);

        // Methods are cdecl so we need to move upwards in memory to
        // get to the next parameter
        pir->ti.s16.iDir = 1;

        // We need to look up the appropriate method pointer by
        // looking in the 32-bit object's vtable
        GET_STACK16(&pir->ti, pir->vpvThis16, VPVOID);

        thkDebugOut((DEB_INVOKES,
                     "InvokeOn32: vpvThis16 = %08lX\n", pir->vpvThis16 ));

        pir->pto = FIXVDMPTR(pir->vpvThis16, THUNK1632OBJ);
        if (pir->pto == NULL)
        {
            STACKFREE32(pir, sizeof(INVOKE32RECORD));
            return (DWORD)E_INVALIDARG;
        }

        if ((pir->pto->grfFlags & PROXYFLAG_TEMPORARY) == 0)
        {
            // Make sure proxy is still valid.
            // After PPC/Win95 we might want to look at using
            // a signiture for validating this rather than IsValidInterface
            // because it will speed this code path up.
            if (!IsValidInterface(pir->pto->punkThis32))
            {
                thkDebugOut((
                    DEB_ERROR, "InvokeOn32: %p: Invalid proxied object %p\n",
                         pir->vpvThis16, pir->pto->punkThis32));
                STACKFREE32(pir, sizeof(INVOKE32RECORD));
                RELVDMPTR(pir->vpvThis16);
                return (DWORD)E_INVALIDARG;
            }

            DebugValidateProxy1632(pir->vpvThis16);

            pir->ppvfnThis32 = (VTBLFN CONST * CONST*)pir->pto->punkThis32;
        }
        else
        {
            // Temporary proxies cannot be validated

            // A temporary proxy's this pointer is actually a pointer
            // to the real this pointer, so indirect through the this
            // pointer to retrieve the real this pointer
            pir->ppvfnThis32 = (VTBLFN CONST * CONST *)*(void **)pir->pto->punkThis32;
            thkAssert(pir->ppvfnThis32 != NULL);
            thkDebugOut((DEB_WARN, "WARNING: InvokeOn32 on temporary "
                         "%s proxy for %p\n", IidIdxString(pir->pto->iidx),
                         pir->ppvfnThis32));
        }

        pir->iidx = pir->pto->iidx;
        RELVDMPTR(pir->vpvThis16);

        if (pir->ppvfnThis32 == NULL)
        {
            STACKFREE32(pir, sizeof(INVOKE32RECORD));
            return (DWORD)E_FAIL;
        }

        pir->ti.dwCallerProxy = pir->vpvThis16;

        thkAssert(pir->iidx < THI_COUNT);

        pir->ppThop = athopiInterfaceThopis[pir->iidx].ppThops-SMI_COUNT;
        pir->uiThop = athopiInterfaceThopis[pir->iidx].uiSize;

        pir->pvfnVtbl = *pir->ppvfnThis32;

        // Push the 32-bit this pointer on the stack first
        TO_STACK32(&pir->ti, pir->ppvfnThis32, VTBLFN CONST * CONST*);
    }

    thkAssert(dwMethod < pir->uiThop);

    pir->pThop = pir->ppThop[dwMethod];

    thkAssert(pir->pThop != NULL);

    pir->ti.pThop = pir->pThop;
    pir->ti.pvfn  = pir->pvfnVtbl[dwMethod];
    pir->ti.iidx  = pir->iidx;
    pir->ti.dwMethod = dwMethod;

    pir->ptd = TlsThkGetData();
    if (pir->ptd == NULL)
    {
        thkDebugOut((DEB_WARN, "WARNING: InvokeOn32: Call refused\n"));

        STACKFREE32(pir, sizeof(INVOKE32RECORD));
        return (DWORD)E_FAIL;
    }

    pir->ti.pThkMgr = pir->ptd->pCThkMgr;
    thkAssert(pir->ti.pThkMgr != NULL);

#if DBG == 1
    if (pir->iidx == IIDIDX_INVALID)
    {
        thkDebugOut((DEB_INVOKES, "%s#(%04X):InvokeOn32 on %p, %s\n",
                     NestingLevelString(), ulInvokeOn32_count,
                     pir->ti.pvfn, apszApiNames[dwMethod]));
    }
    else
    {
        thkDebugOut((DEB_INVOKES, "%s#(%04X):InvokeOn32 on %p:%p, %s::%s (0x%0x:0x%0x)\n",
                     NestingLevelString(), ulInvokeOn32_count,
                     pir->ppvfnThis32, pir->ti.pvfn,
                     inInterfaceNames[pir->iidx].pszInterface,
                     inInterfaceNames[pir->iidx].ppszMethodNames[dwMethod],
		     pir->iidx,
		     dwMethod));
    }
#endif

    DebugIncrementNestingLevel();
    // save and set the new thunk state

    pir->ti.pThkMgr->SetThkState(THKSTATE_INVOKETHKIN32);

#if DBG == 1
    if ((_iInvokeOn32BreakIidx > 0 &&
         _iInvokeOn32BreakIidx == (int)pir->iidx) &&
        (_iInvokeOn32BreakMethod < 0 ||
         _iInvokeOn32BreakMethod == (int)dwMethod))
    {
        DebugBreak();
    }
#endif

#if DBG == 1
    SStackRecord sr;

    RecordStackState16(&sr);
#endif

#if DBG == 1
    if (fStabilizeProxies)
#endif
    {
        // HACK HACK HACK
        // Because of changes in the way refcounting rules work between
        // 16 and 32-bits, we have to stabilize this pointers for
        // 16->32 calls.  To effect this, we do a purely local AddRef
        //
        // Temporary proxies are not valid proxies so they cannot
        // be stabilized
        if (pir->iidx != IIDIDX_INVALID)
        {
            DWORD dwFlags;

            pir->pto = FIXVDMPTR(pir->vpvThis16, THUNK1632OBJ);
            dwFlags = pir->pto->grfFlags;
            RELVDMPTR(pir->vpvThis16);

            if ((dwFlags & PROXYFLAG_TEMPORARY) == 0)
            {
                pir->ti.pThkMgr->AddRefProxy1632(pir->vpvThis16);
            }
        }
    }

    dwResult = EXECUTE_THOP1632(&pir->ti);

#if DBG == 1
    if (fStabilizeProxies)
#endif
    {
        // Remove our stabilization reference
        // Note that we don't really know whether the proxy is
        // still valid, so we're just crossing our fingers here
        // and hoping that things continue to work
        if (pir->iidx != IIDIDX_INVALID)
        {
            DWORD dwFlags;

            pir->pto = FIXVDMPTR(pir->vpvThis16, THUNK1632OBJ);
            dwFlags = pir->pto->grfFlags;
            RELVDMPTR(pir->vpvThis16);

            if ((dwFlags & PROXYFLAG_TEMPORARY) == 0)
            {
                DebugValidateProxy1632(pir->vpvThis16);
                pir->ti.pThkMgr->ReleaseProxy1632(pir->vpvThis16);
            }
        }
    }

#if DBG == 1

    if ( !pir->ti.fResultThunked && FAILED(dwResult) )
    {
        if (pir->iidx == IIDIDX_INVALID)
        {
            thkDebugOut((DEB_FAILURES,
                         "InvokeOn32 probable failure %s sc = %08lX\n",
                         apszApiNames[dwMethod],
                         dwResult));
        }
        else
        {
            thkDebugOut((DEB_FAILURES,
                         "InvokeOn32 probable failure %s::%s sc = %08lX\n",
                         inInterfaceNames[pir->iidx].pszInterface,
                         inInterfaceNames[pir->iidx].ppszMethodNames[dwMethod],
                         dwResult));
        }
        if(thkInfoLevel & DEB_DBGFAIL)
            thkAssert(!"Wish to Debug");
    }

    CheckStackState16(&sr);

#endif

    pir->ti.pThkMgr->SetThkState(THKSTATE_NOCALL);

    DebugDecrementNestingLevel();

    if ( !pir->ti.fResultThunked )
    {
        dwResult = TransformHRESULT_3216( dwResult );
    }

#if DBG == 1
    if (pir->iidx == IIDIDX_INVALID)
    {
        thkDebugOut((DEB_INVOKES,
                     "%s#(%04X):InvokeOn32 on %p, %s returns 0x%08lX\n",
                     NestingLevelString(), ulInvokeOn32_count, pir->ti.pvfn,
                     apszApiNames[dwMethod], dwResult ));
    }
    else
    {
        thkDebugOut((DEB_INVOKES,
                     "%s#(%04X):InvokeOn32 on %p:%p, %s::%s returns 0x%08lX\n",
                     NestingLevelString(), ulInvokeOn32_count,
                     pir->ppvfnThis32,
                     pir->ti.pvfn, inInterfaceNames[pir->iidx].pszInterface,
                     inInterfaceNames[pir->iidx].ppszMethodNames[dwMethod],
                     dwResult));
    }
#endif

    STACKFREE32(pir, sizeof(INVOKE32RECORD));

    return dwResult;
}


#ifdef _CHICAGO_
//+---------------------------------------------------------------------------
//
//  Function:   SSCallback16
//
//  Synopsis:	Switches to 16 bit and calls back to 16 bit.
//
//  Arguments:  [vpfn16] --  function pointer
//		[dwParam] -- pointer to parameter
//
//  Returns:
//
//  History:    12-08-94   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD WINAPI SSCallback16(DWORD vpfn16, DWORD dwParam)
{
    DWORD dwRet;
    // switch to the 16 bit stack
    //
    if (SSONBIGSTACK())
    {
	StackDebugOut((DEB_STCKSWTCH, "%sSSCallback16 32->16(%p)\n",NestingLevelString(), vpfn16));
	dwRet = SSCall(8, SSF_SmallStack, WOWCallback16, vpfn16, dwParam);
	StackDebugOut((DEB_STCKSWTCH, "%sSSCallback16 32<-16 done\n",NestingLevelString() ));
    }
    else
    {
	dwRet = WOWCallback16(vpfn16, dwParam);	
    }
    return dwRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   SSCallback16Ex
//
//  Synopsis:   Like SSCallback16 except can handle up 16 bytes of parametes
//
//  Arguments:  [vpfn16] --  see Callback16Ex
//		[dwFlags] --
//		[cbArgs] --
//		[pArgs] --
//		[pdwRetCode] --
//
//  Returns:
//
//  History:    12-08-94   JohannP (Johann Posch)   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
BOOL WINAPI SSCallback16Ex(DWORD  vpfn16, DWORD  dwFlags,
			   DWORD  cbArgs, PVOID  pArgs, PDWORD pdwRetCode)
{
    DWORD dwRet;
    // switch to the 16 bit stack
    //
    if (SSONBIGSTACK())
    {
	StackDebugOut((DEB_STCKSWTCH, "%sSSCallback16Ex 32->16 (%p)\n",NestingLevelString(), vpfn16));
	dwRet = SSCall(20, SSF_SmallStack, WOWCallback16Ex,vpfn16, dwFlags, cbArgs, pArgs, pdwRetCode);
	StackDebugOut((DEB_STCKSWTCH, "%sSSCallback16Ex 32<-16 done\n",NestingLevelString() ));
    }
    else
    {
	dwRet = WOWCallback16Ex(vpfn16, dwFlags, cbArgs, pArgs, pdwRetCode);
    }
    return dwRet;

}

//+---------------------------------------------------------------------------
//
//  Function:   InvokeOn32
//
//  Synopsis:	Switches to the 32 bit stack and calls SSAPI(InvokeOn32)
//
//  Arguments:  [dw1] --	See SSAPI(InvokeOn32)
//		[dwMethod] --
//		[pvStack16] --
//
//  Returns:
//
//  History:    12-08-94   JohannP (Johann Posch)   Created
//
//  Notes:	Only executed under WIN95
//
//----------------------------------------------------------------------------
STDAPI_(DWORD) InvokeOn32 (DWORD dw1, DWORD dwMethod, LPVOID pvStack16)
{
    DWORD dwRes;
    if (SSONSMALLSTACK())
    {
	StackDebugOut((DEB_STCKSWTCH, "%sSSInvokeOn32 16->32 (0x%08x, %p)\n",
		     NestingLevelString(), dwMethod, pvStack16));
	dwRes = SSCall(12 ,SSF_BigStack, SSInvokeOn32, dw1, dwMethod, pvStack16);
	StackDebugOut((DEB_STCKSWTCH, "%sSSInvokeOn32 16<-32 done(0x%08x, %p)\n",
		     NestingLevelString(), dwMethod, pvStack16));
    }
    else
        dwRes = SSInvokeOn32(dw1, dwMethod, pvStack16);

    return dwRes;
}

#endif // _CHICAGO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\olethk32\mmodel.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	mmodel.cxx
//
//  Contents:	CMemoryModel
//
//  History:	29-Sep-94	DrewB	Created
//
//----------------------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

CMemoryModel16 mmodel16Public(TRUE);
CMemoryModel16 mmodel16Owned(FALSE);
CMemoryModel32 mmodel32;

//+---------------------------------------------------------------------------
//
//  Method:     CMemoryModel16::AllocMemory
//
//  Synopsis:   Allocates memory
//
//  Arguments:  [cb] - Size of block to allocate
//
//  Returns:    New address of block or NULL
//
//  History:    7-05-94   BobDay (Bob Day)  Created
//
//----------------------------------------------------------------------------

DWORD CMemoryModel16::AllocMemory(DWORD cb)
{
    VPVOID vpv;
    HMEM16 hmem16;

    thkAssert(cb > 0);

    vpv = WgtAllocLock(GMEM_MOVEABLE, cb, &hmem16);
    if (vpv == 0)
    {
        //
        // Not able to allocate a 16-bit memory block!
        //
        thkDebugOut((DEB_ERROR,
                     "CMemoryModel16::AllocMemory, "
                     "Allocation failed, size %08lX\n",
                     cb));
        return 0;
    }

    if (_fPublic)
    {
        SetOwnerPublicHMEM16(hmem16);
    }

    return vpv;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMemoryModel16::FreeMemory
//
//  Synopsis:   Deallocates a block of memory previously allocated
//
//  Arguments:  [dwMem] - Address of memory block to free
//
//  History:    7-05-94   BobDay (Bob Day)  Created
//
//----------------------------------------------------------------------------

void CMemoryModel16::FreeMemory(DWORD dwMem)
{
    thkAssert(dwMem != 0);
    
    WgtUnlockFree(dwMem);
}

//+---------------------------------------------------------------------------
//
//  Method:     CMemoryModel16::ResolvePtr
//
//  Synopsis:   Returns a resolved pointer given an abstract pointer
//
//  Arguments:  [dwMem] - Address to get pointer from
//              [cb] - Length, starting at given address, to make valid
//                     pointers for. 
//
//  Returns:    LPVOID - A real pointer equivalent to the abstract pointer.
//
//  History:    7-05-94   BobDay (Bob Day)  Created
//
//  Notes:      Be careful of alignment issues
//
//----------------------------------------------------------------------------

LPVOID CMemoryModel16::ResolvePtr(DWORD dwMem, DWORD cb)
{
    LPVOID pv;

    thkAssert(dwMem != 0 && cb > 0);

    pv = (LPVOID)WOWFIXVDMPTR(dwMem, cb);
    if (pv == NULL)
    {
        thkDebugOut((DEB_ERROR,
                     "CMemoryModel16::ResolvePtr, "
                     "WOWGetVDMPointer failed on %08lX, size %08lX\n",
                     dwMem, cb));
    }

    return pv;
}

//+---------------------------------------------------------------------------
//
//  Member:	CMemoryModel16::ReleasePtr, public
//
//  Synopsis:	Releases a resolved pointer
//
//  Arguments:	[dwMem] - Abstract pointer to release
//
//  History:	10-Oct-94	DrewB	Created
//
//----------------------------------------------------------------------------

void CMemoryModel16::ReleasePtr(DWORD dwMem)
{
    thkAssert(dwMem != 0);

    WOWRELVDMPTR(dwMem);
}

//+---------------------------------------------------------------------------
//
//  Method:     CMemoryModel32::AllocMemory
//
//  Synopsis:   Allocates memory
//
//  Arguments:  [cb] - Size of block to allocate
//
//  Returns:    New address of block or NULL
//
//  History:    7-05-94   BobDay (Bob Day)  Created
//
//----------------------------------------------------------------------------

DWORD CMemoryModel32::AllocMemory(DWORD cb)
{
    DWORD dwMem;

    thkAssert(cb > 0);
    
    dwMem = (DWORD)CoTaskMemAlloc(cb);
    if (dwMem == 0)
    {
        //
        // Not able to allocate a 32-bit memory block!
        //
        thkDebugOut((DEB_ERROR,
                     "CMemoryModel32::AllocBlock, "
                     "CoTaskMemAlloc failed size %08lX\n",
                     cb));
        return 0;
    }
    
    return dwMem;
}

//+---------------------------------------------------------------------------
//
//  Method:     CMemoryModel32::FreeMemory
//
//  Synopsis:   Deallocates a block of memory previously allocated
//
//  Arguments:  [dwMem] - Address of memory block to free
//
//  History:    7-05-94   BobDay (Bob Day)  Created
//
//----------------------------------------------------------------------------

void CMemoryModel32::FreeMemory(DWORD dwMem)
{
    thkAssert(dwMem != 0);
    
    CoTaskMemFree((LPVOID)dwMem);
}

//+---------------------------------------------------------------------------
//
//  Method:     CMemoryModel32::ResolvePtr
//
//  Synopsis:   Returns a resolved pointer given an abstract pointer
//
//  Arguments:  [dwMem] - Address to get pointer from
//              [cb] - Length, starting at given address, to make valid
//                     pointers for. 
//
//  Returns:    LPVOID - A real pointer equivalent to the abstract pointer.
//
//  History:    7-05-94   BobDay (Bob Day)  Created
//
//  Notes:      Be careful of alignment issues
//
//----------------------------------------------------------------------------

LPVOID CMemoryModel32::ResolvePtr(DWORD dwMem, DWORD cb)
{
    thkAssert(dwMem != 0 && cb > 0);
    
    return (LPVOID)dwMem;
}

//+---------------------------------------------------------------------------
//
//  Member:	CMemoryModel32::ReleasePtr, public
//
//  Synopsis:	Releases a resolved pointer
//
//  Arguments:	[dwMem] - Abstract pointer to release
//
//  History:	10-Oct-94	DrewB	Created
//
//----------------------------------------------------------------------------

void CMemoryModel32::ReleasePtr(DWORD dwMem)
{
    thkAssert(dwMem != 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\olethk32\plex.h ===
// This is a part of the Microsoft Foundation Classes C++ library. 
// Copyright (C) 1992 Microsoft Corporation 
// All rights reserved. 
//  
// This source code is only intended as a supplement to the 
// Microsoft Foundation Classes Reference and Microsoft 
// QuickHelp documentation provided with the library. 
// See these sources for detailed information regarding the 
// Microsoft Foundation Classes product. 

#ifndef __PLEX_H__
#define __PLEX_H__

#define INTERNAL_(x) x

struct FAR CPlex    // warning variable length structure
{
   CPlex FAR* pNext;
   UINT nMax;
   UINT nCur;
   /* BYTE data[maxNum*elementSize]; */

   INTERNAL_(void FAR*) data() { return this+1; }

   static INTERNAL_(CPlex FAR*) Create(CPlex FAR* FAR& head, UINT nMax, UINT cbElement);

   INTERNAL_(void) FreeDataChain();       // free this one and links
};

#endif //__PLEX_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\olethk32\plex.cxx ===
// This is a part of the Microsoft Foundation Classes C++ library. 
// Copyright (C) 1992 Microsoft Corporation 
// All rights reserved. 
//  
// This source code is only intended as a supplement to the 
// Microsoft Foundation Classes Reference and Microsoft 
// QuickHelp documentation provided with the library. 
// See these sources for detailed information regarding the 
// Microsoft Foundation Classes product. 

#include "headers.cxx"
#pragma hdrstop

//#include <ole2int.h>
#include "plex.h"
  
// Collection support

#define CairoleAssert(x) thkAssert(x)

CPlex FAR* CPlex::Create(CPlex FAR* FAR& pHead, UINT nMax, UINT cbElement)
{
   CairoleAssert(nMax > 0 && cbElement > 0);
   CPlex FAR* p = (CPlex FAR*)CoTaskMemAlloc(sizeof(CPlex) + nMax * cbElement);
   if (p == NULL)
        return NULL;

   p->nMax = nMax;
   p->nCur = 0;
   p->pNext = pHead;
   pHead = p;  // change head (adds in reverse order for simplicity)
   return p;
}

void CPlex::FreeDataChain()     // free this one and links
{
    CPlex FAR* pThis;
    CPlex FAR* pNext;

    for (pThis = this; pThis != NULL; pThis = pNext) {
        pNext = pThis->pNext;
        pThis->pNext = NULL; // So compiler won't do nasty optimizations
        CoTaskMemFree(pThis);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\olethk32\map_kv.cxx ===
/////////////////////////////////////////////////////////////////////////////
// class CMapKeyToValue - a mapping from 'KEY's to 'VALUE's, passed in as
// pv/cb pairs.  The keys can be variable length, although we optmizize the
// case when they are all the same.
//
/////////////////////////////////////////////////////////////////////////////
#include "headers.cxx"
#pragma hdrstop

#include <olecoll.h>
#include "map_kv.h"
#include "plex.h"


/////////////////////////////////////////////////////////////////////////////


//CMapKeyToValue::CMapKeyToValue(DWORD memctx, UINT cbValue, UINT cbKey,
CMapKeyToValue::CMapKeyToValue(UINT cbValue, UINT cbKey,
   int nBlockSize, LPFNHASHKEY lpfnHashKey, UINT nHashSize)
{
   Assert(nBlockSize > 0);

   m_cbValue = cbValue;
   m_cbKey = cbKey;
   m_cbKeyInAssoc = cbKey == 0 ? sizeof(CKeyWrap) : cbKey;

   m_pHashTable = NULL;
   m_nHashTableSize = nHashSize;
   m_lpfnHashKey = lpfnHashKey;

   m_nCount = 0;
   m_pFreeList = NULL;
   m_pBlocks = NULL;
   m_nBlockSize = nBlockSize;
   //if (memctx == MEMCTX_SAME)
   //   memctx = CoMemctxOf(this);
   //m_memctx = memctx;
   //Assert(m_memctx != MEMCTX_UNKNOWN);
}

CMapKeyToValue::~CMapKeyToValue()
{
   ASSERT_VALID(this);
   RemoveAll();
   Assert(m_nCount == 0);
}


// simple, default hash function
// REVIEW: need to check the value in this for GUIDs and strings
STDAPI_(UINT) MKVDefaultHashKey(LPVOID pKey, UINT cbKey)
{
   UINT hash = 0;
   BYTE FAR* lpb = (BYTE FAR*)pKey;

   while (cbKey-- != 0)
        hash = 257 * hash + *lpb++;

   return hash;
}


BOOL CMapKeyToValue::InitHashTable()
{
   ASSERT_VALID(this);
   Assert(m_nHashTableSize  > 0);
   
   if (m_pHashTable != NULL)
        return TRUE;

   Assert(m_nCount == 0);

   if ((m_pHashTable = (CAssoc FAR* FAR*)CoTaskMemAlloc(m_nHashTableSize * sizeof(CAssoc FAR*))) == NULL)
        return FALSE;

   memset(m_pHashTable, 0, sizeof(CAssoc FAR*) * m_nHashTableSize);

   ASSERT_VALID(this);

   return TRUE;
}


void CMapKeyToValue::RemoveAll()
{
   ASSERT_VALID(this);

   // free all key values and then hash table
   if (m_pHashTable != NULL)
   {
        // destroy assocs
        for (UINT nHash = 0; nHash < m_nHashTableSize; nHash++)
        {
                register CAssoc FAR* pAssoc;
                for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL;
                  pAssoc = pAssoc->pNext)
                        // assoc itself is freed by FreeDataChain below
                        FreeAssocKey(pAssoc);
        }

        // free hash table
        CoTaskMemFree(m_pHashTable);
        m_pHashTable = NULL;
   }

   m_nCount = 0;
   m_pFreeList = NULL;
   m_pBlocks->FreeDataChain();
   m_pBlocks = NULL;

   ASSERT_VALID(this);
}

/////////////////////////////////////////////////////////////////////////////
// Assoc helpers
// CAssoc's are singly linked all the time

CMapKeyToValue::CAssoc  FAR*
    CMapKeyToValue::NewAssoc(UINT hash, LPVOID pKey, UINT cbKey, LPVOID pValue)
{
   if (m_pFreeList == NULL)
   {
        // add another block
        CPlex FAR* newBlock = CPlex::Create(m_pBlocks, m_nBlockSize, SizeAssoc());

        if (newBlock == NULL)
                return NULL;

        // chain them into free list
        register BYTE  FAR* pbAssoc = (BYTE FAR*) newBlock->data();
        // free in reverse order to make it easier to debug
        pbAssoc += (m_nBlockSize - 1) * SizeAssoc();
        for (int i = m_nBlockSize-1; i >= 0; i--, pbAssoc -= SizeAssoc())
        {
                ((CAssoc FAR*)pbAssoc)->pNext = m_pFreeList;
                m_pFreeList = (CAssoc FAR*)pbAssoc;
        }
   }
   Assert(m_pFreeList != NULL); // we must have something

   CMapKeyToValue::CAssoc  FAR* pAssoc = m_pFreeList;

   // init all fields except pNext while still on free list
   pAssoc->nHashValue = hash;
   if (!SetAssocKey(pAssoc, pKey, cbKey))
        return NULL;

   SetAssocValue(pAssoc, pValue);

   // remove from free list after successfully initializing it (except pNext)
   m_pFreeList = m_pFreeList->pNext;
   m_nCount++;
   Assert(m_nCount > 0);       // make sure we don't overflow

   return pAssoc;
}


// free individual assoc by freeing key and putting on free list
void CMapKeyToValue::FreeAssoc(CMapKeyToValue::CAssoc  FAR* pAssoc)
{
   pAssoc->pNext = m_pFreeList;
   m_pFreeList = pAssoc;
   m_nCount--;
   Assert(m_nCount >= 0);      // make sure we don't underflow

   FreeAssocKey(pAssoc);
}


// find association (or return NULL)
CMapKeyToValue::CAssoc  FAR*
CMapKeyToValue::GetAssocAt(LPVOID pKey, UINT cbKey, UINT FAR& nHash) const
{
   if (m_lpfnHashKey)
       nHash = (*m_lpfnHashKey)(pKey, cbKey) % m_nHashTableSize;
   else
       nHash = MKVDefaultHashKey(pKey, cbKey) % m_nHashTableSize;

   if (m_pHashTable == NULL)
        return NULL;

   // see if it exists
   register CAssoc  FAR* pAssoc;
   for (pAssoc = m_pHashTable[nHash]; pAssoc != NULL; pAssoc = pAssoc->pNext)
   {
        if (CompareAssocKey(pAssoc, pKey, cbKey))
                return pAssoc;
   }
   return NULL;
}


BOOL CMapKeyToValue::CompareAssocKey(CAssoc FAR* pAssoc, LPVOID pKey2, UINT cbKey2) const
{
   LPVOID pKey1;
   UINT cbKey1;

   GetAssocKeyPtr(pAssoc, &pKey1, &cbKey1);
   return cbKey1 == cbKey2 && memcmp(pKey1, pKey2, cbKey1) == 0;
}


BOOL CMapKeyToValue::SetAssocKey(CAssoc FAR* pAssoc, LPVOID pKey, UINT cbKey) const
{
   Assert(cbKey == m_cbKey || m_cbKey == 0);

   if (m_cbKey == 0)
   {
        Assert(m_cbKeyInAssoc == sizeof(CKeyWrap));

        // alloc, set size and pointer
        if ((pAssoc->key.pKey = CoTaskMemAlloc(cbKey)) == NULL)
                return FALSE;

        pAssoc->key.cbKey = cbKey;
   }

   LPVOID pKeyTo;

   GetAssocKeyPtr(pAssoc, &pKeyTo, &cbKey);

   memcpy(pKeyTo, pKey, cbKey);

   return TRUE;
}


// gets pointer to key and its length
void CMapKeyToValue::GetAssocKeyPtr(CAssoc FAR* pAssoc, LPVOID FAR* ppKey,UINT FAR* pcbKey) const
{
   if (m_cbKey == 0)
   {
        // variable length key; go indirect
        *ppKey = pAssoc->key.pKey;
        *pcbKey = pAssoc->key.cbKey;
   }
   else
   {
        // fixed length key; key in assoc
        *ppKey = (LPVOID)&pAssoc->key;
        *pcbKey = m_cbKey;
   }
}


void CMapKeyToValue::FreeAssocKey(CAssoc FAR* pAssoc) const
{
   if (m_cbKey == 0)
        CoTaskMemFree(pAssoc->key.pKey);
}


void CMapKeyToValue::GetAssocValuePtr(CAssoc FAR* pAssoc, LPVOID FAR* ppValue) const
{
   *ppValue = (char FAR*)&pAssoc->key + m_cbKeyInAssoc;
}


void CMapKeyToValue::GetAssocValue(CAssoc FAR* pAssoc, LPVOID pValue) const
{
   LPVOID pValueFrom;
   GetAssocValuePtr(pAssoc, &pValueFrom);
   Assert(pValue != NULL);
   memcpy(pValue, pValueFrom, m_cbValue);
}


void CMapKeyToValue::SetAssocValue(CAssoc FAR* pAssoc, LPVOID pValue) const
{
   LPVOID pValueTo;
   GetAssocValuePtr(pAssoc, &pValueTo);
   if (pValue == NULL)
        memset(pValueTo, 0, m_cbValue);
   else
        memcpy(pValueTo, pValue, m_cbValue);
}


/////////////////////////////////////////////////////////////////////////////

// lookup value given key; return FALSE if key not found; in that
// case, the value is set to all zeros
BOOL CMapKeyToValue::Lookup(LPVOID pKey, UINT cbKey, LPVOID pValue) const
{
   UINT nHash;
   HMAPKEY hmapkey = (HMAPKEY)GetAssocAt(pKey, cbKey, nHash);
   return LookupHKey(hmapkey, pValue);
   //return LookupHKey((HMAPKEY)GetAssocAt(pKey, cbKey, nHash), pValue);
}


// lookup value given key; return FALSE if NULL (or bad) key; in that
// case, the value is set to all zeros
BOOL CMapKeyToValue::LookupHKey(HMAPKEY hKey, LPVOID pValue) const
{
   // REVIEW: would like some way to verify that hKey is valid
   register CAssoc  FAR* pAssoc = (CAssoc FAR*)hKey;
   if (pAssoc == NULL)
   {
        memset(pValue, 0, m_cbValue);
        return FALSE;       // not in map
   }

   ASSERT_VALID(this);

   GetAssocValue(pAssoc, pValue);
   return TRUE;
}


// lookup and if not found add; returns FALSE only if OOM; if added, 
// value added and pointer passed are set to zeros.
BOOL CMapKeyToValue::LookupAdd(LPVOID pKey, UINT cbKey, LPVOID pValue) const
{
   if (Lookup(pKey, cbKey, pValue))
        return TRUE;

   // value set to zeros since lookup failed

   return ((CMapKeyToValue FAR*)this)->SetAt(pKey, cbKey, NULL);
}


// the only place new assocs are created; return FALSE if OOM;
// never returns FALSE if keys already exists
BOOL CMapKeyToValue::SetAt(LPVOID pKey, UINT cbKey, LPVOID pValue)
{
   UINT nHash;
   register CAssoc  FAR* pAssoc;

   ASSERT_VALID(this);

   if ((pAssoc = GetAssocAt(pKey, cbKey, nHash)) == NULL)
   {
        if (!InitHashTable())
                // out of memory
                return FALSE;

        // it doesn't exist, add a new Association
        if ((pAssoc = NewAssoc(nHash, pKey, cbKey, pValue)) == NULL)
                return FALSE;

        // put into hash table
        pAssoc->pNext = m_pHashTable[nHash];
        m_pHashTable[nHash] = pAssoc;

        ASSERT_VALID(this);
   }
   else
   {
        SetAssocValue(pAssoc, pValue);
   }

   return TRUE;
}


// set existing hkey to value; return FALSE if NULL or bad key
BOOL CMapKeyToValue::SetAtHKey(HMAPKEY hKey, LPVOID pValue)
{
   // REVIEW: would like some way to verify that hKey is valid
   register CAssoc  FAR* pAssoc = (CAssoc FAR*)hKey;
   if (pAssoc == NULL)
        return FALSE;       // not in map

   ASSERT_VALID(this);

   SetAssocValue(pAssoc, pValue);
   return TRUE;
}


// remove key - return TRUE if removed
BOOL CMapKeyToValue::RemoveKey(LPVOID pKey, UINT cbKey)
{
   ASSERT_VALID(this);

   if (m_pHashTable == NULL)
        return FALSE;       // nothing in the table

   register CAssoc  FAR* FAR* ppAssocPrev;
   UINT i;
   if (m_lpfnHashKey)
       i = (*m_lpfnHashKey)(pKey, cbKey) % m_nHashTableSize;
   else
       i = MKVDefaultHashKey(pKey, cbKey) % m_nHashTableSize;

   ppAssocPrev = &m_pHashTable[i];

   CAssoc  FAR* pAssoc;
   for (pAssoc = *ppAssocPrev; pAssoc != NULL; pAssoc = pAssoc->pNext)
   {
        if (CompareAssocKey(pAssoc, pKey, cbKey))
        {
                // remove it
                *ppAssocPrev = pAssoc->pNext;       // remove from list
                FreeAssoc(pAssoc);
                ASSERT_VALID(this);
                return TRUE;
        }
        ppAssocPrev = &pAssoc->pNext;
   }
   return FALSE;   // not found
}


// remove key based on pAssoc (HMAPKEY)
BOOL CMapKeyToValue::RemoveHKey(HMAPKEY hKey)
{
   ASSERT_VALID(this);

   if (m_pHashTable == NULL)
        return FALSE;       // nothing in the table

   // REVIEW: would like some way to verify that hKey is valid
   CAssoc  FAR* pAssoc = (CAssoc FAR*)hKey;
   if (pAssoc == NULL || pAssoc->nHashValue >= m_nHashTableSize)
        // null hkey or bad hash value
        return FALSE;

   register CAssoc  FAR* FAR* ppAssocPrev;
   ppAssocPrev = &m_pHashTable[pAssoc->nHashValue];

   while (*ppAssocPrev != NULL)
   {
        if (*ppAssocPrev == pAssoc)
        {
                // remove it
                *ppAssocPrev = pAssoc->pNext;       // remove from list
                FreeAssoc(pAssoc);
                ASSERT_VALID(this);
                return TRUE;
        }
        ppAssocPrev = &(*ppAssocPrev)->pNext;
   }

   return FALSE;   // not found (must have a messed up list or passed 
                                // a key from another list)
}


HMAPKEY CMapKeyToValue::GetHKey(LPVOID pKey, UINT cbKey) const
{
   UINT nHash;

   ASSERT_VALID(this);

   return (HMAPKEY)GetAssocAt(pKey, cbKey, nHash);
}


/////////////////////////////////////////////////////////////////////////////
// Iterating

// for fixed length keys, copies key to pKey; pcbKey can be NULL;
// for variable length keys, copies pointer to key to pKey; sets pcbKey.

void CMapKeyToValue::GetNextAssoc(POSITION FAR* pNextPosition, 
        LPVOID pKey, UINT FAR* pcbKey, LPVOID pValue) const
{
   ASSERT_VALID(this);

   Assert(m_pHashTable != NULL);       // never call on empty map

   register CAssoc  FAR* pAssocRet = (CAssoc  FAR*)*pNextPosition;
   Assert(pAssocRet != NULL);

   if (pAssocRet == (CAssoc  FAR*) BEFORE_START_POSITION)
   {
        // find the first association
        for (UINT nBucket = 0; nBucket < m_nHashTableSize; nBucket++)
                if ((pAssocRet = m_pHashTable[nBucket]) != NULL)
                        break;
        Assert(pAssocRet != NULL);  // must find something
   }

   // find next association
   CAssoc  FAR* pAssocNext;
   if ((pAssocNext = pAssocRet->pNext) == NULL)
   {
        // go to next bucket
        for (UINT nBucket = pAssocRet->nHashValue + 1;
          nBucket < m_nHashTableSize; nBucket++)
                if ((pAssocNext = m_pHashTable[nBucket]) != NULL)
                        break;
   }

   // fill in return data
   *pNextPosition = (POSITION) pAssocNext;

   // fill in key/pointer to key
   LPVOID pKeyFrom;
   UINT cbKey;
   GetAssocKeyPtr(pAssocRet, &pKeyFrom, &cbKey);
   if (m_cbKey == 0)
        // variable length key; just return pointer to key itself
        *(void FAR* FAR*)pKey = pKeyFrom;
   else
        memcpy(pKey, pKeyFrom, cbKey);

   if (pcbKey != NULL)
        *pcbKey = cbKey;

   // get value
   GetAssocValue(pAssocRet, pValue);
}

/////////////////////////////////////////////////////////////////////////////

void CMapKeyToValue::AssertValid() const
{
#ifdef _DEBUG
   Assert(m_cbKeyInAssoc == (m_cbKey == 0 ? sizeof(CKeyWrap) : m_cbKey));

   Assert(m_nHashTableSize > 0);
   Assert(m_nCount == 0 || m_pHashTable != NULL);

   if (m_pHashTable != NULL)
        Assert(!IsBadReadPtr(m_pHashTable, m_nHashTableSize * sizeof(CAssoc FAR*)));

   if (m_lpfnHashKey)
       Assert(!IsBadCodePtr((FARPROC)m_lpfnHashKey));

   if (m_pFreeList != NULL)
        Assert(!IsBadReadPtr(m_pFreeList, SizeAssoc()));

   if (m_pBlocks != NULL)
        Assert(!IsBadReadPtr(m_pBlocks, SizeAssoc() * m_nBlockSize));

   // some collections live as global variables in the libraries, but 
   // have their existance in some context.  Also, we can't check shared
   // collections since we might be checking the etask collection
   // which would cause an infinite recursion.
   // REVIEW: Assert(m_memctx == MEMCTX_SHARED || 
   // CoMemctxOf(this) == MEMCTX_UNKNOWN || CoMemctxOf(this) == m_memctx);
#endif //_DEBUG
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\olethk32\olethk32.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       olethk32.cxx
//
//  Contents:   Main routines for olethk32.dll
//
//  History:    22-Feb-94       DrewB   Created
//
//----------------------------------------------------------------------------

#include "headers.cxx"
#include <userapis.h>
#pragma hdrstop

#include <thkmgr.hxx>
#include <stdio.h>


DECLARE_INFOLEVEL(thk);
DECLARE_INFOLEVEL(Stack);

// Interop is disabled at load time
DATA16 gdata16Data;
BOOL gfIteropEnabled;

#if DBG == 1
BOOL fSaveProxy = FALSE;        // Used to find apps who call dead proxies
BOOL fStabilizeProxies = TRUE;  // Used to easily disable stabilization
BOOL fZapProxy = FALSE;         // Used to zap entries in freelist

#ifdef _CHICAGO_
BOOL fSSOn = TRUE;
#endif // _CHICAGO_

#if defined(__cplusplus)
extern "C"
{
#endif
void CallOutputFunctions(const char *buffer);
#if defined(__cplusplus)
}
#endif

#endif

CLIPFORMAT g_cfLinkSourceDescriptor, g_cfObjectDescriptor;

BYTE g_abLeadTable[256];

//+---------------------------------------------------------------------------
//
//  Function:   DoThreadDetach
//
//  Synopsis:   When a thread is detaching, cleanup for it.
//
//  Effects:    This is called during both DLL_THREAD_DETACH, and
//		DLL_PROCESS_DETACH.
//
//  Arguments:  (none)
//
//  History:    3-18-95   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
void
DoThreadDetach()
{
    thkDebugOut((DEB_DLL,"_IN DoThreadDetach\n"));
    //
    // If there is thunk data, clean it up now.
    //
    if (TlsGetValue(dwTlsThkIndex) != NULL)
    {
	thkDebugOut((DEB_DLL,"DoThreadDetach calling ThkMgrUninitialize\n"));
	ThkMgrUninitialize(0, 0, 0);
    }
    thkDebugOut((DEB_DLL,"OUT DoThreadDetach\n"));
}
//+---------------------------------------------------------------------------
//
//  Function:   LibMain, public
//
//  Synopsis:   DLL initialization entry point
//
//  History:    23-Feb-94       DrewB   Created
//
//  Notes:
//
//	(KevinRo 19-Mar-95)
//
//	Caution needs to be exercised during cleanup. OLE32.DLL has
//	a pointer that we pass in during CoInitializeWOW. This pointer
//	is used to call back into OLETHK32 for cleanup purposes, as well as
//	accessing functions exposed by the 16-bit side. It is important that
//	when OLETHK32 unloads, the pointer in OLE32 is marked as invalid.
//	There is a call during the DLL_PROCESS_DETACH below that causes
//	OLE32 to invalidate its pointer.
//
//	In addition, the last thread attached to a DLL will not generate
//	a DLL_THREAD_DETACH. Instead, it generates a DLL_PROCESS_DETACH. This
//	means that DLL_PROCESS_DETACH should perform all the steps that
//	DLL_THREAD_DETACH does in addition to whatever DLL_PROCESS_DETACH work
//	that needs to be done.
//
//	Lastly, OLETHK32.DLL is statically linked to OLE32.DLL. This means
//	that OLETHK32.DLL's DLL_PROCESS_DETACH will be called before OLE32's.
//	That is why it is safe for us to call the OLE32 entry point during
//	DLL_PROCESS_DETACH
//----------------------------------------------------------------------------

extern "C" BOOL __cdecl LibMain(HANDLE hDll,
                                 DWORD dwReason,
                                 LPVOID lpReserved)
{
    switch( dwReason )
    {
    case DLL_PROCESS_ATTACH:
#if DBG == 1
        char achInfoLevel[80];

        if(thkInfoLevel == (DEB_ERROR | DEB_WARN) &&
           GetProfileStringA("olethk32", "InfoLevel", "3", achInfoLevel,
                             sizeof(achInfoLevel)) > 0)
        {
            thkInfoLevel = strtol (achInfoLevel, NULL, 0);
        }
#endif
	thkDebugOut((DEB_DLL,"_IN DLL_PROCESS_ATTACH\n"));

        //
        // Save a slot in the thread local storage for our PSTACK (pseudo-
        // stack) pointer.
        //

        if (!TlsThkAlloc())
        {
            thkDebugOut((DEB_WARN, "TlsThkAlloc failed\n"));
            return FALSE;
        }
	thkDebugOut((DEB_DLL,"OUT DLL_PROCESS_ATTACH\n"));
        break;

    case DLL_THREAD_ATTACH:
	thkDebugOut((DEB_DLL,"_IN DLL_THREAD_ATTACH\n"));
	TlsSetValue(dwTlsThkIndex, NULL);
	thkDebugOut((DEB_DLL,"OUT DLL_THREAD_ATTACH\n"));
        break;

    case DLL_THREAD_DETACH:
	thkDebugOut((DEB_DLL,"_IN DLL_THREAD_DETACH\n"));

	//
	// Call OLE32.DLL and tell it to cleanup for this thread. This will
	// not mark OLE32's ptr invalid since this is only a thread detach
        // and not a process detach. This is a private API between OLE32 and
        // OLETHK32.
	//
	thkDebugOut((DEB_DLL,"Calling Unload WOW for Thread Detach\n"));

	CoUnloadingWOW(FALSE);

        //
        // When the thread for this task goes away, we need to clean out
	// the thunk manager.
	//

        DoThreadDetach();

	thkDebugOut((DEB_DLL,"OUT DLL_THREAD_DETACH\n"));
        break;

    case DLL_PROCESS_DETACH:
	thkDebugOut((DEB_DLL,
		     "IN DLL_PROCESS_DETACH: %s\n",
		     lpReserved?"Process Exit":"Dll Unload"));

	//
	// The last threads cleanup needs to be done here.
	//
	if (lpReserved == NULL)
	{
	    //
	    // Call OLE32.DLL and tell it to cleanup for this thread, and to
	    // never call us again, since we are going away. This is a private
	    // API between OLE32 and OLETHK32. This call will mark OLE32's
	    // private pointer to us as invalid.
	    //
	    thkDebugOut((DEB_DLL,"Calling Unload WOW\n"));

	    CoUnloadingWOW(TRUE);

	    //
	    // lpReserved being NULL means this cleanup is due to
	    // a FreeLibrary. If it was due to process exit, there
	    // is no way for us to determine the state of the data
	    // structures in the system. Other threads may have been
	    // right smack in the middle of taking apart data structures.
	    //
	    //
	    // Chicago unloads DLL's differently than NT. On Chicago, the
	    // 32-bit side cleans up first, plus resources allocated on
	    // the 32-bit side are released when the 16-bit process goes
	    // away. On NT, the 16-bit process is treated like a thread,
	    // so we have to cleanup.
	    //

#ifndef _CHICAGO_
	    DoThreadDetach();
#endif
	    //
	    // Only cleanup the memory if the process is not going away.
	    // On Windows NT, there are cases when the NTVDM needs to be
	    // blown away. We shouldn't be calling back to the 16-bit
	    // side in this case. Therefore, we explicitly call free here
	    // instead of putting it in the destructor.
	    //
	    flFreeList32.FreeMemoryBlocks();
	    flHolderFreeList.FreeMemoryBlocks();
	    flRequestFreeList.FreeMemoryBlocks();
	}

        TlsThkFree();

	//
	// Call to cleanup 16-bit memory if we are running on Win95.
	// This should free up the 16-bit memory associated with this
	// process. This is called in IntOpUninitialize on NT, since it
	// needs to be called before the 16-bit side goes away.
	//

#ifdef _CHICAGO_
	flFreeList16.FreeMemoryBlocks();
#endif


	thkDebugOut((DEB_DLL,"OUT DLL_PROCESS_DETACH\n"));
        break;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   IntOpInitialize, public
//
//  Synopsis:   Initializes the 32-bit interoperability code
//
//  Arguments:  [lpdata16] - 16-bit call data
//              [dw1] - Ignored
//              [dw2] - Ignored
//
//  Returns:    Appropriate status code
//
//  History:    22-Feb-94       JohannP Created
//
//----------------------------------------------------------------------------

STDAPI IntOpInitialize(LPDATA16 lpdata16, DWORD dw1, DWORD dw2)
{
    int i;

    thkDebugOut((DEB_ITRACE | DEB_THUNKMGR, "_IN IntOpInitialize (%08lX)\n",
                 lpdata16));

    thkAssert((THOP_LASTOP & ~THOP_OPMASK) == 0);

#if DBG == 1
    char achInfoLevel[80];
#ifdef _CHICAGO_
    if (GetProfileStringA("CairOLE InfoLevels",
			"Stack", "3", achInfoLevel,
                        sizeof(achInfoLevel)) > 0)
    {
        StackInfoLevel = strtol (achInfoLevel, NULL, 0);
    }

#endif // _CHICAGO_

    if (GetProfileIntA("olethk32", "BreakOnInit", FALSE))
    {
        // DebugBreak's in WOW are fatal unless the exception
        // is handled somehow.  If a debugger is hooked up,
        // it'll get first crack at the break exception
        // If not, our handler will ignore the exception so
        // execution can continue

        __try
        {
            DebugBreak();
        }
        __except(EXCEPTION_EXECUTE_HANDLER)
        {
        }
    }

    fSaveProxy = GetProfileIntA("olethk32", "SaveProxy", FALSE);
    fZapProxy = GetProfileIntA("olethk32", "ZapProxy", FALSE);
    fStabilizeProxies = GetProfileIntA("olethk32", "Stabilize", TRUE);
#endif

    // Copy passed parameter from 16-bit world...
    memcpy( (LPVOID)&gdata16Data, (LPVOID)lpdata16, sizeof( DATA16 ) );
    // Enable interop
    gfIteropEnabled = TRUE;

#if defined(_CHICAGO_)
    g_cfObjectDescriptor =
        RegisterClipboardFormatA("Object Descriptor");
    g_cfLinkSourceDescriptor =
        RegisterClipboardFormatA("Link Source Descriptor");
#else
    g_cfObjectDescriptor =
        (CLIPFORMAT) RegisterClipboardFormat(__TEXT("Object Descriptor"));
    g_cfLinkSourceDescriptor =
        (CLIPFORMAT) RegisterClipboardFormat(__TEXT("Link Source Descriptor"));
#endif
    if (g_cfObjectDescriptor == 0 || g_cfLinkSourceDescriptor == 0)
    {
        thkDebugOut((DEB_WARN, "IntOpInitialize: "
                     "Unable to register clipboard formats\n"));
        return E_UNEXPECTED;
    }

    // Create a lookup table for lead-byte-ness
    // so we can avoid calling IsDBCSLeadByte on every character
    // during string validation
    for (i = 0; i < 256; i++)
    {
        g_abLeadTable[i] = (BYTE)IsDBCSLeadByte((BYTE)i);
    }

    thkDebugOut((DEB_THUNKMGR | DEB_ITRACE, "OUT IntOpInitialize (%08lX)\n",
                 lpdata16));
    return NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Function:	IntOpUninitialize, public
//
//  Synopsis:	Cleanup initiated by 16-bit DLL unload
//
//  Arguments:	[dw1]
//              [dw2]
//              [dw3]
//
//  History:	29-Nov-94	DrewB	Created
//              10-20-97        Gopalk  Disabled interop as CompObj is no
//                                      longer present after this point
//
//  Notes:	(KevinRo) This routine is only called by compobj.dll. To make
//  things even more interesting, it is only called on Windows/NT. Win95
//  does the flFreeList16.FreeMemoryBlocks during PROCESS_DETACH. Cleanup
//  of the proxies is not neccessary on Win95, since the 16-bit process will
//  clean them up for us.
//
//----------------------------------------------------------------------------

STDAPI IntOpUninitialize(DWORD dw1, DWORD dw2, DWORD dw3)
{
    thkDebugOut((DEB_THUNKMGR | DEB_ITRACE, "_IN IntOpUninitialize\n"));
#ifndef _CHICAGO_
    // Remove all existing proxies since we're going to free the
    // proxy memory in the next step
    if (TlsThkGetData() != NULL)
    {
        CThkMgr *ptm = TlsThkGetThkMgr();

        if (ptm)
        {
            ptm->RemoveAllProxies();
        }
    }

    // Clean up the 16-bit freelist at this time because we know
    // that 16-bit code is still active and available for callback
    // If we waited for the freelist destructor to be called, 16-bit
    // code would already be cleaned up and the WOWGlobalFree calls
    // would fail
    flFreeList16.FreeMemoryBlocks();

    // Disable interop
    gfIteropEnabled = FALSE;
#if DBG==1
    // In debug builds zero out 16-bit callback function pointer so that
    // we fault in the 32-bit code if we call them hereafter
    memset( (LPVOID)&gdata16Data, 0, sizeof( DATA16 ) );
#endif 

    WgtDump();
#else
    thkAssert(!"IntOpUninitialize called on Win95");
#endif
    thkDebugOut((DEB_THUNKMGR | DEB_ITRACE, "OUT IntOpUninitialize\n"));
    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:	ConvertHr1632Thunk, public
//
//  Synopsis:	Trivial function to allow calling HRESULT conversion
//              functions from 16-bit
//
//  Arguments:	[hr] - HRESULT to convert
//              [dw1]
//              [dw2]
//
//  Returns:	Appropriate status code
//
//  History:	26-Sep-94	DrewB	Created
//
//  Notes:      Required because 16-bit calls to CallProc32W use three
//              arguments
//
//----------------------------------------------------------------------------

STDAPI ConvertHr1632Thunk(HRESULT hr, DWORD dw1, DWORD dw2)
{
    return TransformHRESULT_1632(hr);
}

//+---------------------------------------------------------------------------
//
//  Function:	ConvertHr3216Thunk, public
//
//  Synopsis:	Trivial function to allow calling HRESULT conversion
//              functions from 16-bit
//
//  Arguments:	[hr] - HRESULT to convert
//              [dw1]
//              [dw2]
//
//  Returns:	Appropriate status code
//
//  History:	26-Sep-94	DrewB	Created
//
//  Notes:      Required because 16-bit calls to CallProc32W use three
//              arguments
//
//----------------------------------------------------------------------------

STDAPI ConvertHr3216Thunk(HRESULT hr, DWORD dw1, DWORD dw2)
{
    return TransformHRESULT_3216(hr);
}

//+-------------------------------------------------------------------------
//
//  Function:  	ThkAddAppCompatFlag
//
//  Synopsis: 	Takes the given flag and ORs it into the current app
//		compatibility flag set
//
//  Effects:
//
//  Arguments:	[dwFlag]	-- flag to set
//
//  Requires:
//
//  Returns: 	void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//     		15-Mar-95 alexgo    author
//
//  Notes:	This function exists so that 16bit thunk dll's may
//		also set app compatibility flags.  olethk32 code typically
//		sets the flags directly via TlsThkSetAppCompatFlags
//
//--------------------------------------------------------------------------

STDAPI_(void) ThkAddAppCompatFlag( DWORD dwFlag )
{
    DWORD dw;

    dw = TlsThkGetAppCompatFlags();

    dw |= dwFlag;

    TlsThkSetAppCompatFlags(dw);
}


#if DBG == 1
static LONG _wgtAllocated = 0;

//+---------------------------------------------------------------------------
//
//  Function:	WgtAllocLock, public debug
//
//  Synopsis:	Tracking for WOWGlobalAllocLock16
//
//  History:	29-Nov-94	DrewB	Created
//
//----------------------------------------------------------------------------

VPVOID WgtAllocLock(WORD wFlags, DWORD cb, HMEM16 *ph)
{
    HMEM16 h;
    VPVOID vpv;

    vpv = WOWGlobalAllocLock16(wFlags, cb, &h);
    if (vpv != 0)
    {
#ifdef WGT_TRACK
        if (WOWGlobalLockSize16(h, &cb) != 0)
        {
            _wgtAllocated += cb;
            WOWGlobalUnlock16(h);
        }
        else
        {
            thkDebugOut((DEB_WARN,
                         "Unable to get size of allocated block 0x%04lX\n",
                         h));

            // This is a guess at how big a block Win16 will allocate
            _wgtAllocated += (cb+31) & 31;
        }
#endif

        if (ph != NULL)
        {
            *ph = h;
        }
    }
    else
    {
        thkDebugOut((DEB_WARN,
                     "Unable to allocate %d bytes of 16-bit memory\n",
                     cb));
    }

    return vpv;
}

//+---------------------------------------------------------------------------
//
//  Function:	WgtUnlockFree, public
//
//  Synopsis:	Tracking for WOWGlobalUnlockFree16
//
//  History:	29-Nov-94	DrewB	Created
//
//----------------------------------------------------------------------------

void WgtUnlockFree(VPVOID vpv)
{
    HMEM16 h;
    DWORD cb;

    if (vpv == 0)
    {
        thkDebugOut((DEB_WARN, "Attempt to free NULL\n"));
    }
    else
    {
#ifdef WGT_TRACK
        // Total hack, incorrect
        h = (HMEM16)(vpv >> 16);

        if (WOWGlobalLockSize16(h, &cb) != 0)
        {
            _wgtAllocated -= cb;
            WOWGlobalUnlock16(h);
        }
        else
        {
            thkDebugOut((DEB_WARN,
                         "Unable to get size of allocated block 0x%04lX\n",
                         h));
        }
#endif

        WOWGlobalUnlockFree16(vpv);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:	WgtDump, public
//
//  Synopsis:	Dumps global tracking information
//
//  History:	29-Nov-94	DrewB	Created
//
//----------------------------------------------------------------------------

void WgtDump(void)
{
    if (_wgtAllocated != 0)
    {
        thkDebugOut((DEB_WARN,
                     "%d bytes of 16-bit memory currently allocated\n",
                     _wgtAllocated));
    }
}

//+---------------------------------------------------------------------------
//
//  Function:	ThkCallOutputFunctions, public
//
//  Synopsis:	thunked pass-thru to Ole32 CallOutputFunctions for 16-bit land
//
//  History:	23-Jan-95	murthys	Created
//
//----------------------------------------------------------------------------

void ThkCallOutputFunctions(const char * buffer, PVOID dummy1, PVOID dummy2)
{
    CallOutputFunctions(buffer);
}

#endif // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\olethk32\map_kv.h ===
#ifndef __MAP_KV_H__
#define __MAP_KV_H__

//#include <memapi.hxx>

/////////////////////////////////////////////////////////////////////////////
// class CMapKeyToValue - a mapping from 'KEY's to 'VALUE's, passed in as
// pv/cb pairs.  The keys can be variable length, although we optmizize the
// case when they are all the same.
//
/////////////////////////////////////////////////////////////////////////////

STDAPI_(UINT) MKVDefaultHashKey(LPVOID pKey, UINT cbKey);

#ifdef WIN32
DECLARE_HANDLE(HMAPKEY);
#else
DECLARE_HANDLE32(HMAPKEY);
#endif

typedef UINT (STDAPICALLTYPE FAR* LPFNHASHKEY)(LPVOID, UINT);

class FAR CMapKeyToValue
{
public:
        CMapKeyToValue(UINT cbValue, UINT cbKey = 0,
                int nBlockSize=10,
                LPFNHASHKEY lpfnHashKey = NULL,
                UINT nHashSize = 17);
        ~CMapKeyToValue();

        // number of elements
        int     GetCount() const { return m_nCount; }
        BOOL    IsEmpty() const { return m_nCount == 0; }

        // Lookup; return FALSE if not found
        BOOL    Lookup(LPVOID pKey, UINT cbKey, LPVOID pValue) const;
        BOOL    LookupHKey(HMAPKEY hKey, LPVOID pValue) const;
        BOOL    LookupAdd(LPVOID pKey, UINT cbKey, LPVOID pValue) const;

        // add a new (key, value) pair; return FALSE if out of memory
        BOOL    SetAt(LPVOID pKey, UINT cbKey, LPVOID pValue);
        BOOL    SetAtHKey(HMAPKEY hKey, LPVOID pValue);

        // removing existing (key, ?) pair; return FALSE if no such key
        BOOL    RemoveKey(LPVOID pKey, UINT cbKey);
        BOOL    RemoveHKey(HMAPKEY hKey);
        void    RemoveAll();

        // iterating all (key, value) pairs
        POSITION GetStartPosition() const
                        { return (m_nCount == 0) ? (POSITION)NULL : BEFORE_START_POSITION; }
        void    GetNextAssoc(POSITION FAR* pNextPosition, LPVOID pKey,
                                UINT FAR* pcbKey, LPVOID pValue) const;

        // return HMAPKEY for given key; returns NULL if not currently in map
        HMAPKEY GetHKey(LPVOID pKey, UINT cbKey) const;

        void    AssertValid() const;

private:
        // abstracts, somewhat, variable and fixed sized keys; size is really
        // m_cbKeyInAssoc.
        union CKeyWrap
        {
                BYTE rgbKey[sizeof(LPVOID) + sizeof(UINT)];
                struct
                {
                        LPVOID pKey;
                        UINT cbKey;
                };
        };

        // Association of one key and one value; NOTE: even though in general
        // the size of the key and value varies, for any given map,
        // the size of an assoc is fixed.
        struct CAssoc
        {
                CAssoc  FAR* pNext;
                UINT    nHashValue; // needed for efficient iteration
                CKeyWrap key;           // size is really m_cbKeyInAssoc
                // BYTE rgbValue[m_cbValue];
        };

        UINT    SizeAssoc() const
                { return sizeof(CAssoc)-sizeof(CKeyWrap) + m_cbKeyInAssoc + m_cbValue; }
        CAssoc  FAR* NewAssoc(UINT hash, LPVOID pKey, UINT cbKey, LPVOID pValue);
        void    FreeAssoc(CAssoc FAR* pAssoc);
        BOOL    CompareAssocKey(CAssoc FAR* pAssoc, LPVOID pKey, UINT cbKey) const;
        CAssoc  FAR* GetAssocAt(LPVOID pKey, UINT cbKey, UINT FAR& nHash) const;

        BOOL    SetAssocKey(CAssoc FAR* pAssoc, LPVOID pKey, UINT cbKey) const;
        void    GetAssocKeyPtr(CAssoc FAR* pAssoc, LPVOID FAR* ppKey,UINT FAR* pcbKey) const;
        void    FreeAssocKey(CAssoc FAR* pAssoc) const;
        void    GetAssocValuePtr(CAssoc FAR* pAssoc, LPVOID FAR* ppValue) const;
        void    GetAssocValue(CAssoc FAR* pAssoc, LPVOID pValue) const;
        void    SetAssocValue(CAssoc FAR* pAssoc, LPVOID pValue) const;

        BOOL    InitHashTable();

        UINT    m_cbValue;
        UINT    m_cbKey;                        // variable length if 0
        UINT    m_cbKeyInAssoc;         // always non-zero

        CAssoc  FAR* FAR* m_pHashTable;
        UINT    m_nHashTableSize;
        LPFNHASHKEY m_lpfnHashKey;

        int     m_nCount;
        CAssoc  FAR* m_pFreeList;
        struct CPlex FAR* m_pBlocks;
        int     m_nBlockSize;
};


#endif // !__MAP_KV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\olethk32\map_dwp.h ===
////////////////////////////////////////////////////////////////////////////



class FAR CMapDwordPtr
{
public:
   // Construction
   CMapDwordPtr(UINT nBlockSize=10)
        : m_mkv(sizeof(void FAR*), sizeof(DWORD), nBlockSize) { }

   // Attributes
   // number of elements
   int     GetCount() const
                        { return m_mkv.GetCount(); }
   BOOL    IsEmpty() const
                        { return GetCount() == 0; }

   // Lookup
   BOOL    Lookup(DWORD key, void FAR* FAR& value) const
                        { return m_mkv.Lookup((LPVOID) &key, sizeof(DWORD), (LPVOID)&value); }

   BOOL    LookupHKey(HMAPKEY hKey, void FAR* FAR& value) const
                        { return m_mkv.LookupHKey(hKey, (LPVOID)&value); }

   BOOL    LookupAdd(DWORD key, void FAR* FAR& value) const
                        { return m_mkv.LookupAdd((LPVOID)&key, sizeof(DWORD), (LPVOID)&value); }

   // Add/Delete
   // add a new (key, value) pair
   BOOL    SetAt(DWORD key, void FAR* value)
                        { return m_mkv.SetAt((LPVOID) &key, sizeof(DWORD), (LPVOID)&value); }
   BOOL    SetAtHKey(HMAPKEY hKey, void FAR* value)
                        { return m_mkv.SetAtHKey(hKey, (LPVOID)&value); }

   // removing existing (key, ?) pair
   BOOL    RemoveKey(DWORD key)
                        { return m_mkv.RemoveKey((LPVOID) &key, sizeof(DWORD)); }

   BOOL    RemoveHKey(HMAPKEY hKey)
                        { return m_mkv.RemoveHKey(hKey); }

   void    RemoveAll()
                        { m_mkv.RemoveAll(); }


   // iterating all (key, value) pairs
   POSITION GetStartPosition() const
                        { return m_mkv.GetStartPosition(); }

   void    GetNextAssoc(POSITION FAR& rNextPosition, DWORD FAR& rKey, void FAR* FAR& rValue) const
                        { m_mkv.GetNextAssoc(&rNextPosition, (LPVOID)&rKey, NULL, (LPVOID)&rValue); }

   HMAPKEY GetHKey(DWORD key) const
                        { return m_mkv.GetHKey((LPVOID)&key, sizeof(DWORD)); }

#ifdef _DEBUG
   void    AssertValid() const
                        { m_mkv.AssertValid(); }
#endif

private:
   CMapKeyToValue m_mkv;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\olethk32\stalloc.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	stalloc.cxx
//
//  Contents:	CStackAllocator
//
//  History:	29-Sep-94	DrewB	Created
//
//  Notes:      Loosely based on BobDay's original PSTACK implementation
//
//----------------------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

// Pad a count to the given alignment
// Alignment must be 2^n-1
#define ALIGN_CB(cb, align) \
    (((cb)+(align)) & ~(align))

//+---------------------------------------------------------------------------
//
//  Structure:	SStackBlock (sb)
//
//  Purpose:	Header information for stack blocks
//
//  History:	29-Sep-94	DrewB	Created
//
//----------------------------------------------------------------------------

struct SStackBlock
{
    DWORD dwNextBlock;
    DWORD dwStackTop;
};

#define BLOCK_OVERHEAD (sizeof(SStackBlock))
#define BLOCK_START(mem) ((mem)+BLOCK_OVERHEAD)
#define BLOCK_AVAILABLE(cb) ((cb)-BLOCK_OVERHEAD)

//+---------------------------------------------------------------------------
//
//  Function:	CStackAllocator::CStackAllocator, public
//
//  Arguments:	[pmm] - Memory model to use
//              [cbBlock] - Size of chunk to allocate when necessary
//              [cbAlignment] - Alignment size, must be 2^N
//
//  History:	29-Sep-94	DrewB	Created
//
//----------------------------------------------------------------------------

CStackAllocator::CStackAllocator(CMemoryModel *pmm,
                                 DWORD cbBlock,
                                 DWORD cbAlignment)
{
    thkAssert(BLOCK_AVAILABLE(cbBlock) > 0);

    // Ensure that the alignment is a power of two
    thkAssert((cbAlignment & (cbAlignment-1)) == 0);
    // Store alignment - 1 since that's the actual value we need for
    // alignment computations
    _cbAlignment = cbAlignment-1;

    // Ensure that overhead and tracking will not affect alignment
    thkAssert(ALIGN_CB(BLOCK_OVERHEAD, _cbAlignment) == BLOCK_OVERHEAD &&
              ALIGN_CB(sizeof(SStackMemTrace), _cbAlignment) ==
              sizeof(SStackMemTrace));

    _pmm = pmm;
    _cbBlock = cbBlock;
    _dwBlocks = 0;
    _dwCurrent = 0;
    _cbAvailable = 0;

    _psaNext = NULL;
    _fActive = TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:	CStackAllocator::~CStackAllocator, public virtual
//
//  History:	29-Sep-94	DrewB	Created
//
//----------------------------------------------------------------------------

CStackAllocator::~CStackAllocator(void)
{
    Reset();
}

//+---------------------------------------------------------------------------
//
//  Function:   CStackAllocator::Alloc, public
//
//  Synopsis:   Allocates a chunk of memory from the stack
//
//  Arguments:  [cb] - Amount of memory to allocate
//
//  Returns:    Pointer to memory or NULL
//
//  History:    29-Sep-94       DrewB   Created
//
//----------------------------------------------------------------------------

DWORD CStackAllocator::Alloc(DWORD cb)
{
    DWORD dwMem;

    thkAssert(cb > 0);

    // Round size up to maintain alignment of stack
    cb = ALIGN_CB(cb, _cbAlignment);

#if DBG == 1
    // Reserve space to record caller
    cb += sizeof(SStackMemTrace);
#endif

    thkAssert(cb <= BLOCK_AVAILABLE(_cbBlock));

    // Check to see if the current block can hold the new allocation
    if (cb > _cbAvailable)
    {
        DWORD dwBlock;
        SStackBlock UNALIGNED *psb;

        // It's too big, so allocate a new block
        dwBlock = _pmm->AllocMemory(_cbBlock);
        if (dwBlock == 0)
        {
            return 0;
        }

        if (_dwBlocks != 0)
        {
            // Update current top block
            psb = (SStackBlock UNALIGNED *)
                _pmm->ResolvePtr(_dwBlocks, sizeof(SStackBlock));
            psb->dwStackTop = _dwCurrent;
            _pmm->ReleasePtr(_dwBlocks);
        }

        // Make the new block the top block
        psb = (SStackBlock UNALIGNED *)
            _pmm->ResolvePtr(dwBlock, sizeof(SStackBlock));
        psb->dwNextBlock = _dwBlocks;
        _dwBlocks = dwBlock;
        _pmm->ReleasePtr(dwBlock);

        _dwCurrent = BLOCK_START(dwBlock);
        _cbAvailable = BLOCK_AVAILABLE(_cbBlock);
    }

    thkAssert(_cbAvailable >= cb);

    dwMem = _dwCurrent;
    _dwCurrent += cb;
    _cbAvailable -= cb;

#if DBG == 1
    void *pvMem;

    // Fill memory to show reuse problems
    pvMem = _pmm->ResolvePtr(dwMem, cb);
    memset(pvMem, 0xED, cb);
    _pmm->ReleasePtr(dwMem);
#endif

#if DBG == 1
    SStackMemTrace UNALIGNED *psmt;

    psmt = (SStackMemTrace UNALIGNED *)
        _pmm->ResolvePtr(_dwCurrent-sizeof(SStackMemTrace),
                         sizeof(SStackMemTrace));
    psmt->cbSize = cb-sizeof(SStackMemTrace);

#if !defined(_CHICAGO_)
    //
    // On RISC platforms, psmt points to an unaligned structure.
    // Use a temp variable so we don't get an alignment fault
    // when RtlGetCallersAddress returns the value.
    //
    void *pv;
    void *pvCaller;
    RtlGetCallersAddress(&pvCaller, &pv);
    psmt->pvCaller = pvCaller;
#else
    // Depends on return address being directly below first argument
    psmt->pvCaller = *((void **)&cb-1);
#endif

    thkDebugOut((DEB_MEMORY, "Stack: %p alloc 0x%08lX:%3d, avail %d\n",
                 psmt->pvCaller, dwMem, cb, _cbAvailable));

    _pmm->ReleasePtr(_dwCurrent-sizeof(SStackMemTrace));
#endif

    return dwMem;
}

//+---------------------------------------------------------------------------
//
//  Function:   CStackAllocator::Free, public
//
//  Synopsis:   Frees allocated memory
//
//  Arguments:  [dwMem] - Memory
//              [cb] - Amount of memory allocated
//
//  History:    29-Sep-94       DrewB   Created
//
//----------------------------------------------------------------------------

void CStackAllocator::Free(DWORD dwMem, DWORD cb)
{
    thkAssert(dwMem != 0);
    thkAssert(cb > 0);

    // Round size up to maintain alignment of stack
    cb = ALIGN_CB(cb, _cbAlignment);

#if DBG == 1
    cb += sizeof(SStackMemTrace);
#endif

    thkAssert(cb <= BLOCK_AVAILABLE(_cbBlock));

#if DBG == 1
    void *pvCaller;

#if !defined(_CHICAGO_)
    void *pv;
    RtlGetCallersAddress(&pvCaller, &pv);
#else
    // Depends on return address being directly below first argument
    pvCaller = *((void **)&dwMem-1);
#endif

    thkDebugOut((DEB_MEMORY, "Stack: %p frees 0x%08lX:%3d, avail %d\n",
                 pvCaller, dwMem, cb, _cbAvailable));
#endif

#if DBG == 1
    if (_dwCurrent-cb != dwMem)
    {
        thkDebugOut((DEB_ERROR, "Free of %d:%d is not TOS (0x%08lX)\n",
                     dwMem, cb, _dwCurrent));

        thkAssert(_dwCurrent-cb == dwMem);
    }
#endif

    _dwCurrent -= cb;
    _cbAvailable += cb;

#if DBG == 1
    void *pvMem;

    // Fill memory to show reuse problems
    pvMem = _pmm->ResolvePtr(dwMem, cb);
    memset(pvMem, 0xDD, cb);
    _pmm->ReleasePtr(dwMem);
#endif

    if (_dwCurrent == BLOCK_START(_dwBlocks))
    {
        SStackBlock UNALIGNED *psb;
        DWORD dwBlock;

        // If we've just freed up an entire block and it's not the
        // only block for the stack, free the block itself and
        // restore stack state from the next block
        // We keep the first block around forever to avoid memory
        // thrashing

        psb = (SStackBlock UNALIGNED *)
            _pmm->ResolvePtr(_dwBlocks, sizeof(SStackBlock));
        dwBlock = psb->dwNextBlock;
        _pmm->ReleasePtr(_dwBlocks);

        if (dwBlock != 0)
        {
            _pmm->FreeMemory(_dwBlocks);

            _dwBlocks = dwBlock;
            psb = (SStackBlock UNALIGNED *)
                _pmm->ResolvePtr(_dwBlocks, sizeof(SStackBlock));
            _dwCurrent = psb->dwStackTop;
            _cbAvailable = _cbBlock-(_dwCurrent-_dwBlocks);
            _pmm->ReleasePtr(_dwBlocks);
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:	CStackAllocator::Reset, public
//
//  Synopsis:	Releases all memory in the stack
//
//  History:	29-Sep-94	DrewB	Created
//
//----------------------------------------------------------------------------

void CStackAllocator::Reset(void)
{
    DWORD dwBlock;
    SStackBlock UNALIGNED *psb;

    while (_dwBlocks != 0)
    {
        psb = (SStackBlock UNALIGNED *)
            _pmm->ResolvePtr(_dwBlocks, sizeof(SStackBlock));
        dwBlock = psb->dwNextBlock;
        _pmm->ReleasePtr(_dwBlocks);

        _pmm->FreeMemory(_dwBlocks);

        _dwBlocks = dwBlock;
    }

    _dwCurrent = 0;
    _cbAvailable = 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   CStackAllocator::RecordState, public debug
//
//  Synopsis:   Records the current state of the stack
//
//  Arguments:  [psr] - Storage space for information
//
//  Modifies:   [psr]
//
//  History:    28-Apr-94       DrewB   Created
//
//----------------------------------------------------------------------------

#if DBG == 1
void CStackAllocator::RecordState(SStackRecord *psr)
{
    psr->dwStackPointer = _dwCurrent;
    psr->dwThreadId = GetCurrentThreadId();
}
#endif

//+---------------------------------------------------------------------------
//
//  Function:   CStackAllocator::CheckState, public debug
//
//  Synopsis:   Checks recorded information about the stack against its
//              current state
//
//  Arguments:  [psr] - Recorded information
//
//  History:    28-Apr-94       DrewB   Created
//
//----------------------------------------------------------------------------

#if DBG == 1
void CStackAllocator::CheckState(SStackRecord *psr)
{
    thkAssert(psr->dwThreadId == GetCurrentThreadId());

    if ((psr->dwStackPointer != 0 && psr->dwStackPointer != _dwCurrent) ||
        (psr->dwStackPointer == 0 &&
         _dwCurrent != 0 && _dwCurrent != BLOCK_START(_dwBlocks)))
    {
        thkDebugOut((DEB_ERROR, "Stack alloc change: 0x%08lX to 0x%08lX\n",
                     psr->dwStackPointer, _dwCurrent));

        if (_dwCurrent > BLOCK_START(_dwBlocks))
        {
            SStackMemTrace UNALIGNED *psmt;

            psmt = (SStackMemTrace UNALIGNED *)
                _pmm->ResolvePtr(_dwCurrent-sizeof(SStackMemTrace),
                                 sizeof(SStackMemTrace));
            thkDebugOut((DEB_ERROR, "Top alloc: %d bytes by %p\n",
                         psmt->cbSize, psmt->pvCaller));
            _pmm->ReleasePtr(_dwCurrent-sizeof(SStackMemTrace));
        }

        thkAssert(!((psr->dwStackPointer != 0 &&
                     psr->dwStackPointer != _dwCurrent) ||
                    (psr->dwStackPointer == 0 &&
                     _dwCurrent != 0 ||
                      _dwCurrent != BLOCK_START(_dwBlocks))));
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\olethk32\thkmgr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       thkmgr.cxx
//
//  Contents:   Thunk manager initialization
//              IUnknown transition functions
//
//  History:    5-18-94   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Function:   ThkMgrInitialize
//
//  Synopsis:   Creates a new thunkmanager and set it for given thread
//
//  Arguments:  [dw1]
//              [dw2]
//              [dw3]
//
//  Returns:    HRESULT
//
//  History:    5-18-94   JohannP (Johann Posch)   Created
//
//  Notes:      Called from CoInitialize
//
//----------------------------------------------------------------------------
STDAPI ThkMgrInitialize(DWORD dw1, DWORD dw2, DWORD dw3)
{
    CThkMgr *pcthkmgr = NULL;

    thkDebugOut((DEB_THUNKMGR, "In  ThkMgrInitialize()\n"));

    //
    // If we are already initialized, do nothing.
    //
    if (TlsGetValue(dwTlsThkIndex) != NULL)
    {
	thkDebugOut((DEB_THUNKMGR, "OUT ThkMgrInitialize() Already Init\n"));
	return(NOERROR);
    }

    //
    // initialize the Tls storage
    //
    if ( NOERROR != TlsThkInitialize())
    {
	thkDebugOut((DEB_ERROR, "TlsThkInitialize failed"));

	return E_OUTOFMEMORY;
    }

    thkAssert(TlsThkGetThkMgr() == NULL);

    pcthkmgr = CThkMgr::Create();
    TlsThkSetThkMgr(pcthkmgr);

    thkDebugOut((DEB_THUNKMGR, "Out ThkMgrInitialize() => %p\n",
                 pcthkmgr));

    return (pcthkmgr == NULL) ? E_OUTOFMEMORY : NOERROR;
}

//+---------------------------------------------------------------------------
//
//  Function:   ThkMgrUninitialize
//
//  Synopsis:   deletes the thunkmanager and removes it from thread data
//              tls data are removed as well
//
//  Arguments:  [dw1]
//              [dw2]
//              [dw3]
//
//  History:    5-18-94   JohannP (Johann Posch)   Created
//
//  Notes:      Called during CoUninitialize
//
//----------------------------------------------------------------------------
STDAPI_(void) ThkMgrUninitialize(DWORD dw1, DWORD dw2, DWORD dw3)
{
    thkDebugOut((DEB_THUNKMGR, "In ThkMgrUninitialize()\n"));

    thkAssert(TlsGetValue(dwTlsThkIndex) != NULL);

    CThkMgr *pcthkmgr = (CThkMgr*)TlsThkGetThkMgr();
    if (pcthkmgr != NULL)
    {
        // Note: the thunkmanger gets removed from tlsthk
        delete pcthkmgr;
    }

    // If we weren't called from 16-bit code then it's not safe to reset
    // the 16-bit stack allocator here because we may be doing this
    // in thread cleanup and it may not be safe to call back into
    // 16-bit code

    TlsThkGetStack32()->Reset();

    // uninitialize the tls data for this apartment
    TlsThkUninitialize();

    thkDebugOut((DEB_THUNKMGR, "Out ThkMgrUninitialize()\n"));
}

//+---------------------------------------------------------------------------
//
//  Function:   IUnknownObj32
//
//  Synopsis:   Entry point from 16bit for IUnknown methods
//
//  Arguments:  [vpvThis16] -- Proxy object
//              [wMethod] -- IUnknown method
//              [vpvData] -- Call data
//
//  Returns:    Call result, pdata contains out data for particular call
//
//  History:    5-18-94   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
STDAPI_(DWORD) IUnknownObj32(VPVOID vpvThis16, DWORD wMethod, VPVOID vpvData)
{
    DWORD dwRet;
    LONG vpvInterface;
    IID iid;

    if (TlsThkGetData() == NULL)
    {
        thkDebugOut((DEB_WARN, "WARNING: IUnknownObj32 call refused\n"));

        if (wMethod == SMI_QUERYINTERFACE)
        {
            return (DWORD)E_FAIL;
        }
        else
        {
            return 0;
        }
    }

    // Note: at this point we should always get a thunkmanager
    CThkMgr *pcthkmgr = (CThkMgr*)TlsThkGetThkMgr();
    thkAssert(pcthkmgr != NULL && "ThunkManager was not initialized");

    thkAssert(vpvThis16 != 0 && "IUnknownObj32: invalid pointer." );
    thkAssert(wMethod < SMI_COUNT);

    switch (wMethod)
    {
    case SMI_QUERYINTERFACE:
        thkAssert(vpvData != NULL &&
                  "IUnknownObj32.QueryInterface without IID");

        // Copy the 16-bit IID into 32-bit memory for the real call
        iid = *FIXVDMPTR(vpvData, IID);
        RELVDMPTR(vpvData);

        thkDebugOut((DEB_UNKNOWN,
                     "%sIn  QueryInterface1632(%p, %s)\n",
                     NestingLevelString(), vpvThis16,
                     IidOrInterfaceString(&iid)));

        dwRet = pcthkmgr->QueryInterfaceProxy1632(vpvThis16, iid,
                                                  (void **)&vpvInterface);

        // Translate the 32-bit HRESULT to a 16-bit HRESULT
        dwRet = (DWORD)TransformHRESULT_3216((HRESULT)dwRet);

        // Pass the return interface pointer back through the IID
        // memory.  We re-resolve the data pointer since nested
        // calls may have occurred
        (FIXVDMPTR(vpvData, IID))->Data1 = vpvInterface;
        RELVDMPTR(vpvData);

        thkDebugOut((DEB_UNKNOWN,
                     "%sOut QueryInterface1632(%p) => %p, 0x%08lX\n",
                     NestingLevelString(), vpvThis16, vpvInterface, dwRet));
        break;

    case SMI_ADDREF:
        thkDebugOut((DEB_UNKNOWN, "%sIn  AddRef1632(%p)\n",
                     NestingLevelString(), vpvThis16));

        dwRet = pcthkmgr->AddRefProxy1632(vpvThis16);

        thkDebugOut((DEB_UNKNOWN, "%sOut AddRef1632(%p) => %d\n",
                     NestingLevelString(), vpvThis16, dwRet));
        break;

    case SMI_RELEASE:
        thkDebugOut((DEB_UNKNOWN, "%sIn  Release1632(%p)\n",
                     NestingLevelString(), vpvThis16));

        dwRet = pcthkmgr->ReleaseProxy1632(vpvThis16);

        thkDebugOut((DEB_UNKNOWN, "%sOut Release1632(%p) => %d\n",
                     NestingLevelString(), vpvThis16, dwRet));
        break;
    }

    return dwRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   QueryInterfaceProxy3216
//
//  Synopsis:   call QueryInterface on a 32 bit proxy
//
//  Arguments:  [pto] -- This pointer (a 32->16 proxy)
//              [refiid] -- Interface queried for
//              [ppv] -- Interface return
//
//  Returns:    HRESULT
//
//  History:    5-18-94   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
SCODE QueryInterfaceProxy3216(THUNK3216OBJ *pto, REFIID refiid, LPVOID *ppv)
{
    HRESULT hrRet;

    thkDebugOut((DEB_UNKNOWN, "%sIn  QueryInterface3216(%p, %s)\n",
                 NestingLevelString(), pto,
                 IidOrInterfaceString(&refiid)));
    DebugIncrementNestingLevel();

    if (TlsThkGetData() == NULL)
    {
        thkDebugOut((DEB_WARN, "WARNING: QIProxy3216 call refused\n"));

        return E_FAIL;
    }

    CThkMgr *pcthkmgr = TlsThkGetThkMgr();
    thkAssert(pcthkmgr != NULL && "ThunkManager was not initialized");

    if ( pto->grfFlags & PROXYFLAG_CLEANEDUP )
    {
        thkDebugOut((DEB_WARN,
                     "QueryInterfaceProxy3216: Attempt to QI "
                     "on cleaned-up proxy %08lX for 16-bit object %08lX %s\n",
                     pto, pto->vpvThis16,
                     IidIdxString(IID_IIDIDX(&refiid)) ));
        *ppv = NULL;
        return E_FAIL;
    }

    hrRet = pcthkmgr->QueryInterfaceProxy3216(pto, refiid, ppv);

    //
    // If the QI for IUnknown failed, then return the current this
    // pointer as the IUnknown. Watermark 1.02 appears to not support
    // IUnknown in its IOleInPlaceActiveObject interface, which causes
    // CoMarshalInterface to fail. The reason it used to work is the
    // original 16-bit DLL's would just use the provided pointer as
    // the punk if IUnknown wasn't supported. The following lines of
    // code emulate that behaviour.
    //
    if ((hrRet == E_NOINTERFACE) && IsEqualIID(refiid,IID_IUnknown))
    {
	thkDebugOut((DEB_UNKNOWN,
                 "%s Object %p didn't support QI(IID_IUnknown): Faking it\n",
                 NestingLevelString(), pto));
	((IUnknown *)pto)->AddRef();
	*ppv = pto;
	hrRet = S_OK;
    }

    DebugDecrementNestingLevel();
    thkDebugOut((DEB_UNKNOWN,
                 "%sOut QueryInterface3216(%p) => %p, ret:0x%08lX\n",
                 NestingLevelString(), pto, *ppv, hrRet));
    return hrRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   AddRefProxy3216
//
//  Synopsis:   call addref on an 16 bit object
//
//  Arguments:  [pto] -- This pointer (a 32->16 proxy)
//
//  Returns:    New refcount
//
//  History:    5-18-94   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
DWORD AddRefProxy3216(THUNK3216OBJ *pto)
{
    DWORD   dwRet;

    thkDebugOut((DEB_UNKNOWN, "%sIn  AddRef3216(%p)\n",
                 NestingLevelString(), pto));
    DebugIncrementNestingLevel();

    if (TlsThkGetData() == NULL)
    {
        thkDebugOut((DEB_WARN, "WARNING: AddRefProxy3216 call refused\n"));

        return 0;
    }

    CThkMgr *pcthkmgr = TlsThkGetThkMgr();
    thkAssert(pcthkmgr != NULL && "ThunkManager was not initialized");

    if ( pto->grfFlags & PROXYFLAG_CLEANEDUP )
    {
        thkDebugOut((DEB_WARN,
                     "AddRefProxy3216: Attempt to AddRef "
                     "on cleaned-up proxy %08lX for 16-bit object %08lX\n",
                     pto, pto->vpvThis16));
        return 0;
    }

    dwRet = pcthkmgr->AddRefProxy3216(pto);

    DebugDecrementNestingLevel();
    thkDebugOut((DEB_UNKNOWN, "%sOut AddRef3216(%p) => %ld\n",
                 NestingLevelString(), pto, dwRet));

    return dwRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   ReleaseProxy3216
//
//  Synopsis:   Release implementation for 32->16 proxies
//
//  Arguments:  [pto] -- This pointer (a 32->16 proxy)
//
//  Returns:    New refcount
//
//  History:    5-18-94   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
DWORD ReleaseProxy3216(THUNK3216OBJ *pto)
{
    DWORD   dwRet;

    thkDebugOut((DEB_UNKNOWN, "%sIn  Release3216(%p)\n",
                 NestingLevelString(), pto));
    DebugIncrementNestingLevel();

    if (TlsThkGetData() == NULL)
    {
        thkDebugOut((DEB_WARN, "WARNING: ReleaseProxy3216 call refused\n"));

        return 0;
    }

    CThkMgr *pcthkmgr = TlsThkGetThkMgr();
    thkAssert(pcthkmgr != NULL && "ThunkManager was not initialized");

    if ( pto->grfFlags & PROXYFLAG_CLEANEDUP )
    {
        thkDebugOut((DEB_WARN,
                     "ReleaseProxy3216: Attempt to Release "
                     "on cleaned-up proxy %08lX for 16-bit object %08lX\n",
                     pto, pto->vpvThis16));
        return 0;
    }

    dwRet = pcthkmgr->ReleaseProxy3216(pto);

    DebugDecrementNestingLevel();
    thkDebugOut((DEB_UNKNOWN, "%sOut Release3216(%p) => %ld\n",
                 NestingLevelString(), pto, dwRet));

    return dwRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   QueryInterfaceOnObj16
//
//  Synopsis:   call QueryInterface on an 16 bit object
//
//  Arguments:  [vpvThis16] -- 16-bit this pointer
//              [refiid] -- IID
//              [ppv] -- Interface return
//
//  Returns:    HRESULT
//
//  History:    5-18-94   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------

struct QIARGS
{
    IID iid;
    void *pvObject;
};

HRESULT QueryInterfaceOnObj16(VPVOID vpvThis16, REFIID refiid, LPVOID *ppv)
{
    HRESULT hrRet;
    VPVOID vpvArgs;
    QIARGS UNALIGNED *pqa;
    BYTE bArgs32[WCB16_MAX_CBARGS];

    thkDebugOut((DEB_THUNKMGR, "%sIn  QueryInterfaceOnObj16(%p, %s)\n",
                 NestingLevelString(), vpvThis16,
                 IidOrInterfaceString(&refiid)));
    DebugIncrementNestingLevel();

    thkAssert(WCB16_MAX_CBARGS >= 3*sizeof(DWORD));
    thkAssert(vpvThis16 != 0 && "QueryInterfaceOnObj16: invalid pointer.");

    // Allocate space for the sixteen bit arguments memory
    vpvArgs = STACKALLOC16(sizeof(QIARGS));
    if (vpvArgs == 0)
    {
        return E_OUTOFMEMORY;
    }

    // Fill in the in-param memory
    pqa = FIXVDMPTR(vpvArgs, QIARGS);
    pqa->iid = refiid;

    // Set up the 16-bit stack in pascal order
    *(VPVOID *)(bArgs32+0*sizeof(VPVOID)) = vpvArgs+
        FIELD_OFFSET(QIARGS, pvObject);
    *(VPVOID *)(bArgs32+1*sizeof(VPVOID)) = vpvArgs;
    *(VPVOID *)(bArgs32+2*sizeof(VPVOID)) = vpvThis16;

    RELVDMPTR(vpvArgs);

    // Call to 16-bit stub
    if (!CallbackTo16Ex(gdata16Data.fnQueryInterface16, WCB16_PASCAL,
                         3*sizeof(DWORD), bArgs32, (DWORD *)&hrRet))
    {
        hrRet = E_UNEXPECTED;
    }

    // Transform the 16-bit HRESULT to a 32-bit HRESULT
    hrRet = TransformHRESULT_1632(hrRet);

    // Copy back out-param memory
    pqa = FIXVDMPTR(vpvArgs, QIARGS);
    *ppv = pqa->pvObject;
    RELVDMPTR(vpvArgs);

    STACKFREE16(vpvArgs, sizeof(QIARGS));

    DebugDecrementNestingLevel();
    thkDebugOut((DEB_THUNKMGR,
                 "%sOut QueryInterfaceOnObj16(%p) => %p, ret:0x%08lX\n",
                 NestingLevelString(), vpvThis16, *ppv, hrRet));

    return hrRet;
}

//+---------------------------------------------------------------------------
//
//  Function:   AddRefOnObj16
//
//  Synopsis:   calls addref on an 16 bit object
//
//  Arguments:  [vpvThis16] -- 16-bit this pointer
//
//  Returns:    New ref count
//
//  History:    5-18-94   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#if DBG == 1
DWORD AddRefOnObj16(VPVOID vpvThis16)
{
    DWORD dwRet;

    thkDebugOut((DEB_THUNKMGR, "%sIn  AddRefOnObj16(%p)\n",
                 NestingLevelString(), vpvThis16));
    DebugIncrementNestingLevel();

    dwRet = CallbackTo16(gdata16Data.fnAddRef16, vpvThis16);

    DebugDecrementNestingLevel();
    thkDebugOut((DEB_THUNKMGR, "%sOut AddRefOnObj16(%p) => %ld\n",
                 NestingLevelString(), vpvThis16, dwRet));

    return dwRet;
}
#endif

//+---------------------------------------------------------------------------
//
//  Function:   ReleaseOnObj16
//
//  Synopsis:   Release a 16-bit object
//
//  Arguments:  [vpvThis16] -- 16-bit this pointer
//
//  Returns:    New ref count
//
//  History:    5-18-94   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#if DBG == 1
DWORD ReleaseOnObj16(VPVOID vpvThis16)
{
    DWORD dwRet;

    thkDebugOut((DEB_THUNKMGR, "%sIn  ReleaseOnObj16(%p)\n",
                 NestingLevelString(), vpvThis16));
    DebugIncrementNestingLevel();

    dwRet = CallbackTo16(gdata16Data.fnRelease16, vpvThis16);

#if DBG==1
    if(dwRet==0 && TlsThkGetThkMgr()->GetThkState()==THKSTATE_VERIFY16INPARAM) {
        thkDebugOut((DEB_WARN, "WARINING: 16-bit 0x%x IN parameter with zero "
                               "ref count\n", vpvThis16));
     
        if(thkInfoLevel & DEB_DBGFAIL)
            thkAssert(!"Wish to Debug");
    }
#endif

    DebugDecrementNestingLevel();
    thkDebugOut((DEB_THUNKMGR, "%sOut ReleaseOnObj16(%p) => %ld\n",
                 NestingLevelString(), vpvThis16, dwRet));

    return dwRet;
}
#endif

#if DBG == 1
void DebugDump()
{
    CThkMgr *pcthkmgr = (CThkMgr*)TlsThkGetThkMgr();
    thkAssert(pcthkmgr != NULL && "ThunkManager was not initialized");
    pcthkmgr->DebugDump3216();
    pcthkmgr->DebugDump1632();
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\olethk32\thopiint.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	thopiint.cxx
//
//  Notes:	This file is automatically generated
//		Do not modify by hand
//
//  History:	Fri May 27 10:39:02 1994	Generated
//
//----------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#include "thopsint.cxx"
#include "thtblint.cxx"
#include "vtblifn.cxx"
#include "vtblint.cxx"
#include "fntomthd.cxx"

THOPI CONST athopiInterfaceThopis[] =
{
    apthopsIUnknown, 3, tfnIUnknown, NULL
,    apthopsIClassFactory, 5, tfnIClassFactory, ftmIClassFactory
,    apthopsIMarshal, 9, tfnIMarshal, ftmIMarshal
,    apthopsIStdMarshalInfo, 4, tfnIStdMarshalInfo, ftmIStdMarshalInfo
,    apthopsIMessageFilter, 6, tfnIMessageFilter, ftmIMessageFilter
,    apthopsIExternalConnection, 5, tfnIExternalConnection, ftmIExternalConnection
,    apthopsIEnumString, 7, tfnIEnumString, ftmIEnumString
,    apthopsIEnumUnknown, 7, tfnIEnumUnknown, ftmIEnumUnknown
,    apthopsIEnumSTATSTG, 7, tfnIEnumSTATSTG, ftmIEnumSTATSTG
,    apthopsILockBytes, 10, tfnILockBytes, ftmILockBytes
,    apthopsIStream, 14, tfnIStream, ftmIStream
,    apthopsIStorage, 18, tfnIStorage, ftmIStorage
,    apthopsIRootStorage, 4, tfnIRootStorage, ftmIRootStorage
,    apthopsIEnumFORMATETC, 7, tfnIEnumFORMATETC, ftmIEnumFORMATETC
,    apthopsIEnumSTATDATA, 7, tfnIEnumSTATDATA, ftmIEnumSTATDATA
,    apthopsIDataObject, 12, tfnIDataObject, ftmIDataObject
,    apthopsIViewObject, 9, tfnIViewObject, ftmIViewObject
,    apthopsIViewObject2, 10, tfnIViewObject2, ftmIViewObject2
,    apthopsIAdviseSink, 8, tfnIAdviseSink, ftmIAdviseSink
,    apthopsIAdviseSink2, 9, tfnIAdviseSink2, ftmIAdviseSink2
,    apthopsIDataAdviseHolder, 7, tfnIDataAdviseHolder, ftmIDataAdviseHolder
,    apthopsIOleCache, 8, tfnIOleCache, ftmIOleCache
,    apthopsIOleCache2, 10, tfnIOleCache2, ftmIOleCache2
,    apthopsIOleCacheControl, 5, tfnIOleCacheControl, ftmIOleCacheControl
,    apthopsIDropTarget, 7, tfnIDropTarget, ftmIDropTarget
,    apthopsIDropSource, 5, tfnIDropSource, ftmIDropSource
,    apthopsIPersist, 4, tfnIPersist, ftmIPersist
,    apthopsIPersistStorage, 10, tfnIPersistStorage, ftmIPersistStorage
,    apthopsIPersistStream, 8, tfnIPersistStream, ftmIPersistStream
,    apthopsIPersistFile, 9, tfnIPersistFile, ftmIPersistFile
,    apthopsIBindCtx, 13, tfnIBindCtx, ftmIBindCtx
,    apthopsIMoniker, 23, tfnIMoniker, ftmIMoniker
,    apthopsIRunningObjectTable, 10, tfnIRunningObjectTable, ftmIRunningObjectTable
,    apthopsIEnumMoniker, 7, tfnIEnumMoniker, ftmIEnumMoniker
,    apthopsIEnumOLEVERB, 7, tfnIEnumOLEVERB, ftmIEnumOLEVERB
,    apthopsIOleObject, 24, tfnIOleObject, ftmIOleObject
,    apthopsIOleClientSite, 9, tfnIOleClientSite, ftmIOleClientSite
,    apthopsIRunnableObject, 8, tfnIRunnableObject, ftmIRunnableObject
,    apthopsIParseDisplayName, 4, tfnIParseDisplayName, ftmIParseDisplayName
,    apthopsIOleContainer, 6, tfnIOleContainer, ftmIOleContainer
,    apthopsIOleItemContainer, 9, tfnIOleItemContainer, ftmIOleItemContainer
,    apthopsIOleAdviseHolder, 9, tfnIOleAdviseHolder, ftmIOleAdviseHolder
,    apthopsIOleLink, 14, tfnIOleLink, ftmIOleLink
,    apthopsIOleWindow, 5, tfnIOleWindow, ftmIOleWindow
,    apthopsIOleInPlaceObject, 9, tfnIOleInPlaceObject, ftmIOleInPlaceObject
,    apthopsIOleInPlaceActiveObject, 10, tfnIOleInPlaceActiveObject, ftmIOleInPlaceActiveObject
,    apthopsIOleInPlaceUIWindow, 9, tfnIOleInPlaceUIWindow, ftmIOleInPlaceUIWindow
,    apthopsIOleInPlaceFrame, 15, tfnIOleInPlaceFrame, ftmIOleInPlaceFrame
,    apthopsIOleInPlaceSite, 15, tfnIOleInPlaceSite, ftmIOleInPlaceSite
,    apthopsIRpcChannelBuffer, 8, tfnIRpcChannelBuffer, ftmIRpcChannelBuffer
,    apthopsIRpcProxyBuffer, 5, tfnIRpcProxyBuffer, ftmIRpcProxyBuffer
,    apthopsIRpcStubBuffer, 10, tfnIRpcStubBuffer, ftmIRpcStubBuffer
,    apthopsIPSFactoryBuffer, 5, tfnIPSFactoryBuffer, ftmIPSFactoryBuffer
,    apthopsIRpcChannel, 7, tfnIRpcChannel, ftmIRpcChannel
,    apthopsIRpcProxy, 5, tfnIRpcProxy, ftmIRpcProxy
,    apthopsIRpcStub, 8, tfnIRpcStub, ftmIRpcStub
,    apthopsIPSFactory, 5, tfnIPSFactory, ftmIPSFactory
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\olethk32\tc1632.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       tc1632.cxx
//
//  Notes:      This file is automatically generated
//      Do not modify by hand
//
//  History:    Fri May 27 10:39:02 1994        Generated
//
//----------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#if DBG == 1
extern "C" ULONG ThunkCall1632_count = 0;
extern "C" ULONG ThunkCall1632_break = 0;
#endif

DWORD ThunkCall1632(THUNKINFO *pti)
{
    DWORD dwReturn;

#if DBG == 1
    ULONG ulThunkCall1632_count = ++ThunkCall1632_count;
    thkAssert( (ThunkCall1632_count != ThunkCall1632_break) &&
               "Break Count Hit");
#endif

    thkAssert(pti->pvfn != NULL);
    thkAssert(*pti->pThop == THOP_END);
    pti->pThop++;
    thkAssert(*pti->pThop == THOP_ROUTINEINDEX);
    pti->pThop++;
    
    thkDebugOut((DEB_ITRACE, "%sIn ThunkCall1632 #(%x) %p, index %d\n",
                 NestingLevelString(), ulThunkCall1632_count, 
                 pti->pvfn, *pti->pThop));
    DebugIncrementNestingLevel();

    if (FAILED(pti->scResult))
    {
        DebugDecrementNestingLevel();
        thkDebugOut((DEB_ITRACE, "%sOut ThunkCall1632 #(%x) returns 0x%08lX\n",
                     NestingLevelString(), ulThunkCall1632_count, pti->scResult));
        return (DWORD)pti->scResult;
    }
    pti->pThkMgr->SetThkState(THKSTATE_NOCALL);
    switch(*pti->pThop)
    {
    case 0:
        dwReturn = (*(DWORD (__stdcall *)(
                DWORD,
                DWORD,
                DWORD))pti->pvfn)(
            *(DWORD *)(pti->s32.pbStart+0),
            *(DWORD *)(pti->s32.pbStart+4),
            *(DWORD *)(pti->s32.pbStart+8)
            );
        break;
    case 1:
        dwReturn = (*(DWORD (__stdcall *)(
                DWORD))pti->pvfn)(
            *(DWORD *)(pti->s32.pbStart+0)
            );
        break;
    case 2:
        dwReturn = (*(DWORD (__stdcall *)(
                DWORD,
                DWORD,
                DWORD,
                DWORD))pti->pvfn)(
            *(DWORD *)(pti->s32.pbStart+0),
            *(DWORD *)(pti->s32.pbStart+4),
            *(DWORD *)(pti->s32.pbStart+8),
            *(DWORD *)(pti->s32.pbStart+12)
            );
        break;
    case 3:
        dwReturn = (*(DWORD (__stdcall *)(
                DWORD,
                DWORD))pti->pvfn)(
            *(DWORD *)(pti->s32.pbStart+0),
            *(DWORD *)(pti->s32.pbStart+4)
            );
        break;
    case 4:
        dwReturn = (*(DWORD (__stdcall *)(
                DWORD,
                DWORD,
                DWORD,
                DWORD,
                DWORD,
                DWORD,
                DWORD))pti->pvfn)(
            *(DWORD *)(pti->s32.pbStart+0),
            *(DWORD *)(pti->s32.pbStart+4),
            *(DWORD *)(pti->s32.pbStart+8),
            *(DWORD *)(pti->s32.pbStart+12),
            *(DWORD *)(pti->s32.pbStart+16),
            *(DWORD *)(pti->s32.pbStart+20),
            *(DWORD *)(pti->s32.pbStart+24)
            );
        break;
    case 5:
        dwReturn = (*(DWORD (__stdcall *)(
                DWORD,
                DWORD,
                DWORD,
                DWORD,
                DWORD))pti->pvfn)(
            *(DWORD *)(pti->s32.pbStart+0),
            *(DWORD *)(pti->s32.pbStart+4),
            *(DWORD *)(pti->s32.pbStart+8),
            *(DWORD *)(pti->s32.pbStart+12),
            *(DWORD *)(pti->s32.pbStart+16)
            );
        break;
    case 6:
        dwReturn = (*(DWORD (__stdcall *)())pti->pvfn)(
            );
        break;
    case 7:
        dwReturn = (*(DWORD (__stdcall *)(
                DWORD,
                DWORD,
                DWORD,
                DWORD,
                DWORD,
                DWORD))pti->pvfn)(
            *(DWORD *)(pti->s32.pbStart+0),
            *(DWORD *)(pti->s32.pbStart+4),
            *(DWORD *)(pti->s32.pbStart+8),
            *(DWORD *)(pti->s32.pbStart+12),
            *(DWORD *)(pti->s32.pbStart+16),
            *(DWORD *)(pti->s32.pbStart+20)
            );
        break;
    case 8:
        dwReturn = (*(DWORD (__stdcall *)(
                WORD,
                WORD,
                DWORD))pti->pvfn)(
            *(WORD *)(pti->s32.pbStart+0),
            *(WORD *)(pti->s32.pbStart+4),
            *(DWORD *)(pti->s32.pbStart+8)
            );
        break;
    case 9:
        dwReturn = (*(DWORD (__stdcall *)(
                DWORD,
                ULARGE_INTEGER,
                DWORD,
                DWORD,
                DWORD))pti->pvfn)(
            *(DWORD *)(pti->s32.pbStart+0),
            *(ULARGE_INTEGER UNALIGNED *)(pti->s32.pbStart+4),
            *(DWORD *)(pti->s32.pbStart+12),
            *(DWORD *)(pti->s32.pbStart+16),
            *(DWORD *)(pti->s32.pbStart+20)
            );
        break;
    case 10:
        dwReturn = (*(DWORD (__stdcall *)(
                DWORD,
                ULARGE_INTEGER))pti->pvfn)(
            *(DWORD *)(pti->s32.pbStart+0),
            *(ULARGE_INTEGER UNALIGNED *)(pti->s32.pbStart+4)
            );
        break;
    case 11:
        dwReturn = (*(DWORD (__stdcall *)(
                DWORD,
                ULARGE_INTEGER,
                ULARGE_INTEGER,
                DWORD))pti->pvfn)(
            *(DWORD *)(pti->s32.pbStart+0),
            *(ULARGE_INTEGER UNALIGNED *)(pti->s32.pbStart+4),
            *(ULARGE_INTEGER UNALIGNED *)(pti->s32.pbStart+12),
            *(DWORD *)(pti->s32.pbStart+20)
            );
        break;
    case 12:
        dwReturn = (*(DWORD (__stdcall *)(
                DWORD,
                ULARGE_INTEGER,
                DWORD,
                DWORD))pti->pvfn)(
            *(DWORD *)(pti->s32.pbStart+0),
            *(ULARGE_INTEGER UNALIGNED *)(pti->s32.pbStart+4),
            *(DWORD *)(pti->s32.pbStart+12),
            *(DWORD *)(pti->s32.pbStart+16)
            );
        break;
    case 13:
        dwReturn = (*(DWORD (__stdcall *)(
                DWORD,
                DWORD,
                ULARGE_INTEGER,
                DWORD,
                DWORD))pti->pvfn)(
            *(DWORD *)(pti->s32.pbStart+0),
            *(DWORD *)(pti->s32.pbStart+4),
            *(ULARGE_INTEGER UNALIGNED *)(pti->s32.pbStart+8),
            *(DWORD *)(pti->s32.pbStart+16),
            *(DWORD *)(pti->s32.pbStart+20)
            );
        break;
    case 14:
        dwReturn = (*(DWORD (__stdcall *)(
                DWORD,
                DWORD,
                DWORD,
                DWORD,
                DWORD,
                DWORD,
                DWORD,
                DWORD,
                DWORD,
                DWORD,
                DWORD))pti->pvfn)(
            *(DWORD *)(pti->s32.pbStart+0),
            *(DWORD *)(pti->s32.pbStart+4),
            *(DWORD *)(pti->s32.pbStart+8),
            *(DWORD *)(pti->s32.pbStart+12),
            *(DWORD *)(pti->s32.pbStart+16),
            *(DWORD *)(pti->s32.pbStart+20),
            *(DWORD *)(pti->s32.pbStart+24),
            *(DWORD *)(pti->s32.pbStart+28),
            *(DWORD *)(pti->s32.pbStart+32),
            *(DWORD *)(pti->s32.pbStart+36),
            *(DWORD *)(pti->s32.pbStart+40)
            );
        break;
    case 15:
        dwReturn = (*(DWORD (__stdcall *)(
                DWORD,
                DWORD,
                DWORD,
                SIZEL,
                DWORD))pti->pvfn)(
            *(DWORD *)(pti->s32.pbStart+0),
            *(DWORD *)(pti->s32.pbStart+4),
            *(DWORD *)(pti->s32.pbStart+8),
            *(SIZEL *)(pti->s32.pbStart+12),
            *(DWORD *)(pti->s32.pbStart+20)
            );
        break;
    case 16:
        dwReturn = (*(DWORD (__stdcall *)(
                DWORD,
                DWORD,
                SIZEL,
                DWORD))pti->pvfn)(
            *(DWORD *)(pti->s32.pbStart+0),
            *(DWORD *)(pti->s32.pbStart+4),
            *(SIZEL *)(pti->s32.pbStart+8),
            *(DWORD *)(pti->s32.pbStart+16)
            );
        break;
    case 17:
        dwReturn = (*(DWORD (__stdcall *)(
                DWORD,
                DWORD,
                WORD))pti->pvfn)(
            *(DWORD *)(pti->s32.pbStart+0),
            *(DWORD *)(pti->s32.pbStart+4),
            *(WORD *)(pti->s32.pbStart+8)
            );
        break;
    case 18:
        dwReturn = (*(DWORD (__stdcall *)(
                DWORD,
                SIZEL))pti->pvfn)(
            *(DWORD *)(pti->s32.pbStart+0),
            *(SIZEL *)(pti->s32.pbStart+4)
            );
        break;
    case 19:
        dwReturn = (*(DWORD (__stdcall *)(
                DWORD,
                WORD,
                DWORD))pti->pvfn)(
            *(DWORD *)(pti->s32.pbStart+0),
            *(WORD *)(pti->s32.pbStart+4),
            *(DWORD *)(pti->s32.pbStart+8)
            );
        break;
    case 20:
        dwReturn = (*(DWORD (__stdcall *)(
                DWORD,
                DWORD,
                DWORD,
                DWORD,
                DWORD,
                DWORD,
                DWORD,
                DWORD))pti->pvfn)(
            *(DWORD *)(pti->s32.pbStart+0),
            *(DWORD *)(pti->s32.pbStart+4),
            *(DWORD *)(pti->s32.pbStart+8),
            *(DWORD *)(pti->s32.pbStart+12),
            *(DWORD *)(pti->s32.pbStart+16),
            *(DWORD *)(pti->s32.pbStart+20),
            *(DWORD *)(pti->s32.pbStart+24),
            *(DWORD *)(pti->s32.pbStart+28)
            );
        break;
    case 21:
        dwReturn = (*(DWORD (__stdcall *)(
                DWORD,
                WORD,
                DWORD,
                DWORD,
                DWORD,
                DWORD,
                DWORD))pti->pvfn)(
            *(DWORD *)(pti->s32.pbStart+0),
            *(WORD *)(pti->s32.pbStart+4),
            *(DWORD *)(pti->s32.pbStart+8),
            *(DWORD *)(pti->s32.pbStart+12),
            *(DWORD *)(pti->s32.pbStart+16),
            *(DWORD *)(pti->s32.pbStart+20),
            *(DWORD *)(pti->s32.pbStart+24)
            );
        break;
    }

#if DBG == 1
    if ( !pti->fResultThunked && FAILED(dwReturn) )
    {
        thkDebugOut((DEB_FAILURES,
                     "ThunkCall1632 pvfn = %08lX Probably failed hr = %08lX\n",
                     pti->pvfn, dwReturn));
        if(thkInfoLevel & DEB_DBGFAIL)
            thkAssert(!"Wish to Debug");
    }
#endif

    pti->pThkMgr->SetThkState(THKSTATE_INVOKETHKOUT32);
    
    DebugDecrementNestingLevel();
    thkDebugOut((DEB_ITRACE, "%sOut ThunkCall1632 #(%x) returns 0x%08lX\n",
                 NestingLevelString(), ulThunkCall1632_count, dwReturn));
    return dwReturn;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\olethk32\thop16.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       thop16.cxx
//
//  Contents:   Thop implementations for 16->32
//
//  History:    22-Feb-94       DrewB   Created
//
//----------------------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

#include <ole2.h>
#include <valid.h>
#include <string.h>

#include "struct16.hxx"

//+---------------------------------------------------------------------------
//
//  Function:   EXECUTE_THOP1632, public
//
//  Synopsis:   Debugging version of thop dispatch routine
//
//  Arguments:  [pti] - Thunking info
//
//  Returns:    Appropriate status
//
//  History:    24-Feb-94       DrewB   Created
//
//----------------------------------------------------------------------------

#if DBG == 1
DWORD EXECUTE_THOP1632(THUNKINFO *pti)
{
    thkDebugOut((DEB_THOPS, "%sIn ExThop1632: %s (0x%02X), s16 %p, s32 %p\n",
                 NestingLevelString(), 
                 ThopName(*pti->pThop), *pti->pThop, pti->s16.pbCurrent,
                 pti->s32.pbCurrent));
    DebugIncrementNestingLevel();
    
    // Local variable
    DWORD dwRet;

    // Sanity check
    thkAssert((*pti->pThop & THOP_OPMASK) < THOP_LASTOP);
    dwRet = (*aThopFunctions1632[*((pti)->pThop) & THOP_OPMASK])(pti);

    DebugDecrementNestingLevel();
    thkDebugOut((DEB_THOPS, "%sOut ExThop1632\n", NestingLevelString()));
    return(dwRet);
}
#endif

#if DBG == 1
DWORD EXECUTE_ENUMTHOP1632(THUNKINFO *pti)
{
    thkDebugOut((DEB_THOPS, "%sIn ExEnumThop1632: %s (0x%02X), s16 %p, s32 %p\n",
                 NestingLevelString(), 
                 EnumThopName(*pti->pThop), *pti->pThop, pti->s16.pbCurrent,
                 pti->s32.pbCurrent));
    DebugIncrementNestingLevel();

    // Local variable
    DWORD dwRet;
    
    dwRet = (*aThopEnumFunctions1632[*(pti)->pThop])(pti);
    
    DebugDecrementNestingLevel();
    thkDebugOut((DEB_THOPS, "%sOut ExEnumThop1632\n", NestingLevelString()));
    return(dwRet);
}
#endif

// Generated by the tool, in tc1632.cxx
DWORD ThunkCall1632( THUNKINFO * );

//+---------------------------------------------------------------------------
//
//  Function:   FixedThopHandler, public
//
//  Synopsis:   Generic function which handles the high-level details
//              of thop execution for thops that operate on known-size
//              data
//
//  Arguments:  [pti] - Thunking state information
//              [thop] - Thop being executed
//              [cb16] - 16-bit size
//              [pfn1632] - 16->32 conversion routine
//              [cb32] - 32-bit size
//              [pfn3216] - 32->16 conversion routine
//
//  Returns:    Appropriate status code
//
//  History:    05-Apr-94       DrewB   Created
//
//  Notes:      Automatically increments pThop
//
//----------------------------------------------------------------------------

DWORD FixedThopHandler1632(THUNKINFO *pti,
                           THOP thop,
                           UINT cb16,
                           FIXEDHANDLERROUTINE pfn1632,
                           UINT cb32,
                           FIXEDHANDLERROUTINE pfn3216)
{
    DWORD   dwResult;
    VPVOID  vp16;
    BYTE    *pb16;
    BYTE    *pb32;

    if ((thop & (THOP_IN | THOP_OUT)) != 0)
    {
        pb32 = NULL;

        GET_STACK16(pti, vp16, VPVOID);
        if ( vp16 != 0 )
        {
            pb16 = (BYTE *)ValidatePtr16(pti, vp16, cb16, thop);
            if (pb16 != NULL)
            {
                pb32 = (BYTE *)STACKALLOC32(cb32);
                if (pb32 == NULL)
                {
                    pti->scResult = E_OUTOFMEMORY;
                }
                else if ((thop & THOP_IN) != 0)
                {
                    (pfn1632)(pb16, pb32, cb16, cb32);
                }

                WOWRELVDMPTR(vp16);
            }
        }

        TO_STACK32(pti, pb32, BYTE *);

        pti->pThop++;
        dwResult = EXECUTE_THOP1632(pti);

        if ((thop & THOP_OUT) != 0 && vp16 != 0)
        {
            pb16 = (BYTE *)WOWFIXVDMPTR(vp16, cb16);

            if (SUCCEEDED(dwResult))
            {
                (pfn3216)(pb32, pb16, cb32, cb16);
            }
            else if ((thop & THOP_IN) == 0)
            {
                // Zero out-only parameters on failure
                memset(pb16, 0, cb16);
            }

            WOWRELVDMPTR(vp16);
        }

        if (pb32 != NULL)
        {
            STACKFREE32(pb32, cb32);
        }
    }
    else
    {
        (pfn1632)(PTR_STACK16(&pti->s16, cb16), PTR_STACK32(&pti->s32),
                  cb16, cb32);
        SKIP_STACK16(&pti->s16, cb16);
        SKIP_STACK32(&pti->s32, cb32);

        pti->pThop++;
        dwResult = EXECUTE_THOP1632(pti);
    }

    return dwResult;
}

//-----------------------------------------------------------------------------
//
// Handler-based thunks
//
// These thunks use the fixed-size generic thop handler to do their work
//
//-----------------------------------------------------------------------------

// Handle straight copy
DWORD Thop_Copy_1632(THUNKINFO *pti)
{
    THOP thopSize;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_COPY);

    thopSize = *++pti->pThop;
    return FixedThopHandler1632(pti,
                                *(pti->pThop-1),
                                thopSize, FhCopyMemory,
                                thopSize, FhCopyMemory);
}

DWORD Thop_ShortToLong_1632(THUNKINFO *pti)
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_SHORTLONG);

    return FixedThopHandler1632(pti,
                                *pti->pThop,
                                sizeof(SHORT), FhShortToLong,
                                sizeof(LONG), FhLongToShort);
}

DWORD Thop_WordToDword_1632(THUNKINFO *pti)
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_WORDDWORD);

    return FixedThopHandler1632(pti,
                                *pti->pThop,
                                sizeof(WORD), FhWordToDword,
                                sizeof(DWORD), FhDwordToWord);
}

DWORD Thop_GdiHandle_1632(THUNKINFO *pti)
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_HGDI);

    return FixedThopHandler1632(pti,
                                *pti->pThop,
                                sizeof(HAND16), FhGdiHandle1632,
                                sizeof(HANDLE), FhGdiHandle3216);
}

DWORD Thop_UserHandle_1632(THUNKINFO *pti)
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_HUSER);

    return FixedThopHandler1632(pti,
                                *pti->pThop,
                                sizeof(HAND16), FhUserHandle1632,
                                sizeof(HANDLE), FhUserHandle3216);
}

DWORD Thop_HACCEL_1632(THUNKINFO *pti)
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_HACCEL);

    return FixedThopHandler1632(pti,
                                *pti->pThop,
                                sizeof(HAND16), FhHaccel1632,
                                sizeof(HANDLE), FhHaccel3216);
}

DWORD Thop_HTASK_1632(THUNKINFO *pti)
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_HTASK);

    return FixedThopHandler1632(pti,
                                *pti->pThop,
                                sizeof(HAND16), FhHtask1632,
                                sizeof(HANDLE), FhHtask3216);
}

DWORD Thop_HRESULT_1632( THUNKINFO *pti )
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_HRESULT);

    return FixedThopHandler1632(pti,
                                *pti->pThop,
                                sizeof(HRESULT), FhHresult1632,
                                sizeof(HRESULT), FhHresult3216);
}

DWORD Thop_NULL_1632(THUNKINFO *pti)
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_NULL);

    return FixedThopHandler1632(pti,
                                *pti->pThop,
                                sizeof(void *), FhNull,
                                sizeof(void *), FhNull);
}

DWORD Thop_RECT_1632( THUNKINFO *pti )
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_RECT);

    return FixedThopHandler1632(pti,
                                *pti->pThop,
                                sizeof(RECT16), FhRect1632,
                                sizeof(RECT), FhRect3216);
}

DWORD Thop_BINDOPTS_1632( THUNKINFO *pti )
{
    VPVOID vpbo16;
    BIND_OPTS UNALIGNED *pbo;
    UINT cb;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_BINDOPTS);

    PEEK_STACK16(pti, vpbo16, VPVOID);
    pbo = (BIND_OPTS UNALIGNED *)GetReadPtr16(pti, vpbo16, sizeof(BIND_OPTS));
    if (pbo != NULL)
    {
        cb = pbo->cbStruct;
        WOWRELVDMPTR(vpbo16);
    }
    else
    {
        // Doesn't really matter, since pti->scResult was set to error
        // by GetReadPtr16
        cb = sizeof(BIND_OPTS);
    }

    return FixedThopHandler1632(pti,
                                *pti->pThop,
                                cb, FhCopyMemory,
                                cb, FhCopyMemory);
}

DWORD Thop_SIZE_1632( THUNKINFO *pti )
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_SIZE);

    return FixedThopHandler1632(pti,
                                *pti->pThop,
                                sizeof(SIZE16), FhSize1632,
                                sizeof(SIZE), FhSize3216);
}

DWORD Thop_MSG_1632( THUNKINFO *pti )
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_MSG);

    return FixedThopHandler1632(pti,
                                *pti->pThop,
                                sizeof(MSG16), FhMsg1632,
                                sizeof(MSG), FhMsg3216);
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_ERROR_1632, public
//
//  Synopsis:   Any Thop type which should just fail with an error
//              should go be directed here.
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    23-Feb-94       BobDay  Created
//
//----------------------------------------------------------------------------
DWORD Thop_ERROR_1632 ( THUNKINFO *pti )
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_ERROR);

    thkAssert( FALSE && "Hey we hit an ERROR Thop in 16->32" );

    return (DWORD)E_UNEXPECTED;
}

//+---------------------------------------------------------------------------
//
//  Function:   ThunkInString1632, public
//
//  Synopsis:   Converts an in-parameter string
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    24-Aug-94       DrewB   Created
//
//----------------------------------------------------------------------------

DWORD ThunkInString1632(THUNKINFO *pti)
{
    DWORD   dwResult;
    VPSTR   vpstr;
    LPOLESTR lpstrDest;
    OLECHAR *ptcStackText;

    dwResult = (DWORD)S_OK;
    ptcStackText = NULL;

    GET_STACK16(pti, vpstr, VPSTR);

    if (vpstr == 0)
    {
        lpstrDest = NULL;
    }
    else
    {
        ptcStackText = (OLECHAR *)STACKALLOC32(CWCSTRINGPREALLOC*
                                               sizeof(OLECHAR));
        if (ptcStackText == NULL)
        {
            pti->scResult = E_OUTOFMEMORY;
        }
        else
        {
            lpstrDest = Convert_VPSTR_to_LPOLESTR( pti, vpstr, ptcStackText,
                                                   CWCSTRINGPREALLOC );
        }
    }

    thkDebugOut((DEB_ARGS, "In1632  LPSTR: %p -> %p '%ws'\n",
                 vpstr, lpstrDest, lpstrDest));

    TO_STACK32(pti, lpstrDest, LPOLESTR );

    pti->pThop++;
    dwResult = EXECUTE_THOP1632(pti);

    if (lpstrDest != NULL)
    {
        Convert_VPSTR_to_LPOLESTR_free( ptcStackText, lpstrDest );
    }

    if (ptcStackText != NULL)
    {
        STACKFREE32(ptcStackText, CWCSTRINGPREALLOC*sizeof(OLECHAR));
    }

    return( dwResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_LPSTR_1632, public
//
//  Synopsis:   Converts 16-bit LPSTR to 32-bit LPSTR pointer
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    23-Feb-94       BobDay  Created
//
//----------------------------------------------------------------------------

DWORD Thop_LPSTR_1632( THUNKINFO *pti )
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_LPSTR);
    //
    // We have only input LPSTRs
    //
    thkAssert( (*pti->pThop & THOP_IOMASK) == THOP_IN &&
               "LPSTR must be input only!" );

    return ThunkInString1632(pti);
}

//+---------------------------------------------------------------------------
//
//  Function:   ConvertTaskString3216, public
//
//  Synopsis:   Converts a task-memory string
//
//  Arguments:  [pti] - Thunk info
//              [pos32] - String
//              [vpstrPreAlloc] - Preallocated string or NULL
//              [cchPreAlloc] - Preallocated size or zero
//              [pvpstr16] - String
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pti]
//              [pvpstr16]
//
//  History:    14-May-94       DrewB   Created
//
//  Notes:      Frees preallocation if successful and:
//                  Name is too large or
//                  Name is NULL
//
//              Always frees source string if non-zero and valid
//
//----------------------------------------------------------------------------

SCODE ConvertTaskString3216(THUNKINFO *pti,
                            LPOLESTR pos32,
                            VPSTR vpstrPreAlloc,
                            UINT cchPreAlloc,
                            VPSTR UNALIGNED *pvpstr16)
{
    VPVOID vpstr16;
    UINT cch;
    SCODE sc;

    sc = S_OK;

    if (pos32 == NULL)
    {
        vpstr16 = 0;
    }
    else
    {
        if (IsBadStringPtrW(pos32, CCHMAXSTRING))
        {
            sc = E_INVALIDARG;
        }
        else
        {
            cch = lstrlenW(pos32)+1;

            if (cch > cchPreAlloc)
            {
                // Our prealloc buffer is too small, so try and get a
                // new one

                // Allow for each Unicode character to take two
                // bytes in case of multibyte expansion
                vpstr16 = (VPSTR)TaskMalloc16( cch*2 );
                if (vpstr16 == 0)
                {
                    sc = E_OUTOFMEMORY;
                }
            }
            else
            {
                vpstr16 = vpstrPreAlloc;
            }

            if (SUCCEEDED(sc))
            {
                sc = Convert_LPOLESTR_to_VPSTR(pos32, vpstr16, cch, cch*2);
                if (FAILED(sc) && vpstr16 != vpstrPreAlloc)
                {
                    TaskFree16(vpstr16);
                }
            }

            TaskFree32(pos32);
        }
    }

    if (SUCCEEDED(sc))
    {
        // If there was a preallocated string we didn't use,
        // free it
        if (vpstrPreAlloc != 0 && vpstrPreAlloc != vpstr16)
        {
            TaskFree16(vpstrPreAlloc);
        }

        *pvpstr16 = vpstr16;
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   ThunkOutString1632, public
//
//  Synopsis:   Converts an out param string or filename
//
//  Arguments:  [pti] - Thunk state information
//              [fFile] - Filename or plain string
//
//  Returns:    Appropriate status code
//
//  History:    24-Aug-94       DrewB   Created
//
//----------------------------------------------------------------------------

DWORD ThunkOutString1632(THUNKINFO *pti,
                         BOOL fFile)
{
    DWORD           dwResult;
    VPVOID          vpvpstr16;
    VPSTR           vpstr16;
    VPSTR UNALIGNED *lpvpstr16;
    LPOLESTR        *lplpstr32;
    LPOLESTR        lpstr = NULL;

    GET_STACK16(pti, vpvpstr16, VPSTR);

    lplpstr32 = NULL;
    if ( vpvpstr16 != 0 )
    {
        lpvpstr16 = (VPSTR UNALIGNED *)GetWritePtr16(pti, vpvpstr16,
                                                     sizeof(VPSTR));
        if ( lpvpstr16 != NULL )
        {
            WOWRELVDMPTR(vpvpstr16);

            lplpstr32 = &lpstr;

            vpstr16 = (VPSTR)TaskMalloc16(CBSTRINGPREALLOC);
            if (vpstr16 == 0)
            {
                pti->scResult = E_OUTOFMEMORY;
            }
        }
    }

    TO_STACK32(pti, lplpstr32, LPOLESTR FAR *);

    pti->pThop++;
    dwResult = EXECUTE_THOP1632(pti);

    if ( lplpstr32 != NULL )
    {
        if ( SUCCEEDED(dwResult) )
        {
            SCODE sc;

            if (fFile)
            {
                UINT cch;

                // The string pointed to by lpstr is ours so we
                // can do the long->short conversion in place
                // without worrying about trashing the memory
                // The short path name should always be able
                // to fit in the long path name's buffer since
                // the file names that we are thunking are always
                // absolute paths

                cch = lstrlenW(lpstr)+1;

                // Ignore failures; if we can't convert the name
                // then we simply pass on what we were given
                GetShortPathName(lpstr, lpstr, cch);
            }

            sc = ConvertTaskString3216(pti, lpstr, vpstr16,
                                       CWCSTRINGPREALLOC, &vpstr16);
            if (FAILED(sc))
            {
                dwResult = sc;
            }
        }

        if (FAILED(dwResult))
        {
            TaskFree16(vpstr16);
            vpstr16 = 0;
        }

        lpvpstr16 = FIXVDMPTR( vpvpstr16, VPSTR );
        *lpvpstr16 = vpstr16;

#if DBG==1
        thkDebugOut((DEB_ARGS, "%sOut1632 LPLPSTR: %p -> %p '%s'\n",
                     NestingLevelString(), lpstr, vpstr16,
                     vpstr16 != 0 ? WOWFIXVDMPTR(vpstr16, 0) : "<null>"));
        if (vpstr16 != 0)
        {
            WOWRELVDMPTR(vpstr16);
        }
#endif

        RELVDMPTR( vpvpstr16 );
    }
    else
    {
        thkDebugOut((DEB_ARGS, "Out1632 LPLPSTR NULL\n"));
    }

    return( dwResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_LPLPSTR_1632, public
//
//  Synopsis:   Converts 32-bit LPSTR to 16-bit LPSTR pointer
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    25-Feb-94       BobDay  Created
//
//----------------------------------------------------------------------------
DWORD Thop_LPLPSTR_1632( THUNKINFO *pti )
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_LPLPSTR);
    //
    // We don't have anything but unmodified LPLPSTRs
    //
    thkAssert( (*pti->pThop & THOP_IOMASK) == 0 &&
               "LPLPSTR must be unmodified only!" );

    return ThunkOutString1632(pti, FALSE);
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_BUFFER_1632, public
//
//  Synopsis:   Converts 16-bit block of memory to 32-bit block of memory
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    25-Feb-94       BobDay  Created
//              14-Mar-95       KentCe  Buffer copy not required for Win95.
//
//  Notes:      WARNING! WARNING! WARNING! For an out parameter this expects
//              three parameters on the stack in the following format and order:
//                  VOID *  pointer to buffer
//                  DWORD   count of bytes in buffer
//                  DWORD * count of bytes returned in the buffer
//
//----------------------------------------------------------------------------

#define WATCH_VALUE 0xfef1f0

DWORD Thop_BUFFER_1632( THUNKINFO *pti )
{
    DWORD       dwResult;
    BOOL        fThopInput;
    BOOL        fThopOutput;
    VPVOID      vp16;
    LPVOID      lp16;
    LPVOID      lp32;
    DWORD       dwCount;
    VPVOID      vp16CountOut;
    DWORD       dwCountOut32 = 0;
    DWORD *     pdwCountOut32 = &dwCountOut32;
#if DBG == 1
    DWORD       dwWatch;
#endif

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_BUFFER);

    fThopInput  = IS_THOP_IN(pti);
    fThopOutput = IS_THOP_OUT(pti);

    //
    // We only have in and out BUFFER thops
    //
    thkAssert((fThopInput || fThopOutput)
         && (fThopInput != fThopOutput)
         && "BUFFER must be in or out only!" );

    GET_STACK16(pti, vp16, VPVOID);
    GET_STACK16(pti, dwCount, DWORD);

    if (fThopOutput)
    {
        // Get the pointer to the returned value off the stack
        GET_STACK16(pti, vp16CountOut, VPVOID);
    }

    lp32 = NULL;

    if (vp16 == 0)
    {
        // lp32 is already NULL
    }
    else if (dwCount == 0)
    {
        // If the count is zero then we can pass any valid 32-bit
        // pointer

#if DBG == 1
        // In debug, make sure that no data is written back to the
        // memory we pass on
        dwWatch = WATCH_VALUE;
        lp32 = &dwWatch;
#else
        lp32 = &dwResult;
#endif
    }
    else
    {
        //
        //  Under Win95 we can lock down 16-bit memory so a duplicate
        //  buffer is not required.
        //
#if defined(_CHICAGO_)
        lp32 = WOWFIXVDMPTR(vp16, dwCount);
#else
        lp16 = ValidatePtr16(pti, vp16, dwCount, *pti->pThop);

        if ( lp16 != NULL )
        {
            lp32 = (LPVOID)CoTaskMemAlloc( dwCount );
            if ( lp32 == NULL )
            {
                pti->scResult = E_OUTOFMEMORY;
            }
            else
            {
                if ( fThopInput )
                {
                    memcpy( lp32, lp16, dwCount );
                }
            }

            WOWRELVDMPTR(vp16);
        }
#endif
    }

    thkDebugOut((DEB_ARGS, "1632    BUFFER: %p -> %p, %u\n",
                 vp16, lp32, dwCount));

    TO_STACK32(pti, lp32, LPVOID );
    TO_STACK32(pti, dwCount, DWORD );

    if (fThopOutput)
    {
        TO_STACK32(pti, pdwCountOut32, LPVOID );
    }

    pti->pThop++;
    dwResult = EXECUTE_THOP1632(pti);

    if (fThopOutput)
    {
        // If the pointer in sixteen bit land is non-null then return the
        // count of bytes written to the buffer.
        DWORD UNALIGNED *lpdw16 = (DWORD UNALIGNED *)
               ValidatePtr16(pti, vp16CountOut, sizeof(DWORD), *pti->pThop);

        if (lpdw16 != NULL)
        {
            *lpdw16 = dwCountOut32;
            WOWRELVDMPTR(vp16CountOut);
        }

#if !defined(_CHICAGO_)
        //
        //  Under Win95 we can lock down 16-bit memory so a duplicate
        //  buffer is not required.
        //
        if ( SUCCEEDED(dwResult) )
        {
            if (dwCountOut32 > 0 && vp16 != 0)
            {
                lp16 = (LPVOID)WOWFIXVDMPTR( vp16, dwCountOut32 );

                memcpy( lp16, lp32, dwCountOut32 );

                WOWRELVDMPTR(vp16);
            }
        }
#endif // _CHICAGO_
    }

#if DBG == 1
    if (lp32 != NULL && dwCount == 0)
    {
        thkAssert(dwWatch == WATCH_VALUE);
    }
#endif

    //
    //  Under Win95 we can lock down 16-bit memory so a duplicate
    //  buffer is not required.
    //
    // Now free the buffer
    //
    if ( lp32 != NULL && dwCount > 0 )
    {
#if defined(_CHICAGO_)
        WOWRELVDMPTR(vp16);
#else
        CoTaskMemFree( lp32 );
#endif // _CHICAGO_
    }


    return( dwResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_SNB_1632, public
//
//  Synopsis:   Converts 16-bit SNB to 32-bit SNB pointer
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    23-Feb-94       BobDay  Created
//
//----------------------------------------------------------------------------
DWORD Thop_SNB_1632( THUNKINFO *pti )
{
    DWORD       dwResult;
    BOOL        fThopInput;
    BOOL        fThopOutput;
    VPVOID      snb16;
    VPSTR       *lpvpstr;
    VPSTR UNALIGNED *lpvpstrTemp;
    VPSTR       vpstr;
    SNB         snb32;
    UINT        cStr;
    UINT        cStrTemp;
    LPOLESTR    *lplpstr;
    UINT        cbStrings;
    OLECHAR     *pocStr;
    LPSTR       lpstr16;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_SNB);

    fThopInput  = IS_THOP_IN(pti);
    fThopOutput = IS_THOP_OUT(pti);

    //
    // We don't have anything but unmodified SNBs
    //
    thkAssert( !fThopInput && !fThopOutput && "SNB must be unmodified only!" );

    GET_STACK16(pti, snb16, VPVOID);

    snb32 = NULL;
    if ( snb16 != 0 )
    {
        //
        // Count the strings in the 16-bit snb
        //
        lpvpstr = (VPSTR FAR *)GetReadPtr16( pti, snb16, sizeof(VPSTR) );
        if ( lpvpstr != 0 )
        {
            lpvpstrTemp = lpvpstr;
            cStr = 0;
            cbStrings = 0;
            do
            {
                cStr++;
                vpstr = *lpvpstrTemp++;

                if ( vpstr == 0 )
                {
                    break;
                }

                lpstr16 = GetStringPtr16(pti, vpstr, CCHMAXSTRING,
                                         &cStrTemp);
                if ( lpstr16 == 0 )
                {
                    WOWRELVDMPTR(snb16);
                    lpvpstr = NULL;
                    break;      // Leave with snb32 still NULL
                }

                WOWRELVDMPTR(vpstr);

                cbStrings += cStrTemp;
            }
            while ( TRUE );
        }

        if ( lpvpstr != NULL )
        {
            thkDebugOut((DEB_ARGS, "In1632  SNB: %d strings\n", cStr));

            //
            // Allocate space for the 32-bit snb
            //
            snb32 = (LPOLESTR FAR *)CoTaskMemAlloc( cStr*sizeof(LPOLESTR) +
                                                    cbStrings*sizeof(WCHAR));
            if (snb32 == NULL)
            {
                pti->scResult = E_OUTOFMEMORY;
            }
            else
            {
                pocStr = (OLECHAR *)((BYTE *)snb32+cStr*sizeof(LPOLESTR));

                //
                // Now convert the strings
                //
                lpvpstrTemp = lpvpstr;
                lplpstr = snb32;
                cStrTemp = cStr - 1;

                while ( cStrTemp > 0 )
                {
                    --cStrTemp;

                    vpstr = *lpvpstrTemp++;

                    thkAssert( vpstr != 0 &&
                               "Loop is processing end of snb\n" );

                    // Guaranteed to use pocStr as storage since cbStrings is
                    // large enough to contain all the strings
                    *lplpstr = Convert_VPSTR_to_LPOLESTR( pti, vpstr,
                                                          pocStr, cbStrings );

                    if (*lplpstr == NULL)
                    {
                        CoTaskMemFree(snb32);
                        snb32 = NULL;
                        break;
                    }

#if DBG == 1
                    thkDebugOut((DEB_ARGS, "In1632  SNB: %p '%s' -> "
                                 "%p '%ws'\n",
                                 vpstr, WOWFIXVDMPTR(vpstr, 0),
                                 *lplpstr, *lplpstr));
                    WOWRELVDMPTR(vpstr);
#endif

                    pocStr += lstrlenW(pocStr)+1;
                    lplpstr++;
                }

                // Terminate SNB
                *lplpstr = NULL;

                thkAssert(*lpvpstrTemp == 0);

                WOWRELVDMPTR(snb16);
            }
        }
    }

    thkDebugOut((DEB_ARGS, "In1632  SNB: %p -> %p\n", snb16, snb32));

    TO_STACK32(pti, snb32, SNB );

    pti->pThop++;
    dwResult = EXECUTE_THOP1632(pti);

    //
    // Free SNB memory if necessary
    //
    if ( snb32 != 0 )
    {
        CoTaskMemFree(snb32);
    }

    return( dwResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   ThunkInterface1632, private
//
//  Synopsis:   Handles interface thunking for THOP_IFACE and
//              THOP_IFACEGEN
//
//  Arguments:  [pti]       - Thunking state information
//              [iidx]      - Interface index or IID
//              [thop]      - Thop being executed
//              [punkOuter] - Controlling IUnknown or NULL
//
//  Returns:    status code
//
//  History:    Mar 14,97   Gopalk      Rewritten to support aggregation and
//                                      proper thunking of IN/OUT interfaces
//
//  Notes:      Assumes caller has already adjusted pti->pThop
//----------------------------------------------------------------------------

DWORD ThunkInterface1632(THUNKINFO *pti, IIDIDX iidx, THOP thop, IUnknown *punkOuter)
{
    // Local variables
    VPVOID vpv;
    DWORD dwResult, dwStatus;
    IUnknown *punkThis32In;
    IUnknown *punkThis32Out;
    VPVOID vpvOut;
    VPVOID vpvIn;
    VPVOID UNALIGNED *pvpvOut;
    VPVOID vpvPreAlloc = NULL;
    THUNK1632OBJ UNALIGNED *pto;
    PROXYHOLDER *pph;
    PROXYHOLDER *pAggHolder = NULL;
    SAggHolder aggHolderNode;
    BOOL      bUnlinkAggHolder = FALSE;
    BOOL      bExtraAddRef;

    // Validate the IID of the interface
    thkAssert(IIDIDX_IS_IID(iidx) ||
              (IIDIDX_INDEX(iidx) >= 0 &&  IIDIDX_INDEX(iidx) <= THI_COUNT));

    // Initialize
    dwResult = (DWORD) S_OK;
    punkThis32In = NULL;
    pph = NULL;

    // Retrieve interface pointer
    GET_STACK16(pti, vpv, VPVOID);

    // Assert invariant
    thkAssert(iidx!=THI_COUNT || vpv==NULL);

    // Check for valid OUT parameter. It also verifies IN-OUT case as well
    if((thop & THOP_OUT) && vpv) {
        pvpvOut = (VPVOID UNALIGNED *)GetWritePtr16(pti, vpv, sizeof(VPVOID));
        if(!pvpvOut) {
            thkDebugOut((DEB_WARN, "WARNING: ThunkInterface1632 - bad pointer %p\n",
                         vpv));
            pti->scResult = E_INVALIDARG;
            return (DWORD) E_INVALIDARG;
        }

        // Check if the interface needs to be thunked IN as well.
        // In other words, IN-OUT paramenter case
        if(thop & THOP_IN)
            vpvIn = *pvpvOut;
        else
            vpvIn = NULL;

        // Release the VMD pointer
        WOWRELVDMPTR(vpv);
    }
    else {
        // It must be IN parameter or a NULL OUT parameter
        vpvIn = vpv;
    }

    // Check if interface needs to be thunked IN
    if(thop & THOP_IN) {
        if (vpvIn) {
            // Validate the interface
            if(IsValidInterface16(pti, vpvIn)) {
                if((thop & THOP_OPMASK) == THOP_IFACENOADDREF) {
                    // vpvIn represents an interface that is used by the
                    // 32-bit side without addrefing it.
                    // Classic example: IOleCacheControl::OnRun
                    // Aggregate it with the identity of the interface on which
                    // the current call is being made to ensure that lifetime of proxy
                    // is controlled by it.
                    VPVOID vpvThis16;

                    // Obtain the 16-bit interface on which the current call is
                    // being made
                    thkAssert(punkOuter);
                    vpvThis16 = pti->pThkMgr->LookupProxy1632(punkOuter);
                    thkAssert(vpvThis16);

                    // Obtain its holder
                    pto = FIXVDMPTR(vpvThis16, THUNK1632OBJ);
                    pph = pto->pphHolder;
                    thkAssert(pto->punkThis32 ==  punkOuter);
                    RELVDMPTR(vpvThis16);

                    // Assert that holder exists
                    thkAssert(pph);
                }
                else {
                    thkAssert(pph == NULL);
                }

                if((thop & THOP_OPMASK) == THOP_UNKOUTER) {                        
                    // Aggregation is being carried out
                    // Assert that interface is only being thunked IN
                    thkAssert(!(thop & THOP_OUT));
                    thkAssert(iidx == THI_IUnknown);

                    // Either find the actual 32-bit identity or generate a
                    // new 32-bit proxy identity for the 16-bit identity
                    punkThis32In = pti->pThkMgr->CreateOuter32(vpvIn, &pAggHolder, &dwStatus);
                    aggHolderNode.pph = pAggHolder;
                    bUnlinkAggHolder = TRUE;
                    TlsThkLinkAggHolder(&aggHolderNode);
                    // We use this pAggHolder for proxies of inner unk(s). Since
                    // we cannot put it in the proxy table (as it is private
                    // and we do not want other thunk calls to use it), we put
                    // it in a linked list in the TLS. The holder gets used by
                    // calls to FindAggregate() when the pUnkInner is being
                    // thunked out. The holder is revoked from the list when
                    // the ThunkInterface call for the pUnkOuter unwinds.
                    
                }
                else {
                    // Find/Generate the proxy for the 16-bit interface to be thunked IN
                    bExtraAddRef = FALSE;
                    if (
                        (
                        (pti->pvfn == (VTBLFN) OleIsCurrentClipboard) &&
                        (TlsThkGetAppCompatFlags() & OACF_WORKSCLIPOBJ) 
                        )
                        || 
                        (
                        (TlsThkGetAppCompatFlags() & OACF_TEXTARTDOBJ) &&
                        (pti->iidx == THI_IDataAdviseHolder) && 
                        (iidx == THI_IDataObject) && (pti->dwMethod == 3)
                        )
                       ){
                        bExtraAddRef = TRUE;
                    }

                    punkThis32In = pti->pThkMgr->FindProxy3216(NULL, vpvIn, pph, 
                                                iidx, bExtraAddRef, &dwStatus);
                }
                
                if(punkThis32In) {
                    thkAssert(!((thop & THOP_OPMASK) == THOP_UNKOUTER) ||
                              (dwStatus == FST_CREATED_NEW) || 
                              (dwStatus == FST_SHORTCUT));
                }
                else {
                    thkDebugOut((DEB_WARN, "WARNING: ThunkInterface1632 - Can't create proxy for %p\n",
                                 vpvIn));                    
					pti->scResult = E_OUTOFMEMORY;
					return (DWORD) E_OUTOFMEMORY;
                }
            }
            else {
                thkDebugOut((DEB_WARN, "WARNING: ThunkInterface1632 - invalid interface %p\n", 
                             vpvIn));
                pti->scResult = E_INVALIDARG;
                return (DWORD) E_INVALIDARG;
            }
        }
        else {
            // No interface to be thunked IN
            punkThis32In = NULL;
        }

        thkDebugOut((DEB_ARGS, "%sIn1632  %s %p -> %p\n", 
                     NestingLevelString(), IidIdxString(iidx),
                     vpvIn, punkThis32In));
    }

    // Check if interface needs to be thunked OUT
    if((thop & THOP_OUT) && vpv) {
        // Preallocate a proxy for the out parameter
        vpvPreAlloc = pti->pThkMgr->CanGetNewProxy1632(iidx);
        if(vpvPreAlloc) {
            // Assert that no interface is being thunked IN for
            // pure OUT parameter case
            thkAssert((thop & THOP_IN) || !punkThis32In);

            // Use a local variable for OUT parameter
            punkThis32Out = punkThis32In;

            // Push the OUT/IN-OUT parameter onto the stack
            TO_STACK32(pti, &punkThis32Out, IUnknown **);
            
            // Corel Draw 5.0 HACK
            // Some apps seem to call through the OUT parameter in the 
            // nested calls before the following call returns

            // Set the temporary proxy's this pointer to point to 
            // 32-bit out pointer pushed onto the satck
            pto = FIXVDMPTR(vpvPreAlloc, THUNK1632OBJ);
            pto->punkThis32 = (IUnknown *)&punkThis32Out;
            RELVDMPTR(vpvPreAlloc);

            // Set the 16-bit OUT parameter to the preallocated proxy
            *FIXVDMPTR(vpv, VPVOID) = vpvPreAlloc;
            RELVDMPTR(vpv);
        }
        else {
			thkDebugOut((DEB_WARN, "WARNING: ThunkInterface1632 - Cannot preallocate proxy\n"));
			pti->scResult = E_OUTOFMEMORY;
			dwResult = (DWORD) E_OUTOFMEMORY;
        }

    }
    else
    {
        // Assert invariant
        thkAssert((vpv && punkThis32In) || (!vpv && !punkThis32In));

        TO_STACK32(pti, punkThis32In, IUnknown *);
    }

    if(SUCCEEDED((SCODE)dwResult)) {
        // Execute the next THOP operation
        dwResult = EXECUTE_THOP1632(pti);
    }

    if((thop & THOP_OUT) && vpv) {
        vpvOut = 0;

        if(SUCCEEDED((SCODE)dwResult) && punkThis32Out) {
            // Obtain 16-bit proxy for the 32-bit interface
            if(punkOuter) {
                //Get the holder that was linked into TLS when the pUnkOuter
                //was being thunked in.
                pAggHolder = (TlsThkGetAggHolder())->pph;
                vpvOut = pti->pThkMgr->FindAggregate1632(vpvPreAlloc, punkOuter,
                                                         punkThis32Out, iidx, pAggHolder,
                                                         &dwStatus);
            }
            else {
                vpvOut = pti->pThkMgr->FindProxy1632(vpvPreAlloc, punkThis32Out,
                                                     NULL, iidx, &dwStatus);
            }

            if(vpvOut) {

                if((thop & THOP_OPMASK) == THOP_UNKINNER) {
                    if (dwStatus != FST_SHORTCUT) {
                        THUNK1632OBJ UNALIGNED *pProxy1632;
                        // Obtain the holder
                        pProxy1632 = FIXVDMPTR(vpvOut, THUNK1632OBJ);
                        pph = pProxy1632->pphHolder;

                        // Assert invariants in debug builds
                        thkAssert(pph->dwFlags & PH_AGGREGATEE);
                        thkAssert(dwStatus == FST_CREATED_NEW);

                        // Mark the proxy as representing inner unknown
                        pProxy1632->grfFlags = PROXYFLAG_PUNKINNER;
                    }
                }

                // Either the preallocated proxy was used and freed
                vpvPreAlloc = NULL;
            }
            else {
                pti->scResult = E_OUTOFMEMORY;
                dwResult = (DWORD)E_OUTOFMEMORY;
            }
            
            // Release the actual 32-bit interface. If a proxy to the 
            // 32-bit interface could not be created above, this could 
            // be the last release on the 32-bit interface
            punkThis32Out->Release();
        }

        // Set the OUT parameter
        pvpvOut = FIXVDMPTR(vpv, VPVOID);
        *pvpvOut = vpvOut;
        RELVDMPTR(vpv);

        thkDebugOut((DEB_ARGS, "%sOut1632 %s %p -> %p\n",
                     NestingLevelString(), IidIdxString(iidx), 
                     punkThis32Out, vpvOut));
    }
    
    if(punkThis32In) {
        if((thop & THOP_INOUT) == THOP_INOUT) {
            // IN-OUT parameter.
            thkAssert(vpvIn);

            // Release the 16-bit side interface
            ReleaseOnObj16(vpvIn);
        }
        else {
            // Just an IN parameter
            thkAssert(thop & THOP_IN);

#if DBG==1
            // Ensure that the following is not the last release
            // on the IN parameter
            THKSTATE thkstate;

            // Remember the current thunk state
            thkstate = pti->pThkMgr->GetThkState();

            // Set the thunk state to THKSTATE_VERIFYINPARAM
            pti->pThkMgr->SetThkState(THKSTATE_VERIFY16INPARAM);
#endif
            // Release the 32-bit side interface
            punkThis32In->Release();
#if DBG==1
            // Restore previous thunk state
            pti->pThkMgr->SetThkState(thkstate);
#endif
        }
    }

    // Cleanup
    if(vpvPreAlloc) {
        // Free preallocated proxy as it was not used
        pti->pThkMgr->FreeNewProxy1632(vpvPreAlloc, iidx);
    }

    if (bUnlinkAggHolder)
        TlsThkUnlinkAggHolder();

    return dwResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_IFACEGEN_1632, public
//
//  Synopsis:   Thunks interfaces out through ppvs from 16->32
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    23-Feb-94       DrewB   Created
//
//----------------------------------------------------------------------------

DWORD Thop_IFACEGEN_1632(THUNKINFO *pti)
{
    IIDIDX iidx;
    THOP thop, thopOp, thopWeakOffset;
    VPVOID vpvIid;
    IUnknown *punkOuter;
    IID UNALIGNED const *piid;

    thop = *pti->pThop++;
    thopOp = thop & THOP_OPMASK;

    thkAssert(thopOp == THOP_IFACEGEN ||
              thopOp == THOP_IFACEGENOWNER);

    // The current thop byte indicates how many bytes to look
    // back in the stack to find the IID which identifies the
    // interface being returned
    INDEX_STACK16(pti, vpvIid, VPVOID, *pti->pThop, sizeof(VPVOID));
    pti->pThop++;

    piid = (IID const *)GetReadPtr16(pti, vpvIid, sizeof(IID const));
    if (piid == NULL)
    {
        pti->scResult = E_INVALIDARG;
    }
    else
    {
#if DBG == 1
        if (!IsValidIid(*piid))
        {
            pti->scResult = E_INVALIDARG;
        }
        else
#endif
        {
            iidx = IidToIidIdx(*piid);
        }

        WOWRELVDMPTR(vpvIid);
    }

	if (FAILED(pti->scResult))
		return pti->scResult;

    punkOuter = NULL;
    if (thopOp == THOP_IFACEGENOWNER)
    {
        // Obtain the outer unknown that is being passed to the 32 bit world
        thopWeakOffset = *pti->pThop++;
        INDEX_STACK32(pti, punkOuter, IUnknown *, thopWeakOffset);
        if(punkOuter) {
            // Aggregation across 16-32 boundary
            // Assert that the IID requested is IID_IUnknown
            thkAssert(iidx == THI_IUnknown || 
                      (pti->iidx==THI_IPSFactoryBuffer && pti->dwMethod==3));
            // Change thop to indicate that inner unknown is being thunked
            if(iidx == THI_IUnknown)
                thop = (thop & THOP_IOMASK) | THOP_UNKINNER;
        }
    }

    return ThunkInterface1632(pti, iidx, thop, punkOuter);
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_OIFI_1632, public
//
//  Synopsis:   Convert OLEINPLACEFRAMEINFO
//
//  Arguments:  [pti] - Thunking state information
//
//  Returns:    Appropriate status code
//
//  History:    26-May-94       DrewB   Created
//
//----------------------------------------------------------------------------

DWORD Thop_OIFI_1632( THUNKINFO *pti )
{
    DWORD dwResult;
    VPVOID vpoifi16;
    OIFI16 UNALIGNED *poifi16;
    OLEINPLACEFRAMEINFO oifi32;
    OLEINPLACEFRAMEINFO *poifi32;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_OIFI);
    thkAssert((*pti->pThop & THOP_IOMASK) == THOP_OUT);

    // OIFIs are out-only parameters for their contents
    // However, cb is in/out, so we need to copy cb on the way in
    // Furthermore, cb may not be set to a valid value, in which
    // case the documentation mentions that it should be assumed
    // that this is an OLE 2.0 OIFI
    // This thop simply ignores cb on the way in and always sets
    // it to the OLE 2.0 size
    // Since we're out-only, this always works since the number of
    // fields we thunk is the size of the structure that we give out
    // If OLEINPLACEFRAMEINFO is extended, this thop will break

    // Assert that OLEINPLACEFRAMEINFO is what we expect it to be
    thkAssert(sizeof(OLEINPLACEFRAMEINFO) == 20);

    GET_STACK16(pti, vpoifi16, VPVOID);

    poifi32 = NULL;
    if (vpoifi16 != 0)
    {
        poifi16 = (OIFI16 UNALIGNED *) GetWritePtr16(pti, vpoifi16, sizeof(OIFI16));
        if (NULL != poifi16)
        {
            poifi32 = &oifi32;

            // OIFI's may be an out only parameters but if the "cb" field is
            // "in" RPC doesn't slice up structs, so the whole thing is "in"
            // as well.  We are Thoping here but if we want this to match
            // the RPC sematics then we need to copy all the fields.

            poifi32 = &oifi32;
            poifi32->cb            = sizeof(OLEINPLACEFRAMEINFO);
            poifi32->fMDIApp       = (BOOL)poifi16->fMDIApp;
            poifi32->hwndFrame     = HWND_32(poifi16->hwndFrame);
            poifi32->cAccelEntries = (UINT)poifi16->cAccelEntries;

            if (poifi16->haccel == NULL)
            {
                poifi32->haccel = NULL;
            }
            else
            {
                // WOW will clean up any dangling accelerator tables when
                // tasks die
                poifi32->haccel = HACCEL_32(poifi16->haccel);
                if (poifi32->haccel == NULL)
                {
                    dwResult = (DWORD)E_UNEXPECTED;
                }
            }

            WOWRELVDMPTR(vpoifi16);
        }
    }

    TO_STACK32(pti, poifi32, OLEINPLACEFRAMEINFO *);

    pti->pThop++;
    dwResult = EXECUTE_THOP1632(pti);

    if (poifi32 != NULL)
    {
        poifi16 = FIXVDMPTR(vpoifi16, OIFI16);

        if (SUCCEEDED(dwResult))
        {
            poifi16->cb            = sizeof(OIFI16);
            poifi16->fMDIApp       = (WORD)poifi32->fMDIApp;
            poifi16->hwndFrame     = HWND_16(poifi32->hwndFrame);
            poifi16->cAccelEntries =
                ClampULongToUShort(poifi32->cAccelEntries);

            if (poifi32->haccel == NULL)
            {
                poifi16->haccel = NULL;
            }
            else
            {
                // WOW will clean up any dangling accelerator tables when
                // tasks die
                poifi16->haccel = HACCEL_16(poifi32->haccel);
                if (poifi16->haccel == NULL)
                {
                    dwResult = (DWORD)E_UNEXPECTED;
                }
            }

#if DBG == 1
            if (SUCCEEDED(dwResult))
            {
                thkDebugOut((DEB_ARGS, "Out1632 OIFI: "
                             "%p {%d, %d, 0x%p, 0x%p, %d} -> "
                             "%p {%d, %d, 0x%04X, 0x%04X, %d}\n",
                             poifi32, poifi32->cb, poifi32->fMDIApp,
                             poifi32->hwndFrame, poifi32->haccel,
                             poifi32->cAccelEntries,
                             vpoifi16, poifi16->cb, (BOOL)poifi16->fMDIApp,
                             (DWORD)poifi16->hwndFrame, (DWORD)poifi16->haccel,
                             poifi16->cAccelEntries));
            }
#endif
        }

        if (FAILED(dwResult))
        {
            memset(poifi16, 0, sizeof(OIFI16));
        }

        RELVDMPTR(vpoifi16);
    }

    return dwResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_STGMEDIUM_1632, public
//
//  Synopsis:   Converts 32-bit STGMEDIUM to 16-bit STGMEDIUM returned
//              structure
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    23-Feb-94       BobDay  Created
//
//----------------------------------------------------------------------------

DWORD Thop_STGMEDIUM_1632( THUNKINFO *pti )
{
    DWORD       dwResult;
    BOOL        fThopInput;
    BOOL        fThopOutput;
    VPVOID      vpstgmedium16;
    STGMEDIUM   UNALIGNED *lpstgmedium16;
    STGMEDIUM   *lpstgmedium32;
    STGMEDIUM   stgmedium32;
    DWORD       dwSize;
    SCODE       sc;
    BOOL        fReleaseParam;
    SHORT       fTransferOwnership;
    FORMATETC   *pfe;
    THOP        thopFeOffset;
    BOOL        fReversedTYMED_NULL = FALSE;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_STGMEDIUM);

    fThopInput  = IS_THOP_IN(pti);
    fThopOutput = IS_THOP_OUT(pti);

    //
    // We currently don't have any unmodified or inout thops for STGMEDIUMs
    //
    thkAssert( (fThopInput || fThopOutput) &&
               (fThopInput != fThopOutput) &&
               "STGMEDIUM must be input or output only" );

    // +2 thop byte indicates whether there's a FORMATETC to look at
    // or not
    // We need to reference this now before the stack is modified
    // by argument recovery
    thopFeOffset = *(pti->pThop+2);
    if (thopFeOffset > 0)
    {
        INDEX_STACK32(pti, pfe, FORMATETC *, thopFeOffset);
    }
    else
    {
        pfe = NULL;
    }

    GET_STACK16(pti, vpstgmedium16, VPVOID);

    // Next thop byte indicates whether there's an ownership transfer
    // argument or not
    pti->pThop++;
    fReleaseParam = (BOOL)*pti->pThop++;

    if (fReleaseParam)
    {
        GET_STACK16(pti, fTransferOwnership, SHORT);
    }
    else
    {
        fTransferOwnership = FALSE;
    }

    // Skip FORMATETC offset thop
    pti->pThop++;

    lpstgmedium32 = NULL;

    if ( vpstgmedium16 != 0 )
    {
        if ( fThopInput )
        {
            // This code supports GetDataHere() passing TYMED_NULL.  It then
            // behaves like GetData().  This is not per the OLE spec.
            // According to every OLE spec TYMED_NULL is an invalid type in
            // GetDataHere().   But AlexGo says that 16bit inproc servers
            // did support this, especially the Default Handler / Clipboard.

            lpstgmedium16 = (STGMEDIUM FAR *)GetReadPtr16(pti, vpstgmedium16,
                                                           sizeof(STGMEDIUM));

			thkAssert(lpstgmedium16);
			// To fix a prefix bug... vpstgmedium should never be invalid, but
			// if it is, we'll get back NULL, so we'll return E_UNEXPECTED.
			if (lpstgmedium16)
			{
				if (lpstgmedium16->tymed == TYMED_NULL &&
					!fTransferOwnership)
				{
					WOWRELVDMPTR(vpstgmedium16);
					
					memset(&stgmedium32, 0, sizeof(stgmedium32));
					thkAssert( TYMED_NULL == 0 );   // Don't need to set tymed to 0
					
					fThopInput = FALSE;
					fThopOutput = TRUE;
					fReversedTYMED_NULL = TRUE;
				}
				else
				{
					WOWRELVDMPTR(vpstgmedium16);
					
					sc = ConvertStgMed1632(pti, vpstgmedium16, &stgmedium32,
										   pfe, fTransferOwnership, &dwSize);
					if (SUCCEEDED(sc))
					{
						lpstgmedium32 = &stgmedium32;
					}
				}
			} 
			else 
			{
				return E_UNEXPECTED;
			}
        }

        if ( fThopOutput )
        {
            thkAssert( fThopOutput );

            lpstgmedium16 = (STGMEDIUM FAR *)GetWritePtr16(pti, vpstgmedium16,
                                                           sizeof(STGMEDIUM));
            if ( lpstgmedium16 != NULL )
            {
                lpstgmedium32 = &stgmedium32;
                WOWRELVDMPTR(vpstgmedium16);
            }

            // 32->16 sets tymed to TYMED_NULL before passing
            // on the STGMEDIUM because some apps incorrectly check for this
            // I'm assuming this isn't necessary for 16->32 because 32-bit
            // apps can't rely on tymed being NULL since nothing in the 32-bit
            // code sets it that way for out parameters
            // DrewB 5/30
        }
    }

    TO_STACK32(pti, lpstgmedium32, STGMEDIUM FAR *);

    if (fReleaseParam)
    {
        TO_STACK32(pti, (BOOL)fTransferOwnership, BOOL);
    }

    dwResult = EXECUTE_THOP1632(pti);

    if ( lpstgmedium32 != NULL)
    {
        if ( fThopInput )
        {
            if (!fTransferOwnership || FAILED(dwResult))
            {
                sc = CleanStgMed32(pti, lpstgmedium32, vpstgmedium16,
                                   dwSize, TRUE, pfe);
                if (FAILED(sc))
                {
                    dwResult = (DWORD)sc;
                }
            }
            else if (SUCCEEDED(dwResult))
            {
                lpstgmedium16 = FIXVDMPTR(vpstgmedium16, STGMEDIUM);
                if (lpstgmedium16->pUnkForRelease == NULL)
                {
                    RELVDMPTR(vpstgmedium16);
                    sc = CleanStgMed16(pti, vpstgmedium16, lpstgmedium32,
                                       0, FALSE, pfe);
                    thkAssert(SUCCEEDED(sc));
                }
                else
                {
                    RELVDMPTR(vpstgmedium16);
                }
            }
        }
        else
        {
            thkAssert( fThopOutput );

            if (SUCCEEDED(dwResult))
            {
                sc = ConvertStgMed3216(pti, lpstgmedium32, vpstgmedium16,
                                       pfe, FALSE, &dwSize);
                if (FAILED(sc))
                {
                    dwResult = (DWORD)sc;
                    ReleaseStgMedium(lpstgmedium32);
                }
                else if (lpstgmedium32->pUnkForRelease == NULL)
                {
                    sc = CleanStgMed32(pti, lpstgmedium32, vpstgmedium16,
                                       dwSize, FALSE, pfe);
                    thkAssert(SUCCEEDED(sc));
                }
            }

            // Clear the [out] parameters if the call failed.
            // Unless it had previously been an [in] parameter.
            // We don't want to erase the caller's [in] argument.

            if (FAILED(dwResult) && !fReversedTYMED_NULL)
            {
                lpstgmedium16 = FIXVDMPTR(vpstgmedium16, STGMEDIUM);
                memset(lpstgmedium16, 0, sizeof(STGMEDIUM));
                RELVDMPTR(vpstgmedium16);
            }
        }
    }

    return dwResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   ConvertStatStg3216, public
//
//  Synopsis:   Converts a STATSTG
//
//  Arguments:  [pti] - Thunk info
//              [pss32] - STATSTG
//              [vpss16] - STATSTG
//              [vpstrPreAlloc] - Preallocated string memory or NULL
//              [cchPreAlloc] - Amount preallocated
//
//  Returns:    Appropriate status code
//
//  Modifies:   [vpss16]
//
//  History:    14-May-94       DrewB   Created
//
//  Notes:      Assumes input STATSTG memory is valid
//              Assumes task memory for the string
//
//----------------------------------------------------------------------------

SCODE ConvertStatStg3216(THUNKINFO *pti,
                         STATSTG *pss32,
                         VPVOID vpss16,
                         VPSTR vpstrPreAlloc,
                         UINT cchPreAlloc)
{
    STATSTG UNALIGNED *pss16;
    SCODE sc;
    VPSTR vpstr16;

    sc = ConvertTaskString3216(pti, pss32->pwcsName,
                               vpstrPreAlloc, cchPreAlloc,
                               &vpstr16);
    if (SUCCEEDED(sc))
    {
        pss16 = FIXVDMPTR(vpss16, STATSTG);
        memcpy(pss16, pss32, sizeof(STATSTG));
        pss16->pwcsName = (LPOLESTR)vpstr16;
        RELVDMPTR(vpss16);
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_STATSTG_1632, public
//
//  Synopsis:   Converts 32-bit STATSTG to 16-bit STATSTG returned structure
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    23-Feb-94       BobDay  Created
//
//----------------------------------------------------------------------------
DWORD Thop_STATSTG_1632( THUNKINFO *pti )
{
    DWORD       dwResult;
    VPVOID      vpstatstg16;
    STATSTG UNALIGNED *lpstatstg16;
    VPSTR       vpstr;
    STATSTG     statstg32;
    STATSTG     *lpstatstg32;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_STATSTG);

    //
    // We currently don't have any input thops for STATSTGs
    //
    thkAssert( (*pti->pThop & THOP_IOMASK) == THOP_OUT &&
               "STATSTG must be output only" );

    GET_STACK16(pti, vpstatstg16, VPVOID);

    lpstatstg32 = NULL;

    lpstatstg16 = (STATSTG FAR *)GetWritePtr16( pti, vpstatstg16,
                                                sizeof(STATSTG) );
    if ( lpstatstg16 != NULL )
    {
        statstg32.pwcsName = NULL;
        lpstatstg32 = &statstg32;

        vpstr = (VPSTR)TaskMalloc16(CBSTRINGPREALLOC);
        if (vpstr == 0)
        {
            pti->scResult = E_OUTOFMEMORY;
        }

        WOWRELVDMPTR(vpstatstg16);
    }

    TO_STACK32(pti, lpstatstg32, STATSTG FAR *);

    pti->pThop++;
    dwResult = EXECUTE_THOP1632(pti);

    if ( lpstatstg32 != NULL )
    {
        if ( SUCCEEDED(dwResult) )
        {
            SCODE sc;

            sc = ConvertStatStg3216(pti, &statstg32, vpstatstg16,
                                    vpstr, CWCSTRINGPREALLOC);
            if (FAILED(sc))
            {
                dwResult = sc;
            }
        }

        if (FAILED(dwResult))
        {
            TaskFree16(vpstr);

            lpstatstg16 = FIXVDMPTR(vpstatstg16, STATSTG);
            memset(lpstatstg16, 0, sizeof(STATSTG));
            RELVDMPTR(vpstatstg16);
        }
    }

    return dwResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_DVTARGETDEVICE_1632, public
//
//  Synopsis:   Converts 16-bit DVTARGETDEVICE to 32-bit DVTARGETDEVICE
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    23-Feb-94       BobDay  Created
//
//----------------------------------------------------------------------------
DWORD Thop_DVTARGETDEVICE_1632( THUNKINFO *pti )
{
    DWORD               dwResult;
    UINT                uiSize;
    DVTARGETDEVICE      *lpdv32;
    VPVOID              vpdv16;
    SCODE               sc;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_DVTARGETDEVICE);

    //
    // We currently don't have any output thops for DVTARGETDEVICEs
    //
    thkAssert( (*pti->pThop & THOP_IOMASK) == THOP_IN &&
               "DVTARGETDEVICE must be input only" );

    //
    // Processing for a DVTARGETDEVICE FAR * as input
    //
    GET_STACK16(pti, vpdv16, VPVOID);

    lpdv32 = NULL;

    if ( vpdv16 != 0 )
    {
        sc = ConvertDvtd1632(pti, vpdv16, ArStack32, FrStack32, &lpdv32,
                             &uiSize);
        if (FAILED(sc))
        {
            pti->scResult = sc;
        }
    }

    TO_STACK32(pti, lpdv32, DVTARGETDEVICE FAR *);
    pti->pThop++;
    dwResult = EXECUTE_THOP1632(pti);

    if (lpdv32 != NULL)
    {
        FrStack32(lpdv32, uiSize);
    }

    return dwResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_FORMATETC_1632, public
//
//  Synopsis:   Converts 16-bit FORMATETC to 32-bit FORMATETC and back
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    24-Feb-94       BobDay  Created
//
//----------------------------------------------------------------------------

DWORD Thop_FORMATETC_1632( THUNKINFO *pti )
{
    DWORD               dwResult;
    BOOL                fThopInput;
    BOOL                fThopOutput;
    VPVOID              vpformatetc16;
    FORMATETC16 UNALIGNED *lpformatetc16;
    LPFORMATETC         lpformatetc32;
    FORMATETC           formatetc32;
    DVTARGETDEVICE      *lpdv32;
    SCODE               sc;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_FORMATETC);

    fThopInput  = IS_THOP_IN(pti);
    fThopOutput = IS_THOP_OUT(pti);

    //
    // We have only input and output thops, not both, or neither
    //
    thkAssert( (fThopInput || fThopOutput) &&
            (fThopInput != fThopOutput) &&
               "formatetc must be input or output only" );

    lpdv32 = NULL;

    GET_STACK16(pti, vpformatetc16, VPVOID);

    if ( vpformatetc16 == 0 )
    {
        lpformatetc32 = NULL;
    }
    else
    {
        lpformatetc32 = &formatetc32;

        if ( fThopInput )
        {
            sc = ConvertFetc1632(pti, vpformatetc16, lpformatetc32, FALSE);
            if (FAILED(sc))
            {
                pti->scResult = sc;
            }
        }
        else
        {
            thkAssert( fThopOutput );
            //
            // The below memset is needed at least for the DATA_S_SAMEFORMATETC
            // case.  This allows it to be cleaned up because all its pointers
            // will be null.
            //
            memset( &formatetc32, 0, sizeof(formatetc32) );
            lpformatetc16 = (LPFORMATETC16)GetWritePtr16(pti, vpformatetc16,
                                                         sizeof(FORMATETC16));
            WOWRELVDMPTR(vpformatetc16);
        }
    }

    TO_STACK32(pti, lpformatetc32, LPFORMATETC);
    pti->pThop++;
    dwResult = EXECUTE_THOP1632(pti);

    if ( fThopInput )
    {
        if (lpformatetc32 != NULL && lpformatetc32->ptd != NULL)
        {
            TaskFree32(lpformatetc32->ptd);
        }
    }

    if ( fThopOutput && vpformatetc16 != NULL)
    {
        if (SUCCEEDED(dwResult))
        {
            sc = ConvertFetc3216(pti, lpformatetc32, vpformatetc16, TRUE);
            if (FAILED(sc))
            {
                dwResult = sc;
            }
        }

        if (FAILED(dwResult))
        {
            lpformatetc16 = FIXVDMPTR(vpformatetc16, FORMATETC16);
            memset(lpformatetc16, 0, sizeof(FORMATETC16));
            RELVDMPTR(vpformatetc16);
        }
    }

    return dwResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_LOGPALETTE_1632, public
//
//  Synopsis:   Converts 16-bit LOGPALLETE to 32-bit LOGPALETTE
//              and converts 32-bit LOGPALETTE returned to 16-bit structure
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    23-Feb-94       BobDay  Created
//
//----------------------------------------------------------------------------

DWORD Thop_LOGPALETTE_1632 ( THUNKINFO *pti )
{
    DWORD         dwResult;
    UINT          uiSize;
    LPLOGPALETTE  lplogpal32;
    VPVOID        vplogpal16;
    LOGPALETTE UNALIGNED *lplogpal16;
    VPVOID        vp16;
    LPVOID UNALIGNED *lp16;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_LOGPALETTE);

    //
    // It must be either an input or output LOGPALETTE
    //
    thkAssert( ((*pti->pThop & THOP_IOMASK) == THOP_IN ||
                (*pti->pThop & THOP_IOMASK) == THOP_OUT) &&
               "Hey, LOGPALETTE can't be input and output!" );

    lplogpal32 = NULL;

    if ( (*pti->pThop & THOP_IN) != 0 )
    {
        //
        // Processing for a LPLOGPALETTE as input
        //
        GET_STACK16(pti, vplogpal16, VPVOID);

        if ( vplogpal16 != 0 )
        {
            // Copy over the input LOGPALETTE structure
            lplogpal16 = (LPLOGPALETTE)GetReadPtr16( pti, vplogpal16,
                                                     sizeof(LOGPALETTE) );

            if ( lplogpal16 != NULL )
            {
                uiSize = CBPALETTE(lplogpal16->palNumEntries);

                WOWRELVDMPTR(vplogpal16);

                lplogpal16 = (LPLOGPALETTE)GetReadPtr16(pti, vplogpal16,
                                                        uiSize);
                if ( lplogpal16 != NULL )
                {
                    lplogpal32 = (LPLOGPALETTE)CoTaskMemAlloc(uiSize);
                    if ( lplogpal32 == NULL )
                    {
                        pti->scResult = E_OUTOFMEMORY;
                    }
                    else
                    {
                        memcpy( lplogpal32, lplogpal16, uiSize );
                    }

                    WOWRELVDMPTR(vplogpal16);
                }
            }
        }

        TO_STACK32(pti, lplogpal32, LPLOGPALETTE);
        pti->pThop++;
        dwResult = EXECUTE_THOP1632(pti);

        if ( lplogpal32 )
        {
            CoTaskMemFree( lplogpal32 );
        }
    }
    else
    {
        //
        // Processing for LPLPLOGPALETTE as output
        //

        thkAssert((*pti->pThop & THOP_OUT) != 0);

        GET_STACK16(pti, vp16, VPVOID);

        vplogpal16 = (VPVOID)TaskMalloc16(CBPALETTE(NPALETTEPREALLOC));
        if (vplogpal16 == 0)
        {
            pti->scResult = E_OUTOFMEMORY;
        }

        TO_STACK32(pti, &lplogpal32, LPLOGPALETTE *);

        pti->pThop++;
        dwResult = EXECUTE_THOP1632(pti);

        if ( SUCCEEDED(dwResult) && lplogpal32 != NULL )
        {
            //
            // Copy the returned LOGPALETTE into 16-bit memory
            //
            uiSize = CBPALETTE(lplogpal32->palNumEntries);
            if (uiSize > CBPALETTE(NPALETTEPREALLOC))
            {
                TaskFree16(vplogpal16);
                vplogpal16 = (VPVOID)TaskMalloc16(uiSize);
                if ( vplogpal16 == 0 )
                {
                    dwResult = (DWORD)E_OUTOFMEMORY;
                }
            }

            if (vplogpal16 != 0)
            {
                lplogpal16 = (LPLOGPALETTE)WOWFIXVDMPTR(vplogpal16, uiSize);
                if ( lplogpal16 == NULL )
                {
                    dwResult = (DWORD)E_UNEXPECTED;
                    vplogpal16 = 0;
                }
                else
                {
                    memcpy( lplogpal16, lplogpal32, uiSize );

                    WOWRELVDMPTR(vplogpal16);
                }
            }

            TaskFree32( lplogpal32 );
        }
        else
        {
            TaskFree16(vplogpal16);
            vplogpal16 = 0;
        }

        //
        // Update the value pointed to by the parameter on the 16-bit stack
        //
        lp16 = FIXVDMPTR(vp16, LPVOID);
        if ( lp16 == NULL )
        {
            dwResult = (DWORD)E_UNEXPECTED;
        }
        else
        {
            *lp16 = (LPVOID)vplogpal16;
            RELVDMPTR(vp16);
        }
    }
    return dwResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_CRGIID_1632, public
//
//  Synopsis:   Converts 16-bit CRGIID to 32-bit CRGIID structure
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    23-Feb-94       BobDay  Created
//
//----------------------------------------------------------------------------
DWORD Thop_CRGIID_1632( THUNKINFO *pti )
{
    DWORD       dwResult;
    DWORD       dwCount;
    VPVOID      vpiid16;
    IID UNALIGNED *lpiid16;
    IID         *lpiid32;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_CRGIID);

    //
    // We currently don't have any output thops for CRGIIDs
    //
    thkAssert( (*pti->pThop & THOP_IOMASK) == 0 &&
               "CRGIID must be unmodified only" );

    GET_STACK16(pti, dwCount, DWORD);
    GET_STACK16(pti, vpiid16, VPVOID);

    lpiid32 = NULL;

    if ( vpiid16 != 0 )
    {
        lpiid16 = (IID UNALIGNED *)GetReadPtr16( pti, vpiid16,
                                                 dwCount*sizeof(IID) );
        if ( lpiid16 != NULL )
        {
            lpiid32 = (IID FAR *)CoTaskMemAlloc( dwCount * sizeof(IID) );
            if ( lpiid32 == NULL )
            {
                pti->scResult = E_OUTOFMEMORY;
            }
            else
            {
                memcpy( lpiid32, lpiid16, dwCount*sizeof(IID) );
            }

            WOWRELVDMPTR(vpiid16);
        }
    }

    TO_STACK32(pti, dwCount, DWORD);
    TO_STACK32(pti, lpiid32, IID FAR *);

    pti->pThop++;
    dwResult = EXECUTE_THOP1632(pti);

    if ( lpiid32 != NULL )
    {
        CoTaskMemFree( lpiid32 );
    }
    return( dwResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_INTERFACEINFO_1632, public
//
//  Synopsis:   Converts an INTERFACEINFO
//
//  Arguments:  [pti] - Thunking state information
//
//  Returns:    Appropriate status code
//
//  History:    19-May-94       DrewB   Created
//
//----------------------------------------------------------------------------

DWORD Thop_INTERFACEINFO_1632(THUNKINFO *pti)
{
    INTERFACEINFO *pii32;
    INTERFACEINFO ii32;
    INTERFACEINFO16 UNALIGNED *pii16;
    VPVOID vpii16;
    DWORD dwResult;
    IUnknown *punk32;
    VPVOID vpvUnk16;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_INTERFACEINFO);
    thkAssert((*pti->pThop & THOP_INOUT) == THOP_IN);

    pii32 = NULL;
    punk32 = NULL;

    GET_STACK16(pti, vpii16, VPVOID);
    if (vpii16 != 0)
    {
        pii16 = (INTERFACEINFO16 UNALIGNED *)
            GetReadPtr16(pti, vpii16, sizeof(INTERFACEINFO16));
        if (pii16 != NULL)
        {
            if (pii16->pUnk != NULL)
            {
                vpvUnk16 = pii16->pUnk;

                WOWRELVDMPTR(vpii16);

                punk32 =
                    pti->pThkMgr->FindProxy3216(NULL, vpvUnk16, NULL,
                                                INDEX_IIDIDX(THI_IUnknown),
                                                FALSE, NULL);
                if (punk32 == NULL)
                {
                    pti->scResult = E_OUTOFMEMORY;
                }

                pii16 = FIXVDMPTR(vpii16, INTERFACEINFO16);
            }

            pii32 = &ii32;
            pii32->pUnk = punk32;
            pii32->iid = pii16->iid;
            pii32->wMethod = pii16->wMethod;

            WOWRELVDMPTR(vpii16);

            thkDebugOut((DEB_ARGS,
                         "In1632  INTERFACEINFO: %p -> %p {%p (%p), %s, %u}\n",
                         vpii16, pii32, pii32->pUnk, pii16->pUnk,
                         IidOrInterfaceString(&pii32->iid), pii32->wMethod));
        }
    }

    TO_STACK32(pti, pii32, INTERFACEINFO *);

    pti->pThop++;
    dwResult = EXECUTE_THOP1632(pti);

    if(punk32) {        
        // Release the 32-bit interface as it is an IN parameter
        punk32->Release();
    }

    return dwResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_RETURNTYPE_1632, public
//
//  Synopsis:   Thunks the return value of a call
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    24-Feb-94       DrewB   Created
//
//  Notes:      This thunk assumes that the return value will always fit
//              in 32 bits and that the thops for it are only one thop
//              long.  This fits the existing APIs and methods
//
//----------------------------------------------------------------------------

DWORD Thop_RETURNTYPE_1632(THUNKINFO *pti)
{
    THOP thops[2];
    DWORD dwResult;
    ALIAS alias;
    VPVOID vpvPreAlloc = NULL;
    IIDIDX iidx;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_RETURNTYPE);
    thkAssert((*pti->pThop & THOP_IOMASK) == 0);

    pti->fResultThunked = TRUE;

    pti->pThop++;

    // Remember return type thop
    thops[0] = *pti->pThop++;
    if ((thops[0] & THOP_OPMASK) == THOP_COPY ||
        (thops[0] & THOP_OPMASK) == THOP_IFACE ||
        (thops[0] & THOP_OPMASK) == THOP_ALIAS32)
    {
        thops[1] = *pti->pThop++;
    }

    // Preallocate any necessary resources
    switch(thops[0])
    {
    case THOP_IFACE | THOP_IN:
        iidx = INDEX_IIDIDX(thops[1]);
        if ((vpvPreAlloc =
             pti->pThkMgr->CanGetNewProxy1632(iidx)) == NULL)
        {
            pti->scResult = E_OUTOFMEMORY;
        }
        break;

    case THOP_ALIAS32:
        thkAssert(thops[1] == ALIAS_CREATE);

        // The value used for preallocation doesn't really matter
        // as long as it's unique and not INVALID_VALUE
        // In our case we know that we won't have to deal with nested
        // preallocations so uniqueness is not as much of an issue
        // By using INVALID_HANDLE_VALUE, we can be sure that there
        // won't already be an entry with that value already in the
        // alias table since we're aliasing handles
        alias = gAliases32.AddValue((DWORD)INVALID_HANDLE_VALUE);
        if (alias == INVALID_ALIAS)
        {
            pti->scResult = E_OUTOFMEMORY;
        }
        break;
    }

    dwResult = EXECUTE_THOP1632(pti);

    // Now that we have the return value thunk it from 32->16
    // We must use pti->scResult to check for failure rather than
    // dwResult because dwResult may not be an SCODE

    switch(thops[0])
    {
    case THOP_COPY:
        // Only handle DWORD copies
        thkAssert(thops[1] == sizeof(DWORD));
        break;

    case THOP_SHORTLONG:
        // For boolean results, not necessary to clamp
        dwResult = (DWORD)(SHORT)*(LONG *)&dwResult;
        break;

    case THOP_IFACE | THOP_IN:
        // Thunking an interface as a return value is completly broken
        // First, such an interface needs to be thunked as an OUT parameter
        // which I am fixing below. Second, the IID of the interface being
        // thunked needs to be in the THOP string for proper thunking of
        // interface. The only known case where an interface is returned
        // is IRpcStubBuffer::IsIIDSupported() and the interface returned
        // is of type IRpcStubBuffer, not IUnknown. As this method is not
        // used in the curremt COM code, I am not changing THOP strings
        // to reflect the IID of the interface being thunked
        //            Gopalk     Mar 27, 97
        if (dwResult != 0)
        {
            if (FAILED(pti->scResult))
            {
                dwResult = 0;
            }
            else
            {
                IUnknown *punk = (IUnknown *) dwResult;
                dwResult =
                    (DWORD)pti->pThkMgr->FindProxy1632(vpvPreAlloc,
                                                       (IUnknown *)dwResult, NULL,
                                                       iidx, NULL);
                
                // Release actual interface as it is an OUT parameter
                // This could be the last release on the interface if the
                // above call failed;
                punk->Release();
                thkAssert(dwResult);

                thkDebugOut((DEB_ARGS, "Ret1632 %s %p\n",
                             inInterfaceNames[thops[1]].pszInterface,
                             dwResult));
            }
        }
        else
        {
            pti->pThkMgr->FreeNewProxy1632(vpvPreAlloc, iidx);
        }
        break;

    case THOP_ALIAS32:
        if (dwResult != 0)
        {
            if (FAILED(pti->scResult))
            {
                dwResult = 0;
            }
            else
            {
                gAliases32.SetValue(alias, dwResult);

                thkDebugOut((DEB_ARGS, "Ret1632 ALIAS32: 0x%08lX -> 0x%04lX\n",
                             dwResult, alias));

                dwResult = (DWORD)alias;
            }
        }
        break;

    default:
        thkAssert(!"Unhandled 1632 return type");
        break;
    }

    return dwResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_IFACE_1632, public
//
//  Synopsis:   Thunks a known interface pointer
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    24-Feb-94       DrewB   Created
//
//----------------------------------------------------------------------------

DWORD Thop_IFACE_1632(THUNKINFO *pti)
{
    IIDIDX iidx;
    THOP thop, thopOp, thopWeakOffset;
    IUnknown *punkOuter;

    thop = *pti->pThop++;
    thopOp = thop & THOP_OPMASK;

    thkAssert(   thopOp == THOP_IFACE
              || thopOp == THOP_IFACEOWNER
              || thopOp == THOP_IFACENOADDREF
              || thopOp == THOP_UNKOUTER);

    iidx = INDEX_IIDIDX(*pti->pThop++);

    // There's a bit of a special case here in that IMalloc is
    // not thunked so it doesn't have a real index but it's used
    // in thop strings so it has a fake index to function as a placeholder
    // The fake index is THI_COUNT so allow that in the assert
    thkAssert(IIDIDX_INDEX(iidx) >= 0 && IIDIDX_INDEX(iidx) <= THI_COUNT);
    thkAssert(thopOp != THOP_UNKOUTER || iidx == THI_IUnknown);

    punkOuter = NULL;
    if (   thopOp == THOP_IFACEOWNER
        || thopOp == THOP_IFACENOADDREF)
    {
        thopWeakOffset = *pti->pThop++;
        INDEX_STACK32(pti, punkOuter, IUnknown *, thopWeakOffset);
        if(punkOuter && (thopOp==THOP_IFACEOWNER)) {
            // Aggregation across 16-32 boundary
            // Assert invariants
            thkAssert(iidx == THI_IRpcProxyBuffer || iidx == THI_IRpcProxy);
            // Change thop to indicate that inner unknown is being thunked
            thop = (thop & THOP_IOMASK) | THOP_UNKINNER;
        }
    }

    return ThunkInterface1632(pti, iidx, thop, punkOuter);
}

typedef struct tagOLESTREAMOBJECT
{
    OLESTREAM   os;
    VPVOID      vpolestream16;
} OLESTREAMOBJECT, FAR * LPOLESTREAMOBJECT;

#define OLESTREAM_GET 0
#define OLESTREAM_PUT 1


//+---------------------------------------------------------------------------
//
//  Function:   OLESTREAM_Callback, private
//
//  Synopsis:   Handles callbacks into 16-bit world for OLESTREAM methods
//
//  Arguments:  [dwMethod] - Index of method to invoke
//              [lposo]    - Pointer to 32 LPOLESTREAM
//              [lpv]      - Pointer to 32 bit buffer
//              [dwCount]  - Size of 32 bit buffer
//
//
//  Returns:    Appropriate status code
//
//  History:    11-Mar-94   BobDay  Created
//              29-May-94   TerryRu Converted to call WOWCallBackEx directly.
//
//----------------------------------------------------------------------------

DWORD OLESTREAM_Callback( DWORD dwMethod,
                          LPOLESTREAM lpos,
                          LPVOID lpv,
                          DWORD dwCount )
{
    const DWORD             cbStack     = sizeof( DWORD ) +
        sizeof( VPVOID ) + sizeof( VPVOID );

    BYTE                    b32Args[cbStack];
    DWORD                   dwResult;

    VPVOID                  vpvVtbl16;
    VTBLFN                  vpfn16;

    VPVOID                  vpolestream16;
    LPOLESTREAMOBJECT       lposo;

    VPVOID                  vp16;
    LPVOID                  lp16;


    lposo = (LPOLESTREAMOBJECT)lpos;
    vpolestream16 = lposo->vpolestream16;

    // Get pointer to 16 bit this pointer

    vpvVtbl16 =  (VPVOID)*FIXVDMPTR( vpolestream16,  VPVOID );
    RELVDMPTR(vpolestream16);
    vpfn16    =  (VTBLFN)*FIXVDMPTR( vpvVtbl16+dwMethod*sizeof(VPVOID),
                                     VPVOID );
    RELVDMPTR(vpvVtbl16+dwMethod*sizeof(VPVOID));

    //
    // now thop the  IN 32 bit-block of memory to 16 bit block
    //

    vp16 = WgtAllocLock( GMEM_MOVEABLE, dwCount, NULL );
    if ( vp16 == NULL )
    {
        return (DWORD) E_OUTOFMEMORY;
    }

    if ( dwMethod == OLESTREAM_PUT )
    {
        lp16 = WOWFIXVDMPTR( vp16, dwCount );
        memcpy( lp16, lpv, dwCount );
        WOWRELVDMPTR(vp16);
    }

    // setup 32 bit arguements.
    *(DWORD *)(b32Args)             = dwCount;
    *(VPVOID *)(b32Args+4)          = vp16;
    *(VPVOID *)(b32Args+8)          = vpolestream16;

    if ( !CallbackTo16Ex( (DWORD)vpfn16, WCB16_PASCAL, cbStack, b32Args,
                         &dwResult) )
    {
        dwResult = (DWORD)E_UNEXPECTED;
    }

    if ( dwMethod == OLESTREAM_GET )
    {

        lp16 = WOWFIXVDMPTR( vp16, dwCount );
        memcpy( (LPVOID) lpv, lp16, dwCount );
        WOWRELVDMPTR(vp16);

    }

    WgtUnlockFree(vp16);

    thkDebugOut((DEB_INVOKES, "OLESTREAM_Callback returns 0x%08lX\n",
                 dwResult));

    return dwResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   OLESTREAM_Get_Proxy, private
//
//  Synopsis:   Handles callbacks into 16-bit world for OLESTREAM::Get
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    11-Mar-94   BobDay  Created
//              29-May-94   TerryRu Now calls OLESTREAM::Get using Pascal
//                                  calling conventions.
//
//----------------------------------------------------------------------------

DWORD OLESTREAM_Get_Proxy(
    LPOLESTREAM lpos,
    void FAR *  lpv,
    DWORD       dwCount
)
{
    return OLESTREAM_Callback( OLESTREAM_GET, lpos, lpv, dwCount );
}

//+---------------------------------------------------------------------------
//
//  Function:   OLESTREAM_Put_Proxy, private
//
//  Synopsis:   Handles callbacks into 16-bit world for OLESTREAM::Put
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    11-Mar-94   BobDay  Created
//              29-May-94   TerryRu Now call OLESTREAM::Put using pascal
//              calling conventions.
//
//----------------------------------------------------------------------------

DWORD OLESTREAM_Put_Proxy(
    LPOLESTREAM lpos,
    const void FAR* lpv,
    DWORD       dwCount
)
{
    return OLESTREAM_Callback( OLESTREAM_PUT, lpos,(LPVOID) lpv, dwCount );
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_OLESTREAM_1632, public
//
//  Synopsis:   Thunks an OLESTREAM parameter from 16-bit to 32-bit
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    14-Mar-94   BobDay  Created
//
//----------------------------------------------------------------------------

_OLESTREAMVTBL osVtbl =
{
    OLESTREAM_Get_Proxy,
    OLESTREAM_Put_Proxy
};

DWORD Thop_OLESTREAM_1632(THUNKINFO *pti)
{
    OLESTREAMOBJECT osObject;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_OLESTREAM);

    //
    // Ignore the THOP_INPUT/THOP_OUTPUT, it is always just an interface
    //

    osObject.os.lpstbl = &osVtbl;
    GET_STACK16(pti, osObject.vpolestream16, VPVOID);

    TO_STACK32(pti, &osObject, LPOLESTREAMOBJECT );

    pti->pThop++;
    return EXECUTE_THOP1632(pti);
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_RPCOLEMESSAGE_1632, public
//
//  Synopsis:   Converts 16-bit RPCOLEMESSAGE to 32-bit RPCOLEMESSAGE
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    23-Feb-94       BobDay  Created
//      28-May-94       JohannP Rewritten
//      13-Aug-94       Rickhi  made it work for GetBuffer when the
//                              buffer size grows, commented better
//
//  CODEWORK:   this routine is inefficient. since it cant tell why it was
//      called (GetBuffer/SendReceive/Invoke/FreeBuffer) it always
//      copies the data, when it only really needs to in Invoke and
//      in SendReceive.
//
//  Context: This routine will "Thop" a client side RPCOLEMESSGE (aka "rom")
//      three times.  The first time for the "getbuffer" call, the second
//      time for the "SendRecieve", and the third time for the "freebuffer".
//      This make it confusing, some calls allocate a buffer but don't
//      free it.  Other calls free a buffer they didn't allocate.  A good
//      way to see what is happening is to step through several calls to
//      this routine with a debugger and note the pointer values.
//
//----------------------------------------------------------------------------
DWORD Thop_RPCOLEMESSAGE_1632( THUNKINFO *pti )
{
    DWORD           dwResult;
    PRPCOLEMESSAGE  prom32;
    VPVOID          vprom16;
    RPCOLEMESSAGE UNALIGNED *prom16;
    LPVOID          lp16;
    RPCOLEMESSAGE   rom32;
    BOOL            fAllocNew = FALSE;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_RPCOLEMESSAGE);

    //
    // We currently have only INOUT RPCOLEMESSAGE
    //
    thkAssert( (*pti->pThop & THOP_IOMASK) == (THOP_IN | THOP_OUT) &&
               "RPCOLEMESSAGE must be input/output only" );

    //
    // Processing for a RPCOLEMESSAGE FAR * as input/output
    //
    GET_STACK16(pti, vprom16, VPVOID);

    prom32 = NULL;
    if ( vprom16 != 0 )
    {
        // Copy over the input RPCOLEMESSAGE structure
        prom16 = (RPCOLEMESSAGE UNALIGNED *)
            GetReadWritePtr16( pti, vprom16, sizeof(RPCOLEMESSAGE) );
        if ( prom16 != NULL )
        {
            // Note: ROM_THUNK_FIELD(prom) holds the pointer to the 32 bit rom
            //        in case the buffer is not NULL

            // Note: this assert is not valid when a fault happens on the
            //        server side. In that case, the return buffer is NULLed
            //        by the 16bit stub but the THUNK_FIELD is non-null.

            //thkAssert((prom16->Buffer == NULL &&
            //           ROM_THUNK_FIELD(prom16) == NULL) ||
            //          (prom16->Buffer != NULL &&
            //           ROM_THUNK_FIELD(prom16) != NULL));

            if (prom16->Buffer != NULL)
            {
                prom32 = (RPCOLEMESSAGE *)ROM_THUNK_FIELD(prom16);

                if ( prom32->Buffer != NULL )
                {
                    // we use the min size of the two buffers because when
                    // the stub (server side) calls GetBuffer he is supplying
                    // the old pBuffer with the new (and potentially larger)
                    // cbBuffer

                    DWORD cbSizeMin = (prom16->cbBuffer <= prom32->cbBuffer) ?
                        prom16->cbBuffer :  prom32->cbBuffer;

                    lp16 = (LPVOID)GetReadPtr16(pti,
                                                (VPVOID)prom16->Buffer,
                                                cbSizeMin);
                    if (lp16 == NULL)
                    {
                        prom32 = NULL;
                    }
                    else
                    {
                        memcpy( prom32->Buffer, lp16, prom32->cbBuffer );
                        WOWRELVDMPTR((VPVOID)prom16->Buffer);
                    }
                }

				if (prom32)
				{
					// the stub might be asking for a larger buffer for output
					// parameters than it was given for input parameters. We have
					// to figure that out here by comparing the 16bit size with
					// the 32bit size.

					fAllocNew = (prom32->cbBuffer < prom16->cbBuffer);
					prom32->cbBuffer = prom16->cbBuffer;
				}
				else
				{
					fAllocNew = FALSE;
				}
            }
            else
            {
                rom32 = *prom16;
                prom32 = &rom32;
            }

            WOWRELVDMPTR(vprom16);
        }
    }

    TO_STACK32(pti, prom32, PRPCOLEMESSAGE);
    pti->pThop++;
    dwResult = EXECUTE_THOP1632(pti);

    if ( prom32 != NULL )
    {
        prom16 = (RPCOLEMESSAGE UNALIGNED *)
            GetReadWritePtr16( pti, vprom16, sizeof(RPCOLEMESSAGE) );
        if ( prom16 == NULL )
        {
            dwResult = (DWORD)E_UNEXPECTED;
        }
        else
        {
            if (SUCCEEDED(dwResult))
            {
                if (prom32->Buffer == NULL)
                {
                    //  RELEASE THE BUFFER AND ROM:
                    // Free the 16 bit buffer, copy the 32 bit rom into
                    // the 16 bit rom and free the 32bit rom, if it was
                    // allocated
                    //
                    if (prom16->Buffer != 0)
                    {
                        TaskFree16((VPVOID)prom16->Buffer);
                    }

                    *prom16 = *prom32;

                    if (prom32 != &rom32)
                    {
                        TaskFree32(prom32);
                        prom32 = NULL;
                    }
                    ROM_THUNK_FIELD(prom16) = NULL;
                }
                else
                {
                    // ALLOCATE AND/OR COPYBACK THE BUFFER AND ROM:
                    RPCOLEMESSAGE *pr32;
                    LPVOID pBuffer;

                    // Create a message to save the 32-bit message in
                    // Use the existing one in the thunk field if we can
                    if (ROM_THUNK_FIELD(prom16) == NULL)
                    {
                        pr32 = (RPCOLEMESSAGE *)
                            TaskMalloc32(sizeof(RPCOLEMESSAGE));
                    }
                    else
                    {
                        pr32 = (RPCOLEMESSAGE *)ROM_THUNK_FIELD(prom16);
                    }
                    *pr32 = *prom32;

                    //
                    // Allocate an output buffer and copy the buffer back
                    //
                    if (   (prom16->Buffer == NULL)
                        || (prom16->cbBuffer < prom32->cbBuffer)
                        || fAllocNew)
                    {
                        if (prom16->Buffer != NULL)
                        {
                            TaskFree16((VPVOID) prom16->Buffer);
                        }

                        pBuffer = (LPVOID)TaskMalloc16(prom32->cbBuffer );
                    }
                    else
                    {
                        pBuffer = prom16->Buffer;
                    }

                    *prom16 = *prom32;
                    prom16->Buffer = pBuffer;
                    ROM_THUNK_FIELD(prom16) = pr32;

                    if (prom16->Buffer == NULL)
                    {
                        dwResult = (DWORD)E_OUTOFMEMORY;
                    }
                    else
                    {
                        lp16 = (LPVOID)GetReadPtr16(pti,
                                                    (VPVOID)prom16->Buffer,
                                                    prom16->cbBuffer);
                        if ( lp16 == NULL )
                        {
                            dwResult = (DWORD)E_UNEXPECTED;
                        }
                        else
                        {
                            memcpy( lp16, prom32->Buffer,
                                    prom32->cbBuffer );
                            WOWRELVDMPTR((VPVOID)prom16->Buffer);
                        }
                    }
                }
            }

            WOWRELVDMPTR(vprom16);
        }
    }

    return dwResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_ALIAS32_1632, public
//
//  Synopsis:   Handles 16-bit aliases to 32-bit quantities
//
//  Arguments:  [pti] - Thunking state information
//
//  Returns:    Appropriate status code
//
//  History:    27-May-94       DrewB   Created
//
//----------------------------------------------------------------------------

DWORD Thop_ALIAS32_1632(THUNKINFO *pti)
{
    ALIAS alias;
    DWORD dwValue;
    THOP thopAction;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_ALIAS32);
    thkAssert((*pti->pThop & THOP_IOMASK) == 0);

    pti->pThop++;

    GET_STACK16(pti, alias, ALIAS);

    // Second byte indicates how the alias should be handled
    thopAction = *pti->pThop++;

    if (alias != 0)
    {
        switch(thopAction)
        {
        case ALIAS_RESOLVE:
            dwValue = gAliases32.AliasValue(alias);
            break;

        case ALIAS_REMOVE:
            dwValue = gAliases32.AliasValue(alias);
            gAliases32.RemoveAlias(alias);
            break;

        default:
            thkAssert(!"Default hit in Thop_ALIAS32_1632");
			dwValue = 0;
            break;
        }
    }
    else
    {
        dwValue = 0;
    }

    thkDebugOut((DEB_ARGS, "In1632  ALIAS32: 0x%04X -> 0x%08lX\n",
                 alias, dwValue));

    TO_STACK32(pti, dwValue, DWORD);

    return EXECUTE_THOP1632(pti);
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_ENUM_1632, public
//
//  Synopsis:   Thunks Enum::Next parameters
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    1-Mar-94        BobDay  Created
//
//  Notes:      This thunk is the start of a 2-byte thop.  The next thop
//              byte references a function in the enumerator table, rather
//              than the standard thop table.
//
//----------------------------------------------------------------------------

DWORD Thop_ENUM_1632(THUNKINFO *pti)
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_ENUM);
    thkAssert((*pti->pThop & THOP_IOMASK) == 0);

    //
    // Get then next thop byte and execute it as a Enum thop
    //
    pti->pThop++;
    return EXECUTE_ENUMTHOP1632(pti);
}

//+---------------------------------------------------------------------------
//
//  Function:   CallbackProcessing_1632, public
//
//  Synopsis:   Thunks IOleObject::Draw pfnContinue & DWORD parameters
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    3-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------
typedef struct tagCallbackControl
{
    DWORD   dwContinue;
    VPVOID  vpfn16;
} CALLBACKCONTROL;

BOOL CallbackProcessing_1632( DWORD dwContinue )
{
    DWORD           dwResult;
    CALLBACKCONTROL *lpcbc;

    lpcbc = (CALLBACKCONTROL *)dwContinue;

    // The callback function must be FAR PASCAL
    // It's declared CALLBACK in the methods so this is ensured
    dwResult = CallbackTo16( lpcbc->vpfn16, lpcbc->dwContinue );

    return (BOOL)((WORD)dwResult);  // Ignore HIWORD
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_CALLBACK_1632, public
//
//  Synopsis:   Thunks IOleObject::Draw pfnContinue & DWORD parameters
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    3-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------

DWORD Thop_CALLBACK_1632(THUNKINFO *pti)
{
    VPVOID          vpfn16;
    DWORD           dwContinue;
    CALLBACKCONTROL cbc;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_CALLBACK);
    thkAssert((*pti->pThop & THOP_IOMASK) == 0);

    GET_STACK16(pti, vpfn16, VPVOID);
    GET_STACK16(pti, dwContinue, DWORD);

    if ( vpfn16 == 0 )
    {
        TO_STACK32(pti, NULL, LPVOID);
        TO_STACK32(pti, dwContinue, DWORD);
    }
    else
    {
        cbc.vpfn16     = vpfn16;
        cbc.dwContinue = dwContinue;

        TO_STACK32(pti, CallbackProcessing_1632, LPVOID);
        TO_STACK32(pti, (DWORD)&cbc, DWORD);
    }

    pti->pThop++;
    return EXECUTE_THOP1632(pti);
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_CLSCONTEXT_1632, public
//
//  Synopsis:   Converts a class context flags DWORD
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    29-Jun-94       DrewB   Created
//
//----------------------------------------------------------------------------

DWORD Thop_CLSCONTEXT_1632(THUNKINFO *pti)
{
    DWORD dwClsContext;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_CLSCONTEXT);
    thkAssert((*pti->pThop & THOP_IOMASK) == 0);

    GET_STACK16(pti, dwClsContext, DWORD);

    // When passing a 16-bit class context on to 32-bits,
    // add on a flag to indicate that this is a 16-bit request
    // in the inproc server case

    if (dwClsContext & CLSCTX_INPROC_SERVER)
    {
        dwClsContext |= CLSCTX_INPROC_SERVER16;
    }

    TO_STACK32(pti, dwClsContext, DWORD);

    pti->pThop++;
    return EXECUTE_THOP1632(pti);
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_FILENAME_1632, public
//
//  Synopsis:   Converts a filename string
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    24-Aug-94       DrewB   Created
//
//----------------------------------------------------------------------------

DWORD Thop_FILENAME_1632(THUNKINFO *pti)
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_FILENAME);

    // Can be in or out only
    thkAssert((*pti->pThop & THOP_IOMASK) == THOP_IN ||
              (*pti->pThop & THOP_IOMASK) == THOP_OUT);

    if ((*pti->pThop & THOP_IN) != 0)
    {
        // No special processing is necessary for filenames going
        // from 16->32 since it isn't possible for 16-bit code to
        // generate a filename which can't be handled in 32-bits

        return ThunkInString1632(pti);
    }
    else
    {
        thkAssert((*pti->pThop & THOP_OUT) != 0);

        // Convert filenames going from 32->16 to short filenames
        // to avoid any possible problems with non-8.3 names.

        return ThunkOutString1632(pti, TRUE);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_SIZEDSTRING_1632, public
//
//  Synopsis:   Converts strings which cannot exceed a given length
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    02-Sep-94       DrewB   Created
//
//----------------------------------------------------------------------------

DWORD Thop_SIZEDSTRING_1632(THUNKINFO *pti)
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_SIZEDSTRING);
    thkAssert((*pti->pThop & THOP_IOMASK) == THOP_IN);

    // For 16->32, there are no limits on string length so
    // thunk the string normally

    // Advance once to account for the length byte
    // ThunkInString will advance again

    pti->pThop++;
    return ThunkInString1632(pti);
}

#define THOP_FN(x)  Thop_ ## x ## _1632

DWORD (*CONST aThopFunctions1632[])(THUNKINFO *) =
{

                                // x = Implemented
                                // ? = Mysteriously not needed
                                //   = Left to do
                                //
                                // ^
                                // |
                                // +===+
                                //     |
                                //     v
                                //
    ThunkCall1632,                  // x Terminating THOP
    Thop_ShortToLong_1632,          // x SHORTLONG
    Thop_WordToDword_1632,          // x WORDDWORD
    Thop_Copy_1632,                 // x COPY
    THOP_FN(LPSTR),                 // x LPSTR
    THOP_FN(LPLPSTR),               // x LPLPSTR
    THOP_FN(BUFFER),                // x BUFFER
    Thop_UserHandle_1632,           // x HUSER
    Thop_GdiHandle_1632,            // x HGDI
    THOP_FN(SIZE),                  // x SIZE
    THOP_FN(RECT),                  // x RECT
    THOP_FN(MSG),                   // x MSG
    THOP_FN(HRESULT),               // x HRESULT
    THOP_FN(STATSTG),               // x STATSTG
    THOP_FN(DVTARGETDEVICE),        // x DVTARGETDEVICE
    THOP_FN(STGMEDIUM),             // x STGMEDIUM
    THOP_FN(FORMATETC),             // x FORMATETC
    THOP_FN(HACCEL),                // x HACCEL
    THOP_FN(OIFI),                  // x OLEINPLACEFRAMEINFO
    THOP_FN(BINDOPTS),              // x BIND_OPTS
    THOP_FN(LOGPALETTE),            // x LOGPALETTE
    THOP_FN(SNB),                   // x SNB
    THOP_FN(CRGIID),                // x CRGIID
    THOP_FN(OLESTREAM),             // x OLESTREAM
    THOP_FN(HTASK),                 // x HTASK
    THOP_FN(INTERFACEINFO),         // x INTERFACEINFO
    THOP_FN(IFACE),                 // x IFACE
    THOP_FN(IFACE),                 // x IFACEOWNER
    THOP_FN(IFACE),                 // x IFACENOADDREF
    Thop_ERROR_1632,                // x IFACECLEAN
    THOP_FN(IFACEGEN),              // x IFACEGEN
    THOP_FN(IFACEGEN),              // x IFACEGENOWNER
    THOP_FN(IFACE),                 // x UNKOUTER
    Thop_ERROR_1632,                // x UNKINNER
    Thop_ERROR_1632,                // x ROUTINE_INDEX
    THOP_FN(RETURNTYPE),            // x RETURN_TYPE
    THOP_FN(NULL),                  // x NULL
    Thop_ERROR_1632,                // x ERROR
    THOP_FN(ENUM),                  // x ENUM
    THOP_FN(CALLBACK),              // x CALLBACK
    THOP_FN(RPCOLEMESSAGE),         // x RPCOLEMESSAGE
    THOP_FN(ALIAS32),               // x ALIAS32
    THOP_FN(CLSCONTEXT),            // x CLSCONTEXT
    THOP_FN(FILENAME),              // x FILENAME
    THOP_FN(SIZEDSTRING),           // x SIZEDSTRING
};

//+---------------------------------------------------------------------------
//
//  Function:   General_Enum_1632, private
//
//  Synopsis:   Thunking for standard OLE enumerator interface ::Next member
//              function.
//
//  Arguments:  [pti] - Thunk state information
//              [uiSize32] - 32-bit information size
//              [uiSize16] - 16-bit information size
//              [pfnCallback] - Data thunking callback
//              [pfnCleanup] - Thunking cleanup
//
//  Returns:    Appropriate status code
//
//  History:    1-Mar-94        BobDay  Created
//
//  Notes:      This handler is called from many IXXXEnum::Next handlers thop
//              thunks to do the standard sorts of "buffer of structures"
//              processing.
//
//----------------------------------------------------------------------------
#define MAX_ALLOCA_STRUCT   10

DWORD General_Enum_1632(
    THUNKINFO   *pti,
    UINT        uiSize32,
    UINT        uiSize16,
    SCODE       (*pfnCallback)( THUNKINFO *, LPVOID, VPVOID),
    void        (*pfnCleanup)( THUNKINFO *, LPVOID, VPVOID)   )
{
    DWORD       dwResult;
    ULONG       ulCount;
    VPVOID      vpstruct16;
    VPVOID      vpfetched16;
    LPVOID      lpstruct32;
    LPVOID      lpstruct32Iterate;
    VPVOID      vpstruct16Iterate;
    ULONG       ulFetched32;
    ULONG       *lpfetched32;
    ULONG UNALIGNED *lpfetched16;
    ULONG       ulIterate;
    LPVOID      lp16;
    BOOL        fError;
    SCODE       sc;

    dwResult = (DWORD)S_OK;

    GET_STACK16(pti, ulCount, ULONG );
    GET_STACK16(pti, vpstruct16, VPVOID );
    GET_STACK16(pti, vpfetched16, VPVOID );

    //
    // THIS ROUTINE CAN DEAL WITH dwResult RATHER THAN pti->scResult BECAUSE
    // WE KNOW THIS IS THE ONLY THOP FOR THIS FUNCTION!  NO OTHER CLEANUP
    // WILL HAVE TO BE DONE!
    //
    ulFetched32 = 0;
    lpfetched32 = &ulFetched32;
    lp16 = NULL;
    lpstruct32 = NULL;

    if ( vpstruct16 != 0 )
    {
        if ( ulCount == 0 )
        {
            dwResult = (DWORD)E_INVALIDARG;
        }
        else
        {
            //
            // Verify we have write access to the 16-bit memory.
            //
            lp16 = GetWritePtr16(pti, vpstruct16, uiSize16*ulCount);
            if ( lp16 == NULL )
            {
                dwResult = (DWORD)E_INVALIDARG;
            }
            else
            {
                if ( ulCount > MAX_ALLOCA_STRUCT )
                {
                    lpstruct32 = (LPVOID)CoTaskMemAlloc( ulCount * uiSize32 );
                    if (lpstruct32 == NULL)
                    {
                        dwResult = (DWORD)E_OUTOFMEMORY;
                    }
                }
                else
                {
                    lpstruct32 = (LPVOID)STACKALLOC32( ulCount * uiSize32 );
                    if (lpstruct32 == NULL)
                    {
                        dwResult = (DWORD)E_OUTOFMEMORY;
                    }
                }

                WOWRELVDMPTR(vpstruct16);
            }
        }
    }

    if (SUCCEEDED(dwResult))
    {
        TO_STACK32(pti, ulCount, ULONG);
        TO_STACK32(pti, lpstruct32, LPVOID);
        TO_STACK32(pti, lpfetched32, ULONG FAR *);

        pti->pThop++;
        dwResult = EXECUTE_THOP1632(pti);
    }

    if ( SUCCEEDED(dwResult) )
    {
        if ( vpstruct16 != 0 )
        {
            // Some apps (MsWorks3 is one) return S_FALSE and do not return
            // the number of elements retrieved.  The only thing we can
            // do is ignore the enumeration since we don't know how many
            // were actually set.  Of course, we can't ignore all enumerations
            // when the return is S_FALSE so we only handle the case
            // where S_FALSE was returned on a enumeration of one element,
            // in which we can be sure there isn't any valid data
            if (dwResult == (DWORD)S_FALSE && ulCount == 1)
            {
                ulFetched32 = 0;
            }

            //
            // Iterate through all of the structures, converting them
            // into 16-bit
            //
            fError = FALSE;
            ulIterate = 0;
            vpstruct16Iterate = vpstruct16;
            lpstruct32Iterate = lpstruct32;

            while ( ulIterate < ulFetched32 )
            {
                //
                // Callback to the callback function to do any specific
                // processing
                //
                sc = (*pfnCallback)( pti, lpstruct32Iterate,
                                     vpstruct16Iterate );

                if ( FAILED(sc) )
                {
                    fError = TRUE;
                    dwResult = sc;
                }

                vpstruct16Iterate = (VPVOID)((DWORD)vpstruct16Iterate +
                                             uiSize16);
                lpstruct32Iterate = (LPVOID)((DWORD)lpstruct32Iterate +
                                             uiSize32);

                ulIterate++;
            }

            if ( fError )
            {
                //
                // Cleanup all these guys
                //
                ulIterate = 0;
                vpstruct16Iterate = vpstruct16;
                lpstruct32Iterate = lpstruct32;

                while ( ulIterate <= ulFetched32 )
                {
                    (*pfnCleanup)( pti, lpstruct32Iterate, vpstruct16Iterate );
                    vpstruct16Iterate = (VPVOID)((DWORD)vpstruct16Iterate +
                                                 uiSize16);
                    lpstruct32Iterate = (LPVOID)((DWORD)lpstruct32Iterate +
                                                 uiSize32);

                    ulIterate++;
                }
            }
        }
    }

    if (FAILED(dwResult) && lp16 != NULL)
    {
        memset(lp16, 0, ulCount*uiSize16);
    }

    //
    // Free up any space we've allocated
    //
    if (lpstruct32 != NULL)
    {
        if ( ulCount > MAX_ALLOCA_STRUCT )
        {
            CoTaskMemFree( lpstruct32 );
        }
        else
        {
            STACKFREE32(lpstruct32, ulCount*uiSize32);
        }
    }

    if ( vpfetched16 != 0 )
    {
        lpfetched16 = FIXVDMPTR( vpfetched16, ULONG);
        *lpfetched16 = ulFetched32;
        RELVDMPTR(vpfetched16);
    }

    return dwResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   Callback_STRING_1632, public
//
//  Synopsis:   Prepares the LPOLESTR for the copy back into 16-bit address
//              space.
//
//  Arguments:  [pti] - Thunking state information
//              [lp32] - Pointer to 32-bit returned structure
//              [lp16] - Pointer to 16-bit output structure
//
//  Returns:    SCODE indicating success/failure
//
//  History:    1-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------

SCODE Callback_STRING_1632( THUNKINFO *pti, LPVOID lp32, VPVOID vp16 )
{
    VPSTR vpstr;
    VPSTR UNALIGNED *pvpstr16;
    SCODE sc;

    vpstr = 0;
    sc = ConvertTaskString3216(pti, *(LPOLESTR *)lp32, NULL, 0,
                               &vpstr);

    pvpstr16 = FIXVDMPTR(vp16, VPSTR);
    *pvpstr16 = vpstr;
    RELVDMPTR(vp16);

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   Cleanup_STRING_1632, public
//
//  Synopsis:   Cleans up the any STRINGs returned (either to 16-bit or 32-bit)
//
//  Arguments:  [pti] - Thunking state information
//              [lp32] - Pointer to 32-bit returned structure
//              [lp16] - Pointer to 16-bit output structure
//
//  Returns:    nothing, should NEVER fail
//
//  History:    1-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------

void Cleanup_STRING_1632( THUNKINFO *pti, LPVOID lp32, VPVOID vp16 )
{
    VPSTR UNALIGNED *lpvpstr16;
    VPSTR           vpstr16;

    lpvpstr16 = FIXVDMPTR( vp16, VPSTR );
    vpstr16 = *lpvpstr16;
    RELVDMPTR(vp16);

    if ( vpstr16 != 0 )
    {
        TaskFree16( vpstr16 );
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_Enum_STRING_1632, public
//
//  Synopsis:   Thunks IEnumSTRING::Next parameters
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    1-Mar-94        BobDay  Created
//
//  Notes:      This thunk is 2nd part of a 2-byte thop.
//
//----------------------------------------------------------------------------

DWORD Thop_Enum_STRING_1632(THUNKINFO *pti)
{
    return General_Enum_1632(pti,
                             sizeof(LPOLESTR),
                             sizeof(VPSTR),
                             Callback_STRING_1632,
                             Cleanup_STRING_1632 );
}

//+---------------------------------------------------------------------------
//
//  Function:   Callback_UNKNOWN_1632, public
//
//  Synopsis:   Prepares the UNKNOWN structure for the copy back into 16-bit
//              address space.
//
//  Arguments:  [pti] - Thunking state information
//              [lp32] - Pointer to 32-bit returned structure
//              [lp16] - Pointer to 16-bit output structure
//
//  Returns:    SCODE indicating success/failure
//
//  History:    1-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------

SCODE Callback_UNKNOWN_1632( THUNKINFO *pti, LPVOID lp32, VPVOID vp16 )
{
    VPVOID          vpunknown16;
    SCODE           sc = S_OK;

    vpunknown16 =
        pti->pThkMgr->FindProxy1632(NULL, *(LPUNKNOWN *)lp32, NULL,
                                    INDEX_IIDIDX(THI_IUnknown), NULL);
    
    // Release the actual 32-bit IUnknown as it is a OUT parameter
    // This could be the last release on the interface if the
    // above call failed;
    (*((LPUNKNOWN *) lp32))->Release();
    
    if(!vpunknown16) {
        sc = E_OUTOFMEMORY;
    }

    *FIXVDMPTR( vp16, VPVOID ) = vpunknown16;
    RELVDMPTR(vp16);

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   Cleanup_UNKNOWN_1632, public
//
//  Synopsis:   Cleans up the any UNKNOWNs returned (either to 16-bit
//              or 32-bit)
//
//  Arguments:  [pti] - Thunking state information
//              [lp32] - Pointer to 32-bit returned structure
//              [lp16] - Pointer to 16-bit output structure
//
//  Returns:    nothing, should NEVER fail
//
//  History:    1-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------

void Cleanup_UNKNOWN_1632( THUNKINFO *pti, LPVOID lp32, VPVOID vp16 )
{
    LPUNKNOWN        lpunknown32;
    VPVOID           vpunknown16;

    vpunknown16 = *FIXVDMPTR( vp16, VPVOID );
    RELVDMPTR(vp16);
    lpunknown32 = *(LPUNKNOWN *)lp32;

    if(vpunknown16) {
        // Release the proxy to 32-bit interface
        pti->pThkMgr->ReleaseProxy1632(vpunknown16);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_Enum_UNKNOWN_1632, public
//
//  Synopsis:   Thunks IEnumUNKNOWN::Next parameters
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    1-Mar-94        BobDay  Created
//
//  Notes:      This thunk is 2nd part of a 2-byte thop.
//
//----------------------------------------------------------------------------

DWORD Thop_Enum_UNKNOWN_1632(THUNKINFO *pti)
{
    return General_Enum_1632(pti,
                             sizeof(LPUNKNOWN),
                             sizeof(LPUNKNOWN),
                             Callback_UNKNOWN_1632,
                             Cleanup_UNKNOWN_1632 );
}

//+---------------------------------------------------------------------------
//
//  Function:   Callback_STATSTG_1632, public
//
//  Synopsis:   Prepares the STATSTG structure for the copy back into 16-bit
//              address space.
//
//  Arguments:  [pti] - Thunking state information
//              [lp32] - Pointer to 32-bit returned structure
//              [lp16] - Pointer to 16-bit output structure
//
//  Returns:    SCODE indicating success/failure
//
//  History:    1-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------

SCODE Callback_STATSTG_1632( THUNKINFO *pti, LPVOID lp32, VPVOID vp16 )
{
    (FIXVDMPTR(vp16, STATSTG))->pwcsName = NULL;
    RELVDMPTR(vp16);
    return ConvertStatStg3216(pti, (STATSTG *)lp32, vp16,
                              NULL, 0);
}

//+---------------------------------------------------------------------------
//
//  Function:   Cleanup_STATSTG_1632, public
//
//  Synopsis:   Cleans up the any STATSTGs returned (either to 16-bit
//              or 32-bit)
//
//  Arguments:  [pti] - Thunking state information
//              [lp32] - Pointer to 32-bit returned structure
//              [lp16] - Pointer to 16-bit output structure
//
//  Returns:    nothing, should NEVER fail
//
//  History:    1-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------

void Cleanup_STATSTG_1632( THUNKINFO *pti, LPVOID lp32, VPVOID vp16 )
{
    STATSTG UNALIGNED *lpstatstg16;
    VPVOID vpstr;

    lpstatstg16 = FIXVDMPTR( vp16, STATSTG );
    vpstr = (VPVOID)lpstatstg16->pwcsName;
    RELVDMPTR(vp16);

    if ( vpstr != 0)
    {
        TaskFree16( vpstr );
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_Enum_STATSTG_1632, public
//
//  Synopsis:   Thunks IEnumSTATSTG::Next parameters
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    1-Mar-94        BobDay  Created
//
//  Notes:      This thunk is 2nd part of a 2-byte thop.
//
//----------------------------------------------------------------------------

DWORD Thop_Enum_STATSTG_1632(THUNKINFO *pti)
{
    return General_Enum_1632(pti,
                             sizeof(STATSTG),
                             sizeof(STATSTG),
                             Callback_STATSTG_1632,
                             Cleanup_STATSTG_1632 );
}

//+---------------------------------------------------------------------------
//
//  Function:   Callback_FORMATETC_1632, public
//
//  Synopsis:   Prepares the FORMATETC structure for the copy back into 16-bit
//              address space.
//
//  Arguments:  [pti] - Thunking state information
//              [lp32] - Pointer to 32-bit returned structure
//              [lp16] - Pointer to 16-bit output structure
//
//  Returns:    SCODE indicating success/failure
//
//  History:    1-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------

SCODE Callback_FORMATETC_1632( THUNKINFO *pti, LPVOID lp32, VPVOID vp16 )
{
    (FIXVDMPTR(vp16, FORMATETC16))->ptd = NULL;
    RELVDMPTR(vp16);
    return ConvertFetc3216(pti, (FORMATETC *)lp32, vp16, TRUE);
}

//+---------------------------------------------------------------------------
//
//  Function:   Cleanup_FORMATETC_1632, public
//
//  Synopsis:   Cleans up the any FORMATETCs returned (either to 16-bit
//              or 32-bit)
//
//  Arguments:  [pti] - Thunking state information
//              [lp32] - Pointer to 32-bit returned structure
//              [lp16] - Pointer to 16-bit output structure
//
//  Returns:    nothing, should NEVER fail
//
//  History:    1-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------

void Cleanup_FORMATETC_1632( THUNKINFO *pti, LPVOID lp32, VPVOID vp16 )
{
    FORMATETC16 UNALIGNED *lpformatetc16;
    VPVOID vptd;

    lpformatetc16 = FIXVDMPTR( vp16, FORMATETC16 );
    vptd = lpformatetc16->ptd;
    RELVDMPTR(vp16);

    if (vptd != 0)
    {
        TaskFree16(vptd);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_Enum_FORMATETC_1632, public
//
//  Synopsis:   Thunks IEnumFORMATETC::Next parameters
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    1-Mar-94        BobDay  Created
//
//  Notes:      This thunk is 2nd part of a 2-byte thop.
//
//----------------------------------------------------------------------------

DWORD Thop_Enum_FORMATETC_1632(THUNKINFO *pti)
{
    return General_Enum_1632(pti,
                             sizeof(FORMATETC),
                             sizeof(FORMATETC16),
                             Callback_FORMATETC_1632,
                             Cleanup_FORMATETC_1632 );
}

//+---------------------------------------------------------------------------
//
//  Function:   Callback_STATDATA_1632, public
//
//  Synopsis:   Prepares the STATDATA structure for the copy back into 16-bit
//              address space.
//
//  Arguments:  [pti] - Thunking state information
//              [lp32] - Pointer to 32-bit returned structure
//              [lp16] - Pointer to 16-bit output structure
//
//  Returns:    SCODE indicating success/failure
//
//  History:    1-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------
SCODE Callback_STATDATA_1632( THUNKINFO *pti, LPVOID lp32, VPVOID vp16 )
{
    SCODE               sc;
    LPSTATDATA          lpstatdata32;
    STATDATA16 UNALIGNED *lpstatdata16;
    VPVOID              vpadv16;

    sc = S_OK;

    lpstatdata32 = (LPSTATDATA)lp32;

    if (lpstatdata32->pAdvSink != NULL)
    {
        // We don't know whether it's an AdviseSink or
        // an AdviseSink2, so pass AdviseSink2 since it's
        // a superset of AdviseSink and will work for both

        vpadv16 = pti->pThkMgr->FindProxy1632(NULL, lpstatdata32->pAdvSink, NULL,
                                              INDEX_IIDIDX(THI_IAdviseSink2),
                                              NULL);

        // Release the actual 32-bit IAdviseSink as it is a OUT parameter
        // This could be the last release on the interface if the
        // above call failed;
        lpstatdata32->pAdvSink->Release();

        if(!vpadv16) {
            sc = E_OUTOFMEMORY;
        }
    }
    else
    {
        vpadv16 = 0;
    }

    lpstatdata16 = FIXVDMPTR( vp16, STATDATA16 );
    lpstatdata16->formatetc.ptd = NULL;
    if (SUCCEEDED(sc))
    {
        // If this fails the AdviseSink proxy will be cleaned up in
        // the cleanup function later

        sc = ConvertFetc3216(pti,
                             &lpstatdata32->formatetc,
                             vp16+FIELD_OFFSET(STATDATA16, formatetc), TRUE);
    }

    if (SUCCEEDED(sc))
    {
        lpstatdata16->advf = lpstatdata32->advf;
        lpstatdata16->pAdvSink = vpadv16;
        lpstatdata16->dwConnection = lpstatdata32->dwConnection;
    }

    RELVDMPTR(vp16);

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   Cleanup_STATDATA_1632, public
//
//  Synopsis:   Cleans up the any STATDATAs returned (either to 16-bit
//              or 32-bit)
//
//  Arguments:  [pti] - Thunking state information
//              [lp32] - Pointer to 32-bit returned structure
//              [lp16] - Pointer to 16-bit output structure
//
//  Returns:    nothing, should NEVER fail
//
//  History:    1-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------

void Cleanup_STATDATA_1632( THUNKINFO *pti, LPVOID lp32, VPVOID vp16 )
{
    STATDATA *lpstatdata32;
    STATDATA16 UNALIGNED *lpstatdata16;
    LPADVISESINK lpadv32;
    VPVOID vptd;

    lpstatdata32 = (STATDATA FAR *)lp32;
    lpadv32 = lpstatdata32->pAdvSink;

    lpstatdata16 = FIXVDMPTR( vp16, STATDATA16 );
    vptd = lpstatdata16->formatetc.ptd;
    RELVDMPTR(vp16);

    if(lpstatdata16->pAdvSink) {
        // Release the proxy to 32-bit interface
        pti->pThkMgr->ReleaseProxy1632((VPVOID) lpstatdata32->pAdvSink);
    }

    if (vptd != 0)
    {
        TaskFree16(vptd);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_Enum_STATDATA_1632, public
//
//  Synopsis:   Thunks IEnumSTATDATA::Next parameters
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    1-Mar-94        BobDay  Created
//
//  Notes:      This thunk is 2nd part of a 2-byte thop.
//
//----------------------------------------------------------------------------

DWORD Thop_Enum_STATDATA_1632(THUNKINFO *pti)
{
    return General_Enum_1632(pti,
                             sizeof(STATDATA),
                             sizeof(STATDATA16),
                             Callback_STATDATA_1632,
                             Cleanup_STATDATA_1632 );
}

//+---------------------------------------------------------------------------
//
//  Function:   Callback_MONIKER_1632, public
//
//  Synopsis:   Prepares the MONIKER structure for the copy back into 16-bit
//              address space.
//
//  Arguments:  [pti] - Thunking state information
//              [lp32] - Pointer to 32-bit returned structure
//              [lp16] - Pointer to 16-bit output structure
//
//  Returns:    SCODE indicating success/failure
//
//  History:    1-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------

SCODE Callback_MONIKER_1632( THUNKINFO *pti, LPVOID lp32, VPVOID vp16 )
{
    VPVOID        vpmoniker16;
    SCODE         sc = S_OK;

    vpmoniker16 = pti->pThkMgr->FindProxy1632(NULL, *(LPMONIKER *)lp32, NULL,
                                              INDEX_IIDIDX(THI_IMoniker),
                                              NULL);
    
    // Release the actual 32-bit IMoniker as it is a OUT parameter
    // This could be the last release on the interface if the
    // above call failed;
    (*(LPMONIKER *)lp32)->Release();

    if(!vpmoniker16) {
        sc = E_OUTOFMEMORY;
    }

    *FIXVDMPTR(vp16, VPVOID) = vpmoniker16;
    RELVDMPTR(vp16);

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   Cleanup_MONIKER_1632, public
//
//  Synopsis:   Cleans up the any MONIKERs returned (either to 16-bit
//              or 32-bit)
//
//  Arguments:  [pti] - Thunking state information
//              [lp32] - Pointer to 32-bit returned structure
//              [lp16] - Pointer to 16-bit output structure
//
//  Returns:    nothing, should NEVER fail
//
//  History:    1-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------

void Cleanup_MONIKER_1632( THUNKINFO *pti, LPVOID lp32, VPVOID vp16 )
{
    LPMONIKER       lpmoniker32;
    VPVOID          vpmoniker16;

    vpmoniker16 = *FIXVDMPTR( vp16, VPVOID );
    RELVDMPTR(vp16);
    lpmoniker32 = *(LPMONIKER *)lp32;

    if(vpmoniker16) {
        pti->pThkMgr->ReleaseProxy1632(vpmoniker16);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_Enum_MONIKER_1632, public
//
//  Synopsis:   Thunks IEnumMONIKER::Next parameters
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    1-Mar-94        BobDay  Created
//
//  Notes:      This thunk is 2nd part of a 2-byte thop.
//
//----------------------------------------------------------------------------

DWORD Thop_Enum_MONIKER_1632(THUNKINFO *pti)
{
    return General_Enum_1632(pti,
                             sizeof(LPMONIKER),
                             sizeof(LPMONIKER),
                             Callback_MONIKER_1632,
                             Cleanup_MONIKER_1632 );
}

//+---------------------------------------------------------------------------
//
//  Function:   Callback_OLEVERB_1632, public
//
//  Synopsis:   Prepares the OLEVERB structure for the copy back into 16-bit
//              address space.
//
//  Arguments:  [pti] - Thunking state information
//              [lp32] - Pointer to 32-bit returned structure
//              [lp16] - Pointer to 16-bit output structure
//
//  Returns:    SCODE indicating success/failure
//
//  History:    1-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------

SCODE Callback_OLEVERB_1632( THUNKINFO *pti, LPVOID lp32, VPVOID vp16 )
{
    SCODE       sc;
    OLEVERB     *lpoleverb32;
    OLEVERB UNALIGNED *lpoleverb16;
    VPSTR vpstr;

    lpoleverb32 = (LPOLEVERB)lp32;
    vpstr = 0;
    sc = ConvertTaskString3216(pti, lpoleverb32->lpszVerbName, NULL, 0,
                               &vpstr);
    lpoleverb16 = FIXVDMPTR(vp16, OLEVERB);
    lpoleverb16->lpszVerbName = (LPOLESTR)vpstr;
    if (SUCCEEDED(sc))
    {
        lpoleverb16->lVerb        = lpoleverb32->lVerb;
        lpoleverb16->fuFlags      = lpoleverb32->fuFlags;
        lpoleverb16->grfAttribs   = lpoleverb32->grfAttribs;
    }
    RELVDMPTR(vp16);

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   Cleanup_OLEVERB_1632, public
//
//  Synopsis:   Cleans up the any OLEVERBs returned (either to 16-bit
//              or 32-bit)
//
//  Arguments:  [pti] - Thunking state information
//              [lp32] - Pointer to 32-bit returned structure
//              [lp16] - Pointer to 16-bit output structure
//
//  Returns:    nothing, should NEVER fail
//
//  History:    1-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------

void Cleanup_OLEVERB_1632( THUNKINFO *pti, LPVOID lp32, VPVOID vp16 )
{
    OLEVERB UNALIGNED *lpoleverb16;
    VPVOID vpstr;

    lpoleverb16 = FIXVDMPTR( vp16, OLEVERB );
    vpstr = (VPVOID)lpoleverb16->lpszVerbName;
    RELVDMPTR(vp16);

    if ( vpstr != 0 )
    {
        TaskFree16( vpstr );
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_Enum_OLEVERB_1632, public
//
//  Synopsis:   Thunks IEnumOLEVERB::Next parameters
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    1-Mar-94        BobDay  Created
//
//  Notes:      This thunk is 2nd part of a 2-byte thop.
//
//----------------------------------------------------------------------------

DWORD Thop_Enum_OLEVERB_1632(THUNKINFO *pti)
{
    return General_Enum_1632(pti,
                             sizeof(OLEVERB),
                             sizeof(OLEVERB),
                             Callback_OLEVERB_1632,
                             Cleanup_OLEVERB_1632 );
}

#define THOP_EFN(x)  Thop_Enum_ ## x ## _1632

DWORD (*CONST aThopEnumFunctions1632[])(THUNKINFO *) =
{
    THOP_EFN(STRING),               // STRING
    THOP_EFN(UNKNOWN),              // UNKNOWN
    THOP_EFN(STATSTG),              // STATSTG
    THOP_EFN(FORMATETC),            // FORMATETC
    THOP_EFN(STATDATA),             // STATDATA
    THOP_EFN(MONIKER),              // MONIKER
    THOP_EFN(OLEVERB),              // OLEVERB
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\olethk32\thopsapi.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	thopsapi.cxx
//
//  Notes:	This file is automatically generated
//		Do not modify by hand
//
//  History:	Fri May 27 10:39:02 1994	Generated
//
//----------------------------------------------------------------------------

THOP CONST thopsCoInitialize[] =
{
    THOP_IFACE | THOP_IN, THI_IMalloc, THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsCoUninitialize[] =
{
    THOP_END, THOP_ROUTINEINDEX, 6
};
THOP CONST thopsCoGetClassObject[] =
{
    THOP_COPY | THOP_IN, 16, THOP_CLSCONTEXT, THOP_NULL | THOP_IN, THOP_COPY | THOP_IN, 16, THOP_IFACEGEN | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 5
};
THOP CONST thopsCoRegisterClassObject[] =
{
    THOP_COPY | THOP_IN, 16, THOP_IFACE | THOP_IN, THI_IUnknown, THOP_CLSCONTEXT, THOP_COPY, 4, THOP_COPY | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 5
};
THOP CONST thopsCoRevokeClassObject[] =
{
    THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsCoMarshalInterface[] =
{
    THOP_IFACE | THOP_IN, THI_IStream, THOP_COPY | THOP_IN, 16, THOP_IFACEGEN | THOP_IN, 4, THOP_COPY, 4, THOP_NULL | THOP_IN, THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 7
};
THOP CONST thopsCoUnmarshalInterface[] =
{
    THOP_IFACE | THOP_IN, THI_IStream, THOP_COPY | THOP_IN, 16, THOP_IFACEGEN | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsCoReleaseMarshalData[] =
{
    THOP_IFACE | THOP_IN, THI_IStream, THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsCoDisconnectObject[] =
{
    THOP_IFACE | THOP_IN, THI_IUnknown, THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsCoLockObjectExternal[] =
{
    THOP_IFACE | THOP_IN, THI_IUnknown, THOP_SHORTLONG, THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsCoGetStandardMarshal[] =
{
    THOP_COPY | THOP_IN, 16, THOP_IFACE | THOP_IN, THI_IUnknown, THOP_COPY, 4, THOP_NULL | THOP_IN, THOP_COPY, 4, THOP_IFACE | THOP_OUT, THI_IMarshal, THOP_END, THOP_ROUTINEINDEX, 7
};
THOP CONST thopsCoIsHandlerConnected[] =
{
    THOP_RETURNTYPE, THOP_SHORTLONG, THOP_IFACE | THOP_IN, THI_IUnknown, THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsCoFreeAllLibraries[] =
{
    THOP_END, THOP_ROUTINEINDEX, 6
};
THOP CONST thopsCoFreeUnusedLibraries[] =
{
    THOP_END, THOP_ROUTINEINDEX, 6
};
THOP CONST thopsCoCreateInstance[] =
{
    THOP_COPY | THOP_IN, 16, THOP_UNKOUTER | THOP_IN, THI_IUnknown, THOP_CLSCONTEXT, THOP_COPY | THOP_IN, 16, THOP_IFACEGENOWNER | THOP_OUT, 4, 12, THOP_END, THOP_ROUTINEINDEX, 5
};
THOP CONST thopsCLSIDFromString[] =
{
    THOP_LPSTR | THOP_IN, THOP_COPY | THOP_OUT, 16, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsCoIsOle1Class[] =
{
    THOP_RETURNTYPE, THOP_SHORTLONG, THOP_COPY | THOP_IN, 16, THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsProgIDFromCLSID[] =
{
    THOP_COPY | THOP_IN, 16, THOP_LPLPSTR, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsCLSIDFromProgID[] =
{
    THOP_LPSTR | THOP_IN, THOP_COPY | THOP_OUT, 16, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsCoCreateGuid[] =
{
    THOP_COPY | THOP_OUT, 16, THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsCoFileTimeToDosDateTime[] =
{
    THOP_RETURNTYPE, THOP_SHORTLONG, THOP_COPY | THOP_IN, 8, THOP_WORDDWORD | THOP_OUT, THOP_WORDDWORD | THOP_OUT, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsCoDosDateTimeToFileTime[] =
{
    THOP_RETURNTYPE, THOP_SHORTLONG, THOP_WORDDWORD, THOP_WORDDWORD, THOP_COPY | THOP_OUT, 8, THOP_END, THOP_ROUTINEINDEX, 8
};
THOP CONST thopsCoFileTimeNow[] =
{
    THOP_COPY | THOP_OUT, 8, THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsCoRegisterMessageFilter[] =
{
    THOP_IFACE | THOP_IN, THI_IMessageFilter, THOP_IFACE | THOP_OUT, THI_IMessageFilter, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsCoGetTreatAsClass[] =
{
    THOP_COPY | THOP_IN, 16, THOP_COPY | THOP_OUT, 16, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsCoTreatAsClass[] =
{
    THOP_COPY | THOP_IN, 16, THOP_COPY | THOP_IN, 16, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsDllGetClassObject[] =
{
    THOP_COPY | THOP_IN, 16, THOP_COPY | THOP_IN, 16, THOP_IFACEGEN | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsStgCreateDocfile[] =
{
    THOP_LPSTR | THOP_IN, THOP_COPY, 4, THOP_COPY, 4, THOP_IFACE | THOP_OUT, THI_IStorage, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsStgCreateDocfileOnILockBytes[] =
{
    THOP_IFACE | THOP_IN, THI_ILockBytes, THOP_COPY, 4, THOP_COPY, 4, THOP_IFACE | THOP_OUT, THI_IStorage, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsStgOpenStorage[] =
{
    THOP_LPSTR | THOP_IN, THOP_IFACE | THOP_IN, THI_IStorage, THOP_COPY, 4, THOP_SNB, THOP_COPY, 4, THOP_IFACE | THOP_OUT, THI_IStorage, THOP_END, THOP_ROUTINEINDEX, 7
};
THOP CONST thopsStgOpenStorageOnILockBytes[] =
{
    THOP_IFACE | THOP_IN, THI_ILockBytes, THOP_IFACE | THOP_IN, THI_IStorage, THOP_COPY, 4, THOP_SNB, THOP_COPY, 4, THOP_IFACE | THOP_OUT, THI_IStorage, THOP_END, THOP_ROUTINEINDEX, 7
};
THOP CONST thopsStgIsStorageFile[] =
{
    THOP_LPSTR | THOP_IN, THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsStgIsStorageILockBytes[] =
{
    THOP_IFACE | THOP_IN, THI_ILockBytes, THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsStgSetTimes[] =
{
    THOP_LPSTR | THOP_IN, THOP_COPY | THOP_IN, 8, THOP_COPY | THOP_IN, 8, THOP_COPY | THOP_IN, 8, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsCreateDataAdviseHolder[] =
{
    THOP_IFACE | THOP_OUT, THI_IDataAdviseHolder, THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsCreateDataCache[] =
{
    THOP_UNKOUTER | THOP_IN, THI_IUnknown, THOP_COPY | THOP_IN, 16, THOP_COPY | THOP_IN, 16, THOP_IFACEGENOWNER | THOP_OUT, 4, 12, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsBindMoniker[] =
{
    THOP_IFACE | THOP_IN, THI_IMoniker, THOP_COPY, 4, THOP_COPY | THOP_IN, 16, THOP_IFACEGEN | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsMkParseDisplayName[] =
{
    THOP_IFACE | THOP_IN, THI_IBindCtx, THOP_LPSTR | THOP_IN, THOP_COPY | THOP_OUT, 4, THOP_IFACE | THOP_OUT, THI_IMoniker, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsMonikerRelativePathTo[] =
{
    THOP_IFACE | THOP_IN, THI_IMoniker, THOP_IFACE | THOP_IN, THI_IMoniker, THOP_IFACE | THOP_OUT, THI_IMoniker, THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsMonikerCommonPrefixWith[] =
{
    THOP_IFACE | THOP_IN, THI_IMoniker, THOP_IFACE | THOP_IN, THI_IMoniker, THOP_IFACE | THOP_OUT, THI_IMoniker, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsCreateBindCtx[] =
{
    THOP_COPY, 4, THOP_IFACE | THOP_OUT, THI_IBindCtx, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsCreateGenericComposite[] =
{
    THOP_IFACE | THOP_IN, THI_IMoniker, THOP_IFACE | THOP_IN, THI_IMoniker, THOP_IFACE | THOP_OUT, THI_IMoniker, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsGetClassFile[] =
{
    THOP_LPSTR | THOP_IN, THOP_COPY | THOP_OUT, 16, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsCreateFileMoniker[] =
{
    THOP_LPSTR | THOP_IN, THOP_IFACE | THOP_OUT, THI_IMoniker, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsCreateItemMoniker[] =
{
    THOP_LPSTR | THOP_IN, THOP_LPSTR | THOP_IN, THOP_IFACE | THOP_OUT, THI_IMoniker, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsCreateAntiMoniker[] =
{
    THOP_IFACE | THOP_OUT, THI_IMoniker, THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsCreatePointerMoniker[] =
{
    THOP_IFACE | THOP_IN, THI_IUnknown, THOP_IFACE | THOP_OUT, THI_IMoniker, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsGetRunningObjectTable[] =
{
    THOP_COPY, 4, THOP_IFACE | THOP_OUT, THI_IRunningObjectTable, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsReadClassStg[] =
{
    THOP_IFACE | THOP_IN, THI_IStorage, THOP_COPY | THOP_OUT, 16, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsWriteClassStg[] =
{
    THOP_IFACE | THOP_IN, THI_IStorage, THOP_COPY | THOP_IN, 16, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsReadClassStm[] =
{
    THOP_IFACE | THOP_IN, THI_IStream, THOP_COPY | THOP_OUT, 16, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsWriteClassStm[] =
{
    THOP_IFACE | THOP_IN, THI_IStream, THOP_COPY | THOP_IN, 16, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsWriteFmtUserTypeStg[] =
{
    THOP_IFACE | THOP_IN, THI_IStorage, THOP_WORDDWORD, THOP_LPSTR | THOP_IN, THOP_END, THOP_ROUTINEINDEX, 19
};
THOP CONST thopsReadFmtUserTypeStg[] =
{
    THOP_IFACE | THOP_IN, THI_IStorage, THOP_WORDDWORD | THOP_OUT, THOP_LPLPSTR, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsOleInitialize[] =
{
    THOP_IFACE | THOP_IN, THI_IMalloc, THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsOleUninitialize[] =
{
    THOP_END, THOP_ROUTINEINDEX, 6
};
THOP CONST thopsOleQueryLinkFromData[] =
{
    THOP_IFACE | THOP_IN, THI_IDataObject, THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsOleQueryCreateFromData[] =
{
    THOP_IFACE | THOP_IN, THI_IDataObject, THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsOleCreate[] =
{
    THOP_COPY | THOP_IN, 16, THOP_COPY | THOP_IN, 16, THOP_COPY, 4, THOP_FORMATETC | THOP_IN, THOP_IFACE | THOP_IN, THI_IOleClientSite, THOP_IFACE | THOP_IN, THI_IStorage, THOP_IFACEGEN | THOP_OUT, 20, THOP_END, THOP_ROUTINEINDEX, 4
};
THOP CONST thopsOleCreateFromData[] =
{
    THOP_IFACE | THOP_IN, THI_IDataObject, THOP_COPY | THOP_IN, 16, THOP_COPY, 4, THOP_FORMATETC | THOP_IN, THOP_IFACE | THOP_IN, THI_IOleClientSite, THOP_IFACE | THOP_IN, THI_IStorage, THOP_IFACEGEN | THOP_OUT, 20, THOP_END, THOP_ROUTINEINDEX, 4
};
THOP CONST thopsOleCreateLinkFromData[] =
{
    THOP_IFACE | THOP_IN, THI_IDataObject, THOP_COPY | THOP_IN, 16, THOP_COPY, 4, THOP_FORMATETC | THOP_IN, THOP_IFACE | THOP_IN, THI_IOleClientSite, THOP_IFACE | THOP_IN, THI_IStorage, THOP_IFACEGEN | THOP_OUT, 20, THOP_END, THOP_ROUTINEINDEX, 4
};
THOP CONST thopsOleCreateStaticFromData[] =
{
    THOP_IFACE | THOP_IN, THI_IDataObject, THOP_COPY | THOP_IN, 16, THOP_COPY, 4, THOP_FORMATETC | THOP_IN, THOP_IFACE | THOP_IN, THI_IOleClientSite, THOP_IFACE | THOP_IN, THI_IStorage, THOP_IFACEGEN | THOP_OUT, 20, THOP_END, THOP_ROUTINEINDEX, 4
};
THOP CONST thopsOleCreateLink[] =
{
    THOP_IFACE | THOP_IN, THI_IMoniker, THOP_COPY | THOP_IN, 16, THOP_COPY, 4, THOP_FORMATETC | THOP_IN, THOP_IFACE | THOP_IN, THI_IOleClientSite, THOP_IFACE | THOP_IN, THI_IStorage, THOP_IFACEGEN | THOP_OUT, 20, THOP_END, THOP_ROUTINEINDEX, 4
};
THOP CONST thopsOleCreateLinkToFile[] =
{
    THOP_LPSTR | THOP_IN, THOP_COPY | THOP_IN, 16, THOP_COPY, 4, THOP_FORMATETC | THOP_IN, THOP_IFACE | THOP_IN, THI_IOleClientSite, THOP_IFACE | THOP_IN, THI_IStorage, THOP_IFACEGEN | THOP_OUT, 20, THOP_END, THOP_ROUTINEINDEX, 4
};
THOP CONST thopsOleCreateFromFile[] =
{
    THOP_COPY | THOP_IN, 16, THOP_LPSTR | THOP_IN, THOP_COPY | THOP_IN, 16, THOP_COPY, 4, THOP_FORMATETC | THOP_IN, THOP_IFACE | THOP_IN, THI_IOleClientSite, THOP_IFACE | THOP_IN, THI_IStorage, THOP_IFACEGEN | THOP_OUT, 20, THOP_END,
    THOP_ROUTINEINDEX, 20
};
THOP CONST thopsOleLoad[] =
{
    THOP_IFACE | THOP_IN, THI_IStorage, THOP_COPY | THOP_IN, 16, THOP_IFACE | THOP_IN, THI_IOleClientSite, THOP_IFACEGEN | THOP_OUT, 8, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsOleSave[] =
{
    THOP_IFACE | THOP_IN, THI_IPersistStorage, THOP_IFACE | THOP_IN, THI_IStorage, THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsOleLoadFromStream[] =
{
    THOP_IFACE | THOP_IN, THI_IStream, THOP_COPY | THOP_IN, 16, THOP_IFACEGEN | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsOleSaveToStream[] =
{
    THOP_IFACE | THOP_IN, THI_IPersistStream, THOP_IFACE | THOP_IN, THI_IStream, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsOleSetContainedObject[] =
{
    THOP_IFACE | THOP_IN, THI_IUnknown, THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsOleNoteObjectVisible[] =
{
    THOP_IFACE | THOP_IN, THI_IUnknown, THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsRegisterDragDrop[] =
{
    THOP_HUSER, THOP_IFACE | THOP_IN, THI_IDropTarget, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsRevokeDragDrop[] =
{
    THOP_HUSER, THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsDoDragDrop[] =
{
    THOP_IFACE | THOP_IN, THI_IDataObject, THOP_IFACE | THOP_IN, THI_IDropSource, THOP_COPY, 4, THOP_COPY | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsOleSetClipboard[] =
{
    THOP_IFACE | THOP_IN, THI_IDataObject, THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsOleGetClipboard[] =
{
    THOP_IFACE | THOP_OUT, THI_IDataObject, THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsOleFlushClipboard[] =
{
    THOP_END, THOP_ROUTINEINDEX, 6
};
THOP CONST thopsOleIsCurrentClipboard[] =
{
    THOP_IFACE | THOP_IN, THI_IDataObject, THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsOleCreateMenuDescriptor[] =
{
    THOP_RETURNTYPE, THOP_ALIAS32, ALIAS_CREATE, THOP_HUSER, THOP_COPY | THOP_IN, 24, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsOleSetMenuDescriptor[] =
{
    THOP_ALIAS32, ALIAS_RESOLVE, THOP_HUSER, THOP_HUSER, THOP_IFACE | THOP_IN, THI_IOleInPlaceFrame, THOP_IFACE | THOP_IN, THI_IOleInPlaceActiveObject, THOP_END, THOP_ROUTINEINDEX, 5
};
THOP CONST thopsOleDestroyMenuDescriptor[] =
{
    THOP_ALIAS32, ALIAS_REMOVE, THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsOleDraw[] =
{
    THOP_IFACE | THOP_IN, THI_IUnknown, THOP_COPY, 4, THOP_HGDI, THOP_RECT | THOP_IN, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsOleRun[] =
{
    THOP_IFACE | THOP_IN, THI_IUnknown, THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsOleIsRunning[] =
{
    THOP_RETURNTYPE, THOP_SHORTLONG, THOP_IFACE | THOP_IN, THI_IOleObject, THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsOleLockRunning[] =
{
    THOP_IFACE | THOP_IN, THI_IUnknown, THOP_SHORTLONG, THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsCreateOleAdviseHolder[] =
{
    THOP_IFACE | THOP_OUT, THI_IOleAdviseHolder, THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsOleCreateDefaultHandler[] =
{
    THOP_COPY | THOP_IN, 16, THOP_UNKOUTER | THOP_IN, THI_IUnknown, THOP_COPY | THOP_IN, 16, THOP_IFACEGENOWNER | THOP_OUT, 4, 8, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsOleCreateEmbeddingHelper[] =
{
    THOP_COPY | THOP_IN, 16, THOP_UNKOUTER | THOP_IN, THI_IUnknown, THOP_COPY, 4, THOP_IFACE | THOP_IN, THI_IClassFactory, THOP_COPY | THOP_IN, 16, THOP_IFACEGENOWNER | THOP_OUT, 4, 16, THOP_END, THOP_ROUTINEINDEX, 7
};
THOP CONST thopsOleRegGetUserType[] =
{
    THOP_COPY | THOP_IN, 16, THOP_COPY, 4, THOP_LPLPSTR, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsOleRegGetMiscStatus[] =
{
    THOP_COPY | THOP_IN, 16, THOP_COPY, 4, THOP_COPY | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsOleRegEnumFormatEtc[] =
{
    THOP_COPY | THOP_IN, 16, THOP_COPY, 4, THOP_IFACE | THOP_OUT, THI_IEnumFORMATETC, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsOleRegEnumVerbs[] =
{
    THOP_COPY | THOP_IN, 16, THOP_IFACE | THOP_OUT, THI_IEnumOLEVERB, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsOleConvertIStorageToOLESTREAM[] =
{
    THOP_IFACE | THOP_IN, THI_IStorage, THOP_OLESTREAM | THOP_INOUT, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsOleConvertOLESTREAMToIStorage[] =
{
    THOP_OLESTREAM | THOP_INOUT, THOP_IFACE | THOP_IN, THI_IStorage, THOP_DVTARGETDEVICE | THOP_IN, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsOleConvertIStorageToOLESTREAMEx[] =
{
    THOP_IFACE | THOP_IN, THI_IStorage, THOP_WORDDWORD, THOP_COPY, 4, THOP_COPY, 4, THOP_COPY, 4, THOP_STGMEDIUM | THOP_IN, 0, 0, THOP_OLESTREAM | THOP_INOUT, THOP_END, THOP_ROUTINEINDEX, 21
};
THOP CONST thopsOleConvertOLESTREAMToIStorageEx[] =
{
    THOP_OLESTREAM | THOP_INOUT, THOP_IFACE | THOP_IN, THI_IStorage, THOP_WORDDWORD | THOP_OUT, THOP_COPY | THOP_OUT, 4, THOP_COPY | THOP_OUT, 4, THOP_COPY | THOP_OUT, 4, THOP_STGMEDIUM | THOP_IN, 0, 0, THOP_END, THOP_ROUTINEINDEX, 4
};
THOP CONST thopsOleDoAutoConvert[] =
{
    THOP_IFACE | THOP_IN, THI_IStorage, THOP_COPY | THOP_OUT, 16, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsOleGetAutoConvert[] =
{
    THOP_COPY | THOP_IN, 16, THOP_COPY | THOP_OUT, 16, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsOleSetAutoConvert[] =
{
    THOP_COPY | THOP_IN, 16, THOP_COPY | THOP_IN, 16, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsGetConvertStg[] =
{
    THOP_IFACE | THOP_IN, THI_IStorage, THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsSetConvertStg[] =
{
    THOP_IFACE | THOP_IN, THI_IStorage, THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsReadOleStg[] =
{
    THOP_IFACE | THOP_IN, THI_IStorage, THOP_COPY | THOP_OUT, 4, THOP_COPY | THOP_OUT, 4, THOP_COPY | THOP_OUT, 4, THOP_IFACE | THOP_OUT, THI_IMoniker, THOP_IFACE | THOP_OUT, THI_IStream, THOP_END, THOP_ROUTINEINDEX, 7
};
THOP CONST thopsWriteOleStg[] =
{
    THOP_IFACE | THOP_IN, THI_IStorage, THOP_IFACE | THOP_IN, THI_IOleObject, THOP_COPY, 4, THOP_IFACE | THOP_OUT, THI_IStream, THOP_END, THOP_ROUTINEINDEX, 2
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\olethk32\thop32.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       thop32.cxx
//
//  Contents:   Thop implementations for 32->16
//
//  History:    22-Feb-94       DrewB   Created
//
//----------------------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

#include <ole2.h>
#include <string.h>
#include <valid.h>
#include "olethk32.hxx"
#include "struct16.hxx"

//+---------------------------------------------------------------------------
//
//  Function:   EXECUTE_THOP3216, public
//
//  Synopsis:   Debugging version of thop dispatch routine
//
//  Arguments:  [pti] - Thunking info
//
//  Returns:    Appropriate status
//
//  History:    24-Feb-94       DrewB   Created
//
//----------------------------------------------------------------------------

#if DBG == 1
DWORD EXECUTE_THOP3216(THUNKINFO *pti)
{
    thkDebugOut((DEB_THOPS, "%sIn ExThop3216: %s (0x%02X), s16 %p, s32 %p\n",
                 NestingLevelString(), 
                 ThopName(*pti->pThop), *pti->pThop, pti->s16.pbCurrent,
                 pti->s32.pbCurrent));
    DebugIncrementNestingLevel();
    
    // Local variable
    DWORD dwRet;

    // Sanity check
    thkAssert((*pti->pThop & THOP_OPMASK) < THOP_LASTOP);
    dwRet = (*aThopFunctions3216[*((pti)->pThop) & THOP_OPMASK])(pti);

    DebugDecrementNestingLevel();
    thkDebugOut((DEB_THOPS, "%sOut ExThop3216\n", NestingLevelString()));
    return(dwRet);
}
#endif

#if DBG == 1
DWORD EXECUTE_ENUMTHOP3216(THUNKINFO *pti)
{
    thkDebugOut((DEB_THOPS, "%sIn ExEnumThop3216: %s (0x%02X), s16 %p, s32 %p\n",
                 NestingLevelString(), 
                 EnumThopName(*pti->pThop), *pti->pThop, pti->s16.pbCurrent,
                 pti->s32.pbCurrent));
    DebugIncrementNestingLevel();

    // Local variable
    DWORD dwRet;
    dwRet = (*aThopEnumFunctions3216[*(pti)->pThop])(pti);

    DebugDecrementNestingLevel();
    thkDebugOut((DEB_THOPS, "%sOut ExEnumThop3216\n", NestingLevelString()));
    return(dwRet);
}
#endif

//+---------------------------------------------------------------------------
//
//  Function:   FixedThopHandler, public
//
//  Synopsis:   Generic function which handles the high-level details
//              of thop execution for thops that operate on known-size
//              data
//
//  Arguments:  [pti] - Thunking state information
//              [thop] - Thop being executed
//              [cb16] - 16-bit size
//              [pfn1632] - 16->32 conversion routine
//              [cb32] - 32-bit size
//              [pfn3216] - 32->16 conversion routine
//
//  Returns:    Appropriate status code
//
//  History:    05-Apr-94       DrewB   Created
//
//  Notes:      Automatically increments pThop
//
//----------------------------------------------------------------------------

DWORD FixedThopHandler3216(THUNKINFO *pti,
                           THOP thop,
                           UINT cb16,
                           FIXEDHANDLERROUTINE pfn1632,
                           UINT cb32,
                           FIXEDHANDLERROUTINE pfn3216)
{
    DWORD   dwResult;
    VPVOID  vp16;
    BYTE    *pb16;
    BYTE    *pb32;

    if ((thop & (THOP_IN | THOP_OUT)) != 0)
    {
        vp16 = 0;

        GET_STACK32(pti, pb32, BYTE *);
        if ( pb32 != 0 )
        {
            if ((thop & THOP_IN) != 0)
            {
                if (IsBadReadPtr(pb32, cb32))
                {
                    return (DWORD)E_INVALIDARG;
                }
            }
            if ((thop & THOP_OUT) != 0)
            {
                if (IsBadWritePtr(pb32, cb32))
                {
                    return (DWORD)E_INVALIDARG;
                }
            }

            vp16 = STACKALLOC16(cb16);
            if (vp16 == 0)
            {
                return (DWORD)E_OUTOFMEMORY;
            }
            else if ((thop & THOP_IN) != 0)
            {
                pb16 = (BYTE *)WOWFIXVDMPTR(vp16, cb16);
                (pfn3216)(pb32, pb16, cb32, cb16);
                WOWRELVDMPTR(vp16);
            }
        }

        TO_STACK16(pti, vp16, VPVOID);

        pti->pThop++;
        dwResult = EXECUTE_THOP3216(pti);

        if ((thop & THOP_OUT) != 0 && pb32 != NULL)
        {
            if (SUCCEEDED(dwResult))
            {
                pb16 = (BYTE *)WOWFIXVDMPTR(vp16, cb16);
                (pfn1632)(pb16, pb32, cb16, cb32);
                WOWRELVDMPTR(vp16);
            }
            else if ((thop & THOP_IN) == 0)
            {
                // Zero out-only parameters on failure
                memset(pb32, 0, cb32);
            }
        }

        if (vp16 != 0)
        {
            STACKFREE16(vp16, cb16);
        }
    }
    else
    {
        (pfn3216)(PTR_STACK32(&pti->s32), PTR_STACK16(&pti->s16, cb16),
                  cb32, cb16);

        SKIP_STACK16(&pti->s16, cb16);
        SKIP_STACK32(&pti->s32, cb32);

        pti->pThop++;
        dwResult = EXECUTE_THOP3216(pti);
    }

    return dwResult;
}

//-----------------------------------------------------------------------------
//
// Handler-based thunks
//
// These thunks use the fixed-size generic thop handler to do their work
//
//-----------------------------------------------------------------------------

// Handle straight copy
DWORD Thop_Copy_3216(THUNKINFO *pti)
{
    THOP thopSize;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_COPY);

    thopSize = *++pti->pThop;
    return FixedThopHandler3216(pti,
                                *(pti->pThop-1),
                                thopSize, FhCopyMemory,
                                thopSize, FhCopyMemory);
}

DWORD Thop_ShortToLong_3216(THUNKINFO *pti)
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_SHORTLONG);

    return FixedThopHandler3216(pti,
                                *pti->pThop,
                                sizeof(SHORT), FhShortToLong,
                                sizeof(LONG), FhLongToShort);
}

DWORD Thop_WordToDword_3216(THUNKINFO *pti)
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_WORDDWORD);

    return FixedThopHandler3216(pti,
                                *pti->pThop,
                                sizeof(WORD), FhWordToDword,
                                sizeof(DWORD), FhDwordToWord);
}

DWORD Thop_GdiHandle_3216(THUNKINFO *pti)
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_HGDI);

    return FixedThopHandler3216(pti,
                                *pti->pThop,
                                sizeof(HAND16), FhGdiHandle1632,
                                sizeof(HANDLE), FhGdiHandle3216);
}

DWORD Thop_UserHandle_3216(THUNKINFO *pti)
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_HUSER);

    return FixedThopHandler3216(pti,
                                *pti->pThop,
                                sizeof(HAND16), FhUserHandle1632,
                                sizeof(HANDLE), FhUserHandle3216);
}

DWORD Thop_HACCEL_3216(THUNKINFO *pti)
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_HACCEL);

    return FixedThopHandler3216(pti,
                                *pti->pThop,
                                sizeof(HAND16), FhHaccel1632,
                                sizeof(HANDLE), FhHaccel3216);
}

DWORD Thop_HTASK_3216(THUNKINFO *pti)
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_HTASK);

    return FixedThopHandler3216(pti,
                                *pti->pThop,
                                sizeof(HAND16), FhHtask1632,
                                sizeof(HANDLE), FhHtask3216);
}

DWORD Thop_HRESULT_3216( THUNKINFO *pti )
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_HRESULT);

    return FixedThopHandler3216(pti,
                                *pti->pThop,
                                sizeof(HRESULT), FhHresult1632,
                                sizeof(HRESULT), FhHresult3216);
}

DWORD Thop_NULL_3216(THUNKINFO *pti)
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_NULL);

    return FixedThopHandler3216(pti,
                                *pti->pThop,
                                sizeof(void *), FhNull,
                                sizeof(void *), FhNull);
}

DWORD Thop_RECT_3216( THUNKINFO *pti )
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_RECT);

    return FixedThopHandler3216(pti,
                                *pti->pThop,
                                sizeof(RECT16), FhRect1632,
                                sizeof(RECT), FhRect3216);
}

DWORD Thop_BINDOPTS_3216( THUNKINFO *pti )
{
    LPBIND_OPTS pbo;
    UINT cb;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_BINDOPTS);

    PEEK_STACK32(pti, pbo, LPBIND_OPTS);
    if (!IsBadReadPtr(pbo, sizeof(LPBIND_OPTS)))
    {
        cb = pbo->cbStruct;
    }
    else
    {
        return (DWORD)E_INVALIDARG;
    }

    return FixedThopHandler3216(pti,
                                *pti->pThop,
                                cb, FhCopyMemory,
                                cb, FhCopyMemory);
}

DWORD Thop_SIZE_3216( THUNKINFO *pti )
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_SIZE);

    return FixedThopHandler3216(pti,
                                *pti->pThop,
                                sizeof(SIZE16), FhSize1632,
                                sizeof(SIZE), FhSize3216);
}

DWORD Thop_MSG_3216( THUNKINFO *pti )
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_MSG);

    return FixedThopHandler3216(pti,
                                *pti->pThop,
                                sizeof(MSG16), FhMsg1632,
                                sizeof(MSG), FhMsg3216);
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_ERROR_3216, public
//
//  Synopsis:   Any Thop type which should just fail with an error
//              should go be directed here.
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    23-Feb-94       BobDay  Created
//
//----------------------------------------------------------------------------
DWORD Thop_ERROR_3216 ( THUNKINFO *pti )
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_ERROR);

    thkAssert( FALSE && "Hey we hit an ERROR Thop in 32->16" );

    return (DWORD)E_UNEXPECTED;
}

//+---------------------------------------------------------------------------
//
//  Function:   ThunkInString3216, public
//
//  Synopsis:   Converts an in param string or filename
//
//  Arguments:  [pti] - Thunk state information
//              [fFile] - Filename or plain string
//              [cchMax] - Maximum length allowed or zero
//
//  Returns:    Appropriate status code
//
//  History:    24-Aug-94       DrewB   Created
//
//----------------------------------------------------------------------------

DWORD ThunkInString3216(THUNKINFO *pti,
                        BOOL fFile,
                        UINT cchMax)
{
    DWORD       dwResult;
    LPOLESTR    lpstr32;
    VPSTR       vpstr16;
    UINT        uiSize;
    LPOLESTR    lpstrConv;
    LPOLESTR    lpstrShort;

    dwResult = (DWORD)S_OK;

    lpstrShort = NULL;

    GET_STACK32(pti, lpstr32, LPOLESTR);
    lpstrConv = lpstr32;

    vpstr16 = 0;
    if (lpstr32 != NULL)
    {
        if (IsBadStringPtrW(lpstr32, CCHMAXSTRING))
        {
            return (DWORD)E_INVALIDARG;
        }

        if (fFile)
        {
            DWORD cchNeeded, cchShort;

            // Special case zero-length paths since the length returns from
            // GetShortPathName become ambiguous when zero characters are
            // processed
            cchNeeded = lstrlenW(lpstr32);
            if (cchNeeded > 0)
            {
                cchNeeded = GetShortPathName(lpstr32, NULL, 0);
            }

            // If we can't convert, simply pass through the name we're given
            if (cchNeeded > 0)
            {
                lpstrShort = (LPOLESTR)CoTaskMemAlloc(cchNeeded*sizeof(WCHAR));
                if (lpstrShort == NULL)
                {
                    return (DWORD)E_OUTOFMEMORY;
                }

                cchShort = GetShortPathName(lpstr32, lpstrShort,
                                            cchNeeded);
                if (cchShort == 0 || cchShort > cchNeeded)
                {
                    dwResult = (DWORD)E_UNEXPECTED;
                }
                else
                {
                    lpstrConv = lpstrShort;
                }
            }
        }

        if (SUCCEEDED(dwResult))
        {
            uiSize = lstrlenW( lpstrConv ) + 1;

            vpstr16 = STACKALLOC16(uiSize*2);
            if (vpstr16 == 0)
            {
                dwResult = (DWORD)E_OUTOFMEMORY;
            }
            else
            {
                char *psz;

                dwResult = Convert_LPOLESTR_to_VPSTR(lpstrConv, vpstr16,
                                                     uiSize, uiSize*2);

                // If a maximum length was given, truncate the converted
                // string if necessary
                if (SUCCEEDED(dwResult) && cchMax > 0 && cchMax < uiSize)
                {
                    psz = (char *)WOWFIXVDMPTR(vpstr16, 0);
                    psz[cchMax] = 0;
                    WOWRELVDMPTR(vpstr16);
                }
            }
        }
    }

    if (SUCCEEDED(dwResult))
    {
#if DBG == 1
        thkDebugOut((DEB_ARGS, "%sIn3216  LPSTR %p -> %p '%s'\n",
                     NestingLevelString(), lpstr32, vpstr16,
                     vpstr16 != 0 ? WOWFIXVDMPTR(vpstr16, 0) : "<null>"));
        if (vpstr16 != 0)
        {
            WOWRELVDMPTR(vpstr16);
        }
#endif

        TO_STACK16(pti, vpstr16, VPSTR);

        pti->pThop++;
        dwResult = EXECUTE_THOP3216(pti);
    }

    if (vpstr16 != 0)
    {
        STACKFREE16(vpstr16, uiSize*2);
    }

    if (lpstrShort != NULL)
    {
        CoTaskMemFree(lpstrShort);
    }

    return( dwResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_LPSTR_3216, public
//
//  Synopsis:   Converts 32-bit LPOLESTR to 16-bit LPSTR pointer
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    23-Feb-94       BobDay  Created
//
//----------------------------------------------------------------------------

DWORD Thop_LPSTR_3216( THUNKINFO *pti )
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_LPSTR);
    //
    // We have only input LPSTRs
    //
    thkAssert( (*pti->pThop & THOP_IOMASK) == THOP_IN &&
               "LPSTR must be input only!" );

    return ThunkInString3216(pti, FALSE, 0);
}

//+---------------------------------------------------------------------------
//
//  Function:   ConvertTaskString1632, public
//
//  Synopsis:   Converts a task-memory string
//
//  Arguments:  [pti] - Thunk info
//              [vpstr16] - String
//              [posPreAlloc] - Preallocated string or NULL
//              [cchPreAlloc] - Preallocated size or zero
//              [ppos32] - String
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pti]
//              [ppos32]
//
//  History:    14-May-94       DrewB   Created
//
//  Notes:      Frees preallocation if successful and:
//                  Name is too large or
//                  Name is NULL
//
//              Always frees source string if non-zero
//
//----------------------------------------------------------------------------

SCODE ConvertTaskString1632(THUNKINFO *pti,
                            VPSTR vpstr16,
                            LPOLESTR posPreAlloc,
                            UINT cchPreAlloc,
                            LPOLESTR *ppos32)
{
    LPOLESTR pos32;

    if (vpstr16 == 0)
    {
        pos32 = NULL;
    }
    else
    {
        pos32 = Convert_VPSTR_to_LPOLESTR(pti, vpstr16, posPreAlloc,
                                          cchPreAlloc);

        TaskFree16(vpstr16);

        if (pos32 == NULL)
        {
            return pti->scResult;
        }
    }

    // If there was a preallocated string we didn't use,
    // free it
    if (posPreAlloc != NULL && posPreAlloc != pos32)
    {
        TaskFree32(posPreAlloc);
    }

    *ppos32 = pos32;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   ThunkOutString3216, public
//
//  Synopsis:   Converts an out param string
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    24-Aug-94       DrewB   Created
//
//----------------------------------------------------------------------------

DWORD ThunkOutString3216(THUNKINFO *pti)
{
    DWORD           dwResult;
    LPOLESTR        *lplpstr32;
    VPVOID          vpvpstr16;
    VPSTR UNALIGNED *lpvpstr16;
    LPOLESTR        lpstr32;

    GET_STACK32(pti, lplpstr32, LPOLESTR FAR *);

    if ( lplpstr32 == NULL )
    {
        vpvpstr16 = 0;
    }
    else
    {
        if (IsBadWritePtr(lplpstr32, sizeof(LPOLESTR)))
        {
            return (DWORD)E_INVALIDARG;
        }

        vpvpstr16 = STACKALLOC16(sizeof(VPSTR));
        if (vpvpstr16 == 0)
        {
            return (DWORD)E_OUTOFMEMORY;
        }

        lpvpstr16 = FIXVDMPTR(vpvpstr16, VPSTR);
        *lpvpstr16 = 0;
        RELVDMPTR(vpvpstr16);

        lpstr32 = (LPOLESTR)TaskMalloc32(CBSTRINGPREALLOC);
        if (lpstr32 == NULL)
        {
            STACKFREE16(vpvpstr16, sizeof(VPSTR));
            return (DWORD)E_OUTOFMEMORY;
        }
    }

    TO_STACK16(pti, vpvpstr16, VPVOID);

    pti->pThop++;
    dwResult = EXECUTE_THOP3216(pti);

    if (lplpstr32 != NULL)
    {
        if (SUCCEEDED(dwResult))
        {
            lpvpstr16 = FIXVDMPTR(vpvpstr16, VPSTR);
            if (lpvpstr16 == NULL)
            {
                dwResult = (DWORD)E_INVALIDARG;
            }
            else
            {
                SCODE sc;

                sc = ConvertTaskString1632(pti, *lpvpstr16, lpstr32,
                                           CWCSTRINGPREALLOC, &lpstr32);
                if (FAILED(sc))
                {
                    dwResult = sc;
                }

                RELVDMPTR(vpvpstr16);
            }
        }

        if (FAILED(dwResult))
        {
            TaskFree32(lpstr32);

            *lplpstr32 = NULL;
        }
        else
        {
            *lplpstr32 = lpstr32;
        }

        thkDebugOut((DEB_ARGS, "Out3216 LPLPSTR: %p -> %p, '%ws'\n",
                     *lpvpstr16, lpstr32, lpstr32));
    }
    else
    {
        thkDebugOut((DEB_ARGS, "Out3216 LPLPSTR NULL\n"));
    }

    if (vpvpstr16 != 0)
    {
        STACKFREE16(vpvpstr16, sizeof(VPSTR));
    }

    return( dwResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_LPLPSTR_3216, public
//
//  Synopsis:   Converts 16-bit LPSTR to 32-bit LPSTR pointer
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    26-Feb-94       BobDay  Created
//
//----------------------------------------------------------------------------
DWORD Thop_LPLPSTR_3216( THUNKINFO *pti )
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_LPLPSTR);
    //
    // We don't have anything but unmodified LPLPSTRs
    //
    thkAssert( (*pti->pThop & THOP_IOMASK) == 0 &&
               "LPLPSTR must be unmodified only!" );

    return ThunkOutString3216(pti);
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_BUFFER_3216, public
//
//  Synopsis:   Converts 32-bit block of memory to 16-bit block of memory
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    25-Feb-94       BobDay  Created
//
//  Notes:      WARNING! WARNING! WARNING! For an out parameter this expects
//              three parameters on the stack in the following format and order:
//                  VOID *  pointer to buffer
//                  DWORD   count of bytes in buffer
//                  DWORD * count of bytes returned in the buffer
//
//----------------------------------------------------------------------------

#define WATCH_VALUE 0xfef1f0

DWORD Thop_BUFFER_3216( THUNKINFO *pti )
{
    DWORD       dwResult;
    BOOL        fThopInput;
    BOOL        fThopOutput;
    LPVOID      lp32;
    VPVOID      vp16;
    LPVOID      lp16;
    DWORD       dwCount;
    VPVOID      vp16CountOut;
    LPVOID      pvCountOut32;
    DWORD *     pdwCountOut32;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_BUFFER);

    fThopInput  = IS_THOP_IN(pti);
    fThopOutput = IS_THOP_OUT(pti);

    //
    // Buffers can only be in or out
    //
    thkAssert( (fThopInput || fThopOutput) &&
               (fThopInput != fThopOutput) &&
               "BUFFER must be in or out only!" );

    GET_STACK32(pti, lp32, LPVOID);
    GET_STACK32(pti, dwCount, DWORD);

    if (fThopOutput)
    {
        GET_STACK32(pti, pvCountOut32, LPVOID);
        pdwCountOut32 = (DWORD *) pvCountOut32;
    }

    if ( lp32 == NULL )
    {
        vp16 = 0;
    }
    else if (dwCount == 0)
    {
        // If the count is zero then we can pass any valid 16-bit
        // pointer

#if DBG == 1
        // In debug, make sure that no data is written back to the
        // memory we pass on
        vp16 = STACKALLOC16(sizeof(DWORD));

        if ( vp16 == 0 )
        {
            return (DWORD)E_OUTOFMEMORY;
        }

        *FIXVDMPTR(vp16, DWORD) = WATCH_VALUE;
        RELVDMPTR(vp16);
#else
        vp16 = gdata16Data.atfnProxy1632Vtbl;
#endif
    }
    else
    {
        if ((fThopInput && IsBadReadPtr(lp32, dwCount)) ||
            (fThopOutput && IsBadWritePtr(lp32, dwCount)))
        {
            return (DWORD)E_INVALIDARG;
        }

        vp16 = (VPVOID)WgtAllocLock( GMEM_MOVEABLE, dwCount, NULL );
        if ( vp16 == 0 )
        {
            return (DWORD)E_OUTOFMEMORY;
        }

        if ( fThopInput )
        {
            lp16 = (LPVOID)WOWFIXVDMPTR(vp16, dwCount);
            memcpy( lp16, lp32, dwCount );
            WOWRELVDMPTR(vp16);
        }
    }

    if (fThopOutput)
    {
        // We always allocate storage so we can guarantee that we
        // only copy the correct number of bytes.
        vp16CountOut = STACKALLOC16(sizeof(DWORD));

        if (vp16CountOut == 0)
        {
            return (DWORD) E_OUTOFMEMORY;
        }
    }

    thkDebugOut((DEB_ARGS, "3216    BUFFER: %p -> %p, %u\n",
                 lp32, vp16, dwCount));

    TO_STACK16(pti, vp16, VPVOID );
    TO_STACK16(pti, dwCount, DWORD );

    if (fThopOutput)
    {
        TO_STACK16(pti, vp16CountOut, VPVOID );
    }

    pti->pThop++;
    dwResult = EXECUTE_THOP3216(pti);

    if ( SUCCEEDED(dwResult) && fThopOutput )
    {
        // Count of bytes to copy into the output buffer
        DWORD dwCountOut;

        // Get the output data count
        DWORD UNALIGNED *pdw16 = (DWORD UNALIGNED *)
            WOWFIXVDMPTR(vp16CountOut, sizeof(DWORD));

        // Save count to return to 32 bit caller.
        dwCountOut = *pdw16;
        if (pdwCountOut32)
        {
            // Note: this parameter can be a NULL pointer
            *pdwCountOut32 = dwCountOut;
        }

        WOWRELVDMPTR(vp16CountOut);

        // Copy data into output buffer if necessary.
        if (dwCountOut > 0)
        {
            lp16 = (LPVOID) WOWFIXVDMPTR( vp16, dwCountOut );
            memcpy( lp32, lp16, dwCountOut );
            WOWRELVDMPTR(vp16);
        }
    }

#if DBG == 1
    if (vp16 != 0 && dwCount == 0)
    {
        thkAssert(*FIXVDMPTR(vp16, DWORD) == WATCH_VALUE &&
                  (RELVDMPTR(vp16), TRUE));
        STACKFREE16(vp16, sizeof(DWORD));
    }
#endif

    //
    // Now free the buffers
    //
    if ( vp16 != 0 && dwCount > 0 )
    {
        WgtUnlockFree( vp16 );
    }

    if (fThopOutput && (vp16CountOut != 0))
    {
        STACKFREE16(vp16CountOut, sizeof(DWORD));
    }

    return( dwResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_SNB_3216, public
//
//  Synopsis:   Converts 32-bit SNB to 16-bit SNB pointer
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    23-Feb-94       BobDay  Created
//
//----------------------------------------------------------------------------
DWORD Thop_SNB_3216( THUNKINFO *pti )
{
    DWORD           dwResult;
    BOOL            fThopInput;
    BOOL            fThopOutput;

    SNB             snbSrc32;             // Ptr to 32 bit Source SNB.
    LPOLESTR FAR    *lplpsTabSrc32;       // Ptr into 32 bit Source ptr table.
    LPOLESTR        lpstr32;              // Ptr into a Source Unicode data block.

    VPVOID          snbDest16s;           // Seg:Ptr to 16 bit Destination SNB.
    VPSTR UNALIGNED FAR *lpvpsTabDest16f; // Flat Ptr into 16 bit Dest ptr table.
    char UNALIGNED  *lpstrDest16f;        // Flat Ptr into 16 bit Dest data block.
    VPVOID          lpstrDest16s;         // Seg:Ptr  into 16 bit Dest data block.

    UINT            cPointers;      // Count of number of string pointers.
    UINT            cbStrings;      // Count of number of bytes in data table.
    UINT            cLength;
    UINT            cChars;
    UINT            cbAlloc;
    UINT            i;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_SNB);

    fThopInput  = IS_THOP_IN(pti);
    fThopOutput = IS_THOP_OUT(pti);

    //
    // We don't have anything but unmodified SNBs
    //
    thkAssert( !fThopInput && !fThopOutput && "SNB must be unmodified only!" );

    GET_STACK32(pti, snbSrc32, LPOLESTR FAR *);

    if ( snbSrc32 == NULL )
    {
        snbDest16s = 0;
    }
    else
    {
        //
        // Count the strings in the 32-bit snb
        //
        lplpsTabSrc32 = snbSrc32;

        cPointers = 0;
        cbStrings = 0;
        do
        {
            cPointers++;
            if (IsBadReadPtr(lplpsTabSrc32, sizeof(LPOLESTR)))
            {
                return (DWORD)E_INVALIDARG;
            }

            lpstr32 = *lplpsTabSrc32++;

            if ( lpstr32 == NULL )
            {
                break;
            }

            if (IsBadStringPtrW(lpstr32, CCHMAXSTRING))
            {
                return (DWORD)E_INVALIDARG;
            }

            cbStrings += lstrlenW(lpstr32)+1;
        }
        while ( TRUE );

        //
        // Allocate a table for the 16-bit snb
        //   cPointers is a count of pointers plus the NULL pointer at the end.
        //
        cbAlloc = cPointers*sizeof(VPSTR)+cbStrings;
        snbDest16s = (VPVOID)STACKALLOC16(cbAlloc);
        if (snbDest16s == 0)
        {
            return (DWORD)E_OUTOFMEMORY;
        }

        //
        // Set up the pointers to the destination table and string block.
        //   This gets a flat pointer to the pointer table, a both flat and
        //   segmented pointers to the data block.
        //
        lpvpsTabDest16f = (VPSTR UNALIGNED FAR *)WOWFIXVDMPTR( snbDest16s, cbAlloc );
        lpstrDest16f = (char UNALIGNED *)
                ((BYTE UNALIGNED *)lpvpsTabDest16f+cPointers*sizeof(VPSTR));
        lpstrDest16s = (VPVOID)((DWORD)snbDest16s+cPointers*sizeof(VPSTR));

        //
        // Now convert the strings
        //
        cPointers -= 1;
        lplpsTabSrc32 = snbSrc32;
        for(i=0; i<cPointers; i++)
        {
            lpstr32 = *lplpsTabSrc32++;

            thkAssert( lpstr32 != NULL && "Loop is processing end of snb\n" );

            cLength = lstrlenW( lpstr32 ) + 1;

            cChars = WideCharToMultiByte( AreFileApisANSI() ? CP_ACP : CP_OEMCP,
                                          0, lpstr32, cLength,
                                          lpstrDest16f, cbStrings, NULL, NULL );

            if ( cChars == 0 && cLength != 0 )
            {
                WOWRELVDMPTR(snbDest16s);
                STACKFREE16(snbDest16s, cbAlloc);
                return (DWORD)E_UNEXPECTED;
            }

            //
            // Assign the Segmented pointer into the pointer table.
            //
            *lpvpsTabDest16f++ = lpstrDest16s;

            //
            // Advance both the flat and segmented data pointers.
            //
            lpstrDest16f += cChars;
            lpstrDest16s = (VPVOID)((DWORD)lpstrDest16s + cChars);

            //
            // As we advance the Dest pointer the size of the remaining
            // space in the buffer decreases.
            //
            cbStrings -= cChars;
        }

        // Terminate SNB
        *lpvpsTabDest16f = NULL;

        thkAssert( *lplpsTabSrc32 == NULL &&
                   "Loop is out of sync with count\n" );

        WOWRELVDMPTR(snbDest16s);
    }

    thkDebugOut((DEB_ARGS, "In3216  SNB: %p -> %p\n", snbSrc32, snbDest16s));

    TO_STACK16(pti, snbDest16s, VPVOID );

    pti->pThop++;
    dwResult = EXECUTE_THOP3216(pti);

    //
    // Free SNB data if necessary
    //
    if ( snbDest16s != 0 )
    {
        STACKFREE16( snbDest16s, cbAlloc );
    }

    return( dwResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   ThunkInterface3216, private
//
//  Synopsis:   Handles 32->16 interface thunking for THOP_IFACE and
//              THOP_IFACEGEN
//
//  Arguments:  [pti]      - Thunking state information
//              [iidx]     - Interface IID or index
//              [thop]     - Thop being executed
//              [vpvOuter] - Controlling unknown passed to the 16-bit world
//
//  Returns:    Status code
//
//  History:    Mar 14,97   Gopalk      Rewritten to support aggregation and
//                                      proper thunking of IN/OUT interfaces
//
//  Notes:      Assumes pti->pThop is adjusted by caller
//----------------------------------------------------------------------------

DWORD ThunkInterface3216(THUNKINFO *pti, IIDIDX iidx, THOP thop, VPVOID vpvOuter)
{
    // Local variables
    DWORD dwResult, dwStatus;
    void *pv;
    VPVOID vpvOutParam;
    VPVOID vpvThis16In, vpvThis16Out;
    IUnknown *punkOut;
    IUnknown *punkIn;
    THUNK3216OBJ *ptoPreAlloc = NULL;
    PROXYHOLDER *pph = NULL;
    PROXYHOLDER *pAggHolder = NULL;
    SAggHolder aggHolderNode;
    BOOL        bUnlinkAggHolder = FALSE;

    // Validate the IID of the interface
    thkAssert(IIDIDX_IS_IID(iidx) ||
              (IIDIDX_INDEX(iidx) >= 0 &&  IIDIDX_INDEX(iidx) < THI_COUNT));

    // Initialize
    dwResult = (DWORD) S_OK;
    vpvOutParam = NULL;
    vpvThis16In = NULL;

    // Retrieve interface pointer
    GET_STACK32(pti, pv, void *);

    // Check for valid OUT parameter. It also verifies IN-OUT case as well
    if((thop & THOP_OUT) && pv) {
        if(IsBadReadPtr(pv, sizeof(void *)) || IsBadWritePtr(pv, sizeof(void *))) {
            thkDebugOut((DEB_WARN, "WARNING: failing - bad pointer %p\n", pv));
            return (DWORD) E_INVALIDARG;
        }
        
        // Check if the interface needs to be thunked IN as well.
        // In other words, IN-OUT paramenter case
        if(thop & THOP_IN)
            punkIn = *(IUnknown **)pv;
        else
            punkIn = NULL;
    }
    else {
        // It must be IN parameter or a NULL OUT parameter
        punkIn = (IUnknown *)pv;
    }

    // Check if interface needs to be thunked IN
    if(thop & THOP_IN) {
        if(punkIn) {
            // Validate the interface
            if(IsValidInterface(punkIn)) {
                if((thop & THOP_OPMASK) == THOP_UNKOUTER) {                        
                    // Aggregation being carried out
                    // Assert that it is only being thunked IN
                    thkAssert(!(thop & THOP_OUT));
                    thkAssert(iidx == THI_IUnknown);

                    // Either find the actual 16-bit identity or generate a
                    // new 16-bit proxy identity for the 32-bit identity
                    vpvThis16In = pti->pThkMgr->CreateOuter16(punkIn,  &pAggHolder, &dwStatus);
                    aggHolderNode.pph = pAggHolder;
                    TlsThkLinkAggHolder(&aggHolderNode);
                    bUnlinkAggHolder = TRUE;

                    // We use this pAggHolder for proxies of inner unk(s). Since
                    // we cannot put it in the proxy table (as it is private
                    // and we do not want other thunk calls to use it), we put
                    // it in a linked list in the TLS. The holder gets used by
                    // calls to FindAggregate() when the pUnkInner is being
                    // thunked out. The holder is revoked from the list when
                    // the ThunkInterface call for the pUnkOuter unwinds.
                    
                }
                else {
                    // Find/Generate the proxy for the 32-bit interface 
                    // to be thunked IN
                    vpvThis16In = pti->pThkMgr->FindProxy1632(NULL, punkIn, NULL, 
                                                              iidx, &dwStatus);
                }
                
                if(vpvThis16In) {
                    thkAssert(!((thop & THOP_OPMASK) == THOP_UNKOUTER) ||
                              (dwStatus == FST_CREATED_NEW) || 
                              (dwStatus == FST_SHORTCUT));
                }
                else {
                    thkDebugOut((DEB_WARN, "WARNING: failing - Can't create proxy for %p\n",
                                 punkIn));
                    return (DWORD) E_OUTOFMEMORY;
                }
            }
            else {
                thkDebugOut((DEB_WARN, "WARNING: failing - invalid interface %p\n", 
                             punkIn));
                return (DWORD) E_INVALIDARG;
            }
        }
        else {
            // No interface to be thunked IN
            vpvThis16In = NULL;
        }

        thkDebugOut((DEB_ARGS, "%sIn3216  %s %p -> %p\n",
                     NestingLevelString(), IidIdxString(iidx), 
                     punkIn, vpvThis16In));
    }

    // Check if interface needs to be thunked OUT
    if((thop & THOP_OUT) && pv) {
        // Preallocate a proxy for the out parameter
        ptoPreAlloc = pti->pThkMgr->CanGetNewProxy3216(iidx);
        if(ptoPreAlloc) {
            // Allocate space for OUT parameter from the 16-bit heap
            vpvOutParam = STACKALLOC16(sizeof(VPVOID));
            if(vpvOutParam)  {
                // Assert that no interface is being thunked IN for
                // pure OUT parameter case
                thkAssert((thop & THOP_IN) || !vpvThis16In);

                // Assign the interface being thunked IN 
                *FIXVDMPTR(vpvOutParam, VPVOID) = vpvThis16In;
                RELVDMPTR(vpvOutParam);

                // Push the OUT/IN-OUT parameter onto the stack
                TO_STACK16(pti, vpvOutParam, VPVOID);
            }
            else {
                thkDebugOut((DEB_WARN, "WARNING: failing - Allocation on 16-bit heap failed\n"));
                dwResult = (DWORD)E_OUTOFMEMORY;
            }
        }
        else {
            thkDebugOut((DEB_WARN, "WARNING: failing - Cannot allocate proxy\n"));
            dwResult = (DWORD) E_OUTOFMEMORY;
        }
    }
    else {
        // Assert invariant
        thkAssert((pv && vpvThis16In) || (!pv && !vpvThis16In));

        // Push the IN parameter onto the stack
        TO_STACK16(pti, vpvThis16In, VPVOID);
    }

    if(SUCCEEDED((SCODE)dwResult)) {
        // Execute the next THOP operation
        dwResult = EXECUTE_THOP3216(pti);
    }

    if((thop & THOP_OUT) && pv) {
        punkOut = NULL;

        if(SUCCEEDED((SCODE)dwResult)) {
            // Obtain the 16-bit interface to be thunked OUT
            vpvThis16Out = *FIXVDMPTR(vpvOutParam, VPVOID);
            RELVDMPTR(vpvOutParam);

            // Check if a 16-bit interface was returned
            if(vpvThis16Out) {
                // Obtain 32-bit proxy for the 16-bit interface
                if(vpvOuter) {
                    //Get the holder that was linked into TLS when the pUnkOuter
                    //was being thunked in.
                    pAggHolder = (TlsThkGetAggHolder())->pph;
                    punkOut = pti->pThkMgr->FindAggregate3216(ptoPreAlloc, vpvOuter, 
                                                           vpvThis16Out, iidx, pAggHolder, 
                                                           &dwStatus);
                }
                else {
                    punkOut = pti->pThkMgr->FindProxy3216(ptoPreAlloc, vpvThis16Out, 
                                                       NULL, iidx, FALSE, &dwStatus);
                }
                
                if(punkOut) {
                    if((thop & THOP_OPMASK) == THOP_UNKINNER) {
                        if (dwStatus != FST_SHORTCUT) {
                            // Obtain the holder
                            pph = ((THUNK3216OBJ *)punkOut)->pphHolder ;

                            // Assert invariants in debug builds
                            thkAssert(pph->dwFlags & PH_AGGREGATEE);
                            thkAssert(dwStatus == FST_CREATED_NEW);

                            // Mark the proxy as representing inner unknown
                            ((THUNK3216OBJ *)punkOut)->grfFlags = PROXYFLAG_PUNKINNER;
                        }
                    }

                    // Either the preallocated proxy was used and freed
                    ptoPreAlloc = NULL;
                }
                else {
                    dwResult = (DWORD)E_OUTOFMEMORY;
                }

                // Release the actual 16-bit interface. If a proxy to the 
                // 16-bit interface could not be created above, this could 
                // be the last release on the 16-bit interface
                ReleaseOnObj16(vpvThis16Out);
            }
        }

        // Set the OUT parameter
        *(void **)pv = (void *)punkOut;

        thkDebugOut((DEB_ARGS, "%sOut3216 %s %p -> %p\n",
                     NestingLevelString(), IidIdxString(iidx),
                     vpvThis16Out, punkOut));
    }

    if(vpvThis16In) {
        if((thop & THOP_INOUT) == THOP_INOUT) {
            // IN-OUT parameter.
            thkAssert(punkIn);

            // Release the 32-bit side interface
            punkIn->Release();
        }
        else {
            // Just an IN parameter
            thkAssert(thop & THOP_IN);

#if DBG==1
            // Ensure that the following is not the last release
            // on the IN parameter
            THKSTATE thkstate;

            // Remember the current thunk state
            thkstate = pti->pThkMgr->GetThkState();

            // Set the thunk state to THKSTATE_VERIFYINPARAM
            pti->pThkMgr->SetThkState(THKSTATE_VERIFY32INPARAM);
#endif
            // Release the 16-bit side interface
            ReleaseOnObj16(vpvThis16In);
#if DBG==1
            // Restore previous thunk state
            pti->pThkMgr->SetThkState(thkstate);
#endif
        }

        // We should never receive a call IRpcStubBuffer::DebugServerRelease
        Win4Assert((thop & THOP_OPMASK) != THOP_IFACECLEAN);
    }
    
    // Cleanup
    if(ptoPreAlloc) {
        // Free preallocated proxy as it was not used
        pti->pThkMgr->FreeNewProxy3216(ptoPreAlloc, iidx);
    }
    if(vpvOutParam) {
        // Free the space created on the 16-bit for the OUT parameter
        STACKFREE16(vpvOutParam, sizeof(VPVOID));
    }

    if (bUnlinkAggHolder) {
        TlsThkUnlinkAggHolder();
    }

    return dwResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_IFACEGEN_3216, public
//
//  Synopsis:   Thunks riid,ppv pairs from 16->32
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    23-Feb-94       DrewB   Created
//
//----------------------------------------------------------------------------

DWORD Thop_IFACEGEN_3216(THUNKINFO *pti)
{
    IIDIDX iidx;
    THOP thop, thopOp, thopWeakOffset;
    VPVOID vpvOuter;
    IID const *piid;

    thop = *pti->pThop++;
    thopOp = thop & THOP_OPMASK;

    thkAssert(thopOp == THOP_IFACEGEN ||
              thopOp == THOP_IFACEGENOWNER);

    // The current thop byte indicates how many bytes to look
    // back in the stack to find the IID which identifies the
    // interface being returned
    INDEX_STACK32(pti, piid, IID const *, *pti->pThop);

#if DBG == 1
    if (!IsValidIid(*piid))
    {
        return (DWORD)E_INVALIDARG;
    }
#endif

    pti->pThop++;

    iidx = IidToIidIdx(*piid);
    vpvOuter = 0;
    if (thopOp == THOP_IFACEGENOWNER)
    {
        // Obtain the outer unknown that is being passed to the 16 bit world
        thopWeakOffset = *pti->pThop++;
        INDEX_STACK16(pti, vpvOuter, VPVOID, thopWeakOffset, sizeof(DWORD));
        if(vpvOuter) {
            // Aggregation across 32-16 boundary
            // Assert that the IID requested is IID_IUnknown
            thkAssert(iidx == THI_IUnknown ||
                      (pti->iidx==THI_IPSFactoryBuffer && pti->dwMethod==3));
            // Change thop to indicate that inner unknown is being thunked
            if(iidx == THI_IUnknown)
                thop = (thop & THOP_IOMASK) | THOP_UNKINNER;
        }
    }

    return ThunkInterface3216(pti, iidx, thop, vpvOuter);
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_OIFI_3216, public
//
//  Synopsis:   Convert OLEINPLACEFRAMEINFO
//
//  Arguments:  [pti] - Thunking state information
//
//  Returns:    Appropriate status code
//
//  History:    26-May-94       DrewB   Created
//
//----------------------------------------------------------------------------

DWORD Thop_OIFI_3216( THUNKINFO *pti )
{
    DWORD dwResult;
    VPVOID vpoifi16;
    OIFI16 UNALIGNED *poifi16;
    OLEINPLACEFRAMEINFO *poifi32;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_OIFI);
    thkAssert((*pti->pThop & THOP_IOMASK) == THOP_OUT);

    // OIFIs are out-only parameters for their contents
    // However, cb is in/out, so we need to copy cb on the way in
    // Furthermore, cb may not be set to a valid value, in which
    // case the documentation mentions that it should be assumed
    // that this is an OLE 2.0 OIFI
    // This thop simply ignores cb on the way in and always sets
    // it to the OLE 2.0 size
    // Since we're out-only, this always works since the number of
    // fields we thunk is the size of the structure that we give out
    // If OLEINPLACEFRAMEINFO is extended, this thop will break

    // Assert that OLEINPLACEFRAMEINFO is what we expect it to be
    thkAssert(sizeof(OLEINPLACEFRAMEINFO) == 20);

    GET_STACK32(pti, poifi32, OLEINPLACEFRAMEINFO *);

    vpoifi16 = 0;
    if (poifi32 != NULL)
    {
        if (IsBadWritePtr(poifi32, sizeof(OLEINPLACEFRAMEINFO)))
        {
            return (DWORD)E_INVALIDARG;
        }

        vpoifi16 = STACKALLOC16(sizeof(OIFI16));
        if (vpoifi16 == 0)
        {
            return (DWORD)E_OUTOFMEMORY;
        }

        // OIFI's may be an out only parameters but if the "cb" field is
        // "in" RPC doesn't slice up structs, so the whole thing is "in"
        // as well.  We are Thoping here but if we want this to match
        // the RPC sematics then we need to copy all the fields.

        poifi16 = FIXVDMPTR(vpoifi16, OIFI16);

        poifi16->cb            = sizeof(OIFI16);
        poifi16->fMDIApp       = (WORD)poifi32->fMDIApp;
        poifi16->hwndFrame     = HWND_16(poifi32->hwndFrame);
        poifi16->cAccelEntries =
            ClampULongToUShort(poifi32->cAccelEntries);

        if (poifi32->haccel == NULL)
        {
            poifi16->haccel = NULL;
        }
        else
        {
            // WOW will clean up any dangling accelerator tables when
            // tasks die
            poifi16->haccel = HACCEL_16(poifi32->haccel);
            if (poifi16->haccel == NULL)
            {
                dwResult = (DWORD)E_UNEXPECTED;
            }
        }

        RELVDMPTR(vpoifi16);
    }

    TO_STACK16(pti, vpoifi16, VPVOID);

    pti->pThop++;
    dwResult = EXECUTE_THOP3216(pti);

    if (vpoifi16 != NULL)
    {
        poifi16 = FIXVDMPTR(vpoifi16, OIFI16);

        if (SUCCEEDED(dwResult))
        {
            poifi32->cb            = sizeof(OLEINPLACEFRAMEINFO);
            poifi32->fMDIApp       = (BOOL)poifi16->fMDIApp;
            poifi32->hwndFrame     = HWND_32(poifi16->hwndFrame);
            poifi32->cAccelEntries = (UINT)poifi16->cAccelEntries;

            if (poifi16->haccel == NULL)
            {
                poifi32->haccel = NULL;
            }
            else
            {
                // WOW will clean up any dangling accelerator tables when
                // tasks die

                // Check that the haccel is valid.   We don't need to lock
                // the pointer.  We just want some means of validating it.
                // HACCEL_32 faults in krnl386 if the handle is bad.

                if(NULL != WOWGlobalLock16(poifi16->haccel))
                {
                    poifi32->haccel = HACCEL_32(poifi16->haccel);
                    WOWGlobalUnlock16(poifi16->haccel);
                }
                else
                {
                    poifi32->haccel = NULL;
                }

                if (poifi32->haccel == NULL)
                {
                    dwResult = (DWORD)E_UNEXPECTED;
                }
            }

#if DBG == 1
            if (SUCCEEDED(dwResult))
            {
                thkDebugOut((DEB_ARGS, "Out3216 OIFI: "
                             "%p {%d, %d, 0x%04X, 0x%04X, %d} -> "
                             "%p {%d, %d, 0x%p, 0x%p, %d}\n",
                             vpoifi16, poifi16->cb, (BOOL)poifi16->fMDIApp,
                             (DWORD)poifi16->hwndFrame, (DWORD)poifi16->haccel,
                             poifi16->cAccelEntries,
                             poifi32, poifi32->cb, poifi32->fMDIApp,
                             poifi32->hwndFrame, poifi32->haccel,
                             poifi32->cAccelEntries));
            }
#endif
        }

        RELVDMPTR(vpoifi16);

        if (FAILED(dwResult))
        {
            memset(poifi32, 0, sizeof(OLEINPLACEFRAMEINFO));
        }

        STACKFREE16(vpoifi16, sizeof(OIFI16));
    }

    return dwResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_STGMEDIUM_3216, public
//
//  Synopsis:   Converts 32-bit STGMEDIUM to 16-bit STGMEDIUM returned
//              structure
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    23-Feb-94       BobDay  Created
//
//----------------------------------------------------------------------------

DWORD Thop_STGMEDIUM_3216(THUNKINFO *pti)
{
    DWORD       dwResult;
    BOOL        fThopInput;
    BOOL        fThopOutput;
    VPVOID      vpstgmedium16;
    STGMEDIUM   *lpstgmedium32;
    DWORD       dwSize;
    SCODE       sc;
    BOOL        fReleaseParam;
    BOOL        fTransferOwnership;
    FORMATETC   *pfe;
    THOP        thopFeOffset;
    DWORD       vpIStream = 0;
    STGMEDIUM UNALIGNED *psm16;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_STGMEDIUM);

    fThopInput  = IS_THOP_IN(pti);
    fThopOutput = IS_THOP_OUT(pti);

    //
    // We currently don't have any unmodified or inout thops for STGMEDIUMs
    //
    thkAssert( (fThopInput || fThopOutput) &&
               (fThopInput != fThopOutput) &&
               "STGMEDIUM must be input or output only" );

    // +2 thop byte indicates whether there's a FORMATETC to look at
    // or not
    // We need to reference this now before the stack is modified
    // by argument recovery
    thopFeOffset = *(pti->pThop+2);
    if (thopFeOffset > 0)
    {
        INDEX_STACK32(pti, pfe, FORMATETC *, thopFeOffset);
    }
    else
    {
        pfe = NULL;
    }

    GET_STACK32(pti, lpstgmedium32, STGMEDIUM FAR *);

    // Next thop byte indicates whether there's an ownership transfer
    // argument or not
    pti->pThop++;
    fReleaseParam = (BOOL)*pti->pThop++;

    if (fReleaseParam)
    {
        GET_STACK32(pti, fTransferOwnership, BOOL);
    }
    else
    {
        fTransferOwnership = FALSE;
    }

    // Skip FORMATETC offset thop
    pti->pThop++;

    vpstgmedium16 = 0;

    if ( lpstgmedium32 != NULL )
    {
        if ((fThopInput && IsBadReadPtr(lpstgmedium32, sizeof(STGMEDIUM))) ||
            (fThopOutput && IsBadWritePtr(lpstgmedium32, sizeof(STGMEDIUM))))
        {
            return (DWORD)E_INVALIDARG;
        }

        vpstgmedium16 = STACKALLOC16(sizeof(STGMEDIUM));
        if (vpstgmedium16 == 0)
        {
            return (DWORD)E_OUTOFMEMORY;
        }

        if ( fThopInput )
        {
            sc = ConvertStgMed3216(pti, lpstgmedium32, vpstgmedium16,
                                   pfe, fTransferOwnership, &dwSize);
            if (SUCCEEDED(sc))
            {
                // Apparently if you pass TYMED_NULL into GetDataHere
                // it's supposed to work like GetData, so switch input-only
                // TYMED_NULLs to output
                if (lpstgmedium32->tymed == TYMED_NULL &&
                    !fTransferOwnership)
                {
                    fThopInput = FALSE;
                    fThopOutput = TRUE;
                }
                else if (lpstgmedium32->tymed == TYMED_ISTREAM)
                {
                    //
                    // Excel has a bug in its Clipboard data object that when
                    // GetDataHere is done providing a IStream interface, it
                    // will create its own stream and pounce on the pointer
                    // being passed in. So, if the thing is input, and the
                    // TYMED is ISTREAM we need to stash away the original
                    // 16-bit stream pointer for use later.
                    //
                    psm16 = FIXVDMPTR(vpstgmedium16, STGMEDIUM);
                    vpIStream = (DWORD)psm16->pstm;
                    RELVDMPTR(vpstgmedium16);
                }
            }
            else
            {
                STACKFREE16(vpstgmedium16, sizeof(STGMEDIUM));
                return (DWORD)sc;
            }

        }
        else
        {
            if( !((TlsThkGetAppCompatFlags() & OACF_CORELTRASHMEM) &&
                lpstgmedium32->tymed == 0x66666666 ))
            {

                // Even though this is an out parameter, some apps
                // (Graph 5 is one) check its values and depend on it
                // being zeroed out

                // However, if we are in CorelDraw *and* we're being
                // called by wGetMonikerAndClassFromObject (tymed set to
                // all 6's), then we do not want to set the tymed to zero.
                // Corel5 relies on the memory being trashed in order to
                // prevent paste-link-to-yourself.

                memset(FIXVDMPTR(vpstgmedium16, STGMEDIUM), 0,
                    sizeof(STGMEDIUM));
                RELVDMPTR(vpstgmedium16);
            }

        }
    }

    TO_STACK16(pti, vpstgmedium16, VPVOID);

    if (fReleaseParam)
    {
        TO_STACK16(pti, (SHORT)fTransferOwnership, SHORT);
    }

    dwResult = EXECUTE_THOP3216(pti);

    if (lpstgmedium32 != NULL)
    {
        if (fThopInput)
        {

            if (SUCCEEDED(dwResult) &&
                (lpstgmedium32->tymed == TYMED_ISTREAM) &&
                (vpIStream != 0))
            {
                //
                // To continue our Excel Clipboard GetDataHere hack, if the
                // TYMED was ISTREAM, and the medium was input (as it is now)
                // then we need to detect the case where the IStream pointer
                // changed. If it did change, then we have a special function
                // in the 16-bit world that will copy the contents of the
                // 'new' stream into 'our' stream, and release the 'new'
                // stream. This should make the clipboard work properly.
                //
                psm16 = FIXVDMPTR(vpstgmedium16, STGMEDIUM);
                if( (psm16->tymed == TYMED_ISTREAM) &&
                    (vpIStream != (DWORD)psm16->pstm))
                {
                    BYTE b32Args[WCB16_MAX_CBARGS];
                    *(DWORD *)&b32Args[0] = vpIStream;
                    *(DWORD *)&b32Args[sizeof(DWORD)] = (DWORD)psm16->pstm;

                    RELVDMPTR(vpstgmedium16);

                    if( !CallbackTo16Ex(
                            (DWORD)gdata16Data.fnStgMediumStreamHandler16,
                            WCB16_PASCAL,
                            2*sizeof(DWORD),
                            b32Args,
                            &dwResult) )
                    {
                        dwResult = (DWORD)E_UNEXPECTED;
                    }

                }
                else
                {
                    //
                    // Two possibilites
                    // The stream pointers are the same. Good news
                    // The tymed was changed. Bad news. There isn't anything
                    // we can safely do with the different tymed, so ignore
                    // the whole thing.
                    //

                    RELVDMPTR(vpstgmedium16);
                }
            }


            if (!fTransferOwnership || FAILED(dwResult))
            {
                sc = CleanStgMed16(pti, vpstgmedium16, lpstgmedium32,
                                   dwSize, TRUE, pfe);
                if (FAILED(sc))
                {
                    dwResult = (DWORD)sc;
                }
            }
            else if (SUCCEEDED(dwResult))
            {

                if (lpstgmedium32->pUnkForRelease == NULL)
                {
                    sc = CleanStgMed32(pti, lpstgmedium32, vpstgmedium16,
                                       0, FALSE, pfe);
                    thkAssert(SUCCEEDED(sc));
                }
            }
        }
        else
        {
            thkAssert(fThopOutput);

            if (SUCCEEDED(dwResult))
            {
                sc = ConvertStgMed1632(pti, vpstgmedium16, lpstgmedium32,
                                       pfe, FALSE, &dwSize);
                if (FAILED(sc))
                {
                    dwResult = (DWORD)sc;
                    CallbackTo16(gdata16Data.fnReleaseStgMedium16,
                                  vpstgmedium16);
                }
                else if (lpstgmedium32->pUnkForRelease == NULL)
                {
                    sc = CleanStgMed16(pti, vpstgmedium16, lpstgmedium32,
                                       dwSize, FALSE, pfe);
                    thkAssert(SUCCEEDED(sc));
                }
            }

            if (FAILED(dwResult))
            {
                memset(lpstgmedium32, 0, sizeof(STGMEDIUM));
            }
        }
    }

    if (vpstgmedium16 != 0)
    {
        STACKFREE16(vpstgmedium16, sizeof(STGMEDIUM));
    }

    return dwResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   ConvertStatStg1632, public
//
//  Synopsis:   Converts a STATSTG
//
//  Arguments:  [pti] - Thunk info
//              [vpss16] - STATSTG
//              [pss32] - STATSTG
//              [posPreAlloc] - Preallocated string memory or NULL
//              [cchPreAlloc] - Amount preallocated
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pss32]
//
//  History:    14-May-94       DrewB   Created
//
//  Notes:      Assumes input STATSTG memory is valid
//              Assumes task memory for the string
//
//----------------------------------------------------------------------------

SCODE ConvertStatStg1632(THUNKINFO *pti,
                         VPVOID vpss16,
                         STATSTG *pss32,
                         LPOLESTR posPreAlloc,
                         UINT cchPreAlloc)
{
    STATSTG UNALIGNED *pss16;
    SCODE sc;
    LPOLESTR pos32;
    VPSTR vpstr;

    pss16 = FIXVDMPTR(vpss16, STATSTG);
    vpstr = (VPSTR)pss16->pwcsName;
    RELVDMPTR(vpss16);

    sc = ConvertTaskString1632(pti, vpstr,
                               posPreAlloc, cchPreAlloc,
                               &pos32);

    if (SUCCEEDED(sc))
    {
        pss16 = FIXVDMPTR(vpss16, STATSTG);
        memcpy(pss32, pss16, sizeof(STATSTG));
        pss32->pwcsName = pos32;
        RELVDMPTR(vpss16);
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_STATSTG_3216, public
//
//  Synopsis:   Converts 32-bit STATSTG to 16-bit STATSTG returned structure
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    23-Feb-94       BobDay  Created
//
//----------------------------------------------------------------------------
DWORD Thop_STATSTG_3216( THUNKINFO *pti )
{
    DWORD       dwResult;
    STATSTG     *lpstatstg32;
    VPVOID      vpstatstg16;
    LPOLESTR    lpstr32;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_STATSTG);

    //
    // We currently don't have any input thops for STATSTGs
    //
    thkAssert( (*pti->pThop & THOP_IOMASK) == THOP_OUT &&
               "STATSTG must be output only" );

    GET_STACK32(pti, lpstatstg32, STATSTG FAR *);

    if (IsBadWritePtr(lpstatstg32, sizeof(STATSTG)))
    {
        return (DWORD)E_INVALIDARG;
    }

    vpstatstg16 = STACKALLOC16(sizeof(STATSTG));
    if (vpstatstg16 == 0)
    {
        return (DWORD)E_OUTOFMEMORY;
    }

    lpstr32 = (LPOLESTR)TaskMalloc32(CBSTRINGPREALLOC);
    if (lpstr32 == NULL)
    {
        STACKFREE16(vpstatstg16, sizeof(STATSTG));
        return (DWORD)E_OUTOFMEMORY;
    }

    TO_STACK16(pti, vpstatstg16, VPVOID);

    pti->pThop++;
    dwResult = EXECUTE_THOP3216(pti);

    if (SUCCEEDED(dwResult))
    {
        SCODE sc;

        sc = ConvertStatStg1632(pti, vpstatstg16, lpstatstg32,
                                lpstr32, CWCSTRINGPREALLOC);
        if (FAILED(sc))
        {
            dwResult = sc;
        }
    }

    if (FAILED(dwResult))
    {
        TaskFree32(lpstr32);

        memset(lpstatstg32, 0, sizeof(STATSTG));
    }

    STACKFREE16(vpstatstg16, sizeof(STATSTG));

    return dwResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_DVTARGETDEVICE_3216, public
//
//  Synopsis:   Converts 16-bit DVTARGETDEVICE to 32-bit DVTARGETDEVICE
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    23-Feb-94       BobDay  Created
//
//----------------------------------------------------------------------------
DWORD Thop_DVTARGETDEVICE_3216( THUNKINFO *pti )
{
    DWORD               dwResult;
    UINT                uiSize;
    DVTARGETDEVICE FAR  *lpdv32;
    VPVOID              vpdv16;
    SCODE               sc;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_DVTARGETDEVICE);

    //
    // We currently don't have any output thops for DVTARGETDEVICEs
    //
    thkAssert( (*pti->pThop & THOP_IOMASK) == THOP_IN &&
               "DVTARGETDEVICE must be input only" );

    //
    // Processing for a DVTARGETDEVICE FAR * as input
    //
    GET_STACK32(pti, lpdv32, DVTARGETDEVICE FAR *);

    vpdv16 = 0;

    if ( lpdv32 != NULL )
    {
        sc = ConvertDvtd3216(pti, lpdv32, ArStack16, FrStack16, &vpdv16,
                             &uiSize);
        if (FAILED(sc))
        {
            return (DWORD)sc;
        }
    }

    TO_STACK16(pti, vpdv16, VPVOID);
    pti->pThop++;
    dwResult = EXECUTE_THOP3216(pti);

    if ( lpdv32 != NULL )
    {
        FrStack16((void *)vpdv16, uiSize);
    }

    return dwResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_FORMATETC_3216, public
//
//  Synopsis:   Converts 16-bit FORMATETC to 32-bit FORMATETC and back
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    24-Feb-94       BobDay  Created
//
//----------------------------------------------------------------------------
DWORD Thop_FORMATETC_3216( THUNKINFO *pti )
{
    DWORD               dwResult;
    BOOL                fThopInput;
    BOOL                fThopOutput;
    VPVOID              vpformatetc16;
    FORMATETC16 UNALIGNED *lpformatetc16;
    LPFORMATETC         lpformatetc32;
    VPVOID              vpdv16;
    SCODE               sc;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_FORMATETC);

    fThopInput  = IS_THOP_IN(pti);
    fThopOutput = IS_THOP_OUT(pti);

    vpdv16 = 0;

    //
    // We have only input or output thops
    //
    thkAssert( (fThopInput || fThopOutput) &&
               (fThopInput != fThopOutput) &&
               "formatetc must be input or output only" );

    GET_STACK32(pti, lpformatetc32, LPFORMATETC);

    if ( lpformatetc32 == NULL )
    {
        vpformatetc16 = 0;
    }
    else
    {
        if ((fThopInput && IsBadReadPtr(lpformatetc32, sizeof(LPFORMATETC))) ||
            (fThopOutput && IsBadWritePtr(lpformatetc32, sizeof(LPFORMATETC))))
        {
            return (DWORD)E_INVALIDARG;
        }

        vpformatetc16 = STACKALLOC16(sizeof(FORMATETC16));
        if (vpformatetc16 == 0)
        {
            return (DWORD)E_OUTOFMEMORY;
        }

        if ( fThopInput )
        {
            sc = ConvertFetc3216(pti, lpformatetc32, vpformatetc16, FALSE);
            if (FAILED(sc))
            {
                STACKFREE16(vpformatetc16, sizeof(FORMATETC16));
                return (DWORD)sc;
            }
        }
        else
        {
            thkAssert( fThopOutput );

            //
            // The below memset is needed at least for the DATA_S_SAMEFORMATETC
            // case.  This allows it to be cleaned up because all its pointers
            // will be null.
            //
            lpformatetc16 = FIXVDMPTR(vpformatetc16, FORMATETC16);
            memset(lpformatetc16, 0, sizeof(FORMATETC16) );
            RELVDMPTR(vpformatetc16);
        }
    }

    TO_STACK16(pti, vpformatetc16, VPVOID);
    pti->pThop++;
    dwResult = EXECUTE_THOP3216(pti);

    if (fThopInput && vpformatetc16 != 0)
    {
        VPVOID vptd;

        lpformatetc16 = FIXVDMPTR(vpformatetc16, FORMATETC16);
        vptd = (VPVOID)lpformatetc16->ptd;
        RELVDMPTR(vpformatetc16);

        if (vptd != 0)
        {
            TaskFree16(vptd);
        }
    }

    if ( fThopOutput && lpformatetc32 != NULL)
    {
        if (SUCCEEDED(dwResult))
        {
            sc = ConvertFetc1632(pti, vpformatetc16, lpformatetc32, TRUE);
            if (FAILED(sc))
            {
                dwResult = sc;
            }
        }

        if (FAILED(dwResult))
        {
            memset(lpformatetc32, 0, sizeof(FORMATETC));
        }
    }

    if (vpformatetc16 != 0)
    {
        STACKFREE16(vpformatetc16, sizeof(FORMATETC16));
    }

    return dwResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_LOGPALETTE_3216, public
//
//  Synopsis:   Converts 16-bit LOGPALLETE to 32-bit LOGPALETTE
//              and converts 32-bit LOGPALETTE returned to 16-bit structure
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    23-Feb-94       BobDay  Created
//
//----------------------------------------------------------------------------

DWORD Thop_LOGPALETTE_3216 ( THUNKINFO *pti )
{
    DWORD             dwResult;
    UINT              uiSize;
    LPLOGPALETTE      lplogpal32;
    VPVOID            vplogpal16;
    LOGPALETTE UNALIGNED *lplogpal16;
    LPLOGPALETTE      *lplplogpal32;
    VPVOID            vpvplogpal16;
    VPVOID UNALIGNED *lpvplogpal16;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_LOGPALETTE);

    //
    // It must be either an input or output LOGPALETTE
    //
    thkAssert( ((*pti->pThop & THOP_IOMASK) == THOP_IN ||
                (*pti->pThop & THOP_IOMASK) == THOP_OUT) &&
               "Hey, LOGPALETTE can't be input and output!" );

    if ( (*pti->pThop & THOP_IN) != 0 )
    {
        //
        // Processing for a LPLOGPALETTE as input
        //
        GET_STACK32(pti, lplogpal32, LPLOGPALETTE);

        if ( lplogpal32 == NULL )
        {
            vplogpal16 = 0;
        }
        else
        {
            if (IsBadReadPtr(lplogpal32, sizeof(LOGPALETTE)))
            {
                return (DWORD)E_INVALIDARG;
            }

            uiSize = CBPALETTE(lplogpal32->palNumEntries);

            if (IsBadReadPtr(lplogpal32, uiSize))
            {
                return (DWORD)E_INVALIDARG;
            }

            vplogpal16 = STACKALLOC16(uiSize);
            if (vplogpal16 == 0)
            {
                return (DWORD)E_OUTOFMEMORY;
            }

            lplogpal16 = (LOGPALETTE UNALIGNED *)
                WOWFIXVDMPTR( vplogpal16, uiSize );

            memcpy( lplogpal16, lplogpal32, uiSize );

            WOWRELVDMPTR(vplogpal16);
        }

        TO_STACK16(pti, vplogpal16, VPVOID);
        pti->pThop++;
        dwResult = EXECUTE_THOP3216(pti);

        if ( vplogpal16 != 0 )
        {
            STACKFREE16(vplogpal16, uiSize);
        }
    }
    else
    {
        //
        // Processing for LPLPLOGPALETTE as output
        //
        thkAssert((*pti->pThop & THOP_OUT) != 0);

        GET_STACK32(pti, lplplogpal32, LPLOGPALETTE FAR *);
        if (IsBadWritePtr(lplplogpal32, sizeof(LPLOGPALETTE)))
        {
            return (DWORD)E_INVALIDARG;
        }

        vpvplogpal16 = (VPVOID)STACKALLOC16(sizeof(LPLOGPALETTE));
        if (vpvplogpal16 == 0)
        {
            return (DWORD)E_OUTOFMEMORY;
        }

        lplogpal32 = (LPLOGPALETTE)TaskMalloc32(CBPALETTE(NPALETTEPREALLOC));
        if (lplogpal32 == NULL)
        {
            STACKFREE16(vpvplogpal16, sizeof(LPLOGPALETTE));
            return (DWORD)E_OUTOFMEMORY;
        }

        //
        // We DO need to zero out the pointer on the way in.
        //
        *FIXVDMPTR(vpvplogpal16, LPLOGPALETTE) = 0;
        RELVDMPTR(vpvplogpal16);

        TO_STACK16(pti, vpvplogpal16, VPVOID);

        pti->pThop++;
        dwResult = EXECUTE_THOP3216(pti);

        if (SUCCEEDED(dwResult))
        {
            lpvplogpal16 = FIXVDMPTR( vpvplogpal16, VPVOID);
            vplogpal16 = *lpvplogpal16;
            RELVDMPTR(vpvplogpal16);

            if ( vplogpal16 == 0 )
            {
                TaskFree32(lplogpal32);
                lplogpal32 = NULL;
            }
            else
            {
                lplogpal16 = FIXVDMPTR( vplogpal16, LOGPALETTE );

                //
                // Copy the returned LOGPALETTE into 16-bit memory
                //
                uiSize = CBPALETTE(lplogpal16->palNumEntries);
                if (uiSize > CBPALETTE(NPALETTEPREALLOC))
                {
                    TaskFree32(lplogpal32);

                    lplogpal32 = (LPLOGPALETTE)TaskMalloc32(uiSize);
                    if ( lplogpal32 == NULL )
                    {
                        dwResult = (DWORD)E_OUTOFMEMORY;
                    }
                }

                if (lplogpal32 != NULL)
                {
                    memcpy( lplogpal32, lplogpal16, uiSize );
                }

                RELVDMPTR(vplogpal16);

                TaskFree16( vplogpal16 );
            }
        }
        else
        {
            TaskFree32(lplogpal32);
            lplogpal32 = NULL;
        }

        //
        // Update the value pointed to by the parameter on the 16-bit stack
        //
        *lplplogpal32 = lplogpal32;

        if (vpvplogpal16 != 0)
        {
            STACKFREE16(vpvplogpal16, sizeof(LPLOGPALETTE));
        }
    }
    return dwResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_CRGIID_3216, public
//
//  Synopsis:   Converts 32-bit CRGIID to 16-bit CRGIID structure
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    23-Feb-94       BobDay  Created
//
//----------------------------------------------------------------------------
DWORD Thop_CRGIID_3216( THUNKINFO *pti )
{
    DWORD       dwResult;
    DWORD       dwCount;
    VPVOID      vpiid16;
    IID UNALIGNED *lpiid16;
    IID         *lpiid32;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_CRGIID);

    //
    // We currently don't have any output thops for CRGIIDs
    //
    thkAssert( (*pti->pThop & THOP_IOMASK) == 0 &&
               "CRGIID must be unmodified only" );

    GET_STACK32(pti, dwCount, DWORD);
    GET_STACK32(pti, lpiid32, IID FAR *);

    if ( lpiid32 == NULL )
    {
        vpiid16 = 0;
    }
    else
    {
        if (IsBadReadPtr(lpiid32, dwCount*sizeof(IID)))
        {
            return (DWORD)E_INVALIDARG;
        }

        vpiid16 = STACKALLOC16( dwCount * sizeof(IID) );
        if (vpiid16 == 0)
        {
            return (DWORD)E_OUTOFMEMORY;
        }

        lpiid16 = (IID UNALIGNED *)
            WOWFIXVDMPTR( vpiid16, dwCount*sizeof(IID) );

        memcpy( lpiid16, lpiid32, dwCount*sizeof(IID) );

        WOWRELVDMPTR(vpiid16);
    }

    TO_STACK16(pti, dwCount, DWORD);
    TO_STACK16(pti, vpiid16, VPVOID);

    pti->pThop++;
    dwResult = EXECUTE_THOP3216(pti);

    if ( vpiid16 != 0 )
    {
        STACKFREE16( vpiid16, dwCount * sizeof(IID) );
    }
    return( dwResult );
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_INTERFACEINFO_3216, public
//
//  Synopsis:   Converts an INTERFACEINFO
//
//  Arguments:  [pti] - Thunking state information
//
//  Returns:    Appropriate status code
//
//  History:    19-May-94       DrewB   Created
//
//----------------------------------------------------------------------------

DWORD Thop_INTERFACEINFO_3216(THUNKINFO *pti)
{
    INTERFACEINFO *pii32;
    INTERFACEINFO16 UNALIGNED *pii16;
    VPVOID vpii16;
    DWORD dwResult;
    VPVOID vpunk16;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_INTERFACEINFO);
    thkAssert((*pti->pThop & THOP_INOUT) == THOP_IN);

    vpunk16 = 0;

    GET_STACK32(pti, pii32, INTERFACEINFO *);
    if (pii32 == NULL)
    {
        vpii16 = 0;
    }
    else
    {
        if (IsBadReadPtr(pii32, sizeof(INTERFACEINFO)))
        {
            return (DWORD)E_INVALIDARG;
        }

        vpii16 = STACKALLOC16(sizeof(INTERFACEINFO16));
        if (vpii16 == 0)
        {
            return (DWORD)E_OUTOFMEMORY;
        }

        if (pii32->pUnk != NULL)
        {
            vpunk16 = pti->pThkMgr->FindProxy1632(NULL, pii32->pUnk, NULL,
                                                  INDEX_IIDIDX(THI_IUnknown),
                                                  NULL);
            if (vpunk16 == 0)
            {
                STACKFREE16(vpii16, sizeof(INTERFACEINFO16));
                return (DWORD)E_OUTOFMEMORY;
            }
        }

        pii16 = FIXVDMPTR(vpii16, INTERFACEINFO16);
        pii16->pUnk = vpunk16;
        pii16->iid = pii32->iid;
        pii16->wMethod = pii32->wMethod;

        thkDebugOut((DEB_ARGS,
                     "In3216  INTERFACEINFO: %p -> %p {%p (%p), %s, %u}\n",
                     pii32, vpii16, pii16->pUnk, pii32->pUnk,
                     IidOrInterfaceString(&pii16->iid), pii16->wMethod));

        RELVDMPTR(vpii16);
    }

    TO_STACK16(pti, vpii16, VPVOID);

    pti->pThop++;
    dwResult = EXECUTE_THOP3216(pti);

    if (vpunk16 != 0)
    {
        // Release the 16-bit interface as it is an IN parameter
        ReleaseOnObj16(vpunk16);
    }

    if (vpii16 != 0)
    {
        STACKFREE16(vpii16, sizeof(INTERFACEINFO16));
    }

    return dwResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_RETURNTYPE_3216, public
//
//  Synopsis:   Thunks the return value of a call
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    24-Feb-94       DrewB   Created
//
//  Notes:      This thunk assumes that the return value will always fit
//              in 32 bits and that the thops for it are only one thop
//              long.  This fits the existing APIs and methods
//
//----------------------------------------------------------------------------

DWORD Thop_RETURNTYPE_3216(THUNKINFO *pti)
{
    THOP thops[2];
    DWORD dwResult;
    THUNK3216OBJ *ptoPreAlloc = NULL;
    IIDIDX iidx;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_RETURNTYPE);
    thkAssert((*pti->pThop & THOP_IOMASK) == 0);

    pti->fResultThunked = TRUE;

    pti->pThop++;

    // Remember return type thop
    thops[0] = *pti->pThop++;
    if ((thops[0] & THOP_OPMASK) == THOP_COPY ||
        (thops[0] & THOP_OPMASK) == THOP_IFACE ||
        (thops[0] & THOP_OPMASK) == THOP_ALIAS32)
    {
        thops[1] = *pti->pThop++;
    }

    // Preallocate any necessary resources
    switch(thops[0])
    {
    case THOP_IFACE | THOP_IN:
        iidx = INDEX_IIDIDX(thops[1]);
        if ((ptoPreAlloc = pti->pThkMgr->CanGetNewProxy3216(iidx)) == NULL)
        {
            return (DWORD)E_OUTOFMEMORY;
        }
        break;
    }

    dwResult = EXECUTE_THOP3216(pti);

    // Now that we have the return value thunk it from 16->32

    switch(thops[0])
    {
    case THOP_COPY:
        // Only handle DWORD copies
        thkAssert(thops[1] == sizeof(DWORD));
        break;

    case THOP_SHORTLONG:
        // For boolean results, not necessary to clamp
        dwResult = (DWORD)(LONG)*(SHORT *)&dwResult;
        break;

    case THOP_IFACE | THOP_IN:
        // Thunking an interface as a return value is completly broken
        // First, such an interface needs to be thunked as an OUT parameter
        // which I am fixing below. Second, the IID of the interface being
        // thunked needs to be in the THOP string for proper thunking of
        // interface. The only known case where an interface is returned
        // is IRpcStubBuffer::IsIIDSupported() and the interface returned
        // is of type IRpcStubBuffer, not IUnknown. As this method is not
        // used in the curremt COM code, I am not changing THOP strings
        // to reflect the IID of the interface being thunked
        //            Gopalk     Mar 27, 97
        if (dwResult != 0)
        {
            // BUGBUG - What if another thop failed and returned an HRESULT?
            // This will break
            VPVOID vpvUnk = (VPVOID) dwResult;
            dwResult =
                (DWORD)pti->pThkMgr->FindProxy3216(ptoPreAlloc, dwResult, NULL,
                                                   iidx, FALSE, NULL);
            
            // Release actual interface as it is an OUT parameter
            // This could be the last release on the interface if the
            // above call failed;
            ReleaseOnObj16(vpvUnk);
            thkAssert(dwResult);

            thkDebugOut((DEB_ARGS, "Ret3216 %s %p\n",
                         inInterfaceNames[thops[1]].pszInterface,
                         dwResult));
        }
        else
        {
            pti->pThkMgr->FreeNewProxy3216(ptoPreAlloc, iidx);
        }
        break;

    default:
        thkAssert(!"Unhandled 3216 return type");
        break;
    }

    return dwResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_IFACE_3216, public
//
//  Synopsis:   Thunks a known interface pointer
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    24-Feb-94       DrewB   Created
//
//----------------------------------------------------------------------------

DWORD Thop_IFACE_3216(THUNKINFO *pti)
{
    IIDIDX iidx;
    THOP thop, thopOp, thopWeakOffset;
    VPVOID vpvOuter;

    thop = *pti->pThop++;
    thopOp = thop & THOP_OPMASK;

    thkAssert(   thopOp == THOP_IFACE
              || thopOp == THOP_IFACEOWNER
              || thopOp == THOP_IFACECLEAN
              || thopOp == THOP_UNKOUTER);

    iidx = INDEX_IIDIDX(*pti->pThop++);
    // There's a bit of a special case here in that IMalloc is
    // not thunked so it doesn't have a real index but it's used
    // in thop strings so it has a fake index to function as a placeholder
    // The fake index is THI_COUNT so allow that in the assert
    thkAssert(IIDIDX_INDEX(iidx) >= 0 && IIDIDX_INDEX(iidx) <= THI_COUNT);
    thkAssert(thopOp != THOP_UNKOUTER || iidx == THI_IUnknown);

    vpvOuter = 0;
    if (thopOp == THOP_IFACEOWNER)
    {
        // Obtain the outer unknown that is being passed to the 16 bit world
        thopWeakOffset = *pti->pThop++;
        INDEX_STACK16(pti, vpvOuter, VPVOID, thopWeakOffset, sizeof(DWORD));
        if(vpvOuter) {
            // Aggregation across 32-16 boundary
            // Assert invariants
            thkAssert(iidx == THI_IRpcProxyBuffer || iidx == THI_IRpcProxy);
            // Change thop to indicate that inner unknown is being thunked
            thop = (thop & THOP_IOMASK) | THOP_UNKINNER;
        }
    }

    return ThunkInterface3216(pti, iidx, thop, vpvOuter);
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_ALIAS32_3216, public
//
//  Synopsis:   Handles 16-bit aliases to 32-bit quantities
//
//  Arguments:  [pti] - Thunking state information
//
//  Returns:    Appropriate status code
//
//  History:    27-May-94       DrewB   Created
//
//----------------------------------------------------------------------------

DWORD Thop_ALIAS32_3216(THUNKINFO *pti)
{
    ALIAS alias;
    DWORD dwValue;
    THOP thopAction;
    BOOL fTemporary = FALSE;
    DWORD dwResult;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_ALIAS32);
    thkAssert((*pti->pThop & THOP_IOMASK) == 0);

    pti->pThop++;

    GET_STACK32(pti, dwValue, DWORD);

    // Second byte indicates how the alias should be handled
    thopAction = *pti->pThop++;

    if (dwValue != 0)
    {
        switch(thopAction)
        {
        case ALIAS_RESOLVE:
            alias = gAliases32.ValueAlias(dwValue);

            // There may be cases where there is no existing alias
            // for a value (for example, remoted SetMenu calls where
            // the HOLEMENU is a temporary RPC object)
            // so create a temporary one
            if (alias == INVALID_ALIAS)
            {
                alias = gAliases32.AddValue(dwValue);
                if (alias == INVALID_ALIAS)
                {
                    return (DWORD)E_OUTOFMEMORY;
                }

                fTemporary = TRUE;
            }
            break;

        default:
            thkAssert(!"Default hit in Thop_ALIAS32_3216");
			alias = 0;
            break;
        }
    }
    else
    {
        alias = 0;
    }

    thkDebugOut((DEB_ARGS, "In3216  ALIAS32: 0x%08lX -> 0x%04X\n",
                 dwValue, alias));

    TO_STACK16(pti, alias, ALIAS);

    dwResult = EXECUTE_THOP3216(pti);

    if (fTemporary)
    {
        gAliases32.RemoveAlias(alias);
    }

    return dwResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_RPCOLEMESSAGE_3216, public
//
//  Synopsis:   Converts 32-bit RPCOLEMESSAGE to 16-bit RPCOLEMESSAGE
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    23-Feb-94       JohannP  Created
//
//----------------------------------------------------------------------------
DWORD Thop_RPCOLEMESSAGE_3216( THUNKINFO *pti )
{
    DWORD           dwResult;
    PRPCOLEMESSAGE  prom32;
    VPVOID          vprom16;
    RPCOLEMESSAGE UNALIGNED *prom16;
    VPVOID          vpvBuffer16;
    LPVOID          lp16;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_RPCOLEMESSAGE);

    //
    // We currently have only IN/OUT RPCOLEMESSAGE
    //
    thkAssert( (*pti->pThop & THOP_IOMASK) == (THOP_IN | THOP_OUT) &&
               "RPCOLEMESSAGE must be input/output only" );

    vprom16 = 0;
    vpvBuffer16 = 0;

    //
    // Processing for a RPCOLEMESSAGE FAR * as input/output
    //
    GET_STACK32(pti, prom32, RPCOLEMESSAGE *);
    if ( prom32 != 0 )
    {
        // Copy over the input RPCOLEMESSAGE structure

        vprom16 = STACKALLOC16(sizeof(RPCOLEMESSAGE));
        if (vprom16 == NULL)
        {
            return (DWORD)E_OUTOFMEMORY;
        }

        prom16 = FIXVDMPTR(vprom16, RPCOLEMESSAGE);
        *prom16 = *prom32;
        ROM_THUNK_FIELD(prom16) = (void *)prom32;
        RELVDMPTR(vprom16);

        // If there's a buffer, copy it
        if (prom32->cbBuffer != 0)
        {
            vpvBuffer16 = TaskMalloc16(prom32->cbBuffer);
            if (vpvBuffer16 == NULL)
            {
                STACKFREE16(vprom16, sizeof(RPCOLEMESSAGE));
                return (DWORD)E_OUTOFMEMORY;
            }

            prom16 = FIXVDMPTR(vprom16, RPCOLEMESSAGE);
            prom16->Buffer = (LPVOID) vpvBuffer16;
            lp16 = (LPVOID)WOWFIXVDMPTR(vpvBuffer16, prom32->cbBuffer);
            memcpy( lp16, prom32->Buffer, prom32->cbBuffer );
            WOWRELVDMPTR(vpvBuffer16);
            RELVDMPTR(vprom16);
        }
    }

    TO_STACK16(pti, vprom16, VPVOID);
    pti->pThop++;
    dwResult = EXECUTE_THOP3216(pti);

    prom16 = (PRPCOLEMESSAGE)FIXVDMPTR(vprom16, RPCOLEMESSAGE);
    if (prom16 == NULL)
    {
        dwResult = (DWORD)E_UNEXPECTED;
    }
    else
    {
        VPVOID vpvBuffer;

        vpvBuffer = (VPVOID)prom16->Buffer;
        RELVDMPTR(vprom16);

        if (SUCCEEDED(dwResult))
        {
            if ( prom32->Buffer != NULL )
            {
                lp16 = (LPVOID)WOWFIXVDMPTR(vpvBuffer, prom16->cbBuffer);
                if (lp16 == NULL)
                {
                    dwResult = (DWORD)E_UNEXPECTED;
                }
                else
                {
                    memcpy( prom32->Buffer, lp16, prom16->cbBuffer );

                    WOWRELVDMPTR(vpvBuffer);
                }
            }
        }

        if ( vpvBuffer16 != 0 )
        {
            // We'd better have a buffer at this point
            thkAssert( vpvBuffer != 0);

            // Free up the buffer that we've been dealing with
            TaskFree16(vpvBuffer);
        }
    }

    if ( vprom16 != 0 )
    {
        STACKFREE16(vprom16, sizeof(RPCOLEMESSAGE));
    }

    return dwResult;
}


//+---------------------------------------------------------------------------
//
//  Function:   Thop_ENUM_3216, public
//
//  Synopsis:   Thunks Enum::Next parameters
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    1-Mar-94        BobDay  Created
//
//  Notes:      This thunk is the start of a 2-byte thop.  The next thop
//              byte references a function in the enumerator table, rather
//              than the standard thop table.
//
//----------------------------------------------------------------------------

DWORD Thop_ENUM_3216(THUNKINFO *pti)
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_ENUM);
    thkAssert((*pti->pThop & THOP_IOMASK) == 0);

    //
    // Get then next thop byte and execute it as a Enum thop
    //
    pti->pThop++;
    return EXECUTE_ENUMTHOP3216(pti);
}

//+---------------------------------------------------------------------------
//
//  Function:   CallbackProcessing_3216, public
//
//  Synopsis:   Thunks IOleObject::Draw pfnContinue & DWORD parameters
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    3-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------
typedef struct tagCallbackControl
{
    DWORD   dwContinue;
    LPVOID  lpfn32;
} CALLBACKCONTROL;


STDAPI_(BOOL) CallbackProcessing_3216( DWORD dwContinue, DWORD dw1, DWORD dw2 )
{
    BOOL            fResult;
    CALLBACKCONTROL *lpcbc;
    BOOL            (*lpfn32)(DWORD);

    lpcbc = (CALLBACKCONTROL *)dwContinue;

    lpfn32 = (BOOL (*)(DWORD))lpcbc->lpfn32;

    fResult = (*lpfn32)(lpcbc->dwContinue);

    if ( fResult )      // This maps DWORD sized BOOLs into WORD sized BOOLs
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_CALLBACK_3216, public
//
//  Synopsis:   Thunks IOleObject::Draw pfnContinue & DWORD parameters
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    3-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------

DWORD Thop_CALLBACK_3216(THUNKINFO *pti)
{
    LPVOID              lpfn32;
    DWORD               dwContinue;
    CALLBACKCONTROL     cbc;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_CALLBACK);
    thkAssert((*pti->pThop & THOP_IOMASK) == 0);

    GET_STACK32(pti, lpfn32, LPVOID);
    GET_STACK32(pti, dwContinue, DWORD);

    if ( lpfn32 == 0 )
    {
        TO_STACK16(pti, NULL, VPVOID);
        TO_STACK16(pti, dwContinue, DWORD);
    }
    else
    {
        cbc.lpfn32     = lpfn32;
        cbc.dwContinue = dwContinue;

        TO_STACK16(pti, gdata16Data.fnCallbackHandler, DWORD);
        TO_STACK16(pti, (DWORD)&cbc, DWORD);
    }

    pti->pThop++;
    return EXECUTE_THOP3216(pti);
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_CLSCONTEXT_3216, public
//
//  Synopsis:   Converts a class context flags DWORD
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    29-Jun-94       DrewB   Created
//
//----------------------------------------------------------------------------

DWORD Thop_CLSCONTEXT_3216(THUNKINFO *pti)
{
    DWORD dwClsContext;

    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_CLSCONTEXT);
    thkAssert((*pti->pThop & THOP_IOMASK) == 0);

    // When passing a 32-bit class context to 16-bits nothing
    // nothing special needs to be done

    GET_STACK32(pti, dwClsContext, DWORD);
    TO_STACK16(pti, dwClsContext, DWORD);

    pti->pThop++;
    return EXECUTE_THOP3216(pti);
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_FILENAME_3216, public
//
//  Synopsis:   Converts a filename string
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    24-Aug-94       DrewB   Created
//
//----------------------------------------------------------------------------

DWORD Thop_FILENAME_3216(THUNKINFO *pti)
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_FILENAME);

    // Can be in or out only
    thkAssert((*pti->pThop & THOP_IOMASK) == THOP_IN ||
              (*pti->pThop & THOP_IOMASK) == THOP_OUT);

    if ((*pti->pThop & THOP_IN) != 0)
    {
        // Convert filenames going from 32->16 to short filenames
        // to avoid any possible problems with non-8.3 names.

        return ThunkInString3216(pti, TRUE, 0);
    }
    else
    {
        thkAssert((*pti->pThop & THOP_OUT) != 0);

        // No special processing is necessary for filenames going
        // from 16->32 since it isn't possible for 16-bit code to
        // generate a filename which can't be handled in 32-bits

        return ThunkOutString3216(pti);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_SIZEDSTRING_3216, public
//
//  Synopsis:   Converts strings which cannot exceed a given length
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    02-Sep-94       DrewB   Created
//
//----------------------------------------------------------------------------

DWORD Thop_SIZEDSTRING_3216(THUNKINFO *pti)
{
    thkAssert((*pti->pThop & THOP_OPMASK) == THOP_SIZEDSTRING);
    thkAssert((*pti->pThop & THOP_IOMASK) == THOP_IN);

    // Advance once to account for the length byte
    // ThunkInString will advance again
    pti->pThop++;
    return ThunkInString3216(pti, FALSE, *pti->pThop);
}

#define THOP_FN(x)  Thop_ ## x ## _3216

DWORD (* CONST aThopFunctions3216[])(THUNKINFO *) =
{

                                // x = Implemented
                                // ? = Mysteriously not needed
                                //   = Left to do
                                //
                                // ^
                                // |
                                // +===+
                                //     |
                                //     v
                                //
    ThunkCall3216,                  // x Terminating THOP
    Thop_ShortToLong_3216,          // x SHORTLONG
    Thop_WordToDword_3216,          // x WORDDWORD
    Thop_Copy_3216,                 // x COPY
    THOP_FN(LPSTR),                 // x LPSTR
    THOP_FN(LPLPSTR),               // x LPLPSTR
    THOP_FN(BUFFER),                // x BUFFER
    Thop_UserHandle_3216,           // x HUSER
    Thop_GdiHandle_3216,            // x HGDI
    THOP_FN(SIZE),                  // x SIZE
    THOP_FN(RECT),                  // x RECT
    THOP_FN(MSG),                   // x MSG
    THOP_FN(HRESULT),               // x HRESULT
    THOP_FN(STATSTG),               // x STATSTG
    THOP_FN(DVTARGETDEVICE),        // x DVTARGETDEVICE
    THOP_FN(STGMEDIUM),             // x STGMEDIUM
    THOP_FN(FORMATETC),             // x FORMATETC
    THOP_FN(HACCEL),                // x HACCEL
    THOP_FN(OIFI),                  // x OLEINPLACEFRAMEINFO
    THOP_FN(BINDOPTS),              // x BIND_OPTS
    THOP_FN(LOGPALETTE),            // x LOGPALETTE
    THOP_FN(SNB),                   // x SNB
    THOP_FN(CRGIID),                // x CRGIID
    Thop_ERROR_3216,                // x OLESTREAM  (only 16-bit)
    THOP_FN(HTASK),                 // x HTASK
    THOP_FN(INTERFACEINFO),         // x INTERFACEINFO
    THOP_FN(IFACE),                 // x IFACE
    THOP_FN(IFACE),                 // x IFACEOWNER
    THOP_FN(IFACE),                 // x IFACENOADDREF
    THOP_FN(IFACE),                 // x IFACECLEAN
    THOP_FN(IFACEGEN),              // x IFACEGEN
    THOP_FN(IFACEGEN),              // x IFACEGENOWNER
    THOP_FN(IFACE),                 // x UNKOUTER
    Thop_ERROR_3216,                // x UNKINNER
    Thop_ERROR_3216,                // x ROUTINE_INDEX
    THOP_FN(RETURNTYPE),            // x RETURN_TYPE
    THOP_FN(NULL),                  // x NULL
    Thop_ERROR_3216,                // x ERROR
    THOP_FN(ENUM),                  // x ENUM
    THOP_FN(CALLBACK),              // x CALLBACK
    THOP_FN(RPCOLEMESSAGE),         // x RPCOLEMESSAGE
    THOP_FN(ALIAS32),               // x ALIAS32
    THOP_FN(CLSCONTEXT),            // x CLSCONTEXT
    THOP_FN(FILENAME),              // x FILENAME
    THOP_FN(SIZEDSTRING),           // x SIZEDSTRING
};

//+---------------------------------------------------------------------------
//
//  Function:   General_Enum_3216, private
//
//  Synopsis:   Thunking for standard OLE enumerator interface ::Next member
//              function.
//
//  Arguments:  [pti] - Thunk state information
//              [uiSize32] - 32-bit information size
//              [uiSize16] - 16-bit information size
//              [pfnCallback] - Data thunking callback
//              [pfnCleanup] - Thunking cleanup
//
//  Returns:    Appropriate status code
//
//  History:    1-Mar-94        BobDay  Created
//
//  Notes:      This handler is called from many IXXXEnum::Next handlers thop
//              thunks to do the standard sorts of "buffer of structures"
//              processing.
//
//----------------------------------------------------------------------------
#define MAX_ALLOCA_STRUCT   5       // 16-bit stacks are precious

DWORD General_Enum_3216(
    THUNKINFO   *pti,
    UINT        uiSize32,
    UINT        uiSize16,
    SCODE       (*pfnCallback)( THUNKINFO *, LPVOID, VPVOID),
    void        (*pfnCleanup)( THUNKINFO *, LPVOID, VPVOID)   )
{
    DWORD       dwResult;
    ULONG       ulCount;
    VPVOID      vpstruct16;
    VPVOID      vpfetched16;
    LPVOID      lpstruct32;
    LPVOID      lpstruct32Iterate;
    VPVOID      vpstruct16Iterate;
    ULONG       *lpfetched32;
    ULONG UNALIGNED *lpfetched16;
    ULONG       ulFetched16 = 0;
    ULONG       ulIterate;
    BOOL        fError;
    SCODE       sc;
    LPVOID      pvArg32;

    dwResult = (DWORD)S_OK;

    GET_STACK32(pti, ulCount, ULONG );
    GET_STACK32(pti, lpstruct32, LPVOID );
    GET_STACK32(pti, lpfetched32, ULONG FAR *);

    vpfetched16 = STACKALLOC16(sizeof(ULONG));
    if (vpfetched16 == 0)
    {
        dwResult = (DWORD)E_OUTOFMEMORY;
    }
    else
    {
        // Zero this out so that we don't have a random value sitting
        // underneath
        // when bad apps like 16-bit MsWorks don't return the number of items
        // in the returned enumeration.

        lpfetched16  = FIXVDMPTR(vpfetched16, ULONG);
        *lpfetched16 = 0;
        RELVDMPTR(vpfetched16);
    }

    pvArg32 = NULL;
    vpstruct16 = 0;

    if ( lpstruct32 != NULL )
    {
        if ( ulCount == 0 )
        {
            dwResult = (DWORD)E_INVALIDARG;
        }
        else
        {
            if (IsBadWritePtr(lpstruct32, ulCount*uiSize32))
            {
                dwResult = (DWORD)E_INVALIDARG;
            }
            else
            {
                pvArg32 = lpstruct32;

                if ( ulCount > MAX_ALLOCA_STRUCT )
                {
                    vpstruct16 = WgtAllocLock( GMEM_MOVEABLE,
                                               ulCount * uiSize16,
                                               NULL );
                }
                else
                {
                    vpstruct16 = STACKALLOC16( ulCount * uiSize16 );
                }

                if (vpstruct16 == 0)
                {
                    dwResult = (DWORD)E_OUTOFMEMORY;
                }
            }
        }
    }

    if (SUCCEEDED(dwResult))
    {
        TO_STACK16(pti, ulCount, ULONG);
        TO_STACK16(pti, vpstruct16, VPVOID);
        TO_STACK16(pti, vpfetched16, VPVOID);

        pti->pThop++;
        dwResult = EXECUTE_THOP3216(pti);
    }

    if ( SUCCEEDED(dwResult) )
    {
        lpfetched16 = FIXVDMPTR( vpfetched16, ULONG);
        ulFetched16 = *lpfetched16;
        RELVDMPTR(vpfetched16);

        if ( lpstruct32 != NULL )
        {
            // Some apps (MsWorks3 is one) return S_FALSE and do not return
            // the number of elements retrieved.  The only thing we can
            // do is ignore the enumeration since we don't know how many
            // were actually set.  Of course, we can't ignore all enumerations
            // when the return is S_FALSE so we only handle the case
            // where S_FALSE was returned on a enumeration of one element,
            // in which we can be sure there isn't any valid data
            if (dwResult == (DWORD)S_FALSE && ulCount == 1)
            {
                ulFetched16 = 0;
            }

            //
            // Iterate through all of the structures, converting them
            // into 16-bit
            //
            fError = FALSE;
            ulIterate = 0;
            vpstruct16Iterate = vpstruct16;
            lpstruct32Iterate = lpstruct32;

            while ( ulIterate < ulFetched16 )
            {
                //
                // Callback to the callback function to do any specific
                // processing
                //
                sc = (*pfnCallback)( pti, lpstruct32Iterate,
                                     vpstruct16Iterate );

                if ( FAILED(sc) )
                {
                    fError = TRUE;
                    dwResult = sc;
                }

                vpstruct16Iterate = (VPVOID)((DWORD)vpstruct16Iterate +
                                             uiSize16);
                lpstruct32Iterate = (LPVOID)((DWORD)lpstruct32Iterate +
                                             uiSize32);

                ulIterate++;
            }

            if ( fError )
            {
                //
                // Cleanup all these guys
                //
                ulIterate = 0;
                vpstruct16Iterate = vpstruct16;
                lpstruct32Iterate = lpstruct32;

                while ( ulIterate <= ulFetched16 )
                {
                    (*pfnCleanup)( pti, lpstruct32Iterate, vpstruct16Iterate );
                    vpstruct16Iterate = (VPVOID)((DWORD)vpstruct16Iterate +
                                                 uiSize16);
                    lpstruct32Iterate = (LPVOID)((DWORD)lpstruct32Iterate +
                                                 uiSize32);

                    ulIterate++;
                }
            }
        }
    }

    if (FAILED(dwResult) && pvArg32 != NULL)
    {
        memset(pvArg32, 0, ulCount*uiSize32);
    }

    if ( lpfetched32 != NULL )
    {
        *lpfetched32 = ulFetched16;
    }

    //
    // Free up any space we've allocated
    //
    if (vpstruct16 != 0)
    {
        if ( ulCount > MAX_ALLOCA_STRUCT )
        {
            WgtUnlockFree( vpstruct16 );
        }
        else
        {
            STACKFREE16( vpstruct16, ulCount * uiSize16 );
        }
    }

    if (vpfetched16 != 0)
    {
        STACKFREE16(vpfetched16, sizeof(ULONG));
    }

    return dwResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   Callback_STRING_3216, public
//
//  Synopsis:   Prepares the LPOLESTR for the copy back into 16-bit address
//              space.
//
//  Arguments:  [pti] - Thunking state information
//              [lp32] - Pointer to 32-bit output structure
//              [lp16] - Pointer to 16-bit returned structure
//
//  Returns:    SCODE indicating success/failure
//
//  History:    1-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------

SCODE Callback_STRING_3216( THUNKINFO *pti, LPVOID lp32, VPVOID vp16 )
{
    VPSTR vpstr;

    *(LPOLESTR *)lp32 = NULL;
    vpstr = *FIXVDMPTR(vp16, VPSTR);
    RELVDMPTR(vp16);
    return ConvertTaskString1632(pti, vpstr, NULL, 0, (LPOLESTR *)lp32);
}

//+---------------------------------------------------------------------------
//
//  Function:   Cleanup_STRING_3216, public
//
//  Synopsis:   Cleans up the any STRINGs returned (either to 16-bit or 32-bit)
//
//  Arguments:  [pti] - Thunking state information
//              [lp32] - Pointer to 32-bit output structure
//              [lp16] - Pointer to 16-bit returned structure
//
//  Returns:    nothing, should NEVER fail
//
//  History:    1-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------

void Cleanup_STRING_3216( THUNKINFO *pti, LPVOID lp32, VPVOID vp16 )
{
    LPOLESTR lpstr32;

    lpstr32 = *(LPOLESTR *)lp32;
    if ( lpstr32 != NULL )
    {
        TaskFree32( lpstr32 );
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_Enum_STRING_3216, public
//
//  Synopsis:   Thunks IEnumSTRING::Next parameters
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    1-Mar-94        BobDay  Created
//
//  Notes:      This thunk is 2nd part of a 2-byte thop.
//
//----------------------------------------------------------------------------

DWORD Thop_Enum_STRING_3216(THUNKINFO *pti)
{
    return General_Enum_3216(pti,
                             sizeof(LPOLESTR),
                             sizeof(VPSTR),
                             Callback_STRING_3216,
                             Cleanup_STRING_3216 );
}

//+---------------------------------------------------------------------------
//
//  Function:   Callback_UNKNOWN_3216, public
//
//  Synopsis:   Prepares the UNKNOWN structure for the copy back into 16-bit
//              address space.
//
//  Arguments:  [pti] - Thunking state information
//              [lp32] - Pointer to 32-bit output structure
//              [lp16] - Pointer to 16-bit returned structure
//
//  Returns:    SCODE indicating success/failure
//
//  History:    1-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------

SCODE Callback_UNKNOWN_3216( THUNKINFO *pti, LPVOID lp32, VPVOID vp16 )
{
    SCODE           sc = S_OK;
    VPVOID          vpunknown16;
    IUnknown        *punkThis32;

    vpunknown16 = *FIXVDMPTR( vp16, VPVOID );
    RELVDMPTR(vp16);

    punkThis32 = pti->pThkMgr->FindProxy3216(NULL, vpunknown16, NULL,
                                             INDEX_IIDIDX(THI_IUnknown),
                                             FALSE, NULL);
    
    // Release the actual 16-bit IUnknown as it is an OUT parameter
    // This could be the last release on the interface if the
    // above call failed;
    ReleaseOnObj16(vpunknown16);

    if(!punkThis32) {
        sc = E_OUTOFMEMORY;
    }

    *(LPUNKNOWN *)lp32 = (LPUNKNOWN)punkThis32;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   Cleanup_UNKNOWN_3216, public
//
//  Synopsis:   Cleans up the any UNKNOWNs returned (either to 16-bit
//              or 32-bit)
//
//  Arguments:  [pti] - Thunking state information
//              [lp32] - Pointer to 32-bit output structure
//              [lp16] - Pointer to 16-bit returned structure
//
//  Returns:    nothing, should NEVER fail
//
//  History:    1-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------

void Cleanup_UNKNOWN_3216( THUNKINFO *pti, LPVOID lp32, VPVOID vp16 )
{
    LPUNKNOWN lpunknown32;
    VPVOID vpv;

    lpunknown32 = *(LPUNKNOWN *)lp32;
    if(lpunknown32) {
        // Release the proxy to 16-bit interface
        ReleaseProxy3216((THUNK3216OBJ *) lpunknown32);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_Enum_UNKNOWN_3216, public
//
//  Synopsis:   Thunks IEnumUNKNOWN::Next parameters
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    1-Mar-94        BobDay  Created
//
//  Notes:      This thunk is 2nd part of a 2-byte thop.
//
//----------------------------------------------------------------------------

DWORD Thop_Enum_UNKNOWN_3216(THUNKINFO *pti)
{
    return General_Enum_3216(pti,
                             sizeof(LPUNKNOWN),
                             sizeof(LPUNKNOWN),
                             Callback_UNKNOWN_3216,
                             Cleanup_UNKNOWN_3216 );
}

//+---------------------------------------------------------------------------
//
//  Function:   Callback_STATSTG_3216, public
//
//  Synopsis:   Prepares the STATSTG structure for the copy back into 16-bit
//              address space.
//
//  Arguments:  [pti] - Thunking state information
//              [lp32] - Pointer to 32-bit output structure
//              [lp16] - Pointer to 16-bit returned structure
//
//  Returns:    SCODE indicating success/failure
//
//  History:    1-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------

SCODE Callback_STATSTG_3216( THUNKINFO *pti, LPVOID lp32, VPVOID vp16 )
{
    ((STATSTG *)lp32)->pwcsName = NULL;
    return ConvertStatStg1632(pti, vp16, (STATSTG *)lp32,
                              NULL, 0);
}

//+---------------------------------------------------------------------------
//
//  Function:   Cleanup_STATSTG_3216, public
//
//  Synopsis:   Cleans up the any STATSTGs returned (either to 16-bit
//              or 32-bit)
//
//  Arguments:  [pti] - Thunking state information
//              [lp32] - Pointer to 32-bit output structure
//              [lp16] - Pointer to 16-bit returned structure
//
//  Returns:    nothing, should NEVER fail
//
//  History:    1-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------

void Cleanup_STATSTG_3216( THUNKINFO *pti, LPVOID lp32, VPVOID vp16 )
{
    STATSTG FAR     *lpstatstg32;

    lpstatstg32 = (STATSTG FAR *)lp32;

    if ( lpstatstg32->pwcsName != NULL )
    {
        TaskFree32( lpstatstg32->pwcsName );
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_Enum_STATSTG_3216, public
//
//  Synopsis:   Thunks IEnumSTATSTG::Next parameters
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    1-Mar-94        BobDay  Created
//
//  Notes:      This thunk is 2nd part of a 2-byte thop.
//
//----------------------------------------------------------------------------

DWORD Thop_Enum_STATSTG_3216(THUNKINFO *pti)
{
    return General_Enum_3216(pti,
                             sizeof(STATSTG),
                             sizeof(STATSTG),
                             Callback_STATSTG_3216,
                             Cleanup_STATSTG_3216 );
}

//+---------------------------------------------------------------------------
//
//  Function:   Callback_FORMATETC_3216, public
//
//  Synopsis:   Prepares the FORMATETC structure for the copy back into 16-bit
//              address space.
//
//  Arguments:  [pti] - Thunking state information
//              [lp32] - Pointer to 32-bit output structure
//              [lp16] - Pointer to 16-bit returned structure
//
//  Returns:    SCODE indicating success/failure
//
//  History:    1-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------

SCODE Callback_FORMATETC_3216( THUNKINFO *pti, LPVOID lp32, VPVOID vp16 )
{
    ((FORMATETC *)lp32)->ptd = NULL;
    return ConvertFetc1632(pti, vp16, (FORMATETC *)lp32, TRUE);
}

//+---------------------------------------------------------------------------
//
//  Function:   Cleanup_FORMATETC_3216, public
//
//  Synopsis:   Cleans up the any FORMATETCs returned (either to 16-bit
//              or 32-bit)
//
//  Arguments:  [pti] - Thunking state information
//              [lp32] - Pointer to 32-bit output structure
//              [lp16] - Pointer to 16-bit returned structure
//
//  Returns:    nothing, should NEVER fail
//
//  History:    1-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------

void Cleanup_FORMATETC_3216( THUNKINFO *pti, LPVOID lp32, VPVOID vp16 )
{
    FORMATETC FAR   *lpformatetc32;

    lpformatetc32 = (FORMATETC FAR *)lp32;

    if ( lpformatetc32->ptd != NULL )
    {
        TaskFree32( lpformatetc32->ptd );
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_Enum_FORMATETC_3216, public
//
//  Synopsis:   Thunks IEnumFORMATETC::Next parameters
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    1-Mar-94        BobDay  Created
//
//  Notes:      This thunk is 2nd part of a 2-byte thop.
//
//----------------------------------------------------------------------------

DWORD Thop_Enum_FORMATETC_3216(THUNKINFO *pti)
{
    return General_Enum_3216(pti,
                             sizeof(FORMATETC),
                             sizeof(FORMATETC16),
                             Callback_FORMATETC_3216,
                             Cleanup_FORMATETC_3216 );
}

//+---------------------------------------------------------------------------
//
//  Function:   Callback_STATDATA_3216, public
//
//  Synopsis:   Prepares the STATDATA structure for the copy back into 16-bit
//              address space.
//
//  Arguments:  [pti] - Thunking state information
//              [lp32] - Pointer to 32-bit output structure
//              [lp16] - Pointer to 16-bit returned structure
//
//  Returns:    SCODE indicating success/failure
//
//  History:    1-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------
SCODE Callback_STATDATA_3216( THUNKINFO *pti, LPVOID lp32, VPVOID vp16 )
{
    SCODE               sc;
    LPSTATDATA          lpstatdata32;
    STATDATA16 UNALIGNED *lpstatdata16;
    LPADVISESINK        lpadv32;
    VPVOID              vpadv16;
    IUnknown            *punkThis32;

    sc = S_OK;

    lpstatdata32 = (LPSTATDATA)lp32;

    lpstatdata16 = FIXVDMPTR( vp16, STATDATA16 );
    vpadv16 = lpstatdata16->pAdvSink;
    RELVDMPTR(vp16);

    if ( vpadv16 != 0)
    {
        // We don't know whether it's an AdviseSink or
        // an AdviseSink2, so pass AdviseSink2 since it's
        // a superset of AdviseSink and will work for both

        punkThis32 =
            pti->pThkMgr->FindProxy3216(NULL, vpadv16, NULL,
                                        INDEX_IIDIDX(THI_IAdviseSink2),
                                        FALSE, NULL);
        
        // Release the actual 16-bit IAdviseSink as it is an OUT parameter
        // This could be the last release on the interface if the
        // above call failed;
        ReleaseOnObj16(vpadv16);
        
        if(!punkThis32) {
            sc = E_OUTOFMEMORY;
        }

        lpadv32 = (LPADVISESINK)punkThis32;
    }
    else
    {
        lpadv32 = NULL;
    }

    lpstatdata32->formatetc.ptd = NULL;
    if (SUCCEEDED(sc))
    {
        // If this fails the AdviseSink proxy will be cleaned up in
        // the cleanup function later

        sc = ConvertFetc1632(pti,
                             vp16+FIELD_OFFSET(STATDATA16, formatetc),
                             &lpstatdata32->formatetc, TRUE);
    }

    if (SUCCEEDED(sc))
    {
        lpstatdata16 = FIXVDMPTR( vp16, STATDATA16 );
        lpstatdata32->advf = lpstatdata16->advf;
        lpstatdata32->pAdvSink = lpadv32;
        lpstatdata32->dwConnection = lpstatdata16->dwConnection;
        RELVDMPTR(vp16);
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   Cleanup_STATDATA_3216, public
//
//  Synopsis:   Cleans up the any STATDATAs returned (either to 16-bit
//              or 32-bit)
//
//  Arguments:  [pti] - Thunking state information
//              [lp32] - Pointer to 32-bit output structure
//              [lp16] - Pointer to 16-bit returned structure
//
//  Returns:    nothing, should NEVER fail
//
//  History:    1-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------

void Cleanup_STATDATA_3216( THUNKINFO *pti, LPVOID lp32, VPVOID vp16 )
{
    STATDATA FAR    *lpstatdata32;
    VPVOID vpvSink;

    lpstatdata32 = (STATDATA FAR *)lp32;

    if ( lpstatdata32->formatetc.ptd != NULL )
    {
        TaskFree32( lpstatdata32->formatetc.ptd );
    }

    if(lpstatdata32->pAdvSink) {
        // Release the proxy to 16-bit interface
        ReleaseProxy3216((THUNK3216OBJ *) (lpstatdata32->pAdvSink));
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_Enum_STATDATA_3216, public
//
//  Synopsis:   Thunks IEnumSTATDATA::Next parameters
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    1-Mar-94        BobDay  Created
//
//  Notes:      This thunk is 2nd part of a 2-byte thop.
//
//----------------------------------------------------------------------------

DWORD Thop_Enum_STATDATA_3216(THUNKINFO *pti)
{
    return General_Enum_3216(pti,
                             sizeof(STATDATA),
                             sizeof(STATDATA16),
                             Callback_STATDATA_3216,
                             Cleanup_STATDATA_3216 );
}

//+---------------------------------------------------------------------------
//
//  Function:   Callback_MONIKER_3216, public
//
//  Synopsis:   Prepares the MONIKER structure for the copy back into 16-bit
//              address space.
//
//  Arguments:  [pti] - Thunking state information
//              [lp32] - Pointer to 32-bit output structure
//              [lp16] - Pointer to 16-bit returned structure
//
//  Returns:    SCODE indicating success/failure
//
//  History:    1-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------

SCODE Callback_MONIKER_3216( THUNKINFO *pti, LPVOID lp32, VPVOID vp16 )
{
    VPVOID          vpmoniker16;
    IUnknown        *punkThis32;
    SCODE           sc = S_OK;

    vpmoniker16 = *FIXVDMPTR( vp16, VPVOID );
    RELVDMPTR(vp16);

    punkThis32 = pti->pThkMgr->FindProxy3216(NULL, vpmoniker16, NULL,
                                             INDEX_IIDIDX(THI_IMoniker),
                                             FALSE, NULL);
    
    // Release the actual 16-bit IMoniker as it is an OUT parameter
    // This could be the last release on the interface if the
    // above call failed;
    ReleaseOnObj16(vpmoniker16);
    
    if(!punkThis32) {
        sc = E_OUTOFMEMORY;
    }

    *(LPMONIKER *)lp32 = (LPMONIKER)punkThis32;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   Cleanup_MONIKER_3216, public
//
//  Synopsis:   Cleans up the any MONIKERs returned (either to 16-bit
//              or 32-bit)
//
//  Arguments:  [pti] - Thunking state information
//              [lp32] - Pointer to 32-bit output structure
//              [lp16] - Pointer to 16-bit returned structure
//
//  Returns:    nothing, should NEVER fail
//
//  History:    1-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------

void Cleanup_MONIKER_3216( THUNKINFO *pti, LPVOID lp32, VPVOID vp16 )
{
    LPMONIKER       lpmoniker32;
    VPVOID vpv;

    lpmoniker32 = *(LPMONIKER *)lp32;
    if(lpmoniker32) {
        // Release the proxy to 16-bit interface
        ReleaseProxy3216((THUNK3216OBJ *) lpmoniker32);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_Enum_MONIKER_3216, public
//
//  Synopsis:   Thunks IEnumMONIKER::Next parameters
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    1-Mar-94        BobDay  Created
//
//  Notes:      This thunk is 2nd part of a 2-byte thop.
//
//----------------------------------------------------------------------------

DWORD Thop_Enum_MONIKER_3216(THUNKINFO *pti)
{
    return General_Enum_3216(pti,
                             sizeof(LPMONIKER),
                             sizeof(LPMONIKER),
                             Callback_MONIKER_3216,
                             Cleanup_MONIKER_3216 );
}

//+---------------------------------------------------------------------------
//
//  Function:   Callback_OLEVERB_3216, public
//
//  Synopsis:   Prepares the OLEVERB structure for the copy back into 16-bit
//              address space.
//
//  Arguments:  [pti] - Thunking state information
//              [lp32] - Pointer to 32-bit output structure
//              [lp16] - Pointer to 16-bit returned structure
//
//  Returns:    SCODE indicating success/failure
//
//  History:    1-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------

SCODE Callback_OLEVERB_3216( THUNKINFO *pti, LPVOID lp32, VPVOID vp16 )
{
    SCODE       sc;
    OLEVERB *lpoleverb32;
    OLEVERB UNALIGNED *lpoleverb16;
    VPSTR vpstr;

    lpoleverb32 = (LPOLEVERB)lp32;

    lpoleverb16 = FIXVDMPTR(vp16, OLEVERB);
    vpstr = (VPSTR)lpoleverb16->lpszVerbName;
    RELVDMPTR(vp16);

    lpoleverb32->lpszVerbName = NULL;
    sc = ConvertTaskString1632(pti, vpstr, NULL, 0,
                               &lpoleverb32->lpszVerbName);
    if (SUCCEEDED(sc))
    {
        lpoleverb16 = FIXVDMPTR(vp16, OLEVERB);
        lpoleverb32->lVerb        = lpoleverb16->lVerb;
        lpoleverb32->fuFlags      = lpoleverb16->fuFlags;
        lpoleverb32->grfAttribs   = lpoleverb16->grfAttribs;
        RELVDMPTR(vp16);
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   Cleanup_OLEVERB_3216, public
//
//  Synopsis:   Cleans up the any OLEVERBs returned (either to 16-bit
//              or 32-bit)
//
//  Arguments:  [pti] - Thunking state information
//              [lp32] - Pointer to 32-bit output structure
//              [lp16] - Pointer to 16-bit returned structure
//
//  Returns:    nothing, should NEVER fail
//
//  History:    1-Mar-94        BobDay  Created
//
//----------------------------------------------------------------------------

void Cleanup_OLEVERB_3216( THUNKINFO *pti, LPVOID lp32, VPVOID vp16 )
{
    OLEVERB FAR     *lpoleverb32;

    lpoleverb32 = (LPOLEVERB)lp32;

    if ( lpoleverb32->lpszVerbName != NULL )
    {
        TaskFree32( lpoleverb32->lpszVerbName );
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   Thop_Enum_OLEVERB_3216, public
//
//  Synopsis:   Thunks IEnumOLEVERB::Next parameters
//
//  Arguments:  [pti] - Thunk state information
//
//  Returns:    Appropriate status code
//
//  History:    1-Mar-94        BobDay  Created
//
//  Notes:      This thunk is 2nd part of a 2-byte thop.
//
//----------------------------------------------------------------------------

DWORD Thop_Enum_OLEVERB_3216(THUNKINFO *pti)
{
    return General_Enum_3216(pti,
                             sizeof(OLEVERB),
                             sizeof(OLEVERB),
                             Callback_OLEVERB_3216,
                             Cleanup_OLEVERB_3216 );
}

#define THOP_EFN(x)  Thop_Enum_ ## x ## _3216

DWORD (*CONST aThopEnumFunctions3216[])(THUNKINFO *) =
{
    THOP_EFN(STRING),               // STRING
    THOP_EFN(UNKNOWN),              // UNKNOWN
    THOP_EFN(STATSTG),              // STATSTG
    THOP_EFN(FORMATETC),            // FORMATETC
    THOP_EFN(STATDATA),             // STATDATA
    THOP_EFN(MONIKER),              // MONIKER
    THOP_EFN(OLEVERB),              // OLEVERB
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\olethk32\thoputil.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       thoputil.cxx
//
//  Contents:   Utility routines for thunking
//
//  History:    01-Mar-94       DrewB   Created
//
//----------------------------------------------------------------------------

#include "headers.cxx"
#pragma hdrstop

#include <stdio.h>
#include <limits.h>

#include <vdmdbg.h>
#include <valid.h>

//
//  Chicago doesn't support the NT ExpLdr API, use the new Chicago
//  WOWGetDescriptor that copies the LDT info to a provided buffer.
//
#if defined(_CHICAGO_)
extern "C" WOWGetDescriptor(VPVOID, VDMLDT_ENTRY *);
#else
extern "C" DECLSPEC_IMPORT VDMLDT_ENTRY *ExpLdt;
#endif

#include "struct16.hxx"

#define CF_INVALID ((CLIPFORMAT)0)

#define OBJDESC_CF(cf) \
    ((cf) == g_cfObjectDescriptor || (cf) == g_cfLinkSourceDescriptor)

// Alias manager for THOP_ALIAS32
CAliases gAliases32;

//+---------------------------------------------------------------------------
//
//  Function:   IidToIidIdx, public
//
//  Synopsis:   Looks up an interface index by IID
//              If it's not found, it returns the IID pointer
//
//  Arguments:  [riid] - IID
//
//  Returns:    Index or IID
//
//  History:    23-Feb-94       DrewB   Created
//
//----------------------------------------------------------------------------

IIDIDX IidToIidIdx(REFIID riid)
{
    int idx;

    for (idx = 0; idx < THI_COUNT; idx++)
    {
        if (IsEqualIID(riid, *aittIidToThi[idx].piid))
        {
            return INDEX_IIDIDX(aittIidToThi[idx].iThi);
        }
    }

    return IID_IIDIDX(&riid);
}

//+---------------------------------------------------------------------------
//
//  Function:   TaskMalloc32, public
//
//  Synopsis:   Task allocation for 32-bits
//
//  History:    01-Mar-94       DrewB   Created
//
//  Notes:      Temporary until CoTaskMemAlloc is hooked up
//
//----------------------------------------------------------------------------

#ifndef COTASK_DEFINED
LPVOID TaskMalloc32(SIZE_T cb)
{
    IMalloc *pm;
    LPVOID pv;

    if (FAILED(GetScode(CoGetMalloc(MEMCTX_TASK, &pm))))
    {
        return NULL;
    }
    else
    {
        pv = pm->Alloc(cb);
        pm->Release();
    }
    return pv;
}

//+---------------------------------------------------------------------------
//
//  Function:   TaskFree32, public
//
//  Synopsis:   Task free for 32-bits
//
//  History:    01-Mar-94       DrewB   Created
//
//  Notes:      Temporary until CoTaskMemAlloc is hooked up
//
//----------------------------------------------------------------------------

void TaskFree32(LPVOID pv)
{
    IMalloc *pm;

    if (FAILED(GetScode(CoGetMalloc(MEMCTX_TASK, &pm))))
    {
        thkAssert(!"CoGetMalloc failed");
    }
    else
    {
        pm->Free(pv);
        pm->Release();
    }
}
#endif

//+---------------------------------------------------------------------------
//
//  Function:   TaskMalloc16, public
//
//  Synopsis:   Allocates 16-bit task memory
//
//  Arguments:  [uiSize] - Amount of memory to allocate
//
//  Returns:    VPVOID for memory allocated
//
//  History:    01-Mar-94       DrewB   Created
//
//----------------------------------------------------------------------------

DWORD TaskMalloc16( UINT uiSize )
{
    return CallbackTo16(gdata16Data.fnTaskAlloc, uiSize);
}

//+---------------------------------------------------------------------------
//
//  Function:   TaskFree16, public
//
//  Synopsis:   Frees 16-bit task memory
//
//  Arguments:  [vpvoid] - VPVOID of allocated memory
//
//  History:    01-Mar-94       DrewB   Created
//
//----------------------------------------------------------------------------

void TaskFree16( DWORD vpvoid )
{
    CallbackTo16(gdata16Data.fnTaskFree, vpvoid);
}

// List of 16/32 HRESULT mappings for mapping functions
struct SHrMapping
{
    HRESULT hr16;
    HRESULT hr32;
};

// Since we're including 32-bit headers in this code we can use
// the defines for the 32-bit values but we must specify the
// 16-bit values explicitly
static SHrMapping hmMappings[] =
{
    0x80000001, E_NOTIMPL,
    0x80000002, E_OUTOFMEMORY,
    0x80000003, E_INVALIDARG,
    0x80000004, E_NOINTERFACE,
    0x80000005, E_POINTER,
    0x80000006, E_HANDLE,
    0x80000007, E_ABORT,
    0x80000008, E_FAIL,
    0x80000009, E_ACCESSDENIED
};
#define NMAPPINGS (sizeof(hmMappings)/sizeof(hmMappings[0]))

#define HR16_ERROR 0x80000000
#define HR16_MAP_FIRST 1
#define HR16_MAP_LAST 9

//+---------------------------------------------------------------------------
//
//  Function:   TransformHRESULT_1632, public
//
//  Synopsis:   Translates a 16-bit hresult into a 32-bit hresult
//
//  Arguments:  [hresult] - 16-bit hresult to transform
//
//  History:    15-Mar-94   BobDay  Created
//
//----------------------------------------------------------------------------

STDAPI_(DWORD) TransformHRESULT_1632( DWORD hresult )
{
    ULONG ulIndex;

    // We only map error codes
    if (hresult & HR16_ERROR)
    {
        // The 16-bit HRESULTs to be mapped are known quantities
        // whose values are sequential, so we can map directly from
        // the value to an array index

        ulIndex = hresult & ~HR16_ERROR;
        if (ulIndex >= HR16_MAP_FIRST && ulIndex <= HR16_MAP_LAST)
        {
            // Known value, index array to find 32-bit HRESULT
            return hmMappings[ulIndex-HR16_MAP_FIRST].hr32;
        }
    }

    // No mapping found, so return the original
    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Function:   TransformHRESULT_3216, public
//
//  Synopsis:   Translates a 32-bit hresult into a 16-bit hresult
//
//  Arguments:  [hresult] - 32-bit hresult to transform
//
//  History:    15-Mar-94   BobDay  Created
//
//----------------------------------------------------------------------------

STDAPI_(DWORD) TransformHRESULT_3216( DWORD hresult )
{
    int i;
    SHrMapping *phm;

    // We don't know the true values of 32-bit HRESULTs since we're
    // using the defines and they may change, so we have to look up
    // the hard way

    phm = hmMappings;
    for (i = 0; i < NMAPPINGS; i++)
    {
        if (phm->hr32 == (HRESULT)hresult)
        {
            return phm->hr16;
        }

        phm++;
    }

    // No mapping found, so return the original
    return hresult;
}

//+---------------------------------------------------------------------------
//
//  Function:   RecordStackState, public debug
//
//  Synopsis:   Records the current state of the stack
//
//  Arguments:  [psr] - Storage space for information
//
//  Modifies:   [psr]
//
//  History:    28-Apr-94       DrewB   Created
//
//----------------------------------------------------------------------------

#if DBG == 1
void RecordStackState16(SStackRecord *psr)
{
    CStackAllocator *psa;

    psa = TlsThkGetStack16();
    psa->RecordState(psr);
}

void RecordStackState32(SStackRecord *psr)
{
    CStackAllocator *psa;

    psa = TlsThkGetStack32();
    psa->RecordState(psr);
}
#endif

//+---------------------------------------------------------------------------
//
//  Function:   CheckStackState, public debug
//
//  Synopsis:   Checks recorded information about the stack against its
//              current state
//
//  Arguments:  [psr] - Recorded information
//
//  History:    28-Apr-94       DrewB   Created
//
//----------------------------------------------------------------------------

#if DBG == 1
void CheckStackState16(SStackRecord *psr)
{
    CStackAllocator *psa;

    psa = TlsThkGetStack16();
    psa->CheckState(psr);
}

void CheckStackState32(SStackRecord *psr)
{
    CStackAllocator *psa;

    psa = TlsThkGetStack32();
    psa->CheckState(psr);
}
#endif

//+---------------------------------------------------------------------------
//
//  Function:   Convert_VPSTR_to_LPOLESTR
//
//  Synopsis:   Converts 16-bit VPSTR to 32-bit LPOLESTR pointer
//
//  Arguments:  [vpstr] - VPSTR
//              [lpOleStr] - OLESTR
//              [uiSizeInPlace] - Amount of data available in [lpOleStr]
//                      for in-place conversion (in characters, not bytes)
//                      including nul
//
//  Returns:    Pointer to LPOLESTR with data
//
//  History:    24-Feb-94       BobDay  Created
//
//----------------------------------------------------------------------------

LPOLESTR Convert_VPSTR_to_LPOLESTR(
    THUNKINFO   *pti,
    VPSTR       vpstr,
    LPOLESTR    lpOleStr,
    UINT        uiSizeInPlace
)
{
    LPSTR       lpstr;
    UINT        uiSize;
    LPOLESTR    lpOleStrResult;
    UINT        cChars;

    // We shouldn't be calling here for null strings
    thkAssert( vpstr != NULL );

    lpstr = GetStringPtr16(pti, vpstr, CCHMAXSTRING, &uiSize);
    if ( lpstr == NULL )
    {
        //
        // GetStringPtr will have filled in the pti->scResult
        //
        return( NULL );
    }

    // The string has to have at least one character in it
    // because it must be null-terminated to be valid
    thkAssert(uiSize > 0);

    lpOleStrResult = lpOleStr;

    if ( uiSize > uiSizeInPlace )
    {
        lpOleStrResult = (LPOLESTR)TaskMalloc32(uiSize*sizeof(OLECHAR));
        if (lpOleStrResult == NULL)
        {
            pti->scResult = E_OUTOFMEMORY;
            return NULL;
        }
    }

    cChars = MultiByteToWideChar( AreFileApisANSI() ? CP_ACP : CP_OEMCP,
                                  0,
                                  lpstr,
                                  uiSize,
                                  lpOleStrResult,
                                  uiSize );

    WOWRELVDMPTR(vpstr);

    if ( cChars == 0 )
    {
        if (lpOleStrResult != lpOleStr)
        {
            TaskFree32(lpOleStrResult);
        }

        pti->scResult = E_UNEXPECTED;
        return( NULL );
    }
    else
    {
        return( lpOleStrResult );
    }
}
//+---------------------------------------------------------------------------
//
//  Function:   Convert_LPOLESTR_to_VPSTR
//
//  Synopsis:   Converts 32-bit LPOLESTR to 16-bit VPSTR pointer
//
//  Arguments:  [lpOleStr] - OLESTR
//              [vpstr] - VPSTR
//              [uiSize32] - Length of OLESTR in characters (not bytes)
//                      including nul
//              [uiSize16] - Byte length of buffer referred to by VPSTR
//
//  Returns:    Appropriate status code
//
//  History:    24-Feb-94       BobDay  Created
//
//  Notes:      Always converts in place
//
//----------------------------------------------------------------------------

SCODE Convert_LPOLESTR_to_VPSTR(
    LPCOLESTR    lpOleStr,
    VPSTR       vpstr,
    UINT        uiSize32,
    UINT        uiSize16
)
{
    LPSTR       lpstr;
    UINT        cChars;
    SCODE       sc;

    sc = S_OK;

    lpstr = (LPSTR)WOWFIXVDMPTR(vpstr, uiSize16);

    cChars = WideCharToMultiByte( AreFileApisANSI() ? CP_ACP : CP_OEMCP,
                                  0,
                                  lpOleStr,
                                  uiSize32,
                                  lpstr,
                                  uiSize16,
                                  NULL,
                                  NULL );

    if ( cChars == 0 && uiSize32 != 0 )
    {
        sc = E_UNEXPECTED;
    }

    WOWRELVDMPTR(vpstr);

    return sc;
}
#ifdef _CHICAGO_
//+---------------------------------------------------------------------------
//
//  Function:   Convert_LPSTR_to_VPSTR
//
//  Synopsis:   Converts 32-bit LPSTR to 16-bit VPSTR pointer
//
//  Arguments:  [lpOleStr] - LPSTR
//              [vpstr] - VPSTR
//              [uiSize32] - Length of LPSTR in bytes including nul
//              [uiSize16] - Byte length of buffer referred to by VPSTR
//
//  Returns:    Appropriate status code
//
//  History:    10-21-95 KevinRo Created
//
//  Notes:
//
//----------------------------------------------------------------------------

SCODE Convert_LPSTR_to_VPSTR(
    LPCSTR	lpOleStr,
    VPSTR       vpstr,
    UINT        uiSize32,
    UINT        uiSize16
)
{
    LPSTR       lpstr;

    lpstr = (LPSTR)WOWFIXVDMPTR(vpstr, uiSize16);

    memcpy(lpstr,lpOleStr,uiSize32);

    WOWRELVDMPTR(vpstr);

    return S_OK;
}
#endif // _CHICAGO_

// Selector bit constants
#define SEL_TI          0x0004
#define SEL_RPL         0x0003
#define SEL_INDEX       0xfff8

#define IS_LDT_SELECTOR(sel) (((sel) & SEL_TI) == SEL_TI)

// LDT bit constants
#define LTYPE_APP       0x0010
#define LTYPE_CODE      0x0008
#define LTYPE_CREAD     0x0002
#define LTYPE_DDOWN     0x0004
#define LTYPE_DWRITE    0x0002

// Pointer access types, or'able
// Defined to be the same as thop in/out so that no translation
// is necessary for checks on thop memory access
#define PACC_READ       THOP_IN
#define PACC_WRITE      THOP_OUT
#define PACC_CODE       1           // Special for CODE PTRs

// Information about a VDM pointer
typedef struct _VPTRDESC
{
    BYTE *pbFlat;
    DWORD dwLengthLeft;
} VPTRDESC;

// VDM memory is always zero-based on Win95
#ifndef _CHICAGO_
DWORD dwBaseVDMMemory = 0xFFFFFFFF;
#else
#define dwBaseVDMMemory 0
#endif

// Extended success returns from GetPtr16Description
#define S_GDTENTRY      MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_NULL, 1)
#define S_SYSLDTENTRY   MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_NULL, 2)

//+---------------------------------------------------------------------------
//
//  Function:   GetPtr16Description, public
//
//  Synopsis:   Validates access for a VDM pointer and returns
//              information about it
//              Also forces not-present segments into memory by
//              touching them
//
//  Arguments:  [vp] - VDM pointer
//              [grfAccess] - Desired access
//              [dwSize] - Desired size of access, must be >= 1
//              [pvpd] - VPTRDESC out
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pvpd]
//
//  History:    26-Apr-94       DrewB   Created
//
//  Notes:      Returns fixed memory
//
//----------------------------------------------------------------------------

SCODE GetPtr16Description(VPVOID vp,
                          WORD grfAccess,
                          DWORD dwSize,
                          VPTRDESC *pvpd)
{
    VDMLDT_ENTRY *vle;
#if defined(_CHICAGO_)
    VDMLDT_ENTRY LdtEntry;
#endif
    WORD wSel;
    WORD wOff;
    DWORD dwLength;

    thkAssert(vp != 0);
    thkAssert(dwSize > 0);
    thkAssert(grfAccess != 0);

    wSel = (WORD)(vp >> 16);
    wOff = (WORD)(vp & 0xffff);

    pvpd->dwLengthLeft = 0xffff-wOff+1;     // Default length remaining

    if (!IS_LDT_SELECTOR(wSel))
    {
        // According to the WOW developers, the only GDT selector
        // is for the BIOS data area so we should never see one

        thkDebugOut((DEB_ERROR, "GDT selector: 0x%04X\n", wSel));

        // Handle it just in case
        pvpd->pbFlat = (BYTE *)WOWFIXVDMPTR(vp, dwSize);

        return S_GDTENTRY;
    }

#if defined(_CHICAGO_)
    vle = &LdtEntry;
    if (!WOWGetDescriptor(vp, vle))
    {
        return E_INVALIDARG;
    }
#else
    vle = (VDMLDT_ENTRY *)((BYTE *)(ExpLdt)+(wSel & SEL_INDEX));
#endif

    if ((vle->HighWord.Bits.Type & LTYPE_APP) == 0)
    {
        // According to the WOW developers, they don't use
        // system segments so we should never see one

        thkDebugOut((DEB_ERROR, "System descriptor: 0x%04X\n", wSel));

        // Handle it just in case
        pvpd->pbFlat = (BYTE *)WOWFIXVDMPTR(vp, dwSize);

        return S_SYSLDTENTRY;
    }

    // Do as much up-front validation as possible
    // Since the segment may not be present, we are restricted to
    // only checking the access permissions

    if (vle->HighWord.Bits.Type & LTYPE_CODE)
    {
        // Validate access for code segments
        // Code segments are never writable

        if (((grfAccess & PACC_READ) &&
             (vle->HighWord.Bits.Type & LTYPE_CREAD) == 0) ||
            (grfAccess & PACC_WRITE))
        {
            return E_INVALIDARG;
        }
    }
    else
    {
        // Validate access for data segments
        // Data segments are always readable never executable

        if (((grfAccess & PACC_WRITE) &&
             (vle->HighWord.Bits.Type & LTYPE_DWRITE) == 0) ||
             (grfAccess & PACC_CODE))
        {
            return E_INVALIDARG;
        }
    }

    // Bring in segment if it's not present
    if (!vle->HighWord.Bits.Pres)
    {
        // We've validated access permissions and segments must
        // always be at least one byte long so it's safe to
        // touch the first byte to bring it in

        // On Win95, this will call GlobalFix on the pointer
        // to ensure that it stays in memory
        WOWCallback16(gdata16Data.fnTouchPointer16, vp);

#if defined(_CHICAGO_)
        // Since we only copy the descriptor, recopy it now.
        WOWGetDescriptor(vp, vle);
#endif

        thkAssert(vle->HighWord.Bits.Pres);
    }
#ifdef _CHICAGO_
    else
    {
        // Lock the LDT entry (as best as we can) by fixing it
        // This prevents global blocks from being relocated during
        // heap compaction
        WOWGetVDMPointerFix(vp, dwSize, TRUE);
    }
#endif


    dwLength = ((DWORD)vle->LimitLow |
                ((DWORD)vle->HighWord.Bits.LimitHi << 16))+1;
    if (vle->HighWord.Bits.Granularity)
    {
        // 4K granularity
        dwLength <<= 12;
    }

    if ((vle->HighWord.Bits.Type & LTYPE_CODE) ||
        (vle->HighWord.Bits.Type & LTYPE_DDOWN) == 0)
    {
        // Validate length for code and normal data segments

        if (wOff+dwSize > dwLength)
        {
            WOWRELVDMPTR(vp);
            return E_INVALIDARG;
        }

        pvpd->dwLengthLeft = dwLength-wOff;
    }
    else
    {
        // Expand-down segment

        if (wOff < dwLength)
        {
            WOWRELVDMPTR(vp);
            return E_INVALIDARG;
        }

        // Check for wraparound

        if (vle->HighWord.Bits.Granularity)
        {
            // Compiler - This should be +1, but
            // the compiler generates a warning about an overflow
            // in constant arithmetic
            pvpd->dwLengthLeft = 0xffffffff-wOff;
        }

        if (dwSize > pvpd->dwLengthLeft)
        {
            WOWRELVDMPTR(vp);
            return E_INVALIDARG;
        }
    }

    // VDM memory is always zero-based on Win95
#ifndef _CHICAGO_
    if ( dwBaseVDMMemory == 0xFFFFFFFF )
    {
        dwBaseVDMMemory = (DWORD)WOWGetVDMPointer(0, 0, FALSE);
    }
#endif

    // Translate the pointer even on Win95 because forcing the segment
    // present may have changed its address
    pvpd->pbFlat = (BYTE *)(dwBaseVDMMemory +
                            wOff +
                            (  (DWORD)vle->BaseLow |
                             ( (DWORD)vle->HighWord.Bytes.BaseMid << 16) |
                             ( (DWORD)vle->HighWord.Bytes.BaseHi  << 24) ) );

#if DBG == 1
    if (pvpd->pbFlat != WOWGetVDMPointer(vp, dwSize, TRUE))
    {
        thkDebugOut((DEB_ERROR, "GetPtr16Description: "
                     "%p computed, %p system\n",
                     pvpd->pbFlat, WOWGetVDMPointer(vp, dwSize, TRUE)));
    }
#endif

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   GetReadPtr16
//
//  Synopsis:   Validates a 16-bit pointer for reading and converts it into
//              a flat 32 pointer.
//
//  Arguments:  [pti] - THUNKINFO * for updating error code
//              [vp] - 16-bit pointer to validate/convert
//              [dwSize] - Length to validate
//
//  Returns:    Appropriate status code
//
//  History:    22-Mar-94   BobDay  Created
//
//----------------------------------------------------------------------------

VOID  *
GetReadPtr16(
    THUNKINFO   *pti,
    VPVOID      vp,
    DWORD       dwSize )
{
    VPTRDESC vpd;
    SCODE sc;

    sc = GetPtr16Description(vp, PACC_READ, dwSize, &vpd);
    if (FAILED(sc))
    {
        pti->scResult = sc;
        return NULL;
    }
    else
    {
        return vpd.pbFlat;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   GetWritePtr16
//
//  Synopsis:   Validates a 16-bit pointer for writing and converts it into
//              a flat 32 pointer.
//
//  Arguments:  [pti] - THUNKINFO * for updating error code
//              [vp] - 16-bit pointer to validate/convert
//              [dwSize] - Length to validate
//
//  Returns:    Appropriate status code
//
//  History:    22-Mar-94   BobDay  Created
//
//----------------------------------------------------------------------------

VOID  *
GetWritePtr16(
    THUNKINFO   *pti,
    VPVOID      vp,
    DWORD       dwSize )
{
    VPTRDESC vpd;
    SCODE sc;

    sc = GetPtr16Description(vp, PACC_WRITE, dwSize, &vpd);
    if (FAILED(sc))
    {
        pti->scResult = sc;
        return NULL;
    }
    else
    {
        return vpd.pbFlat;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   GetCodePtr16
//
//  Synopsis:   Validates a 16-bit pointer for execution and converts it
//              into a flat 32 pointer.
//
//  Arguments:  [pti] - THUNKINFO * for updating error code
//              [vp] - 16-bit pointer to validate/convert
//              [dwSize] - Length to validate
//
//  Returns:    Appropriate status code
//
//  History:    22-Jul-94   BobDay  Created
//
//----------------------------------------------------------------------------

VOID  *
GetCodePtr16(
    THUNKINFO   *pti,
    VPVOID      vp,
    DWORD       dwSize )
{
    VPTRDESC vpd;
    SCODE sc;

    sc = GetPtr16Description(vp, PACC_CODE, dwSize, &vpd);
    if (FAILED(sc))
    {
        pti->scResult = sc;
        return NULL;
    }
    else
    {
        return vpd.pbFlat;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   GetReadWritePtr16
//
//  Synopsis:   Validates a 16-bit pointer for reading and writing and
//              converts it into a flat 32 pointer.
//
//  Arguments:  [pti] - THUNKINFO * for updating error code
//              [vp] - 16-bit pointer to validate/convert
//              [dwSize] - Length to validate
//
//  Returns:    Appropriate status code
//
//  History:    22-Mar-94   BobDay  Created
//
//----------------------------------------------------------------------------

VOID  *
GetReadWritePtr16(
    THUNKINFO   *pti,
    VPVOID      vp,
    DWORD       dwSize )
{
    VPTRDESC vpd;
    SCODE sc;

    sc = GetPtr16Description(vp, PACC_READ | PACC_WRITE, dwSize, &vpd);
    if (FAILED(sc))
    {
        pti->scResult = sc;
        return NULL;
    }
    else
    {
        return vpd.pbFlat;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   GetStringPtr16
//
//  Synopsis:   Validates a 16-bit pointer to a string for reading and
//              converts it (the pointer) into a flat 32 pointer. It also
//              returns the length, since it has to compute it anyway.
//
//  Arguments:  [pti] - THUNKINFO * for updating error code
//              [vp] - 16-bit pointer to validate/convert
//              [cchMax] - Maximum legal length
//              [lpSize] - Place to return length
//
//  Returns:    Appropriate status code
//
//  History:    22-Mar-94   BobDay  Created
//
//----------------------------------------------------------------------------

CHAR  *
GetStringPtr16(
    THUNKINFO   *pti,
    VPSTR       vp,
    UINT        cchMax,
    PUINT       lpSize )
{
    VPTRDESC vpd;
    SCODE sc;

    // Check the first byte to ensure read access to the segment
    sc = GetPtr16Description(vp, PACC_READ, 1, &vpd);
    if (FAILED(sc))
    {
        pti->scResult = sc;
        return NULL;
    }
    else
    {
        UINT cchLen;
        BYTE *pb;
        BOOL fMbLead;

        pb = vpd.pbFlat;

        if (pb == NULL)
        {
            goto Exit;
        }


        // Restrict zero-termination search to cchMax characters
        // or valid remaining memory
        // Since we specified one in GetPtr16Description, dwLengthLeft
        // is one off here
        cchMax = min(cchMax, vpd.dwLengthLeft+1);

        cchLen = 0;
        fMbLead = FALSE;
        while (cchMax > 0)
        {
            cchLen++;

            if (*pb == 0 && !fMbLead)
            {
                break;
            }
            else
            {
                fMbLead = (BOOL)g_abLeadTable[*pb++];
                cchMax--;
            }
        }

        if (cchMax > 0)
        {
            *lpSize = cchLen;
            return (LPSTR)vpd.pbFlat;
        }

Exit:
        {
            pti->scResult = E_INVALIDARG;
            WOWRELVDMPTR(vp);
            return NULL;
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   ValidatePtr16, public
//
//  Synopsis:   Calls an appropriate validation routine for 16-bit
//              memory based on in/out status
//
//  Arguments:  [pti] - Thunk info, can be NULL for no validation
//              [vp16] - 16-bit pointer
//              [dwSize] - Size
//              [thopInOut] - In/out type
//
//  Returns:    Pointer or NULL
//
//  Modifies:   [pti]->scResult for errors
//
//  History:    24-Apr-94       DrewB   Created
//
//  Notes:      0 - No validation
//              THOP_IN - Read validation
//              THOP_OUT - Write validation
//              THOP_INOUT - Read/write validation
//
//----------------------------------------------------------------------------

VOID  *
ValidatePtr16(THUNKINFO *pti,
                     VPVOID vp16,
                     DWORD dwSize,
                     THOP thopInOut)
{
    VPTRDESC vpd;
    SCODE sc;

    thopInOut &= THOP_INOUT;
    if (thopInOut != 0)
    {
        sc = GetPtr16Description(vp16, thopInOut, dwSize, &vpd);
        if (FAILED(sc))
        {
            pti->scResult = sc;
            return NULL;
        }
        else
        {
            return vpd.pbFlat;
        }
    }
    else
    {
        return WOWFIXVDMPTR(vp16, dwSize);
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   IsValidInterface16, public
//
//  Synopsis:   Validates that a provided 16-bit interface is really valid
//              (uses the same validation technique as 16-bit OLE 2.01)
//
//  Arguments:  [pti] - Thunk info, can be NULL for no validation
//              [vp16] - 16-bit pointer
//
//  Returns:    BOOL - true for valid, false for invalid
//
//  Modifies:   [pti]->scResult for errors
//
//  History:    22-Jul-92       BobDay      Created
//
//----------------------------------------------------------------------------

BOOL IsValidInterface16( THUNKINFO *pti, VPVOID vp )
{
    VPVOID UNALIGNED *pvpv;
    VPVOID  vpvtbl;
    VPVOID  vpfn;
    LPVOID  lpfn;

    //
    // Make sure we can read the vtbl pointer from the object.
    //
    pvpv = (VPVOID FAR *)GetReadPtr16(pti, vp, sizeof(VPVOID));
    if ( pvpv == NULL )
    {
        thkDebugOut((DEB_WARN, "IsValidInterface16: "
                     "Interface ptr invalid %p\n", vp));
        return FALSE;
    }

    vpvtbl = *pvpv;     // Read the vtbl ptr

    WOWRELVDMPTR(vp);

    // Make sure we can read the first entry from the vtbl (QI)

    pvpv = (VPVOID FAR *)GetReadPtr16(pti, vpvtbl, sizeof(VPVOID));
    if ( pvpv == NULL )
    {
        thkDebugOut((DEB_WARN, "Vtbl ptr invalid %p:%p\n", vp, vpvtbl));
        return FALSE;
    }

    vpfn = *pvpv;           // Get the QI Function

    WOWRELVDMPTR(vpvtbl);

    if ( vpfn == 0 )
    {
        thkDebugOut((DEB_WARN, "QI function NULL %p:%p\n", vp, vpvtbl));
        pti->scResult = E_INVALIDARG;
        return FALSE;
    }

    // Why it has to be 9 bytes long, I have no idea.
    // This check was taken from valid.cpp in
    // \src\ole2\dll\src\debug the 16-bit ole2.01
    // sources...
    lpfn = (LPVOID)GetCodePtr16(pti, vpfn, 9);

    WOWRELVDMPTR(vpfn);

    if ( lpfn == NULL )
    {
        thkDebugOut((DEB_WARN, "QI function ptr invalid %p:%p:%p\n",
                     vp,vpvtbl,vpfn));
        return FALSE;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   GuidString, debug public
//
//  Synopsis:   Converts a guid to a string
//
//  Arguments:  [pguid] - GUID
//
//  Returns:    Pointer to string
//
//  History:    08-Mar-94       DrewB   Created
//
//  Notes:      Uses a static buffer
//
//----------------------------------------------------------------------------

#if DBG == 1

#pragma pack(1)
struct SplitGuid
{
    DWORD dw1;
    WORD w1;
    WORD w2;
    BYTE b[8];
};
#pragma pack()

char *GuidString(GUID const *pguid)
{
    static char ach[39];
    SplitGuid *psg = (SplitGuid *)pguid;

    wsprintfA(ach, "{%08lX-%04hX-%04hX-%02X%02X-%02X%02X%02X%02X%02X%02X}",
            psg->dw1, psg->w1, psg->w2, psg->b[0], psg->b[1], psg->b[2],
            psg->b[3], psg->b[4], psg->b[5], psg->b[6], psg->b[7]);
    return ach;
}

#endif

#if DBG == 1
 char *apszThopNames[] =
{
    "THOP_END",
    "THOP_SHORTLONG",
    "THOP_WORDDWORD",
    "THOP_COPY",
    "THOP_LPSTR",
    "THOP_LPLPSTR",
    "THOP_BUFFER",
    "THOP_HUSER",
    "THOP_HGDI",
    "THOP_SIZE",
    "THOP_RECT",
    "THOP_MSG",
    "THOP_HRESULT",
    "THOP_STATSTG",
    "THOP_DVTARGETDEVICE",
    "THOP_STGMEDIUM",
    "THOP_FORMATETC",
    "THOP_HACCEL",
    "THOP_OIFI",
    "THOP_BINDOPTS",
    "THOP_LOGPALETTE",
    "THOP_SNB",
    "THOP_CRGIID",
    "THOP_OLESTREAM",
    "THOP_HTASK",
    "THOP_INTERFACEINFO",
    "THOP_IFACE",
    "THOP_IFACEOWNER",
    "THOP_IFACENOADDREF",
    "THOP_IFACECLEAN",
    "THOP_IFACEGEN",
    "THOP_IFACEGENOWNER",
    "THOP_UNKOUTER",
    "THOP_UNKINNER",
    "THOP_ROUTINEINDEX",
    "THOP_RETURNTYPE",
    "THOP_NULL",
    "THOP_ERROR",
    "THOP_ENUM",
    "THOP_CALLBACK",
    "THOP_RPCOLEMESSAGE",
    "THOP_ALIAS32",
    "THOP_CLSCONTEXT",
    "THOP_FILENAME",
    "THOP_SIZEDSTRING"
};
#endif

//+---------------------------------------------------------------------------
//
//  Function:   ThopName, debug public
//
//  Synopsis:   Returns the string name of a thop
//
//  Arguments:  [thop] - Thop
//
//  Returns:    Pointer to string
//
//  History:    11-Mar-94       DrewB   Created
//
//  Notes:      Uses a static buffer
//
//----------------------------------------------------------------------------

#if DBG == 1
char *ThopName(THOP thop)
{
    static char achString[80];
    char *psz;

    thkAssert((thop & THOP_OPMASK) < THOP_LASTOP);
    thkAssert(THOP_LASTOP ==
              (sizeof(apszThopNames)/sizeof(apszThopNames[0])));

    strcpy(achString, apszThopNames[thop & THOP_OPMASK]);

    psz = achString+strlen(achString);
    if (thop & THOP_IN)
    {
        strcpy(psz, " | THOP_IN");
        psz += strlen(psz);
    }
    if (thop & THOP_OUT)
    {
        strcpy(psz, " | THOP_OUT");
    }

    return achString;
}
#endif

#if DBG == 1
 char *apszEnumThopNames[] =
{
    "STRING",
    "UNKNOWN",
    "STATSTG",
    "FORMATETC",
    "STATDATA",
    "MONIKER",
    "OLEVERB"
};
#endif

//+---------------------------------------------------------------------------
//
//  Function:   EnumThopName, debug public
//
//  Synopsis:   Returns the string name of an enum thop
//
//  Arguments:  [thopEnum] - Thop
//
//  Returns:    Pointer to string
//
//  History:    11-Mar-94       DrewB   Created
//
//----------------------------------------------------------------------------

#if DBG == 1
char *EnumThopName(THOP thopEnum)
{
    thkAssert(thopEnum <
              (sizeof(apszEnumThopNames)/sizeof(apszEnumThopNames[0])));
    return apszEnumThopNames[thopEnum];
}
#endif

#if DBG == 1
// Maintain current thunking invocation nesting level
int _iThunkNestingLevel = 1;
#endif

//+---------------------------------------------------------------------------
//
//  Function:   NestingSpaces, debug public
//
//  Synopsis:   Spaces for each nesting level
//
//  History:    22-Mar-94       DrewB   Created
//
//----------------------------------------------------------------------------

#if DBG == 1

#define NESTING_SPACES 32
#define SPACES_PER_LEVEL 2

static char achSpaces[NESTING_SPACES+1] = "                                ";

void NestingSpaces(char *psz)
{
    int iSpaces, i;

    iSpaces = _iThunkNestingLevel*SPACES_PER_LEVEL;

    while (iSpaces > 0)
    {
        i = min(iSpaces, NESTING_SPACES);
        memcpy(psz, achSpaces, i);
        psz += i;
        *psz = 0;
        iSpaces -= i;
    }
}
#endif

//+---------------------------------------------------------------------------
//
//  Function:   NestingLevelString, debug public
//
//  Synopsis:   Provides a string describing the nesting level
//
//  History:    22-Mar-94       DrewB   Created
//
//  Notes:      Uses a static buffer
//
//----------------------------------------------------------------------------

#if DBG == 1
char *NestingLevelString(void)
{
    static char ach[256];
    char *psz;

    if ((thkInfoLevel & DEB_NESTING) == 0)
    {
        return "";
    }

    wsprintfA(ach, "%2d:", _iThunkNestingLevel);
    psz = ach+strlen(ach);

    if (sizeof(ach)/SPACES_PER_LEVEL <= _iThunkNestingLevel)
    {
        strcpy(psz, "...");
    }
    else
    {
        NestingSpaces(psz);
    }
    return ach;
}
#endif

//+---------------------------------------------------------------------------
//
//  Function:   IidOrInterfaceString, debug public
//
//  Synopsis:   Returns the interface name for known interfaces or
//              the IID string itself
//
//  Arguments:  [piid] - IID
//
//  Returns:    char *
//
//  History:    18-Jun-94       DrewB   Created
//
//----------------------------------------------------------------------------

#if DBG == 1
char *IidOrInterfaceString(IID const *piid)
{
    return IidIdxString(IidToIidIdx(*piid));
}
#endif

//+---------------------------------------------------------------------------
//
//  Function:   IidIdxString, debug public
//
//  Synopsis:   Returns the interface name for known interfaces or
//              the IID string itself
//
//  Arguments:  [iidx] - IID or index
//
//  Returns:    char *
//
//  History:    07-Jul-94       DrewB   Created
//
//----------------------------------------------------------------------------

#if DBG == 1
char *IidIdxString(IIDIDX iidx)
{
    if (IIDIDX_IS_IID(iidx))
    {
        return GuidString(IIDIDX_IID(iidx));
    }
    else if (IIDIDX_INDEX(iidx) == THI_COUNT)
    {
        // Special case here because of IMalloc's unusual unthunked-
        // but-indexed existence
        return "IMalloc";
    }
    else
    {
        return inInterfaceNames[IIDIDX_INDEX(iidx)].pszInterface;
    }
}
#endif

//+---------------------------------------------------------------------------
//
//  Function:   Handler routines, public
//
//  Synopsis:   Generic conversion routines for the generic thop handler
//
//  Arguments:  [pbFrom] - Data to convert from
//              [pbTo] - Buffer to convert into
//              [cbFrom] - Size of source data
//              [cbTo] - Size of destination data
//
//  History:    05-Apr-94       DrewB   Created
//
//----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Function:   FhCopyMemory, public
//
//  Synopsis:   Handler routine for memory copies
//
//  History:    05-Apr-94       DrewB   Created
//
//----------------------------------------------------------------------------

void FhCopyMemory(BYTE *pbFrom, BYTE *pbTo, UINT cbFrom, UINT cbTo)
{
    thkAssert(cbFrom == cbTo);

    memcpy(pbTo, pbFrom, cbFrom);

#if DBG == 1
    if (cbFrom == sizeof(DWORD))
    {
        thkDebugOut((DEB_ARGS, "Arg     DWORD: 0x%08lX\n",
                *(DWORD UNALIGNED *)pbFrom));
    }
    else if (cbFrom == sizeof(LARGE_INTEGER))
    {
        thkDebugOut((DEB_ARGS, "Arg     8 byte: 0x%08lX:%08lX\n",
                     *(DWORD UNALIGNED *)(pbFrom+1*sizeof(DWORD)),
                     *(DWORD UNALIGNED *)(pbFrom+0*sizeof(DWORD))));
    }
    else if (cbFrom == sizeof(GUID))
    {
        thkDebugOut((DEB_ARGS, "Arg     16 byte: 0x%08lX:%08lX:%08lX:%08lX\n",
                     *(DWORD UNALIGNED *)(pbFrom+3*sizeof(DWORD)),
                     *(DWORD UNALIGNED *)(pbFrom+2*sizeof(DWORD)),
                     *(DWORD UNALIGNED *)(pbFrom+1*sizeof(DWORD)),
                     *(DWORD UNALIGNED *)(pbFrom+0*sizeof(DWORD))));
    }
    else
    {
        thkDebugOut((DEB_ARGS, "Arg     %d byte copy\n", cbFrom));
    }
#endif
}

//+---------------------------------------------------------------------------
//
//  Function:   FhShortToLong, FhLongToShort, public
//
//  Synopsis:   Signed int conversion
//
//  History:    05-Apr-94       DrewB   Created
//
//----------------------------------------------------------------------------

void FhShortToLong(BYTE *pbFrom, BYTE *pbTo, UINT cbFrom, UINT cbTo)
{
    thkAssert(cbFrom == sizeof(SHORT));
    thkAssert(cbTo == sizeof(LONG));

    *(LONG UNALIGNED *)pbTo = (LONG)*(SHORT UNALIGNED *)pbFrom;

    thkDebugOut((DEB_ARGS, "ShToLo  %d -> %d\n",
                 *(SHORT UNALIGNED *)pbFrom, *(LONG UNALIGNED *)pbTo));
}

void FhLongToShort(BYTE *pbFrom, BYTE *pbTo, UINT cbFrom, UINT cbTo)
{
    thkAssert(cbFrom == sizeof(LONG));
    thkAssert(cbTo == sizeof(SHORT));

    // Not used in situations where clamping is meaningful
    *(SHORT UNALIGNED *)pbTo = (SHORT)*(LONG UNALIGNED *)pbFrom;

    thkDebugOut((DEB_ARGS, "LoToSh  %d -> %d\n",
                 *(LONG UNALIGNED *)pbFrom, *(SHORT UNALIGNED *)pbTo));
}

//+---------------------------------------------------------------------------
//
//  Function:   FhWordToDword, FhDwordToWord, public
//
//  Synopsis:   Handler routine for memory copies
//
//  History:    05-Apr-94       DrewB   Created
//
//----------------------------------------------------------------------------

void FhWordToDword(BYTE *pbFrom, BYTE *pbTo, UINT cbFrom, UINT cbTo)
{
    thkAssert(cbFrom == sizeof(WORD));
    thkAssert(cbTo == sizeof(DWORD));

    *(DWORD UNALIGNED *)pbTo = (DWORD)*(WORD UNALIGNED *)pbFrom;

    thkDebugOut((DEB_ARGS, "WoToDw  0x%04lX -> 0x%08lX\n",
                 *(WORD UNALIGNED *)pbFrom, *(DWORD UNALIGNED *)pbTo));
}

void FhDwordToWord(BYTE *pbFrom, BYTE *pbTo, UINT cbFrom, UINT cbTo)
{
    thkAssert(cbFrom == sizeof(DWORD));
    thkAssert(cbTo == sizeof(WORD));

    // Not used in situations where clamping is meaningful
    *(WORD UNALIGNED *)pbTo = (WORD)*(DWORD UNALIGNED *)pbFrom;

    thkDebugOut((DEB_ARGS, "DwToWo  0x%08lX -> 0x%04lX\n",
                 *(DWORD UNALIGNED *)pbFrom, *(WORD UNALIGNED *)pbTo));
}

//+---------------------------------------------------------------------------
//
//  Function:   Handle routines, public
//
//  Synopsis:   Handler routine for Windows handles
//
//  History:    05-Apr-94       DrewB   Created
//
//----------------------------------------------------------------------------

void FhGdiHandle1632(BYTE *pbFrom, BYTE *pbTo, UINT cbFrom, UINT cbTo)
{
    thkAssert(cbFrom == sizeof(HAND16));
    thkAssert(cbTo == sizeof(HANDLE));

    *(HBITMAP *)pbTo = HBITMAP_32(*(HBITMAP16 UNALIGNED *)pbFrom);

    thkDebugOut((DEB_ARGS, "1632    HGdi: 0x%04lX -> 0x%p\n",
                 *(HAND16 UNALIGNED *)pbFrom, *(HANDLE *)pbTo));
}

void FhGdiHandle3216(BYTE *pbFrom, BYTE *pbTo, UINT cbFrom, UINT cbTo)
{
    thkAssert(cbFrom == sizeof(HANDLE));
    thkAssert(cbTo == sizeof(HAND16));

    *(HAND16 UNALIGNED *)pbTo = HBITMAP_16(*(HANDLE *)pbFrom);

    thkDebugOut((DEB_ARGS, "3216    HGdi: 0x%p -> 0x%04lX\n",
                 *(HANDLE *)pbFrom, *(HAND16 UNALIGNED *)pbTo));
}

void FhUserHandle1632(BYTE *pbFrom, BYTE *pbTo, UINT cbFrom, UINT cbTo)
{
    thkAssert(cbFrom == sizeof(HAND16));
    thkAssert(cbTo == sizeof(HANDLE));

    // Even though the constant is WOW_TYPE_FULLHWND, it
    // works for any user handle

    *(HANDLE *)pbTo = WOWHandle32(*(HAND16 UNALIGNED *)pbFrom,
                                  WOW_TYPE_FULLHWND);

    thkDebugOut((DEB_ARGS, "1632    HUser: 0x%04lX -> 0x%p\n",
                 *(HAND16 UNALIGNED *)pbFrom, *(HANDLE *)pbTo));
}

void FhUserHandle3216(BYTE *pbFrom, BYTE *pbTo, UINT cbFrom, UINT cbTo)
{
    thkAssert(cbFrom == sizeof(HANDLE));
    thkAssert(cbTo == sizeof(HAND16));

    *(HAND16 UNALIGNED *)pbTo = HWND_16(*(HANDLE *)pbFrom);

    thkDebugOut((DEB_ARGS, "3216    HUser: 0x%p -> 0x%04lX\n",
                 *(HANDLE *)pbFrom, *(HAND16 UNALIGNED *)pbTo));
}

void FhHaccel1632(BYTE *pbFrom, BYTE *pbTo, UINT cbFrom, UINT cbTo)
{
    thkAssert(cbFrom == sizeof(HAND16));
    thkAssert(cbTo == sizeof(HANDLE));

    *(HANDLE *)pbTo = HACCEL_32(*(HAND16 UNALIGNED *)pbFrom);

    thkDebugOut((DEB_ARGS, "1632    HACCEL: 0x%04lX -> 0x%p\n",
                 *(HAND16 UNALIGNED *)pbFrom, *(HANDLE *)pbTo));
}

void FhHaccel3216(BYTE *pbFrom, BYTE *pbTo, UINT cbFrom, UINT cbTo)
{
    thkAssert(cbFrom == sizeof(HANDLE));
    thkAssert(cbTo == sizeof(HAND16));

    *(HAND16 UNALIGNED *)pbTo = HACCEL_16(*(HANDLE *)pbFrom);

    thkDebugOut((DEB_ARGS, "3216    HACCEL: 0x%p -> 0x%04lX\n",
                 *(HANDLE *)pbFrom, *(HAND16 UNALIGNED *)pbTo));
}

void FhHtask1632(BYTE *pbFrom, BYTE *pbTo, UINT cbFrom, UINT cbTo)
{
    HAND16  h16;
    DWORD   h32;
    thkAssert(cbFrom == sizeof(HAND16));
    thkAssert(cbTo == sizeof(HANDLE));

    h16 = *(HAND16 UNALIGNED *)pbFrom;
    if ( h16 == 0 )
    {
        h32 = 0;
    }
    else
    {
        h32 = HTASK_32(h16);
    }
    *(DWORD *)pbTo = h32;

    thkDebugOut((DEB_ARGS, "1632    HTASK: 0x%04lX -> 0x%p\n", h16, h32));
}

void FhHtask3216(BYTE *pbFrom, BYTE *pbTo, UINT cbFrom, UINT cbTo)
{
    HAND16  h16;
    HANDLE  h32;

    thkAssert(cbFrom == sizeof(HANDLE));
    thkAssert(cbTo == sizeof(HAND16));

    h32 = *(HANDLE *)pbFrom;
    if ( h32 == NULL )
    {
        h16 = 0;
    }
    else
    {
        h16 = HTASK_16(h32);
    }
    *(HAND16 UNALIGNED *)pbTo = h16;

    thkDebugOut((DEB_ARGS, "3216    HTASK: 0x%p -> 0x%04lX\n",h32, h16));
}

//+---------------------------------------------------------------------------
//
//  Function:   HRESULT routines, public
//
//  Synopsis:   Handler routine for HRESULTs
//
//  History:    05-Apr-94       DrewB   Created
//
//----------------------------------------------------------------------------

void FhHresult1632(BYTE *pbFrom, BYTE *pbTo, UINT cbFrom, UINT cbTo)
{
    thkAssert(cbFrom == sizeof(HRESULT));
    thkAssert(cbTo == sizeof(HRESULT));

    *(HRESULT *)pbTo = TransformHRESULT_1632(*(HRESULT UNALIGNED *)pbFrom);

    thkDebugOut((DEB_ARGS, "1632    HRESULT: 0x%08lX -> 0x%08lX\n",
                 *(HRESULT UNALIGNED *)pbFrom, *(HRESULT *)pbTo));
}

void FhHresult3216(BYTE *pbFrom, BYTE *pbTo, UINT cbFrom, UINT cbTo)
{
    thkAssert(cbFrom == sizeof(HRESULT));
    thkAssert(cbTo == sizeof(HRESULT));

    *(HRESULT UNALIGNED *)pbTo = TransformHRESULT_3216(*(HRESULT *)pbFrom);

    thkDebugOut((DEB_ARGS, "3216    HRESULT: 0x%08lX -> 0x%08lX\n",
                 *(HRESULT *)pbFrom, *(HRESULT UNALIGNED *)pbTo));
}

//+---------------------------------------------------------------------------
//
//  Function:   NULL routines, public
//
//  Synopsis:   Handler routine for NULL
//
//  History:    05-Apr-94       DrewB   Created
//
//----------------------------------------------------------------------------

void FhNull(BYTE *pbFrom, BYTE *pbTo, UINT cbFrom, UINT cbTo)
{
    thkAssert(cbFrom == sizeof(void *));
    thkAssert(cbTo == sizeof(void *));

    thkDebugOut((DEB_WARN, "FhNull: %p NULL value not NULL\n", pbFrom));
    *(void UNALIGNED **)pbTo = NULL;

    thkDebugOut((DEB_ARGS, "Arg     NULL\n"));
}

//+---------------------------------------------------------------------------
//
//  Function:   Rect routines, public
//
//  Synopsis:   Handler routines for RECT
//
//  History:    05-Apr-94       DrewB   Created
//
//----------------------------------------------------------------------------

void FhRect1632(BYTE *pbFrom, BYTE *pbTo, UINT cbFrom, UINT cbTo)
{
    RECT *pr32;
    RECT16 UNALIGNED * pr16;

    thkAssert(cbFrom == sizeof(RECT16));
    thkAssert(cbTo == sizeof(RECT));

    pr16 = (RECT16 UNALIGNED *)pbFrom;
    pr32 = (RECT *)pbTo;

    pr32->left   = (LONG)pr16->left;   // Sign extend
    pr32->top    = (LONG)pr16->top;    // Sign extend
    pr32->right  = (LONG)pr16->right;  // Sign extend
    pr32->bottom = (LONG)pr16->bottom; // Sign extend

    thkDebugOut((DEB_ARGS, "1632    RECT: {%d, %d, %d, %d}\n",
                 pr32->left, pr32->top, pr32->right, pr32->bottom));
}

void FhRect3216(BYTE *pbFrom, BYTE *pbTo, UINT cbFrom, UINT cbTo)
{
    RECT *pr32;
    RECT16 UNALIGNED *pr16;

    thkAssert(cbFrom == sizeof(RECT));
    thkAssert(cbTo == sizeof(RECT16));

    pr32 = (RECT *)pbFrom;
    pr16 = (RECT16 UNALIGNED *)pbTo;

    pr16->left   = ClampLongToShort(pr32->left);
    pr16->top    = ClampLongToShort(pr32->top);
    pr16->right  = ClampLongToShort(pr32->right);
    pr16->bottom = ClampLongToShort(pr32->bottom);

    thkDebugOut((DEB_ARGS, "3216    RECT: {%d, %d, %d, %d}\n",
                 pr32->left, pr32->top, pr32->right, pr32->bottom));
}

//+---------------------------------------------------------------------------
//
//  Function:   Size routines, public
//
//  Synopsis:   Handler routines for SIZE
//
//  History:    05-Apr-94       DrewB   Created
//
//----------------------------------------------------------------------------

void FhSize1632(BYTE *pbFrom, BYTE *pbTo, UINT cbFrom, UINT cbTo)
{
    SIZE16 UNALIGNED *psize16;
    SIZE *psize32;

    thkAssert(cbFrom == sizeof(SIZE16));
    thkAssert(cbTo == sizeof(SIZE));

    psize16 = (SIZE16 UNALIGNED *)pbFrom;
    psize32 = (SIZE *)pbTo;

    psize32->cx = (LONG)psize16->cx;
    psize32->cy = (LONG)psize16->cy;

    thkDebugOut((DEB_ARGS, "1632    SIZE: {%d, %d}\n",
                 psize32->cx, psize32->cy));
}

void FhSize3216(BYTE *pbFrom, BYTE *pbTo, UINT cbFrom, UINT cbTo)
{
    SIZE16 UNALIGNED *psize16;
    SIZE *psize32;

    thkAssert(cbFrom == sizeof(SIZE));
    thkAssert(cbTo == sizeof(SIZE16));

    psize32 = (SIZE *)pbFrom;
    psize16 = (SIZE16 UNALIGNED *)pbTo;

    psize16->cx = ClampLongToShort(psize32->cx);
    psize16->cy = ClampLongToShort(psize32->cy);

    thkDebugOut((DEB_ARGS, "3216    SIZE: {%d, %d}\n",
                 psize32->cx, psize32->cy));
}

//+---------------------------------------------------------------------------
//
//  Function:   Message routines, public
//
//  Synopsis:   Handler routines for MSG
//
//  History:    05-Apr-94       DrewB   Created
//
//----------------------------------------------------------------------------

void FhMsg1632(BYTE *pbFrom, BYTE *pbTo, UINT cbFrom, UINT cbTo)
{
    MSG16 UNALIGNED *pmsg16;
    MSG *pmsg32;

    thkAssert(cbFrom == sizeof(MSG16));
    thkAssert(cbTo == sizeof(MSG));

    pmsg16 = (MSG16 UNALIGNED *)pbFrom;
    pmsg32 = (MSG *)pbTo;

    pmsg32->hwnd    = HWND_32(pmsg16->hwnd);
    pmsg32->message = (UINT)pmsg16->message;
    pmsg32->wParam  = (WPARAM)pmsg16->wParam; // Should we sign extend?
    pmsg32->lParam  = (LPARAM)pmsg16->lParam;
    pmsg32->time    = pmsg16->time;
    pmsg32->pt.x    = (LONG)(SHORT)LOWORD(pmsg16->pt);   // Sign extend
    pmsg32->pt.y    = (LONG)(SHORT)HIWORD(pmsg16->pt);   // Sign extend

    thkDebugOut((DEB_ARGS, "1632    MSG: {0x%p, %d, 0x%08lX, 0x%08lX, "
                 "0x%08lX, {%d, %d}}\n",
                 pmsg32->hwnd, pmsg32->message, pmsg32->wParam,
                 pmsg32->lParam, pmsg32->time, pmsg32->pt.x,
                 pmsg32->pt.y));
}

void FhMsg3216(BYTE *pbFrom, BYTE *pbTo, UINT cbFrom, UINT cbTo)
{
    MSG16 UNALIGNED *pmsg16;
    MSG *pmsg32;

    thkAssert(cbFrom == sizeof(MSG));
    thkAssert(cbTo == sizeof(MSG16));

    pmsg32 = (MSG *)pbFrom;
    pmsg16 = (MSG16 UNALIGNED *)pbTo;

    pmsg16->hwnd    = HWND_16(pmsg32->hwnd);
    pmsg16->message = (WORD)pmsg32->message;
    pmsg16->wParam  = (WORD)pmsg32->wParam;           // Sign truncate
    pmsg16->lParam  = (LONG)pmsg32->lParam;
    pmsg16->time    = pmsg32->time;
    pmsg16->pt      = MAKELONG(ClampLongToShort(pmsg32->pt.x),
                               ClampLongToShort(pmsg32->pt.y));

    thkDebugOut((DEB_ARGS, "3216    MSG: {0x%p, %d, 0x%08lX, 0x%08lX, "
                 "0x%08lX, {%d, %d}}\n",
                 pmsg32->hwnd, pmsg32->message, pmsg32->wParam,
                 pmsg32->lParam, pmsg32->time, pmsg32->pt.x,
                 pmsg32->pt.y));
}

//+---------------------------------------------------------------------------
//
//  Function:   ALLOCROUTINE, public
//
//  Synopsis:   A routine which allocates memory
//
//  Arguments:  [cb] - Amount to allocate
//
//  Returns:    Pointer to memory
//
//  History:    19-Apr-94       DrewB   Created
//
//----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Function:   FREEROUTINE, public
//
//  Synopsis:   A routine which frees memory
//
//  Arguments:  [pv] - Memory to free
//              [cb] - Size of memory to free
//
//  History:    19-Apr-94       DrewB   Created
//
//----------------------------------------------------------------------------

void *ArTask16(UINT cb)
{
    return (void *)TaskMalloc16(cb);
}

void FrTask16(void *pv, UINT cb)
{
    TaskFree16((VPVOID)pv);
}

void *ArTask32(UINT cb)
{
    return TaskMalloc32(cb);
}

void FrTask32(void *pv, UINT cb)
{
    TaskFree32(pv);
}

void *ArStack16(UINT cb)
{
    return (void *)STACKALLOC16(cb);
}

void FrStack16(void *pv, UINT cb)
{
    STACKFREE16((VPVOID)pv, cb);
}

void *ArStack32(UINT cb)
{
    // Can't use STACKALLOC32 on NT since it may be _alloca which wouldn't
    // live beyond this routine
#ifdef _CHICAGO_
    return STACKALLOC32(cb);
#else
    return (void *)LocalAlloc(LMEM_FIXED, cb);
#endif
}

void FrStack32(void *pv, UINT cb)
{
#ifdef _CHICAGO_
    STACKFREE32(pv, cb);
#else
    LocalFree(pv);
#endif
}

//+---------------------------------------------------------------------------
//
//  Function:   ConvertDvtd1632, private
//
//  Synopsis:   Converts a DVTARGETDEVICE from 16 to 32-bits
//
//  Arguments:  [pti] - Thunking state information
//              [vpdvtd16] - Source
//              [pfnAlloc] - ALLOCROUTINE
//              [pfnFree] - FREEROUTINE
//              [ppdvtd32] - Destination
//              [pcbSize] - Size return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppdvtd32]
//              [pcbSize]
//
//  History:    18-Apr-94       DrewB   Created
//
//  Notes:      [pfnAlloc/Free] must deal with 32-bit memory
//
//----------------------------------------------------------------------------

SCODE ConvertDvtd1632(THUNKINFO *pti,
                      VPVOID vpdvtd16,
                      ALLOCROUTINE pfnAlloc,
                      FREEROUTINE pfnFree,
                      DVTARGETDEVICE **ppdvtd32,
                      UINT *pcbSize)
{
    DVTARGETDEVICE UNALIGNED *pdvtd16;
    DVTARGETDEVICE *pdvtd32;
    DVTDINFO dvtdi;

    pdvtd16 = (DVTARGETDEVICE UNALIGNED *)GetReadPtr16(pti, vpdvtd16,
                                                       sizeof(DVTARGETDEVICE));
    if (pdvtd16 == NULL)
    {
        return pti->scResult;
    }

    pdvtd16 = (DVTARGETDEVICE UNALIGNED *)GetReadPtr16(pti, vpdvtd16,
                                                       pdvtd16->tdSize);

    WOWRELVDMPTR(vpdvtd16);

    if (pdvtd16 == NULL)
    {
        return pti->scResult;
    }

    pti->scResult = UtGetDvtd16Info( pdvtd16, &dvtdi );

    if ( FAILED(pti->scResult) )
    {
        WOWRELVDMPTR(vpdvtd16);
        return pti->scResult;
    }

    pdvtd32 = (DVTARGETDEVICE *)pfnAlloc(dvtdi.cbConvertSize);
    if (pdvtd32 == NULL)
    {
        WOWRELVDMPTR(vpdvtd16);
        return E_OUTOFMEMORY;
    }

    pti->scResult = UtConvertDvtd16toDvtd32( pdvtd16, &dvtdi, pdvtd32 );

    WOWRELVDMPTR(vpdvtd16);

    if ( FAILED(pti->scResult) )
    {
        pfnFree(pdvtd32, dvtdi.cbConvertSize);
        return pti->scResult;
    }

    *ppdvtd32 = pdvtd32;
    *pcbSize = dvtdi.cbConvertSize;

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   ConvertDvtd3216, private
//
//  Synopsis:   Converts a DVTARGETDEVICE from 32 to 16-bits
//
//  Arguments:  [pti] - Thunking state information
//              [pdvtd32] - Source
//              [pfnAlloc] - Allocator
//              [pfnFree] - Freer
//              [ppvdvtd16] - Destination
//              [pcbSize] - Size return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [ppvdvtd16]
//              [pcbSize]
//
//  History:    18-Apr-94       DrewB   Created
//
//  Notes:      [pfnAlloc/Free] must deal with 16-bit memory
//
//----------------------------------------------------------------------------

SCODE ConvertDvtd3216(THUNKINFO *pti,
                      DVTARGETDEVICE *pdvtd32,
                      ALLOCROUTINE pfnAlloc,
                      FREEROUTINE pfnFree,
                      VPVOID *ppvdvtd16,
                      UINT *pcbSize)
{
    DVTARGETDEVICE UNALIGNED *pdvtd16;
    VPVOID vpdvtd16;
    DVTDINFO dvtdi;

    if (IsBadReadPtr(pdvtd32, sizeof(DVTARGETDEVICE)) ||
        IsBadReadPtr(pdvtd32, pdvtd32->tdSize))
    {
        return E_INVALIDARG;
    }

    pti->scResult = UtGetDvtd32Info( pdvtd32, &dvtdi );

    if ( FAILED(pti->scResult) )
    {
        return pti->scResult;
    }

    vpdvtd16 = (VPVOID)pfnAlloc(dvtdi.cbConvertSize);
    if (vpdvtd16 == 0)
    {
        return E_OUTOFMEMORY;
    }

    pdvtd16 = (DVTARGETDEVICE UNALIGNED *)WOWFIXVDMPTR(vpdvtd16,
                                                       dvtdi.cbConvertSize);

    pti->scResult = UtConvertDvtd32toDvtd16( pdvtd32, &dvtdi, pdvtd16 );

    WOWRELVDMPTR(vpdvtd16);

    if ( FAILED(pti->scResult) )
    {
        pfnFree((void *)vpdvtd16, dvtdi.cbConvertSize);
        return pti->scResult;
    }

    *ppvdvtd16 = vpdvtd16;
    *pcbSize = dvtdi.cbConvertSize;

    return S_OK;
}

#if !defined(_CHICAGO_)

SCODE ConvertHDrop1632(HMEM16 hg16, HGLOBAL* phg32)
{
    SCODE sc = S_OK;

    *phg32 = CopyDropFilesFrom16(hg16);
    if (!*phg32)
        sc = E_INVALIDARG;

    return sc;
}


SCODE ConvertHDrop3216(HGLOBAL hg32, HMEM16* phg16)
{
    SCODE sc = S_OK;

    *phg16 = CopyDropFilesFrom32(hg32);
    if (!*phg16)
        sc = E_INVALIDARG;

    return sc;
}

#endif



//+---------------------------------------------------------------------------
//
//  Function:   ConvertHGlobal1632, public
//
//  Synopsis:   Creates a 32-bit HGLOBAL for a 16-bit HGLOBAL
//
//  Arguments:  [pti] - Thunk info, can be NULL for no validation
//              [hg16] - 16-bit HGLOBAL
//              [thopInOut] - Validation type
//              [phg32] - 32-bit HGLOBAL in/out
//              [pdwSize] - Size in/out
//
//  Returns:    Appropriate status code
//
//  Modifies:   [phg32]
//              [pdwSize]
//
//  History:    24-Apr-94       DrewB   Created
//
//  Notes:      If [phg32] is non-NULL on entry, [pdwSize] must be set
//              appropriately also
//
//----------------------------------------------------------------------------

SCODE ConvertHGlobal1632(THUNKINFO *pti,
                         HMEM16 hg16,
                         THOP thopInOut,
                         HGLOBAL *phg32,
                         DWORD *pdwSize)
{
    SCODE sc;
    VPVOID vpdata16;
    LPVOID lpdata16;
    LPVOID lpdata32;
    HGLOBAL hg32;
    DWORD dwSize;
    BOOL fOwn;

    sc = S_OK;

    vpdata16 = WOWGlobalLockSize16( hg16, &dwSize );
    if ( vpdata16 == 0 )
    {
        sc = E_INVALIDARG;
    }
    else
    {
        if (*phg32 != 0 && *pdwSize == dwSize)
        {
            hg32 = *phg32;
            fOwn = FALSE;
        }
        else
        {
            hg32 = GlobalAlloc( GMEM_MOVEABLE, dwSize );
            fOwn = TRUE;
        }

        if ( hg32 == 0 )
        {
            sc = E_OUTOFMEMORY;
        }
        else
        {
            lpdata32 = GlobalLock( hg32 );

            lpdata16 = (LPVOID)ValidatePtr16(pti, vpdata16, dwSize, thopInOut);
            if ( lpdata16 != NULL )
            {
                memcpy( lpdata32, lpdata16, dwSize );
                WOWRELVDMPTR(vpdata16);
            }
            else
            {
                sc = pti->scResult;
            }

            GlobalUnlock(hg32);

            if (FAILED(sc) && fOwn)
            {
                GlobalFree(hg32);
            }
        }

        WOWGlobalUnlock16( hg16 );
    }

    if (SUCCEEDED(sc))
    {
        if (*phg32 != 0 && hg32 != *phg32)
        {
            GlobalFree(*phg32);
        }

        *phg32 = hg32;
        *pdwSize = dwSize;

        thkDebugOut((DEB_ARGS, "1632    HGLOBAL: 0x%04X -> 0x%p, %u\n",
                     hg16, hg32, dwSize));
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   ConvertHGlobal3216, public
//
//  Synopsis:   Creates a 16-bit HGLOBAL for a 32-bit HGLOBAL
//
//  Arguments:  [pti] - Thunk info, can be NULL for no validation
//              [hg32] - 32-bit HGLOBAL
//              [thopInOut] - Validation type
//              [phg16] - 16-bit HGLOBAL in/out
//              [pdwSize] - Size in/out
//
//  Returns:    Appropriate status code
//
//  Modifies:   [phg16]
//              [pdwSize]
//
//  History:    24-Apr-94       DrewB   Created
//
//  Notes:      If [phg16] is non-NULL on entry, [pdwSize] must be set
//              appropriately also
//
//----------------------------------------------------------------------------

SCODE ConvertHGlobal3216(THUNKINFO *pti,
                         HGLOBAL hg32,
                         THOP thopInOut,
                         HMEM16 *phg16,
                         DWORD *pdwSize)
{
    SCODE sc;
    VPVOID vpdata16;
    LPVOID lpdata16;
    LPVOID lpdata32;
    HMEM16 hg16;
    DWORD dwSize;
    BOOL fOwn;

    sc = S_OK;

    dwSize = (DWORD) GlobalSize(hg32);
    if (dwSize == 0)
    {
        sc = E_INVALIDARG;
    }
    else
    {
        lpdata32 = GlobalLock(hg32);

        if (*phg16 != 0 && *pdwSize == dwSize)
        {
            hg16 = *phg16;
            vpdata16 = WOWGlobalLock16(hg16);
            fOwn = FALSE;
        }
        else
        {
            vpdata16 = WOWGlobalAllocLock16(GMEM_MOVEABLE | GMEM_DDESHARE,
                                            dwSize, &hg16);
            fOwn = TRUE;
        }

        if (vpdata16 == 0)
        {
            sc = E_OUTOFMEMORY;
        }
        else
        {
            lpdata16 = (LPVOID)WOWFIXVDMPTR( vpdata16, dwSize );
            if ( lpdata16 == NULL )
            {
                sc = E_UNEXPECTED;
            }
            else
            {
                memcpy( lpdata16, lpdata32, dwSize );

                WOWRELVDMPTR(vpdata16);
            }

            WOWGlobalUnlock16( hg16 );

            if (FAILED(sc) && fOwn)
            {
                WOWGlobalFree16(hg16);
            }
        }

        GlobalUnlock(hg32);
    }

    if (SUCCEEDED(sc))
    {
        if (*phg16 != 0 && hg16 != *phg16)
        {
            WOWGlobalFree16(*phg16);
        }

        *phg16 = hg16;
        *pdwSize = dwSize;

        thkDebugOut((DEB_ARGS, "3216    HGLOBAL: 0x%p -> 0x%04X, %u\n",
                     hg32, hg16, dwSize));
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   ConvertMfPict1632, public
//
//  Synopsis:   Converts a 16-bit METAFILEPICT to 32-bit
//
//  Arguments:  [pti] - Thunk info
//              [hg16] - 16-bit HGLOBAL containing METAFILEPICT
//              [phg32] - 32-bit HGLOBAL return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [phg32]
//
//  History:    24-Apr-94       DrewB   Created
//
//----------------------------------------------------------------------------

 SCODE ConvertMfPict1632(THUNKINFO *pti,
                               HMEM16 hg16,
                               HGLOBAL *phg32)
{
    SCODE sc;
    VPVOID vpmfp16;
    METAFILEPICT16 UNALIGNED *pmfp16;
    METAFILEPICT *pmfp32;
    HGLOBAL hg32;
    DWORD dwSize;
#if DBG == 1
    BOOL fSaveToFile = FALSE;
#endif

    thkDebugOut((DEB_ITRACE, "In  ConvertMfPict1632(%p, 0x%04X, %p)\n",
                 pti, hg16, phg32));

    *phg32 = 0;
    sc = S_OK;

    vpmfp16 = WOWGlobalLockSize16( hg16, &dwSize );
    if ( vpmfp16 == 0 || dwSize < sizeof(METAFILEPICT16))
    {
        sc = E_INVALIDARG;
    }
    else
    {
        hg32 = GlobalAlloc( GMEM_MOVEABLE, sizeof(METAFILEPICT) );
        if ( hg32 == 0 )
        {
            sc = E_OUTOFMEMORY;
        }
        else
        {
            pmfp32 = (METAFILEPICT *)GlobalLock( hg32 );

            pmfp16 = (METAFILEPICT16 UNALIGNED *)GetReadPtr16(pti, vpmfp16,
                                                              dwSize);
            if ( pmfp16 != NULL )
            {
                pmfp32->mm = (LONG)pmfp16->mm;
                pmfp32->xExt = (LONG)pmfp16->xExt;
                pmfp32->yExt = (LONG)pmfp16->yExt;

                pmfp32->hMF = HMETAFILE_32(pmfp16->hMF);

                thkDebugOut((DEB_ARGS, "1632    METAFILEPICT: "
                         "{%d, %d, %d, 0x%p} -> {%d, %d, %d, 0x%4x}\n",
                         pmfp16->mm, pmfp16->xExt, pmfp16->yExt, pmfp16->hMF,
                         pmfp32->mm, pmfp32->xExt, pmfp32->yExt, pmfp32->hMF));

                WOWRELVDMPTR(vpmfp16);

#if DBG == 1
                if (fSaveToFile)
                {
                    HMETAFILE hmf;

                    hmf = CopyMetaFile(pmfp32->hMF, __TEXT("thkmf.wmf"));
                    if (hmf != NULL)
                    {
                        DeleteMetaFile(hmf);
                    }
                }
#endif
            }
            else
            {
                sc = pti->scResult;
            }

            GlobalUnlock(hg32);

            if (FAILED(sc))
            {
                GlobalFree(hg32);
            }
        }

        WOWGlobalUnlock16( hg16 );
    }

    if (SUCCEEDED(sc))
    {
        *phg32 = hg32;
    }

    thkDebugOut((DEB_ITRACE, "Out ConvertMfPict1632 => 0x%08lX, 0x%p\n",
                 sc, *phg32));

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   ConvertMfPict3216, public
//
//  Synopsis:   Converts a 32-bit METAFILEPICT to 16-bit
//
//  Arguments:  [pti] - Thunk info
//              [hg32] - 32-bit HGLOBAL containing METAFILEPICT
//              [phg16] - 16-bit HGLOBAL return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [phg16]
//
//  History:    24-Apr-94       DrewB   Created
//
//----------------------------------------------------------------------------

 SCODE ConvertMfPict3216(THUNKINFO *pti,
                               HGLOBAL hg32,
                               HMEM16 *phg16)
{
    SCODE sc;
    VPVOID vpmfp16;
    METAFILEPICT16 UNALIGNED *pmfp16;
    METAFILEPICT *pmfp32;
    DWORD dwSize;
    HMEM16 hg16;
#if DBG == 1
    BOOL fSaveToFile = FALSE;
#endif

    thkDebugOut((DEB_ITRACE, "In  ConvertMfPict3216(%p, 0x%p, %p)\n",
                 pti, hg32, phg16));

    *phg16 = 0;
    sc = S_OK;

    dwSize = (DWORD) GlobalSize(hg32);
    pmfp32 = (METAFILEPICT *)GlobalLock(hg32);
    if (dwSize == 0 || dwSize < sizeof(METAFILEPICT) || pmfp32 == NULL)
    {
        sc = E_INVALIDARG;
    }
    else
    {
        vpmfp16 = WOWGlobalAllocLock16(GMEM_MOVEABLE | GMEM_DDESHARE,
                                       sizeof(METAFILEPICT16), &hg16);
        if (vpmfp16 == 0)
        {
            sc = E_OUTOFMEMORY;
        }
        else
        {
            pmfp16 = FIXVDMPTR(vpmfp16, METAFILEPICT16);
            if ( pmfp16 != NULL )
            {
                pmfp16->mm = (SHORT)pmfp32->mm;
                pmfp16->xExt = ClampLongToShort(pmfp32->xExt);
                pmfp16->yExt = ClampLongToShort(pmfp32->yExt);
                pmfp16->hMF = HMETAFILE_16(pmfp32->hMF);

                thkDebugOut((DEB_ARGS, "3216    METAFILEPICT: "
                         "{%d, %d, %d, 0x%p} -> {%d, %d, %d, 0x%4x}\n",
                         pmfp32->mm, pmfp32->xExt, pmfp32->yExt, pmfp32->hMF,
                         pmfp16->mm, pmfp16->xExt, pmfp16->yExt, pmfp16->hMF));

                RELVDMPTR(vpmfp16);

#if DBG == 1
                if (fSaveToFile)
                {
                    HMETAFILE hmf;

                    hmf = CopyMetaFile(pmfp32->hMF, __TEXT("thkmf.wmf"));
                    if (hmf != NULL)
                    {
                        DeleteMetaFile(hmf);
                    }
                }
#endif
            }
            else
            {
                sc = E_UNEXPECTED;
            }

            WOWGlobalUnlock16(hg16);

            if (FAILED(sc))
            {
                WOWGlobalFree16(hg16);
            }
        }

        GlobalUnlock(hg32);
    }

    if (SUCCEEDED(sc))
    {
        *phg16 = hg16;
    }

    thkDebugOut((DEB_ITRACE, "Out ConvertMfPict3216 => 0x%08lX, 0x%04X\n",
                 sc, *phg16));

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   ConvertObjDesc1632, public
//
//  Synopsis:   Converts an OBJECTDESCRIPTOR structure
//
//  Arguments:  [pti] - THUNKINFO
//              [hg16] - HGLOBAL containing structure
//              [phg32] - Output HGLOBAL
//
//  Returns:    Appropriate status code
//
//  Modifies:   [phg32]
//
//  History:    04-May-94       DrewB   Created
//
//----------------------------------------------------------------------------

SCODE ConvertObjDesc1632(THUNKINFO *pti,
                         HMEM16 hg16,
                         HGLOBAL *phg32)
{
    SCODE sc;
    VPVOID vp16;
    HGLOBAL hg32;
    DWORD dwSize;
    OBJECTDESCRIPTOR UNALIGNED *pod16;
    OBJECTDESCRIPTOR *pod32;
    char *pszFutn, *pszSoc;
    UINT cchFutn, cchSoc;
    UINT cbOffset;

    sc = S_OK;

	*phg32 = NULL;

    vp16 = WOWGlobalLock16(hg16);
    if ( vp16 == 0 )
    {
        return E_INVALIDARG;
    }

    pszFutn = NULL;
    pszSoc = NULL;

    pod16 = (OBJECTDESCRIPTOR UNALIGNED *)
        GetReadPtr16(pti, vp16, sizeof(OBJECTDESCRIPTOR));
    if (pod16 == NULL)
    {
        sc = pti->scResult;
        goto EH_Unlock;
    }

    dwSize = sizeof(OBJECTDESCRIPTOR);

    if (pod16->dwFullUserTypeName > 0)
    {
        pszFutn = (char *)GetStringPtr16(pti, vp16+pod16->dwFullUserTypeName,
                                         CCHMAXSTRING, &cchFutn);
        if (pszFutn == NULL)
        {
            sc = pti->scResult;
            goto EH_Unlock;
        }

        dwSize += cchFutn*sizeof(WCHAR);
    }

    if (pod16->dwSrcOfCopy > 0)
    {
        pszSoc = (char *)GetStringPtr16(pti, vp16+pod16->dwSrcOfCopy,
                                        CCHMAXSTRING, &cchSoc);
        if (pszSoc == NULL)
        {
            sc = pti->scResult;
            goto EH_Unlock;
        }

        dwSize += cchSoc*sizeof(WCHAR);
    }

    hg32 = GlobalAlloc(GMEM_MOVEABLE, dwSize);
    if ( hg32 == 0 )
    {
        sc = E_OUTOFMEMORY;
        goto EH_Unlock;
    }

    pod32 = (OBJECTDESCRIPTOR *)GlobalLock(hg32);
    memcpy(pod32, pod16, sizeof(OBJECTDESCRIPTOR));
    pod32->cbSize = dwSize;

    cbOffset = sizeof(OBJECTDESCRIPTOR);

    if (pod16->dwFullUserTypeName > 0)
    {
        if (MultiByteToWideChar(AreFileApisANSI() ? CP_ACP : CP_OEMCP,
                                0, pszFutn, cchFutn,
                                (WCHAR *)((BYTE *)pod32+cbOffset),
                                cchFutn) == 0)
        {
            sc = E_UNEXPECTED;
            goto EH_Free;
        }

        pod32->dwFullUserTypeName = cbOffset;
        cbOffset += cchFutn*sizeof(WCHAR);
    }

    if (pod16->dwSrcOfCopy > 0)
    {
        if (MultiByteToWideChar(AreFileApisANSI() ? CP_ACP : CP_OEMCP,
                                0, pszSoc, cchSoc,
                                (WCHAR *)((BYTE *)pod32+cbOffset),
                                cchSoc)  == 0)
        {
            sc = E_UNEXPECTED;
            goto EH_Free;
        }

        pod32->dwSrcOfCopy = cbOffset;
        cbOffset += cchFutn*sizeof(WCHAR);
    }

#if DBG == 1
    WCHAR *pwcsFutn, *pwcsSoc;
    if (pod32->dwFullUserTypeName > 0)
    {
        pwcsFutn = (WCHAR *)((BYTE *)pod32+pod32->dwFullUserTypeName);
    }
    else
    {
        pwcsFutn = NULL;
    }
    if (pod32->dwSrcOfCopy > 0)
    {
        pwcsSoc = (WCHAR *)((BYTE *)pod32+pod32->dwSrcOfCopy);
    }
    else
    {
        pwcsSoc = NULL;
    }
    thkDebugOut((DEB_ARGS, "1632    OBJECTDESCRIPTOR: "
                 "{%d, ..., \"%ws\" (%s), \"%ws\" (%s)} %p -> %p\n",
                 pod32->cbSize, pwcsFutn, pszFutn, pwcsSoc, pszSoc,
                 vp16, pod32));
#endif

    GlobalUnlock(hg32);

    *phg32 = hg32;

 EH_Unlock:
    if (pszFutn != NULL)
    {
        WOWRELVDMPTR(vp16+pod16->dwFullUserTypeName);
    }
    if (pszSoc != NULL)
    {
        WOWRELVDMPTR(vp16+pod16->dwSrcOfCopy);
    }
    if (pod16 != NULL)
    {
        WOWRELVDMPTR(vp16);
    }

    WOWGlobalUnlock16(hg16);

    return sc;

 EH_Free:
    GlobalUnlock(hg32);
    GlobalFree(hg32);
    goto EH_Unlock;
}

//+---------------------------------------------------------------------------
//
//  Function:   ConvertObjDesc3216, public
//
//  Synopsis:   Converts an OBJECTDESCRIPTOR structure
//
//  Arguments:  [pti] - THUNKINFO
//              [hg32] - HGLOBAL containing structure
//              [phg16] - Output HGLOBAL
//
//  Returns:    Appropriate status code
//
//  Modifies:   [phg16]
//
//  History:    04-May-94       DrewB   Created
//
//----------------------------------------------------------------------------

SCODE ConvertObjDesc3216(THUNKINFO *pti,
                         HGLOBAL hg32,
                         HMEM16 *phg16)
{
    SCODE sc;
    VPVOID vp16;
    HMEM16 hg16;
    DWORD dwSize;
    OBJECTDESCRIPTOR UNALIGNED *pod16;
    OBJECTDESCRIPTOR *pod32;
    WCHAR *pwcsFutn, *pwcsSoc;
    UINT cchFutn, cchSoc;
    UINT cbOffset;

    sc = S_OK;

    pod32 = (OBJECTDESCRIPTOR *)GlobalLock(hg32);
    if ( pod32 == 0 )
    {
        return E_INVALIDARG;
    }

    if (IsBadReadPtr(pod32, sizeof(OBJECTDESCRIPTOR)))
    {
        sc = E_INVALIDARG;
        goto EH_Unlock;
    }

    dwSize = sizeof(OBJECTDESCRIPTOR);

    pwcsFutn = NULL;
    if (pod32->dwFullUserTypeName > 0)
    {
        pwcsFutn = (WCHAR *)((BYTE *)pod32+pod32->dwFullUserTypeName);
        if (IsBadStringPtrW(pwcsFutn, CCHMAXSTRING))
        {
            sc = E_INVALIDARG;
            goto EH_Unlock;
        }

        cchFutn = lstrlenW(pwcsFutn)+1;
        dwSize += cchFutn*2;
    }

    pwcsSoc = NULL;
    if (pod32->dwSrcOfCopy > 0)
    {
        pwcsSoc = (WCHAR *)((BYTE *)pod32+pod32->dwSrcOfCopy);
        if (IsBadStringPtrW(pwcsSoc, CCHMAXSTRING))
        {
            sc = E_INVALIDARG;
            goto EH_Unlock;
        }

        cchSoc = lstrlenW(pwcsSoc)+1;
        dwSize += cchSoc*2;
    }

    vp16 = WOWGlobalAllocLock16(GMEM_MOVEABLE, dwSize, &hg16);
    if ( vp16 == 0 )
    {
        sc = E_OUTOFMEMORY;
        goto EH_Unlock;
    }

    pod16 = FIXVDMPTR(vp16, OBJECTDESCRIPTOR);
    memcpy(pod16, pod32, sizeof(OBJECTDESCRIPTOR));
    pod16->cbSize = dwSize;

    cbOffset = sizeof(OBJECTDESCRIPTOR);

    if (pod32->dwFullUserTypeName > 0)
    {
        if (WideCharToMultiByte(AreFileApisANSI() ? CP_ACP : CP_OEMCP,
                                0, pwcsFutn, cchFutn,
                                (char *)pod16+cbOffset, 2 * cchFutn,
                                NULL, NULL) == 0)
        {
            sc = E_UNEXPECTED;
            goto EH_Free;
        }

        pod16->dwFullUserTypeName = cbOffset;
        cbOffset += cchFutn*2;
    }

    if (pod32->dwSrcOfCopy > 0)
    {
        if (WideCharToMultiByte(AreFileApisANSI() ? CP_ACP : CP_OEMCP,
                                0, pwcsSoc, cchSoc,
                                (char *)pod16+cbOffset, 2 * cchSoc,
                                NULL, NULL) == 0)
        {
            sc = E_UNEXPECTED;
            goto EH_Free;
        }

        pod16->dwSrcOfCopy = cbOffset;
        cbOffset += cchFutn*2;
    }

#if DBG == 1
    char *pszFutn, *pszSoc;
    if (pod16->dwFullUserTypeName > 0)
    {
        pszFutn = (char *)((BYTE *)pod16+pod16->dwFullUserTypeName);
    }
    else
    {
        pszFutn = NULL;
    }
    if (pod16->dwSrcOfCopy > 0)
    {
        pszSoc = (char *)((BYTE *)pod16+pod16->dwSrcOfCopy);
    }
    else
    {
        pszSoc = NULL;
    }
    thkDebugOut((DEB_ARGS, "3216    OBJECTDESCRIPTOR: "
                 "{%d, ..., \"%s\" (%ws), \"%s\" (%ws)} %p -> %p\n",
                 pod16->cbSize, pszFutn, pwcsFutn, pszSoc, pwcsSoc,
                 pod32, vp16));
#endif

    RELVDMPTR(vp16);

    WOWGlobalUnlock16(hg16);

    *phg16 = hg16;

 EH_Unlock:
    GlobalUnlock(hg32);

    return sc;

 EH_Free:
    WOWGlobalUnlockFree16(vp16);
    goto EH_Unlock;
}

//+---------------------------------------------------------------------------
//
//  Class:      CSm32ReleaseHandler (srh)
//
//  Purpose:    Provides punkForRelease for 16->32 STGMEDIUM conversion
//
//  Interface:  IUnknown
//
//  History:    24-Apr-94       DrewB   Created
//
//----------------------------------------------------------------------------

class CSm32ReleaseHandler : public IUnknown
{
public:
    CSm32ReleaseHandler(void)
    {
        _vpvForRelease = NULL;
    }
    ~CSm32ReleaseHandler(void)
    {
    }

    void Init(CThkMgr *pThkMgr,
              STGMEDIUM UNALIGNED *psm16,
              STGMEDIUM *psm32,
              VPVOID vpvForRelease,
              CLIPFORMAT cfFormat)
    {
        // Unfortunately, the MIPS compiler is not smart enough
        // to do the right thing if we just declare psm16 as UNALIGNED -- it
        // doesn't recognize that each member of the structure is also
        // unaligned when it does the structure copy.  So...to make
        // sure we don't generate an alignment fault, we just copy each
        // member of the structure directly.

        _sm16.tymed          = psm16->tymed;
        switch(_sm16.tymed) {
        case TYMED_HGLOBAL:
            _sm16.hGlobal = psm16->hGlobal;
        case TYMED_FILE:
            _sm16.lpszFileName = psm16->lpszFileName;
        case TYMED_ISTREAM:
            _sm16.pstm = psm16->pstm;
        case TYMED_ISTORAGE:
            _sm16.pstg = psm16->pstg;
        }
        _sm16.pUnkForRelease = psm16->pUnkForRelease;
        _sm32 = *psm32;
        _vpvForRelease = vpvForRelease;
        _cReferences = 1;
        _cfFormat = cfFormat;
        _pThkMgr = pThkMgr;
    }

    STDMETHOD(QueryInterface)(REFIID riid, void **ppv)
    {
        if ( IsEqualIID(riid,IID_IUnknown) )
        {
            *ppv = this;
            AddRef();
            return NOERROR;
        }
        else
        {
            thkDebugOut((DEB_WARN, "Not a QI for IUnknown\n"));
            *ppv = NULL;
            return E_NOINTERFACE;
        }
    }
    STDMETHOD_(ULONG, AddRef)(void)
    {
        return InterlockedIncrement(&_cReferences);
    }
    STDMETHOD_(ULONG, Release)(void);

    void CallFailed() {
        _vpvForRelease = NULL;
    }

private:
    STGMEDIUM _sm16;
    STGMEDIUM _sm32;
    VPVOID _vpvForRelease;
    CLIPFORMAT _cfFormat;
    CThkMgr *_pThkMgr;
    LONG _cReferences;
};

//+---------------------------------------------------------------------------
//
//  Member:     CSm32ReleaseHandler::Release, public
//
//  Synopsis:   Frees resources for the 32-bit copy and then
//              passes the ReleaseStgMedium on to 16-bits
//
//  Returns:    Ref count
//
//  History:    24-Apr-94       DrewB   Created
//
//----------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CSm32ReleaseHandler::Release(void)
{
    STGMEDIUM UNALIGNED *psm16;
    VPVOID vpvunk;
    STGMEDIUM *psm32;
    LONG lRet;
    SCODE sc;
    BOOL fCopy;
    DWORD dwSize;

    lRet = InterlockedDecrement(&_cReferences);
    if (lRet != 0) {
        return lRet;
    }
    
    if(_vpvForRelease) {
        // This is the last release on ReleaseHandler
        // Cleanup 32-bit STGMEDIUM after copying it to 
        // 16-bit STGMEDIUM.
        fCopy = TRUE;
    }
    else {
        // The current call failed.
        // As the fields in the 16-bit STGMEDIUM are not longer valid,
        // cleanup the 32-bit STGMEDIUM without copying it to
        // 16-bit STGMEDIUM
        fCopy = FALSE;
    }

    psm16 = &_sm16;
    psm32 = &_sm32;

    switch(psm32->tymed)
    {
    case TYMED_HGLOBAL:
        // Assumption that OBJECTDESCRIPTOR does not need copyback
        if (fCopy && !OBJDESC_CF(_cfFormat))
        {
            // Do we ever need to do this?
            // Is it valid to rely on the contents of the HGLOBAL
            // at release time?

            // Is this the right time to copy back?

            Assert(NULL != psm32->hGlobal);

            WOWGlobalLockSize16((HMEM16)psm16->hGlobal, &dwSize);
            WOWGlobalUnlock16((HMEM16)psm16->hGlobal);

            sc = ConvertHGlobal3216(NULL, psm32->hGlobal, 0,
                                    (HMEM16 *)&psm16->hGlobal, &dwSize);
            // What happens on errors?
            thkAssert(SUCCEEDED(sc));
        }

        GlobalFree(psm32->hGlobal);
        psm32->hGlobal = NULL;
        break;

    case TYMED_MFPICT:
        //  Chicago uses the same GDI handles for both 32bit and 16bit worlds.
        //  Don't delete the handle after a copy since Chicago doesn't actually
        //  copy the handle.
#if !defined(_CHICAGO_)
        METAFILEPICT *pmfp32;

        pmfp32 = (METAFILEPICT *)GlobalLock(psm32->hGlobal);
        DeleteMetaFile(pmfp32->hMF);
        GlobalUnlock(psm32->hGlobal);
#endif
        GlobalFree(psm32->hGlobal);
        break;

    case TYMED_FILE:
        // 32-bit handled by ReleaseStgMedium
        // Clean up 16-bit ourselves
#ifdef SM_FREE_16BIT_FILENAME
        if(fCopy) {
            // 16-bit OLE did not free the filename, so we can't
            // either.  This may lead to memory leaks, but there's not
            // really anything we can do about it
            TaskFree16((VPVOID)psm16->lpszFileName);
        }
#endif
        break;

    case TYMED_ISTREAM:
        if(fCopy) {
            // The proxy to the 16-bit stream interface was released by
            // ReleaseStgMedium
            // Release the reference kept on the 16-bit stream interface
            ReleaseOnObj16((VPVOID) psm16->pstm);
        }
        break;

    case TYMED_ISTORAGE:
        if(fCopy) {
            // The proxy to the 16-bit storage interface was released by
            // ReleaseStgMedium
            // Release the reference kept on the 16-bit storage interface
            ReleaseOnObj16((VPVOID) psm16->pstg);
        }
        break;

    case TYMED_GDI:
    case TYMED_NULL:
        // Nothing to release
        break;

    default:
        thkAssert(!"Unknown tymed in CSm32ReleaseHandler::Release");
        break;
    }

    // Call Release on the 16-bit vpvForRelease
    if(_vpvForRelease) {
        ReleaseOnObj16(_vpvForRelease);
        _vpvForRelease = NULL;
    }

    // Clean up this
    delete this;

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CSm16ReleaseHandler::Init, public
//
//  Synopsis:   Initialize class
//
//  Arguments:  [psm32] - 32-bit STGMEDIUM
//              [psm16] - 16-bit STGMEDIUM
//              [vpvUnkForRelease] - Object for punkForRelease
//              [cfFormat] - Clipboard format associated with STGMEDIUM
//
//  History:    24-Apr-94       DrewB   Created
//
//----------------------------------------------------------------------------

void CSm16ReleaseHandler::Init(IUnknown *pThkMgr,
                               STGMEDIUM *psm32,
                               STGMEDIUM UNALIGNED *psm16,
                               IUnknown *punkForRelease,
                               CLIPFORMAT cfFormat)
{
    _avpfnVtbl = gdata16Data.avpfnSm16ReleaseHandlerVtbl;
    _sm32 = *psm32;

    // Unfortunately, the MIPS compiler is not smart enough
    // to do the right thing if we just (ony) declare psm16 as UNALIGNED,
    // it doesn't recognize that each member of the structure is also
    // unaligned when it does the structure copy.  So...to make
    // sure we don't generate an alignment fault, we just copy each
    // member of the structure directly.

    _sm16.tymed          = psm16->tymed;
    _sm16.hGlobal        = psm16->hGlobal;
    _sm16.pstm           = psm16->pstm;
    _sm16.pstg           = psm16->pstg;
    _sm16.pUnkForRelease = psm16->pUnkForRelease;

    _punkForRelease = punkForRelease;
    _cReferences = 1;
    _cfFormat = cfFormat;
    _pUnkThkMgr = pThkMgr;
}

//+---------------------------------------------------------------------------
//
//  Function:   CSm16ReleaseHandler_Release32, public
//
//  Synopsis:   Handles 32-bit portion of cleaning up STGMEDIUMs for
//              punkForRelease
//
//  Arguments:  [psrh] - this
//              [dw1]
//              [dw2]
//
//  Returns:    punkForRelease->Release()
//
//  History:    24-Apr-94       DrewB   Created
//
//----------------------------------------------------------------------------

STDAPI_(DWORD) CSm16ReleaseHandler_Release32(CSm16ReleaseHandler *psrh,
                                             DWORD dw1,
                                             DWORD dw2)
{
    STGMEDIUM UNALIGNED *psm16;
    STGMEDIUM *psm32;
    DWORD dwSize;
    SCODE sc;
    BOOL fCopy;

    if(psrh->_punkForRelease) {
        // This is the last release on ReleaseHandler
        // Cleanup 16-bit STGMEDIUM after copying it to 
        // 32-bit STGMEDIUM.
        fCopy = TRUE;
    }
    else {
        // The current call failed.
        // As the fields in the 32-bit STGMEDIUM are not longer valid,
        // cleanup the 16-bit STGMEDIUM without copying it to
        // 32-bit STGMEDIUM
        fCopy = FALSE;
    }

    psm16 = &psrh->_sm16;
    psm32 = &psrh->_sm32;
    switch(psm32->tymed)
    {
    case TYMED_FILE:
        // 16-bit code cleaned up the 16-bit name,
        // now clean up the 32-bit name
        if (fCopy) {
            TaskFree32(psm32->lpszFileName);
        }
        break;

    case TYMED_HGLOBAL:
        //  Assumption that OBJECTDESCRIPTOR does not need copyback
        if(fCopy && !OBJDESC_CF(psrh->_cfFormat))
        {
            // Do we ever need to do this?
            // Copy data back and free global memory

            dwSize = (DWORD) GlobalSize(psm32->hGlobal);

            sc = ConvertHGlobal1632(NULL, (HMEM16)psm16->hGlobal, 0,
                                    &psm32->hGlobal, &dwSize);
            // What happens on errors?
            thkAssert(SUCCEEDED(sc));
        }

        WOWGlobalFree16((HMEM16)psm16->hGlobal);
        break;

    case TYMED_MFPICT:
        // Untouched in this case
        break;

    case TYMED_ISTREAM:
        if(fCopy) {
            // The proxy to the 32-bit stream interface was released by
            // ReleaseStgMedium
            // Release the reference kept on the 32-bit stream interface
            psm32->pstm->Release();
        }
        break;

    case TYMED_ISTORAGE:
        if(fCopy) {
            // The proxy to the 32-bit stream interface was released by
            // ReleaseStgMedium
            // Release the reference kept on the 32-bit stream interface
            psm32->pstg->Release();
        }
        break;

    case TYMED_GDI:
    case TYMED_NULL:
        // Nothing to release
        break;

    default:
        thkAssert(!"Unknown tymed in ReleaseStgMedium32");
        break;
    }

    // Call Release on the 32-bit punkForRelease
    if(fCopy) {
        psrh->_punkForRelease->Release();
        psrh->_punkForRelease = NULL;
    }

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   ConvertStgMed1632, public
//
//  Synopsis:   Converts a 16-bit STGMEDIUM to 32-bits
//
//  Arguments:  [pti] - Thunk info
//              [vpsm16] - VDM pointer to 16-bit STGMEDIUM
//              [psm32] - 32-bit STGMEDIUM to fill in
//              [pfe] - FORMATETC paired with STGMEDIUM or NULL
//              [pdwSize] - Size return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pdwSize]
//
//  History:    24-Apr-94       DrewB   Created
//
//  Notes:      [pdwSize] is only set for TYMED_HGLOBAL
//
//----------------------------------------------------------------------------

SCODE ConvertStgMed1632(THUNKINFO *pti,
                        VPVOID vpsm16,
                        STGMEDIUM *psm32,
                        FORMATETC *pfe,
                        BOOL fPassingOwnershipIn,
                        DWORD *pdwSize)
{
    SCODE sc;
    STGMEDIUM UNALIGNED *psm16;
    CSm32ReleaseHandler *psrh;
    IUnknown *punkForRelease;
    VPVOID vpvUnk, vpvForRelease;
    HMEM16 hmem16;
    HGDIOBJ hGDI = NULL;
    THKSTATE thkstateSaved;

    psm16 = (STGMEDIUM UNALIGNED *)
        GetReadPtr16(pti, vpsm16, sizeof(STGMEDIUM));
    if (psm16 == NULL)
    {
        return pti->scResult;
    }

    sc = S_OK;

    psm32->tymed = psm16->tymed;

    vpvForRelease = (VPVOID)psm16->pUnkForRelease;
    WOWRELVDMPTR(vpsm16);

    if(vpvForRelease) {
        // Create the 32-bit punkForRelease
        thkDebugOut((DEB_WARN, "pUnkForRelease present in StgMedium1632\n"));
        psrh = new CSm32ReleaseHandler;
        if(psrh == NULL)
            return E_OUTOFMEMORY;
    }
    else {
        psrh = NULL;
    }
    psm32->pUnkForRelease = psrh;

    psm16 = FIXVDMPTR(vpsm16, STGMEDIUM);

    // Word 6 insists on treating BITMAPs as HGLOBALS, which is bogus.
    // If this is the case, just patch the tymed to the correct value

    if (pfe != NULL)
    {
        if( (pfe->cfFormat == CF_BITMAP || pfe->cfFormat == CF_PALETTE ) &&
            psm16->tymed == TYMED_HGLOBAL )
        {
            DWORD dw = TlsThkGetAppCompatFlags();

            // if we are in Word 6, then hack the tymed so we thunk the
            // bitmaps as GDI objects

            if( (dw & OACF_USEGDI ) )
            {
                DWORD dwType;

                hGDI = HBITMAP_32((HBITMAP16)psm16->hBitmap);

                // make sure HGDI is either a bitmap or palette

                dwType = GetObjectType(hGDI);
                if( (pfe->cfFormat == CF_BITMAP && dwType == OBJ_BITMAP) ||
                    (pfe->cfFormat == CF_PALETTE && dwType == OBJ_PAL) )
                {
                    psm16->tymed = TYMED_GDI;
                }
                else
                {
                    thkDebugOut((DEB_WARN,
                        "WARNING! invalid bitmap or palette!\n"));
                    hGDI = NULL;
                }
            }
            else
            {
                thkDebugOut((DEB_WARN, "WARNING!  App trying to transfer a "
                    "bitmap or palette on an HGLOBAL\n"));
            }
        }
    }

    switch( psm16->tymed )
    {
    case TYMED_HGLOBAL:
        hmem16 = (HMEM16)psm16->hGlobal;
        RELVDMPTR(vpsm16);

        if (pfe && OBJDESC_CF(pfe->cfFormat))
        {
            sc = ConvertObjDesc1632(pti, hmem16, &psm32->hGlobal);
        }
#if !defined(_CHICAGO_)

        else if (pfe && pfe->cfFormat == CF_HDROP)
        {
            // fix for mapi forms
            // thunk CF_HDROP passed as HGLOBAL format
            sc = ConvertHDrop1632(hmem16, &psm32->hGlobal);
        }

#endif
        else
        {
            psm32->hGlobal = 0;
            sc = ConvertHGlobal1632(pti, hmem16, THOP_INOUT,
                                    &psm32->hGlobal, pdwSize);
        }
        break;

    case TYMED_MFPICT:
        hmem16 = (HMEM16)psm16->hGlobal;
        RELVDMPTR(vpsm16);

        sc = ConvertMfPict1632(pti, hmem16, &psm32->hGlobal);
        break;

    case TYMED_FILE:
        psm32->lpszFileName =
            Convert_VPSTR_to_LPOLESTR( pti,
                                       (VPVOID)psm16->lpszFileName,
                                       NULL, 0 );
        if (psm32->lpszFileName == NULL)
        {
            sc = pti->scResult;
        }
        else
        {
#if DBG == 1
            thkDebugOut((DEB_ARGS, "1632    TYMED_FILE: '%ws' (%s)\n",
                         psm32->lpszFileName,
                         WOWFIXVDMPTR((VPVOID)psm16->lpszFileName, 0)));
            WOWRELVDMPTR((VPVOID)psm16->lpszFileName);
#endif
        }
        RELVDMPTR(vpsm16);
        break;

    case TYMED_ISTREAM:
        vpvUnk = (VPVOID)psm16->pstm;
        RELVDMPTR(vpsm16);

        psm32->pstm =
            (LPSTREAM)pti->pThkMgr->FindProxy3216(NULL, vpvUnk, NULL,
                                                  INDEX_IIDIDX(THI_IStream), 
                                                  FALSE, NULL);
        if(psm32->pstm) {
            thkDebugOut((DEB_ARGS, "1632    TYMED_ISTREAM: %p -> %p\n",
                         vpvUnk, psm32->pstm));
        }
        else {
            sc = E_OUTOFMEMORY;
        }

        break;

    case TYMED_ISTORAGE:
        vpvUnk = (VPVOID)psm16->pstg;
        RELVDMPTR(vpsm16);

        psm32->pstg =
            (LPSTORAGE)pti->pThkMgr->FindProxy3216(NULL, vpvUnk, NULL,
                                                   INDEX_IIDIDX(THI_IStorage),
                                                   FALSE, NULL);
        if(psm32->pstg) {
            thkDebugOut((DEB_ARGS, "1632    TYMED_ISTORAGE: %p -> %p\n",
                         vpvUnk, psm32->pstg));
        }
        else {
            sc = E_OUTOFMEMORY;
        }

        break;

    case TYMED_GDI:
        // if we're in Word6, then we may have already converted the bitmap
        // or palette handle
        if( hGDI == NULL )
        {
            psm32->hBitmap = HBITMAP_32((HBITMAP16)psm16->hBitmap);
        }
        else
        {
            psm32->hBitmap = (HBITMAP)hGDI;
        }

        thkDebugOut((DEB_ARGS, "1632    TYMED_GDI: 0x%04X -> 0x%p\n",
                     psm16->hBitmap, psm32->hBitmap));
        RELVDMPTR(vpsm16);
        break;

    case TYMED_NULL:
        RELVDMPTR(vpsm16);
        break;

    default:
        RELVDMPTR(vpsm16);
        sc = E_INVALIDARG;
        break;
    }

    if (FAILED(sc))
    {
        delete psrh;
    }
    else
    {
        if (psrh)
        {
            CLIPFORMAT cf;

            if (pfe)
            {
                cf = pfe->cfFormat;
            }
            else
            {
                cf = CF_INVALID;
            }
            thkAssert(vpvForRelease);
            psrh->Init(pti->pThkMgr, FIXVDMPTR(vpsm16, STGMEDIUM), psm32,
                       vpvForRelease, cf);
            RELVDMPTR(vpsm16);
        }

#if DBG == 1
        if (pfe)
        {
            thkDebugOut((DEB_ARGS, "1632    STGMEDIUM FORMATETC %p {%d}\n",
                         pfe, pfe->cfFormat));
        }
        thkDebugOut((DEB_ARGS, "1632    STGMEDIUM: %p {%d, %p, ...} -> "
                     "%p {%d, %p, ...}\n", vpsm16, psm16->tymed,
                     psm16->pUnkForRelease, psm32, psm32->tymed,
                     psm32->pUnkForRelease));
#endif
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   CleanStgMed32, public
//
//  Synopsis:   Cleans up a 32-bit STGMEDIUM
//
//  Arguments:  [pti] - Thunk info
//              [psm32] - STGMEDIUM to clean
//              [vpsm16] - Source STGMEDIUM if thunk
//              [dwSize] - Source size if thunk
//              [fIsThunk] - STGMEDIUM was generated by thunking
//              [pfe] - FORMATETC or NULL
//
//  Returns:    Appropriate status code
//
//  History:    24-Apr-94       DrewB   Created
//
//----------------------------------------------------------------------------

SCODE CleanStgMed32(THUNKINFO *pti,
                    STGMEDIUM *psm32,
                    VPVOID vpsm16,
                    DWORD dwSize,
                    BOOL fIsThunk,
                    FORMATETC *pfe)
{
    SCODE sc;
    STGMEDIUM UNALIGNED *psm16;
    HMEM16 hmem16;
    VPVOID vpvUnk;
    BOOL fCleanup = TRUE;

    thkDebugOut((DEB_ITRACE, "In  CleanStgMed32(%p, %p, %p, %u, %d, %p)\n",
                 pti, psm32, vpsm16, dwSize, fIsThunk, pfe));

    sc = S_OK;

    if(fIsThunk && psm32->pUnkForRelease) {
        // This means that the current call failed
        // Inform the 32-bit punkForRelease created during thunking
        // so that it would cleanup 32-bit STGMEDIUM
        ((CSm32ReleaseHandler *) (psm32->pUnkForRelease))->CallFailed();
        fCleanup = FALSE;
    }

    switch( psm32->tymed )
    {
    case TYMED_HGLOBAL:
        if (fIsThunk &&
            (pfe == NULL || !OBJDESC_CF(pfe->cfFormat)))
        {
            psm16 = FIXVDMPTR(vpsm16, STGMEDIUM);
            hmem16 = (HMEM16)psm16->hGlobal;
            RELVDMPTR(vpsm16);

            Assert(NULL != psm32->hGlobal);

            sc = ConvertHGlobal3216(pti, psm32->hGlobal, 0,
                                    &hmem16, &dwSize);
            psm16 = FIXVDMPTR(vpsm16, STGMEDIUM);
            psm16->hGlobal = (HGLOBAL)hmem16;
            RELVDMPTR(vpsm16);
        }

        if(fCleanup) {
            GlobalFree( psm32->hGlobal );
            psm32->hGlobal = NULL;
        }
        break;

    case TYMED_MFPICT:
        //  Chicago uses the same GDI handles for both 32bit and 16bit worlds.
        //  Don't delete the handle after a copy since Chicago doesn't actually
        //  copy the handle.
        if(fCleanup) {
#if !defined(_CHICAGO_)
            // Can't modify an MFPICT
            METAFILEPICT *pmfp32;

            pmfp32 = (METAFILEPICT *)GlobalLock(psm32->hGlobal);
            DeleteMetaFile(pmfp32->hMF);
            GlobalUnlock(psm32->hGlobal);
#endif
            GlobalFree(psm32->hGlobal);
        }
        break;

    case TYMED_FILE:
        Convert_VPSTR_to_LPOLESTR_free( NULL, psm32->lpszFileName );
#ifdef SM_FREE_16BIT_FILENAME
        if(fCleanup) {
            // 16-bit OLE did not free the filename, so we can't
            // either.  This may lead to memory leaks, but there's not
            // really anything we can do about it
            TaskFree16((VPVOID)psm16->lpszFileName);
        }
#endif
        break;

    case TYMED_ISTREAM:
        if(fIsThunk) {
            // Release the 32-bit stream interface
            psm32->pstm->Release();
        }
        break;

    case TYMED_ISTORAGE:
        if(fIsThunk) {
            // Release the 32-bit storage interface
            psm32->pstg->Release();
        }
        break;

    case TYMED_GDI:
        //
        // No unthunking needed
        //
        break;

    case TYMED_NULL:
        break;

    default:
        // Ignore, this case is handled on input
        thkAssert(!"STGMEDIUM with invalid tymed");
        break;
    }

    if(fIsThunk && psm32->pUnkForRelease) {
        // Release the 32-bit STGMEDIUM pUnkForRelease.
        // 32-bit STGMEDIUM would be cleaned up after the last release
        psm32->pUnkForRelease->Release();
    }

    thkDebugOut((DEB_ITRACE, "Out CleanStgMed32 => 0x%08lX\n", sc));

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   ConvertStgMed3216, public
//
//  Synopsis:   Converts a 32-bit STGMEDIUM to 16-bits
//
//  Arguments:  [pti] - Thunk info
//              [psm32] - 32-bit STGMEDIUM
//              [vpsm16] - VDM pointer to 16-bit STGMEDIUM
//              [pfe] - FORMATETC paired with STGMEDIUM or NULL
//              [pdwSize] - Size return
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pdwSize]
//
//  History:    24-Apr-94       DrewB   Created
//
//  Notes:      [pdwSize] is only set for TYMED_HGLOBAL
//
//----------------------------------------------------------------------------

SCODE ConvertStgMed3216(THUNKINFO *pti,
                        STGMEDIUM *psm32,
                        VPVOID vpsm16,
                        FORMATETC *pfe,
                        BOOL fPassingOwnershipIn,
                        DWORD *pdwSize)
{
    SCODE sc;
    STGMEDIUM UNALIGNED *psm16;
    VPVOID vpsrh;
    VPSTR vpstr;
    UINT uiSize;
    VPVOID vpvUnkForRelease;
    VPVOID vpvUnk;
    HMEM16 hmem16;
    THKSTATE thkstateSaved;

    sc = S_OK;

    if(psm32->pUnkForRelease) {
        thkDebugOut((DEB_WARN, "pUnkForRelease present in StgMedium3216\n"));
        vpsrh = WOWGlobalAllocLock16(GMEM_MOVEABLE, sizeof(CSm16ReleaseHandler),
                                     NULL);
        if(vpsrh == 0)
            return E_OUTOFMEMORY;
    }
    else {
        vpsrh = 0;
    }

    psm16 = FIXVDMPTR(vpsm16, STGMEDIUM);
    psm16->tymed = psm32->tymed;
    psm16->pUnkForRelease = (IUnknown *)vpsrh;
    RELVDMPTR(vpsm16);

    switch( psm32->tymed )
    {
    case TYMED_HGLOBAL:
        if (pfe && OBJDESC_CF(pfe->cfFormat))
        {
            sc = ConvertObjDesc3216(pti, psm32->hGlobal, &hmem16);
        }
#if !defined(_CHICAGO_)

        else if (pfe && pfe->cfFormat == CF_HDROP)
        {
            // fix for mapi forms
            sc = ConvertHDrop3216(psm32->hGlobal, &hmem16);
        }

#endif
        else
        {
            hmem16 = 0;
            sc = ConvertHGlobal3216(pti, psm32->hGlobal, THOP_INOUT,
                                    &hmem16, pdwSize);
        }

        psm16 = FIXVDMPTR(vpsm16, STGMEDIUM);
        psm16->hGlobal = (HGLOBAL)hmem16;
        RELVDMPTR(vpsm16);
        break;

    case TYMED_MFPICT:
        sc = ConvertMfPict3216(pti, psm32->hGlobal, &hmem16);

        psm16 = FIXVDMPTR(vpsm16, STGMEDIUM);
        psm16->hGlobal = (HGLOBAL)hmem16;
        RELVDMPTR(vpsm16);
        break;

    case TYMED_FILE:
        uiSize = lstrlenW(psm32->lpszFileName) + 1;
        vpstr = TaskMalloc16( uiSize*2 );
        if ( vpstr == NULL )
        {
            sc = E_OUTOFMEMORY;
        }
        else
        {
            sc = Convert_LPOLESTR_to_VPSTR( psm32->lpszFileName,
                                            vpstr, uiSize, uiSize*2 );
            if (FAILED(sc))
            {
                TaskFree16(vpstr);
            }
            else
            {
                psm16 = FIXVDMPTR(vpsm16, STGMEDIUM);
                psm16->lpszFileName = (LPOLESTR)vpstr;
                RELVDMPTR(vpsm16);

#if DBG == 1
                thkDebugOut((DEB_ARGS, "3216    TYMED_FILE: '%s' (%ws)\n",
                             WOWFIXVDMPTR(vpstr, 0),
                             psm32->lpszFileName));
                WOWRELVDMPTR(vpstr);
#endif
            }
        }
        break;

    case TYMED_ISTREAM:
        vpvUnk = pti->pThkMgr->FindProxy1632(NULL, psm32->pstm, NULL,
                                             INDEX_IIDIDX(THI_IStream),
                                             NULL);
        if (vpvUnk == 0)
        {
            sc = E_OUTOFMEMORY;
        }
        else
        {
            thkDebugOut((DEB_ARGS, "3216    TYMED_ISTREAM: %p -> %p\n",
                         psm32->pstm, vpvUnk));

            psm16 = FIXVDMPTR(vpsm16, STGMEDIUM);
            psm16->pstm = (IStream *)vpvUnk;
            RELVDMPTR(vpsm16);
        }
        break;

    case TYMED_ISTORAGE:
        vpvUnk = pti->pThkMgr->FindProxy1632(NULL, psm32->pstg, NULL,
                                             INDEX_IIDIDX(THI_IStorage),
                                             NULL);
        if (vpvUnk == 0)
        {
            sc = E_OUTOFMEMORY;
        }
        else
        {
            thkDebugOut((DEB_ARGS, "3216    TYMED_ISTORAGE: %p -> %p\n",
                         psm32->pstg, vpvUnk));

            psm16 = FIXVDMPTR(vpsm16, STGMEDIUM);
            psm16->pstg = (IStorage *)vpvUnk;
            RELVDMPTR(vpsm16);
        }
        break;

    case TYMED_GDI:
        psm16 = FIXVDMPTR(vpsm16, STGMEDIUM);
        psm16->hBitmap = (HBITMAP)HBITMAP_16(psm32->hBitmap);
        thkDebugOut((DEB_ARGS, "3216    TYMED_GDI: 0x%p -> 0x%04X\n",
                     psm32->hBitmap, psm16->hBitmap));
        RELVDMPTR(vpsm16);
        break;

    case TYMED_NULL:
        break;

    default:
        sc = E_INVALIDARG;
        break;
    }

    if (FAILED(sc))
    {
        if (vpsrh != 0)
        {
            WOWGlobalUnlockFree16(vpsrh);
        }
    }
    else
    {
        if (vpsrh != 0)
        {
            CSm16ReleaseHandler UNALIGNED *psrh;
            CLIPFORMAT cf;

            if (pfe)
            {
                cf = pfe->cfFormat;
            }
            else
            {
                cf = CF_INVALID;
            }
            thkAssert(psm32->pUnkForRelease);
            psrh = FIXVDMPTR(vpsrh, CSm16ReleaseHandler);
            psrh->Init(pti->pThkMgr, psm32, FIXVDMPTR(vpsm16, STGMEDIUM),
                       psm32->pUnkForRelease, cf);
            RELVDMPTR(vpsrh);
            RELVDMPTR(vpsm16);
        }

#if DBG == 1
        if (pfe)
        {
            thkDebugOut((DEB_ARGS, "3216    STGMEDIUM FORMATETC %p {%d}\n",
                         pfe, pfe->cfFormat));
        }
        thkDebugOut((DEB_ARGS, "3216    STGMEDIUM: %p {%d, %p, ...} -> "
                     "%p {%d, %p, ...}\n", psm32, psm32->tymed,
                     psm32->pUnkForRelease, vpsm16, psm16->tymed,
                     psm16->pUnkForRelease));
#endif
    }

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   CleanStgMed16, public
//
//  Synopsis:   Frees up resources in a 16-bit STGMEDIUM
//
//  Arguments:  [pti] - Thunk info
//              [vpsm16] - STGMEDIUM to clean
//              [psm32] - Source STGMEDIUM if thunk
//              [dwSize] - Source size for thunked HGLOBAL
//              [fIsThunk] - If the STGMEDIUM is a result of thunking
//              [pfe] - FORMATETC or NULL
//
//  Returns:    Appropriate status code
//
//  History:    24-Apr-94       DrewB   Created
//
//----------------------------------------------------------------------------

SCODE CleanStgMed16(THUNKINFO *pti,
                    VPVOID vpsm16,
                    STGMEDIUM *psm32,
                    DWORD dwSize,
                    BOOL fIsThunk,
                    FORMATETC *pfe)
{
    SCODE sc;
    STGMEDIUM UNALIGNED *psm16;
    VPVOID vpvUnk, vpv;
    HMEM16 hmem16;
    BOOL fCleanup = TRUE;

    thkDebugOut((DEB_ITRACE, "In  CleanStgMed16(%p, %p, %p, %u, %d, %p)\n",
                 pti, vpsm16, psm32, dwSize, fIsThunk, pfe));

    sc = S_OK;

    psm16 = FIXVDMPTR(vpsm16, STGMEDIUM);
    vpvUnk = (VPVOID)psm16->pUnkForRelease;
    RELVDMPTR(vpsm16);

    if (fIsThunk && vpvUnk)
    {
        // This means that the current call failed
        // Inform the 32-bit punkForRelease created during thunking
        // so that it would cleanup 32-bit STGMEDIUM
        CSm16ReleaseHandler UNALIGNED *psrh;

        psrh = FIXVDMPTR(vpvUnk, CSm16ReleaseHandler);
        psrh->CallFailed();
        RELVDMPTR(vpvUnk);
        fCleanup = FALSE;
    }

    psm16 = FIXVDMPTR(vpsm16, STGMEDIUM);
    switch( psm16->tymed )
    {
    case TYMED_HGLOBAL:
        hmem16 = (HMEM16)psm16->hGlobal;
        RELVDMPTR(vpsm16);

        if (fIsThunk &&
            (pfe == NULL || !OBJDESC_CF(pfe->cfFormat)))
        {
            sc = ConvertHGlobal1632(pti, hmem16, 0,
                                    &psm32->hGlobal, &dwSize);
        }

        if(fCleanup)
            WOWGlobalFree16(hmem16);

        break;

    case TYMED_MFPICT:
        hmem16 = (HMEM16)psm16->hGlobal;
        RELVDMPTR(vpsm16);

        //  Chicago uses the same GDI handles for both 32bit and 16bit worlds.
        //  Don't delete the handle after a copy since Chicago doesn't actually
        //  copy the handle.
        if(fCleanup) {
#if !defined(_CHICAGO_)
            VPVOID vpvmfp16;
            METAFILEPICT16 *pmfp16;
            HMEM16 hmf16;

            vpvmfp16 = WOWGlobalLock16(hmem16);
            pmfp16 = FIXVDMPTR(vpvmfp16, METAFILEPICT16);
            hmf16 = pmfp16->hMF;
            RELVDMPTR(vpvmfp16);

            // Relies on the fact that a 16-bit metafile is an HGLOBAL
            WOWGlobalFree16(hmf16);

            WOWGlobalUnlockFree16(vpvmfp16);
#else
            WOWGlobalFree16(hmem16);
#endif
        }
        break;

    case TYMED_FILE:
        vpv = (VPVOID)psm16->lpszFileName;
        RELVDMPTR(vpsm16);

        if(fCleanup)
            TaskFree16(vpv);
        break;

    case TYMED_ISTREAM:
        vpv = (VPVOID) psm16->pstm;
        RELVDMPTR(vpsm16);

        if(fIsThunk) {
            // Release the 16-bit stream interface
            ReleaseOnObj16(vpv);
        }
        break;

    case TYMED_ISTORAGE:
        vpv = (VPVOID) psm16->pstg;
        RELVDMPTR(vpsm16);

        if(fIsThunk) {
            // Release the 16-bit storage interface
            ReleaseOnObj16(vpv);
        }
        break;

    case TYMED_GDI:
        RELVDMPTR(vpsm16);

        //
        // No unthunking needed
        //
        break;

    case TYMED_NULL:
        RELVDMPTR(vpsm16);

        break;

    default:
        // Ignore, this case is handled on input
        thkAssert(!"CleanStgMed16 with invalid tymed");
        break;
    }

    if(fIsThunk && vpvUnk) {
        // Release the 16-bit STGMEDIUM vpvForRelease.
        // 16-bit STGMEDIUM would be cleaned up after the last release
        ReleaseOnObj16(vpvUnk);
    }

    thkDebugOut((DEB_ITRACE, "Out CleanStgMed16 => 0x%08lX\n", sc));

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Function:   ConvertFetc1632, public
//
//  Synopsis:   Converts a FORMATETC
//
//  Arguments:  [pti] - Thunk info
//              [vpfe16] - FORMATETC
//              [pfe32] - FORMATETC
//              [fFree] - Free resources as converting
//
//  Returns:    Appropriate status code
//
//  Modifies:   [pfe32]
//
//  History:    14-May-94       DrewB   Created
//				11-Dec-00		DickD	initialize pdv32 (prefix bug 22397)
//
//----------------------------------------------------------------------------

SCODE ConvertFetc1632(THUNKINFO *pti,
                      VPVOID vpfe16,
                      FORMATETC *pfe32,
                      BOOL fFree)
{
    FORMATETC16 UNALIGNED *pfe16;
    VPVOID vpdv16;
    DVTARGETDEVICE *pdv32 = NULL;
    UINT cbSize;
    SCODE sc;

    pfe16 = FIXVDMPTR(vpfe16, FORMATETC16);
    vpdv16 = (VPVOID)pfe16->ptd;
    RELVDMPTR(vpfe16);

    if ( vpdv16 == 0 )
    {
        pdv32 = NULL;
    }
    else
    {
        sc = ConvertDvtd1632(pti, vpdv16, ArTask32, FrTask32,
                             &pdv32, &cbSize);

        if (fFree)
        {
            TaskFree16(vpdv16);
        }

        if (FAILED(sc))
        {
            return sc;
        }
    }

    pfe16 = FIXVDMPTR(vpfe16, FORMATETC16);
    pfe32->cfFormat = pfe16->cfFormat;
    pfe32->ptd      = pdv32;
    pfe32->dwAspect = pfe16->dwAspect;
    pfe32->lindex   = pfe16->lindex;
    pfe32->tymed    = pfe16->tymed;

    thkDebugOut((DEB_ARGS, "1632    FORMATETC: "
                 "%p -> %p {%d, %p (%p), %u, %u, 0x%X}\n",
                 vpfe16, pfe32,
                 pfe32->cfFormat,
                 pfe32->ptd, vpdv16,
                 pfe32->dwAspect,
                 pfe32->lindex,
                 pfe32->tymed));

    RELVDMPTR(vpfe16);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   ConvertFetc3216, public
//
//  Synopsis:   Converts a FORMATETC
//
//  Arguments:  [pti] - Thunk info
//              [pfe32] - FORMATETC
//              [vpfe16] - FORMATETC
//              [fFree] - Free resources as converting
//
//  Returns:    Appropriate status code
//
//  Modifies:   [vpfe16]
//
//  History:    14-May-94       DrewB   Created
//
//----------------------------------------------------------------------------

SCODE ConvertFetc3216(THUNKINFO *pti,
                      FORMATETC *pfe32,
                      VPVOID vpfe16,
                      BOOL fFree)
{
    FORMATETC16 UNALIGNED *pfe16;
    DVTARGETDEVICE *pdv32;
    SCODE sc;
    VPVOID vpdv16;
    UINT cbSize;

    pdv32 = pfe32->ptd;
    if (pdv32 != NULL)
    {
        sc = ConvertDvtd3216(pti, pdv32, ArTask16, FrTask16,
                             &vpdv16, &cbSize);

        if (fFree)
        {
            TaskFree32(pdv32);
        }

        if (FAILED(sc))
        {
            return sc;
        }
    }
    else
    {
        vpdv16 = 0;
    }

    pfe16 = FIXVDMPTR(vpfe16, FORMATETC16);
    pfe16->cfFormat = pfe32->cfFormat;
    pfe16->ptd      = vpdv16;
    pfe16->dwAspect = pfe32->dwAspect;
    pfe16->lindex   = pfe32->lindex;
    pfe16->tymed    = pfe32->tymed;

    thkDebugOut((DEB_ARGS, "3216    FORMATETC: "
                 "%p -> %p {%d, %p (%p), %u, %u, 0x%X}\n",
                 pfe32, vpfe16,
                 pfe16->cfFormat,
                 vpdv16, pdv32,
                 pfe16->dwAspect,
                 pfe16->lindex,
                 pfe16->tymed));

    RELVDMPTR(vpfe16);

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   DebugValidateProxy1632, debug public
//
//  Synopsis:   Validates a 16->32 proxy pointer and its memory
//
//  Arguments:  [vpvProxy] - Proxy
//
//  History:    07-Jul-94       DrewB   Created
//
//----------------------------------------------------------------------------

#if DBG == 1
void DebugValidateProxy1632(VPVOID vpvProxy)
{
    THUNK1632OBJ UNALIGNED *pto;
    THUNKINFO ti;

    thkAssert(vpvProxy != 0 && "Invalid proxy pointer");

    pto = (THUNK1632OBJ UNALIGNED *)
        GetReadWritePtr16(&ti, vpvProxy, sizeof(THUNK1632OBJ));
    thkAssert(pto != NULL && "Invalid proxy pointer");

    thkAssert(pto->dwSignature == PSIG1632 && "Dead or invalid proxy!");

    thkAssert(pto->cRefLocal>=0 && "Invalid proxy refcount");
    thkAssert(pto->cRefLocal>=pto->cRef && "Invalid proxy refcount");
    thkAssert((pto->cRefLocal>0 && pto->cRef>0) || (pto->cRef==0 && pto->cRefLocal==0));
    thkAssert(pto->pphHolder && "Proxy without a holder");

    if (!IsValidInterface(pto->punkThis32))
    {
        thkDebugOut((DEB_ERROR, "1632 %p: Invalid proxied object %p\n",
                     vpvProxy, pto->punkThis32));
    }

    WOWRELVDMPTR(vpvProxy);
}
#endif

//+---------------------------------------------------------------------------
//
//  Function:   DebugValidateProxy3216, debug public
//
//  Synopsis:   Validates a 32->16 proxy pointer and its memory
//
//  Arguments:  [pto] - Proxy
//
//  History:    07-Jul-94       DrewB   Created
//
//----------------------------------------------------------------------------

#if DBG == 1
void DebugValidateProxy3216(THUNK3216OBJ *pto)
{
    THUNKINFO ti;

    thkAssert(pto != 0 && "Invalid proxy pointer");

    thkAssert(!IsBadReadPtr(pto, sizeof(THUNK3216OBJ)) &&
              !IsBadWritePtr(pto, sizeof(THUNK3216OBJ)) &&
              "Invalid proxy pointer");

    thkAssert(pto->dwSignature == PSIG3216 && "Dead or invalid proxy!");

    thkAssert(pto->cRefLocal>=0 && "Invalid proxy refcount");
    thkAssert(pto->cRefLocal>=pto->cRef && "Invalid proxy refcount");
    thkAssert((pto->cRefLocal>0 && pto->cRef>0) || (pto->cRef==0 && pto->cRefLocal==0));
    thkAssert(pto->pphHolder && "Proxy without a holder");

    if (!IsValidInterface16(&ti, pto->vpvThis16))
    {
        thkDebugOut((DEB_ERROR, "3216 %p: Invalid proxied object %p\n",
                     pto, pto->vpvThis16));
    }
}
#endif

//+---------------------------------------------------------------------------
//
//  Function:   ClampLongToShort, public
//
//  Synopsis:   Restricts a long value to a short value by clamping
//
//  Arguments:  [l] - Long
//
//  Returns:    Short
//
//  History:    16-Aug-94       DrewB   Created
//
//----------------------------------------------------------------------------

SHORT ClampLongToShort(LONG l)
{
    SHORT s;

    if (l < SHRT_MIN)
    {
        s = SHRT_MIN;
        thkDebugOut((DEB_WARN, "ClampLongToShort: %ld -> %d\n", l, s));
    }
    else if (l > SHRT_MAX)
    {
        s = SHRT_MAX;
        thkDebugOut((DEB_WARN, "ClampLongToShort: %ld -> %d\n", l, s));
    }
    else
    {
        s = (SHORT)l;
    }

    return s;
}

//+---------------------------------------------------------------------------
//
//  Function:   ClampULongToUShort, public
//
//  Synopsis:   Restricts an unsigned long value to an unsigned short value
//              by clamping
//
//  Arguments:  [ul] - Long
//
//  Returns:    UShort
//
//  History:    16-Aug-94       DrewB   Created
//
//----------------------------------------------------------------------------

USHORT ClampULongToUShort(ULONG ul)
{
    USHORT us;

    if (ul > USHRT_MAX)
    {
        us = USHRT_MAX;
        thkDebugOut((DEB_WARN, "ClampULongToUShort: %ld -> %d\n", ul, us));
    }
    else
    {
        us = (USHORT)ul;
    }

    return us;
}

//+---------------------------------------------------------------------------
//
//  Function:   ConvertObjDescriptor
//
//  Synopsis:   Exported API called by WOW to convert ObjectDescriptors to
//              the indicated format.
//
//
//  Arguments:  [hMem] --  Handle to the ObjectDescriptor to convert.
//              [flag] --  Flag indicating which direction the convertion
//              should take place.  Valid values are:
//                          CFOLE_UNICODE_TO_ANSI.
//                          CFOLE_ANSI_TO_UNICODE.
//
//  Returns:    HGLOBAL to the converted ObjectDescriptor,
//              or NULL on failure.
//
//  History:    8-16-94   terryru   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
STDAPI_(HGLOBAL) ConvertObjDescriptor( HANDLE hMem, UINT flag )
{

   const UINT CFOLE_UNICODE_TO_ANSI = 0;
   const UINT CFOLE_ANSI_TO_UNICODE = 1;

   THUNKINFO ti;
   HGLOBAL hMem32;
   HMEM16  hMem16;

    switch ( flag )
    {
    case CFOLE_UNICODE_TO_ANSI:
        if( FAILED( ConvertObjDesc3216( &ti, (HGLOBAL) hMem, &hMem16 )))
        {
            return (HGLOBAL) NULL;
        }
        else
        {
            return (HGLOBAL)  hMem16;
        }
        break;

    case CFOLE_ANSI_TO_UNICODE:
        if( FAILED( ConvertObjDesc1632( &ti, (HMEM16) hMem, &hMem32 )))
        {
            return (HGLOBAL) NULL;
        }
        else
        {
            return (HGLOBAL) hMem32;
        }
        break;

    default:
        thkAssert(!"ConvertObjDescriptor, Invalid flag");
        break;
    }
    return (HGLOBAL) NULL;
}

#if defined(_CHICAGO_)

//
//  A hack so everyone can build Chicago OLE until I write the thunking
//  library later this week.
//
//  (15-Feb-2000:  I find the fact that this comment is still here amazingly
//                 entertaining - JohnDoty)
//

#define ERR ((char*) -1)

#if DBG==1
int UnicodeToAnsi(LPSTR sz, LPCWSTR pwsz, LONG cb)
{
    int ret;

    ret = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, pwsz, -1, sz, cb, NULL, NULL);

    thkAssert(ret != 0 && "Lost characters in thk Unicode->Ansi conversion");
    if (ret == 0)
    {
        DebugBreak();
    }

    return ret;
}
#else
#define UnicodeToAnsi(sz,pwsz,cb) WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, pwsz, -1, sz, cb, NULL, NULL)
#endif


#if DBG==1
int AnsiToUnicode(LPWSTR pwsz, LPCSTR sz, LONG cb)
{
    int ret;

    ret = MultiByteToWideChar (CP_ACP, MB_PRECOMPOSED, sz, -1, pwsz, cb);

    thkAssert(ret != 0 && "Lost characters in thk Ansi->Unicode conversion");
    if (ret == 0)
    {
        DebugBreak();
    }

    return ret;
}
#else
#define AnsiToUnicode(pwsz,sz,cb) MultiByteToWideChar (CP_ACP, MB_PRECOMPOSED, sz, -1, pwsz, cb)
#endif



extern "C"
DWORD
WINAPI
GetShortPathNameX(
    LPCWSTR lpszFullPath,
    LPWSTR  lpszShortPath,
    DWORD   cchBuffer
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("GetShortPathName\n");
    #endif

    CHAR  szFullPath[MAX_PATH];
    CHAR  szShortBuffer[MAX_PATH];
    DWORD ret;


    UnicodeToAnsi(szFullPath, lpszFullPath, sizeof(szFullPath));

    if (lpszShortPath == NULL)
    {
        ret = GetShortPathNameA(szFullPath, NULL, cchBuffer);
    }
    else
    {
        ret = GetShortPathNameA(szFullPath, szShortBuffer,
                                sizeof(szShortBuffer));

        thkAssert(ret != cchBuffer &&
                  "GetShortPathName - Output buffer too short");
        //
        // Don't convert the buffer if the
        // call to GetShortPathNameA() failed.
        //
        if(0 != ret)
        {
            //
            //  Only convert the actual data, not the whole buffer.
            //
            if (cchBuffer > ret + 1)
                cchBuffer = ret + 1;

            AnsiToUnicode(lpszShortPath, szShortBuffer, cchBuffer);
        }
    }

    return ret;
}

#endif  // _CHICAGO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\olethk32\thtblapi.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	thtblapi.cxx
//
//  Notes:	This file is automatically generated
//		Do not modify by hand
//
//  History:	Fri May 27 10:39:02 1994	Generated
//
//----------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

#include "thopsapi.cxx"

THOP CONST * CONST apthopsApiThops[] =
{
    thopsCoInitialize
,    thopsCoUninitialize
,    thopsCoGetClassObject
,    thopsCoRegisterClassObject
,    thopsCoRevokeClassObject
,    thopsCoMarshalInterface
,    thopsCoUnmarshalInterface
,    thopsCoReleaseMarshalData
,    thopsCoDisconnectObject
,    thopsCoLockObjectExternal
,    thopsCoGetStandardMarshal
,    thopsCoIsHandlerConnected
,    thopsCoFreeAllLibraries
,    thopsCoFreeUnusedLibraries
,    thopsCoCreateInstance
,    thopsCLSIDFromString
,    thopsCoIsOle1Class
,    thopsProgIDFromCLSID
,    thopsCLSIDFromProgID
,    thopsCoCreateGuid
,    thopsCoFileTimeToDosDateTime
,    thopsCoDosDateTimeToFileTime
,    thopsCoFileTimeNow
,    thopsCoRegisterMessageFilter
,    thopsCoGetTreatAsClass
,    thopsCoTreatAsClass
,    thopsDllGetClassObject
,    thopsStgCreateDocfile
,    thopsStgCreateDocfileOnILockBytes
,    thopsStgOpenStorage
,    thopsStgOpenStorageOnILockBytes
,    thopsStgIsStorageFile
,    thopsStgIsStorageILockBytes
,    thopsStgSetTimes
,    thopsCreateDataAdviseHolder
,    thopsCreateDataCache
,    thopsBindMoniker
,    thopsMkParseDisplayName
,    thopsMonikerRelativePathTo
,    thopsMonikerCommonPrefixWith
,    thopsCreateBindCtx
,    thopsCreateGenericComposite
,    thopsGetClassFile
,    thopsCreateFileMoniker
,    thopsCreateItemMoniker
,    thopsCreateAntiMoniker
,    thopsCreatePointerMoniker
,    thopsGetRunningObjectTable
,    thopsReadClassStg
,    thopsWriteClassStg
,    thopsReadClassStm
,    thopsWriteClassStm
,    thopsWriteFmtUserTypeStg
,    thopsReadFmtUserTypeStg
,    thopsOleInitialize
,    thopsOleUninitialize
,    thopsOleQueryLinkFromData
,    thopsOleQueryCreateFromData
,    thopsOleCreate
,    thopsOleCreateFromData
,    thopsOleCreateLinkFromData
,    thopsOleCreateStaticFromData
,    thopsOleCreateLink
,    thopsOleCreateLinkToFile
,    thopsOleCreateFromFile
,    thopsOleLoad
,    thopsOleSave
,    thopsOleLoadFromStream
,    thopsOleSaveToStream
,    thopsOleSetContainedObject
,    thopsOleNoteObjectVisible
,    thopsRegisterDragDrop
,    thopsRevokeDragDrop
,    thopsDoDragDrop
,    thopsOleSetClipboard
,    thopsOleGetClipboard
,    thopsOleFlushClipboard
,    thopsOleIsCurrentClipboard
,    thopsOleCreateMenuDescriptor
,    thopsOleSetMenuDescriptor
,    thopsOleDestroyMenuDescriptor
,    thopsOleDraw
,    thopsOleRun
,    thopsOleIsRunning
,    thopsOleLockRunning
,    thopsCreateOleAdviseHolder
,    thopsOleCreateDefaultHandler
,    thopsOleCreateEmbeddingHelper
,    thopsOleRegGetUserType
,    thopsOleRegGetMiscStatus
,    thopsOleRegEnumFormatEtc
,    thopsOleRegEnumVerbs
,    thopsOleConvertIStorageToOLESTREAM
,    thopsOleConvertOLESTREAMToIStorage
,    thopsOleConvertIStorageToOLESTREAMEx
,    thopsOleConvertOLESTREAMToIStorageEx
,    thopsOleDoAutoConvert
,    thopsOleGetAutoConvert
,    thopsOleSetAutoConvert
,    thopsGetConvertStg
,    thopsSetConvertStg
,    thopsReadOleStg
,    thopsWriteOleStg
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\olethk32\tlsthk.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       tlsthk.cxx
//
//  Contents:   Utility routines for logical thread data
//
//  History:    5-18-94   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
#include "headers.cxx"
#pragma hdrstop

#define UNINITIALIZED_INDEX (0xffffffff)

DWORD dwTlsThkIndex = UNINITIALIZED_INDEX;

//+---------------------------------------------------------------------------
//
//  Function:   TlsThkGetData
//
//  Synopsis:   returns pointer to thread data
//
//  Returns:    pointer to threaddata
//
//  History:    5-18-94   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------

#if DBG == 1
PThreadData TlsThkGetData(void)
{
    if (dwTlsThkIndex == UNINITIALIZED_INDEX)
    {
        thkDebugOut((DEB_WARN, "WARNING: TLS slot used when uninitialized\n"));
    }

    PThreadData pThreaddata = (PThreadData) TlsGetValue(dwTlsThkIndex);

    return pThreaddata;
}
#endif

//+---------------------------------------------------------------------------
//
//  Function:   TlsThkAlloc
//
//  Synopsis:   allocates a slot for thread data
//
//  Returns:    BOOL
//
//  History:    5-18-94   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
BOOL TlsThkAlloc(void)
{
    thkDebugOut((DEB_THUNKMGR, "In TlsThkAlloc\n"));

    // We must be uninitialized to call this routine
    thkAssert(dwTlsThkIndex == UNINITIALIZED_INDEX);

    dwTlsThkIndex = TlsAlloc();
    if (dwTlsThkIndex == UNINITIALIZED_INDEX)
    {
        return FALSE;
    }

    thkDebugOut((DEB_THUNKMGR, "Out TlsThkAlloc\n"));
    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Function:  	GetTaskName
//
//  Synopsis: 	Obtain the 16-bit task name
//
//  Author:     July 14,97     Gopalk     Created
//
//--------------------------------------------------------------------------

// these 2 from com\inc\ole2int.h
#define IncLpch(sz)          ((sz)=CharNext ((sz)))
#define DecLpch(szStart, sz) ((sz)=CharPrev ((szStart),(sz)))

// Helper function for IsTaskName
inline BOOL IsPathSeparator( WCHAR ch )
{
    return (ch == TCHAR('\\') || ch == TCHAR('/') || ch == TCHAR(':'));
}

FARINTERNAL_(BOOL) IsTaskName(LPCTSTR lpszIn)
{
    TCHAR atszImagePath[MAX_PATH] = _T("");
    BOOL retval = FALSE;

    if (GetModuleFileName(NULL, atszImagePath, MAX_PATH))
    {
        TCHAR * pch;
        LONG len=0;         // length of exe name after last separator
        LONG N;             // length of lpszIn

        // Get last component of path

        //
        // Find the end of the string and determine the string length.
        //
        for (pch=atszImagePath; *pch; pch++);

        DecLpch (atszImagePath, pch);   // pch now points to the last real char

        while (!IsPathSeparator(*pch)) {
           DecLpch (atszImagePath, pch);
           len++;
        }

        // we're at the last separator. 
        // we want to do an lstrNcmpi (found cases where there was a non-null
        // char at the end of the exe name eg. "WINWORD.EXE>#")

        N = lstrlen(lpszIn);
        if (len > N) {      // simulate lstrNcmpi (don't have one available)
            //pch+1 is the 0th char after the separator
            TCHAR saveChar = *(pch+1+N);    // save N+1 th char
            *(pch+1+N) = 0;         
            if (!lstrcmpi(pch+1, lpszIn))
                retval = TRUE;
            *(pch+1+N) = saveChar;          // restore N+1 th char
        }
        else if (!lstrcmpi(pch+1, lpszIn)) {
            retval = TRUE;
        }
    }

    return retval;
}


//+---------------------------------------------------------------------------
//
//  Function:   TlsThkInitialize
//
//  Synopsis:   allocates thread data and initialize slot
//
//  Returns:    Appropriate status code
//
//  History:    5-18-94   JohannP (Johann Posch)   Created
//              7-14-97   Gopalk                   Added compatiblity flags 
//                                                 based on the image name
//
//----------------------------------------------------------------------------
HRESULT TlsThkInitialize(void)
{
    PThreadData pThreaddata;
    TCHAR pwszImagePath[MAX_PATH];
    TCHAR *pch;

    thkDebugOut((DEB_THUNKMGR, "In TlsThkInitialize\n"));

    thkAssert(dwTlsThkIndex != UNINITIALIZED_INDEX &&
              "Tls slot not allocated.");

    // We must be uninitialized to call this routine
    thkAssert(TlsGetValue(dwTlsThkIndex) == 0);

    pThreaddata = (PThreadData) LocalAlloc(LPTR, sizeof (ThreadData));
    if(pThreaddata != NULL)
    {
        // Force construction since we allocated with LocalAlloc
        pThreaddata->sa16.CStackAllocator::
            CStackAllocator(&mmodel16Owned, 1024, 2);
        pThreaddata->sa32.CStackAllocator::
            CStackAllocator(&mmodel32, 8192, 8);

        pThreaddata->pCThkMgr = 0;
        pThreaddata->dwAppCompatFlags = 0;
        pThreaddata->pAggHolderList = 0;

        if (IsTaskName(TEXT("WINWORD.EXE")) || 
            IsTaskName(TEXT("MSWORKS.EXE")) || 
            IsTaskName(TEXT("WPWIN61.EXE")) ||
            IsTaskName(TEXT("QPW.EXE"))     ||
            IsTaskName(TEXT("PDOXWIN.EXE")) )
        {
            thkDebugOut((DEB_WARN, "OleIsCurrentClipBoard hack enabled\n"));
            pThreaddata->dwAppCompatFlags |= OACF_WORKSCLIPOBJ;
        }
        else if (IsTaskName(TEXT("CORELPNT.EXE")))
        {
            thkDebugOut((DEB_WARN, "CorelPaint 5.0 hack enabled\n"));
            pThreaddata->dwAppCompatFlags |= OACF_CRLPNTPERSIST;
        }
        else if (IsTaskName(TEXT("TEXTART.EXE")))
        {
            thkDebugOut((DEB_WARN, "TextArt DAHolder::DAdvise hack enabled\n"));
            pThreaddata->dwAppCompatFlags |= OACF_TEXTARTDOBJ;
        }

        TlsSetValue(dwTlsThkIndex, pThreaddata);
    }

    thkDebugOut((DEB_THUNKMGR, "Out TlsThkInitialize\n"));

    return (pThreaddata != NULL) ? NOERROR : E_OUTOFMEMORY;
}

//+---------------------------------------------------------------------------
//
//  Function:   TlsThkUninitialize
//
//  Synopsis:   frees thread data and set it to NULL
//
//  History:    5-18-94   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
void TlsThkUninitialize(void)
{
    thkDebugOut((DEB_TLSTHK, "In TlsThkUninitialize\n"));

    // Asserts if data is NULL
    PThreadData pThreaddata = TlsThkGetData();

    // We should assert that the things in the ThreadData
    // are freed up

    if (pThreaddata != NULL)
    {
        // Stack allocators are cleaned up elsewhere
        // because they require special treatment

	if (pThreaddata->pDelayedRegs != NULL)
	{
	    delete pThreaddata->pDelayedRegs;
	}
	LocalFree(pThreaddata);
    }

    TlsSetValue(dwTlsThkIndex, NULL);

    thkDebugOut((DEB_TLSTHK, "Out TlsThkUninitialize\n"));
}

//+---------------------------------------------------------------------------
//
//  Function:   TlsThkFree
//
//  Synopsis:   frees slot
//
//  History:    5-18-94   JohannP (Johann Posch)   Created
//
//----------------------------------------------------------------------------
void TlsThkFree(void)
{
    thkAssert(dwTlsThkIndex != UNINITIALIZED_INDEX);

    TlsFree( dwTlsThkIndex );

    // We must set this to an invalid value so any further uses of the
    // TLS slot will return NULL
    dwTlsThkIndex = UNINITIALIZED_INDEX;
}

//+---------------------------------------------------------------------------
//
//  Function:   TlsThkLinkAggHolder
//
//  Synopsis:   Links ProxyHolder node into a list in TLS (used in Aggregation)
//
//  History:    2-11-98   MPrabhu   Created
//
//----------------------------------------------------------------------------
void TlsThkLinkAggHolder(SAggHolder *pNode)
{
    SAggHolder *head = TlsThkGetAggHolderList();
    pNode->next = head;
    TlsThkSetAggHolderList(pNode);
}

//+---------------------------------------------------------------------------
//
//  Function:   TlsThkGetAggHolder
//
//  Synopsis:   Gets the last ProxyHolder node that was linked into TLS list
//
//  History:    2-11-98   MPrabhu   Created
//
//----------------------------------------------------------------------------
SAggHolder* TlsThkGetAggHolder(void)
{
    SAggHolder *head = TlsThkGetAggHolderList();
    thkAssert(head);
    return head;
}


//+---------------------------------------------------------------------------
//
//  Function:   TlsThkGetAggHolder
//
//  Synopsis:   Unlinks the last ProxyHolder node that was linked into TLS list
//
//  History:    2-11-98   MPrabhu   Created
//
//----------------------------------------------------------------------------
void TlsThkUnlinkAggHolder(void)
{
    SAggHolder *head = TlsThkGetAggHolderList();
    thkAssert(head);
    TlsThkSetAggHolderList(head->next);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\olethk32\vtblapi.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	vtblapi.cxx
//
//  Notes:	This file is automatically generated
//		Do not modify by hand
//
//  History:	Fri May 27 10:39:02 1994	Generated
//
//----------------------------------------------------------------------------

#include <headers.cxx>
#pragma hdrstop

VTBLFN CONST apfnApiFunctions[] =
{
    (VTBLFN)CoInitializeNot
,    (VTBLFN)CoUninitialize
,    (VTBLFN)CoGetClassObject
,    (VTBLFN)CoRegisterClassObjectNot
,    (VTBLFN)CoRevokeClassObjectNot
,    (VTBLFN)CoMarshalInterface
,    (VTBLFN)CoUnmarshalInterface
,    (VTBLFN)CoReleaseMarshalData
,    (VTBLFN)CoDisconnectObject
,    (VTBLFN)CoLockObjectExternal
,    (VTBLFN)CoGetStandardMarshal
,    (VTBLFN)CoIsHandlerConnected
,    (VTBLFN)CoFreeAllLibraries
,    (VTBLFN)CoFreeUnusedLibraries
,    (VTBLFN)CoCreateInstance
,    (VTBLFN)CLSIDFromString
,    (VTBLFN)CoIsOle1Class
,    (VTBLFN)ProgIDFromCLSID
,    (VTBLFN)CLSIDFromProgID
,    (VTBLFN)CoCreateGuid
,    (VTBLFN)CoFileTimeToDosDateTime
,    (VTBLFN)CoDosDateTimeToFileTime
,    (VTBLFN)CoFileTimeNow
,    (VTBLFN)CoRegisterMessageFilter
,    (VTBLFN)CoGetTreatAsClass
,    (VTBLFN)CoTreatAsClass
,    (VTBLFN)DllGetClassObjectWOW
,    (VTBLFN)StgCreateDocfile
,    (VTBLFN)StgCreateDocfileOnILockBytes
,    (VTBLFN)StgOpenStorage
,    (VTBLFN)StgOpenStorageOnILockBytes
,    (VTBLFN)StgIsStorageFile
,    (VTBLFN)StgIsStorageILockBytes
,    (VTBLFN)StgSetTimes
,    (VTBLFN)CreateDataAdviseHolder
,    (VTBLFN)CreateDataCache
,    (VTBLFN)BindMoniker
,    (VTBLFN)MkParseDisplayName
,    (VTBLFN)MonikerRelativePathTo
,    (VTBLFN)MonikerCommonPrefixWith
,    (VTBLFN)CreateBindCtx
,    (VTBLFN)CreateGenericComposite
,    (VTBLFN)GetClassFile
,    (VTBLFN)CreateFileMoniker
,    (VTBLFN)CreateItemMoniker
,    (VTBLFN)CreateAntiMoniker
,    (VTBLFN)CreatePointerMoniker
,    (VTBLFN)GetRunningObjectTable
,    (VTBLFN)ReadClassStg
,    (VTBLFN)WriteClassStg
,    (VTBLFN)ReadClassStm
,    (VTBLFN)WriteClassStm
,    (VTBLFN)WriteFmtUserTypeStg
,    (VTBLFN)ReadFmtUserTypeStg
,    (VTBLFN)OleInitializeNot
,    (VTBLFN)OleUninitialize
,    (VTBLFN)OleQueryLinkFromData
,    (VTBLFN)OleQueryCreateFromData
,    (VTBLFN)OleCreate
,    (VTBLFN)OleCreateFromData
,    (VTBLFN)OleCreateLinkFromData
,    (VTBLFN)OleCreateStaticFromData
,    (VTBLFN)OleCreateLink
,    (VTBLFN)OleCreateLinkToFile
,    (VTBLFN)OleCreateFromFile
,    (VTBLFN)OleLoad
,    (VTBLFN)OleSave
,    (VTBLFN)OleLoadFromStream
,    (VTBLFN)OleSaveToStream
,    (VTBLFN)OleSetContainedObject
,    (VTBLFN)OleNoteObjectVisible
,    (VTBLFN)RegisterDragDrop
,    (VTBLFN)RevokeDragDrop
,    (VTBLFN)DoDragDrop
,    (VTBLFN)OleSetClipboard
,    (VTBLFN)OleGetClipboard
,    (VTBLFN)OleFlushClipboard
,    (VTBLFN)OleIsCurrentClipboard
,    (VTBLFN)OleCreateMenuDescriptor
,    (VTBLFN)OleSetMenuDescriptor
,    (VTBLFN)OleDestroyMenuDescriptor
,    (VTBLFN)OleDraw
,    (VTBLFN)OleRun
,    (VTBLFN)OleIsRunning
,    (VTBLFN)OleLockRunning
,    (VTBLFN)CreateOleAdviseHolder
,    (VTBLFN)OleCreateDefaultHandler
,    (VTBLFN)OleCreateEmbeddingHelper
,    (VTBLFN)OleRegGetUserTypeNot
,    (VTBLFN)OleRegGetMiscStatus
,    (VTBLFN)OleRegEnumFormatEtc
,    (VTBLFN)OleRegEnumVerbs
,    (VTBLFN)OleConvertIStorageToOLESTREAM
,    (VTBLFN)OleConvertOLESTREAMToIStorage
,    (VTBLFN)OleConvertIStorageToOLESTREAMEx
,    (VTBLFN)OleConvertOLESTREAMToIStorageEx
,    (VTBLFN)OleDoAutoConvert
,    (VTBLFN)OleGetAutoConvert
,    (VTBLFN)OleSetAutoConvert
,    (VTBLFN)GetConvertStg
,    (VTBLFN)SetConvertStg
,    (VTBLFN)ReadOleStg
,    (VTBLFN)WriteOleStg
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\olethk32\chicago\makefile.inc ===
olethk32.sym:
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\olethk32\thopsint.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:       thopsint.cxx
//
//  Notes:      This file is automatically generated
//              Do not modify by hand
//
//  History:    Fri May 27 10:39:02 1994        Generated
//
//----------------------------------------------------------------------------

THOP CONST thopsIClassFactory_CreateInstance[] =
{
    THOP_UNKOUTER | THOP_IN, THI_IUnknown, THOP_COPY | THOP_IN, 16, THOP_IFACEGENOWNER | THOP_OUT, 4, 8, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIClassFactory_LockServer[] =
{
    THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIMarshal_GetUnmarshalClass[] =
{
    THOP_COPY | THOP_IN, 16, THOP_IFACEGEN | THOP_IN, 4, THOP_COPY, 4, THOP_NULL | THOP_IN, THOP_COPY, 4, THOP_COPY | THOP_OUT, 16, THOP_END, THOP_ROUTINEINDEX, 4
};
THOP CONST thopsIMarshal_GetMarshalSizeMax[] =
{
    THOP_COPY | THOP_IN, 16, THOP_IFACEGEN | THOP_IN, 4, THOP_COPY, 4, THOP_NULL | THOP_IN, THOP_COPY, 4, THOP_COPY | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 4
};
THOP CONST thopsIMarshal_MarshalInterface[] =
{
    THOP_IFACE | THOP_IN, THI_IStream, THOP_COPY | THOP_IN, 16, THOP_IFACEGEN | THOP_IN, 4, THOP_COPY, 4, THOP_NULL | THOP_IN, THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 4
};
THOP CONST thopsIMarshal_UnmarshalInterface[] =
{
    THOP_IFACE | THOP_IN, THI_IStream, THOP_COPY | THOP_IN, 16, THOP_IFACEGEN | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIMarshal_ReleaseMarshalData[] =
{
    THOP_IFACE | THOP_IN, THI_IStream, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIMarshal_DisconnectObject[] =
{
    THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIStdMarshalInfo_GetClassForHandler[] =
{
    THOP_COPY, 4, THOP_NULL | THOP_IN, THOP_COPY | THOP_OUT, 16, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIMessageFilter_HandleInComingCall[] =
{
    THOP_RETURNTYPE, THOP_COPY, 4, THOP_COPY, 4, THOP_HTASK, THOP_COPY, 4, THOP_INTERFACEINFO | THOP_IN, THOP_END, THOP_ROUTINEINDEX, 5
};
THOP CONST thopsIMessageFilter_RetryRejectedCall[] =
{
    THOP_RETURNTYPE, THOP_COPY, 4, THOP_HTASK, THOP_COPY, 4, THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIMessageFilter_MessagePending[] =
{
    THOP_RETURNTYPE, THOP_COPY, 4, THOP_HTASK, THOP_COPY, 4, THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIExternalConnection_AddConnection[] =
{
    THOP_RETURNTYPE, THOP_COPY, 4, THOP_COPY, 4, THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIExternalConnection_ReleaseConnection[] =
{
    THOP_RETURNTYPE, THOP_COPY, 4, THOP_COPY, 4, THOP_COPY, 4, THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIEnumString_Next[] =
{
    THOP_ENUM, THE_IEnumString, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIEnumString_Skip[] =
{
    THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIEnumString_Reset[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIEnumString_Clone[] =
{
    THOP_IFACE | THOP_OUT, THI_IEnumString, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIEnumUnknown_Next[] =
{
    THOP_ENUM, THE_IEnumUnknown, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIEnumUnknown_Skip[] =
{
    THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIEnumUnknown_Reset[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIEnumUnknown_Clone[] =
{
    THOP_IFACE | THOP_OUT, THI_IEnumUnknown, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIEnumSTATSTG_Next[] =
{
    THOP_ENUM, THE_IEnumSTATSTG, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIEnumSTATSTG_Skip[] =
{
    THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIEnumSTATSTG_Reset[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIEnumSTATSTG_Clone[] =
{
    THOP_IFACE | THOP_OUT, THI_IEnumSTATSTG, THOP_END, THOP_ROUTINEINDEX, 3
};

// Note:    THOP_BUFFER | THOP_OUT takes care of the size of the input buffer
//          and the size of the output buffer.
THOP CONST thopsILockBytes_ReadAt[] =
{
    THOP_COPY, 8, THOP_BUFFER | THOP_OUT, THOP_END, THOP_ROUTINEINDEX, 9
};
THOP CONST thopsILockBytes_WriteAt[] =
{
    THOP_COPY, 8, THOP_BUFFER | THOP_IN, THOP_COPY | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 9
};
THOP CONST thopsILockBytes_Flush[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsILockBytes_SetSize[] =
{
    THOP_COPY, 8, THOP_END, THOP_ROUTINEINDEX, 10
};
THOP CONST thopsILockBytes_LockRegion[] =
{
    THOP_COPY, 8, THOP_COPY, 8, THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 11
};
THOP CONST thopsILockBytes_UnlockRegion[] =
{
    THOP_COPY, 8, THOP_COPY, 8, THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 11
};
THOP CONST thopsILockBytes_Stat[] =
{
    THOP_STATSTG | THOP_OUT, THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 0
};

// Note:    THOP_BUFFER | THOP_OUT takes care of the size of the input buffer
//          and the size of the output buffer.
THOP CONST thopsIStream_Read[] =
{
    THOP_BUFFER | THOP_OUT, THOP_END, THOP_ROUTINEINDEX, 2
};

THOP CONST thopsIStream_Write[] =
{
    THOP_BUFFER | THOP_IN, THOP_COPY | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIStream_Seek[] =
{
    THOP_COPY, 8, THOP_COPY, 4, THOP_COPY | THOP_OUT, 8, THOP_END, THOP_ROUTINEINDEX, 12
};
THOP CONST thopsIStream_SetSize[] =
{
    THOP_COPY, 8, THOP_END, THOP_ROUTINEINDEX, 10
};
THOP CONST thopsIStream_CopyTo[] =
{
    THOP_IFACE | THOP_IN, THI_IStream, THOP_COPY, 8, THOP_COPY | THOP_OUT, 8, THOP_COPY | THOP_OUT, 8, THOP_END, THOP_ROUTINEINDEX, 13
};
THOP CONST thopsIStream_Commit[] =
{
    THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIStream_Revert[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIStream_LockRegion[] =
{
    THOP_COPY, 8, THOP_COPY, 8, THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 11
};
THOP CONST thopsIStream_UnlockRegion[] =
{
    THOP_COPY, 8, THOP_COPY, 8, THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 11
};
THOP CONST thopsIStream_Stat[] =
{
    THOP_STATSTG | THOP_OUT, THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIStream_Clone[] =
{
    THOP_IFACE | THOP_OUT, THI_IStream, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIStorage_CreateStream[] =
{
    THOP_LPSTR | THOP_IN, THOP_COPY, 4, THOP_COPY, 4, THOP_COPY, 4, THOP_IFACE | THOP_OUT, THI_IStream, THOP_END, THOP_ROUTINEINDEX, 7
};
THOP CONST thopsIStorage_OpenStream[] =
{
    THOP_LPSTR | THOP_IN, THOP_NULL | THOP_IN, THOP_COPY, 4, THOP_COPY, 4, THOP_IFACE | THOP_OUT, THI_IStream, THOP_END, THOP_ROUTINEINDEX, 7
};
THOP CONST thopsIStorage_CreateStorage[] =
{
    THOP_LPSTR | THOP_IN, THOP_COPY, 4, THOP_COPY, 4, THOP_COPY, 4, THOP_IFACE | THOP_OUT, THI_IStorage, THOP_END, THOP_ROUTINEINDEX, 7
};
THOP CONST thopsIStorage_OpenStorage[] =
{
    THOP_LPSTR | THOP_IN, THOP_IFACE | THOP_IN, THI_IStorage, THOP_COPY, 4, THOP_SNB, THOP_COPY, 4, THOP_IFACE | THOP_OUT, THI_IStorage, THOP_END, THOP_ROUTINEINDEX, 4
};
THOP CONST thopsIStorage_CopyTo[] =
{
    THOP_CRGIID, THOP_SNB, THOP_IFACE | THOP_IN, THI_IStorage, THOP_END, THOP_ROUTINEINDEX, 5
};
THOP CONST thopsIStorage_MoveElementTo[] =
{
    THOP_LPSTR | THOP_IN, THOP_IFACE | THOP_IN, THI_IStorage, THOP_LPSTR | THOP_IN, THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 5
};
THOP CONST thopsIStorage_Commit[] =
{
    THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIStorage_Revert[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIStorage_EnumElements[] =
{
    THOP_COPY, 4, THOP_NULL | THOP_IN, THOP_COPY, 4, THOP_IFACE | THOP_OUT, THI_IEnumSTATSTG, THOP_END, THOP_ROUTINEINDEX, 5
};
THOP CONST thopsIStorage_DestroyElement[] =
{
    THOP_LPSTR | THOP_IN, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIStorage_RenameElement[] =
{
    THOP_LPSTR | THOP_IN, THOP_LPSTR | THOP_IN, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIStorage_SetElementTimes[] =
{
    THOP_LPSTR | THOP_IN, THOP_COPY | THOP_IN, 8, THOP_COPY | THOP_IN, 8, THOP_COPY | THOP_IN, 8, THOP_END, THOP_ROUTINEINDEX, 5
};
THOP CONST thopsIStorage_SetClass[] =
{
    THOP_COPY | THOP_IN, 16, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIStorage_SetStateBits[] =
{
    THOP_COPY, 4, THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIStorage_Stat[] =
{
    THOP_STATSTG | THOP_OUT, THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIRootStorage_SwitchToFile[] =
{
    THOP_LPSTR | THOP_IN, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIEnumFORMATETC_Next[] =
{
    THOP_ENUM, THE_IEnumFORMATETC, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIEnumFORMATETC_Skip[] =
{
    THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIEnumFORMATETC_Reset[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIEnumFORMATETC_Clone[] =
{
    THOP_IFACE | THOP_OUT, THI_IEnumFORMATETC, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIEnumSTATDATA_Next[] =
{
    THOP_ENUM, THE_IEnumSTATDATA, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIEnumSTATDATA_Skip[] =
{
    THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIEnumSTATDATA_Reset[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIEnumSTATDATA_Clone[] =
{
    THOP_IFACE | THOP_OUT, THI_IEnumSTATDATA, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIDataObject_GetData[] =
{
    THOP_FORMATETC | THOP_IN, THOP_STGMEDIUM | THOP_OUT, 0, 4, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIDataObject_GetDataHere[] =
{
    THOP_FORMATETC | THOP_IN, THOP_STGMEDIUM | THOP_IN, 0, 4, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIDataObject_QueryGetData[] =
{
    THOP_FORMATETC | THOP_IN, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIDataObject_GetCanonicalFormatEtc[] =
{
    THOP_FORMATETC | THOP_IN, THOP_FORMATETC | THOP_OUT, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIDataObject_SetData[] =
{
    THOP_FORMATETC | THOP_IN, THOP_STGMEDIUM | THOP_IN, 1, 4, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIDataObject_EnumFormatEtc[] =
{
    THOP_COPY, 4, THOP_IFACE | THOP_OUT, THI_IEnumFORMATETC, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIDataObject_DAdvise[] =
{
    THOP_FORMATETC | THOP_IN, THOP_COPY, 4, THOP_IFACE | THOP_IN, THI_IAdviseSink, THOP_COPY | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 5
};
THOP CONST thopsIDataObject_DUnadvise[] =
{
    THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIDataObject_EnumDAdvise[] =
{
    THOP_IFACE | THOP_OUT, THI_IEnumSTATDATA, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIViewObject_Draw[] =
{
    THOP_COPY, 4, THOP_COPY, 4, THOP_NULL | THOP_IN, THOP_DVTARGETDEVICE | THOP_IN, THOP_HGDI, THOP_HGDI, THOP_COPY | THOP_IN, 16, THOP_COPY | THOP_IN, 16, THOP_CALLBACK, THOP_END, THOP_ROUTINEINDEX, 14
};
THOP CONST thopsIViewObject_GetColorSet[] =
{
    THOP_COPY, 4, THOP_COPY, 4, THOP_NULL | THOP_IN, THOP_DVTARGETDEVICE | THOP_IN, THOP_HGDI, THOP_LOGPALETTE | THOP_OUT, THOP_END, THOP_ROUTINEINDEX, 4
};
THOP CONST thopsIViewObject_Freeze[] =
{
    THOP_COPY, 4, THOP_COPY, 4, THOP_NULL | THOP_IN, THOP_COPY | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 5
};
THOP CONST thopsIViewObject_Unfreeze[] =
{
    THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIViewObject_SetAdvise[] =
{
    THOP_COPY, 4, THOP_COPY, 4, THOP_IFACE | THOP_IN, THI_IAdviseSink, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIViewObject_GetAdvise[] =
{
    THOP_COPY | THOP_OUT, 4, THOP_COPY | THOP_OUT, 4, THOP_IFACE | THOP_OUT, THI_IAdviseSink, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIViewObject2_Draw[] =
{
    THOP_COPY, 4, THOP_COPY, 4, THOP_NULL | THOP_IN, THOP_DVTARGETDEVICE | THOP_IN, THOP_HGDI, THOP_HGDI, THOP_COPY | THOP_IN, 16, THOP_COPY | THOP_IN, 16, THOP_CALLBACK, THOP_END, THOP_ROUTINEINDEX, 14
};
THOP CONST thopsIViewObject2_GetColorSet[] =
{
    THOP_COPY, 4, THOP_COPY, 4, THOP_NULL | THOP_IN, THOP_DVTARGETDEVICE | THOP_IN, THOP_HGDI, THOP_LOGPALETTE | THOP_OUT, THOP_END, THOP_ROUTINEINDEX, 4
};
THOP CONST thopsIViewObject2_Freeze[] =
{
    THOP_COPY, 4, THOP_COPY, 4, THOP_NULL | THOP_IN, THOP_COPY | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 5
};
THOP CONST thopsIViewObject2_Unfreeze[] =
{
    THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIViewObject2_SetAdvise[] =
{
    THOP_COPY, 4, THOP_COPY, 4, THOP_IFACE | THOP_IN, THI_IAdviseSink, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIViewObject2_GetAdvise[] =
{
    THOP_COPY | THOP_OUT, 4, THOP_COPY | THOP_OUT, 4, THOP_IFACE | THOP_OUT, THI_IAdviseSink, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIViewObject2_GetExtent[] =
{
    THOP_COPY, 4, THOP_COPY, 4, THOP_DVTARGETDEVICE | THOP_IN, THOP_COPY | THOP_OUT, 8, THOP_END, THOP_ROUTINEINDEX, 5
};
THOP CONST thopsIAdviseSink_OnDataChange[] =
{
    THOP_FORMATETC | THOP_IN, THOP_STGMEDIUM | THOP_IN, 0, 4, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIAdviseSink_OnViewChange[] =
{
    THOP_COPY, 4, THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIAdviseSink_OnRename[] =
{
    THOP_IFACE | THOP_IN, THI_IMoniker, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIAdviseSink_OnSave[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIAdviseSink_OnClose[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIAdviseSink2_OnDataChange[] =
{
    THOP_FORMATETC | THOP_IN, THOP_STGMEDIUM | THOP_IN, 0, 4, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIAdviseSink2_OnViewChange[] =
{
    THOP_COPY, 4, THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIAdviseSink2_OnRename[] =
{
    THOP_IFACE | THOP_IN, THI_IMoniker, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIAdviseSink2_OnSave[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIAdviseSink2_OnClose[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIAdviseSink2_OnLinkSrcChange[] =
{
    THOP_IFACE | THOP_IN, THI_IMoniker, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIDataAdviseHolder_Advise[] =
{
    THOP_IFACE | THOP_IN, THI_IDataObject, THOP_FORMATETC | THOP_IN, THOP_COPY, 4, THOP_IFACE | THOP_IN, THI_IAdviseSink, THOP_COPY | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 7
};
THOP CONST thopsIDataAdviseHolder_Unadvise[] =
{
    THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIDataAdviseHolder_EnumAdvise[] =
{
    THOP_IFACE | THOP_OUT, THI_IEnumSTATDATA, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIDataAdviseHolder_SendOnDataChange[] =
{
    THOP_IFACE | THOP_IN, THI_IDataObject, THOP_COPY, 4, THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIOleCache_Cache[] =
{
    THOP_FORMATETC | THOP_IN, THOP_COPY, 4, THOP_COPY | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIOleCache_Uncache[] =
{
    THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleCache_EnumCache[] =
{
    THOP_IFACE | THOP_OUT, THI_IEnumSTATDATA, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleCache_InitCache[] =
{
    THOP_IFACE | THOP_IN, THI_IDataObject, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleCache_SetData[] =
{
    THOP_FORMATETC | THOP_IN, THOP_STGMEDIUM | THOP_IN, 1, 4, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIOleCache2_Cache[] =
{
    THOP_FORMATETC | THOP_IN, THOP_COPY, 4, THOP_COPY | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIOleCache2_Uncache[] =
{
    THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleCache2_EnumCache[] =
{
    THOP_IFACE | THOP_OUT, THI_IEnumSTATDATA, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleCache2_InitCache[] =
{
    THOP_IFACE | THOP_IN, THI_IDataObject, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleCache2_SetData[] =
{
    THOP_FORMATETC | THOP_IN, THOP_STGMEDIUM | THOP_IN, 1, 4, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIOleCache2_UpdateCache[] =
{
    THOP_IFACE | THOP_IN, THI_IDataObject, THOP_COPY, 4, THOP_NULL | THOP_IN, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIOleCache2_DiscardCache[] =
{
    THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleCacheControl_OnRun[] =
{
    THOP_IFACENOADDREF | THOP_IN, THI_IDataObject, 4, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleCacheControl_OnStop[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIDropTarget_DragEnter[] =
{
    THOP_IFACE | THOP_IN, THI_IDataObject, THOP_COPY, 4, THOP_COPY, 8, THOP_COPY | THOP_INOUT, 4, THOP_END, THOP_ROUTINEINDEX, 15
};
THOP CONST thopsIDropTarget_DragOver[] =
{
    THOP_COPY, 4, THOP_COPY, 8, THOP_COPY | THOP_INOUT, 4, THOP_END, THOP_ROUTINEINDEX, 16
};
THOP CONST thopsIDropTarget_DragLeave[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIDropTarget_Drop[] =
{
    THOP_IFACE | THOP_IN, THI_IDataObject, THOP_COPY, 4, THOP_COPY, 8, THOP_COPY | THOP_INOUT, 4, THOP_END, THOP_ROUTINEINDEX, 15
};
THOP CONST thopsIDropSource_QueryContinueDrag[] =
{
    THOP_SHORTLONG, THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIDropSource_GiveFeedback[] =
{
    THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIPersist_GetClassID[] =
{
    THOP_COPY | THOP_OUT, 16, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIPersistStorage_GetClassID[] =
{
    THOP_COPY | THOP_OUT, 16, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIPersistStorage_IsDirty[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIPersistStorage_InitNew[] =
{
    THOP_IFACE | THOP_IN, THI_IStorage, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIPersistStorage_Load[] =
{
    THOP_IFACE | THOP_IN, THI_IStorage, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIPersistStorage_Save[] =
{
    THOP_IFACE | THOP_IN, THI_IStorage, THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIPersistStorage_SaveCompleted[] =
{
    THOP_IFACE | THOP_IN, THI_IStorage, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIPersistStorage_HandsOffStorage[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIPersistStream_GetClassID[] =
{
    THOP_COPY | THOP_OUT, 16, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIPersistStream_IsDirty[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIPersistStream_Load[] =
{
    THOP_IFACE | THOP_IN, THI_IStream, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIPersistStream_Save[] =
{
    THOP_IFACE | THOP_IN, THI_IStream, THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIPersistStream_GetSizeMax[] =
{
    THOP_COPY | THOP_OUT, 8, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIPersistFile_GetClassID[] =
{
    THOP_COPY | THOP_OUT, 16, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIPersistFile_IsDirty[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIPersistFile_Load[] =
{
    THOP_FILENAME | THOP_IN, THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIPersistFile_Save[] =
{
    THOP_FILENAME | THOP_IN, THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIPersistFile_SaveCompleted[] =
{
    THOP_FILENAME | THOP_IN, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIPersistFile_GetCurFile[] =
{
    THOP_FILENAME | THOP_OUT, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIBindCtx_RegisterObjectBound[] =
{
    THOP_IFACE | THOP_IN, THI_IUnknown, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIBindCtx_RevokeObjectBound[] =
{
    THOP_IFACE | THOP_IN, THI_IUnknown, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIBindCtx_ReleaseBoundObjects[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIBindCtx_SetBindOptions[] =
{
    THOP_BINDOPTS | THOP_IN, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIBindCtx_GetBindOptions[] =
{
    THOP_BINDOPTS | THOP_INOUT, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIBindCtx_GetRunningObjectTable[] =
{
    THOP_IFACE | THOP_OUT, THI_IRunningObjectTable, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIBindCtx_RegisterObjectParam[] =
{
    THOP_LPSTR | THOP_IN, THOP_IFACE | THOP_IN, THI_IUnknown, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIBindCtx_GetObjectParam[] =
{
    THOP_LPSTR | THOP_IN, THOP_IFACE | THOP_OUT, THI_IUnknown, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIBindCtx_EnumObjectParam[] =
{
    THOP_IFACE | THOP_OUT, THI_IEnumString, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIBindCtx_RevokeObjectParam[] =
{
    THOP_LPSTR | THOP_IN, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIMoniker_GetClassID[] =
{
    THOP_COPY | THOP_OUT, 16, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIMoniker_IsDirty[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIMoniker_Load[] =
{
    THOP_IFACE | THOP_IN, THI_IStream, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIMoniker_Save[] =
{
    THOP_IFACE | THOP_IN, THI_IStream, THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIMoniker_GetSizeMax[] =
{
    THOP_COPY | THOP_OUT, 8, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIMoniker_BindToObject[] =
{
    THOP_IFACE | THOP_IN, THI_IBindCtx, THOP_IFACE | THOP_IN, THI_IMoniker, THOP_COPY | THOP_IN, 16, THOP_IFACEGEN | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 5
};
THOP CONST thopsIMoniker_BindToStorage[] =
{
    THOP_IFACE | THOP_IN, THI_IBindCtx, THOP_IFACE | THOP_IN, THI_IMoniker, THOP_COPY | THOP_IN, 16, THOP_IFACEGEN | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 5
};
THOP CONST thopsIMoniker_Reduce[] =
{
    THOP_IFACE | THOP_IN, THI_IBindCtx, THOP_COPY, 4, THOP_IFACE | THOP_INOUT, THI_IMoniker, THOP_IFACE | THOP_OUT, THI_IMoniker, THOP_END, THOP_ROUTINEINDEX, 5
};
THOP CONST thopsIMoniker_ComposeWith[] =
{
    THOP_IFACE | THOP_IN, THI_IMoniker, THOP_SHORTLONG, THOP_IFACE | THOP_OUT, THI_IMoniker, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIMoniker_Enum[] =
{
    THOP_SHORTLONG, THOP_IFACE | THOP_OUT, THI_IEnumMoniker, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIMoniker_IsEqual[] =
{
    THOP_IFACE | THOP_IN, THI_IMoniker, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIMoniker_Hash[] =
{
    THOP_COPY | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIMoniker_IsRunning[] =
{
    THOP_IFACE | THOP_IN, THI_IBindCtx, THOP_IFACE | THOP_IN, THI_IMoniker, THOP_IFACE | THOP_IN, THI_IMoniker, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIMoniker_GetTimeOfLastChange[] =
{
    THOP_IFACE | THOP_IN, THI_IBindCtx, THOP_IFACE | THOP_IN, THI_IMoniker, THOP_COPY | THOP_OUT, 8, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIMoniker_Inverse[] =
{
    THOP_IFACE | THOP_OUT, THI_IMoniker, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIMoniker_CommonPrefixWith[] =
{
    THOP_IFACE | THOP_IN, THI_IMoniker, THOP_IFACE | THOP_OUT, THI_IMoniker, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIMoniker_RelativePathTo[] =
{
    THOP_IFACE | THOP_IN, THI_IMoniker, THOP_IFACE | THOP_OUT, THI_IMoniker, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIMoniker_GetDisplayName[] =
{
    THOP_IFACE | THOP_IN, THI_IBindCtx, THOP_IFACE | THOP_IN, THI_IMoniker, THOP_LPLPSTR, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIMoniker_ParseDisplayName[] =
{
    THOP_IFACE | THOP_IN, THI_IBindCtx, THOP_IFACE | THOP_IN, THI_IMoniker, THOP_LPSTR | THOP_IN, THOP_COPY | THOP_OUT, 4, THOP_IFACE | THOP_OUT, THI_IMoniker, THOP_END, THOP_ROUTINEINDEX, 7
};
THOP CONST thopsIMoniker_IsSystemMoniker[] =
{
    THOP_COPY | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIRunningObjectTable_Register[] =
{
    THOP_COPY, 4, THOP_IFACE | THOP_IN, THI_IUnknown, THOP_IFACE | THOP_IN, THI_IMoniker, THOP_COPY | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 5
};
THOP CONST thopsIRunningObjectTable_Revoke[] =
{
    THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIRunningObjectTable_IsRunning[] =
{
    THOP_IFACE | THOP_IN, THI_IMoniker, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIRunningObjectTable_GetObject[] =
{
    THOP_IFACE | THOP_IN, THI_IMoniker, THOP_IFACE | THOP_OUT, THI_IUnknown, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIRunningObjectTable_NoteChangeTime[] =
{
    THOP_COPY, 4, THOP_COPY | THOP_IN, 8, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIRunningObjectTable_GetTimeOfLastChange[] =
{
    THOP_IFACE | THOP_IN, THI_IMoniker, THOP_COPY | THOP_OUT, 8, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIRunningObjectTable_EnumRunning[] =
{
    THOP_IFACE | THOP_OUT, THI_IEnumMoniker, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIEnumMoniker_Next[] =
{
    THOP_ENUM, THE_IEnumMoniker, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIEnumMoniker_Skip[] =
{
    THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIEnumMoniker_Reset[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIEnumMoniker_Clone[] =
{
    THOP_IFACE | THOP_OUT, THI_IEnumMoniker, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIEnumOLEVERB_Next[] =
{
    THOP_ENUM, THE_IEnumOLEVERB, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIEnumOLEVERB_Skip[] =
{
    THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIEnumOLEVERB_Reset[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIEnumOLEVERB_Clone[] =
{
    THOP_IFACE | THOP_OUT, THI_IEnumOLEVERB, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleObject_SetClientSite[] =
{
    THOP_IFACE | THOP_IN, THI_IOleClientSite, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleObject_GetClientSite[] =
{
    THOP_IFACE | THOP_OUT, THI_IOleClientSite, THOP_END, THOP_ROUTINEINDEX, 3
};
/*
  The eighty character limit was arrived at by trial and error
  with ClipArt Gallery.  It faults at 90 characters.
  */
THOP CONST thopsIOleObject_SetHostNames[] =
{
    THOP_LPSTR | THOP_IN, THOP_SIZEDSTRING | THOP_IN, 80, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIOleObject_Close[] =
{
    THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleObject_SetMoniker[] =
{
    THOP_COPY, 4, THOP_IFACE | THOP_IN, THI_IMoniker, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIOleObject_GetMoniker[] =
{
    THOP_COPY, 4, THOP_COPY, 4, THOP_IFACE | THOP_OUT, THI_IMoniker, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIOleObject_InitFromData[] =
{
    THOP_IFACE | THOP_IN, THI_IDataObject, THOP_SHORTLONG, THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIOleObject_GetClipboardData[] =
{
    THOP_COPY, 4, THOP_IFACE | THOP_OUT, THI_IDataObject, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIOleObject_DoVerb[] =
{
    THOP_COPY, 4, THOP_MSG | THOP_IN, THOP_IFACE | THOP_IN, THI_IOleClientSite, THOP_COPY, 4, THOP_HUSER, THOP_RECT | THOP_IN, THOP_END, THOP_ROUTINEINDEX, 4
};
THOP CONST thopsIOleObject_EnumVerbs[] =
{
    THOP_IFACE | THOP_OUT, THI_IEnumOLEVERB, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleObject_Update[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIOleObject_IsUpToDate[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIOleObject_GetUserClassID[] =
{
    THOP_COPY | THOP_OUT, 16, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleObject_GetUserType[] =
{
    THOP_COPY, 4, THOP_LPLPSTR, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIOleObject_SetExtent[] =
{
    THOP_COPY, 4, THOP_COPY | THOP_IN, 8, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIOleObject_GetExtent[] =
{
    THOP_COPY, 4, THOP_COPY | THOP_OUT, 8, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIOleObject_Advise[] =
{
    THOP_IFACE | THOP_IN, THI_IAdviseSink, THOP_COPY | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIOleObject_Unadvise[] =
{
    THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleObject_EnumAdvise[] =
{
    THOP_IFACE | THOP_OUT, THI_IEnumSTATDATA, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleObject_GetMiscStatus[] =
{
    THOP_COPY, 4, THOP_COPY | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIOleObject_SetColorScheme[] =
{
    THOP_LOGPALETTE | THOP_IN, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleClientSite_SaveObject[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIOleClientSite_GetMoniker[] =
{
    THOP_COPY, 4, THOP_COPY, 4, THOP_IFACE | THOP_OUT, THI_IMoniker, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIOleClientSite_GetContainer[] =
{
    THOP_IFACE | THOP_OUT, THI_IOleContainer, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleClientSite_ShowObject[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIOleClientSite_OnShowWindow[] =
{
    THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleClientSite_RequestNewObjectLayout[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIRunnableObject_GetRunningClass[] =
{
    THOP_COPY | THOP_OUT, 16, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIRunnableObject_Run[] =
{
    THOP_IFACE | THOP_IN, THI_IBindCtx, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIRunnableObject_IsRunning[] =
{
    THOP_RETURNTYPE, THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIRunnableObject_LockRunning[] =
{
    THOP_SHORTLONG, THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIRunnableObject_SetContainedObject[] =
{
    THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIParseDisplayName_ParseDisplayName[] =
{
    THOP_IFACE | THOP_IN, THI_IBindCtx, THOP_LPSTR | THOP_IN, THOP_COPY | THOP_OUT, 4, THOP_IFACE | THOP_OUT, THI_IMoniker, THOP_END, THOP_ROUTINEINDEX, 5
};
THOP CONST thopsIOleContainer_ParseDisplayName[] =
{
    THOP_IFACE | THOP_IN, THI_IBindCtx, THOP_LPSTR | THOP_IN, THOP_COPY | THOP_OUT, 4, THOP_IFACE | THOP_OUT, THI_IMoniker, THOP_END, THOP_ROUTINEINDEX, 5
};
THOP CONST thopsIOleContainer_EnumObjects[] =
{
    THOP_COPY, 4, THOP_IFACE | THOP_OUT, THI_IEnumUnknown, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIOleContainer_LockContainer[] =
{
    THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleItemContainer_ParseDisplayName[] =
{
    THOP_IFACE | THOP_IN, THI_IBindCtx, THOP_LPSTR | THOP_IN, THOP_COPY | THOP_OUT, 4, THOP_IFACE | THOP_OUT, THI_IMoniker, THOP_END, THOP_ROUTINEINDEX, 5
};
THOP CONST thopsIOleItemContainer_EnumObjects[] =
{
    THOP_COPY, 4, THOP_IFACE | THOP_OUT, THI_IEnumUnknown, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIOleItemContainer_LockContainer[] =
{
    THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleItemContainer_GetObject[] =
{
    THOP_LPSTR | THOP_IN, THOP_COPY, 4, THOP_IFACE | THOP_IN, THI_IBindCtx, THOP_COPY | THOP_IN, 16, THOP_IFACEGEN | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 7
};
THOP CONST thopsIOleItemContainer_GetObjectStorage[] =
{
    THOP_LPSTR | THOP_IN, THOP_IFACE | THOP_IN, THI_IBindCtx, THOP_COPY | THOP_IN, 16, THOP_IFACEGEN | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 5
};
THOP CONST thopsIOleItemContainer_IsRunning[] =
{
    THOP_LPSTR | THOP_IN, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleAdviseHolder_Advise[] =
{
    THOP_IFACE | THOP_IN, THI_IAdviseSink, THOP_COPY | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIOleAdviseHolder_Unadvise[] =
{
    THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleAdviseHolder_EnumAdvise[] =
{
    THOP_IFACE | THOP_OUT, THI_IEnumSTATDATA, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleAdviseHolder_SendOnRename[] =
{
    THOP_IFACE | THOP_IN, THI_IMoniker, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleAdviseHolder_SendOnSave[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIOleAdviseHolder_SendOnClose[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIOleLink_SetUpdateOptions[] =
{
    THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleLink_GetUpdateOptions[] =
{
    THOP_COPY | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleLink_SetSourceMoniker[] =
{
    THOP_IFACE | THOP_IN, THI_IMoniker, THOP_COPY | THOP_IN, 16, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIOleLink_GetSourceMoniker[] =
{
    THOP_IFACE | THOP_OUT, THI_IMoniker, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleLink_SetSourceDisplayName[] =
{
    THOP_LPSTR | THOP_IN, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleLink_GetSourceDisplayName[] =
{
    THOP_LPLPSTR, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleLink_BindToSource[] =
{
    THOP_COPY, 4, THOP_IFACE | THOP_IN, THI_IBindCtx, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIOleLink_BindIfRunning[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIOleLink_GetBoundSource[] =
{
    THOP_IFACE | THOP_OUT, THI_IUnknown, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleLink_UnbindSource[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIOleLink_Update[] =
{
    THOP_IFACE | THOP_IN, THI_IBindCtx, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleWindow_GetWindow[] =
{
    THOP_HUSER | THOP_OUT, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleWindow_ContextSensitiveHelp[] =
{
    THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleInPlaceObject_GetWindow[] =
{
    THOP_HUSER | THOP_OUT, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleInPlaceObject_ContextSensitiveHelp[] =
{
    THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleInPlaceObject_InPlaceDeactivate[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIOleInPlaceObject_UIDeactivate[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIOleInPlaceObject_SetObjectRects[] =
{
    THOP_RECT | THOP_IN, THOP_RECT | THOP_IN, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIOleInPlaceObject_ReactivateAndUndo[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIOleInPlaceActiveObject_GetWindow[] =
{
    THOP_HUSER | THOP_OUT, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleInPlaceActiveObject_ContextSensitiveHelp[] =
{
    THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleInPlaceActiveObject_TranslateAccelerator[] =
{
    THOP_MSG | THOP_IN, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleInPlaceActiveObject_OnFrameWindowActivate[] =
{
    THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleInPlaceActiveObject_OnDocWindowActivate[] =
{
    THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleInPlaceActiveObject_ResizeBorder[] =
{
    THOP_RECT | THOP_IN, THOP_IFACE | THOP_IN, THI_IOleInPlaceFrame, THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIOleInPlaceActiveObject_EnableModeless[] =
{
    THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleInPlaceUIWindow_GetWindow[] =
{
    THOP_HUSER | THOP_OUT, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleInPlaceUIWindow_ContextSensitiveHelp[] =
{
    THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleInPlaceUIWindow_GetBorder[] =
{
    THOP_RECT | THOP_OUT, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleInPlaceUIWindow_RequestBorderSpace[] =
{
    THOP_RECT | THOP_IN, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleInPlaceUIWindow_SetBorderSpace[] =
{
    THOP_RECT | THOP_IN, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleInPlaceUIWindow_SetActiveObject[] =
{
    THOP_IFACE | THOP_IN, THI_IOleInPlaceActiveObject, THOP_LPSTR | THOP_IN, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIOleInPlaceFrame_GetWindow[] =
{
    THOP_HUSER | THOP_OUT, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleInPlaceFrame_ContextSensitiveHelp[] =
{
    THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleInPlaceFrame_GetBorder[] =
{
    THOP_RECT | THOP_OUT, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleInPlaceFrame_RequestBorderSpace[] =
{
    THOP_RECT | THOP_IN, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleInPlaceFrame_SetBorderSpace[] =
{
    THOP_RECT | THOP_IN, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleInPlaceFrame_SetActiveObject[] =
{
    THOP_IFACE | THOP_IN, THI_IOleInPlaceActiveObject, THOP_LPSTR | THOP_IN, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIOleInPlaceFrame_InsertMenus[] =
{
    THOP_HUSER, THOP_COPY | THOP_INOUT, 24, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIOleInPlaceFrame_SetMenu[] =
{
    THOP_HUSER, THOP_ALIAS32, ALIAS_RESOLVE, THOP_HUSER, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIOleInPlaceFrame_RemoveMenus[] =
{
    THOP_HUSER, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleInPlaceFrame_SetStatusText[] =
{
    THOP_LPSTR | THOP_IN, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleInPlaceFrame_EnableModeless[] =
{
    THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleInPlaceFrame_TranslateAccelerator[] =
{
    THOP_MSG | THOP_IN, THOP_WORDDWORD, THOP_END, THOP_ROUTINEINDEX, 17
};
THOP CONST thopsIOleInPlaceSite_GetWindow[] =
{
    THOP_HUSER | THOP_OUT, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleInPlaceSite_ContextSensitiveHelp[] =
{
    THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleInPlaceSite_CanInPlaceActivate[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIOleInPlaceSite_OnInPlaceActivate[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIOleInPlaceSite_OnUIActivate[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIOleInPlaceSite_GetWindowContext[] =
{
    THOP_IFACE | THOP_OUT, THI_IOleInPlaceFrame, THOP_IFACE | THOP_OUT, THI_IOleInPlaceUIWindow, THOP_RECT | THOP_OUT, THOP_RECT | THOP_OUT, THOP_OIFI | THOP_OUT, THOP_END, THOP_ROUTINEINDEX, 7
};
THOP CONST thopsIOleInPlaceSite_Scroll[] =
{
    THOP_SIZE, THOP_END, THOP_ROUTINEINDEX, 18
};
THOP CONST thopsIOleInPlaceSite_OnUIDeactivate[] =
{
    THOP_SHORTLONG, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIOleInPlaceSite_OnInPlaceDeactivate[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIOleInPlaceSite_DiscardUndoState[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIOleInPlaceSite_DeactivateAndUndo[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIOleInPlaceSite_OnPosRectChange[] =
{
    THOP_RECT | THOP_IN, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIRpcChannelBuffer_GetBuffer[] =
{
    THOP_RPCOLEMESSAGE | THOP_INOUT, THOP_COPY | THOP_IN, 16, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIRpcChannelBuffer_SendReceive[] =
{
    THOP_RPCOLEMESSAGE | THOP_INOUT, THOP_COPY | THOP_OUT, 4, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIRpcChannelBuffer_FreeBuffer[] =
{
    THOP_RPCOLEMESSAGE | THOP_INOUT, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIRpcChannelBuffer_GetDestCtx[] =
{
    THOP_COPY | THOP_OUT, 4, THOP_NULL | THOP_OUT, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIRpcChannelBuffer_IsConnected[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIRpcProxyBuffer_Connect[] =
{
    THOP_IFACE | THOP_IN, THI_IRpcChannelBuffer, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIRpcProxyBuffer_Disconnect[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIRpcStubBuffer_Connect[] =
{
    THOP_IFACE | THOP_IN, THI_IUnknown, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIRpcStubBuffer_Disconnect[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIRpcStubBuffer_Invoke[] =
{
    THOP_RPCOLEMESSAGE | THOP_INOUT, THOP_IFACE | THOP_IN, THI_IRpcChannelBuffer, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIRpcStubBuffer_IsIIDSupported[] =
{
    THOP_RETURNTYPE, THOP_IFACE | THOP_IN, THI_IRpcStubBuffer, THOP_COPY | THOP_IN, 16, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIRpcStubBuffer_CountRefs[] =
{
    THOP_RETURNTYPE, THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIRpcStubBuffer_DebugServerQueryInterface[] =
{
    THOP_IFACE | THOP_OUT, THI_IUnknown, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIRpcStubBuffer_DebugServerRelease[] =
{
    THOP_IFACECLEAN | THOP_IN, THI_IUnknown, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIPSFactoryBuffer_CreateProxy[] =
{
    THOP_UNKOUTER | THOP_IN, THI_IUnknown, THOP_COPY | THOP_IN, 16, THOP_IFACEOWNER | THOP_OUT, THI_IRpcProxyBuffer, 8, THOP_IFACEGENOWNER | THOP_OUT, 8, 12, THOP_END, THOP_ROUTINEINDEX, 5
};
THOP CONST thopsIPSFactoryBuffer_CreateStub[] =
{
    THOP_COPY | THOP_IN, 16, THOP_IFACE | THOP_IN, THI_IUnknown, THOP_IFACE | THOP_OUT, THI_IRpcStubBuffer, THOP_END, THOP_ROUTINEINDEX, 2
};
THOP CONST thopsIRpcChannel_GetStream[] =
{
    THOP_COPY | THOP_IN, 16, THOP_SHORTLONG, THOP_SHORTLONG, THOP_SHORTLONG, THOP_COPY, 4, THOP_IFACE | THOP_OUT, THI_IStream, THOP_END, THOP_ROUTINEINDEX, 4
};
THOP CONST thopsIRpcChannel_Call[] =
{
    THOP_IFACE | THOP_IN, THI_IStream, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIRpcChannel_GetDestCtx[] =
{
    THOP_COPY | THOP_OUT, 4, THOP_NULL | THOP_OUT, THOP_END, THOP_ROUTINEINDEX, 0
};
THOP CONST thopsIRpcChannel_IsConnected[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIRpcProxy_Connect[] =
{
    THOP_IFACE | THOP_IN, THI_IRpcChannel, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIRpcProxy_Disconnect[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIRpcStub_Connect[] =
{
    THOP_IFACE | THOP_IN, THI_IUnknown, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIRpcStub_Disconnect[] =
{
    THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIRpcStub_Invoke[] =
{
    THOP_COPY | THOP_IN, 16, THOP_SHORTLONG, THOP_IFACE | THOP_IN, THI_IStream, THOP_COPY, 4, THOP_NULL | THOP_IN, THOP_END, THOP_ROUTINEINDEX, 7
};
THOP CONST thopsIRpcStub_IsIIDSupported[] =
{
    THOP_RETURNTYPE, THOP_SHORTLONG, THOP_COPY | THOP_IN, 16, THOP_END, THOP_ROUTINEINDEX, 3
};
THOP CONST thopsIRpcStub_CountRefs[] =
{
    THOP_RETURNTYPE, THOP_COPY, 4, THOP_END, THOP_ROUTINEINDEX, 1
};
THOP CONST thopsIPSFactory_CreateProxy[] =
{
    THOP_UNKOUTER | THOP_IN, THI_IUnknown, THOP_COPY | THOP_IN, 16,  THOP_IFACEOWNER | THOP_OUT, THI_IRpcProxy, 8, THOP_IFACEGENOWNER | THOP_OUT, 8, 12, THOP_END, THOP_ROUTINEINDEX, 5
};
THOP CONST thopsIPSFactory_CreateStub[] =
{
    THOP_COPY | THOP_IN, 16, THOP_IFACE | THOP_IN, THI_IUnknown, THOP_IFACE | THOP_OUT, THI_IRpcStub, THOP_END, THOP_ROUTINEINDEX, 2
};

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\olethk32\thtblint.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	thtblint.cxx
//
//  Notes:	This file is automatically generated
//		Do not modify by hand
//
//  History:	Fri May 27 10:39:02 1994	Generated
//
//----------------------------------------------------------------------------

THOP CONST * CONST apthopsIUnknown[] =
{
    NULL
};
THOP CONST * CONST apthopsIClassFactory[] =
{
    thopsIClassFactory_CreateInstance
,    thopsIClassFactory_LockServer
};
THOP CONST * CONST apthopsIMarshal[] =
{
    thopsIMarshal_GetUnmarshalClass
,    thopsIMarshal_GetMarshalSizeMax
,    thopsIMarshal_MarshalInterface
,    thopsIMarshal_UnmarshalInterface
,    thopsIMarshal_ReleaseMarshalData
,    thopsIMarshal_DisconnectObject
};
THOP CONST * CONST apthopsIStdMarshalInfo[] =
{
    thopsIStdMarshalInfo_GetClassForHandler
};
THOP CONST * CONST apthopsIMessageFilter[] =
{
    thopsIMessageFilter_HandleInComingCall
,    thopsIMessageFilter_RetryRejectedCall
,    thopsIMessageFilter_MessagePending
};
THOP CONST * CONST apthopsIExternalConnection[] =
{
    thopsIExternalConnection_AddConnection
,    thopsIExternalConnection_ReleaseConnection
};
THOP CONST * CONST apthopsIEnumString[] =
{
    thopsIEnumString_Next
,    thopsIEnumString_Skip
,    thopsIEnumString_Reset
,    thopsIEnumString_Clone
};
THOP CONST * CONST apthopsIEnumUnknown[] =
{
    thopsIEnumUnknown_Next
,    thopsIEnumUnknown_Skip
,    thopsIEnumUnknown_Reset
,    thopsIEnumUnknown_Clone
};
THOP CONST * CONST apthopsIEnumSTATSTG[] =
{
    thopsIEnumSTATSTG_Next
,    thopsIEnumSTATSTG_Skip
,    thopsIEnumSTATSTG_Reset
,    thopsIEnumSTATSTG_Clone
};
THOP CONST * CONST apthopsILockBytes[] =
{
    thopsILockBytes_ReadAt
,    thopsILockBytes_WriteAt
,    thopsILockBytes_Flush
,    thopsILockBytes_SetSize
,    thopsILockBytes_LockRegion
,    thopsILockBytes_UnlockRegion
,    thopsILockBytes_Stat
};
THOP CONST * CONST apthopsIStream[] =
{
    thopsIStream_Read
,    thopsIStream_Write
,    thopsIStream_Seek
,    thopsIStream_SetSize
,    thopsIStream_CopyTo
,    thopsIStream_Commit
,    thopsIStream_Revert
,    thopsIStream_LockRegion
,    thopsIStream_UnlockRegion
,    thopsIStream_Stat
,    thopsIStream_Clone
};
THOP CONST * CONST apthopsIStorage[] =
{
    thopsIStorage_CreateStream
,    thopsIStorage_OpenStream
,    thopsIStorage_CreateStorage
,    thopsIStorage_OpenStorage
,    thopsIStorage_CopyTo
,    thopsIStorage_MoveElementTo
,    thopsIStorage_Commit
,    thopsIStorage_Revert
,    thopsIStorage_EnumElements
,    thopsIStorage_DestroyElement
,    thopsIStorage_RenameElement
,    thopsIStorage_SetElementTimes
,    thopsIStorage_SetClass
,    thopsIStorage_SetStateBits
,    thopsIStorage_Stat
};
THOP CONST * CONST apthopsIRootStorage[] =
{
    thopsIRootStorage_SwitchToFile
};
THOP CONST * CONST apthopsIEnumFORMATETC[] =
{
    thopsIEnumFORMATETC_Next
,    thopsIEnumFORMATETC_Skip
,    thopsIEnumFORMATETC_Reset
,    thopsIEnumFORMATETC_Clone
};
THOP CONST * CONST apthopsIEnumSTATDATA[] =
{
    thopsIEnumSTATDATA_Next
,    thopsIEnumSTATDATA_Skip
,    thopsIEnumSTATDATA_Reset
,    thopsIEnumSTATDATA_Clone
};
THOP CONST * CONST apthopsIDataObject[] =
{
    thopsIDataObject_GetData
,    thopsIDataObject_GetDataHere
,    thopsIDataObject_QueryGetData
,    thopsIDataObject_GetCanonicalFormatEtc
,    thopsIDataObject_SetData
,    thopsIDataObject_EnumFormatEtc
,    thopsIDataObject_DAdvise
,    thopsIDataObject_DUnadvise
,    thopsIDataObject_EnumDAdvise
};
THOP CONST * CONST apthopsIViewObject[] =
{
    thopsIViewObject_Draw
,    thopsIViewObject_GetColorSet
,    thopsIViewObject_Freeze
,    thopsIViewObject_Unfreeze
,    thopsIViewObject_SetAdvise
,    thopsIViewObject_GetAdvise
};
THOP CONST * CONST apthopsIViewObject2[] =
{
    thopsIViewObject2_Draw
,    thopsIViewObject2_GetColorSet
,    thopsIViewObject2_Freeze
,    thopsIViewObject2_Unfreeze
,    thopsIViewObject2_SetAdvise
,    thopsIViewObject2_GetAdvise
,    thopsIViewObject2_GetExtent
};
THOP CONST * CONST apthopsIAdviseSink[] =
{
    thopsIAdviseSink_OnDataChange
,    thopsIAdviseSink_OnViewChange
,    thopsIAdviseSink_OnRename
,    thopsIAdviseSink_OnSave
,    thopsIAdviseSink_OnClose
};
THOP CONST * CONST apthopsIAdviseSink2[] =
{
    thopsIAdviseSink2_OnDataChange
,    thopsIAdviseSink2_OnViewChange
,    thopsIAdviseSink2_OnRename
,    thopsIAdviseSink2_OnSave
,    thopsIAdviseSink2_OnClose
,    thopsIAdviseSink2_OnLinkSrcChange
};
THOP CONST * CONST apthopsIDataAdviseHolder[] =
{
    thopsIDataAdviseHolder_Advise
,    thopsIDataAdviseHolder_Unadvise
,    thopsIDataAdviseHolder_EnumAdvise
,    thopsIDataAdviseHolder_SendOnDataChange
};
THOP CONST * CONST apthopsIOleCache[] =
{
    thopsIOleCache_Cache
,    thopsIOleCache_Uncache
,    thopsIOleCache_EnumCache
,    thopsIOleCache_InitCache
,    thopsIOleCache_SetData
};
THOP CONST * CONST apthopsIOleCache2[] =
{
    thopsIOleCache2_Cache
,    thopsIOleCache2_Uncache
,    thopsIOleCache2_EnumCache
,    thopsIOleCache2_InitCache
,    thopsIOleCache2_SetData
,    thopsIOleCache2_UpdateCache
,    thopsIOleCache2_DiscardCache
};
THOP CONST * CONST apthopsIOleCacheControl[] =
{
    thopsIOleCacheControl_OnRun
,    thopsIOleCacheControl_OnStop
};
THOP CONST * CONST apthopsIDropTarget[] =
{
    thopsIDropTarget_DragEnter
,    thopsIDropTarget_DragOver
,    thopsIDropTarget_DragLeave
,    thopsIDropTarget_Drop
};
THOP CONST * CONST apthopsIDropSource[] =
{
    thopsIDropSource_QueryContinueDrag
,    thopsIDropSource_GiveFeedback
};
THOP CONST * CONST apthopsIPersist[] =
{
    thopsIPersist_GetClassID
};
THOP CONST * CONST apthopsIPersistStorage[] =
{
    thopsIPersistStorage_GetClassID
,    thopsIPersistStorage_IsDirty
,    thopsIPersistStorage_InitNew
,    thopsIPersistStorage_Load
,    thopsIPersistStorage_Save
,    thopsIPersistStorage_SaveCompleted
,    thopsIPersistStorage_HandsOffStorage
};
THOP CONST * CONST apthopsIPersistStream[] =
{
    thopsIPersistStream_GetClassID
,    thopsIPersistStream_IsDirty
,    thopsIPersistStream_Load
,    thopsIPersistStream_Save
,    thopsIPersistStream_GetSizeMax
};
THOP CONST * CONST apthopsIPersistFile[] =
{
    thopsIPersistFile_GetClassID
,    thopsIPersistFile_IsDirty
,    thopsIPersistFile_Load
,    thopsIPersistFile_Save
,    thopsIPersistFile_SaveCompleted
,    thopsIPersistFile_GetCurFile
};
THOP CONST * CONST apthopsIBindCtx[] =
{
    thopsIBindCtx_RegisterObjectBound
,    thopsIBindCtx_RevokeObjectBound
,    thopsIBindCtx_ReleaseBoundObjects
,    thopsIBindCtx_SetBindOptions
,    thopsIBindCtx_GetBindOptions
,    thopsIBindCtx_GetRunningObjectTable
,    thopsIBindCtx_RegisterObjectParam
,    thopsIBindCtx_GetObjectParam
,    thopsIBindCtx_EnumObjectParam
,    thopsIBindCtx_RevokeObjectParam
};
THOP CONST * CONST apthopsIMoniker[] =
{
    thopsIMoniker_GetClassID
,    thopsIMoniker_IsDirty
,    thopsIMoniker_Load
,    thopsIMoniker_Save
,    thopsIMoniker_GetSizeMax
,    thopsIMoniker_BindToObject
,    thopsIMoniker_BindToStorage
,    thopsIMoniker_Reduce
,    thopsIMoniker_ComposeWith
,    thopsIMoniker_Enum
,    thopsIMoniker_IsEqual
,    thopsIMoniker_Hash
,    thopsIMoniker_IsRunning
,    thopsIMoniker_GetTimeOfLastChange
,    thopsIMoniker_Inverse
,    thopsIMoniker_CommonPrefixWith
,    thopsIMoniker_RelativePathTo
,    thopsIMoniker_GetDisplayName
,    thopsIMoniker_ParseDisplayName
,    thopsIMoniker_IsSystemMoniker
};
THOP CONST * CONST apthopsIRunningObjectTable[] =
{
    thopsIRunningObjectTable_Register
,    thopsIRunningObjectTable_Revoke
,    thopsIRunningObjectTable_IsRunning
,    thopsIRunningObjectTable_GetObject
,    thopsIRunningObjectTable_NoteChangeTime
,    thopsIRunningObjectTable_GetTimeOfLastChange
,    thopsIRunningObjectTable_EnumRunning
};
THOP CONST * CONST apthopsIEnumMoniker[] =
{
    thopsIEnumMoniker_Next
,    thopsIEnumMoniker_Skip
,    thopsIEnumMoniker_Reset
,    thopsIEnumMoniker_Clone
};
THOP CONST * CONST apthopsIEnumOLEVERB[] =
{
    thopsIEnumOLEVERB_Next
,    thopsIEnumOLEVERB_Skip
,    thopsIEnumOLEVERB_Reset
,    thopsIEnumOLEVERB_Clone
};
THOP CONST * CONST apthopsIOleObject[] =
{
    thopsIOleObject_SetClientSite
,    thopsIOleObject_GetClientSite
,    thopsIOleObject_SetHostNames
,    thopsIOleObject_Close
,    thopsIOleObject_SetMoniker
,    thopsIOleObject_GetMoniker
,    thopsIOleObject_InitFromData
,    thopsIOleObject_GetClipboardData
,    thopsIOleObject_DoVerb
,    thopsIOleObject_EnumVerbs
,    thopsIOleObject_Update
,    thopsIOleObject_IsUpToDate
,    thopsIOleObject_GetUserClassID
,    thopsIOleObject_GetUserType
,    thopsIOleObject_SetExtent
,    thopsIOleObject_GetExtent
,    thopsIOleObject_Advise
,    thopsIOleObject_Unadvise
,    thopsIOleObject_EnumAdvise
,    thopsIOleObject_GetMiscStatus
,    thopsIOleObject_SetColorScheme
};
THOP CONST * CONST apthopsIOleClientSite[] =
{
    thopsIOleClientSite_SaveObject
,    thopsIOleClientSite_GetMoniker
,    thopsIOleClientSite_GetContainer
,    thopsIOleClientSite_ShowObject
,    thopsIOleClientSite_OnShowWindow
,    thopsIOleClientSite_RequestNewObjectLayout
};
THOP CONST * CONST apthopsIRunnableObject[] =
{
    thopsIRunnableObject_GetRunningClass
,    thopsIRunnableObject_Run
,    thopsIRunnableObject_IsRunning
,    thopsIRunnableObject_LockRunning
,    thopsIRunnableObject_SetContainedObject
};
THOP CONST * CONST apthopsIParseDisplayName[] =
{
    thopsIParseDisplayName_ParseDisplayName
};
THOP CONST * CONST apthopsIOleContainer[] =
{
    thopsIOleContainer_ParseDisplayName
,    thopsIOleContainer_EnumObjects
,    thopsIOleContainer_LockContainer
};
THOP CONST * CONST apthopsIOleItemContainer[] =
{
    thopsIOleItemContainer_ParseDisplayName
,    thopsIOleItemContainer_EnumObjects
,    thopsIOleItemContainer_LockContainer
,    thopsIOleItemContainer_GetObject
,    thopsIOleItemContainer_GetObjectStorage
,    thopsIOleItemContainer_IsRunning
};
THOP CONST * CONST apthopsIOleAdviseHolder[] =
{
    thopsIOleAdviseHolder_Advise
,    thopsIOleAdviseHolder_Unadvise
,    thopsIOleAdviseHolder_EnumAdvise
,    thopsIOleAdviseHolder_SendOnRename
,    thopsIOleAdviseHolder_SendOnSave
,    thopsIOleAdviseHolder_SendOnClose
};
THOP CONST * CONST apthopsIOleLink[] =
{
    thopsIOleLink_SetUpdateOptions
,    thopsIOleLink_GetUpdateOptions
,    thopsIOleLink_SetSourceMoniker
,    thopsIOleLink_GetSourceMoniker
,    thopsIOleLink_SetSourceDisplayName
,    thopsIOleLink_GetSourceDisplayName
,    thopsIOleLink_BindToSource
,    thopsIOleLink_BindIfRunning
,    thopsIOleLink_GetBoundSource
,    thopsIOleLink_UnbindSource
,    thopsIOleLink_Update
};
THOP CONST * CONST apthopsIOleWindow[] =
{
    thopsIOleWindow_GetWindow
,    thopsIOleWindow_ContextSensitiveHelp
};
THOP CONST * CONST apthopsIOleInPlaceObject[] =
{
    thopsIOleInPlaceObject_GetWindow
,    thopsIOleInPlaceObject_ContextSensitiveHelp
,    thopsIOleInPlaceObject_InPlaceDeactivate
,    thopsIOleInPlaceObject_UIDeactivate
,    thopsIOleInPlaceObject_SetObjectRects
,    thopsIOleInPlaceObject_ReactivateAndUndo
};
THOP CONST * CONST apthopsIOleInPlaceActiveObject[] =
{
    thopsIOleInPlaceActiveObject_GetWindow
,    thopsIOleInPlaceActiveObject_ContextSensitiveHelp
,    thopsIOleInPlaceActiveObject_TranslateAccelerator
,    thopsIOleInPlaceActiveObject_OnFrameWindowActivate
,    thopsIOleInPlaceActiveObject_OnDocWindowActivate
,    thopsIOleInPlaceActiveObject_ResizeBorder
,    thopsIOleInPlaceActiveObject_EnableModeless
};
THOP CONST * CONST apthopsIOleInPlaceUIWindow[] =
{
    thopsIOleInPlaceUIWindow_GetWindow
,    thopsIOleInPlaceUIWindow_ContextSensitiveHelp
,    thopsIOleInPlaceUIWindow_GetBorder
,    thopsIOleInPlaceUIWindow_RequestBorderSpace
,    thopsIOleInPlaceUIWindow_SetBorderSpace
,    thopsIOleInPlaceUIWindow_SetActiveObject
};
THOP CONST * CONST apthopsIOleInPlaceFrame[] =
{
    thopsIOleInPlaceFrame_GetWindow
,    thopsIOleInPlaceFrame_ContextSensitiveHelp
,    thopsIOleInPlaceFrame_GetBorder
,    thopsIOleInPlaceFrame_RequestBorderSpace
,    thopsIOleInPlaceFrame_SetBorderSpace
,    thopsIOleInPlaceFrame_SetActiveObject
,    thopsIOleInPlaceFrame_InsertMenus
,    thopsIOleInPlaceFrame_SetMenu
,    thopsIOleInPlaceFrame_RemoveMenus
,    thopsIOleInPlaceFrame_SetStatusText
,    thopsIOleInPlaceFrame_EnableModeless
,    thopsIOleInPlaceFrame_TranslateAccelerator
};
THOP CONST * CONST apthopsIOleInPlaceSite[] =
{
    thopsIOleInPlaceSite_GetWindow
,    thopsIOleInPlaceSite_ContextSensitiveHelp
,    thopsIOleInPlaceSite_CanInPlaceActivate
,    thopsIOleInPlaceSite_OnInPlaceActivate
,    thopsIOleInPlaceSite_OnUIActivate
,    thopsIOleInPlaceSite_GetWindowContext
,    thopsIOleInPlaceSite_Scroll
,    thopsIOleInPlaceSite_OnUIDeactivate
,    thopsIOleInPlaceSite_OnInPlaceDeactivate
,    thopsIOleInPlaceSite_DiscardUndoState
,    thopsIOleInPlaceSite_DeactivateAndUndo
,    thopsIOleInPlaceSite_OnPosRectChange
};
THOP CONST * CONST apthopsIRpcChannelBuffer[] =
{
    thopsIRpcChannelBuffer_GetBuffer
,    thopsIRpcChannelBuffer_SendReceive
,    thopsIRpcChannelBuffer_FreeBuffer
,    thopsIRpcChannelBuffer_GetDestCtx
,    thopsIRpcChannelBuffer_IsConnected
};
THOP CONST * CONST apthopsIRpcProxyBuffer[] =
{
    thopsIRpcProxyBuffer_Connect
,    thopsIRpcProxyBuffer_Disconnect
};
THOP CONST * CONST apthopsIRpcStubBuffer[] =
{
    thopsIRpcStubBuffer_Connect
,    thopsIRpcStubBuffer_Disconnect
,    thopsIRpcStubBuffer_Invoke
,    thopsIRpcStubBuffer_IsIIDSupported
,    thopsIRpcStubBuffer_CountRefs
,    thopsIRpcStubBuffer_DebugServerQueryInterface
,    thopsIRpcStubBuffer_DebugServerRelease
};
THOP CONST * CONST apthopsIPSFactoryBuffer[] =
{
    thopsIPSFactoryBuffer_CreateProxy
,    thopsIPSFactoryBuffer_CreateStub
};
THOP CONST * CONST apthopsIRpcChannel[] =
{
    thopsIRpcChannel_GetStream
,    thopsIRpcChannel_Call
,    thopsIRpcChannel_GetDestCtx
,    thopsIRpcChannel_IsConnected
};
THOP CONST * CONST apthopsIRpcProxy[] =
{
    thopsIRpcProxy_Connect
,    thopsIRpcProxy_Disconnect
};
THOP CONST * CONST apthopsIRpcStub[] =
{
    thopsIRpcStub_Connect
,    thopsIRpcStub_Disconnect
,    thopsIRpcStub_Invoke
,    thopsIRpcStub_IsIIDSupported
,    thopsIRpcStub_CountRefs
};
THOP CONST * CONST apthopsIPSFactory[] =
{
    thopsIPSFactory_CreateProxy
,    thopsIPSFactory_CreateStub
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\thc\thc\main.h ===
#ifndef __MAIN_H__
#define __MAIN_H__

extern int yyline;

void LexError(char *fmt, ...);
void SetFile(int line, char *file);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\olethk32\vtblifn.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	vtblifn.cxx
//
//  Notes:	This file is automatically generated
//		Do not modify by hand
//
//  History:	Fri May 27 10:39:02 1994	Generated
//
//----------------------------------------------------------------------------

DWORD ThunkMethod3216_48(
    THUNK3216OBJ *ptoThis32
    )
{
    DWORD dwMethod;
    BYTE bArgs[4];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[48];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_47(
    THUNK3216OBJ *ptoThis32
    )
{
    DWORD dwMethod;
    BYTE bArgs[4];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[47];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_46(
    THUNK3216OBJ *ptoThis32
    )
{
    DWORD dwMethod;
    BYTE bArgs[4];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[46];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_45(
    THUNK3216OBJ *ptoThis32,
    SIZEL Arg1
    )
{
    DWORD dwMethod;
    BYTE bArgs[12];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(SIZEL *)(bArgs+4) = Arg1;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[45];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_44(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1,
    WORD Arg2
    )
{
    DWORD dwMethod;
    BYTE bArgs[12];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    *(WORD *)(bArgs+8) = Arg2;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[44];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_43(
    THUNK3216OBJ *ptoThis32
    )
{
    DWORD dwMethod;
    BYTE bArgs[4];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[43];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_42(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1
    )
{
    DWORD dwMethod;
    BYTE bArgs[8];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[42];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_41(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1,
    DWORD Arg2
    )
{
    DWORD dwMethod;
    BYTE bArgs[12];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    *(DWORD *)(bArgs+8) = Arg2;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[41];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_40(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1,
    DWORD Arg2
    )
{
    DWORD dwMethod;
    BYTE bArgs[12];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    *(DWORD *)(bArgs+8) = Arg2;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[40];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_39(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1,
    DWORD Arg2
    )
{
    DWORD dwMethod;
    BYTE bArgs[12];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    *(DWORD *)(bArgs+8) = Arg2;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[39];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_38(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1,
    DWORD Arg2
    )
{
    DWORD dwMethod;
    BYTE bArgs[12];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    *(DWORD *)(bArgs+8) = Arg2;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[38];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_37(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1,
    DWORD Arg2,
    DWORD Arg3
    )
{
    DWORD dwMethod;
    BYTE bArgs[16];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    *(DWORD *)(bArgs+8) = Arg2;
    *(DWORD *)(bArgs+12) = Arg3;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[37];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_36(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1
    )
{
    DWORD dwMethod;
    BYTE bArgs[8];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[36];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_35(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1
    )
{
    DWORD dwMethod;
    BYTE bArgs[8];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[35];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_34(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1
    )
{
    DWORD dwMethod;
    BYTE bArgs[8];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[34];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_33(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1,
    DWORD Arg2,
    SIZEL Arg3,
    DWORD Arg4
    )
{
    DWORD dwMethod;
    BYTE bArgs[24];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    *(DWORD *)(bArgs+8) = Arg2;
    *(SIZEL *)(bArgs+12) = Arg3;
    *(DWORD *)(bArgs+20) = Arg4;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[33];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_32(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1,
    SIZEL Arg2,
    DWORD Arg3
    )
{
    DWORD dwMethod;
    BYTE bArgs[20];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    *(SIZEL *)(bArgs+8) = Arg2;
    *(DWORD *)(bArgs+16) = Arg3;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[32];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_31(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1,
    DWORD Arg2,
    SIZEL Arg3,
    DWORD Arg4
    )
{
    DWORD dwMethod;
    BYTE bArgs[24];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    *(DWORD *)(bArgs+8) = Arg2;
    *(SIZEL *)(bArgs+12) = Arg3;
    *(DWORD *)(bArgs+20) = Arg4;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[31];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_30(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1,
    DWORD Arg2,
    DWORD Arg3
    )
{
    DWORD dwMethod;
    BYTE bArgs[16];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    *(DWORD *)(bArgs+8) = Arg2;
    *(DWORD *)(bArgs+12) = Arg3;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[30];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_29(
    THUNK3216OBJ *ptoThis32
    )
{
    DWORD dwMethod;
    BYTE bArgs[4];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[29];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_28(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1,
    DWORD Arg2,
    DWORD Arg3,
    DWORD Arg4,
    DWORD Arg5,
    DWORD Arg6,
    DWORD Arg7,
    DWORD Arg8,
    DWORD Arg9,
    DWORD Arg10
    )
{
    DWORD dwMethod;
    BYTE bArgs[44];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    *(DWORD *)(bArgs+8) = Arg2;
    *(DWORD *)(bArgs+12) = Arg3;
    *(DWORD *)(bArgs+16) = Arg4;
    *(DWORD *)(bArgs+20) = Arg5;
    *(DWORD *)(bArgs+24) = Arg6;
    *(DWORD *)(bArgs+28) = Arg7;
    *(DWORD *)(bArgs+32) = Arg8;
    *(DWORD *)(bArgs+36) = Arg9;
    *(DWORD *)(bArgs+40) = Arg10;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[28];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_27(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1,
    DWORD Arg2
    )
{
    DWORD dwMethod;
    BYTE bArgs[12];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    *(DWORD *)(bArgs+8) = Arg2;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[27];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_26(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1,
    DWORD Arg2
    )
{
    DWORD dwMethod;
    BYTE bArgs[12];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    *(DWORD *)(bArgs+8) = Arg2;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[26];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_25(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1,
    DWORD Arg2
    )
{
    DWORD dwMethod;
    BYTE bArgs[12];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    *(DWORD *)(bArgs+8) = Arg2;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[25];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_24(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1,
    DWORD Arg2,
    DWORD Arg3,
    DWORD Arg4
    )
{
    DWORD dwMethod;
    BYTE bArgs[20];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    *(DWORD *)(bArgs+8) = Arg2;
    *(DWORD *)(bArgs+12) = Arg3;
    *(DWORD *)(bArgs+16) = Arg4;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[24];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_23(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1,
    DWORD Arg2,
    DWORD Arg3,
    DWORD Arg4
    )
{
    DWORD dwMethod;
    BYTE bArgs[20];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    *(DWORD *)(bArgs+8) = Arg2;
    *(DWORD *)(bArgs+12) = Arg3;
    *(DWORD *)(bArgs+16) = Arg4;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[23];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_22(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1,
    DWORD Arg2,
    DWORD Arg3,
    DWORD Arg4
    )
{
    DWORD dwMethod;
    BYTE bArgs[20];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    *(DWORD *)(bArgs+8) = Arg2;
    *(DWORD *)(bArgs+12) = Arg3;
    *(DWORD *)(bArgs+16) = Arg4;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[22];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_21(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1,
    DWORD Arg2,
    DWORD Arg3,
    DWORD Arg4,
    DWORD Arg5
    )
{
    DWORD dwMethod;
    BYTE bArgs[24];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    *(DWORD *)(bArgs+8) = Arg2;
    *(DWORD *)(bArgs+12) = Arg3;
    *(DWORD *)(bArgs+16) = Arg4;
    *(DWORD *)(bArgs+20) = Arg5;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[21];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_20(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1,
    DWORD Arg2,
    DWORD Arg3,
    DWORD Arg4,
    DWORD Arg5
    )
{
    DWORD dwMethod;
    BYTE bArgs[24];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    *(DWORD *)(bArgs+8) = Arg2;
    *(DWORD *)(bArgs+12) = Arg3;
    *(DWORD *)(bArgs+16) = Arg4;
    *(DWORD *)(bArgs+20) = Arg5;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[20];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_19(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1,
    DWORD Arg2,
    DWORD Arg3,
    DWORD Arg4,
    DWORD Arg5
    )
{
    DWORD dwMethod;
    BYTE bArgs[24];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    *(DWORD *)(bArgs+8) = Arg2;
    *(DWORD *)(bArgs+12) = Arg3;
    *(DWORD *)(bArgs+16) = Arg4;
    *(DWORD *)(bArgs+20) = Arg5;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[19];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_18(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1,
    ULARGE_INTEGER Arg2,
    DWORD Arg3,
    DWORD Arg4
    )
{
    DWORD dwMethod;
    BYTE bArgs[24];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    *(ULARGE_INTEGER UNALIGNED *)(bArgs+8) = Arg2;
    *(DWORD *)(bArgs+16) = Arg3;
    *(DWORD *)(bArgs+20) = Arg4;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[18];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_17(
    THUNK3216OBJ *ptoThis32,
    ULARGE_INTEGER Arg1,
    DWORD Arg2,
    DWORD Arg3
    )
{
    DWORD dwMethod;
    BYTE bArgs[20];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(ULARGE_INTEGER UNALIGNED *)(bArgs+4) = Arg1;
    *(DWORD *)(bArgs+12) = Arg2;
    *(DWORD *)(bArgs+16) = Arg3;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[17];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_16(
    THUNK3216OBJ *ptoThis32,
    ULARGE_INTEGER Arg1,
    ULARGE_INTEGER Arg2,
    DWORD Arg3
    )
{
    DWORD dwMethod;
    BYTE bArgs[24];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(ULARGE_INTEGER UNALIGNED *)(bArgs+4) = Arg1;
    *(ULARGE_INTEGER UNALIGNED *)(bArgs+12) = Arg2;
    *(DWORD *)(bArgs+20) = Arg3;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[16];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_15(
    THUNK3216OBJ *ptoThis32,
    ULARGE_INTEGER Arg1,
    ULARGE_INTEGER Arg2,
    DWORD Arg3
    )
{
    DWORD dwMethod;
    BYTE bArgs[24];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(ULARGE_INTEGER UNALIGNED *)(bArgs+4) = Arg1;
    *(ULARGE_INTEGER UNALIGNED *)(bArgs+12) = Arg2;
    *(DWORD *)(bArgs+20) = Arg3;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[15];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_14(
    THUNK3216OBJ *ptoThis32,
    ULARGE_INTEGER Arg1
    )
{
    DWORD dwMethod;
    BYTE bArgs[12];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(ULARGE_INTEGER UNALIGNED *)(bArgs+4) = Arg1;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[14];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_13(
    THUNK3216OBJ *ptoThis32,
    ULARGE_INTEGER Arg1,
    DWORD Arg2,
    DWORD Arg3,
    DWORD Arg4
    )
{
    DWORD dwMethod;
    BYTE bArgs[24];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(ULARGE_INTEGER UNALIGNED *)(bArgs+4) = Arg1;
    *(DWORD *)(bArgs+12) = Arg2;
    *(DWORD *)(bArgs+16) = Arg3;
    *(DWORD *)(bArgs+20) = Arg4;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[13];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_12(
    THUNK3216OBJ *ptoThis32,
    ULARGE_INTEGER Arg1,
    DWORD Arg2,
    DWORD Arg3,
    DWORD Arg4
    )
{
    DWORD dwMethod;
    BYTE bArgs[24];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(ULARGE_INTEGER UNALIGNED *)(bArgs+4) = Arg1;
    *(DWORD *)(bArgs+12) = Arg2;
    *(DWORD *)(bArgs+16) = Arg3;
    *(DWORD *)(bArgs+20) = Arg4;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[12];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_11(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1,
    DWORD Arg2,
    DWORD Arg3
    )
{
    DWORD dwMethod;
    BYTE bArgs[16];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    *(DWORD *)(bArgs+8) = Arg2;
    *(DWORD *)(bArgs+12) = Arg3;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[11];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_10(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1,
    DWORD Arg2,
    DWORD Arg3,
    DWORD Arg4
    )
{
    DWORD dwMethod;
    BYTE bArgs[20];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    *(DWORD *)(bArgs+8) = Arg2;
    *(DWORD *)(bArgs+12) = Arg3;
    *(DWORD *)(bArgs+16) = Arg4;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[10];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_9(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1,
    DWORD Arg2,
    DWORD Arg3,
    DWORD Arg4,
    DWORD Arg5,
    DWORD Arg6
    )
{
    DWORD dwMethod;
    BYTE bArgs[28];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    *(DWORD *)(bArgs+8) = Arg2;
    *(DWORD *)(bArgs+12) = Arg3;
    *(DWORD *)(bArgs+16) = Arg4;
    *(DWORD *)(bArgs+20) = Arg5;
    *(DWORD *)(bArgs+24) = Arg6;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[9];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_8(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1,
    DWORD Arg2,
    DWORD Arg3,
    DWORD Arg4,
    DWORD Arg5,
    DWORD Arg6
    )
{
    DWORD dwMethod;
    BYTE bArgs[28];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    *(DWORD *)(bArgs+8) = Arg2;
    *(DWORD *)(bArgs+12) = Arg3;
    *(DWORD *)(bArgs+16) = Arg4;
    *(DWORD *)(bArgs+20) = Arg5;
    *(DWORD *)(bArgs+24) = Arg6;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[8];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_7(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1,
    DWORD Arg2,
    DWORD Arg3,
    DWORD Arg4,
    DWORD Arg5,
    DWORD Arg6
    )
{
    DWORD dwMethod;
    BYTE bArgs[28];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    *(DWORD *)(bArgs+8) = Arg2;
    *(DWORD *)(bArgs+12) = Arg3;
    *(DWORD *)(bArgs+16) = Arg4;
    *(DWORD *)(bArgs+20) = Arg5;
    *(DWORD *)(bArgs+24) = Arg6;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[7];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_6(
    THUNK3216OBJ *ptoThis32
    )
{
    DWORD dwMethod;
    BYTE bArgs[4];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[6];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_5(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1
    )
{
    DWORD dwMethod;
    BYTE bArgs[8];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[5];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_4(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1
    )
{
    DWORD dwMethod;
    BYTE bArgs[8];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[4];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_3(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1
    )
{
    DWORD dwMethod;
    BYTE bArgs[8];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[3];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_2(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1,
    DWORD Arg2
    )
{
    DWORD dwMethod;
    BYTE bArgs[12];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    *(DWORD *)(bArgs+8) = Arg2;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[2];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_1(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1
    )
{
    DWORD dwMethod;
    BYTE bArgs[8];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[1];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}
DWORD ThunkMethod3216_0(
    THUNK3216OBJ *ptoThis32,
    DWORD Arg1,
    DWORD Arg2,
    DWORD Arg3
    )
{
    DWORD dwMethod;
    BYTE bArgs[16];
    *(VPVOID *)bArgs = (DWORD)ptoThis32;
    *(DWORD *)(bArgs+4) = Arg1;
    *(DWORD *)(bArgs+8) = Arg2;
    *(DWORD *)(bArgs+12) = Arg3;
    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)].pftm[0];
    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), dwMethod, bArgs);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\thc\thc\main.c ===
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <string.h>

#include "main.h"
#include "type.h"
#include "gen.h"

extern FILE *yyin;

int yyline;
char yyfile[256];

int yyparse(void);

void SetFile(int line, char *file)
{
    yyline = line;
    strcpy(yyfile, file);
}

void LexError(char *fmt, ...)
{
    va_list args;

    fprintf(stderr, "Error: %s(%d): ", yyfile, yyline);
    va_start(args, fmt);
    vfprintf(stderr, fmt, args);
    va_end(args);
    fputc('\n', stderr);
}

extern int yydebug;

void __cdecl main(int argc, char **argv)
{
    char fn[256];

    if (argc < 2)
    {
        printf("Usage: %s file\n", argv[0]);
        exit(1);
    }

    sprintf(fn, "%s.i", argv[1]);
    fclose(stdin);
    yyin = fopen(fn, "r");
    if (yyin == NULL)
    {
        perror(fn);
        exit(1);
    }

    SetFile(1, fn);
    InitTypes();
    StartGen();

    yyparse();

    if (yyin != stdin)
        fclose(yyin);

    EndGen();
    UninitTypes();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\thc\thc\gen.h ===
#ifndef __GEN_H__
#define __GEN_H__

#define MAX_PARAMS 15
#define MAX_METHODS 32

#define INDEX_TYPE_GLOBAL 0
#define INDEX_TYPE_SIGORD 1
#define INDEX_TYPE_UAGLOBAL 2
#define INDEX_TYPE_PER_CLASS 3
#define INDEX_TYPE_COUNT 4

#define SIGF_NONE       0
#define SIGF_SCALAR     1
#define SIGF_UNALIGNED  2

typedef struct _ParamDesc
{
    int flags;
    size_t size;
} ParamDesc;

typedef struct _RoutineSignature
{
    int nparams;
    ParamDesc params[MAX_PARAMS];
    struct _RoutineSignature *next;
    int index[INDEX_TYPE_COUNT];
} RoutineSignature;

void StartGen(void);
void EndGen(void);

void GenApi(Member *api, Member *params);
void GenMethod(char *class, Member *method, Member *params);
void StartClass(char *class);
void EndClass(char *class);

#define GEN_ALL (-1)

void sStartRoutine(char *class, Member *routine);
void sEndRoutine(char *class, Member *routine,
                 RoutineSignature *sig);
Member *sGenParamList(Member *params, int generic, int number);
void sGenType(Type *t, int generic);

#define THOPI_SECTION           0
#define IFACE_THOPS_SECTION     1
#define IFACE_THOP_TABLE_SECTION 2
#define VTABLE_SECTION          3
#define VTABLE_IMP_SECTION      4
#define IFACE_3216_FN_TO_METHOD_SECTION 5
#define SWITCH_SECTION          6
#define THI_SECTION             7
#define API_LIST_SECTION        8
#define API_THOP_TABLE_SECTION  9
#define API_THOPS_SECTION       10
#define API_VTBL_SECTION        11
#define IID_TO_THI_SECTION      12
#define ENUM_INDEX_SECTION      13
#define API_DEBUG_SECTION       14
#define IFACE_DEBUG_SECTION     15
#define IFACE_DEBUG_TABLE_SECTION 16
#define NSECTIONS               17

void Section(int sec);
void SecOut(char *fmt, ...);

#ifndef TRUE
#define TRUE 1
#define FALSE 0
#endif

extern int not_thunked;

/* Count of methods present on all interfaces, currently the set from
   IUnknown */
#define STD_METHODS 3

#ifdef THUNK_IUNKNOWN
#define FIRST_METHOD 1
#else
#define FIRST_METHOD (STD_METHODS+1)
#endif

#endif

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\olethk32\vtblint.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	vtblint.cxx
//
//  Notes:	This file is automatically generated
//		Do not modify by hand
//
//  History:	Fri May 27 10:39:02 1994	Generated
//
//----------------------------------------------------------------------------

THUNK3216FN CONST tfnIUnknown[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
};
THUNK3216FN CONST tfnIClassFactory[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_0
,    (THUNK3216FN)ThunkMethod3216_1
};
THUNK3216FN CONST tfnIMarshal[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_7
,    (THUNK3216FN)ThunkMethod3216_8
,    (THUNK3216FN)ThunkMethod3216_9
,    (THUNK3216FN)ThunkMethod3216_0
,    (THUNK3216FN)ThunkMethod3216_5
,    (THUNK3216FN)ThunkMethod3216_4
};
THUNK3216FN CONST tfnIStdMarshalInfo[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_0
};
THUNK3216FN CONST tfnIMessageFilter[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_10
,    (THUNK3216FN)ThunkMethod3216_0
,    (THUNK3216FN)ThunkMethod3216_11
};
THUNK3216FN CONST tfnIExternalConnection[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_2
,    (THUNK3216FN)ThunkMethod3216_11
};
THUNK3216FN CONST tfnIEnumString[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_11
,    (THUNK3216FN)ThunkMethod3216_5
,    (THUNK3216FN)ThunkMethod3216_6
,    (THUNK3216FN)ThunkMethod3216_4
};
THUNK3216FN CONST tfnIEnumUnknown[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_11
,    (THUNK3216FN)ThunkMethod3216_5
,    (THUNK3216FN)ThunkMethod3216_6
,    (THUNK3216FN)ThunkMethod3216_4
};
THUNK3216FN CONST tfnIEnumSTATSTG[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_11
,    (THUNK3216FN)ThunkMethod3216_5
,    (THUNK3216FN)ThunkMethod3216_6
,    (THUNK3216FN)ThunkMethod3216_4
};
THUNK3216FN CONST tfnILockBytes[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_12
,    (THUNK3216FN)ThunkMethod3216_13
,    (THUNK3216FN)ThunkMethod3216_6
,    (THUNK3216FN)ThunkMethod3216_14
,    (THUNK3216FN)ThunkMethod3216_15
,    (THUNK3216FN)ThunkMethod3216_16
,    (THUNK3216FN)ThunkMethod3216_2
};
THUNK3216FN CONST tfnIStream[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_11
,    (THUNK3216FN)ThunkMethod3216_0
,    (THUNK3216FN)ThunkMethod3216_17
,    (THUNK3216FN)ThunkMethod3216_14
,    (THUNK3216FN)ThunkMethod3216_18
,    (THUNK3216FN)ThunkMethod3216_5
,    (THUNK3216FN)ThunkMethod3216_6
,    (THUNK3216FN)ThunkMethod3216_16
,    (THUNK3216FN)ThunkMethod3216_15
,    (THUNK3216FN)ThunkMethod3216_2
,    (THUNK3216FN)ThunkMethod3216_4
};
THUNK3216FN CONST tfnIStorage[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_19
,    (THUNK3216FN)ThunkMethod3216_20
,    (THUNK3216FN)ThunkMethod3216_21
,    (THUNK3216FN)ThunkMethod3216_9
,    (THUNK3216FN)ThunkMethod3216_10
,    (THUNK3216FN)ThunkMethod3216_22
,    (THUNK3216FN)ThunkMethod3216_5
,    (THUNK3216FN)ThunkMethod3216_6
,    (THUNK3216FN)ThunkMethod3216_23
,    (THUNK3216FN)ThunkMethod3216_4
,    (THUNK3216FN)ThunkMethod3216_2
,    (THUNK3216FN)ThunkMethod3216_24
,    (THUNK3216FN)ThunkMethod3216_3
,    (THUNK3216FN)ThunkMethod3216_25
,    (THUNK3216FN)ThunkMethod3216_26
};
THUNK3216FN CONST tfnIRootStorage[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_5
};
THUNK3216FN CONST tfnIEnumFORMATETC[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_11
,    (THUNK3216FN)ThunkMethod3216_5
,    (THUNK3216FN)ThunkMethod3216_6
,    (THUNK3216FN)ThunkMethod3216_4
};
THUNK3216FN CONST tfnIEnumSTATDATA[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_11
,    (THUNK3216FN)ThunkMethod3216_5
,    (THUNK3216FN)ThunkMethod3216_6
,    (THUNK3216FN)ThunkMethod3216_4
};
THUNK3216FN CONST tfnIDataObject[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_26
,    (THUNK3216FN)ThunkMethod3216_25
,    (THUNK3216FN)ThunkMethod3216_5
,    (THUNK3216FN)ThunkMethod3216_2
,    (THUNK3216FN)ThunkMethod3216_11
,    (THUNK3216FN)ThunkMethod3216_27
,    (THUNK3216FN)ThunkMethod3216_24
,    (THUNK3216FN)ThunkMethod3216_4
,    (THUNK3216FN)ThunkMethod3216_3
};
THUNK3216FN CONST tfnIViewObject[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_28
,    (THUNK3216FN)ThunkMethod3216_9
,    (THUNK3216FN)ThunkMethod3216_24
,    (THUNK3216FN)ThunkMethod3216_5
,    (THUNK3216FN)ThunkMethod3216_11
,    (THUNK3216FN)ThunkMethod3216_0
};
THUNK3216FN CONST tfnIViewObject2[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_28
,    (THUNK3216FN)ThunkMethod3216_9
,    (THUNK3216FN)ThunkMethod3216_24
,    (THUNK3216FN)ThunkMethod3216_5
,    (THUNK3216FN)ThunkMethod3216_11
,    (THUNK3216FN)ThunkMethod3216_0
,    (THUNK3216FN)ThunkMethod3216_23
};
THUNK3216FN CONST tfnIAdviseSink[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_27
,    (THUNK3216FN)ThunkMethod3216_26
,    (THUNK3216FN)ThunkMethod3216_5
,    (THUNK3216FN)ThunkMethod3216_6
,    (THUNK3216FN)ThunkMethod3216_29
};
THUNK3216FN CONST tfnIAdviseSink2[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_27
,    (THUNK3216FN)ThunkMethod3216_26
,    (THUNK3216FN)ThunkMethod3216_5
,    (THUNK3216FN)ThunkMethod3216_29
,    (THUNK3216FN)ThunkMethod3216_6
,    (THUNK3216FN)ThunkMethod3216_4
};
THUNK3216FN CONST tfnIDataAdviseHolder[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_21
,    (THUNK3216FN)ThunkMethod3216_5
,    (THUNK3216FN)ThunkMethod3216_4
,    (THUNK3216FN)ThunkMethod3216_11
};
THUNK3216FN CONST tfnIOleCache[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_11
,    (THUNK3216FN)ThunkMethod3216_5
,    (THUNK3216FN)ThunkMethod3216_4
,    (THUNK3216FN)ThunkMethod3216_3
,    (THUNK3216FN)ThunkMethod3216_0
};
THUNK3216FN CONST tfnIOleCache2[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_11
,    (THUNK3216FN)ThunkMethod3216_5
,    (THUNK3216FN)ThunkMethod3216_4
,    (THUNK3216FN)ThunkMethod3216_3
,    (THUNK3216FN)ThunkMethod3216_0
,    (THUNK3216FN)ThunkMethod3216_30
,    (THUNK3216FN)ThunkMethod3216_1
};
THUNK3216FN CONST tfnIOleCacheControl[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_5
,    (THUNK3216FN)ThunkMethod3216_29
};
THUNK3216FN CONST tfnIDropTarget[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_31
,    (THUNK3216FN)ThunkMethod3216_32
,    (THUNK3216FN)ThunkMethod3216_29
,    (THUNK3216FN)ThunkMethod3216_33
};
THUNK3216FN CONST tfnIDropSource[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_27
,    (THUNK3216FN)ThunkMethod3216_5
};
THUNK3216FN CONST tfnIPersist[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_5
};
THUNK3216FN CONST tfnIPersistStorage[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_5
,    (THUNK3216FN)ThunkMethod3216_29
,    (THUNK3216FN)ThunkMethod3216_4
,    (THUNK3216FN)ThunkMethod3216_3
,    (THUNK3216FN)ThunkMethod3216_27
,    (THUNK3216FN)ThunkMethod3216_1
,    (THUNK3216FN)ThunkMethod3216_6
};
THUNK3216FN CONST tfnIPersistStream[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_5
,    (THUNK3216FN)ThunkMethod3216_29
,    (THUNK3216FN)ThunkMethod3216_4
,    (THUNK3216FN)ThunkMethod3216_27
,    (THUNK3216FN)ThunkMethod3216_3
};
THUNK3216FN CONST tfnIPersistFile[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_5
,    (THUNK3216FN)ThunkMethod3216_29
,    (THUNK3216FN)ThunkMethod3216_27
,    (THUNK3216FN)ThunkMethod3216_26
,    (THUNK3216FN)ThunkMethod3216_4
,    (THUNK3216FN)ThunkMethod3216_3
};
THUNK3216FN CONST tfnIBindCtx[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_5
,    (THUNK3216FN)ThunkMethod3216_4
,    (THUNK3216FN)ThunkMethod3216_29
,    (THUNK3216FN)ThunkMethod3216_3
,    (THUNK3216FN)ThunkMethod3216_1
,    (THUNK3216FN)ThunkMethod3216_34
,    (THUNK3216FN)ThunkMethod3216_27
,    (THUNK3216FN)ThunkMethod3216_26
,    (THUNK3216FN)ThunkMethod3216_35
,    (THUNK3216FN)ThunkMethod3216_36
};
THUNK3216FN CONST tfnIMoniker[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_36
,    (THUNK3216FN)ThunkMethod3216_29
,    (THUNK3216FN)ThunkMethod3216_35
,    (THUNK3216FN)ThunkMethod3216_27
,    (THUNK3216FN)ThunkMethod3216_34
,    (THUNK3216FN)ThunkMethod3216_24
,    (THUNK3216FN)ThunkMethod3216_23
,    (THUNK3216FN)ThunkMethod3216_22
,    (THUNK3216FN)ThunkMethod3216_30
,    (THUNK3216FN)ThunkMethod3216_26
,    (THUNK3216FN)ThunkMethod3216_5
,    (THUNK3216FN)ThunkMethod3216_4
,    (THUNK3216FN)ThunkMethod3216_11
,    (THUNK3216FN)ThunkMethod3216_0
,    (THUNK3216FN)ThunkMethod3216_3
,    (THUNK3216FN)ThunkMethod3216_25
,    (THUNK3216FN)ThunkMethod3216_2
,    (THUNK3216FN)ThunkMethod3216_37
,    (THUNK3216FN)ThunkMethod3216_21
,    (THUNK3216FN)ThunkMethod3216_1
};
THUNK3216FN CONST tfnIRunningObjectTable[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_24
,    (THUNK3216FN)ThunkMethod3216_36
,    (THUNK3216FN)ThunkMethod3216_35
,    (THUNK3216FN)ThunkMethod3216_27
,    (THUNK3216FN)ThunkMethod3216_26
,    (THUNK3216FN)ThunkMethod3216_25
,    (THUNK3216FN)ThunkMethod3216_34
};
THUNK3216FN CONST tfnIEnumMoniker[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_37
,    (THUNK3216FN)ThunkMethod3216_36
,    (THUNK3216FN)ThunkMethod3216_29
,    (THUNK3216FN)ThunkMethod3216_35
};
THUNK3216FN CONST tfnIEnumOLEVERB[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_37
,    (THUNK3216FN)ThunkMethod3216_36
,    (THUNK3216FN)ThunkMethod3216_29
,    (THUNK3216FN)ThunkMethod3216_35
};
THUNK3216FN CONST tfnIOleObject[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_36
,    (THUNK3216FN)ThunkMethod3216_35
,    (THUNK3216FN)ThunkMethod3216_27
,    (THUNK3216FN)ThunkMethod3216_34
,    (THUNK3216FN)ThunkMethod3216_26
,    (THUNK3216FN)ThunkMethod3216_37
,    (THUNK3216FN)ThunkMethod3216_30
,    (THUNK3216FN)ThunkMethod3216_25
,    (THUNK3216FN)ThunkMethod3216_9
,    (THUNK3216FN)ThunkMethod3216_5
,    (THUNK3216FN)ThunkMethod3216_29
,    (THUNK3216FN)ThunkMethod3216_6
,    (THUNK3216FN)ThunkMethod3216_4
,    (THUNK3216FN)ThunkMethod3216_2
,    (THUNK3216FN)ThunkMethod3216_38
,    (THUNK3216FN)ThunkMethod3216_39
,    (THUNK3216FN)ThunkMethod3216_40
,    (THUNK3216FN)ThunkMethod3216_3
,    (THUNK3216FN)ThunkMethod3216_1
,    (THUNK3216FN)ThunkMethod3216_41
,    (THUNK3216FN)ThunkMethod3216_42
};
THUNK3216FN CONST tfnIOleClientSite[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_29
,    (THUNK3216FN)ThunkMethod3216_37
,    (THUNK3216FN)ThunkMethod3216_42
,    (THUNK3216FN)ThunkMethod3216_6
,    (THUNK3216FN)ThunkMethod3216_36
,    (THUNK3216FN)ThunkMethod3216_43
};
THUNK3216FN CONST tfnIRunnableObject[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_42
,    (THUNK3216FN)ThunkMethod3216_36
,    (THUNK3216FN)ThunkMethod3216_43
,    (THUNK3216FN)ThunkMethod3216_41
,    (THUNK3216FN)ThunkMethod3216_35
};
THUNK3216FN CONST tfnIParseDisplayName[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_24
};
THUNK3216FN CONST tfnIOleContainer[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_24
,    (THUNK3216FN)ThunkMethod3216_41
,    (THUNK3216FN)ThunkMethod3216_42
};
THUNK3216FN CONST tfnIOleItemContainer[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_24
,    (THUNK3216FN)ThunkMethod3216_41
,    (THUNK3216FN)ThunkMethod3216_42
,    (THUNK3216FN)ThunkMethod3216_21
,    (THUNK3216FN)ThunkMethod3216_23
,    (THUNK3216FN)ThunkMethod3216_36
};
THUNK3216FN CONST tfnIOleAdviseHolder[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_41
,    (THUNK3216FN)ThunkMethod3216_42
,    (THUNK3216FN)ThunkMethod3216_36
,    (THUNK3216FN)ThunkMethod3216_35
,    (THUNK3216FN)ThunkMethod3216_43
,    (THUNK3216FN)ThunkMethod3216_29
};
THUNK3216FN CONST tfnIOleLink[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_42
,    (THUNK3216FN)ThunkMethod3216_36
,    (THUNK3216FN)ThunkMethod3216_41
,    (THUNK3216FN)ThunkMethod3216_35
,    (THUNK3216FN)ThunkMethod3216_34
,    (THUNK3216FN)ThunkMethod3216_5
,    (THUNK3216FN)ThunkMethod3216_40
,    (THUNK3216FN)ThunkMethod3216_43
,    (THUNK3216FN)ThunkMethod3216_4
,    (THUNK3216FN)ThunkMethod3216_29
,    (THUNK3216FN)ThunkMethod3216_3
};
THUNK3216FN CONST tfnIOleWindow[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_42
,    (THUNK3216FN)ThunkMethod3216_36
};
THUNK3216FN CONST tfnIOleInPlaceObject[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_42
,    (THUNK3216FN)ThunkMethod3216_36
,    (THUNK3216FN)ThunkMethod3216_43
,    (THUNK3216FN)ThunkMethod3216_29
,    (THUNK3216FN)ThunkMethod3216_41
,    (THUNK3216FN)ThunkMethod3216_6
};
THUNK3216FN CONST tfnIOleInPlaceActiveObject[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_42
,    (THUNK3216FN)ThunkMethod3216_36
,    (THUNK3216FN)ThunkMethod3216_35
,    (THUNK3216FN)ThunkMethod3216_34
,    (THUNK3216FN)ThunkMethod3216_5
,    (THUNK3216FN)ThunkMethod3216_37
,    (THUNK3216FN)ThunkMethod3216_4
};
THUNK3216FN CONST tfnIOleInPlaceUIWindow[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_42
,    (THUNK3216FN)ThunkMethod3216_36
,    (THUNK3216FN)ThunkMethod3216_35
,    (THUNK3216FN)ThunkMethod3216_34
,    (THUNK3216FN)ThunkMethod3216_5
,    (THUNK3216FN)ThunkMethod3216_41
};
THUNK3216FN CONST tfnIOleInPlaceFrame[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_42
,    (THUNK3216FN)ThunkMethod3216_36
,    (THUNK3216FN)ThunkMethod3216_35
,    (THUNK3216FN)ThunkMethod3216_34
,    (THUNK3216FN)ThunkMethod3216_5
,    (THUNK3216FN)ThunkMethod3216_41
,    (THUNK3216FN)ThunkMethod3216_40
,    (THUNK3216FN)ThunkMethod3216_37
,    (THUNK3216FN)ThunkMethod3216_4
,    (THUNK3216FN)ThunkMethod3216_3
,    (THUNK3216FN)ThunkMethod3216_1
,    (THUNK3216FN)ThunkMethod3216_44
};
THUNK3216FN CONST tfnIOleInPlaceSite[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_42
,    (THUNK3216FN)ThunkMethod3216_36
,    (THUNK3216FN)ThunkMethod3216_43
,    (THUNK3216FN)ThunkMethod3216_29
,    (THUNK3216FN)ThunkMethod3216_6
,    (THUNK3216FN)ThunkMethod3216_21
,    (THUNK3216FN)ThunkMethod3216_45
,    (THUNK3216FN)ThunkMethod3216_35
,    (THUNK3216FN)ThunkMethod3216_46
,    (THUNK3216FN)ThunkMethod3216_47
,    (THUNK3216FN)ThunkMethod3216_48
,    (THUNK3216FN)ThunkMethod3216_34
};
THUNK3216FN CONST tfnIRpcChannelBuffer[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_41
,    (THUNK3216FN)ThunkMethod3216_40
,    (THUNK3216FN)ThunkMethod3216_42
,    (THUNK3216FN)ThunkMethod3216_39
,    (THUNK3216FN)ThunkMethod3216_48
};
THUNK3216FN CONST tfnIRpcProxyBuffer[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_42
,    (THUNK3216FN)ThunkMethod3216_48
};
THUNK3216FN CONST tfnIRpcStubBuffer[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_42
,    (THUNK3216FN)ThunkMethod3216_48
,    (THUNK3216FN)ThunkMethod3216_41
,    (THUNK3216FN)ThunkMethod3216_36
,    (THUNK3216FN)ThunkMethod3216_47
,    (THUNK3216FN)ThunkMethod3216_35
,    (THUNK3216FN)ThunkMethod3216_34
};
THUNK3216FN CONST tfnIPSFactoryBuffer[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_24
,    (THUNK3216FN)ThunkMethod3216_37
};
THUNK3216FN CONST tfnIRpcChannel[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_9
,    (THUNK3216FN)ThunkMethod3216_42
,    (THUNK3216FN)ThunkMethod3216_41
,    (THUNK3216FN)ThunkMethod3216_48
};
THUNK3216FN CONST tfnIRpcProxy[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_42
,    (THUNK3216FN)ThunkMethod3216_48
};
THUNK3216FN CONST tfnIRpcStub[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_42
,    (THUNK3216FN)ThunkMethod3216_48
,    (THUNK3216FN)ThunkMethod3216_21
,    (THUNK3216FN)ThunkMethod3216_36
,    (THUNK3216FN)ThunkMethod3216_47
};
THUNK3216FN CONST tfnIPSFactory[] =
{
    (THUNK3216FN)QueryInterfaceProxy3216
,    (THUNK3216FN)AddRefProxy3216
,    (THUNK3216FN)ReleaseProxy3216
,    (THUNK3216FN)ThunkMethod3216_24
,    (THUNK3216FN)ThunkMethod3216_37
};

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\thc\thc\gen.c ===
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>
#include <time.h>
#include <string.h>
#include <stdarg.h>

#include "type.h"
#include "main.h"
#include "gen.h"
#include "special.h"

typedef struct _FileSection
{
    char *file;
    int is_cxx;
    FILE *fp;
} FileSection;

FileSection sections[] =
{
    /* The following files are all #included into a single file so
       only the master file (thopiint) gets cxx decoration */
    "thopiint.cxx",     TRUE,   NULL,
    "thopsint.cxx",     FALSE,  NULL,
    "thtblint.cxx",     FALSE,  NULL,
    "vtblint.cxx",      FALSE,  NULL,
    "vtblifn.cxx",      FALSE,  NULL,
    "fntomthd.cxx",     FALSE,  NULL,

    "tc1632.cxx",       TRUE,   NULL,
    "thi.hxx",          FALSE,  NULL,
    "apilist.hxx",      FALSE,  NULL,

    /* thopsapi is combined with thtblapi so don't generate
       cxx code for it */
    "thtblapi.cxx",     TRUE,   NULL,
    "thopsapi.cxx",     FALSE,  NULL,

    "vtblapi.cxx",      TRUE,   NULL,
    "iidtothi.cxx",     TRUE,   NULL,
    "the.hxx",          FALSE,  NULL,
    "dbgapi.cxx",       TRUE,   NULL,

    /* These two files are a group */
    "dbgint.cxx",       FALSE,  NULL,
    "dbgitbl.cxx",      TRUE,   NULL
};

static FILE *cur_section;

void SecOut(char *fmt, ...)
{
    va_list args;

    if (cur_section == NULL)
    {
        return;
    }

    va_start(args, fmt);
    vfprintf(cur_section, fmt, args);
    va_end(args);
}

void Section(int sec)
{
    if (cur_section == NULL)
    {
        cur_section = sections[sec].fp;
    }
    else
    {
        if (cur_section != sections[sec].fp)
        {
            LexError("Attempt to use section %d when other section open\n",
                     sec);
            cur_section = sections[sec].fp;
        }
        else
        {
            cur_section = NULL;
        }
    }
}

void OpenSection(int sec)
{
    sections[sec].fp = fopen(sections[sec].file, "w");
    if (sections[sec].fp == NULL)
    {
        perror(sections[sec].file);
        exit(1);
    }
}

void CloseSection(int sec)
{
    fclose(sections[sec].fp);
}

void tGenType(char *name, Type *t, int postpone_name)
{
    if (t == NULL)
    {
        LexError("untyped %s", name);
        return;
    }

    for (;;)
    {
        if (t->base == NULL || t->kind == TYK_TYPEDEF)
        {
            switch(t->kind)
            {
            case TYK_STRUCT:
            case TYK_UNION:
            case TYK_CLASS:
            case TYK_ENUM:
                SecOut("%s ", TypeKindNames[t->kind]);
                break;
            }
            if (t->name)
                SecOut("%s", t->name);
            else
                SecOut("<anonymous>");
            if (!postpone_name)
                SecOut(" %s", name);
            break;
        }
        else
        {
            switch(t->kind)
            {
            case TYK_QUALIFIER:
                if (t->flags & TYF_UNSIGNED)
                    SecOut("unsigned ");
                if (t->flags & TYF_CONST)
                    SecOut("const ");
                if (t->flags & TYF_IN)
                    SecOut("__in ");
                if (t->flags & TYF_OUT)
                    SecOut("__out ");
                break;
            case TYK_POINTER:
                tGenType(name, t->base, TRUE);
                SecOut(" *");
                if (!postpone_name)
                    SecOut("%s", name);
                t = NULL;
                break;
            case TYK_ARRAY:
                tGenType(name, t->base, FALSE);
                SecOut("[%d]", t->u.array.len);
                t = NULL;
                break;
            case TYK_FUNCTION:
                tGenType(NULL, t->base, TRUE);
                SecOut(" (*%s)(...)", name);
                t = NULL;
                break;

            default:
                LexError("<Unhandled non-base type>");
                t = NULL;
                break;
            }

            if (t == NULL)
                break;
            else
                t = t->base;
        }
    }
}

void tGenMember(char *name_prefix, Member *m)
{
    char nm[128], *mnm;

    if (m->name)
        mnm = m->name;
    else
        mnm = "<unnamed>";
    if (name_prefix)
        sprintf(nm, "%s%s", name_prefix, mnm);
    else
        strcpy(nm, mnm);

    tGenType(nm, m->type, FALSE);
}

void tGenParamList(Member *params)
{
    SecOut("(");
    if (params->type && params->type->kind == TYK_BASE &&
        !strcmp(params->type->name, "void"))
    {
        SecOut("void");
    }
    else
    {
        while (params)
        {
            tGenMember(NULL, params);
            params = params->next;
            if (params)
                SecOut(", ");
        }
    }
    SecOut(");\n");
}

#define is_id_char(c) (isalnum(c) || (c) == '_')

int EqStructure(char *structure, char *match)
{
    char enclosing = 0;

    for (;;)
    {
        if (*structure == 0 || *match == 0)
            return *structure == *match;

        switch(*match)
        {
        case '?':
            if (enclosing == 0)
                return TRUE;

            while (*structure != enclosing && is_id_char(*structure))
                structure++;

            if (*structure != enclosing)
            {
                LexError("Improperly formed structure string");
                return FALSE;
            }

            if (*++match != enclosing)
                LexError("Improperly formed match string");
            enclosing = 0;
            break;

        case '<':
            enclosing = '>';
            goto must_match;
        case '/':
            enclosing = '/';
            goto must_match;
        case '[':
            enclosing = ']';
            goto must_match;
        case '\'':
            enclosing = '\'';
            goto must_match;
        case '{':
            enclosing = '}';
            goto must_match;
        case '(':
            enclosing = ')';
            goto must_match;

        default:
        must_match:
            if (*structure != *match)
                return FALSE;
            break;
        }
        structure++;
        match++;
    }
}

void Nothing(char *structure, char *arg)
{
}

void PrintArg(char *structure, char *arg)
{
    SecOut("%s", arg);
}

void ClassIn(char *structure, char *arg)
{
    structure += 2;
    structure[strlen(structure)-1] = 0;
    SecOut("THOP_IFACE | THOP_IN, THI_%s", structure);
}

void ClassOut(char *structure, char *arg)
{
    structure += 3;
    structure[strlen(structure)-1] = 0;
    SecOut("THOP_IFACE | THOP_OUT, THI_%s", structure);
}

void StructureError(char *structure, char *arg)
{
    LexError("<ERROR - StructureError called>\n");
}

typedef struct _ToThop
{
    char *structure;
    ParamDesc desc;
    void (*fn)(char *structure, char *arg);
    char *arg;
    int review;
} ToThop;

ToThop to_thops[] =
{
    "<HRESULT>",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_HRESULT",
    FALSE,

    "u<long>",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_COPY, 4",
    FALSE,

    "<long>",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_COPY, 4",
    FALSE,

    "*<long>",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_COPY | THOP_OUT, 4",
    FALSE,

    "<int>",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_SHORTLONG",
    FALSE,

    "*<int>",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_SHORTLONG | THOP_OUT",
    FALSE,

    "u<int>",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_WORDDWORD",
    FALSE,

    "*/?/",
    SIGF_SCALAR, 4,
    ClassIn, "",
    FALSE,

    "**/?/",
    SIGF_SCALAR, 4,
    ClassOut, "",
    FALSE,

    "<void>",
    SIGF_NONE, 0,
    Nothing, "",
    FALSE,

    "*u<long>",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_COPY | THOP_OUT, 4",
    FALSE,

    "*<WCHAR>",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_LPSTR | THOP_IN",
    FALSE,

    "*<char>",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_LPSTR | THOP_IN",
    FALSE,

    "<REFGUID>",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_COPY | THOP_IN, 16",
    FALSE,

    "<REFCLSID>",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_COPY | THOP_IN, 16",
    FALSE,

    "<REFIID>",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_COPY | THOP_IN, 16",
    FALSE,

    "*<HRESULT>",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_HRESULT | THOP_OUT",
    FALSE,

    "<HANDLE>",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_HANDLE",
    FALSE,

    "<HINSTANCE>",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_HINST",
    FALSE,

    "<HDC>",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_HGDI",
    FALSE,

    "<HWND>",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_HUSER",
    FALSE,

    "*<HWND>",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_HUSER | THOP_OUT",
    FALSE,

    "<HMENU>",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_HUSER",
    FALSE,

    "<HOLEMENU>",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_ALIAS32, ALIAS_RESOLVE",
    FALSE,

    "<HACCEL>",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_HACCEL",
    FALSE,

    "<HGLOBAL>",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_HGLOBAL",
    FALSE,

    "*<HGLOBAL>",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_HGLOBAL | THOP_OUT",
    FALSE,

    "<HICON>",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_HGDI",
    FALSE,

    "<HTASK>",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_HTASK",
    FALSE,

    "**<WCHAR>",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_LPLPSTR",
    FALSE,

    "**<char>",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_LPLPSTR",
    FALSE,

    "u<short>",
    SIGF_SCALAR, 2,
    PrintArg, "THOP_WORDDWORD",
    FALSE,

    "*u<short>",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_WORDDWORD | THOP_OUT",
    FALSE,

    "{tagULARGE_INTEGER}",
    SIGF_SCALAR|SIGF_UNALIGNED, 8,
    PrintArg, "THOP_COPY, 8",
    FALSE,

    "{_ULARGE_INTEGER}",
    SIGF_SCALAR|SIGF_UNALIGNED, 8,
    PrintArg, "THOP_COPY, 8",
    FALSE,

    "{tagLARGE_INTEGER}",
    SIGF_SCALAR|SIGF_UNALIGNED, 8,
    PrintArg, "THOP_COPY, 8",
    FALSE,

    "{_LARGE_INTEGER}",
    SIGF_SCALAR|SIGF_UNALIGNED, 8,
    PrintArg, "THOP_COPY, 8",
    FALSE,

    "*{tagULARGE_INTEGER}",
    SIGF_SCALAR|SIGF_UNALIGNED, 4,
    PrintArg, "THOP_COPY | THOP_OUT, 8",
    FALSE,

    "*{_ULARGE_INTEGER}",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_COPY | THOP_OUT, 8",
    FALSE,

    "*{tagLOGPALETTE}",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_LOGPALETTE | THOP_IN",
    FALSE,

    "**{tagLOGPALETTE}",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_LOGPALETTE | THOP_OUT",
    FALSE,

    "{tagPOINTL}",
    SIGF_NONE, 8,
    PrintArg, "THOP_COPY, 8",
    FALSE,

    "{tagSIZEL}",
    SIGF_NONE, 8,
    PrintArg, "THOP_COPY, 8",
    FALSE,

    "{tagSIZE}",
    SIGF_NONE, 8,
    PrintArg, "THOP_SIZE",
    FALSE,

    "*{GUID}",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_COPY | THOP_OUT, 16",
    FALSE,

    "*{tagSTATSTG}",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_STATSTG | THOP_OUT",
    FALSE,

    "<SNB>",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_SNB",
    FALSE,

    "*{tagDVTARGETDEVICE}",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_DVTARGETDEVICE | THOP_IN",
    FALSE,

    "*{tagMSG}",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_MSG | THOP_IN",
    FALSE,

    "*{tagINTERFACEINFO}",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_INTERFACEINFO | THOP_IN",
    FALSE,

    /* An OLESTREAM must always be filled out so it's always inout */
    "*{_OLESTREAM}",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_OLESTREAM | THOP_INOUT",
    FALSE,

    /* RPCOLEMESSAGE seems to always be inout */
    "*{tagRPCOLEMESSAGE}",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_RPCOLEMESSAGE | THOP_INOUT",
    FALSE,

    "i*{tagRECT}",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_RECT | THOP_IN",
    FALSE,

    "i*{tagBIND_OPTS}",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_BINDOPTS | THOP_IN",
    FALSE,

    "i*{tagRECTL}",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_COPY | THOP_IN, 16",
    FALSE,

    "i*{tagSTGMEDIUM}",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_STGMEDIUM | THOP_IN, 0, 0",
    FALSE,

    "i*{tagFORMATETC}",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_FORMATETC | THOP_IN",
    FALSE,

    "i*{tagOIFI}",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_OIFI | THOP_IN",
    FALSE,

    "i*{tagFILETIME}",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_COPY | THOP_IN, 8",
    FALSE,

    "i*{tagSIZEL}",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_COPY | THOP_IN, 8",
    FALSE,

    "i*{tagOleMenuGroupWidths}",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_COPY | THOP_IN, 24",
    FALSE,

    "o*{tagRECT}",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_RECT | THOP_OUT",
    FALSE,

    "o*{tagRECTL}",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_COPY | THOP_OUT, 16",
    FALSE,

    "o*{tagSTGMEDIUM}",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_STGMEDIUM | THOP_OUT, 0, 0",
    FALSE,

    "o*{tagFORMATETC}",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_FORMATETC | THOP_OUT",
    FALSE,

    "o*{tagOIFI}",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_OIFI | THOP_OUT",
    FALSE,

    "o*{tagFILETIME}",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_COPY | THOP_OUT, 8",
    FALSE,

    "o*{tagSIZEL}",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_COPY | THOP_OUT, 8",
    FALSE,

    "o*{tagBIND_OPTS}",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_BINDOPTS | THOP_OUT",
    FALSE,

    "io*{tagOleMenuGroupWidths}",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_COPY | THOP_INOUT, 24",
    FALSE,

    "io*u<long>",
    SIGF_SCALAR, 4,
    PrintArg, "THOP_COPY | THOP_INOUT, 4",
    FALSE,

    /* The following can't be used as structural elements but
       are needed for size computations */
    "*<void>",
    SIGF_SCALAR, 4,
    StructureError, NULL,
    TRUE,

    "**<void>",
    SIGF_SCALAR, 4,
    StructureError, NULL,
    TRUE,

    "(pfn)",
    SIGF_SCALAR, 4,
    StructureError, NULL,
    TRUE,

    "*{tagSTATDATA}",
    SIGF_SCALAR, 4,
    StructureError, NULL,
    TRUE,

    "*{tagOLEVERB}",
    SIGF_SCALAR, 4,
    StructureError, NULL,
    TRUE
};
#define TO_THOPS (sizeof(to_thops)/sizeof(to_thops[0]))

static int needs_review;

void sGenToThops(char *structure, int generic)
{
    int i;

    for (i = 0; i < TO_THOPS; i++)
        if (EqStructure(structure, to_thops[i].structure))
        {
            if (generic)
                needs_review |= to_thops[i].review;
            to_thops[i].fn(structure, to_thops[i].arg);
            return;
        }
    LexError("<BUGBUG untranslatable '%s'>", structure);
}

static void TypeStructure(Type *t, char *structure)
{
    char *p;

    if (t == NULL)
    {
        LexError("TypeStructure: No type\n");
        return;
    }

    p = structure;
    while (t)
    {
        switch(t->kind)
        {
        case TYK_BASE:
            sprintf(p, "<%s>", t->name);
            p += strlen(p);
            t = NULL;
            break;
        case TYK_TYPEDEF:
            t = t->base;
            break;
        case TYK_QUALIFIER:
            if (t->flags & TYF_UNSIGNED)
                *p++ = 'u';
            if (t->flags & TYF_IN)
                *p++ = 'i';
            if (t->flags & TYF_OUT)
                *p++ = 'o';
            t = t->base;
            break;
        case TYK_POINTER:
            *p++ = '*';
            t = t->base;
            break;
        case TYK_ARRAY:
            LexError("<BUGBUG - unhandled array>\n");
            t = t->base;
            break;
        case TYK_STRUCT:
            sprintf(p, "{%s}", t->name);
            p += strlen(p);
            t = NULL;
            break;
        case TYK_UNION:
            sprintf(p, "[%s]", t->name);
            p += strlen(p);
            t = NULL;
            break;
        case TYK_CLASS:
            sprintf(p, "/%s/", t->name);
            p += strlen(p);
            t = NULL;
            break;
        case TYK_ENUM:
            sprintf(p, "'%s'", t->name);
            p += strlen(p);
            t = NULL;
            break;
        case TYK_FUNCTION:
            sprintf(p, "(pfn)", t->name);
            p += strlen(p);
            t = NULL;
            break;

        default:
            LexError("TypeStructure: Unknown type kind %d\n", t->kind);
            break;
        }
    }
    *p = 0;
}

void sGenType(Type *t, int generic)
{
    char s[80];

    TypeStructure(t, s);
    sGenToThops(s, generic);
}

static int NoParams(Member *params)
{
    if (params == NULL ||
        (params->type && params->type->name &&
         (!strcmp(params->type->name, "void") ||
          !strcmp(params->type->name, "VOID"))))
        return TRUE;
    else
        return FALSE;
}

Member *sGenParamList(Member *params, int generic, int number)
{
    if (!NoParams(params))
    {
        while (params && number != 0)
        {
            sGenType(params->type, generic);
            params = params->next;
            SecOut(", ");
            if (number > 0)
                number--;
        }
    }
    return params;
}

int method_count;

void sStartRoutine(char *class, Member *routine)
{
    needs_review = FALSE;

    if (class == NULL)
    {
        Section(API_THOPS_SECTION);
    }
    else
    {
        Section(IFACE_THOP_TABLE_SECTION);
        /* method_count has already been incremented */
        if (method_count > FIRST_METHOD)
            SecOut(",");
        SecOut("    thops%s_%s\n", class, routine->name);
        Section(IFACE_THOP_TABLE_SECTION);
        Section(IFACE_THOPS_SECTION);
    }

    SecOut("THOP CONST thops");
    if (class)
        SecOut("%s_", class);
    SecOut("%s[] =\n{\n    ", routine->name);

    if (routine->type &&
        (routine->type->name == NULL ||
         (strcmp(routine->type->name, "HRESULT") != 0 &&
          strcmp(routine->type->name, "void") != 0)))
    {
        SecOut("THOP_RETURNTYPE, ");
        sGenType(routine->type, TRUE);
        SecOut(", ");
    }
}

void sEndRoutine(char *class, Member *routine,
                 RoutineSignature *sig)
{
    SecOut("THOP_END");
    SecOut(", THOP_ROUTINEINDEX, %d", sig->index[INDEX_TYPE_GLOBAL]);
    SecOut("\n};\n");

    if (class == NULL)
        Section(API_THOPS_SECTION);
    else
        Section(IFACE_THOPS_SECTION);

    if (needs_review)
        SecOut("/* ** BUGBUG - REVIEW ** */\n");
}

static void StructureDesc(char *str, ParamDesc *desc)
{
    int i;

    for (i = 0; i < TO_THOPS; i++)
    {
        if (EqStructure(str, to_thops[i].structure))
        {
            *desc = to_thops[i].desc;
            return;
        }
    }

    LexError("<BUGBUG - No match for '%s'\n", str);
}

static void MemberDesc(Member *m, ParamDesc *desc)
{
    char str[80];

    TypeStructure(m->type, str);
    StructureDesc(str, desc);
}

static int max_params = 0;

static RoutineSignature *sig_types = NULL;
static int sig_index = 0;
static RoutineSignature *sig_ord_types[MAX_METHODS];
static int sig_ord_index = 0;
static RoutineSignature *sig_uaglobal_types = NULL;
static int sig_uaglobal_index = 0;
static RoutineSignature *per_class_sigs;
static int per_class_index = 0;

static int method_ua_index[MAX_METHODS];

static void ComputeSignature(char *class, Member *routine, Member *params,
                             RoutineSignature *sig)
{
    int i;
    Member *p;

    i = 0;
    if (class != NULL)
    {
        /* Account for this pointer */
        StructureDesc("*<void>", &sig->params[i++]);
    }

    if (!NoParams(params))
    {
        for (p = params; p; p = p->next)
        {
            MemberDesc(p, &sig->params[i++]);
            if (sig->params[i-1].size == 0)
            {
                LexError("param %d in %s:%s is zero\n", i, class,
                         routine->name);
            }

            if (i > MAX_PARAMS)
            {
                LexError("Too many parameters %d\n", i);
                exit(1);
            }
        }
    }

    if (i > max_params)
        max_params = i;
    sig->nparams = i;
}

static int SignaturesMatch(RoutineSignature *a, RoutineSignature *b)
{
    int i;

    if (a->nparams == b->nparams)
    {
        for (i = 0; i < a->nparams; i++)
        {
            if (a->params[i].flags != b->params[i].flags ||
                a->params[i].size != b->params[i].size)
            {
                break;
            }
        }

        if (i == a->nparams)
        {
            return TRUE;
        }
    }
    return FALSE;
}

static RoutineSignature *RememberSignature(RoutineSignature *sig,
                                           RoutineSignature **list,
                                           int *index_base,
                                           int index_type,
                                           int n)
{
    RoutineSignature *s;

    for (s = *list; s; s = s->next)
        if (SignaturesMatch(sig, s) && --n == 0)
            break;

    if (s == NULL)
    {
        sig->index[index_type] = (*index_base)++;
        s = (RoutineSignature *)PanicMalloc(sizeof(RoutineSignature));
        *s = *sig;
        s->next = *list;
        *list = s;
    }
    else
    {
        sig->index[index_type] = s->index[index_type];
    }
    return s;
}

void sGenRoutine(char *class, Member *routine, Member *params,
                 RoutineSignature *sig)
{
    int i;
    RoutineSignature *s;

    ComputeSignature(class, routine, params, sig);
    RememberSignature(sig, &sig_types, &sig_index, INDEX_TYPE_GLOBAL, 1);

    if (class != NULL)
    {
        /* method_count has already been incremented so subtract one here */
        RememberSignature(sig, &sig_ord_types[method_count-1], &sig_ord_index,
                          INDEX_TYPE_SIGORD, 1);

        /* Ignore QueryInterface, AddRef and Release */
        if (method_count > STD_METHODS)
        {
            per_class_index = 0;
            s = RememberSignature(sig, &per_class_sigs, &per_class_index,
                                  INDEX_TYPE_PER_CLASS, 1);
            s->index[INDEX_TYPE_PER_CLASS]++;

            /* Look up a signature in the unambiguous global list which has
               a matching ambiguity count */
            s = RememberSignature(sig, &sig_uaglobal_types,
                                  &sig_uaglobal_index,
                                  INDEX_TYPE_UAGLOBAL,
                                  s->index[INDEX_TYPE_PER_CLASS]);
            method_ua_index[method_count-1] = s->index[INDEX_TYPE_UAGLOBAL];
        }
    }

    for (i = 0; i < SpecialCaseCount(); i++)
    {
        if (class == NULL || special_cases[i].class == NULL)
        {
            if (class != special_cases[i].class)
                continue;
        }
        else if (!EqStructure(class, special_cases[i].class))
        {
            continue;
        }

        if (!EqStructure(routine->name, special_cases[i].routine))
            continue;

        special_cases[i].fn(class, routine, params, sig);
        break;
    }

    if (i == SpecialCaseCount())
    {
        sStartRoutine(class, routine);
        sGenParamList(params, TRUE, GEN_ALL);
        sEndRoutine(class, routine, sig);
    }
}

int not_thunked;

static char *names_not_thunked[] =
{
    "IMalloc",
    "DllCanUnloadNow",
    "PropagateResult",
    "CoGetMalloc",
    "CoGetCurrentProcess",
    "CoBuildVersion",
    "CoMarshalHresult",
    "CoUnmarshalHresult",
    "IsEqualGUID",
    "StringFromCLSID",
    "StringFromIID",
    "IIDFromString",
    "StringFromGUID2",
    "OleGetMalloc",
    "OleBuildVersion",
    "CoCreateStandardMalloc",
    "CoLoadLibrary",
    "CoFreeLibrary",
    "ReleaseStgMedium",
    "OleGetIconOfFile",
    "OleGetIconOfClass",
    "OleMetafilePictFromIconAndLabel",
    "GetHGlobalFromILockBytes",
    "CreateILockBytesOnHGlobal",
    "GetHGlobalFromStream",
    "CreateStreamOnHGlobal",
    "OleDuplicateData",
    "OleTranslateAccelerator",
    "IsAccelerator",
    "CoGetState",
    "CoSetState"
};
#define NNOT_THUNKED (sizeof(names_not_thunked)/sizeof(names_not_thunked[0]))

static int NotThunked(char *class)
{
    int i;

    for (i = 0; i < NNOT_THUNKED; i++)
        if (!strcmp(names_not_thunked[i], class))
            return TRUE;
    return FALSE;
}

int api_index = 0;

void GenApi(Member *api, Member *params)
{
    RoutineSignature sig;

    if (!NotThunked(api->name))
    {
        tGenMember(NULL, api);
        tGenParamList(params);

        Section(API_THOP_TABLE_SECTION);
        if (api_index > 0)
            SecOut(",");
        SecOut("    thops%s\n", api->name);
        Section(API_THOP_TABLE_SECTION);

        Section(API_VTBL_SECTION);
        if (api_index > 0)
            SecOut(",");

	/* Special case for some calls because the thunking
	   code needs special initialization */
	if (!strcmp(api->name, "CoInitialize") ||
	    !strcmp(api->name, "OleInitialize") ||
            !strcmp(api->name, "CoRegisterClassObject") ||
            !strcmp(api->name, "CoRevokeClassObject") ||
            !strcmp(api->name, "OleRegGetUserType") )
	{
	    SecOut("    (VTBLFN)%sNot\n", api->name);
	}
	else if (!strcmp(api->name, "DllGetClassObject"))
	{
	    SecOut("    (VTBLFN)%sWOW\n", api->name);
	}
	else
	{
	    SecOut("    (VTBLFN)%s\n", api->name);
	}
        Section(API_VTBL_SECTION);

        Section(API_DEBUG_SECTION);
        if (api_index > 0)
            SecOut(",");
        SecOut("    \"%s\"\n", api->name);
        Section(API_DEBUG_SECTION);

        Section(API_LIST_SECTION);
        SecOut("#define THK_API_%s %d\n", api->name, api_index++);
        Section(API_LIST_SECTION);

        sGenRoutine(NULL, api, params, &sig);
    }

    FreeMember(api);
    FreeMemberList(params);
}

void GenMethod(char *class, Member *method, Member *params)
{
    char str[80];
    RoutineSignature sig;

    method_count++;
    if (method_count > MAX_METHODS)
    {
        LexError("Too many methods on %s, %d\n", class, method_count);
        exit(1);
    }

    sprintf(str, "%s::", class);

    tGenMember(str, method);
    tGenParamList(params);

    sGenRoutine(class, method, params, &sig);

    if (!not_thunked)
    {
        Section(VTABLE_SECTION);
        if (method_count > 1)
            SecOut(",");

        /* QueryInterface, AddRef and Release are handled specially */
        if (!strcmp(method->name, "QueryInterface") ||
            !strcmp(method->name, "AddRef") ||
            !strcmp(method->name, "Release"))
        {
            SecOut("    (THUNK3216FN)%sProxy3216\n", method->name);
        }
        else
        {
            SecOut("    (THUNK3216FN)ThunkMethod3216_%d\n",
                   sig.index[INDEX_TYPE_UAGLOBAL]);
        }
        Section(VTABLE_SECTION);

        Section(IFACE_DEBUG_SECTION);
        if (method_count > 1)
            SecOut(",");
        SecOut("    \"%s\"\n", method->name);
        Section(IFACE_DEBUG_SECTION);
    }

    FreeMember(method);
    FreeMemberList(params);
}

static int interface_index = 0;
static int max_methods = 0;
static int total_methods = 0;

void StartClass(char *class)
{
    not_thunked = NotThunked(class);
    if (not_thunked)
    {
        Section(THI_SECTION);
        /* Unthunked but present interfaces are given an index
           of THI_COUNT to guarantee that they're not valid yet
           still keep a consecutive index set */
        SecOut("#define THI_%s THI_COUNT\n", class);
        Section(THI_SECTION);
    }
    else
    {
        Section(THI_SECTION);
        SecOut("#define THI_%s %d\n", class, interface_index++);
        Section(THI_SECTION);

        Section(IID_TO_THI_SECTION);
        if (interface_index > 1)
            SecOut(",");
        SecOut("    &IID_%s, THI_%s\n", class, class);
        Section(IID_TO_THI_SECTION);

        Section(VTABLE_SECTION);
        SecOut("THUNK3216FN CONST tfn%s[] =\n", class);
        SecOut("{\n");
        Section(VTABLE_SECTION);

        Section(IFACE_DEBUG_SECTION);
        SecOut("char *apsz%sNames[] =\n", class);
        SecOut("{\n");
        Section(IFACE_DEBUG_SECTION);

        Section(IFACE_THOP_TABLE_SECTION);
        SecOut("THOP CONST * CONST apthops%s[] =\n", class);
        SecOut("{\n");
        Section(IFACE_THOP_TABLE_SECTION);
    }

    method_count = 0;
    per_class_sigs = NULL;

    memset(method_ua_index, 0xff, sizeof(method_ua_index));
}

void EndClass(char *class)
{
    RoutineSignature *s;
    int i, j;

    if (!not_thunked)
    {
        Section(VTABLE_SECTION);
        SecOut("};\n");
        Section(VTABLE_SECTION);

        Section(IFACE_DEBUG_SECTION);
        SecOut("};\n");
        Section(IFACE_DEBUG_SECTION);

        Section(IFACE_DEBUG_TABLE_SECTION);
        if (interface_index > 1)
            SecOut(",");
        SecOut("    \"%s\", apsz%sNames\n", class, class);
        Section(IFACE_DEBUG_TABLE_SECTION);

        Section(IFACE_THOP_TABLE_SECTION);
        if (method_count <= STD_METHODS)
        {
            SecOut("    NULL\n");
        }
        SecOut("};\n");
        Section(IFACE_THOP_TABLE_SECTION);

        Section(THOPI_SECTION);
        if (interface_index > 1)
            SecOut(",");
        SecOut("    apthops%s", class);
        SecOut(", %d, tfn%s, ", method_count, class);
        if (method_count > STD_METHODS)
            SecOut("ftm%s\n", class);
        else
            SecOut("NULL\n");
        Section(THOPI_SECTION);

        if (method_count > STD_METHODS)
        {
            Section(IFACE_3216_FN_TO_METHOD_SECTION);
            SecOut("BYTE CONST ftm%s[] =\n", class);
            SecOut("{\n");
            for (i = 0; i < sig_uaglobal_index; i++)
            {
                for (j = 0; j < MAX_METHODS; j++)
                    if (method_ua_index[j] == i)
                        break;

                if (j == MAX_METHODS)
                    j = 0;

                if (i > 0)
                    SecOut(",\n");
                SecOut("    %d", j);
            }
            SecOut("\n};\n");
            Section(IFACE_3216_FN_TO_METHOD_SECTION);
        }

        if (method_count > max_methods)
            max_methods = method_count;

        total_methods += method_count;
    }

    while (per_class_sigs)
    {
        s = per_class_sigs->next;
        free(per_class_sigs);
        per_class_sigs = s;
    }
}

static void CairoFilePrologue(char *fn, char *gen, int is_cxx)
{
    SecOut("//+-------------------------------------------------------"
           "--------------------\n");
    SecOut("//\n");
    SecOut("//  Microsoft Windows\n");
    SecOut("//  Copyright (C) Microsoft Corporation, 1992 - 1994.\n");
    SecOut("//\n");
    SecOut("//  File:\t%s\n", fn);
    SecOut("//\n");
    SecOut("//  Notes:	This file is automatically generated\n");
    SecOut("//\t\tDo not modify by hand\n");
    SecOut("//\n");
    //SecOut("//  History:\t%s\tGenerated\n", gen);
    SecOut("//  History:\tFri May 27 10:39:02 1994\tGenerated\n", gen);
    SecOut("//\n");
    SecOut("//--------------------------------------------------------"
           "--------------------\n");
    SecOut("\n");

    if (is_cxx)
    {
        SecOut("#include <headers.cxx>\n");
        SecOut("#pragma hdrstop\n");
        SecOut("\n");
    }
}

void StartGen(void)
{
    int i;
    char tms[80];
    time_t tm;

    tm = time(NULL);
    strcpy(tms, ctime(&tm));
    tms[strlen(tms)-1] = 0;
    for (i = 0; i < NSECTIONS; i++)
    {
        OpenSection(i);
        Section(i);
        CairoFilePrologue(sections[i].file, tms, sections[i].is_cxx);
        Section(i);
    }

    Section(THOPI_SECTION);
    SecOut("#include \"%s\"\n", sections[IFACE_THOPS_SECTION].file);
    SecOut("#include \"%s\"\n", sections[IFACE_THOP_TABLE_SECTION].file);
    SecOut("#include \"%s\"\n", sections[VTABLE_IMP_SECTION].file);
    SecOut("#include \"%s\"\n", sections[VTABLE_SECTION].file);
    SecOut("#include \"%s\"\n",
           sections[IFACE_3216_FN_TO_METHOD_SECTION].file);
    SecOut("\n");
    SecOut("THOPI CONST athopiInterfaceThopis[] =\n");
    SecOut("{\n");
    Section(THOPI_SECTION);

    Section(API_THOP_TABLE_SECTION);
    SecOut("#include \"%s\"\n", sections[API_THOPS_SECTION].file);
    SecOut("\n");
    SecOut("THOP CONST * CONST apthopsApiThops[] =\n");
    SecOut("{\n");
    Section(API_THOP_TABLE_SECTION);

    Section(API_VTBL_SECTION);
    SecOut("VTBLFN CONST apfnApiFunctions[] =\n");
    SecOut("{\n");
    Section(API_VTBL_SECTION);

    Section(IID_TO_THI_SECTION);
    SecOut("#include <coguid.h>\n");
    SecOut("#include <oleguid.h>\n");
    SecOut("IIDTOTHI CONST aittIidToThi[] =\n");
    SecOut("{\n");
    Section(IID_TO_THI_SECTION);

    Section(API_DEBUG_SECTION);
    SecOut("#if DBG == 1\n\n");
    SecOut("char *apszApiNames[] =\n");
    SecOut("{\n");
    Section(API_DEBUG_SECTION);

    Section(IFACE_DEBUG_SECTION);
    SecOut("#if DBG == 1\n\n");
    Section(IFACE_DEBUG_SECTION);

    Section(IFACE_DEBUG_TABLE_SECTION);
    SecOut("#include \"%s\"\n", sections[IFACE_DEBUG_SECTION].file);
    SecOut("#if DBG == 1\n\n");
    SecOut("INTERFACENAMES inInterfaceNames[] =\n");
    SecOut("{\n");
    Section(IFACE_DEBUG_TABLE_SECTION);
}

typedef struct _FullParamSizeInfo
{
    char *scalar_type, *struct_type;
    int byte4_size;
} FullParamSizeInfo;

typedef struct _ParamSizeInfo
{
    char *type;
    int byte4_size;
} ParamSizeInfo;

static FullParamSizeInfo arg_type_conv[] =
{
    NULL,       NULL,       0,
    "BYTE",     NULL,       4,
    "WORD",     NULL,       4,
    NULL,       NULL,       0,
    "DWORD",    NULL,       4,
    NULL,       NULL,       0,
    NULL,       NULL,       0,
    NULL,       NULL,       0,
    "ULARGE_INTEGER", "SIZEL", 8
};
#define ARG_TYPE_CONVS (sizeof(arg_type_conv)/sizeof(arg_type_conv[0]))

static ParamSizeInfo *GetParamSizeInfo(ParamDesc *desc)
{
    static ParamSizeInfo info;
    FullParamSizeInfo *finfo;

    if (desc->size < 0 || desc->size >= ARG_TYPE_CONVS)
    {
        LexError("Invalid parameter description\n");
        exit(1);
    }

    finfo = &arg_type_conv[desc->size];
    if (finfo->byte4_size == 0)
    {
        LexError("Parameter description has unhandled size\n");
        exit(1);
    }

    info.byte4_size = finfo->byte4_size;
    if (desc->flags & SIGF_SCALAR)
    {
        info.type = finfo->scalar_type;
    }
    else
    {
        info.type = finfo->struct_type;
    }
    return &info;
}

static char *AlignmentPrefix(ParamDesc *desc)
{
    if(desc->flags & SIGF_UNALIGNED)
        return "UNALIGNED";
    else
        return "";
}

void EndGen(void)
{
    RoutineSignature *s;
    int i, j, sc, dws, dwi;
    ParamSizeInfo *sinfo;

    printf("APIs = %d\n", api_index);
    printf("Interfaces = %d\n", interface_index);
    printf("Methods = %d\n", total_methods);
    printf("Maximum number of methods on an interface = %d\n", max_methods);
    printf("Maximum number of parameters in a signature = %d\n", max_params);
    printf("Distinct signatures = %d\n", sig_index);
    printf("Distinct signature-ordinal pairs = %d\n", sig_ord_index);
    printf("Per-class unambiguous signatures = %d\n", sig_uaglobal_index);

    sc = 0;
#ifdef SHOW_SIGNATURES
    printf("\nSignatures:\n");
    for (s = sig_types; s; s = s->next)
    {
        printf("%d params:", s->nparams);
        for (i = 0; i < s->nparams; i++)
        {
            printf(" %X:%d", s->params[i].flags, s->params[i].size);
        }
        putchar('\n');
        sc++;
    }
#endif

    Section(THOPI_SECTION);
    SecOut("};\n");
    Section(THOPI_SECTION);

    Section(API_THOP_TABLE_SECTION);
    SecOut("};\n");
    Section(API_THOP_TABLE_SECTION);

    Section(API_VTBL_SECTION);
    SecOut("};\n");
    Section(API_VTBL_SECTION);

    Section(API_LIST_SECTION);
    SecOut("#define THK_API_COUNT %d\n", api_index);
    Section(API_LIST_SECTION);

    Section(THI_SECTION);
    SecOut("#define THI_COUNT %d\n", interface_index);
    Section(THI_SECTION);

    Section(IID_TO_THI_SECTION);
    SecOut("};\n");
    Section(IID_TO_THI_SECTION);

    Section(API_DEBUG_SECTION);
    SecOut("};\n");
    SecOut("\n#endif // DBG\n");
    Section(API_DEBUG_SECTION);

    Section(IFACE_DEBUG_SECTION);
    SecOut("\n#endif // DBG\n");
    Section(IFACE_DEBUG_SECTION);

    Section(IFACE_DEBUG_TABLE_SECTION);
    SecOut("};\n");
    SecOut("\n#endif // DBG\n");
    Section(IFACE_DEBUG_TABLE_SECTION);

    Section(VTABLE_IMP_SECTION);

#ifdef STD_METHOD_IMPL
    SecOut("DWORD ThunkQueryInterface3216(THUNK3216OBJ *pto,\n");
    SecOut("                              DWORD dwArg1,\n");
    SecOut("                              DWORD dwArg2)\n");
    SecOut("{\n");
    SecOut("    DWORD dwStack32[3];\n");
    SecOut("    dwStack32[0] = (DWORD)pto;\n");
    SecOut("    dwStack32[1] = dwArg1;\n");
    SecOut("    dwStack32[2] = dwArg2;\n");
    SecOut("    return InvokeOn16(pto->oid, 0, dwStack32);\n");
    SecOut("}\n");

    SecOut("DWORD ThunkAddRef3216(THUNK3216OBJ *pto)\n");
    SecOut("{\n");
    SecOut("    DWORD dwStack32[1];\n");
    SecOut("    InterlockedIncrement(&pto->cReferences);\n");
    SecOut("    dwStack32[0] = (DWORD)pto;\n");
    SecOut("    return InvokeOn16(pto->oid, 1, dwStack32);\n");
    SecOut("}\n");

    SecOut("DWORD ThunkRelease3216(THUNK3216OBJ *pto)\n");
    SecOut("{\n");
    SecOut("    LONG lRet;\n");
    SecOut("    DWORD dwResult;\n");
    SecOut("    DWORD dwStack32[1];\n");
    SecOut("    lRet = InterlockedDecrement(&pto->cReferences);\n");
    SecOut("    dwStack32[0] = (DWORD)pto;\n");
    SecOut("    dwResult = InvokeOn16(pto->oid, 2, dwStack32);\n");
    SecOut("    if (lRet == 0)\n");
    SecOut("        DestroyProxy3216(pto);\n");
    SecOut("    return dwResult;\n");
    SecOut("}\n");
#endif

#ifdef SIGORD_METHODS
    for (i = 0; i < MAX_METHODS; i++)
    {
        for (s = sig_ord_types[i]; s; s = s->next)
        {
            SecOut("DWORD ThunkMethod3216_%d(\n", s->index[INDEX_TYPE_SIGORD]);

            /* We know that these are all methods so we can always declare
               the this pointer */
            SecOut("    THUNK3216OBJ *ptoThis32");
            dws = sizeof(unsigned long);
            if (s->nparams > 1)
            {
                for (j = 1; j < s->nparams; j++)
                {
                    sinfo = GetParamSizeInfo(&s->params[j]);

                    SecOut(",\n    %s Arg%d", sinfo->type, j);
                    dws += sinfo->byte4_size;
                }
            }
            SecOut("\n    )\n");

            SecOut("{\n");
            SecOut("    BYTE bArgs[%d];\n", dws);

            /* Put this pointer on stack */
            SecOut("    *(VPVOID *)bArgs = (DWORD)ptoThis32;\n");
            dwi = sizeof(unsigned long);

            for (j = 1; j < s->nparams; j++)
            {
                sinfo = GetParamSizeInfo(&s->params[j]);

                SecOut("    *(%s %s *)(bArgs+%d) = Arg%d;\n",
                        sinfo->type,
                        AlignmentPrefix(&s->params[j]),
                        dwi,
                        j);
                dwi += sinfo->byte4_size;
            }

            SecOut("    return InvokeOn16(ptoThis32->oid, %d, bArgs);\n", i);
            SecOut("}\n");
        }
    }
#else
    for (s = sig_uaglobal_types; s; s = s->next)
    {
        SecOut("DWORD ThunkMethod3216_%d(\n", s->index[INDEX_TYPE_UAGLOBAL]);

        /* We know that these are all methods so we can always declare
           the this pointer */
        SecOut("    THUNK3216OBJ *ptoThis32");
        dws = sizeof(unsigned long);
        if (s->nparams > 1)
        {
            for (j = 1; j < s->nparams; j++)
            {
                sinfo = GetParamSizeInfo(&s->params[j]);

                SecOut(",\n    %s Arg%d", sinfo->type, j);
                dws += sinfo->byte4_size;
            }
        }
        SecOut("\n    )\n");

        SecOut("{\n");
        SecOut("    DWORD dwMethod;\n");
        SecOut("    BYTE bArgs[%d];\n", dws);

        /* Put this pointer on stack */
        SecOut("    *(VPVOID *)bArgs = (DWORD)ptoThis32;\n");
        dwi = sizeof(unsigned long);

        for (j = 1; j < s->nparams; j++)
        {
            sinfo = GetParamSizeInfo(&s->params[j]);

            SecOut("    *(%s %s *)(bArgs+%d) = Arg%d;\n",
                    sinfo->type,
                    AlignmentPrefix(&s->params[j]),
                    dwi,
                    j);
            dwi += sinfo->byte4_size;
        }

        SecOut("    dwMethod = athopiInterfaceThopis[IIDIDX_INDEX(ptoThis32->iidx)]."
               "pftm[%d];\n", s->index[INDEX_TYPE_UAGLOBAL]);
        SecOut("    return InvokeOn16(IIDIDX_INDEX(ptoThis32->iidx), "
	       "dwMethod, bArgs);\n");
        SecOut("}\n");
    }
#endif
    Section(VTABLE_IMP_SECTION);

    Section(SWITCH_SECTION);
    SecOut("DWORD ThunkCall1632(THUNKINFO *pti)\n");
    SecOut("{\n");
    SecOut("    DWORD dwReturn;\n");
    SecOut("    thkAssert(pti->pvfn != NULL);\n");
    SecOut("    thkAssert(*pti->pThop == THOP_END);\n");
    SecOut("    pti->pThop++;\n");
    SecOut("    thkAssert(*pti->pThop == THOP_ROUTINEINDEX);\n");
    SecOut("    pti->pThop++;\n");
    SecOut("    if (FAILED(pti->scResult))\n");
    SecOut("    {\n");
    SecOut("        return (DWORD)pti->scResult;\n");
    SecOut("    }\n");
    SecOut("    pti->pThkMgr->SetThkState(THKSTATE_NOCALL);\n");
    SecOut("    switch(*pti->pThop)\n");
    SecOut("    {\n");

    for (i = 0; i < sig_index; i++)
    {
        for (s = sig_types; s; s = s->next)
            if (s->index[INDEX_TYPE_GLOBAL] == i)
                break;

        SecOut("    case %d:\n", i);
        SecOut("        dwReturn = (*(DWORD (__stdcall *)(");

        for (j = 0; j < s->nparams; j++)
        {
            sinfo = GetParamSizeInfo(&s->params[j]);

            SecOut("\n                %s", sinfo->type);
            if (j < s->nparams-1)
            {
                SecOut(",");
            }
        }

        SecOut("))pti->pvfn)(\n");

        dwi = 0;
        for (j = 0; j < s->nparams; j++)
        {
            sinfo = GetParamSizeInfo(&s->params[j]);

            SecOut("            *(%s %s *)(pti->s32.pbStart+%d)",
                    sinfo->type,
                    AlignmentPrefix(&s->params[j]),
                    dwi);
            if (j < s->nparams-1)
            {
                SecOut(",\n");
            }
            else
            {
                SecOut("\n");
            }
            dwi += sinfo->byte4_size;
        }
        SecOut("            );\n");
        SecOut("        break;\n");
    }
    SecOut("    }\n");

    SecOut("#if DBG == 1\n");
    SecOut("    if ( !pti->fResultThunked && FAILED(dwReturn) )\n");
    SecOut("    {\n");
    SecOut("        thkDebugOut((DEB_FAILURES,\n");
    SecOut("            \"ThunkCall1632 pvfn = %%08lX "
	   "Probably failed hr = %%08lX\\n\",\n");
    SecOut("            pti->pvfn, dwReturn));\n");
    SecOut("    }\n");
    SecOut("#endif\n");

    SecOut("    pti->pThkMgr->SetThkState(THKSTATE_INVOKETHKOUT32);\n");
    SecOut("    return dwReturn;\n");
    SecOut("}\n");
    Section(SWITCH_SECTION);

    for (i = 0; i < NSECTIONS; i++)
    {
        CloseSection(i);
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\thc\thpp\cobjps.h ===
/*****************************************************************************\
*                                                                             *
* cobjps.h -    Definitions for writing standard proxies and stubs			  *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/

#if !defined( _COBJPS_H_ )
#define _COBJPS_H_


/****** IRpcChannel Interface ***********************************************/

interface IRpcChannel : IUnknown 
{
    STDMETHOD(GetStream)(REFIID iid, int iMethod, BOOL fSend,
                     BOOL fNoWait, DWORD size, IStream FAR* FAR* ppIStream) = 0;
    STDMETHOD(Call)(IStream FAR* pIStream) = 0;
    STDMETHOD(GetDestCtx)(DWORD FAR* lpdwDestCtx, LPVOID FAR* lplpvDestCtx) = 0;
    STDMETHOD(IsConnected)(void) = 0;
};


/****** IRpcProxy Interface *************************************************/

// IRpcProxy is an interface implemented by proxy objects.  A proxy object has
// exactly the same interfaces as the real object in addition to IRpcProxy.
//

interface IRpcProxy : IUnknown 
{
    STDMETHOD(Connect)(IRpcChannel FAR* pRpcChannel) = 0;
    STDMETHOD_(void, Disconnect)(void) = 0;
};


/****** IRpcStub Interface **************************************************/

// IRpcStub is an interface implemented by stub objects.  
//

interface IRpcStub : IUnknown
{
    STDMETHOD(Connect)(IUnknown FAR* pUnk) = 0;
    STDMETHOD_(void, Disconnect)(void) = 0;
    STDMETHOD(Invoke)(REFIID iid, int iMethod, IStream FAR* pIStream,
            DWORD dwDestCtx, LPVOID lpvDestCtx) = 0;
    STDMETHOD_(BOOL, IsIIDSupported)(REFIID iid) = 0;
    STDMETHOD_(ULONG, CountRefs)(void) = 0;
};


/****** IPSFactory Interface ************************************************/

// IPSFactory - creates proxies and stubs
//

interface IPSFactory : IUnknown
{
    STDMETHOD(CreateProxy)(IUnknown FAR* pUnkOuter, REFIID riid, 
        IRpcProxy FAR* FAR* ppProxy, void FAR* FAR* ppv) = 0;
    STDMETHOD(CreateStub)(REFIID riid, IUnknown FAR* pUnkServer,
        IRpcStub FAR* FAR* ppStub) = 0;
};

#endif // _COBJPS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\thc\thpp\coguid.h ===
/*****************************************************************************\
*                                                                             *
* coguid.h -    Master definition of GUIDs for compobj.dll                    *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/

/* this file is the master definition of all GUIDs for the component object
   model and is included in compobj.h.  Some GUIDs for moinkers and storage 
   appear here as well.  All of these GUIDs are OLE GUIDs only in the sense 
   that part of the GUID range owned by OLE was used to define them.  
   
   NOTE: The second byte of all of these GUIDs is 0.
*/
   

DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

DEFINE_OLEGUID(IID_IUnknown,            0x00000000L, 0, 0);
DEFINE_OLEGUID(IID_IClassFactory,       0x00000001L, 0, 0);
DEFINE_OLEGUID(IID_IMalloc,             0x00000002L, 0, 0);
DEFINE_OLEGUID(IID_IMarshal,            0x00000003L, 0, 0);

/* RPC related interfaces */
DEFINE_OLEGUID(IID_IRpcChannel,         0x00000004L, 0, 0);
DEFINE_OLEGUID(IID_IRpcStub,            0x00000005L, 0, 0);
DEFINE_OLEGUID(IID_IStubManager,        0x00000006L, 0, 0);
DEFINE_OLEGUID(IID_IRpcProxy,           0x00000007L, 0, 0);
DEFINE_OLEGUID(IID_IProxyManager,       0x00000008L, 0, 0);
DEFINE_OLEGUID(IID_IPSFactory,          0x00000009L, 0, 0);

/* storage related interfaces */
DEFINE_OLEGUID(IID_ILockBytes,          0x0000000aL, 0, 0);
DEFINE_OLEGUID(IID_IStorage,            0x0000000bL, 0, 0);
DEFINE_OLEGUID(IID_IStream,             0x0000000cL, 0, 0);
DEFINE_OLEGUID(IID_IEnumSTATSTG,        0x0000000dL, 0, 0);

/* moniker related interfaces */
DEFINE_OLEGUID(IID_IBindCtx,            0x0000000eL, 0, 0);
DEFINE_OLEGUID(IID_IMoniker,            0x0000000fL, 0, 0);
DEFINE_OLEGUID(IID_IRunningObjectTable, 0x00000010L, 0, 0);
DEFINE_OLEGUID(IID_IInternalMoniker,    0x00000011L, 0, 0);

/* storage related interfaces */
DEFINE_OLEGUID(IID_IRootStorage,        0x00000012L, 0, 0);
DEFINE_OLEGUID(IID_IDfReserved1,        0x00000013L, 0, 0);
DEFINE_OLEGUID(IID_IDfReserved2,        0x00000014L, 0, 0);
DEFINE_OLEGUID(IID_IDfReserved3,        0x00000015L, 0, 0);

/* concurrency releated interfaces */
DEFINE_OLEGUID(IID_IMessageFilter,      0x00000016L, 0, 0);

/* CLSID of standard marshaler */
DEFINE_OLEGUID(CLSID_StdMarshal,        0x00000017L, 0, 0);

/* interface on server for getting info for std marshaler */
DEFINE_OLEGUID(IID_IStdMarshalInfo,     0x00000018L, 0, 0);

/* interface to inform object of number of external connections */
DEFINE_OLEGUID(IID_IExternalConnection, 0x00000019L, 0, 0);

/* NOTE: LSB 0x1a through 0xff are reserved for future use */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\thc\thc\myypars.c ===
# define YYFLAG -1000
# define YYERROR goto yyerrlab
# define YYACCEPT return(0)
# define YYABORT return(1)

/*      parser for yacc output  */

int yydebug = 0; /* 1 for debugging */
YYSTYPE yyv[YYMAXDEPTH]; /* where the values are stored */
int yychar = -1; /* current input token number */
int yynerrs = 0;  /* number of errors */
short yyerrflag = 0;  /* error recovery flag */

yyparse()
   {

   short yys[YYMAXDEPTH];
   short yyj, yym;
   register YYSTYPE *yypvt;
   register short yystate, *yyps, yyn;
   register YYSTYPE *yypv;
   register short *yyxi;

   yystate = 0;
   yychar = -1;
   yynerrs = 0;
   yyerrflag = 0;
   yyps= &yys[-1];
   yypv= &yyv[-1];

yystack:    /* put a state and value onto the stack */

   if( yydebug  )
       printf( "depth %3d, state %3d, char 0%o\n",
              yyps-yys+1, yystate, yychar );
   if( ++yyps> &yys[YYMAXDEPTH] )
      {
      yyerror( "yacc stack overflow" );
      return(1);
      }
   *yyps = yystate;
   ++yypv;
#ifdef YACC_UNION
   yyunion(yypv, &yyval);
#else
   *yypv = yyval;
#endif
yynewstate:

   yyn = yypact[yystate];

   if( yyn<= YYFLAG ) goto yydefault; /* simple state */

   if( yychar<0 ) if( (yychar=yylex())<0 ) yychar=0;
   if( (yyn += yychar)<0 || yyn >= YYLAST ) goto yydefault;

   if( yychk[ yyn=yyact[ yyn ] ] == yychar )
      {
      /* valid shift */
      yychar = -1;
#ifdef YACC_UNION
	  yyunion(&yyval, &yylval);
#else
      yyval = yylval;
#endif
      yystate = yyn;
      if( yyerrflag > 0 ) --yyerrflag;
      goto yystack;
      }
yydefault:
   /* default state action */

   if( (yyn=yydef[yystate]) == -2 )
      {
      if( yychar<0 ) if( (yychar=yylex())<0 ) yychar = 0;
      /* look through exception table */

      for( yyxi=yyexca; (*yyxi!= (-1)) || (yyxi[1]!=yystate) ; yyxi += 2 ) ; /* VOID */

      for(yyxi+=2; *yyxi >= 0; yyxi+=2)
         {
         if( *yyxi == yychar ) break;
         }
      if( (yyn = yyxi[1]) < 0 ) return(0);   /* accept */
      }

   if( yyn == 0 )
      {
      /* error */
      /* error ... attempt to resume parsing */

      switch( yyerrflag )
         {

      case 0:   /* brand new error */

         yyerror( "syntax error" );
yyerrlab:
         ++yynerrs;

      case 1:
      case 2: /* incompletely recovered error ... try again */

         yyerrflag = 3;

         /* find a state where "error" is a legal shift action */

         while ( yyps >= yys )
            {
            yyn = yypact[*yyps] + YYERRCODE;
            if( yyn>= 0 && yyn < YYLAST && yychk[yyact[yyn]] == YYERRCODE )
               {
               yystate = yyact[yyn];  /* simulate a shift of "error" */
               goto yystack;
               }
            yyn = yypact[*yyps];

            /* the current yyps has no shift onn "error", pop stack */

            if( yydebug ) printf( "error recovery pops state %d, uncovers %d\n", *yyps, yyps[-1] );
            --yyps;
            --yypv;
            }

         /* there is no state on the stack with an error shift ... abort */

yyabort:
         return(1);


      case 3:  /* no shift yet; clobber input char */

         if( yydebug ) printf( "error recovery discards char %d\n", yychar );

         if( yychar == 0 ) goto yyabort; /* don't discard EOF, quit */
         yychar = -1;
         goto yynewstate;   /* try again in the same state */

         }

      }

   /* reduction by production yyn */

   if( yydebug ) printf("reduce %d\n",yyn);
   yyps -= yyr2[yyn];
   yypvt = yypv;
   yypv -= yyr2[yyn];
#ifdef YACC_UNION
   yyunion(&yyval, &yypv[1]);
#else
   yyval = yypv[1];
#endif
   yym=yyn;
   /* consult goto table to find next state */
   yyn = yyr1[yyn];
   yyj = yypgo[yyn] + *yyps + 1;
   if( yyj>=YYLAST || yychk[ yystate = yyact[yyj] ] != -yyn ) yystate = yyact[yypgo[yyn]];
   switch(yym)
      {
      $A
      }
   goto yystack;  /* stack new state and value */

   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\thc\thc\op.c ===
#include <stdio.h>

#include "op.h"
#include "main.h"

int PrefixOp(int op, int val)
{
    switch(op)
    {
    case OP_UNARY_MINUS:
        return -val;
    }
    LexError("Unknown prefix operator");
    return 0;
}

int BinaryOp(int left, int op, int right)
{
    switch(op)
    {
    case OP_LEFT_SHIFT:
        return left << right;
    }
    LexError("Unknown binary operator");
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\thc\thc\op.h ===
#ifndef __OP_H__
#define __OP_H__

#define OP_UNARY_MINUS 0
#define OP_LEFT_SHIFT 1

int PrefixOp(int op, int val);
int BinaryOp(int left, int op, int right);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\thc\thc\special.h ===
#ifndef __SPECIAL_H__
#define __SPECIAL_H__

typedef struct _SpecialCase
{
    char *class;
    char *routine;
    void (*fn)(char *class, Member *routine, Member *params,
               RoutineSignature *sig);
} SpecialCase;

extern SpecialCase special_cases[];

int SpecialCaseCount(void);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\thc\thpp\initguid.h ===
/*****************************************************************************\
*                                                                             *
* initguid.h -	Definitions for controlling GUID initialization				  *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/

// Include after compobj.h to enable GUID initialization.  This 
//              must be done once per exe/dll.
//
// After this file, include one or more of the GUID definition files.
//
// NOTE: ole2.lib contains references to all GUIDs defined by OLE.

#ifndef DEFINE_GUID
#pragma error "initguid: must include compobj.h first."
#endif

#undef DEFINE_GUID

#ifdef _MAC
#define __based(a)
#endif

#ifdef WIN32
#define __based(a)
#endif

#ifdef __TURBOC__
#define __based(a)
#endif

#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    EXTERN_C const GUID CDECL __based(__segname("_CODE")) name \
                    = { l, w1, w2, { b1, b2,  b3,  b4,  b5,  b6,  b7,  b8 } }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\thc\thc\type.h ===
#ifndef __TYPE_H__
#define __TYPE_H__

#define TYF_NONE        0
#define TYF_UNSIGNED    1
#define TYF_CONST       2
#define TYF_IN          4
#define TYF_OUT         8

#define TYK_BASE        0
#define TYK_TYPEDEF     1
#define TYK_QUALIFIER   2
#define TYK_POINTER     3
#define TYK_ARRAY       4
#define TYK_STRUCT      5
#define TYK_UNION       6
#define TYK_CLASS       7
#define TYK_ENUM        8
#define TYK_FUNCTION    9

struct _Type;
typedef struct _Type Type;

typedef struct _ArrayType
{
    int len;
} ArrayType;

typedef struct _Member
{
    char *name;
    Type *type;
    struct _Member *next;
} Member;

typedef struct _Aggregate
{
    Member *members;
} Aggregate;

struct _Type
{
    char *name;
    struct _Type *base;
    int flags;
    int kind;
    int ref;

    union
    {
        ArrayType array;
        Aggregate agg;
    } u;

    struct _Type *next;
    struct _Type *prev;
};

extern char *TypeKindNames[];

void *PanicMalloc(size_t bytes);

void InitTypes(void);
void UninitTypes(void);

Type *NewBaseType(char *name);
Type *NewQualifiedType(char *name, int flags, Type *base);
Type *NewTypedefType(char *name, Type *base);
Type *NewPointerType(char *name, Type *base);
Type *NewArrayType(char *name, int len, Type *base);
Type *NewStructType(char *name, Member *members);
Type *NewUnionType(char *name, Member *members);
Type *NewClassType(char *name, Member *members);
Type *NewAggregateType(char *name, Member *members, int kind);
Type *NewEnumType(char *name);
Type *NewFunctionType(char *name);

void FreeType(Type *t);

void ReferenceType(Type *t);
void DereferenceType(Type *t);

void AddType(Type *t);
Type *FindType(char *name);
Type *FindTypeErr(char *name);

Type *ApplyQualifiers(Type *qual, Type *base);

Member *NewMember(char *name, Type *t);
Member *AppendMember(Member *list, Member *m);
Member *ApplyMemberType(Member *list, Type *t);
void FreeMember(Member *m);
void FreeMemberList(Member *list);

void Typedef(Member *td_names, Type *decl);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\thc\thc\special.c ===
#include <stdio.h>
#include <ctype.h>

#include "type.h"
#include "main.h"
#include "gen.h"
#include "special.h"

#ifndef TRUE
#define TRUE 1
#define FALSE 0
#endif

#define ALL_CLASSES "Std"

extern int api_index;
extern int method_count;

void sBuiltIn(char *class, Member *routine, Member *params,
              RoutineSignature *sig)
{
    /* Thop string is built in */
    if (!not_thunked)
    {
        if (class == NULL)
        {
            Section(API_THOP_TABLE_SECTION);
            if (api_index > 1)
                SecOut(",");
            SecOut("    thops%s\n", routine->name);
            Section(API_THOP_TABLE_SECTION);
        }
        else
        {
            Section(IFACE_THOP_TABLE_SECTION);
            if (method_count > FIRST_METHOD)
                SecOut(",");
            SecOut("    thops" ALL_CLASSES "_%s\n", routine->name);
            Section(IFACE_THOP_TABLE_SECTION);
        }
    }
}

// Only generate these once even though they exist on every interface

#ifdef THUNK_IUNKNOWN
void sQueryInterface(char *class, Member *routine, Member *params,
                     RoutineSignature *sig)
{
    static int gen = FALSE;

    if (!not_thunked)
    {
        if (!gen)
        {
            sStartRoutine(ALL_CLASSES, routine);

            // This thop string should never be used
            SecOut("THOP_ERROR, ");
            
            sEndRoutine(ALL_CLASSES, routine, sig);
            gen = TRUE;
        }
        else
        {
            sBuiltIn(ALL_CLASSES, routine, params, sig);
        }
    }
}

void sAddRef(char *class, Member *routine, Member *params,
             RoutineSignature *sig)
{
    static int gen = FALSE;

    if (!not_thunked)
    {
        if (!gen)
        {
            sStartRoutine(ALL_CLASSES, routine);

            // This thop string should never be used
            SecOut("THOP_ERROR, ");
            
            sEndRoutine(ALL_CLASSES, routine, sig);
            gen = TRUE;
        }
        else
        {
            sBuiltIn(ALL_CLASSES, routine, params, sig);
        }
    }
}

void sRelease(char *class, Member *routine, Member *params,
              RoutineSignature *sig)
{
    static int gen = FALSE;

    if (!not_thunked)
    {
        if (!gen)
        {
            sStartRoutine(ALL_CLASSES, routine);

            // This thop string should never be used
            SecOut("THOP_ERROR, ");
            
            sEndRoutine(ALL_CLASSES, routine, sig);
            gen = TRUE;
        }
        else
        {
            sBuiltIn(ALL_CLASSES, routine, params, sig);
        }
    }
}
#else
void sQueryInterface(char *class, Member *routine, Member *params,
                     RoutineSignature *sig)
{
    // Not thunked
}

void sAddRef(char *class, Member *routine, Member *params,
             RoutineSignature *sig)
{
    // Not thunked
}

void sRelease(char *class, Member *routine, Member *params,
              RoutineSignature *sig)
{
    // Not thunked
}
#endif

static int enum_index = 0;

void sIEnum_Next(char *class, Member *routine, Member *params,
                 RoutineSignature *sig)
{
    Section(ENUM_INDEX_SECTION);
    SecOut("#define THE_%s %d\n", class, enum_index++);
    Section(ENUM_INDEX_SECTION);
    
    sStartRoutine(class, routine);
    SecOut("THOP_ENUM, THE_%s, ", class);
    sEndRoutine(class, routine, sig);
}

void sIClassFactory_CreateInstance(char *class, Member *routine,
                                   Member *params,
                                   RoutineSignature *sig)
{
    sStartRoutine(class, routine);
    
    /* LPUNKNOWN */
    sGenType(params->type, FALSE);
    params = params->next;
    SecOut(", ");

    /* REFIID */
    sGenType(params->type, FALSE);
    
    /* Interface return */
    SecOut(", THOP_IFACEGENOWNER | THOP_OUT, %d, %d, ",
           sizeof(void *), 2*sizeof(void *));
    
    sEndRoutine(class, routine, sig);
}

void sIMalloc_All(char *class, Member *routine, Member *params,
                  RoutineSignature *sig)
{
}

void sIMarshal_GetUnmarshalClass(char *class, Member *routine, Member *params,
                                 RoutineSignature *sig)
{
    sStartRoutine(class, routine);

    /* REFIID */
    sGenType(params->type, FALSE);
    params = params->next;
    
    /* Interface in */
    SecOut(", THOP_IFACEGEN | THOP_IN, %d, ", sizeof(void *));
    params = params->next;
    
    /* dwContext */
    sGenType(params->type, FALSE);
    params = params->next;

    /* pvContext is reserved NULL */
    SecOut(", THOP_NULL | THOP_IN, ");
    params = params->next;
    
    /* Continue normally */
    sGenParamList(params, FALSE, GEN_ALL);
    
    sEndRoutine(class, routine, sig);
}

void sIMarshal_GetMarshalSizeMax(char *class, Member *routine, Member *params,
                                 RoutineSignature *sig)
{
    sStartRoutine(class, routine);

    /* REFIID */
    sGenType(params->type, FALSE);
    params = params->next;
    
    /* Interface in */
    SecOut(", THOP_IFACEGEN | THOP_IN, %d, ", sizeof(void *));
    params = params->next;
    
    /* dwContext */
    sGenType(params->type, FALSE);
    params = params->next;

    /* pvContext is reserved NULL */
    SecOut(", THOP_NULL | THOP_IN, ");
    params = params->next;
    
    /* Continue normally */
    sGenParamList(params, FALSE, GEN_ALL);
    
    sEndRoutine(class, routine, sig);
}

void sIMarshal_MarshalInterface(char *class, Member *routine, Member *params,
                                RoutineSignature *sig)
{
    sStartRoutine(class, routine);

    /* LPSTREAM */
    sGenType(params->type, FALSE);
    params = params->next;
    SecOut(", ");

    /* REFIID */
    sGenType(params->type, FALSE);
    params = params->next;
    
    /* Interface in */
    SecOut(", THOP_IFACEGEN | THOP_IN, %d, ", sizeof(void *));
    params = params->next;
    
    /* dwContext */
    sGenType(params->type, FALSE);
    params = params->next;

    /* pvContext is reserved NULL */
    SecOut(", THOP_NULL | THOP_IN, ");
    params = params->next;
    
    /* Continue normally */
    sGenParamList(params, FALSE, GEN_ALL);
    
    sEndRoutine(class, routine, sig);
}

void sIMarshal_UnmarshalInterface(char *class, Member *routine, Member *params,
                                  RoutineSignature *sig)
{
    sStartRoutine(class, routine);

    /* LPSTREAM */
    sGenType(params->type, FALSE);
    params = params->next;
    SecOut(", ");

    /* REFIID */
    sGenType(params->type, FALSE);
    
    /* Interface out */
    SecOut(", THOP_IFACEGEN | THOP_OUT, %d, ", sizeof(void *));
    
    sEndRoutine(class, routine, sig);
}

void sIStdMarshalInfo_GetClassForHandler(char *class, Member *routine,
                                         Member *params,
                                         RoutineSignature *sig)
{
    sStartRoutine(class, routine);

    /* dwContext */
    sGenType(params->type, FALSE);
    params = params->next;

    /* pvContext is reserved NULL */
    SecOut(", THOP_NULL | THOP_IN, ");
    params = params->next;
    
    /* Continue normally */
    sGenParamList(params, FALSE, GEN_ALL);
    
    sEndRoutine(class, routine, sig);
}

void sCoGetClassObject(char *class, Member *routine, Member *params,
                       RoutineSignature *sig)
{
    sStartRoutine(class, routine);

    /* REFCLSID */
    params = sGenParamList(params, FALSE, 1);

    /* dwClsContext */
    SecOut("THOP_CLSCONTEXT, ");
    params = params->next;
    
    /* pvReserved */
    SecOut("THOP_NULL | THOP_IN, ");
    params = params->next;

    /* REFIID */
    sGenType(params->type, FALSE);
    params = params->next;
    
    /* Interface out */
    SecOut(", THOP_IFACEGEN | THOP_OUT, %d, ", sizeof(void *));
    
    sEndRoutine(class, routine, sig);
}

void sCoRegisterClassObject(char *class, Member *routine, Member *params,
                            RoutineSignature *sig)
{
    sStartRoutine(class, routine);

    /* Two normal */
    params = sGenParamList(params, FALSE, 2);

    /* dwClsContext */
    SecOut("THOP_CLSCONTEXT, ");
    params = params->next;
    
    /* Continue normally */
    sGenParamList(params, FALSE, GEN_ALL);
    
    sEndRoutine(class, routine, sig);
}

void sCoMarshalInterface(char *class, Member *routine, Member *params,
                         RoutineSignature *sig)
{
    sStartRoutine(class, routine);

    /* LPSTREAM */
    sGenType(params->type, FALSE);
    params = params->next;
    SecOut(", ");

    /* REFIID */
    sGenType(params->type, FALSE);
    params = params->next;
    
    /* Interface in */
    SecOut(", THOP_IFACEGEN | THOP_IN, %d, ", sizeof(void *));
    params = params->next;
    
    /* dwContext */
    sGenType(params->type, FALSE);
    params = params->next;

    /* pvContext is reserved NULL */
    SecOut(", THOP_NULL | THOP_IN, ");
    params = params->next;
    
    /* Continue normally */
    sGenParamList(params, FALSE, GEN_ALL);
    
    sEndRoutine(class, routine, sig);
}

void sCoUnmarshalInterface(char *class, Member *routine, Member *params,
                           RoutineSignature *sig)
{
    sStartRoutine(class, routine);

    /* LPSTREAM */
    sGenType(params->type, FALSE);
    params = params->next;
    SecOut(", ");

    /* REFIID */
    sGenType(params->type, FALSE);
    
    /* Interface out */
    SecOut(", THOP_IFACEGEN | THOP_OUT, %d, ", sizeof(void *));
    
    sEndRoutine(class, routine, sig);
}

void sCoCreateInstance(char *class, Member *routine, Member *params,
                       RoutineSignature *sig)
{
    sStartRoutine(class, routine);

    /* Two normal */
    params = sGenParamList(params, FALSE, 2);

    /* Class context */
    SecOut("THOP_CLSCONTEXT, ");
    params = params->next;
    
    /* REFIID */
    sGenType(params->type, FALSE);
    params = params->next;
    
    /* Interface out */
    SecOut(", THOP_IFACEGENOWNER | THOP_OUT, %d, %d, ",
           sizeof(void *), 3*sizeof(void *));
    
    sEndRoutine(class, routine, sig);
}

void sDllGetClassObject(char *class, Member *routine, Member *params,
                        RoutineSignature *sig)
{
    sStartRoutine(class, routine);

    /* REFCLSID */
    sGenType(params->type, FALSE);
    params = params->next;
    SecOut(", ");

    /* REFIID */
    sGenType(params->type, FALSE);
    
    /* Interface out */
    SecOut(", THOP_IFACEGEN | THOP_OUT, %d, ", sizeof(void *));
    
    sEndRoutine(class, routine, sig);
}

void sCoGetStandardMarshal(char *class, Member *routine, Member *params,
                           RoutineSignature *sig)
{
    sStartRoutine(class, routine);

    /* riid, punk, dwDestContext */
    params = sGenParamList(params, FALSE, 3);

    /* pvContext is reserved NULL */
    SecOut("THOP_NULL | THOP_IN, ");
    params = params->next;
    
    /* Continue normally */
    sGenParamList(params, FALSE, GEN_ALL);
    
    sEndRoutine(class, routine, sig);
}

void sILockBytes_ReadAt(char *class, Member *routine, Member *params,
                        RoutineSignature *sig)
{
    sStartRoutine(class, routine);

    /* ULARGE_INTEGER */
    sGenType(params->type, FALSE);
    params = params->next;

    /* Skip pv and size */
    SecOut(", THOP_BUFFER | THOP_OUT, ");
    params = params->next->next;

    /* Continue normally */
    sGenParamList(params, FALSE, GEN_ALL);
    
    sEndRoutine(class, routine, sig);
}

void sILockBytes_WriteAt(char *class, Member *routine, Member *params,
                         RoutineSignature *sig)
{
    sStartRoutine(class, routine);

    /* ULARGE_INTEGER */
    sGenType(params->type, FALSE);
    params = params->next;

    /* Buffer */
    SecOut(", THOP_BUFFER | THOP_IN, ");
    params = params->next->next;

    /* Continue normally */
    sGenParamList(params, FALSE, GEN_ALL);
    
    sEndRoutine(class, routine, sig);
}

void sIStream_Read(char *class, Member *routine, Member *params,
                   RoutineSignature *sig)
{
    sStartRoutine(class, routine);

    /* Skip pv and size */
    SecOut("THOP_BUFFER | THOP_OUT, ");
    params = params->next->next;

    /* Continue normally */
    sGenParamList(params, FALSE, GEN_ALL);
    
    sEndRoutine(class, routine, sig);
}

void sIStream_Write(char *class, Member *routine, Member *params,
                    RoutineSignature *sig)
{
    sStartRoutine(class, routine);
    
    /* Buffer */
    SecOut("THOP_BUFFER | THOP_IN, ");
    params = params->next->next;

    /* Continue normally */
    sGenParamList(params, FALSE, GEN_ALL);
    
    sEndRoutine(class, routine, sig);
}

void sIStorage_CopyTo(char *class, Member *routine, Member *params,
                      RoutineSignature *sig)
{
    sStartRoutine(class, routine);

    /* iidExclude array */
    SecOut("THOP_CRGIID, ");
    params = params->next->next;

    /* Continue normally */
    sGenParamList(params, FALSE, GEN_ALL);
    
    sEndRoutine(class, routine, sig);
}

void sCreateDataCache(char *class, Member *routine, Member *params,
                      RoutineSignature *sig)
{
    sStartRoutine(class, routine);

    /* Two normal */
    params = sGenParamList(params, FALSE, 2);

    /* REFIID */
    sGenType(params->type, FALSE);
    params = params->next;
    
    /* Out interface */
    SecOut(", THOP_IFACEGENOWNER | THOP_OUT, %d, %d, ",
           sizeof(void *), 3*sizeof(void *));
    
    sEndRoutine(class, routine, sig);
}

void sIMoniker_BindToObject(char *class, Member *routine, Member *params,
                            RoutineSignature *sig)
{
    sStartRoutine(class, routine);

    /* Two normal */
    params = sGenParamList(params, FALSE, 2);

    /* REFIID */
    sGenType(params->type, FALSE);
    params = params->next;
    
    /* Out interface */
    SecOut(", THOP_IFACEGEN | THOP_OUT, %d, ", sizeof(void *));
    
    sEndRoutine(class, routine, sig);
}

void sIMoniker_BindToStorage(char *class, Member *routine, Member *params,
                             RoutineSignature *sig)
{
    sStartRoutine(class, routine);

    /* Two normal */
    params = sGenParamList(params, FALSE, 2);

    /* REFIID */
    sGenType(params->type, FALSE);
    params = params->next;
    
    /* Out interface */
    SecOut(", THOP_IFACEGEN | THOP_OUT, %d, ", sizeof(void *));
    
    sEndRoutine(class, routine, sig);
}

void sBindMoniker(char *class, Member *routine, Member *params,
                  RoutineSignature *sig)
{
    sStartRoutine(class, routine);

    /* Two normal */
    params = sGenParamList(params, FALSE, 2);

    /* REFIID */
    sGenType(params->type, FALSE);
    params = params->next;
    
    /* Out interface */
    SecOut(", THOP_IFACEGEN | THOP_OUT, %d, ", sizeof(void *));
    
    sEndRoutine(class, routine, sig);
}

void sIOleItemContainer_GetObject(char *class, Member *routine, Member *params,
                                  RoutineSignature *sig)
{
    sStartRoutine(class, routine);

    /* Three normal */
    params = sGenParamList(params, FALSE, 3);

    /* REFIID */
    sGenType(params->type, FALSE);
    params = params->next;
    
    /* Out interface */
    SecOut(", THOP_IFACEGEN | THOP_OUT, %d, ", sizeof(void *));
    
    sEndRoutine(class, routine, sig);
}

void sIOleItemContainer_GetObjectStorage(char *class, Member *routine,
                                         Member *params,
                                         RoutineSignature *sig)
{
    sStartRoutine(class, routine);

    /* Two normal */
    params = sGenParamList(params, FALSE, 2);

    /* REFIID */
    sGenType(params->type, FALSE);
    params = params->next;
    
    /* Out interface */
    SecOut(", THOP_IFACEGEN | THOP_OUT, %d, ", sizeof(void *));
    
    sEndRoutine(class, routine, sig);
}

void sOleCreate(char *class, Member *routine, Member *params,
                RoutineSignature *sig)
{
    sStartRoutine(class, routine);

    /* Six normal */
    params = sGenParamList(params, FALSE, 6);

    /* Out interface referring to second param */
    SecOut("THOP_IFACEGEN | THOP_OUT, %d, ", 5*sizeof(void *));
    
    sEndRoutine(class, routine, sig);
}

void sOleCreateFromData(char *class, Member *routine, Member *params,
                        RoutineSignature *sig)
{
    sStartRoutine(class, routine);

    /* Six normal */
    params = sGenParamList(params, FALSE, 6);

    /* Out interface referring to second param */
    SecOut("THOP_IFACEGEN | THOP_OUT, %d, ", 5*sizeof(void *));
    
    sEndRoutine(class, routine, sig);
}

void sOleCreateLinkFromData(char *class, Member *routine, Member *params,
                            RoutineSignature *sig)
{
    sStartRoutine(class, routine);

    /* Six normal */
    params = sGenParamList(params, FALSE, 6);

    /* Out interface referring to second param */
    SecOut("THOP_IFACEGEN | THOP_OUT, %d, ", 5*sizeof(void *));
    
    sEndRoutine(class, routine, sig);
}

void sOleCreateLinkToFile(char *class, Member *routine, Member *params,
                          RoutineSignature *sig)
{
    sStartRoutine(class, routine);

    /* Six normal */
    params = sGenParamList(params, FALSE, 6);

    /* Out interface referring to second param */
    SecOut("THOP_IFACEGEN | THOP_OUT, %d, ", 5*sizeof(void *));
    
    sEndRoutine(class, routine, sig);
}

void sOleCreateStaticFromData(char *class, Member *routine, Member *params,
                              RoutineSignature *sig)
{
    sStartRoutine(class, routine);

    /* Six normal */
    params = sGenParamList(params, FALSE, 6);

    /* Out interface referring to second param */
    SecOut("THOP_IFACEGEN | THOP_OUT, %d, ", 5*sizeof(void *));
    
    sEndRoutine(class, routine, sig);
}

void sOleCreateLink(char *class, Member *routine, Member *params,
                    RoutineSignature *sig)
{
    sStartRoutine(class, routine);

    /* Six normal */
    params = sGenParamList(params, FALSE, 6);

    /* Out interface referring to second param */
    SecOut("THOP_IFACEGEN | THOP_OUT, %d, ", 5*sizeof(void *));
    
    sEndRoutine(class, routine, sig);
}

void sOleCreateFromFile(char *class, Member *routine, Member *params,
                        RoutineSignature *sig)
{
    sStartRoutine(class, routine);

    /* Seven normal */
    params = sGenParamList(params, FALSE, 7);

    /* Out interface referring to third param */
    SecOut("THOP_IFACEGEN | THOP_OUT, %d, ", 5*sizeof(void *));
    
    sEndRoutine(class, routine, sig);
}

void sOleLoad(char *class, Member *routine, Member *params,
              RoutineSignature *sig)
{
    sStartRoutine(class, routine);

    /* Three normal */
    params = sGenParamList(params, FALSE, 3);

    /* Out interface referring to second param */
    SecOut("THOP_IFACEGEN | THOP_OUT, %d, ", 2*sizeof(void *));
    
    sEndRoutine(class, routine, sig);
}

void sOleLoadFromStream(char *class, Member *routine, Member *params,
                        RoutineSignature *sig)
{
    sStartRoutine(class, routine);

    /* One normal */
    params = sGenParamList(params, FALSE, 1);

    /* REFIID */
    sGenType(params->type, FALSE);
    params = params->next;
    
    /* Out interface */
    SecOut(", THOP_IFACEGEN | THOP_OUT, %d, ", sizeof(void *));
    
    sEndRoutine(class, routine, sig);
}

void sOleCreateDefaultHandler(char *class, Member *routine, Member *params,
                              RoutineSignature *sig)
{
    sStartRoutine(class, routine);

    /* Two normal */
    params = sGenParamList(params, FALSE, 2);

    /* REFIID */
    sGenType(params->type, FALSE);
    params = params->next;
    
    /* Out interface */
    SecOut(", THOP_IFACEGENOWNER | THOP_OUT, %d, %d, ",
           sizeof(void *), 2*sizeof(void *));
    
    sEndRoutine(class, routine, sig);
}

void sOleCreateEmbeddingHelper(char *class, Member *routine, Member *params,
                               RoutineSignature *sig)
{
    sStartRoutine(class, routine);

    /* Four normal */
    params = sGenParamList(params, FALSE, 4);

    /* REFIID */
    sGenType(params->type, FALSE);
    params = params->next;
    
    /* Out interface */
    SecOut(", THOP_IFACEGENOWNER | THOP_OUT, %d, %d, ",
           sizeof(void *), 4*sizeof(void *));
    
    sEndRoutine(class, routine, sig);
}

void sStringFromGUID2(char *class, Member *routine, Member *params,
                      RoutineSignature *sig)
{
    sStartRoutine(class, routine);
    SecOut("THOP_ERROR /* BUGBUG - LPWSTR is out param */, ");
    sEndRoutine(class, routine, sig);
}

void sIViewObject_Draw(char *class, Member *routine, Member *params,
                       RoutineSignature *sig)
{
    sStartRoutine(class, routine);

    /* Two normal */
    params = sGenParamList(params, FALSE, 2);

    /* pvAspect */
    SecOut("THOP_NULL | THOP_IN, ");
    params = params->next;

    /* Five normal */
    params = sGenParamList(params, FALSE, 5);

    /* pfnContinue and dwContinue */
    SecOut("THOP_CALLBACK, ");
    
    sEndRoutine(class, routine, sig);
}

void sIViewObject_GetColorSet(char *class, Member *routine, Member *params,
                              RoutineSignature *sig)
{
    sStartRoutine(class, routine);

    /* Two normal */
    params = sGenParamList(params, FALSE, 2);

    /* pvAspect */
    SecOut("THOP_NULL | THOP_IN, ");
    params = params->next;

    /* Continue normally */
    sGenParamList(params, FALSE, GEN_ALL);
    
    sEndRoutine(class, routine, sig);
}

void sIViewObject_Freeze(char *class, Member *routine, Member *params,
                         RoutineSignature *sig)
{
    sStartRoutine(class, routine);

    /* Two normal */
    params = sGenParamList(params, FALSE, 2);

    /* pvAspect */
    SecOut("THOP_NULL | THOP_IN, ");
    params = params->next;

    /* Continue normally */
    sGenParamList(params, FALSE, GEN_ALL);
    
    sEndRoutine(class, routine, sig);
}

void sIViewObject2_Draw(char *class, Member *routine, Member *params,
                        RoutineSignature *sig)
{
    sStartRoutine(class, routine);

    /* Two normal */
    params = sGenParamList(params, FALSE, 2);

    /* pvAspect */
    SecOut("THOP_NULL | THOP_IN, ");
    params = params->next;

    /* Five normal */
    params = sGenParamList(params, FALSE, 5);

    /* pfnContinue and dwContinue */
    SecOut("THOP_CALLBACK, ");
    
    sEndRoutine(class, routine, sig);
}

void sIViewObject2_GetColorSet(char *class, Member *routine, Member *params,
                               RoutineSignature *sig)
{
    sStartRoutine(class, routine);

    /* Two normal */
    params = sGenParamList(params, FALSE, 2);

    /* pvAspect */
    SecOut("THOP_NULL | THOP_IN, ");
    params = params->next;

    /* Continue normally */
    sGenParamList(params, FALSE, GEN_ALL);
    
    sEndRoutine(class, routine, sig);
}

void sIViewObject2_Freeze(char *class, Member *routine, Member *params,
                          RoutineSignature *sig)
{
    sStartRoutine(class, routine);

    /* Two normal */
    params = sGenParamList(params, FALSE, 2);

    /* pvAspect */
    SecOut("THOP_NULL | THOP_IN, ");
    params = params->next;

    /* Continue normally */
    sGenParamList(params, FALSE, GEN_ALL);
    
    sEndRoutine(class, routine, sig);
}

void sIStorage_OpenStream(char *class, Member *routine, Member *params,
                          RoutineSignature *sig)
{
    sStartRoutine(class, routine);

    /* One normal */
    params = sGenParamList(params, FALSE, 1);

    /* reserved1 */
    SecOut("THOP_NULL | THOP_IN, ");
    params = params->next;

    /* Continue normally */
    sGenParamList(params, FALSE, GEN_ALL);
    
    sEndRoutine(class, routine, sig);
}

void sIStorage_EnumElements(char *class, Member *routine, Member *params,
                            RoutineSignature *sig)
{
    sStartRoutine(class, routine);

    /* One normal */
    params = sGenParamList(params, FALSE, 1);

    /* reserved2 */
    SecOut("THOP_NULL | THOP_IN, ");
    params = params->next;

    /* Continue normally */
    sGenParamList(params, FALSE, GEN_ALL);
    
    sEndRoutine(class, routine, sig);
}

void sIOleCache2_UpdateCache(char *class, Member *routine, Member *params,
                             RoutineSignature *sig)
{
    sStartRoutine(class, routine);

    /* Two normal */
    params = sGenParamList(params, FALSE, 2);

    /* pReserved */
    SecOut("THOP_NULL | THOP_IN, ");

    sEndRoutine(class, routine, sig);
}

void sIMoniker_Reduce(char *class, Member *routine,
                      Member *params,
                      RoutineSignature *sig)
{
    sStartRoutine(class, routine);

    /* Two normal */
    params = sGenParamList(params, FALSE, 2);

    /* ppmkToLeft, In/out IMoniker */
    SecOut("THOP_IFACE | THOP_INOUT, THI_IMoniker, ");
    params = params->next;

    /* Finish normally */
    sGenParamList(params, FALSE, GEN_ALL);
    
    sEndRoutine(class, routine, sig);
}

void sIRpcChannelOrBuffer_GetDestCtx(char *class, Member *routine,
                                     Member *params,
                                     RoutineSignature *sig)
{
    sStartRoutine(class, routine);

    /* One normal */
    params = sGenParamList(params, FALSE, 1);

    /* ppvDestContext should always return NULL */
    SecOut("THOP_NULL | THOP_OUT, ");
    
    sEndRoutine(class, routine, sig);
}

void sIRpcStubBuffer_DebugServerRelease(char *class, Member *routine,
                                        Member *params,
                                        RoutineSignature *sig)
{
    sStartRoutine(class, routine);

    /* We need to do special hacking to clean up our proxies for
       DebugServerQueryInterface and Release */
    SecOut("THOP_IFACECLEAN | THOP_IN, THI_IUnknown, ");
    
    sEndRoutine(class, routine, sig);
}

void sIPSFactoryOrBuffer_CreateProxy(char *class, Member *routine,
                                     Member *params,
                                     RoutineSignature *sig)
{
    sStartRoutine(class, routine);

    /* Two normal */
    params = sGenParamList(params, FALSE, 2);

    /* Proxy is aggregated */
    SecOut("THOP_IFACEOWNER | THOP_OUT, THI_%s, %d, ",
	   params->type->base->base->name,
           2*sizeof(void *));
    
    /* ppv returns an aggregated interface */
    SecOut("THOP_IFACEGENOWNER | THOP_OUT, %d, %d, ",
           2*sizeof(void *), 3*sizeof(void *));
    
    sEndRoutine(class, routine, sig);
}

void sIPSFactoryOrBuffer_CreateStub(char *class, Member *routine,
                                    Member *params,
                                    RoutineSignature *sig)
{
    sStartRoutine(class, routine);

    /* Two normal */
    params = sGenParamList(params, FALSE, 2);

    /* Stub is aggregated */
    SecOut("THOP_IFACEOWNER | THOP_OUT, THI_%s, %d, ",
           params->type->base->base->name, sizeof(void *));
    
    sEndRoutine(class, routine, sig);
}

void sIRpcStub_Invoke(char *class, Member *routine,
                      Member *params,
                      RoutineSignature *sig)
{
    sStartRoutine(class, routine);

    /* Four normal */
    params = sGenParamList(params, FALSE, 4);

    /* pvDestContext should always be NULL */
    SecOut("THOP_NULL | THOP_IN, ");
    
    sEndRoutine(class, routine, sig);
}

void sCoDosDateTimeToFileTime(char *class, Member *routine,
                              Member *params,
                              RoutineSignature *sig)
{
    sStartRoutine(class, routine);

    /* Two normal */
    params = sGenParamList(params, FALSE, 2);

    /* out FILETIME */
    SecOut("THOP_COPY | THOP_OUT, 8, ");
    
    sEndRoutine(class, routine, sig);
}

void sStgMedSetData(char *class, Member *routine,
                    Member *params,
                    RoutineSignature *sig)
{
    sStartRoutine(class, routine);

    /* One normal */
    params = sGenParamList(params, FALSE, 1);

    /* In STGMEDIUM with possible ownership transfer indicated
       by following BOOL and FORMATETC as previous parameter */
    SecOut("THOP_STGMEDIUM | THOP_IN, 1, %d, ", sizeof(void *));

    sEndRoutine(class, routine, sig);
}

void sIDataObject_GetData(char *class, Member *routine,
                          Member *params,
                          RoutineSignature *sig)
{
    sStartRoutine(class, routine);

    /* One normal */
    params = sGenParamList(params, FALSE, 1);

    /* Out STGMEDIUM
         Without ownership transfer
         With FORMATETC as previous parameter */
    SecOut("THOP_STGMEDIUM | THOP_OUT, 0, %d, ", sizeof(void *));

    sEndRoutine(class, routine, sig);
}

void sIDataObject_GetDataHere(char *class, Member *routine,
                              Member *params,
                              RoutineSignature *sig)
{
    sStartRoutine(class, routine);

    /* One normal */
    params = sGenParamList(params, FALSE, 1);

    /* In STGMEDIUM
         Without ownership transfer
         With FORMATETC as previous parameter */
    SecOut("THOP_STGMEDIUM | THOP_IN, 0, %d, ", sizeof(void *));

    sEndRoutine(class, routine, sig);
}

void sIAdviseSinks_OnDataChange(char *class, Member *routine,
                                Member *params,
                                RoutineSignature *sig)
{
    sStartRoutine(class, routine);

    /* One normal */
    params = sGenParamList(params, FALSE, 1);

    /* In STGMEDIUM
         Without ownership transfer
         With FORMATETC as previous parameter */
    SecOut("THOP_STGMEDIUM | THOP_IN, 0, %d, ", sizeof(void *));

    sEndRoutine(class, routine, sig);
}

void sOleCreateMenuDescriptor(char *class, Member *routine,
                              Member *params,
                              RoutineSignature *sig)
{
    Type *t;

    /* Avoid generating a return type */
    t = routine->type;
    routine->type = NULL;
    sStartRoutine(class, routine);
    routine->type = t;

    /* Generate return type by hand */
    SecOut("THOP_RETURNTYPE, THOP_ALIAS32, ALIAS_CREATE, ");
    
    /* Finish normally */
    params = sGenParamList(params, FALSE, GEN_ALL);

    sEndRoutine(class, routine, sig);
}

void sOleDestroyMenuDescriptor(char *class, Member *routine,
                               Member *params,
                               RoutineSignature *sig)
{
    sStartRoutine(class, routine);

    /* Destroy alias */
    SecOut("THOP_ALIAS32, ALIAS_REMOVE, ");

    sEndRoutine(class, routine, sig);
}

SpecialCase special_cases[] =
{
    "?", "QueryInterface", sQueryInterface,
    "?", "AddRef", sAddRef,
    "?", "Release", sRelease,
    "IEnum?", "Next", sIEnum_Next,
    "IClassFactory", "CreateInstance", sIClassFactory_CreateInstance,
    "IMalloc", "?", sIMalloc_All,
    "IMarshal", "GetUnmarshalClass", sIMarshal_GetUnmarshalClass,
    "IMarshal", "GetMarshalSizeMax", sIMarshal_GetMarshalSizeMax,
    "IMarshal", "MarshalInterface", sIMarshal_MarshalInterface,
    "IMarshal", "UnmarshalInterface", sIMarshal_UnmarshalInterface,
    "IStdMarshalInfo", "GetClassForHandler",
        sIStdMarshalInfo_GetClassForHandler,
    NULL, "CoGetClassObject", sCoGetClassObject,
    NULL, "CoRegisterClassObject", sCoRegisterClassObject,
    NULL, "CoMarshalInterface", sCoMarshalInterface,
    NULL, "CoUnmarshalInterface", sCoUnmarshalInterface,
    NULL, "CoCreateInstance", sCoCreateInstance,
    NULL, "DllGetClassObject", sDllGetClassObject,
    NULL, "CoGetStandardMarshal", sCoGetStandardMarshal,
    "ILockBytes", "ReadAt", sILockBytes_ReadAt,
    "ILockBytes", "WriteAt", sILockBytes_WriteAt,
    "IStream", "Read", sIStream_Read,
    "IStream", "Write", sIStream_Write,
    "IStorage", "CopyTo", sIStorage_CopyTo,
    NULL, "CreateDataCache", sCreateDataCache,
    "IMoniker", "BindToObject", sIMoniker_BindToObject,
    "IMoniker", "BindToStorage", sIMoniker_BindToStorage,
    NULL, "BindMoniker", sBindMoniker,
    "IOleItemContainer", "GetObject", sIOleItemContainer_GetObject,
    "IOleItemContainer", "GetObjectStorage",
        sIOleItemContainer_GetObjectStorage,
    NULL, "OleCreate", sOleCreate,
    NULL, "OleCreateFromData", sOleCreateFromData,
    NULL, "OleCreateLinkFromData", sOleCreateLinkFromData,
    NULL, "OleCreateStaticFromData", sOleCreateStaticFromData,
    NULL, "OleCreateLink", sOleCreateLink,
    NULL, "OleCreateLinkToFile", sOleCreateLinkToFile,
    NULL, "OleCreateFromFile", sOleCreateFromFile,
    NULL, "OleLoad", sOleLoad,
    NULL, "OleLoadFromStream", sOleLoadFromStream,
    NULL, "OleCreateDefaultHandler", sOleCreateDefaultHandler,
    NULL, "OleCreateEmbeddingHelper", sOleCreateEmbeddingHelper,
    NULL, "StringFromGUID2", sStringFromGUID2,
    "IViewObject", "Draw", sIViewObject_Draw,
    "IViewObject", "GetColorSet", sIViewObject_GetColorSet,
    "IViewObject", "Freeze", sIViewObject_Freeze,
    "IViewObject2", "Draw", sIViewObject2_Draw,
    "IViewObject2", "GetColorSet", sIViewObject2_GetColorSet,
    "IViewObject2", "Freeze", sIViewObject2_Freeze,
    "IStorage", "OpenStream", sIStorage_OpenStream,
    "IStorage", "EnumElements", sIStorage_EnumElements,
    "IOleCache2", "UpdateCache", sIOleCache2_UpdateCache,
    "IMoniker", "Reduce", sIMoniker_Reduce,
    "IRpcChannelBuffer", "GetDestCtx", sIRpcChannelOrBuffer_GetDestCtx,
    "IRpcChannel", "GetDestCtx", sIRpcChannelOrBuffer_GetDestCtx,
    "IRpcStubBuffer", "DebugServerRelease", sIRpcStubBuffer_DebugServerRelease,
    "IPSFactoryBuffer", "CreateProxy", sIPSFactoryOrBuffer_CreateProxy,
    "IPSFactory", "CreateProxy", sIPSFactoryOrBuffer_CreateProxy,
    "IPSFactoryBuffer", "CreateStub", sIPSFactoryOrBuffer_CreateStub,
    "IPSFactory", "CreateStub", sIPSFactoryOrBuffer_CreateStub,
    "IRpcStub", "Invoke", sIRpcStub_Invoke,
    "IDataObject", "SetData", sStgMedSetData,
    "IOleCache", "SetData", sStgMedSetData,
    "IOleCache2", "SetData", sStgMedSetData,
    "IDataObject", "GetData", sIDataObject_GetData,
    "IDataObject", "GetDataHere", sIDataObject_GetDataHere,
    "IAdviseSink", "OnDataChange", sIAdviseSinks_OnDataChange,
    "IAdviseSink2", "OnDataChange", sIAdviseSinks_OnDataChange,
    NULL, "OleCreateMenuDescriptor", sOleCreateMenuDescriptor,
    NULL, "OleDestroyMenuDescriptor", sOleDestroyMenuDescriptor
};
#define SPECIAL_CASES (sizeof(special_cases)/sizeof(special_cases[0]))

int SpecialCaseCount(void)
{
    return SPECIAL_CASES;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\thc\thpp\ole1cls.h ===
/*****************************************************************************\
*                                                                             *
* ole1cls.h -   Master definition of GUIDs for OLE1 classes					  *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/

/* This file is the master definition of all GUIDs for OLE1 classes.
   
   All such GUIDs are of the form:

       0003xxxx-0000-0000-C000-000000000046

    The last parameter to DEFINE_OLE1GUID is the old 1.0 class name,
    i.e., its key in the registration database.

    Do not remove or change GUIDs.

    Do not add anything to this file except comments and DEFINE_OLE1GUID macros.
*/

#ifndef DEFINE_OLE1GUID
#define DEFINE_OLE1GUID(a,b,c,d,e) DEFINE_OLEGUID (a,b,c,d)
#endif
   
DEFINE_OLE1GUID(CLSID_ExcelWorksheet,   0x00030000, 0, 0, "ExcelWorksheet");
DEFINE_OLE1GUID(CLSID_ExcelChart,       0x00030001, 0, 0, "ExcelChart");
DEFINE_OLE1GUID(CLSID_ExcelMacrosheet,  0x00030002, 0, 0, "ExcelMacrosheet");
DEFINE_OLE1GUID(CLSID_WordDocument,     0x00030003, 0, 0, "WordDocument");
DEFINE_OLE1GUID(CLSID_MSPowerPoint,     0x00030004, 0, 0, "MSPowerPoint");
DEFINE_OLE1GUID(CLSID_MSPowerPointSho,  0x00030005, 0, 0, "MSPowerPointSho");
DEFINE_OLE1GUID(CLSID_MSGraph,          0x00030006, 0, 0, "MSGraph");
DEFINE_OLE1GUID(CLSID_MSDraw,               0x00030007, 0, 0, "MSDraw");
DEFINE_OLE1GUID(CLSID_Note_It,          0x00030008, 0, 0, "Note-It");
DEFINE_OLE1GUID(CLSID_WordArt,          0x00030009, 0, 0, "WordArt");
DEFINE_OLE1GUID(CLSID_PBrush,               0x0003000a, 0, 0, "PBrush");
DEFINE_OLE1GUID(CLSID_Equation,         0x0003000b, 0, 0, "Equation");
DEFINE_OLE1GUID(CLSID_Package,          0x0003000c, 0, 0, "Package");
DEFINE_OLE1GUID(CLSID_SoundRec,         0x0003000d, 0, 0, "SoundRec");
DEFINE_OLE1GUID(CLSID_MPlayer,          0x0003000e, 0, 0, "MPlayer");

/* test apps */
DEFINE_OLE1GUID(CLSID_ServerDemo,       0x0003000f, 0, 0, "ServerDemo");
DEFINE_OLE1GUID(CLSID_Srtest,               0x00030010, 0, 0, "Srtest");
DEFINE_OLE1GUID(CLSID_SrtInv,               0x00030011, 0, 0, "SrtInv");
DEFINE_OLE1GUID(CLSID_OleDemo,          0x00030012, 0, 0, "OleDemo");

/* External ISVs */
// Coromandel / Dorai Swamy / 718-793-7963
DEFINE_OLE1GUID(CLSID_CoromandelIntegra,    0x00030013, 0, 0, "CoromandelIntegra");
DEFINE_OLE1GUID(CLSID_CoromandelObjServer,0x00030014, 0, 0, "CoromandelObjServer");

// 3-d Visions Corp / Peter Hirsch / 310-325-1339
DEFINE_OLE1GUID(CLSID_StanfordGraphics, 0x00030015, 0, 0, "StanfordGraphics");

// Deltapoint / Nigel Hearne / 408-648-4000
DEFINE_OLE1GUID(CLSID_DGraphCHART,          0x00030016, 0, 0, "DGraphCHART");
DEFINE_OLE1GUID(CLSID_DGraphDATA,           0x00030017, 0, 0, "DGraphDATA");

// Corel / Richard V. Woodend / 613-728-8200 x1153
DEFINE_OLE1GUID(CLSID_PhotoPaint,           0x00030018, 0, 0, "PhotoPaint");
DEFINE_OLE1GUID(CLSID_CShow,                    0x00030019, 0, 0, "CShow");
DEFINE_OLE1GUID(CLSID_CorelChart,           0x0003001a, 0, 0, "CorelChart");
DEFINE_OLE1GUID(CLSID_CDraw,                    0x0003001b, 0, 0, "CDraw");

// Inset Systems / Mark Skiba / 203-740-2400
DEFINE_OLE1GUID(CLSID_HJWIN1_0,             0x0003001c, 0, 0, "HJWIN1.0");

// Mark V Systems / Mark McGraw / 818-995-7671
DEFINE_OLE1GUID(CLSID_ObjMakerOLE,          0x0003001d, 0, 0, "ObjMakerOLE");

// IdentiTech / Mike Gilger / 407-951-9503
DEFINE_OLE1GUID(CLSID_FYI,                      0x0003001e, 0, 0, "FYI");
DEFINE_OLE1GUID(CLSID_FYIView,                  0x0003001f, 0, 0, "FYIView");

// Inventa Corporation / Balaji Varadarajan / 408-987-0220
DEFINE_OLE1GUID(CLSID_Stickynote,       0x00030020, 0, 0, "Stickynote");

// ShapeWare Corp. / Lori Pearce / 206-467-6723
DEFINE_OLE1GUID(CLSID_ShapewareVISIO10, 0x00030021, 0, 0, "ShapewareVISIO10");
DEFINE_OLE1GUID(CLSID_ImportServer,     0x00030022, 0, 0, "ImportServer");


// test app SrTest
DEFINE_OLE1GUID(CLSID_SrvrTest,          0x00030023, 0, 0, "SrvrTest");

// Special clsid for when a 1.0 client pastes an embedded object
// that is a link.
// **This CLSID is obsolete. Do not reuse number.
//DEFINE_OLE1GUID(CLSID_10EmbedObj,        0x00030024, 0, 0, "OLE2_Embedded_Link");

// test app ClTest.  Doesn't really work as a server but is in reg db
DEFINE_OLE1GUID(CLSID_ClTest,            0x00030025, 0, 0, "Cltest");

// Microsoft ClipArt Gallery   Sherry Larsen-Holmes
DEFINE_OLE1GUID(CLSID_MS_ClipArt_Gallery,0x00030026, 0, 0, "MS_ClipArt_Gallery");

// Microsoft Project  Cory Reina
DEFINE_OLE1GUID(CLSID_MSProject,         0x00030027, 0, 0, "MSProject");

// Microsoft Works Chart
DEFINE_OLE1GUID(CLSID_MSWorksChart,      0x00030028, 0, 0, "MSWorksChart");

// Microsoft Works Spreadsheet
DEFINE_OLE1GUID(CLSID_MSWorksSpreadsheet,0x00030029, 0, 0, "MSWorksSpreadsheet");

// AFX apps - Dean McCrory
DEFINE_OLE1GUID(CLSID_MinSvr,            0x0003002A, 0, 0, "MinSvr");
DEFINE_OLE1GUID(CLSID_HierarchyList,     0x0003002B, 0, 0, "HierarchyList");
DEFINE_OLE1GUID(CLSID_BibRef,            0x0003002C, 0, 0, "BibRef");
DEFINE_OLE1GUID(CLSID_MinSvrMI,          0x0003002D, 0, 0, "MinSvrMI");
DEFINE_OLE1GUID(CLSID_TestServ,          0x0003002E, 0, 0, "TestServ");

// Ami Pro
DEFINE_OLE1GUID(CLSID_AmiProDocument,    0x0003002F, 0, 0, "AmiProDocument");

// WordPerfect Presentations For Windows
DEFINE_OLE1GUID(CLSID_WPGraphics,       0x00030030, 0, 0, "WPGraphics");
DEFINE_OLE1GUID(CLSID_WPCharts,         0x00030031, 0, 0, "WPCharts");


// MicroGrafx Charisma
DEFINE_OLE1GUID(CLSID_Charisma,         0x00030032, 0, 0, "Charisma");
DEFINE_OLE1GUID(CLSID_Charisma_30,      0x00030033, 0, 0, "Charisma_30");
DEFINE_OLE1GUID(CLSID_CharPres_30,      0x00030034, 0, 0, "CharPres_30");

// MicroGrafx Draw
DEFINE_OLE1GUID(CLSID_Draw,             0x00030035, 0, 0, "Draw");

// MicroGrafx Designer
DEFINE_OLE1GUID(CLSID_Designer_40,      0x00030036, 0, 0, "Designer_40");


#undef DEFINE_OLE1GUID

/* as we discover OLE 1 servers we will add them to the end of this list;
   there is room for 64K of them!
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\thc\thc\type.c ===
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <malloc.h>

#include "main.h"
#include "type.h"

char *TypeKindNames[] =
{
    "basic type",
    "typedef",
    "qualifier",
    "pointer",
    "array",
    "struct",
    "union",
    "class",
    "enum",
    "function"
};

Type *types;

void *PanicMalloc(size_t bytes)
{
    void *p;

    p = (void *)malloc(bytes);
    if (p == NULL)
    {
        printf("Out of memory\n");
        exit(1);
    }
    return p;
}

static char *base_types[] =
{
    "void", "char", "short", "int", "long", "float", "double"
};
#define BASE_TYPES (sizeof(base_types)/sizeof(base_types[0]))

static char *extended_types[] =
{
    "HANDLE", "HICON", "HWND", "HMENU", "HINSTANCE", "HGLOBAL",
    "HDC", "HACCEL", "HRESULT", "WPARAM", "LPARAM", "WCHAR",
    "REFIID", "REFGUID", "REFCLSID", "HOLEMENU", "SNB", "HTASK"
};
#define EXTENDED_TYPES (sizeof(extended_types)/sizeof(extended_types[0]))

void InitTypes(void)
{
    int i;

    for (i = 0; i < BASE_TYPES; i++)
        AddType(NewBaseType(base_types[i]));

    /* New types for the thops interpreter */
    for (i = 0; i < EXTENDED_TYPES; i++)
        AddType(NewBaseType(extended_types[i]));
}

void UninitTypes(void)
{
    while (types)
    {
        FreeType(types);
    }
}

void AddType(Type *t)
{
    t->next = types;
    t->prev = NULL;
    if (t->next)
        t->next->prev = t;
    types = t;
}

void UnlinkType(Type *t)
{
    if (t->prev != NULL)
        t->prev->next = t->next;
    else
        types = t->next;
    if (t->next != NULL)
        t->next->prev = t->prev;
}

Type *NewType(char *name, Type *base, int flags, int kind)
{
    Type *t;

    t = (Type *)PanicMalloc(sizeof(Type));
    t->name = name;
    t->base = base;
    ReferenceType(t->base);
    t->flags = flags;
    t->kind = kind;
    t->ref = 1;
    return t;
}

Type *NewBaseType(char *name)
{
    return NewType(name, NULL, TYF_NONE, TYK_BASE);
}
   
Type *NewQualifiedType(char *name, int flags, Type *base)
{
    return NewType(name, base, flags, TYK_QUALIFIER);
}

Type *NewTypedefType(char *name, Type *base)
{
    return NewType(name, base, TYF_NONE, TYK_TYPEDEF);
}

Type *NewPointerType(char *name, Type *base)
{
    return NewType(name, base, TYF_NONE, TYK_POINTER);
}

Type *NewArrayType(char *name, int len, Type *base)
{
    Type *t;

    t = NewType(name, base, TYF_NONE, TYK_ARRAY);
    t->u.array.len = len;
    return t;
}

Type *NewStructType(char *name, Member *members)
{
    Type *t;

    t = NewType(name, NULL, TYF_NONE, TYK_STRUCT);
    t->u.agg.members = members;
    return t;
}

Type *NewUnionType(char *name, Member *members)
{
    Type *t;

    t = NewType(name, NULL, TYF_NONE, TYK_UNION);
    t->u.agg.members = members;
    return t;
}

Type *NewClassType(char *name, Member *members)
{
    Type *t;

    t = NewType(name, NULL, TYF_NONE, TYK_CLASS);
    t->u.agg.members = members;
    return t;
}

Type *NewAggregateType(char *name, Member *members, int kind)
{
    Type *t;

    t = NewType(name, NULL, TYF_NONE, kind);
    t->u.agg.members = members;
    return t;
}

Type *NewEnumType(char *name)
{
    return NewType(name, NULL, TYF_NONE, TYK_ENUM);
}

Type *NewFunctionType(char *name)
{
    return NewType(name, NULL, TYF_NONE, TYK_FUNCTION);
}

void FreeType(Type *t)
{
    if (t->name)
        free(t->name);
    DereferenceType(t->base);

    switch(t->kind)
    {
    case TYK_STRUCT:
    case TYK_UNION:
    case TYK_CLASS:
        FreeMemberList(t->u.agg.members);
        break;
    }
    
    UnlinkType(t);

    free(t);
}

void ReferenceType(Type *t)
{
    if (t)
    {
        t->ref++;
    }
}

void DereferenceType(Type *t)
{
    if (t)
    {
        t->ref--;
        if (t->ref == 0)
            FreeType(t);
    }
}

Type *FindType(char *name)
{
    Type *t;

    for (t = types; t; t = t->next)
    {
        if (!strcmp(t->name, name))
            return t;
    }
    return NULL;
}

Type *FindTypeErr(char *name)
{
    Type *t;

    t = FindType(name);
    if (t == NULL)
        LexError("Unknown type: '%s'", name);
    return t;
}

Type *ApplyQualifiers(Type *qual, Type *base)
{
    Type *t;

    if (qual == NULL)
        return base;
    if (base == NULL)
        return qual;
    
    t = qual;
    while (t->base != NULL)
    {
        t = t->base;
    }
    t->base = base;
    ReferenceType(base);
    return qual;
}

Member *NewMember(char *name, Type *t)
{
    Member *m;

    m = (Member *)PanicMalloc(sizeof(Member));
    m->name = name;
    m->type = t;
    m->next = NULL;
    return m;
}

Member *AppendMember(Member *list, Member *m)
{
    Member *t;
    
    if (list == NULL)
        return m;

    t = list;
    while (t->next)
    {
        t = t->next;
    }

    t->next = m;
    return list;
}

Member *ApplyMemberType(Member *list, Type *t)
{
    Member *m;
    
    for (m = list; m; m = m->next)
        if (m->type)
            m->type = ApplyQualifiers(m->type, t);
        else
            m->type = t;
    return list;
}

void FreeMember(Member *m)
{
    free(m->name);
    free(m);
}

void FreeMemberList(Member *list)
{
    Member *m;

    while (list)
    {
        m = list->next;
        FreeMember(list);
        list = m;
    }
}

void Typedef(Member *td_names, Type *decl)
{
    Member *m, *t;


    m = ApplyMemberType(td_names, decl);
    while (m)
    {
        t = m->next;
        if (FindType(m->name))
        {
            int i;

            for (i = 0; i < EXTENDED_TYPES; i++)
                if (!strcmp(m->name, extended_types[i]))
                    break;
#ifdef REDEF_ERROR
            if (i == EXTENDED_TYPES)
                LexError("'%s' redefinition ignored", m->name);
#endif
            FreeMember(m);
        }
        else
        {
            AddType(NewTypedefType(m->name, m->type));
            /* Can't use FreeMember since we want to keep the name */
            free(m);
        }
        m = t;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\thc\thpp\dvobj.h ===
/*****************************************************************************\
*                                                                             *
* dvobj.h -		Data/View object definitions								  *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/

#if !defined( _DVOBJ_H_ )
#define _DVOBJ_H_

/****** DV value types ******************************************************/

//      forward type declarations
#if defined(__cplusplus)
interface IStorage;
interface IStream;
interface IAdviseSink;
interface IMoniker;
#else 
typedef interface IStorage IStorage;
typedef interface IStream IStream;
typedef interface IAdviseSink IAdviseSink;
typedef interface IMoniker IMoniker;
#endif

typedef            IStorage FAR* LPSTORAGE;
typedef             IStream FAR* LPSTREAM;
typedef         IAdviseSink FAR* LPADVISESINK;
typedef             IMoniker FAR* LPMONIKER;


#if !defined(_MAC)
typedef WORD CLIPFORMAT;
#else
typedef unsigned long CLIPFORMAT;            // ResType
#endif
typedef  CLIPFORMAT FAR* LPCLIPFORMAT;


// Data/View aspect; specifies the desired aspect of the object when 
// drawing or getting data.
typedef enum tagDVASPECT
{
    DVASPECT_CONTENT = 1,
    DVASPECT_THUMBNAIL = 2,
    DVASPECT_ICON = 4,
    DVASPECT_DOCPRINT = 8
} DVASPECT;


// Data/View target device; determines the device for drawing or gettting data
typedef struct FARSTRUCT tagDVTARGETDEVICE
{
    DWORD tdSize;
    WORD tdDriverNameOffset;
    WORD tdDeviceNameOffset;
    WORD tdPortNameOffset;
    WORD tdExtDevmodeOffset;
    BYTE tdData[1];
} DVTARGETDEVICE;


// Format, etc.; completely specifices the kind of data desired, including tymed
typedef struct FARSTRUCT tagFORMATETC
{
    CLIPFORMAT          cfFormat;
    DVTARGETDEVICE FAR* ptd;
    DWORD               dwAspect;
    LONG                lindex;
    DWORD               tymed;
} FORMATETC, FAR* LPFORMATETC;


// TYpes of storage MEDiums; determines how data is stored or passed around
typedef enum tagTYMED
{
    TYMED_HGLOBAL = 1,
    TYMED_FILE = 2,
    TYMED_ISTREAM = 4,
    TYMED_ISTORAGE = 8,
    TYMED_GDI = 16,
    TYMED_MFPICT = 32,
    TYMED_NULL = 0
} TYMED;


// DATA format DIRection
typedef enum tagDATADIR
{
    DATADIR_GET = 1,
    DATADIR_SET = 2,
} DATADIR;


// SToraGe MEDIUM; a block of data on a particular medium 
typedef struct FARSTRUCT tagSTGMEDIUM
{
    DWORD   tymed;
    union
    {
        HANDLE  hGlobal;
        LPSTR   lpszFileName;
        IStream FAR* pstm;
        IStorage FAR* pstg;
    }
#ifdef NONAMELESSUNION
    u       // add a tag when name less unions not supported
#endif
    ;
    IUnknown FAR* pUnkForRelease;
} STGMEDIUM, FAR* LPSTGMEDIUM;


// Advise Flags
typedef enum tagADVF
{
    ADVF_NODATA = 1,
    ADVF_PRIMEFIRST = 2,
    ADVF_ONLYONCE = 4,
    ADVF_DATAONSTOP = 64,
    ADVFCACHE_NOHANDLER = 8,
    ADVFCACHE_FORCEBUILTIN = 16,
    ADVFCACHE_ONSAVE = 32
} ADVF;


// Stats for data; used by several enumerations and by at least one 
// implementation of IDataAdviseHolder; if a field is not used, it
// will be NULL.
typedef struct FARSTRUCT tagSTATDATA
{                                   // field used by:
    FORMATETC formatetc;            // EnumAdvise, EnumData (cache), EnumFormats
    DWORD advf;                     // EnumAdvise, EnumData (cache)
    IAdviseSink FAR* pAdvSink;      // EnumAdvise
    DWORD dwConnection;             // EnumAdvise
} STATDATA;
    
typedef  STATDATA FAR* LPSTATDATA;



/****** DV Interfaces ***************************************************/


#undef  INTERFACE
#define INTERFACE   IEnumFORMATETC

DECLARE_INTERFACE_(IEnumFORMATETC, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IEnumFORMATETC methods ***
    STDMETHOD(Next) (THIS_ ULONG celt, FORMATETC __out FAR * rgelt, ULONG FAR* pceltFetched) PURE;
    STDMETHOD(Skip) (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset) (THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumFORMATETC FAR* FAR* ppenum) PURE;
};
typedef        IEnumFORMATETC FAR* LPENUMFORMATETC;


#undef  INTERFACE
#define INTERFACE   IEnumSTATDATA

DECLARE_INTERFACE_(IEnumSTATDATA, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** IEnumSTATDATA methods ***
    STDMETHOD(Next) (THIS_ ULONG celt, STATDATA FAR * rgelt, ULONG FAR* pceltFetched) PURE;
    STDMETHOD(Skip) (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset) (THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumSTATDATA FAR* FAR* ppenum) PURE;
};
typedef        IEnumSTATDATA FAR* LPENUMSTATDATA;



#undef  INTERFACE
#define INTERFACE   IDataObject

#define DATA_E_FORMATETC        DV_E_FORMATETC
#define DATA_S_SAMEFORMATETC    (DATA_S_FIRST + 0)

DECLARE_INTERFACE_(IDataObject, IUnknown)
{ 
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** IDataObject methods ***
    STDMETHOD(GetData) (THIS_ __in LPFORMATETC pformatetcIn,
                            __out LPSTGMEDIUM pmedium ) PURE;
    STDMETHOD(GetDataHere) (THIS_ __in LPFORMATETC pformatetc,
                            __in LPSTGMEDIUM pmedium ) PURE;
    STDMETHOD(QueryGetData) (THIS_ __in LPFORMATETC pformatetc ) PURE;
    STDMETHOD(GetCanonicalFormatEtc) (THIS_ __in LPFORMATETC pformatetc,
                            __out LPFORMATETC pformatetcOut) PURE;
    STDMETHOD(SetData) (THIS_ __in LPFORMATETC pformatetc, STGMEDIUM __in FAR * pmedium,
                            BOOL fRelease) PURE;
    STDMETHOD(EnumFormatEtc) (THIS_ DWORD dwDirection,
                            LPENUMFORMATETC FAR* ppenumFormatEtc) PURE;

    STDMETHOD(DAdvise) (THIS_ FORMATETC __in FAR* pFormatetc, DWORD advf, 
                    LPADVISESINK pAdvSink, DWORD FAR* pdwConnection) PURE;
    STDMETHOD(DUnadvise) (THIS_ DWORD dwConnection) PURE;
    STDMETHOD(EnumDAdvise) (THIS_ LPENUMSTATDATA FAR* ppenumAdvise) PURE;
};                 
typedef      IDataObject FAR* LPDATAOBJECT;



#undef  INTERFACE
#define INTERFACE   IViewObject

#define VIEW_E_DRAW             (VIEW_E_FIRST)
#define E_DRAW                  VIEW_E_DRAW

#define VIEW_S_ALREADY_FROZEN   (VIEW_S_FIRST)

DECLARE_INTERFACE_(IViewObject, IUnknown)
{ 
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IViewObject methods ***
    STDMETHOD(Draw) (THIS_ DWORD dwDrawAspect, LONG lindex,
                    void FAR* pvAspect, DVTARGETDEVICE FAR * ptd,
                    HDC hicTargetDev,
                    HDC hdcDraw, 
                    __in LPCRECTL lprcBounds, 
                    __in LPCRECTL lprcWBounds,
                    BOOL (CALLBACK * pfnContinue) (DWORD), 
                    DWORD dwContinue) PURE;

    STDMETHOD(GetColorSet) (THIS_ DWORD dwDrawAspect, LONG lindex,
                    void FAR* pvAspect, DVTARGETDEVICE FAR * ptd,
                    HDC hicTargetDev,
                    LPLOGPALETTE FAR* ppColorSet) PURE;

    STDMETHOD(Freeze)(THIS_ DWORD dwDrawAspect, LONG lindex, 
                    void FAR* pvAspect,
                    DWORD FAR* pdwFreeze) PURE;
    STDMETHOD(Unfreeze) (THIS_ DWORD dwFreeze) PURE;
    STDMETHOD(SetAdvise) (THIS_ DWORD aspects, DWORD advf, 
                    LPADVISESINK pAdvSink) PURE;
    STDMETHOD(GetAdvise) (THIS_ DWORD FAR* pAspects, DWORD FAR* pAdvf, 
                    LPADVISESINK FAR* ppAdvSink) PURE;
};
typedef      IViewObject FAR* LPVIEWOBJECT;


#undef  INTERFACE
#define INTERFACE   IViewObject2

DECLARE_INTERFACE_(IViewObject2, IViewObject)
{ 
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IViewObject methods ***
    STDMETHOD(Draw) (THIS_ DWORD dwDrawAspect, LONG lindex,
                    void FAR* pvAspect, DVTARGETDEVICE FAR * ptd,
                    HDC hicTargetDev,
                    HDC hdcDraw, 
                    __in LPCRECTL lprcBounds, 
                    __in LPCRECTL lprcWBounds,
                    BOOL (CALLBACK * pfnContinue) (DWORD), 
                    DWORD dwContinue) PURE;

    STDMETHOD(GetColorSet) (THIS_ DWORD dwDrawAspect, LONG lindex,
                    void FAR* pvAspect, DVTARGETDEVICE FAR * ptd,
                    HDC hicTargetDev,
                    LPLOGPALETTE FAR* ppColorSet) PURE;

    STDMETHOD(Freeze)(THIS_ DWORD dwDrawAspect, LONG lindex, 
                    void FAR* pvAspect,
                    DWORD FAR* pdwFreeze) PURE;
    STDMETHOD(Unfreeze) (THIS_ DWORD dwFreeze) PURE;
    STDMETHOD(SetAdvise) (THIS_ DWORD aspects, DWORD advf, 
                    LPADVISESINK pAdvSink) PURE;
    STDMETHOD(GetAdvise) (THIS_ DWORD FAR* pAspects, DWORD FAR* pAdvf, 
                    LPADVISESINK FAR* ppAdvSink) PURE;
					
    // *** IViewObject2 methods ***
    STDMETHOD(GetExtent) (THIS_ DWORD dwDrawAspect, LONG lindex,
                    DVTARGETDEVICE FAR * ptd, __out LPSIZEL lpsizel) PURE;
					
};
typedef      IViewObject2 FAR* LPVIEWOBJECT2;


#undef  INTERFACE
#define INTERFACE   IAdviseSink

DECLARE_INTERFACE_(IAdviseSink, IUnknown)
{ 
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IAdviseSink methods ***
    STDMETHOD_(void,OnDataChange)(THIS_ FORMATETC FAR __in * pFormatetc, 
                            STGMEDIUM FAR __in * pStgmed) PURE;
    STDMETHOD_(void,OnViewChange)(THIS_ DWORD dwAspect, LONG lindex) PURE;
    STDMETHOD_(void,OnRename)(THIS_ LPMONIKER pmk) PURE;
    STDMETHOD_(void,OnSave)(THIS) PURE;
    STDMETHOD_(void,OnClose)(THIS) PURE;
};
typedef      IAdviseSink FAR* LPADVISESINK;



#undef  INTERFACE
#define INTERFACE   IAdviseSink2

DECLARE_INTERFACE_(IAdviseSink2, IAdviseSink)
{ 
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IAdviseSink methods ***
    STDMETHOD_(void,OnDataChange)(THIS_ FORMATETC FAR __in * pFormatetc, 
                            STGMEDIUM FAR __in * pStgmed) PURE;
    STDMETHOD_(void,OnViewChange)(THIS_ DWORD dwAspect, LONG lindex) PURE;
    STDMETHOD_(void,OnRename)(THIS_ LPMONIKER pmk) PURE;
    STDMETHOD_(void,OnSave)(THIS) PURE;
    STDMETHOD_(void,OnClose)(THIS) PURE;

    // *** IAdviseSink2 methods ***
    STDMETHOD_(void,OnLinkSrcChange)(THIS_ LPMONIKER pmk) PURE;
};
typedef      IAdviseSink2 FAR* LPADVISESINK2;



#undef  INTERFACE
#define INTERFACE   IDataAdviseHolder

DECLARE_INTERFACE_(IDataAdviseHolder, IUnknown)
{ 
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IDataAdviseHolder methods ***
    STDMETHOD(Advise)(THIS_ LPDATAOBJECT pDataObject, FORMATETC FAR __in * pFetc, 
            DWORD advf, LPADVISESINK pAdvise, DWORD FAR* pdwConnection) PURE;
    STDMETHOD(Unadvise)(THIS_ DWORD dwConnection) PURE;
    STDMETHOD(EnumAdvise)(THIS_ LPENUMSTATDATA FAR* ppenumAdvise) PURE;

    STDMETHOD(SendOnDataChange)(THIS_ LPDATAOBJECT pDataObject, DWORD dwReserved, DWORD advf) PURE;
};
typedef      IDataAdviseHolder FAR* LPDATAADVISEHOLDER;



#undef  INTERFACE
#define INTERFACE   IOleCache

#define CACHE_E_NOCACHE_UPDATED         (CACHE_E_FIRST)

#define CACHE_S_FORMATETC_NOTSUPPORTED  (CACHE_S_FIRST)
#define CACHE_S_SAMECACHE               (CACHE_S_FIRST+1)
#define CACHE_S_SOMECACHES_NOTUPDATED   (CACHE_S_FIRST+2)


DECLARE_INTERFACE_(IOleCache, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleCache methods ***
    STDMETHOD(Cache) (THIS_  __in LPFORMATETC lpFormatetc, DWORD advf, LPDWORD lpdwConnection) PURE;
    STDMETHOD(Uncache) (THIS_ DWORD dwConnection) PURE;
    STDMETHOD(EnumCache) (THIS_ LPENUMSTATDATA FAR* ppenumStatData) PURE;
    STDMETHOD(InitCache) (THIS_ LPDATAOBJECT pDataObject) PURE;
    STDMETHOD(SetData) (THIS_  __in LPFORMATETC pformatetc, STGMEDIUM FAR  __in * pmedium,
                            BOOL fRelease) PURE;
};
typedef         IOleCache FAR* LPOLECACHE;



// Cache update Flags

#define	UPDFCACHE_NODATACACHE			0x00000001
#define UPDFCACHE_ONSAVECACHE			0x00000002
#define	UPDFCACHE_ONSTOPCACHE			0x00000004
#define	UPDFCACHE_NORMALCACHE			0x00000008
#define	UPDFCACHE_IFBLANK				0x00000010
#define UPDFCACHE_ONLYIFBLANK			0x80000000

#define UPDFCACHE_IFBLANKORONSAVECACHE	(UPDFCACHE_IFBLANK | UPDFCACHE_ONSAVECACHE )
#define UPDFCACHE_ALL					(~UPDFCACHE_ONLYIFBLANK)
#define UPDFCACHE_ALLBUTNODATACACHE		(UPDFCACHE_ALL & ~UPDFCACHE_NODATACACHE)


// IOleCache2::DiscardCache options
typedef enum tagDISCARDCACHE
{
	DISCARDCACHE_SAVEIFDIRTY =	0,	// Save all dirty cache before discarding
	DISCARDCACHE_NOSAVE		 =	1	// Don't save dirty caches before 
									// discarding
} DISCARDCACHE;


#undef  INTERFACE
#define INTERFACE   IOleCache2

DECLARE_INTERFACE_(IOleCache2, IOleCache)
{ 
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** IOleCache methods ***
    STDMETHOD(Cache) (THIS_  __in LPFORMATETC lpFormatetc, DWORD advf, LPDWORD lpdwConnection) PURE;
    STDMETHOD(Uncache) (THIS_ DWORD dwConnection) PURE;
    STDMETHOD(EnumCache) (THIS_ LPENUMSTATDATA FAR* ppenumStatData) PURE;
    STDMETHOD(InitCache) (THIS_ LPDATAOBJECT pDataObject) PURE;
    STDMETHOD(SetData) (THIS_  __in LPFORMATETC pformatetc, STGMEDIUM FAR  __in * pmedium,
                            BOOL fRelease) PURE;

    // *** IOleCache2 methods ***							
    STDMETHOD(UpdateCache) (THIS_ LPDATAOBJECT pDataObject, DWORD grfUpdf, 
							LPVOID pReserved) PURE;
    STDMETHOD(DiscardCache) (THIS_ DWORD dwDiscardOptions) PURE;
						
};
typedef      IOleCache2 FAR* LPOLECACHE2;


#undef  INTERFACE
#define INTERFACE   IOleCacheControl

DECLARE_INTERFACE_(IOleCacheControl, IUnknown)
{ 
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // *** IDataObject methods ***
    STDMETHOD(OnRun) (THIS_ LPDATAOBJECT pDataObject) PURE;
    STDMETHOD(OnStop) (THIS) PURE;
};                 
typedef      IOleCacheControl FAR* LPOLECACHECONTROL;



/****** DV APIs ***********************************************************/


STDAPI CreateDataAdviseHolder(LPDATAADVISEHOLDER FAR* ppDAHolder);

STDAPI CreateDataCache(LPUNKNOWN pUnkOuter, REFCLSID rclsid,
					REFIID iid, LPVOID FAR* ppv);
					
#endif // _DVOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\thc\thpp\ole2dbg.h ===
/*
	ole2dbg.h:	This header file contains the function declarations for the publicly
	exported debugging interfaces.

	Include *after* standard OLE2 includes.
	
	Copyright (c) 1992-1993, Microsoft Corp. All rights reserved.
*/

#ifndef __OLE2DBG_H
#define __OLE2DBG_H

STDAPI_(void) DbgDumpObject( IUnknown FAR * pUnk, DWORD dwReserved);
STDAPI_(void) DbgDumpExternalObject( IUnknown FAR * pUnk, DWORD dwReserved );

STDAPI_(BOOL) DbgIsObjectValid( IUnknown FAR * pUnk );
STDAPI_(void) DbgDumpClassName( IUnknown FAR * pUnk );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\thc\thpp\config.h ===
/* Additional base types which the THOPS interpreter understands:
   HANDLE
   HWND
   HMENU
   HINSTANCE
   HICON
   HGLOBAL
   HDC
   HACCEL
   HOLEMENU
   HTASK
   HRESULT
   WPARAM
   LPARAM
   WCHAR
   SNB
   */

/* Always compile for Win16 */
#undef WIN32

#define WINAPI
#define FAR
#define CDECL
#define CALLBACK
#define NONAMELESSUNION
#define INITGUID
#define _INC_STRING
#define PASCAL __pascal

#define DECLARE_HANDLE(type)

typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef unsigned long DWORD;
typedef void *LPVOID;
typedef int BOOL;
typedef DWORD *LPDWORD;
typedef WCHAR *LPWSTR;
typedef WCHAR const *LPCWSTR;
typedef void VOID;
typedef unsigned int UINT;
typedef long LONG;
typedef WORD *LPWORD;
typedef char *LPSTR;
typedef char const *LPCSTR;

/* This isn't called point to ensure that there are no legal uses of
   POINT in the headers */
typedef struct _INT_POINT
{
    int x;
    int y;
} INT_POINT;

typedef struct tagRECT
{
    int top;
    int left;
    int right;
    int bottom;
} RECT, *LPRECT;

typedef struct tagSIZE
{
    int x;
    int y;
} SIZE, *LPSIZE;

typedef struct tagMSG
{
    HWND        hwnd;
    UINT        message;
    WPARAM      wParam;
    LPARAM      lParam;
    DWORD       time;
    INT_POINT   pt;
} MSG, *LPMSG;

typedef struct tagPALETTEENTRY
{
    BYTE        peRed;
    BYTE        peGreen;
    BYTE        peBlue;
    BYTE        peFlags;
} PALETTEENTRY, *LPPALETTEENTRY;

typedef struct tagLOGPALETTE
{
    WORD        palVersion;
    WORD        palNumEntries;
    PALETTEENTRY        palPalEntry[1];
} LOGPALETTE, *LPLOGPALETTE;

/* To compile with this you must first delete this section from
   compobj.h */
#define interface class
#define STDMETHOD(method)       virtual HRESULT STDMETHODCALLTYPE method
#define STDMETHOD_(type,method) virtual type STDMETHODCALLTYPE method
#define PURE                    = 0
#define THIS_
#define THIS                    void
#define DECLARE_INTERFACE(iface)    interface iface
#define DECLARE_INTERFACE_(iface, baseiface)    interface iface : public baseiface

/* You must also delete the section defining REF* */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\thc\thpp\compobj.h ===
/*****************************************************************************\
*                                                                             *
* compobj.h - 	Component object model definitions							  *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/


#if !defined( _COMPOBJ_H_ )
#define _COMPOBJ_H_

/****** Linkage Definitions *************************************************/

/*
 *      These are macros for declaring methods/functions.  They exist so that
 *      control over the use of keywords (CDECL, PASCAL, __export,
 *      extern "C") resides in one place, and because this is the least
 *      intrusive way of writing function declarations that do not have
 *      to be modified in order to port to the Mac.
 *
 *      The macros without the trailing underscore are for functions/methods
 *      which a return value of type HRESULT; this is by far the most common
 *      case in OLE. The macros with a trailing underscore take a return
 *      type as a parameter.
 *
 * WARNING: STDAPI is hard coded into the LPFNGETCLASSOBJECT typedef below.
 */

#ifdef __cplusplus
    #define EXTERN_C    extern "C"
#else
    #define EXTERN_C    extern
#endif

#ifdef _MAC
#define STDMETHODCALLTYPE
#define STDAPICALLTYPE          pascal

#define STDAPI                  EXTERN_C STDAPICALLTYPE HRESULT
#define STDAPI_(type)           EXTERN_C STDAPICALLTYPE type

#else   //  !_MAC

#ifdef WIN32
#define STDMETHODCALLTYPE       __export __cdecl
#define STDAPICALLTYPE          __export __stdcall

#define STDAPI                  EXTERN_C HRESULT STDAPICALLTYPE
#define STDAPI_(type)           EXTERN_C type STDAPICALLTYPE

#else
#define STDMETHODCALLTYPE       __export FAR CDECL
#define STDAPICALLTYPE          __export FAR PASCAL

#define STDAPI                  EXTERN_C HRESULT STDAPICALLTYPE
#define STDAPI_(type)           EXTERN_C type STDAPICALLTYPE

#endif

#endif //!_MAC

#define STDMETHODIMP            HRESULT STDMETHODCALLTYPE
#define STDMETHODIMP_(type)     type STDMETHODCALLTYPE


/****** Interface Declaration ***********************************************/

/*
 *      These are macros for declaring interfaces.  They exist so that
 *      a single definition of the interface is simulataneously a proper
 *      declaration of the interface structures (C++ abstract classes)
 *      for both C and C++.
 *
 *      DECLARE_INTERFACE(iface) is used to declare an interface that does
 *      not derive from a base interface.
 *      DECLARE_INTERFACE_(iface, baseiface) is used to declare an interface
 *      that does derive from a base interface.
 *
 *      By default if the source file has a .c extension the C version of
 *      the interface declaratations will be expanded; if it has a .cpp
 *      extension the C++ version will be expanded. if you want to force
 *      the C version expansion even though the source file has a .cpp
 *      extension, then define the macro "CINTERFACE".
 *      eg.     cl -DCINTERFACE file.cpp
 *
 *      Example Interface declaration:
 *
 *          #undef  INTERFACE
 *          #define INTERFACE   IClassFactory
 *
 *          DECLARE_INTERFACE_(IClassFactory, IUnknown)
 *          {
 *              // *** IUnknown methods ***
 *              STDMETHOD(QueryInterface) (THIS_
 *                                        REFIID riid,
 *                                        LPVOID FAR* ppvObj) PURE;
 *              STDMETHOD_(ULONG,AddRef) (THIS) PURE;
 *              STDMETHOD_(ULONG,Release) (THIS) PURE;
 *
 *              // *** IClassFactory methods ***
 *              STDMETHOD(CreateInstance) (THIS_
 *                                        LPUNKNOWN pUnkOuter,
 *                                        REFIID riid,
 *                                        LPVOID FAR* ppvObject) PURE;
 *          };
 *
 *      Example C++ expansion:
 *
 *          struct FAR IClassFactory : public IUnknown
 *          {
 *              virtual HRESULT STDMETHODCALLTYPE QueryInterface(
 *                                                  IID FAR& riid,
 *                                                  LPVOID FAR* ppvObj) = 0;
 *              virtual HRESULT STDMETHODCALLTYPE AddRef(void) = 0;
 *              virtual HRESULT STDMETHODCALLTYPE Release(void) = 0;
 *              virtual HRESULT STDMETHODCALLTYPE CreateInstance(
 *                                              LPUNKNOWN pUnkOuter,
 *                                              IID FAR& riid,
 *                                              LPVOID FAR* ppvObject) = 0;
 *          };
 *
 *          NOTE: Our documentation says '#define interface class' but we use
 *          'struct' instead of 'class' to keep a lot of 'public:' lines
 *          out of the interfaces.  The 'FAR' forces the 'this' pointers to
 *          be far, which is what we need.
 *
 *      Example C expansion:
 *
 *          typedef struct IClassFactory
 *          {
 *              const struct IClassFactoryVtbl FAR* lpVtbl;
 *          } IClassFactory;
 *
 *          typedef struct IClassFactoryVtbl IClassFactoryVtbl;
 *
 *          struct IClassFactoryVtbl
 *          {
 *              HRESULT (STDMETHODCALLTYPE * QueryInterface) (
 *                                                  IClassFactory FAR* This,
 *                                                  IID FAR* riid,
 *                                                  LPVOID FAR* ppvObj) ;
 *              HRESULT (STDMETHODCALLTYPE * AddRef) (IClassFactory FAR* This) ;
 *              HRESULT (STDMETHODCALLTYPE * Release) (IClassFactory FAR* This) ;
 *              HRESULT (STDMETHODCALLTYPE * CreateInstance) (
 *                                                  IClassFactory FAR* This,
 *                                                  LPUNKNOWN pUnkOuter,
 *                                                  IID FAR* riid,
 *                                                  LPVOID FAR* ppvObject);
 *              HRESULT (STDMETHODCALLTYPE * LockServer) (
 *                                                  IClassFactory FAR* This,
 *                                                  BOOL fLock);
 *          };
 */




/****** Additional basic types **********************************************/


#ifndef FARSTRUCT
#ifdef __cplusplus
#define FARSTRUCT   FAR
#else
#define FARSTRUCT   
#endif  // __cplusplus
#endif  // FARSTRUCT


#ifndef WINAPI          /* If not included with 3.1 headers... */

#ifdef WIN32
#define FAR
#define PASCAL          __stdcall
#define CDECL
#else
#define FAR             _far
#define PASCAL          _pascal
#define CDECL           _cdecl
#endif

#define VOID            void
#define WINAPI      FAR PASCAL
#define CALLBACK    FAR PASCAL

#ifndef FALSE
#define FALSE 0
#define TRUE 1
#endif

typedef int BOOL;
typedef unsigned char BYTE;
typedef unsigned short WORD;
typedef unsigned int UINT;

typedef long LONG;
typedef unsigned long DWORD;


typedef UINT WPARAM;
typedef LONG LPARAM;
typedef LONG LRESULT;

typedef unsigned int HANDLE;
#define DECLARE_HANDLE(name)    typedef UINT name

DECLARE_HANDLE(HMODULE);
DECLARE_HANDLE(HINSTANCE);
DECLARE_HANDLE(HLOCAL);
DECLARE_HANDLE(HGLOBAL);
DECLARE_HANDLE(HDC);
DECLARE_HANDLE(HRGN);
DECLARE_HANDLE(HWND);
DECLARE_HANDLE(HMENU);
DECLARE_HANDLE(HACCEL);
DECLARE_HANDLE(HTASK);

#ifndef NULL
#define NULL 0
#endif


typedef void FAR *      LPVOID;
typedef WORD FAR *      LPWORD;
typedef DWORD FAR *     LPDWORD;
typedef char FAR*       LPSTR;
typedef const char FAR* LPCSTR;
typedef void FAR*       LPLOGPALETTE;
typedef void FAR*       LPMSG;
//typedef struct tagMSG FAR *LPMSG;

typedef HANDLE FAR *LPHANDLE;
typedef struct tagRECT FAR *LPRECT;

typedef struct FARSTRUCT tagSIZE
{
    int cx;
    int cy;
} SIZE;
typedef SIZE*       PSIZE;


#endif  /* WINAPI */


typedef short SHORT;
typedef unsigned short USHORT;
typedef DWORD ULONG;


#ifndef HUGEP
#ifdef WIN32
#define HUGEP
#else
#define HUGEP __huge
#endif // WIN32
#endif // HUGEP

typedef WORD WCHAR;

#ifndef WIN32
typedef struct FARSTRUCT _LARGE_INTEGER {
    DWORD LowPart;
    LONG  HighPart;
} LARGE_INTEGER, *PLARGE_INTEGER;
#endif
#define LISet32(li, v) ((li).HighPart = ((LONG)(v)) < 0 ? -1 : 0, (li).LowPart = (v))

#ifndef WIN32
typedef struct FARSTRUCT _ULARGE_INTEGER {
    DWORD LowPart;
    DWORD HighPart;
} ULARGE_INTEGER, *PULARGE_INTEGER;
#endif
#define ULISet32(li, v) ((li).HighPart = 0, (li).LowPart = (v))

#ifndef _WINDOWS_
#ifndef _FILETIME_
#define _FILETIME_
typedef struct FARSTRUCT tagFILETIME
{
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME;
#endif
#endif

#ifdef WIN32
#define HTASK DWORD
#endif

#include "scode.h"



// *********************** Compobj errors **********************************

#define CO_E_NOTINITIALIZED         (CO_E_FIRST + 0x0)
// CoInitialize has not been called and must be

#define CO_E_ALREADYINITIALIZED     (CO_E_FIRST + 0x1)
// CoInitialize has already been called and cannot be called again (temporary)

#define CO_E_CANTDETERMINECLASS     (CO_E_FIRST + 0x2)
// can't determine clsid (e.g., extension not in reg.dat)

#define CO_E_CLASSSTRING            (CO_E_FIRST + 0x3)
// the string form of the clsid is invalid (including ole1 classes)

#define CO_E_IIDSTRING              (CO_E_FIRST + 0x4)
// the string form of the iid is invalid

#define CO_E_APPNOTFOUND            (CO_E_FIRST + 0x5)
// application not found

#define CO_E_APPSINGLEUSE           (CO_E_FIRST + 0x6)
// application cannot be run more than once

#define CO_E_ERRORINAPP             (CO_E_FIRST + 0x7)
// some error in the app program file

#define CO_E_DLLNOTFOUND            (CO_E_FIRST + 0x8)
// dll not found

#define CO_E_ERRORINDLL             (CO_E_FIRST + 0x9)
// some error in the dll file

#define CO_E_WRONGOSFORAPP          (CO_E_FIRST + 0xa)
// app written for other version of OS or other OS altogether

#define CO_E_OBJNOTREG              (CO_E_FIRST + 0xb)
// object is not registered

#define CO_E_OBJISREG               (CO_E_FIRST + 0xc)
// object is already registered

#define CO_E_OBJNOTCONNECTED        (CO_E_FIRST + 0xd)
// handler is not connected to server

#define CO_E_APPDIDNTREG            (CO_E_FIRST + 0xe)
// app was launched, but didn't registered a class factory


// ********************* ClassObject errors ********************************

#define CLASS_E_NOAGGREGATION       (CLASSFACTORY_E_FIRST + 0x0)
// class does not support aggregation (or class object is remote)

#define CLASS_E_CLASSNOTAVAILABLE   (CLASSFACTORY_E_FIRST + 0x1)
// dll doesn't support that class (returned from DllGetClassObject)


// *********************** Reg.dat errors **********************************

#define REGDB_E_READREGDB           (REGDB_E_FIRST + 0x0)
// some error reading the registration database

#define REGDB_E_WRITEREGDB          (REGDB_E_FIRST + 0x1)
// some error reading the registration database

#define REGDB_E_KEYMISSING          (REGDB_E_FIRST + 0x2)
// some error reading the registration database

#define REGDB_E_INVALIDVALUE        (REGDB_E_FIRST + 0x3)
// some error reading the registration database

#define REGDB_E_CLASSNOTREG         (REGDB_E_FIRST + 0x4)
// some error reading the registration database

#define REGDB_E_IIDNOTREG           (REGDB_E_FIRST + 0x5)
// some error reading the registration database


// *************************** RPC errors **********************************

#define RPC_E_FIRST    MAKE_SCODE(SEVERITY_ERROR, FACILITY_RPC,  0x000)

// call was rejected by callee, either by MF::HandleIncomingCall or
#define RPC_E_CALL_REJECTED             (RPC_E_FIRST + 0x1)         

// call was canceld by call - returned by MessagePending
// this code only occurs if MessagePending return cancel
#define RPC_E_CALL_CANCELED             (RPC_E_FIRST + 0x2)         

// the caller is dispatching an intertask SendMessage call and 
// can NOT call out via PostMessage
#define RPC_E_CANTPOST_INSENDCALL       (RPC_E_FIRST + 0x3)             

// the caller is dispatching an asynchronus call can NOT 
// make an outgoing call on behalf of this call
#define RPC_E_CANTCALLOUT_INASYNCCALL   (RPC_E_FIRST + 0x4)         

// the caller is not in a state where an outgoing call can be made
// this is the case if the caller has an outstandig call and
// another incoming call was excepted by HIC; now the caller is
// not allowed to call out again
#define RPC_E_CANTCALLOUT_INEXTERNALCALL (RPC_E_FIRST + 0x5)                

// the connection terminated or is in a bogus state
// and can not be used any more. Other connections
// are still valid.
#define RPC_E_CONNECTION_TERMINATED     (RPC_E_FIRST + 0x6)         

// the callee (server [not server application]) is not available 
// and disappeared; all connections are invalid
#define RPC_E_SERVER_DIED               (RPC_E_FIRST + 0x7)         

// the caller (client ) disappeared while the callee (server) was 
// processing a call 
#define RPC_E_CLIENT_DIED               (RPC_E_FIRST + 0x8)         

// the date paket with the marshalled parameter data is
// incorrect 
#define RPC_E_INVALID_DATAPACKET        (RPC_E_FIRST + 0x9)         

// the call was not transmitted properly; the message queue 
// was full and was not emptied after yielding
#define RPC_E_CANTTRANSMIT_CALL         (RPC_E_FIRST + 0xa)         

// the client (caller) can not marshall the parameter data 
// or unmarshall the return data - low memory etc.
#define RPC_E_CLIENT_CANTMARSHAL_DATA   (RPC_E_FIRST + 0xb)         
#define RPC_E_CLIENT_CANTUNMARSHAL_DATA (RPC_E_FIRST + 0xc)         

// the server (caller) can not unmarshall the parameter data
// or marshall the return data - low memory
#define RPC_E_SERVER_CANTMARSHAL_DATA   (RPC_E_FIRST + 0xd)         
#define RPC_E_SERVER_CANTUNMARSHAL_DATA (RPC_E_FIRST + 0xe)         

// received data are invalid; can be server or 
// client data
#define RPC_E_INVALID_DATA              (RPC_E_FIRST + 0xf)         

// a particular parameter is invalid and can not be un/marshalled
#define RPC_E_INVALID_PARAMETER         (RPC_E_FIRST + 0x10)

// DDE conversation - no second outgoing call on same channel
#define RPC_E_CANTCALLOUT_AGAIN			(RPC_E_FIRST + 0x11)         

// a internal error occured 
#define RPC_E_UNEXPECTED                (RPC_E_FIRST + 0xFFFF)


/****** Globally Unique Ids *************************************************/
 
#ifdef __cplusplus

struct FAR GUID
{
    DWORD Data1;
    WORD  Data2;
    WORD  Data3;
    BYTE  Data4[8];

    BOOL operator==(const GUID& iidOther) const

#ifdef WIN32
        { return !memcmp(&Data1,&iidOther.Data1,sizeof(GUID)); }
#else        
        { return !_fmemcmp(&Data1,&iidOther.Data1,sizeof(GUID)); }
#endif
    BOOL operator!=(const GUID& iidOther) const
        { return !((*this) == iidOther); }
};

#else
typedef struct GUID
{
    DWORD Data1;
    WORD  Data2;
    WORD  Data3;
    BYTE  Data4[8];
} GUID;
#endif

typedef                GUID FAR* LPGUID;


// macros to define byte pattern for a GUID.  
//      Example: DEFINE_GUID(GUID_XXX, a, b, c, ...);
//
// Each dll/exe must initialize the GUIDs once.  This is done in one of
// two ways.  If you are not using precompiled headers for the file(s) which
// initializes the GUIDs, define INITGUID before including compobj.h.  This
// is how OLE builds the initialized versions of the GUIDs which are included
// in compobj.dll.
//
// The alternative (which some versions of the compiler don't handle properly;
// they wind up with the initialized GUIDs in a data, not a text segment),
// is to use a precompiled version of compobj.h and then include initguid.h 
// after compobj.h followed by one or more of the guid defintion files.


#define DEFINE_GUID(name, l, w1, w2, b1, b2, b3, b4, b5, b6, b7, b8) \
    EXTERN_C const GUID CDECL FAR name

#ifdef INITGUID
#include "initguid.h"
#endif

#define DEFINE_OLEGUID(name, l, w1, w2) \
    DEFINE_GUID(name, l, w1, w2, 0xC0,0,0,0,0,0,0,0x46)


// Interface ID are just a kind of GUID
typedef GUID IID;
typedef                IID FAR* LPIID;
#define IID_NULL            GUID_NULL
#define IsEqualIID(riid1, riid2) IsEqualGUID(riid1, riid2)


// Class ID are just a kind of GUID
typedef GUID CLSID;
typedef              CLSID FAR* LPCLSID;
#define CLSID_NULL          GUID_NULL
#define IsEqualCLSID(rclsid1, rclsid2) IsEqualGUID(rclsid1, rclsid2)



#ifndef INITGUID
#include "coguid.h"
#endif

/****** Other value types ***************************************************/

// memory context values; passed to CoGetMalloc
typedef enum tagMEMCTX
{
    MEMCTX_TASK = 1,            // task (private) memory
    MEMCTX_SHARED = 2,          // shared memory (between processes)
#ifdef _MAC
    MEMCTX_MACSYSTEM = 3,       // on the mac, the system heap
#endif 

    // these are mostly for internal use...
    MEMCTX_UNKNOWN = -1,        // unknown context (when asked about it)
    MEMCTX_SAME = -2,           // same context (as some other pointer)
} MEMCTX;



// class context: used to determine what scope and kind of class object to use
// NOTE: this is a bitwise enum
typedef enum tagCLSCTX
{
    CLSCTX_INPROC_SERVER = 1,   // server dll (runs in same process as caller)
    CLSCTX_INPROC_HANDLER = 2,  // handler dll (runs in same process as caller)
    CLSCTX_LOCAL_SERVER = 4     // server exe (runs on same machine; diff proc)
} CLSCTX;

#define CLSCTX_ALL              (CLSCTX_INPROC_SERVER| \
                                 CLSCTX_INPROC_HANDLER| \
                                 CLSCTX_LOCAL_SERVER)

#define CLSCTX_INPROC           (CLSCTX_INPROC_SERVER|CLSCTX_INPROC_HANDLER)

#define CLSCTX_SERVER           (CLSCTX_INPROC_SERVER|CLSCTX_LOCAL_SERVER)


// class registration flags; passed to CoRegisterClassObject
typedef enum tagREGCLS
{
    REGCLS_SINGLEUSE = 0,       // class object only generates one instance
    REGCLS_MULTIPLEUSE = 1,     // same class object genereates multiple inst.
								// and local automatically goes into inproc tbl.
    REGCLS_MULTI_SEPARATE = 2,  // multiple use, but separate control over each
								// context.

	// NOTE: CLSCTX_LOCAL_SERVER, REGCLS_MULTIPLEUSE is the same as
	// (CLSCTX_INPROC_SERVER|CLSCTX_LOCAL_SERVER), REGCLS_MULTI_SEPARATE, but
	// not the same as CLSCTX_LOCAL_SERVER, REGCLS_MULTI_SEPARATE.
} REGCLS;


// interface marshaling definitions
#define MARSHALINTERFACE_MIN 40 // minimum number of bytes for interface marshl

// marshaling flags; passed to CoMarshalInterface
typedef enum tagMSHLFLAGS
{
    MSHLFLAGS_NORMAL = 0,       // normal marshaling via proxy/stub
    MSHLFLAGS_TABLESTRONG = 1,  // keep object alive; must explicitly release
    MSHLFLAGS_TABLEWEAK = 2     // doesn't hold object alive; still must release
} MSHLFLAGS;

// marshal context: determines the destination context of the marshal operation
typedef enum tagMSHCTX
{
    MSHCTX_LOCAL = 0,           // unmarshal context is local (eg.shared memory)
    MSHCTX_NOSHAREDMEM = 1,     // unmarshal context has no shared memory access
} MSHCTX;


// call type used by IMessageFilter::HandleIncommingMessage
typedef enum tagCALLTYPE
{
    CALLTYPE_TOPLEVEL = 1,      // toplevel call - no outgoing call 
    CALLTYPE_NESTED   = 2,      // callback on behalf of previous outgoing call - should always handle
    CALLTYPE_ASYNC    = 3,      // aysnchronous call - can NOT be rejected
    CALLTYPE_TOPLEVEL_CALLPENDING = 4,  // new toplevel call with new LID
    CALLTYPE_ASYNC_CALLPENDING    = 5   // async call - can NOT be rejected
} CALLTYPE;

typedef struct tagINTERFACEINFO 
{               
    interface IUnknown FAR *pUnk;       // the pointer to the object
    IID      			iid;            // interface id
    WORD        		wMethod;        // interface methode
} INTERFACEINFO, FAR * LPINTERFACEINFO;

// status of server call - returned by IMessageFilter::HandleIncommingCall
// and passed to  IMessageFilter::RetryRejectedCall
typedef enum tagSERVERCALL
{
    SERVERCALL_ISHANDLED    = 0,
    SERVERCALL_REJECTED     = 1,
    SERVERCALL_RETRYLATER   = 2         
} SERVERCALL;


// Pending type indicates the level of nesting
typedef enum tagPENDINGTYPE
{   
    PENDINGTYPE_TOPLEVEL = 1,       // toplevel call
    PENDINGTYPE_NESTED   = 2,       // nested call
} PENDINGTYPE;

// return values of MessagePending
typedef enum tagPENDINGMSG
{   
    PENDINGMSG_CANCELCALL  = 0, // cancel the outgoing call
    PENDINGMSG_WAITNOPROCESS  = 1, // wait for the return and don't dispatch the message
    PENDINGMSG_WAITDEFPROCESS = 2  // wait and dispatch the message 
    
} PENDINGMSG;


// bit flags for IExternalConnection
typedef enum tagEXTCONN 
{
	EXTCONN_STRONG		= 0x0001	// strong connection
} EXTCONN;


/****** IUnknown Interface **************************************************/


#undef  INTERFACE
#define INTERFACE   IUnknown

DECLARE_INTERFACE(IUnknown)
{
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
};

typedef        IUnknown FAR* LPUNKNOWN;


/****** Class Factory Interface *******************************************/


#undef  INTERFACE
#define INTERFACE   IClassFactory

DECLARE_INTERFACE_(IClassFactory, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IClassFactory methods ***
    STDMETHOD(CreateInstance) (THIS_ LPUNKNOWN pUnkOuter,
                              REFIID riid,
                              LPVOID FAR* ppvObject) PURE;
    STDMETHOD(LockServer) (THIS_ BOOL fLock) PURE;

};
typedef       IClassFactory FAR* LPCLASSFACTORY;


/****** Memory Allocation Interface ***************************************/


#undef  INTERFACE
#define INTERFACE   IMalloc

DECLARE_INTERFACE_(IMalloc, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IMalloc methods ***
    STDMETHOD_(void FAR*, Alloc) (THIS_ SIZE_T cb) PURE;
    STDMETHOD_(void FAR*, Realloc) (THIS_ void FAR* pv, SIZE_T cb) PURE;
    STDMETHOD_(void, Free) (THIS_ void FAR* pv) PURE;
    STDMETHOD_(SIZE_T, GetSize) (THIS_ void FAR* pv) PURE;
    STDMETHOD_(int, DidAlloc) (THIS_ void FAR* pv) PURE;
    STDMETHOD_(void, HeapMinimize) (THIS) PURE;
};
typedef       IMalloc FAR* LPMALLOC;


/****** IMarshal Interface ************************************************/

// forward declaration for IStream; must include storage.h later to use
#ifdef __cplusplus
interface IStream;
#else
typedef interface IStream IStream;
#endif
typedef         IStream FAR* LPSTREAM;


#undef  INTERFACE
#define INTERFACE   IMarshal

DECLARE_INTERFACE_(IMarshal, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IMarshal methods ***
    STDMETHOD(GetUnmarshalClass)(THIS_ REFIID riid, LPVOID pv, 
                        DWORD dwDestContext, LPVOID pvDestContext,
                        DWORD mshlflags, LPCLSID pCid) PURE;
    STDMETHOD(GetMarshalSizeMax)(THIS_ REFIID riid, LPVOID pv, 
                        DWORD dwDestContext, LPVOID pvDestContext,
                        DWORD mshlflags, LPDWORD pSize) PURE;
    STDMETHOD(MarshalInterface)(THIS_ LPSTREAM pStm, REFIID riid,
                        LPVOID pv, DWORD dwDestContext, LPVOID pvDestContext,
                        DWORD mshlflags) PURE;
    STDMETHOD(UnmarshalInterface)(THIS_ LPSTREAM pStm, REFIID riid,
                        LPVOID FAR* ppv) PURE;
    STDMETHOD(ReleaseMarshalData)(THIS_ LPSTREAM pStm) PURE;
    STDMETHOD(DisconnectObject)(THIS_ DWORD dwReserved) PURE;
};
typedef         IMarshal FAR* LPMARSHAL;


#undef  INTERFACE
#define INTERFACE   IStdMarshalInfo

DECLARE_INTERFACE_(IStdMarshalInfo, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IStdMarshalInfo methods ***
    STDMETHOD(GetClassForHandler)(THIS_ DWORD dwDestContext, 
                        LPVOID pvDestContext, LPCLSID pClsid) PURE;
};
typedef         IStdMarshalInfo FAR* LPSTDMARSHALINFO;


/****** Message Filter Interface *******************************************/


#undef  INTERFACE
#define INTERFACE   IMessageFilter

DECLARE_INTERFACE_(IMessageFilter, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IMessageFilter methods ***
    STDMETHOD_(DWORD, HandleInComingCall) (THIS_ DWORD dwCallType,
                                HTASK htaskCaller, DWORD dwTickCount,
                                LPINTERFACEINFO pii) PURE;
    STDMETHOD_(DWORD, RetryRejectedCall) (THIS_ 
                                HTASK htaskCallee, DWORD dwTickCount,
                                DWORD dwRejectType ) PURE;
    STDMETHOD_(DWORD, MessagePending) (THIS_ 
                                HTASK htaskCallee, DWORD dwTickCount, 
                                DWORD dwPendingType  ) PURE; 
};
typedef       IMessageFilter FAR* LPMESSAGEFILTER;


/****** External Connection Information ***********************************/

#undef  INTERFACE
#define INTERFACE   IExternalConnection

DECLARE_INTERFACE_(IExternalConnection, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IExternalConnection methods ***
    STDMETHOD_(DWORD, AddConnection) (THIS_ DWORD extconn, DWORD reserved) PURE;
    STDMETHOD_(DWORD, ReleaseConnection) (THIS_ DWORD extconn, DWORD reserved, BOOL fLastReleaseCloses) PURE;
};
typedef       IExternalConnection FAR* LPEXTERNALCONNECTION;


/****** Enumerator Interfaces *********************************************/

/*
 *  Since we don't use parametrized types, we put in explicit declarations
 *  of the enumerators we need.
 */


#undef  INTERFACE
#define INTERFACE   IEnumString

DECLARE_INTERFACE_(IEnumString, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IEnumString methods ***
    STDMETHOD(Next) (THIS_ ULONG celt, 
                       LPSTR FAR* rgelt, 
                       ULONG FAR* pceltFetched) PURE;
    STDMETHOD(Skip) (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset) (THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumString FAR* FAR* ppenm) PURE;
};
typedef      IEnumString FAR* LPENUMSTRING;


#undef  INTERFACE
#define INTERFACE   IEnumUnknown

DECLARE_INTERFACE_(IEnumUnknown, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IEnumUnknown methods ***
    STDMETHOD(Next) (THIS_ ULONG celt, LPUNKNOWN FAR* rgelt, ULONG FAR* pceltFetched) PURE;
    STDMETHOD(Skip) (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset) (THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumUnknown FAR* FAR* ppenm) PURE;
};
typedef         IEnumUnknown FAR* LPENUMUNKNOWN;


/****** STD Object API Prototypes *****************************************/

STDAPI_(DWORD) CoBuildVersion( VOID );

/* init/uninit */

STDAPI  CoInitialize(LPMALLOC pMalloc);
STDAPI_(void)  CoUninitialize(void);
STDAPI  CoGetMalloc(DWORD dwMemContext, LPMALLOC FAR* ppMalloc);
STDAPI_(DWORD) CoGetCurrentProcess(void);
STDAPI  CoCreateStandardMalloc(DWORD memctx, IMalloc FAR* FAR* ppMalloc);


/* register/revoke/get class objects */

STDAPI  CoGetClassObject(REFCLSID rclsid, DWORD dwClsContext, LPVOID pvReserved,
                    REFIID riid, LPVOID FAR* ppv);
STDAPI  CoRegisterClassObject(REFCLSID rclsid, LPUNKNOWN pUnk,
                    DWORD dwClsContext, DWORD flags, LPDWORD lpdwRegister);
STDAPI  CoRevokeClassObject(DWORD dwRegister);


/* marshaling interface pointers */

STDAPI CoMarshalInterface(LPSTREAM pStm, REFIID riid, LPUNKNOWN pUnk,
                    DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags);
STDAPI CoUnmarshalInterface(LPSTREAM pStm, REFIID riid, LPVOID FAR* ppv);
STDAPI CoMarshalHresult(LPSTREAM pstm, HRESULT hresult);
STDAPI CoUnmarshalHresult(LPSTREAM pstm, HRESULT FAR * phresult);
STDAPI CoReleaseMarshalData(LPSTREAM pStm);
STDAPI CoDisconnectObject(LPUNKNOWN pUnk, DWORD dwReserved);
STDAPI CoLockObjectExternal(LPUNKNOWN pUnk, BOOL fLock, BOOL fLastUnlockReleases);
STDAPI CoGetStandardMarshal(REFIID riid, LPUNKNOWN pUnk, 
                    DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags,
                    LPMARSHAL FAR* ppMarshal);

STDAPI_(BOOL) CoIsHandlerConnected(LPUNKNOWN pUnk);

/* dll loading helpers; keeps track of ref counts and unloads all on exit */

STDAPI_(HINSTANCE) CoLoadLibrary(LPSTR lpszLibName, BOOL bAutoFree);
STDAPI_(void) CoFreeLibrary(HINSTANCE hInst);
STDAPI_(void) CoFreeAllLibraries(void);
STDAPI_(void) CoFreeUnusedLibraries(void);


/* helper for creating instances */

STDAPI CoCreateInstance(REFCLSID rclsid, LPUNKNOWN pUnkOuter,
                    DWORD dwClsContext, REFIID riid, LPVOID FAR* ppv);


/* other helpers */
STDAPI_(BOOL) IsEqualGUID(REFGUID rguid1, REFGUID rguid2);
STDAPI StringFromCLSID(REFCLSID rclsid, LPSTR FAR* lplpsz);
STDAPI CLSIDFromString(LPSTR lpsz, LPCLSID pclsid);
STDAPI StringFromIID(REFIID rclsid, LPSTR FAR* lplpsz);
STDAPI IIDFromString(LPSTR lpsz, LPIID lpiid);
STDAPI_(BOOL) CoIsOle1Class(REFCLSID rclsid);
STDAPI ProgIDFromCLSID (REFCLSID clsid, LPSTR FAR* lplpszProgID);
STDAPI CLSIDFromProgID (LPCSTR lpszProgID, LPCLSID lpclsid);
STDAPI_(int) StringFromGUID2(REFGUID rguid, LPSTR lpsz, int cbMax);

STDAPI CoCreateGuid(GUID FAR *pguid);

STDAPI_(BOOL) CoFileTimeToDosDateTime(
                 FILETIME __in FAR* lpFileTime, LPWORD lpDosDate, LPWORD lpDosTime);
STDAPI_(BOOL) CoDosDateTimeToFileTime(
                       WORD nDosDate, WORD nDosTime, FILETIME __out FAR* lpFileTime);
STDAPI  CoFileTimeNow( FILETIME __out FAR* lpFileTime );


STDAPI CoRegisterMessageFilter( LPMESSAGEFILTER lpMessageFilter,
                                LPMESSAGEFILTER FAR* lplpMessageFilter );


/* TreatAs APIS */

STDAPI CoGetTreatAsClass(REFCLSID clsidOld, LPCLSID pClsidNew);
STDAPI CoTreatAsClass(REFCLSID clsidOld, REFCLSID clsidNew);


/* the server dlls must define their DllGetClassObject and DllCanUnloadNow
 * to match these; the typedefs are located here to ensure all are changed at 
 * the same time.
 */

STDAPI  DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID FAR* ppv);
#ifdef _MAC
typedef STDAPICALLTYPE HRESULT (FAR* LPFNGETCLASSOBJECT) (REFCLSID, REFIID, LPVOID FAR*);
#else
typedef HRESULT (STDAPICALLTYPE FAR* LPFNGETCLASSOBJECT) (REFCLSID, REFIID, LPVOID FAR*);
#endif


STDAPI  DllCanUnloadNow(void);
#ifdef _MAC
typedef STDAPICALLTYPE HRESULT (FAR* LPFNCANUNLOADNOW)(void);
#else
typedef HRESULT (STDAPICALLTYPE FAR* LPFNCANUNLOADNOW)(void);
#endif


/****** Debugging Helpers *************************************************/

#ifdef _DEBUG
// writes to the debug port and displays a message box
STDAPI FnAssert(LPSTR lpstrExpr, LPSTR lpstrMsg, LPSTR lpstrFileName, UINT iLine);
#endif  //  _DEBUG

#endif // _COMPOBJ_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\thc\thpp\oleguid.h ===
/*****************************************************************************\
*                                                                             *
* oleguid.h -   Master definition of GUIDs for ole2.dll                       *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/

/* this file is the master definition of all public GUIDs specific to OLE 
   and is included in ole2.h.
   
   NOTE: The second least significant byte of all of these GUIDs is 1.
*/
   

DEFINE_OLEGUID(IID_IEnumUnknown,            0x00000100, 0, 0);
DEFINE_OLEGUID(IID_IEnumString,             0x00000101, 0, 0);
DEFINE_OLEGUID(IID_IEnumMoniker,            0x00000102, 0, 0);
DEFINE_OLEGUID(IID_IEnumFORMATETC,          0x00000103, 0, 0);
DEFINE_OLEGUID(IID_IEnumOLEVERB,            0x00000104, 0, 0);
DEFINE_OLEGUID(IID_IEnumSTATDATA,           0x00000105, 0, 0);

DEFINE_OLEGUID(IID_IEnumGeneric,            0x00000106, 0, 0);
DEFINE_OLEGUID(IID_IEnumHolder,             0x00000107, 0, 0);
DEFINE_OLEGUID(IID_IEnumCallback,           0x00000108, 0, 0);

DEFINE_OLEGUID(IID_IPersistStream,          0x00000109, 0, 0);
DEFINE_OLEGUID(IID_IPersistStorage,         0x0000010a, 0, 0);
DEFINE_OLEGUID(IID_IPersistFile,            0x0000010b, 0, 0);
DEFINE_OLEGUID(IID_IPersist,                0x0000010c, 0, 0);

DEFINE_OLEGUID(IID_IViewObject,             0x0000010d, 0, 0);
DEFINE_OLEGUID(IID_IDataObject,             0x0000010e, 0, 0);
DEFINE_OLEGUID(IID_IAdviseSink,             0x0000010f, 0, 0);
DEFINE_OLEGUID(IID_IDataAdviseHolder,       0x00000110, 0, 0);
DEFINE_OLEGUID(IID_IOleAdviseHolder,        0x00000111, 0, 0);

DEFINE_OLEGUID(IID_IOleObject,              0x00000112, 0, 0);
DEFINE_OLEGUID(IID_IOleInPlaceObject,       0x00000113, 0, 0);
DEFINE_OLEGUID(IID_IOleWindow,              0x00000114, 0, 0);
DEFINE_OLEGUID(IID_IOleInPlaceUIWindow,     0x00000115, 0, 0);
DEFINE_OLEGUID(IID_IOleInPlaceFrame,        0x00000116, 0, 0);
DEFINE_OLEGUID(IID_IOleInPlaceActiveObject, 0x00000117, 0, 0);

DEFINE_OLEGUID(IID_IOleClientSite,          0x00000118, 0, 0);
DEFINE_OLEGUID(IID_IOleInPlaceSite,         0x00000119, 0, 0);

DEFINE_OLEGUID(IID_IParseDisplayName,       0x0000011a, 0, 0);
DEFINE_OLEGUID(IID_IOleContainer,           0x0000011b, 0, 0);
DEFINE_OLEGUID(IID_IOleItemContainer,       0x0000011c, 0, 0);

DEFINE_OLEGUID(IID_IOleLink,                0x0000011d, 0, 0);
DEFINE_OLEGUID(IID_IOleCache,               0x0000011e, 0, 0);
DEFINE_OLEGUID(IID_IOleManager,             0x0000011f, 0, 0); // unused
DEFINE_OLEGUID(IID_IOlePresObj,             0x00000120, 0, 0);

DEFINE_OLEGUID(IID_IDropSource,             0x00000121, 0, 0);
DEFINE_OLEGUID(IID_IDropTarget,             0x00000122, 0, 0);

DEFINE_OLEGUID(IID_IDebug,                  0x00000123, 0, 0);
DEFINE_OLEGUID(IID_IDebugStream,            0x00000124, 0, 0);

DEFINE_OLEGUID(IID_IAdviseSink2,            0x00000125, 0, 0);

DEFINE_OLEGUID(IID_IRunnableObject,         0x00000126, 0, 0);

DEFINE_OLEGUID(IID_IViewObject2,			0x00000127, 0, 0);
DEFINE_OLEGUID(IID_IOleCache2,				0x00000128, 0, 0);
DEFINE_OLEGUID(IID_IOleCacheControl,        0x00000129, 0, 0);

/* NOTE: LSB values 0x27 through 0xff are reserved */


/* GUIDs defined in OLE's private range */
DEFINE_OLEGUID(CLSID_Picture_Metafile,        0x00000315, 0, 0);
DEFINE_OLEGUID(CLSID_Picture_Dib,             0x00000316, 0, 0);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\thc\thpp\main.c ===
#include "config.h"
#include "compobj.h"
#include "storage.h"
#include "ole2.h"
#include "extens.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\thc\thpp\extens.h ===
typedef unsigned long RPCOLEDATAREP;

typedef enum tagRPCFLG
  {
	RPCFLG_ASYNCHRONOUS = 1073741824,
	RPCFLG_INPUT_SYNCHRONOUS = 536870912
  }
RPCFLG;

typedef struct tagRPCOLEMESSAGE
  {
  void *reserved1;
  RPCOLEDATAREP dataRepresentation;
  void *Buffer;
  ULONG cbBuffer;
  ULONG iMethod;
  DWORD reserved2[5];
  ULONG rpcFlags;
  }
RPCOLEMESSAGE;

typedef RPCOLEMESSAGE *PRPCOLEMESSAGE;

interface IRpcChannelBuffer : public IUnknown
{
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    
    virtual HRESULT STDMETHODCALLTYPE GetBuffer
    (
	RPCOLEMESSAGE *pMessage,
	REFIID riid
    ) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE SendReceive
    (
	RPCOLEMESSAGE *pMessage,
	ULONG *pStatus
    ) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE FreeBuffer
    (
	RPCOLEMESSAGE *pMessage
    ) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE GetDestCtx
    (
	DWORD *pdwDestContext,
	void **ppvDestContext
    ) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE IsConnected
    (
        void
    ) = 0;
};

interface IRpcProxyBuffer : public IUnknown
{
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    virtual HRESULT STDMETHODCALLTYPE Connect
    (
	IRpcChannelBuffer *pRpcChannelBuffer
    ) = 0;
    
    virtual void STDMETHODCALLTYPE Disconnect
    (
        void
    ) = 0;
    
};

interface IRpcStubBuffer : public IUnknown
{
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    virtual HRESULT STDMETHODCALLTYPE Connect
    (
	IUnknown *pUnkServer
    ) = 0;
    
    virtual void STDMETHODCALLTYPE Disconnect
    (
        void
    ) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE Invoke
    (
	RPCOLEMESSAGE *_prpcmsg,
	IRpcChannelBuffer *_pRpcChannelBuffer
    ) = 0;
    
    virtual IRpcStubBuffer  FAR *STDMETHODCALLTYPE IsIIDSupported
    (
	REFIID riid
    ) = 0;
    
    virtual ULONG STDMETHODCALLTYPE CountRefs
    (
        void
    ) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE DebugServerQueryInterface
    (
	IUnknown **ppunk
    ) = 0;
    
    virtual void STDMETHODCALLTYPE DebugServerRelease
    (
	void *pv
    ) = 0;
    
};

interface IPSFactoryBuffer : public IUnknown
{
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    virtual HRESULT STDMETHODCALLTYPE CreateProxy
    (
	IUnknown *pUnkOuter,
	REFIID riid,
	IRpcProxyBuffer **ppProxy,
	void **ppv
    ) = 0;
    
    virtual HRESULT STDMETHODCALLTYPE CreateStub
    (
	REFIID riid,
	IUnknown *pUnkServer,
	IRpcStubBuffer **ppStub
    ) = 0;
};

interface IRpcChannel : public IUnknown 
{
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    STDMETHOD(GetStream)(REFIID iid, int iMethod, BOOL fSend,
                     BOOL fNoWait, DWORD size, IStream FAR* FAR* ppIStream) = 0;
    STDMETHOD(Call)(IStream FAR* pIStream) = 0;
    STDMETHOD(GetDestCtx)(DWORD FAR* lpdwDestCtx, LPVOID FAR* lplpvDestCtx) = 0;
    STDMETHOD(IsConnected)(void) = 0;
};


interface IRpcProxy : public IUnknown 
{
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    STDMETHOD(Connect)(IRpcChannel FAR* pRpcChannel) = 0;
    STDMETHOD_(void, Disconnect)(void) = 0;
};


interface IRpcStub : public IUnknown
{
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    STDMETHOD(Connect)(IUnknown FAR* pUnk) = 0;
    STDMETHOD_(void, Disconnect)(void) = 0;
    STDMETHOD(Invoke)(REFIID iid, int iMethod, IStream FAR* pIStream,
            DWORD dwDestCtx, LPVOID lpvDestCtx) = 0;
    STDMETHOD_(BOOL, IsIIDSupported)(REFIID iid) = 0;
    STDMETHOD_(ULONG, CountRefs)(void) = 0;
};

interface IPSFactory : public IUnknown
{
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    STDMETHOD(CreateProxy)(IUnknown FAR* pUnkOuter, REFIID riid, 
        IRpcProxy FAR* FAR* ppProxy, void FAR* FAR* ppv) = 0;
    STDMETHOD(CreateStub)(REFIID riid, IUnknown FAR* pUnkServer,
        IRpcStub FAR* FAR* ppStub) = 0;
};

STDAPI ReadOleStg 
	(LPSTORAGE pstg, DWORD FAR* pdwFlags, DWORD FAR* pdwOptUpdate, 
	 DWORD FAR* pdwReserved, LPMONIKER FAR* ppmk, LPSTREAM FAR* ppstmOut);
STDAPI WriteOleStg 
	(LPSTORAGE pstg, IOleObject FAR* pOleObj, 
	 DWORD dwReserved, LPSTREAM FAR* ppstmOut);

STDAPI CoGetState(IUnknown FAR * FAR *ppunk);
STDAPI CoSetState(IUnknown FAR *punk);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\thc\thpp\ole2ver.h ===
#define rmj		0
#define rmm		23
#define rup		639
#define szVerName	""
#define szVerUser	"Y-OLEBLD"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\thc\thpp\ole2.h ===
/*****************************************************************************\
*                                                                             *
* ole2.h - 		Main OLE2 header; includes all subcomponents				  *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/


#if !defined( _OLE2_H_ )
#define _OLE2_H_

#ifndef RC_INVOKED
#pragma warning(disable:4001)
#endif  /* RC_INVOKED */

#include <string.h>

/****** Standard Object Definitions *****************************************/

#include <compobj.h>


// *************** FACILITY_ITF scodes common to all interfaces ************
//
// By convention, OLE interfaces divide the FACILITY_ITF range of errors
// into nonoverlapping subranges.  If an interface returns a FACILITY_ITF 
// scode, it must be from the range associated with that interface or from
// the shared range: OLE_E_FIRST...OLE_E_LAST.
//

// error codes

#define OLE_E_OLEVERB               (OLE_E_FIRST)
// invalid OLEVERB structure  

#define OLE_E_ADVF                  (OLE_E_FIRST+1)
// invalid advise flags

#define OLE_E_ENUM_NOMORE           (OLE_E_FIRST+2)
// you can't enuemrate any more, because the associated data is missing

#define OLE_E_ADVISENOTSUPPORTED    (OLE_E_FIRST+3)
// this implementation doesn't take advises

#define OLE_E_NOCONNECTION          (OLE_E_FIRST+4)
// there is no connection for this connection id

#define OLE_E_NOTRUNNING            (OLE_E_FIRST+5)
// need run the object to perform this operation

#define OLE_E_NOCACHE               (OLE_E_FIRST+6)
// there is no cache to operate on

#define OLE_E_BLANK                 (OLE_E_FIRST+7)
// Uninitialized object

#define OLE_E_CLASSDIFF             (OLE_E_FIRST+8)
// linked object's source class has changed 

#define OLE_E_CANT_GETMONIKER       (OLE_E_FIRST+9)
// not able to get the moniker of the object

#define OLE_E_CANT_BINDTOSOURCE     (OLE_E_FIRST+10)
// not able to bind to the source

#define OLE_E_STATIC                (OLE_E_FIRST+11)
// object is static, operation not allowed

#define OLE_E_PROMPTSAVECANCELLED   (OLE_E_FIRST+12)
// user cancelled out of save dialog

#define OLE_E_INVALIDRECT           (OLE_E_FIRST+13)
// invalid rectangle 

#define OLE_E_WRONGCOMPOBJ          (OLE_E_FIRST+14)
// compobj.dll is too old for the ole2.dll initialized

#define OLE_E_INVALIDHWND           (OLE_E_FIRST+15)
// invalid window handle

#define OLE_E_NOT_INPLACEACTIVE     (OLE_E_FIRST+16)
// object is not in any of the inplace active states  

#define OLE_E_CANTCONVERT			(OLE_E_FIRST+17)
// not able to convert the object 

#define OLE_E_NOSTORAGE				(OLE_E_FIRST+18)
// not able to perform the operation because object is not given storage yet.
 

#define DVGEN_E_FIRST               (OLE_E_FIRST+100)

#define DV_E_FORMATETC              (DVGEN_E_FIRST)
// invalid FORMATETC structure

#define DV_E_DVTARGETDEVICE         (DVGEN_E_FIRST+1)
// invalid DVTARGETDEVICE structure

#define DV_E_STGMEDIUM              (DVGEN_E_FIRST+2)
// invalid STDGMEDIUM structure

#define DV_E_STATDATA               (DVGEN_E_FIRST+3)
// invalid STATDATA structure

#define DV_E_LINDEX                 (DVGEN_E_FIRST+4)
// invalid lindex

#define DV_E_TYMED                  (DVGEN_E_FIRST+5)
// invalid tymed

#define DV_E_CLIPFORMAT             (DVGEN_E_FIRST+6)
// invalid clipboard format

#define DV_E_DVASPECT               (DVGEN_E_FIRST+7)
// invalid aspect(s) 

#define DV_E_DVTARGETDEVICE_SIZE    (DVGEN_E_FIRST+8)
// tdSize paramter of the DVTARGETDEVICE structure is invalid

#define DV_E_NOIVIEWOBJECT          (DVGEN_E_FIRST+9)
// object doesn't support IViewObject interface


// Success codes

#define OLE_S_USEREG                (OLE_S_FIRST)
// use the reg database to provide the requested info

#define OLE_S_STATIC                (OLE_S_FIRST+1)
// success, but static 

#define OLE_S_MAC_CLIPFORMAT        (OLE_S_FIRST+2)
// macintosh clipboard format

//*************************** Interface or API specific scodes *************

// Errors for OleConvertOLESTREAMToIStorage and OleConvertIStorageToOLESTREAM

// OLESTREAM Get method failed
#define CONVERT10_E_OLESTREAM_GET       (CONVERT10_E_FIRST + 0)

// OLESTREAM Put method failed
#define CONVERT10_E_OLESTREAM_PUT       (CONVERT10_E_FIRST + 1)

// Contents of the OLESTREAM not in correct format
#define CONVERT10_E_OLESTREAM_FMT       (CONVERT10_E_FIRST + 2)

// There was in an error in a Windows GDI call while converting the bitmap
// to a DIB.
#define CONVERT10_E_OLESTREAM_BITMAP_TO_DIB (CONVERT10_E_FIRST + 3)

// Contents of the IStorage not in correct format
#define CONVERT10_E_STG_FMT             (CONVERT10_E_FIRST + 4)

// Contents of IStorage is missing one of the standard streams ("\1CompObj", 
// "\1Ole", "\2OlePres000").  This may be the storage for a DLL object, or a
// class that does not use the def handler.
#define CONVERT10_E_STG_NO_STD_STREAM   (CONVERT10_E_FIRST + 5)

// There was in an error in a Windows GDI call while converting the DIB
// to a bitmap.
#define CONVERT10_E_STG_DIB_TO_BITMAP   (CONVERT10_E_FIRST + 6)


// Returned by either API, this scode indicates that the original object
//  had no presentation, therefore the converted object does not either.
#define CONVERT10_S_NO_PRESENTATION     (CONVERT10_S_FIRST + 0)


// Errors for Clipboard functions

// OpenClipboard Failed
#define CLIPBRD_E_CANT_OPEN     (CLIPBRD_E_FIRST + 0)

// EmptyClipboard Failed
#define CLIPBRD_E_CANT_EMPTY        (CLIPBRD_E_FIRST + 1)

// SetClipboard Failed
#define CLIPBRD_E_CANT_SET          (CLIPBRD_E_FIRST + 2)

// Data on clipboard is invalid
#define CLIPBRD_E_BAD_DATA          (CLIPBRD_E_FIRST + 3)

// CloseClipboard Failed
#define CLIPBRD_E_CANT_CLOSE        (CLIPBRD_E_FIRST + 4)


/****** OLE value types *****************************************************/

/* rendering options */
typedef enum tagOLERENDER
{
    OLERENDER_NONE   = 0, 
    OLERENDER_DRAW   = 1, 
    OLERENDER_FORMAT = 2,
    OLERENDER_ASIS   = 3
} OLERENDER;
typedef  OLERENDER FAR* LPOLERENDER;

// OLE verb; returned by IEnumOLEVERB
typedef struct FARSTRUCT tagOLEVERB
{
    LONG    lVerb;
    LPSTR   lpszVerbName;
    DWORD   fuFlags;
    DWORD	grfAttribs;
} OLEVERB, FAR* LPOLEVERB;


// Bitwise verb attributes used in OLEVERB.grfAttribs
typedef enum tagOLEVERBATTRIB // bitwise
{
    OLEVERBATTRIB_NEVERDIRTIES = 1,
    OLEVERBATTRIB_ONCONTAINERMENU = 2
} OLEVERBATTRIB;


// IOleObject::GetUserType optons; determines which form of the string to use
typedef enum tagUSERCLASSTYPE
{
    USERCLASSTYPE_FULL = 1,
    USERCLASSTYPE_SHORT= 2,
    USERCLASSTYPE_APPNAME= 3,
} USERCLASSTYPE;


// bits returned from IOleObject::GetMistStatus
typedef enum tagOLEMISC // bitwise
{
    OLEMISC_RECOMPOSEONRESIZE				= 1,
    OLEMISC_ONLYICONIC						= 2,
    OLEMISC_INSERTNOTREPLACE				= 4,
    OLEMISC_STATIC							= 8,
    OLEMISC_CANTLINKINSIDE					= 16,
    OLEMISC_CANLINKBYOLE1					= 32,
    OLEMISC_ISLINKOBJECT					= 64,
    OLEMISC_INSIDEOUT						= 128,
    OLEMISC_ACTIVATEWHENVISIBLE				= 256,
    OLEMISC_RENDERINGISDEVICEINDEPENDENT	= 512	
} OLEMISC;


// IOleObject::Close options
typedef enum tagOLECLOSE
{
    OLECLOSE_SAVEIFDIRTY = 0,
    OLECLOSE_NOSAVE      = 1,
    OLECLOSE_PROMPTSAVE  = 2
} OLECLOSE;


// IOleObject::GetMoniker and IOleClientSite::GetMoniker options; determines
// if and how monikers should be assigned.
typedef enum tagOLEGETMONIKER
{
    OLEGETMONIKER_ONLYIFTHERE=1,
    OLEGETMONIKER_FORCEASSIGN=2,
    OLEGETMONIKER_UNASSIGN=3,
    OLEGETMONIKER_TEMPFORUSER=4 
} OLEGETMONIKER;


// IOleObject::GetMoniker, IOleObject::SetMoniker and 
// IOleClientSite::GetMoniker options; determines which moniker to use
typedef enum tagOLEWHICHMK
{
    OLEWHICHMK_CONTAINER=1,
    OLEWHICHMK_OBJREL=2,
    OLEWHICHMK_OBJFULL=3
} OLEWHICHMK;


#ifdef WIN32
#define LPSIZEL PSIZEL
#else
typedef struct FARSTRUCT tagSIZEL
{
    long cx;
    long cy;
} SIZEL, FAR* LPSIZEL;
#endif


#ifdef WIN32
#define LPRECTL PRECTL
#else
typedef struct FARSTRUCT tagRECTL
{
    long    left;
    long    top;
    long    right;
    long    bottom;
} RECTL, FAR* LPRECTL;

typedef struct FARSTRUCT tagPOINTL {
    LONG x;
    LONG y;
} POINTL;

#endif
   

#ifndef LPCRECT
typedef const RECT FAR* LPCRECT;
#endif

#ifndef LPCRECTL
typedef const RECTL FAR* LPCRECTL;
#endif


// for OleCreateEmbeddingHelper flags; roles in low word; options in high word
#define EMBDHLP_INPROC_HANDLER   0x0000L // role is handler; implementation is 
										 // default handler; pCF can be NULL
#define EMBDHLP_INPROC_SERVER    0x0001L // role is server; pCF can't be NULL

#define EMBDHLP_CREATENOW    0x00000000L // create using pCF immediately; if pCF
										 // is NULL, uses std remoting handler
#define EMBDHLP_DELAYCREATE  0x00010000L // delayed create; must supply pCF


// NOTE: OleCreateEmbeddingHelper(clsid, pUnkOuter, 
// 		EMBDHLP_INPROC_HANDLER | EMBDHLP_CREATENOW, NULL, riid, lplpObj) 
// is the same as OleCreateDefaultHandler(clsid, pUnkOuter, riid, lplpObj);
// i.e., the embedding helper is the default handler in various roles.


/***** OLE 1.0 OLESTREAM declarations *************************************/

typedef struct _OLESTREAM FAR*  LPOLESTREAM;

typedef struct _OLESTREAMVTBL
{
    DWORD (CALLBACK* Get)(LPOLESTREAM, void FAR*, DWORD);
    DWORD (CALLBACK* Put)(LPOLESTREAM, const void FAR*, DWORD);
} OLESTREAMVTBL;
typedef  OLESTREAMVTBL FAR*  LPOLESTREAMVTBL;

typedef struct _OLESTREAM
{
    LPOLESTREAMVTBL lpstbl;
} OLESTREAM;


/****** Clipboard Data structures *****************************************/

typedef struct tagOBJECTDESCRIPTOR
{
   ULONG    cbSize;              // Size of structure in bytes
   CLSID    clsid;               // CLSID of data being transferred
   DWORD    dwDrawAspect;        // Display aspect of the object
                                 //     normally DVASPECT_CONTENT or ICON.
                                 //     dwDrawAspect will be 0 (which is NOT
                                 //     DVASPECT_CONTENT) if the copier or 
                                 //     dragsource didn't draw the object to 
                                 //     begin with.
   SIZEL    sizel;               // size of the object in HIMETRIC
                                 //    sizel is opt.: will be (0,0) for apps
                                 //    which don't draw the object being
                                 //    transferred
   POINTL   pointl;              // Offset in HIMETRIC units from the
                                 //    upper-left corner of the obj where the
                                 //    mouse went down for the drag.
                                 //    NOTE: y coordinates increase downward.
                                 //          x coordinates increase to right
                                 //    pointl is opt.; it is only meaningful 
                                 //    if object is transfered via drag/drop.
                                 //    (0, 0) if mouse position is unspecified
                                 //    (eg. when obj transfered via clipboard)
   DWORD    dwStatus;            // Misc. status flags for object. Flags are 
                                 //    defined by OLEMISC enum. these flags 
                                 //    are as would be returned
                                 //    by IOleObject::GetMiscStatus.
   DWORD    dwFullUserTypeName;  // Offset from beginning of structure to 
                                 //    null-terminated string that specifies 
                                 //    Full User Type Name of the object. 
                                 //    0 indicates string not present.
   DWORD    dwSrcOfCopy;         // Offset from beginning of structure to 
                                 //    null-terminated string that specifies
                                 //    source of the transfer. 
                                 //    dwSrcOfCOpy is normally implemented as 
                                 //    the display name of the temp-for-user 
                                 //    moniker which identifies the source of 
                                 //    the data. 
                                 //    0 indicates string not present.
                                 //    NOTE: moniker assignment is NOT forced.
                                 //    see IOleObject::GetMoniker(
                                 //                OLEGETMONIKER_TEMPFORUSER)

 /* variable sized string data may appear here */

} OBJECTDESCRIPTOR,  *POBJECTDESCRIPTOR,  FAR *LPOBJECTDESCRIPTOR,
  LINKSRCDESCRIPTOR, *PLINKSRCDESCRIPTOR, FAR *LPLINKSRCDESCRIPTOR;



/* verbs */
#define OLEIVERB_PRIMARY            (0L)
#define OLEIVERB_SHOW               (-1L)
#define OLEIVERB_OPEN               (-2L)
#define OLEIVERB_HIDE               (-3L)
#define OLEIVERB_UIACTIVATE         (-4L)
#define OLEIVERB_INPLACEACTIVATE    (-5L)
#define OLEIVERB_DISCARDUNDOSTATE   (-6L)


//      forward type declarations
#if defined(__cplusplus)
interface IOleClientSite;
interface IOleContainer;
interface IOleObject;
#else 
typedef interface IOleClientSite IOleClientSite;
typedef interface IOleContainer IOleContainer;
typedef interface IOleObject IOleObject;
#endif

typedef         IOleObject FAR* LPOLEOBJECT;
typedef     IOleClientSite FAR* LPOLECLIENTSITE;
typedef       IOleContainer FAR* LPOLECONTAINER;


/****** OLE GUIDs *********************************************************/

#ifndef INITGUID
#include "oleguid.h"
#endif


/****** Other Major Interfaces ********************************************/

#include <dvobj.h>

#include <storage.h>



/****** IDrop??? Interfaces ********************************************/

#define MK_ALT 0x0020


#define DROPEFFECT_NONE     0
#define DROPEFFECT_COPY     1
#define DROPEFFECT_MOVE     2
#define DROPEFFECT_LINK     4
#define DROPEFFECT_SCROLL   0x80000000

// default inset-width of the hot zone, in pixels
//   typical use: GetProfileInt("windows","DragScrollInset",DD_DEFSCROLLINSET)
#define DD_DEFSCROLLINSET		11

// default delay before scrolling, in milliseconds
//   typical use: GetProfileInt("windows","DragScrollDelay",DD_DEFSCROLLDELAY)
#define DD_DEFSCROLLDELAY		50

// default scroll interval, in milliseconds
//   typical use: GetProfileInt("windows","DragScrollInterval",
//                              DD_DEFSCROLLINTERVAL)
#define DD_DEFSCROLLINTERVAL	50

// default delay before dragging should start, in milliseconds
//   typical use: GetProfileInt("windows", "DragDelay", DD_DEFDRAGDELAY)
#define DD_DEFDRAGDELAY     	200

// default minimum distance (radius) before dragging should start, in pixels
//   typical use: GetProfileInt("windows", "DragMinDist", DD_DEFDRAGMINDIST)
#define DD_DEFDRAGMINDIST		2



/* Dragdrop specific error codes */

#define DRAGDROP_E_NOTREGISTERED        (DRAGDROP_E_FIRST)
// trying to revoke a drop target that has not been registered 

#define DRAGDROP_E_ALREADYREGISTERED    (DRAGDROP_E_FIRST+1)
// this window has already been registered as a drop target

#define DRAGDROP_E_INVALIDHWND          (DRAGDROP_E_FIRST+2)
// invalid HWND


#define DRAGDROP_S_DROP                 (DRAGDROP_S_FIRST + 0)
// successful drop took place 

#define DRAGDROP_S_CANCEL               (DRAGDROP_S_FIRST + 1)
// drag-drop operation canceled

#define DRAGDROP_S_USEDEFAULTCURSORS    (DRAGDROP_S_FIRST + 2)
// use the default cursor


#undef INTERFACE
#define INTERFACE   IDropTarget

DECLARE_INTERFACE_(IDropTarget, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IDropTarget methods ***
    STDMETHOD(DragEnter) (THIS_ LPDATAOBJECT pDataObj, DWORD grfKeyState, POINTL pt, __in __out LPDWORD pdwEffect) PURE;
    STDMETHOD(DragOver) (THIS_ DWORD grfKeyState, POINTL pt, __in __out LPDWORD pdwEffect) PURE;
    STDMETHOD(DragLeave) (THIS) PURE;
    STDMETHOD(Drop) (THIS_ LPDATAOBJECT pDataObj, DWORD grfKeyState, POINTL pt, __in __out LPDWORD pdwEffect) PURE;
};
typedef         IDropTarget FAR* LPDROPTARGET;



#undef INTERFACE
#define INTERFACE   IDropSource

DECLARE_INTERFACE_(IDropSource, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IDropSource methods ***
    STDMETHOD(QueryContinueDrag) (THIS_ BOOL fEscapePressed, DWORD grfKeyState) PURE;
    STDMETHOD(GiveFeedback) (THIS_ DWORD dwEffect) PURE;
};
typedef         IDropSource FAR* LPDROPSOURCE;



/****** IPersist??? Interfaces ********************************************/


#undef INTERFACE
#define INTERFACE   IPersist

DECLARE_INTERFACE_(IPersist, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IPersist methods ***
    STDMETHOD(GetClassID) (THIS_ LPCLSID lpClassID) PURE;
};
typedef            IPersist FAR* LPPERSIST;



#undef INTERFACE
#define INTERFACE   IPersistStorage

DECLARE_INTERFACE_(IPersistStorage, IPersist)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IPersist methods ***
    STDMETHOD(GetClassID) (THIS_ LPCLSID lpClassID) PURE;

    // *** IPersistStorage methods ***
    STDMETHOD(IsDirty) (THIS) PURE;
    STDMETHOD(InitNew) (THIS_ LPSTORAGE pStg) PURE;
    STDMETHOD(Load) (THIS_ LPSTORAGE pStg) PURE;
    STDMETHOD(Save) (THIS_ LPSTORAGE pStgSave, BOOL fSameAsLoad) PURE;
    STDMETHOD(SaveCompleted) (THIS_ LPSTORAGE pStgNew) PURE;
    STDMETHOD(HandsOffStorage) (THIS) PURE; 
};
typedef         IPersistStorage FAR* LPPERSISTSTORAGE;



#undef INTERFACE
#define INTERFACE   IPersistStream

DECLARE_INTERFACE_(IPersistStream, IPersist)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IPersist methods ***
    STDMETHOD(GetClassID) (THIS_ LPCLSID lpClassID) PURE;

    // *** IPersistStream methods ***
    STDMETHOD(IsDirty) (THIS) PURE;
    STDMETHOD(Load) (THIS_ LPSTREAM pStm) PURE;
    STDMETHOD(Save) (THIS_ LPSTREAM pStm,
                    BOOL fClearDirty) PURE;
    STDMETHOD(GetSizeMax) (THIS_ ULARGE_INTEGER FAR* pcbSize) PURE;
};
typedef          IPersistStream FAR* LPPERSISTSTREAM;



#undef INTERFACE
#define INTERFACE   IPersistFile

DECLARE_INTERFACE_(IPersistFile, IPersist)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;
    
    // *** IPersist methods ***
    STDMETHOD(GetClassID) (THIS_ LPCLSID lpClassID) PURE;
    
    // *** IPersistFile methods ***
    STDMETHOD(IsDirty) (THIS) PURE;
    STDMETHOD(Load) (THIS_ LPCSTR lpszFileName, DWORD grfMode) PURE;
    STDMETHOD(Save) (THIS_ LPCSTR lpszFileName, BOOL fRemember) PURE;
    STDMETHOD(SaveCompleted) (THIS_ LPCSTR lpszFileName) PURE;
    STDMETHOD(GetCurFile) (THIS_ LPSTR FAR* lplpszFileName) PURE;
};
typedef            IPersistFile FAR* LPPERSISTFILE;

  
/****** Moniker Object Interfaces ******************************************/

#include <moniker.h>


/****** OLE Object Interfaces ******************************************/
  
 
#undef  INTERFACE
#define INTERFACE   IEnumOLEVERB

DECLARE_INTERFACE_(IEnumOLEVERB, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IEnumOLEVERB methods ***
    STDMETHOD(Next) (THIS_ ULONG celt, LPOLEVERB rgelt, ULONG FAR* pceltFetched) PURE;
    STDMETHOD(Skip) (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset) (THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumOLEVERB FAR* FAR* ppenm) PURE;
};
typedef         IEnumOLEVERB FAR* LPENUMOLEVERB;




#undef  INTERFACE
#define INTERFACE   IOleObject

#define OLEOBJ_E_NOVERBS                (OLEOBJ_E_FIRST + 0)

#define OLEOBJ_E_INVALIDVERB            (OLEOBJ_E_FIRST + 1)

#define OLEOBJ_S_INVALIDVERB            (OLEOBJ_S_FIRST + 0)

#define OLEOBJ_S_CANNOT_DOVERB_NOW      (OLEOBJ_S_FIRST + 1)
// verb number is valid but verb cannot be done now, for instance
// hiding a link or hiding a visible OLE 1.0 server

#define OLEOBJ_S_INVALIDHWND            (OLEOBJ_S_FIRST + 2)
// invalid hwnd passed


DECLARE_INTERFACE_(IOleObject, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleObject methods ***
    STDMETHOD(SetClientSite) (THIS_ LPOLECLIENTSITE pClientSite) PURE;
    STDMETHOD(GetClientSite) (THIS_ LPOLECLIENTSITE FAR* ppClientSite) PURE;
    STDMETHOD(SetHostNames) (THIS_ LPCSTR szContainerApp, LPCSTR szContainerObj) PURE;
    STDMETHOD(Close) (THIS_ DWORD dwSaveOption) PURE;
    STDMETHOD(SetMoniker) (THIS_ DWORD dwWhichMoniker, LPMONIKER pmk) PURE;
    STDMETHOD(GetMoniker) (THIS_ DWORD dwAssign, DWORD dwWhichMoniker, 
                LPMONIKER FAR* ppmk) PURE;
    STDMETHOD(InitFromData) (THIS_ LPDATAOBJECT pDataObject,
                BOOL fCreation,
                DWORD dwReserved) PURE;
    STDMETHOD(GetClipboardData) (THIS_ DWORD dwReserved, 
                LPDATAOBJECT FAR* ppDataObject) PURE;
    STDMETHOD(DoVerb) (THIS_ LONG iVerb,
                LPMSG lpmsg, 
                LPOLECLIENTSITE pActiveSite, 
                LONG lindex,
                HWND hwndParent,
                __in LPCRECT lprcPosRect) PURE;
    STDMETHOD(EnumVerbs) (THIS_ LPENUMOLEVERB FAR* ppenumOleVerb) PURE;
    STDMETHOD(Update) (THIS) PURE;
    STDMETHOD(IsUpToDate) (THIS) PURE;
    STDMETHOD(GetUserClassID) (THIS_ CLSID FAR* pClsid) PURE;
    STDMETHOD(GetUserType) (THIS_ DWORD dwFormOfType, LPSTR FAR* pszUserType) PURE;
    STDMETHOD(SetExtent) (THIS_ DWORD dwDrawAspect, __in LPSIZEL lpsizel) PURE;
    STDMETHOD(GetExtent) (THIS_ DWORD dwDrawAspect, __out LPSIZEL lpsizel) PURE;

    STDMETHOD(Advise)(THIS_ LPADVISESINK pAdvSink, DWORD FAR* pdwConnection) PURE;
    STDMETHOD(Unadvise)(THIS_ DWORD dwConnection) PURE;
    STDMETHOD(EnumAdvise) (THIS_ LPENUMSTATDATA FAR* ppenumAdvise) PURE;
    STDMETHOD(GetMiscStatus) (THIS_ DWORD dwAspect, DWORD FAR* pdwStatus) PURE;
    STDMETHOD(SetColorScheme) (THIS_ LPLOGPALETTE lpLogpal) PURE;
};
typedef      IOleObject FAR* LPOLEOBJECT;



#undef  INTERFACE
#define INTERFACE   IOleClientSite

DECLARE_INTERFACE_(IOleClientSite, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleClientSite methods ***
    STDMETHOD(SaveObject) (THIS) PURE;
    STDMETHOD(GetMoniker) (THIS_ DWORD dwAssign, DWORD dwWhichMoniker, 
                LPMONIKER FAR* ppmk) PURE;
    STDMETHOD(GetContainer) (THIS_ LPOLECONTAINER FAR* ppContainer) PURE;   
    STDMETHOD(ShowObject) (THIS) PURE;  
    STDMETHOD(OnShowWindow) (THIS_ BOOL fShow) PURE;    
    STDMETHOD(RequestNewObjectLayout) (THIS) PURE;      
};
typedef      IOleClientSite FAR* LPOLECLIENTSITE;


/****** OLE Runnable Object Interface **********************************/

#undef  INTERFACE
#define INTERFACE	IRunnableObject

DECLARE_INTERFACE_(IRunnableObject, IUnknown)
{
	// *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

	// *** IRunnableObject methods ***
    STDMETHOD(GetRunningClass) (THIS_ LPCLSID lpClsid) PURE;
    STDMETHOD(Run) (THIS_ LPBINDCTX pbc) PURE;
    STDMETHOD_(BOOL, IsRunning) (THIS) PURE;
	STDMETHOD(LockRunning)(THIS_ BOOL fLock, BOOL fLastUnlockCloses) PURE;
	STDMETHOD(SetContainedObject)(THIS_ BOOL fContained) PURE;
};
typedef      IRunnableObject FAR* LPRUNNABLEOBJECT;


/****** OLE Container Interfaces ***************************************/
  

#undef  INTERFACE
#define INTERFACE   IParseDisplayName

DECLARE_INTERFACE_(IParseDisplayName, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IParseDisplayName method ***
    STDMETHOD(ParseDisplayName) (THIS_ LPBC pbc, LPSTR lpszDisplayName,
        ULONG FAR* pchEaten, LPMONIKER FAR* ppmkOut) PURE;
};
typedef       IParseDisplayName FAR* LPPARSEDISPLAYNAME;


#undef  INTERFACE
#define INTERFACE   IOleContainer

DECLARE_INTERFACE_(IOleContainer, IParseDisplayName)
{ 
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IParseDisplayName method ***
    STDMETHOD(ParseDisplayName) (THIS_ LPBC pbc, LPSTR lpszDisplayName,
        ULONG FAR* pchEaten, LPMONIKER FAR* ppmkOut) PURE;

    // *** IOleContainer methods ***
    STDMETHOD(EnumObjects) ( DWORD grfFlags, LPENUMUNKNOWN FAR* ppenumUnknown) PURE;
    STDMETHOD(LockContainer) (THIS_ BOOL fLock) PURE;   
};
typedef IOleContainer FAR* LPOLECONTAINER;


typedef enum tagBINDSPEED
{
    BINDSPEED_INDEFINITE    = 1,
    BINDSPEED_MODERATE      = 2,
    BINDSPEED_IMMEDIATE     = 3
} BINDSPEED;

typedef enum tagOLECONTF
{
    OLECONTF_EMBEDDINGS     =  1,
    OLECONTF_LINKS          =  2,
    OLECONTF_OTHERS         =  4,
    OLECONTF_ONLYUSER       =  8,
    OLECONTF_ONLYIFRUNNING  = 16
} OLECONTF;


#undef  INTERFACE
#define INTERFACE   IOleItemContainer

DECLARE_INTERFACE_(IOleItemContainer, IOleContainer)
{ 
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IParseDisplayName method ***
    STDMETHOD(ParseDisplayName) (THIS_ LPBC pbc, LPSTR lpszDisplayName,
        ULONG FAR* pchEaten, LPMONIKER FAR* ppmkOut) PURE;

    // *** IOleContainer methods ***
    STDMETHOD(EnumObjects) (THIS_ DWORD grfFlags, LPENUMUNKNOWN FAR* ppenumUnknown) PURE;
    STDMETHOD(LockContainer) (THIS_ BOOL fLock) PURE;   
    
    // *** IOleItemContainer methods ***
    STDMETHOD(GetObject) (THIS_ LPSTR lpszItem, DWORD dwSpeedNeeded,
        LPBINDCTX pbc, REFIID riid, LPVOID FAR* ppvObject) PURE;
    STDMETHOD(GetObjectStorage) (THIS_ LPSTR lpszItem, LPBINDCTX pbc,
        REFIID riid, LPVOID FAR* ppvStorage) PURE;
    STDMETHOD(IsRunning) (THIS_ LPSTR lpszItem) PURE;
};
typedef       IOleItemContainer FAR* LPOLEITEMCONTAINER;


/****** OLE Advise Holder Interface ***************************************/


#undef  INTERFACE
#define INTERFACE   IOleAdviseHolder

DECLARE_INTERFACE_(IOleAdviseHolder, IUnknown)
{ 
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppv) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleAdviseHolder methods ***
    STDMETHOD(Advise)(THIS_ LPADVISESINK pAdvise, DWORD FAR* pdwConnection) PURE;
    STDMETHOD(Unadvise)(THIS_ DWORD dwConnection) PURE;
    STDMETHOD(EnumAdvise)(THIS_ LPENUMSTATDATA FAR* ppenumAdvise) PURE;

    STDMETHOD(SendOnRename)(THIS_ LPMONIKER pmk) PURE;
    STDMETHOD(SendOnSave)(THIS) PURE;
    STDMETHOD(SendOnClose)(THIS) PURE;
};
typedef      IOleAdviseHolder FAR* LPOLEADVISEHOLDER;


/****** OLE Link Interface ************************************************/

/* Link update options */
typedef enum tagOLEUPDATE
{
    OLEUPDATE_ALWAYS=1,
    OLEUPDATE_ONCALL=3
} OLEUPDATE;
typedef  OLEUPDATE FAR* LPOLEUPDATE;


// for IOleLink::BindToSource
typedef enum tagOLELINKBIND
{
    OLELINKBIND_EVENIFCLASSDIFF = 1,
} OLELINKBIND;


#undef  INTERFACE
#define INTERFACE   IOleLink

DECLARE_INTERFACE_(IOleLink, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleLink methods ***
    STDMETHOD(SetUpdateOptions) (THIS_ DWORD dwUpdateOpt) PURE;
    STDMETHOD(GetUpdateOptions) (THIS_ LPDWORD pdwUpdateOpt) PURE;
    STDMETHOD(SetSourceMoniker) (THIS_ LPMONIKER pmk, REFCLSID rclsid) PURE;
    STDMETHOD(GetSourceMoniker) (THIS_ LPMONIKER FAR* ppmk) PURE;
    STDMETHOD(SetSourceDisplayName) (THIS_ LPCSTR lpszDisplayName) PURE;
    STDMETHOD(GetSourceDisplayName) (THIS_ LPSTR FAR* lplpszDisplayName) PURE;
    STDMETHOD(BindToSource) (THIS_ DWORD bindflags, LPBINDCTX pbc) PURE;
    STDMETHOD(BindIfRunning) (THIS) PURE;
    STDMETHOD(GetBoundSource) (THIS_ LPUNKNOWN FAR* ppUnk) PURE;
    STDMETHOD(UnbindSource) (THIS) PURE;
    STDMETHOD(Update) (THIS_ LPBINDCTX pbc) PURE;
};
typedef         IOleLink FAR* LPOLELINK;


/****** OLE InPlace Editing Interfaces ************************************/
  
#ifdef _MAC
typedef Handle  HOLEMENU;
typedef long    SIZE;
typedef long    HACCEL;
#else
DECLARE_HANDLE(HOLEMENU);
#endif  

typedef struct FARSTRUCT tagOIFI          // OleInPlaceFrameInfo
{
    UINT    cb;
    BOOL    fMDIApp;
    HWND    hwndFrame;
    HACCEL  haccel;
    int     cAccelEntries;
} OLEINPLACEFRAMEINFO, FAR* LPOLEINPLACEFRAMEINFO;


typedef struct FARSTRUCT tagOleMenuGroupWidths
{
    LONG    width[6];
} OLEMENUGROUPWIDTHS, FAR* LPOLEMENUGROUPWIDTHS;

typedef RECT    BORDERWIDTHS;
typedef LPRECT  LPBORDERWIDTHS;
typedef LPCRECT LPCBORDERWIDTHS;

/* Inplace editing specific error codes */

#define INPLACE_E_NOTUNDOABLE   (INPLACE_E_FIRST)
// undo is not avaiable

#define INPLACE_E_NOTOOLSPACE       (INPLACE_E_FIRST+1)
// Space for tools is not available

#define INPLACE_S_TRUNCATED     (INPLACE_S_FIRST)
// Message is too long, some of it had to be truncated before displaying

//misc definitions
#define INPLACE_DEFBORDERWIDTH	4

//      forward type declarations
#if defined(__cplusplus)
interface IOleInPlaceUIWindow;
#else 
typedef interface IOleInPlaceUIWindow IOleInPlaceUIWindow;
#endif

typedef     IOleInPlaceUIWindow FAR* LPOLEINPLACEUIWINDOW;


#undef  INTERFACE
#define INTERFACE   IOleWindow

DECLARE_INTERFACE_(IOleWindow, IUnknown)
{ 
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND FAR* lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;
};

typedef         IOleWindow FAR* LPOLEWINDOW;



#undef  INTERFACE
#define INTERFACE   IOleInPlaceObject

DECLARE_INTERFACE_(IOleInPlaceObject, IOleWindow)
{ 
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND FAR* lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IOleInPlaceObject methods ***
    STDMETHOD(InPlaceDeactivate) (THIS) PURE;   
    STDMETHOD(UIDeactivate) (THIS) PURE;
    STDMETHOD(SetObjectRects) (THIS_ __in LPCRECT lprcPosRect, 
                    __in LPCRECT lprcClipRect) PURE;
    STDMETHOD(ReactivateAndUndo) (THIS) PURE;   
};
typedef         IOleInPlaceObject FAR* LPOLEINPLACEOBJECT;



#undef  INTERFACE
#define INTERFACE   IOleInPlaceActiveObject

DECLARE_INTERFACE_(IOleInPlaceActiveObject, IOleWindow)
{ 
   // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND FAR* lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IOleInPlaceActiveObject methods ***
    STDMETHOD(TranslateAccelerator) (THIS_ LPMSG lpmsg) PURE;   
    STDMETHOD(OnFrameWindowActivate) (THIS_ BOOL fActivate) PURE;           
    STDMETHOD(OnDocWindowActivate) (THIS_ BOOL fActivate) PURE;
    STDMETHOD(ResizeBorder) (THIS_ __in LPCRECT lprectBorder, LPOLEINPLACEUIWINDOW lpUIWindow, BOOL fFrameWindow) PURE;          
    STDMETHOD(EnableModeless) (THIS_ BOOL fEnable) PURE;
};
typedef         IOleInPlaceActiveObject FAR* LPOLEINPLACEACTIVEOBJECT;



#undef  INTERFACE
#define INTERFACE   IOleInPlaceUIWindow

DECLARE_INTERFACE_(IOleInPlaceUIWindow, IOleWindow)
{ 
   // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND FAR* lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IOleInPlaceUIWindow methods ***
    STDMETHOD(GetBorder) (THIS_ __out LPRECT lprectBorder) PURE;
    STDMETHOD(RequestBorderSpace) (THIS_ __in LPCBORDERWIDTHS lpborderwidths) PURE;
    STDMETHOD(SetBorderSpace) (THIS_ __in LPCBORDERWIDTHS lpborderwidths) PURE;
    STDMETHOD(SetActiveObject) (THIS_ LPOLEINPLACEACTIVEOBJECT lpActiveObject,
                        LPCSTR lpszObjName) PURE; 
};
typedef     IOleInPlaceUIWindow FAR* LPOLEINPLACEUIWINDOW;



#undef  INTERFACE
#define INTERFACE   IOleInPlaceFrame

DECLARE_INTERFACE_(IOleInPlaceFrame, IOleInPlaceUIWindow)
{ 
   // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND FAR* lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IOleInPlaceUIWindow methods ***
    STDMETHOD(GetBorder) (THIS_ __out LPRECT lprectBorder) PURE;
    STDMETHOD(RequestBorderSpace) (THIS_ __in LPCBORDERWIDTHS lpborderwidths) PURE;
    STDMETHOD(SetBorderSpace) (THIS_ __in LPCBORDERWIDTHS lpborderwidths) PURE;
    STDMETHOD(SetActiveObject) (THIS_ LPOLEINPLACEACTIVEOBJECT lpActiveObject,
                    LPCSTR lpszObjName) PURE; 
    
    
    // *** IOleInPlaceFrame methods ***
    STDMETHOD(InsertMenus) (THIS_ HMENU hmenuShared, __in __out LPOLEMENUGROUPWIDTHS lpMenuWidths) PURE;
    STDMETHOD(SetMenu) (THIS_ HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject) PURE;
    STDMETHOD(RemoveMenus) (THIS_ HMENU hmenuShared) PURE;
    STDMETHOD(SetStatusText) (THIS_ LPCSTR lpszStatusText) PURE;    
    STDMETHOD(EnableModeless) (THIS_ BOOL fEnable) PURE;
    STDMETHOD(TranslateAccelerator) (THIS_ LPMSG lpmsg, WORD wID) PURE;
};
typedef     IOleInPlaceFrame FAR* LPOLEINPLACEFRAME;


#undef  INTERFACE
#define INTERFACE   IOleInPlaceSite

DECLARE_INTERFACE_(IOleInPlaceSite, IOleWindow)
{ 
   // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IOleWindow methods ***
    STDMETHOD(GetWindow) (THIS_ HWND FAR* lphwnd) PURE;
    STDMETHOD(ContextSensitiveHelp) (THIS_ BOOL fEnterMode) PURE;

    // *** IOleInPlaceSite methods ***
    STDMETHOD(CanInPlaceActivate) (THIS) PURE;
    STDMETHOD(OnInPlaceActivate) (THIS) PURE;
    STDMETHOD(OnUIActivate) (THIS) PURE;    
    STDMETHOD(GetWindowContext) (THIS_ LPOLEINPLACEFRAME FAR* lplpFrame,
                        LPOLEINPLACEUIWINDOW FAR* lplpDoc,
                        __out LPRECT lprcPosRect,
                        __out LPRECT lprcClipRect,
                        __out LPOLEINPLACEFRAMEINFO lpFrameInfo) PURE;
    STDMETHOD(Scroll) (THIS_ SIZE scrollExtent) PURE;       
    STDMETHOD(OnUIDeactivate) (THIS_ BOOL fUndoable) PURE;      
    STDMETHOD(OnInPlaceDeactivate) (THIS) PURE;
    STDMETHOD(DiscardUndoState) (THIS) PURE;
    STDMETHOD(DeactivateAndUndo) (THIS) PURE;
    STDMETHOD(OnPosRectChange) (THIS_ __in LPCRECT lprcPosRect) PURE; 
};
typedef         IOleInPlaceSite FAR* LPOLEINPLACESITE;



/****** OLE API Prototypes ************************************************/

STDAPI_(DWORD) OleBuildVersion( VOID );

/* helper functions */
STDAPI ReadClassStg(LPSTORAGE pStg, CLSID FAR* pclsid);
STDAPI WriteClassStg(LPSTORAGE pStg, REFCLSID rclsid);
STDAPI ReadClassStm(LPSTREAM pStm, CLSID FAR* pclsid);
STDAPI WriteClassStm(LPSTREAM pStm, REFCLSID rclsid);
STDAPI WriteFmtUserTypeStg (LPSTORAGE pstg, CLIPFORMAT cf, LPSTR lpszUserType);
STDAPI ReadFmtUserTypeStg (LPSTORAGE pstg, CLIPFORMAT FAR* pcf, LPSTR FAR* lplpszUserType);


/* init/term */

STDAPI OleInitialize(LPMALLOC pMalloc);
STDAPI_(void) OleUninitialize(void);


/* APIs to query whether (Embedded/Linked) object can be created from 
   the data object */

STDAPI  OleQueryLinkFromData(LPDATAOBJECT pSrcDataObject);
STDAPI  OleQueryCreateFromData(LPDATAOBJECT pSrcDataObject);
                    

/* Object creation APIs */

STDAPI  OleCreate(REFCLSID rclsid, REFIID riid, DWORD renderopt, 
                __in LPFORMATETC pFormatEtc, LPOLECLIENTSITE pClientSite, 
                LPSTORAGE pStg, LPVOID FAR* ppvObj); 

STDAPI  OleCreateFromData(LPDATAOBJECT pSrcDataObj, REFIID riid, 
                DWORD renderopt, __in LPFORMATETC pFormatEtc, 
                LPOLECLIENTSITE pClientSite, LPSTORAGE pStg, 
                LPVOID FAR* ppvObj);

STDAPI  OleCreateLinkFromData(LPDATAOBJECT pSrcDataObj, REFIID riid, 
                DWORD renderopt, __in LPFORMATETC pFormatEtc, 
                LPOLECLIENTSITE pClientSite, LPSTORAGE pStg, 
                LPVOID FAR* ppvObj);

STDAPI  OleCreateStaticFromData(LPDATAOBJECT pSrcDataObj, REFIID iid, 
                DWORD renderopt, __in LPFORMATETC pFormatEtc, 
                LPOLECLIENTSITE pClientSite, LPSTORAGE pStg, 
                LPVOID FAR* ppvObj);    

                
STDAPI  OleCreateLink(LPMONIKER pmkLinkSrc, REFIID riid, 
            DWORD renderopt, __in LPFORMATETC lpFormatEtc, 
            LPOLECLIENTSITE pClientSite, LPSTORAGE pStg, LPVOID FAR* ppvObj);

STDAPI  OleCreateLinkToFile(LPCSTR lpszFileName, REFIID riid, 
            DWORD renderopt, __in LPFORMATETC lpFormatEtc, 
            LPOLECLIENTSITE pClientSite, LPSTORAGE pStg, LPVOID FAR* ppvObj);
            
STDAPI  OleCreateFromFile(REFCLSID rclsid, LPCSTR lpszFileName, REFIID riid, 
            DWORD renderopt, __in LPFORMATETC lpFormatEtc, 
            LPOLECLIENTSITE pClientSite, LPSTORAGE pStg, LPVOID FAR* ppvObj);

STDAPI  OleLoad(LPSTORAGE pStg, REFIID riid, LPOLECLIENTSITE pClientSite, 
            LPVOID FAR* ppvObj);
            
STDAPI  OleSave(LPPERSISTSTORAGE pPS, LPSTORAGE pStg, BOOL fSameAsLoad);

STDAPI  OleLoadFromStream( LPSTREAM pStm, REFIID iidInterface, LPVOID FAR* ppvObj);
STDAPI  OleSaveToStream( LPPERSISTSTREAM pPStm, LPSTREAM pStm );


STDAPI  OleSetContainedObject(LPUNKNOWN pUnknown, BOOL fContained);
STDAPI  OleNoteObjectVisible(LPUNKNOWN pUnknown, BOOL fVisible);


/* Drag/Drop APIs */

STDAPI  RegisterDragDrop(HWND hwnd, LPDROPTARGET pDropTarget);
STDAPI  RevokeDragDrop(HWND hwnd);
STDAPI  DoDragDrop(LPDATAOBJECT pDataObj, LPDROPSOURCE pDropSource,
            DWORD dwOKEffects, LPDWORD pdwEffect);

/* Clipboard APIs */

STDAPI  OleSetClipboard(LPDATAOBJECT pDataObj);
STDAPI  OleGetClipboard(LPDATAOBJECT FAR* ppDataObj);
STDAPI  OleFlushClipboard(void);
STDAPI  OleIsCurrentClipboard(LPDATAOBJECT pDataObj);


/* InPlace Editing APIs */

STDAPI_(HOLEMENU)   OleCreateMenuDescriptor (HMENU hmenuCombined, 
                                __in LPOLEMENUGROUPWIDTHS lpMenuWidths);
STDAPI              OleSetMenuDescriptor (HOLEMENU holemenu, HWND hwndFrame,
                                HWND hwndActiveObject,
                                LPOLEINPLACEFRAME lpFrame,
                                LPOLEINPLACEACTIVEOBJECT lpActiveObj);
STDAPI              OleDestroyMenuDescriptor (HOLEMENU holemenu);

STDAPI              OleTranslateAccelerator (LPOLEINPLACEFRAME lpFrame, 
                            LPOLEINPLACEFRAMEINFO lpFrameInfo, LPMSG lpmsg);
                                
                                    
/* Helper APIs */
STDAPI_(HANDLE) OleDuplicateData (HANDLE hSrc, CLIPFORMAT cfFormat, 
                        UINT uiFlags);

STDAPI          OleDraw (LPUNKNOWN pUnknown, DWORD dwAspect, HDC hdcDraw, 
                    __in LPCRECT lprcBounds); 
                        
STDAPI          OleRun(LPUNKNOWN pUnknown);
STDAPI_(BOOL)   OleIsRunning(LPOLEOBJECT pObject);
STDAPI          OleLockRunning(LPUNKNOWN pUnknown, BOOL fLock, BOOL fLastUnlockCloses);

STDAPI_(void)   ReleaseStgMedium(LPSTGMEDIUM);
STDAPI          CreateOleAdviseHolder(LPOLEADVISEHOLDER FAR* ppOAHolder);

STDAPI          OleCreateDefaultHandler(REFCLSID clsid, LPUNKNOWN pUnkOuter,
                    REFIID riid, LPVOID FAR* lplpObj);

STDAPI          OleCreateEmbeddingHelper(REFCLSID clsid, LPUNKNOWN pUnkOuter,
                    DWORD flags, LPCLASSFACTORY pCF,
					REFIID riid, LPVOID FAR* lplpObj);
					
STDAPI_(BOOL)	IsAccelerator(HACCEL hAccel, int cAccelEntries, LPMSG lpMsg, 
					WORD FAR* lpwCmd);

					
/* Icon extraction Helper APIs */
					
STDAPI_(HGLOBAL) OleGetIconOfFile(LPSTR lpszPath, BOOL fUseFileAsLabel);

STDAPI_(HGLOBAL) OleGetIconOfClass(REFCLSID rclsid,	LPSTR lpszLabel, 
					BOOL fUseTypeAsLabel);

STDAPI_(HGLOBAL) OleMetafilePictFromIconAndLabel(HICON hIcon, LPSTR lpszLabel,
					LPSTR lpszSourceFile, UINT iIconIndex);


					
/* Registration Database Helper APIs */

STDAPI 			OleRegGetUserType (REFCLSID clsid, DWORD dwFormOfType,
					LPSTR FAR* pszUserType);

STDAPI 			OleRegGetMiscStatus	(REFCLSID clsid, DWORD dwAspect,
					DWORD FAR* pdwStatus);

STDAPI 			OleRegEnumFormatEtc	(REFCLSID clsid, DWORD dwDirection,
					LPENUMFORMATETC FAR* ppenum);

STDAPI 			OleRegEnumVerbs	(REFCLSID clsid, LPENUMOLEVERB FAR* ppenum);



/* OLE 1.0 conversion APIS */

STDAPI OleConvertIStorageToOLESTREAM
    (LPSTORAGE			pstg,
	 LPOLESTREAM		polestm);

STDAPI OleConvertOLESTREAMToIStorage
    (LPOLESTREAM                polestm,
     LPSTORAGE                  pstg,
     const DVTARGETDEVICE FAR*  ptd);

STDAPI OleConvertIStorageToOLESTREAMEx
    (LPSTORAGE			pstg,
									// Presentation data to OLESTREAM
	 CLIPFORMAT			cfFormat,	//		format
	 LONG				lWidth,		//		width
	 LONG				lHeight,	//		height
	 DWORD				dwSize,		//		size in bytes
     __in LPSTGMEDIUM		pmedium,	//		bits
	 LPOLESTREAM		polestm);

STDAPI OleConvertOLESTREAMToIStorageEx
    (LPOLESTREAM		polestm,
	 LPSTORAGE			pstg,
									// Presentation data from OLESTREAM
	 CLIPFORMAT FAR*	pcfFormat,	//		format
	 LONG FAR*			plwWidth,	//		width
	 LONG FAR*			plHeight,	//		height
	 DWORD FAR*			pdwSize,	//		size in bytes
	 __in LPSTGMEDIUM		pmedium);	//		bits



/* Storage Utility APIs */
STDAPI GetHGlobalFromILockBytes (LPLOCKBYTES plkbyt, HGLOBAL FAR* phglobal);
STDAPI CreateILockBytesOnHGlobal (HGLOBAL hGlobal, BOOL fDeleteOnRelease,
                                    LPLOCKBYTES FAR* pplkbyt);

STDAPI GetHGlobalFromStream (LPSTREAM pstm, HGLOBAL FAR* phglobal);
STDAPI CreateStreamOnHGlobal (HGLOBAL hGlobal, BOOL fDeleteOnRelease,
                                LPSTREAM FAR* ppstm);


/* ConvertTo APIS */

STDAPI OleDoAutoConvert(LPSTORAGE pStg, LPCLSID pClsidNew);
STDAPI OleGetAutoConvert(REFCLSID clsidOld, LPCLSID pClsidNew);
STDAPI OleSetAutoConvert(REFCLSID clsidOld, REFCLSID clsidNew);
STDAPI GetConvertStg(LPSTORAGE pStg);
STDAPI SetConvertStg(LPSTORAGE pStg, BOOL fConvert);


#endif // _OLE2_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\thc\thpp\moniker.h ===
/*****************************************************************************\
*                                                                             *
* moniker.h - 	Moniker and related interfaces and APIs						  *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/


#if !defined( _MONIKER_H_ )
#define _MONIKER_H_

#define MK_E_CONNECTMANUALLY        MK_E_FIRST
#define MK_E_EXCEEDEDDEADLINE       (MK_E_FIRST + 1)
#define MK_E_NEEDGENERIC            (MK_E_FIRST + 2)
#define MK_E_UNAVAILABLE            (MK_E_FIRST + 3)
#define MK_E_SYNTAX                 (MK_E_FIRST + 4)
#define MK_E_NOOBJECT               (MK_E_FIRST + 5)
#define MK_E_INVALIDEXTENSION       (MK_E_FIRST + 6)
#define MK_E_INTERMEDIATEINTERFACENOTSUPPORTED (MK_E_FIRST + 7)
#define MK_E_NOTBINDABLE            (MK_E_FIRST + 8)
#define MK_E_NOTBOUND               (MK_E_FIRST + 9)
                            // called IBindCtx->RevokeObjectBound for an
                            // object which was not bound
#define MK_E_CANTOPENFILE           (MK_E_FIRST + 10)
#define MK_E_MUSTBOTHERUSER         (MK_E_FIRST + 11)
#define MK_E_NOINVERSE              (MK_E_FIRST + 12)
#define MK_E_NOSTORAGE              (MK_E_FIRST + 13)
#define MK_E_NOPREFIX               (MK_E_FIRST + 14)


// reserved                     MK_S_FIRST
// reserved                     (MK_S_FIRST + 1)
#define MK_S_REDUCED_TO_SELF    (MK_S_FIRST + 2)
// reserved                     (MK_S_FIRST + 3)
#define MK_S_ME                 (MK_S_FIRST + 4)
#define MK_S_HIM                (MK_S_FIRST + 5)
#define MK_S_US                 (MK_S_FIRST + 6)
#define MK_S_MONIKERALREADYREGISTERED (MK_S_FIRST + 7)


// bind options; variable sized
typedef struct FARSTRUCT tagBIND_OPTS
{
    DWORD       cbStruct;       //  sizeof(BIND_OPTS)
    DWORD       grfFlags;
    DWORD       grfMode;
    DWORD       dwTickCountDeadline;
} BIND_OPTS, FAR* LPBIND_OPTS;


// bind flags; controls binding; stored in bind options above
typedef enum
{
    BIND_MAYBOTHERUSER = 1,
    BIND_JUSTTESTEXISTENCE = 2
} BIND_FLAGS;


// system moniker types; returned from IsSystemMoniker.
typedef enum tagMKSYS
{
    MKSYS_NONE = 0,
    MKSYS_GENERICCOMPOSITE = 1,
    MKSYS_FILEMONIKER = 2,
    MKSYS_ANTIMONIKER = 3,
    MKSYS_ITEMMONIKER = 4,
    MKSYS_POINTERMONIKER = 5
}MKSYS;


// bit wise enum to control how much reduction takes place.
typedef enum tagMKREDUCE
{
    MKRREDUCE_ONE           =   3<<16,
    MKRREDUCE_TOUSER        =   2<<16,
    MKRREDUCE_THROUGHUSER   =   1<<16,
    MKRREDUCE_ALL           =   0
} MKRREDUCE;


#if defined(__cplusplus)
interface IEnumMoniker;
interface IRunningObjectTable;
#else 
typedef interface IEnumMoniker IEnumMoniker;
typedef interface IRunningObjectTable IRunningObjectTable;
#endif

typedef       IEnumMoniker FAR* LPENUMMONIKER;
typedef         IRunningObjectTable FAR* LPRUNNINGOBJECTTABLE;



#undef  INTERFACE
#define INTERFACE   IBindCtx

DECLARE_INTERFACE_(IBindCtx, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IBindCtx methods ***
    STDMETHOD(RegisterObjectBound) (THIS_ LPUNKNOWN punk) PURE;
    STDMETHOD(RevokeObjectBound) (THIS_ LPUNKNOWN punk) PURE;
    STDMETHOD(ReleaseBoundObjects) (THIS) PURE;
    
    STDMETHOD(SetBindOptions) (THIS_ __in LPBIND_OPTS pbindopts) PURE;
    STDMETHOD(GetBindOptions) (THIS_ __out LPBIND_OPTS pbindopts) PURE;
    STDMETHOD(GetRunningObjectTable) (THIS_ LPRUNNINGOBJECTTABLE  FAR*
        pprot) PURE;
    STDMETHOD(RegisterObjectParam) (THIS_ LPSTR lpszKey, LPUNKNOWN punk) PURE;
    STDMETHOD(GetObjectParam) (THIS_ LPSTR lpszKey, LPUNKNOWN FAR* ppunk) PURE;
    STDMETHOD(EnumObjectParam) (THIS_ LPENUMSTRING FAR* ppenum) PURE;
    STDMETHOD(RevokeObjectParam) (THIS_ LPSTR lpszKey) PURE;
};
typedef             IBindCtx FAR* LPBC;
typedef         IBindCtx FAR* LPBINDCTX;



#undef  INTERFACE
#define INTERFACE   IMoniker

DECLARE_INTERFACE_(IMoniker, IPersistStream)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IPersist methods ***
    STDMETHOD(GetClassID) (THIS_ LPCLSID lpClassID) PURE;

    // *** IPersistStream methods ***
    STDMETHOD(IsDirty) (THIS) PURE;
    STDMETHOD(Load) (THIS_ LPSTREAM pStm) PURE;
    STDMETHOD(Save) (THIS_ LPSTREAM pStm,
                    BOOL fClearDirty) PURE;
    STDMETHOD(GetSizeMax) (THIS_ ULARGE_INTEGER FAR * pcbSize) PURE;

    // *** IMoniker methods ***
    STDMETHOD(BindToObject) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
        REFIID riidResult, LPVOID FAR* ppvResult) PURE;
    STDMETHOD(BindToStorage) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
        REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD(Reduce) (THIS_ LPBC pbc, DWORD dwReduceHowFar, LPMONIKER FAR*
        ppmkToLeft, LPMONIKER FAR * ppmkReduced) PURE;
    STDMETHOD(ComposeWith) (THIS_ LPMONIKER pmkRight, BOOL fOnlyIfNotGeneric,
        LPMONIKER FAR* ppmkComposite) PURE;
    STDMETHOD(Enum) (THIS_ BOOL fForward, LPENUMMONIKER FAR* ppenumMoniker)
        PURE;
    STDMETHOD(IsEqual) (THIS_ LPMONIKER pmkOtherMoniker) PURE;
    STDMETHOD(Hash) (THIS_ LPDWORD pdwHash) PURE;
    STDMETHOD(IsRunning) (THIS_ LPBC pbc, LPMONIKER pmkToLeft, LPMONIKER
        pmkNewlyRunning) PURE;
    STDMETHOD(GetTimeOfLastChange) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
        FILETIME FAR __out * pfiletime) PURE;
    STDMETHOD(Inverse) (THIS_ LPMONIKER FAR* ppmk) PURE;
    STDMETHOD(CommonPrefixWith) (THIS_ LPMONIKER pmkOther, LPMONIKER FAR*
        ppmkPrefix) PURE;
    STDMETHOD(RelativePathTo) (THIS_ LPMONIKER pmkOther, LPMONIKER FAR*
        ppmkRelPath) PURE;
    STDMETHOD(GetDisplayName) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
        LPSTR FAR* lplpszDisplayName) PURE;
    STDMETHOD(ParseDisplayName) (THIS_ LPBC pbc, LPMONIKER pmkToLeft,
        LPSTR lpszDisplayName, ULONG FAR* pchEaten,
        LPMONIKER FAR* ppmkOut) PURE;
    STDMETHOD(IsSystemMoniker) (THIS_ LPDWORD pdwMksys) PURE;
};
typedef         IMoniker FAR* LPMONIKER;


//  IRunningObjectTable::Register flags
#define ROTFLAGS_REGISTRATIONKEEPSALIVE 1

#undef  INTERFACE
#define INTERFACE   IRunningObjectTable

DECLARE_INTERFACE_(IRunningObjectTable, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IRunningObjectTable methods ***
    STDMETHOD(Register) (THIS_ DWORD grfFlags, LPUNKNOWN punkObject, 
        LPMONIKER pmkObjectName, DWORD FAR * pdwRegister) PURE;
    STDMETHOD(Revoke) (THIS_ DWORD dwRegister) PURE;
    STDMETHOD(IsRunning) (THIS_ LPMONIKER pmkObjectName) PURE;
    STDMETHOD(GetObject) (THIS_ LPMONIKER pmkObjectName,
        LPUNKNOWN FAR* ppunkObject) PURE;
    STDMETHOD(NoteChangeTime) (THIS_ DWORD dwRegister, FILETIME FAR __in * pfiletime) PURE;
    STDMETHOD(GetTimeOfLastChange) (THIS_ LPMONIKER pmkObjectName, FILETIME FAR __out * pfiletime) PURE;
    STDMETHOD(EnumRunning) (THIS_ LPENUMMONIKER FAR * ppenumMoniker ) PURE;
};
typedef         IRunningObjectTable FAR* LPRUNNINGOBJECTTABLE;



#undef  INTERFACE
#define INTERFACE   IEnumMoniker

DECLARE_INTERFACE_(IEnumMoniker, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IEnumOleDataObject methods ***
    STDMETHOD(Next) (THIS_ ULONG celt, LPMONIKER FAR* rgelt, ULONG FAR* pceltFetched) PURE;
    STDMETHOD(Skip) (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset) (THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumMoniker FAR* FAR* ppenm) PURE;
};
typedef       IEnumMoniker FAR* LPENUMMONIKER;




STDAPI  BindMoniker(LPMONIKER pmk, DWORD grfOpt, REFIID iidResult, LPVOID FAR* ppvResult);
STDAPI  MkParseDisplayName(LPBC pbc, LPSTR szUserName, 
                ULONG FAR * pchEaten, LPMONIKER FAR * ppmk);
STDAPI  MonikerRelativePathTo(LPMONIKER pmkSrc, LPMONIKER pmkDest, LPMONIKER
                FAR* ppmkRelPath, BOOL fCalledFromMethod);
STDAPI  MonikerCommonPrefixWith(LPMONIKER pmkThis, LPMONIKER pmkOther,
                LPMONIKER FAR* ppmkCommon);
STDAPI  CreateBindCtx(DWORD reserved, LPBC FAR* ppbc);
STDAPI  CreateGenericComposite(LPMONIKER pmkFirst, LPMONIKER pmkRest,
    LPMONIKER FAR* ppmkComposite);
STDAPI  GetClassFile (LPCSTR szFilename, CLSID FAR* pclsid);

STDAPI  CreateFileMoniker(LPSTR lpszPathName, LPMONIKER FAR* ppmk);
STDAPI  CreateItemMoniker(LPSTR lpszDelim, LPSTR lpszItem,
    LPMONIKER FAR* ppmk);
STDAPI  CreateAntiMoniker(LPMONIKER FAR* ppmk);
STDAPI  CreatePointerMoniker(LPUNKNOWN punk, LPMONIKER FAR* ppmk);

STDAPI  GetRunningObjectTable( DWORD reserved, LPRUNNINGOBJECTTABLE FAR* pprot);


#endif  // _MONIKER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\thc\thpp\scode.h ===
/*****************************************************************************\
*                                                                             *
* scode.h - 	Defines standard status code services.						  *
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/


#ifndef __SCODE_H__
#define __SCODE_H__

//
// SCODE
//

typedef long SCODE;
typedef SCODE *PSCODE;
typedef void FAR * HRESULT;
#define NOERROR 0

//
//  Status values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +-+---------------------+-------+-------------------------------+
//  |S|       Context       | Facil |               Code            |
//  +-+---------------------+-------+-------------------------------+
//
//  where
//
//      S - is the severity code
//
//          0 - Success
//          1 - Error
//
//      Context - context info
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//

//
// Severity values
//

#define SEVERITY_SUCCESS    0
#define SEVERITY_ERROR      1



#define SUCCEEDED(Status) ((SCODE)(Status) >= 0)

#define FAILED(Status) ((SCODE)(Status)<0)


//
// Return the code
//

#define SCODE_CODE(sc)      ((sc) & 0xFFFF)

//
//  Return the facility
//

#define SCODE_FACILITY(sc)  (((sc) >> 16) & 0x1fff)

//
//  Return the severity
//

#define SCODE_SEVERITY(sc)  (((sc) >> 31) & 0x1)

//
// Create an SCODE value from component pieces
//

#define MAKE_SCODE(sev,fac,code) \
    ((SCODE) (((unsigned long)(sev)<<31) | ((unsigned long)(fac)<<16) | ((unsigned long)(code))) )



// --------------------- Functions ---------------------------------------

#define GetScode(hr)        ((SCODE)(hr) & 0x800FFFFF)
#define ResultFromScode(sc) ((HRESULT)((SCODE)(sc) & 0x800FFFFF))

STDAPI PropagateResult(HRESULT hrPrev, SCODE scNew);


// -------------------------- Facility definitions -------------------------

#define FACILITY_NULL       0x0000 // generally useful errors ([SE]_*)
#define FACILITY_RPC            0x0001 // remote procedure call errors (RPC_E_*)
#define FACILITY_DISPATCH   0x0002 // late binding dispatch errors
#define FACILITY_STORAGE   0x0003 // storage errors (STG_E_*)
#define FACILITY_ITF            0x0004 // interface-specific errors



#define S_OK                0L
#define S_FALSE             MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_NULL, 1)



// --------------------- FACILITY_NULL errors ------------------------------

#define E_UNEXPECTED        MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 0xffff)
                            // relatively catastrophic failure

#define E_NOTIMPL           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 1)
                            // not implemented

#define E_OUTOFMEMORY       MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 2)
                            // ran out of memory

#define E_INVALIDARG        MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 3)
                            // one or more arguments are invalid

#define E_NOINTERFACE       MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 4)
                            // no such interface supported


#define E_POINTER           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 5)
                            // invalid pointer

#define E_HANDLE            MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 6)
                            // invalid handle

#define E_ABORT             MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 7)
                            // operation aborted

#define E_FAIL              MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 8)
                            // unspecified error


#define E_ACCESSDENIED      MAKE_SCODE(SEVERITY_ERROR,   FACILITY_NULL, 9)
                            // general access denied error


// ----------------- FACILITY_ITF errors used by OLE ---------------------
//
// By convention, OLE interfaces divide the FACILITY_ITF range of errors
// into nonoverlapping subranges.  If an OLE interface returns a FACILITY_ITF 
// scode, it must be from the range associated with that interface or from
// the shared range: OLE_E_FIRST...OLE_E_LAST.
//
// The ranges, their associated interfaces, and the header file that defines
// the actual scodes are given below.
// 

// Generic OLE errors that may be returned by many interfaces
#define OLE_E_FIRST MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0000)
#define OLE_E_LAST  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x00FF)
#define OLE_S_FIRST MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0000)
#define OLE_S_LAST  MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x00FF)
// interfaces: all
// file: ole2.h


#define DRAGDROP_E_FIRST    MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0100)
#define DRAGDROP_E_LAST     MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x010F)
#define DRAGDROP_S_FIRST    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0100)
#define DRAGDROP_S_LAST     MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x010F)
// interfaces: IDropSource, IDropTarget
// file: ole2.h

#define CLASSFACTORY_E_FIRST MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0110)
#define CLASSFACTORY_E_LAST  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x011F)
#define CLASSFACTORY_S_FIRST MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0110)
#define CLASSFACTORY_S_LAST  MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x011F)
// interfaces: IClassFactory
// file:

#define MARSHAL_E_FIRST MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0120)
#define MARSHAL_E_LAST  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x012F)
#define MARSHAL_S_FIRST MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0120)
#define MARSHAL_S_LAST  MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x012F)
// interfaces: IMarshal, IStdMarshalInfo, marshal APIs
// file:

#define DATA_E_FIRST    MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0130)
#define DATA_E_LAST     MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x013F)
#define DATA_S_FIRST    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0130)
#define DATA_S_LAST     MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x013F)
// interfaces: IDataObject
// file: dvobj.h

#define VIEW_E_FIRST    MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0140)
#define VIEW_E_LAST     MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x014F)
#define VIEW_S_FIRST    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0140)
#define VIEW_S_LAST     MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x014F)
// interfaces: IViewObject
// file: dvobj.h

#define REGDB_E_FIRST   MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0150)
#define REGDB_E_LAST    MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x015F)
#define REGDB_S_FIRST   MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0150)
#define REGDB_S_LAST    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x015F)
// API: reg.dat manipulation
// file: 


// range 160 - 16F reserved

#define CACHE_E_FIRST   MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0170) 
#define CACHE_E_LAST    MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x017F)
#define CACHE_S_FIRST   MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0170)
#define CACHE_S_LAST    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x017F)
// interfaces: IOleCache
// file:

#define OLEOBJ_E_FIRST  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0180)
#define OLEOBJ_E_LAST   MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x018F)
#define OLEOBJ_S_FIRST  MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0180)
#define OLEOBJ_S_LAST   MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x018F)
// interfaces: IOleObject
// file:

#define CLIENTSITE_E_FIRST  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x0190) 
#define CLIENTSITE_E_LAST  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x019F)
#define CLIENTSITE_S_FIRST MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x0190)
#define CLIENTSITE_S_LAST   MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x019F)
// interfaces: IOleClientSite
// file:

#define INPLACE_E_FIRST MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01A0)
#define INPLACE_E_LAST  MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01AF)
#define INPLACE_S_FIRST MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01A0)
#define INPLACE_S_LAST  MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01AF)
// interfaces: IOleWindow, IOleInPlaceObject, IOleInPlaceActiveObject,
//                 IOleInPlaceUIWindow, IOleInPlaceFrame, IOleInPlaceSite
// file:

#define ENUM_E_FIRST        MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01B0)
#define ENUM_E_LAST     MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01BF)
#define ENUM_S_FIRST    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01B0)
#define ENUM_S_LAST     MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01BF)
// interfaces: IEnum*
// file:

#define CONVERT10_E_FIRST   MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01C0)
#define CONVERT10_E_LAST   MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01CF)
#define CONVERT10_S_FIRST  MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01C0)
#define CONVERT10_S_LAST   MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01CF)
// API: OleConvertOLESTREAMToIStorage, OleConvertIStorageToOLESTREAM
// file:


#define CLIPBRD_E_FIRST     MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01D0)
#define CLIPBRD_E_LAST      MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01DF)
#define CLIPBRD_S_FIRST     MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01D0)
#define CLIPBRD_S_LAST      MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01DF)
// interfaces: OleSetClipboard, OleGetClipboard, OleFlushClipboard
// file: ole2.h

#define MK_E_FIRST      MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01E0)
#define MK_E_LAST           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01EF)
#define MK_S_FIRST          MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01E0)
#define MK_S_LAST           MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01EF)
// interfaces: IMoniker, IBindCtx, IRunningObjectTable, IParseDisplayName,
//             IOleContainer, IOleItemContainer, IOleLink
// file: moniker.h


#define CO_E_FIRST      MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01F0)
#define CO_E_LAST           MAKE_SCODE(SEVERITY_ERROR,   FACILITY_ITF, 0x01FF)
#define CO_S_FIRST          MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01F0)
#define CO_S_LAST           MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_ITF, 0x01FF)
// all Co* API
// file: compobj.h


// range 200 - ffff for new error codes



#endif      // ifndef __SCODE_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\thc\thpp\storage.h ===
/*****************************************************************************\
*                                                                             *
* storage.h -   Definitions for the strutured storage system
*                                                                             *
*               OLE Version 2.0                                               *
*                                                                             *
*               Copyright (c) 1992-1993, Microsoft Corp. All rights reserved. *
*                                                                             *
\*****************************************************************************/


#if !defined( _STORAGE_H_ )
#define _STORAGE_H_


#include <compobj.h>


/****** Storage Error Codes *************************************************/

/* DOS-based error codes */
#define STG_E_INVALIDFUNCTION \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x01)

#define STG_E_FILENOTFOUND \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x02)

#define STG_E_PATHNOTFOUND \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x03)

#define STG_E_TOOMANYOPENFILES \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x04)

#define STG_E_ACCESSDENIED \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x05)

#define STG_E_INVALIDHANDLE \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x06)

#define STG_E_INSUFFICIENTMEMORY \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x08)

#define STG_E_INVALIDPOINTER \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x09)

#define STG_E_NOMOREFILES \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x12)

#define STG_E_DISKISWRITEPROTECTED \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x13)

#define STG_E_SEEKERROR \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x19)

#define STG_E_WRITEFAULT \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x1d)

#define STG_E_READFAULT \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x1e)

#define STG_E_SHAREVIOLATION \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x20)

#define STG_E_LOCKVIOLATION \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x21)

#define STG_E_FILEALREADYEXISTS \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x50)

#define STG_E_INVALIDPARAMETER \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x57)

#define STG_E_MEDIUMFULL \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x70)

#define STG_E_ABNORMALAPIEXIT \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0xfa)

#define STG_E_INVALIDHEADER \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0xfb)

#define STG_E_INVALIDNAME \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0xfc)

#define STG_E_UNKNOWN \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0xfd)

#define STG_E_UNIMPLEMENTEDFUNCTION\
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0xfe)

#define STG_E_INVALIDFLAG \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0xff)

/* Standard storage error codes */
#define STG_E_INUSE \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x100)

#define STG_E_NOTCURRENT \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x101)

#define STG_E_REVERTED \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x102)

#define STG_E_CANTSAVE \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x103)

#define STG_E_OLDFORMAT \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x104)
	
#define STG_E_OLDDLL \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x105)

#define STG_E_SHAREREQUIRED \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x106)

#define STG_E_NOTFILEBASEDSTORAGE \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x107)

#define STG_E_EXTANTMARSHALLINGS \
    MAKE_SCODE(SEVERITY_ERROR, FACILITY_STORAGE, 0x108)

/* Information returns */
#define STG_S_CONVERTED \
    MAKE_SCODE(SEVERITY_SUCCESS, FACILITY_STORAGE, 0x200)

/****** Storage types *******************************************************/

#if defined(_M_I286)
typedef char TCHAR;
#ifndef HUGEP
#define HUGEP _huge
#endif
#else
typedef char TCHAR;
#ifndef HUGEP
#define HUGEP
#endif
#endif

#define CWCSTORAGENAME 32

/* Storage instantiation modes */
#define STGM_DIRECT		0x00000000L
#define STGM_TRANSACTED		0x00010000L

#define STGM_READ		0x00000000L
#define STGM_WRITE		0x00000001L
#define STGM_READWRITE		0x00000002L

#define STGM_SHARE_DENY_NONE	0x00000040L
#define STGM_SHARE_DENY_READ	0x00000030L
#define STGM_SHARE_DENY_WRITE	0x00000020L
#define STGM_SHARE_EXCLUSIVE	0x00000010L

#define STGM_PRIORITY		0x00040000L
#define STGM_DELETEONRELEASE	0x04000000L

#define STGM_CREATE		0x00001000L
#define STGM_CONVERT		0x00020000L
#define STGM_FAILIFTHERE	0x00000000L

/* Storage commit types */
typedef enum tagSTGC
{
    STGC_DEFAULT = 0,
    STGC_OVERWRITE  = 1,
    STGC_ONLYIFCURRENT  = 2,
    STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE = 4
} STGC;

/* Stream name block definitions */
typedef char FAR * FAR *SNB;


#ifndef _WINDOWS_
#ifndef _FILETIME_
#define _FILETIME_
typedef struct FARSTRUCT tagFILETIME
{
    DWORD dwLowDateTime;
    DWORD dwHighDateTime;
} FILETIME;
#endif
#endif


/* Storage stat buffer */

typedef struct FARSTRUCT tagSTATSTG
{
    char FAR* pwcsName;
    DWORD type;
    ULARGE_INTEGER cbSize;
    FILETIME mtime;
    FILETIME ctime;
    FILETIME atime;
    DWORD grfMode;
    DWORD grfLocksSupported;
    CLSID clsid;
    DWORD grfStateBits;
    DWORD reserved;
} STATSTG;


/* Storage element types */
typedef enum tagSTGTY
{
    STGTY_STORAGE   = 1,
    STGTY_STREAM    = 2,
    STGTY_LOCKBYTES = 3,
    STGTY_PROPERTY  = 4
} STGTY;

typedef enum tagSTREAM_SEEK
{
    STREAM_SEEK_SET = 0,
    STREAM_SEEK_CUR = 1,
    STREAM_SEEK_END = 2
} STREAM_SEEK;

typedef enum tagLOCKTYPE
{
    LOCK_WRITE      = 1,
    LOCK_EXCLUSIVE  = 2,
    LOCK_ONLYONCE   = 4
} LOCKTYPE;

typedef enum tagSTGMOVE
{
    STGMOVE_MOVE    = 0,
    STGMOVE_COPY    = 1
} STGMOVE;

typedef enum tagSTATFLAG
{
    STATFLAG_DEFAULT = 0,
    STATFLAG_NONAME = 1
} STATFLAG;


/****** Storage Enumerators *************************************************/

#undef  INTERFACE
#define INTERFACE   IEnumSTATSTG

DECLARE_INTERFACE_(IEnumSTATSTG, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IENUMSTATSTG methods ***
    STDMETHOD(Next) (THIS_ ULONG celt, STATSTG FAR * rgelt, ULONG FAR *pceltFetched) PURE;
    STDMETHOD(Skip) (THIS_ ULONG celt) PURE;
    STDMETHOD(Reset) (THIS) PURE;
    STDMETHOD(Clone) (THIS_ IEnumSTATSTG FAR *FAR *ppenm) PURE;
};

typedef IEnumSTATSTG FAR* LPENUMSTATSTG;



/****** ILockBytes Interface ************************************************/

#undef  INTERFACE
#define INTERFACE   ILockBytes

DECLARE_INTERFACE_(ILockBytes, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** ILockBytes methods ***
    STDMETHOD(ReadAt) (THIS_ ULARGE_INTEGER ulOffset,
             VOID HUGEP *pv,
             ULONG cb,
             ULONG FAR *pcbRead) PURE;
    STDMETHOD(WriteAt) (THIS_ ULARGE_INTEGER ulOffset,
              VOID const HUGEP *pv,
              ULONG cb,
              ULONG FAR *pcbWritten) PURE;
    STDMETHOD(Flush) (THIS) PURE;
    STDMETHOD(SetSize) (THIS_ ULARGE_INTEGER cb) PURE;
    STDMETHOD(LockRegion) (THIS_ ULARGE_INTEGER libOffset,
                 ULARGE_INTEGER cb,
                 DWORD dwLockType) PURE;
    STDMETHOD(UnlockRegion) (THIS_ ULARGE_INTEGER libOffset,
                   ULARGE_INTEGER cb,
                 DWORD dwLockType) PURE;
    STDMETHOD(Stat) (THIS_ STATSTG FAR *pstatstg, DWORD grfStatFlag) PURE;
};

typedef ILockBytes FAR* LPLOCKBYTES;



/****** IStream Interface ***************************************************/


#undef  INTERFACE
#define INTERFACE   IStream

DECLARE_INTERFACE_(IStream, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IStream methods ***
    STDMETHOD(Read) (THIS_ VOID HUGEP *pv,
		     ULONG cb, ULONG FAR *pcbRead) PURE;
    STDMETHOD(Write) (THIS_ VOID const HUGEP *pv,
            ULONG cb,
            ULONG FAR *pcbWritten) PURE;
    STDMETHOD(Seek) (THIS_ LARGE_INTEGER dlibMove,
               DWORD dwOrigin,
               ULARGE_INTEGER FAR *plibNewPosition) PURE;
    STDMETHOD(SetSize) (THIS_ ULARGE_INTEGER libNewSize) PURE;
    STDMETHOD(CopyTo) (THIS_ IStream FAR *pstm,
             ULARGE_INTEGER cb,
             ULARGE_INTEGER FAR *pcbRead,
             ULARGE_INTEGER FAR *pcbWritten) PURE;
    STDMETHOD(Commit) (THIS_ DWORD grfCommitFlags) PURE;
    STDMETHOD(Revert) (THIS) PURE;
    STDMETHOD(LockRegion) (THIS_ ULARGE_INTEGER libOffset,
                 ULARGE_INTEGER cb,
                 DWORD dwLockType) PURE;
    STDMETHOD(UnlockRegion) (THIS_ ULARGE_INTEGER libOffset,
                 ULARGE_INTEGER cb,
                 DWORD dwLockType) PURE;
    STDMETHOD(Stat) (THIS_ STATSTG FAR *pstatstg, DWORD grfStatFlag) PURE;
    STDMETHOD(Clone)(THIS_ IStream FAR * FAR *ppstm) PURE;
};

typedef IStream FAR* LPSTREAM;



/****** IStorage Interface **************************************************/

#undef  INTERFACE
#define INTERFACE   IStorage

DECLARE_INTERFACE_(IStorage, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IStorage methods ***
    STDMETHOD(CreateStream) (THIS_ const char FAR* pwcsName,
                   DWORD grfMode,
                   DWORD reserved1,
                   DWORD reserved2,
                   IStream FAR *FAR *ppstm) PURE;
    STDMETHOD(OpenStream) (THIS_ const char FAR* pwcsName,
		 void FAR *reserved1,
                 DWORD grfMode,
                 DWORD reserved2,
                 IStream FAR *FAR *ppstm) PURE;
    STDMETHOD(CreateStorage) (THIS_ const char FAR* pwcsName,
                DWORD grfMode,
                DWORD reserved1,
                DWORD reserved2,
                IStorage FAR *FAR *ppstg) PURE;
    STDMETHOD(OpenStorage) (THIS_ const char FAR* pwcsName,
                  IStorage FAR *pstgPriority,
                  DWORD grfMode,
                  SNB snbExclude,
                  DWORD reserved,
                  IStorage FAR *FAR *ppstg) PURE;
    STDMETHOD(CopyTo) (THIS_ DWORD ciidExclude,
 		       IID const FAR *rgiidExclude,
 		       SNB snbExclude,
 		       IStorage FAR *pstgDest) PURE;
    STDMETHOD(MoveElementTo) (THIS_ char const FAR* lpszName,
    			      IStorage FAR *pstgDest,
                              char const FAR* lpszNewName,
                              DWORD grfFlags) PURE;
    STDMETHOD(Commit) (THIS_ DWORD grfCommitFlags) PURE;
    STDMETHOD(Revert) (THIS) PURE;
    STDMETHOD(EnumElements) (THIS_ DWORD reserved1,
                 void FAR *reserved2,
                 DWORD reserved3,
                 IEnumSTATSTG FAR *FAR *ppenm) PURE;
    STDMETHOD(DestroyElement) (THIS_ const char FAR* pwcsName) PURE;
    STDMETHOD(RenameElement) (THIS_ const char FAR* pwcsOldName,
                const char FAR* pwcsNewName) PURE;
    STDMETHOD(SetElementTimes) (THIS_ const char FAR *lpszName,
    			        FILETIME __in const FAR *pctime,
                                FILETIME __in const FAR *patime,
                                FILETIME __in const FAR *pmtime) PURE;
    STDMETHOD(SetClass) (THIS_ REFCLSID clsid) PURE;
    STDMETHOD(SetStateBits) (THIS_ DWORD grfStateBits, DWORD grfMask) PURE;
    STDMETHOD(Stat) (THIS_ STATSTG FAR *pstatstg, DWORD grfStatFlag) PURE;
};

typedef IStorage FAR* LPSTORAGE;



/****** IRootStorage Interface **********************************************/

#undef  INTERFACE
#define INTERFACE   IRootStorage

DECLARE_INTERFACE_(IRootStorage, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS)  PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IRootStorage methods ***
    STDMETHOD(SwitchToFile) (THIS_ LPSTR lpstrFile) PURE;
};

typedef IRootStorage FAR* LPROOTSTORAGE;



/****** Storage API Prototypes ********************************************/

STDAPI StgCreateDocfile(const char FAR* pwcsName,
            DWORD grfMode,
            DWORD reserved,
            IStorage FAR * FAR *ppstgOpen);
STDAPI StgCreateDocfileOnILockBytes(ILockBytes FAR *plkbyt,
                    DWORD grfMode,
                    DWORD reserved,
                    IStorage FAR * FAR *ppstgOpen);
STDAPI StgOpenStorage(const char FAR* pwcsName,
              IStorage FAR *pstgPriority,
              DWORD grfMode,
              SNB snbExclude,
              DWORD reserved,
              IStorage FAR * FAR *ppstgOpen);
STDAPI StgOpenStorageOnILockBytes(ILockBytes FAR *plkbyt,
                  IStorage FAR *pstgPriority,
                  DWORD grfMode,
                  SNB snbExclude,
                  DWORD reserved,
                  IStorage FAR * FAR *ppstgOpen);
STDAPI StgIsStorageFile(const char FAR* pwcsName);
STDAPI StgIsStorageILockBytes(ILockBytes FAR* plkbyt);

STDAPI StgSetTimes(char const FAR* lpszName,
		  FILETIME __in const FAR* pctime,
                  FILETIME __in const FAR* patime,
                  FILETIME __in const FAR* pmtime);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\thc\thpp\valid.h ===
#define IsValidPtrIn(pv,cb)  (!IsBadReadPtr ((pv),(cb)))
#define IsValidPtrOut(pv,cb) (!IsBadWritePtr((pv),(cb)))

STDAPI_(BOOL) IsValidInterface( void FAR* pv );
STDAPI_(BOOL) IsValidIid( REFIID riid );

 
#ifdef _DEBUG

//** POINTER IN validation macros:
#define VDATEPTRIN( pv, TYPE ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) \
    return (FnAssert(#pv,"Invalid in ptr", _szAssertFile, __LINE__),ResultFromScode(E_INVALIDARG))
#define GEN_VDATEPTRIN( pv, TYPE, retval ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) \
    return (FnAssert(#pv,"Invalid in ptr", _szAssertFile, __LINE__), retval)
#define VOID_VDATEPTRIN( pv, TYPE ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) {\
    FnAssert(#pv,"Invalid in ptr", _szAssertFile, __LINE__); return; }

//** POINTER OUT validation macros:
#define VDATEPTROUT( pv, TYPE ) if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
    return (FnAssert(#pv,"Invalid out ptr", _szAssertFile, __LINE__),ResultFromScode(E_INVALIDARG))
#define GEN_VDATEPTROUT( pv, TYPE, retval ) if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
    return (FnAssert(#pv,"Invalid out ptr", _szAssertFile, __LINE__), retval)

//** INTERFACE validation macro:
#define GEN_VDATEIFACE( pv, retval ) if (!IsValidInterface(pv)) \
    return (FnAssert(#pv,"Invalid interface", _szAssertFile, __LINE__), retval)
#define VDATEIFACE( pv ) if (!IsValidInterface(pv)) \
    return (FnAssert(#pv,"Invalid interface", _szAssertFile, __LINE__),ResultFromScode(E_INVALIDARG))
#define VOID_VDATEIFACE( pv ) if (!IsValidInterface(pv)) {\
    FnAssert(#pv,"Invalid interface", _szAssertFile, __LINE__); return; }

//** INTERFACE ID validation macro:
#define VDATEIID( iid ) if (!IsValidIid( iid )) \
    return (FnAssert(#iid,"Invalid iid", _szAssertFile, __LINE__),ResultFromScode(E_INVALIDARG))
#define GEN_VDATEIID( iid, retval ) if (!IsValidIid( iid )) {\
    FnAssert(#iid,"Invalid iid", _szAssertFile, __LINE__); return retval; }
#else



//  --assertless macros for non-debug case
//** POINTER IN validation macros:
#define VDATEPTRIN( pv, TYPE ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) \
    return (ResultFromScode(E_INVALIDARG))
#define GEN_VDATEPTRIN( pv, TYPE, retval ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) \
    return (retval)
#define VOID_VDATEPTRIN( pv, TYPE ) if (!IsValidPtrIn( (pv), sizeof(TYPE))) {\
    return; }

//** POINTER OUT validation macros:
#define VDATEPTROUT( pv, TYPE ) if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
    return (ResultFromScode(E_INVALIDARG))

#define GEN_VDATEPTROUT( pv, TYPE, retval ) if (!IsValidPtrOut( (pv), sizeof(TYPE))) \
    return (retval)

//** INTERFACE validation macro:
#define VDATEIFACE( pv ) if (!IsValidInterface(pv)) \
    return (ResultFromScode(E_INVALIDARG))
#define VOID_VDATEIFACE( pv ) if (!IsValidInterface(pv)) \
    return; 
#define GEN_VDATEIFACE( pv, retval ) if (!IsValidInterface(pv)) \
    return (retval)

//** INTERFACE ID validation macro:
#define VDATEIID( iid ) if (!IsValidIid( iid )) \
    return (ResultFromScode(E_INVALIDARG))
#define GEN_VDATEIID( iid, retval ) if (!IsValidIid( iid )) \
    return retval; 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\thc\thsplit\thsplit.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994.
//
//  File:	thsplit.c
//
//  Contents:	File splitter tool for the thunk tool
//
//  History:	22-Feb-94	DrewB	Created
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>
#include <string.h>

void __cdecl main(int argc, char **argv)
{
    FILE *in, *out;
    char line[256];
    char ofile[32], nfile[32], *n, *l;

    if (argc != 2)
    {
        printf("Usage: %s multifile\n", argv[0]);
        exit(1);
    }

    in = fopen(argv[1], "r");
    if (in == NULL)
    {
        perror(argv[1]);
        exit(1);
    }

    out = NULL;
    for (;;)
    {
        if (fgets(line, 256, in) == NULL)
            break;

        if (strncmp(line, "|- ", 3) == 0)
        {
            n = nfile;
            l = line+3;
            while (*l != ' ')
                *n++ = *l++;
            *n = 0;

            if (out != NULL && strcmp(nfile, ofile) != 0)
            {
                printf("Section '%s' started while section '%s' was active\n",
                       nfile, ofile);
                fclose(out);
                out = NULL;
            }
            
            if (out == NULL)
            {
                out = fopen(nfile, "a");
                if (out == NULL)
                {
                    perror(nfile);
                    exit(1);
                }

                strcpy(ofile, nfile);
            }
            else
            {
                fclose(out);
                out = NULL;
            }
        }
        else
        {
            if (out)
            {
                fprintf(out, "%s", line);
            }
        }
    }

    if (out != NULL)
    {
        printf("Unterminated section '%s'\n", ofile);
        fclose(out);
    }
    
    fclose(in);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\tools\clschk\classchk.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       classchk.cxx
//
// Classchk is a program for verifying that the contents of the registry are
// OKY-DOKY as far as OLE is concerned.
//
// In general, we verify that all CLSID's are of the correct length, all string
// parameters are NULL terminated.
//
// There are several phases of checking.
//
// 1) Checking that PROGID entries that have CLSID sections match.
// 2) Checking that PROGID entries have correct and existing protocol entries
// 3) Checking that PROGID entries
//
//  History:    5-31-95   kevinro   Created
//
//----------------------------------------------------------------------------

#include <windows.h>
#include <stdio.h>
#include <ctype.h>
#include "classchk.h"

//
// The following registry values are used quite a few times in this program.
// These global variables keep us from needing to open them constantly.
//

HKEY hkey_clsid = 0;

DWORD g_VerbosityLevel = VERB_LEVEL_WARN | VERB_LEVEL_ERROR;

#define StrICmp(x,y) (CompareString(LOCALE_USER_DEFAULT,NORM_IGNORECASE,x,-1,y,-1) - 2)
//+---------------------------------------------------------------------------
//
//  Function:   ReadRegistryString
//
//  Synopsis:	Reads a string from the registry
//
//  Effects:
//
// 	This function reads in a string from the registry, and does some basic
// 	consistency checking on it, such as verifying the length and NULL
// 	terminatation.
//
//
//  Arguments:  [hkeyRoot] --
//		[pszSubKeyName] --
//		[pszValueName] --
//		[pszValue] --
//		[pcbValue] --
//
//  Returns:	ERROR_SUCCESS		Everything peachy
//		ERROR_FILE_NOT_FOUND	Couldn't read entry from registry
//		CLASSCHK_SOMETHINGODD	Something about the string is wrong
//		(other)			Return value from registry
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    5-31-95   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD ReadRegistryString( HKEY hkeyRoot, LPSTR pszSubKeyName, LPSTR pszValueName, LPSTR pszValue, PULONG pcbValue)
{
	LONG lRetValue;
	DWORD dwType;
	DWORD dwReturn = ERROR_SUCCESS;
	HKEY hkey = hkeyRoot;

	if(pszSubKeyName != NULL)
	{
		lRetValue = RegOpenKeyEx(hkeyRoot,
					 pszSubKeyName,
					 NULL,
					 KEY_READ,
				 	 &hkey);

                //
		// It is common to see keys that don't exist. Let the caller decide if it is
		// important or not.
		//
		if(lRetValue != ERROR_SUCCESS)
		{
			VERBOSITY(VERB_LEVEL_TRACE,printf("Unable to open subkey %s to read value %s\n",pszSubKeyName,pszValueName););
			return lRetValue;
		}
	}

	lRetValue = RegQueryValueEx(hkey,
				    pszValueName,
				    NULL,		// Must be NULL according to spec
				    &dwType,
				    (BYTE *)pszValue,
				    pcbValue);
	if(hkeyRoot != hkey)
	{
		//
		//  Always close the new subkey if we opened it
		//
		RegCloseKey(hkey);
	}

	switch(lRetValue)
	{
		case ERROR_SUCCESS:
			//
			// Read the value, everything A-OK
			//
			break;
		case ERROR_MORE_DATA:
			VERBOSITY(VERB_LEVEL_WARN,printf("The value '%s' is larger than expected. May be a problem\n",pszValueName);)
			return lRetValue;
			break;

		case ERROR_FILE_NOT_FOUND:
			//
			// This may be expected, so don't report any errors. Let the caller handle that
			//
			return lRetValue;
		default:
			VERBOSITY(VERB_LEVEL_WARN,printf("RegQueryValueEx() for '%s' returned unexpected error 0x%x\n",pszValueName,lRetValue);)
			return lRetValue;
	}

	//
	// We expect this type to be REG_SZ. If it isn't, complain
	//
	if(dwType != REG_SZ)
	{
		VERBOSITY(VERB_LEVEL_WARN,printf("The value for '%s' is type 0x%x, was expecting REG_SZ (0x%x)\n",pszValueName,dwType,REG_SZ);)
		dwReturn = CLASSCHK_SOMETHINGODD;
	}

	//
	// We expect the value to be NULL terminated
	//
	if(pszValue[(*pcbValue)-1] != 0)
	{

		VERBOSITY(VERB_LEVEL_WARN,printf("The value for '%s' may not be NULL terminated.\n",pszValueName);)
	}

	//
	// We expect strlen to be the same as the length returned (which includes the NULL)
	//
	if((strlen(pszValue) + 1) != *pcbValue)
	{
		VERBOSITY(VERB_LEVEL_WARN,printf("The string value for '%s' may not have the correct length\n",pszValueName);)
		if(dwType == REG_SZ)
		{
			VERBOSITY(VERB_LEVEL_WARN,printf("The string value is '%s'\n",pszValue);)
		}
		dwReturn = CLASSCHK_SOMETHINGODD;
	}

	return dwReturn;
}

//+---------------------------------------------------------------------------
//
//  Function:   AllHexDigits
//
//  Synopsis:   Verify that all of the digits specified are hexidecimal
//
//  Effects:
//
//  Arguments:  [pszString] -- String to check
//		[chString] -- Number of characters
//
//  Requires:
//
//  Returns:    TRUE	All hex digits
//		FALSE	Not all hex digits
//
//  History:    5-31-95   kevinro   Created
//----------------------------------------------------------------------------
BOOL AllHexDigits(LPSTR pszString, ULONG chString)
{
	while(chString--)
	{
		if(!isxdigit(pszString[chString]))
		{
			return FALSE;
		}
	}
	return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Function:   CheckForValidGuid
//
//  Synopsis:   Given a string, determine if the string is a GUID
//
//  Arguments:  [pszValue] -- String to check
//
//  History:    5-31-95   kevinro   Created
//
//----------------------------------------------------------------------------
DWORD CheckForValidGuid(LPSTR pszValue)
{
	DWORD dwResult = 0;
	if((strlen(pszValue) != 38) || (pszValue[0] != '{') || (pszValue[37] != '}'))
	{
	    dwResult = CLASSCHK_SOMETHINGODD;
	}
	else
	{
	    // Check the internals of the GUID.
	    if(!AllHexDigits(&pszValue[1],8) ||
	       pszValue[9] != '-' ||				
	       !AllHexDigits(&pszValue[10],4) ||
	       pszValue[14] != '-' ||
	       !AllHexDigits(&pszValue[15],4) ||
	       pszValue[19] != '-' ||
	       !AllHexDigits(&pszValue[20],4) ||
	       pszValue[24] != '-' ||
	       !AllHexDigits(&pszValue[25],12) )
	    {
		dwResult = CLASSCHK_SOMETHINGODD;
	    }	
	}
	return dwResult;	
}

//+---------------------------------------------------------------------------
//
//  Function:   ReadRegistryGuid
//
//  Synopsis:   Read a GUID from the registry, and check to see if it is valid.
//
//  Arguments:  [hkey] -- Key to start from
//		[pszSubKeyName] -- Subkey relative to hkey (NULL if hkey)
//		[pszValueName] -- Value name (NULL if default value)
//		[pszValue] -- Pointer to return buffer
//		[pcbValue] -- Size of return buffer in characters
//
//  Returns:    ERROR_SUCCESS		Read and verified GUID
//		(other)			Something is wrong
//		ERROR_FILE_NOT_FOUND	Key didn't exist
//		CLASSCHK_SOMETHINGODD	Read key, but something is wrong with it.
//
//  History:    5-31-95   kevinro   Created
//
//----------------------------------------------------------------------------
DWORD ReadRegistryGuid( HKEY hkey, LPSTR pszSubKeyName, LPSTR pszValueName, LPSTR pszValue, PULONG pcbValue)
{
	DWORD dwResult;
	//
	// First, just read the value from the registry.
	//
	dwResult = ReadRegistryString(hkey, pszSubKeyName, pszValueName, pszValue, pcbValue);

	if(dwResult == ERROR_SUCCESS)
	{
	    //
	    // Do some additional basic checking, such as the length being correct, and the
	    // GUID correctly formed.
	    //
	    dwResult = CheckForValidGuid(pszValue);
	    if(dwResult != ERROR_SUCCESS)
	    {
		VERBOSITY(VERB_LEVEL_ERROR,printf("*** Malformed GUID '%s' ***\n",pszValue);)
	    }

	}
	return dwResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   ReadRegistryFile
//
//  Synopsis:   Read a registry entry which is supposed to be a file,
//		and determine if the file exists
//
//  Arguments:  [hkey] -- Key to start from
//		[pszSubKeyName] -- Subkey relative to hkey (NULL if hkey)
//		[pszValueName] -- Value name (NULL if default value)
//		[pszValue] -- Pointer to return buffer
//		[pcbValue] -- Size of return buffer in characters
//
//  Returns:    ERROR_SUCCESS		Read and verified
//		(other)			Something is wrong
//		ERROR_FILE_NOT_FOUND	Key didn't exist
//		CLASSCHK_SOMETHINGODD	Read key, but something is wrong with it.
//
//  History:    5-31-95   kevinro   Created
//
//----------------------------------------------------------------------------

ReadRegistryFile(HKEY hkey, LPSTR pszSubKeyName, LPSTR pszValueName, LPSTR pszValue, PULONG pcbValue)
{
	DWORD dwResult;
	//
	// First, just read the value from the registry.
	//
	dwResult = ReadRegistryString(hkey, pszSubKeyName, pszValueName, pszValue, pcbValue);

	if (dwResult == ERROR_SUCCESS)
	{
		char achFoundPath[MAX_PATH];
		char *pszFileNamePart;
		//
		// Some apps append a switch at the end.
		// If there is a switch, terminate the path at that point
		//
		if(pszFileNamePart = strchr(pszValue,'/'))
		{
			*pszFileNamePart = 0;
		}
		else if(pszFileNamePart = strchr(pszValue,'-'))
		{
		    //
		    // Some applications also use the '-' character
		    // as a switch delimiter. If this character is in
		    // the string, and the previous character is a space,
		    // then assume it is a delimiter. This isn't foolproof,
		    // but it should work most of the time.
		    //
		    if(pszFileNamePart[-1] == ' ')
		    {
			*pszFileNamePart = 0;
		    }
		}

		if(SearchPath(NULL,pszValue,NULL,MAX_PATH,achFoundPath,&pszFileNamePart) == 0)
		{
			//
			// Didn't find the name in the path.
			//
			VERBOSITY(VERB_LEVEL_ERROR,printf("*** Could not find path '%s' ***\n",pszValue));
			dwResult = CLASSCHK_SOMETHINGODD;

		}
		else
		{
			VERBOSITY(VERB_LEVEL_TRACE,printf("Found path %s (%s)\n",achFoundPath,pszValue));
		}

	}

	return dwResult;
}

//+---------------------------------------------------------------------------
//
//  Function:   CheckProgID
//
//  Synopsis:
//
// Given a PROGID entry, do some checking to insure the entry is sane. Of the things to check,
// we should check to insure the name string is readable. If there is a CLSID entry, we should
// check to see if it has a CLSID in it.
//
//
//  Arguments:  [pszProgID] -- PROGID string to check
//
//  History:    5-31-95   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD CheckProgID(LPSTR pszProgID)
{

    LONG lRetValue = 0;
    char achValue[MAX_PATH];
    DWORD cbValue;
    DWORD dwRetValue;
    HKEY progidKey = NULL;


    lRetValue = RegOpenKeyEx(HKEY_CLASSES_ROOT,
			     pszProgID,
			     NULL,
			     KEY_READ,
			     &progidKey);

    if(lRetValue == ERROR_SUCCESS)
    {
	cbValue = MAX_PATH;
	
	//
	// Read the default key value for the PROGID. Normally, this should be the name of the class name
	// or program name that would be shown.
	//
	dwRetValue = ReadRegistryString(progidKey,NULL,NULL,achValue,&cbValue);

	if(dwRetValue == CLASSCHK_SOMETHINGODD)
	{
		VERBOSITY(VERB_LEVEL_WHINE,printf("HKEY_CLASSES_ROOT\\%s found odd description '%s'\n",pszProgID,achValue);)
	}

	cbValue = MAX_PATH;

	dwRetValue = ReadRegistryGuid(progidKey,"CLSID",NULL,achValue,&cbValue);

	switch(dwRetValue)
	{
		case ERROR_SUCCESS:
			break;
		case ERROR_FILE_NOT_FOUND:
			// Not all of these entries will have a CLSID section
			break;
		default:
			VERBOSITY(VERB_LEVEL_ERROR,
					  printf("*** Possible invalid CLSID in HKEY_CLASSES_ROOT\\%s\\CLSID\n",pszProgID);)
	}

	if(dwRetValue == ERROR_SUCCESS)
	{
		char achValue2[MAX_PATH];
		DWORD cbValue2 = MAX_PATH;
		//
		// We appear to have a valid CLSID. Check for existence of the CLSID. We are actually only
		// interested in it being found or not.
		//
		dwRetValue = ReadRegistryString(hkey_clsid,achValue,NULL,achValue2,&cbValue2);
		if(dwRetValue == ERROR_FILE_NOT_FOUND)
		{
			VERBOSITY(VERB_LEVEL_ERROR,printf("ProgID %s has CLSID %s. Unable to find HKEY_CLASSES_ROOT\\CLSID\\%s\n",pszProgID,achValue,achValue);)
		}
	}

	//
	// Check to see if there is an OLE 1.0 section that specifies protocol\stdfileediting\server
	//
	cbValue = MAX_PATH;
	dwRetValue = ReadRegistryFile(progidKey,"protocol\\stdfileediting\\server",NULL,achValue,&cbValue);
	if(dwRetValue == CLASSCHK_SOMETHINGODD)
	{
	    VERBOSITY(VERB_LEVEL_ERROR,printf("HKEY_CLASSES_ROOT\\%s\\Protocol\\StdFileEditing\\server may have invalid entry\n",pszProgID);)
	}
		
    }
    else
    {
    	VERBOSITY(VERB_LEVEL_WARN,printf("Unable to open HKEY_CLASSES_ROOT\\%s\n",pszProgID);)
    }

    if(progidKey != NULL)
    {
	RegCloseKey(progidKey);
    }
    	
    return 0;
}



//
// Given an extention (ie something that starts with a '.'), determine if the mapping to PROGID is correct
//
DWORD CheckExtentionToProgID(LPSTR pszExtention)
{

	LONG lRetValue = 0;
	char achValue[MAX_PATH];
	DWORD cbValue;
	DWORD dwRetValue;
	HKEY subKey = NULL;
	HKEY progidKey = NULL;


	lRetValue = RegOpenKeyEx(HKEY_CLASSES_ROOT,
							 pszExtention,
							 NULL,
							 KEY_READ,
							 &subKey);

	if(lRetValue == ERROR_SUCCESS)
	{
		cbValue = MAX_PATH;
	
		//
		// Read the default key value for the extention. Normally, this should point to a
		// PROGID.
		//
		dwRetValue = ReadRegistryString(subKey,NULL,NULL,achValue,&cbValue);
		VERBOSITY(VERB_LEVEL_TRACE,printf("HKEY_CLASSES_ROOT\\%s = %s\n",pszExtention,achValue);)

		if(dwRetValue == CLASSCHK_SOMETHINGODD)
		{
			VERBOSITY(VERB_LEVEL_WARN,printf("Reading HKEY_CLASSES_ROOT\\%s found something odd\n",pszExtention);)
		}
		
		//
		// If it is an extension, the value should be a PROGID.Take a look to see if it is.
		//
		lRetValue = RegOpenKeyEx(HKEY_CLASSES_ROOT,
								 achValue,
							 	 NULL,
							 	 KEY_READ,
							 	 &progidKey);
		//
		// It should have been there. If it wasn't, then report a strangeness
		//

		switch(lRetValue)
		{
			case ERROR_SUCCESS:
				//
				// The PROGID actually existed. We will verify its contents later.
				//
				break;
			case ERROR_FILE_NOT_FOUND:
				//
				// The PROGID doesn't exist. This could be a potential problem in the registry. Report it.
				//
				VERBOSITY(VERB_LEVEL_ERROR,
						  printf("HKEY_CLASSES_ROOT\\%s **** PROGID '%s' didn't exist ***\n*** Check Registry ***\n",
						  pszExtention,
						  achValue);)
				break;
			default:
				VERBOSITY(VERB_LEVEL_WARN,printf("Unexpected error opening HKEY_CLASSES_ROOT\\%s (error 0x%x)\n",achValue,lRetValue);)

		}


	}
	else
	{
		VERBOSITY(VERB_LEVEL_WARN,printf("Unable to open HKEY_CLASSES_ROOT\\%s\n",pszExtention);)
	}


	if(subKey != NULL) RegCloseKey(subKey);
	if(progidKey != NULL) RegCloseKey(progidKey);
		
	
	return 0;
}


//+---------------------------------------------------------------------------
//
//  Function:   CheckOLE1CLSID
//
//  Synopsis:   CheckOLE1CLSID looks at CLSID's that are typically OLE 1.0.
//		This includes checking for AutoConvert, checking the PROGID,
//		and checking that the Ole1Class key exists.
//
//  Arguments:  [pszCLSID] -- Name of OLE 1.0 CLASSID to check
//
//  History:    5-31-95   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD CheckOLE1CLSID(LPSTR pszCLSID)
{
    LONG lRetValue = 0;
    char achValue[MAX_PATH];
    DWORD cbValue;
    DWORD dwRetValue;
    HKEY subKey = NULL;
    BOOL fFoundAServer = FALSE;
    char achValue2[MAX_PATH];
    DWORD cbValue2 = MAX_PATH;

    lRetValue = RegOpenKeyEx(hkey_clsid,pszCLSID,NULL,KEY_READ,&subKey);

    if(lRetValue != ERROR_SUCCESS)
    {
    	VERBOSITY(VERB_LEVEL_ERROR,printf("Unable to open HKEY_CLASSES_ROOT\\CLSID\\%s error 0x%x\n",pszCLSID,lRetValue);)
    	return CLASSCHK_SOMETHINGODD;
    }

    //
    // Check to insure that there is an Ole1Class entry
    //

    cbValue = MAX_PATH;
    dwRetValue = ReadRegistryString(subKey,"Ole1Class",NULL,achValue,&cbValue);
    switch(dwRetValue)
    {
    	case ERROR_FILE_NOT_FOUND:
    		VERBOSITY(VERB_LEVEL_WARN,printf("HKEY_CLASSES_ROOT\\CLSID\\%s is missing its Ole1Class key\n",pszCLSID);)
    		break;
    	case CLASSCHK_SOMETHINGODD:
    		VERBOSITY(VERB_LEVEL_WARN,printf("HKEY_CLASSES_ROOT\\CLSID\\%s\\Ole1Class key is odd\n",pszCLSID);)

    }

    //
    // Quite often, there will be a AutoConvertTo key, which is supposed to be a GUID
    //
    cbValue = MAX_PATH;
    dwRetValue = ReadRegistryGuid(subKey,"AutoConvertTo",NULL,achValue,&cbValue);
    switch(dwRetValue)
    {
    	case ERROR_SUCCESS:
    		//
    		// The CLSID should normally point to another class, such as the 2.0 version. Check to
    		// insure the CLSID exists
    		//
    		dwRetValue = ReadRegistryString(hkey_clsid,achValue,NULL,achValue2,&cbValue2);
    		if(dwRetValue != ERROR_SUCCESS)
    		{
		    VERBOSITY(VERB_LEVEL_WARN,printf("HKEY_CLASSES_ROOT\\CLSID\\%s\\AutoConvertTo key is odd\n",pszCLSID);)
		    switch(dwRetValue)
    		    {
			case ERROR_FILE_NOT_FOUND:

			    VERBOSITY(VERB_LEVEL_WARN,printf("HKEY_CLASSES_ROOT\\CLSID\\%s doesn't appear to exist\n",achValue);)
			    break;
		    }
    		}

    		break;
    	case ERROR_FILE_NOT_FOUND:
    		//
    		// This entry isn't required. If it doesn't exist, no big deal.
    		//
    		break;
    	case CLASSCHK_SOMETHINGODD:
    		VERBOSITY(VERB_LEVEL_WARN,printf("HKEY_CLASSES_ROOT\\CLSID\\%s\\AutoConvertTo key is odd\n",pszCLSID);)
		break;

    }

    //
    // It would be abnormal to find a missing PROGID key
    //
    cbValue = MAX_PATH;
    dwRetValue = ReadRegistryString(subKey,"ProgID",NULL,achValue,&cbValue);
    switch(dwRetValue)
    {
    	case ERROR_SUCCESS:
	    //
	    // The PROGID should normally point to a valid PROGID
	    //
	    cbValue2 = MAX_PATH;
	    dwRetValue = ReadRegistryString(HKEY_CLASSES_ROOT,achValue,NULL,achValue2,&cbValue2);
	    if(dwRetValue != ERROR_SUCCESS)
	    {
		VERBOSITY(VERB_LEVEL_ERROR,printf("HKEY_CLASSES_ROOT\\CLSID\\%s\\PROGID key is odd\n",pszCLSID);)
		switch(dwRetValue)
		{
		    case ERROR_FILE_NOT_FOUND:

			VERBOSITY(VERB_LEVEL_ERROR,printf("HKEY_CLASSES_ROOT\\%s doesn't appear to exist\n",achValue);)
			break;
		}
	    }

	break;
    	case ERROR_FILE_NOT_FOUND:
    		//
    		// This entry is required.
    		//
    		VERBOSITY(VERB_LEVEL_ERROR,printf("HKEY_CLASSES_ROOT\\CLSID\\%s\\PROGID key is missing\n",pszCLSID);)

    		break;
    	case CLASSCHK_SOMETHINGODD:
    		VERBOSITY(VERB_LEVEL_WARN,printf("HKEY_CLASSES_ROOT\\CLSID\\%s\\Ole1Class key is odd\n",pszCLSID);)

    }

    return dwRetValue;
}


//+---------------------------------------------------------------------------
//
//  Function:   CheckForDLL
//
//  Synopsis:   Given a CLSID, its hkey, and the name of the DLL value,
//		determine if the DLL exists as a file, and if the threading
//		model value is appropriate.
//
//  Arguments:  [pszCLSID] -- 	Name of the CLSID (for debug output)
//		[hkeyCLSID] --  HKEY for the clsid
//		[pszDLLKey] -- 	Name of the subkey to check for
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    5-31-95   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD CheckForDLL(LPSTR pszCLSID, HKEY hkeyCLSID, LPSTR pszDLLKey)
{
    LONG lRetValue = 0;
    char achValue[MAX_PATH];
    DWORD cbValue;
    DWORD dwRetValue;
    char achThreadModel[MAX_PATH];
    DWORD cbThreadModel = MAX_PATH;
    //
    // The DLL name should be in
    //
    cbValue = MAX_PATH;
    dwRetValue = ReadRegistryFile(hkeyCLSID,pszDLLKey,NULL,achValue,&cbValue);

    switch(dwRetValue)
    {
    	case ERROR_FILE_NOT_FOUND:
    	//
    	// The registry key didn't exist. Thats normally OK.
    	//
    		return dwRetValue;
    	case CLASSCHK_SOMETHINGODD:
    		VERBOSITY(VERB_LEVEL_WARN,printf("HKEY_CLASSES_ROOT\\CLSID\\%s\\%s key is odd\n",pszCLSID,pszDLLKey);)
    		return dwRetValue;
    }

    //
    // If the DLL exists, check to see if the ThreadingModelKey is valid
    //
    dwRetValue = ReadRegistryString(hkeyCLSID,pszDLLKey,"ThreadingModel",achThreadModel,&cbThreadModel);
    switch(dwRetValue)
    {
    	case ERROR_FILE_NOT_FOUND:
	    //
	    // The registry key didn't exist. Thats normally OK.
	    //
	    return ERROR_SUCCESS;
    	case CLASSCHK_SOMETHINGODD:
	    VERBOSITY(VERB_LEVEL_WARN,printf("HKEY_CLASSES_ROOT\\CLSID\\%s\\%s\\ThreadingModel value is odd\n",pszCLSID,pszDLLKey);)
	    return dwRetValue;
    }

    //
    // Check to insure the threading model is something we understand
    //
    if( StrICmp( achThreadModel, "Apartment") &&
    	StrICmp( achThreadModel, "Both") &&
    	StrICmp( achThreadModel, "Free"))
    {
    	VERBOSITY(VERB_LEVEL_WARN,printf("HKEY_CLASSES_ROOT\\CLSID\\%s\\%s\\ThreadingModel value is %s\n",pszCLSID,pszDLLKey,achThreadModel);)
    	VERBOSITY(VERB_LEVEL_WARN,printf("Expected 'Apartment','Both', or 'Free'");)
    	return CLASSCHK_SOMETHINGODD;
    }
    return ERROR_SUCCESS;
						 	
}

//+---------------------------------------------------------------------------
//
//  Function:   CheckCLSIDEntry
//
//  Synopsis:   Given the name of a CLSID entry, verify that the entry is
//		valid by looking for the 'usual' key information, and
//		cross checking it against things that we assert should be
//		true.
//  Effects:
//
//  Arguments:  [pszCLSID] -- CLSID in a string form. Used to open key
//
//  History:    5-31-95   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD CheckCLSIDEntry(LPSTR pszCLSID)
{
    LONG lRetValue = 0;
    char achValue[MAX_PATH];
    DWORD cbValue;
    char achPROGID[MAX_PATH];
    DWORD cbPROGID = MAX_PATH;
    char achPROGIDPath[MAX_PATH];
    DWORD cbPROGIDPath = MAX_PATH;
    char achPROGIDValue[MAX_PATH];
    DWORD cbPROGIDValue = MAX_PATH;

    LPSTR pszLocalServer = "LocalServer32";
    DWORD dwRetValue;
    HKEY subKey = NULL;
    BOOL fFoundAServer = FALSE;

    lRetValue = RegOpenKeyEx(hkey_clsid,
			     pszCLSID,
			     NULL,
			     KEY_READ,
			     &subKey);

    if(lRetValue != ERROR_SUCCESS)
    {
	VERBOSITY(VERB_LEVEL_ERROR,printf("Unable to open HKEY_CLASSES_ROOT\\CLSID\\%s error 0x%x\n",pszCLSID,lRetValue);)
	return CLASSCHK_SOMETHINGODD;
    }

    //
    // Basic sanity check: Is the description string a valid string
    //
    cbValue = MAX_PATH;
    dwRetValue = ReadRegistryString(subKey,NULL,NULL,achValue,&cbValue);
    if(dwRetValue != ERROR_SUCCESS)
    {
	VERBOSITY(VERB_LEVEL_WHINE,printf("HKEY_CLASSES_ROOT\\CLSID\\%s has odd description string\n",pszCLSID);)
    }

    //
    // A CLSID entry typically has several values. Least of which is supposed to be one or more of the following:
    // InprocHandler
    // InprocServer
    // LocalServer
    // InprocHandler32
    // InprocServer32
    // LocalServer32
    //
    // It may also have an optional PROGID entry, which we can use to verify that that the LocalServer and
    // the protocol\StdFileEditing\server entries match.
    //
    // Another couple of things to watch for include checking the Inproc entries for ThreadingModel,
    //
    // Yet another thing to look at is the value of the CLSID itself. If the first 4 digits are 0003 or 0004, then
    // the CLSID is for an OLE 1.0 class, and we need to do a seperate check
    //
    if((strncmp(&pszCLSID[1],"0003",4) == 0) || (strncmp(&pszCLSID[1],"0004",4) == 0) )
    {
    	//
    	// In theory, this is supposed to be an OLE1CLASS. Check it seperately
    	//
    	RegCloseKey(subKey);
    	return CheckOLE1CLSID(pszCLSID);
    }

    dwRetValue = CheckForDLL(pszCLSID, subKey, "InprocHandler");
    dwRetValue = CheckForDLL(pszCLSID, subKey, "InprocHandler32");

    dwRetValue = CheckForDLL(pszCLSID, subKey, "InprocServer");
    if(dwRetValue != ERROR_FILE_NOT_FOUND) fFoundAServer++;

    dwRetValue = CheckForDLL(pszCLSID, subKey, "InprocServer32");
    if(dwRetValue != ERROR_FILE_NOT_FOUND) fFoundAServer++;

    //
    // First, check for LocalServer32. If that doesn't exist, then try for
    // LocalServer.
    //

    cbValue = MAX_PATH;
    dwRetValue = ReadRegistryFile(subKey,pszLocalServer,NULL,achValue,&cbValue);
    if(dwRetValue == ERROR_FILE_NOT_FOUND)
    {
    	cbValue = MAX_PATH;
    	pszLocalServer = "LocalServer";
    	dwRetValue = ReadRegistryFile(subKey,pszLocalServer,NULL,achValue,&cbValue);
    	if(dwRetValue == CLASSCHK_SOMETHINGODD)
    	{
    		VERBOSITY(VERB_LEVEL_WARN,printf("HKEY_CLASSES_ROOT\\CLSID\\%s\\LocalServer32 is odd\n",pszCLSID);)

    	}
    }
    else if(dwRetValue ==  CLASSCHK_SOMETHINGODD)
    {
    	VERBOSITY(VERB_LEVEL_WARN,printf("HKEY_CLASSES_ROOT\\CLSID\\%s\\%s is odd\n",pszCLSID,pszLocalServer);)

    }

    if(dwRetValue == ERROR_SUCCESS)
    {
    	fFoundAServer++;
    	//
    	// We have a valid LocalServer. Lets get the PROGID's version of the local server, and compare the
    	// two. They should compare.
    	//
    	dwRetValue = ReadRegistryString(subKey,"PROGID",NULL,achPROGID,&cbPROGID);
    	switch(dwRetValue)
    	{
	    case ERROR_FILE_NOT_FOUND:
		//
		// Most CLSID's should indeed have a PROGID, but it isn't 100% required.
		//
		VERBOSITY(VERB_LEVEL_WHINE,printf("HKEY_CLASSES_ROOT\\CLSID\\%s missing a PROGID entry\n",pszCLSID);)
		break;
	    case CLASSCHK_SOMETHINGODD:
		VERBOSITY(VERB_LEVEL_WARN,printf("HKEY_CLASSES_ROOT\\CLSID\\%s PROGID entry is odd\n",pszCLSID);)
		break;
	    default:
		sprintf(achPROGIDPath,"%s\\protocol\\stdfileediting\\server",achPROGID);
		dwRetValue = ReadRegistryFile(HKEY_CLASSES_ROOT,achPROGIDPath,NULL,achPROGIDValue,&cbPROGIDValue);
		//
		// The only thing we are interested in checking is if the two strings compare.
		//
		if(dwRetValue == ERROR_SUCCESS)
		{
		    if(StrICmp(achPROGIDValue,achValue) != 0)
		    {
			VERBOSITY(VERB_LEVEL_ERROR,printf("HKEY_CLASSES_ROOT\\CLSID\\%s is inconsistent with its PROGID\n",pszCLSID);)
			VERBOSITY(VERB_LEVEL_ERROR,printf("HKEY_CLASSES_ROOT\\%s = '%s'\n",achPROGIDPath,achPROGIDValue);)
			VERBOSITY(VERB_LEVEL_ERROR,printf("HKEY_CLASSES_ROOT\\CLSID\\%s\\%s = '%s'\n",pszCLSID,pszLocalServer,achValue);)

		    }
		}
    	}
    }

    if(!fFoundAServer)
    {
    	VERBOSITY(VERB_LEVEL_ERROR,printf("*** Unable to find a valid server for HKEY_CLASSES_ROOT\\CLSID\\%s ***\n",pszCLSID);)
    }

    RegCloseKey(subKey);

    return dwRetValue;
}


//+---------------------------------------------------------------------------
//
//  Function:   EnumerateClsidRoot
//
//  Synopsis:   Enumerate and check each entry in the CLSID section
//
//  History:    5-31-95   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD EnumerateClsidRoot()
{
	LONG lRetValue = 0;
	DWORD iSubKey = 0;
	char achKeyName[MAX_PATH];
	DWORD cbKeyName;
	FILETIME filetime;

	while(1)
	{
		cbKeyName = MAX_PATH;

		lRetValue = RegEnumKeyEx(hkey_clsid,
					 iSubKey,
					 achKeyName,
		 			 &cbKeyName,
		 			 NULL,
		 			 NULL,
		 			 NULL,
					 &filetime);

		if(lRetValue == ERROR_NO_MORE_ITEMS)
		{
			// End of enumeration
			break;
		}

		if(lRetValue != ERROR_SUCCESS)
		{
			VERBOSITY(VERB_LEVEL_ERROR,printf("EnumerateClsidRoot:RegEnumKeyEx returned %x\n",lRetValue);)
			return CLASSCHK_ERROR;
		}

		//
		// Each of the sub keys enumerated here is expected to be a GUID. If it isn't a GUID, then it
		// might be some other random garbage that we don't care about.
		//

		if(CheckForValidGuid(achKeyName) == ERROR_SUCCESS)
		{
			CheckCLSIDEntry(achKeyName);
		}

		iSubKey++;
	}

	return 0;
}


//+---------------------------------------------------------------------------
//
//  Function:   EnumerateClassesRoot
//
//  Synopsis:   Enumerate the root of HKEY_CLASSES, and check each entry
//		based on what we think it should be.
//
//  History:    5-31-95   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
DWORD EnumerateClassesRoot()
{
	LONG lRetValue = 0;
	DWORD iSubKey = 0;
	char achKeyName[MAX_PATH];
	DWORD cbKeyName;
	FILETIME filetime;

	while(1)
	{
		cbKeyName = MAX_PATH;
		lRetValue = RegEnumKeyEx(HKEY_CLASSES_ROOT,
					 iSubKey,
					 achKeyName,
					 &cbKeyName,
					 NULL,
					 NULL,
					 NULL,
					 &filetime);

		if(lRetValue == ERROR_NO_MORE_ITEMS)
		{
			// End of enumeration
			break;
		}

		if(lRetValue != ERROR_SUCCESS)
		{
			VERBOSITY(VERB_LEVEL_ERROR,printf("EnumerateClassesRoot:RegEnumKeyEx returned %x\n",lRetValue);)
			return CLASSCHK_ERROR;
		}

		//
		// We expect to find two basic things at the HKEY_CLASSES_ROOT level.
		// First are extention mappings, second are PROGID's. There is also
		// the special cases of CLSID, Interface, and FileType, which are
		// checked differently
		//

		if(StrICmp(achKeyName,"CLSID") == 0)
		{
			// The CLSID section is done later
		}
		else if(StrICmp(achKeyName,"Interface") == 0)
		{
			// The interface section is done later
		}
		else if(StrICmp(achKeyName,"FileType") == 0)
		{
			// The FileType entry is done later
		}
		else if(achKeyName[0] == '.')
		{
			// File extentions start with dots.
			// Call the Check Extention function here
			CheckExtentionToProgID(achKeyName);
		}
		else
		{
			// Assume it may be a PROGID. Call the PROGID function here.

			CheckProgID(achKeyName);
		}
		

		iSubKey++;
	}

	return 0;
}

//+---------------------------------------------------------------------------
//
//  Function:   main
//
//  Synopsis:   Main entry point for program. Does what main entry points
//		usually do.
//
//  Arguments:  [argc] --
//		[argv] --
//
//  History:    5-31-95   kevinro   Created
//
//  Notes:
//
//----------------------------------------------------------------------------
int _cdecl main(int argc, char *argv[])
{
	LONG lRetValue = 0;

	//
	// HKEY_CLASSES_ROOT is often used.
	//
	lRetValue = RegOpenKeyEx(HKEY_CLASSES_ROOT,
				 "CLSID",
				 NULL,
				 KEY_READ,
				 &hkey_clsid);

	if(lRetValue != ERROR_SUCCESS)
	{
		printf("Couldn't open HKEY_CLASSES_ROOT\\CLSID\n");
		return(1);
	}

	//
	// Enumerate different parts of the registry, reporting
	// errors as we go.
	//
	EnumerateClassesRoot();
	EnumerateClsidRoot();

	RegCloseKey(hkey_clsid);	
	return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\tools\clschk\classchk.h ===
//
// classchk.h
//

#define CLASSCHK_SOMETHINGODD  	0x12340001

// Some unknown error has occured
#define CLASSCHK_ERROR		    0x1234FFFF


#define VERB_LEVEL_ERROR	0x01
#define VERB_LEVEL_WARN 	0x02
#define VERB_LEVEL_WHINE	0x04
#define VERB_LEVEL_TRACE	0x10
#define VERB_LEVEL_ITRACE	0x20
#define VERB_LEVEL_IWARN	0x40
#define VERB_LEVEL_IERRROR	0x80

extern DWORD g_VerbosityLevel;

#define VERBOSITY( level, x) if( level & g_VerbosityLevel ) x
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\utest\simple\simple.c ===
#include <windows.h>
#include <ole2.h>
#include "simple.h"

HANDLE hInst;			    /* current instance			     */

int PASCAL WinMain(
    HANDLE hInstance,
    HANDLE hPrevInstance,
    LPSTR lpCmdLine,
    int nCmdShow
) {
    MSG             msg;
    HDC             hdc;

    if (!hPrevInstance)			 /* Other instances of app running? */
	if (!InitApplication(hInstance)) /* Initialize shared things */
	    return (FALSE);		 /* Exits if unable to initialize     */

    /* Perform initializations that apply to a specific instance */

    if (!InitInstance(hInstance, nCmdShow))
        return (FALSE);

    /* Acquire and dispatch messages until a WM_QUIT message is received. */
    while ( GetMessage(&msg, NULL, 0,0) ) {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
    }
}


BOOL InitApplication(hInstance)
HANDLE hInstance;
{
    WNDCLASS  wc;

    wc.style = CS_OWNDC;                /* Class style(s).                    */
    wc.lpfnWndProc   = MainWndProc;     /* Function to retrieve messages for  */
                                        /* windows of this class.             */
    wc.cbClsExtra    = 0;               /* No per-class extra data.           */
    wc.cbWndExtra    = 0;               /* No per-window extra data.          */
    wc.hInstance     = hInstance;       /* Application that owns the class.   */
    wc.hIcon         = LoadIcon(NULL, IDI_APPLICATION);
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = GetStockObject(LTGRAY_BRUSH);
    wc.lpszMenuName  = "SimpleMenu";   /* Name of menu resource in .RC file. */
    wc.lpszClassName = "SimpleClass";  /* Name used in call to CreateWindow. */

    /* Register the window class and return success/failure code. */

    return (RegisterClass(&wc));

}

BOOL InitInstance(hInstance, nCmdShow)
    HANDLE          hInstance;          /* Current instance identifier.       */
    int             nCmdShow;           /* Param for first ShowWindow() call. */
{
    HWND            hWnd;               /* Main window handle.                */
    HWND            hWndX;
    OFSTRUCT        ofFileData;
    HANDLE          hLogFile;
    HDC             hDC;
    int             i;
    SIZE            size;
    int             length;
    BOOL            f;

    hInst = hInstance;

    /* Create a main window for this application instance.  */

    hWnd = CreateWindow(
        "SimpleClass",                  /* See RegisterClass() call.          */
        "OLE 2.0 Simple Thunk Testing", /* Text for window title bar.         */
        WS_OVERLAPPEDWINDOW,            /* Window style.                      */
        280,                            /* Default horizontal position.       */
        50,                             /* Default vertical position.         */
        CW_USEDEFAULT,                  /* Default width.                     */
        CW_USEDEFAULT,                  /* Default height.                    */
        NULL,                           /* Overlapped windows have no parent. */
        NULL,                           /* Use the window class menu.         */
        hInstance,                      /* This instance owns this window.    */
        NULL                            /* Pointer not needed.                */
    );

    /* If window could not be created, return "failure" */

    if (!hWnd)
        return (FALSE);

    ShowWindow(hWnd, nCmdShow);  /* Show the window                        */
    UpdateWindow(hWnd);          /* Sends WM_PAINT message                 */

    return (TRUE);               /* Returns the value from PostQuitMessage */

}

void LogResult( LPSTR message, HRESULT hr )
{
    char text[256];

    if ( hr ) {
        wsprintf(text,"%s:%08lX\n",message,hr);
        OutputDebugString(text);
    }
}


LONG FAR PASCAL MainWndProc(hWnd, message, wParam, lParam)
HWND hWnd;				  /* window handle		     */
UINT message;    			  /* type of message		     */
WPARAM wParam;				  /* additional information	     */
LONG lParam;				  /* additional information	     */
{
    FARPROC     lpProcAbout;		  /* pointer to the "About" function */
    PAINTSTRUCT ps;
    long        rc;
    int         i;
    HRESULT     hr;

    switch (message) {
	case WM_COMMAND:	   /* message: command from application menu */
            switch( wParam ) {
                case IDM_ABOUT:
                    lpProcAbout = MakeProcInstance(About, hInst);

                    DialogBox(hInst,      /* current instance         */
                        "AboutBox",       /* resource to use          */
                        hWnd,             /* parent handle            */
                        lpProcAbout);     /* About() instance address */

                    FreeProcInstance(lpProcAbout);
                    break;                  /* Lets Windows process it       */
                default:
                    { char text[100];
                      HDC hdc;
                      static int position = 0;
                      position += 20;
                      wsprintf(text,"Cmd = %04X",wParam);
                      hdc = GetDC( hWnd );
                      TextOut(hdc,100,position,text,lstrlen(text));
                      ReleaseDC( hWnd, hdc );
                    }
                    return (DefWindowProc(hWnd, message, wParam, lParam));
                case IDM_COINIT:
                    hr = CoInitialize(NULL);
                    LogResult( "CoInitialize", hr );

                    break;
            }
            break;

        case WM_DESTROY:                  /* message: window being destroyed */

	    PostQuitMessage(0);
            break;

        case WM_PAINT:
            {
                PAINTSTRUCT ps;
                HDC         hDC;
                char        text[100];

                hDC = BeginPaint( hWnd, &ps );


                EndPaint( hWnd, &ps );
            }
            break;

	default:			  /* Passes it on if unproccessed    */
            rc = DefWindowProc(hWnd, message, wParam, lParam);
            return( rc );
    }
    return (NULL);
}


BOOL FAR PASCAL About(hDlg, message, wParam, lParam)
HWND hDlg;                                /* window handle of the dialog box */
UINT message;                             /* type of message                 */
WPARAM wParam;				  /* message-specific information    */
LONG lParam;
{

    switch (message) {
	case WM_INITDIALOG:		   /* message: initialize dialog box */
	    return (TRUE);

	case WM_COMMAND:		      /* message: received a command */
	    if (wParam == IDOK                /* "OK" box selected?	     */
                || wParam == IDCANCEL) {      /* System menu close command? */
		EndDialog(hDlg, TRUE);	      /* Exits the dialog box	     */
		return (TRUE);
	    }
	    break;
    }
    return (FALSE);			      /* Didn't process a message    */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\tools\infolvl\infolvl.cxx ===
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>


typedef struct _InfoLevelRecord
{
	char *pszInfoLevel;
	char *pszSectionName;
	char *pszDescription;
} InfoLevelRecord;

InfoLevelRecord ilrArray[] =
{
	{ "cairole", "Cairole Infolevels","Compobj layer" },
	{ "DD", "Cairole Infolevels","Drag & Drop" },
	{ "heap", "Cairole Infolevels","Heap trace output" },
	{ "hk", "Cairole Infolevels","Hook layer" },
	{ "intr","Cairole Infolevels","1.0/2.0 interop layer" },
	{ "le", "Cairole Infolevels", "Linking and embedding" },
	{ "mnk", "Cairole Infolevels", "Moniker tracing" },
	{ "msf", "Cairole Infolevels", "Upper layer storage" },
	{ "ol", "Cairole Infolevels", "Lower layer storage" },
	{ "ref", "Cairole Infolevels", "CSafeRef class (Cairo)" },
	{ "scm", "Cairole Infolevels", "OLE service" },
	{ "Stack", "Cairole Infolevels", "Stack switching (Win95)" },
	{ "StackOn", "Cairole Infolevels", "Stack switching enable (boolean,Win95)" },
	{ "prop", "Cairole Infolevels", "Storage property interfaces" },
	{ "api", "Cairole Infolevels","CompApi trace" },
	{ "breakoninit", "Olethk32","Break on initialization (boolean)" },
	{ "InfoLevel", "Olethk32","16/32 thunk layer (32-bit side)" },
	{ "ole2", "Olethk16","16/32 thunk layer: ole2.dll" },
	{ "stg",  "Olethk16","16/32 thunk layer: storage.dll" },
	{ "comp", "Olethk16","16/32 thunk layer: compobj.dll" },
	{ NULL, NULL }
};

typedef struct _AttrRecord
{
	char *pszAttr;
	char *pszSectionName;
	char *pszDescription;
} AttrRecord;

AttrRecord arArray[] =
{
	{ "DebugScreen", "Cairole Infolevels","Debugger Screen (Yes|No)" },
	{ "LogFile", "Cairole Infolevels","LogFile (\"<name>\"|\"\")" },
        { NULL, NULL}
};

char * LookupILSection (char * pszInfoLevel)
{
	InfoLevelRecord *pr;
	for ( pr = ilrArray ; pr->pszInfoLevel != NULL ; pr++)
	{
		if (_stricmp(pr->pszInfoLevel,pszInfoLevel) == 0)
		{
			break;
		}

	}
	return pr->pszSectionName;
}

void DumpInfoLevelRecords()
{
	InfoLevelRecord *pr;
	
	printf("%20s %-12s Currently\n","Section Name","Name");

	for ( pr = ilrArray ; pr->pszInfoLevel != NULL ; pr++)
	{
		printf("%20s %-12s (%08x) %s\n",
		       pr->pszSectionName,
		       pr->pszInfoLevel,
		       GetProfileInt(pr->pszSectionName,pr->pszInfoLevel,0),
		       pr->pszDescription);

	}

}

char * LookupASection (char * pszAttr)
{
	AttrRecord *pr;
	for ( pr = arArray ; pr->pszAttr != NULL ; pr++)
	{
		if (_stricmp(pr->pszAttr,pszAttr) == 0)
		{
			break;
		}

	}
	return pr->pszSectionName;
}

void DumpAttrRecords()
{
	AttrRecord *pr;
        char buffer[256];
	
	printf("%20s %-12s Currently\n","Section Name","Name");

	for ( pr = arArray ; pr->pszAttr != NULL ; pr++)
	{
                GetProfileString(pr->pszSectionName,pr->pszAttr, "", buffer, sizeof(buffer));
		printf("%20s %-12s (%s) %s\n",
		       pr->pszSectionName,
		       pr->pszAttr,
		       buffer,
		       pr->pszDescription);

	}

}

void Usage(char *pszProgName)
{
	printf("Usage:\n\t%s <infolevel name> 0x<hexvalue>\tOR\n\t%s <attribute> <value>\n", pszProgName, pszProgName);
	printf("\nKnown infolevels are as follows\n\n");
	DumpInfoLevelRecords();
	printf("\nKnown attributes are as follows\n\n");
	DumpAttrRecords();
}

void _cdecl main(int argc, char *argv[])
{
	//
	// The command line specifies the infolevel, followed by the
	// value. There are a known set of infolevels.
	//
	//
	if (argc != 3)
	{
		Usage(argv[0]);
		return;
	}

	char *pszSectionName = LookupILSection(argv[1]);

        if (pszSectionName == NULL)
        {
                pszSectionName = LookupASection(argv[1]);
        }

	if (pszSectionName == NULL)
	{
		printf("Don't recognize %s as an infolevel or attribute\n",argv[1]);
		Usage(argv[0]);
		return;
	}

	if(!WriteProfileString(pszSectionName,argv[1],argv[2]))
	{
		printf("Error: WriteProfileString returns false\n");
		printf("GetLastError returns %x\n",GetLastError());
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\tools\rotdump\rotdump.cxx ===
#include <windows.h>
#include <ole2.h>
#include <stdio.h>

void _cdecl main(int argc, char *argv[])
{
	IRunningObjectTable *prot = NULL;
	HRESULT hr;
	IBindCtx *pbc = NULL;
	IEnumMoniker * penumMoniker = NULL;
	IMoniker *alpMonikers[100];
	DWORD dwReturned;
	DWORD dwTotalCount = 0;
	BOOL fFlushROT = FALSE;



	hr = CoInitialize(NULL);

	if (FAILED(hr))
	{
		printf("CoInitialize fails %x\n",hr);
		exit(-1);
	}

	if ((argc == 2) && strcmp(argv[1],"-f"))
	{
		printf("Valid flags are -f for flush\n");
		goto exitNow;
	}

	if( argc == 2)
	{
		fFlushROT = TRUE;
		printf("Flushing ROT as we go!\n");
	}

	hr = GetRunningObjectTable(0,&prot);					
	if (FAILED(hr))
	{
		printf("Get ROT failed! %x\n",hr);	
		goto exitNow;
	}

	hr = prot->EnumRunning(&penumMoniker);
	if (FAILED(hr))
	{
		printf("Enum ROT has failed %x\n",hr);
		goto exitNow;
	}

	hr = CreateBindCtx(0,&pbc);
	if(FAILED(hr))
	{
		printf("CreateBindContext returned %x\n",hr);
		goto exitNow;
	}

	do
	{
		hr = penumMoniker->Next(100,alpMonikers,&dwReturned);
		if(FAILED(hr))
		{
			printf("penumMoniker->Next failed %x\n",hr);
			goto exitNow;
		}

		for (DWORD i = 0 ; i < dwReturned ; i++)
		{
			LPWSTR pwcName;

			if(alpMonikers[i] == NULL) continue;

			hr = alpMonikers[i]->GetDisplayName(pbc,NULL,&pwcName);

			if(FAILED(hr))
			{
				printf("** MONIKER %x RETURNED ERRORCODE %x",i,hr);
			}
			else
			{
				printf("%S",pwcName);
				CoTaskMemFree(pwcName);
			}
			if(fFlushROT)
			{
				IUnknown *punk;
				hr = prot->GetObject(alpMonikers[i],&punk);
				if(FAILED(hr))
				{
					printf(" Flushed (hr=0x%x)",hr);
				}
				else
				{
					printf(" Connected. Releasing connection");
			
				}
			}
			printf("\n");
			alpMonikers[i]->Release();
			
		}
		dwTotalCount += dwReturned;
	} while(dwReturned == 100);

	printf("** Total number of entries is %u\n",dwTotalCount);

exitNow:
	if(prot != NULL)
	{
		prot->Release();
	}
	if(penumMoniker != NULL)
	{
		penumMoniker->Release();
	}
	if(pbc != NULL)
	{
		pbc->Release();
	}

	CoUninitialize();


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\utest\simple\simple.h ===
#define IDM_ABOUT   200
#define IDM_COINIT  101

int PASCAL WinMain(HANDLE, HANDLE, LPSTR, int);
BOOL InitApplication(HANDLE);
BOOL InitInstance(HANDLE, int);
LONG FAR PASCAL MainWndProc(HWND, UINT, WPARAM, LONG);
BOOL FAR PASCAL About(HWND, UINT, WPARAM, LONG);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\tools\zapknown\zapknown.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       ZAPKNOWN.C
//
//  Contents:   This tool will remove the OLE KnownDLL's entries from the
//		registry.
//----------------------------------------------------------------------------

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

void ZapEntry(HKEY hKnownKey, char *pszEntry)
{
    long l;

    l = RegDeleteValue(hKnownKey, pszEntry);
    if (l == ERROR_FILE_NOT_FOUND)
    {
	printf("FYI: %s isn't in the KnownDLL list (no problem)\n",pszEntry);
    } else if(l != ERROR_SUCCESS)
    {
    	printf("Warning: Could not delete %s (error 0x%x)\n",pszEntry,l);
    }
}

void AddExcludeEntry(HKEY hSesMan, char *pszEntry)
{
    long l, cbSize, cbEntry, cbTotal;
    DWORD dwType;
    char *pBuffer, *ptr, *pEnd;

    cbEntry = strlen(pszEntry);

    l = RegQueryValueEx(hSesMan, "ExcludeFromKnownDlls", 0,
                        &dwType, 0, &cbSize);
    if(ERROR_SUCCESS != l)
    {
        printf("Creating HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\ExcludeFromKnownDlls\n");
        cbSize = 1;
    }
    cbTotal = cbSize + cbEntry+1;
    pBuffer = GlobalAlloc(0, cbTotal);

    if(ERROR_SUCCESS == l)
    {
        l = RegQueryValueEx(hSesMan, "ExcludeFromKnownDlls", 0,
                            &dwType, pBuffer, &cbSize);
    }

    //
    // It succeeded above but now it fails ??
    //
    if(ERROR_SUCCESS != l || REG_MULTI_SZ != dwType)
    {
        printf("Sorry, Problems reading 'Session Manager\\ExcludeFromKnownDlls'\n");
        exit(0);
    }

    ptr = pBuffer;
    pEnd = pBuffer+cbSize-1;

    while(ptr < pEnd)
    {
        // if it is already there. when we are done.
        if(0 == strcmp(ptr, pszEntry))
            return;

        // Scan to end of the string and then onto the next string.
        while(ptr < pEnd && *ptr != '\0')
            ++ptr;
        ++ptr;
    }

    strcpy(pBuffer + cbSize-1, pszEntry);
    pBuffer[cbTotal-1] = '\0';      // The second NULL

    l = RegSetValueEx(hSesMan, "ExcludeFromKnownDlls", 0,
                        REG_MULTI_SZ, pBuffer, cbTotal);
    if(ERROR_SUCCESS != l)
    {
        printf("Error writing 'Session Manager\\ExcludeFromKnownDlls'\n");
        exit(0);
    }
}

HKEY    hSesMan, hKnownKey;

void ExcludeDll(char *pszDll)
{
    ZapEntry(hKnownKey, pszDll);
    AddExcludeEntry(hSesMan, pszDll);
}


int _cdecl main(
    int     argc,
    char    *argv[]
) {
    long    l;
    DWORD   dwRegValueType;
    CHAR    sz[2048];
    ULONG   ulSize;

    l = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                      "SYSTEM\\CurrentControlSet\\Control\\Session Manager",
                      0,
                      KEY_QUERY_VALUE | KEY_SET_VALUE,
                      &hSesMan );

    if(ERROR_SUCCESS != l)
    {
        printf("Failed to open HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\n");
        printf("Do you have administrator privleges?\n");
        exit(1);
    }

    l = RegOpenKeyEx(hSesMan, "KnownDlls", 0,
                     KEY_QUERY_VALUE | KEY_SET_VALUE, &hKnownKey);

    if(ERROR_SUCCESS != l)
    {
        printf("Failed to open HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Session Manager\\KnownDlls\n");
        printf("Do you have administrator privleges?\n");
        exit(1);
    }

    //
    // Delete OLE32.DLL, OLETHK32.DLL, OLEPRX32.DLL, and OLECNV32.DLL
    //
    ExcludeDll("OLE32");
    ExcludeDll("OLEAUT32");
    ExcludeDll("OLETHK32");
    ExcludeDll("OLECNV32");

    l = RegCloseKey( hSesMan );
    l = RegCloseKey( hKnownKey );

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\olethunk\tools\upknown\upknown.c ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       UPKNOWN.C
//
//  Contents:   This tool will add the three OLE2 DLL's to the known list
//		for wow.
//----------------------------------------------------------------------------

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

void FindAndDelete(
    char    *psz,
    char    *pszDeleteString
)
{
    char    *substr;
    char    temp[1024];
    char    *pstr;

    if ( psz == NULL )
    {
	return;
    }

    while ( TRUE ) {
        substr = strstr(psz,pszDeleteString);
        if ( substr == NULL ) {
            break;
        }

	pstr = substr;
	if ((substr > psz) && (substr[-1] == ' '))
	{
	    substr--;
	}

	*substr=0;
	strcat(psz,pstr+strlen(pszDeleteString));
    }

}
void FindOrAdd(
    char    *psz,
    char    *pszAddition
) {
    char    *substr;
    char    temp[1024];
    char    ch;

    strcpy(temp," ");
    strcat(temp,pszAddition);

    substr = psz;
    while ( TRUE ) {
        substr = strstr(substr,temp);
        if ( substr == NULL ) {
            break;
        }
        ch = *(substr+strlen(temp));

        if ( ch = ' ' || ch == '\0' ) {
            break;
        }
    }

    if ( substr == NULL )
    {
        strcat( psz, temp );
    }
}


int _cdecl main(
    int     argc,
    char    *argv[]
) {
    HKEY    WowKey;
    long    l;
    DWORD   dwRegValueType;
    CHAR    sz[2048];
    ULONG   ulSize;

    l = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                      "SYSTEM\\CurrentControlSet\\Control\\WOW",
                      0,
                      KEY_QUERY_VALUE | KEY_SET_VALUE,
                      &WowKey );

    if ( l != 0 ) {
        printf("Failed to open HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\WOW\n");
        printf("Do you have administrator privleges?\n");
        exit(1);
    }

    ulSize = sizeof(sz);

    l = RegQueryValueEx( WowKey,
                         "KnownDLLs",
                         NULL,
                         &dwRegValueType,
                         sz,
                         &ulSize );

    if ( l != ERROR_SUCCESS )
    {
        printf("Failed reading [WOWKEY]\\KnownDLLs\n");
        printf("Do you have administrator privleges?\n");
        exit(1);
    }

    if ( dwRegValueType != REG_SZ ) {
        printf("Internal error, [WOWKEY]\\KnownDLLs is not a REG_SZ (string)\n");
        exit(1);
    }

    printf("\nKey was: \"%s\"\n\n", sz );

    switch (argc)
    {
    case 1:
	FindOrAdd( sz, "compobj.dll" );
	FindOrAdd( sz, "storage.dll" );
	FindOrAdd( sz, "ole2.dll" );
	FindOrAdd( sz, "ole2disp.dll" );
	FindOrAdd( sz, "typelib.dll" );
	FindOrAdd( sz, "ole2nls.dll" );
	break;
    case 2:
	if( (strcmp(argv[1],"-r") == 0) ||
            (strcmp(argv[1],"/r") == 0))
	{
	    FindAndDelete( sz, "compobj.dll" );
	    FindAndDelete( sz, "storage.dll" );
	    FindAndDelete( sz, "ole2.dll" );
	    FindAndDelete( sz, "ole2disp.dll" );
	    FindAndDelete( sz, "typelib.dll" );
	    FindAndDelete( sz, "ole2nls.dll" );
	}
	else
	{
	    printf("Unknown parameters\n");
	    exit(1);
	}

	break;
    default:
	printf("Too many parameters\n");
	exit(1);

    }


    printf("Key is now: \"%s\"\n\n", sz );

    ulSize = strlen( sz );

    l = RegSetValueEx( WowKey,
                         "KnownDLLs",
                         0,
                         dwRegValueType,
                         sz,
                         ulSize+1 );

    if ( l != ERROR_SUCCESS ) {
        printf("Error setting value (l=%ld,0x%08lX)\n",l,l);
        printf("Do you have administrator privleges?\n");
        exit(1);
    }


    l = RegCloseKey( WowKey );

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleui\clspsht.h ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1997.
//
//  File:       ClsPSht.h
//
//  Contents:   
//
//  Classes:    
//
//  Methods:    
//
//  History:    
//
//----------------------------------------------------------------------

// This class defines custom modal property sheet
// CClsidPropertySheet.

#ifndef __CLSPSHT_H__
#define __CLSPSHT_H__

#include "LocPPg.h"
#include "epoptppg.h"

#define INPROC 0
#define LOCALEXE 1
#define SERVICE 2
#define PURE_REMOTE 3
#define REMOTE_LOCALEXE 4
#define REMOTE_SERVICE 5
#define SURROGATE 6

/////////////////////////////////////////////////////////////////////////////
// CClsidPropertySheet

class CClsidPropertySheet : public CPropertySheet
{
        DECLARE_DYNAMIC(CClsidPropertySheet)

// Construction
public:
        CClsidPropertySheet(CWnd* pParentWnd = NULL);
        BOOL InitData(
                CString szAppName,
                HKEY hkAppID,
                HKEY * rghkCLSID,
                unsigned cCLSIDs);

// Attributes
public:
        CGeneralPropertyPage  m_Page1;
        CLocationPropertyPage m_Page2;
        CSecurityPropertyPage m_Page3;
        CIdentityPropertyPage m_Page4;
        CRpcOptionsPropertyPage m_Page5;

// Operations
public:

// Overrides
        // ClassWizard generated virtual function overrides
        //{{AFX_VIRTUAL(CClsidPropertySheet)
        protected:
        virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
        //}}AFX_VIRTUAL

// Implementation
public:
        CString m_szAppName;
        HKEY    m_hkAppID;
        HKEY *  m_rghkCLSID;
        unsigned m_cCLSIDs;

        BOOL    ValidateAndUpdate(void);
        BOOL    ChangeCLSIDInfo(BOOL fLocal);
        BOOL    LookAtCLSIDs(void);

        virtual ~CClsidPropertySheet();

// Generated message map functions
protected:
        //{{AFX_MSG(CClsidPropertySheet)
        afx_msg BOOL OnNcCreate(LPCREATESTRUCT lpCreateStruct);
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

#endif  // __CLSPSHT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleui\clspsht.cpp ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1997.
//
//  File:       clspsht.cpp
//
//  Contents:   Implements class CClsidPropertySheet
//
//  Classes:
//
//  Methods:    CClsidPropertySheet::CClsidPropertySheet
//              CClsidPropertySheet::~CClsidPropertySheet
//              CClsidPropertySheet::InitData
//              CClsidPropertySheet::OnNcCreate
//              CClsidPropertySheet::ValidateAndUpdate
//              CClsidPropertySheet::OnCommand
//              CClsidPropertySheet::LookAtCLSIDs
//              CClsidPropertySheet::ChangeCLSIDInfo
//
//  History:    23-Apr-96   BruceMa    Created.
//
//----------------------------------------------------------------------


#include "stdafx.h"
#include "resource.h"
#include "clspsht.h"
#include "datapkt.h"

#if !defined(STANDALONE_BUILD)
extern "C"
{
#include <getuser.h>
}
#endif

#include "util.h"
#include "newsrvr.h"

#if !defined(STANDALONE_BUILD)
    extern "C"
    {
    #include <sedapi.h>
    #include <ntlsa.h>
    }
#endif

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif



/////////////////////////////////////////////////////////////////////////////
// CClsidPropertySheet

IMPLEMENT_DYNAMIC(CClsidPropertySheet, CPropertySheet)

CClsidPropertySheet::CClsidPropertySheet(CWnd* pParentWnd)
         : CPropertySheet(IDS_PROPSHT_CAPTION1, pParentWnd)
{
}

CClsidPropertySheet::~CClsidPropertySheet()
{
}

BEGIN_MESSAGE_MAP(CClsidPropertySheet, CPropertySheet)
        //{{AFX_MSG_MAP(CClsidPropertySheet)
        ON_WM_NCCREATE()
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

CClsidPropertySheet::InitData(
        CString szAppName,
        HKEY hkAppID,
        HKEY * rghkCLSID,
        unsigned cCLSIDs)
{
    m_szAppName = szAppName;
    m_hkAppID = hkAppID;
    m_rghkCLSID = rghkCLSID;
    m_cCLSIDs = cCLSIDs;

    // Save the appid key, the table of clsid keys and the application
    // title globally so the property pages can access them
    // it
    g_hAppid = hkAppID;
    g_rghkCLSID = rghkCLSID;
    g_cCLSIDs = cCLSIDs;
    g_szAppTitle = (TCHAR *) LPCTSTR(szAppName);

    m_Page2.m_fRemote = FALSE;
    m_Page4.m_fService = FALSE;
    m_Page2.m_fCanBeLocal = FALSE;
    m_Page2.m_fLocal = FALSE;
    m_Page1.m_fSurrogate = FALSE;

    if (!LookAtCLSIDs())
    {
        return FALSE;
    }

    TCHAR szBuffer[MAX_PATH];
    DWORD dwSize;
    long lErr;

    dwSize = sizeof(szBuffer);
    lErr = RegQueryValueEx(
            m_hkAppID,
            TEXT("LocalService"),
            NULL,
            NULL,
            (BYTE *)szBuffer,
            &dwSize);
    if (lErr == ERROR_SUCCESS)
    {
        m_Page1.m_szServerPath = szBuffer;
        m_Page4.m_fService = TRUE;
        m_Page2.m_fCanBeLocal = TRUE;
        m_Page2.m_fLocal = TRUE;
    }
    else
    {
        dwSize = sizeof(szBuffer);
        lErr = RegQueryValueEx(
                m_hkAppID,
                TEXT("_LocalService"),
                NULL,
                NULL,
                (BYTE *)szBuffer,
                &dwSize);
        if (lErr == ERROR_SUCCESS)
        {
            m_Page1.m_szServerPath = szBuffer;
            m_Page4.m_fService = TRUE;
            m_Page2.m_fCanBeLocal = TRUE;
        }
    }

    dwSize = sizeof(szBuffer);

    if (!m_Page2.m_fLocal)
    {
        lErr = RegQueryValueEx(
                m_hkAppID,
                TEXT("DllSurrogate"),
                NULL,
                NULL,
                (BYTE *)szBuffer,
                &dwSize);
        if (lErr == ERROR_SUCCESS)
        {
            if (szBuffer[0])
                m_Page1.m_szServerPath = szBuffer;
            else
                m_Page1.m_szServerPath.LoadString(IDS_DEFAULT);
            m_Page1.m_fSurrogate = TRUE;
        }

    }
    dwSize = sizeof(szBuffer);

    lErr = RegQueryValueEx(
            m_hkAppID,
            TEXT("RemoteServerName"),
            NULL,
            NULL,
            (BYTE *)szBuffer,
            &dwSize);
    if (lErr == ERROR_SUCCESS)
    {
        m_Page1.m_szComputerName = szBuffer;
        m_Page2.m_szComputerName = szBuffer;
        m_Page2.m_fRemote = TRUE;
    }

    m_Page2.m_fAtStorage = FALSE;
    dwSize = sizeof(szBuffer);
    lErr = RegQueryValueEx(
            m_hkAppID,
            TEXT("ActivateAtStorage"),
            NULL,
            NULL,
            (BYTE *)szBuffer,
            &dwSize);
    if (lErr == ERROR_SUCCESS)
    {
        if (szBuffer[0] ==  L'Y' || szBuffer[0] == L'y')
        {
//                      m_Page2.m_fRemote = TRUE;
            m_Page2.m_fAtStorage = TRUE;
        }
    }

    dwSize = sizeof(szBuffer);
    lErr = RegQueryValueEx(
            m_hkAppID,
            TEXT("RunAs"),
            NULL,
            NULL,
            (BYTE *)szBuffer,
            &dwSize);
    if (lErr == ERROR_SUCCESS)
    {
        // If the RunAs name is empty, jam in something
        if (szBuffer[0] == TEXT('\0'))
        {
            _tcscpy(szBuffer, TEXT("<domain>\\<user>"));
        }

        if (0 == _tcsicmp(szBuffer, TEXT("Interactive User")))
        {
            m_Page4.m_iIdentity = 0;
        }
        else
        {
            m_Page4.m_iIdentity = 2;
            m_Page4.m_szUserName = szBuffer;

            // Extract password from the Lsa private database
            g_util.RetrieveUserPassword(g_szAppid , m_Page4.m_szPassword);
            m_Page4.m_szConfirmPassword = m_Page4.m_szPassword;
        }
    }
    else
    {
        if (m_Page4.m_fService)
        {
            m_Page4.m_iIdentity = 3;
        }
        else
        {
            m_Page4.m_iIdentity = 1;
        }
    }

    m_Page1.m_szServerName = m_szAppName;

    if (!m_Page1.m_fSurrogate)
    {
        if (m_Page2.m_fCanBeLocal)
        {
            if (m_Page4.m_fService)
                m_Page1.m_iServerType = SERVICE;
            else
                m_Page1.m_iServerType = LOCALEXE;
            if (m_Page2.m_fRemote)
                m_Page1.m_iServerType += 3;
        }
        else
            m_Page1.m_iServerType = PURE_REMOTE;
    }
    else
    {
        m_Page1.m_iServerType = SURROGATE;
    }


    // Set the title
    SetTitle((const TCHAR *) m_szAppName, PSH_PROPTITLE);
    m_Page1.m_szServerName = m_szAppName;

    // TODO: If there are running instances, then make IDC_RUNNING,
    // IDC_LIST2, IDC_BUTTON1, IDC_BUTTON2, and IDC_BUTTON3 visible
    // and fill in IDC_LIST2 on page 1.

    m_Page2.m_pPage1 = &m_Page1;


    // Fetch RunAs key, LaunchPermission, AccessPermission and
    // ConfigurationPermission
    int   err;
    DWORD dwType;
    BYTE  bValue[16];
    BYTE *pbValue = NULL;
    ULONG ulSize = 1;

    m_Page3.m_iAccess = 0;
    m_Page3.m_iLaunch = 0;
    m_Page3.m_iConfig = 0;

    // "AccessPermission"
    // Note: We always expect to get ERROR_MORE_DATA
    err = RegQueryValueEx(g_hAppid, TEXT("AccessPermission"), 0,
                          &dwType, bValue, &ulSize);
    if (err == ERROR_MORE_DATA)
    {
        pbValue = (BYTE *)GlobalAlloc(GMEM_FIXED, ulSize);
        if (pbValue == NULL)
        {
            return FALSE;
        }
        err = RegQueryValueEx(g_hAppid, TEXT("AccessPermission"), 0,
                              &dwType, pbValue, &ulSize);
    }

    if (err == ERROR_SUCCESS && g_util.CheckForValidSD((SECURITY_DESCRIPTOR *)pbValue))
    {
        m_Page3.m_iAccess = 1;
        g_virtreg.NewRegSingleACL(g_hAppid,
                                  NULL,
                                  TEXT("AccessPermission"),
                                  (SECURITY_DESCRIPTOR *) pbValue,
                                  TRUE,    // Already in self-relative form
                                  &m_Page3.m_iAccessIndex);
        CDataPacket *pCdb = g_virtreg.GetAt(m_Page3.m_iAccessIndex);
        pCdb->SetModified(FALSE);
    }
    GlobalFree(pbValue);
    pbValue = NULL;

    // "LaunchPermission"
    // Note: We always expect to get ERROR_MORE_DATA
    ulSize = 1;
    pbValue = NULL;
    err = RegQueryValueEx(g_hAppid, TEXT("LaunchPermission"), 0,
                          &dwType, bValue, &ulSize);
    if (err == ERROR_MORE_DATA)
    {
        pbValue = (BYTE *)GlobalAlloc(GMEM_FIXED, ulSize);
        if (pbValue == NULL)
        {
            return FALSE;
        }
        err = RegQueryValueEx(g_hAppid, TEXT("LaunchPermission"), 0,
                              &dwType, pbValue, &ulSize);
    }

    if (err == ERROR_SUCCESS && g_util.CheckForValidSD((SECURITY_DESCRIPTOR *)pbValue))
    {
        m_Page3.m_iLaunch = 1;
        g_virtreg.NewRegSingleACL(g_hAppid,
                                  NULL,
                                  TEXT("LaunchPermission"),
                                  (SECURITY_DESCRIPTOR *) pbValue,
                                  TRUE,    // Already in self-relative form
                                  &m_Page3.m_iLaunchIndex);
        CDataPacket * pCdb = g_virtreg.GetAt(m_Page3.m_iLaunchIndex);
        pCdb->SetModified(FALSE);
    }
    GlobalFree(pbValue);
    pbValue = NULL;


    // "ConfigurationPermission"

    // Fetch the security descriptor on this AppID
    // Note: We always expect to get ERROR_INSUFFICIENT_BUFFER
    ulSize = 1;
    err = RegGetKeySecurity(g_hAppid,
                            OWNER_SECURITY_INFORMATION |
                            GROUP_SECURITY_INFORMATION |
                            DACL_SECURITY_INFORMATION,
                            pbValue,
                            &ulSize);
    if (err == ERROR_INSUFFICIENT_BUFFER)
    {
        pbValue = (BYTE *)GlobalAlloc(GMEM_FIXED, ulSize);
        if (pbValue == NULL)
        {
            return FALSE;
        }
        err = RegGetKeySecurity(g_hAppid,
                            OWNER_SECURITY_INFORMATION |
                            GROUP_SECURITY_INFORMATION |
                            DACL_SECURITY_INFORMATION,
                            pbValue,
                            &ulSize);
    }

    // Fetch the current security descriptor on HKEY_CLASSES_ROOT
    // Note: We always expect to get ERROR_INSUFFICIENT_BUFFER
    BYTE *pbValue2 = NULL;

    ulSize = 1;
    pbValue2 = NULL;
    err = RegGetKeySecurity(HKEY_CLASSES_ROOT,
                            OWNER_SECURITY_INFORMATION |
                            GROUP_SECURITY_INFORMATION |
                            DACL_SECURITY_INFORMATION,
                            pbValue2,
                            &ulSize);
    if (err == ERROR_INSUFFICIENT_BUFFER)
    {
        pbValue2 = (BYTE *)GlobalAlloc(GMEM_FIXED, ulSize);
        if (pbValue2 == NULL)
        {
            return FALSE;
        }
        err = RegGetKeySecurity(HKEY_CLASSES_ROOT,
                                OWNER_SECURITY_INFORMATION |
                                GROUP_SECURITY_INFORMATION |
                                DACL_SECURITY_INFORMATION,
                                pbValue2,
                                &ulSize);
    }

    // Now compare them.  If they differ then this AppId uses custom
    // configuration permissions

    if (err == ERROR_SUCCESS && g_util.CheckForValidSD((SECURITY_DESCRIPTOR *)pbValue))
    {
        if (!g_util.CompareSDs((PSrSecurityDescriptor) pbValue,
                               (PSrSecurityDescriptor) pbValue2))
        {
            err = g_virtreg.NewRegKeyACL(g_hAppid,
                                         rghkCLSID,
                                         cCLSIDs,
                                         g_szAppTitle,
                                         (SECURITY_DESCRIPTOR *) pbValue,
                                         (SECURITY_DESCRIPTOR *) pbValue,
                                         TRUE,
                                         &m_Page3.m_iConfigurationIndex);
            CDataPacket * pCdb = g_virtreg.GetAt(m_Page3.m_iConfigurationIndex);
            pCdb->SetModified(FALSE);
            m_Page3.m_iConfig = 1;
        }
    }
    GlobalFree(pbValue);
    GlobalFree(pbValue2);


    // Add all of the property pages here.  Note that
    // the order that they appear in here will be
    // the order they appear in on screen.  By default,
    // the first page of the set is the active one.
    // One way to make a different property page the
    // active one is to call SetActivePage().

    AddPage(&m_Page1);
    if (m_Page1.m_iServerType != SURROGATE)
    {
        AddPage(&m_Page2);
    }
    if (m_Page2.m_fCanBeLocal || m_Page1.m_fSurrogate)
    {
        AddPage(&m_Page3);
        AddPage(&m_Page4);
    }
    // add the property page for endpoint options
    AddPage(&m_Page5);
    m_Page5.InitData(szAppName, hkAppID);


    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CClsidPropertySheet message handlers


BOOL CClsidPropertySheet::OnNcCreate(LPCREATESTRUCT lpCreateStruct)
{
        if (!CPropertySheet::OnNcCreate(lpCreateStruct))
                return FALSE;

        ModifyStyleEx(0, WS_EX_CONTEXTHELP);

        return TRUE;
}

BOOL CClsidPropertySheet::ValidateAndUpdate(void)
{
    // Call update data on all initialized pages
    // to make sure that their private member variables are correct.
    long lErr;

    BOOL fReturn = UpdateData(TRUE);
    if (fReturn && m_Page1.m_hWnd)
        fReturn = m_Page1.ValidateChanges();
    if (fReturn && m_Page2.m_hWnd)
        fReturn = m_Page2.ValidateChanges();
    if (fReturn && m_Page3.m_hWnd)
        fReturn = m_Page3.ValidateChanges();
    if (fReturn && m_Page4.m_hWnd)
        fReturn = m_Page4.ValidateChanges();

    if (fReturn && m_Page5.m_hWnd)
        fReturn = m_Page5.ValidateChanges();

    if (!fReturn)
        return FALSE;

    m_Page1.UpdateChanges(m_hkAppID);
    m_Page2.UpdateChanges(m_hkAppID);
    m_Page3.UpdateChanges(m_hkAppID);
    m_Page4.UpdateChanges(m_hkAppID);
    m_Page5.UpdateChanges(m_hkAppID);

    ////////////////////////////////////////////////////////////////////
    // Persist cross page data

    if (m_Page4.m_fService)
    {
        if (m_Page2.m_fLocal)
        {
            BOOL fOk;

            // Write the LocalService value to the registry
            lErr = RegSetValueEx(
                    m_hkAppID,
                    TEXT("LocalService"),
                    0,
                    REG_SZ,
                    (BYTE *)(LPCTSTR)m_Page1.m_szServerPath,
                    (1 + m_Page1.m_szServerPath.GetLength()) * sizeof (TCHAR));
            lErr = RegDeleteValue(
                    m_hkAppID,
                    TEXT("_LocalService"));

            // Persist information to the service manager database
            if (m_Page4.m_iIdentity == 3)
            {
                fOk = g_util.ChangeService((LPCTSTR) m_Page1.m_szServerPath,
                                           TEXT("LocalSystem"),
                                           TEXT(""),
                                           (LPCTSTR) m_Page1.m_szServerName);
            }
            else
            {
                fOk = g_util.ChangeService((LPCTSTR) m_Page1.m_szServerPath,
                                           (LPCTSTR) m_Page4.m_szUserName,
                                           (LPCTSTR) m_Page4.m_szPassword,
                                           (LPCTSTR) m_Page1.m_szServerName);
            }
            if (!fOk)
            {
                return FALSE;
            }
        }
        else
        {
            lErr = RegSetValueEx(
                    m_hkAppID,
                    TEXT("_LocalService"),
                    0,
                    REG_SZ,
                    (BYTE *)(LPCTSTR)m_Page1.m_szServerPath,
                    (1 + m_Page1.m_szServerPath.GetLength()) * sizeof (TCHAR));
            lErr = RegDeleteValue(
                    m_hkAppID,
                    TEXT("LocalService"));
        }
    }

    return ChangeCLSIDInfo(m_Page2.m_fLocal);
}

BOOL CClsidPropertySheet::OnCommand(WPARAM wParam, LPARAM lParam)
{
        switch (LOWORD(wParam))
        {
        case IDOK:
        case ID_APPLY_NOW:
            if (!ValidateAndUpdate())
                return TRUE;
                break;
        }
        return CPropertySheet::OnCommand(wParam, lParam);
}

BOOL CClsidPropertySheet::LookAtCLSIDs(void)
{
    BOOL fFoundLocalServer = FALSE;
    TCHAR szBuffer[MAX_PATH];
    DWORD dwSize;
    HKEY hKey;
    long lErr;

    unsigned n = 0;
    while (n < m_cCLSIDs && !fFoundLocalServer)
    {
        lErr = RegOpenKeyEx(
                m_rghkCLSID[n],
                TEXT("LocalServer32"),
                0,
                KEY_ALL_ACCESS,
                &hKey);
        if (lErr == ERROR_SUCCESS)
        {
            dwSize = sizeof(szBuffer);
            lErr = RegQueryValueEx(
                    hKey,
                    TEXT(""),
                    NULL,
                    NULL,
                    (BYTE *)szBuffer,
                    &dwSize);
            if (lErr == ERROR_SUCCESS)
            {
                m_Page1.m_szServerPath = szBuffer;
                m_Page2.m_fLocal = TRUE;
                m_Page2.m_fCanBeLocal = TRUE;
                fFoundLocalServer = TRUE;
            }
            RegCloseKey(hKey);
        }


        if (!fFoundLocalServer)
        {
            lErr = RegOpenKeyEx(
                    m_rghkCLSID[n],
                    TEXT("LocalServer"),
                    0,
                    KEY_ALL_ACCESS,
                    &hKey);
            if (lErr == ERROR_SUCCESS)
            {
                dwSize = sizeof(szBuffer);
                lErr = RegQueryValueEx(
                        hKey,
                        TEXT(""),
                        NULL,
                        NULL,
                        (BYTE *)szBuffer,
                        &dwSize);
                if (lErr == ERROR_SUCCESS)
                {
                    m_Page1.m_szServerPath = szBuffer;
                    m_Page2.m_fLocal = TRUE;
                    m_Page2.m_fCanBeLocal = TRUE;
                    fFoundLocalServer = TRUE;
                }
                RegCloseKey(hKey);
            }
        }

        if (!fFoundLocalServer)
        {
            lErr = RegOpenKeyEx(
                    m_rghkCLSID[n],
                    TEXT("_LocalServer32"),
                    0,
                    KEY_ALL_ACCESS,
                    &hKey);
            if (lErr == ERROR_SUCCESS)
            {
                dwSize = sizeof(szBuffer);
                lErr = RegQueryValueEx(
                        hKey,
                        TEXT(""),
                        NULL,
                        NULL,
                        (BYTE *)szBuffer,
                        &dwSize);
                if (lErr == ERROR_SUCCESS)
                {
                    m_Page1.m_szServerPath = szBuffer;
                    m_Page2.m_fCanBeLocal = TRUE;
                    fFoundLocalServer = TRUE;
                }
                RegCloseKey(hKey);
            }
        }

        if (!fFoundLocalServer)
        {
            lErr = RegOpenKeyEx(
                    m_rghkCLSID[n],
                    TEXT("_LocalServer"),
                    0,
                    KEY_ALL_ACCESS,
                    &hKey);
            if (lErr == ERROR_SUCCESS)
            {
                dwSize = sizeof(szBuffer);
                lErr = RegQueryValueEx(
                        hKey,
                        TEXT(""),
                        NULL,
                        NULL,
                        (BYTE *)szBuffer,
                        &dwSize);
                if (lErr == ERROR_SUCCESS)
                {
                    m_Page1.m_szServerPath = szBuffer;
                    m_Page2.m_fCanBeLocal = TRUE;
                    fFoundLocalServer = TRUE;
                }
                RegCloseKey(hKey);
            }
        }

        n++;
    }
    return TRUE;
}




BOOL    CClsidPropertySheet::ChangeCLSIDInfo(BOOL fLocal)
{
    TCHAR szBuffer[MAX_PATH];
    CString szOld;
    CString szNew;
    CString szOld16;
    CString szNew16;
    DWORD dwSize;
    HKEY hKey;
    long lErr;

    if (fLocal)
    {
        szOld = TEXT("_LocalServer32");
        szNew = TEXT("LocalServer32");
        szOld16 = TEXT("_LocalServer");
        szNew16 = TEXT("LocalServer");
    }
    else
    {
        szOld = TEXT("LocalServer32");
        szNew = TEXT("_LocalServer32");
        szOld16 = TEXT("LocalServer");
        szNew16 = TEXT("_LocalServer");
    }

    unsigned n = 0;
    while (n < m_cCLSIDs)
    {
        // First do 32 servers
        lErr = RegOpenKeyEx(
                m_rghkCLSID[n],
                szOld,
                0,
                KEY_ALL_ACCESS,
                &hKey);
        if (lErr == ERROR_SUCCESS)
        {
            dwSize = sizeof(szBuffer);
            lErr = RegQueryValueEx(
                    hKey,
                    TEXT(""),
                    NULL,
                    NULL,
                    (BYTE *)szBuffer,
                    &dwSize);
            if (lErr == ERROR_SUCCESS)
            {
                HKEY hKeyNew;
                DWORD dwDisp;

                lErr = RegCreateKeyEx(
                        m_rghkCLSID[n],
                        szNew,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hKeyNew,
                        &dwDisp);
                if (lErr == ERROR_SUCCESS)
                {
                    lErr = RegSetValueEx(
                            hKeyNew,
                            TEXT(""),
                            NULL,
                            REG_SZ,
                            (BYTE *)szBuffer,
                            dwSize);
                    RegCloseKey(hKeyNew);
                }
            }
            RegCloseKey(hKey);
            lErr = RegDeleteKey(m_rghkCLSID[n], szOld);
        }


        // Then do 16 servers
        lErr = RegOpenKeyEx(
                m_rghkCLSID[n],
                szOld16,
                0,
                KEY_ALL_ACCESS,
                &hKey);
        if (lErr == ERROR_SUCCESS)
        {
            dwSize = sizeof(szBuffer);
            lErr = RegQueryValueEx(
                    hKey,
                    TEXT(""),
                    NULL,
                    NULL,
                    (BYTE *)szBuffer,
                    &dwSize);
            if (lErr == ERROR_SUCCESS)
            {
                HKEY hKeyNew;
                DWORD dwDisp;

                lErr = RegCreateKeyEx(
                        m_rghkCLSID[n],
                        szNew16,
                        0,
                        NULL,
                        REG_OPTION_NON_VOLATILE,
                        KEY_ALL_ACCESS,
                        NULL,
                        &hKeyNew,
                        &dwDisp);
                if (lErr == ERROR_SUCCESS)
                {
                    lErr = RegSetValueEx(
                            hKeyNew,
                            TEXT(""),
                            NULL,
                            REG_SZ,
                            (BYTE *)szBuffer,
                            dwSize);
                    RegCloseKey(hKeyNew);
                }
            }
            RegCloseKey(hKey);
            lErr = RegDeleteKey(m_rghkCLSID[n], szOld16);
        }

        n++;
    }
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleui\cnfgdlg.h ===
// CnfgDlg.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// COlecnfgDlg dialog

class COlecnfgDlg : public CDialog
{
// Construction
public:
    void OnProperties();
    COlecnfgDlg(CWnd* pParent = NULL);  // standard constructor

// Dialog Data
    //{{AFX_DATA(COlecnfgDlg)
    enum { IDD = IDD_OLECNFG_DIALOG };
        // NOTE: the ClassWizard will add data members here
    //}}AFX_DATA

    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(COlecnfgDlg)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    HICON m_hIcon;

    // Generated message map functions
    //{{AFX_MSG(COlecnfgDlg)
    virtual BOOL OnInitDialog();
    afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
    afx_msg void OnPaint();
    afx_msg HCURSOR OnQueryDragIcon();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleui\cstrings.cpp ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1997.
//
//  File:       cstrings.cpp
//
//  Contents:   Implements the class CStrings to manage a dynamically
//              expandable array of string pairs which may be enumerated
//
//  Classes:
//
//  Methods:    CStrings::CStrings
//              CStrings::~CStrings
//              CStrings::PutItem
//              CStrings::FindItem
//              CStrings::FindAppid
//              CStrings::AddClsid
//              CStrings::InitGetNext
//              CStrings::GetNextItem
//              CStrings::GetItem
//              CStrings::GetNumItems
//              CStrings::RemoveItem
//              CStrings::RemoveAll
//
//  History:    23-Apr-96   BruceMa     Created.
//
//----------------------------------------------------------------------
#include "stdafx.h"
#include "types.h"
#include "cstrings.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

CStrings::CStrings(void)
{
    m_nCount = 0;
}

CStrings::~CStrings(void)
{
    RemoveAll();
}


// Store a string pair, expanding the array if necessary
SItem *CStrings::PutItem(TCHAR *szString, TCHAR *szTitle, TCHAR *szAppid)
{
    SItem *psTemp = new SItem(szString, szTitle, szAppid);

    if (psTemp )
        arrSItems.Add(psTemp);

    return psTemp;
}



SItem *CStrings::FindItem(TCHAR *szItem)
{
    for (int wItem = 0; wItem < arrSItems.GetSize(); wItem++)
    {
        SItem* pTmp = (SItem*)arrSItems.GetAt(wItem);
        if (pTmp -> szItem .CompareNoCase(szItem) == 0)
            return pTmp;
    }

    return NULL;
}



SItem *CStrings::FindAppid(TCHAR *szAppid)
{
    for (int wItem = 0; wItem < arrSItems.GetSize(); wItem++)
    {
        SItem* pTmp = (SItem*)arrSItems.GetAt(wItem);
        if (!(pTmp -> szItem.IsEmpty())  &&
            (pTmp -> szAppid.CompareNoCase(szAppid) == 0))
        {
            return pTmp;
        }
    }

    return NULL;
}

BOOL CStrings::AddClsid(SItem *pItem, TCHAR *szClsid)
{
    // Create or expand the clsid table if necessary
    if (pItem->ulClsids == pItem->ulClsidTbl)
    {
        TCHAR **ppTmp = new TCHAR *[pItem->ulClsidTbl + 8];
        if (ppTmp == NULL)
        {
            return FALSE;
        }
        if (pItem->ppszClsids)
        {
            memcpy(ppTmp,
                   pItem->ppszClsids,
                   pItem->ulClsids * sizeof(TCHAR *));
            delete pItem->ppszClsids;
        }
        pItem->ppszClsids = ppTmp;
        pItem->ulClsidTbl += 8;
    }

    // Add the new clsid
    TCHAR *pszTmp = new TCHAR[GUIDSTR_MAX + 1];
    if (pszTmp == NULL)
    {
        return FALSE;
    }
        _tcscpy(pszTmp, szClsid);
    pItem->ppszClsids[pItem->ulClsids++] = pszTmp;

    return TRUE;
}

// Prepare to enumerate the array
DWORD CStrings::InitGetNext(void)
{
    m_nCount = 0;
    return (DWORD)arrSItems.GetSize();
}




// Return the first string in the next eumerated item
SItem *CStrings::GetNextItem(void)
{
    if (m_nCount < arrSItems.GetSize())
    {
        return (SItem*)(arrSItems[m_nCount++]);
    }
    else
    {
        m_nCount = 0;
        return NULL;
    }
}

// Return the first string in the next eumerated item
SItem *CStrings::GetItem(DWORD dwItem)
{
    if (((int)dwItem) < arrSItems.GetSize())
    {
        return (SItem*)(arrSItems[dwItem]);
    }
    else
    {
        m_nCount = 0;
        return NULL;
    }
}




// Return the total number of items
DWORD CStrings::GetNumItems(void)
{
    return (DWORD)arrSItems.GetSize();
}

// Given an item index, remove it
BOOL CStrings::RemoveItem(DWORD dwItem)
{
    if (((int)dwItem) < arrSItems.GetSize())
    {
        SItem* pTmp = (SItem*)arrSItems.GetAt(dwItem);

        if (pTmp)
        {
            arrSItems.RemoveAt(dwItem);
            delete pTmp;
            return TRUE;
        }
    }

    return FALSE;
}

// Remove the array of items
BOOL CStrings::RemoveAll(void)
{
    int nItems = (int)arrSItems.GetSize();

    for (int nItem = 0; nItem < nItems; nItem++)
    {
        SItem* pTmp = (SItem*)arrSItems.GetAt(nItem);
        delete pTmp;
    }

    arrSItems.RemoveAll();

    return TRUE;
}

SItem::SItem(LPCTSTR sItem, LPCTSTR sTitle, LPCTSTR sAppid)
: szItem(sItem), szTitle(sTitle), szAppid(sAppid)
{
    fMarked = FALSE;
    fChecked = FALSE;
    fHasAppid = FALSE;
    fDontDisplay = FALSE;
    ulClsids = 0;
    ulClsidTbl = 0;
    ppszClsids = 0;
}

SItem::~SItem()
{
    for (UINT k = 0; k < ulClsids; k++)
    {
        delete ppszClsids[k];
    }
    ulClsids = 0;
    ulClsidTbl = 0;
    delete ppszClsids;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleui\cnfgpsht.cpp ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1997.
//
//  File:       cnfgpsht.cpp
//
//  Contents:   Implements class COlecnfgPropertySheet
//
//  Classes:
//
//  Methods:    COlecnfgPropertySheet::COlecnfgPropertySheet
//              COlecnfgPropertySheet::~COlecnfgPropertySheet
//              COlecnfgPropertySheet::DoModal
//              COlecnfgPropertySheet::Create
//              COlecnfgPropertySheet::OnNcCreate
//              COlecnfgPropertySheet::OnCommand
//
//  History:    23-Apr-96   BruceMa    Created.
//
//----------------------------------------------------------------------


#include "stdafx.h"
#include "afxtempl.h"
#include "resource.h"
#include "cstrings.h"
#include "creg.h"
#include "types.h"
#include "datapkt.h"

#if !defined(STANDALONE_BUILD)
    extern "C"
    {
    #include <getuser.h>
    }
#endif

#include "util.h"
#include "virtreg.h"
#include "CnfgPSht.h"



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// COlecnfgPropertySheet

IMPLEMENT_DYNAMIC(COlecnfgPropertySheet, CPropertySheet)

COlecnfgPropertySheet::COlecnfgPropertySheet(CWnd* pWndParent)
: CPropertySheet(IDS_PROPSHT_CAPTION, pWndParent)
{
    // Set the title
    CString sTitle;
    sTitle.LoadString(IDS_PSMAIN_TITLE);
    SetTitle(sTitle, PSH_PROPTITLE);
    
    // Add all of the property pages here.  Note that
    // the order that they appear in here will be
    // the order they appear in on screen.  By default,
    // the first page of the set is the active one.
    // One way to make a different property page the
    // active one is to call SetActivePage().
    
    // Disable property sheet help button
    m_psh.dwFlags &= ~PSH_HASHELP;
    m_Page1.m_psp.dwFlags &= ~PSH_HASHELP;
    m_Page2.m_psp.dwFlags &= ~PSH_HASHELP;
    m_Page3.m_psp.dwFlags &= ~PSH_HASHELP;
#ifndef _CHICAGO_
    m_Page4.m_psp.dwFlags &= ~PSH_HASHELP;
#endif 

    AddPage(&m_Page1);
    AddPage(&m_Page2);
    AddPage(&m_Page3);
#ifndef _CHICAGO_
    AddPage(&m_Page4);
#endif
}

COlecnfgPropertySheet::~COlecnfgPropertySheet()
{
}


BEGIN_MESSAGE_MAP(COlecnfgPropertySheet, CPropertySheet)
//{{AFX_MSG_MAP(COlecnfgPropertySheet)
ON_WM_NCCREATE()
ON_WM_DESTROY()
//}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// COlecnfgPropertySheet message handlers



INT_PTR COlecnfgPropertySheet::DoModal()
{
    return CPropertySheet::DoModal();
}

BOOL COlecnfgPropertySheet::Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext)
{
    return CWnd::Create(lpszClassName, lpszWindowName, dwStyle, rect, pParentWnd, nID, pContext);
}

BOOL COlecnfgPropertySheet::OnNcCreate(LPCREATESTRUCT lpCreateStruct)
{
    if (!CPropertySheet::OnNcCreate(lpCreateStruct))
        return FALSE;

    // Enable context help
    ModifyStyleEx(0, WS_EX_CONTEXTHELP);

    return TRUE;
}

BOOL COlecnfgPropertySheet::OnCommand(WPARAM wParam, LPARAM lParam)
{
    // TODO: Add your specialized code here and/or call the base class
    switch (LOWORD(wParam))
    {
    case IDOK:
    case ID_APPLY_NOW:
        g_virtreg.ApplyAll();

        
        // Check whether the user changed something that requires a notification to DCOM
        if (g_fReboot)
        {
            g_util.UpdateDCOMInfo();

            // With the above interface to the SCM we don't have to ask the
            // user whether to reboot.  However, I'll keep the code for
            // posterity.
/*
            CString sCaption;
            CString sMessage;

            sCaption.LoadString(IDS_SYSTEMMESSAGE);
            sMessage.LoadString(IDS_REBOOT);
            if (MessageBox(sMessage, sCaption, MB_YESNO) == IDYES)
            {
                if (g_util.AdjustPrivilege(SE_SHUTDOWN_NAME))
                {
                    // Now reboot
                    ExitWindowsEx(EWX_REBOOT, 0);
                }
            }
*/
        }

        break;

    }
    return CPropertySheet::OnCommand(wParam, lParam);
}


void COlecnfgPropertySheet::OnDestroy()
{
    CPropertySheet::OnDestroy();

    if (g_fReboot)
    {
        // On NT, with the above interface to the SCM (UpdateDCOMInfo)
        // we don't have to ask the user whether to reboot.
#ifdef _CHICAGO_
        CString sCaption;
        CString sMessage;

        sCaption.LoadString(IDS_SYSTEMMESSAGE);
        sMessage.LoadString(IDS_PERHAPSREBOOT);
        sMessage.LoadString(IDS_REBOOT);
        if (MessageBox(sMessage, sCaption, MB_YESNO) == IDYES)
        {
//            if (g_util.AdjustPrivilege(SE_SHUTDOWN_NAME))
//            {
                // Now reboot
                ExitWindowsEx(EWX_REBOOT, 0);
//            }
        }
#endif
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleui\cnfgpsht.h ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1997.
//
//  File:       cnfgpsht.h
//
//  Contents:   Defines class COlecnfgPropertySheet
//
//  Classes:    
//
//  Methods:    
//
//  History:    23-Apr-96   BruceMa    Created.
//
//----------------------------------------------------------------------

 
#ifndef __CNFGPSHT_H__
#define __CNFGPSHT_H__

#include "SrvPPg.h"
#ifndef _CHICAGO_
    #include "defprot.h"
#endif

/////////////////////////////////////////////////////////////////////////////
// COlecnfgPropertySheet

class COlecnfgPropertySheet : public CPropertySheet
{
    DECLARE_DYNAMIC(COlecnfgPropertySheet)

// Construction
public:
    COlecnfgPropertySheet(CWnd* pParentWnd = NULL);

// Attributes
public:
    CServersPropertyPage m_Page1;
    CMachinePropertyPage m_Page2;  
    CDefaultSecurityPropertyPage m_Page3;
#ifndef _CHICAGO_
    CDefaultProtocols    m_Page4;
#endif


// Operations
public:

    // Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(COlecnfgPropertySheet)
    public:
    virtual INT_PTR DoModal();
    virtual BOOL Create(LPCTSTR lpszClassName, LPCTSTR lpszWindowName, DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID, CCreateContext* pContext = NULL);
    protected:
    virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam);
    //}}AFX_VIRTUAL

    // Implementation
public:
    virtual ~COlecnfgPropertySheet();

    // Generated message map functions
protected:
    //{{AFX_MSG(COlecnfgPropertySheet)
    afx_msg BOOL OnNcCreate(LPCREATESTRUCT lpCreateStruct);
    afx_msg void OnDestroy();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

#endif  // __CNFGPSHT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleui\datapkt.cpp ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1997.
//
//  File:       datapkt.cpp
//
//  Contents:   Implements the class CDataPacket to manages diverse data
//              packets needing to be written to various databases
//
//  Classes:
//
//  Methods:    CDataPacket::CDataPacket (x 7)
//              CDataPacket::~CDataPacket
//              CDataPacket::ChgSzValue
//              CDataPacket::ChgDwordValue
//              CDataPacket::ChgACL
//              CDataPacket::ChgPassword
//              CDataPacket::ChgSrvIdentity
//
//  History:    23-Apr-96   BruceMa    Created.
//              12-Dec-96   RonanS      Added copy constructor to CDataPacket
//                                      to get around bugs when copying CDataPacket.
//                                      Fixed memory leaks in destructor.
//                                      Simplified constructor code.
//              09-Jan-97   SteveBl     Modified to support IAccessControl.
//
//----------------------------------------------------------------------



#include "stdafx.h"
#include "assert.h"
#include "datapkt.h"

#if !defined(STANDALONE_BUILD)
extern "C"
{
#include <getuser.h>
}
#endif

#include "util.h"

static TCHAR *  TStrDup(const TCHAR  *lpszString)
{
    TCHAR * lpszTmp = NULL;
    int nStrlen = 0;

    if (lpszString )
        {
        lpszTmp = new TCHAR[_tcslen(lpszString) + 1];
        ASSERT(lpszTmp);

        _tcscpy(lpszTmp, lpszString);
        }

    return lpszTmp;
}

CDataPacket::CDataPacket(void)
{
    m_tagType = Empty;
    m_fDelete = FALSE;
    m_fDeleteHive = FALSE;
    m_hRoot = 0;
    SetModified(TRUE);
}

CDataPacket::CDataPacket(HKEY   hRoot,
                         TCHAR *szKeyPath,
                         TCHAR *szValueName,
                         DWORD dwValue)
:m_szKeyPath(szKeyPath), m_szValueName(szValueName)
{
    m_tagType = NamedValueDword;
    m_hRoot = hRoot;
    pkt.nvdw.dwValue = dwValue;
    SetModified(TRUE);
    m_fDelete = FALSE;
    m_fDeleteHive = FALSE;
}



CDataPacket::CDataPacket(HKEY   hRoot,
                         TCHAR *szKeyPath,
                         TCHAR *szValueName,
                         SECURITY_DESCRIPTOR *pSec,
                         BOOL   fSelfRelative)
:m_szKeyPath(szKeyPath), m_szValueName(szValueName)
{
    int                  err;
    ULONG                cbLen;
    SECURITY_DESCRIPTOR *pSD;

    m_tagType = SingleACL;
    m_hRoot = hRoot;

    // Get the security descriptor into self relative form so we
    // can cache it

    // Force first call to fail so we can get the real size needed
    if (!fSelfRelative)
    {
        cbLen = 1;
        if (!MakeSelfRelativeSD(pSec, NULL, &cbLen))
        {
            err = GetLastError();
        }

        // Now really do it
        pSD = (SECURITY_DESCRIPTOR *) GlobalAlloc(GMEM_FIXED, cbLen);
        if (!pSD) 
        {   
            ReportOutOfMemAndTerminate();
            // will never get here
            return;
        }
        if (!MakeSelfRelativeSD(pSec, pSD, &cbLen))
        {
            err = GetLastError();
        }
        pkt.acl.pSec   = pSD;
    }
    else
    {
        // The security descriptor is aready in self relative form
        // as it was read directly from the registry.  However, we still
        // have to copy the it.
        g_util.CopySD(pSec, &pkt.acl.pSec);
    }

    SetModified(TRUE);
    m_fDelete = FALSE;
    m_fDeleteHive = FALSE;
}



CDataPacket::CDataPacket(HKEY     hKey,
                         HKEY    *phClsids,
                         unsigned cClsids,
                         TCHAR   *szTitle,
                         SECURITY_DESCRIPTOR *pSecOrig,
                         SECURITY_DESCRIPTOR *pSec,
                         BOOL   fSelfRelative)
{
    ULONG                cbLen;
    SECURITY_DESCRIPTOR *pSD;

    m_tagType = RegKeyACL;
    m_hRoot = hKey;

    pkt.racl.phClsids = phClsids;
    pkt.racl.cClsids = cClsids;
    pkt.racl.szTitle = TStrDup(szTitle);

    // Get the new security descriptor into self relative form so we
    // can cache it (if we have to)
    if (!fSelfRelative)
    {
        // Force first call to fail so we can get the real size needed
        cbLen = 1;
        MakeSelfRelativeSD(pSec, NULL, &cbLen);

        // Now really do it
        pSD = (SECURITY_DESCRIPTOR *) GlobalAlloc(GMEM_FIXED, cbLen);
        if (!pSD) 
        {   
            ReportOutOfMemAndTerminate();
            // will never get here
            return;
        }
        MakeSelfRelativeSD(pSec, pSD, &cbLen);
        pkt.racl.pSec   = pSD;
    }
    else
    {
        g_util.CopySD(pSec, &pkt.racl.pSec);
    }

    // The original security descriptor is aready in self relative form
    // as it was read directly from the registry.  (The edited SD from the
    // ACL editor is in absolute form.)  However, we still have to copy the
    // original SD.
    g_util.CopySD(pSecOrig, &pkt.racl.pSecOrig);

    SetModified(TRUE);
    m_fDelete = FALSE;
    m_fDeleteHive = FALSE;
}



CDataPacket::CDataPacket(TCHAR *szPassword,
                         CLSID appid)
{
    m_tagType = Password;
    pkt.pw.szPassword = TStrDup(szPassword);
    pkt.pw.appid      = appid;
    SetModified(TRUE);
    m_fDelete = FALSE;
    m_hRoot = 0;
    m_fDeleteHive = FALSE;
}



CDataPacket::CDataPacket(TCHAR *szServiceName,
                         TCHAR *szIdentity)
{
    m_hRoot = 0;
    m_tagType = ServiceIdentity;
    pkt.si.szServiceName = TStrDup(szServiceName);
    pkt.si.szIdentity = TStrDup(szIdentity);
    SetModified(TRUE);
    m_fDelete = FALSE;
    m_fDeleteHive = FALSE;
}

CRegSzNamedValueDp::CRegSzNamedValueDp(const CRegSzNamedValueDp& rDataPacket)
: CDataPacket((const CDataPacket & ) rDataPacket)
{
    m_szValue = rDataPacket.m_szValue;
}

CDataPacket::CDataPacket( const CDataPacket & rDataPacket)
:m_szKeyPath (rDataPacket.m_szKeyPath), m_szValueName(rDataPacket.m_szValueName)
{
    m_tagType = rDataPacket.m_tagType;
    m_fModified = rDataPacket.m_fModified;
    m_fDelete = rDataPacket.m_fDelete;
    m_hRoot = rDataPacket.m_hRoot;

    switch (m_tagType)
    {
    case NamedValueSz:
        // handled by derived class
        break;
        
    case NamedValueDword:
        pkt.nvdw.dwValue = rDataPacket.pkt.nvdw.dwValue;
        break;

    case SingleACL:
        // Get the security descriptor into self relative form so we
        g_util.CopySD(rDataPacket.pkt.acl.pSec, &pkt.acl.pSec);
        break;

    case RegKeyACL:
        pkt.racl.phClsids = rDataPacket.pkt.racl.phClsids;
        pkt.racl.cClsids = rDataPacket.pkt.racl.cClsids;
        pkt.racl.szTitle = TStrDup(rDataPacket.pkt.racl.szTitle);
        g_util.CopySD(rDataPacket.pkt.racl.pSec, &pkt.racl.pSec);
        g_util.CopySD(rDataPacket.pkt.racl.pSecOrig, &pkt.racl.pSecOrig);
        break;

    case Password:
        pkt.pw.szPassword = TStrDup(rDataPacket.pkt.pw.szPassword);
        pkt.pw.appid = rDataPacket.pkt.pw.appid;
        break;

    case ServiceIdentity:
        pkt.si.szServiceName = TStrDup(rDataPacket.pkt.si.szServiceName);
        pkt.si.szIdentity = TStrDup(rDataPacket.pkt.si.szIdentity);
        break;

    case Empty:
        break;
    }
}



CDataPacket::~CDataPacket()
{

    switch (m_tagType)
    {
    case NamedValueSz:
        // handled by derived class
        break;

    case NamedValueDword:
        break;

    case SingleACL:
        if (pkt.acl.pSec)
            GlobalFree(pkt.acl.pSec);
        break;

    case RegKeyACL:
        if (pkt.racl.szTitle)
            delete pkt.racl.szTitle;
        if (pkt.racl.pSec)
            GlobalFree(pkt.racl.pSec);
        if (pkt.racl.pSecOrig)
            GlobalFree(pkt.racl.pSecOrig);
        break;

    case Password:
        if (pkt.pw.szPassword)
            delete pkt.pw.szPassword;
        break;

    case ServiceIdentity:
        if (pkt.si.szServiceName)
            delete pkt.si.szServiceName;
        if (pkt.si.szIdentity)
            delete pkt.si.szIdentity;
        break;
    }
}


void CRegSzNamedValueDp::ChgSzValue(TCHAR *szValue)
{
    assert(m_tagType == NamedValueSz);
    m_szValue = szValue;
    SetModified(TRUE);
}


void CDataPacket::ChgDwordValue(DWORD dwValue)
{
    assert(m_tagType == NamedValueDword);
    pkt.nvdw.dwValue = dwValue;
    SetModified(TRUE);
}



void CDataPacket::ChgACL(SECURITY_DESCRIPTOR *pSec, BOOL fSelfRelative)
{
    ULONG                cbLen;
    SECURITY_DESCRIPTOR *pSD;

    assert(m_tagType == SingleACL  ||  m_tagType == RegKeyACL);

    // Remove the previous security descriptor
    if (m_tagType == SingleACL)
    {
        GlobalFree(pkt.acl.pSec);
        pkt.acl.pSec = NULL;
    }
    else
    {
        GlobalFree(pkt.racl.pSec);
        pkt.racl.pSec = NULL;
    }

    // Put into self relative form (if necessary)
    if (!fSelfRelative)
    {
        cbLen = 1;
        MakeSelfRelativeSD(pSec, NULL, &cbLen);

        // Now really do it
        pSD = (SECURITY_DESCRIPTOR *) GlobalAlloc(GMEM_FIXED, cbLen);
        if (!pSD) 
        {   
            ReportOutOfMemAndTerminate();
            // will never get here
            return;
        }
        MakeSelfRelativeSD(pSec, pSD, &cbLen);

        // Store it
        if (m_tagType == SingleACL)
        {
            pkt.acl.pSec = pSD;
        }
        else
        {
            pkt.racl.pSec = pSD;
        }
    }
    else
    {
        if (m_tagType == SingleACL)
        {
            g_util.CopySD(pSec, &pkt.acl.pSec);
        }
        else
        {
            g_util.CopySD(pSec, &pkt.racl.pSec);
        }
    }
    SetModified(TRUE);
}



void CDataPacket::ChgPassword(TCHAR *szPassword)
{
    if (m_tagType != Password)
        return;
    if (pkt.pw.szPassword)
        delete pkt.pw.szPassword;
    pkt.pw.szPassword = TStrDup(szPassword);
    SetModified(TRUE);
}



void CDataPacket::ChgSrvIdentity(TCHAR *szIdentity)
{
    assert(m_tagType == ServiceIdentity);
    if (pkt.si.szIdentity)
        delete pkt.si.szIdentity;
    pkt.si.szIdentity =  TStrDup(szIdentity);
    SetModified(TRUE);
}


void CDataPacket::MarkForDeletion(BOOL bDelete)
{
    m_fDelete = bDelete;
    SetModified(TRUE);
}

void CDataPacket::MarkHiveForDeletion(BOOL bDelete)
{
    m_fDelete = bDelete;
    m_fDeleteHive = bDelete;
    SetModified(TRUE);
}

int CDataPacket::Apply()
{
    int err = ERROR_SUCCESS;

    if (m_fModified)
    {
        if (m_fDelete)
            err = Remove();
        else
            err = Update();
    }

    // Cleanup work
    if (err == ERROR_SUCCESS)
    {
        m_fModified = FALSE;
    }
    else
    {
        if (err == ERROR_ACCESS_DENIED)
        {
            g_util.CkForAccessDenied(ERROR_ACCESS_DENIED);
        }
        else
        {
            g_util.PostErrorMessage();
        }
    }

    return err;

}

int CDataPacket::Update()
{
    int err = ERROR_SUCCESS;

    ASSERT(m_fModified);
    switch (m_tagType)
    {
    case Empty:
        break;

    case NamedValueSz:
        ASSERT(FALSE); // we should never reach here
        break;

    case NamedValueDword:
        {
            err = g_util.WriteRegDwordNamedValue(m_hRoot,
                                                 (LPCTSTR)m_szKeyPath,
                                                 (LPCTSTR)m_szValueName,
                                                 pkt.nvdw.dwValue);
        }
        break;

    case SingleACL:
        {
            err = g_util.WriteRegSingleACL(m_hRoot,
                                           (LPCTSTR)m_szKeyPath,
                                           (LPCTSTR)m_szValueName,
                                           pkt.acl.pSec);
        }
        break;

    case RegKeyACL:
        err = g_util.WriteRegKeyACL(m_hRoot,
                                    pkt.racl.phClsids,
                                    pkt.racl.cClsids,
                                    pkt.racl.pSec,
                                    pkt.racl.pSecOrig);
        break;

    case Password:
        err = g_util.WriteLsaPassword(pkt.pw.appid,
                                      pkt.pw.szPassword);
        break;

    case ServiceIdentity:
        err = g_util.WriteSrvIdentity(pkt.si.szServiceName,
                                      pkt.si.szIdentity);
        break;
    }

    return err;
}


long CDataPacket::Read(HKEY hKey)
{
    return 0;
}

int CDataPacket::Remove()
{
    int err = ERROR_SUCCESS;

    if (m_fModified && m_fDelete)
    {
        switch (m_tagType)
        {
        case Empty:
            break;

        case SingleACL:
        case NamedValueDword:
        case NamedValueSz:
        case NamedValueMultiSz:
            if (m_fDeleteHive)
                g_util.DeleteRegKey(m_hRoot,(LPCTSTR)m_szKeyPath);
            else
                g_util.DeleteRegValue(m_hRoot,
                                      (LPCTSTR)m_szKeyPath,
                                      (LPCTSTR)m_szValueName);
            break;

        case RegKeyACL:
            err = g_util.WriteRegKeyACL(m_hRoot,
                                        pkt.racl.phClsids,
                                        pkt.racl.cClsids,
                                        pkt.racl.pSec,
                                        pkt.racl.pSecOrig);
            break;

        case Password:
            err = g_util.WriteLsaPassword(pkt.pw.appid,
                                          pkt.pw.szPassword);
            break;

        case ServiceIdentity:
            err = g_util.WriteSrvIdentity(pkt.si.szServiceName,
                                          pkt.si.szIdentity);
            break;
        }
    }

    return err;
}

//
//  ReportOutOfMemAndTerminate
//
//  Dcomcnfg was not coded very well to handle out-of-memory
//  errors in certain spots.   Rather than rip out and replace
//  lots of code to fix this properly, I am simply going to report
//  an error and terminate the process when this occurs.  Dcomnfg
//  as of now only ships in the reskit, not in the os.
//
void CDataPacket::ReportOutOfMemAndTerminate()
{
    CString sTitle;
    CString sMessage;

    if (sTitle.LoadString(IDS_FATALOUTOFMEMORYTITLE))
    {
        if (sMessage.LoadString(IDS_FATALOUTOFMEMORY))
        {
            MessageBoxW(NULL, sMessage, sTitle, MB_ICONWARNING | MB_OK | MB_TASKMODAL);
        }
    }

    TerminateProcess(GetCurrentProcess(), ERROR_NOT_ENOUGH_MEMORY);

    // will never get here
    return;
}


//*****************************************************************************
//
// class CRegSzNamedValueDp
//
// data packet for RegSZ named value
//
//*****************************************************************************
int CRegSzNamedValueDp::Update()
{
    int err = ERROR_SUCCESS;

    ASSERT(m_tagType == NamedValueSz);
    ASSERT(m_fModified);

    err = g_util.WriteRegSzNamedValue(m_hRoot,
                      (LPCTSTR)m_szKeyPath,
                      (LPCTSTR)m_szValueName,
                      (LPCTSTR)m_szValue,
                      m_szValue.GetLength() + 1);
    return err;
}

long CRegSzNamedValueDp::Read(HKEY hkey)
{
    return 0;
}

CString CRegSzNamedValueDp::Value()
{
    return m_szValue;
}


CRegSzNamedValueDp::CRegSzNamedValueDp(HKEY hRoot, TCHAR *szKeyPath, TCHAR *szValueName, TCHAR *szValue)
: m_szValue(szValue)
{
    m_tagType = NamedValueSz;
    m_hRoot = hRoot;
    m_szKeyPath = szKeyPath;
    m_szValueName = szValueName;
}


BOOL CDataPacket::IsIdentifiedBy(HKEY hRoot, TCHAR *szKeyPath, TCHAR *szValueName)
{
    if (((m_tagType == NamedValueSz) &&
         (m_hRoot == hRoot) &&
         (m_szKeyPath == szKeyPath) &&
         (m_szValueName == szValueName)) ||
        ((m_tagType == NamedValueDword) &&
         (m_hRoot == hRoot) &&
         (m_szKeyPath == szKeyPath)  &&
         (m_szValueName == szValueName) ))
        return TRUE;

    return FALSE;
}

BOOL CRegSzNamedValueDp::IsIdentifiedBy(HKEY hRoot, TCHAR * szKeyPath, TCHAR * szValueName)
{
    if (((m_tagType == NamedValueSz) &&
         (m_hRoot == hRoot) &&
         (m_szKeyPath == szKeyPath) &&
         (m_szValueName == szValueName)))
        return TRUE;

    return FALSE;
}

//////////////////////////////////////////////////////////////////////
// CRegMultiSzNamedValueDp Class
//////////////////////////////////////////////////////////////////////

//////////////////////////////////////////////////////////////////////
// Construction/Destruction
//////////////////////////////////////////////////////////////////////

CRegMultiSzNamedValueDp::CRegMultiSzNamedValueDp(HKEY hRoot, TCHAR *szKeyPath, TCHAR *szValueName)
{
    m_tagType = NamedValueMultiSz;
    m_hRoot = hRoot;
    m_szKeyPath = szKeyPath;
    m_szValueName = szValueName;
}

CRegMultiSzNamedValueDp::~CRegMultiSzNamedValueDp()
{

}

BOOL CRegMultiSzNamedValueDp::IsIdentifiedBy(HKEY hRoot, TCHAR * szKeyPath, TCHAR * szValueName)
{
    if (((m_tagType == NamedValueMultiSz) &&
         (m_hRoot == hRoot) &&
         (m_szKeyPath == szKeyPath) &&
         (m_szValueName == szValueName)))
        return TRUE;

    return FALSE;
}

int CRegMultiSzNamedValueDp::Update()
{
    int err = ERROR_SUCCESS;

    ASSERT(m_tagType == NamedValueMultiSz);
    ASSERT(m_fModified);

    // build up string to save
    // calculate size of string
    int nSize=0, nIndex = 0;

    for (nIndex = 0; nIndex < m_strValues.GetSize(); nIndex ++)
    {
        CString sTmp = m_strValues.GetAt(nIndex);
        nSize += sTmp.GetLength()+1;
    }
    nSize += 2;

    // build up string to save
    TCHAR* lpszTmp = new TCHAR[nSize];
    if (lpszTmp)
    {
        int nOffset = 0;
        for (nIndex = 0; nIndex < m_strValues.GetSize(); nIndex ++)
        {
            CString sTmp = m_strValues.GetAt(nIndex);
            _tcscpy((TCHAR*)(&lpszTmp[nOffset]), (LPCTSTR) sTmp);
            nOffset += sTmp.GetLength()+1;
        }

        // finish with two nulls
        lpszTmp[nOffset++] = TEXT('\0');
        lpszTmp[nOffset++] = TEXT('\0');
    
        err = g_util.WriteRegMultiSzNamedValue(m_hRoot,
                          (LPCTSTR)m_szKeyPath,
                          (LPCTSTR)m_szValueName,
                          lpszTmp,
                          nOffset);
        delete lpszTmp;
    }

    return err;
}

void CRegMultiSzNamedValueDp::Clear()
{
    m_strValues.RemoveAll();
}

long CRegMultiSzNamedValueDp::Read(HKEY hKey)
{
    ASSERT(hKey  != NULL);

    HKEY hkEndpoints = NULL;

    DWORD dwType = REG_MULTI_SZ;
    DWORD dwcbBuffer = 1024;
    TCHAR* pszBuffer = new TCHAR[1024];

    ASSERT(pszBuffer != NULL);

    // try to read values into default sized buffer
    LONG lErr = RegQueryValueEx(hKey, 
                        (LPCTSTR)m_szValueName, 
                        0, 
                        &dwType, 
                        (LPBYTE)pszBuffer,
                        &dwcbBuffer);

    // if buffer is not big enough, extend it and reread
    if (lErr == ERROR_MORE_DATA)
    {
        delete  pszBuffer;
        DWORD dwNewSize = (dwcbBuffer + 1 / sizeof(TCHAR));
        pszBuffer = new TCHAR[dwNewSize];
        if (pszBuffer)
            dwcbBuffer = dwNewSize;
    
        lErr = RegQueryValueEx(m_hRoot, 
                        (LPCTSTR)m_szValueName, 
                        0, 
                        &dwType, 
                        (LPBYTE)pszBuffer,
                        &dwcbBuffer);
    }

    if ((lErr == ERROR_SUCCESS) && 
        (dwcbBuffer > 0) &&
        (dwType == REG_MULTI_SZ))
    {
        // parse each string
        TCHAR * lpszRegEntry = pszBuffer;

        while(lpszRegEntry && *lpszRegEntry)
        {
            // caclulate length of entry
            CString sTmp(lpszRegEntry);
            int nLenEntry = sTmp.GetLength();
            m_strValues.Add(sTmp);

            lpszRegEntry += nLenEntry+1;
        }
    }
    else if ((lErr != ERROR_SUCCESS) && (lErr != ERROR_FILE_NOT_FOUND))
        g_util.PostErrorMessage();

    delete pszBuffer;
    SetModified(FALSE);

    return lErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleui\creg.h ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1997.
//
//  File:       creg.h
//
//  Contents:   Defines class CRegistry to wrap registry access
//
//  Classes:    
//
//  Methods:    
//
//  History:    23-Apr-96   BruceMa    Created.
//
//----------------------------------------------------------------------

typedef enum {_LOCALSERVER, LOCALSERVER, _LOCALSERVER32, LOCALSERVER32,
              LOCALSERVICE, REMOTESERVER} SRVTYPE;


// Wraps registry access

class CRegistry
{
 public:

            CRegistry(void);

           ~CRegistry(void);

    BOOL    Init(void);

    BOOL    InitGetItem(void);

    SItem  *GetNextItem(void); 

    SItem  *GetItem(DWORD dwItem);

    SItem  *FindItem(TCHAR *szItem);

    SItem  *FindAppid(TCHAR *szAppid);

    void    AppendIndex(SItem *pItem, DWORD dwIndex);

    DWORD   GetNumItems(void);

 private:

    CStrings m_applications;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleui\creg.cpp ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1997.
//
//  File:       creg.cpp
//
//  Contents:   Implements class CRegistry to wrap registry access
//
//  Classes:
//
//  Methods:    CRegistry::CRegistry
//              CRegistry::~CRegistry
//              CRegistry::Init
//              CRegistry::InitGetItem
//              CRegistry::GetNextItem
//              CRegistry::GetItem
//              CRegistry::FindItem
//              CRegistry::FindAppid
//              CRegistry::AppendIndex
//              CRegistry::GetNumItems
//
//  History:    23-Apr-96   BruceMa    Created.
//
//----------------------------------------------------------------------



#include "stdafx.h"
#include "resource.h"
#include "types.h"
#include "cstrings.h"
#include "creg.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

CRegistry::CRegistry(void)
{
    m_applications.RemoveAll();
}


CRegistry::~CRegistry(void)
{
}




// Access and store all application names and associated appid's
BOOL CRegistry::Init(void)
{
    int    err;
    HKEY   hKey;
    DWORD  dwSubKey;
    TCHAR  szTitle[MAX_PATH];
    TCHAR  szAppid[MAX_PATH];
    TCHAR  szCLSID[MAX_PATH];
    TCHAR  szBuffer[MAX_PATH];
    LONG   lSize;
    DWORD  dwType;
    DWORD  dwDisposition;

    // Cleanup any previous run
    m_applications.RemoveAll();


    // First enumerate HKEY_CLASSES_ROOT\CLSID picking up all .exe

    // Open HKEY_CLASSES_ROOT\CLSID
    if (RegOpenKeyEx(HKEY_CLASSES_ROOT, TEXT("CLSID"), 0, KEY_READ |  KEY_WRITE,
                     &hKey) != ERROR_SUCCESS)
    {
        return FALSE;
    }

    // Enumerate the CLSID subkeys
    dwSubKey = 0;
    while (RegEnumKey(hKey, dwSubKey, szCLSID, sizeof(szCLSID) / sizeof(TCHAR))
           == ERROR_SUCCESS)
    {
        TCHAR  szPath[MAX_PATH];
        HKEY    hKey2;
        SRVTYPE srvType;

        // Prepare for next key
        dwSubKey++;

        // Open this key
        if (RegOpenKeyEx(hKey, szCLSID, 0, KEY_READ |  KEY_WRITE,
                         &hKey2) == ERROR_SUCCESS)
        {
            // Check for subkeys "LocalServer32", "_LocalServer32",
            // "LocalServer", and "_LocalServer"
            lSize = MAX_PATH * sizeof(TCHAR);
            err = RegQueryValue(hKey2, TEXT("LocalServer32"), szPath,
                                &lSize);
            srvType = LOCALSERVER32;

            if (err != ERROR_SUCCESS)
            {
                lSize = MAX_PATH * sizeof(TCHAR);
                err = RegQueryValue(hKey2, TEXT("_LocalServer32"), szPath,
                                    &lSize);
                srvType = _LOCALSERVER32;
            }

            if (err != ERROR_SUCCESS)
            {
                lSize = MAX_PATH * sizeof(TCHAR);
                err = RegQueryValue(hKey2, TEXT("LocalServer"), szPath,
                                    &lSize);
                srvType = LOCALSERVER;
            }

            if (err != ERROR_SUCCESS)
            {
                lSize = MAX_PATH * sizeof(TCHAR);
                err = RegQueryValue(hKey2, TEXT("_LocalServer"), szPath,
                                    &lSize);
                srvType = _LOCALSERVER;
            }

            if (err != ERROR_SUCCESS)
            {
                RegCloseKey(hKey2);
                continue;
            }

            // Strip off any command line parameters -
            // it's the executale path that determines an item.  Because
            // of quotes, embedded spaces, etc. we scan for ".exe"
            int k = 0;

            // szPath is executable path
            while (szPath[k])
            {
                if (szPath[k]     == TEXT('.')      &&
                    szPath[k + 1]  &&  (szPath[k + 1] == TEXT('e')  ||
                                        szPath[k + 1] == TEXT('E'))    &&
                    szPath[k + 2]  &&  (szPath[k + 2] == TEXT('x')  ||
                                        szPath[k + 2] == TEXT('X'))    &&
                    szPath[k + 3]  &&  (szPath[k + 3] == TEXT('e')  ||
                                        szPath[k + 3] == TEXT('E')))
                {
                    break;
                }

                k++;
            }

            // Just continue if we don't have an .exe path
            if (!szPath[k])
            {
                RegCloseKey(hKey2);
                continue;
            }

            // Increment to the nominal end of the path
            k += 4;

            // In case the entire path is surrounded by quotes
            if (szPath[k] == TEXT('"'))
            {
                k++;
            }
            szPath[k] = TEXT('\0');

            // Read the AppID for this clsid (if any)
            BOOL fUseThisClsid = FALSE;

            lSize = MAX_PATH * sizeof(TCHAR);
            if (RegQueryValueEx(hKey2, TEXT("AppID"), NULL, &dwType,
                                (UCHAR *) szAppid, (ULONG *) &lSize)
                != ERROR_SUCCESS)
            {
                // Use this clsid as the appid
                fUseThisClsid = TRUE;
            }

            // If this is a 16-bit server without an existing AppId
            // named value then skip it
            if ((srvType == LOCALSERVER  ||  srvType == _LOCALSERVER)  &&
                fUseThisClsid == TRUE)
            {
                RegCloseKey(hKey2);
                continue;
            }

            // Read the title for the item
            BOOL fNoTitle = FALSE;

            lSize = MAX_PATH * sizeof(TCHAR);
            if (RegQueryValueEx(hKey2, NULL, NULL, &dwType,
                                (UCHAR *) szTitle, (ULONG *) &lSize)
                != ERROR_SUCCESS)
            {
                fNoTitle = TRUE;
            }
            else if (szTitle[0] == TEXT('\0'))
            {
                fNoTitle = TRUE;
            }

            // If both the item (the executable path) and the title
            // (the unnamed value on the CLSID) are empty, then skip
            // this entry
            if (szPath[0] == TEXT('\0')  &&
                (fNoTitle  ||  szTitle[0] == TEXT('\0')))
            {
                RegCloseKey(hKey2);
                continue;
            }

            // Check whether we already have this item in the table - we
            // search differently depending on whether this clsid already
            // has an associated appid
            SItem *pItem;

            if (fUseThisClsid)
            {
                // check if application is in list
                pItem = FindItem(szPath);
            }
            else
            {
                pItem = FindAppid(szAppid);
            }

            if (pItem == NULL)
            {
                // Create a new item
                // szPath is path, szCLSID is CLSID
                pItem = m_applications.PutItem(szPath[0] ? szPath : szCLSID,
                                               fNoTitle ? szCLSID : szTitle,
                                          fUseThisClsid ? szCLSID : szAppid);
                if (pItem == NULL)
                {
                    RegCloseKey(hKey2);
                    RegCloseKey(hKey);
                    return FALSE;
                }

                // Note whether the clsid had an appid named value
                pItem->fHasAppid = !fUseThisClsid;
            }

            // Write the AppId for this class if it doesn't exist
            lSize = MAX_PATH * sizeof(TCHAR);
            if (RegQueryValueEx(hKey2, TEXT("AppID"), 0, &dwType,
                                (BYTE *) szBuffer, (ULONG *) &lSize)
                != ERROR_SUCCESS)
            {
                if (RegSetValueEx(hKey2, TEXT("AppID"), 0, REG_SZ,
                                  (const BYTE *) (LPCTSTR)pItem->szAppid,
                                 (pItem->szAppid.GetLength() + 1) * sizeof(TCHAR))
                    != ERROR_SUCCESS)
                {
                    RegCloseKey(hKey2);
                    RegCloseKey(hKey);
                    return FALSE;
                }
            }

            // Now add this clsid to the table of clsid's for this .exe
            if (!m_applications.AddClsid(pItem, szCLSID))
            {
                RegCloseKey(hKey2);
                RegCloseKey(hKey);
                return FALSE;
            }

            // Close the key
            RegCloseKey(hKey2);
        }
    } // End of the enumeration over HKEY_CLASSES_ROOT\CLSID

    // Close the key on HKEY_CLASSES_ROOT\CLSID
    RegCloseKey(hKey);



    // Create or open the key "HKEY_CLASSES_ROOT\AppID"
    if (RegCreateKeyEx(HKEY_CLASSES_ROOT, TEXT("AppID"), 0, NULL,
                       REG_OPTION_NON_VOLATILE, KEY_READ |  KEY_WRITE, NULL, &hKey,
                       &dwDisposition) != ERROR_SUCCESS)
    {
        return FALSE;
    }

    // Enumerate keys under HKEY_CLASSES_ROOT\AppID
    dwSubKey = 0;
    while (RegEnumKey(hKey, dwSubKey, szCLSID, sizeof(szCLSID) / sizeof(TCHAR)) == ERROR_SUCCESS)
    {
        // Prepare for next key
        dwSubKey++;

        // Only look at entries having an AppId format
        if (!(szCLSID[0] == TEXT('{')          &&
              _tcslen(szCLSID) == GUIDSTR_MAX  &&
              szCLSID[37] == TEXT('}')))
        {
            continue;
        }

        // Check if this appid is already in the table
        SItem *pItem = FindAppid(szCLSID);

        // read title
        TCHAR szTitle[MAX_PATH];
        long  lSize = MAX_PATH * sizeof(TCHAR);

        // Read its unnamed value as the title
        szTitle[0] = TEXT('\0');
        err = RegQueryValue(hKey, szCLSID, szTitle, &lSize);

        // If not create an item entry so it can be displayed in the UI
        if (pItem == NULL)
        {
            // Store this item
            pItem = m_applications.PutItem(NULL,
                                           szTitle[0] ? szTitle : szCLSID,
                                           szCLSID);
            if (pItem == NULL)
                return FALSE;
        }
        else
        {
            // ronans - bugfix for raided bug
            // change existing item title to AppID title if there is one
            if ((err == ERROR_SUCCESS) && szTitle[0])
            {
                pItem -> szTitle = (LPCTSTR)szTitle;
            }
        }

        // Mark it so we don't rewrite it to HKEY_CLASSES_ROOT\AppID
        pItem->fMarked = TRUE;
    } // End enumeration of HKEY_CLASSES_ROOT\AppID



    // Enumerate through the table of items, writing to HKEY_CLASSES_ROOT\AppID
    // any items that are not marked
    SItem *pItem;

    m_applications.InitGetNext();
    for (pItem = GetNextItem(); pItem; pItem = GetNextItem())
    {
        HKEY hKey2;

        // If this item has an AppID but is unmarked, then ask the user
        // whether he really wants to create the AppID
        if (!pItem->fMarked  &&  pItem->fHasAppid)
        {
            CString szMessage;
            CString szDCOM_;
            CString szNULL;
            TCHAR   szText[MAX_PATH*2];
            TCHAR  *szParms[3];

            szMessage.LoadString(IDS_CLSID_);
            szDCOM_.LoadString(IDS_DCOM_Configuration_Warning);
            szNULL.LoadString(IDS_NULL);

            szParms[0] = pItem->ppszClsids[0];
            szParms[1] = !pItem->szItem.IsEmpty() ? (TCHAR *) ((LPCTSTR)pItem->szItem)
                : (TCHAR *) ((LPCTSTR) szNULL);
            szParms[2] = !pItem->szTitle.IsEmpty() ? (TCHAR *) ((LPCTSTR)pItem->szTitle)
                : (TCHAR *) ((LPCTSTR) szNULL);

            FormatMessage(FORMAT_MESSAGE_FROM_STRING |
                          FORMAT_MESSAGE_ARGUMENT_ARRAY,
                          (TCHAR *) ((LPCTSTR) szMessage),
                          0,
                          0,
                          szText,
                          MAX_PATH*2 * sizeof(TCHAR),
                          (va_list *) szParms);

            if (MessageBox(GetForegroundWindow(),
                           szText,
                           (TCHAR *) ((LPCTSTR) szDCOM_),
                           MB_YESNO) == IDNO)
            {
                pItem->fMarked = TRUE;
                pItem->fDontDisplay = TRUE;
            }
        }

        // If this item is not marked then, then create an appid key for
        // it under HKEY_CLASSES_ROOT\AppID and, separately, write the
        // .exe name under HKEY_CLASSES_ROOT\AppID
        if (!pItem->fMarked)
        {
            if (RegCreateKeyEx(hKey, pItem->szAppid, 0, NULL,
                               REG_OPTION_NON_VOLATILE, KEY_READ |  KEY_WRITE, NULL, &hKey2,
                               &dwDisposition) == ERROR_SUCCESS)
            {
                // Write the item title as the unnamed value
                if (!pItem->szTitle.IsEmpty())
                {
                    RegSetValueEx(hKey2, NULL, 0, REG_SZ,(BYTE *) (LPCTSTR) pItem->szTitle,
                                  (pItem->szTitle.GetLength() + 1) * sizeof(TCHAR));
                }

                // Close it
                RegCloseKey(hKey2);


                // Write the .exe name if it's not empty
                if (!(pItem->szItem.IsEmpty()))
                {
                    // Extract the .exe name
                    int k = pItem->szItem.ReverseFind(TEXT('\\'));
                    CString szExe = pItem->szItem.Mid((k != -1) ? k+1 : 0);

                    // remove trailing quotes on executable name if necessary
                    k = szExe.GetLength();
                    if (k && (szExe.GetAt(k-1) == TEXT('\"')))
                        szExe = szExe.Left(k-1);

                    // Write the .exe name as a key
                    if (RegCreateKeyEx(hKey, (LPCTSTR)szExe, 0, NULL,
                               REG_OPTION_NON_VOLATILE, KEY_READ |  KEY_WRITE, NULL, &hKey2,
                               &dwDisposition) == ERROR_SUCCESS)
                    {
                    // Now write the associated AppId as a named value
                    RegSetValueEx(hKey2, TEXT("AppId"), 0, REG_SZ,
                                  (BYTE *)(LPCTSTR) pItem->szAppid,
                                  (pItem->szAppid.GetLength() + 1) * sizeof(TCHAR));

                    RegCloseKey(hKey2);
                    }
                }
            }
            else // dont continue on failure
                break;
        }
    }

    // Close the key on HKEY_CLASSES_ROOT\AppID
    RegCloseKey(hKey);


    // We display applications by their titles (e.g. "Microsoft Word 6.0")
    // which have to be unique because we're going to uniquely associate
    // an entry in the list box with the index of its associated SItem
    // structure.  So here we make sure all the titles are unique.
    DWORD  cbItems = m_applications.GetNumItems();

    // Compare all non-empty titles of the same length.  If they are
    // not unique, then append "(<index>)" to make them unique
    for (DWORD k = 0; k < cbItems; k++)
    {
        DWORD dwIndex = 1;
        SItem *pItem = m_applications.GetItem(k);

        if (!(pItem->szTitle.IsEmpty())  &&  !pItem->fChecked)
        {
            for (DWORD j = k + 1; j < cbItems; j++)
            {
                SItem *pItem2 = m_applications.GetItem(j);

                if (!pItem2->fChecked  &&
                    (pItem->szTitle == pItem2->szTitle))
                {
                    if (dwIndex == 1)
                    {
                        AppendIndex(pItem, 1);
                        dwIndex++;
                    }
                    AppendIndex(pItem2, dwIndex++);
                    pItem2->fChecked = TRUE;
                }
            }
        }
    }


    // Prepare for the UI enumerating item entries
    m_applications.InitGetNext();

    return TRUE;
}





BOOL CRegistry::InitGetItem(void)
{
    return m_applications.InitGetNext();
}




// Enumerate the next application name
SItem *CRegistry::GetNextItem(void)
{
    return m_applications.GetNextItem();
}




// Get a specific item
SItem *CRegistry::GetItem(DWORD dwItem)
{
    return m_applications.GetItem(dwItem);
}



SItem *CRegistry::FindItem(TCHAR *szPath)
{
    return m_applications.FindItem(szPath);
}



SItem *CRegistry::FindAppid(TCHAR *szAppid)
{
    return m_applications.FindAppid(szAppid);
}




void CRegistry::AppendIndex(SItem *pItem, DWORD dwIndex)
{
    CString szTmp;
    szTmp.Format(TEXT(" (%d)"),dwIndex);

    pItem->szTitle += szTmp;
}



DWORD CRegistry::GetNumItems(void)
{
    return m_applications.GetNumItems();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleui\cstrings.h ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1997.
//
//  File:       cstrings.h
//
//  Contents:   Defines the class CStrings to manage a dynamically
//              expandable array of string pairs which may be enumerated
//
//  Classes:  
//
//  Methods:    
//
//  History:    23-Apr-96   BruceMa    Created.
//
//----------------------------------------------------------------------


const DWORD INCREMENT_SIZE = 1024;


class SItem : public CObject
{
public:

    SItem(LPCTSTR sItem, LPCTSTR sTitle, LPCTSTR sAppid);
    ~SItem();

// data members
    CString szItem;
    CString szTitle;
    CString szAppid;
    ULONG   fMarked:1;
    ULONG   fChecked:1;
    ULONG   fHasAppid:1;
    ULONG   fDontDisplay:1;
    UINT    ulClsids;
    UINT    ulClsidTbl;
    TCHAR **ppszClsids;
};


class CStrings
{
 public:

           CStrings(void);
          ~CStrings(void);

   SItem  *PutItem(TCHAR *szString, TCHAR *szTitle, TCHAR *szAppid);
   SItem  *FindItem(TCHAR *szItem);
   SItem  *FindAppid(TCHAR *szAppid);
   BOOL    AddClsid(SItem *pItem, TCHAR *szClsid);
   DWORD   InitGetNext(void);
   SItem  *GetNextItem(void);
   SItem  *GetItem(DWORD dwItem);
   DWORD   GetNumItems(void);
   BOOL    RemoveItem(DWORD dwItem);
   BOOL    RemoveAll(void);


 private:

   CObArray arrSItems;
   int  m_nCount;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleui\datapkt.h ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1997.
//
//  File:       datapkt.h
//
//  Contents:   Defines the class CDataPacket to manages diverse data
//              packets needing to be written to various databases
//
//  Classes:
//
//  Methods:
//
//  History:    23-Apr-96   BruceMa    Created.
//
//----------------------------------------------------------------------


#ifndef _DATAPKT_H_
#define _DATAPKT_H_

typedef enum tagPACKETTYPE {
    Empty, 
    NamedValueSz, 
    NamedValueDword, 
    SingleACL,
    RegKeyACL, 
    Password, 
    ServiceIdentity, 
    NamedValueMultiSz, 
    RegistryNode
} PACKETTYPE;

typedef struct
{
    TCHAR *szValue;
} SNamedValueSz, *PNamedValueSz;

typedef struct
{
  int Dummy;
} SNamedValueMultiSz;

typedef struct
{
    DWORD  dwValue;
} SNamedValueDword, *PNamedValueDword;

typedef struct
{
    SECURITY_DESCRIPTOR *pSec;
} SSingleACL, *PSingleACL;


typedef struct
{
    HKEY                *phClsids;
    unsigned             cClsids;
    TCHAR               *szTitle;
    SECURITY_DESCRIPTOR *pSec;
    SECURITY_DESCRIPTOR *pSecOrig;
} SRegKeyACL, *PRegKeyACL;


typedef struct
{
    TCHAR *szPassword;
    CLSID  appid;
} SPassword, *PPassword;


typedef struct
{
    TCHAR *szServiceName;
    TCHAR *szIdentity;
} SServiceIdentity, *PServiceIdentity;


class CDataPacket
{
public:

    CDataPacket(void);

    CDataPacket(HKEY   hRoot,
                TCHAR *szKeyPath,
                TCHAR *szValueName,
                DWORD  dwValue);

    CDataPacket(HKEY   hRoot,
                TCHAR *szKeyPath,
                TCHAR *szValueName,
                SECURITY_DESCRIPTOR *pSec,
                BOOL   fSelfRelative);

    CDataPacket(HKEY     hKey,
                HKEY    *phClsids,
                unsigned cClsids,
                TCHAR   *szTitle,
                SECURITY_DESCRIPTOR *pSecOrig,
                SECURITY_DESCRIPTOR *pSec,
                BOOL   fSelfRelative);

    CDataPacket(TCHAR *szPassword, CLSID apid);

    CDataPacket(TCHAR *szServiceName, TCHAR *szIdentity);

    CDataPacket(PACKETTYPE pktType,
                HKEY       hRoot,
                TCHAR     *szKeyPath,
                TCHAR     *szValueName);

    CDataPacket(const CDataPacket& rDataPacket);
    virtual ~CDataPacket();


    void ChgDwordValue(DWORD dwValue);

    void ChgACL(SECURITY_DESCRIPTOR *pSec, BOOL fSelfRelative);

    void ChgPassword(TCHAR *szPassword);

    void ChgSrvIdentity(TCHAR *szIdentity);

    void MarkForDeletion(BOOL);
    void MarkHiveForDeletion(BOOL bDelete);

    void SetModified(BOOL fDirty);
    BOOL IsDeleted();
    BOOL IsModified();

    virtual int Apply();

    virtual long Read(HKEY hKey);
    virtual int Remove();
    virtual int Update();

    DWORD GetDwordValue();
    

    virtual BOOL IsIdentifiedBy(HKEY hRoot,TCHAR *, TCHAR*);

    PACKETTYPE m_tagType;
    BOOL       m_fModified;
    BOOL       m_fDelete;
    BOOL       m_fDeleteHive;
    HKEY       m_hRoot;
    CString    m_szKeyPath;
    CString    m_szValueName;

    union
    {
        SNamedValueSz    nvsz;
        SNamedValueDword nvdw;
        SSingleACL       acl;
        SRegKeyACL       racl;
        SPassword        pw;
        SServiceIdentity si;
        SNamedValueMultiSz nvmsz;
    } pkt;

private:

    void ReportOutOfMemAndTerminate();

};

inline void CDataPacket::SetModified(BOOL fDirty)
{
    m_fModified = fDirty;
}

inline BOOL CDataPacket::IsModified()
{
    return m_fModified;
}


inline BOOL CDataPacket::IsDeleted()
{
    return m_fDelete;
}

inline DWORD CDataPacket::GetDwordValue()
{
    return pkt.nvdw.dwValue;
}
                     
class CRegSzNamedValueDp : public CDataPacket
{
public:
    CRegSzNamedValueDp(HKEY hRoot, TCHAR *szKeyPath, TCHAR *szValueName, TCHAR *szValue);
    CRegSzNamedValueDp(const CRegSzNamedValueDp&);

    virtual BOOL IsIdentifiedBy(HKEY hRoot, TCHAR *szKeyPath, TCHAR *szValueName);
    virtual int Update();
    virtual long Read(HKEY hkey);

    CString Value();
    void ChgSzValue(TCHAR *szValue);

private:
    CString m_szValue;
};

class CRegMultiSzNamedValueDp : public CDataPacket  
{
public:
    CRegMultiSzNamedValueDp(HKEY hRoot, TCHAR *szKeyPath, TCHAR *szValueName);
    virtual ~CRegMultiSzNamedValueDp();

    virtual long Read(HKEY hKey);
    virtual int Update();
    virtual BOOL IsIdentifiedBy(HKEY hRoot, TCHAR *szKeyPath, TCHAR *szValueName);
    void Clear();

    CStringArray& Values() { return m_strValues; }
private:
    CStringArray m_strValues;
};

#endif // _DATAPKT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleui\dcomcnfg.cpp ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1994.
//
//  File:       dcomcnfg.cpp
//
//  Contents:   Simply wraps the true top level source program olecnfg.cpp
//
//  Classes:    
//
//  Functions:  
//
//  History:    23-Apr-96   BruceMa    Created.
//
//----------------------------------------------------------------------

#include "stdafx.h"

#include "olecnfg.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleui\defprot.cpp ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1997.
//
//  File:       defprot.cpp
//
//  Contents:   Implementation of Default protocols property page
//
//  Classes:    CDefaultProtocols
//
//  Methods:
//
//  History:    ??-oct-97   RonanS    Created.
//
//----------------------------------------------------------------------
#include "stdafx.h"
#include "olecnfg.h"

#include "afxtempl.h"
#include "CStrings.h"
#include "CReg.h"
#include "types.h"
#include "datapkt.h"
#include "util.h"
#include "virtreg.h"

#include "defprot.h"
#include "epprops.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CDefaultProtocols property page

IMPLEMENT_DYNCREATE(CDefaultProtocols, CPropertyPage)

//+-------------------------------------------------------------------------
//
//  Member:     CDefaultProtocols::constructor
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
CDefaultProtocols::CDefaultProtocols() : CPropertyPage(CDefaultProtocols::IDD)
{
    //{{AFX_DATA_INIT(CDefaultProtocols)
    //}}AFX_DATA_INIT
    m_nSelected = -1;
    m_bChanged = FALSE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefaultProtocols::destructor
//
//  Synopsis:
//
//  Arguments:
//
//  Returns:
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
CDefaultProtocols::~CDefaultProtocols()
{
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefaultProtocols::DoDataExchange
//
//  Synopsis:   Called to update data automatically to / from controls
//
//  Arguments:
//
//  Returns:
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
void CDefaultProtocols::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CDefaultProtocols)
    DDX_Control(pDX, IDC_CMDUPDATE, m_btnProperties);
    DDX_Control(pDX, IDC_CMDREMOVE, m_btnRemove);
    DDX_Control(pDX, IDC_CMDMOVEUP, m_btnMoveUp);
    DDX_Control(pDX, IDC_CMDMOVEDOWN, m_btnMoveDown);
    DDX_Control(pDX, IDC_CMDADD, m_btnAdd);
    DDX_Control(pDX, IDC_LSTPROTSEQ, m_lstProtocols);
    //}}AFX_DATA_MAP

    if (pDX -> m_bSaveAndValidate && m_bChanged)
    {
        // update selection
        CRegMultiSzNamedValueDp * pCdp = (CRegMultiSzNamedValueDp*)g_virtreg.GetAt(m_nDefaultProtocolsIndex);
        CStringArray& rProtocols = pCdp -> Values();

        rProtocols.RemoveAll();

        // copy protocols
        int nIndex;
        for (nIndex = 0; nIndex < m_arrProtocols.GetSize(); nIndex++)
        {
            CEndpointData *pED = (CEndpointData *)m_arrProtocols.GetAt(nIndex);
            rProtocols.Add((LPCTSTR)pED -> m_szProtseq);
        }
        pCdp -> SetModified(TRUE);
    }
}


BEGIN_MESSAGE_MAP(CDefaultProtocols, CPropertyPage)
    //{{AFX_MSG_MAP(CDefaultProtocols)
    ON_BN_CLICKED(IDC_CMDADD, OnAddProtocol)
    ON_BN_CLICKED(IDC_CMDMOVEDOWN, OnMoveProtocolDown)
    ON_BN_CLICKED(IDC_CMDMOVEUP, OnMoveProtocolUp)
    ON_BN_CLICKED(IDC_CMDREMOVE, OnRemoveProtocol)
    ON_WM_KILLFOCUS()
    ON_NOTIFY(NM_CLICK, IDC_LSTPROTSEQ, OnSelectProtocol)
    ON_BN_CLICKED(IDC_CMDUPDATE, OnProperties)
    ON_NOTIFY(NM_DBLCLK, IDC_LSTPROTSEQ, OnPropertiesClick)
    ON_WM_HELPINFO()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDefaultProtocols message handlers

//+-------------------------------------------------------------------------
//
//  Member:     CDefaultProtocols::OnInitDialog
//
//  Synopsis:   Called to initialize dialog before showing
//              (in response to WM_INITDIALOG)
//
//  Arguments:
//
//  Returns:    BOOL - TRUE to set focus to Dialog, FALSE if
//              focus will be set to another control or window
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
BOOL CDefaultProtocols::OnInitDialog()
{
    CPropertyPage::OnInitDialog();

    // setup image list control for dialog (for use with listview)
    m_imgNetwork.Create( IDB_IMGNETWORK, 16, 0, RGB(255,255,255));
    m_lstProtocols.SetImageList(&m_imgNetwork, LVSIL_SMALL);
    ASSERT(m_imgNetwork.GetImageCount() == 2);

    // Attempt to read HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\RPC\DCOM Protocols
    int err;

    err = g_virtreg.ReadRegMultiSzNamedValue(HKEY_LOCAL_MACHINE,
                                        TEXT("SOFTWARE\\Microsoft\\RPC"),
                                        TEXT("DCOM Protocols"),
                                        &m_nDefaultProtocolsIndex);
    if (err == ERROR_SUCCESS)
    {
        CRegMultiSzNamedValueDp * pCdp = (CRegMultiSzNamedValueDp*)g_virtreg.GetAt(m_nDefaultProtocolsIndex);

        CStringArray& rProtocols = pCdp -> Values();

        // copy protocols
        int nIndex;
        for (nIndex = 0; nIndex < rProtocols.GetSize(); nIndex++)
        {
            CEndpointData *pED = new CEndpointData(rProtocols.GetAt(nIndex));
            m_arrProtocols.Add(pED);
        }

        // set selection to first item
        if (nIndex > 0)
            m_nSelected = 0;
        else
            m_nSelected = -1;

        RefreshProtocolList();
    }
    else if (err != ERROR_ACCESS_DENIED  &&  err !=
             ERROR_FILE_NOT_FOUND)
    {
        g_util.PostErrorMessage();
    }

    SetModified(m_bChanged = FALSE);

    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefaultProtocols::UpdateSelection
//
//  Synopsis:   Called to update UI after protocol selection
//
//  Arguments:
//
//  Returns:
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
void CDefaultProtocols::UpdateSelection()
{
    BOOL bAllowGlobalProperties = FALSE;
     // get the corresponding endpoint data object

    if (m_nSelected != (-1))
    {
        CEndpointData *pEPD = (CEndpointData*)m_arrProtocols.GetAt(m_nSelected);
        bAllowGlobalProperties = pEPD -> AllowGlobalProperties();
    }

    m_btnAdd.EnableWindow(TRUE);
    m_btnRemove.EnableWindow(m_nSelected !=  -1);
    m_btnProperties.EnableWindow(bAllowGlobalProperties);

    m_btnMoveUp.EnableWindow(m_nSelected > 0);
    m_btnMoveDown.EnableWindow((m_nSelected < m_arrProtocols.GetUpperBound()) && (m_nSelected >=0));

    // set up initial selection
    if (m_nSelected != (-1))
    {
        m_lstProtocols.SetItemState(m_nSelected, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
        m_lstProtocols.Update(m_nSelected);
    }

    UpdateData(FALSE);
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefaultProtocols::RefreshProtocolList
//
//  Synopsis:   Called to refresh protocol list into dialog
//
//  Arguments:
//
//  Returns:
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
void CDefaultProtocols::RefreshProtocolList()
{
    int nIndex;

    // clear the list controls current contents
    m_lstProtocols.DeleteAllItems();

    for (nIndex = 0; (nIndex < m_arrProtocols.GetSize()); nIndex++)
        {
        CEndpointData *pEPD = (CEndpointData*)m_arrProtocols.GetAt(nIndex);

        if (pEPD )
            {
            CString sTmp;
            pEPD -> GetDescription(sTmp);

            // insert item and store pointer to its associated CEndpointData
            m_lstProtocols.InsertItem(nIndex, sTmp, 0);
            m_lstProtocols.SetItemData(0, (DWORD_PTR)pEPD);
            }
        }

    UpdateSelection();
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefaultProtocols::OnAddProtocol
//
//  Synopsis:   Called when user selects AddProtocol button
//
//  Arguments:
//
//  Returns:
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
void CDefaultProtocols::OnAddProtocol()
{
    CAddProtocolDlg capd;

    if (capd.DoModal() == IDOK)
    {
        // create new endpoint
        CEndpointData *pNewProtocol = new CEndpointData();
        ASSERT(pNewProtocol);

        pNewProtocol = capd.GetEndpointData(pNewProtocol);
        ASSERT(pNewProtocol);

        // check if protocol is already in collection
        int nIndex;

        for (nIndex = 0; nIndex < m_arrProtocols.GetSize(); nIndex++)
            {
            CEndpointData *pEPD = (CEndpointData*)m_arrProtocols.GetAt(nIndex);
            if (pEPD -> m_pProtocol == pNewProtocol -> m_pProtocol)
                {
                delete pNewProtocol;
                pNewProtocol = NULL;
                AfxMessageBox((UINT)IDS_DUPLICATE_PROTSEQ);
                break;
                }
            }

        // only add the endpoint if its not already in collection
        if (pNewProtocol)
        {
            // reset old hilited item
            if (m_nSelected != -1)
            {
                m_lstProtocols.SetItemState(m_nSelected, 0, LVIS_SELECTED | LVIS_FOCUSED);
                m_lstProtocols.Update(m_nSelected);
            }

            // add new endpoint
            int nNewIndex = (int)m_arrProtocols.Add((CObject*)pNewProtocol);

            // set new item in list control
            CString sTmp;

            pNewProtocol -> GetDescription(sTmp);

            // insert item and store pointer to its associated CEndpointData
            m_nSelected = m_lstProtocols.InsertItem(nNewIndex, sTmp, 0);
            if (m_nSelected != -1)
            {
                m_lstProtocols.SetItemData(m_nSelected, (DWORD_PTR)pNewProtocol);
                UpdateSelection();

                // set modified flag to enable apply button
                SetModified(m_bChanged = TRUE);

                // This is a reboot event
                g_fReboot = TRUE;

                UpdateData(TRUE);
            }
        }
    }
    SetFocus();
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefaultProtocols::OnMoveProtocolDown
//
//  Synopsis:   Called when user clicks MoveDown button
//
//  Arguments:
//
//  Returns:
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
void CDefaultProtocols::OnMoveProtocolDown()
{
    if ((m_nSelected != -1) && (m_nSelected < m_arrProtocols.GetUpperBound()))
    {
        CEndpointData * p1, *p2;
        p1 = (CEndpointData * )m_arrProtocols.GetAt(m_nSelected);
        p2 = (CEndpointData * )m_arrProtocols.GetAt(m_nSelected + 1);
        m_arrProtocols.SetAt(m_nSelected,(CObject*)p2);
        m_arrProtocols.SetAt(m_nSelected+1,(CObject*)p1);

        m_nSelected = m_nSelected+1;

        // set modified flag to enable apply button
        SetModified(m_bChanged = TRUE);
        UpdateData(TRUE);

        // This is a reboot event
        g_fReboot = TRUE;

        RefreshProtocolList();
        SetFocus();
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefaultProtocols::OnMoveProtocolUp
//
//  Synopsis:   Called when user clicks MoveUp button
//
//  Arguments:
//
//  Returns:
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
void CDefaultProtocols::OnMoveProtocolUp()
{
    if ((m_nSelected != -1) && (m_nSelected > 0))
    {
        CEndpointData * p1, *p2;
        p1 = (CEndpointData * )m_arrProtocols.GetAt(m_nSelected);
        p2 = (CEndpointData * )m_arrProtocols.GetAt(m_nSelected - 1);
        m_arrProtocols.SetAt(m_nSelected,(CObject*)p2);
        m_arrProtocols.SetAt(m_nSelected - 1 ,(CObject*)p1);

        m_nSelected = m_nSelected - 1;

        // set modified flag to enable apply button
        SetModified(m_bChanged = TRUE);
        UpdateData(TRUE);

        // This is a reboot event
        g_fReboot = TRUE;

        RefreshProtocolList();
        SetFocus();
    }

}

//+-------------------------------------------------------------------------
//
//  Member:     CDefaultProtocols::OnRemoveProtocol
//
//  Synopsis:   Called when user clicks Remove button
//
//  Arguments:
//
//  Returns:
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
void CDefaultProtocols::OnRemoveProtocol()
{
    if (m_nSelected != -1)
    {
        CEndpointData * p1;
        p1 = (CEndpointData * )m_arrProtocols.GetAt(m_nSelected);
        m_arrProtocols.RemoveAt(m_nSelected);
        delete p1;

        if (!m_arrProtocols.GetSize())
            m_nSelected  = -1;
        else if (m_nSelected > m_arrProtocols.GetUpperBound())
            m_nSelected = (int)m_arrProtocols.GetUpperBound();

        // set modified flag to enable apply button
        SetModified(m_bChanged = TRUE);
        UpdateData(TRUE);

        // This is a reboot event
        g_fReboot = TRUE;

        RefreshProtocolList();
        SetFocus();
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefaultProtocols::OnKillActive
//
//  Synopsis:   Called when Default protocols is no longer active pane
//
//  Arguments:
//
//  Returns:
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
BOOL CDefaultProtocols::OnKillActive()
{
    return CPropertyPage::OnKillActive();
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefaultProtocols::OnSetActive
//
//  Synopsis:   Called when Default protocols becomes active pane
//
//  Arguments:
//
//  Returns:
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
BOOL CDefaultProtocols::OnSetActive()
{
    BOOL bRetval = CPropertyPage::OnSetActive();

    // force focus to be set for page
    PostMessage(WM_SETFOCUS);
    return bRetval;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefaultProtocols::OnKillFocus
//
//  Synopsis:   Called when Default protocols pane loses focus
//
//  Arguments:
//
//  Returns:
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
void CDefaultProtocols::OnKillFocus(CWnd* pNewWnd)
{
    CPropertyPage::OnKillFocus(pNewWnd);
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefaultProtocols::OnSetFocus
//
//  Synopsis:   Called when Default protocols pane gains focus
//
//  Arguments:
//
//  Returns:
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
void CDefaultProtocols::OnSetFocus(CWnd* pOldWnd)
{
    CPropertyPage::OnSetFocus(pOldWnd);
    m_lstProtocols.SetFocus();

    if (m_nSelected != (-1))
    {
        m_lstProtocols.SetItemState(m_nSelected, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED );
        m_lstProtocols.Update(m_nSelected);
    }
    else
    {
        TRACE(TEXT("Invalid state"));
    }

}

//+-------------------------------------------------------------------------
//
//  Member:     CDefaultProtocols::OnSelectProtocol
//
//  Synopsis:   Called when users selects protocol from list
//
//  Arguments:
//
//  Returns:
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
void CDefaultProtocols::OnSelectProtocol(NMHDR* pNMHDR, LRESULT* pResult)
{
    m_nSelected = m_lstProtocols.GetNextItem(-1, LVIS_SELECTED | LVIS_FOCUSED);

    UpdateSelection();
    *pResult = 0;
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefaultProtocols::OnProperties
//
//  Synopsis:   Called when user clicks Properties button
//
//  Arguments:
//
//  Returns:
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
void CDefaultProtocols::OnProperties()
{
    if (m_nSelected != (-1))
    {
        CPortRangesDlg cprd;
        cprd.DoModal();
        SetFocus();
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CDefaultProtocols::OnPropertiesClick
//
//  Synopsis:   Called when user double clicks protocol in list
//
//  Arguments:
//
//  Returns:
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
void CDefaultProtocols::OnPropertiesClick(NMHDR* pNMHDR, LRESULT* pResult)
{
    m_nSelected = m_lstProtocols.GetNextItem(-1, LVIS_SELECTED | LVIS_FOCUSED);


    if (m_nSelected != (-1))
    {
        CEndpointData *pEPD = (CEndpointData*)m_arrProtocols.GetAt(m_nSelected);
        BOOL bAllowGlobalProperties = pEPD -> AllowGlobalProperties();
        if (bAllowGlobalProperties)
            OnProperties();
    }

    UpdateSelection();

    *pResult = 0;
}

BOOL CDefaultProtocols::OnHelpInfo(HELPINFO* pHelpInfo)
{
    if(-1 != pHelpInfo->iCtrlId)
    {
        WORD hiWord = 0x8000 | CDefaultProtocols::IDD;
        WORD loWord = (WORD) pHelpInfo->iCtrlId;
        DWORD dwLong = MAKELONG(loWord,hiWord);

        WinHelp(dwLong, HELP_CONTEXTPOPUP);
        TRACE1("Help Id 0x%lx\n", dwLong);
        return TRUE;
    }
    else
    {
        return CPropertyPage::OnHelpInfo(pHelpInfo);
    }
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleui\defprot.h ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1997.
//
//  File:       locppg.h
//
//  Contents:   Defines the classes CDefaultProtocols
//
//  Classes:
//
//  Methods:
//
//  History:    02-Jul-97   ronans  Created.
//
//----------------------------------------------------------------------

#ifndef __DEFPROT_H__
#define __DEFPROT_H__

/////////////////////////////////////////////////////////////////////////////
// CDefaultProtocols property page

class CDefaultProtocols : public CPropertyPage
{
    DECLARE_DYNCREATE(CDefaultProtocols)

// Construction
public:
    BOOL m_bChanged;
    void RefreshProtocolList();
    void UpdateSelection();
    CDefaultProtocols();
    ~CDefaultProtocols();

// Dialog Data
    //{{AFX_DATA(CDefaultProtocols)
    enum { IDD = IDD_PPGDEFPROT };
    CButton m_btnProperties;
    CButton m_btnRemove;
    CButton m_btnMoveUp;
    CButton m_btnMoveDown;
    CButton m_btnAdd;
    CListCtrl   m_lstProtocols;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CDefaultProtocols)
    public:
    virtual BOOL OnKillActive();
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:

    CImageList  m_imgNetwork;    // image list for use in protocols
    int         m_nDefaultProtocolsIndex;
    CObArray    m_arrProtocols;
    int         m_nSelected;


    // Generated message map functions
    //{{AFX_MSG(CDefaultProtocols)
    virtual BOOL OnInitDialog();
    afx_msg void OnAddProtocol();
    afx_msg void OnMoveProtocolDown();
    afx_msg void OnMoveProtocolUp();
    afx_msg void OnRemoveProtocol();
    afx_msg void OnKillFocus(CWnd* pNewWnd);
    afx_msg void OnSetFocus(CWnd* pOldWnd);
    afx_msg void OnSelectProtocol(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg void OnProperties();
    afx_msg void OnPropertiesClick(NMHDR* pNMHDR, LRESULT* pResult);
    afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleui\epoptppg.cpp ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1997.
//
//  File:       epoptppg.cpp
//
//  Contents:   Implements the classes CRpcOptionsPropertyPage
//
//  Classes:    
//
//  Methods:    CRpcOptionsPropertyPage::CRpcOptionsPropertyPage
//              CRpcOptionsPropertyPage::~CRpcOptionsPropertyPage
//
//  History:    02-Dec-96   RonanS    Created.
//
//----------------------------------------------------------------------

#include "stdafx.h"
#include "olecnfg.h"
#include "resource.h"
#include "Epoptppg.h"
#include "Epprops.h"
#include "TChar.h"
#include "util.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
// CRpcOptionsPropertyPage property page

IMPLEMENT_DYNCREATE(CRpcOptionsPropertyPage, CPropertyPage)

//+-------------------------------------------------------------------------
//
//  Member:     CRpcOptionsPropertyPage::CRpcOptionsPropertyPage
//
//  Synopsis:   Constructor
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
CRpcOptionsPropertyPage::CRpcOptionsPropertyPage() : CPropertyPage(CRpcOptionsPropertyPage::IDD)
{
    //{{AFX_DATA_INIT(CRpcOptionsPropertyPage)
    //}}AFX_DATA_INIT

    m_bChanged = FALSE;

    // make distinguished ednpoint data description for default settings
    m_epSysDefault = new  CEndpointData;
    m_nSelected = -1;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcOptionsPropertyPage::~CRpcOptionsPropertyPage
//
//  Synopsis:   Destructor
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
CRpcOptionsPropertyPage::~CRpcOptionsPropertyPage()
{
    ClearProtocols();

    // remove distinguished default settings descriptor
    if (m_epSysDefault)
        delete m_epSysDefault;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcOptionsPropertyPage::DoDataExchange
//
//  Synopsis:   Standard method for dialog data exchange. MFC uses this to 
//              transfer data between the controls and the C++ classes memeber variables.
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
void CRpcOptionsPropertyPage::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CRpcOptionsPropertyPage)
    DDX_Control(pDX, IDC_LSTPROTSEQ, m_lstProtseqs);
    DDX_Control(pDX, IDC_CMDUPDATE, m_btnUpdate);
    DDX_Control(pDX, IDC_CMDREMOVE, m_btnRemove);
    DDX_Control(pDX, IDC_CMDCLEAR, m_btnClear);
    DDX_Control(pDX, IDC_CMDADD, m_btnAdd);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CRpcOptionsPropertyPage, CPropertyPage)
    //{{AFX_MSG_MAP(CRpcOptionsPropertyPage)
    ON_BN_CLICKED(IDC_CMDCLEAR, OnClearEndpoints)
    ON_BN_CLICKED(IDC_CMDREMOVE, OnRemoveEndpoint)
    ON_BN_CLICKED(IDC_CMDUPDATE, OnUpdateEndpoint)
    ON_BN_CLICKED(IDC_CMDADD, OnAddEndpoint)
    ON_NOTIFY(NM_CLICK, IDC_LSTPROTSEQ, OnSelectProtseq)
    ON_WM_SETFOCUS()
    ON_WM_KILLFOCUS()
    ON_WM_HELPINFO()
    ON_NOTIFY(NM_DBLCLK, IDC_LSTPROTSEQ, OnPropertiesProtseq)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CRpcOptionsPropertyPage message handlers




//+-------------------------------------------------------------------------
//
//  Member:     CRpcOptionsPropertyPage::OnInitDialog
//
//  Synopsis:   This standard MFC method will be called when the dialog is to be initialised.
//              It is called when the WIN32 Window object receives a WM_INITDIALOG message.
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
BOOL CRpcOptionsPropertyPage::OnInitDialog() 
{
    CPropertyPage::OnInitDialog();
    
    // setup image list control for dialog (for use with listview)
    m_imgNetwork.Create( IDB_IMGNETWORK, 16, 0, RGB(255,255,255));
    m_lstProtseqs.SetImageList(&m_imgNetwork, LVSIL_SMALL);
    ASSERT(m_imgNetwork.GetImageCount() == 2);

    RefreshEPList();
 
    return TRUE;  // return TRUE unless you set the focus to a control
}



const TCHAR szEndpointText[] = TEXT("Endpoint");
const int lenEndpoint = (sizeof(szEndpointText) / sizeof(TCHAR)) -1; 

//+-------------------------------------------------------------------------
//
//  Member:     CRpcOptionsPropertyPage::InitData
//
//  Synopsis:   Method to initialise options
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
void CRpcOptionsPropertyPage::InitData(CString AppName, HKEY hkAppID)
{
    // read DCOM endpoint data from the registry    
    ASSERT(hkAppID != NULL);

    HKEY hkEndpoints = NULL;

    DWORD dwType = REG_MULTI_SZ;
    DWORD dwcbBuffer = 1024;
    TCHAR* pszBuffer = new TCHAR[1024];

    ASSERT(pszBuffer != NULL);

    // try to read values into default sized buffer
    LONG lErr = RegQueryValueEx(hkAppID, 
                        TEXT("Endpoints"), 
                        0, 
                        &dwType, 
                        (LPBYTE)pszBuffer,
                        &dwcbBuffer);

    // if buffer is not big enough, extend it and reread
    if (lErr == ERROR_MORE_DATA)
    {
        delete  pszBuffer;
        DWORD dwNewSize = (dwcbBuffer + 1 / sizeof(TCHAR));
        pszBuffer = new TCHAR[dwNewSize];
        if (pszBuffer)
            dwcbBuffer = dwNewSize;
    
        lErr = RegQueryValueEx(hkAppID, 
                        TEXT("Endpoints"), 
                        0, 
                        &dwType, 
                        (LPBYTE)pszBuffer,
                        &dwcbBuffer);
    }

    if ((lErr == ERROR_SUCCESS) && 
        (dwcbBuffer > 0) &&
        (dwType == REG_MULTI_SZ))
    {
        // parse each string
        TCHAR * lpszRegEntry = pszBuffer;


        while(*lpszRegEntry)
        {
            // caclulate length of entry
            int nLenEntry = _tcslen(lpszRegEntry);

            // ok its a valid endpoint so parse it
            TCHAR* pszProtseq = NULL;
            TCHAR* pszEndpointData = NULL;
            TCHAR* pszTmpDynamic = NULL;
            CEndpointData::EndpointFlags nDynamic;

            pszProtseq = _tcstok(lpszRegEntry, TEXT(", "));

            pszTmpDynamic = _tcstok(NULL, TEXT(", "));
            nDynamic = (CEndpointData::EndpointFlags) _ttoi(pszTmpDynamic);

            pszEndpointData = _tcstok(NULL, TEXT(", "));

            // at this point we should have the protseq, endpoint and flags
            // .. so add the entry

            // ignore result as we will continue even if one fails
            AddEndpoint(new CEndpointData(pszProtseq, nDynamic, pszEndpointData));
            lpszRegEntry += nLenEntry + 1;
        }
    }
    else if ((lErr != ERROR_SUCCESS) && (lErr != ERROR_FILE_NOT_FOUND))
        g_util.PostErrorMessage();

    delete pszBuffer;
    m_bChanged = FALSE;
    SetModified(FALSE);

    // select first item
    if (!m_colProtseqs.GetCount())
        // add default item
        m_colProtseqs.AddTail(m_epSysDefault);

    m_nSelected = 0;
}




//+-------------------------------------------------------------------------
//
//  Member:     CRpcOptionsPropertyPage::OnClearEndpoints
//
//  Synopsis:   Clears endpoint list and restores default settings
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
void CRpcOptionsPropertyPage::OnClearEndpoints() 
{
    // clear protocol list 
    ClearProtocols();
    m_bChanged = TRUE;

    m_colProtseqs.AddTail(m_epSysDefault);
    m_nSelected = 0;

    RefreshEPList();
    SetModified(TRUE);
    SetFocus();
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcOptionsPropertyPage::OnRemoveEndpoint
//
//  Synopsis:   Updates display after removal of endpoint
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
void CRpcOptionsPropertyPage::OnRemoveEndpoint() 
{
    if (m_nSelected != (-1))
    {
        if (m_colProtseqs.GetCount() == 1)
            OnClearEndpoints();
        else
        {
            // get the corresponding endpoint data object
            
            CEndpointData * pData = (CEndpointData*) m_lstProtseqs.GetItemData(m_nSelected);
            POSITION pos = m_colProtseqs. Find(pData, NULL);

            if (pos)
            {
                // remove item
                m_colProtseqs.RemoveAt(pos);
                if (pData != m_epSysDefault)
                    delete pData;

                // update item focus
                if (m_nSelected >= m_colProtseqs.GetCount())
                    m_nSelected = -1;

                UpdateData(FALSE);

                m_bChanged = TRUE;
                SetModified(TRUE);
                RefreshEPList();
                SetFocus();
            }
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcOptionsPropertyPage::OnUpdateEndpoint
//
//  Synopsis:   Called to process update command btn on existing endpoint
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
void CRpcOptionsPropertyPage::OnUpdateEndpoint() 
{
    // if there's a current selection (should always be the case)
    if (m_nSelected !=  -1)
    {
        // get the corresponding endpoint data object
        CEndpointData * pData = (CEndpointData*) m_lstProtseqs.GetItemData(m_nSelected);
        
        if (pData != m_epSysDefault)
        {
            CEndpointDetails ced;
    
            ced.SetOperation( CEndpointDetails::opUpdateProtocol);
            ced.SetEndpointData(pData);
            
            if (ced.DoModal() == IDOK)
                {
                pData = ced.GetEndpointData(pData);
                m_bChanged = TRUE;
                SetModified(TRUE);
                RefreshEPList();
                }
            SetFocus();
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcOptionsPropertyPage::OnAddEndpoint
//
//  Synopsis:   Called to process add endpoint command button
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
void CRpcOptionsPropertyPage::OnAddEndpoint() 
{
    CEndpointDetails ced;

    ced.SetOperation( CEndpointDetails::opAddProtocol);

    if (ced.DoModal() == IDOK)
    {
        // create new endpoint
        CEndpointData *pNewEndpoint = new CEndpointData();
        ASSERT(pNewEndpoint);

        pNewEndpoint = ced.GetEndpointData(pNewEndpoint);
        ASSERT(pNewEndpoint);

        // check if protseq is already in collection
        POSITION pos = NULL;

        pos = m_colProtseqs.GetHeadPosition();
        while (pos != NULL)
            {
            CEndpointData *pEPD = (CEndpointData*)m_colProtseqs.GetNext(pos);
            if (pEPD -> m_pProtocol == pNewEndpoint -> m_pProtocol)
                {
                delete pNewEndpoint;
                pNewEndpoint = NULL;

                AfxMessageBox((UINT)IDS_DUPLICATE_PROTSEQ);
                break;
                }
            }

        // only add the endpoint if its not already in collection
        if (pNewEndpoint)
        {
            // reset old hilited item 
            if (m_nSelected != -1)
            {
                m_lstProtseqs.SetItemState(m_nSelected, 0, LVIS_SELECTED | LVIS_FOCUSED);
                m_lstProtseqs.Update(m_nSelected);
            }

            // add new endpoint
            AddEndpoint(pNewEndpoint);

            // set new item in list 
            CString sTmp;

            if (pNewEndpoint -> m_pProtocol)
                sTmp .LoadString(pNewEndpoint -> m_pProtocol -> nResidDesc);

            // insert item and store pointer to its associated CEndpointData
            int nImageNum = (pNewEndpoint -> m_nDynamicFlags != CEndpointData::edDisableEP) ? 0 : 1;
            m_nSelected = m_lstProtseqs.InsertItem(0, sTmp, nImageNum);

            if (m_nSelected != -1)
            {
                m_lstProtseqs.SetItemData(m_nSelected, (DWORD_PTR)pNewEndpoint);
                UpdateSelection();
                m_bChanged = TRUE;
                SetModified(TRUE);
            }
        }
    }
    SetFocus();
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcOptionsPropertyPage::ClearProtocols
//
//  Synopsis:   Clears protocol list
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
void CRpcOptionsPropertyPage::ClearProtocols()
{
    // clean up endpoint data collection
    POSITION pos = NULL;

    pos = m_colProtseqs.GetHeadPosition();
    while (pos != NULL)
        {
        CEndpointData *pEPD = (CEndpointData*)m_colProtseqs.GetNext(pos);
        if (pEPD != m_epSysDefault)
            delete pEPD;
        }

    m_colProtseqs.RemoveAll();
    m_nSelected = -1;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcOptionsPropertyPage::RefreshEPList
//
//  Synopsis:   Refreshes display from protocol list
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
void CRpcOptionsPropertyPage::RefreshEPList()
{
    POSITION pos = m_colProtseqs.GetHeadPosition();
    
    // clear the list controls current contents
    m_lstProtseqs.DeleteAllItems();

    while (pos != NULL)
        {
        CString sTmp;
        CEndpointData *pEPD = (CEndpointData*)m_colProtseqs.GetNext(pos);

        if (pEPD -> m_pProtocol)
            sTmp .LoadString(pEPD -> m_pProtocol -> nResidDesc);

        // insert item and store pointer to its associated CEndpointData
        int nImageNum = (pEPD -> m_nDynamicFlags != CEndpointData::edDisableEP) ? 0 : 1;
        m_lstProtseqs.InsertItem(0, sTmp, nImageNum);
        m_lstProtseqs.SetItemData(0, (DWORD_PTR)pEPD);
        }

    UpdateSelection();
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcOptionsPropertyPage::AddEndpoint
//
//  Synopsis:   This method adds a new endpoint to the collection
//              of endpoints (m_colProtSeqs). If the collection justs consists of 
//              the default endpoint, it removes it first.
//
//  Arguments:  pED - The new endpoint object to add
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
void CRpcOptionsPropertyPage::AddEndpoint(CEndpointData* pED)
{
    // remove default item if present
    if ((m_colProtseqs.GetCount() == 1) &&
        (m_colProtseqs.GetHead() == m_epSysDefault))
    {
        m_colProtseqs.RemoveAll();
        if (m_lstProtseqs.GetItemCount())
            m_lstProtseqs.DeleteItem(0);
    }
    
    // add new item 
    m_colProtseqs.AddTail(pED);
    m_bChanged = TRUE;
}


//+-------------------------------------------------------------------------
//
//  Member:     CRpcOptionsPropertyPage::OnSelectProtseq
//
//  Synopsis:   This method is called when an element is selected from the listview 
//              containing the list of protocols and endpoints. 
//              It updates the buttons and controls to reflect the current selection
//
//  Arguments:  Standard args for ListCtrl callbacks
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
void CRpcOptionsPropertyPage::OnSelectProtseq(NMHDR* pNMHDR, LRESULT* pResult) 
{
    m_nSelected = m_lstProtseqs.GetNextItem(-1, LVIS_SELECTED | LVIS_FOCUSED);

    UpdateSelection();
    *pResult = 0;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcOptionsPropertyPage::UpdateSelection
//
//  Synopsis:   Updates UI after protocol has been selected
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
void CRpcOptionsPropertyPage::UpdateSelection()
{
    // check to see what buttons should be enabled
    if ((m_colProtseqs.GetCount() == 1) &&
        (m_colProtseqs.GetHead() == m_epSysDefault))
        {
        m_btnClear.EnableWindow(FALSE);
        m_btnRemove.EnableWindow(FALSE);
        m_btnUpdate.EnableWindow(FALSE);
        }
    else
        {
        m_btnClear.EnableWindow(TRUE);
        if (m_nSelected ==  -1)
            {
            m_btnRemove.EnableWindow(FALSE);
            m_btnUpdate.EnableWindow(FALSE);
            }
        else
            {
             // get the corresponding endpoint data object
            CEndpointData * pData = (CEndpointData*) m_lstProtseqs.GetItemData(m_nSelected);
            m_btnRemove.EnableWindow(TRUE);
            m_btnUpdate.EnableWindow(TRUE);
            }
        }


    // set up initial selection
    if (m_nSelected != (-1))
    {
        m_lstProtseqs.SetItemState(m_nSelected, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED);
        m_lstProtseqs.Update(m_nSelected);
    }
    
    UpdateData(FALSE);
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcOptionsPropertyPage::OnSetActive
//
//  Synopsis:   Called when page is activated
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
BOOL CRpcOptionsPropertyPage::OnSetActive() 
{
    BOOL bRetval = CPropertyPage::OnSetActive();

    PostMessage(WM_SETFOCUS);
    return bRetval;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcOptionsPropertyPage::OnSetFocus
//
//  Synopsis:   Called when page gets focus
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
void CRpcOptionsPropertyPage::OnSetFocus(CWnd* pOldWnd) 
{
    CPropertyPage::OnSetFocus(pOldWnd);
    m_lstProtseqs.SetFocus();
    
    if (m_nSelected != (-1))
    {
        m_lstProtseqs.SetItemState(m_nSelected, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED );
        m_lstProtseqs.Update(m_nSelected);
    }
    else
    {
        TRACE(TEXT("Invalid state"));
    }

}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcOptionsPropertyPage::OnKillFocus
//
//  Synopsis:   Called when page loses focus
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
void CRpcOptionsPropertyPage::OnKillFocus(CWnd* pNewWnd) 
{
    CPropertyPage::OnKillFocus(pNewWnd);
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcOptionsPropertyPage::OnKillActive
//
//  Synopsis:   Called when page is deactivated
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
BOOL CRpcOptionsPropertyPage::OnKillActive() 
{
    return CPropertyPage::OnKillActive();
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcOptionsPropertyPage::OnHelpInfo
//
//  Synopsis:   Called to display help info on items
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
BOOL CRpcOptionsPropertyPage::OnHelpInfo(HELPINFO* pHelpInfo) 
{
    if(-1 != pHelpInfo->iCtrlId)
    {
        WORD hiWord = 0x8000 | CRpcOptionsPropertyPage::IDD;
        WORD loWord = (WORD) pHelpInfo->iCtrlId;
        DWORD dwLong = MAKELONG(loWord,hiWord);

        WinHelp(dwLong, HELP_CONTEXTPOPUP);
        TRACE1("Help Id 0x%lx\n", dwLong);
        return TRUE;
    }
    else
    {
        return CPropertyPage::OnHelpInfo(pHelpInfo);
    }
}

void CRpcOptionsPropertyPage::OnPropertiesProtseq(NMHDR* pNMHDR, LRESULT* pResult) 
{
    m_nSelected = m_lstProtseqs.GetNextItem(-1, LVIS_SELECTED | LVIS_FOCUSED);

    OnUpdateEndpoint();
    UpdateSelection();
    
    *pResult = 0;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcOptionsPropertyPage::ValidateChanges
//
//  Synopsis:   To be called to validate the endpoint set before saving
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
BOOL CRpcOptionsPropertyPage::ValidateChanges()
{
    UpdateData(TRUE);

    // only validate if data has changed
    if (m_bChanged)
    {
        // validate endpoint entries
    }
    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcOptionsPropertyPage::UpdateChanges
//
//  Synopsis:   Called to update the changes to registry
//
//  Arguments:  None
//
//  Returns:    BOOL success flag
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
BOOL CRpcOptionsPropertyPage::UpdateChanges(HKEY hkAppID)
{
    ASSERT(hkAppID != NULL);

    // only write the keys if there have been changes
    if (m_bChanged)
    {
        // write the DCOM endpoint data to the registry if necessary    
        LONG lErr = ERROR_SUCCESS;

        // delete old key
        lErr = RegDeleteValue(hkAppID, TEXT("Endpoints"));

        // if we successfully deleted the old value (or
        // there was no old value) then write the new values
        if ((lErr == ERROR_SUCCESS) || (lErr == ERROR_FILE_NOT_FOUND))
        {
            POSITION pos = NULL;
            int inxEP = 0;
            int nLenRegString = 0;
            TCHAR * lpszBuffer , *lpszBuffer2;

            // calculate string length
            pos = m_colProtseqs.GetHeadPosition();
            while (pos != NULL)
                {
                CEndpointData *pEPD = (CEndpointData*)m_colProtseqs.GetNext(pos);
                ASSERT(pEPD != NULL);

                if (pEPD != m_epSysDefault)
                    {
                    // create string for saving
                    CString sKeyValue;
                    sKeyValue.Format(TEXT("%s,%d,%s"), 
                            (LPCTSTR)(pEPD -> m_szProtseq), 
                            pEPD -> m_nDynamicFlags, 
                            (LPCTSTR) pEPD -> m_szEndpoint);
                    nLenRegString += sKeyValue.GetLength() + 1;
                    }
                }

            // if the combined string length is zero, we don't need to write anything
            if (nLenRegString)
            {
                lpszBuffer2 = lpszBuffer = new TCHAR[nLenRegString+1];

                pos = m_colProtseqs.GetHeadPosition();
                while (pos != NULL)
                    {
                    CEndpointData *pEPD = (CEndpointData*)m_colProtseqs.GetNext(pos);

                    if (pEPD != m_epSysDefault)
                        {
                        // create string for saving
                        CString sKeyValue;
                        sKeyValue.Format(TEXT("%s,%d,%s"), 
                                (LPCTSTR)(pEPD -> m_szProtseq), 
                                pEPD -> m_nDynamicFlags, 
                                (LPCTSTR) pEPD -> m_szEndpoint);
                        lstrcpy(lpszBuffer2, sKeyValue);
                        lpszBuffer2 += sKeyValue.GetLength() + 1;   // skip over trailing null
                        }
                    }
                *lpszBuffer2 = 0;

                // write out the string
                lErr = RegSetValueEx(hkAppID, 
                        (LPCTSTR)TEXT("Endpoints"), 
                        NULL, 
                        REG_MULTI_SZ, 
                        (BYTE*)(LPCTSTR)lpszBuffer, 
                        (nLenRegString + 1) * sizeof(TCHAR));

                delete lpszBuffer;
            }
        }
    else 
        g_util.PostErrorMessage();

    SetModified(FALSE);
    }

    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CRpcOptionsPropertyPage::CancelChanges
//
//  Synopsis:   Called to cancel the changes to registry
//
//  Arguments:  None
//
//  Returns:    BOOL success flag
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
BOOL CRpcOptionsPropertyPage::CancelChanges()
{
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleui\epoptppg.h ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1997.
//
//  File:       epoptppg.h
//
//  Contents:   Defines the classes CRpcOptionsPropertyPage,
//              which manages the RPC endpoint options per AppId.
//
//  Classes:    
//
//  Methods:    
//
//  History:    02-Dec-96   Ronans    Created.
//
//----------------------------------------------------------------------


#ifndef __EPOPTPPG_H__
#define __EPOPTPPG_H__	
class CEndpointData;

/////////////////////////////////////////////////////////////////////////////
// CRpcOptionsPropertyPage dialog

class CRpcOptionsPropertyPage : public CPropertyPage
{
	DECLARE_DYNCREATE(CRpcOptionsPropertyPage)

// Construction
public:
	CRpcOptionsPropertyPage();
	~CRpcOptionsPropertyPage();
    BOOL CancelChanges();
    BOOL UpdateChanges(HKEY hkAppID);
    BOOL ValidateChanges();
	void UpdateSelection();
	void AddEndpoint(CEndpointData* pED);
	void RefreshEPList();
	void ClearProtocols();
	BOOL m_bCanModify;
	BOOL Validate();
	void InitData(CString AppName, HKEY hkAppID);

	CString GetProtseq();
	CString GetEndpoint();
	CString GetDynamicOptions();

	int m_nProtocolIndex; // index into protocol array

// Dialog Data
	//{{AFX_DATA(CRpcOptionsPropertyPage)
	enum { IDD = IDD_RPCOPTIONS };
	CListCtrl	m_lstProtseqs;
	CButton	m_btnUpdate;
	CButton	m_btnRemove;
	CButton	m_btnClear;
	CButton	m_btnAdd;
	//}}AFX_DATA

// Overrides
	// ClassWizard generate virtual function overrides
	//{{AFX_VIRTUAL(CRpcOptionsPropertyPage)
	public:
	virtual BOOL OnSetActive();
	virtual BOOL OnKillActive();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CEndpointData* m_epSysDefault;
	CImageList m_imgNetwork;
	CObList m_colProtseqs;	// collection of protseq objects
	BOOL m_bChanged;		// flag to indicate if data changed

	// Generated message map functions
	//{{AFX_MSG(CRpcOptionsPropertyPage)
	virtual BOOL OnInitDialog();
	afx_msg void OnClearEndpoints();
	afx_msg void OnRemoveEndpoint();
	afx_msg void OnUpdateEndpoint();
	afx_msg void OnAddEndpoint();
	afx_msg void OnSelectProtseq(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	afx_msg void OnPropertiesProtseq(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
	int m_nSelected;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleui\epprops.cpp ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1997.
//
//  File:       epprops.cpp
//
//  Contents:   Implements the classes CEndpointDetails which manage the
//              Endpoint properties dialog.
//
//  Classes:
//
//  Methods:
//
//  History:    03-Dec-96   RonanS    Created.
//
//----------------------------------------------------------------------

#include "stdafx.h"
#include "olecnfg.h"
#include "Epoptppg.h"
#include "Epprops.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CEndpointData
//
// The CEndpointData object is used to hold information about a users choices for
// a specific protocol and endpoint combination.
// Each endpoint will also contain an user readable description to be displayed in
// protocol lists and user displays

IMPLEMENT_DYNAMIC(CEndpointData, CObject)


// change this to point to index of ncacn_ip_tcp or other default protocol
#define TCP_INDEX 4

ProtocolDesc aProtocols [] =
{
    { _T("*"),          // default system protocols
        IDS_EPDESC_DEFAULT,
        ProtocolDesc::ef_IpPortNum,
        IDS_INETADDR,
        IDS_INETPORT ,
        TRUE,
        TRUE
    },

    { _T("ncacn_nb_tcp"),
        IDS_EPDESC_NCACN_NB_TCP,
        ProtocolDesc::ef_Integer255,
        IDS_NTMACHINENAME,
        IDS_INTEGER255,
        FALSE,
        FALSE
    },

    { _T("ncacn_nb_ipx"),
        IDS_EPDESC_NCACN_NB_IPX,
        ProtocolDesc::ef_Integer255,
        IDS_NTMACHINENAME,
        IDS_INTEGER255 ,
        FALSE,
        TRUE
    },

    { _T("ncacn_nb_nb"),
        IDS_EPDESC_NCACN_NB_NB,
        ProtocolDesc::ef_Integer255,
        IDS_NTMACHINENAME,
        IDS_INTEGER255 ,
        FALSE,
        TRUE
    },

    { _T("ncacn_ip_tcp"),
        IDS_EPDESC_NCACN_IP_TCP,
        ProtocolDesc::ef_IpPortNum,
        IDS_INETADDR,
        IDS_INETPORT ,
        TRUE,
        TRUE
    },

    { _T("ncacn_np"),
        IDS_EPDESC_NCACN_NP,
        ProtocolDesc::ef_NamedPipe,
        IDS_NTSERVER,
        IDS_NAMEDPIPE ,
        FALSE,
        FALSE
    },

    { _T("ncacn_spx"),
        IDS_EPDESC_NCACN_SPX,
        ProtocolDesc::ef_Integer,
        IDS_IPXINETADDR,
        IDS_INTEGER ,
        FALSE,
        TRUE
    },

    { _T("ncacn_dnet_nsp"),
        IDS_EPDESC_NCACN_DNET_NSP,
        ProtocolDesc::ef_DecNetObject,
        IDS_DECNET,
        IDS_DECNETOBJECT ,
        FALSE,
        FALSE
    },

    { _T("ncacn_at_dsp"),
        IDS_EPDESC_NCACN_AT_DSP,
        ProtocolDesc::ef_Char22,
        IDS_APPLETALK,
        IDS_ATSTRING ,
        FALSE,
        FALSE
    },

    { _T("ncacn_vnns_spp"),
        IDS_EPDESC_NCACN_VNNS_SPP,
        ProtocolDesc::ef_VinesSpPort,
        IDS_VINES,
        IDS_VINESPORT ,
        FALSE,
        FALSE
    },

    { _T("ncadg_ip_udp"),
        IDS_EPDESC_NCADG_IP_UDP,
        ProtocolDesc::ef_IpPortNum,
        IDS_INETADDR,
        IDS_INETPORT ,
        TRUE,
        TRUE
    },

    { _T("ncadg_ipx"),
        IDS_EPDESC_NCADG_IPX,
        ProtocolDesc::ef_Integer,
        IDS_IPXINETADDR,
        IDS_INTEGER ,
        FALSE,
        TRUE
    },

    { _T("ncacn_http"),
        IDS_EPDESC_NCACN_HTTP,
        ProtocolDesc::ef_IpPortNum,
        IDS_INETADDR,
        IDS_INETPORT ,
        TRUE ,
        TRUE
        },
};


//+-------------------------------------------------------------------------
//
//  Member:     CEndpointData::CEndpointData
//
//  Synopsis:   Constructor
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
CEndpointData::CEndpointData(LPCTSTR szProtseq, EndpointFlags nDynamic, LPCTSTR szEndpoint)
: m_szProtseq(szProtseq), m_nDynamicFlags(nDynamic), m_szEndpoint(szEndpoint)
{
    int i = FindProtocol(szProtseq);
    if (i != (-1))
        m_pProtocol = (&aProtocols[i]);
    else
        m_pProtocol = NULL;
}

//+-------------------------------------------------------------------------
//
//  Member:     CEndpointData::CEndpointData
//
//  Synopsis:   Constructor
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
CEndpointData::CEndpointData()
{
    m_szProtseq = aProtocols[0].pszProtseq;
    m_nDynamicFlags = edUseStaticEP;
    m_pProtocol = &aProtocols[0];
}

BOOL CEndpointData::GetDescription(CString &rsDesc)
{

    if (m_pProtocol)
    {
        rsDesc .LoadString(m_pProtocol -> nResidDesc);
        return TRUE;
    }

    return FALSE;
}

BOOL CEndpointData::AllowGlobalProperties()
{
    if (m_pProtocol)
    {
        return m_pProtocol -> bAllowDynamic;
    }

    return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// CEndpointDetails dialog
//
// The CEndpointDetails dialog is used for adding or modifying an existing endpoint
//


//+-------------------------------------------------------------------------
//
//  Member:     CEndpointDetails::CEndpointDetails
//
//  Synopsis:   Constructor
//
//  Arguments:
//              CWnd*   pParent     The parent window
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
CEndpointDetails::CEndpointDetails(CWnd* pParent /*=NULL*/)
    : CDialog(CEndpointDetails::IDD, pParent)
{
    //{{AFX_DATA_INIT(CEndpointDetails)
    m_szEndpoint = _T("");
    m_nDynamic = -1;
    //}}AFX_DATA_INIT

    m_nProtocolIndex = -1;
    m_opTask = opAddProtocol;
    m_pCurrentEPData = NULL;
    m_nDynamic = (int) rbiDefault;
}

//+-------------------------------------------------------------------------
//
//  Member:     CEndpointDetails::SetOperation
//
//  Synopsis:   Sets the operation to one of update or add new data
//              This method determines whether the dialog is being
//              used to select a new end point or modify an existing one
//
//  Arguments:
//              opTask  The operation to select
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
void CEndpointDetails::SetOperation (  operation opTask )
{
    m_opTask = opTask;
}

BOOL isNumericCStr(CString &rString)
{
    int i = 0;

    for (i = 0; i < rString.GetLength(); i++)
    {
        if ((rString[i] < TEXT('0')) || (rString[i] > TEXT('9')))
            return FALSE;
    }

    return TRUE;
}

void ReportEndpointError(CDataExchange *pDX, int nProtocol)
{
    if (nProtocol != -1)
    {
        CString sTmpTemplate, sTmpSpecific, sTmpOverall;
        sTmpTemplate.LoadString(IDS_ERR_ENDPOINT);

        sTmpSpecific.LoadString(aProtocols[nProtocol].nEndpointTip);

        sTmpOverall.Format(sTmpTemplate, (LPCTSTR)sTmpSpecific);
        AfxMessageBox(sTmpOverall, MB_OK | MB_ICONEXCLAMATION);
        pDX -> Fail();
    }
}

void PASCAL DDV_ValidateEndpoint(CDataExchange* pDX, int nProtocol, CEndpointDetails::btnOrder bo, CString & rszEndpoint)
{
    if (pDX -> m_bSaveAndValidate)
    {
        rszEndpoint.TrimLeft();
        rszEndpoint.TrimRight();

        // a non empty endpoint is only acceptable when choosing a static endpoint
        if (!rszEndpoint.IsEmpty())
        {
            if (bo == CEndpointDetails::rbiStatic)
            {
                if (nProtocol!= -1)
                {
                    switch (aProtocols[nProtocol].nEndpFmt)
                    {
                    case ProtocolDesc::ef_Integer255:
                        if (!isNumericCStr(rszEndpoint))
                            ReportEndpointError(pDX, nProtocol);

                        if (_ttol((LPCTSTR)rszEndpoint) > 255)
                            ReportEndpointError(pDX, nProtocol);
                        break;

                    case ProtocolDesc::ef_IpPortNum:
                        if (!isNumericCStr(rszEndpoint))
                            ReportEndpointError(pDX, nProtocol);
                        if (_ttol((LPCTSTR)rszEndpoint) > 65535)
                            ReportEndpointError(pDX, nProtocol);
                        break;


                    case ProtocolDesc::ef_Integer:
                        if (!isNumericCStr(rszEndpoint))
                            ReportEndpointError(pDX, nProtocol);
                        break;


                    case ProtocolDesc::ef_Char22:
                        if (rszEndpoint.GetLength() > 22)
                            ReportEndpointError(pDX, nProtocol);
                        break;

                    case ProtocolDesc::ef_VinesSpPort:
                    case ProtocolDesc::ef_sAppService:
                    case ProtocolDesc::ef_NamedPipe:
                    case ProtocolDesc::ef_DecNetObject:
                    default:
                        // no validation
                        break;
                    }
                }
                return;
            }
        else 
            ReportEndpointError(pDX, nProtocol);
        }
        else
        {
             if (bo == CEndpointDetails::rbiStatic)
                ReportEndpointError(pDX, nProtocol);
        }
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     CEndpointDetails::DoDataExchange
//
//  Synopsis:   Performs standard dialog data exchange
//
//  Arguments:
//				CDataExchange*	pDx	The data exchange object
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
void CEndpointDetails::DoDataExchange(CDataExchange* pDX)
{
    if (!pDX -> m_bSaveAndValidate)
    {
        switch(m_nDynamicFlags)
        {
        case CEndpointData::edDisableEP:
            m_nDynamic = rbiDisable;
            break;

        case CEndpointData::edUseStaticEP:
            if (m_szEndpoint.IsEmpty())
                m_nDynamic = rbiDefault;
            else
                m_nDynamic = rbiStatic;
            break;

        case CEndpointData::edUseIntranetEP:
            m_nDynamic = rbiIntranet;
            break;

        case CEndpointData::edUseInternetEP:
            m_nDynamic = rbiInternet;
            break;
        }

    }

    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CEndpointDetails)
    DDX_Control(pDX, IDC_EPDISABLE, m_rbDisableEP);
    DDX_Control(pDX, IDC_SPROTSEQ, m_stProtseq);
    DDX_Control(pDX, IDC_SINSTRUCTIONS, m_stInstructions);
    DDX_Control(pDX, IDC_EENDPOINT, m_edtEndpoint);
    DDX_Control(pDX, IDC_EPSTATICEP, m_rbStaticEP);
    DDX_Control(pDX, IDC_CBPROTSEQ, m_cbProtseq);
    DDX_Radio(pDX, IDC_EPDISABLE, m_nDynamic);
    //}}AFX_DATA_MAP


    DDX_Text(pDX, IDC_EENDPOINT, m_szEndpoint);
    if(((btnOrder)m_nDynamic) == rbiStatic)
        DDV_ValidateEndpoint(pDX, m_nProtocolIndex, (btnOrder)m_nDynamic, m_szEndpoint);

    DDX_Control(pDX, IDC_EPDYNAMIC_INTER, m_rbDynamicInternet);
    DDX_Control(pDX, IDC_EPDYNAMIC_INTRA, m_rbDynamicIntranet);

    if (pDX -> m_bSaveAndValidate)
        switch((btnOrder)m_nDynamic)
        {
        case rbiDisable:
            m_nDynamicFlags = CEndpointData::edDisableEP;
            break;

        case rbiDefault:
        case rbiStatic:
            m_nDynamicFlags = CEndpointData::edUseStaticEP;
            break;

        case rbiIntranet:
            m_nDynamicFlags = CEndpointData::edUseIntranetEP;
            break;

        case rbiInternet:
            m_nDynamicFlags = CEndpointData::edUseInternetEP;
            break;
        }
}


BEGIN_MESSAGE_MAP(CEndpointDetails, CDialog)
    //{{AFX_MSG_MAP(CEndpointDetails)
    ON_CBN_SELCHANGE(IDC_CBPROTSEQ, OnChooseProtocol)
    ON_BN_CLICKED(IDC_EPDYNAMIC_INTER, OnEndpointAssignment)
    ON_BN_CLICKED(IDC_EPDYNAMIC_INTRA, OnEndpointAssignment)
    ON_BN_CLICKED(IDC_EPSTATICEP, OnEndpointAssignmentStatic)
    ON_BN_CLICKED(IDC_EPDISABLE, OnEndpointAssignment)
    ON_BN_CLICKED(IDC_EPDYNAMIC_DEFAULT, OnEndpointAssignment)
    ON_WM_HELPINFO()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CEndpointDetails message handlers


int FindProtocol(LPCTSTR lpszProtSeq)
{
    int i = 0;

    while(i < sizeof(aProtocols) / sizeof(ProtocolDesc))
        {
        if (lstrcmp(lpszProtSeq, aProtocols[i].pszProtseq) == 0)
            return i;
        i++;
        }
    return -1;
}

//+-------------------------------------------------------------------------
//
//  Member:     CEndpointDetails::OnInitDialog
//
//  Synopsis:   Called by MFC when the dialog message WM_INITDIALOG is recieved.
//				Used to initialise the dialog state
//
//  Arguments:  None
//
//  Returns:    TRUE  - to set focus to the default push button
//              FALSE - if focus has been set to some other control.
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
BOOL CEndpointDetails::OnInitDialog()
{
    CDialog::OnInitDialog();

    int i = 0;
    int index = 0;
    int defaultItem = -1;

    // initialise combobox with list of protocols
    for (i = 1; i < sizeof(aProtocols) / sizeof(ProtocolDesc); i++)
    {
        if (aProtocols[i].m_bSupportedInCOM)
        {
            CString tmp((LPCTSTR) UIntToPtr( aProtocols[i].nResidDesc ));    // get string from resource
            index =  m_cbProtseq.AddString(tmp);
            if (index >= 0)
                m_cbProtseq.SetItemData(index, (DWORD)i);

            if (m_nProtocolIndex != -1)
            {
                if (i == m_nProtocolIndex)
                    defaultItem = index;
            }
            else if (i == TCP_INDEX)
            {
                m_nProtocolIndex = i;
                defaultItem = index;
            }
        }
    }


    // set up prompt and instructions for dialog
    if (m_opTask == opAddProtocol)
    {
        CString sInstructions((LPCTSTR)IDS_INSTRUCTIONS_ADDPROTOCOL) ;
        CString sCaption((LPCTSTR) IDS_CAPTION_ADDPROTOCOL);
        m_stInstructions.SetWindowText(sInstructions);
        SetWindowText(sCaption);
        m_stProtseq.ShowWindow(SW_HIDE);
    }
    else
    {
        CString sInstructions((LPCTSTR)IDS_INSTRUCTIONS_UPDATEPROTOCOL) ;
        CString sCaption((LPCTSTR) IDS_CAPTION_UPDATEPROTOCOL);
        m_stInstructions.SetWindowText(sInstructions);
        SetWindowText(sCaption);
        m_cbProtseq.ShowWindow(SW_HIDE);
        m_cbProtseq.EnableWindow(FALSE);
    }

    //  default to tcpip - unless we are updating an existing
    // protocol
    if (m_nProtocolIndex != (-1))
        m_cbProtseq.SetCurSel(defaultItem);

    UpdateProtocolUI();
    m_edtEndpoint.EnableWindow(((btnOrder)m_nDynamic) == rbiStatic);

    return TRUE;  // return TRUE unless you set the focus to a control

}

//+-------------------------------------------------------------------------
//
//  Member:     OnChooseProtocol
//
//  Synopsis:   Updates UI after protocol has been chosen
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
void CEndpointDetails::OnChooseProtocol()
{
    int sel = m_cbProtseq.GetCurSel();
    if (sel >= 0)
    {
        m_nProtocolIndex = (int) m_cbProtseq.GetItemData(sel);
        m_nDynamic = (int) rbiDefault;
        m_szEndpoint.Empty();
        UpdateProtocolUI();
        UpdateData(FALSE);
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     OnEndpointAssignment
//
//  Synopsis:   Handles radio buttons for endpoint assignment
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
void CEndpointDetails::OnEndpointAssignment()
{
    int i = m_nDynamic;

    if (m_edtEndpoint.IsWindowEnabled())
    {
        m_szEndpoint.Empty();
        m_edtEndpoint.SetWindowText(NULL);
        m_edtEndpoint.EnableWindow(FALSE);
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     OnEndpointAssignmentStatic
//
//  Synopsis:   Handles radio buttons for endpoint assignment
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
void CEndpointDetails::OnEndpointAssignmentStatic()
{
    int i = m_nDynamic;

    if (!m_edtEndpoint.IsWindowEnabled())
    {
        m_szEndpoint.Empty();
        m_edtEndpoint.SetWindowText(NULL);
        m_edtEndpoint.EnableWindow(TRUE);
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     GetEndpointData
//
//  Synopsis:   Fills out CEndpointData structure according to current selections
//
//  Arguments:  CEndpointData *     Pointer to CEndpointData structure to fill out
//
//  Returns:    CEndpointData *     Pointer to filled out CEndpointData *
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
CEndpointData* CEndpointDetails::GetEndpointData(CEndpointData *pData)
{
    if (m_nProtocolIndex != -1)
        pData -> m_pProtocol = &aProtocols[m_nProtocolIndex];
    else
        pData -> m_pProtocol = NULL;

    pData -> m_szProtseq = aProtocols[m_nProtocolIndex].pszProtseq;
    pData -> m_nDynamicFlags = m_nDynamicFlags;
    pData -> m_szEndpoint = m_szEndpoint;
    return pData;
}

//+-------------------------------------------------------------------------
//
//  Member:     SetEndpointData
//
//  Synopsis:   Sets endpoint data for updating
//
//  Arguments:  pData   The endpoint to update
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
void CEndpointDetails::SetEndpointData(CEndpointData* pData)
{
    ASSERT(pData != NULL);

    m_pCurrentEPData = pData;

    if (pData)
    {
        m_nDynamicFlags = pData -> m_nDynamicFlags;
        m_nDynamic = (int)(pData -> m_nDynamicFlags);
        m_szEndpoint = pData -> m_szEndpoint;
        m_nProtocolIndex = FindProtocol(pData -> m_szProtseq);
    }
    else
    {
        m_nDynamicFlags = CEndpointData::edUseStaticEP;
        m_szEndpoint .Empty();
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CEndpointDetails::UpdateProtocolUI
//
//  Synopsis:   Updates protocol UI based on m_nProtocolIndex and  m_pCurrentData
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    08-Jan-97 Ronans    Created
//
//--------------------------------------------------------------------------
void CEndpointDetails::UpdateProtocolUI()
{
    ASSERT(m_nProtocolIndex >= 0);
    ASSERT(m_nProtocolIndex < (sizeof(aProtocols) / sizeof(ProtocolDesc)));

    // set static to point to protocol description string
    CString tmp((LPCTSTR) UIntToPtr( aProtocols[m_nProtocolIndex].nResidDesc )); // get string from resource
    m_stProtseq.SetWindowText(tmp);

    // check if dynamic endpoint options are enabled for this
    m_rbDynamicInternet.EnableWindow(aProtocols[m_nProtocolIndex].bAllowDynamic);
    m_rbDynamicIntranet.EnableWindow(aProtocols[m_nProtocolIndex].bAllowDynamic);
}


/////////////////////////////////////////////////////////////////////////////
// CAddProtocolDlg dialog


CAddProtocolDlg::CAddProtocolDlg(CWnd* pParent /*=NULL*/)
    : CDialog(CAddProtocolDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CAddProtocolDlg)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT

    m_nProtocolIndex = -1;
    m_pCurrentEPData = NULL;
}


void CAddProtocolDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAddProtocolDlg)
    DDX_Control(pDX, IDC_CBPROTSEQ, m_cbProtseq);
    DDX_Control(pDX, IDC_SINSTRUCTIONS, m_stInstructions);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CAddProtocolDlg, CDialog)
    //{{AFX_MSG_MAP(CAddProtocolDlg)
    ON_CBN_SELCHANGE(IDC_CBPROTSEQ, OnChooseProtocol)
    ON_WM_HELPINFO()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAddProtocolDlg message handlers

void CAddProtocolDlg::OnChooseProtocol()
{
    int sel = m_cbProtseq.GetCurSel();
    if (sel >= 0)
        m_nProtocolIndex = (int) m_cbProtseq.GetItemData(sel);
}

BOOL CAddProtocolDlg::OnInitDialog()
{
    CDialog::OnInitDialog();

    int i = 0;
    int index = 0;

    // initialise combobox with list of protocols
    for (i = 1; i < sizeof(aProtocols) / sizeof(ProtocolDesc); i++)
    {
        if (aProtocols[i].m_bSupportedInCOM)
        {
            CString tmp((LPCTSTR) UIntToPtr( aProtocols[i].nResidDesc ));    // get string from resource
            index =  m_cbProtseq.AddString(tmp);
            if (index >= 0)
                m_cbProtseq.SetItemData(index, (DWORD)i);
        }
    }


    CString sInstructions((LPCTSTR)IDS_INSTRUCTIONS_ADDPROTOCOL) ;
    CString sCaption((LPCTSTR) IDS_CAPTION_ADDPROTOCOL);

    m_stInstructions.SetWindowText(sInstructions);
    SetWindowText(sCaption);

    //  default to tcpip - unless we are updating an existing
    // protocol
    if (m_nProtocolIndex == (-1))
    {
        m_nProtocolIndex = (int)m_cbProtseq.GetItemData(TCP_INDEX - 1);
        m_cbProtseq.SetCurSel(TCP_INDEX - 1);
    }
    else
        m_cbProtseq.SetCurSel(m_nProtocolIndex - 1);


    return TRUE;  // return TRUE unless you set the focus to a control
}

//+-------------------------------------------------------------------------
//
//  Member:     GetEndpointData
//
//  Synopsis:   Fills out CEndpointData structure according to current selections
//
//  Arguments:  CEndpointData *     Pointer to CEndpointData structure to fill out
//
//  Returns:    CEndpointData *     Pointer to filled out CEndpointData *
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
CEndpointData* CAddProtocolDlg::GetEndpointData(CEndpointData *pData)
{
    if (m_nProtocolIndex != -1)
        pData -> m_pProtocol = &aProtocols[m_nProtocolIndex];
    else
        pData -> m_pProtocol = NULL;

    pData -> m_szProtseq = aProtocols[m_nProtocolIndex].pszProtseq;
    pData -> m_szEndpoint.Empty();
    return pData;
}
/////////////////////////////////////////////////////////////////////////////
// CPortRangesDlg dialog


CPortRangesDlg::CPortRangesDlg(CWnd* pParent /*=NULL*/)
    : CDialog(CPortRangesDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CPortRangesDlg)
    m_nrbDefaultAssignment = -1;
    m_nrbRangeAssignment = -1;
    //}}AFX_DATA_INIT

    m_nSelection = -1;
    m_nrbDefaultAssignment = (int)cprDefaultIntranet;
    m_nrbRangeAssignment = (int)cprIntranet;
    m_pRanges = &m_arrInternetRanges;
    m_bChanged = FALSE;
}


void CPortRangesDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CPortRangesDlg)
    DDX_Control(pDX, IDC_ASSIGN_RANGE_INTERNET, m_rbRangeInternet);
    DDX_Control(pDX, IDC_SINSTRUCTIONS, m_stInstructions);
    DDX_Control(pDX, IDC_LIST1, m_lbRanges);
    DDX_Control(pDX, IDC_BTNREMOVEALL, m_btnRemoveAll);
    DDX_Control(pDX, IDC_BTNREMOVE, m_btnRemove);
    DDX_Control(pDX, IDC_BTNADD, m_btnAdd);
    DDX_Radio(pDX, IDC_DEFAULT_INTERNET, m_nrbDefaultAssignment);       // 1 = intranet, 0 = internet
    DDX_Radio(pDX, IDC_ASSIGN_RANGE_INTERNET, m_nrbRangeAssignment);    // 1 = intranet, 0 = internet
    //}}AFX_DATA_MAP
    DDX_Control(pDX, IDC_ASSIGN_RANGE_INTRANET, m_rbRangeIntranet);
}

CPortRangesDlg::~CPortRangesDlg()
{
    int nIndex;

    for (nIndex = 0; nIndex < m_arrInternetRanges.GetSize(); nIndex++)
    {
        CPortRange *pRange = (CPortRange*) m_arrInternetRanges.GetAt(nIndex);
        delete pRange;
    }

    m_arrInternetRanges.RemoveAll();

    for (nIndex = 0; nIndex < m_arrIntranetRanges.GetSize(); nIndex++)
    {
        CPortRange *pRange = (CPortRange*) m_arrIntranetRanges.GetAt(nIndex);
        delete pRange;
    }

    m_arrIntranetRanges.RemoveAll();

}

BEGIN_MESSAGE_MAP(CPortRangesDlg, CDialog)
    //{{AFX_MSG_MAP(CPortRangesDlg)
    ON_BN_CLICKED(IDC_BTNADD, OnAddPortRange)
    ON_BN_CLICKED(IDC_BTNREMOVE, OnRemovePortRange)
    ON_BN_CLICKED(IDC_BTNREMOVEALL, OnRemoveAllRanges)
    ON_BN_CLICKED(IDC_ASSIGN_RANGE_INTERNET, OnAssignRangeInternet)
    ON_BN_CLICKED(IDC_ASSIGN_RANGE_INTRANET, OnAssignRangeIntranet)
    ON_LBN_SELCHANGE(IDC_LIST1, OnSelChangeRanges)
    ON_WM_HELPINFO()
    ON_BN_CLICKED(IDC_DEFAULT_INTERNET, OnDefaultInternet)
    ON_BN_CLICKED(IDC_DEFAULT_INTRANET, OnDefaultIntranet)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CPortRangesDlg message handlers

BOOL ExtractPortsFromString(CString &rPortRange, long &dwStartPort, long &dwEndPort)
{
    if (!rPortRange.IsEmpty())
    {
        int nRangeLength = rPortRange.GetLength();

        // extract the two numbers
        CString sStartPort,sEndPort;

        sStartPort = rPortRange.SpanIncluding(TEXT("0123456789"));

        if (!sStartPort.IsEmpty())
            dwEndPort = dwStartPort = _tcstol((LPCTSTR)sStartPort, NULL, 10);

        if (sStartPort.IsEmpty() || (dwStartPort > MAX_PORT) || (dwStartPort < MIN_PORT))
            return FALSE;

        int nIndex = sStartPort.GetLength();

        // skip - or whitespace
        while ((nIndex < nRangeLength) &&
                ((rPortRange.GetAt(nIndex) == TEXT(' ')) ||
                (rPortRange.GetAt(nIndex) == TEXT('\t')) ||
                (rPortRange.GetAt(nIndex) == TEXT('-'))))
            nIndex++;

        // extract second port
        sEndPort = rPortRange.Mid(nIndex);

        // check for second valid number
        if (!sEndPort.IsEmpty())
        {
            CString sTmp = sEndPort.SpanIncluding(TEXT("0123456789"));
            dwEndPort = _tcstol((LPCTSTR)sTmp, NULL, 10);

            // ensure all characters are numeric
            if (sEndPort.GetLength() != sTmp.GetLength())
                return FALSE;

            if (dwEndPort > MAX_PORT)
                return FALSE;

            if (dwEndPort < dwStartPort)
                return FALSE;
        }

        return TRUE;
    }
    return FALSE;
}

BOOL PortsToString(CString &rsPort, long dwStartPort, long dwEndPort)
{
    rsPort.Empty();
    if (dwStartPort == dwEndPort)
        rsPort.Format(TEXT("%d"), dwStartPort);
    else
        rsPort.Format(TEXT("%d-%d"), dwStartPort, dwEndPort);

    return TRUE;
}


BOOL CPortRangesDlg::OnInitDialog()
{
    CDialog::OnInitDialog();

    // set up instructions
    CString sTmp((LPCTSTR)IDS_INSTRUCTIONS_PORTRANGES);
    m_stInstructions.SetWindowText(sTmp);

    m_btnAdd.EnableWindow(TRUE);
    m_btnRemoveAll.EnableWindow(TRUE);

    // Attempt to read HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Rpc\PortsInternetAvailable
    // this determines whether the range read later refers to internet or intranet port range
    int err;

    // read in whether ports are available for internet
    err = g_virtreg.ReadRegSzNamedValue(HKEY_LOCAL_MACHINE,
                                        TEXT("SOFTWARE\\Microsoft\\RPC\\Internet"),
                                        TEXT("PortsInternetAvailable"),
                                        &m_nInetPortsAvailableIdx);
    if (err == ERROR_SUCCESS)
    {
        CRegSzNamedValueDp * pCdp = (CRegSzNamedValueDp*)g_virtreg.GetAt(m_nInetPortsAvailableIdx);

        CString sTmp = pCdp -> Value();

        if ((sTmp == TEXT("y")) || (sTmp == TEXT("Y")))
        {
            m_nrbRangeAssignment = (int)cprInternet;
            m_pRanges = &m_arrInternetRanges;
        }
        else
        {
            m_nrbRangeAssignment = (int)cprIntranet;
            m_pRanges = &m_arrIntranetRanges;
        }
    }
    else if (err != ERROR_ACCESS_DENIED  &&  err !=
             ERROR_FILE_NOT_FOUND)
    {
        g_util.PostErrorMessage();
    }


    // read in ports list
    err = g_virtreg.ReadRegMultiSzNamedValue(HKEY_LOCAL_MACHINE,
                                        TEXT("SOFTWARE\\Microsoft\\RPC\\Internet"),
                                        TEXT("Ports"),
                                        &m_nInetPortsIdx);
    if (err == ERROR_SUCCESS)
    {
        CRegMultiSzNamedValueDp * pCdp = (CRegMultiSzNamedValueDp*)g_virtreg.GetAt(m_nInetPortsIdx);

        CStringArray& rPorts = pCdp -> Values();

        // copy protocols
        int nIndex;
        for (nIndex = 0; nIndex < rPorts.GetSize(); nIndex++)
        {
            CString sTmp = rPorts.GetAt(nIndex);
            long dwStartPort, dwEndPort;
            ExtractPortsFromString(sTmp, dwStartPort, dwEndPort);
            m_pRanges -> Add(new CPortRange(dwStartPort, dwEndPort));
        }

        // set selection to first item
        m_nSelection = 0;
    }
    else if (err != ERROR_ACCESS_DENIED  &&  err !=
             ERROR_FILE_NOT_FOUND)
    {
        g_util.PostErrorMessage();
    }

    // read in default policy
    err = g_virtreg.ReadRegSzNamedValue(HKEY_LOCAL_MACHINE,
                                        TEXT("SOFTWARE\\Microsoft\\RPC\\Internet"),
                                        TEXT("UseInternetPorts"),
                                        &m_nInetDefaultPortsIdx);
    if (err == ERROR_SUCCESS)
    {
        CRegSzNamedValueDp * pCdp = (CRegSzNamedValueDp*)g_virtreg.GetAt(m_nInetDefaultPortsIdx);

        CString sTmp = pCdp -> Value();

        if ((sTmp == TEXT("y")) || (sTmp == TEXT("Y")))
            m_nrbDefaultAssignment = (int)cprDefaultInternet;
        else
            m_nrbDefaultAssignment = (int)cprDefaultIntranet;
    }
    else if (err != ERROR_ACCESS_DENIED  &&  err !=
             ERROR_FILE_NOT_FOUND)
    {
        g_util.PostErrorMessage();
    }

    m_bChanged = FALSE;
    RefreshRanges(NULL, TRUE);

    // focus and selection will be set to listbox
//    if (m_nSelection != -1)
//        return FALSE;

    UpdateData(FALSE);
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CPortRangesDlg::OnAddPortRange()
{
    CAddPortDlg capd;

    if (capd.DoModal() == IDOK)
    {
        CPortRange* pNewPort = capd.GetPortRange();
        m_pRanges -> Add(pNewPort);

        SortRangeSet(*m_pRanges);

        RefreshRanges(pNewPort, TRUE);
        m_bChanged = TRUE;
    }
    SetFocus();
}

void CPortRangesDlg::OnRemovePortRange()
{
    if (m_nSelection != -1)
    {
        CPortRange *pRange = (CPortRange*)m_pRanges -> GetAt(m_nSelection);
        m_pRanges -> RemoveAt(m_nSelection);
        m_lbRanges.DeleteString(m_nSelection);
        RefreshRanges(pRange, FALSE);
        
        delete pRange;
        m_bChanged = TRUE;
        
        if (!m_lbRanges.GetCount())
        {
            m_nrbDefaultAssignment = (int)cprDefaultIntranet;
            m_nrbRangeAssignment = (int)cprIntranet;
            UpdateData(FALSE);
        }
    }
}

void CPortRangesDlg::OnRemoveAllRanges()
{
    RemoveAllRanges(*m_pRanges);
    RefreshRanges(NULL, TRUE);
    m_nrbDefaultAssignment = (int)cprDefaultIntranet;
    m_nrbRangeAssignment = (int)cprIntranet;
    UpdateData(FALSE);
    m_bChanged = TRUE;
}

void CPortRangesDlg::RefreshRanges(CPortRange *pModifiedRange, BOOL bAdded)
{
    if (!pModifiedRange && bAdded)
    {
        m_nSelection = 0;
        m_lbRanges.ResetContent();
    }

    // for a deleted item we only need to update the selection
    for (int nIndex = 0; bAdded && (nIndex < m_pRanges -> GetSize()); nIndex++)
    {
        CPortRange *pRange = (CPortRange*) m_pRanges  -> GetAt(nIndex);
        int nNewIndex = -1;

        if (!pModifiedRange || (pModifiedRange == pRange))
        {
            // add string for range
            CString sTmp;
            PortsToString(sTmp, pRange -> m_dwStart, pRange -> m_dwFinish);
            ;
            if ((nNewIndex = m_lbRanges.InsertString(nIndex, sTmp))!= LB_ERR)
                m_lbRanges.SetItemDataPtr(nNewIndex, pRange);

            if (pModifiedRange)
            {
                m_nSelection = nNewIndex;
                break;
            }
        }
    }

    // check if selection is out of range
    int nCount = m_lbRanges.GetCount();
    if (m_nSelection >= nCount)
        m_nSelection = nCount -1;

    // update selection settings
    m_btnRemove.EnableWindow(m_nSelection != -1);
    m_btnRemoveAll.EnableWindow(nCount > 0);

    CWnd * pTmpRadioBtn = NULL;

    pTmpRadioBtn = GetDlgItem(IDC_ASSIGN_RANGE_INTERNET);
    if (pTmpRadioBtn)
        pTmpRadioBtn -> EnableWindow(nCount > 0);

    pTmpRadioBtn = GetDlgItem(IDC_ASSIGN_RANGE_INTRANET);
    if (pTmpRadioBtn)
        pTmpRadioBtn -> EnableWindow(nCount > 0);

    pTmpRadioBtn = GetDlgItem(IDC_DEFAULT_INTERNET);
    if (pTmpRadioBtn)
        pTmpRadioBtn -> EnableWindow(nCount > 0);

    pTmpRadioBtn = GetDlgItem(IDC_DEFAULT_INTRANET);
    if (pTmpRadioBtn)
        pTmpRadioBtn -> EnableWindow(nCount > 0);

    if (m_nSelection != -1)
        m_lbRanges.SetCurSel(m_nSelection);
}

void CPortRangesDlg::CreateInverseRangeSet(CObArray & arrSrc, CObArray & arrDest)
{
    CondenseRangeSet(arrSrc);

    int nIndex;

    long nPreviousFinish = -1;

    // dont bother creating inverse range set for empty range set
    if (arrSrc.GetSize() != 0)
    {
        for (nIndex = 0; nIndex < arrSrc.GetSize(); nIndex++)
        {
            CPortRange *pRange = (CPortRange*) arrSrc.GetAt(nIndex);

            if ((pRange -> m_dwStart - nPreviousFinish) > 1)
            {
                CPortRange *pNewRange = new CPortRange(nPreviousFinish+1,pRange -> m_dwStart -1);
                arrDest.Add(pNewRange);
            }
            nPreviousFinish = pRange -> m_dwFinish;
        }

        // special case for last item
        if (MAX_PORT > nPreviousFinish)
        {
            CPortRange *pFinalRange = new CPortRange(nPreviousFinish+1,MAX_PORT);
            arrDest.Add(pFinalRange);
        }
    }
}

void CPortRangesDlg::SortRangeSet(CObArray& arrSrc)
{
    // bubble sort of port range set
    BOOL bChange;
    int nIndex;

    // iterate until no changes
    do
    {
        bChange = FALSE;
        for (nIndex = 0; nIndex < (arrSrc.GetSize() -1 ); nIndex++)
        {
            CPortRange *pRange1 = (CPortRange*) arrSrc.GetAt(nIndex);
            CPortRange *pRange2 = (CPortRange*) arrSrc.GetAt(nIndex+1);

            if (*pRange2 < *pRange1)
            {
                arrSrc.SetAt(nIndex, (CObject*)pRange2);
                arrSrc.SetAt(nIndex+1, (CObject*)pRange1);
                bChange = TRUE;
            }
        }
    }
    while (bChange);
}


void CPortRangesDlg::CondenseRangeSet(CObArray &arrSrc)
{
    SortRangeSet(arrSrc);

    int nIndex;

    for (nIndex = 0; nIndex < (arrSrc.GetSize() -1 ); nIndex++)
    {
        CPortRange *pRange1 = (CPortRange*) arrSrc.GetAt(nIndex);
        CPortRange *pRange2 = (CPortRange*) arrSrc.GetAt(nIndex+1);

        if (pRange1 -> m_dwFinish >= pRange2 -> m_dwStart)
        {
            if (pRange1 -> m_dwFinish < pRange2 -> m_dwFinish)
                pRange1 -> m_dwFinish = pRange2 -> m_dwFinish;

            arrSrc.RemoveAt(nIndex+1);
            delete pRange2;
        }
    }
}

void CPortRangesDlg::RemoveAllRanges(CObArray & arrSrc)
{
    int nIndex;

    for (nIndex = 0; nIndex < arrSrc.GetSize(); nIndex++)
    {
        CPortRange *pRange = (CPortRange*) arrSrc.GetAt(nIndex);
        arrSrc.SetAt(nIndex, NULL);
        delete pRange;
    }

    arrSrc.RemoveAll();

    RefreshRanges(NULL, TRUE);
}

void CPortRangesDlg::OnAssignRangeInternet()
{
    if (m_pRanges != &m_arrInternetRanges)
    {
        m_pRanges = &m_arrInternetRanges;
        RemoveAllRanges(*m_pRanges);
        CreateInverseRangeSet(m_arrIntranetRanges, m_arrInternetRanges);

        RefreshRanges(NULL, TRUE);
    	m_bChanged = TRUE;
    }
}

void CPortRangesDlg::OnAssignRangeIntranet()
{
    if (m_pRanges != &m_arrIntranetRanges)
    {
        m_pRanges = &m_arrIntranetRanges;
        RemoveAllRanges(*m_pRanges);
        CreateInverseRangeSet(m_arrInternetRanges, m_arrIntranetRanges);

        RefreshRanges(NULL, TRUE);
        m_bChanged = TRUE;

    }
}

void CPortRangesDlg::OnDefaultInternet()
{
        m_bChanged = TRUE;
}

void CPortRangesDlg::OnDefaultIntranet()
{
        m_bChanged = TRUE;
}

void CPortRangesDlg::OnSelChangeRanges()
{
    if ((m_nSelection = m_lbRanges.GetCurSel()) == LB_ERR)
        m_nSelection = -1;
}

void CPortRangesDlg::OnOK()
{
    UpdateData(TRUE);   
    if (m_bChanged)
    {
        // write out registry data if necessary
        // if there are no port ranges - then delete the keys
        if ((m_arrInternetRanges.GetSize() == 0) &&
            (m_arrIntranetRanges.GetSize() == 0))
        {
            if (m_nInetPortsIdx != -1)
                g_virtreg.MarkHiveForDeletion(m_nInetPortsIdx);
            if (m_nInetPortsAvailableIdx != -1)
                g_virtreg.MarkHiveForDeletion(m_nInetPortsAvailableIdx);
            if (m_nInetDefaultPortsIdx != -1)
                g_virtreg.MarkHiveForDeletion(m_nInetDefaultPortsIdx);
        }
        else
        {
            // write out updated / new key values

            // port range assignments
            TCHAR* pTmp = ((m_nrbRangeAssignment == (int)cprInternet) ? TEXT("Y") : TEXT("N"));
            if (m_nInetPortsAvailableIdx != -1)
                g_virtreg.ChgRegSzNamedValue(m_nInetPortsAvailableIdx, pTmp);
            else
            {
                g_virtreg.NewRegSzNamedValue(HKEY_LOCAL_MACHINE,
                                        TEXT("SOFTWARE\\Microsoft\\RPC\\Internet"),
                                        TEXT("PortsInternetAvailable"),
                                        pTmp,
                                        &m_nInetPortsAvailableIdx);
            }

            // default port assignments
            pTmp = ((m_nrbDefaultAssignment == (int)cprDefaultInternet) ? TEXT("Y") : TEXT("N"));
            if (m_nInetDefaultPortsIdx != -1)
                g_virtreg.ChgRegSzNamedValue(m_nInetDefaultPortsIdx, pTmp);
            else
            {
            g_virtreg.NewRegSzNamedValue(HKEY_LOCAL_MACHINE,
                                        TEXT("SOFTWARE\\Microsoft\\RPC\\Internet"),
                                        TEXT("UseInternetPorts"),
                                        pTmp,
                                        &m_nInetDefaultPortsIdx);
            }

            // Actual port ranges
            if (m_nInetPortsIdx == -1)
                g_virtreg.NewRegMultiSzNamedValue(HKEY_LOCAL_MACHINE,
                                TEXT("SOFTWARE\\Microsoft\\RPC\\Internet"),
                                TEXT("Ports"),
                                &m_nInetPortsIdx);

            if (m_nInetPortsIdx != -1)
            {
                CRegMultiSzNamedValueDp * pMszdp = (CRegMultiSzNamedValueDp*)g_virtreg.GetAt( m_nInetPortsIdx);
                pMszdp -> Clear();

                CStringArray& rStrings = pMszdp -> Values();
                for (int nIndex = 0; nIndex < m_pRanges -> GetSize(); nIndex++)
                {
                    CPortRange *pRange = (CPortRange*) m_pRanges -> GetAt(nIndex);
                    CString sTmp;

                    PortsToString(sTmp, pRange -> Start(), pRange -> Finish());
                    rStrings.Add(sTmp);
                }
                pMszdp -> SetModified(TRUE);
            }

        }
    }

    CDialog::OnOK();
}


/////////////////////////////////////////////////////////////////////////////
// CAddPortDlg dialog


CAddPortDlg::CAddPortDlg(CWnd* pParent /*=NULL*/)
    : CDialog(CAddPortDlg::IDD, pParent)
{
    //{{AFX_DATA_INIT(CAddPortDlg)
    m_sRange = _T("");
    //}}AFX_DATA_INIT

    m_dwStartPort = -1;
    m_dwEndPort = -1;
}


void CAddPortDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAddPortDlg)
    DDX_Control(pDX, IDC_PORTRANGE, m_edtPortRange);
    DDX_Control(pDX, IDOK, m_btnOk);
    DDX_Control(pDX, IDC_SINSTRUCTIONS, m_stInstructions);
    DDX_Text(pDX, IDC_PORTRANGE, m_sRange);
    //}}AFX_DATA_MAP

    if (pDX -> m_bSaveAndValidate)
    {
        m_sRange.TrimLeft();
        m_sRange.TrimRight();
    }
}


BEGIN_MESSAGE_MAP(CAddPortDlg, CDialog)
    //{{AFX_MSG_MAP(CAddPortDlg)
    ON_EN_CHANGE(IDC_PORTRANGE, OnChangePortrange)
    ON_WM_HELPINFO()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAddPortDlg message handlers


BOOL CAddPortDlg::OnInitDialog()
{
    CDialog::OnInitDialog();
    
    CString sTmp((LPCTSTR)IDS_ADDPORT_INSTRUCTIONS);

    m_stInstructions.SetWindowText(sTmp);
    m_btnOk.EnableWindow(FALSE);
    m_edtPortRange.SetFocus();
    return FALSE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

void CAddPortDlg::OnOK()
{
    UpdateData(TRUE);

    if (Validate())
        CDialog::OnOK();
    else
    {
		CString sTmp((LPCTSTR)IDS_INVALID_PORTRANGE);
        AfxMessageBox((LPCTSTR)sTmp);
    }
}


BOOL CAddPortDlg::Validate()
{
    // check contents of m_sRange
    long dwStartPort = -1, dwEndPort = -1;
    return ExtractPortsFromString(m_sRange, m_dwStartPort, m_dwEndPort);
}

void CAddPortDlg::OnChangePortrange()
{
    UpdateData(TRUE);

    m_btnOk.EnableWindow(!m_sRange.IsEmpty());

}

CPortRange* CAddPortDlg::GetPortRange()
{
    return new CPortRange(m_dwStartPort, m_dwEndPort);

}

BOOL CAddPortDlg::OnHelpInfo(HELPINFO* pHelpInfo)
{
    if(-1 != pHelpInfo->iCtrlId)
    {
        WORD hiWord = 0x8000 | CAddPortDlg::IDD;
        WORD loWord = (WORD) pHelpInfo->iCtrlId;
        DWORD dwLong = MAKELONG(loWord,hiWord);

        WinHelp(dwLong, HELP_CONTEXTPOPUP);
        TRACE1("Help Id 0x%lx\n", dwLong);
        return TRUE;
    }
    else
    {
        return CDialog::OnHelpInfo(pHelpInfo);
    }
}

BOOL CAddProtocolDlg::OnHelpInfo(HELPINFO* pHelpInfo)
{
    if(-1 != pHelpInfo->iCtrlId)
    {
        WORD hiWord = 0x8000 | CAddProtocolDlg::IDD;
        WORD loWord = (WORD) pHelpInfo->iCtrlId;
        DWORD dwLong = MAKELONG(loWord,hiWord);

        WinHelp(dwLong, HELP_CONTEXTPOPUP);
        TRACE1("Help Id 0x%lx\n", dwLong);
        return TRUE;
    }
    else
    {
        return CDialog::OnHelpInfo(pHelpInfo);
    }
}

BOOL CEndpointDetails::OnHelpInfo(HELPINFO* pHelpInfo)
{
    if(-1 != pHelpInfo->iCtrlId)
    {
        WORD hiWord = 0x8000 | CEndpointDetails::IDD;
        WORD loWord = (WORD) pHelpInfo->iCtrlId;
        DWORD dwLong = MAKELONG(loWord,hiWord);

        WinHelp(dwLong, HELP_CONTEXTPOPUP);
        TRACE1("Help Id 0x%lx\n", dwLong);
        return TRUE;
    }
    else
    {
        return CDialog::OnHelpInfo(pHelpInfo);
    }
}

BOOL CPortRangesDlg::OnHelpInfo(HELPINFO* pHelpInfo)
{
    if(-1 != pHelpInfo->iCtrlId)
    {
        WORD hiWord = 0x8000 | CPortRangesDlg::IDD;
        WORD loWord = (WORD) pHelpInfo->iCtrlId;

        // both radio button pairs should generate same help id
        if (loWord == IDC_DEFAULT_INTRANET)
            loWord = IDC_DEFAULT_INTERNET;

        // both radio button pairs should generate same help id
        if (loWord == IDC_ASSIGN_RANGE_INTRANET)
            loWord = IDC_ASSIGN_RANGE_INTERNET;

        DWORD dwLong = MAKELONG(loWord,hiWord);


        WinHelp(dwLong, HELP_CONTEXTPOPUP);
        TRACE1("Help Id 0x%lx\n", dwLong);
        return TRUE;
    }
    else
    {
        return CDialog::OnHelpInfo(pHelpInfo);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleui\inetppg.h ===
// InternetPropertyPage.h : header file
//

/////////////////////////////////////////////////////////////////////////////
// CInternetPropertyPage dialog

class CInternetPropertyPage : public CPropertyPage
{
    DECLARE_DYNCREATE(CInternetPropertyPage)

// Construction
public:
    void InitData(CString AppName, HKEY hkAppID);
    CInternetPropertyPage();
    ~CInternetPropertyPage();

// Dialog Data
    //{{AFX_DATA(CInternetPropertyPage)
    enum { IDD = IDD_INTERNET };
    CButton m_chkLaunch;
    CButton m_chkInternet;
    CButton m_chkAccess;
    BOOL    m_bAllowAccess;
    BOOL    m_bAllowInternet;
    BOOL    m_bAllowLaunch;
    //}}AFX_DATA


// Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CInternetPropertyPage)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    BOOL m_bCanModify;
    BOOL m_bChanged;
    // Generated message map functions
    //{{AFX_MSG(CInternetPropertyPage)
    afx_msg void OnAllowInternet();
    afx_msg void OnAllowaccess();
    afx_msg void OnAllowlaunch();
    afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleui\inetppg.cpp ===
// InternetPropertyPage.cpp : implementation file
//

#include "stdafx.h"
#include "olecnfg.h"
#include "inetppg.h"
#include "util.h"
#include <tchar.h>

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CInternetPropertyPage property page

IMPLEMENT_DYNCREATE(CInternetPropertyPage, CPropertyPage)

CInternetPropertyPage::CInternetPropertyPage() : CPropertyPage(CInternetPropertyPage::IDD)
{
    //{{AFX_DATA_INIT(CInternetPropertyPage)
    m_bAllowAccess = FALSE;
    m_bAllowInternet = FALSE;
    m_bAllowLaunch = FALSE;
    //}}AFX_DATA_INIT

    m_bAllowInternet = m_bAllowLaunch = m_bAllowAccess = FALSE;
    m_bCanModify = TRUE;
}

CInternetPropertyPage::~CInternetPropertyPage()
{
}


void PASCAL DDX_Enable(CDataExchange* pDX, int nIDC, BOOL bEnable)
{
    HWND hWndCtrl = pDX->PrepareCtrl(nIDC);

    :: EnableWindow(hWndCtrl,bEnable);
}


void CInternetPropertyPage::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CInternetPropertyPage)
    DDX_Control(pDX, IDC_ALLOWLAUNCH, m_chkLaunch);
    DDX_Control(pDX, IDC_ALLOWINTERNET, m_chkInternet);
    DDX_Control(pDX, IDC_ALLOWACCESS, m_chkAccess);
    DDX_Check(pDX, IDC_ALLOWACCESS, m_bAllowAccess);
    DDX_Check(pDX, IDC_ALLOWINTERNET, m_bAllowInternet);
    DDX_Check(pDX, IDC_ALLOWLAUNCH, m_bAllowLaunch);
    //}}AFX_DATA_MAP

    DDX_Enable(pDX, IDC_ALLOWLAUNCH, m_bAllowInternet);
    DDX_Enable(pDX, IDC_ALLOWACCESS, m_bAllowInternet);

}


BEGIN_MESSAGE_MAP(CInternetPropertyPage, CPropertyPage)
    //{{AFX_MSG_MAP(CInternetPropertyPage)
    ON_BN_CLICKED(IDC_ALLOWINTERNET, OnAllowInternet)
    ON_BN_CLICKED(IDC_ALLOWACCESS, OnAllowaccess)
    ON_BN_CLICKED(IDC_ALLOWLAUNCH, OnAllowlaunch)
    ON_WM_HELPINFO()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CInternetPropertyPage message handlers

//+-------------------------------------------------------------------------
//
//  Member:     CInternetPropertyPage::InitData
//
//  Synopsis:   Method to initialise options
//
//  Arguments:  None
//
//  Returns:    Nothing
//
//  Algorithm:  N/A
//
//  History:    02-Dec-96 Ronans    Created
//
//--------------------------------------------------------------------------
void CInternetPropertyPage::InitData(CString AppName, HKEY hkAppID)
{
    // read internet permissions data from the registry 
    ASSERT(hkAppID != NULL);

    TCHAR szInternetPermission[128];
    DWORD dwBufferSize = 128 * sizeof(TCHAR);
    DWORD dwType = REG_SZ;

    LONG lErr = RegQueryValueEx(hkAppID, 
                                TEXT("DcomHttpPermission"), 
                                0,
                                &dwType,
                                (LPBYTE)szInternetPermission,
                                &dwBufferSize);

    if (lErr == ERROR_SUCCESS)
    {
        if (dwBufferSize != 0)
        {
            TCHAR *pszToken = _tcstok(szInternetPermission, TEXT(" "));
            
            // parse retrieved value
            while (pszToken != NULL)
            {
                if (_tcsicmp(pszToken, TEXT("LAUNCH")) == 0)
                {
                    m_bAllowLaunch = TRUE;
                    m_bAllowInternet = TRUE;
                }
                else if (_tcsicmp(pszToken, TEXT("ACCESS")) == 0)
                {
                    m_bAllowAccess = TRUE;
                    m_bAllowInternet = TRUE;
                }
                else if (_tcsicmp(pszToken, TEXT("NONE")) == 0)
                {
                    m_bAllowAccess = FALSE;
                    m_bAllowInternet = FALSE;
                    m_bAllowInternet = FALSE;
                }

                pszToken = _tcstok(NULL, TEXT(" "));
            }
        }
    }
    else
        // nt 4.0 returns ERROR_FILE_NOT_FOUND if no value is found 
        if ((lErr != ERROR_SUCCESS) && (lErr != ERROR_FILE_NOT_FOUND))
            {
            m_bCanModify = FALSE;
            g_util.PostErrorMessage();
            }

    SetModified(FALSE);
    m_bChanged = FALSE;
}


void CInternetPropertyPage::OnAllowInternet() 
{
    m_bChanged = TRUE;
    UpdateData(TRUE);
    SetModified(TRUE);
}

void CInternetPropertyPage::OnAllowaccess() 
{
    m_bChanged = TRUE;
    UpdateData(TRUE);
    SetModified(TRUE);
 }

void CInternetPropertyPage::OnAllowlaunch() 
{
    m_bChanged = TRUE;
    UpdateData(TRUE);
    SetModified(TRUE);
}

BOOL CInternetPropertyPage::OnHelpInfo(HELPINFO* pHelpInfo) 
{
    /*
    if(-1 != pHelpInfo->iCtrlId)
    {
            WORD hiWord = 0x8000 | CGeneralPropertyPage::IDD;
            WORD loWord = pHelpInfo->iCtrlId;
            DWORD dwLong = MAKELONG(loWord,hiWord);

            WinHelp(dwLong, HELP_CONTEXTPOPUP);
            return TRUE;
    }

    else
    */
    {
            return CPropertyPage::OnHelpInfo(pHelpInfo);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleui\epprops.h ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1997.
//
//  File:       endpointDetails.h
//
//  Contents:   Defines the classes CEndpointDetails,
//
//  Classes:    
//
//  Methods:    
//
//  History:    03-Dec-96   Ronans    Created.
//
//----------------------------------------------------------------------


#ifndef __ENDPOINTDETAILS_H__
#define __ENDPOINTDETAILS_H__

/////////////////////////////////////////////////////////////////////////////
// ProtocolDesc structure

struct ProtocolDesc {

	enum endpFormat {
		ef_Integer255 = 1,
		ef_IpPortNum = 2, 
		ef_NamedPipe = 4, 
		ef_Integer = 8, 
		ef_DecNetObject = 16, 
		ef_Char22 = 32, 
		ef_VinesSpPort = 64,
		ef_sAppService = 128 };

	LPCTSTR pszProtseq;
	int nResidDesc;
	int	 nEndpFmt;
	int nAddrTip;
	int nEndpointTip;
	BOOL bAllowDynamic;
    BOOL m_bSupportedInCOM;
};

int FindProtocol(LPCTSTR pszProtSeq);

/////////////////////////////////////////////////////////////////////////////
// CEndpointData

class CEndpointData : public CObject
{
	DECLARE_DYNAMIC(CEndpointData)

public:
	BOOL AllowGlobalProperties();
	BOOL GetDescription(CString&);
	enum EndpointFlags { edUseStaticEP = 0, edUseInternetEP = 1, edUseIntranetEP = 2, edDisableEP = 3 };

	CEndpointData();
	CEndpointData(LPCTSTR szProtseq, EndpointFlags nDynamic = edUseStaticEP, LPCTSTR szEndpoint = NULL);

	CString m_szProtseq;
	EndpointFlags m_nDynamicFlags;
	CString m_szEndpoint;
	ProtocolDesc *m_pProtocol;

};

/////////////////////////////////////////////////////////////////////////////
// CEndpointDetails dialog

class CEndpointDetails : public CDialog
{
// Construction
public:
	void UpdateProtocolUI();
	void SetEndpointData(CEndpointData* pData);
	CEndpointData* GetEndpointData(CEndpointData *);
	CEndpointDetails(CWnd* pParent = NULL);   // standard constructor


	enum operation { opAddProtocol, opUpdateProtocol };

	void SetOperation (  operation opTask );

    enum btnOrder { rbiDisable = 0, rbiDefault,  rbiStatic, rbiIntranet, rbiInternet }; 

    // Dialog Data
	//{{AFX_DATA(CEndpointDetails)
	enum { IDD = IDD_RPCEP_DETAILS };
	CButton	m_rbDisableEP;
	CStatic	m_stProtseq;
	CStatic	m_stInstructions;
	CEdit	m_edtEndpoint;
	CButton	m_rbStaticEP;
	CComboBox	m_cbProtseq;
	CString	m_szEndpoint;
	int		m_nDynamic;
	//}}AFX_DATA

	CButton	m_rbDynamicInternet;
	CButton	m_rbDynamicIntranet;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CEndpointDetails)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	CEndpointData::EndpointFlags m_nDynamicFlags;
	int m_nProtocolIndex;
	operation m_opTask;
	CEndpointData *m_pCurrentEPData;

	// Generated message map functions
	//{{AFX_MSG(CEndpointDetails)
	virtual BOOL OnInitDialog();
	afx_msg void OnChooseProtocol();
	afx_msg void OnEndpointAssignment();
    afx_msg void OnEndpointAssignmentStatic();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
#endif
/////////////////////////////////////////////////////////////////////////////
// CAddProtocolDlg dialog

const long MIN_PORT = 0;
const long MAX_PORT = 0xffff;


class CAddProtocolDlg : public CDialog
{
// Construction
public:
	CAddProtocolDlg(CWnd* pParent = NULL);   // standard constructor
	CEndpointData* GetEndpointData(CEndpointData *);

// Dialog Data
	//{{AFX_DATA(CAddProtocolDlg)
	enum { IDD = IDD_ADDPROTOCOL };
	CComboBox	m_cbProtseq;
	CStatic	m_stInstructions;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAddProtocolDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAddProtocolDlg)
	afx_msg void OnChooseProtocol();
	virtual BOOL OnInitDialog();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

private:
	int m_nProtocolIndex;
	CEndpointData *m_pCurrentEPData;

};

class CPortRange : public CObject
{
    friend class CPortRangesDlg;
    friend class CAddPortDlg;
public:
    CPortRange(long start, long finish);
    long Start();
    long Finish();
    BOOL operator<(CPortRange& rRange);

private:
    long m_dwStart;
    long m_dwFinish;
};

inline CPortRange::CPortRange(long start, long finish)
{
    m_dwStart = start;
    m_dwFinish = finish;
}

inline long CPortRange::Start()
{
    return m_dwStart;
}

inline long CPortRange::Finish()
{
    return m_dwFinish;
}

inline BOOL CPortRange::operator<(CPortRange& rRange)
{
    return (m_dwStart < rRange.m_dwStart);
}
/////////////////////////////////////////////////////////////////////////////
// CPortRangesDlg dialog


class CPortRangesDlg : public CDialog
{
// Construction
public:
	CPortRangesDlg(CWnd* pParent = NULL);   // standard constructor
    ~CPortRangesDlg();

	void RemoveAllRanges(CObArray& rRanges);
	void RefreshRanges(CPortRange *pModifiedRange, BOOL bAdded);

    enum cprRangeAssignment { cprInternet = 0, cprIntranet = 1 };
    enum cprDefaultRange { cprDefaultInternet = 0, cprDefaultIntranet = 1 };

// Dialog Data
	//{{AFX_DATA(CPortRangesDlg)
	enum { IDD = IDD_RPC_PORT_RANGES };
	CButton	m_rbRangeInternet;
	CStatic	m_stInstructions;
	CListBox	m_lbRanges;
	CButton	m_btnRemoveAll;
	CButton	m_btnRemove;
	CButton	m_btnAdd;
	int		m_nrbDefaultAssignment;
	int		m_nrbRangeAssignment;          // 1 = intranet, 0 = internet
	//}}AFX_DATA
    CButton	m_rbRangeIntranet;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPortRangesDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	void CondenseRangeSet(CObArray &arrSrc);
	void SortRangeSet(CObArray &arrSrc);
	void CreateInverseRangeSet(CObArray& arrSrc, CObArray& arrDest);

	// Generated message map functions
	//{{AFX_MSG(CPortRangesDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnAddPortRange();
	afx_msg void OnRemovePortRange();
	afx_msg void OnRemoveAllRanges();
	afx_msg void OnAssignRangeInternet();
	afx_msg void OnAssignRangeIntranet();
	afx_msg void OnSelChangeRanges();
	virtual void OnOK();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
        afx_msg void OnDefaultInternet();
        afx_msg void OnDefaultIntranet();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
	CObArray* m_pRanges;
	int m_nSelection;
    CObArray m_arrInternetRanges;
    CObArray m_arrIntranetRanges;

    int m_nInetPortsIdx;
    int m_nInetPortsAvailableIdx;
    int m_nInetDefaultPortsIdx;

    BOOL m_bChanged;

};
/////////////////////////////////////////////////////////////////////////////
// CAddPortDlg dialog

class CAddPortDlg : public CDialog
{
// Construction
public:
    CPortRange* GetPortRange();
	BOOL Validate();
	CAddPortDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CAddPortDlg)
	enum { IDD = IDD_ADD_PORT_RANGE };
	CEdit	m_edtPortRange;
	CButton	m_btnOk;
	CStatic	m_stInstructions;
	CString	m_sRange;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAddPortDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CAddPortDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnChangePortrange();
	afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
private:
	long m_dwEndPort;
	long m_dwStartPort;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleui\locppg.cpp ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1997.
//
//  File:       locppg.cpp
//
//  Contents:   Implements the classes CGeneralPropertyPage,
//              CLocationPropertyPage, CSecurityPropertyPage and
//              CIdentityPropertyPage which manage the four property
//              pages per AppId.
//
//  Classes:
//
//  Methods:    CGeneralPropertyPage::CGeneralPropertyPage
//              CGeneralPropertyPage::~CGeneralPropertyPage
//              CGeneralPropertyPage::DoDataExchange
//              CLocationPropertyPage::CLocationPropertyPage
//              CLocationPropertyPage::~CLocationPropertyPage
//              CLocationPropertyPage::DoDataExchange
//              CLocationPropertyPage::OnBrowse
//              CLocationPropertyPage::OnRunRemote
//              CLocationPropertyPage::UpdateControls
//              CLocationPropertyPage::OnSetActive
//              CLocationPropertyPage::OnChange
//              CSecurityPropertyPage::CSecurityPropertyPage
//              CSecurityPropertyPage::~CSecurityPropertyPage
//              CSecurityPropertyPage::DoDataExchange
//              CSecurityPropertyPage::OnDefaultAccess
//              CSecurityPropertyPage::OnCustomAccess
//              CSecurityPropertyPage::OnDefaultLaunch
//              CSecurityPropertyPage::OnCustomLaunch
//              CSecurityPropertyPage::OnDefaultConfig
//              CSecurityPropertyPage::OnCustomConfig
//              CSecurityPropertyPage::OnEditAccess
//              CSecurityPropertyPage::OnEditLaunch
//              CSecurityPropertyPage::OnEditConfig
//              CIdentityPropertyPage::CIdentityPropertyPage
//              CIdentityPropertyPage::~CIdentityPropertyPage
//              CIdentityPropertyPage::DoDataExchange
//              CIdentityPropertyPage::OnBrowse
//              CIdentityPropertyPage::OnChange
//
//  History:    23-Apr-96   BruceMa    Created.
//              ??-Oct-97   ronans     General fixes and cleanup 
//
//----------------------------------------------------------------------


#include "stdafx.h"
#include "afxtempl.h"
#include "assert.h"
#include "resource.h"
#include "types.h"
#include "LocPPg.h"
#include "clspsht.h"
#include "datapkt.h"

#if !defined(STANDALONE_BUILD)
extern "C"
{
#include <getuser.h>
}
#endif

#include "util.h"
#include "virtreg.h"

#if !defined(STANDALONE_BUILD)
#include "ntlsa.h"
#endif



#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CGeneralPropertyPage, CPropertyPage)
IMPLEMENT_DYNCREATE(CLocationPropertyPage, CPropertyPage)
IMPLEMENT_DYNCREATE(CSecurityPropertyPage, CPropertyPage)
IMPLEMENT_DYNCREATE(CIdentityPropertyPage, CPropertyPage)


/////////////////////////////////////////////////////////////////////////////
// CGeneralPropertyPage property page

CGeneralPropertyPage::CGeneralPropertyPage() : CPropertyPage(CGeneralPropertyPage::IDD)
{
    //{{AFX_DATA_INIT(CGeneralPropertyPage)
    m_szServerName = _T("");
    m_szServerPath = _T("");
    m_szServerType = _T("");
    m_szPathTitle = _T("");
    m_szComputerName = _T("");
    //}}AFX_DATA_INIT

    m_authLevel = Defaultx;
    m_authLevelIndex = -1;
    m_bChanged = FALSE;
}

CGeneralPropertyPage::~CGeneralPropertyPage()
{
    CancelChanges();
}

void CGeneralPropertyPage::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);

    switch (m_iServerType)
    {
    case INPROC:
	m_szPathTitle.LoadString(IDS_PATH);
	GetDlgItem(IDC_PATHTITLE)->ShowWindow(SW_SHOW);
	GetDlgItem(IDC_MACHINETITLE)->ShowWindow(SW_HIDE);
	GetDlgItem(IDC_SERVERPATH)->ShowWindow(SW_SHOW);
	GetDlgItem(IDC_MACHINE)->ShowWindow(SW_HIDE);
        m_szServerType.LoadString(IDS_SERVERTYPE_INPROC);
	break;

  case LOCALEXE:
        m_szPathTitle.LoadString(IDS_PATH);
        GetDlgItem(IDC_PATHTITLE)->ShowWindow(SW_SHOW);
        GetDlgItem(IDC_MACHINETITLE)->ShowWindow(SW_HIDE);
        GetDlgItem(IDC_SERVERPATH)->ShowWindow(SW_SHOW);
        GetDlgItem(IDC_MACHINE)->ShowWindow(SW_HIDE);
	m_szServerType.LoadString(IDS_SERVERTYPE_LOCALEXE);
        break;
    
    case SERVICE:
        m_szPathTitle.LoadString(IDS_SERVICENAME);
        GetDlgItem(IDC_PATHTITLE)->ShowWindow(SW_SHOW);
        GetDlgItem(IDC_MACHINETITLE)->ShowWindow(SW_HIDE);
        GetDlgItem(IDC_SERVERPATH)->ShowWindow(SW_SHOW);
        GetDlgItem(IDC_MACHINE)->ShowWindow(SW_HIDE);
	m_szServerType.LoadString(IDS_SERVERTYPE_SERVICE);
        break;
    
    case PURE_REMOTE:
        GetDlgItem(IDC_PATHTITLE)->ShowWindow(SW_HIDE);
        GetDlgItem(IDC_MACHINETITLE)->ShowWindow(SW_SHOW);
        GetDlgItem(IDC_SERVERPATH)->ShowWindow(SW_HIDE);
        GetDlgItem(IDC_MACHINE)->ShowWindow(SW_SHOW);
        m_szServerType.LoadString(IDS_SERVERTYPE_PURE_REMOTE);
        break;
    
    case REMOTE_LOCALEXE:
        m_szPathTitle.LoadString(IDS_PATH);
        GetDlgItem(IDC_PATHTITLE)->ShowWindow(SW_SHOW);
        GetDlgItem(IDC_MACHINETITLE)->ShowWindow(SW_SHOW);
        GetDlgItem(IDC_SERVERPATH)->ShowWindow(SW_SHOW);
        GetDlgItem(IDC_MACHINE)->ShowWindow(SW_SHOW);
	m_szServerType.LoadString(IDS_SERVERTYPE_REMOTE_LOCALEXE);
        break;
    
    case REMOTE_SERVICE:
        m_szPathTitle.LoadString(IDS_SERVICENAME);
        GetDlgItem(IDC_PATHTITLE)->ShowWindow(SW_SHOW);
        GetDlgItem(IDC_MACHINETITLE)->ShowWindow(SW_SHOW);
        GetDlgItem(IDC_SERVERPATH)->ShowWindow(SW_SHOW);
        GetDlgItem(IDC_MACHINE)->ShowWindow(SW_SHOW);
	m_szServerType.LoadString(IDS_SERVERTYPE_REMOTE_SERVICE);
        break;
    
    case SURROGATE:
        m_szPathTitle.LoadString(IDS_PATH);
        GetDlgItem(IDC_PATHTITLE)->ShowWindow(SW_SHOW);
        GetDlgItem(IDC_MACHINETITLE)->ShowWindow(SW_HIDE);
        GetDlgItem(IDC_SERVERPATH)->ShowWindow(SW_SHOW);
        GetDlgItem(IDC_MACHINE)->ShowWindow(SW_HIDE);
	m_szServerType.LoadString(IDS_SERVERTYPE_SURROGATE);
        break;

   default:
        m_szServerType.LoadString(IDS_SERVERTYPE_UNKNOWN);
	break;
    }
    
    //{{AFX_DATA_MAP(CGeneralPropertyPage)
    DDX_Control(pDX, IDC_COMBO1, m_authLevelCBox);
    DDX_Text(pDX, IDC_SERVERNAME, m_szServerName);
    DDX_Text(pDX, IDC_SERVERPATH, m_szServerPath);
    DDX_Text(pDX, IDC_SERVERTYPE, m_szServerType);
    DDX_Text(pDX, IDC_PATHTITLE, m_szPathTitle);
    DDX_Text(pDX, IDC_MACHINE, m_szComputerName);
    //}}AFX_DATA_MAP
}

void CGeneralPropertyPage::OnEditchangeCombo1() 
{
    // TODO: Add your control notification handler code here
    
}

void CGeneralPropertyPage::OnSelchangeCombo1() 
{
    int iSel;

    // Get the new selection
    iSel = m_authLevelCBox.GetCurSel();
    m_authLevel = (AUTHENTICATIONLEVEL) m_authLevelCBox.GetItemData(iSel);

    // Virtually write it to the registry
    if (m_authLevelIndex == -1)
    {
        g_virtreg.NewRegDwordNamedValue(g_hAppid,
                                        NULL,
                                        TEXT("AuthenticationLevel"),
                                        m_authLevel,
                                        &m_authLevelIndex);
    }
    else
    {
        g_virtreg.ChgRegDwordNamedValue(m_authLevelIndex,
                                        m_authLevel);
    }

    // This is a reboot event
    g_fReboot = TRUE;

    // Enable the Apply button
    SetModified(m_bChanged = TRUE);
}

BOOL CGeneralPropertyPage::OnInitDialog() 
{
    int iIndex;
    int   err;
    CPropertyPage::OnInitDialog();
    
    // Populate the authentication combo boxe
    CString sTemp;

    m_authLevelCBox.ResetContent();

    // Associate values with entries
    sTemp.LoadString(IDS_DEFAULT);
    iIndex = m_authLevelCBox.AddString(sTemp);
    m_authLevelCBox.SetItemData(iIndex, Defaultx);

    sTemp.LoadString(IDS_NONE);
    iIndex = m_authLevelCBox.AddString(sTemp);
    m_authLevelCBox.SetItemData(iIndex, None);

    sTemp.LoadString(IDS_CONNECT);
    iIndex = m_authLevelCBox.AddString(sTemp);
    m_authLevelCBox.SetItemData(iIndex, Connect);

    sTemp.LoadString(IDS_CALL);
    iIndex = m_authLevelCBox.AddString(sTemp);
    m_authLevelCBox.SetItemData(iIndex, Call);

    sTemp.LoadString(IDS_PACKET);
    iIndex = m_authLevelCBox.AddString(sTemp);
    m_authLevelCBox.SetItemData(iIndex, Packet);

    sTemp.LoadString(IDS_PACKETINTEGRITY);
    iIndex = m_authLevelCBox.AddString(sTemp);
    m_authLevelCBox.SetItemData(iIndex, PacketIntegrity);

    sTemp.LoadString(IDS_PACKETPRIVACY);
    iIndex = m_authLevelCBox.AddString(sTemp);
    m_authLevelCBox.SetItemData(iIndex, PacketPrivacy);
    
    m_authLevelCBox.SetCurSel(Defaultx);

    // Attempt to read HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\OLE.
    // LegacyAuthenticationLevel
    err = g_virtreg.ReadRegDwordNamedValue(g_hAppid,
                                           NULL,
                                           TEXT("AuthenticationLevel"),
                                           &m_authLevelIndex);
    if (err == ERROR_SUCCESS)
    {
        CDataPacket * pCdp = g_virtreg.GetAt(m_authLevelIndex);

        m_authLevel = (AUTHENTICATIONLEVEL) pCdp->GetDwordValue();
    }
    else if (err != ERROR_ACCESS_DENIED  &&  err != ERROR_FILE_NOT_FOUND)
    {
        g_util.PostErrorMessage();
    }
    else
        m_authLevel = Defaultx;

    // AuthenticationLevel
    for (int k = 0; k < m_authLevelCBox.GetCount(); k++)
    {
        if (((AUTHENTICATIONLEVEL) m_authLevelCBox.GetItemData(k)) == m_authLevel)
        {
            m_authLevelCBox.SetCurSel(k);
            break;
        }
    }

    SetModified(m_bChanged = FALSE);
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

//+-------------------------------------------------------------------------
//
//  Member:     CGeneralPropertyPage::ValidateChanges
//
//  Synopsis:   Called to validate the changes before updating
//
//  Arguments:  None
//
//  Returns:    BOOL success flag
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
BOOL CGeneralPropertyPage::ValidateChanges()
{
    UpdateData(TRUE);
    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CGeneralPropertyPage::UpdateChanges
//
//  Synopsis:   Called to update the changes to registry
//
//  Arguments:  hkAppID - HKEY for AppID 
//
//  Returns:    BOOL success flag
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
BOOL CGeneralPropertyPage::UpdateChanges(HKEY hkAppID)
{
    if (m_authLevelIndex >= 0)
    {
        if (m_bChanged)
        {
            // delete key if its the default
            if (m_authLevel == Defaultx)
                g_virtreg.MarkForDeletion(m_authLevelIndex);
            g_virtreg.Apply(m_authLevelIndex);
        }
        g_virtreg.Remove(m_authLevelIndex);
        m_authLevelIndex = -1;
    }
    m_bChanged = FALSE;
    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CGeneralPropertyPage::CancelChanges
//
//  Synopsis:   Called to cancel the changes to registry
//
//  Arguments:  None
//
//  Returns:    BOOL success flag
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
BOOL CGeneralPropertyPage::CancelChanges()
{
    if (m_authLevelIndex >= 0)
    {
        g_virtreg.Remove(m_authLevelIndex);
        m_authLevelIndex = -1;
    }

    return TRUE;
}



BOOL CGeneralPropertyPage::OnHelpInfo(HELPINFO* pHelpInfo)
{
    if(-1 != pHelpInfo->iCtrlId)
    {
        WORD hiWord = 0x8000 | CGeneralPropertyPage::IDD;
        WORD loWord = (WORD) pHelpInfo->iCtrlId;
        DWORD dwLong = MAKELONG(loWord,hiWord);

        WinHelp(dwLong, HELP_CONTEXTPOPUP);
        return TRUE;
    }
    else
        return CPropertyPage::OnHelpInfo(pHelpInfo);
}

BEGIN_MESSAGE_MAP(CGeneralPropertyPage, CPropertyPage)
    //{{AFX_MSG_MAP(CGeneralPropertyPage)
    ON_WM_HELPINFO()
    ON_CBN_EDITCHANGE(IDC_COMBO1, OnEditchangeCombo1)
    ON_CBN_SELCHANGE(IDC_COMBO1, OnSelchangeCombo1)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CLocationPropertyPage property page

CLocationPropertyPage::CLocationPropertyPage() : CPropertyPage(CLocationPropertyPage::IDD)
{
    //{{AFX_DATA_INIT(CLocationPropertyPage)
    m_szComputerName = _T("");
    m_fAtStorage = FALSE;
    m_fLocal = FALSE;
    m_fRemote = FALSE;
    m_iInitial = 2;
    //}}AFX_DATA_INIT
    m_bChanged = FALSE;
}

CLocationPropertyPage::~CLocationPropertyPage()
{
}

void CLocationPropertyPage::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CLocationPropertyPage)
    DDX_Text(pDX, IDC_EDIT1, m_szComputerName);
    DDV_MaxChars(pDX, m_szComputerName, 256);
    DDX_Check(pDX, IDC_CHECK1, m_fAtStorage);
    DDX_Check(pDX, IDC_CHECK2, m_fLocal);
    DDX_Check(pDX, IDC_CHECK3, m_fRemote);
    //}}AFX_DATA_MAP
    if (m_fRemote)
    {
        pDX->PrepareEditCtrl(IDC_EDIT1);
        if (m_szComputerName.GetLength() == 0  &&  m_iInitial == 0)
        {
            CString szTemp;
            szTemp.LoadString(IDS_INVALIDSERVER);
            MessageBox(szTemp);
            pDX->Fail();
        }
    }

    if (m_fAtStorage)
    {
        m_pPage1->m_szComputerName.LoadString(IDS_ATSTORAGE);
    }
    else
        m_pPage1->m_szComputerName = m_szComputerName;

    switch(m_pPage1->m_iServerType)
    {
    case LOCALEXE:
    case SERVICE:
        if (m_fAtStorage || m_fRemote)
            m_pPage1->m_iServerType += 3;
        break;
    
    case REMOTE_LOCALEXE:
    case REMOTE_SERVICE:
        if (!(m_fAtStorage || m_fRemote))
            m_pPage1->m_iServerType -= 3;
        break;
    }

    if (m_iInitial)
        m_iInitial--;
}

BEGIN_MESSAGE_MAP(CLocationPropertyPage, CPropertyPage)
    //{{AFX_MSG_MAP(CLocationPropertyPage)
    ON_BN_CLICKED(IDC_BUTTON1, OnBrowse)
    ON_BN_CLICKED(IDC_CHECK3, OnRunRemote)
    ON_EN_CHANGE(IDC_EDIT1, OnChange)
    ON_BN_CLICKED(IDC_CHECK1, OnChange)
    ON_BN_CLICKED(IDC_CHECK2, OnChange)
    ON_WM_HELPINFO()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CLocationPropertyPage::OnBrowse()
{
    TCHAR szMachine[MAX_PATH];

    if (g_util.InvokeMachineBrowser(szMachine))
    {
        // Strip off "\\" - if present
        int nIndex = 0;
        while(szMachine[nIndex] == TEXT('\\'))
            nIndex++;

        GetDlgItem(IDC_EDIT1)->SetWindowText(&szMachine[nIndex]);
        SetModified(m_bChanged = TRUE);
    }
}

void CLocationPropertyPage::OnRunRemote()
{
    SetModified(m_bChanged = TRUE);
    UpdateControls();
}

void CLocationPropertyPage::UpdateControls()
{
    BOOL fChecked = IsDlgButtonChecked(IDC_CHECK3);
    GetDlgItem(IDC_EDIT1)->EnableWindow(fChecked);

    // Leave this browse button disabled until after SUR Beta 2
    GetDlgItem(IDC_BUTTON1)->EnableWindow(fChecked);
}

BOOL CLocationPropertyPage::OnSetActive()
{
    if (!m_fCanBeLocal)
        GetDlgItem(IDC_CHECK2)->EnableWindow(FALSE);
    UpdateControls();
    return CPropertyPage::OnSetActive();
}

void CLocationPropertyPage::OnChange()
{
    SetModified(m_bChanged = TRUE);
}

//+-------------------------------------------------------------------------
//
//  Member:     CLocationPropertyPage::ValidateChanges
//
//  Synopsis:   Called to validate the changes before updating
//
//  Arguments:  None
//
//  Returns:    BOOL success flag
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
BOOL CLocationPropertyPage::ValidateChanges()
{
    UpdateData(TRUE);

    // Check that remote servers are valid connectable machines
    if (m_fRemote)
    {
        if (!g_util.VerifyRemoteMachine((TCHAR *) LPCTSTR(m_szComputerName)))
            return FALSE;
    }
    
    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CLocationPropertyPage::UpdateChanges
//
//  Synopsis:   Called to update the changes to registry
//
//  Arguments:  hkAppID - HKEY for AppID 
//
//  Returns:    BOOL success flag
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
BOOL CLocationPropertyPage::UpdateChanges(HKEY hkAppID)
{
    long lErr;

    ////////////////////////////////////////////////////////////////////
    // Persist Location property page data
    if (m_fAtStorage)
        lErr = RegSetValueEx(
                hkAppID,
                TEXT("ActivateAtStorage"),
                0,
                REG_SZ,
                (BYTE *)TEXT("Y"),
                sizeof(TCHAR) * 2);
    else
        lErr = RegDeleteValue(hkAppID, TEXT("ActivateAtStorage"));


    if (m_fRemote)
        lErr = RegSetValueEx(
                hkAppID,
                TEXT("RemoteServerName"),
                0,
                REG_SZ,
                (BYTE *)(LPCTSTR)m_szComputerName,
                (1 + m_szComputerName.GetLength()) * sizeof(TCHAR));
    else
        lErr = RegDeleteValue(hkAppID, TEXT("RemoteServerName"));

    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CLocationPropertyPage::CancelChanges
//
//  Synopsis:   Called to cancel the changes to registry
//
//  Arguments:  None
//
//  Returns:    BOOL success flag
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
BOOL CLocationPropertyPage::CancelChanges()
{
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
// CSecurityPropertyPage property page

CSecurityPropertyPage::CSecurityPropertyPage() : CPropertyPage(CSecurityPropertyPage::IDD)
{
    //{{AFX_DATA_INIT(CSecurityPropertyPage)
    m_iAccess             = -1;
    m_iLaunch             = -1;
    m_iConfig             = -1;
    m_iAccessIndex        = -1;
    m_iLaunchIndex        = -1;
    m_iConfigurationIndex = -1;
    //}}AFX_DATA_INIT
}

CSecurityPropertyPage::~CSecurityPropertyPage()
{
}

void CSecurityPropertyPage::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CSecurityPropertyPage)
    DDX_Radio(pDX, IDC_RADIO1, m_iAccess);
    DDX_Radio(pDX, IDC_RADIO3, m_iLaunch);
    DDX_Radio(pDX, IDC_RADIO5, m_iConfig);
    //}}AFX_DATA_MAP
    GetDlgItem(IDC_BUTTON1)->EnableWindow(1 == m_iAccess);
    GetDlgItem(IDC_BUTTON2)->EnableWindow(1 == m_iLaunch);
    GetDlgItem(IDC_BUTTON3)->EnableWindow(1 == m_iConfig);
}

BEGIN_MESSAGE_MAP(CSecurityPropertyPage, CPropertyPage)
    //{{AFX_MSG_MAP(CSecurityPropertyPage)
    ON_BN_CLICKED(IDC_RADIO1, OnDefaultAccess)
    ON_BN_CLICKED(IDC_RADIO2, OnCustomAccess)
    ON_BN_CLICKED(IDC_RADIO3, OnDefaultLaunch)
    ON_BN_CLICKED(IDC_RADIO4, OnCustomLaunch)
    ON_BN_CLICKED(IDC_RADIO5, OnDefaultConfig)
    ON_BN_CLICKED(IDC_RADIO6, OnCustomConfig)
    ON_BN_CLICKED(IDC_BUTTON1, OnEditAccess)
    ON_BN_CLICKED(IDC_BUTTON2, OnEditLaunch)
    ON_BN_CLICKED(IDC_BUTTON3, OnEditConfig)
    ON_WM_HELPINFO()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CSecurityPropertyPage::OnDefaultAccess()
{
    // Disable the edit access permissions window
    UpdateData(TRUE);

    // If there is an SD here then mark it for delete
    if (m_iAccessIndex != -1)
    {
        CDataPacket * pCdp = g_virtreg.GetAt(m_iAccessIndex);
        pCdp->MarkForDeletion(TRUE);
        SetModified(TRUE);
    }
}

void CSecurityPropertyPage::OnCustomAccess()
{
    UpdateData(TRUE);

    // If there is an SD here then unmark it for delete
    if (m_iAccessIndex != -1)
    {
        CDataPacket * pCdp = g_virtreg.GetAt(m_iAccessIndex);
        pCdp->MarkForDeletion(FALSE);
        SetModified(TRUE);
    }
}

void CSecurityPropertyPage::OnDefaultLaunch()
{
    UpdateData(TRUE);

    // If there is an SD here then mark it for delete
    if (m_iLaunchIndex != -1)
    {
        CDataPacket * pCdp = g_virtreg.GetAt(m_iLaunchIndex);
        pCdp->MarkForDeletion(TRUE);
        SetModified(TRUE);
    }
}

void CSecurityPropertyPage::OnCustomLaunch()
{
    UpdateData(TRUE);

    // If there is an SD here then unmark it for delete
    if (m_iLaunchIndex != -1)
    {
        CDataPacket *pCdp = g_virtreg.GetAt(m_iLaunchIndex);
        pCdp->MarkForDeletion(FALSE);
    }
}

void CSecurityPropertyPage::OnDefaultConfig()
{
    int   err;
    ULONG ulSize = 1;
    BYTE *pbValue = NULL;

    // Read the security descriptor for HKEY_CLASSES_ROOT
    // Note: We always expect to get ERROR_INSUFFICIENT_BUFFER
    err = RegGetKeySecurity(HKEY_CLASSES_ROOT,
                            OWNER_SECURITY_INFORMATION |
                            GROUP_SECURITY_INFORMATION |
                            DACL_SECURITY_INFORMATION,
                            pbValue,
                            &ulSize);
    if (err == ERROR_INSUFFICIENT_BUFFER)
    {
        pbValue = new BYTE[ulSize];
        if (pbValue == NULL)
        {
            return;
        }
        err = RegGetKeySecurity(HKEY_CLASSES_ROOT,
                                OWNER_SECURITY_INFORMATION |
                                GROUP_SECURITY_INFORMATION |
                                DACL_SECURITY_INFORMATION,
                                pbValue,
                                &ulSize);
    }
    // Change the custom security back to the default, if there is a custom
    // security descriptor, but just in the virtual registry -
    // in case the user cancels
    if (m_iConfigurationIndex != -1)
    {
        CDataPacket * pCdb = g_virtreg.GetAt(m_iConfigurationIndex);
        pCdb->ChgACL((SECURITY_DESCRIPTOR *) pbValue, TRUE);
        pCdb->SetModified(TRUE);
    }
    delete pbValue;

    UpdateData(TRUE);
    SetModified(TRUE);
}


void CSecurityPropertyPage::OnCustomConfig()
{
    // If a security descriptor already exists, then the user was here
    // before, then selected default configuration.  So just copy the
    // original as the extant custom configuration
    if (m_iConfigurationIndex != -1)
    {
        CDataPacket *pCdb = g_virtreg.GetAt(m_iConfigurationIndex);
        pCdb->ChgACL(pCdb->pkt.racl.pSecOrig, TRUE);
        pCdb-> SetModified(TRUE);
    }

    UpdateData(TRUE);
    SetModified(TRUE);
}


void CSecurityPropertyPage::OnEditAccess()
{
    int     err;

    // Invoke the ACL editor
    err = g_util.ACLEditor(m_hWnd,
                           g_hAppid,
                           NULL,
                           TEXT("AccessPermission"),
                           &m_iAccessIndex,
                           SingleACL,
                           dcomAclAccess);

    // Enable the Apply button
    if (err == ERROR_SUCCESS)
        SetModified(TRUE);
}

void CSecurityPropertyPage::OnEditLaunch()
{
    int     err;

    // Invoke the ACL editor
    err = g_util.ACLEditor(m_hWnd,
                           g_hAppid,
                           NULL,
                           TEXT("LaunchPermission"),
                           &m_iLaunchIndex,
                           SingleACL,
                           dcomAclLaunch);

    // Enable the Apply button
    if (err == ERROR_SUCCESS)
        SetModified(TRUE);
}

void CSecurityPropertyPage::OnEditConfig()
{
    int     err = ERROR_SUCCESS;

    // Invoke the ACL editor
    err = g_util.ACLEditor2(m_hWnd,
                            g_hAppid,
                            g_rghkCLSID,
                            g_cCLSIDs,
                            g_szAppTitle,
                            &m_iConfigurationIndex,
                            RegKeyACL);

    // Enable the Apply button
    if (err == ERROR_SUCCESS)
        SetModified(TRUE);
    else if (err == ERROR_ACCESS_DENIED)
        g_util.CkForAccessDenied(ERROR_ACCESS_DENIED);
    else if (err != IDCANCEL)
        g_util.PostErrorMessage();
}

//+-------------------------------------------------------------------------
//
//  Member:     CSecurityPropertyPage::ValidateChanges
//
//  Synopsis:   Called to validate the changes before updating
//
//  Arguments:  None
//
//  Returns:    BOOL success flag
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
BOOL CSecurityPropertyPage::ValidateChanges()
{
    UpdateData(TRUE);
    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CSecurityPropertyPage::UpdateChanges
//
//  Synopsis:   Called to update the changes to registry
//
//  Arguments:  hkAppID - HKEY for AppID 
//
//  Returns:    BOOL success flag
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
BOOL CSecurityPropertyPage::UpdateChanges(HKEY hkAppID)
{
    ////////////////////////////////////////////////////////////////////
    // Persist Security property page data

    // Access permissions
    // Use default access permissions
    if (m_iAccess == 0)
    {
        // Delete the local AccessPermission named value to force this
        // AppID to use the default global named value DefaultAccessPermission
        long lErr = RegDeleteValue(hkAppID, TEXT("AccessPermission"));
    }

    // Use per AppID access permissions
    else
    {
        // If the user edited security, then persist that now
        if (m_iAccessIndex >= 0)
        {
            long lErr = g_virtreg.Apply(m_iAccessIndex);
            g_virtreg.Remove(m_iAccessIndex);
            m_iAccessIndex = -1;
        }
    }

    // Launch permissions
    // Use default Launch permissions
    if (m_iLaunch == 0)
    {
        // Delete the local LaunchPermission named value to force this
        // AppID to use the default global named value DefaultLaunchPermission
        long lErr = RegDeleteValue(hkAppID, TEXT("LaunchPermission"));
    }

    // Use per AppID Launch permissions
    else
    {
        // If the user edited security, then persist that now
        if (m_iLaunchIndex >= 0)
        {
            long lErr = g_virtreg.Apply(m_iLaunchIndex);
            g_virtreg.Remove(m_iLaunchIndex);
            m_iLaunchIndex = -1;
        }
    }

    // Configuration permissions
    // Only meaningful on a per AppID basis
    // If the user edited configuration security, then persist that now
    if (m_iConfigurationIndex >= 0)
    {
        long lErr = g_virtreg.Apply(m_iConfigurationIndex);
        g_virtreg.Remove(m_iConfigurationIndex);
        m_iConfigurationIndex = -1;
    }

    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CSecurityPropertyPage::CancelChanges
//
//  Synopsis:   Called to cancel the changes to registry
//
//  Arguments:  None
//
//  Returns:    BOOL success flag
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
BOOL CSecurityPropertyPage::CancelChanges()
{
    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// CIdentityPropertyPage property page

CIdentityPropertyPage::CIdentityPropertyPage() : CPropertyPage(CIdentityPropertyPage::IDD)
{
    //{{AFX_DATA_INIT(CIdentityPropertyPage)
    m_szUserName = _T("");
    m_szPassword = _T("");
    m_szConfirmPassword = _T("");
    m_iIdentity = -1;
    //}}AFX_DATA_INIT
}

CIdentityPropertyPage::~CIdentityPropertyPage()
{
}

void CIdentityPropertyPage::DoDataExchange(CDataExchange* pDX)
{
    // If server is not a service, disable IDC_RADIO4 on page4.
    if (m_fService)
    {
        GetDlgItem(IDC_RADIO1)->EnableWindow(FALSE);
        GetDlgItem(IDC_RADIO2)->EnableWindow(FALSE);
    }
    else
    {
        GetDlgItem(IDC_RADIO4)->EnableWindow(FALSE);
    }

    CPropertyPage::DoDataExchange(pDX);

    //{{AFX_DATA_MAP(CIdentityPropertyPage)
    DDX_Text(pDX, IDC_EDIT1, m_szUserName);
    DDV_MaxChars(pDX, m_szUserName, 128);
    DDX_Text(pDX, IDC_EDIT2, m_szPassword);
    DDV_MaxChars(pDX, m_szPassword, 128);
    DDX_Text(pDX, IDC_EDIT3, m_szConfirmPassword);
    DDV_MaxChars(pDX, m_szConfirmPassword, 128);
    DDX_Radio(pDX, IDC_RADIO1, m_iIdentity);
    //}}AFX_DATA_MAP

    GetDlgItem(IDC_EDIT1)->EnableWindow(2 == m_iIdentity);
    GetDlgItem(IDC_STATIC1)->EnableWindow(2 == m_iIdentity);
    GetDlgItem(IDC_EDIT2)->EnableWindow(2 == m_iIdentity);
    GetDlgItem(IDC_STATIC2)->EnableWindow(2 == m_iIdentity);
    GetDlgItem(IDC_EDIT3)->EnableWindow(2 == m_iIdentity);
    GetDlgItem(IDC_STATIC3)->EnableWindow(2 == m_iIdentity);
    GetDlgItem(IDC_BUTTON1)->EnableWindow(2 == m_iIdentity);
}

BEGIN_MESSAGE_MAP(CIdentityPropertyPage, CPropertyPage)
    //{{AFX_MSG_MAP(CIdentityPropertyPage)
    ON_EN_CHANGE(IDC_EDIT1, OnChange)
    ON_BN_CLICKED(IDC_BUTTON1, OnBrowse)
    ON_WM_HELPINFO()
    ON_EN_CHANGE(IDC_EDIT2, OnChange)
    ON_EN_CHANGE(IDC_EDIT3, OnChange)
    ON_BN_CLICKED(IDC_RADIO1, OnChange)
    ON_BN_CLICKED(IDC_RADIO2, OnChange)
    ON_BN_CLICKED(IDC_RADIO4, OnChange)
	ON_BN_CLICKED(IDC_RADIO3, OnChangeToUser)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

void CIdentityPropertyPage::OnBrowse()
{
    TCHAR szUser[128];
    
    if (g_util.InvokeUserBrowser(m_hWnd, szUser))
    {
        GetDlgItem(IDC_EDIT1)->SetWindowText(szUser);
        UpdateData(TRUE);
        SetModified(TRUE);
    }
}

void CIdentityPropertyPage::OnChange()
{
    UpdateData(TRUE);
    SetModified(TRUE);
}

void CIdentityPropertyPage::OnChangeToUser() 
{
    if (g_util.IsBackupDC())
    {
        CString sTmp((LPCTSTR)IDS_BDCCONFIRM);
        int reply = AfxMessageBox(sTmp, MB_YESNO);
        if (reply == IDYES ) {
            UpdateData(TRUE);
            SetModified(TRUE);
        }
        else
        {
            UpdateData(FALSE);

            // set focus to old button 
            switch (m_iIdentity)
            {
            case 0:
                GetDlgItem(IDC_RADIO1)->SetFocus();
                break;

            case 1:
                GetDlgItem(IDC_RADIO2)->SetFocus();
                break;

            case 2:
                GetDlgItem(IDC_RADIO3)->SetFocus();
                break;

            case 3:
                GetDlgItem(IDC_RADIO4)->SetFocus();
                break;
            }
        }
    }
    else
    {
        // get old identity value
        UpdateData(TRUE);
        SetModified(TRUE);
    }
	
}


//+-------------------------------------------------------------------------
//
//  Member:     CIdentityPropertyPage::ValidateChanges
//
//  Synopsis:   Called to validate the changes before updating
//
//  Arguments:  None
//
//  Returns:    BOOL success flag
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
BOOL CIdentityPropertyPage::ValidateChanges()
{
    CString szUserName;

    UpdateData(TRUE);

    if (m_iIdentity == 2)
    {
        // Check that the username is not blank
        if (_tcslen(m_szUserName) == 0)
        {
            CString szTemp((LPCTSTR)IDS_BLANKUSERNAME);
            MessageBox(szTemp);
            return FALSE;
        }

/*
        // Check that the password is not blank
        if (_tcslen(m_szPassword) == 0)
        {
            CString szTemp((LPCTSTR)IDS_BLANKPASSWORD);
            MessageBox(szTemp);
            return FALSE;
        }
*/

        // Check that the password has been confirmed
        if (m_szPassword != m_szConfirmPassword)
        {
            CString szTemp((LPCTSTR)IDS_NOMATCH);
            MessageBox(szTemp);
            return FALSE;
        }

        int iSplitPoint = m_szUserName.ReverseFind('\\');
        if (iSplitPoint < 0)
        {
            DWORD dwSize = MAX_COMPUTERNAME_LENGTH + 1;

            // user didn't specify a domain
            if (!GetComputerName(m_szDomain.GetBuffer(dwSize), &dwSize))
            {
                m_szDomain.ReleaseBuffer();
                g_util.PostErrorMessage();
                return FALSE;
            }
            m_szDomain.ReleaseBuffer();
            szUserName = m_szUserName;
            m_szUserName = m_szDomain + "\\" + m_szUserName;
        }
        else
        {
            // user did specify a domain
            m_szDomain = m_szUserName.Left(iSplitPoint);
            szUserName = m_szUserName.Mid(iSplitPoint + 1);
        }

        // Validate the domain and user name
        BOOL                fOk = FALSE;
        BYTE                sid[256];
        DWORD               cbSid = 256;
        TCHAR               szAcctDomain[MAX_PATH];
        DWORD               cbAcctDomain = MAX_PATH * sizeof(TCHAR);
        SID_NAME_USE        acctType;

        CString sFullUserName = m_szDomain + "\\" + m_szUserName;
        fOk = LookupAccountName(NULL,
                                (TCHAR *) ((LPCTSTR) m_szUserName),
                                sid,
                                &cbSid,
                                szAcctDomain,
                                &cbAcctDomain,
                                &acctType);

        // if successful, then validate domain name and account type
        if (fOk)
        {
            fOk = ((_tcsicmp((TCHAR *) ((LPCTSTR) m_szDomain), szAcctDomain) == 0)
                   &&
                   (acctType == SidTypeUser));

            // If still unsuccessful, then try to match the domain against
            // this computer's name
            if (!fOk)
            {
                TCHAR szThisComputer[MAX_COMPUTERNAME_LENGTH + 1];
                DWORD dwSize;

                if (GetComputerName(szThisComputer, &dwSize))
                {
                    fOk = (_tcsicmp((TCHAR *) ((LPCTSTR) szThisComputer),
                                    szAcctDomain) == 0
                           &&
                           acctType == SidTypeDomain);
                }
            }
        }

        if (!fOk)
        {
            CString szTemp((LPCTSTR)IDS_NOACCOUNT);
            MessageBox(szTemp);
            return FALSE;
        }
    }
    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CIdentityPropertyPage::UpdateChanges
//
//  Synopsis:   Called to update the changes to registry
//
//  Arguments:  hkAppID - HKEY for AppID 
//
//  Returns:    BOOL success flag
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
BOOL CIdentityPropertyPage::UpdateChanges(HKEY hkAppID)
{
    long lErr;

#if !defined(STANDALONE_BUILD)
        // Write the RunAs password to the Lsa private database
        // (Note: We do this even if it's a service since QueryServiceConfig
        //  doesn't return the password, though we can use ChangeServiceConfig
        //  to set the password in the service database.)
    if (m_iIdentity == 2)
    {
        if (!g_util.StoreUserPassword(g_szAppid, m_szPassword))
            g_util.PostErrorMessage();

        // Add rights to this user's account for "SeBatchLogonRight"
        int err;

        CString szUserName = m_szUserName;

        // ronans - do not display errors when trying to set account rights on backup domain controllers
        if ((err = g_util.SetAccountRights((LPCTSTR) szUserName, m_fService ? SE_SERVICE_LOGON_NAME : SE_BATCH_LOGON_NAME ) != ERROR_SUCCESS)
            && !g_util.IsBackupDC())
            g_util.PostErrorMessage(err);
    }
#endif

    switch (m_iIdentity)
    {
    case 0:
        {
            CString szTemp(TEXT("Interactive User"));
            lErr = RegSetValueEx(
                    hkAppID,
                    TEXT("RunAs"),
                    0,
                    REG_SZ,
                    (BYTE *)(LPCTSTR)szTemp,
                    (1 + szTemp.GetLength()) * sizeof(TCHAR));
            break;
        }

    case 1:
    case 3:
        lErr = RegDeleteValue(hkAppID,
                          TEXT("RunAs"));
    break;

    case 2:
        lErr = RegSetValueEx(hkAppID,
                         TEXT("RunAs"),
                         0,
                         REG_SZ,
                         (BYTE *)(LPCTSTR)m_szUserName,
                         (1 + m_szUserName.GetLength()) *
                         sizeof(TCHAR));
        break;
    }

    return TRUE;
}

//+-------------------------------------------------------------------------
//
//  Member:     CIdentityPropertyPage::CancelChanges
//
//  Synopsis:   Called to cancel the changes to registry
//
//  Arguments:  None
//
//  Returns:    BOOL success flag
//
//  Algorithm:  N/A
//
//  History:    27-Oct-97   Ronans  Created
//
//--------------------------------------------------------------------------
BOOL CIdentityPropertyPage::CancelChanges()
{
    return TRUE;
}








BOOL CLocationPropertyPage::OnHelpInfo(HELPINFO* pHelpInfo)
{
    if(-1 != pHelpInfo->iCtrlId)
    {
        WORD hiWord = 0x8000 | CLocationPropertyPage::IDD;
        WORD loWord = (WORD) pHelpInfo->iCtrlId;
        DWORD dwLong = MAKELONG(loWord,hiWord);

        WinHelp(dwLong, HELP_CONTEXTPOPUP);
        return TRUE;
    }
    else
        return CPropertyPage::OnHelpInfo(pHelpInfo);
}


BOOL CSecurityPropertyPage::OnHelpInfo(HELPINFO* pHelpInfo)
{
    if(-1 != pHelpInfo->iCtrlId)
    {
        WORD hiWord = 0x8000 | CSecurityPropertyPage::IDD;
        WORD loWord = (WORD) pHelpInfo->iCtrlId;
        DWORD dwLong = MAKELONG(loWord,hiWord);

        WinHelp(dwLong, HELP_CONTEXTPOPUP);
        return TRUE;
    }
    else
        return CPropertyPage::OnHelpInfo(pHelpInfo);
}


BOOL CIdentityPropertyPage::OnHelpInfo(HELPINFO* pHelpInfo)
{
    if(-1 != pHelpInfo->iCtrlId)
    {
        WORD hiWord = 0x8000 | CIdentityPropertyPage::IDD;
        WORD loWord = (WORD) pHelpInfo->iCtrlId;
        DWORD dwLong = MAKELONG(loWord,hiWord);

        WinHelp(dwLong, HELP_CONTEXTPOPUP);
        return TRUE;
    }
    else
        return CPropertyPage::OnHelpInfo(pHelpInfo);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleui\locppg.h ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1997.
//
//  File:       locppg.h
//
//  Contents:   Defines the classes CGeneralPropertyPage,
//              CLocationPropertyPage, CSecurityPropertyPage and
//              CIdentityPropertyPage which manage the four property
//              pages per AppId.
//
//  Classes:
//
//  Methods:
//
//  History:    23-Apr-96   BruceMa    Created.
//
//----------------------------------------------------------------------


#ifndef __LOCPPG_H__
#define __LOCPPG_H__

/////////////////////////////////////////////////////////////////////////////
// CGeneralPropertyPage dialog

class CGeneralPropertyPage : public CPropertyPage
{
    DECLARE_DYNCREATE(CGeneralPropertyPage)

    // Construction
public:
    CGeneralPropertyPage();
    ~CGeneralPropertyPage();
    BOOL CancelChanges();
    BOOL UpdateChanges(HKEY hkAppID);
    BOOL ValidateChanges();

    // Dialog Data
    //{{AFX_DATA(CGeneralPropertyPage)
    enum { IDD = IDD_PROPPAGE5 };
    CComboBox   m_authLevelCBox;
    CString m_szServerName;
    CString m_szServerPath;
    CString m_szServerType;
    CString m_szPathTitle;
    CString m_szComputerName;
    //}}AFX_DATA

    int m_iServerType;
    BOOL m_fSurrogate;
    BOOL m_bChanged;

    // Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CGeneralPropertyPage)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CGeneralPropertyPage)
    afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
    afx_msg void OnEditchangeCombo1();
    afx_msg void OnSelchangeCombo1();
    virtual BOOL OnInitDialog();
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

private:
    AUTHENTICATIONLEVEL m_authLevel;
    int m_authLevelIndex;
};


/////////////////////////////////////////////////////////////////////////////
// CLocationPropertyPage dialog

class CLocationPropertyPage : public CPropertyPage
{
    DECLARE_DYNCREATE(CLocationPropertyPage)

// Construction
public:
    CLocationPropertyPage();
    ~CLocationPropertyPage();
    BOOL CancelChanges();
    BOOL UpdateChanges(HKEY hkAppID);
    BOOL ValidateChanges();

    // Dialog Data
    //{{AFX_DATA(CLocationPropertyPage)
    enum { IDD = IDD_PROPPAGE11 };
    CString m_szComputerName;
    BOOL    m_fAtStorage;
    BOOL    m_fLocal;
    BOOL    m_fRemote;
    int     m_iInitial;
    //}}AFX_DATA

    BOOL    m_fCanBeLocal;
    CGeneralPropertyPage * m_pPage1;
    BOOL    m_bChanged;

    // Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CLocationPropertyPage)
    public:
    virtual BOOL OnSetActive();
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

    // Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CLocationPropertyPage)
    afx_msg void OnBrowse();
    afx_msg void OnRunRemote();
    afx_msg void OnChange();
    afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

    void UpdateControls();
};


/////////////////////////////////////////////////////////////////////////////
// CSecurityPropertyPage dialog

class CSecurityPropertyPage : public CPropertyPage
{
    DECLARE_DYNCREATE(CSecurityPropertyPage)

// Construction
public:
    CSecurityPropertyPage();
    ~CSecurityPropertyPage();
    BOOL CancelChanges();
    BOOL UpdateChanges(HKEY hkAppID);
    BOOL ValidateChanges();

    // Dialog Data
    //{{AFX_DATA(CSecurityPropertyPage)
    enum { IDD = IDD_PROPPAGE21 };
    int             m_iAccess;
    int             m_iLaunch;
    int             m_iConfig;
    int             m_iAccessIndex;
    int             m_iLaunchIndex;
    int             m_iConfigurationIndex;
    //}}AFX_DATA


    // Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CSecurityPropertyPage)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

// Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CSecurityPropertyPage)
    afx_msg void OnDefaultAccess();
    afx_msg void OnCustomAccess();
    afx_msg void OnDefaultLaunch();
    afx_msg void OnCustomLaunch();
    afx_msg void OnDefaultConfig();
    afx_msg void OnCustomConfig();
    afx_msg void OnEditAccess();
    afx_msg void OnEditLaunch();
    afx_msg void OnEditConfig();
    afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()

};


/////////////////////////////////////////////////////////////////////////////
// CIdentityPropertyPage dialog

class CIdentityPropertyPage : public CPropertyPage
{
    DECLARE_DYNCREATE(CIdentityPropertyPage)

    // Construction
public:
    CIdentityPropertyPage();
    ~CIdentityPropertyPage();
    BOOL CancelChanges();
    BOOL UpdateChanges(HKEY hkAppID);
    BOOL ValidateChanges();

    // Dialog Data
    //{{AFX_DATA(CIdentityPropertyPage)
    enum { IDD = IDD_PROPPAGE3 };
    CString m_szUserName;
    CString m_szPassword;
    CString m_szConfirmPassword;
    int m_iIdentity;
    //}}AFX_DATA

    CString m_szDomain;
    int m_fService;

    // Overrides
    // ClassWizard generate virtual function overrides
    //{{AFX_VIRTUAL(CIdentityPropertyPage)
    protected:
    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
    //}}AFX_VIRTUAL

    // Implementation
protected:
    // Generated message map functions
    //{{AFX_MSG(CIdentityPropertyPage)
    afx_msg void OnChange();
    afx_msg void OnBrowse();
    afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
    afx_msg void OnChangeToUser();
	//}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};
#endif // __LOCPPG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleui\newsrvr.cpp ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1997.
//
//  File:       newsrvr.cpp
//
//  Contents:   Implements the new server dialog
//
//  Classes:
//
//  Methods:    CNewServer::CNewServer
//              CNewServer::~CNewServer
//              CNewServer::DoDataExchange
//              CNewServer::OnLocal
//              CNewServer::OnRemote
//
//  History:    23-Apr-96   BruceMa    Created.
//
//----------------------------------------------------------------------


#include "stdafx.h"
#include "olecnfg.h"
#include "newsrvr.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// CNewServer dialog


CNewServer::CNewServer(CWnd* pParent /*=NULL*/)
        : CDialog(CNewServer::IDD, pParent)
{
        //{{AFX_DATA_INIT(CNewServer)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT
}


void CNewServer::DoDataExchange(CDataExchange* pDX)
{
        CDialog::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CNewServer)
                // NOTE: the ClassWizard will add DDX and DDV calls here
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CNewServer, CDialog)
        //{{AFX_MSG_MAP(CNewServer)
        ON_BN_CLICKED(IDC_RADIO1, OnLocal)
        ON_BN_CLICKED(IDC_RADIO2, OnRemote)
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CNewServer message handlers

void CNewServer::OnLocal()
{
        // TODO: Add your control notification handler code here
        GetDlgItem(IDC_EDIT2)->EnableWindow(TRUE);
        GetDlgItem(IDC_BUTTON1)->EnableWindow(TRUE);
        GetDlgItem(IDC_EDIT3)->EnableWindow(FALSE);
        GetDlgItem(IDC_BUTTON2)->EnableWindow(FALSE);
}

void CNewServer::OnRemote()
{
        // TODO: Add your control notification handler code here
        GetDlgItem(IDC_EDIT3)->EnableWindow(TRUE);
        GetDlgItem(IDC_BUTTON2)->EnableWindow(TRUE);
        GetDlgItem(IDC_EDIT2)->EnableWindow(FALSE);
        GetDlgItem(IDC_BUTTON1)->EnableWindow(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleui\oleui.cpp ===
// olecnfg.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"

#include "olecnfg.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleui\newsrvr.h ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1997.
//
//  File:       newsrvr.h
//
//  Contents:   Defines the class CNewServer for the new server dialog
//
//  Classes:
//
//  Methods:
//
//  History:    23-Apr-96   BruceMa    Created.
//
//----------------------------------------------------------------------


/////////////////////////////////////////////////////////////////////////////
// CNewServer dialog
#ifndef _NEWSRVR_H_
#define _NEWSRVR_H_

class CNewServer : public CDialog
{
// Construction
public:
        CNewServer(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
        //{{AFX_DATA(CNewServer)
        enum { IDD = IDD_DIALOG1 };
                // NOTE: the ClassWizard will add data members here
        //}}AFX_DATA


// Overrides
        // ClassWizard generated virtual function overrides
        //{{AFX_VIRTUAL(CNewServer)
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        //}}AFX_VIRTUAL

// Implementation
protected:

        // Generated message map functions
        //{{AFX_MSG(CNewServer)
        afx_msg void OnLocal();
        afx_msg void OnRemote();
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()
};

#endif //_NEWSRVR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleui\olecnfg.cpp ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1997.
//
//  File:       olecnfg.cpp
//
//  Contents:   Implements the class COlecnfgApp - the top level class
//              for dcomcnfg.exe
//
//  Classes:    
//
//  Methods:    COlecnfgApp::COlecnfgApp
//              COlecnfgApp::InitInstance
//
//  History:    23-Apr-96   BruceMa    Created.
//
//----------------------------------------------------------------------


#include "stdafx.h"
#include "afxtempl.h"
#include "olecnfg.h"
#include "CStrings.h"   
#include "CReg.h"
#include "types.h"
#include "datapkt.h"
#include "virtreg.h"
#include "CnfgPSht.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
// COlecnfgApp

BEGIN_MESSAGE_MAP(COlecnfgApp, CWinApp)
    //{{AFX_MSG_MAP(COlecnfgApp)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //    DO NOT EDIT what you see in these blocks of generated code!
    ON_COMMAND(ID_CONTEXT_HELP, CWinApp::OnContextHelp)
    //}}AFX_MSG

END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// COlecnfgApp construction

COlecnfgApp::COlecnfgApp()
{
    // TODO: add construction code here,
    // Place all significant initialization in InitInstance
}

/////////////////////////////////////////////////////////////////////////////
// The one and only COlecnfgApp object

COlecnfgApp theApp;

/////////////////////////////////////////////////////////////////////////////
// COlecnfgApp initialization

BOOL COlecnfgApp::InitInstance()
{
    // Standard initialization
    // If you are not using these features and wish to reduce the size
    //  of your final executable, you should remove from the following
    //  the specific initialization routines you do not need.
    
#ifdef _AFXDLL
    Enable3dControls();         // Call this when using MFC in a shared DLL
#else
    Enable3dControlsStatic();   // Call this when linking to MFC statically
#endif
    
    // This tool really so only be run by administrators.  We check this
    // by trying to get KEY_ALL_ACCESS rights to
    // HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\OLE
    HKEY hKey;
    
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("SOFTWARE\\Microsoft\\OLE"),
                     0, KEY_ALL_ACCESS, &hKey)
        != ERROR_SUCCESS)
    {
        CString sCaption;
        CString sMessage;
        
    sCaption.LoadString(IDS_SYSTEMMESSAGE);
    sMessage.LoadString(IDS_ADMINSONLY);
    MessageBox(NULL, sMessage, sCaption, MB_OK);
        return FALSE;
    }
    
    // The main body of oleui
    COlecnfgPropertySheet psht;
    m_pMainWnd = &psht;
    INT_PTR nResponse = psht.DoModal();
    if (nResponse == IDOK)
    {
        g_virtreg.Ok(0);
    }
    else if (nResponse == IDCANCEL)
    {
        g_virtreg.Cancel(0);
    }
    
    // Remove the virtual registry
    g_virtreg.RemoveAll();
    
    // Since the dialog has been closed, return FALSE so that we exit the
    //  application, rather than start the application's message pump.
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleui\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by olecnfg.rc
//
#define IDD_OLECNFG_DIALOG              102
#define IDD_PROPPAGE1                   104
#define IDD_PROPPAGE2                   105
#define IDD_PROPPAGE11                  107
#define IDD_PROPPAGE21                  108
#define IDD_PROPPAGE3                   109
#define IDD_PROPPAGE4                   110
#define IDD_PROPPAGE5                   111
#define IDD_RPCOPTIONS                  128
#define IDR_MAINFRAME                   129
#define IDD_DIALOG1                     130
#define IDR_ACCELERATOR1                131
#define IDI_ICON1                       133
#define IDD_RPCEP_DETAILS               135
#define IDI_ICON2                       137
#define IDB_IMGNETWORK                  142
#define IDD_INTERNET                    239
#define IDD_PPGDEFPROT                  241
#define IDD_ADDPROTOCOL                 242
#define IDD_RPC_PORT_RANGES             243
#define IDD_ADD_PORT_RANGE              244
#define IDS_ABOUTBOX                    300
#define IDS_PROPSHT_CAPTION             301
#define IDS_NOTIPAVAILABLE              302
#define IDS_PROTSEQ                     303
#define IDS_PROPSHT_CAPTION1            304
#define IDS_PSMAIN_TITLE                305
#define IDS_NONE                        306
#define IDS_DEFAULT                     307
#define IDS_CONNECT                     308
#define IDS_CALL                        309
#define IDS_PACKET                      310
#define IDS_PACKETINTEGRITY             311
#define IDS_PACKETPRIVACY               312
#define IDS_ANONYMOUS                   313
#define IDS_IDENTIFY                    314
#define IDS_IMPERSONATE                 315
#define IDS_DELEGATE                    316
#define IDS_ACCESSDENIED                317
#define IDS_SYSTEMMESSAGE               318
#define IDS_NA                          319
#define IDS_SERVERTYPE0                 320
#define IDS_SERVERTYPE_INPROC           320
#define IDS_SERVERTYPE1                 321
#define IDS_SERVERTYPE_LOCALEXE         321
#define IDS_SERVERTYPE2                 322
#define IDS_SERVERTYPE_SERVICE          322
#define IDS_SERVERTYPE3                 323
#define IDS_SERVERTYPE_PURE_REMOTE      323
#define IDS_SERVERTYPE4                 324
#define IDS_SERVERTYPE_REMOTE_LOCALEXE  324
#define IDS_SERVERTYPE5                 325
#define IDS_SERVERTYPE_REMOTE_SERVICE   325
#define IDS_SERVERTYPE6                 326
#define IDS_SERVICENAME                 327
#define IDS_PATH                        328
#define IDS_ATSTORAGE                   329
#define IDS_NOMATCH                     330
#define IDS_INVALIDSERVER               331
#define IDS_NOLOGON                     332
#define IDS_NOACCOUNT                   333
#define IDS_ADMINSONLY                  334
#define IDS_BLANKUSERNAME               335
#define IDS_BLANKPASSWORD               336
#define IDS_BITMAP1                     337
#define IDS_LocalService                338
#define IDS__LocalService               339
#define IDS_RemoteServerName            340
#define IDS_REBOOT                      341
#define IDS_ActivateAtStorage           342
#define IDS_RunAs                       343
#define IDS_InteractiveUser             344
#define IDS_AccessPermission            345
#define IDS_LaunchPermission            346
#define IDS_Y                           347
#define IDS_LocalServer32               348
#define IDS__LocalServer32              349
#define IDS_LocalServer                 350
#define IDS__LocalServer                351
#define IDS_CLSID                       352
#define IDS_AppID                       353
#define IDS_NULL                        354
#define IDS_The_CLSID_                  355
#define IDS_IMPERSONATION               356
#define IDS__item_                      357
#define IDS_ANONYMOUS2                  358
#define IDS_comma_and_title_            359
#define IDS_IDENTITY                    360
#define IDS__has_the_                   361
#define IDS_CLSID_                      362
#define IDS_DCOM_Configuration_Warning  363
#define IDS_SOFTWARE_Microsoft_OLE      367
#define IDS_Clsid2                      368
#define IDS_EnableDCOM                  369
#define IDS_LegacyAuthenticationLevel   370
#define IDS_LegacyImpersonationLevel    371
#define IDS_LegacySecureReferences      372
#define IDS_DefaultccessPermission      373
#define IDS_DefaultLaunchPermission     374
#define IDS_HKEY_CLASSES_ROOT           375
#define IDS_Allow_                      376
#define IDS_Deny                        377
#define IDS_Deny_                       378
#define IDS_Registry_value              379
#define IDS_Browse_for_users            380
#define IDS_SCM_                        381
#define IDS_The_security_               382
#define IDS_backslash                   383
#define IDS_Key_Read                    384
#define IDS_Query_Value                 385
#define IDS_Set_Value                   386
#define IDS_Create_Subkey               387
#define IDS_Enumerate_Subkeys           388
#define IDS_Notify                      389
#define IDS_Create_Link                 390
#define IDS_Delete                      391
#define IDS_Write_DAC                   392
#define IDS_Read_Control                393
#define IDS_Read                        394
#define IDS_Full_Control                395
#define IDS_Special_AccessDotDotDot     396
#define IDS_Registry_Key                397
#define IDS_Registry_Application        398
#define IDS_Write_Owner                 399
#define IDS_BADSD                       400
#define IDS_EFFECTIVE                   401
#define IDS_DYNAMIC                     402
#define IDS_NTMACHINENAME               403
#define IDS_SERVICENAME2                404
#define IDS_INETADDR                    405
#define IDS_INETPORT                    406
#define IDS_INTEGER255                  407
#define IDS_NTSERVER                    408
#define IDS_NAMEDPIPE                   409
#define IDS_INTEGER                     410
#define IDS_IPXINETADDR                 411
#define IDS_DECNET                      412
#define IDS_DECNETOBJECT                413
#define IDS_APPLETALK                   414
#define IDS_ATSTRING                    415
#define IDS_VINES                       416
#define IDS_VINESPORT                   417
#define IDS_DYNAMIC_INTERNET            418
#define IDS_DYNAMIC_INTRANET            419
#define IDS_EPDESC_NCACN_NB_TCP         420
#define IDS_EPDESC_NCACN_NB_IPX         421
#define IDS_EPDESC_NCACN_NB_NB          422
#define IDS_EPDESC_NCACN_IP_TCP         423
#define IDS_EPDESC_NCACN_NP             424
#define IDS_EPDESC_NCACN_SPX            425
#define IDS_EPDESC_NCACN_DNET_NSP       426
#define IDS_EPDESC_NCACN_AT_DSP         427
#define IDS_EPDESC_NCACN_VNNS_SPP       428
#define IDS_EPDESC_NCADG_IP_UDP         429
#define IDS_EPDESC_NCADG_IPX            430
#define IDS_EPDESC_NCALRPC              431
#define IDS_EPSTATIC                    432
#define IDS_INSTRUCTIONS_ADDPROTOCOL    433
#define IDS_CAPTION_ADDPROTOCOL         434
#define IDS_INSTRUCTIONS_UPDATEPROTOCOL 435
#define IDS_CAPTION_UPDATEPROTOCOL      436
#define IDS_EPDYNAMICINTRA              437
#define IDS_EPDYNAMICINTER              438
#define IDS_CANTCONVERT                 439
#define IDS_EPDESC_DEFAULT              440
#define IDS_DUPLICATE_PROTSEQ           441
#define IDS_EPDESC_NCACN_HTTP           442
#define IDS_ADDPORT_INSTRUCTIONS        443
#define IDS_INVALID_PORTRANGE           444
#define IDS_INSTRUCTIONS_PORTRANGES     445
#define IDS_BDCCONFIRM                  446
#define IDS_ERR_ENDPOINT                447
#define IDS_ALLOW_ACCESS                448
#define IDS_DENY_ACCESS                 449
#define IDS_ALLOW_LAUNCH                450
#define IDS_DENY_LAUNCH                 451
#define IDS_ALLOW_CONFIG                452
#define IDS_DENY_CONFIG                 453
#define IDS_SERVERTYPE_SURROGATE        454
#define IDS_SERVERTYPE_UNKNOWN          455
#define IDS_FATALOUTOFMEMORY            456
#define IDS_FATALOUTOFMEMORYTITLE       457
#define IDC_BUTTON1                     1000
#define IDC_EENDPOINT                   1001
#define IDC_CBPROTSEQ                   1002
#define IDC_LIST1                       1003
#define IDC_RADIO1                      1004
#define IDC_RADIO2                      1005
#define IDC_CHECK1                      1006
#define IDC_CHECK2                      1007
#define IDC_CHECK3                      1008
#define IDC_BUTTON2                     1009
#define IDC_EDIT1                       1010
#define IDC_BUTTON3                     1011
#define IDC_ASSIGN_RANGE_INTERNET       1012
#define IDC_RADIO3                      1015
#define IDC_CHKEFFECTIVE                1016
#define IDC_CHKDYNAMIC                  1017
#define IDC_LIST2                       1019
#define IDC_EDIT2                       1023
#define IDC_EDIT3                       1024
#define IDC_COMBO1                      1025
#define IDC_COMBO2                      1026
#define IDC_RADIO4                      1027
#define IDC_RADIO5                      1032
#define IDC_RADIO6                      1033
#define IDC_SERVERNAME                  1037
#define IDC_SERVERICON                  1038
#define IDC_SERVERTYPE                  1039
#define IDC_SERVERPATH                  1040
#define IDC_RUNNING                     1041
#define IDC_MACHINE                     1042
#define IDC_PATHTITLE                   1043
#define IDC_MACHINETITLE                1044
#define IDC_STATIC1                     1045
#define IDC_STATIC2                     1046
#define IDC_STATIC3                     1047
#define IDC_APPTYPE                     1048
#define IDC_APPNAME                     1049
#define IDC_LSTPROTSEQ                  1051
#define IDC_CMDADD                      1052
#define IDC_CMDREMOVE                   1053
#define IDC_CMDUPDATE                   1054
#define IDC_CMDCLEAR                    1055
#define IDC_SINSTRUCTIONS               1056
#define IDS_DESCRIPTION                 1057
#define IDC_SPROTSEQ                    1058
#define IDC_ENABLEINTERNET              1059
#define IDC_ALLOWINTERNET               1060
#define IDC_ALLOWACCESS                 1061
#define IDC_ALLOWLAUNCH                 1062
#define IDC_BTNADD                      1063
#define IDC_BTNREMOVEALL                1064
#define IDC_BTNREMOVE                   1065
#define IDC_DEFAULT_INTERNET            1066
#define IDC_DEFAULT_INTRANET            1067
#define IDC_PORTRANGE                   1068
#define IDC_CMDMOVEUP                   1069
#define IDC_CMDMOVEDOWN                 1070
#define IDC_ENETADDRESS                 1071
#define IDC_SDESCRIPTION                1072
#define IDC_EPSTATIC                    1073
#define IDC_EPDYNAMIC_DEFAULT           1074
#define IDC_EPDYNAMIC_INTRA             1075
#define IDC_EPDISABLE                   1076
#define IDC_ASSIGN_RANGE_INTRANET       1077
#define IDC_EPSTATICEP                  1078
#define IDC_EPDYNAMIC_INTER             1079
#define IDC_RIDENTIFICATION             1080
#define IDC_RANONYMOUS                  1081
#define IDC_RIMPERSONATION              1082

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        460
#define _APS_NEXT_COMMAND_VALUE         32771
#define _APS_NEXT_CONTROL_VALUE         1083
#define _APS_NEXT_SYMED_VALUE           600
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleui\olecnfg.h ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1997.
//
//  File:       olecnfg.h
//
//  Contents:   Implements the class COlecnfgApp - the top level class
//              for dcomcnfg.exe
//
//  Classes:    
//
//  Methods:    
//
//  History:    23-Apr-96   BruceMa    Created.
//
//----------------------------------------------------------------------


#ifndef __AFXWIN_H__
    #error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// COlecnfgApp:
// See olecnfg.cpp for the implementation of this class
//

class COlecnfgApp : public CWinApp
{
public:
    COlecnfgApp();

// Overrides
    // ClassWizard generated virtual function overrides
    //{{AFX_VIRTUAL(COlecnfgApp)
    public:
    virtual BOOL InitInstance();
    //}}AFX_VIRTUAL

// Implementation

    //{{AFX_MSG(COlecnfgApp)
        // NOTE - the ClassWizard will add and remove member functions here.
        //    DO NOT EDIT what you see in these blocks of generated code !
    //}}AFX_MSG
    DECLARE_MESSAGE_MAP()
};


/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleui\srvppg.cpp ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1997.
//
//  File:       srvppg.cpp
//
//  Contents:   Implements the classes CServersPropertyPage,
//              CMachinePropertyPage and CDefaultSecurityPropertyPage to
//              manage the three property pages for top level info
//
//  Classes:
//
//  Methods:    CServersPropertyPage::CServersPropertyPage
//              CServersPropertyPage::~CServersPropertyPage
//              CServersPropertyPage::OnProperties
//              CServersPropertyPage::DoDataExchange
//              CServersPropertyPage::OnServerProperties
//              CServersPropertyPage::OnInitDialog
//              CServersPropertyPage::FetchAndDisplayClasses
//              CServersPropertyPage::OnList1
//              CServersPropertyPage::OnDoubleclickedList1
//              CServersPropertyPage::OnButton2
//              CMachinePropertyPage::CMachinePropertyPage
//              CMachinePropertyPage::~CMachinePropertyPage
//              CMachinePropertyPage::DoDataExchange
//              CMachinePropertyPage::OnInitDialog
//              CMachinePropertyPage::OnCombo1
//              CMachinePropertyPage::OnCheck1
//              CMachinePropertyPage::OnCheck2
//              CMachinePropertyPage::OnEditchangeCombo1
//              CMachinePropertyPage::OnSelchangeCombo1
//              CMachinePropertyPage::OnEditchangeCombo2
//              CMachinePropertyPage::OnSelchangeCombo2
//              CDefaultSecurityPropertyPage::CDefaultSecurityPropertyPage
//              CDefaultSecurityPropertyPage::~CDefaultSecurityPropertyPage
//              CDefaultSecurityPropertyPage::DoDataExchange
//              CDefaultSecurityPropertyPage::OnInitDialog
//              CDefaultSecurityPropertyPage::OnButton1
//              CDefaultSecurityPropertyPage::OnButton2
//              CDefaultSecurityPropertyPage::OnButton3
//
//  History:    23-Apr-96   BruceMa    Created.
//
//----------------------------------------------------------------------


#include "stdafx.h"
#include "afxtempl.h"
#include "assert.h"
#include "resource.h"
#include "CStrings.h"
#include "CReg.h"
#include "types.h"
#include "SrvPPg.h"
#include "ClsPSht.h"
#include "newsrvr.h"
#include "datapkt.h"

#if !defined(STANDALONE_BUILD)
extern "C"
{
#include <getuser.h>
}
#endif

#include "util.h"
#include "virtreg.h"






#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNCREATE(CDefaultSecurityPropertyPage, CPropertyPage)
IMPLEMENT_DYNCREATE(CServersPropertyPage, CPropertyPage)
IMPLEMENT_DYNCREATE(CMachinePropertyPage, CPropertyPage)


// The globals used for communicating arguments between dialog classes
CUtility         g_util;
CVirtualRegistry g_virtreg;
HKEY             g_hAppid;
HKEY            *g_rghkCLSID;
unsigned         g_cCLSIDs;
TCHAR           *g_szAppTitle;
BOOL             g_fReboot = FALSE;
TCHAR           *g_szAppid;

/////////////////////////////////////////////////////////////////////////////
// CServersPropertyPage property page

CServersPropertyPage::CServersPropertyPage() : CPropertyPage(CServersPropertyPage::IDD)
{
    //{{AFX_DATA_INIT(CServersPropertyPage)
    // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT

    m_fApplications   = TRUE;
}

CServersPropertyPage::~CServersPropertyPage()
{
}

void CServersPropertyPage::OnProperties()
{
    CClsidPropertySheet propSheet;
    SItem              *pItem;
    HKEY                hKey;
    HKEY               *phClsids;
    TCHAR               szBuf[128];

    // Get the selected item
    pItem = m_registry.GetItem((DWORD)m_classesLst.GetItemData(m_dwSelection));

    // Save the AppID
    g_szAppid = (TCHAR*)(LPCTSTR)pItem->szAppid;

    // Open the appid key
    _tcscpy(szBuf, TEXT("AppId\\"));
    _tcscat(szBuf, (LPCTSTR)(pItem->szAppid));
    if (RegOpenKeyEx(HKEY_CLASSES_ROOT, szBuf, 0, KEY_ALL_ACCESS, &hKey)
        != ERROR_SUCCESS)
    {
        g_util.PostErrorMessage();
        return;
    }

    // Open a key for each clsid associated with this appid
    phClsids = new HKEY[pItem->ulClsids];
    if (phClsids == NULL)
    {
        g_util.PostErrorMessage();
        return;
    }
    for (UINT ul = 0; ul < pItem->ulClsids; ul++)
    {
        _tcscpy(szBuf, TEXT("ClsId\\"));
        _tcscat(szBuf, pItem->ppszClsids[ul]);
        if (RegOpenKeyEx(HKEY_CLASSES_ROOT, szBuf, 0, KEY_ALL_ACCESS,
                         &phClsids[ul])
            != ERROR_SUCCESS)
        {
            g_util.PostErrorMessage();
            RegCloseKey(hKey);
            for (UINT ul2 = 0; ul2 < ul; ul2++)
            {
                RegCloseKey(phClsids[ul2]);
            }
            delete phClsids;
            return;
        }

    }

    if (propSheet.InitData(m_szSelection, hKey, phClsids, pItem->ulClsids))
    {
        propSheet.DoModal();
    }

    // This is where you would retrieve information from the property
    // sheet if propSheet.DoModal() returned IDOK.  We aren't doing
    // anything for simplicity.

    // Close the registry keys we opened for the ClsidPropertySheet
    RegCloseKey(hKey);
    for (ul = 0; ul < pItem->ulClsids; ul++)
    {
        RegCloseKey(phClsids[ul]);
    }
    delete phClsids;
}


void CServersPropertyPage::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CServersPropertyPage)
    DDX_Control(pDX, IDC_LIST1, m_classesLst);
    //}}AFX_DATA_MAP

    GotoDlgCtrl(GetDlgItem(IDC_BUTTON1));
}


BEGIN_MESSAGE_MAP(CServersPropertyPage, CPropertyPage)
        //{{AFX_MSG_MAP(CServersPropertyPage)
        ON_BN_CLICKED(IDC_BUTTON1, OnServerProperties)
        ON_LBN_SELCHANGE(IDC_LIST1, OnList1)
        ON_LBN_DBLCLK(IDC_LIST1, OnDoubleclickedList1)
        ON_BN_CLICKED(IDC_BUTTON2,OnButton2)
        ON_WM_HELPINFO()
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()




void CServersPropertyPage::OnServerProperties()
{
    m_dwSelection = m_classesLst.GetCurSel();
    m_classesLst.GetText(m_dwSelection, m_szSelection);
    OnProperties();

}

BOOL CServersPropertyPage::OnInitDialog()
{
    // Disable property sheet help button
//    m_psp.dwFlags &= ~PSH_HASHELP;

    CPropertyPage::OnInitDialog();

    // Fetch and display the servers for the types specified
    FetchAndDisplayClasses();


    GotoDlgCtrl(GetDlgItem(IDC_BUTTON1));

    // Invoke the work-around to fix WM_HELP problem on subclassed controls
    g_util.FixHelp(this);

    return FALSE;  // return TRUE unless you set the focus to a control
    // EXCEPTION: OCX Property Pages should return FALSE
}


void CServersPropertyPage::FetchAndDisplayClasses(void)
{
    // Collect applications
    m_registry.Init();

    //  Clear the list box
    m_classesLst.ResetContent();

    //  Store application names in the list box
    SItem *pItem;

    while (pItem = m_registry.GetNextItem())
    {
        if (!pItem->fDontDisplay)
        {
            if (!pItem->szTitle.IsEmpty())
            {
                m_classesLst.AddString(pItem->szTitle);
            }
            else if (!pItem->szItem.IsEmpty())
            {
                m_classesLst.AddString(pItem->szItem);
            }
            else
            {
                m_classesLst.AddString(pItem->szAppid);
            }
        }
    }

    // The list box sorted the items during the AddString's, so now we
    // have to associate each item with its index in CRegistry
    DWORD cbItems = m_registry.GetNumItems();

    for (DWORD k = 0; k < cbItems; k++)
    {
        SItem *pItem = m_registry.GetItem(k);
        int    iLBItem;

        if (!pItem->fDontDisplay)
        {
            if (!pItem->szTitle.IsEmpty())
            {
                iLBItem = m_classesLst.FindStringExact(-1, pItem->szTitle);
            }
            else if (!pItem->szItem.IsEmpty())
            {
                iLBItem = m_classesLst.FindStringExact(-1, pItem->szItem);
            }
            else
            {
                iLBItem = m_classesLst.FindStringExact(-1, pItem->szAppid);
            }
            m_classesLst.SetItemData(iLBItem, k);
        }
    }


    // Select the first item
    m_classesLst.SetCurSel(0);

    OnList1();

}



void CServersPropertyPage::OnList1()
{
    m_dwSelection = m_classesLst.GetCurSel();
    // enable or disable the properties button as necessary
    BOOL bEnableState = GetDlgItem(IDC_BUTTON1)->IsWindowEnabled();
    BOOL bNewEnableState = m_dwSelection != LB_ERR;
    if (bNewEnableState != bEnableState)
        GetDlgItem(IDC_BUTTON1)->EnableWindow(bNewEnableState);
    m_classesLst.GetText(m_dwSelection, m_szSelection);
}

void CServersPropertyPage::OnDoubleclickedList1()
{
    m_dwSelection = m_classesLst.GetCurSel();
    m_classesLst.GetText(m_dwSelection, m_szSelection);
    OnProperties();
}

void CServersPropertyPage::OnButton2()
{
    CNewServer newServerDialog;

    newServerDialog.DoModal();
}

/////////////////////////////////////////////////////////////////////////////
// CMachinePropertyPage property page

CMachinePropertyPage::CMachinePropertyPage() : CPropertyPage(CMachinePropertyPage::IDD)
{
    //{{AFX_DATA_INIT(CMachinePropertyPage)
    //}}AFX_DATA_INIT

    m_fEnableDCOM = FALSE;
    m_fEnableDCOMIndex = -1;
    m_fEnableDCOMHTTP = FALSE;
    m_fEnableDCOMHTTPIndex = -1;
    m_fEnableRpcProxy = FALSE;
    m_fOriginalEnableRpcProxy = FALSE;
    m_fEnableRpcProxyIndex = -1;


    m_authLevel = Connect;
    m_authLevelIndex = -1;
    m_impersonateLevel = Identify;
    m_impersonateLevelIndex = -1;
    m_fLegacySecureReferences = FALSE;
    m_fLegacySecureReferencesIndex = -1;
}



CMachinePropertyPage::~CMachinePropertyPage()
{
}



void CMachinePropertyPage::DoDataExchange(CDataExchange* pDX)
{
        CPropertyPage::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CMachinePropertyPage)
        DDX_Control(pDX, IDC_ENABLEINTERNET, m_EnableDCOMInternet);
        DDX_Control(pDX, IDC_CHECK2, m_legacySecureReferencesChk);
        DDX_Control(pDX, IDC_CHECK1, m_EnableDCOMChk);
        DDX_Control(pDX, IDC_COMBO2, m_impersonateLevelCBox);
        DDX_Control(pDX, IDC_COMBO1, m_authLevelCBox);
    //}}AFX_DATA_MAP
}




BEGIN_MESSAGE_MAP(CMachinePropertyPage, CPropertyPage)
    //{{AFX_MSG_MAP(CMachinePropertyPage)
        ON_BN_CLICKED(IDC_COMBO1, OnCombo1)
        ON_BN_CLICKED(IDC_CHECK1, OnCheck1)
        ON_BN_CLICKED(IDC_CHECK2, OnCheck2)
        ON_CBN_EDITCHANGE(IDC_COMBO1, OnEditchangeCombo1)
        ON_CBN_EDITCHANGE(IDC_COMBO2, OnEditchangeCombo2)
        ON_CBN_SELCHANGE(IDC_COMBO1, OnSelchangeCombo1)
        ON_CBN_SELCHANGE(IDC_COMBO2, OnSelchangeCombo2)
        ON_WM_HELPINFO()
        ON_BN_CLICKED(IDC_ENABLEINTERNET, OnChkEnableInternet)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()




BOOL CMachinePropertyPage::OnInitDialog()
{
    int iIndex;

    // Disable property sheet help button
//    m_psp.dwFlags &= ~PSH_HASHELP;

    CPropertyPage::OnInitDialog();

    // Populate the authentication combo boxe
    CString sTemp;

    m_authLevelCBox.ResetContent();

    // Associate values with entries
    sTemp.LoadString(IDS_DEFAULT);
    iIndex = m_authLevelCBox.AddString(sTemp);
    m_authLevelCBox.SetItemData(iIndex, Defaultx);

    sTemp.LoadString(IDS_NONE);
    iIndex = m_authLevelCBox.AddString(sTemp);
    m_authLevelCBox.SetItemData(iIndex, None);

    sTemp.LoadString(IDS_CONNECT);
    iIndex = m_authLevelCBox.AddString(sTemp);
    m_authLevelCBox.SetItemData(iIndex, Connect);

    sTemp.LoadString(IDS_CALL);
    iIndex = m_authLevelCBox.AddString(sTemp);
    m_authLevelCBox.SetItemData(iIndex, Call);

    sTemp.LoadString(IDS_PACKET);
    iIndex = m_authLevelCBox.AddString(sTemp);
    m_authLevelCBox.SetItemData(iIndex, Packet);

    sTemp.LoadString(IDS_PACKETINTEGRITY);
    iIndex = m_authLevelCBox.AddString(sTemp);
    m_authLevelCBox.SetItemData(iIndex, PacketIntegrity);

    sTemp.LoadString(IDS_PACKETPRIVACY);
    iIndex = m_authLevelCBox.AddString(sTemp);
    m_authLevelCBox.SetItemData(iIndex, PacketPrivacy);


    // Populate the impersonation level combo box
    m_impersonateLevelCBox.ResetContent();

    // Associate values with entries
    sTemp.LoadString(IDS_ANONYMOUS);
    iIndex = m_impersonateLevelCBox.AddString(sTemp);
    m_impersonateLevelCBox.SetItemData(iIndex, Anonymous);

    sTemp.LoadString(IDS_IDENTIFY);
    iIndex = m_impersonateLevelCBox.AddString(sTemp);
    m_impersonateLevelCBox.SetItemData(iIndex, Identify);

    sTemp.LoadString(IDS_IMPERSONATE);
    iIndex = m_impersonateLevelCBox.AddString(sTemp);
    m_impersonateLevelCBox.SetItemData(iIndex, Impersonate);

    sTemp.LoadString(IDS_DELEGATE);
    iIndex = m_impersonateLevelCBox.AddString(sTemp);
    m_impersonateLevelCBox.SetItemData(iIndex, Delegate);


    // Set defaults
    // EnableDCOM is unchecked initially
    m_authLevelCBox.SetCurSel(Connect);
    m_impersonateLevelCBox.SetCurSel(Identify);

    // Attempt to read HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\OLE.EnableDCOM
    int err;

    err = g_virtreg.ReadRegSzNamedValue(HKEY_LOCAL_MACHINE,
                                        TEXT("SOFTWARE\\Microsoft\\OLE"),
                                        TEXT("EnableDCOM"),
                                        &m_fEnableDCOMIndex);
    if (err == ERROR_SUCCESS)
    {
        CRegSzNamedValueDp * pCdp = (CRegSzNamedValueDp*)g_virtreg.GetAt(m_fEnableDCOMIndex);
        CString sTmp = pCdp->Value();

        if (sTmp[0] == TEXT('y')  ||
            sTmp[0] == TEXT('Y'))
        {
            m_fEnableDCOM = TRUE;
        }
    }
    else if (err != ERROR_ACCESS_DENIED  &&  err !=
             ERROR_FILE_NOT_FOUND)
    {
        g_util.PostErrorMessage();
    }

    // Attempt to read HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\OLE.EnableInternetDCOM
    err = g_virtreg.ReadRegSzNamedValue(HKEY_LOCAL_MACHINE,
                                        TEXT("SOFTWARE\\Microsoft\\OLE"),
                                        TEXT("EnableDCOMHTTP"),
                                        &m_fEnableDCOMHTTPIndex);
    if (err == ERROR_SUCCESS)
    {
        CRegSzNamedValueDp * pCdp = (CRegSzNamedValueDp*)g_virtreg.GetAt(m_fEnableDCOMHTTPIndex);
        CString sTmp = pCdp->Value();

        if  (m_fEnableDCOM &&
            ((sTmp[0] == TEXT('y'))  ||
            (sTmp[0] == TEXT('Y'))))
        {
            m_fEnableDCOMHTTP = TRUE;
        }
    }
    else if (err != ERROR_ACCESS_DENIED  &&  err !=
             ERROR_FILE_NOT_FOUND)
    {
        g_util.PostErrorMessage();
    }

    // Attempt to read HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Rpc\RpcProxy\Enabled
    err = g_virtreg.ReadRegDwordNamedValue(HKEY_LOCAL_MACHINE,
                                        TEXT("SOFTWARE\\Microsoft\\Rpc\\RpcProxy"),
                                        TEXT("Enabled"),
                                        &m_fEnableRpcProxyIndex);
    if (err == ERROR_SUCCESS)
    {
        CDataPacket * pCdp = (CDataPacket*)g_virtreg.GetAt(m_fEnableRpcProxyIndex);
        DWORD dwTmp = pCdp -> GetDwordValue();

        if (dwTmp)
        {
            m_fEnableRpcProxy = TRUE;
            m_fOriginalEnableRpcProxy = TRUE;
        }
    }
    else if ((err != ERROR_ACCESS_DENIED)  &&  (err != ERROR_FILE_NOT_FOUND))
    {
        g_util.PostErrorMessage();
    }

    // enable proxy if dcomhttp is enabled
    if (m_fEnableDCOMHTTP)
    {
        m_fEnableRpcProxy = TRUE;
        if (m_fEnableRpcProxyIndex == -1)
        {
            g_virtreg.NewRegDwordNamedValue(HKEY_LOCAL_MACHINE,
                                            TEXT("SOFTWARE\\Microsoft\\Rpc\\RpcProxy"),
                                            TEXT("Enabled"),
                                            1,
                                            &m_fEnableRpcProxyIndex);
        }
        // Else simply update it in the virtual registry
        else
        {
            g_virtreg.ChgRegDwordNamedValue(m_fEnableRpcProxyIndex,1);
        }
    }


    // Attempt to read HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\OLE.
    // LegacyAuthenticationLevel
    err = g_virtreg.ReadRegDwordNamedValue(HKEY_LOCAL_MACHINE,
                                           TEXT("SOFTWARE\\Microsoft\\OLE"),
                                           TEXT("LegacyAuthenticationLevel"),
                                           &m_authLevelIndex);
    if (err == ERROR_SUCCESS)
    {
        CDataPacket * pCdp = g_virtreg.GetAt(m_authLevelIndex);

        m_authLevel = (AUTHENTICATIONLEVEL) pCdp->GetDwordValue();
    }
    else if (err != ERROR_ACCESS_DENIED  &&  err !=
             ERROR_FILE_NOT_FOUND)
    {
        g_util.PostErrorMessage();
    }

    // Attempt to read HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\OLE.
    // LegacyImpersonationLevel
    err = g_virtreg.ReadRegDwordNamedValue(HKEY_LOCAL_MACHINE,
                                           TEXT("SOFTWARE\\Microsoft\\OLE"),
                                           TEXT("LegacyImpersonationLevel"),
                                           &m_impersonateLevelIndex);
    if (err == ERROR_SUCCESS)
    {
        CDataPacket * pCdp = g_virtreg.GetAt(m_impersonateLevelIndex);

        m_impersonateLevel = (IMPERSONATIONLEVEL) pCdp->GetDwordValue();
    }
    else if (err != ERROR_ACCESS_DENIED  &&  err !=
             ERROR_FILE_NOT_FOUND)
    {
        g_util.PostErrorMessage();
    }

    // Attempt to read HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\OLE.
    // LegacySecureReferences
    err = g_virtreg.ReadRegSzNamedValue(HKEY_LOCAL_MACHINE,
                                        TEXT("SOFTWARE\\Microsoft\\OLE"),
                                        TEXT("LegacySecureReferences"),
                                        &m_fLegacySecureReferencesIndex );
    if (err == ERROR_SUCCESS)
    {
        CRegSzNamedValueDp * pCdp = (CRegSzNamedValueDp*)g_virtreg.GetAt(m_fLegacySecureReferencesIndex);
        CString sTmp = pCdp->Value();

        if (sTmp[0] == TEXT('y')  ||
            sTmp[0] == TEXT('Y'))
        {
            m_fLegacySecureReferences = TRUE;
        }
    }
    else if (err != ERROR_ACCESS_DENIED  &&  err !=
             ERROR_FILE_NOT_FOUND)
    {
        g_util.PostErrorMessage();
    }


    // Set the controls according to the current values

    // EnableDCOM
    if (m_fEnableDCOM)
    {
        m_EnableDCOMChk.SetCheck(1);
        GetDlgItem(IDC_COMBO1)->EnableWindow(TRUE);
        GetDlgItem(IDC_COMBO2)->EnableWindow(TRUE);
        GetDlgItem(IDC_CHECK2)->EnableWindow(TRUE);
        GetDlgItem(IDC_ENABLEINTERNET)->EnableWindow(TRUE);
    }
    else
    {
        m_EnableDCOMChk.SetCheck(0);
        GetDlgItem(IDC_ENABLEINTERNET)->EnableWindow(FALSE);
    }

    m_EnableDCOMInternet.SetCheck(m_fEnableDCOMHTTP);


    // AuthenticationLevel
    for (int k = 0; k < m_authLevelCBox.GetCount(); k++)
    {
        if (((AUTHENTICATIONLEVEL) m_authLevelCBox.GetItemData(k)) ==
             m_authLevel)
        {
            m_authLevelCBox.SetCurSel(k);
            break;
        }
    }

    // ImpersonationLevel
    for (k = 0; k < m_impersonateLevelCBox.GetCount(); k++)
    {
        if (((AUTHENTICATIONLEVEL) m_impersonateLevelCBox.GetItemData(k)) ==
             m_impersonateLevel)
        {
            m_impersonateLevelCBox.SetCurSel(k);
            break;
        }
    }

    // LegacySecureReferences
    if (m_fLegacySecureReferences)
    {
        m_legacySecureReferencesChk.SetCheck(1);
    }
    else
    {
        m_legacySecureReferencesChk.SetCheck(0);
    }

    // Invoke the work-around to fix WM_HELP problem on subclassed controls
    g_util.FixHelp(this);

    return TRUE;  // return TRUE unless you set the focus to a control
    // EXCEPTION: OCX Property Pages should return FALSE
}




void CMachinePropertyPage::OnCombo1()
{
    m_authLevelCBox.ShowDropDown(TRUE);

}



void CMachinePropertyPage::OnCheck1()
{
    // Flip the EnableDCOM flag
    m_fEnableDCOM ^= 1;

    //  Disable or enable the other dialog controls:
    GetDlgItem(IDC_COMBO1)->EnableWindow(m_fEnableDCOM);
    GetDlgItem(IDC_COMBO2)->EnableWindow(m_fEnableDCOM);
    GetDlgItem(IDC_CHECK2)->EnableWindow(m_fEnableDCOM);
    GetDlgItem(IDC_ENABLEINTERNET)->EnableWindow(m_fEnableDCOM);

    // Virtually write it to the registry
    if (m_fEnableDCOMIndex == -1)
    {
        g_virtreg.NewRegSzNamedValue(HKEY_LOCAL_MACHINE,
                                     TEXT("SOFTWARE\\Microsoft\\OLE"),
                                     TEXT("EnableDCOM"),
                                     m_fEnableDCOM ? _T("Y") : _T("N"),
                                     &m_fEnableDCOMIndex);
    }

    // Else simply update it in the virtual registry
    else
    {
        g_virtreg.ChgRegSzNamedValue(m_fEnableDCOMIndex,
                                     m_fEnableDCOM ? _T("Y") : _T("N"));
    }

    // This is a reboot event
    g_fReboot = TRUE;

    // Enable the Apply button
    SetModified(TRUE);
}

void CMachinePropertyPage::OnChkEnableInternet()
{
    // Flip the EnableDCOM flag
    m_fEnableDCOMHTTP ^= 1;

    // if Com Internet services are enable then enable proxy
    // otherwise set it to its original value in case non DCOM RPC application is using it
    if (m_fEnableDCOMHTTP)
        m_fEnableRpcProxy = TRUE;
    else
        m_fEnableRpcProxy = m_fOriginalEnableRpcProxy;

    // Virtually write it to the registry
    if (m_fEnableDCOMHTTPIndex == -1)
    {
        g_virtreg.NewRegSzNamedValue(HKEY_LOCAL_MACHINE,
                                     TEXT("SOFTWARE\\Microsoft\\OLE"),
                                     TEXT("EnableDCOMHTTP"),
                                     m_fEnableDCOMHTTP ? _T("Y") : _T("N"),
                                     &m_fEnableDCOMHTTPIndex);
    }

    // Else simply update it in the virtual registry
    else
    {
        g_virtreg.ChgRegSzNamedValue(m_fEnableDCOMHTTPIndex,
                                     m_fEnableDCOMHTTP ? _T("Y") : _T("N"));
    }

    if (m_fEnableRpcProxyIndex == -1)
    {
        g_virtreg.NewRegDwordNamedValue(HKEY_LOCAL_MACHINE,
                    TEXT("SOFTWARE\\Microsoft\\Rpc\\RpcProxy"),
                    TEXT("Enabled"),
                    m_fEnableRpcProxy ? 1 : 0,
                    &m_fEnableRpcProxyIndex);
    }

    // Else simply update it in the virtual registry
    else
    {
        g_virtreg.ChgRegDwordNamedValue(m_fEnableRpcProxyIndex,
                                     m_fEnableRpcProxy ? 1 : 0);
    }


    // This is a reboot event
    g_fReboot = TRUE;

    // Enable the Apply button
    SetModified(TRUE);
}


void CMachinePropertyPage::OnCheck2()
{

    // Flip LegacySecureeferences flag
    m_fLegacySecureReferences ^= 1;

    // Virtually write it to the registry
    if (m_fLegacySecureReferencesIndex == -1)
    {
        g_virtreg.NewRegSzNamedValue(HKEY_LOCAL_MACHINE,
                                     TEXT("SOFTWARE\\Microsoft\\OLE"),
                                     TEXT("LegacySecureReferences"),
                                     m_fLegacySecureReferences ? _T("Y")
                                      : _T("N"),
                                     &m_fLegacySecureReferencesIndex);
    }

    // Else simply update it in the virtual registry
    else
    {
        g_virtreg.ChgRegSzNamedValue(m_fLegacySecureReferencesIndex,
                                     m_fLegacySecureReferences ? _T("Y") : _T("N"));
    }

    // This is a reboot event
    g_fReboot = TRUE;

    // Enable the Apply button
    SetModified(TRUE);
}



void CMachinePropertyPage::OnEditchangeCombo1()
{
}


void CMachinePropertyPage::OnSelchangeCombo1()
{
    int iSel;

    // Get the new selection
    iSel = m_authLevelCBox.GetCurSel();
    m_authLevel = (AUTHENTICATIONLEVEL) m_authLevelCBox.GetItemData(iSel);

    // Virtually write it to the registry
    if (m_authLevelIndex == -1)
    {
        g_virtreg.NewRegDwordNamedValue(HKEY_LOCAL_MACHINE,
                                        TEXT("SOFTWARE\\Microsoft\\OLE"),
                                        TEXT("LegacyAuthenticationLevel"),
                                        m_authLevel,
                                        &m_authLevelIndex);
    }
    else
    {
        g_virtreg.ChgRegDwordNamedValue(m_authLevelIndex,
                                        m_authLevel);
    }

    // This is a reboot event
    g_fReboot = TRUE;

    // Enable the Apply button
    SetModified(TRUE);

}



void CMachinePropertyPage::OnEditchangeCombo2()
{
}





void CMachinePropertyPage::OnSelchangeCombo2()
{
    int iSel;

    // Get the new selection
    iSel = m_impersonateLevelCBox.GetCurSel();
    m_impersonateLevel =
        (IMPERSONATIONLEVEL) m_impersonateLevelCBox.GetItemData(iSel);

    // Virtually write it to the registry
    if (m_impersonateLevelIndex == -1)
    {
        g_virtreg.NewRegDwordNamedValue(HKEY_LOCAL_MACHINE,
                                        TEXT("SOFTWARE\\Microsoft\\OLE"),
                                        TEXT("LegacyImpersonationLevel"),
                                        m_impersonateLevel,
                                        &m_impersonateLevelIndex);
    }
    else
    {
        g_virtreg.ChgRegDwordNamedValue(m_impersonateLevelIndex,
                                        m_impersonateLevel);
    }

    // This is a reboot event
    g_fReboot = TRUE;

    // Enable the Apply button
    SetModified(TRUE);
}






/////////////////////////////////////////////////////////////////////////////
// CDefaultSecurityPropertyPage property page

CDefaultSecurityPropertyPage::CDefaultSecurityPropertyPage() : CPropertyPage(CDefaultSecurityPropertyPage::IDD)
{
        //{{AFX_DATA_INIT(CDefaultSecurityPropertyPage)
                // NOTE: the ClassWizard will add member initialization here
        //}}AFX_DATA_INIT

    m_accessPermissionIndex        = -1;
    m_launchPermissionIndex        = -1;
    m_configurationPermissionIndex = -1;
    m_fAccessChecked               = FALSE;
}



CDefaultSecurityPropertyPage::~CDefaultSecurityPropertyPage()
{
}



void CDefaultSecurityPropertyPage::DoDataExchange(CDataExchange* pDX)
{
        CPropertyPage::DoDataExchange(pDX);
        //{{AFX_DATA_MAP(CDefaultSecurityPropertyPage)
                // NOTE: the ClassWizard will add DDX and DDV calls here
        //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDefaultSecurityPropertyPage, CPropertyPage)
        //{{AFX_MSG_MAP(CDefaultSecurityPropertyPage)
        ON_BN_CLICKED(IDC_BUTTON1, OnButton1)
        ON_BN_CLICKED(IDC_BUTTON2, OnButton2)
        ON_BN_CLICKED(IDC_BUTTON3, OnButton3)
        ON_WM_HELPINFO()
        //}}AFX_MSG_MAP
END_MESSAGE_MAP()



// Default access permissions
BOOL CDefaultSecurityPropertyPage::OnInitDialog(void)
{
    BOOL fPostMsg = FALSE;

    // Disable property sheet help button
//    m_psp.dwFlags &= ~PSH_HASHELP;

    if (!m_fAccessChecked)
    {

        // Check whether we are denied access to
        // HKEY_LOCAL_MACHINE
        if (!g_util.CkAccessRights(HKEY_LOCAL_MACHINE, NULL))
        {
            GetDlgItem(IDC_BUTTON3)->EnableWindow(FALSE);
            fPostMsg = TRUE;
        }

        // Post a message to the user
        if (fPostMsg)
        {
            CString sMsg;
            CString sCaption;

            sMsg.LoadString(IDS_ACCESSDENIED);
            sCaption.LoadString(IDS_SYSTEMMESSAGE);
            MessageBox(sMsg, sCaption, MB_OK);
        }
    }

    m_fAccessChecked = TRUE;
    return TRUE;
}



// Default access permissions
void CDefaultSecurityPropertyPage::OnButton1()
{
    int     err;
    
    // Invoke the ACL editor
    err = g_util.ACLEditor(m_hWnd,
                           HKEY_LOCAL_MACHINE,
                           TEXT("SOFTWARE\\Microsoft\\OLE"),
                           TEXT("DefaultAccessPermission"),
                           &m_accessPermissionIndex,
                           SingleACL,
                           dcomAclAccess);

    // Enable the Apply button
    if (err == ERROR_SUCCESS)
    {
        // This is a reboot event
        g_fReboot = TRUE;

        SetModified(TRUE);
    }
}


// Default launch permissions
void CDefaultSecurityPropertyPage::OnButton2()
{
    int     err;

    // Invoke the ACL editor
    err = g_util.ACLEditor(m_hWnd,
                           HKEY_LOCAL_MACHINE,
                           TEXT("SOFTWARE\\Microsoft\\OLE"),
                           TEXT("DefaultLaunchPermission"),
                           &m_launchPermissionIndex,
                           SingleACL,
                           dcomAclLaunch);

    // Enable the Apply button
    if (err == ERROR_SUCCESS)
    {
        // This is a reboot event
        g_fReboot = TRUE;

        SetModified(TRUE);
    }

}


// Default configuration permissions
void CDefaultSecurityPropertyPage::OnButton3()
{
    int     err;

    err = g_util.ACLEditor2(m_hWnd,
                            HKEY_CLASSES_ROOT,
                            NULL,
                            0,
                            NULL,
                           &m_configurationPermissionIndex,
                            RegKeyACL);

    // Enable the Apply button
    if (err == ERROR_SUCCESS)
        SetModified(TRUE);
}

BOOL CDefaultSecurityPropertyPage::OnHelpInfo(HELPINFO* pHelpInfo)
{
    if(-1 != pHelpInfo->iCtrlId)
    {
        WORD hiWord = 0x8000 | CDefaultSecurityPropertyPage::IDD;
        WORD loWord = (WORD) pHelpInfo->iCtrlId;
        DWORD dwLong = MAKELONG(loWord,hiWord);

        WinHelp(dwLong, HELP_CONTEXTPOPUP);
        return TRUE;
    }

    else
    {
        return CPropertyPage::OnHelpInfo(pHelpInfo);
    }

    return CPropertyPage::OnHelpInfo(pHelpInfo);
}



BOOL CMachinePropertyPage::OnHelpInfo(HELPINFO* pHelpInfo)
{
    if(-1 != pHelpInfo->iCtrlId)
    {
        WORD hiWord = 0x8000 | CMachinePropertyPage::IDD;
        WORD loWord = (WORD) pHelpInfo->iCtrlId;
        DWORD dwLong = MAKELONG(loWord,hiWord);

        WinHelp(dwLong, HELP_CONTEXTPOPUP);
        return TRUE;
    }

    else
    {
        return CPropertyPage::OnHelpInfo(pHelpInfo);
    }
}



BOOL CServersPropertyPage::OnHelpInfo(HELPINFO* pHelpInfo)
{
    if(-1 != pHelpInfo->iCtrlId)
    {
        WORD hiWord = 0x8000 | CServersPropertyPage::IDD;
        WORD loWord = (WORD) pHelpInfo->iCtrlId;
        DWORD dwLong = MAKELONG(loWord,hiWord);

        WinHelp(dwLong, HELP_CONTEXTPOPUP);
        return TRUE;
    }

    else
    {
        return CPropertyPage::OnHelpInfo(pHelpInfo);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleui\srvppg.h ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1997.
//
//  File:       srvppg.h
//
//  Contents:   Defines the classes CServersPropertyPage,
//              CMachinePropertyPage and CDefaultSecurityPropertyPage to
//              manage the three property pages for top level info
//
//  Classes:
//
//  Methods:
//
//  History:    23-Apr-96   BruceMa    Created.
//
//----------------------------------------------------------------------


#ifndef __SRVPPG_H__
#define __SRVPPG_H__


/////////////////////////////////////////////////////////////////////////////
// CServersPropertyPage dialog

class CServersPropertyPage : public CPropertyPage
{
        DECLARE_DYNCREATE(CServersPropertyPage)

// Construction
public:
        CServersPropertyPage();
        ~CServersPropertyPage();
void OnProperties();
void FetchAndDisplayClasses();


// Dialog Data
        //{{AFX_DATA(CServersPropertyPage)
        enum { IDD = IDD_PROPPAGE1 };
        CListBox        m_classesLst;
        //}}AFX_DATA


// Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CServersPropertyPage)
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        virtual BOOL OnInitDialog();

        //}}AFX_VIRTUAL

// Implementation
protected:
        // Generated message map functions
        //{{AFX_MSG(CServersPropertyPage)
        afx_msg void OnServerProperties();
        afx_msg void OnList1();
        afx_msg void OnDoubleclickedList1();
        afx_msg void OnButton2();
        afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()

private:
        CRegistry m_registry;
        BOOL      m_fApplications;
        DWORD     m_dwSelection;
        TCHAR     m_szSelection[MAX_PATH];

};


/////////////////////////////////////////////////////////////////////////////
// CMachinePropertyPage dialog

class CMachinePropertyPage : public CPropertyPage
{
        DECLARE_DYNCREATE(CMachinePropertyPage)

        // Construction
public:
        CMachinePropertyPage();
        ~CMachinePropertyPage();
    
        // Dialog Data
        //{{AFX_DATA(CMachinePropertyPage)
        enum { IDD = IDD_PROPPAGE2 };
        CButton m_EnableDCOMInternet;
        CButton m_legacySecureReferencesChk;
        CButton m_EnableDCOMChk;
        CComboBox       m_impersonateLevelCBox;
        CComboBox       m_authLevelCBox;
    //}}AFX_DATA


        // Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CMachinePropertyPage)
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        virtual BOOL OnInitDialog();
        //}}AFX_VIRTUAL

        // Implementation
protected:
        // Generated message map functions
        //{{AFX_MSG(CMachinePropertyPage)
        afx_msg void OnCombo1();
        afx_msg void OnCheck1();
        afx_msg void OnCheck2();
        afx_msg void OnEditchangeCombo1();
        afx_msg void OnEditchangeCombo2();
        afx_msg void OnSelchangeCombo1();
        afx_msg void OnSelchangeCombo2();
        afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
        afx_msg void OnChkEnableInternet();
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()

private:
        AUTHENTICATIONLEVEL m_authLevel;
        int                 m_authLevelIndex;
        IMPERSONATIONLEVEL  m_impersonateLevel;
        int                 m_impersonateLevelIndex;
        BOOL                m_fEnableDCOM;
        int                 m_fEnableDCOMIndex;
        BOOL                m_fLegacySecureReferences;
        int                 m_fLegacySecureReferencesIndex;
        BOOL                m_fEnableDCOMHTTP;
        int                 m_fEnableDCOMHTTPIndex;
        BOOL                m_fEnableRpcProxy;
        BOOL                m_fOriginalEnableRpcProxy;
        int                 m_fEnableRpcProxyIndex;

};


/////////////////////////////////////////////////////////////////////////////
// CDefaultSecurityPropertyPage dialog

class CDefaultSecurityPropertyPage : public CPropertyPage
{
        DECLARE_DYNCREATE(CDefaultSecurityPropertyPage)

// Construction
public:
        CDefaultSecurityPropertyPage();
        ~CDefaultSecurityPropertyPage();

// Dialog Data
        //{{AFX_DATA(CDefaultSecurityPropertyPage)
        enum { IDD = IDD_PROPPAGE4 };
                // NOTE - ClassWizard will add data members here.
                //    DO NOT EDIT what you see in these blocks of generated code !
        //}}AFX_DATA


// Overrides
        // ClassWizard generate virtual function overrides
        //{{AFX_VIRTUAL(CDefaultSecurityPropertyPage)
        protected:
        virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
        virtual BOOL OnInitDialog();
        //}}AFX_VIRTUAL

// Implementation
protected:
        // Generated message map functions
        //{{AFX_MSG(CDefaultSecurityPropertyPage)
        afx_msg void OnButton1();
        afx_msg void OnButton2();
        afx_msg void OnButton3();
        afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
        //}}AFX_MSG
        DECLARE_MESSAGE_MAP()

private:
        int  m_accessPermissionIndex;
        int  m_launchPermissionIndex;
        int  m_configurationPermissionIndex;
        BOOL m_fAccessChecked;
};




#endif // __SRVPPG_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleui\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  olecnfg.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information


#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleui\stdafx.h ===
#if !defined(STDAFX_DCOMCNFG_INCLUDED)
#define STDAFX_DCOMCNFG_INCLUDED

//#define VC_EXTRALEAN      // Exclude rarely-used stuff from Windows headers

#if !defined(STANDALONE_BUILD)
extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}
#endif

//
// There is a conflict between ASSERT in the nt headers and ASSERT in the MFC headers.
// We'll just take the MFC one. 
//
#ifdef ASSERT
#undef ASSERT
#endif // ASSERT


#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>         // MFC support for Windows 95 Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#ifndef ASSERT
#error ole32\oleui\stdafx.h: ASSERT is not defined
#endif // !ASSERT

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.
#include <iaccess.h>
#include "assert.h"
#include "resource.h"
#include "types.h"

#include "afxtempl.h"
#include "util.h"
#include "datapkt.h"
#include "virtreg.h"

#endif // !defined(STDAFX_DCOMCNFG_INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleui\types.h ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1994.
//
//  File:       types.h
//
//  Contents:   Defines a few generic types
//
//  Classes:    
//
//  Methods:    
//
//  History:    23-Apr-96   BruceMa    Created.
//
//----------------------------------------------------------------------
#ifndef __DCOMCNFG_TYPES_H__
#define __DCOMCNFG_TYPES_H__

// Note. These values are derived from rpcdce.h
typedef enum tagAUTHENTICATIONLEVEL
 {Defaultx=0, None=1, Connect=2, Call=3, Packet=4, PacketIntegrity=5,
  PacketPrivacy=6} AUTHENTICATIONLEVEL;

typedef enum tagIMPERSONATIONLEVEL
 {Anonymous=1, Identify=2, Impersonate=3, Delegate=4} IMPERSONATIONLEVEL;


#define GUIDSTR_MAX 38



// These are help ID's for the "Help" button in the various dialogs
// in the ACL editor
#define IDH_REGISTRY_VALUE_PERMISSIONS       1
#define IDH_ADD_USERS_AND_GROUPS             2
#define IDH_LOCAL_GROUP_MEMBERSHIP           3
#define IDH_GLOBAL_GROUP_MEMBERSHIP          4
#define IDH_FIND_ACCOUNT1                    5
#define IDH_REGISTRY_APPLICATION_PERMISSIONS 6
#define IDH_REGISTRY_KEY_PERMISSIONS         7
#define IDH_SPECIAL_ACCESS_GLOBAL            8
#define IDH_SPECIAL_ACCESS_PER_APPID         9
#define IDH_SELECT_DOMAIN                    10
#define IDH_BROWSE_FOR_USERS                 11
#define IDH_FIND_ACCOUNT2                    14  // == IDH_BROWSE_FOR_USERS + 3
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleui\virtreg.cpp ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1997.
//
//  File:       virtreg.cpp
//
//  Contents:   Implements the class CVirtualRegistry which manages a
//              virtual registry
//
//  Classes:
//
//  Methods:    CVirtualRegistry::CVirtualRegistry
//              CVirtualRegistry::~CVirtualRegistry
//              CVirtualRegistry::ReadRegSzNamedValue
//              CVirtualRegistry::NewRegSzNamedValue
//              CVirtualRegistry::ChgRegSzNamedValue
//              CVirtualRegistry::ReadRegDwordNamedValue
//              CVirtualRegistry::NewRegDwordNamedValue
//              CVirtualRegistry::ChgRegDwordNamedValue
//              CVirtualRegistry::NewRegSingleACL
//              CVirtualRegistry::ChgRegACL
//              CVirtualRegistry::NewRegKeyACL
//              CVirtualRegistry::ReadLsaPassword
//              CVirtualRegistry::NewLsaPassword
//              CVirtualRegistry::ChgLsaPassword
//              CVirtualRegistry::ReadSrvIdentity
//              CVirtualRegistry::NewSrvIdentity
//              CVirtualRegistry::ChgSrvIdentity
//              CVirtualRegistry::MarkForDeletion
//              CVirtualRegistry::GetAt
//              CVirtualRegistry::Remove
//              CVirtualRegistry::Cancel
//              CVirtualRegistry::Apply
//              CVirtualRegistry::ApplyAll
//              CVirtualRegistry::Ok
//              CVirtualRegistry::SearchForRegEntry
//              CVirtualRegistry::SearchForLsaEntry
//              CVirtualRegistry::SearchForSrvEntry
//
//  History:    23-Apr-96   BruceMa     Created.
//              15-Dec-96   RonanS      Tidied up to remove memory leaks
//                                      Use array of pointers to avoid bitwise copy
//
//----------------------------------------------------------------------


#include "stdafx.h"
#include "afxtempl.h"
#include "assert.h"

#if !defined(STANDALONE_BUILD)
extern "C"
{
#include "ntlsa.h"
}
#endif

#include "winsvc.h"
#include "types.h"
#include "datapkt.h"

#if !defined(STANDALONE_BUILD)
    extern "C"
    {
    #include <getuser.h>
    }
#endif

#include "util.h"
#include "virtreg.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

CVirtualRegistry::CVirtualRegistry(void)
{
    m_pkts.SetSize(0, 8);
}



CVirtualRegistry::~CVirtualRegistry(void)
{
    // ronans - remove any remaining items
    RemoveAll();
}




// Read a named string value from the registry and cache it
int CVirtualRegistry::ReadRegSzNamedValue(HKEY   hRoot,
                                          TCHAR *szKeyPath,
                                          TCHAR *szValueName,
                                          int   *pIndex)
{
    int     err;
    HKEY    hKey;
    ULONG   lSize;
    DWORD   dwType;
    TCHAR   szVal[MAX_PATH];

    // Check if we already have an entry for this
    *pIndex = SearchForRegEntry(hRoot, szKeyPath, szValueName);
    if (*pIndex >= 0)
    {
        CDataPacket * pCdp = GetAt(*pIndex);
        ASSERT(pCdp);                           // should always be non null
        if (pCdp->IsDeleted())
        {
            *pIndex = -1;
            return ERROR_FILE_NOT_FOUND;
        }
        else
            return ERROR_SUCCESS;
    }

    // Open the referenced key
    if ((err = RegOpenKeyEx(hRoot, szKeyPath, 0, KEY_ALL_ACCESS, &hKey)) != ERROR_SUCCESS)
    {
        g_util.CkForAccessDenied(err);
        return err;
    }

    // Attempt to read the named value
    lSize = MAX_PATH * sizeof(TCHAR);
    if ((err = RegQueryValueEx(hKey, szValueName, NULL, &dwType, (BYTE *) szVal,
                        &lSize))
        != ERROR_SUCCESS)
    {
        g_util.CkForAccessDenied(err);
        if (hKey != hRoot)
            RegCloseKey(hKey);
        return err;
    }

    // Build a data packet
    if (dwType == REG_SZ)
    {
        CDataPacket * pNewPacket = new CRegSzNamedValueDp(hRoot, szKeyPath, szValueName, szVal);
        ASSERT(pNewPacket);

        if (!pNewPacket)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        *pIndex = (int)m_pkts.Add(pNewPacket);
        pNewPacket->SetModified( FALSE);
        return ERROR_SUCCESS;
    }
    else
        return ERROR_BAD_TOKEN_TYPE;
}

// Read a named string value from the registry and cache it
int CVirtualRegistry::ReadRegMultiSzNamedValue(HKEY   hRoot,
                                          TCHAR *szKeyPath,
                                          TCHAR *szValueName,
                                          int   *pIndex)
{
    int     err = ERROR_SUCCESS;
    HKEY    hKey;

    // Check if we already have an entry for this
    *pIndex = SearchForRegEntry(hRoot, szKeyPath, szValueName);
    if (*pIndex >= 0)
    {
        CDataPacket * pCdp = GetAt(*pIndex);
        ASSERT(pCdp);                           // should always be non null
        if (pCdp->IsDeleted())
        {
            *pIndex = -1;
            return ERROR_FILE_NOT_FOUND;
        }
        else
            return err;
    }

    // Open the referenced key
    if ((err = RegOpenKeyEx(hRoot, szKeyPath, 0, KEY_ALL_ACCESS, &hKey)) == ERROR_SUCCESS)
    {
        // Build a data packet
        CRegMultiSzNamedValueDp * pNewPacket = new CRegMultiSzNamedValueDp(hRoot, szKeyPath, szValueName);
        ASSERT(pNewPacket);

        if (pNewPacket)
        {
            // read the key
            if ((err = pNewPacket -> Read(hKey)) == ERROR_SUCCESS)
            {
                *pIndex = (int)m_pkts.Add(pNewPacket);
                pNewPacket->SetModified( FALSE);
            }
            else
            {
                g_util.CkForAccessDenied(err);
                delete pNewPacket;
                if (hKey != hRoot)
                    RegCloseKey(hKey);
            }
        }
        else
            err = ERROR_NOT_ENOUGH_MEMORY;

        if (err != ERROR_SUCCESS)
            g_util.CkForAccessDenied(err);
    }

    return err;
}


int  CVirtualRegistry::NewRegSzNamedValue(HKEY   hRoot,
                                          TCHAR  *szKeyPath,
                                          TCHAR  *szValueName,
                                          TCHAR  *szVal,
                                          int    *pIndex)
{
    // It may be in the virtual registry but marked for deletion
    *pIndex = SearchForRegEntry(hRoot, szKeyPath, szValueName);
    if (*pIndex >= 0)
    {
        CRegSzNamedValueDp * pCdp = (CRegSzNamedValueDp *)GetAt(*pIndex);
        pCdp->MarkForDeletion(FALSE);
        pCdp->ChgSzValue(szVal);
        return ERROR_SUCCESS;
    }

    // Build a data packet and add it
    CRegSzNamedValueDp * pNewPacket = new CRegSzNamedValueDp (hRoot, szKeyPath, szValueName, szVal);
    ASSERT(pNewPacket);
    if (!pNewPacket)
        return ERROR_NOT_ENOUGH_MEMORY;
    *pIndex = (int)m_pkts.Add(pNewPacket);

    return ERROR_SUCCESS;
}

int  CVirtualRegistry::NewRegMultiSzNamedValue(HKEY   hRoot,
                                          TCHAR  *szKeyPath,
                                          TCHAR  *szValueName,
                                          int    *pIndex)
{
    // It may be in the virtual registry but marked for deletion
    *pIndex = SearchForRegEntry(hRoot, szKeyPath, szValueName);
    if (*pIndex >= 0)
    {
        CRegMultiSzNamedValueDp * pCdp = (CRegMultiSzNamedValueDp *)GetAt(*pIndex);
        pCdp->MarkForDeletion(FALSE);
        pCdp->Clear();
        pCdp -> SetModified(TRUE);
        return ERROR_SUCCESS;
    }

    // Build a data packet and add it
    CRegMultiSzNamedValueDp * pNewPacket = new CRegMultiSzNamedValueDp (hRoot, szKeyPath, szValueName);
    ASSERT(pNewPacket);
    if (!pNewPacket)
        return ERROR_NOT_ENOUGH_MEMORY;
    pNewPacket -> SetModified(TRUE);
    *pIndex = (int)m_pkts.Add(pNewPacket);

    return ERROR_SUCCESS;
}



void CVirtualRegistry::ChgRegSzNamedValue(int nIndex, TCHAR  *szVal)
{
    CRegSzNamedValueDp* pCdp = (CRegSzNamedValueDp*)m_pkts.ElementAt(nIndex);
    pCdp->ChgSzValue(szVal);
}



// Read a named DWORD value from the registry
int CVirtualRegistry::ReadRegDwordNamedValue(HKEY   hRoot,
                                             TCHAR *szKeyPath,
                                             TCHAR *szValueName,
                                             int   *pIndex)
{
        int   err;
    HKEY  hKey;
    ULONG lSize;
    DWORD dwType;
    DWORD dwVal;

    // Check if we already have an entry for this
    *pIndex = SearchForRegEntry(hRoot, szKeyPath, szValueName);
    if (*pIndex >= 0)
    {
        return ERROR_SUCCESS;
    }

    // Open the referenced key
    if ((err = RegOpenKeyEx(hRoot, szKeyPath, 0, KEY_ALL_ACCESS, &hKey)) != ERROR_SUCCESS)
    {
        g_util.CkForAccessDenied(err);
        return err;
    }

    // Attempt to read the named value
    lSize = sizeof(DWORD);
   if ((err = RegQueryValueEx(hKey, szValueName, NULL, &dwType, (BYTE *) &dwVal,
                       &lSize))
        != ERROR_SUCCESS)
    {
        g_util.CkForAccessDenied(err);
        if (hKey != hRoot)
        {
            RegCloseKey(hKey);
        }
        return err;
    }

    // Close the registry key
    if (hKey != hRoot)
    {
        RegCloseKey(hKey);
    }

    // Build a data packet
    if (dwType == REG_DWORD)
    {
        CDataPacket * pNewPacket = new CDataPacket(hRoot, szKeyPath, szValueName, dwVal);
        ASSERT(pNewPacket);
        if (!pNewPacket)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        *pIndex = (int)m_pkts.Add(pNewPacket);
        pNewPacket-> SetModified(FALSE);

        return ERROR_SUCCESS;
    }
    else
    {
        return ERROR_BAD_TOKEN_TYPE;
    }
}



int  CVirtualRegistry::NewRegDwordNamedValue(HKEY   hRoot,
                                             TCHAR  *szKeyPath,
                                             TCHAR  *szValueName,
                                             DWORD  dwVal,
                                             int   *pIndex)
{
    // It may be in the virtual registry but marked for deletion
    *pIndex = SearchForRegEntry(hRoot, szKeyPath, szValueName);
    if (*pIndex >= 0)
    {
        CDataPacket * pCdp = GetAt(*pIndex);
        pCdp->MarkForDeletion(FALSE);
        pCdp->pkt.nvdw.dwValue = dwVal;
        pCdp->SetModified(TRUE);
        return ERROR_SUCCESS;
    }

    // Build a data packet and add it
    CDataPacket * pNewPacket = new CDataPacket(hRoot, szKeyPath, szValueName, dwVal);
    ASSERT(pNewPacket);

    if (!pNewPacket)
        return ERROR_NOT_ENOUGH_MEMORY;
    *pIndex = (int)m_pkts.Add(pNewPacket);
    pNewPacket->SetModified(TRUE);
    return ERROR_SUCCESS;
}


void CVirtualRegistry::ChgRegDwordNamedValue(int nIndex, DWORD dwVal)
{
    CDataPacket * pCdp = m_pkts.ElementAt(nIndex);

    pCdp->pkt.nvdw.dwValue = dwVal;
    pCdp->SetModified( TRUE);
}


int  CVirtualRegistry::NewRegSingleACL(HKEY   hRoot,
                                       TCHAR  *szKeyPath,
                                       TCHAR  *szValueName,
                                       SECURITY_DESCRIPTOR *pacl,
                                       BOOL   fSelfRelative,
                                       int                 *pIndex)
{
    // Build a data packet and add it
    CDataPacket * pNewPacket = new CDataPacket(hRoot, szKeyPath, szValueName, pacl, fSelfRelative);
    ASSERT(pNewPacket);

    if (!pNewPacket)
        return ERROR_NOT_ENOUGH_MEMORY;

    *pIndex = (int)m_pkts.Add(pNewPacket);
    return ERROR_SUCCESS;
}


void CVirtualRegistry::ChgRegACL(int                  nIndex,
                                 SECURITY_DESCRIPTOR *pacl,
                                 BOOL                 fSelfRelative)
{
    CDataPacket * pCdp = m_pkts.ElementAt(nIndex);

    pCdp->ChgACL(pacl, fSelfRelative);
    pCdp->SetModified(TRUE);
}



int  CVirtualRegistry::NewRegKeyACL(HKEY                hKey,
                                    HKEY               *phClsids,
                                    unsigned            cClsids,
                                    TCHAR               *szTitle,
                                    SECURITY_DESCRIPTOR *paclOrig,
                                    SECURITY_DESCRIPTOR *pacl,
                                    BOOL                fSelfRelative,
                                    int                 *pIndex)
{
    // Build a data packet and add it
    CDataPacket * pNewPacket = new CDataPacket(hKey, phClsids, cClsids, szTitle, paclOrig, pacl, fSelfRelative);
    ASSERT(pNewPacket);
    if (!pNewPacket)
        return ERROR_NOT_ENOUGH_MEMORY;
    *pIndex = (int)m_pkts.Add(pNewPacket);
    return ERROR_SUCCESS;
}



int CVirtualRegistry::ReadLsaPassword(CLSID &clsid,
                                      int   *pIndex)
{
#if !defined(STANDALONE_BUILD)

    LSA_OBJECT_ATTRIBUTES sObjAttributes;
    HANDLE                hPolicy = NULL;
    LSA_UNICODE_STRING    sKey;
    TCHAR                 szKey[GUIDSTR_MAX + 5];
    PLSA_UNICODE_STRING   psPassword;


    // Check if we already have an entry fo this
    *pIndex = SearchForLsaEntry(clsid);
    if (*pIndex >= 0)
    {
        return ERROR_SUCCESS;
    }

    // Formulate the access key
    lstrcpyW(szKey, L"SCM:");
    g_util.StringFromGUID(clsid, &szKey[4], GUIDSTR_MAX);
    szKey[GUIDSTR_MAX + 4] = L'\0';

    // UNICODE_STRING length fields are in bytes and include the NULL
    // terminator
    sKey.Length              = (USHORT)((lstrlenW(szKey) + 1) * sizeof(WCHAR));
    sKey.MaximumLength       = (GUIDSTR_MAX + 5) * sizeof(WCHAR);
    sKey.Buffer              = szKey;

    // Open the local security policy
    InitializeObjectAttributes(&sObjAttributes, NULL, 0L, NULL, NULL);
    if (!NT_SUCCESS(LsaOpenPolicy(NULL, &sObjAttributes,
                                  POLICY_GET_PRIVATE_INFORMATION, &hPolicy)))
    {
        return GetLastError();
    }

    // Read the user's password
    if (!NT_SUCCESS(LsaRetrievePrivateData(hPolicy, &sKey, &psPassword)))
    {
        LsaClose(hPolicy);
        return GetLastError();
    }

    // Close the policy handle, we're done with it now.
    LsaClose(hPolicy);

    // Build a data packet
    CDataPacket * pNewPacket = new CDataPacket(psPassword->Buffer, clsid);
    ASSERT(pNewPacket);
    if (!pNewPacket)
        return ERROR_NOT_ENOUGH_MEMORY;
    pNewPacket->SetModified( FALSE );
    *pIndex = (int)m_pkts.Add(pNewPacket);

#endif
    return ERROR_SUCCESS;
}



int  CVirtualRegistry::NewLsaPassword(CLSID &clsid,
                                      TCHAR  *szPassword,
                                      int   *pIndex)
{
    // Build a data packet and add it
    CDataPacket * pNewPacket = new CDataPacket(szPassword, clsid);
    ASSERT(pNewPacket);
    if (!pNewPacket)
        return ERROR_NOT_ENOUGH_MEMORY;
    *pIndex = (int)m_pkts.Add(pNewPacket);
    return ERROR_SUCCESS;
}



void CVirtualRegistry::ChgLsaPassword(int   nIndex,
                                      TCHAR *szPassword)
{
    CDataPacket * pCdp = m_pkts.ElementAt(nIndex);

    pCdp -> ChgPassword(szPassword);
    pCdp -> SetModified(TRUE);
}



int CVirtualRegistry::ReadSrvIdentity(TCHAR *szService,
                                      int   *pIndex)
{
    SC_HANDLE            hSCManager;
    SC_HANDLE            hService;
    QUERY_SERVICE_CONFIG sServiceQueryConfig;
    DWORD                dwSize;


    // Check if we already have an entry fo this
    *pIndex = SearchForSrvEntry(szService);
    if (*pIndex >= 0)
    {
        return ERROR_SUCCESS;
    }

    // Open the service control manager
    if (hSCManager = OpenSCManager(NULL, NULL, GENERIC_READ))
    {
        // Open a handle to the requested service
        if (hService = OpenService(hSCManager, szService, GENERIC_READ))
        {
            // Close the service manager's database
            CloseServiceHandle(hSCManager);

            // Query the service
            if (QueryServiceConfig(hService, &sServiceQueryConfig,
                                   sizeof(QUERY_SERVICE_CONFIG), &dwSize))
            {
                // Build a data packet
                CDataPacket * pNewPacket = new CDataPacket(szService, sServiceQueryConfig.lpServiceStartName);
                ASSERT(pNewPacket);
                if (!pNewPacket)
                    return ERROR_NOT_ENOUGH_MEMORY;
                pNewPacket->SetModified(FALSE);
                *pIndex = (int)m_pkts.Add(pNewPacket);

                // Return success
                CloseServiceHandle(hSCManager);
                CloseServiceHandle(hService);
                return ERROR_SUCCESS;
            }
        }
        CloseServiceHandle(hSCManager);
    }

    return GetLastError();
}



int  CVirtualRegistry::NewSrvIdentity(TCHAR  *szService,
                                      TCHAR  *szIdentity,
                                      int   *pIndex)
{
    // Build a data packet and add it
    CDataPacket * pNewPacket = new CDataPacket(szService, szIdentity);
    ASSERT(pNewPacket);
    if (!pNewPacket)
        return ERROR_NOT_ENOUGH_MEMORY;
    *pIndex = (int)m_pkts.Add(pNewPacket);
    return ERROR_SUCCESS;
}



void CVirtualRegistry::ChgSrvIdentity(int    nIndex,
                                      TCHAR  *szIdentity)
{
    CDataPacket  *pCdp = m_pkts.ElementAt(nIndex);

    pCdp -> ChgSrvIdentity(szIdentity);
    pCdp -> SetModified( TRUE);
}



void CVirtualRegistry::MarkForDeletion(int nIndex)
{
    CDataPacket * pCdp = GetAt(nIndex);
    pCdp->MarkForDeletion(TRUE);
    pCdp->SetModified(TRUE);
}

void CVirtualRegistry::MarkHiveForDeletion(int nIndex)
{
    CDataPacket * pCdp = GetAt(nIndex);
    pCdp->MarkHiveForDeletion(TRUE);
    pCdp->SetModified(TRUE);
}



CDataPacket * CVirtualRegistry::GetAt(int nIndex)
{
    return m_pkts.ElementAt(nIndex);
}




void CVirtualRegistry::Remove(int nIndex)
{
    CDataPacket * pCdp = GetAt(nIndex);

    // ronans - must always destroy even if packet has not been marked dirty
    if (pCdp)
        delete pCdp;

    // overwrite with empty data packet
    m_pkts.SetAt(nIndex, new CDataPacket);
}




void CVirtualRegistry::RemoveAll(void)
{
    int nSize = (int)m_pkts.GetSize();
    for (int k = 0; k < nSize; k++)
    {
        Remove(k);

        CDataPacket * pCdp = GetAt(k);

        // remove empty packet
        if  (pCdp)
            delete pCdp;

    }

    m_pkts.RemoveAll();
}




void CVirtualRegistry::Cancel(int nIndex)
{
    int nSize = (int)m_pkts.GetSize();

    for (int k = nIndex; k < nSize; k++)
    {
        m_pkts.SetAt(nIndex, new CDataPacket);
    }
}



int  CVirtualRegistry::Apply(int nIndex)
{
    int err = ERROR_SUCCESS;
    int nSize = (int)m_pkts.GetSize();
    CDataPacket *pCdp = m_pkts.ElementAt(nIndex);

    if (pCdp->IsModified())
        err = pCdp -> Apply();

    return err;;
}







int  CVirtualRegistry::ApplyAll(void)
{
    int nSize = (int)m_pkts.GetSize();

    // Persist all non-empty data packets
    for (int k = 0; k < nSize; k++)
    {
        Apply(k);
    }

    return ERROR_SUCCESS;
}




int  CVirtualRegistry::Ok(int nIndex)
{
    return 0;
}




int CVirtualRegistry::SearchForRegEntry(HKEY hRoot,
                                        TCHAR *szKeyPath,
                                        TCHAR *szValueName)
{
    int nSize = (int)m_pkts.GetSize();

    for (int k = 0; k < nSize; k++)
    {
        CDataPacket * pCdp = GetAt(k);
        if (pCdp -> IsIdentifiedBy(hRoot, szKeyPath, szValueName))
            return k;
    }

    return -1;
}




int CVirtualRegistry::SearchForLsaEntry(CLSID appid)
{
    int nSize = (int)m_pkts.GetSize();

    for (int k = 0; k < nSize; k++)
    {
        CDataPacket * pCdp = GetAt(k);
        if (pCdp->m_tagType == Password  &&
            g_util.IsEqualGuid(pCdp->pkt.pw.appid, appid))
        {
            return k;
        }
    }

    return -1;
}




int CVirtualRegistry::SearchForSrvEntry(TCHAR *szServiceName)
{
    int nSize = (int)m_pkts.GetSize();

    for (int k = 0; k < nSize; k++)
    {
        CDataPacket * pCdp = GetAt(k);
        if (pCdp->m_tagType == ServiceIdentity                &&
            (_tcscmp(pCdp->pkt.si.szServiceName, szServiceName)))
        {
            return k;
        }
    }

    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleui\util.h ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1997.
//
//  File:       util.cpp
//
//  Contents:   Defnes the utility class CUtility
//
//  Classes:
//
//  Methods:
//
//  History:    23-Apr-96   BruceMa    Created.
//
//----------------------------------------------------------------------


#ifndef _UTIL_H_
#define _UTIL_H_

// note dependencies on the following two files
#include "datapkt.h"

#if !defined(STANDALONE_BUILD)
extern "C"
{
#include <getuser.h>
}
#endif

#define COM_RIGHTS_EXECUTE 1


typedef struct
{
    HKEY                 hRoot;
    TCHAR               *szKeyPath;
    TCHAR               *szValueName;
} SSingleCallBack;



typedef struct
{
    HKEY                 hKey;
    HKEY                *phClsids;
    unsigned             cClsids;
    TCHAR               *szTitle;
} SRegKeyCallBack;



typedef struct tagCallBackContext
{
    PACKETTYPE           pktType;
    int                 *pIndex;
    SECURITY_DESCRIPTOR *origSD;
    BOOL                fIsIAC;
    union
    {
        SSingleCallBack single;
        SRegKeyCallBack regKey;
    }                   info;
} SCallBackContext, *PCallBackContext;



typedef struct
{
    WORD  Control;
    BYTE  Reserved1;
    BYTE  Revision;
    DWORD Owner;
    DWORD Group;
    DWORD Sacl;
    DWORD Dacl;
} SSrSecurityDescriptor, *PSrSecurityDescriptor;



typedef struct
{
    BYTE Revision;
    BYTE Reserved1;
    WORD AclSize;
    WORD AceCount;
    WORD Reserved2;
} SSrAcl, *PSrAcl;



typedef struct
{
    BYTE Type;
    BYTE Flags;
    WORD AceSize;
    ULONG AccessMask;
} SSrAce, *PSrAce;


#if !defined(STANDALONE_BUILD)
#define USER_DETAILS_BUFFER_SIZE 1024

typedef struct tagUserDetailsPlus
{
    USERDETAILS sUserDetails;
    BYTE        bBuffer[USER_DETAILS_BUFFER_SIZE];
} SUserDetailsPlus;
#endif

enum dcomAclType { dcomAclAccess, dcomAclLaunch, dcomAclConfig };

class CUtility
{
public:
          CUtility(void);

         ~CUtility(void);

    void  PostErrorMessage(void);

    void  PostErrorMessage(int err);

    void  CkForAccessDenied(int err);

    BOOL  CkAccessRights(HKEY hRoot, LPCTSTR szKeyPath);

    int   WriteRegSzNamedValue(HKEY   hRoot,
                               LPCTSTR szKeyPath,
                               LPCTSTR szValueName,
                               LPCTSTR szVal,
                               DWORD  dwSize);

    int WriteRegMultiSzNamedValue(HKEY   hRoot,
                                   LPCTSTR szKeyPath,
                                   LPCTSTR szValueName,
                                   LPCTSTR szVal,
                                   DWORD  dwSize);


    int   WriteRegDwordNamedValue(HKEY   hRoot,
                                  LPCTSTR szKeyPath,
                                  LPCTSTR szValueName,
                                  DWORD  dwVal);

    int   WriteRegSingleACL(HKEY   hRoot,
                            LPCTSTR szKeyPath,
                            LPCTSTR szValueName,
                            PSECURITY_DESCRIPTOR pSec);

    int   WriteRegKeyACL(HKEY   hKey,
                         HKEY  *phClsids,
                         unsigned cClsids,
                         PSECURITY_DESCRIPTOR pSec,
                         PSECURITY_DESCRIPTOR pSecOrig);

    int   WriteRegKeyACL2(HKEY   hRoot,
                          HKEY   hKey,
                          PSECURITY_DESCRIPTOR pSec,
                          PSECURITY_DESCRIPTOR pSecOrig);

    int   WriteLsaPassword(CLSID  appid,
                           LPCTSTR szPassword);

    int   WriteSrvIdentity(LPCTSTR szService,
                           LPCTSTR szIdentity);

    int   DeleteRegKey(HKEY hRoot, LPCTSTR szKeyPath);

    int   DeleteRegValue(HKEY hRoot, LPCTSTR szKeyPath, LPCTSTR szValueName);

    int   ACLEditor(HWND       hWnd,
                    HKEY       hRoot,
                    LPCTSTR    szKeyPath,
                    LPCTSTR    szValueName,
                    int       *nIndex,
                    PACKETTYPE pktType,
                    dcomAclType eAclType);

    int   ACLEditor2(HWND       hWnd,
                     HKEY       hKey,
                     HKEY      *phClsids,
                     unsigned   cClsids,
                     TCHAR     *szTitle,
                     int       *nIndex,
                     PACKETTYPE pktType);

    BOOL  InvokeUserBrowser(HWND hWnd, TCHAR *szUser);

    BOOL  InvokeMachineBrowser(TCHAR *szMachine);

    int  StringFromGUID(GUID  &rguid, TCHAR *lpsz, int cbMax);

    BOOL IsEqualGuid(GUID &guid1, GUID &guid2);

    BOOL AdjustPrivilege(TCHAR *szPrivilege);

    BOOL VerifyRemoteMachine(TCHAR *szRemoteMachine);

    BOOL RetrieveUserPassword(TCHAR *szAppid, CString &sPassword);

    BOOL StoreUserPassword(TCHAR *szAppid, CString &sPassword);

    BOOL LookupProcessInfo(SID **ppSid, TCHAR **ppszPrincName);

    BOOL MakeSecDesc(SID *pSid, SECURITY_DESCRIPTOR **ppSD);

    BOOL ChangeService(LPCTSTR szService,
                       LPCTSTR szIdentity,
                       LPCTSTR szPassword,
                       LPCTSTR szDisplay);

    int  UpdateDCOMInfo(void);

    void FixHelp(CWnd* pWnd);

    BOOL CompareSDs(PSrSecurityDescriptor pSD1, PSrSecurityDescriptor pSD2);

    int SetAccountRights( LPCTSTR szUser, TCHAR *szPrivilege);

    BOOL CopySD(SECURITY_DESCRIPTOR *pSrc, SECURITY_DESCRIPTOR **pDest);

    void CopyAbsoluteSD(SECURITY_DESCRIPTOR *pSrc, SECURITY_DESCRIPTOR **pDest);

    void SetInheritanceFlags(SECURITY_DESCRIPTOR *pSec);

    BOOL CheckForValidSD(SECURITY_DESCRIPTOR *pSD);
    BOOL SDisIAC(SECURITY_DESCRIPTOR *pSD);
    SECURITY_DESCRIPTOR * IACfromSD(SECURITY_DESCRIPTOR * pSD);
    SECURITY_DESCRIPTOR * SDfromIAC(SECURITY_DESCRIPTOR * pIAC);

    // added for BDC fix 

    HRESULT GetPrincipalSID (LPCTSTR Principal, PSID *Sid);

    // checks if we're on a BDC
    BOOL    IsBackupDC();
    TCHAR*  PrimaryDCName();


 private:
    BOOL CheckSDForCOM_RIGHTS_EXECUTE(SECURITY_DESCRIPTOR *pSD);

    SCallBackContext  m_sCallBackContext;
    void             *m_args[8];
    HANDLE            m_hRpc;
    BOOL              m_bCheckedDC;
    BOOL              m_bIsBdc;
    TCHAR*            m_pszDomainController;
};



extern CUtility       g_util;
extern HKEY           g_hAppid;
extern HKEY          *g_rghkCLSID;
extern unsigned       g_cCLSIDs;
extern TCHAR         *g_szAppTitle;
extern BOOL           g_fReboot;
extern TCHAR         *g_szAppid;

#endif //_UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleui\util.cpp ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1997.
//
//  File:       util.cpp
//
//  Contents:   Implements the utility class CUtility
//
//  Classes:
//
//  Methods:    CUtility::CkForAccessDenied
//              CUtility::CkAccessRights
//              CUtility::PostErrorMessage (x2)
//              CUtility::WriteRegSzNamedValue
//              CUtility::WriteRegDwordNamedValue
//              CUtility::WriteRegSingleACL
//              CUtility::WriteRegKeyACL
//              CUtility::WriteRegKeyACL2
//              CUtility::WriteLsaPassword
//              CUtility::DeleteRegKey
//              CUtility::DeleteRegValue
//              CUtility::WriteSrvIdentity
//              CUtility::ACLEditor
//              CUtility::ACLEditor2
//              CUtility::InvokeUserBrowser
//              CUtility::InvokeMachineBrowser
//              CUtility::StringFromGUID
//              CUtility::IsEqualGuid
//              CUtility::AdjustPrivilege
//              CUtility::VerifyRemoteMachine
//              CUtility::RetrieveUserPassword
//              CUtility::StoreUserPassword
//              CUtility::LookupProcessInfo
//              CUtility::MakeSecDesc
//              CUtility::CheckForValidSD
//              CUtility::SDisIAC
//              CUtility::CheckSDForCOM_RIGHTS_EXECUTE
//              CUtility::ChangeService
//              CUtility::UpdateDCOMInfo(void)
//              CUtility::FixHelp
//              CUtility::CopySD
//              CUtility::SetInheritanceFlags
//
// Functons:    callBackFunc
//              ControlFixProc
//
//  History:    23-Apr-96   BruceMa    Created.
//
//----------------------------------------------------------------------


#include "stdafx.h"
#include "assert.h"
#include "resource.h"
#include "afxtempl.h"
#include "types.h"
#include "datapkt.h"
#include "clspsht.h"

#if !defined(STANDALONE_BUILD)
extern "C"
{
#include <getuser.h>
}
#endif

#include "util.h"
#include "virtreg.h"

extern "C"
{
#if !defined(STANDALONE_BUILD)
#include <ntlsa.h>
#include <ntseapi.h>
#include <sedapi.h>
#endif

#include <winnetwk.h>

#if !defined(STANDALONE_BUILD)
#include <uiexport.h>
#include <lm.h>
#endif

#include <rpc.h>
#include <rpcdce.h>
#include <aclapi.h>
}

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

const IID IID_IAccessControl = {0xEEDD23E0,0x8410,0x11CE,{0xA1,0xC3,0x08,0x00,0x2B,0x2B,0x8D,0x8F}};

#if !defined(STANDALONE_BUILD)
extern "C"
{
int _stdcall UpdateActivationSettings(HANDLE hRpc, RPC_STATUS *status);
}
#endif


static const BYTE GuidMap[] = { 3, 2, 1, 0, '-', 5, 4, '-', 7, 6, '-',
                                8, 9, '-', 10, 11, 12, 13, 14, 15 };

static const WCHAR wszDigits[] = L"0123456789ABCDEF";

static const DWORD SIZEOF_SID        = 44;

// This leaves space for 2 access allowed ACEs in the ACL.
const DWORD SIZEOF_ACL        = sizeof(ACL) + 2 * sizeof(ACCESS_ALLOWED_ACE) +
                                2 * SIZEOF_SID;

static const DWORD SIZEOF_TOKEN_USER = sizeof(TOKEN_USER) + SIZEOF_SID;

static const SID   LOCAL_SYSTEM_SID  = {SID_REVISION, 1, {0,0,0,0,0,5},
                                 SECURITY_LOCAL_SYSTEM_RID };

static const DWORD NUM_SEC_PKG       = 8;




// These are required for the method CUtility::UpdateDCOMInfo which invokes
// an RPC proxy which expects the following


extern "C" void * _stdcall MIDL_user_allocate(size_t size)
{
    return new BYTE[size];
}


extern "C" void _stdcall MIDL_user_free(void *p)
{
    delete p;
}

CUtility::CUtility(void)
{
    HRESULT hr = OleInitialize(NULL);
    m_hRpc = NULL;
    m_bCheckedDC = NULL;    // have we checked if we're on a BDC yet ?
    m_bIsBdc = FALSE;
    m_pszDomainController = NULL;
}



CUtility::~CUtility(void)
{
#if !defined(STANDALONE_BUILD)
    if (m_pszDomainController) 
        NetApiBufferFree(m_pszDomainController);
#endif

    OleUninitialize();
    if (m_hRpc != NULL)
    {
        RpcBindingFree(&m_hRpc);
    }
}



void CUtility::CkForAccessDenied(int err)
{
    if (err == ERROR_ACCESS_DENIED)
    {
        CString sMsg;
        CString sCaption;
        sMsg.LoadString(IDS_ACCESSDENIED);
        sCaption.LoadString(IDS_SYSTEMMESSAGE);
        MessageBox(NULL, sMsg, sCaption, MB_OK);
    }
}



BOOL CUtility::CkAccessRights(HKEY hRoot, LPCTSTR szKeyPath)
{
    int                  err;
    HKEY                 hKey;
    BYTE                 aSid[256];
    DWORD                cbSid = 256;
    PSECURITY_DESCRIPTOR pSid = (PSECURITY_DESCRIPTOR) aSid;
    BOOL                 fFreePsid = FALSE;


    // Open the specified key
    err = RegOpenKeyEx(hRoot, szKeyPath, 0, KEY_ALL_ACCESS, &hKey);

    // The key may not exist
    if (err == ERROR_FILE_NOT_FOUND)
    {
        return TRUE;
    }

    if (err == ERROR_SUCCESS)
    {
        // Fetch the security descriptor on this key
        err = RegGetKeySecurity(hKey,
                                OWNER_SECURITY_INFORMATION |
                                GROUP_SECURITY_INFORMATION |
                                DACL_SECURITY_INFORMATION,
                                (PSECURITY_DESCRIPTOR) aSid,
                                &cbSid);
        if (err == ERROR_INSUFFICIENT_BUFFER)
        {
            pSid = (PSECURITY_DESCRIPTOR) malloc(cbSid);
            if (pSid == NULL)
            {
                return FALSE;
            }
            fFreePsid = TRUE;
            err = RegGetKeySecurity(hKey,
                                    OWNER_SECURITY_INFORMATION |
                                    GROUP_SECURITY_INFORMATION |
                                    DACL_SECURITY_INFORMATION,
                                    (PSECURITY_DESCRIPTOR) pSid,
                                    &cbSid);
        }

        // We've read the security descriptor - now try to write it
        if (err == ERROR_SUCCESS)
        {
            err = RegSetKeySecurity(hKey,
                                    OWNER_SECURITY_INFORMATION |
                                    GROUP_SECURITY_INFORMATION |
                                    DACL_SECURITY_INFORMATION,
                                    pSid);
        }

        if (hKey != hRoot)
        {
            RegCloseKey(hKey);
        }
    }

    return err == ERROR_SUCCESS ? TRUE : FALSE;
}






void CUtility::PostErrorMessage(void)
{
    TCHAR szMessage[256];

    FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, GetLastError(),
                  0, szMessage, sizeof(szMessage) / sizeof(TCHAR), NULL);
    CString sCaption;
    sCaption.LoadString(IDS_SYSTEMMESSAGE);
    MessageBox(NULL, szMessage, sCaption, MB_OK);
}






void CUtility::PostErrorMessage(int err)
{
    TCHAR szMessage[256];

    FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, err,
                  0, szMessage, sizeof(szMessage) / sizeof(TCHAR), NULL);
    CString sCaption;
    sCaption.LoadString(IDS_SYSTEMMESSAGE);
    MessageBox(NULL, szMessage, sCaption, MB_OK);
}




// Write a named string value to the registry
int CUtility::WriteRegSzNamedValue(HKEY   hRoot,
                                   LPCTSTR szKeyPath,
                                   LPCTSTR szValueName,
                                   LPCTSTR szVal,
                                   DWORD  dwSize)
{
    int  err;
    HKEY hKey;
    ULONG lSize;

    // Open the key
    err = RegOpenKeyEx(hRoot, szKeyPath, 0, KEY_ALL_ACCESS, &hKey);

        // The key may not exist
    if (err == ERROR_FILE_NOT_FOUND)
    {
        DWORD dwDisp;
        err = RegCreateKeyEx(hRoot, 
                             szKeyPath,
                             0, 
                             NULL,
                             REG_OPTION_NON_VOLATILE,
                             KEY_ALL_ACCESS,
                             NULL,
                             &hKey,
                             &dwDisp);
    }

    if (err != ERROR_SUCCESS)
        return err;

    // Attempt to write the named value
    lSize = _tcslen(szVal) + 1;
    err = RegSetValueEx(hKey, szValueName, NULL, REG_SZ, (BYTE *) szVal, lSize*sizeof(TCHAR));
    if (hKey != hRoot)
        RegCloseKey(hKey);
    return err;
}

// Write a named multi string value to the registry
int CUtility::WriteRegMultiSzNamedValue(HKEY   hRoot,
                                   LPCTSTR szKeyPath,
                                   LPCTSTR szValueName,
                                   LPCTSTR szVal,
                                   DWORD  dwSize)
{
    int  err = ERROR_SUCCESS;
    HKEY hKey;

    // Open the key
    err = RegOpenKeyEx(hRoot, szKeyPath, 0, KEY_ALL_ACCESS, &hKey);

        // The key may not exist
    if (err == ERROR_FILE_NOT_FOUND)
    {
        DWORD dwDisp;
        err = RegCreateKeyEx(hRoot, 
                             szKeyPath,
                             0, 
                             NULL,
                             REG_OPTION_NON_VOLATILE,
                             KEY_ALL_ACCESS,
                             NULL,
                             &hKey,
                             &dwDisp);
    }

    if (err != ERROR_SUCCESS)
        return err;

    // Attempt to write the named value
    err = RegSetValueEx(hKey, szValueName, NULL, REG_MULTI_SZ, (BYTE *) szVal, dwSize*sizeof(TCHAR) );

    if (hKey != hRoot)
        RegCloseKey(hKey);
    return err;
}






// Write a named DWORD value to the registry
int CUtility::WriteRegDwordNamedValue(HKEY   hRoot,
                                      LPCTSTR szKeyPath,
                                      LPCTSTR szValueName,
                                      DWORD  dwVal)
{
    int  err;
    HKEY hKey;

    // Open the key
    err = RegOpenKeyEx(hRoot, szKeyPath, 0, KEY_ALL_ACCESS, &hKey);

    // The key may not exist
    if (err == ERROR_FILE_NOT_FOUND)
    {
        DWORD dwDisp;
        err = RegCreateKeyEx(hRoot, 
                             szKeyPath,
                             0, 
                             NULL,
                             REG_OPTION_NON_VOLATILE,
                             KEY_ALL_ACCESS,
                             NULL,
                             &hKey,
                             &dwDisp);
    }

    if (err != ERROR_SUCCESS)
        return err;


    // Attempt to write the named value
    if (RegSetValueEx(hKey, szValueName, NULL, REG_DWORD, (BYTE *) &dwVal,
                      sizeof(DWORD))
        != ERROR_SUCCESS)
    {
        if (hKey != hRoot)
        {
            RegCloseKey(hKey);
        }
        return GetLastError();
    }

    // Return the value
    if (hKey != hRoot)
    {
        RegCloseKey(hKey);
    }

    return ERROR_SUCCESS;
}



// Write an ACL as a registry named value
int CUtility::WriteRegSingleACL(HKEY   hRoot,
                                LPCTSTR szKeyPath,
                                LPCTSTR szValueName,
                                PSECURITY_DESCRIPTOR pSec)
{
    int                   err;
    HKEY                  hKey = hRoot;
    PSrSecurityDescriptor pSrSec;
    PSrAcl                pDacl;

    // Open the key unless the key path is NULL
    if (szKeyPath)
    {
        if ((err = RegOpenKeyEx(hRoot, szKeyPath, 0, KEY_ALL_ACCESS, &hKey))
            != ERROR_SUCCESS)
        {
            return err;
        }
    }

    ULONG cbLen;
    BOOL fIsIAC = SDisIAC((SECURITY_DESCRIPTOR * )pSec);
    // If there are no ACE's and this is DefaultAccessPermission, then
    // interpret this as activator access only which we indicate by
    // removing the named value
    if (!fIsIAC)
    {
        pSrSec = (PSrSecurityDescriptor) pSec;
        pDacl = (PSrAcl) (((BYTE *) pSec) + (pSrSec->Dacl));
        if (_tcscmp(szValueName, TEXT("DefaultAccessPermission")) == 0  &&
            pDacl->AceCount == 0)
        {
            err = RegDeleteValue(hKey, szValueName);
            return err;
        }
        cbLen = RtlLengthSecurityDescriptor(pSec);
    }
    else
    {
        cbLen = (ULONG) GlobalSize(pSec);
    }
    // Else write the ACL simply as a REG_SZ value
    err = RegSetValueEx(hKey,
                        szValueName,
                        0,
                        REG_BINARY,
                        (BYTE *) pSec,
                        cbLen);

    if (hKey != hRoot)
    {
        RegCloseKey(hKey);
    }

    return err;
}



// Write an ACL on a registry key
int CUtility::WriteRegKeyACL(HKEY   hKey,
                             HKEY  *phClsids,
                             unsigned cClsids,
                             PSECURITY_DESCRIPTOR pSec,
                             PSECURITY_DESCRIPTOR pSecOrig)
{
    int err;

    // The logic is somewhat different depending on whether we're starting
    // with HKEY_CLASSES_ROOT or a specific AppID
    if (hKey == HKEY_CLASSES_ROOT)
    {
        return WriteRegKeyACL2(hKey, hKey, pSec, pSecOrig);
    }

    // It's a specific AppID
    else
    {
        // Write the security on the AppID key
        if (err = RegSetKeySecurity(hKey,
                                    OWNER_SECURITY_INFORMATION |
                                    GROUP_SECURITY_INFORMATION |
                                    DACL_SECURITY_INFORMATION,
                                    pSec) != ERROR_SUCCESS)
        {
            return err;
        }

        // Iterate over the CLSID's covered by this AppID and recursively
        // write security on them and their subkeys
        for (UINT k = 0; k < cClsids; k++)
        {
            if (err = WriteRegKeyACL2(phClsids[k], phClsids[k], pSec, pSecOrig)
                != ERROR_SUCCESS)
            {
                return err;
            }
        }
    }
    return ERROR_SUCCESS;
}



// Write an ACL recursively on a registry key provided the current
// security descriptor on the key is the same as the passed in
// original security descriptor
int CUtility::WriteRegKeyACL2(HKEY                 hRoot,
                              HKEY                 hKey,
                              PSECURITY_DESCRIPTOR pSec,
                              PSECURITY_DESCRIPTOR pSecOrig)
{
    BYTE                 aCurrSD[256] = {0};
    DWORD                cbCurrSD = 256;
    PSECURITY_DESCRIPTOR pCurrSD = (PSECURITY_DESCRIPTOR) aCurrSD;
    BOOL                 fFreePCurrSD = FALSE;
    int                  err;
    BOOL                 fProceed;

    // Read the current security descriptor on this key
    err = RegGetKeySecurity(hKey,
                            OWNER_SECURITY_INFORMATION |
                            GROUP_SECURITY_INFORMATION |
                            DACL_SECURITY_INFORMATION,
                            aCurrSD,
                            &cbCurrSD);
    if (err == ERROR_MORE_DATA  ||  err == ERROR_INSUFFICIENT_BUFFER)
    {
        pCurrSD = (SECURITY_DESCRIPTOR *) GlobalAlloc(GMEM_FIXED, cbCurrSD);
        if (pCurrSD == NULL)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        fFreePCurrSD = TRUE;
    }
    else if (err != ERROR_SUCCESS)
    {
        return err;
    }
    if ((err = RegGetKeySecurity(hKey,
                                 OWNER_SECURITY_INFORMATION |
                                 GROUP_SECURITY_INFORMATION |
                                 DACL_SECURITY_INFORMATION,
                                 pCurrSD,
                                 &cbCurrSD)
         != ERROR_SUCCESS))
    {
        if (fFreePCurrSD)
        {
            GlobalFree(pCurrSD);
        }
        return err;
    }

    // Only proceed down this subtree if the current SD and the
    // original SD are the same
    fProceed = CompareSDs((PSrSecurityDescriptor) pCurrSD,
                          (PSrSecurityDescriptor) pSecOrig);

    // We're done with the current security descriptor
    if (fFreePCurrSD)
    {
        GlobalFree(pCurrSD);
    }

    if (!fProceed)
    {
        if (hKey != hRoot)
        {
            RegCloseKey(hKey);
        }
        return ERROR_SUCCESS;
    }

    // Write the top level ACL
    err = RegSetKeySecurity(hKey,
                            OWNER_SECURITY_INFORMATION |
                            GROUP_SECURITY_INFORMATION |
                            DACL_SECURITY_INFORMATION,
                            pSec);

    // Now enumerate the subkeys and write ACL's on them
    DWORD iSubKey;
    TCHAR szSubKeyName[128];
    HKEY  hKey2;

    iSubKey = 0;

    while (err == ERROR_SUCCESS)
    {
        // Enumerate the next key
        err = RegEnumKey(hKey, iSubKey, szSubKeyName, 128);
        if (err != ERROR_SUCCESS)
        {
            break;
        }

        // Prepare for the next key
        iSubKey++;

        // Open this subkey and recursively write the ACL on it and
        // all of its subkeys
        if (RegOpenKeyEx(hKey, szSubKeyName, 0, KEY_ALL_ACCESS, &hKey2)
            == ERROR_SUCCESS)
        {
            err = WriteRegKeyACL2(hRoot, hKey2, pSec, pSecOrig);
        }
    }

    if (hKey != hRoot)
    {
        RegCloseKey(hKey);
    }
    return err == ERROR_NO_MORE_ITEMS ? ERROR_SUCCESS : err;
}




// Write a user's password to the private LSA database
int CUtility::WriteLsaPassword(CLSID appid, LPCTSTR szPassword)
{
    return ERROR_SUCCESS;
}



int CUtility::DeleteRegKey(HKEY hRoot, LPCTSTR szKeyPath)
{
    return RegDeleteKey(hRoot, szKeyPath);
}



int CUtility::DeleteRegValue(HKEY hRoot, LPCTSTR szKeyPath, LPCTSTR szValueName)
{
    int  err;
    HKEY hKey;

    if ((err = RegOpenKeyEx(hRoot, szKeyPath, 0, KEY_ALL_ACCESS, &hKey)) == ERROR_SUCCESS)
    {
        err = RegDeleteValue(hKey, szValueName);
        if (hRoot != hKey)
            RegCloseKey(hKey);
    }

    return err;
}



// Change the identity under which a service runs
int CUtility::WriteSrvIdentity(LPCTSTR szService, LPCTSTR szIdentity)
{
    return ERROR_SUCCESS;
}

DWORD __stdcall callBackFunc(HWND                 hwndParent,
                             HANDLE               hInstance,
                             ULONG_PTR            CallBackContext,
                             PSECURITY_DESCRIPTOR SecDesc,
                             PSECURITY_DESCRIPTOR SecDescNewObjects,
                             BOOLEAN              ApplyToSubContainers,
                             BOOLEAN              ApplyToSubObjects,
                             LPDWORD              StatusReturn)
{
    int err = ERROR_SUCCESS;
    PCallBackContext pCallBackContext = (PCallBackContext) CallBackContext;

    SECURITY_DESCRIPTOR* pSD = (SECURITY_DESCRIPTOR*) SecDesc;
    SECURITY_DESCRIPTOR_RELATIVE* pSDr = (SECURITY_DESCRIPTOR_RELATIVE*) SecDesc;

    PSrAcl                pDacl;
    PSrAce                pAce;
    DWORD                 cbAces;

    // Check whether the security descriptor is self-relative
    if (!(pSD->Control & SE_SELF_RELATIVE))
    {
        pDacl = (PSrAcl) pSD->Dacl;
    }
    else
    {
        pDacl = (PSrAcl) (((BYTE *) pSDr) + (pSDr->Dacl));
    }
    if (pDacl)
    {	
    	// Do over the ACE's
	    for (pAce = (PSrAce) (((BYTE *) pDacl) + sizeof(SSrAcl)),
         	cbAces = pDacl->AceCount;cbAces;
	        pAce = (PSrAce) (((BYTE *) pAce) + pAce->AceSize),cbAces--)
    	{
                if (pAce->Type == 1  &&  pAce->AccessMask == GENERIC_ALL)
                {
                        pAce->AccessMask = COM_RIGHTS_EXECUTE;
                }
        }
    }


    // Set the inheritance flags on the new security descriptor
    if (pCallBackContext->pktType == RegKeyACL)
    {
        g_util.SetInheritanceFlags((SECURITY_DESCRIPTOR *) SecDesc);
    }

    if (pCallBackContext->fIsIAC)
    {
        // try to convert to a serialized IAccessControl
        SECURITY_DESCRIPTOR * pNewSD = g_util.IACfromSD((SECURITY_DESCRIPTOR *)SecDesc);
        if (pNewSD)
        {
            SecDesc = pNewSD;
        }
        else
        {
            pCallBackContext->fIsIAC = FALSE; // failed so treat it as if it is an old-style SD
            CString sMsg;
            CString sCaption;
            sMsg.LoadString(IDS_CANTCONVERT);
            sCaption.LoadString(IDS_SYSTEMMESSAGE);
            MessageBox(NULL, sMsg, sCaption, MB_OK);
        }
    }
    else
    {
        SECURITY_DESCRIPTOR * pNewSD;
#if 0   // set to 0 to remove this test code
        SECURITY_DESCRIPTOR * pTempSD = g_util.IACfromSD((SECURITY_DESCRIPTOR *)SecDesc);
        pNewSD = g_util.SDfromIAC((SECURITY_DESCRIPTOR *)pTempSD);
        BOOL fResult = g_util.CompareSDs((PSrSecurityDescriptor)pNewSD, (PSrSecurityDescriptor)SecDesc);
        GlobalFree(pTempSD);
#else
        // just copy the security descriptor to get it into Global Memory
        g_util.CopySD((SECURITY_DESCRIPTOR *)SecDesc, &pNewSD);
#endif
        SecDesc = pNewSD;
    }

    // Write the new or modified security descriptor
    if (*pCallBackContext->pIndex == -1)
    {
        if (pCallBackContext->pktType == SingleACL)
        {
            err = g_virtreg.NewRegSingleACL(
                    pCallBackContext->info.single.hRoot,
                    pCallBackContext->info.single.szKeyPath,
                    pCallBackContext->info.single.szValueName,
                    (SECURITY_DESCRIPTOR *) SecDesc,
                    pCallBackContext->fIsIAC,   // If it's an IAC then it's already SELF-RELATIVE
                    pCallBackContext->pIndex);
        }
        else
        {
            err = g_virtreg.NewRegKeyACL(
                    pCallBackContext->info.regKey.hKey,
                    pCallBackContext->info.regKey.phClsids,
                    pCallBackContext->info.regKey.cClsids,
                    pCallBackContext->info.regKey.szTitle,
                    pCallBackContext->origSD,
                    (SECURITY_DESCRIPTOR *) SecDesc,
                    pCallBackContext->fIsIAC,   // If it's an IAC then it's already SELF-RELATIVE
                    pCallBackContext->pIndex);
        }
    }
    else
    {
        g_virtreg.ChgRegACL(*pCallBackContext->pIndex,
                            (SECURITY_DESCRIPTOR *) SecDesc,
                            pCallBackContext->fIsIAC);  // If it's an IAC then it's already SELF-RELATIVE
    }

    *StatusReturn = err;
    return err;
}


// Invoke the ACL editor on the specified named value.  This method
// writes an ACL data packet to the virtual registry.  This method is for
// Access and Launch security only (pktType SingleACL).
int CUtility::ACLEditor(HWND       hWnd,
                        HKEY       hRoot,
                        LPCTSTR    szKeyPath,
                        LPCTSTR    szValueName,
                        int       *pIndex,
                        PACKETTYPE pktType,
                        dcomAclType eAclType)
{
#if !defined(STANDALONE_BUILD)
    int                  err;
    HKEY                 hKey;
    BYTE                 aSD[128];
    DWORD                cbSD = 128;
    DWORD                dwType;
    SECURITY_DESCRIPTOR *pSD = (SECURITY_DESCRIPTOR *) aSD;
    BOOL                 fFreePSD = FALSE;
    SID                 *pSid;
    TCHAR                szAllow[32];
    TCHAR                szDeny[32];
    CString              szAllow_;
    CString              szDeny_;

    // Build the allow and deny strings
	switch (eAclType)
	{
	case dcomAclAccess:
		szAllow_.LoadString(IDS_ALLOW_ACCESS);
		szDeny_.LoadString(IDS_DENY_ACCESS);
		break;

	case dcomAclLaunch:
		szAllow_.LoadString(IDS_ALLOW_LAUNCH);
		szDeny_.LoadString(IDS_DENY_LAUNCH);
		break;

	case dcomAclConfig:
		szAllow_.LoadString(IDS_ALLOW_CONFIG);
		szDeny_.LoadString(IDS_DENY_CONFIG);
		break;
	}

    _tcscpy(szAllow, (LPCTSTR) szAllow_);
    _tcscpy(szDeny, (LPCTSTR) szDeny_);

    // Fetch the current SD, either from the registry, by default if the
    // named value doesn't exist or from the virtual registry
    if (*pIndex == -1)
    {
        // Open the specified key
        if ((err = RegOpenKeyEx(hRoot, szKeyPath, 0,
                                KEY_ALL_ACCESS, &hKey))
            != ERROR_SUCCESS)
        {
            return err;
        }

        // Attempt to read the specified named value
        err = RegQueryValueEx(hKey, szValueName, 0, &dwType, (BYTE *) aSD,
                              &cbSD);

        if (err == ERROR_MORE_DATA  ||  err == ERROR_INSUFFICIENT_BUFFER)
        {
            pSD = (SECURITY_DESCRIPTOR *) GlobalAlloc(GMEM_FIXED, cbSD);
            if (pSD == NULL)
            {
                return ERROR_NOT_ENOUGH_MEMORY;
            }
            fFreePSD = TRUE;
            err = RegQueryValueEx(hKey, szValueName, 0, &dwType,
                                  (BYTE *) pSD, &cbSD);
        }
        // The named valued doesn't exist.  If this is
        // \\HKEY_CLASSES_ROOT\...
        // then use the default named value if it exists
        else if (err != ERROR_SUCCESS)
        {
            if (hRoot != HKEY_LOCAL_MACHINE)
            {
                if (err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                       TEXT("SOFTWARE\\Microsoft\\OLE"),
                                       0,
                                       KEY_ALL_ACCESS,
                                       &hKey)
                    != ERROR_SUCCESS)
                {
                    return err;
                }

                // Attempt to read the specified named value
                TCHAR szDefault[32];

                _tcscpy(szDefault, TEXT("Default"));
                _tcscat(szDefault, szValueName);
                err = RegQueryValueEx(hKey, szDefault, 0, &dwType,
                                      (BYTE *) aSD, &cbSD);
                if (err == ERROR_MORE_DATA)
                {
                    pSD = (SECURITY_DESCRIPTOR *) GlobalAlloc(GMEM_FIXED, cbSD);
                    if (pSD == NULL)
                    {
                        return ERROR_NOT_ENOUGH_MEMORY;
                    }
                    fFreePSD = TRUE;
                    err = RegQueryValueEx(hKey, szDefault, 0, &dwType,
                                          (BYTE *) pSD, &cbSD);
                }
                RegCloseKey(hKey);
            }
        }

        // If still don't have an SD, then simply create one
        if (err != ERROR_SUCCESS)
        {
            if (!g_util.LookupProcessInfo(&pSid, NULL))
            {
                return GetLastError();
            }
            if (!g_util.MakeSecDesc(pSid, &pSD))
            {
                delete pSid;
                return GetLastError();
            }
            fFreePSD = TRUE;
        }
    }

    // Fetch the most recently edited SD
    else
    {
        CDataPacket *pCdp = g_virtreg.GetAt(*pIndex);

        pSD = pCdp -> pkt.acl.pSec;
    }


    // Initialize the callback context
    m_sCallBackContext.pktType = pktType;
    m_sCallBackContext.pIndex = pIndex;
    m_sCallBackContext.origSD = pSD;
    m_sCallBackContext.info.single.hRoot = hRoot;
    m_sCallBackContext.info.single.szKeyPath = (TCHAR*)szKeyPath;
    m_sCallBackContext.info.single.szValueName = (TCHAR*)szValueName;

    // Invoke the ACL editor
    DWORD                       dwStatus;
    GENERIC_MAPPING             genericMapping;
    CString                     szObjectType;

    szObjectType.LoadString(IDS_Registry_value);

    SED_HELP_INFO   helpInfo =
        {
            TEXT("dcomcnfg.hlp"),
            {HC_MAIN_DLG,
             HC_MAIN_DLG,
             HC_MAIN_DLG,
             HC_MAIN_DLG,
             HC_MAIN_DLG,
             HC_MAIN_DLG,
             HC_MAIN_DLG}
        };

    SED_OBJECT_TYPE_DESCRIPTOR  objTyp =
            {1,                                // Revision
             FALSE,                            // Is container?
             FALSE,                            // Allow new object perms?
             FALSE,                            // Specific to generic?
             &genericMapping,                  // Generic mapping
             NULL,                             // Generic mapping new
             (TCHAR *) ((LPCTSTR) szObjectType), // Object type name
             &helpInfo,                        // Help info
             TEXT(""),                         // Ckbox title
             TEXT(""),                         // Apply title
             TEXT(""),                         //
             NULL,                             // Special object access
             NULL                              // New special object access
            };

    SED_APPLICATION_ACCESS      appAccess[] =
            {{SED_DESC_TYPE_RESOURCE, COM_RIGHTS_EXECUTE, 0, szAllow},
             {SED_DESC_TYPE_RESOURCE, 0, 0, szDeny}};

    SED_APPLICATION_ACCESSES    appAccesses =
            {2,              // Count of access groups
             appAccess,      // Access array
             szAllow         // Default access name
            };

    // Intialize the help contexts
    helpInfo.aulHelpContext[HC_MAIN_DLG] =
        IDH_REGISTRY_VALUE_PERMISSIONS;
    helpInfo.aulHelpContext[HC_SPECIAL_ACCESS_DLG] =
        IDH_SPECIAL_ACCESS_GLOBAL;
    helpInfo.aulHelpContext[HC_NEW_ITEM_SPECIAL_ACCESS_DLG] =
        IDH_SPECIAL_ACCESS_GLOBAL;
    helpInfo.aulHelpContext[HC_ADD_USER_DLG] =
        IDH_ADD_USERS_AND_GROUPS;
    helpInfo.aulHelpContext[HC_ADD_USER_MEMBERS_LG_DLG] =
        IDH_LOCAL_GROUP_MEMBERSHIP;
    helpInfo.aulHelpContext[HC_ADD_USER_MEMBERS_GG_DLG] =
        IDH_GLOBAL_GROUP_MEMBERSHIP;
    helpInfo.aulHelpContext[HC_ADD_USER_SEARCH_DLG] =
        IDH_FIND_ACCOUNT1;

    genericMapping.GenericRead    = GENERIC_ALL;
    genericMapping.GenericWrite   = GENERIC_ALL;
    genericMapping.GenericExecute = GENERIC_ALL;
    genericMapping.GenericAll     = GENERIC_ALL;

    if (!CheckForValidSD(pSD))
    {
        // make a valid security descriptor so we can continue
        if (!g_util.LookupProcessInfo(&pSid, NULL))
        {
            return GetLastError();
        }
        if (!g_util.MakeSecDesc(pSid, &pSD))
        {
            delete pSid;
            return GetLastError();
        }
        fFreePSD = TRUE;
    }
    m_sCallBackContext.fIsIAC = SDisIAC(pSD);
    if (m_sCallBackContext.fIsIAC)
    {
        // convert to a true security descriptor
        SECURITY_DESCRIPTOR * pNewSD = SDfromIAC(pSD);
        if (!pNewSD)
        {
            // failed so pop up an error box
            CString sMsg, sCaption;
            sMsg.LoadString(IDS_BADSD);
            sCaption.LoadString(IDS_SYSTEMMESSAGE);
            MessageBox(NULL, sMsg, sCaption, MB_OK);
            // make a valid security descriptor so we can continue
            if (!g_util.LookupProcessInfo(&pSid, NULL))
            {
                return GetLastError();
            }
            if (!g_util.MakeSecDesc(pSid, &pNewSD))
            {
                delete pSid;
                return GetLastError();
            }
        }
        if (fFreePSD)
        {
            GlobalFree(pSD);
        }
        pSD=pNewSD;
        fFreePSD = TRUE;
    }

    // If this is for Access or Launch permissons then check that the
    // SD contains only allows and deny's for COM_RIGHTS_EXECUTE
    if (!CheckSDForCOM_RIGHTS_EXECUTE(pSD))
    {
        return IDCANCEL;
    }
    // Invoke the ACL editor
    SedDiscretionaryAclEditor(hWnd,              // Owner hWnd
                              GetModuleHandle(NULL), // Owner hInstance
                              NULL,              // Server
                              &objTyp,           // ObjectTyp,
                              &appAccesses,      // Application accesses
                              (TCHAR*)szValueName,       // Object name,
                              callBackFunc, // Callback function
                              (ULONG_PTR) &m_sCallBackContext, // Callback context
                              pSD,              // Security descriptor,
                              FALSE,             // Couldnt read Dacl,
                              FALSE,             // Can't write Dacl,
                              &dwStatus,         // SED status return,
                              0);                // Flags

    // Check status return
    if (dwStatus != ERROR_SUCCESS)
    {
//        PostErrorMessage(dwStatus);
    }

    // We're done
    if (fFreePSD)
    {
        GlobalFree(pSD);
    }

    return dwStatus == 0 ? ERROR_SUCCESS : IDCANCEL;
#else
    return IDCANCEL;
#endif
}





// Invoke the ACL editor on the specified key.  This method writes an ACL
// data packet to the virtual registry.  This method supports configuration
// security only (pktType RegKeyACL).
int CUtility::ACLEditor2(HWND       hWnd,
                         HKEY       hKey,
                         HKEY      *phClsids,
                         unsigned   cClsids,
                         TCHAR     *szTitle,
                         int       *pIndex,
                         PACKETTYPE pktType)
{
#if !defined(STANDALONE_BUILD)
    int                  err;
    BYTE                 aSD[128];
    DWORD                cbSD = 128;
    SECURITY_DESCRIPTOR *pSD = (SECURITY_DESCRIPTOR *) aSD;
    BOOL                 fFreePSD = FALSE;
    TCHAR                szKeyRead[32];
    CString              szKeyRead_;
    TCHAR                szHkeyClassesRoot[32];
    CString              szHkeyClassesRoot_;


    // Initialize strings
    szKeyRead_.LoadString(IDS_Key_Read);
    _tcscpy(szKeyRead, (LPCTSTR) szKeyRead_);
    szHkeyClassesRoot_.LoadString(IDS_HKEY_CLASSES_ROOT);
    _tcscpy(szHkeyClassesRoot, (LPCTSTR) szHkeyClassesRoot_);

    if (*pIndex == -1)
    {
        // Read the security descriptor on this key
        err = RegGetKeySecurity(hKey,
                                OWNER_SECURITY_INFORMATION |
                                GROUP_SECURITY_INFORMATION |
                                DACL_SECURITY_INFORMATION,
                                aSD,
                                &cbSD);
        if (err == ERROR_MORE_DATA  ||  err == ERROR_INSUFFICIENT_BUFFER)
        {
            pSD = (SECURITY_DESCRIPTOR *) GlobalAlloc(GMEM_FIXED, cbSD);
            if (pSD == NULL)
            {
                return ERROR_NOT_ENOUGH_MEMORY;
            }
            fFreePSD = TRUE;
        }
        else if (err != ERROR_SUCCESS)
        {
            return err;
        }
        if ((err = RegGetKeySecurity(hKey,
                                     OWNER_SECURITY_INFORMATION |
                                     GROUP_SECURITY_INFORMATION |
                                     DACL_SECURITY_INFORMATION,
                                     pSD,
                                     &cbSD)
             != ERROR_SUCCESS))
        {
            if (fFreePSD)
            {
                GlobalFree(pSD);
            }
            return err;
        }
    }

    // Fetch the most recently edited SD
    else
    {
        CDataPacket *pCdp = g_virtreg.GetAt(*pIndex);

        pSD = pCdp -> pkt.racl.pSec;
    }


    // Initialize the callback context
    m_sCallBackContext.pktType = pktType;
    m_sCallBackContext.pIndex = pIndex;
    m_sCallBackContext.origSD = pSD;
    m_sCallBackContext.info.regKey.hKey = hKey;
    m_sCallBackContext.info.regKey.phClsids = phClsids;
    m_sCallBackContext.info.regKey.cClsids = cClsids;
    m_sCallBackContext.info.regKey.szTitle = szTitle;

    // Invoke the ACL editor
    DWORD                       dwStatus;
    GENERIC_MAPPING             genericMapping;

    CString                     szObjectType;
    szObjectType.LoadString(IDS_Registry_Key);
    CString szQueryValue;
    szQueryValue.LoadString(IDS_Query_Value);
    CString szSetValue;
    szSetValue.LoadString(IDS_Set_Value);
    CString szCreateSubkeys;
    szCreateSubkeys.LoadString(IDS_Create_Subkey);
    CString szEnumerateSubkeys;
    szEnumerateSubkeys.LoadString(IDS_Enumerate_Subkeys);
    CString szNotify;
    szNotify.LoadString(IDS_Notify);
    CString szCreateLink;
    szCreateLink.LoadString(IDS_Create_Link);
    CString szDelete;
    szDelete.LoadString(IDS_Delete);
    CString szWriteDAC;
    szWriteDAC.LoadString(IDS_Write_DAC);
    CString szWriteOwner;
    szWriteOwner.LoadString(IDS_Write_Owner);
    CString szReadControl;
    szReadControl.LoadString(IDS_Read_Control);
    CString szRead;
    szRead.LoadString(IDS_Read);
    CString szFullControl;
    szFullControl.LoadString(IDS_Full_Control);
    CString szSpecialAccess;
    szSpecialAccess.LoadString(IDS_Special_AccessDotDotDot);


    SED_HELP_INFO               helpInfo =
    {
        TEXT("dcomcnfg.hlp"),
        {HC_MAIN_DLG,
         HC_MAIN_DLG,
         HC_MAIN_DLG,
         HC_MAIN_DLG,
         HC_MAIN_DLG,
         HC_MAIN_DLG,
         HC_MAIN_DLG}
    };

    SED_OBJECT_TYPE_DESCRIPTOR  objTyp =
            {SED_REVISION1,                    // Revision
             FALSE,                            // Is container?
             FALSE,                            // Allow new object perms?
             FALSE,                            // Specific to generic?
             &genericMapping,                  // Generic mapping
             NULL,                             // Generic mapping new
             (TCHAR *) ((LPCTSTR) szObjectType), // Object type name
             &helpInfo,                        // Help info
             TEXT(""),                         // Ckbox title
             TEXT(""),                         // Apply title
             TEXT(""),                         //
             (TCHAR *) ((LPCTSTR) szSpecialAccess), // Special Access menu item
             NULL                              // New special object access
            };


    SED_APPLICATION_ACCESS      appAccess[] =
    {
        { SED_DESC_TYPE_RESOURCE_SPECIAL, KEY_QUERY_VALUE,        0,
           (TCHAR *) ((LPCTSTR) szQueryValue) },
        { SED_DESC_TYPE_RESOURCE_SPECIAL, KEY_SET_VALUE,          0,
           (TCHAR *) ((LPCTSTR) szSetValue) },
        { SED_DESC_TYPE_RESOURCE_SPECIAL, KEY_CREATE_SUB_KEY,     0,
           (TCHAR *) ((LPCTSTR) szCreateSubkeys) },
        { SED_DESC_TYPE_RESOURCE_SPECIAL, KEY_ENUMERATE_SUB_KEYS, 0,
           (TCHAR *) ((LPCTSTR) szEnumerateSubkeys) },
        { SED_DESC_TYPE_RESOURCE_SPECIAL, KEY_NOTIFY,             0,
           (TCHAR *) ((LPCTSTR) szNotify) },
        { SED_DESC_TYPE_RESOURCE_SPECIAL, KEY_CREATE_LINK,        0,
           (TCHAR *) ((LPCTSTR) szCreateLink) },
        { SED_DESC_TYPE_RESOURCE_SPECIAL, 0x00010000, /* DELETE, */ 0,
           (TCHAR *) ((LPCTSTR) szDelete) },
        { SED_DESC_TYPE_RESOURCE_SPECIAL, WRITE_DAC,              0,
           (TCHAR *) ((LPCTSTR) szWriteDAC) },
        { SED_DESC_TYPE_RESOURCE_SPECIAL, WRITE_OWNER,            0,
           (TCHAR *) ((LPCTSTR) szWriteOwner) },
        { SED_DESC_TYPE_RESOURCE_SPECIAL, READ_CONTROL,           0,
           (TCHAR *) ((LPCTSTR) szReadControl) },
        { SED_DESC_TYPE_RESOURCE,         KEY_READ,               0,
           (TCHAR *) ((LPCTSTR) szRead) },
        { SED_DESC_TYPE_RESOURCE,         GENERIC_ALL, /* KEY_ALL_ACCESS, */ 0,
           (TCHAR *) ((LPCTSTR) szFullControl) }
    };

    SED_APPLICATION_ACCESSES    appAccesses =
        {12,              // Count of access groups
         appAccess,       // Access array
         szKeyRead        // Default access name
        };

    // Intialize the help contexts
    helpInfo.aulHelpContext[HC_MAIN_DLG] =
        IDH_REGISTRY_KEY_PERMISSIONS;
    if (hKey == HKEY_CLASSES_ROOT)
    {
        helpInfo.aulHelpContext[HC_SPECIAL_ACCESS_DLG] =
            IDH_SPECIAL_ACCESS_GLOBAL;
        helpInfo.aulHelpContext[HC_NEW_ITEM_SPECIAL_ACCESS_DLG] =
            IDH_SPECIAL_ACCESS_GLOBAL;
    }
    else
    {
        helpInfo.aulHelpContext[HC_SPECIAL_ACCESS_DLG] =
            IDH_SPECIAL_ACCESS_PER_APPID;
        helpInfo.aulHelpContext[HC_NEW_ITEM_SPECIAL_ACCESS_DLG] =
            IDH_SPECIAL_ACCESS_PER_APPID;
    }

    helpInfo.aulHelpContext[HC_ADD_USER_DLG] =
        IDH_ADD_USERS_AND_GROUPS;
    helpInfo.aulHelpContext[HC_ADD_USER_MEMBERS_LG_DLG] =
        IDH_LOCAL_GROUP_MEMBERSHIP;
    helpInfo.aulHelpContext[HC_ADD_USER_MEMBERS_GG_DLG] =
        IDH_GLOBAL_GROUP_MEMBERSHIP;
    helpInfo.aulHelpContext[HC_ADD_USER_SEARCH_DLG] =
        IDH_FIND_ACCOUNT1;

    genericMapping.GenericRead    = KEY_READ;
    genericMapping.GenericWrite   = KEY_WRITE;
    genericMapping.GenericExecute = KEY_READ;
    genericMapping.GenericAll     = KEY_ALL_ACCESS;

    if (!CheckForValidSD(pSD))
    {
        return IDCANCEL;
    }
    m_sCallBackContext.fIsIAC = SDisIAC(pSD);
    if (m_sCallBackContext.fIsIAC)
    {
        // convert to a true security descriptor
        SECURITY_DESCRIPTOR * pNewSD = SDfromIAC(pSD);
        if (!pNewSD)
        {
            // failed so pop up an error box
            CString sMsg, sCaption;
            sMsg.LoadString(IDS_BADSD);
            sCaption.LoadString(IDS_SYSTEMMESSAGE);
            MessageBox(NULL, sMsg, sCaption, MB_OK);
            return IDCANCEL;
        }
        if (fFreePSD)
        {
            GlobalFree(pSD);
        }
        pSD=pNewSD;
        fFreePSD = TRUE;
    }

    // Invoke the ACL editor
    SedDiscretionaryAclEditor(hWnd,              // Owner hWnd
                              GetModuleHandle(NULL), // Owner hInstance
                              NULL,              // Server
                              &objTyp,           // ObjectTyp,
                              &appAccesses,      // Application accesses
                              szTitle ? szTitle : szHkeyClassesRoot,// Object name,
                              callBackFunc, // Callback function
                              (ULONG_PTR) &m_sCallBackContext, // Callback context
                              pSD,              // Security descriptor,
                              FALSE,             // Couldnt read Dacl,
                              FALSE,             // Can't write Dacl,
                              &dwStatus,         // SED status return,
                              0);                // Flags

    // Check status return
    if (dwStatus != ERROR_SUCCESS)
    {
//        PostErrorMessage(dwStatus);
    }

    // We're done
    if (fFreePSD)
    {
        GlobalFree(pSD);
    }

    return dwStatus == 0 ? ERROR_SUCCESS : IDCANCEL;
#else
    return IDCANCEL;
#endif
}




BOOL CUtility::InvokeUserBrowser(HWND hWnd, TCHAR *szUser)
{
    BOOL             fRet = FALSE;
#if !defined(STANDALONE_BUILD)
    HUSERBROW        hUser;
    USERBROWSER      sUserBrowser;
    SUserDetailsPlus sUserDetailsPlus;
    ULONG            ulSize = USER_DETAILS_BUFFER_SIZE;
    CString          szTitle;

    szTitle.LoadString(IDS_Browse_for_users);

    sUserBrowser.ulStructSize = sizeof(USERBROWSER);
    sUserBrowser.fUserCancelled = FALSE;
    sUserBrowser.fExpandNames = TRUE;
    sUserBrowser.hwndOwner = hWnd;
    sUserBrowser.pszTitle = (TCHAR *) ((LPCTSTR) szTitle);
    sUserBrowser.pszInitialDomain = NULL;
    sUserBrowser.Flags = USRBROWS_SINGLE_SELECT      |
                         USRBROWS_INCL_ALL           |
                         USRBROWS_SHOW_USERS;
    sUserBrowser.ulHelpContext = IDH_BROWSE_FOR_USERS;
    sUserBrowser.pszHelpFileName = TEXT("dcomcnfg.hlp");


    hUser = OpenUserBrowser(&sUserBrowser);
    if (hUser == NULL)
    {
        return FALSE;
    }
    else
    {
        CString szBackslash;

        szBackslash.LoadString(IDS_backslash);

        if (EnumUserBrowserSelection(hUser,
                                     &sUserDetailsPlus.sUserDetails,
                                     &ulSize))
        {
            _tcscpy(szUser, sUserDetailsPlus.sUserDetails.pszDomainName);
            _tcscat(szUser, (LPCTSTR) szBackslash);
            _tcscat(szUser, sUserDetailsPlus.sUserDetails.pszAccountName);
            fRet = TRUE;
        }
    }

    CloseUserBrowser(hUser);
#endif

    return fRet;

}







BOOL CUtility::InvokeMachineBrowser(TCHAR *szMachine)
{
#if !defined(STANDALONE_BUILD)
    ///////////////////////////////////////////////////
   // If we end up not wanting to use I_SystemFocusDialog, then the code below
   // is the start for fetching machine resources ourselves
/*
    DWORD       dwErr;
    NETRESOURCE aNetResource[1000];
    HANDLE      hNetwork;
    DWORD       dwEntries = 100;
    DWORD       dwBufSize =  sizeof(aNetResource);

    dwErr = WNetOpenEnum(RESOURCE_GLOBALNET,
                         RESOURCETYPE_ANY,
                         0,
                         NULL,
                         &hNetwork);

    if (dwErr == NO_ERROR)
    {
        dwEntries = 0xffffffff;
        dwErr = WNetEnumResource(hNetwork,
                                 &dwEntries,
                                 aNetResource,
                                 &dwBufSize);
    }

    WNetCloseEnum(hNetwork);

    dwErr = WNetOpenEnum(RESOURCE_GLOBALNET,
                         RESOURCETYPE_ANY,
                         0,
                         aNetResource,
                         &hNetwork);

    if (dwErr == NO_ERROR)
    {
        dwEntries = 0xffffffff;
        dwErr = WNetEnumResource(hNetwork,
                                 &dwEntries,
                                 &aNetResource[1],
                                 &dwBufSize);
    }


    return dwErr == NO_ERROR ? TRUE : FALSE;
*/
///////////////////////////////////////////////////////




    UINT  err;
    BOOL  fOkPressed = FALSE;

    err = I_SystemFocusDialog(GetForegroundWindow(),
//                              FOCUSDLG_BROWSE_LOGON_DOMAIN |
//                              FOCUSDLG_BROWSE_WKSTA_DOMAIN,
                              0x30003,
                              szMachine,
                              128,
                              &fOkPressed,
                              TEXT("dcomcnfg.hlp"),
                              IDH_SELECT_DOMAIN);

    if (err == ERROR_SUCCESS  &&  fOkPressed)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
#else
    return FALSE;
#endif
}





int CUtility::StringFromGUID(GUID &rguid, TCHAR *lpsz, int cbMax)
{
    int i;
    LPWSTR p = lpsz;

    const BYTE * pBytes = (const BYTE *) &rguid;

    *p++ = L'{';

    for (i = 0; i < sizeof(GuidMap); i++)
    {
        if (GuidMap[i] == '-')
        {
            *p++ = L'-';
        }
        else
        {
            *p++ = wszDigits[ (pBytes[GuidMap[i]] & 0xF0) >> 4 ];
            *p++ = wszDigits[ (pBytes[GuidMap[i]] & 0x0F) ];
        }
    }
    *p++ = L'}';
    *p   = L'\0';

    return GUIDSTR_MAX;
}




BOOL  CUtility::IsEqualGuid(GUID &guid1, GUID &guid2)
{
   return (
      ((PLONG) &guid1)[0] == ((PLONG) &guid2)[0] &&
      ((PLONG) &guid1)[1] == ((PLONG) &guid2)[1] &&
      ((PLONG) &guid1)[2] == ((PLONG) &guid2)[2] &&
      ((PLONG) &guid1)[3] == ((PLONG) &guid2)[3]);
}



BOOL CUtility::AdjustPrivilege(TCHAR *szPrivilege)
{
    HANDLE           hProcessToken = 0;
    BOOL             bOK = FALSE;
    TOKEN_PRIVILEGES privileges;

    if( !OpenProcessToken( GetCurrentProcess(),
                           TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
                           &hProcessToken ) )
    {
        return FALSE;
    }

    privileges.PrivilegeCount = 1;
    privileges.Privileges[ 0 ].Attributes = SE_PRIVILEGE_ENABLED;
    if( !LookupPrivilegeValue(NULL, szPrivilege,
                              &privileges.Privileges[ 0 ].Luid ) )
    {
        return FALSE;
    }

    if( !AdjustTokenPrivileges( hProcessToken, FALSE,
                                &privileges,
                                0L, NULL, NULL ) )
    {
        return FALSE;
    }

    if( hProcessToken )
    {
        CloseHandle( hProcessToken );
    }

    return TRUE;
}



BOOL CUtility::VerifyRemoteMachine(TCHAR *szRemoteMachine)
{
    NETRESOURCE sResource;
    NETRESOURCE sResource2;
    DWORD       dwErr;
    HANDLE      hEnum;
    DWORD       cbEntries;
    DWORD       cbBfr;

    // TODO: Get this function to work.  Right now WNetEnumResource is
    // screwing up the stack, causing an AV and anyway returns the error
    // ERROR_NO_MORE_ITEMS which I don't understand.
    //
    // Also, it is not clear that we should verify the remote machine name.
    // It may have different formats, e.g. IP address or a URL specification.
    // It may not even be on an NT network.  In any case it may be offline
    // currently.
    return TRUE;

    sResource.dwScope       = RESOURCE_GLOBALNET;
    sResource.dwType        = RESOURCETYPE_ANY;
    sResource.dwDisplayType = RESOURCEDISPLAYTYPE_GENERIC;
    sResource.dwUsage       = RESOURCEUSAGE_CONTAINER;
    sResource.lpLocalName   = NULL;
    sResource.lpRemoteName  = szRemoteMachine;
    sResource.lpComment     = NULL;
    sResource.lpProvider    = NULL;



    dwErr = WNetOpenEnum(RESOURCE_GLOBALNET,
                         RESOURCETYPE_ANY,
                         RESOURCEUSAGE_CONTAINER,
                         &sResource,
                         &hEnum);

    if (dwErr == NO_ERROR)
    {
        cbEntries = 1;
        cbBfr = sizeof(NETRESOURCE);
        dwErr = WNetEnumResource(hEnum, &cbEntries, &sResource2, &cbBfr);
    }

    CloseHandle(hEnum);

    return TRUE;

}




BOOL CUtility::RetrieveUserPassword(TCHAR *szAppid, CString &sPassword)
{
#if !defined(STANDALONE_BUILD)
    LSA_OBJECT_ATTRIBUTES sObjAttributes;
    HANDLE                hPolicy = NULL;
    LSA_UNICODE_STRING    sKey;
    PLSA_UNICODE_STRING   psPassword;
    TCHAR                 szKey[4 + GUIDSTR_MAX + 1];

    // Formulate the access key
    _tcscpy(szKey, TEXT("SCM:"));
    _tcscat(szKey, szAppid);

    // UNICODE_STRING length fields are in bytes and include the NULL
    // terminator
    sKey.Length              = (_tcslen(szKey) + 1) * sizeof(TCHAR);
    sKey.MaximumLength       = (GUIDSTR_MAX + 5) * sizeof(TCHAR);
    sKey.Buffer              = szKey;

    // Open the local security policy
    InitializeObjectAttributes(&sObjAttributes, NULL, 0L, NULL, NULL);
    if (!NT_SUCCESS(LsaOpenPolicy(NULL, &sObjAttributes,
                                  POLICY_GET_PRIVATE_INFORMATION, &hPolicy)))
    {
        return FALSE;
    }

    // Read the user's password
    if (!NT_SUCCESS(LsaRetrievePrivateData(hPolicy, &sKey, &psPassword)))
    {
        LsaClose(hPolicy);
        return FALSE;
    }

    // Close the policy handle, we're done with it now.
    LsaClose(hPolicy);

    // Possible for LsaRetrievePrivateData to return success but with a NULL
    // psPassword.   If this happens we fail.
    if (!psPassword)
    {
        return FALSE;
    }

    // Copy the password
    sPassword = psPassword->Buffer;

    // Clear and free lsa's buffer
    memset(psPassword->Buffer, 0, psPassword->Length);
    LsaFreeMemory( psPassword );

    return TRUE;
#else
    return FALSE;
#endif
}





BOOL CUtility::StoreUserPassword(TCHAR *szAppid, CString &szPassword)
{
#if !defined(STANDALONE_BUILD)
    LSA_OBJECT_ATTRIBUTES sObjAttributes;
    HANDLE                hPolicy = NULL;
    LSA_UNICODE_STRING    sKey;
    LSA_UNICODE_STRING    sPassword;
    TCHAR                 szKey[4 + GUIDSTR_MAX + 1];

    // Formulate the access key
    _tcscpy(szKey, TEXT("SCM:"));
    _tcscat(szKey, szAppid);

    // UNICODE_STRING length fields are in bytes and include the NULL
    // terminator
    sKey.Length              = (_tcslen(szKey) + 1) * sizeof(TCHAR);
    sKey.MaximumLength       = (GUIDSTR_MAX + 5) * sizeof(TCHAR);
    sKey.Buffer              = szKey;

    // Make the password a UNICODE string
    sPassword.Length = (_tcslen(LPCTSTR(szPassword)) + 1) * sizeof(TCHAR);
    sPassword.Buffer = (TCHAR *) LPCTSTR(szPassword);
    sPassword.MaximumLength = sPassword.Length;

    // Open the local security policy
    InitializeObjectAttributes(&sObjAttributes, NULL, 0L, NULL, NULL);
    if (!NT_SUCCESS(LsaOpenPolicy(NULL, &sObjAttributes,
                                  POLICY_CREATE_SECRET, &hPolicy)))
    {
        return FALSE;
    }

    // Store the user's password
    if (!NT_SUCCESS(LsaStorePrivateData(hPolicy, &sKey, &sPassword)))
    {
        g_util.PostErrorMessage();
        LsaClose(hPolicy);
        return FALSE;
    }

    // Close the policy handle, we're done with it now.
    LsaClose(hPolicy);

    return TRUE;
#else
    return FALSE;
#endif
}






BOOL CUtility::LookupProcessInfo(SID **ppSid, TCHAR **ppszPrincName)
{
    BYTE               aMemory[SIZEOF_TOKEN_USER];
    TOKEN_USER        *pTokenUser  = (TOKEN_USER *) &aMemory;
    HANDLE             hToken      = NULL;
    DWORD              lIgnore;
    DWORD              lSidLen;
    DWORD              lNameLen    = 0;
    DWORD              lDomainLen  = 0;
    TCHAR             *pDomainName = NULL;
    SID_NAME_USE       sIgnore;

    if (ppszPrincName != NULL)
        *ppszPrincName = NULL;

    // Open the process's token.
    if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))
    {
        // Lookup SID of process token.
        if (GetTokenInformation( hToken, TokenUser, pTokenUser,
                                 sizeof(aMemory), &lIgnore ))
        {
            // Allocate memory to hold the SID.
            lSidLen = GetLengthSid( pTokenUser->User.Sid );
            *ppSid = (SID *) new BYTE[lSidLen];
            if (*ppSid == NULL)
            {
                return FALSE;
            }
            memcpy(*ppSid, pTokenUser->User.Sid, lSidLen);

            // Stop now if the caller doesn't want the user name.
            if (ppszPrincName != NULL)
            {
                // Find out how much memory to allocate for the name.
                LookupAccountSid(NULL, pTokenUser->User.Sid, NULL, &lNameLen,
                                 NULL, &lDomainLen, NULL );
                if (lNameLen != 0)
                {
                    // Allocate memory for the user's name.
                    *ppszPrincName =
                        (TCHAR *) new BYTE[lNameLen*sizeof(TCHAR)];
                    if (ppszPrincName == NULL)
                    {
                        CloseHandle( hToken );
                        return FALSE;
                    }
                    pDomainName = (TCHAR *) new BYTE[lDomainLen*sizeof(TCHAR)];
                    if (pDomainName == NULL)
                    {
                        delete ppszPrincName;
                        CloseHandle( hToken );
                        return FALSE;
                    }

                    // Find the user's name.
                    if (!LookupAccountSid( NULL, pTokenUser->User.Sid,
                                           *ppszPrincName, &lNameLen,
                                           pDomainName,
                                           &lDomainLen, &sIgnore))
                    {
                        delete ppszPrincName;
                        delete pDomainName;
                        CloseHandle( hToken );
                        return FALSE;
                    }
                }
                delete ppszPrincName;
                delete pDomainName;
            }
        }
        CloseHandle( hToken );
    }

    return TRUE;
}






BOOL CUtility::MakeSecDesc(SID *pSid, SECURITY_DESCRIPTOR **ppSD)
{
    ACL               *pAcl;
    DWORD              lSidLen;
    SID               *pGroup;
    SID               *pOwner;

    // In case we fail
    *ppSD = NULL;

    // Allocate the security descriptor.
    lSidLen = GetLengthSid( pSid );
    *ppSD = (SECURITY_DESCRIPTOR *) GlobalAlloc(GMEM_FIXED,
                  sizeof(SECURITY_DESCRIPTOR) + 2*lSidLen + SIZEOF_ACL);
    if (*ppSD == NULL)
    {
        return FALSE;
    }
    pGroup = (SID *) (*ppSD + 1);
    pOwner = (SID *) (((BYTE *) pGroup) + lSidLen);
    pAcl   = (ACL *) (((BYTE *) pOwner) + lSidLen);

    // Initialize a new security descriptor.
    if (!InitializeSecurityDescriptor(*ppSD, SECURITY_DESCRIPTOR_REVISION))
    {
        GlobalFree(*ppSD);
        return FALSE;
    }

    // Initialize a new ACL.
    if (!InitializeAcl(pAcl, SIZEOF_ACL, ACL_REVISION2))
    {
        GlobalFree(*ppSD);
        return FALSE;
    }

// Comment out this code because the only time we create a default SD is
// when attempting to edit
// \\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\OLE.DefaultAccessPermission
// which we want to start with 0 ACE's
/*
    // Allow the current user access.
    if (!AddAccessAllowedAce( pAcl, ACL_REVISION2, COM_RIGHTS_EXECUTE, pSid ))
    {
        GlobalFree(*ppSD);
        return FALSE;
    }

    // Allow local system access.
    if (!AddAccessAllowedAce( pAcl, ACL_REVISION2, COM_RIGHTS_EXECUTE,
                              (void *) &LOCAL_SYSTEM_SID ))
    {
        GlobalFree(*ppSD);
        return FALSE;
    }
*/

    // Add a new ACL to the security descriptor.
    if (!SetSecurityDescriptorDacl( *ppSD, TRUE, pAcl, FALSE ))
    {
        GlobalFree(*ppSD);
        return FALSE;
    }

    // Set the group.
    memcpy( pGroup, pSid, lSidLen );
    if (!SetSecurityDescriptorGroup( *ppSD, pGroup, FALSE ))
    {
        GlobalFree(*ppSD);
        return FALSE;
    }

    // Set the owner.
    memcpy( pOwner, pSid, lSidLen );
    if (!SetSecurityDescriptorOwner( *ppSD, pOwner, FALSE ))
    {
        GlobalFree(*ppSD);
        return FALSE;
    }

    // Check the security descriptor.
    assert(IsValidSecurityDescriptor(*ppSD));

    return TRUE;
}


// Accepts either a traditional security descriptor or an IAccessControl
BOOL CUtility::CheckForValidSD(SECURITY_DESCRIPTOR *pSD)
{
    WORD dwType = 0;
    if (pSD)
    {
        dwType = *((WORD *)pSD);
    }
    if ((dwType != 1) && (dwType != 2))
    {
        CString sMsg, sCaption;
        sMsg.LoadString(IDS_BADSD);
        sCaption.LoadString(IDS_SYSTEMMESSAGE);
        MessageBox(NULL, sMsg, sCaption, MB_OK);
        return FALSE;
    }
    return TRUE;
}

// Check to see if the security descriptor is really a serialized IAccessControl.
BOOL CUtility::SDisIAC(SECURITY_DESCRIPTOR *pSD)
{
    WORD dwType = *((WORD *)pSD);
    if (dwType == 2)
    {
        return TRUE;
    }
    return FALSE;
}

SECURITY_DESCRIPTOR * CUtility::SDfromIAC(SECURITY_DESCRIPTOR * pSD)
{
    IStream * pStream;
    IAccessControl * pIAC;
    IPersistStream * pIPS;
    HRESULT hr;
    BOOL fReturn;

    // Un-serialize the IAccessControl
    hr = CreateStreamOnHGlobal((HGLOBAL)pSD, FALSE, &pStream);
    if (FAILED(hr))
    {
        return NULL;
    }
    // skip version
    DWORD dwVersion;
    hr = pStream->Read(&dwVersion, sizeof(DWORD), NULL);
    if (FAILED(hr) || dwVersion != 2)
    {
        return NULL;
    }
    // skip CLSID
    CLSID clsid;
    hr = pStream->Read(&clsid, sizeof(CLSID), NULL);
    if (FAILED(hr))
    {
        return NULL;
    }
    // create and IAccessControl and get an IPersistStream
    hr = CoCreateInstance(clsid,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IAccessControl,
                          (void **)&pIAC);
    if (FAILED(hr))
    {
        pStream->Release();
        return NULL;
    }
    hr = pIAC->QueryInterface(IID_IPersistStream, (void **) &pIPS);
    if (FAILED(hr))
    {
        pIAC->Release();
        pStream->Release();
        return NULL;
    }
    hr = pIPS->Load(pStream);
    pIPS->Release();
    pStream->Release();
    if (FAILED(hr))
    {
        pIAC->Release();
        return NULL;
    }

    // Create an EXPLICIT_ACCESS list for each entry in the IAccessControl
    DWORD cAces;
    ACTRL_ACCESS_ENTRYW * rgAE;
    ACTRL_ACCESS * pAccess;
//    PTRUSTEE pOwner;
//    PTRUSTEE pGroup;
//    hr = pIAC->GetAllAccessRights(NULL, &pAccess, &pOwner, &pGroup);
    hr = pIAC->GetAllAccessRights(NULL, &pAccess, NULL, NULL);
    if (FAILED(hr) || (pAccess->cEntries == 0))
    {
        pIAC->Release();
        return NULL;
    }
    // we're assuming only one property entry
    cAces = pAccess->pPropertyAccessList->pAccessEntryList->cEntries;
    rgAE = pAccess->pPropertyAccessList->pAccessEntryList->pAccessList;

    EXPLICIT_ACCESS * rgEA = new EXPLICIT_ACCESS[cAces];
    DWORD i;

    for (i = cAces; i--;)
    {
        LPTSTR szName = rgAE[i].Trustee.ptstrName;
        if (TRUSTEE_IS_NAME == rgAE[i].Trustee.TrusteeForm && 0 == wcscmp(rgAE[i].Trustee.ptstrName, L"*"))
        {
            szName = new WCHAR [wcslen(L"EVERYONE") + 1];
            if (!szName)
            {
                pIAC->Release();
                return NULL;
            }
            wcscpy(szName, L"EVERYONE");
        }
        DWORD dwAccessPermissions = rgAE[i].Access;    // should always be COM_RIGHTS_EXECUTE or GENERIC_ALL
        ACCESS_MODE AccessMode;
        switch (rgAE[i].fAccessFlags)
        {
        case ACTRL_ACCESS_ALLOWED:
            AccessMode = SET_ACCESS;
            dwAccessPermissions = COM_RIGHTS_EXECUTE;    // HACK! Required to get ACL editor to work.
            break;
        case ACTRL_ACCESS_DENIED:
        default:
            AccessMode = DENY_ACCESS;
            dwAccessPermissions = GENERIC_ALL;    // HACK! Required to get ACL editor to work.
            break;
        }
        DWORD dwInheritance = rgAE[i].Inheritance;     // Carefull. May not be allowed.
        BuildExplicitAccessWithName(
                    &rgEA[i],
                    szName,
                    dwAccessPermissions,
                    AccessMode,
                    dwInheritance);
    }

    SECURITY_DESCRIPTOR * pSDNew = NULL;
    ULONG cbSize = 0;
    // create the new Security descriptor
    hr = BuildSecurityDescriptor(NULL, //pOwner,
                                 NULL, //pGroup,
                                 cAces,
                                 rgEA,
                                 0,
                                 NULL,
                                 NULL,
                                 &cbSize,
                                 (void **)&pSDNew);
    if (ERROR_SUCCESS != hr)
    {
        // For some reason this may fail with this error even when it appears to have worked
        // A subsequent call seems to have no affect (i.e. it doesn't work like
        // other security descriptor calls that expect you to allocate the buffer yourself)
        if (ERROR_INSUFFICIENT_BUFFER != hr)
        {
            return NULL;
        }
    }
    SECURITY_DESCRIPTOR * pSDCopy = (SECURITY_DESCRIPTOR *)GlobalAlloc(GMEM_FIXED, cbSize);
    if (!pSDCopy)
    {
        LocalFree(pSDNew);
        return NULL;
    }
    memcpy(pSDCopy, pSDNew, cbSize);
    LocalFree(pSDNew);
    //delete [] rgAE;
    pIAC->Release();
    return pSDCopy;
}

SECURITY_DESCRIPTOR * CUtility::IACfromSD(SECURITY_DESCRIPTOR * pSD)
{
    IAccessControl * pIAC = NULL;

    // create new IAccessControl object
    HRESULT hr;

    hr = CoCreateInstance(CLSID_DCOMAccessControl,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IAccessControl,
                          (void **) &pIAC);

    if (FAILED(hr))
    {
        return (NULL);
    }
    IPersistStream * pIPS;
    hr = pIAC->QueryInterface(IID_IPersistStream, (void **) &pIPS);
    if (FAILED(hr))
    {
        pIAC->Release();
        return NULL;
    }
    hr = pIPS->Load(NULL);
    if (FAILED(hr))
    {
        pIPS->Release();
        pIAC->Release();
        return NULL;
    }

    BOOL fReturn, fDaclPresent, fDaclDefaulted;
    ACL * pDacl;

    // get the ACL list
    fReturn = GetSecurityDescriptorDacl(pSD, &fDaclPresent, &pDacl, &fDaclDefaulted);
    if (fReturn && fDaclPresent)
    {
        PEXPLICIT_ACCESS rgEA;
        ULONG cAces;
#if 0    // Set to 1 when GetExplicitEntriesFromAcl works
        DWORD dwReturn = GetExplicitEntriesFromAcl(pDacl,
                                                   &cAces,
                                                   &rgEA);

        // enumerate the ACL, building list of objects to add to IAccessControl object
        if (dwReturn != ERROR_SUCCESS)
        {
            pIAC->Release();
            return NULL;
        }

        ACTRL_ACCESSW stAccess;
        ACTRL_PROPERTY_ENTRYW stProperty;
        ACTRL_ACCESS_ENTRY_LISTW stAccessList;
        stAccess.cEntries = 1;
        stAccess.pPropertyAccessList = &stProperty;
        stProperty.lpProperty = NULL;
        stProperty.pAccessEntryList = &stAccessList;
        stProperty.fListFlags = 0;
        stAccessList.cEntries = cAces;
        ACTRL_ACCESS_ENTRYW * rgAE = new ACTRL_ACCESS_ENTRYW[cAces];
	stAccessList.pAccessList = rgAE;
        ULONG i;
        for (i = cAces; i--; )
        {
            rgAE[i].Trustee = rgEA[i].Trustee;
            if (rgEA[i].Trustee.TrusteeForm == TRUSTEE_IS_SID)
            {
                // convert to a named trustee
                rgAE[i].Trustee.TrusteeForm = TRUSTEE_IS_NAME;
                SID * pSid = (SID *)rgEA[i].Trustee.ptstrName;
                DWORD cbName = 0;
                DWORD cbDomain = 0;
                LPTSTR szName = NULL;
                LPTSTR szDomain = NULL;
                SID_NAME_USE snu;
                fReturn = LookupAccountSid(NULL,
                                           pSid,
                                           szName,
                                           &cbName,
                                           szDomain,
                                           &cbDomain,
                                           &snu);
                szName = (LPTSTR) new char [cbName];
                szDomain = (LPTSTR) new char [cbDomain];
                fReturn = LookupAccountSid(NULL,
                                           pSid,
                                           szName,
                                           &cbName,
                                           szDomain,
                                           &cbDomain,
                                           &snu);
                CString * pcs = new CString;
                (*pcs) = TEXT("\\\\");
                (*pcs) += szDomain;
                (*pcs) += TEXT("\\");
                (*pcs) += szName;
                rgAE[i].Trustee.ptstrName = (LPTSTR)(LPCTSTR)(*pcs);
            }
            else
            {
#if 0   // REMOVE THIS HACK when GetExplicitEntriesFromAcl works as it should
                if (rgAE[i].Trustee.TrusteeType < TRUSTEE_IS_WELL_KNOWN_GROUP)
                {
                    rgAE[i].Trustee.TrusteeType = (enum _TRUSTEE_TYPE)((unsigned)rgAE[i].Trustee.TrusteeType + 1);
                }
#endif
                if (rgAE[i].Trustee.TrusteeType == TRUSTEE_IS_WELL_KNOWN_GROUP)
                {
                    // IAccessControl::GrantAccessRights doesn't like TRUSTEE_IS_WELL_KNOWN_GROUP for some reason
                    rgAE[i].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
                }
            }
            // test for "the world"
            if (TRUSTEE_IS_WELL_KNOWN_GROUP == rgAE[i].Trustee.TrusteeType &&
                0 == _wcsicmp(L"Everyone", rgAE[i].Trustee.ptstrName))
            {
                rgAE[i].Trustee.ptstrName[0] = L'*';
                rgAE[i].Trustee.ptstrName[1] = 0;
            }
            rgAE[i].Access = rgEA[i].grfAccessPermissions;
            rgAE[i].ProvSpecificAccess = 0;
            rgAE[i].Inheritance = rgEA[i].grfInheritance;
            rgAE[i].lpInheritProperty = NULL;
            switch (rgEA[i].grfAccessMode)
            {
            case SET_ACCESS:
                rgAE[i].fAccessFlags = ACTRL_ACCESS_ALLOWED;
                break;
            case DENY_ACCESS:
            default:
                rgAE[i].fAccessFlags = ACTRL_ACCESS_DENIED;
                break;
            }
        }
#else
        ACL_SIZE_INFORMATION aclInfo;
        fReturn = GetAclInformation(pDacl, &aclInfo, sizeof(aclInfo), AclSizeInformation);
        if (!fReturn)
        {
	    pIPS->Release();
	    pIAC->Release();
            return NULL;
        }
        cAces = aclInfo.AceCount;
        ACE_HEADER * pAceHeader;

        ACTRL_ACCESSW stAccess;
        ACTRL_PROPERTY_ENTRYW stProperty;
        ACTRL_ACCESS_ENTRY_LISTW stAccessList;
        stAccess.cEntries = 1;
        stAccess.pPropertyAccessList = &stProperty;
        stProperty.lpProperty = NULL;
        stProperty.pAccessEntryList = &stAccessList;
        stProperty.fListFlags = 0;
        stAccessList.cEntries = cAces;
        ACTRL_ACCESS_ENTRYW * rgAE = new ACTRL_ACCESS_ENTRYW[cAces];
        if (!rgAE) 
	{
	   pIPS->Release();
	   pIAC->Release();
	   return NULL;
	}
	stAccessList.pAccessList = rgAE;
        ULONG i;
        for (i = cAces; i--; )
        {
            rgAE[i].ProvSpecificAccess = 0;
            rgAE[i].Inheritance = NO_INHERITANCE;
            rgAE[i].lpInheritProperty = NULL;
            rgAE[i].Trustee.pMultipleTrustee = NULL;
            rgAE[i].Trustee.MultipleTrusteeOperation = NO_MULTIPLE_TRUSTEE;
            rgAE[i].Trustee.TrusteeForm = TRUSTEE_IS_NAME;
            rgAE[i].Access = COM_RIGHTS_EXECUTE;

            fReturn = GetAce(pDacl, i, (LPVOID *)&pAceHeader);
            if (!fReturn)
            {
	       delete [] rgAE;
	       pIPS->Release();
	       pIAC->Release();
               return NULL;
            }

            SID * pSid = NULL;

            switch (pAceHeader->AceType)
            {
            case ACCESS_ALLOWED_ACE_TYPE:
                {
                    rgAE[i].fAccessFlags = ACTRL_ACCESS_ALLOWED;
                    ACCESS_ALLOWED_ACE * pAce = (ACCESS_ALLOWED_ACE *)pAceHeader;
                    pSid = (SID *) &(pAce->SidStart);
                }
                break;
            case ACCESS_DENIED_ACE_TYPE:
                {
                    rgAE[i].fAccessFlags = ACTRL_ACCESS_DENIED;
                    ACCESS_DENIED_ACE * pAce = (ACCESS_DENIED_ACE *)pAceHeader;
                    pSid = (SID *) &(pAce->SidStart);
                }
                break;
            default:
                break;
            }

            TCHAR szName[MAX_PATH];
            TCHAR szDomain[MAX_PATH];
            DWORD cbName = MAX_PATH;
            DWORD cbDomain = MAX_PATH;
            SID_NAME_USE use;

            if(pSid)
            {
                fReturn = LookupAccountSid(NULL,
                                           pSid,
                                           szName,
                                           &cbName,
                                           szDomain,
                                           &cbDomain,
                                           &use);
            }
            else
            {
                fReturn = FALSE;  // i.e., we took default path above
            }

            if (!fReturn)
            {
	       delete [] rgAE;
	       pIPS->Release();
	       pIAC->Release();
               return NULL;
            }

            switch (use)
            {
            case SidTypeUser:
                rgAE[i].Trustee.TrusteeType = TRUSTEE_IS_USER;
                break;
            case SidTypeGroup:
                rgAE[i].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
                break;
            case SidTypeAlias:
                rgAE[i].Trustee.TrusteeType = TRUSTEE_IS_ALIAS;
                break;
            case SidTypeWellKnownGroup:
                //rgAE[i].Trustee.TrusteeType = TRUSTEE_IS_WELL_KNOWN_GROUP;
                rgAE[i].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
                break;
            case SidTypeDeletedAccount:
                rgAE[i].Trustee.TrusteeType = TRUSTEE_IS_DELETED;
                break;
            case SidTypeInvalid:
                rgAE[i].Trustee.TrusteeType = TRUSTEE_IS_INVALID;
                break;
            case SidTypeDomain:
                rgAE[i].Trustee.TrusteeType = TRUSTEE_IS_GROUP; //TRUSTEE_IS_DOMAIN;
                break;
            case SidTypeUnknown:
            default:
                rgAE[i].Trustee.TrusteeType = TRUSTEE_IS_UNKNOWN;
                break;
            }
            CString sz;
            // test for "the world"
            if (0 == wcslen(szDomain) && 0 == _wcsicmp(L"Everyone", szName))
            {
                sz = "*";
            }
            else
            {
                sz = szDomain;
                sz += "\\";
                sz += szName;
            }

            WCHAR * wsz = new WCHAR[sz.GetLength() + 1];
            wcscpy(wsz, (LPCWSTR)sz);
            rgAE[i].Trustee.ptstrName = wsz;
        }
#endif
        delete [] rgAE;
        hr = pIAC->GrantAccessRights(&stAccess);
        if (FAILED(hr))
        {
            pIPS->Release();
            pIAC->Release();
            return NULL;
        }
        // free up structures
        // LocalFree(rgEA);
    }
    // serialize the IAccessControl object

    // Find out how big it is
    ULARGE_INTEGER size;
    hr = pIPS->GetSizeMax(&size);
    if (FAILED(hr))
    {
        pIPS->Release();
        pIAC->Release();
        return NULL;
    }
    size.QuadPart += sizeof(DWORD) + sizeof (CLSID);
    HANDLE hMem = GlobalAlloc(GMEM_FIXED, size.LowPart);
    if (hMem != NULL)
    {
        IStream * pStream;
        hr = CreateStreamOnHGlobal(hMem, FALSE, &pStream);
        if (FAILED(hr))
        {
            pIPS->Release();
            pIAC->Release();
            return NULL;
        }
        DWORD dwVersion = 2;
        CLSID clsid = CLSID_DCOMAccessControl;
        hr = pStream->Write(&dwVersion, sizeof(DWORD), NULL);
        if (FAILED(hr))
        {
            pStream->Release();
            pIPS->Release();
            pIAC->Release();
            return NULL;
        }
        hr = pStream->Write(&clsid, sizeof(CLSID), NULL);
        if (FAILED(hr))
        {
            pStream->Release();
            pIPS->Release();
            pIAC->Release();
            return NULL;
        }
        hr = pIPS->Save(pStream, TRUE);
        pStream->Release();
        if (FAILED(hr))
        {
            pIPS->Release();
            pIAC->Release();
            return NULL;
        }
    }
    pIPS->Release();
    pIAC->Release();
    return (SECURITY_DESCRIPTOR *) hMem;
}


BOOL CUtility::CheckSDForCOM_RIGHTS_EXECUTE(SECURITY_DESCRIPTOR *pSD)
{
    PSrAcl                        pDacl;
    PSrAce                        pAce;
    DWORD                         cbAces;
    SECURITY_DESCRIPTOR_RELATIVE* pSDr = (SECURITY_DESCRIPTOR_RELATIVE*) pSD;

    // Check whether the security descriptor is self-relative
    if (!(pSD->Control & SE_SELF_RELATIVE))
    {
        pDacl = (PSrAcl) pSD->Dacl;

        // Check for a deny ALL
        if (pDacl == NULL)
        {
            return TRUE;
        }
    }
    else
    {
        // First check for a deny ALL
        if (pSDr->Dacl == 0)
        {
            return TRUE;
        }

        pDacl = (PSrAcl) (((BYTE *) pSDr) + (pSDr->Dacl));
    }

    // Do over the ACE's
    for (pAce = (PSrAce) (((BYTE *) pDacl) + sizeof(SSrAcl)),
         cbAces = pDacl->AceCount;
         cbAces;
         pAce = (PSrAce) (((BYTE *) pAce) + pAce->AceSize),
         cbAces--)
    {
        // workaround for the ACL editor bug. If the ACL editor sees a non GENERIC_ALL deny ACE, it 
	// complains. So we convert COM_RIGHTS_EXECUTE to GENERIC_ALL. On the way back we will
	// do the reverse. See CallBackFunc for the other half of this fix.

	if (pAce->Type == 1  &&  pAce->AccessMask == COM_RIGHTS_EXECUTE)
        {
            pAce->AccessMask = GENERIC_ALL;
        }        
        // Check that it is
        // a) an allow on COM_RIGHTS_EXECUTE
        // b) a deny on GENERIC_ALL,
        // c) a deny on COM_RIGHTS_EXECUTE,
        // d) a deny ALL (handled above if the DACL is NULL) or
        // e) an allow everyone (handled implicitly if cbAces == 0)
        if (!(((pAce->Type == 0  &&  pAce->AccessMask == COM_RIGHTS_EXECUTE)
               ||
               (pAce->Type == 1  &&  pAce->AccessMask == GENERIC_ALL)
               ||
               (pAce->Type == 1  &&  pAce->AccessMask == COM_RIGHTS_EXECUTE))))
        {
            CString szText;
            CString szTitle;

            szText.LoadString(IDS_The_security_);
            szTitle.LoadString(IDS_DCOM_Configuration_Warning);

            if (MessageBox(GetForegroundWindow(),
                           (LPCTSTR) szText,
                           (LPCTSTR) szTitle,
                           MB_YESNO) == IDYES)
            {
                pAce->Flags = 0;
                pAce->Type = 0;
                pAce->AccessMask = COM_RIGHTS_EXECUTE;
            }
            else
            {
                return FALSE;
            }
        }
    }

    return TRUE;
}

BOOL CUtility::ChangeService(LPCTSTR szService,
                             LPCTSTR szIdentity,
                             LPCTSTR szPassword,
                             LPCTSTR szDisplay)
{
    SC_HANDLE            hSCManager;
    SC_HANDLE            hService;
    QUERY_SERVICE_CONFIG qsc;
    DWORD dwBytesNeeded = 0;
    LPTSTR lpszTmpDisplay = (LPTSTR)szDisplay;

    // Open the service control manager
    if (hSCManager = OpenSCManager(NULL, NULL, GENERIC_READ | GENERIC_WRITE))
    {
        // Try to open a handle to the requested service
        if (!(hService = OpenService(hSCManager,
                                     szService,
                                     GENERIC_READ | GENERIC_WRITE)))
        {
            g_util.PostErrorMessage();
            CloseServiceHandle(hSCManager);
            return FALSE;
        }

        // Close the service manager's database
        CloseServiceHandle(hSCManager);


        if (QueryServiceConfig(hService, &qsc, sizeof(qsc), &dwBytesNeeded))
            lpszTmpDisplay = qsc.lpDisplayName;

        // Change service identity parameters
        if (ChangeServiceConfig(hService,
                                SERVICE_NO_CHANGE, // SERVICE_WIN32_OWN_PROCESS,
                                SERVICE_NO_CHANGE, // SERVICE_DEMAND_START,
                                SERVICE_NO_CHANGE,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                szIdentity,
                                szPassword,
                                NULL))
        {

            // Return success
            CloseServiceHandle(hService);
            return TRUE;
        }
        else
        {
            g_util.PostErrorMessage();
            CloseServiceHandle(hService);
            return FALSE;
        }
    }

    else
    {
        g_util.PostErrorMessage();
        return FALSE;
    }

}




BOOL CUtility::UpdateDCOMInfo(void)
{
    RPC_STATUS status;
    TCHAR     *pszBindString;

    // Get a binding handle to the SCM if we haven't yet
    if (m_hRpc == NULL)
    {
        status = RpcStringBindingCompose(NULL,
                                         TEXT("ncalrpc"),
                                         NULL,
                                         TEXT("epmapper"),
                                         NULL,
                                         &pszBindString);

        if (status != RPC_S_OK)
        {
            return status;
        }

        status = RpcBindingFromStringBinding(pszBindString, &m_hRpc);
        RpcStringFree(&pszBindString);

        if (status != ERROR_SUCCESS)
        {
            return status;
        }

    }

#if !defined(STANDALONE_BUILD)
    // Call over to the SCM to get the global registry values read
    // into memory
    UpdateActivationSettings(m_hRpc, &status);
#endif
    return status;
}



LRESULT CALLBACK ControlFixProc( HWND  hwnd, UINT  uMsg, WPARAM wParam,
                                 LPARAM  lParam);

// This is a work-around because there is a bug in msdev 4.1: Cannot get
// WM_HELP message processed by a control on which DDX_Control data exchange
// is done because of subclassing problem.  See msdn Q145865 for a discussion
// plus work-around code.
void CUtility::FixHelp(CWnd* pWnd)
{
    // search all child windows.  If their window proc
    // is AfxWndProc, then subclass with our window proc
    CWnd* pWndChild = pWnd->GetWindow(GW_CHILD);
    while(pWndChild != NULL)
    {
        if (GetWindowLongPtr(pWndChild->GetSafeHwnd(),
                          GWLP_WNDPROC) == (LONG_PTR)AfxWndProc)
        {
            SetWindowLongPtr(pWndChild->GetSafeHwnd(), GWLP_WNDPROC,
                          (LONG_PTR)ControlFixProc);
        }
        pWndChild = pWndChild->GetWindow(GW_HWNDNEXT);
    }
}



LRESULT CALLBACK ControlFixProc(HWND  hwnd, UINT  uMsg, WPARAM wParam,
                                LPARAM  lParam)
{
    if (uMsg == WM_HELP)
    {
        // bypass MFC's handler, message will be sent to parent
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
    return AfxWndProc(hwnd,uMsg,wParam,lParam);
}




// Compare two security descriptors in self-relative form to
// determine if they're the same
BOOL CUtility::CompareSDs(PSrSecurityDescriptor pSD1,
                          PSrSecurityDescriptor pSD2)
{
    PSID   pSid1, pSid2;
    PSrAcl pDacl1, pDacl2;
    PSrAce pAce1, pAce2;
    BYTE   *p1, *p2;

    // Compare the owners
    pSid1 = (PSID) (((BYTE *) pSD1) + pSD1->Owner);
    pSid2 = (PSID) (((BYTE *) pSD2) + pSD2->Owner);
    if (!EqualSid(pSid1, pSid2))
    {
        return FALSE;
    }

    // Compare the groups
    pSid1 = (PSID) (((BYTE *) pSD1) + pSD1->Group);
    pSid2 = (PSID) (((BYTE *) pSD2) + pSD2->Group);
    if (!EqualSid(pSid1, pSid2))
    {
        return FALSE;
    }

    // Compare the DACL's
    pDacl1 = (PSrAcl) (((BYTE *) pSD1) + pSD1->Dacl);
    pDacl2 = (PSrAcl) (((BYTE *) pSD2) + pSD2->Dacl);

    // Check first that they are the same size and have the same
    // number of ACE's
    if (! (pDacl1->AclSize  == pDacl2->AclSize  &&
           pDacl1->AceCount == pDacl2->AceCount))
    {
        return FALSE;
    }

    // Now compare the ACL ACE by ACE
    pAce1 = (PSrAce) (((BYTE *) pDacl1) + sizeof(SSrAcl));
    pAce2 = (PSrAce) (((BYTE *) pDacl2) + sizeof(SSrAcl));
    for (int k = 0; k < pDacl1->AceCount; k++)
    {
        // Check the ACE headers
        if (! (pAce1->Type       == pAce2->Type        &&
               pAce1->AceSize    == pAce2->AceSize     &&
               pAce1->AccessMask == pAce2->AccessMask))
        {
            return FALSE;
        }

        // Check the SID's
        p1 = (BYTE *) (((BYTE *) pAce1) + sizeof(ACE_HEADER));
        p2 = (BYTE *) (((BYTE *) pAce2) + sizeof(ACE_HEADER));
        for (ULONG j = 0; j < pAce1->AceSize - sizeof(ACE_HEADER); j++)
        {
            if (p1[j] != p2[j])
            {
                return FALSE;
            }
        }

        // Go to the next ACE
        pAce1 = (PSrAce) (((BYTE *) pAce1) + pAce1->AceSize);
        pAce2 = (PSrAce) (((BYTE *) pAce2) + pAce2->AceSize);
    }

    return TRUE;
}





int CUtility::SetAccountRights(LPCTSTR szUser, TCHAR *szPrivilege)
{
#if !defined(STANDALONE_BUILD)
    int                   err;
    LSA_HANDLE            hPolicy;
    LSA_OBJECT_ATTRIBUTES objAtt;
    DWORD                 cbSid = 1;
    TCHAR                 szDomain[MAX_PATH];
    DWORD                 cbDomain = MAX_PATH * sizeof(TCHAR);
    PSID                  pSid = NULL;
    SID_NAME_USE          snu;
    LSA_UNICODE_STRING    privStr;

    
    // Fetch the SID for the specified user
    if ((err = GetPrincipalSID(szUser, &pSid)) != ERROR_SUCCESS)
        return err;

    memset(&objAtt, 0, sizeof(LSA_OBJECT_ATTRIBUTES));
    
    if (IsBackupDC()) {
        TCHAR* pszPDC;
        LSA_UNICODE_STRING    lsaPDC;

        pszPDC = PrimaryDCName();

        lsaPDC.Length = _tcslen (pszPDC) * sizeof (TCHAR)-2;
        lsaPDC.MaximumLength = lsaPDC.Length + sizeof (TCHAR);
        lsaPDC.Buffer = &pszPDC[2];

        err = LsaOpenPolicy(&lsaPDC, &objAtt, POLICY_CREATE_ACCOUNT | POLICY_LOOKUP_NAMES | POLICY_VIEW_LOCAL_INFORMATION, &hPolicy);
    }
    else
        err = LsaOpenPolicy(NULL, &objAtt, POLICY_CREATE_ACCOUNT | POLICY_LOOKUP_NAMES | POLICY_VIEW_LOCAL_INFORMATION, &hPolicy);
 
    if (err != ERROR_SUCCESS) {
        return GetLastError();
    }

    // Set the specified privilege on this account
    privStr.Length = _tcslen(szPrivilege) * sizeof(TCHAR);
    privStr.MaximumLength = privStr.Length + sizeof(TCHAR);
    privStr.Buffer = szPrivilege;
    err = LsaAddAccountRights(hPolicy, pSid, &privStr, 1);
    
    // We're done
    delete pSid;
    LsaClose(hPolicy);

    if (err != ERROR_SUCCESS) {
        return GetLastError();
    }

#endif
    return ERROR_SUCCESS;
}

// NOTE: Cannot handle IAccessControl style SDs

void CUtility::CopyAbsoluteSD( SECURITY_DESCRIPTOR *pSDSrc,  SECURITY_DESCRIPTOR **pSDDest)
{
   (*pSDDest)->Revision = pSDSrc->Revision;
   (*pSDDest)->Sbz1 = pSDSrc->Sbz1;
   (*pSDDest)->Control = pSDSrc->Control;
   (*pSDDest)->Group = (*pSDDest)->Owner = (*pSDDest)->Dacl = (*pSDDest)->Sacl = NULL;
   BYTE* pOffSet=(BYTE*)(*pSDDest)+sizeof(SECURITY_DESCRIPTOR);
   if (pSDSrc->Dacl != NULL)
   {
	  memcpy(pOffSet,pSDSrc->Dacl,pSDSrc->Dacl->AclSize);
	  (*pSDDest)->Dacl = (PACL)pOffSet;
	  pOffSet += pSDSrc->Dacl->AclSize;
   }
   if (pSDSrc->Owner != NULL)
   {
	  memcpy(pOffSet,pSDSrc->Owner,GetLengthSid(pSDSrc->Owner));
	  (*pSDDest)->Owner = (PSID)pOffSet;
	  pOffSet += GetLengthSid(pSDSrc->Owner);
   }
   if (pSDSrc->Group != NULL)
   {
	  memcpy(pOffSet,pSDSrc->Group,GetLengthSid(pSDSrc->Group));
	  (*pSDDest)->Group = (PSID)pOffSet;
   }
	  
}
// This method is included only because in the debug version when using
// MFC they validate the C++ heap, whereas RtlCopySecurityDescriptor uses
// the standard process heap, causing MFC to throw a breakpoint

// The return value indicates the success or failure of the operation

// NTBUG 310004. This function is called to copy both self-relative and absolute
// SDs. In its previous incarnation, it corrupted heap when called to
// copy an absolute SD. Now I do the right thing.

// NOTE: This function can not handle IAccessControl style SDs despite
// appearances to the contrary. This is OK, because dcomcnfg.exe does
// not handle such SDs at all. 

BOOL CUtility::CopySD(SECURITY_DESCRIPTOR *pSrc, SECURITY_DESCRIPTOR **pDest)
{
#if !defined(STANDALONE_BUILD)
    ULONG                cbLen;

	*pDest = NULL;
	if (IsValidSecurityDescriptor(pSrc))
	{
		if (SDisIAC(pSrc))
		{
			cbLen = (ULONG) GlobalSize(pSrc);
		}
		else
		{
			cbLen = RtlLengthSecurityDescriptor(pSrc);
		}
		*pDest = (SECURITY_DESCRIPTOR *) GlobalAlloc(GMEM_FIXED, cbLen);
		if (*pDest)
		{
			// if the SD is already self-relative, just copy
			if ((pSrc)->Control & SE_SELF_RELATIVE )
			{
				memcpy(*pDest, pSrc, cbLen);
				return TRUE;
			}
			else 
			{
				// workaround an ACLEDIT bug (NT 352977). When the DACL has no ACES,
				// ACLEDIT returns incorrect AclSize, causing an AV  
				// when I copy it. So fix it here.
				if ((pSrc)->Dacl != NULL && ((pSrc)->Dacl->AceCount == 0))
					(pSrc)->Dacl->AclSize=sizeof(ACL);
				CopyAbsoluteSD(pSrc,pDest);
				return TRUE;
			}
			GlobalFree(*pDest);
		}
	}
#endif
	return FALSE;
}




// Set the inheritance flags on a security descriptor so keys created
// under the key having this security descriptor will inherit all its
// ACE's.  We do this as a utility routine rather than via the ACL
// editor because doing that adds check boxes and such to the ACL editor,
// so it's cleaner this way.
//
// Note. The security descriptor is expected to be in absolute form
void CUtility::SetInheritanceFlags(SECURITY_DESCRIPTOR *pSec)
{
    PSrAcl pAcl = (PSrAcl) pSec->Dacl;
    PSrAce pAce;
    int    k;

    // Do over the ACE's this DACL
    for (k = pAcl->AceCount, pAce = (PSrAce) (((BYTE *) pAcl) + sizeof(SSrAcl));
         k;
         k--, pAce = (PSrAce) (((BYTE *) pAce) + pAce->AceSize))
    {
        pAce->Flags |= CONTAINER_INHERIT_ACE;
    }
}



HRESULT CUtility::GetPrincipalSID (LPCTSTR Principal, PSID *Sid)
{
    DWORD        sidSize = 0;
    TCHAR        refDomain [256];
    DWORD        refDomainSize = 0;
    DWORD        returnValue;
    SID_NAME_USE snu;
    BOOL         bSuccess;
    
    bSuccess = LookupAccountName (NULL,
                       Principal,
                       *Sid,
                       &sidSize,
                       refDomain,
                       &refDomainSize,
                       &snu);

    // codework - we need to check if this is correct
    // what about multisuer machines - ie hydra
    if ((returnValue = GetLastError()) != ERROR_INSUFFICIENT_BUFFER)
        return returnValue;

    if ((*Sid = new BYTE[sidSize]) == NULL)
        return ERROR_OUTOFMEMORY;

    if (!LookupAccountName (NULL,
                            Principal,
                            *Sid,
                            &sidSize,
                            refDomain,
                            &refDomainSize,
                            &snu))
    {
        return GetLastError();
    }

    return ERROR_SUCCESS;
}

// this method, on first execution, checks if the current machine is a backup domain controller and if so,
// caches the value and returns TRUE. Subsequent executions will use cached value.
BOOL CUtility::IsBackupDC()
{
#if !defined(STANDALONE_BUILD)
    USER_MODALS_INFO_2    *umi2 = NULL;
    SERVER_INFO_101       *si101 = NULL;
    DWORD                 dw;

    if (!m_bCheckedDC) {
        if ((dw = NetServerGetInfo (NULL, 101, (LPBYTE *) &si101)) == 0)
        {
            if (si101->sv101_type & SV_TYPE_DOMAIN_BAKCTRL)
            {
                if ((dw = NetUserModalsGet (NULL, 2, (LPBYTE *) &umi2)) == 0)
                {
                    if(umi2)
                    {
                        NetGetDCName (NULL, umi2->usrmod2_domain_name, (LPBYTE *) &m_pszDomainController);
                        NetApiBufferFree (umi2);
                    }
                    m_bIsBdc = TRUE;
                }
            }
        }
        m_bCheckedDC = TRUE;

        if (si101)
            NetApiBufferFree (si101);

    }

    return m_bIsBdc;
#else
    return FALSE;
#endif
}

TCHAR* CUtility::PrimaryDCName()
{

    static TCHAR s_tszUnknownDomainName[] = _T("UnknownDCName");
#if !defined(STANDALONE_BUILD)
    if (IsBackupDC())
    {
        if(m_pszDomainController){
            return m_pszDomainController;
        }
        else
        {
            return  s_tszUnknownDomainName;
        }
    }
#endif

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleui\virtreg.h ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1997.
//
//  File:       virtreg.h
//
//  Contents:   Defines the class CVirtualRegistry which manages a
//              virtual registry
//
//  Classes:
//
//  Methods:
//
//  History:    23-Apr-96   BruceMa    Created.
//
//----------------------------------------------------------------------



#ifndef _VIRTREG_H_
#define _VIRTREG_H_

class CVirtualRegistry
{
 public:
    CVirtualRegistry(void);
    ~CVirtualRegistry(void);

    int ReadRegSzNamedValue(HKEY   hRoot,
                          TCHAR *szKeyPath,
                          TCHAR *szValueName,
                          int   *pIndex);

    int ReadRegMultiSzNamedValue(HKEY   hRoot,
                          TCHAR *szKeyPath,
                          TCHAR *szValueName,
                          int   *pIndex);

    int  NewRegSzNamedValue(HKEY    hRoot,
                          TCHAR  *szKeyPath,
                          TCHAR  *szValueName,
                          TCHAR  *szVal,
                          int    *pIndex);

    int  NewRegMultiSzNamedValue(HKEY    hRoot,
                          TCHAR  *szKeyPath,
                          TCHAR  *szValueName,
                          int    *pIndex);

    void ChgRegSzNamedValue(int     nIndex,
                          TCHAR  *szVal);


    int ReadRegDwordNamedValue(HKEY   hRoot,
                             TCHAR *szKeyPath,
                             TCHAR *szValueName,
                             int   *pIndex);

    int NewRegDwordNamedValue(HKEY   hRoot,
                            TCHAR  *szKeyPath,
                            TCHAR  *szValueName,
                            DWORD  dwVal,
                            int   *pIndex);

    void ChgRegDwordNamedValue(int   nIndex,
                             DWORD dwVal);


    int  NewRegSingleACL(HKEY   hRoot,
                       TCHAR  *szKeyPath,
                       TCHAR  *szValueName,
                       SECURITY_DESCRIPTOR *pacl,
                       BOOL   fSelfRelative,
                       int                 *pIndex);

    void ChgRegACL(int                  nIndex,
                 SECURITY_DESCRIPTOR *pacl,
                 BOOL                 fSelfRelative);


    int NewRegKeyACL(HKEY                hKey,
                   HKEY               *phClsids,
                   unsigned            cClsids,
                   TCHAR               *szTitle,
                   SECURITY_DESCRIPTOR *paclOrig,
                   SECURITY_DESCRIPTOR *pacl,
                   BOOL                fSelfRelative,
                   int                 *pIndex);


    int ReadLsaPassword(CLSID &clsid,
                      int   *pIndex);

    int NewLsaPassword(CLSID &clsid,
                     TCHAR  *szPassword,
                     int   *pIndex);

    void ChgLsaPassword(int   nIndex,
                      TCHAR *szPassword);


    int ReadSrvIdentity(TCHAR  *szService,
                      int   *pIndex);

    int NewSrvIdentity(TCHAR  *szService,
                     TCHAR  *szIdentity,
                     int   *pIndex);

    void ChgSrvIdentity(int    nIndex,
                      TCHAR  *szIdentity);

    void MarkForDeletion(int nIndex);
    void MarkHiveForDeletion(int nIndex);

    CDataPacket * GetAt(int nIndex);

    void Remove(int nIndex);

    void RemoveAll(void);

    void Cancel(int nIndex);

    int Apply(int nIndex);

    int ApplyAll(void);

    int Ok(int nIndex);


 private:
    int SearchForRegEntry(HKEY hRoot,
                        TCHAR *szKeyPath,
                        TCHAR *szValueName);

    int SearchForLsaEntry(CLSID appid);

    int SearchForSrvEntry(TCHAR *szServiceName);

    CArray<CDataPacket*, CDataPacket*> m_pkts;
};



extern CVirtualRegistry g_virtreg;

#endif //_VIRTREG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\async\debug\dprintf.c ===
/***
*dprintf.c - print formatted to debug port
*
*	Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines w4dprintf() - print formatted data to debug port
*	defines w4vdprintf() - print formatted output to debug port, get data
*			       from an argument ptr instead of explicit args.
*******************************************************************************/

#include "dprintf.h"		// function prototypes

#define _W4DPRINTF_
#include "printf.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stdclass\stdclass.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:   stdclass.cxx
//
//  Contents:   Implementation for standard base class for factory objects
//
//  Classes:    CStdClassFactory
//
//  Functions:  DllGetClassObject
//              DllCanUnloadNow
//
//  History:    28-May-93 MikeSe    Created
//               2-Jul-93 ShannonC  Split into CStdFactory and CStdClassFactory
//
//--------------------------------------------------------------------------

#include <stdclass.hxx>

//+-------------------------------------------------------------------------
//
//  Global data
//
//--------------------------------------------------------------------------


CStdClassFactory * CStdClassFactory::_gpcfFirst = NULL;
ULONG CStdClassFactory::_gcDllRefs = 0;

//+-------------------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Standard implementation of entrypoint required by binder.
//
//  Arguments:  [rclsid]    -- class id to find
//      	[riid]      -- interface to return
//      	[ppv]       -- output pointer
//
//  Returns:    E_UNEXPECTED if class not found
//      	Otherwise, whatever is returned by the class's QI
//
//  Algorithm:  Searches the linked list for the required class.
//
//  Notes:
//
//--------------------------------------------------------------------------

STDAPI DllGetClassObject (
    REFCLSID rclsid,
    REFIID riid,
    LPVOID FAR* ppv )
{
    HRESULT hr;

    // Note: this doesn't need to be reentrancy protected either
    //  as the linked list is fixed post-init.

    CStdClassFactory * pcfTry = CStdClassFactory::_gpcfFirst;

    while ( pcfTry != NULL &&
            !IsEqualCLSID ( rclsid, pcfTry->_rcls ) )
    {
	pcfTry = pcfTry->_pcfNext;
    }

    if ( pcfTry != NULL )
    {
	// Note: QueryInterface is supposed (required) to do an AddRef
	//  so we don't need to directly.
	hr = pcfTry->QueryInterface ( riid, ppv );
    }
    else
    {
	hr = E_UNEXPECTED;
        *ppv = NULL;
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Function:   DllCanUnloadNow
//
//  Synopsis:   Standard entrypoint required by binder
//
//  Returns:    S_OK if DLL reference count is zero
//      	S_FALSE otherwise
//
//  Notes:
//
//--------------------------------------------------------------------------

STDAPI DllCanUnloadNow ()
{
    return (CStdClassFactory::_gcDllRefs==0)? S_OK: S_FALSE;
}

//+-------------------------------------------------------------------------
//
//  Function:   DllAddRef
//
//  Synopsis:   Allows incrementing the DLL reference count without
//     		AddRef'ing a specific class object.
//
//  Notes:
//
//--------------------------------------------------------------------------

STDAPI_(void) DllAddRef ()
{
    InterlockedIncrement ( (LONG*)&CStdClassFactory::_gcDllRefs );
}

//+-------------------------------------------------------------------------
//
//  Function:   DllRelease
//
//  Synopsis:   Allows decrementing the DLL reference count without
//      	Release'ing a specific class object.
//
//  Notes:
//
//--------------------------------------------------------------------------

STDAPI_(void) DllRelease ()
{
    InterlockedDecrement ( (LONG*)&CStdClassFactory::_gcDllRefs );
}

//+-------------------------------------------------------------------------
//
//  Member:     CStdClassFactory::CStdClassFactory
//
//  Synopsis:   Constructor
//
//  Effects:    Initialises member variables
//          Adds object to global linked list.
//
//  Arguments:  [rcls]  -- class id of derived class
//      	[punk]  -- controlling IUnknown of derived class
//
//  Notes:      Do not make this function inline, even though it appears
//          	trivial, since it is necessary to force the static library
//          	to be pulled in.
//
//--------------------------------------------------------------------------

CStdClassFactory::CStdClassFactory (
	REFCLSID rcls )
    :_rcls(rcls),
     _cRefs(1)      // DaveStr - 11/3/94 - Ole32 requires (_cRefs >= 1)
{
    // Note: the following is not protected against reentrancy, since it
    //  is assumed to take place prior to LibMain/main/WinMain.

    _pcfNext = _gpcfFirst;
    _gpcfFirst = this;
}

//+-------------------------------------------------------------------------
//
//  Method:     CStdClassFactory::LockServer
//
//  Synopsis:   ???
//
//  Derivation: IClassFactory
//
//--------------------------------------------------------------------------

STDMETHODIMP CStdClassFactory::LockServer (
	BOOL fLock )
{
    return S_OK;
}

//+-------------------------------------------------------------------------
//
//  Method:     CStdClassFactory::CreateInstance, public
//
//  Synopsis:   Creates a new instance and returns the requested interface.
//              The returned object has a reference count of 1.
//
//  Derivation: IClassFactory
//
//  Note:       Calls the pure virtual method _CreateInstance, which must
//              be implemented by subclasses.
//
//--------------------------------------------------------------------------

STDMETHODIMP CStdClassFactory::CreateInstance (
	IUnknown* punkOuter,
        REFIID iidInterface,
        void** ppv )
{
    return _CreateInstance ( punkOuter, iidInterface, ppv );
}

//+-------------------------------------------------------------------------
//
//  Method:     CStdClassFactory::QueryInterface, public
//
//  Synopsis:   Query for an interface on the class factory.
//
//  Derivation: IUnknown
//
//--------------------------------------------------------------------------

STDMETHODIMP CStdClassFactory::QueryInterface (
	REFIID iid,
	void * * ppv )
{
    HRESULT hr;

    if ((IsEqualIID(iid, IID_IUnknown)) ||
        (IsEqualIID(iid, IID_IClassFactory)))
    {
        *ppv = (IClassFactory*)this;
        AddRef();
    	hr = S_OK;
    }
    else
    {
        // Make sure we null the return value in case of error
        *ppv = NULL;
        hr = _QueryInterface ( iid, ppv );
    }

    return hr;
}

//+-------------------------------------------------------------------------
//
//  Method:     CStdClassFactory::_QueryInterface, protected
//
//  Synopsis:   Default private QI, normally overridden in subclass
//
//  Derivation: IUnknown
//
//--------------------------------------------------------------------------

STDMETHODIMP CStdClassFactory::_QueryInterface (
	REFIID iid,
	void * * ppv )
{
    return E_NOINTERFACE;
}

//+-------------------------------------------------------------------------
//
//  Method:     CStdClassFactory::AddRef, public
//
//  Synopsis:   Increment DLL and object reference counts
//
//  Derivation: IUnknown
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CStdClassFactory::AddRef ()
{
    InterlockedIncrement ( (LONG*)&_gcDllRefs );
    return (ULONG)InterlockedIncrement ( (LONG*)&_cRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CStdClassFactory::Release, public
//
//  Synopsis:   Decrement DLL and object reference counts
//
//  Derivation: IUnknown
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CStdClassFactory::Release ()
{
    InterlockedDecrement ( (LONG*)&_gcDllRefs );
    return (ULONG)InterlockedDecrement ( (LONG*)&_cRefs );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\async\debug\dprintf.h ===
//+---------------------------------------------------------------------------
//  Copyright (C) 1991, Microsoft Corporation.
//
//  File:       dprintf.h
//
//  Contents:   Debugging output routine function prototypes
//
//  Functions:  w4printf
//              w4vprintf
//              w4dprintf
//              w4vdprintf
//              
//  History:    18-Oct-91   vich        Created
//      
//----------------------------------------------------------------------------

#include <stdarg.h>

#ifdef __cplusplus
extern "C" {
#endif

#ifdef WIN32
int _cdecl w4printf(const char *format, ...);
int _cdecl w4vprintf(const char *format, va_list arglist);
#endif

int _cdecl w4dprintf(const char *format, ...);
int _cdecl w4vdprintf(const char *format, va_list arglist);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\async\chicago.inc ===
!IF 0

Copyright (c) 1989-1999  Microsoft Corporation

Module Name:

    chicago.inc

!ENDIF

# This is the global include file for the daytona version of CairOLE.
# It is included by all project sources files.

C_DEFINES=    \
              $(C_DEFINES)          \
              -DFLAT                \
              -DWIN32=200           \
              -D_CHICAGO_=200       \
              -DINC_OLE2            \
              -DNOEXCEPTIONS        \
              -DCAIROLE_DOWNLEVEL   \
              -DSTRICT              \
              -DNEWPROPS            \
              $(TRACELOG)

#  DECLSPEC_IMPORT control (see objbase.h)
!if "$(MINORCOMP)"=="com" || "$(MINORCOMP)"=="stg" || "$(MINORCOMP)"=="ole232"
C_DEFINES=    \
              $(C_DEFINES)          \
              -D_OLE32_
!endif

MSC_WARNING_LEVEL=/W3 /WX

CHICAGO_PRODUCT=1

NTLIBCPATH=$(_WINBASE)\Dev\Tools\Lego\Lib

GPCH_BUILD=chicago
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleui\chicago\virtreg.cpp ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1994.
//
//  File:       virtreg.cpp
//
//  Contents:   Implements the class CVirtualRegistry which manages a
//              virtual registry
//
//  Classes:    
//
//  Methods:    CVirtualRegistry::CVirtualRegistry
//              CVirtualRegistry::~CVirtualRegistry
//              CVirtualRegistry::ReadRegSzNamedValue
//              CVirtualRegistry::NewRegSzNamedValue
//              CVirtualRegistry::ChgRegSzNamedValue
//              CVirtualRegistry::ReadRegDwordNamedValue
//              CVirtualRegistry::NewRegDwordNamedValue
//              CVirtualRegistry::ChgRegDwordNamedValue
//              CVirtualRegistry::NewRegSingleACL
//              CVirtualRegistry::ChgRegACL
//              CVirtualRegistry::NewRegKeyACL
//              CVirtualRegistry::ReadLsaPassword
//              CVirtualRegistry::NewLsaPassword
//              CVirtualRegistry::ChgLsaPassword
//              CVirtualRegistry::ReadSrvIdentity
//              CVirtualRegistry::NewSrvIdentity
//              CVirtualRegistry::ChgSrvIdentity
//              CVirtualRegistry::MarkForDeletion
//              CVirtualRegistry::GetAt
//              CVirtualRegistry::Remove
//              CVirtualRegistry::Cancel
//              CVirtualRegistry::Apply
//              CVirtualRegistry::ApplyAll
//              CVirtualRegistry::Ok
//              CVirtualRegistry::SearchForRegEntry
//              CVirtualRegistry::SearchForLsaEntry
//              CVirtualRegistry::SearchForSrvEntry
//
//  History:    23-Apr-96   BruceMa    Created.
//              15-Dec-96   RonanS      Tidied up to remove memory leaks
//                                      Use array of pointers to avoid bitwise copy
//
//----------------------------------------------------------------------


#include "stdafx.h"
#include "afxtempl.h"
#include "assert.h"
extern "C"
{
#include "ntlsa.h"
}
#include "winsvc.h"
#include "types.h"
#include "datapkt.h"
extern "C"
{
#include <getuser.h>
}
#include "util.h"
#include "virtreg.h"
#include "tchar.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

CVirtualRegistry::CVirtualRegistry(void)
{
    m_pkts.SetSize(0, 8);
}



CVirtualRegistry::~CVirtualRegistry(void)
{
    // ronans - remove any remaining items
    RemoveAll();
}




// Read a named string value from the registry and cache it
int CVirtualRegistry::ReadRegSzNamedValue(HKEY   hRoot,
                                          TCHAR *szKeyPath, 
                                          TCHAR *szValueName,
                                          int   *pIndex)
{
    int    err;
    HKEY   hKey;
    ULONG  lSize;
    DWORD  dwType;
    TCHAR *szVal = new TCHAR[MAX_PATH];

    // Check if we already have an entry for this
    *pIndex = SearchForRegEntry(hRoot, szKeyPath, szValueName);
    if (*pIndex >= 0)
    {
        CDataPacket *pCdp = GetAt(*pIndex);
        ASSERT(pCdp);                           // should always be non null
        if (pCdp -> fDelete) 
        {
            *pIndex = -1;
            delete szVal;
            return ERROR_FILE_NOT_FOUND;
        }
        else
        {
            delete szVal;
            return ERROR_SUCCESS;
        }
    }
    
    // Open the referenced key
    if ((err = RegOpenKeyEx(hRoot, szKeyPath, 0, KEY_ALL_ACCESS, &hKey)) != ERROR_SUCCESS)
    {
        g_util.CkForAccessDenied(err);
        delete szVal;
        return err;
    }
    
    // Attempt to read the named value
    lSize = MAX_PATH * sizeof(TCHAR);
    if ((err = RegQueryValueEx(hKey, szValueName, NULL, &dwType, (BYTE *) szVal,
                        &lSize))
        != ERROR_SUCCESS)
    {  
        g_util.CkForAccessDenied(err);
        if (hKey != hRoot)
        {
            RegCloseKey(hKey);
        }
        delete szVal;
        return err;
    }

    // Build a data packet
    if (dwType == REG_SZ)
    {
        CDataPacket * pNewPacket = new CDataPacket(hRoot, szKeyPath, szValueName, szVal);
        ASSERT(pNewPacket);

        if (!pNewPacket)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }

        *pIndex = m_pkts.Add(pNewPacket);
        pNewPacket->fDirty = FALSE;
        delete szVal;
        return ERROR_SUCCESS;
    }
    else
    {
        delete szVal;
        return ERROR_BAD_TOKEN_TYPE;
    }
} 


int  CVirtualRegistry::NewRegSzNamedValue(HKEY   hRoot,
                                          TCHAR  *szKeyPath,
                                          TCHAR  *szValueName,
                                          TCHAR  *szVal,
                                          int    *pIndex)
{
    // It may be in the virtual registry but marked for deletion
    *pIndex = SearchForRegEntry(hRoot, szKeyPath, szValueName);
    if (*pIndex >= 0)
    {
        CDataPacket *pCdp = GetAt(*pIndex);
        pCdp->MarkForDeletion(FALSE);
        pCdp->ChgSzValue(szVal);
        return ERROR_SUCCESS;
    }
    
    // Build a data packet and add it
    CDataPacket * pNewPacket = new CDataPacket(hRoot, szKeyPath, szValueName, szVal);
    ASSERT(pNewPacket);
    if (!pNewPacket)
        return ERROR_NOT_ENOUGH_MEMORY;
    *pIndex = m_pkts.Add(pNewPacket);
    
    return ERROR_SUCCESS;
}



void CVirtualRegistry::ChgRegSzNamedValue(int nIndex, TCHAR  *szVal)
{
    CDataPacket * pCdp = m_pkts.ElementAt(nIndex);
    pCdp->ChgSzValue(szVal);
    pCdp->fDirty = TRUE;
}



// Read a named DWORD value from the registry
int CVirtualRegistry::ReadRegDwordNamedValue(HKEY   hRoot,
                                             TCHAR *szKeyPath, 
                                             TCHAR *szValueName,
                                             int   *pIndex)
{
	int   err;
    HKEY  hKey;
    ULONG lSize;
    DWORD dwType;
    DWORD dwVal;

    // Check if we already have an entry for this
    *pIndex = SearchForRegEntry(hRoot, szKeyPath, szValueName);
    if (*pIndex >= 0)
    {
        return ERROR_SUCCESS;
    }
    
    // Open the referenced key
    if ((err = RegOpenKeyEx(hRoot, szKeyPath, 0, KEY_ALL_ACCESS, &hKey)) != ERROR_SUCCESS)
    {  
        g_util.CkForAccessDenied(err);
        return err;
    }
    
    // Attempt to read the named value
    lSize = sizeof(DWORD);
   if ((err = RegQueryValueEx(hKey, szValueName, NULL, &dwType, (BYTE *) &dwVal,
                       &lSize))
        != ERROR_SUCCESS)
    {	
        g_util.CkForAccessDenied(err);
        if (hKey != hRoot)
        {
            RegCloseKey(hKey);
        }
        return err;
    }
    
    // Close the registry key
    if (hKey != hRoot)
    {
        RegCloseKey(hKey);
    }

    // Build a data packet
    if (dwType == REG_DWORD)
    {
        CDataPacket * pNewPacket = new CDataPacket(hRoot, szKeyPath, szValueName, dwVal);
        ASSERT(pNewPacket);
        if (!pNewPacket)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        *pIndex = m_pkts.Add(pNewPacket);
        pNewPacket->fDirty = FALSE;

        return ERROR_SUCCESS;
    }
    else
    {
        return ERROR_BAD_TOKEN_TYPE;
    }
}



int  CVirtualRegistry::NewRegDwordNamedValue(HKEY   hRoot,
                                             TCHAR  *szKeyPath,
                                             TCHAR  *szValueName,
                                             DWORD  dwVal,
                                             int   *pIndex)
{
    // It may be in the virtual registry but marked for deletion
    *pIndex = SearchForRegEntry(hRoot, szKeyPath, szValueName);
    if (*pIndex >= 0)
    {
        CDataPacket *pCdp = GetAt(*pIndex);
        pCdp->MarkForDeletion(FALSE);
        pCdp -> pkt.nvdw.dwValue = dwVal;
        return ERROR_SUCCESS;
    }
    
    // Build a data packet and add it
    CDataPacket * pNewPacket = new CDataPacket(hRoot, szKeyPath, szValueName, dwVal);
    ASSERT(pNewPacket);

    if (!pNewPacket)
        return ERROR_NOT_ENOUGH_MEMORY;
    *pIndex = m_pkts.Add(pNewPacket);
    pNewPacket->fDirty = FALSE;
    return ERROR_SUCCESS;
}


void CVirtualRegistry::ChgRegDwordNamedValue(int nIndex, DWORD dwVal)
{
    CDataPacket *pCdp = m_pkts.ElementAt(nIndex);

    pCdp -> pkt.nvdw.dwValue = dwVal; 
    pCdp -> fDirty = TRUE;
}


int  CVirtualRegistry::NewRegSingleACL(HKEY   hRoot,
                                       TCHAR  *szKeyPath,
                                       TCHAR  *szValueName,
                                       SECURITY_DESCRIPTOR *pacl,
                                       BOOL   fSelfRelative,
                                       int                 *pIndex)
{
    // Build a data packet and add it
    CDataPacket * pNewPacket = new CDataPacket(hRoot, szKeyPath, szValueName, pacl, fSelfRelative);
    ASSERT(pNewPacket);

    if (!pNewPacket)
        return ERROR_NOT_ENOUGH_MEMORY;

    *pIndex = m_pkts.Add(pNewPacket);
    return ERROR_SUCCESS;
}


void CVirtualRegistry::ChgRegACL(int                  nIndex,
                                 SECURITY_DESCRIPTOR *pacl,
                                 BOOL                 fSelfRelative)
{
    CDataPacket *pCdp = m_pkts.ElementAt(nIndex);

    pCdp -> ChgACL(pacl, fSelfRelative);
    pCdp -> fDirty = TRUE;
}



int  CVirtualRegistry::NewRegKeyACL(HKEY                hKey,
                                    HKEY               *phClsids,
                                    unsigned            cClsids,
                                    TCHAR               *szTitle,
                                    SECURITY_DESCRIPTOR *paclOrig,
                                    SECURITY_DESCRIPTOR *pacl,
                                    BOOL                fSelfRelative,
                                    int                 *pIndex)
{
    // Build a data packet and add it
    CDataPacket * pNewPacket = new CDataPacket(hKey, phClsids, cClsids, szTitle, paclOrig, pacl, fSelfRelative);
    ASSERT(pNewPacket);
    if (!pNewPacket)
        return ERROR_NOT_ENOUGH_MEMORY;
    *pIndex = m_pkts.Add(pNewPacket);
    return ERROR_SUCCESS;
}



int CVirtualRegistry::ReadLsaPassword(CLSID &clsid,
                                      int   *pIndex)
{
#ifdef UNICODE
    LSA_OBJECT_ATTRIBUTES sObjAttributes;
    HANDLE                hPolicy = NULL;
    LSA_UNICODE_STRING    sKey;
    TCHAR                 szKey[GUIDSTR_MAX + 5];
    PLSA_UNICODE_STRING   psPassword;


    // Check if we already have an entry fo this
    *pIndex = SearchForLsaEntry(clsid);
    if (*pIndex >= 0)
    {
        return ERROR_SUCCESS;
    }
    
    // Formulate the access key
    _tcscpy(szKey, TEXT("SCM:"));
    g_util.StringFromGUID(clsid, &szKey[4], GUIDSTR_MAX);
    szKey[GUIDSTR_MAX + 4] = TEXT('\0');
    
    // UNICODE_STRING length fields are in bytes and include the NULL
    // terminator
    sKey.Length              = (_tcslen(szKey) + 1) * sizeof(TCHAR);
    sKey.MaximumLength       = (GUIDSTR_MAX + 5) * sizeof(TCHAR);
    sKey.Buffer              = szKey;
    
    // Open the local security policy
    InitializeObjectAttributes(&sObjAttributes, NULL, 0L, NULL, NULL);
    if (!NT_SUCCESS(LsaOpenPolicy(NULL, &sObjAttributes,
                                  POLICY_GET_PRIVATE_INFORMATION, &hPolicy)))
    {
        return GetLastError();
    }
    
    // Read the user's password
    if (!NT_SUCCESS(LsaRetrievePrivateData(hPolicy, &sKey, &psPassword)))
    {
        LsaClose(hPolicy);
        return GetLastError();
    }
    
    // Close the policy handle, we're done with it now.
    LsaClose(hPolicy);

    // Build a data packet
    CDataPacket * pNewPacket = new CDataPacket(psPassword->Buffer, clsid);
    ASSERT(pNewPacket);
    if (!pNewPacket)
        return ERROR_NOT_ENOUGH_MEMORY;
    pNewPacket->fDirty = FALSE;
    *pIndex = m_pkts.Add(pNewPacket);
#endif
    
    return ERROR_SUCCESS;
}



int  CVirtualRegistry::NewLsaPassword(CLSID &clsid,
                                      TCHAR  *szPassword,
                                      int   *pIndex)
{
    // Build a data packet and add it
    CDataPacket * pNewPacket = new CDataPacket(szPassword, clsid);
    ASSERT(pNewPacket);
    if (!pNewPacket)
        return ERROR_NOT_ENOUGH_MEMORY;
    *pIndex = m_pkts.Add(pNewPacket);
    return ERROR_SUCCESS;
}



void CVirtualRegistry::ChgLsaPassword(int   nIndex,
                                      TCHAR *szPassword)
{
    CDataPacket *pCdp = m_pkts.ElementAt(nIndex);

    delete pCdp -> pkt.pw.szPassword;
    pCdp -> pkt.pw.szPassword = new TCHAR[_tcslen(szPassword) + 1];
    _tcscpy(pCdp -> pkt.pw.szPassword, szPassword);	
	pCdp -> fDirty = TRUE;
}



int CVirtualRegistry::ReadSrvIdentity(TCHAR *szService,
                                      int   *pIndex)
{
    SC_HANDLE            hSCManager;
    SC_HANDLE            hService;
    QUERY_SERVICE_CONFIG sServiceQueryConfig;
    DWORD                dwSize;
    

    // Check if we already have an entry fo this
    *pIndex = SearchForSrvEntry(szService);
    if (*pIndex >= 0)
    {
        return ERROR_SUCCESS;
    }
    
    // Open the service control manager
    if (hSCManager = OpenSCManager(NULL, NULL, GENERIC_READ))
    {
        // Open a handle to the requested service
        if (hService = OpenService(hSCManager, szService, GENERIC_READ))
        {
            // Close the service manager's database
            CloseServiceHandle(hSCManager);

            // Query the service
            if (QueryServiceConfig(hService, &sServiceQueryConfig,
                                   sizeof(SERVICE_QUERY_CONFIG), &dwSize))
            {
                // Build a data packet
                CDataPacket * pNewPacket = new CDataPacket(szService, sServiceQueryConfig.lpServiceStartName);
                ASSERT(pNewPacket);
                if (!pNewPacket)
                    return ERROR_NOT_ENOUGH_MEMORY;
                pNewPacket->fDirty = FALSE;
                *pIndex = m_pkts.Add(pNewPacket);

                // Return success
                CloseServiceHandle(hSCManager);
                CloseServiceHandle(hService);
                return ERROR_SUCCESS;
            }
        }
        CloseServiceHandle(hSCManager);
    }

    return GetLastError();
}



int  CVirtualRegistry::NewSrvIdentity(TCHAR  *szService,
                                      TCHAR  *szIdentity,
                                      int   *pIndex)
{
    // Build a data packet and add it
    CDataPacket * pNewPacket = new CDataPacket(szService, szIdentity);
    ASSERT(pNewPacket);
    if (!pNewPacket)
        return ERROR_NOT_ENOUGH_MEMORY;
    *pIndex = m_pkts.Add(pNewPacket);
    return ERROR_SUCCESS;
} 



void CVirtualRegistry::ChgSrvIdentity(int    nIndex,
                                      TCHAR  *szIdentity)
{
    CDataPacket *pCdp = m_pkts.ElementAt(nIndex);

    delete pCdp -> pkt.si.szIdentity;
    pCdp -> pkt.si.szIdentity = new TCHAR[_tcslen(szIdentity) + 1];
    _tcscpy(pCdp -> pkt.si.szIdentity, szIdentity);
	pCdp -> fDirty = TRUE;
}



void CVirtualRegistry::MarkForDeletion(int nIndex)
{
    CDataPacket *pCdp = GetAt(nIndex);
    pCdp -> fDelete = TRUE;
    pCdp -> fDirty = TRUE;
}




CDataPacket * CVirtualRegistry::GetAt(int nIndex)
{
    return m_pkts.ElementAt(nIndex);
}




void CVirtualRegistry::Remove(int nIndex)
{
    CDataPacket * pCdp = GetAt(nIndex);

    // ronans - must always destroy even if packet has not been marked dirty
    if (pCdp)
        delete pCdp;

    // overwrite with empty data packet
    m_pkts.SetAt(nIndex, new CDataPacket);
}




void CVirtualRegistry::RemoveAll(void)
{
    int nSize = m_pkts.GetSize();
    for (int k = 0; k < nSize; k++)
        Remove(k);
    
    m_pkts.RemoveAll();
}




void CVirtualRegistry::Cancel(int nIndex)
{
    int nSize = m_pkts.GetSize();

    for (int k = nIndex; k < nSize; k++)
    { 
        m_pkts.SetAt(nIndex, new CDataPacket);
    }
}



int  CVirtualRegistry::Apply(int nIndex)
{
    int err = ERROR_SUCCESS;
    int nSize = m_pkts.GetSize();
    CDataPacket *pCdp = m_pkts.ElementAt(nIndex);

    if (pCdp -> fDirty)
    {
        switch (pCdp -> tagType)
        {
        case Empty:
            break;
            
        case NamedValueSz:
            if (pCdp -> fDelete)
            {
                g_util.DeleteRegValue(pCdp -> pkt.nvsz.hRoot,
                                      pCdp -> pkt.nvsz.szKeyPath,
                                      pCdp -> pkt.nvsz.szValueName);
            }
            else
            {
                err = g_util.WriteRegSzNamedValue(pCdp -> pkt.nvsz.hRoot,
                                                  pCdp -> pkt.nvsz.szKeyPath,
                                                  pCdp -> pkt.nvsz.szValueName,
                                                  pCdp -> pkt.nvsz.szValue,
                                                  _tcslen(pCdp -> pkt.nvsz.szValue) + 1);
            }
            break;
            
        case NamedValueDword:
            if (pCdp -> fDelete)
            {
                g_util.DeleteRegValue(pCdp -> pkt.nvdw.hRoot,
                                      pCdp -> pkt.nvdw.szKeyPath,
                                      pCdp -> pkt.nvdw.szValueName);
            }
            else
            {
                err = g_util.WriteRegDwordNamedValue(pCdp -> pkt.nvdw.hRoot,
                                                     pCdp -> pkt.nvdw.szKeyPath,
                                                     pCdp -> pkt.nvdw.szValueName,
                                                     pCdp -> pkt.nvdw.dwValue);
            }
            break;
            
        case SingleACL:
            if (pCdp -> fDelete)
            {
                HKEY hKey;

                if (RegOpenKeyEx(pCdp -> pkt.acl.hRoot,
                                 pCdp -> pkt.acl.szKeyPath,
                                 0,
                                 KEY_ALL_ACCESS,
                                 &hKey) == ERROR_SUCCESS)
                {
                    RegDeleteValue(hKey, pCdp -> pkt.acl.szValueName);
                    RegCloseKey(hKey);
                }
            }
            else
            {
                err = g_util.WriteRegSingleACL(pCdp -> pkt.acl.hRoot,
                                               pCdp -> pkt.acl.szKeyPath,
                                               pCdp -> pkt.acl.szValueName,
                                               pCdp -> pkt.acl.pSec);
            }
            break;
            
        case RegKeyACL:
            err = g_util.WriteRegKeyACL(pCdp -> pkt.racl.hKey,
                                        pCdp -> pkt.racl.phClsids,
                                        pCdp -> pkt.racl.cClsids,
                                        pCdp -> pkt.racl.pSec,
                                        pCdp -> pkt.racl.pSecOrig);
            break;
            
        case Password:
            err = g_util.WriteLsaPassword(pCdp -> pkt.pw.appid,
                                          pCdp -> pkt.pw.szPassword);
            break;
            
        case ServiceIdentity:
            err = g_util.WriteSrvIdentity(pCdp -> pkt.si.szServiceName,
                                          pCdp -> pkt.si.szIdentity);
            break;
        }
    }

    // Cleanup work
    if (err == ERROR_SUCCESS)
    {
        pCdp -> fDirty = FALSE;
    }
    else
    {
        if (err == ERROR_ACCESS_DENIED)
        {
            g_util.CkForAccessDenied(ERROR_ACCESS_DENIED);
        }
        else
        {
            g_util.PostErrorMessage();
        }
    }
    return err;;
}







int  CVirtualRegistry::ApplyAll(void)
{
    int nSize = m_pkts.GetSize();

    // Persist all non-empty data packets
    for (int k = 0; k < nSize; k++)
    {
        Apply(k);
    }

    return ERROR_SUCCESS;
}




int  CVirtualRegistry::Ok(int nIndex)
{
    return 0;
}




int CVirtualRegistry::SearchForRegEntry(HKEY hRoot,
                                        TCHAR *szKeyPath,
                                        TCHAR *szValueName)
{
    int nSize = m_pkts.GetSize();

    for (int k = 0; k < nSize; k++)
    {
        CDataPacket *pCdp = GetAt(k);
        if ((pCdp -> tagType == NamedValueSz                        &&
             pCdp -> pkt.nvsz.hRoot == hRoot                        &&
             (_tcscmp(pCdp -> pkt.nvsz.szKeyPath, szKeyPath) == 0)  &&
             (_tcscmp(pCdp -> pkt.nvsz.szValueName, szValueName) == 0))    ||
            (pCdp -> tagType == NamedValueDword                     &&
             pCdp -> pkt.nvdw.hRoot == hRoot                        &&
             (_tcscmp(pCdp -> pkt.nvdw.szKeyPath, szKeyPath) == 0)  &&
             (_tcscmp(pCdp -> pkt.nvdw.szValueName, szValueName) == 0)))
        {
            return k;
        }
    }

    return -1;
}




int CVirtualRegistry::SearchForLsaEntry(CLSID appid)
{
    int nSize = m_pkts.GetSize();

    for (int k = 0; k < nSize; k++)
    {
        CDataPacket *pCdp = GetAt(k);
        if (pCdp -> tagType == Password  &&
            g_util.IsEqualGuid(pCdp -> pkt.pw.appid, appid))
        {
            return k;
        }
    }

    return -1;
}




int CVirtualRegistry::SearchForSrvEntry(TCHAR *szServiceName)
{
    int nSize = m_pkts.GetSize();

    for (int k = 0; k < nSize; k++)
    {
        CDataPacket *pCdp = GetAt(k);
        if (pCdp -> tagType == ServiceIdentity                &&
            (_tcscmp(pCdp -> pkt.si.szServiceName, szServiceName)))
        {
            return k;
        }
    }

    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\oleui\chicago\util.cpp ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1994.
//
//  File:       util.cpp
//
//  Contents:   Implements the utility class CUtility
//
//  Classes:
//
//  Methods:    CUtility::CkForAccessDenied
//              CUtility::CkAccessRights
//              CUtility::PostErrorMessage (x2)
//              CUtility::WriteRegSzNamedValue
//              CUtility::WriteRegDwordNamedValue
//              CUtility::WriteRegSingleACL
//              CUtility::WriteRegKeyACL
//              CUtility::WriteRegKeyACL2
//              CUtility::WriteLsaPassword
//              CUtility::DeleteRegKey
//              CUtility::DeleteRegValue
//              CUtility::WriteSrvIdentity
//              CUtility::ACLEditor
//              CUtility::ACLEditor2
//              CUtility::InvokeUserBrowser
//              CUtility::InvokeMachineBrowser
//              CUtility::StringFromGUID
//              CUtility::IsEqualGuid
//              CUtility::AdjustPrivilege
//              CUtility::VerifyRemoteMachine
//              CUtility::RetrieveUserPassword
//              CUtility::StoreUserPassword
//              CUtility::LookupProcessInfo
//              CUtility::MakeSecDesc
//              CUtility::CheckSDForCOM_RIGHTS_EXECUTE
//              CUtility::ChangeService
//              CUtility::UpdateDCOMInfo(void)
//              CUtility::FixHelp
//              CUtility::CopySD
//              CUtility::SetInheritanceFlags
//
// Functons:    callBackFunc
//              ControlFixProc
//
//  History:    23-Apr-96   BruceMa    Created.
//
//----------------------------------------------------------------------


#include "stdafx.h"
#include "assert.h"
#include "resource.h"
#include "afxtempl.h"
#include "types.h"
#include "datapkt.h"
#include "clspsht.h"

extern "C"
{
#include <getuser.h>
}

#include "util.h"
#include "virtreg.h"

extern "C"
{
#include <ntlsa.h>
#include <ntseapi.h>
#include <sedapi.h>
#include <winnetwk.h>
#include <uiexport.h>
#include <rpc.h>
#include <rpcdce.h>
}


extern "C"
{
int _stdcall UpdateActivationSettings(HANDLE hRpc, RPC_STATUS *status);
}


static const BYTE GuidMap[] = { 3, 2, 1, 0, '-', 5, 4, '-', 7, 6, '-',
                                8, 9, '-', 10, 11, 12, 13, 14, 15 };

static const TCHAR szDigits[] = TEXT("0123456789ABCDEF");

static const DWORD SIZEOF_SID        = 44;

// This leaves space for 2 access allowed ACEs in the ACL.
const DWORD SIZEOF_ACL        = sizeof(ACL) + 2 * sizeof(ACCESS_ALLOWED_ACE) +
                                2 * SIZEOF_SID;

static const DWORD SIZEOF_TOKEN_USER = sizeof(TOKEN_USER) + SIZEOF_SID;

static const SID   LOCAL_SYSTEM_SID  = {SID_REVISION, 1, {0,0,0,0,0,5},
                                 SECURITY_LOCAL_SYSTEM_RID };

static const DWORD NUM_SEC_PKG       = 8;




// These are required for the method CUtility::UpdateDCOMInfo which invokes
// an RPC proxy which expects the following


extern "C" void * _stdcall MIDL_user_allocate(size_t size)
{
    return new BYTE[size];
}


extern "C" void _stdcall MIDL_user_free(void *p)
{
    delete p;
}






CUtility::CUtility(void)
{
    m_hRpc = NULL;
}



CUtility::~CUtility(void)
{
    if (m_hRpc != NULL)
    {
        RpcBindingFree(&m_hRpc);
    }
}



void CUtility::CkForAccessDenied(int err)
{
    if (err == ERROR_ACCESS_DENIED)
    {
        CString sMsg;
        CString sCaption;
        sMsg.LoadString(IDS_ACCESSDENIED);
        sCaption.LoadString(IDS_SYSTEMMESSAGE);
        MessageBox(NULL, sMsg, sCaption, MB_OK);
    }
}



BOOL CUtility::CkAccessRights(HKEY hRoot, TCHAR *szKeyPath)
{
    int                  err;
    HKEY                 hKey;
    BYTE                 aSid[256];
    DWORD                cbSid = 256;
    PSECURITY_DESCRIPTOR pSid = (PSECURITY_DESCRIPTOR) aSid;
    BOOL                 fFreePsid = FALSE;


    // Open the specified key
    err = RegOpenKeyEx(hRoot, szKeyPath, 0, KEY_ALL_ACCESS, &hKey);

    // The key may not exist
    if (err == ERROR_FILE_NOT_FOUND)
    {
        return TRUE;
    }

    if (err == ERROR_SUCCESS)
    {
        // Fetch the security descriptor on this key
        err = RegGetKeySecurity(hKey,
                                OWNER_SECURITY_INFORMATION |
                                GROUP_SECURITY_INFORMATION |
                                DACL_SECURITY_INFORMATION,
                                (PSECURITY_DESCRIPTOR) aSid,
                                &cbSid);
        if (err == ERROR_INSUFFICIENT_BUFFER)	
        {
            pSid = (PSECURITY_DESCRIPTOR) malloc(cbSid);
            if (pSid == NULL)
            {
                return FALSE;
            }
            fFreePsid = TRUE;
            err = RegGetKeySecurity(hKey,
                                    OWNER_SECURITY_INFORMATION |
                                    GROUP_SECURITY_INFORMATION |
                                    DACL_SECURITY_INFORMATION,
                                    (PSECURITY_DESCRIPTOR) pSid,
                                    &cbSid);
        }

        // We've read the security descriptor - now try to write it
        if (err == ERROR_SUCCESS)
        {
            err = RegSetKeySecurity(hKey,
                                    OWNER_SECURITY_INFORMATION |
                                    GROUP_SECURITY_INFORMATION |
                                    DACL_SECURITY_INFORMATION,
                                    pSid);
        }

        if (hKey != hRoot)
        {
            RegCloseKey(hKey);
        }
    }

    return err == ERROR_SUCCESS ? TRUE : FALSE;
}






void CUtility::PostErrorMessage(void)
{
    TCHAR szMessage[256];

    FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, GetLastError(),
                  0, szMessage, sizeof( szMessage ), NULL);
    CString sCaption;
    sCaption.LoadString(IDS_SYSTEMMESSAGE);
    MessageBox(NULL, szMessage, sCaption, MB_OK);
}






void CUtility::PostErrorMessage(int err)
{
    TCHAR szMessage[256];

    FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, err,
                  0, szMessage, sizeof( szMessage ), NULL);
    CString sCaption;
    sCaption.LoadString(IDS_SYSTEMMESSAGE);
    MessageBox(NULL, szMessage, sCaption, MB_OK);
}




// Write a named string value to the registry
int CUtility::WriteRegSzNamedValue(HKEY   hRoot,
                                   TCHAR *szKeyPath,
                                   TCHAR *szValueName,
                                   TCHAR *szVal,
                                   DWORD  dwSize)
{
    int  err;
    HKEY hKey;
    ULONG lSize;

    // Open the key
    if ((err = RegOpenKeyEx(hRoot, szKeyPath, 0, KEY_ALL_ACCESS, &hKey)) != ERROR_SUCCESS)
    {
        return err;
    }

    // Attempt to write the named value
    lSize = _tcslen(szVal) + 1;
    if ((err = RegSetValueEx(hKey, szValueName, NULL, REG_SZ, (BYTE *) szVal,
                      lSize*sizeof(TCHAR) ))
        != ERROR_SUCCESS)
    {
        if (hKey != hRoot)
        {
            RegCloseKey(hKey);
        }
        return err;
    }

    // Successful
    if (hKey != hRoot)
    {
        RegCloseKey(hKey);
    }
    return ERROR_SUCCESS;
}





// Write a named DWORD value to the registry
int CUtility::WriteRegDwordNamedValue(HKEY   hRoot,
                                      TCHAR *szKeyPath,
                                      TCHAR *szValueName,
                                      DWORD  dwVal)
{
    int  err;
    HKEY hKey;

    // Open the key
    if ((err = RegOpenKeyEx(hRoot, szKeyPath, 0, KEY_ALL_ACCESS, &hKey))
        != ERROR_SUCCESS)
    {
        return err;
    }

    // Attempt to write the named value
    if (RegSetValueEx(hKey, szValueName, NULL, REG_DWORD, (BYTE *) &dwVal,
                      sizeof(DWORD))
        != ERROR_SUCCESS)
    {
        if (hKey != hRoot)
        {
            RegCloseKey(hKey);
        }
        return GetLastError();
    }

    // Return the value			
    if (hKey != hRoot)
    {
        RegCloseKey(hKey);
    }

    return ERROR_SUCCESS;
}
	


// Write an ACL as a registry named value
int CUtility::WriteRegSingleACL(HKEY   hRoot,
                                TCHAR *szKeyPath,
                                TCHAR *szValueName,
                                PSECURITY_DESCRIPTOR pSec)
{
    int                   err;
    HKEY                  hKey = hRoot;
    PSrSecurityDescriptor pSrSec;
    PSrAcl                pDacl;

    // Open the key unless the key path is NULL
    if (szKeyPath)
    {
        if ((err = RegOpenKeyEx(hRoot, szKeyPath, 0, KEY_ALL_ACCESS, &hKey))
            != ERROR_SUCCESS)
        {
            return err;
        }
    }

    // If there are no ACE's and this is DefaultAccessPermission, then
    // interpret this as activator access only which we indicate by
    // removing the named value
    pSrSec = (PSrSecurityDescriptor) pSec;
    pDacl = (PSrAcl) (((BYTE *) pSec) + (pSrSec->Dacl));
    if (_tcscmp(szValueName, TEXT("DefaultAccessPermission")) == 0  &&
        pDacl->AceCount == 0)
    {
        RegDeleteValue(hKey, szValueName);
    }

    // Else write the ACL simply as a REG_SZ value
    else
    {
        err = RegSetValueEx(hKey,
                            szValueName,
                            0,
                            REG_BINARY,
                            (BYTE *) pSec,
#if 0
                            RtlLengthSecurityDescriptor(pSec));
#else
                            10);
#endif
    }

    if (hKey != hRoot)
    {
        RegCloseKey(hKey);
    }

    return err;
}



// Write an ACL on a registry key
int CUtility::WriteRegKeyACL(HKEY   hKey,
                             HKEY  *phClsids,
                             unsigned cClsids,
                             PSECURITY_DESCRIPTOR pSec,
                             PSECURITY_DESCRIPTOR pSecOrig)
{
    int err;

    // The logic is somewhat different depending on whether we're starting
    // with HKEY_CLASSES_ROOT or a specific AppID
    if (hKey == HKEY_CLASSES_ROOT)
    {
        return WriteRegKeyACL2(hKey, hKey, pSec, pSecOrig);
    }

    // It's a specific AppID
    else
    {
        // Write the security on the AppID key
        if (err = RegSetKeySecurity(hKey,
                                    OWNER_SECURITY_INFORMATION |
                                    GROUP_SECURITY_INFORMATION |
                                    DACL_SECURITY_INFORMATION,
                                    pSec) != ERROR_SUCCESS)
        {
            return err;
        }

        // Iterate over the CLSID's covered by this AppID and recursively
        // write security on them and their subkeys
        for (UINT k = 0; k < cClsids; k++)
        {
            if (err = WriteRegKeyACL2(phClsids[k], phClsids[k], pSec, pSecOrig)
                != ERROR_SUCCESS)
            {
                return err;
            }
        }
    }
    return ERROR_SUCCESS;
}



// Write an ACL recursively on a registry key provided the current
// security descriptor on the key is the same as the passed in
// original security descriptor
int CUtility::WriteRegKeyACL2(HKEY                 hRoot,
                              HKEY                 hKey,
                              PSECURITY_DESCRIPTOR pSec,
                              PSECURITY_DESCRIPTOR pSecOrig)
{
    BYTE                 aCurrSD[256];
    DWORD                cbCurrSD = 256;
    PSECURITY_DESCRIPTOR pCurrSD = (PSECURITY_DESCRIPTOR) aCurrSD;
    BOOL                 fFreePCurrSD = FALSE;
    int                  err;
    BOOL                 fProceed;

    // Read the current security descriptor on this key
    err = RegGetKeySecurity(hKey,
                            OWNER_SECURITY_INFORMATION |
                            GROUP_SECURITY_INFORMATION |
                            DACL_SECURITY_INFORMATION,
                            aCurrSD,
                            &cbCurrSD);
    if (err == ERROR_MORE_DATA  ||  err == ERROR_INSUFFICIENT_BUFFER)
    {
        pCurrSD = (SECURITY_DESCRIPTOR *) new BYTE[cbCurrSD];
        if (pCurrSD == NULL)
        {
            return ERROR_NOT_ENOUGH_MEMORY;
        }
        fFreePCurrSD = TRUE;
    }
    else if (err != ERROR_SUCCESS)
    {
        return err;
    }
    if ((err = RegGetKeySecurity(hKey,
                                 OWNER_SECURITY_INFORMATION |
                                 GROUP_SECURITY_INFORMATION |
                                 DACL_SECURITY_INFORMATION,
                                 pCurrSD,
                                 &cbCurrSD)
         != ERROR_SUCCESS))
    {
        if (fFreePCurrSD)
        {
            delete pCurrSD;
        }
        return err;
    }

    // Only proceed down this subtree if the current SD and the
    // original SD are the same
    fProceed = CompareSDs((PSrSecurityDescriptor) pCurrSD,
                          (PSrSecurityDescriptor) pSecOrig);

    // We're done with the current security descriptor
    if (fFreePCurrSD)
    {
        delete pCurrSD;
    }

    if (!fProceed)
    {
        if (hKey != hRoot)
        {
            RegCloseKey(hKey);
        }
        return ERROR_SUCCESS;
    }

    // Write the top level ACL
    err = RegSetKeySecurity(hKey,
                            OWNER_SECURITY_INFORMATION |
                            GROUP_SECURITY_INFORMATION |
                            DACL_SECURITY_INFORMATION,
                            pSec);

    // Now enumerate the subkeys and write ACL's on them
    DWORD iSubKey;
    TCHAR szSubKeyName[128];
    HKEY  hKey2;

    iSubKey = 0;

    while (err == ERROR_SUCCESS)
    {
        // Enumerate the next key
        err = RegEnumKey(hKey, iSubKey, szSubKeyName, 128);
        if (err != ERROR_SUCCESS)
        {
            break;
        }

        // Prepare for the next key
        iSubKey++;

        // Open this subkey and recursively write the ACL on it and
        // all of its subkeys
        if (RegOpenKeyEx(hKey, szSubKeyName, 0, KEY_ALL_ACCESS, &hKey2)
            == ERROR_SUCCESS)
        {
            err = WriteRegKeyACL2(hRoot, hKey2, pSec, pSecOrig);
        }
    }

    if (hKey != hRoot)
    {
        RegCloseKey(hKey);
    }
    return err == ERROR_NO_MORE_ITEMS ? ERROR_SUCCESS : err;
}




// Write a user's password to the private LSA database
int CUtility::WriteLsaPassword(CLSID appid, TCHAR *szPassword)
{
    return ERROR_SUCCESS;
}



int CUtility::DeleteRegKey(HKEY hRoot, TCHAR *szKeyPath)
{
    return RegDeleteKey(hRoot, szKeyPath);
}



int CUtility::DeleteRegValue(HKEY hRoot, TCHAR *szKeyPath, TCHAR *szValueName)
{
    int  err;
    HKEY hKey;

    if ((err = RegOpenKeyEx(hRoot, szKeyPath, 0, KEY_ALL_ACCESS, &hKey)) == ERROR_SUCCESS)
    {
        err = RegDeleteValue(hKey, szValueName);
		if (hRoot != hKey)
			RegCloseKey(hKey);
    }

    return err;
}



// Change the identity under which a service runs
int CUtility::WriteSrvIdentity(TCHAR *szService, TCHAR *szIdentity)
{
    return ERROR_SUCCESS;
}





DWORD __stdcall callBackFunc(HWND                 hwndParent,
                             HANDLE               hInstance,
                             ULONG                CallBackContext,
                             PSECURITY_DESCRIPTOR SecDesc,
                             PSECURITY_DESCRIPTOR SecDescNewObjects,
                             BOOLEAN              ApplyToSubContainers,
                             BOOLEAN              ApplyToSubObjects,
                             LPDWORD              StatusReturn)
{
    int err = ERROR_SUCCESS;
    PCallBackContext pCallBackContext = (PCallBackContext) CallBackContext;

    // Set the inheritance flags on the new security descriptor
    if (pCallBackContext->pktType == RegKeyACL)
    {
        g_util.SetInheritanceFlags((SECURITY_DESCRIPTOR *) SecDesc);
    }

    // Write the new or modified security descriptor
    if (*pCallBackContext->pIndex == -1)
    {
        if (pCallBackContext->pktType == SingleACL)
        {
            err = g_virtreg.NewRegSingleACL(
                    pCallBackContext->info.single.hRoot,
                    pCallBackContext->info.single.szKeyPath,
                    pCallBackContext->info.single.szValueName,
                    (SECURITY_DESCRIPTOR *) SecDesc,
                    FALSE,
                    pCallBackContext->pIndex);
        }
        else
        {
            err = g_virtreg.NewRegKeyACL(
                    pCallBackContext->info.regKey.hKey,
                    pCallBackContext->info.regKey.phClsids,
                    pCallBackContext->info.regKey.cClsids,
                    pCallBackContext->info.regKey.szTitle,
                    pCallBackContext->origSD,
                    (SECURITY_DESCRIPTOR *) SecDesc,
                    FALSE,
                    pCallBackContext->pIndex);
        }
    }
    else
    {
        g_virtreg.ChgRegACL(*pCallBackContext->pIndex,
                            (SECURITY_DESCRIPTOR *) SecDesc,
                            FALSE);
    }

    *StatusReturn = err;
    return err;
}





// Invoke the ACL editor on the specified named value.  This method
// writes an ACL data packet to the virtual registry.  This method is for
// Access and Launch security only (pktType SingleACL).
int CUtility::ACLEditor(HWND       hWnd,
                        HKEY       hRoot,
                        TCHAR     *szKeyPath,
                        TCHAR     *szValueName,
                        int       *pIndex,
                        PACKETTYPE pktType,
                        TCHAR     *szPermType)
{
    int                  err;
    HKEY                 hKey;
    BYTE                 aSD[128];
    DWORD                cbSD = 128;
    DWORD                dwType;
    SECURITY_DESCRIPTOR *pSD = (SECURITY_DESCRIPTOR *) aSD;
    BOOL                 fFreePSD = FALSE;
    SID                 *pSid;
    TCHAR                szAllow[32];
    TCHAR                szDeny[32];
    CString              szAllow_;
    CString              szDeny_;

    szAllow_.LoadString(IDS_Allow_);
    szDeny_.LoadString(IDS_Deny_);


    // Build the allow and deny strings
    _tcscpy(szAllow, (LPCTSTR) szAllow_);
    _tcscat(szAllow, szPermType);
    _tcscpy(szDeny, (LPCTSTR) szDeny_);
    _tcscat(szDeny, szPermType);


    // Fetch the current SD, either from the registry, by default if the
    // named value doesn't exist or from the virtual registry
    if (*pIndex == -1)
    {
        // Open the specified key
        if ((err = RegOpenKeyEx(hRoot, szKeyPath, 0,
                                KEY_ALL_ACCESS, &hKey))
            != ERROR_SUCCESS)
        {
            return err;
        }

        // Attempt to read the specified named value
        err = RegQueryValueEx(hKey, szValueName, 0, &dwType, (BYTE *) aSD,
                              &cbSD);

        if (err == ERROR_MORE_DATA  ||  err == ERROR_INSUFFICIENT_BUFFER)
        {
            pSD = (SECURITY_DESCRIPTOR *) new BYTE[cbSD];
            if (pSD == NULL)
            {
                return ERROR_NOT_ENOUGH_MEMORY;
            }
            fFreePSD = TRUE;
            err = RegQueryValueEx(hKey, szValueName, 0, &dwType,
                                  (BYTE *) pSD, &cbSD);
        }

        // The named valued doesn't exist.  If this is
        // \\HKEY_CLASSES_ROOT\...
        // then use the default named value if it exists
        else if (err != ERROR_SUCCESS)
        {
            if (hRoot != HKEY_LOCAL_MACHINE)
            {
                if (err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                       TEXT("SOFTWARE\\Microsoft\\OLE"),
                                       0,
                                       KEY_ALL_ACCESS,
                                       &hKey)
                    != ERROR_SUCCESS)
                {
                    return err;
                }

                // Attempt to read the specified named value
                TCHAR szDefault[32];

                _tcscpy(szDefault, TEXT("Default"));
                _tcscat(szDefault, szValueName);
                err = RegQueryValueEx(hKey, szDefault, 0, &dwType,
                                      (BYTE *) aSD, &cbSD);

                if (err == ERROR_MORE_DATA)
                {
                    pSD = (SECURITY_DESCRIPTOR *) new BYTE[cbSD];
                    if (pSD == NULL)
                    {
                        return ERROR_NOT_ENOUGH_MEMORY;
                    }
                    fFreePSD = TRUE;
                    err = RegQueryValueEx(hKey, szDefault, 0, &dwType,
                                          (BYTE *) pSD, &cbSD);
                }
                RegCloseKey(hKey);
            }
        }

        // If still don't have an SD, then simply create one
        if (err != ERROR_SUCCESS)
        {
            if (!g_util.LookupProcessInfo(&pSid, NULL))
            {
                return GetLastError();
            }
            if (!g_util.MakeSecDesc(pSid, &pSD))
            {
                delete pSid;
                return GetLastError();
            }
            fFreePSD = TRUE;
        }
    }

    // Fetch the most recently edited SD
    else
    {
        CDataPacket *pCdp = g_virtreg.GetAt(*pIndex);

        pSD = pCdp -> pkt.acl.pSec;
    }


    // Initialize the callback context
    m_sCallBackContext.pktType = pktType;
    m_sCallBackContext.pIndex = pIndex;
    m_sCallBackContext.origSD = pSD;
    m_sCallBackContext.info.single.hRoot = hRoot;
    m_sCallBackContext.info.single.szKeyPath = szKeyPath;
    m_sCallBackContext.info.single.szValueName = szValueName;

    // Invoke the ACL editor
    DWORD                       dwStatus = 0;
    GENERIC_MAPPING             genericMapping;
    CString                     szObjectType;

    szObjectType.LoadString(IDS_Registry_value);

	SED_HELP_INFO               helpInfo =
	{
			L"dcomcnfg.hlp",
			{HC_MAIN_DLG,
			 HC_MAIN_DLG,
			 HC_MAIN_DLG,
			 HC_MAIN_DLG,
			 HC_MAIN_DLG,
			 HC_MAIN_DLG,
			 HC_MAIN_DLG}
	};

#ifndef UNICODE
    WCHAR * wszObjectType = new WCHAR[szObjectType.GetLength() + 1];
    mbstowcs(wszObjectType, szObjectType, szObjectType.GetLength() + 1);
#endif
    SED_OBJECT_TYPE_DESCRIPTOR  objTyp =
            {1,                                // Revision
             FALSE,                            // Is container?
             FALSE,                            // Allow new object perms?
             FALSE,                            // Specific to generic?
             &genericMapping,                  // Generic mapping
             NULL,                             // Generic mapping new
#ifdef UNICODE
             (TCHAR *) ((LPCTSTR) szObjectType), // Object type name
#else
             (WCHAR *) ((LPCWSTR) wszObjectType), // Object type name
#endif
             &helpInfo,                        // Help info
             L"",                         // Ckbox title
             L"",                         // Apply title
             L"",                         //
             NULL,                             // Special object access
             NULL                              // New special object access
            };

#ifndef UNICODE
    WCHAR wszAllow[32];
    mbstowcs(wszAllow, szAllow, 32);
    WCHAR wszDeny[32];
    mbstowcs(wszDeny, szDeny, 32);

    SED_APPLICATION_ACCESS      appAccess[] =
            {{SED_DESC_TYPE_RESOURCE, COM_RIGHTS_EXECUTE, 0, wszAllow},
             {SED_DESC_TYPE_RESOURCE, 0, 0, wszDeny}};

    SED_APPLICATION_ACCESSES    appAccesses =
            {2,              // Count of access groups
             appAccess,      // Access array
             wszAllow         // Default access name
            };
#else
    SED_APPLICATION_ACCESS      appAccess[] =
            {{SED_DESC_TYPE_RESOURCE, COM_RIGHTS_EXECUTE, 0, szAllow},
             {SED_DESC_TYPE_RESOURCE, 0, 0, szDeny}};

    SED_APPLICATION_ACCESSES    appAccesses =
            {2,              // Count of access groups
             appAccess,      // Access array
             szAllow         // Default access name
            };
#endif

    // Intialize the help contexts
    helpInfo.aulHelpContext[HC_MAIN_DLG] =
        IDH_REGISTRY_VALUE_PERMISSIONS;
    helpInfo.aulHelpContext[HC_SPECIAL_ACCESS_DLG] =
        IDH_SPECIAL_ACCESS_GLOBAL;
    helpInfo.aulHelpContext[HC_NEW_ITEM_SPECIAL_ACCESS_DLG] =
        IDH_SPECIAL_ACCESS_GLOBAL;
    helpInfo.aulHelpContext[HC_ADD_USER_DLG] =
        IDH_ADD_USERS_AND_GROUPS;
    helpInfo.aulHelpContext[HC_ADD_USER_MEMBERS_LG_DLG] =
        IDH_LOCAL_GROUP_MEMBERSHIP;
    helpInfo.aulHelpContext[HC_ADD_USER_MEMBERS_GG_DLG] =
        IDH_GLOBAL_GROUP_MEMBERSHIP;
    helpInfo.aulHelpContext[HC_ADD_USER_SEARCH_DLG] =
        IDH_FIND_ACCOUNT1;

    genericMapping.GenericRead    = GENERIC_ALL;
    genericMapping.GenericWrite   = GENERIC_ALL;
    genericMapping.GenericExecute = GENERIC_ALL;
    genericMapping.GenericAll     = GENERIC_ALL;

    // If this is for Access or Launch permissons then check that the
    // SD contains only allows and deny's for COM_RIGHTS_EXECUTE
    if (!CheckSDForCOM_RIGHTS_EXECUTE(pSD))
    {
        return IDCANCEL;
    }

    // Invoke the ACL editor
//    SedDiscretionaryAclEditor(hWnd,              // Owner hWnd
//                              GetModuleHandle(NULL), // Owner hInstance
//                              NULL,		 // Server
//                              &objTyp,           // ObjectTyp,
//                              &appAccesses,      // Application accesses
//                              szValueName,       // Object name,
//                              callBackFunc, // Callback function
//                             (ULONG) &m_sCallBackContext, // Callback context
//                             pSD,              // Security descriptor,
//                             FALSE,             // Couldnt read Dacl,
//                             FALSE,             // Can't write Dacl,
//                             &dwStatus,         // SED status return,
//                             0);                // Flags

    // Check status return
    if (dwStatus != ERROR_SUCCESS)
    {
//        PostErrorMessage(dwStatus);
    }

    // We're done
    if (fFreePSD)
    {
        delete pSD;
    }

    return dwStatus == 0 ? ERROR_SUCCESS : IDCANCEL;
}





// Invoke the ACL editor on the specified key.  This method writes an ACL
// data packet to the virtual registry.  This method supports configuration
// security only (pktType RegKeyACL).
int CUtility::ACLEditor2(HWND       hWnd,
                         HKEY       hKey,
                         HKEY      *phClsids,
                         unsigned   cClsids,
                         TCHAR     *szTitle,
                         int       *pIndex,
                         PACKETTYPE pktType)
{
    int                  err;
    BYTE                 aSD[128];
    DWORD                cbSD = 128;
    SECURITY_DESCRIPTOR *pSD = (SECURITY_DESCRIPTOR *) aSD;
    BOOL                 fFreePSD = FALSE;
    TCHAR                szKeyRead[32];
    CString              szKeyRead_;
    TCHAR                szHkeyClassesRoot[32];
    CString              szHkeyClassesRoot_;


    // Initialize strings
    szKeyRead_.LoadString(IDS_Key_Read);
    _tcscpy(szKeyRead, (LPCTSTR) szKeyRead_);
    szHkeyClassesRoot_.LoadString(IDS_HKEY_CLASSES_ROOT);
    _tcscpy(szHkeyClassesRoot, (LPCTSTR) szHkeyClassesRoot_);


    if (*pIndex == -1)
    {
        // Read the security descriptor on this key
        err = RegGetKeySecurity(hKey,
                                OWNER_SECURITY_INFORMATION |
                                GROUP_SECURITY_INFORMATION |
                                DACL_SECURITY_INFORMATION,
                                aSD,
                                &cbSD);
        if (err == ERROR_MORE_DATA  ||  err == ERROR_INSUFFICIENT_BUFFER)
        {
            pSD = (SECURITY_DESCRIPTOR *) new BYTE[cbSD];
            if (pSD == NULL)
            {
                return ERROR_NOT_ENOUGH_MEMORY;
            }
            fFreePSD = TRUE;
        }
        else if (err != ERROR_SUCCESS)
        {
            return err;
        }
        if ((err = RegGetKeySecurity(hKey,
                                     OWNER_SECURITY_INFORMATION |
                                     GROUP_SECURITY_INFORMATION |
                                     DACL_SECURITY_INFORMATION,
                                     pSD,
                                     &cbSD)
             != ERROR_SUCCESS))
        {
            if (fFreePSD)
            {
                delete pSD;
            }
            return err;
        }
    }

    // Fetch the most recently edited SD
    else
    {
        CDataPacket *pCdp = g_virtreg.GetAt(*pIndex);

        pSD = pCdp -> pkt.racl.pSec;
    }


    // Initialize the callback context
    m_sCallBackContext.pktType = pktType;
    m_sCallBackContext.pIndex = pIndex;
    m_sCallBackContext.origSD = pSD;
    m_sCallBackContext.info.regKey.hKey = hKey;
    m_sCallBackContext.info.regKey.phClsids = phClsids;
    m_sCallBackContext.info.regKey.cClsids = cClsids;
    m_sCallBackContext.info.regKey.szTitle = szTitle;

    // Invoke the ACL editor
    DWORD                       dwStatus = 0;
    GENERIC_MAPPING             genericMapping;

    CString                     szObjectType;
    szObjectType.LoadString(IDS_Registry_Key);
    CString szQueryValue;
    szQueryValue.LoadString(IDS_Query_Value);
    CString szSetValue;
    szSetValue.LoadString(IDS_Set_Value);
    CString szCreateSubkeys;
    szCreateSubkeys.LoadString(IDS_Create_Subkey);
    CString szEnumerateSubkeys;
    szEnumerateSubkeys.LoadString(IDS_Enumerate_Subkeys);
    CString szNotify;
    szNotify.LoadString(IDS_Notify);
    CString szCreateLink;
    szCreateLink.LoadString(IDS_Create_Link);
    CString szDelete;
    szDelete.LoadString(IDS_Delete);
    CString szWriteDAC;
    szWriteDAC.LoadString(IDS_Write_DAC);
    CString szWriteOwner;
    szWriteOwner.LoadString(IDS_Write_Owner);
    CString szReadControl;
    szReadControl.LoadString(IDS_Read_Control);
    CString szRead;
    szRead.LoadString(IDS_Read);
    CString szFullControl;
    szFullControl.LoadString(IDS_Full_Control);
    CString szSpecialAccess;
    szSpecialAccess.LoadString(IDS_Special_AccessDotDotDot);


	SED_HELP_INFO               helpInfo =
	{
			L"dcomcnfg.hlp",
			{HC_MAIN_DLG,
			 HC_MAIN_DLG,
			 HC_MAIN_DLG,
			 HC_MAIN_DLG,
			 HC_MAIN_DLG,
			 HC_MAIN_DLG,
			 HC_MAIN_DLG}
	};

#ifndef UNICODE
    WCHAR * wszObjectType = new WCHAR[szObjectType.GetLength() + 1];
    mbstowcs(wszObjectType, szObjectType, szObjectType.GetLength() + 1);
    WCHAR * wszSpecialAccess = new WCHAR[szSpecialAccess.GetLength() + 1];
    mbstowcs(wszSpecialAccess, szSpecialAccess, szSpecialAccess.GetLength() + 1);
#endif
    SED_OBJECT_TYPE_DESCRIPTOR  objTyp =
            {SED_REVISION1,                    // Revision
             FALSE,                            // Is container?
             FALSE,                            // Allow new object perms?
             FALSE,                            // Specific to generic?
             &genericMapping,                  // Generic mapping
             NULL,                             // Generic mapping new
#ifdef UNICODE
             (TCHAR *) ((LPCTSTR) szObjectType), // Object type name
#else
             (WCHAR *) ((LPCWSTR) wszObjectType), // Object type name
#endif
             &helpInfo,                        // Help info
             L"",                         // Ckbox title
             L"",                         // Apply title
             L"",                         //
#ifdef UNICODE
             (TCHAR *) ((LPCTSTR) szSpecialAccess), // Special Access menu item
#else
             (WCHAR *) ((LPCWSTR) wszSpecialAccess), // Special Access menu item
#endif
             NULL                              // New special object access
            };

#ifdef UNICODE
    SED_APPLICATION_ACCESS      appAccess[] =
    {
        { SED_DESC_TYPE_RESOURCE_SPECIAL, KEY_QUERY_VALUE,        0,
           (TCHAR *) ((LPCTSTR) szQueryValue) },
        { SED_DESC_TYPE_RESOURCE_SPECIAL, KEY_SET_VALUE,          0,
           (TCHAR *) ((LPCTSTR) szSetValue) },
        { SED_DESC_TYPE_RESOURCE_SPECIAL, KEY_CREATE_SUB_KEY,     0,
           (TCHAR *) ((LPCTSTR) szCreateSubkeys) },
        { SED_DESC_TYPE_RESOURCE_SPECIAL, KEY_ENUMERATE_SUB_KEYS, 0,
           (TCHAR *) ((LPCTSTR) szEnumerateSubkeys) },
        { SED_DESC_TYPE_RESOURCE_SPECIAL, KEY_NOTIFY,             0,
           (TCHAR *) ((LPCTSTR) szNotify) },
        { SED_DESC_TYPE_RESOURCE_SPECIAL, KEY_CREATE_LINK,        0,
           (TCHAR *) ((LPCTSTR) szCreateLink) },
        { SED_DESC_TYPE_RESOURCE_SPECIAL, 0x00010000, /* DELETE, */ 0,
           (TCHAR *) ((LPCTSTR) szDelete) },
        { SED_DESC_TYPE_RESOURCE_SPECIAL, WRITE_DAC,              0,
           (TCHAR *) ((LPCTSTR) szWriteDAC) },
        { SED_DESC_TYPE_RESOURCE_SPECIAL, WRITE_OWNER,            0,
           (TCHAR *) ((LPCTSTR) szWriteOwner) },
        { SED_DESC_TYPE_RESOURCE_SPECIAL, READ_CONTROL,           0,
           (TCHAR *) ((LPCTSTR) szReadControl) },
        { SED_DESC_TYPE_RESOURCE,         KEY_READ,               0,
           (TCHAR *) ((LPCTSTR) szRead) },
        { SED_DESC_TYPE_RESOURCE,         GENERIC_ALL, /* KEY_ALL_ACCESS, */ 0,
           (TCHAR *) ((LPCTSTR) szFullControl) }
    };

    SED_APPLICATION_ACCESSES    appAccesses =
            {12,              // Count of access groups
             appAccess,       // Access array
             szKeyRead        // Default access name
            };
#else
    WCHAR * wszQueryValue = new WCHAR[szQueryValue.GetLength() + 1];
    mbstowcs(wszQueryValue, szQueryValue, szQueryValue.GetLength() + 1);
    WCHAR * wszSetValue = new WCHAR[szSetValue.GetLength() + 1];
    mbstowcs(wszSetValue, szSetValue, szSetValue.GetLength() + 1);
    WCHAR * wszCreateSubkeys = new WCHAR[szCreateSubkeys.GetLength() + 1];
    mbstowcs(wszCreateSubkeys, szCreateSubkeys, szCreateSubkeys.GetLength() + 1);
    WCHAR * wszEnumerateSubkeys = new WCHAR[szEnumerateSubkeys.GetLength() + 1];
    mbstowcs(wszEnumerateSubkeys, szEnumerateSubkeys, szEnumerateSubkeys.GetLength() + 1);
    WCHAR * wszNotify = new WCHAR[szNotify.GetLength() + 1];
    mbstowcs(wszNotify, szNotify, szNotify.GetLength() + 1);
    WCHAR * wszCreateLink = new WCHAR[szCreateLink.GetLength() + 1];
    mbstowcs(wszCreateLink, szCreateLink, szCreateLink.GetLength() + 1);
    WCHAR * wszDelete = new WCHAR[szDelete.GetLength() + 1];
    mbstowcs(wszDelete, szDelete, szDelete.GetLength() + 1);
    WCHAR * wszWriteDAC = new WCHAR[szWriteDAC.GetLength() + 1];
    mbstowcs(wszWriteDAC, szWriteDAC, szWriteDAC.GetLength() + 1);
    WCHAR * wszWriteOwner = new WCHAR[szWriteOwner.GetLength() + 1];
    mbstowcs(wszWriteOwner, szWriteOwner, szWriteOwner.GetLength() + 1);
    WCHAR * wszReadControl = new WCHAR[szReadControl.GetLength() + 1];
    mbstowcs(wszReadControl, szReadControl, szReadControl.GetLength() + 1);
    WCHAR * wszRead = new WCHAR[szRead.GetLength() + 1];
    mbstowcs(wszRead, szRead, szRead.GetLength() + 1);
    WCHAR * wszFullControl = new WCHAR[szFullControl.GetLength() + 1];
    mbstowcs(wszFullControl, szFullControl, szFullControl.GetLength() + 1);
    SED_APPLICATION_ACCESS      appAccess[] =
    {
        { SED_DESC_TYPE_RESOURCE_SPECIAL, KEY_QUERY_VALUE,        0,
           (WCHAR *) ((LPCWSTR) wszQueryValue) },
        { SED_DESC_TYPE_RESOURCE_SPECIAL, KEY_SET_VALUE,          0,
           (WCHAR *) ((LPCWSTR) wszSetValue) },
        { SED_DESC_TYPE_RESOURCE_SPECIAL, KEY_CREATE_SUB_KEY,     0,
           (WCHAR *) ((LPCWSTR) wszCreateSubkeys) },
        { SED_DESC_TYPE_RESOURCE_SPECIAL, KEY_ENUMERATE_SUB_KEYS, 0,
           (WCHAR *) ((LPCWSTR) wszEnumerateSubkeys) },
        { SED_DESC_TYPE_RESOURCE_SPECIAL, KEY_NOTIFY,             0,
           (WCHAR *) ((LPCWSTR) wszNotify) },
        { SED_DESC_TYPE_RESOURCE_SPECIAL, KEY_CREATE_LINK,        0,
           (WCHAR *) ((LPCWSTR) wszCreateLink) },
        { SED_DESC_TYPE_RESOURCE_SPECIAL, 0x00010000, /* DELETE, */ 0,
           (WCHAR *) ((LPCWSTR) wszDelete) },
        { SED_DESC_TYPE_RESOURCE_SPECIAL, WRITE_DAC,              0,
           (WCHAR *) ((LPCWSTR) wszWriteDAC) },
        { SED_DESC_TYPE_RESOURCE_SPECIAL, WRITE_OWNER,            0,
           (WCHAR *) ((LPCWSTR) wszWriteOwner) },
        { SED_DESC_TYPE_RESOURCE_SPECIAL, READ_CONTROL,           0,
           (WCHAR *) ((LPCWSTR) wszReadControl) },
        { SED_DESC_TYPE_RESOURCE,         KEY_READ,               0,
           (WCHAR *) ((LPCWSTR) wszRead) },
        { SED_DESC_TYPE_RESOURCE,         GENERIC_ALL, /* KEY_ALL_ACCESS, */ 0,
           (WCHAR *) ((LPCWSTR) wszFullControl) }
    };

    WCHAR wszKeyRead[32];
    mbstowcs(wszKeyRead, szKeyRead, 32);
    SED_APPLICATION_ACCESSES    appAccesses =
            {12,              // Count of access groups
             appAccess,       // Access array
             wszKeyRead        // Default access name
            };
#endif

    // Intialize the help contexts
    helpInfo.aulHelpContext[HC_MAIN_DLG] =
        IDH_REGISTRY_KEY_PERMISSIONS;
    if (hKey == HKEY_CLASSES_ROOT)
    {
        helpInfo.aulHelpContext[HC_SPECIAL_ACCESS_DLG] =
            IDH_SPECIAL_ACCESS_GLOBAL;
        helpInfo.aulHelpContext[HC_NEW_ITEM_SPECIAL_ACCESS_DLG] =
            IDH_SPECIAL_ACCESS_GLOBAL;
    }
    else
    {
        helpInfo.aulHelpContext[HC_SPECIAL_ACCESS_DLG] =
            IDH_SPECIAL_ACCESS_PER_APPID;
        helpInfo.aulHelpContext[HC_NEW_ITEM_SPECIAL_ACCESS_DLG] =
            IDH_SPECIAL_ACCESS_PER_APPID;
    }

    helpInfo.aulHelpContext[HC_ADD_USER_DLG] =
        IDH_ADD_USERS_AND_GROUPS;
    helpInfo.aulHelpContext[HC_ADD_USER_MEMBERS_LG_DLG] =
        IDH_LOCAL_GROUP_MEMBERSHIP;
    helpInfo.aulHelpContext[HC_ADD_USER_MEMBERS_GG_DLG] =
        IDH_GLOBAL_GROUP_MEMBERSHIP;
    helpInfo.aulHelpContext[HC_ADD_USER_SEARCH_DLG] =
        IDH_FIND_ACCOUNT1;

    genericMapping.GenericRead    = KEY_READ;
    genericMapping.GenericWrite   = KEY_WRITE;
    genericMapping.GenericExecute = KEY_READ;
    genericMapping.GenericAll     = KEY_ALL_ACCESS;

    // Invoke the ACL editor
//    SedDiscretionaryAclEditor(hWnd,              // Owner hWnd
//                              GetModuleHandle(NULL), // Owner hInstance
//                              NULL,		 // Server
//                              &objTyp,           // ObjectTyp,
//                              &appAccesses,      // Application accesses
//                              szTitle ? szTitle : szHkeyClassesRoot,// Object name,
//                              callBackFunc, // Callback function
//                              (ULONG) &m_sCallBackContext, // Callback context
//                              pSD,              // Security descriptor,
//                              FALSE,             // Couldnt read Dacl,
//                              FALSE,             // Can't write Dacl,
//                              &dwStatus,         // SED status return,
//                              0);                // Flags

    // Check status return
    if (dwStatus != ERROR_SUCCESS)
    {
//        PostErrorMessage(dwStatus);
    }

    // We're done
    if (fFreePSD)
    {
        delete pSD;
    }

    return dwStatus == 0 ? ERROR_SUCCESS : IDCANCEL;
}




BOOL CUtility::InvokeUserBrowser(HWND hWnd, TCHAR *szUser)
{
    BOOL             fRet = FALSE;
    HUSERBROW        hUser;
    USERBROWSER      sUserBrowser;
    SUserDetailsPlus sUserDetailsPlus;
    ULONG            ulSize = USER_DETAILS_BUFFER_SIZE;
    CString          szTitle;

    szTitle.LoadString(IDS_Browse_for_users);

    sUserBrowser.ulStructSize = sizeof(USERBROWSER);	
    sUserBrowser.fUserCancelled = FALSE;
    sUserBrowser.fExpandNames = TRUE;
    sUserBrowser.hwndOwner = hWnd;
#ifdef UNICODE
    sUserBrowser.pszTitle = (TCHAR *) ((LPCTSTR) szTitle);
#else
    WCHAR * wszTitle = new WCHAR[szTitle.GetLength() + 1];
    mbstowcs(wszTitle, szTitle, szTitle.GetLength() + 1);
    sUserBrowser.pszTitle = (WCHAR *) ((LPCWSTR) wszTitle);
#endif
    sUserBrowser.pszInitialDomain = NULL;
    sUserBrowser.Flags = USRBROWS_DONT_SHOW_COMPUTER |
                         USRBROWS_SINGLE_SELECT      |
                         USRBROWS_INCL_ALL           |
                         USRBROWS_SHOW_USERS;
    sUserBrowser.ulHelpContext = IDH_BROWSE_FOR_USERS;
    sUserBrowser.pszHelpFileName = L"dcomcnfg.hlp";

#if 0
    hUser = OpenUserBrowser(&sUserBrowser);
    if (hUser == NULL)
    {
        return FALSE;
    }
    else
    {
        CString szBackslash;

        szBackslash.LoadString(IDS_backslash);

        if (EnumUserBrowserSelection(hUser,
                                     &sUserDetailsPlus.sUserDetails,
                                     &ulSize))
        {
            _tcscpy(szUser, sUserDetailsPlus.sUserDetails.pszDomainName);
            _tcscat(szUser, (LPCTSTR) szBackslash);
            _tcscat(szUser, sUserDetailsPlus.sUserDetails.pszAccountName);
            fRet = TRUE;
        }
    }

    CloseUserBrowser(hUser);
#endif
    return fRet;
}







BOOL CUtility::InvokeMachineBrowser(TCHAR *szMachine)
{
   ///////////////////////////////////////////////////
   // If we end up not wanting to use I_SystemFocusDialog, then the code below
   // is the start for fetching machine resources ourselves
#if 1
    DWORD       dwErr;
    NETRESOURCE aNetResource[1000];
    HANDLE      hNetwork;
    DWORD       dwEntries = 100;
    DWORD       dwBufSize =  sizeof(aNetResource);

    dwErr = WNetOpenEnum(RESOURCE_GLOBALNET,
                         RESOURCETYPE_ANY,
                         0,
                         NULL,
                         &hNetwork);

    if (dwErr == NO_ERROR)
    {
        dwEntries = 0xffffffff;
        dwErr = WNetEnumResource(hNetwork,
                                 &dwEntries,
                                 aNetResource,
                                 &dwBufSize);
    }

    WNetCloseEnum(hNetwork);

    dwErr = WNetOpenEnum(RESOURCE_GLOBALNET,
                         RESOURCETYPE_ANY,
                         0,
                         aNetResource,
                         &hNetwork);

    if (dwErr == NO_ERROR)
    {
        dwEntries = 0xffffffff;
        dwErr = WNetEnumResource(hNetwork,
                                 &dwEntries,
                                 &aNetResource[1],
                                 &dwBufSize);
    }


    return dwErr == NO_ERROR ? TRUE : FALSE;
#else
///////////////////////////////////////////////////////




    UINT  err;
    BOOL  fOkPressed = FALSE;

    err = I_SystemFocusDialog(GetForegroundWindow(),
//                              FOCUSDLG_BROWSE_LOGON_DOMAIN |
//                              FOCUSDLG_BROWSE_WKSTA_DOMAIN,
                              0x30003,
                              szMachine,
                              128,
                              &fOkPressed,
                              TEXT("dcomcnfg.hlp"),
                              IDH_SELECT_DOMAIN);

    if (err == ERROR_SUCCESS  &&  fOkPressed)
    {
        return TRUE;
    }
    else
    {
        return FALSE;
    }
#endif
}





int CUtility::StringFromGUID(GUID &rguid, TCHAR *lpsz, int cbMax)
{
    int i;
    LPTSTR p = lpsz;

    const BYTE * pBytes = (const BYTE *) &rguid;

    *p++ = L'{';

    for (i = 0; i < sizeof(GuidMap); i++)
    {
        if (GuidMap[i] == '-')
        {
            *p++ = L'-';
        }
        else
        {
            *p++ = szDigits[ (pBytes[GuidMap[i]] & 0xF0) >> 4 ];
            *p++ = szDigits[ (pBytes[GuidMap[i]] & 0x0F) ];
        }
    }
    *p++ = L'}';
    *p   = L'\0';

    return GUIDSTR_MAX;
}




BOOL  CUtility::IsEqualGuid(GUID &guid1, GUID &guid2)
{
   return (
      ((PLONG) &guid1)[0] == ((PLONG) &guid2)[0] &&
      ((PLONG) &guid1)[1] == ((PLONG) &guid2)[1] &&
      ((PLONG) &guid1)[2] == ((PLONG) &guid2)[2] &&
      ((PLONG) &guid1)[3] == ((PLONG) &guid2)[3]);
}



BOOL CUtility::AdjustPrivilege(TCHAR *szPrivilege)
{
    HANDLE           hProcessToken = 0;
    BOOL             bOK = FALSE;
    TOKEN_PRIVILEGES privileges;

    if( !OpenProcessToken( GetCurrentProcess(),
                           TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES,
                           &hProcessToken ) )
    {
        return FALSE;
    }

    privileges.PrivilegeCount = 1;
    privileges.Privileges[ 0 ].Attributes = SE_PRIVILEGE_ENABLED;
    if( !LookupPrivilegeValue(NULL, szPrivilege,
                              &privileges.Privileges[ 0 ].Luid ) )
    {
        return FALSE;
    }

    if( !AdjustTokenPrivileges( hProcessToken, FALSE,
                                &privileges,
                                0L, NULL, NULL ) )
    {
        return FALSE;
    }

    if( hProcessToken )
    {
        CloseHandle( hProcessToken );
    }

    return TRUE;
}



BOOL CUtility::VerifyRemoteMachine(TCHAR *szRemoteMachine)
{
    NETRESOURCE sResource;
    NETRESOURCE sResource2;
    DWORD       dwErr;
    HANDLE      hEnum;
    DWORD       cbEntries;
    DWORD       cbBfr;

    // TODO: Get this function to work.  Right now WNetEnumResource is
    // screwing up the stack, causing an AV and anyway returns the error
    // ERROR_NO_MORE_ITEMS which I don't understand.
    //
    // Also, it is not clear that we should verify the remote machine name.
    // It may have different formats, e.g. IP address or a URL specification.
    // It may not even be on an NT network.  In any case it may be offline
    // currently.
    return TRUE;

    sResource.dwScope       = RESOURCE_GLOBALNET;
    sResource.dwType        = RESOURCETYPE_ANY;
    sResource.dwDisplayType = RESOURCEDISPLAYTYPE_GENERIC;
    sResource.dwUsage       = RESOURCEUSAGE_CONTAINER;
    sResource.lpLocalName   = NULL;
    sResource.lpRemoteName  = szRemoteMachine;
    sResource.lpComment     = NULL;
    sResource.lpProvider    = NULL;



    dwErr = WNetOpenEnum(RESOURCE_GLOBALNET,
                         RESOURCETYPE_ANY,
                         RESOURCEUSAGE_CONTAINER,
                         &sResource,
                         &hEnum);

    if (dwErr == NO_ERROR)
    {
        cbEntries = 1;
        cbBfr = sizeof(NETRESOURCE);
        dwErr = WNetEnumResource(hEnum, &cbEntries, &sResource2, &cbBfr);
    }

    CloseHandle(hEnum);

    return TRUE;

}




BOOL CUtility::RetrieveUserPassword(TCHAR *szAppid, CString &sPassword)
{
#ifdef UNICODE
    LSA_OBJECT_ATTRIBUTES sObjAttributes;
    HANDLE                hPolicy = NULL;
    LSA_UNICODE_STRING    sKey;
    PLSA_UNICODE_STRING   psPassword;
    TCHAR                 szKey[4 + GUIDSTR_MAX + 1];

    // Formulate the access key
    _tcscpy(szKey, TEXT("SCM:"));
    _tcscat(szKey, szAppid);

    // UNICODE_STRING length fields are in bytes and include the NULL
    // terminator
    sKey.Length              = (_tcslen(szKey) + 1) * sizeof(WCHAR);
    sKey.MaximumLength       = (GUIDSTR_MAX + 5) * sizeof(WCHAR);
    sKey.Buffer              = szKey;

    // Open the local security policy
    InitializeObjectAttributes(&sObjAttributes, NULL, 0L, NULL, NULL);
    if (!NT_SUCCESS(LsaOpenPolicy(NULL, &sObjAttributes,
                                  POLICY_GET_PRIVATE_INFORMATION, &hPolicy)))
    {
        return FALSE;
    }

    // Read the user's password
    if (!NT_SUCCESS(LsaRetrievePrivateData(hPolicy, &sKey, &psPassword)))
    {
        LsaClose(hPolicy);
        return FALSE;
    }

    // Close the policy handle, we're done with it now.
    LsaClose(hPolicy);

    // Copy the password
    sPassword = psPassword->Buffer;
#endif
    return TRUE;
}





BOOL CUtility::StoreUserPassword(TCHAR *szAppid, CString &szPassword)
{
#ifdef UNICODE
    LSA_OBJECT_ATTRIBUTES sObjAttributes;
    HANDLE                hPolicy = NULL;
    LSA_UNICODE_STRING    sKey;
    LSA_UNICODE_STRING    sPassword;
    TCHAR                 szKey[4 + GUIDSTR_MAX + 1];

    // Formulate the access key
    _tcscpy(szKey, TEXT("SCM:"));
    _tcscat(szKey, szAppid);

    // UNICODE_STRING length fields are in bytes and include the NULL
    // terminator
    sKey.Length              = (_tcslen(szKey) + 1) * sizeof(WCHAR);
    sKey.MaximumLength       = (GUIDSTR_MAX + 5) * sizeof(WCHAR);
    sKey.Buffer              = szKey;

    // Make the password a UNICODE string
    sPassword.Length = (_tcslen(LPCTSTR(szPassword)) + 1) * sizeof(WCHAR);
    sPassword.Buffer = (TCHAR *) LPCTSTR(szPassword);
    sPassword.MaximumLength = sPassword.Length;

    // Open the local security policy
    InitializeObjectAttributes(&sObjAttributes, NULL, 0L, NULL, NULL);
    if (!NT_SUCCESS(LsaOpenPolicy(NULL, &sObjAttributes,
                                  POLICY_CREATE_SECRET, &hPolicy)))
    {
        return FALSE;
    }

    // Store the user's password
    if (!NT_SUCCESS(LsaStorePrivateData(hPolicy, &sKey, &sPassword)))
    {
        g_util.PostErrorMessage();
        LsaClose(hPolicy);
        return FALSE;
    }

    // Close the policy handle, we're done with it now.
    LsaClose(hPolicy);
#endif
    return TRUE;
}






BOOL CUtility::LookupProcessInfo(SID **ppSid, TCHAR **ppszPrincName)
{
    BYTE               aMemory[SIZEOF_TOKEN_USER];
    TOKEN_USER        *pTokenUser  = (TOKEN_USER *) &aMemory;
    HANDLE	       hToken      = NULL;
    DWORD              lIgnore;
    DWORD              lSidLen;
    DWORD              lNameLen    = 0;
    DWORD              lDomainLen  = 0;
    TCHAR             *pDomainName = NULL;
    SID_NAME_USE       sIgnore;

    if (ppszPrincName != NULL)
	*ppszPrincName = NULL;

    // Open the process's token.
    if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))
    {
        // Lookup SID of process token.
        if (GetTokenInformation( hToken, TokenUser, pTokenUser,
                                 sizeof(aMemory), &lIgnore ))
	{
	    // Allocate memory to hold the SID.
	    lSidLen = GetLengthSid( pTokenUser->User.Sid );
	    *ppSid = (SID *) new BYTE[lSidLen];
	    if (*ppSid == NULL)
	    {
                return FALSE;
            }
            memcpy(*ppSid, pTokenUser->User.Sid, lSidLen);

            // Stop now if the caller doesn't want the user name.
            if (ppszPrincName != NULL)
            {
                // Find out how much memory to allocate for the name.
                LookupAccountSid(NULL, pTokenUser->User.Sid, NULL, &lNameLen,
                                 NULL, &lDomainLen, NULL );
                if (lNameLen != 0)
                {
                    // Allocate memory for the user's name.
                    *ppszPrincName =
                        (TCHAR *) new BYTE[lNameLen*sizeof(TCHAR)];
                    if (ppszPrincName == NULL)
                    {
                        CloseHandle( hToken );
                        return FALSE;
                    }
                    pDomainName = (TCHAR *) new BYTE[lDomainLen*sizeof(TCHAR)];
                    if (pDomainName == NULL)
                    {
                        delete ppszPrincName;
                        CloseHandle( hToken );
                        return FALSE;
                    }

                    // Find the user's name.
                    if (!LookupAccountSid( NULL, pTokenUser->User.Sid,
                                           *ppszPrincName, &lNameLen,
                                           pDomainName,
                                           &lDomainLen, &sIgnore))
                    {
                        delete ppszPrincName;
                        delete pDomainName;
                        CloseHandle( hToken );
                        return FALSE;
		    }
                }
                delete ppszPrincName;
                delete pDomainName;
            }
        }
	CloseHandle( hToken );
    }

    return TRUE;
}






BOOL CUtility::MakeSecDesc(SID *pSid, SECURITY_DESCRIPTOR **ppSD)
{
    ACL               *pAcl;
    DWORD              lSidLen;
    SID               *pGroup;
    SID               *pOwner;

    // In case we fail
    *ppSD = NULL;

    // Allocate the security descriptor.
    lSidLen = GetLengthSid( pSid );
    *ppSD = (SECURITY_DESCRIPTOR *) new BYTE[
                  sizeof(SECURITY_DESCRIPTOR) + 2*lSidLen + SIZEOF_ACL];
    if (*ppSD == NULL)
    {
	return FALSE;
    }
    pGroup = (SID *) (*ppSD + 1);
    pOwner = (SID *) (((BYTE *) pGroup) + lSidLen);
    pAcl   = (ACL *) (((BYTE *) pOwner) + lSidLen);

    // Initialize a new security descriptor.
    if (!InitializeSecurityDescriptor(*ppSD, SECURITY_DESCRIPTOR_REVISION))
    {
        delete *ppSD;
        return FALSE;
    }

    // Initialize a new ACL.
    if (!InitializeAcl(pAcl, SIZEOF_ACL, ACL_REVISION2))
    {
        delete *ppSD;
        return FALSE;
    }

// Comment out this code because the only time we create a default SD is
// when attempting to edit
// \\HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\OLE.DefaultAccessPermission
// which we want to start with 0 ACE's
/*
    // Allow the current user access.
    if (!AddAccessAllowedAce( pAcl, ACL_REVISION2, COM_RIGHTS_EXECUTE, pSid ))
    {
        delete *ppSD;
        return FALSE;
    }

    // Allow local system access.
    if (!AddAccessAllowedAce( pAcl, ACL_REVISION2, COM_RIGHTS_EXECUTE,
	                      (void *) &LOCAL_SYSTEM_SID ))
    {
        delete *ppSD;
        return FALSE;
    }
*/

    // Add a new ACL to the security descriptor.
    if (!SetSecurityDescriptorDacl( *ppSD, TRUE, pAcl, FALSE ))
    {
        delete *ppSD;
        return FALSE;
    }

    // Set the group.
    memcpy( pGroup, pSid, lSidLen );
    if (!SetSecurityDescriptorGroup( *ppSD, pGroup, FALSE ))
    {
        delete *ppSD;
        return FALSE;
    }

    // Set the owner.
    memcpy( pOwner, pSid, lSidLen );
    if (!SetSecurityDescriptorOwner( *ppSD, pOwner, FALSE ))
    {
        delete *ppSD;
        return FALSE;
    }

    // Check the security descriptor.
    assert(IsValidSecurityDescriptor(*ppSD));

    return TRUE;
}





BOOL CUtility::CheckSDForCOM_RIGHTS_EXECUTE(SECURITY_DESCRIPTOR *pSD)
{
    PSrSecurityDescriptor pSrSD = (PSrSecurityDescriptor) pSD;
    PSrAcl                pDacl;
    PSrAce                pAce;
    DWORD                 cbAces;

    // Check whether the security descriptor is self-relative
    if (pSrSD->Dacl > 0x1000)
    {
        pDacl = (PSrAcl) pSrSD->Dacl;

        // Check for a deny ALL
        if (pDacl == NULL)
        {
            return TRUE;
        }
    }
    else
    {
        // First check for a deny ALL
        if (pSrSD->Dacl == 0)
        {
            return TRUE;
        }

        pDacl = (PSrAcl) (((BYTE *) pSrSD) + (pSrSD->Dacl));
    }

    // Do over the ACE's
    for (pAce = (PSrAce) (((BYTE *) pDacl) + sizeof(SSrAcl)),
         cbAces = pDacl->AceCount;
         cbAces;
         pAce = (PSrAce) (((BYTE *) pAce) + pAce->AceSize),
         cbAces--)
    {
        // Check that it is
        // a) an allow on COM_RIGHTS_EXECUTE
        // b) a deny on GENERIC_ALL,
        // c) a deny on COM_RIGHTS_EXECUTE,
        // d) a deny ALL (handled above if the DACL is NULL) or
        // e) an allow everyone (handled implicitly if cbAces == 0)
        if (!(((pAce->Type == 0  &&  pAce->AccessMask == COM_RIGHTS_EXECUTE)
               ||
               (pAce->Type == 1  &&  pAce->AccessMask == GENERIC_ALL)
               ||
               (pAce->Type == 1  &&  pAce->AccessMask == COM_RIGHTS_EXECUTE))))
        {
            CString szText;
            CString szTitle;

            szText.LoadString(IDS_The_security_);
            szTitle.LoadString(IDS_DCOM_Configuration_Warning);

            if (MessageBox(GetForegroundWindow(),
                           (LPCTSTR) szText,
                           (LPCTSTR) szTitle,
                           MB_YESNO) == IDYES)
            {
                pAce->Flags = 0;
                pAce->Type = 0;
                pAce->AccessMask = COM_RIGHTS_EXECUTE;
            }
            else
            {
                return FALSE;
            }
        }
    }

    return TRUE;
}



BOOL CUtility::ChangeService(const TCHAR *szService,
                             const TCHAR *szIdentity,
                             const TCHAR *szPassword,
                             const TCHAR *szDisplay)
{
    SC_HANDLE            hSCManager;
    SC_HANDLE            hService;

    // Open the service control manager
    if (hSCManager = OpenSCManager(NULL, NULL, GENERIC_READ | GENERIC_WRITE))
    {
        // Try to open a handle to the requested service
        if (!(hService = OpenService(hSCManager,
                                     szService,
                                     GENERIC_READ | GENERIC_WRITE)))
        {
            g_util.PostErrorMessage();
            CloseServiceHandle(hSCManager);
            return FALSE;
        }

        // Close the service manager's database
        CloseServiceHandle(hSCManager);

        // Change service identity parameters
        if (ChangeServiceConfig(hService,
                                SERVICE_WIN32_OWN_PROCESS,
                                SERVICE_DEMAND_START,
                                SERVICE_NO_CHANGE,
                                NULL,
                                NULL,
                                NULL,
                                NULL,
                                szIdentity,
                                szPassword,
                                szDisplay))
        {

            // Return success
            CloseServiceHandle(hService);
            return TRUE;
        }
        else
        {
            g_util.PostErrorMessage();
            CloseServiceHandle(hService);
            return FALSE;
        }
    }

    else
    {
        g_util.PostErrorMessage();
        return FALSE;
    }

}




BOOL CUtility::UpdateDCOMInfo(void)
{
    RPC_STATUS status;
#ifdef UNICODE
    TCHAR     *pszBindString;
#else
    unsigned char * pszBindString;
#endif

    // Get a binding handle to the SCM if we haven't yet
    if (m_hRpc == NULL)
    {
#ifdef UNICODE
        status = RpcStringBindingCompose(NULL,
                                         TEXT("ncalrpc"),
                                         NULL,
                                         TEXT("epmapper"),
                                         NULL,
                                         &pszBindString);
#else
        status = RpcStringBindingCompose(NULL,
                                         (unsigned char *)"ncalrpc",
                                         NULL,
                                         (unsigned char *)"epmapper",
                                         NULL,
                                         &pszBindString);
#endif

        if (status != RPC_S_OK)
        {
            return status;
        }

        status = RpcBindingFromStringBinding(pszBindString, &m_hRpc);
        RpcStringFree(&pszBindString);

        if (status != ERROR_SUCCESS)
        {
            return status;
        }

    }

    // Call over to the SCM to get the global registry values read
    // into memory
    UpdateActivationSettings(m_hRpc, &status);
    return status;
}



LRESULT CALLBACK ControlFixProc( HWND  hwnd, UINT  uMsg, WPARAM wParam,
                                 LPARAM  lParam);

// This is a work-around because there is a bug in msdev 4.1: Cannot get
// WM_HELP message processed by a control on which DDX_Control data exchange
// is done because of subclassing problem.  See msdn Q145865 for a discussion
// plus work-around code.
void CUtility::FixHelp(CWnd* pWnd)
{
    // search all child windows.  If their window proc
    // is AfxWndProc, then subclass with our window proc
    CWnd* pWndChild = pWnd->GetWindow(GW_CHILD);
    while(pWndChild != NULL)
    {
        if (GetWindowLong(pWndChild->GetSafeHwnd(),
                          GWL_WNDPROC) == (LONG)AfxWndProc)
        {
            SetWindowLong(pWndChild->GetSafeHwnd(), GWL_WNDPROC,
                          (LONG)ControlFixProc);
        }
        pWndChild = pWndChild->GetWindow(GW_HWNDNEXT);
    }
}



LRESULT CALLBACK ControlFixProc(HWND  hwnd, UINT  uMsg, WPARAM wParam,
                                LPARAM  lParam)
{
    if (uMsg == WM_HELP)
    {
        // bypass MFC's handler, message will be sent to parent
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }
    return AfxWndProc(hwnd,uMsg,wParam,lParam);
}




// Compare two security descriptors in self-relative form to
// determine if they're the same
BOOL CUtility::CompareSDs(PSrSecurityDescriptor pSD1,
                          PSrSecurityDescriptor pSD2)
{
    PSID   pSid1, pSid2;
    PSrAcl pDacl1, pDacl2;
    PSrAce pAce1, pAce2;
    BYTE   *p1, *p2;

    // Compare the owners
    pSid1 = (PSID) (((BYTE *) pSD1) + pSD1->Owner);
    pSid2 = (PSID) (((BYTE *) pSD2) + pSD2->Owner);
    if (!EqualSid(pSid1, pSid2))
    {
        return FALSE;
    }

    // Compare the groups
    pSid1 = (PSID) (((BYTE *) pSD1) + pSD1->Group);
    pSid2 = (PSID) (((BYTE *) pSD2) + pSD2->Group);
    if (!EqualSid(pSid1, pSid2))
    {
        return FALSE;
    }

    // Compare the DACL's
    pDacl1 = (PSrAcl) (((BYTE *) pSD1) + pSD1->Dacl);
    pDacl2 = (PSrAcl) (((BYTE *) pSD2) + pSD2->Dacl);

    // Check first that they are the same size and have the same
    // number of ACE's
    if (! (pDacl1->AclSize  == pDacl2->AclSize  &&
           pDacl1->AceCount == pDacl2->AceCount))
    {
        return FALSE;
    }

    // Now compare the ACL ACE by ACE
    pAce1 = (PSrAce) (((BYTE *) pDacl1) + sizeof(SSrAcl));
    pAce2 = (PSrAce) (((BYTE *) pDacl2) + sizeof(SSrAcl));
    for (int k = 0; k < pDacl1->AceCount; k++)
    {
        // Check the ACE headers
        if (! (pAce1->Type       == pAce2->Type        &&
               pAce1->AceSize    == pAce2->AceSize     &&
               pAce1->AccessMask == pAce2->AccessMask))
        {
            return FALSE;
        }

        // Check the SID's
        p1 = (BYTE *) (((BYTE *) pAce1) + sizeof(ACE_HEADER));
        p2 = (BYTE *) (((BYTE *) pAce2) + sizeof(ACE_HEADER));
        for (ULONG j = 0; j < pAce1->AceSize - sizeof(ACE_HEADER); j++)
        {
            if (p1[j] != p2[j])
            {
                return FALSE;
            }
        }

        // Go to the next ACE
        pAce1 = (PSrAce) (((BYTE *) pAce1) + pAce1->AceSize);
        pAce2 = (PSrAce) (((BYTE *) pAce2) + pAce2->AceSize);
    }

    return TRUE;
}





int CUtility::SetAccountRights(const TCHAR *szUser, TCHAR *szPrivilege)
{
#if UNICODE
    int                   err;
    LSA_HANDLE            hPolicy;
    LSA_OBJECT_ATTRIBUTES objAtt;
    DWORD                 cbSid = 1;
    TCHAR                 szDomain[128];
    DWORD                 cbDomain = 128;
    PSID                  pSid = NULL;
    SID_NAME_USE          snu;
    LSA_UNICODE_STRING    privStr;

    // Get a policy handle
    memset(&objAtt, 0, sizeof(LSA_OBJECT_ATTRIBUTES));
    if (!NT_SUCCESS(LsaOpenPolicy(NULL,
                                  &objAtt,
                                  POLICY_CREATE_ACCOUNT | POLICY_LOOKUP_NAMES,
                                  &hPolicy)))
    {
        return GetLastError();
    }

    // Fetch the SID for the specified user
    LookupAccountName(NULL, szUser, pSid, &cbSid, szDomain, &cbDomain, &snu);
    if ((err = GetLastError()) != ERROR_INSUFFICIENT_BUFFER)
    {
        LsaClose(hPolicy);
        return err;
    }
    pSid = new BYTE[cbSid];
    if (pSid == NULL)
    {
        LsaClose(hPolicy);
        return ERROR_OUTOFMEMORY;
    }
    if (!LookupAccountName(NULL, szUser, pSid, &cbSid,
                          szDomain, &cbDomain, &snu))
    {
        LsaClose(hPolicy);
        return GetLastError();
    }

    // Set the specified privilege on this account
    privStr.Length = _tcslen(szPrivilege) * sizeof(WCHAR);
    privStr.MaximumLength = privStr.Length + sizeof(WCHAR);
    privStr.Buffer = szPrivilege;
    if (!NT_SUCCESS(LsaAddAccountRights(hPolicy, pSid, &privStr, 1)))
    {
        LsaClose(hPolicy);
        return GetLastError();
    }

    // We're done
    delete pSid;
    LsaClose(hPolicy);
#endif
    return ERROR_SUCCESS;
}





// This method is included only because in the debug version when using
// MFC they validate the C++ heap, whereas RtlCopySecurityDescriptor uses
// the standard process heap, causing MFC to throw a breakpoint
void CUtility::CopySD(SECURITY_DESCRIPTOR *pSrc, SECURITY_DESCRIPTOR **pDest)
{
    ULONG                cbLen;
    SECURITY_DESCRIPTOR *pSD;

#if 0
    cbLen = RtlLengthSecurityDescriptor(pSrc);
#else
    cbLen = 10;
#endif
    pSD = (SECURITY_DESCRIPTOR *) new BYTE[cbLen];
    *pDest = pSD;
    if (pSD)
    {
        memcpy(pSD, pSrc, cbLen);
    }
}




// Set the inheritance flags on a security descriptor so keys created
// under the key having this security descriptor will inherit all its
// ACE's.  We do this as a utility routine rather than via the ACL
// editor because doing that adds check boxes and such to the ACL editor,
// so it's cleaner this way.
//
// Note. The security descriptor is expected to be in absolute form
void CUtility::SetInheritanceFlags(SECURITY_DESCRIPTOR *pSec)
{
    PSrAcl pAcl = (PSrAcl) pSec->Dacl;
    PSrAce pAce;
    int    k;

    // Do over the ACE's this DACL
    for (k = pAcl->AceCount, pAce = (PSrAce) (((BYTE *) pAcl) + sizeof(SSrAcl));
         k;
         k--, pAce = (PSrAce) (((BYTE *) pAce) + pAce->AceSize))
    {
        pAce->Flags |= CONTAINER_INHERIT_ACE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\async\debug\printf.c ===
/***
*printf.c - print formatted to stdout
*
*	Copyright (c) 1985-1991, Microsoft Corporation. All rights reserved.
*
*Purpose:
*	defines w4printf() - print formatted data to stdout
*	defines w4vprintf() - print formatted output to stdout, get data
*			      from an argument ptr instead of explicit args.
*******************************************************************************/

#ifdef FLAT
#include "dprintf.h"		// function prototypes

#define _W4PRINTF_
#include "printf.h"
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\ole32\stg\async\daytona.inc ===
!IF 0

Copyright (c) 1989  Microsoft Corporation

Module Name:

    daytona.inc

Abstract:

    This file is included from all of the daytona sources files. It
    is handy for doing things like turning off precompiled headers
    to get around compiler bugs, and other such global activities.

Notes:

    We define _OLE32_ so that when building ole32.dll we don't have
    DECLSPEC_IMPORT defined (see objbase.h)

!ENDIF

C_DEFINES=    \
              $(C_DEFINES)          \
              -DNOEXCEPTIONS        \
              -DINC_OLE2            \
              -DFLAT                \
              -DWIN32=100           \
              -D_NT1X_=100          \
              -DUNICODE             \
              -D_UNICODE            \
	      -DCAIROLE_DOWNLEVEL   \
	      -DDCOM		    \
              -DMSWMSG              \
	      -DDCOM_SECURITY       \
              -DNEWPROPS            \
              -D_TRACKLINK_=1       \
              $(TRACELOG)

#  DECLSPEC_IMPORT control (see objbase.h)
!if "$(MINORCOMP)"=="com" || "$(MINORCOMP)"=="stg" || "$(MINORCOMP)"=="ole232" || "$(MINORCOMP)"=="common"
C_DEFINES=    \
              $(C_DEFINES)          \
              -D_OLE32_
!endif

# For the Daytona build, we do not want statically linked compiler runtimes,
# so leave this commented out.
#
# USE_LIBCMT=   1

MSC_WARNING_LEVEL=/W3 /WX
