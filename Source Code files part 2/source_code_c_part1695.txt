l) {
                *plDevErrVal = (LONG) hr;
                WIAS_LERROR(m_pIWiaLog,
                            WIALOG_NO_RESOURCE_ID,
                            ("ScanItemCB, data transfer failed, status: 0x%X", hr));
            }

            break;
        }
    }

    HRESULT Temphr = m_pScanAPI->Scan(SCAN_END, NULL, 0, NULL);
    if(FAILED(Temphr)){
        WIAS_LERROR(m_pIWiaLog,
                    WIALOG_NO_RESOURCE_ID,
                    ("ScanItemCB, Ending a scanning session failed"));
        return Temphr;
    }

    if (!bBitmapData) {

        //
        // call back client to show 100% with status on the transfer and data offset
        //

        hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(IT_MSG_DATA,
                                                          IT_STATUS_TRANSFER_TO_CLIENT,
                                                          100,
                                                          pmdtc->cbOffset,
                                                          cbWritten,
                                                          pmdtc,
                                                          0);
    }

    return hr;
}

/**************************************************************************\
* CWIAScannerDevice::drvAcquireItemData
*
*   This driver entry point is called when image data is requested from the
*   device.
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA item.
*   lFlags          - Operation flags, unused.
*   pmdtc           - Pointer to mini driver context. On entry, only the
*                     portion of the mini driver context which is derived
*                     from the item properties is filled in.
*   plDevErrVal     - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvAcquireItemData(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    PMINIDRV_TRANSFER_CONTEXT   pmdtc,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvAcquireItemData");
    HRESULT hr = S_OK;
    BOOL bBitmapData   = ((pmdtc->guidFormatID == WiaImgFmt_BMP) || (pmdtc->guidFormatID == WiaImgFmt_MEMORYBMP));
    if (plDevErrVal) {
        *plDevErrVal = 0;
    }

    //
    // Get a pointer to the associated driver item.
    //

    IWiaDrvItem* pDrvItem;

    hr = wiasGetDrvItem(pWiasContext, &pDrvItem);
    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, wiasGetDrvItem() failed."));
        WIAS_LHRESULT(m_pIWiaLog,hr);
        return hr;
    }

    //
    // Validate the data transfer context.
    //

    hr = ValidateDataTransferContext(pmdtc);

    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, ValidateDataTransferContext() failed."));
        WIAS_LHRESULT(m_pIWiaLog,hr);
        return hr;
    }

    //
    //  Get item specific driver data
    //

    PMINIDRIVERITEMCONTEXT  pItemContext = NULL;

    hr = pDrvItem->GetDeviceSpecContext((BYTE**)&pItemContext);

    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, NULL item context"));
        WIAS_LHRESULT(m_pIWiaLog,hr);
        return hr;
    }

    //
    // allocate a buffer to be used for the data transfer.  This will only happen, when the
    // the data format is non-bitmap. Item Size is set to 0, telling the WIA service, that
    // we will be allocating the buffer for transfer.
    //

    if (!pmdtc->bClassDrvAllocBuf) {

        LONG lClassDrvAllocSize = m_MaxBufferSize + BUFFER_PAD; // max buffer band size
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvAcquireItemData, Attempting to Allocate (%d)bytes for pmdtc->pTransferBuffer",lClassDrvAllocSize));

        pmdtc->pTransferBuffer = (PBYTE) CoTaskMemAlloc(lClassDrvAllocSize);
        if (!pmdtc->pTransferBuffer) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, unable to allocate temp transfer buffer, size: %d",(pmdtc->lImageSize + pmdtc->lHeaderSize)));
            return E_OUTOFMEMORY;
        }

        //
        // set new buffer size
        //

        pmdtc->lBufferSize = lClassDrvAllocSize;
    }

    if (bBitmapData) {

        //
        //  Use WIA services to fetch format specific info.  This information
        //  is based on the property settings.
        //

        hr = wiasGetImageInformation(pWiasContext, 0, pmdtc);

        if (hr != S_OK) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, wiasGetImageInformation failed."));
            WIAS_LHRESULT(m_pIWiaLog,hr);
            return hr;
        }

    }

    //
    // Check if we are in Preview Mode
    //

    if(IsPreviewScan(pWiasContext)){
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvAcquireItemData, Preview Property is SET"));
        m_pScanAPI->SetScanMode(SCANMODE_PREVIEWSCAN);
    } else {
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvAcquireItemData, Preview Property is NOT SET"));
        m_pScanAPI->SetScanMode(SCANMODE_FINALSCAN);
    }

    //
    // Get number of pages requested, for ADF scanning loop
    //

    BOOL bEmptyTheADF = FALSE;
    LONG lPagesRequested = GetPageCount(pWiasContext);
    if (lPagesRequested == 0) {
        bEmptyTheADF    = TRUE;
        lPagesRequested = 1;// set to 1 so we can enter our loop
                            // WIA_STATUS_END_OF_MEDIA will terminate
                            // the loop...or an error, or a cancel..
                            //
    }

    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvAcquireItemData, Pages to Scan = %d",lPagesRequested));

    if (IsADFEnabled(pWiasContext)) { // FEEDER is enabled for scanning

        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvAcquireItemData, Feeder is enabled for use"));

        //
        // clear an potential paper that may be blocking the
        // scan pathway.
        //

        hr = m_pScanAPI->ADFUnFeedPage();
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, ADFUnFeedPage (begin transfer) Failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }

    } else {            // FLATBED is enabled for scanning

        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvAcquireItemData, Feeder is disabled or no feeder exists"));

        //
        // Transfer only a single image
        //

        bEmptyTheADF    = FALSE;
        lPagesRequested = 1;
    }

    //
    // WIA document scanning loop
    //

    LONG lPagesScanned      = 0;        // number of pages currently scanned
    BOOL bCallBackTransfer  = FALSE;    // callback transfer flag
    while (lPagesRequested > 0) {

        if (IsADFEnabled(pWiasContext)) {

            //
            // Check feeder for paper
            //

            hr = m_pScanAPI->ADFHasPaper();
            if (FAILED(hr)) {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, ADFHasPaper Failed"));
                WIAS_LHRESULT(m_pIWiaLog, hr);
                return hr;
            } else if(hr == S_FALSE){
                return WIA_ERROR_PAPER_EMPTY;
            }

            //
            // Attempt to load a page (only if needed)
            //

            hr = m_pScanAPI->ADFFeedPage();
            if (FAILED(hr)) {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, ADFFeedPage Failed"));
                WIAS_LHRESULT(m_pIWiaLog, hr);
                return hr;
            }

            //
            // Check feeder's status
            //

            hr = m_pScanAPI->ADFStatus();
            if (FAILED(hr)) {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, ADFStatus Failed"));
                WIAS_LHRESULT(m_pIWiaLog, hr);
                return hr;
            }
        }

        if (bBitmapData) {

            //
            // update image information
            //

            hr = wiasGetImageInformation(pWiasContext, 0, pmdtc);
            if (FAILED(hr)) {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, wiasGetImageInformation Failed"));
                WIAS_LHRESULT(m_pIWiaLog, hr);
                return hr;
            }

        }

        //
        //  Determine if this is a callback or file transfer.
        //

        if (pmdtc->tymed == TYMED_CALLBACK) {

            //
            // Scan the page to memory
            //

            bCallBackTransfer = TRUE;

            hr = ScanItemCB(pItemContext,
                            pmdtc,
                            plDevErrVal);

        } else {

            //
            // Scan the page to file
            //

            hr = ScanItem(pItemContext,
                          pmdtc,
                          plDevErrVal);

        }

        if (!bEmptyTheADF) {

            //
            // update pages requested counter
            //

            lPagesRequested--;
        }

        if (hr == S_FALSE) {

            //
            // user canceled the scan
            //

            lPagesRequested = 0; // set pages to 0 to cleanly exit loop
        }

        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvAcquireItemData, Pages left to scan = %d",lPagesRequested));

        if (IsADFEnabled(pWiasContext)) {

            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvAcquireItemData, Unloading a page from the feeder"));

            //
            // Attempt to unload the scanned page (only if needed)
            //

            hr = m_pScanAPI->ADFUnFeedPage();
            if (SUCCEEDED(hr)) {
                if (bCallBackTransfer) {

                    //
                    // send the NEW_PAGE message, when scanning multiple pages
                    // in callback mode.  This will let the calling application
                    // know when an end-of-page has been hit.
                    //

                    hr = wiasSendEndOfPage(pWiasContext, lPagesScanned, pmdtc);
                    if (FAILED(hr)) {
                        lPagesRequested = 0;
                        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, wiasSendEndOfPage Failed"));
                        WIAS_LHRESULT(m_pIWiaLog, hr);
                    }
                }

                //
                // increment pages scanned counter
                //

                lPagesScanned++;
            } else {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, ADFUnFeedPage (end transfer) Failed"));
                WIAS_LHRESULT(m_pIWiaLog, hr);
            }
        }

        //
        // free any allocated memory between scans to avoid memory leaks
        //

        if (!pmdtc->bClassDrvAllocBuf) {
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvAcquireItemData, Freeing any allocated memory (single scan operation complete)"));
            if (NULL != pmdtc->pTransferBuffer) {
                CoTaskMemFree(pmdtc->pTransferBuffer);
                pmdtc->pTransferBuffer = NULL;
            }
        }

        if (IsADFEnabled(pWiasContext)) { // FEEDER is enabled for scanning

            //
            // Check feeder for paper, to avoid error conditions
            //

            hr = m_pScanAPI->ADFHasPaper();
            if (S_FALSE == hr) {

                LONG lPages = GetPageCount(pWiasContext);

                //
                // have we scanned more than 1 page?
                //

                if(lPagesScanned > 0){

                    //
                    // Pages is set to n, and we successfully scanned n pages, return S_OK
                    //

                    if(lPagesScanned == lPages){
                        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, We are out of paper, but we successfully scanned the requested amount"));
                        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, returning S_OK"));
                        return S_OK;
                    }

                    //
                    // Pages is set to 0, and 1 or more pages have been scanned, return S_OK
                    //

                    if(lPages == 0){
                        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, We are out of paper, but we successfully scanned more than 1 page"));
                        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, returning S_OK"));
                        return S_OK;
                    }

                    //
                    // Pages is set to n, and we successfully scanned lPagesScanned but
                    // that is less than n...and the file is OK, return WIA_STATUS_END_OF_MEDIA
                    //

                    if ((lPages > 0)&&(lPagesScanned < lPages)) {
                        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, We are out of paper, but we successfully scanned more than 1 page..but less than requested"));
                        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, returning WIA_STATUS_END_OF_MEDIA"));
                        return WIA_STATUS_END_OF_MEDIA;
                    }
                }
            }
        }
    }

    //
    // we are now finished scanning all documents
    //

    if (!pmdtc->bClassDrvAllocBuf) {
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvAcquireItemData, Freeing any allocated memory (entire scan operation complete)"));
        if (NULL != pmdtc->pTransferBuffer) {
            CoTaskMemFree(pmdtc->pTransferBuffer);
            pmdtc->pTransferBuffer = NULL;
        }
    }

    return hr;
}

/**************************************************************************\
* IsPreviewScan
*
*   Get the current preview setting from the item properties.
*   A helper for drvAcquireItemData.
*
* Arguments:
*
*   pWiasContext - pointer to an Item context.
*
* Return Value:
*
*    TRUE - Preview is set, FALSE - Final is set
*
* History:
*
*    8/10/2000 Original Version
*
\**************************************************************************/

BOOL CWIAScannerDevice::IsPreviewScan(BYTE *pWiasContext)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::IsPreviewScan");
    //
    // Get a pointer to the root item, for property access.
    //

    BYTE *pRootItemCtx = NULL;

    HRESULT hr = wiasGetRootItem(pWiasContext, &pRootItemCtx);
    if (FAILED(hr)) {
        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("IsPreviewScan, No Preview Property Found on ROOT item!"));
        return FALSE;
    }

    //
    //  Get the current preview setting.
    //

    LONG lPreview = 0;

    hr = wiasReadPropLong(pRootItemCtx, WIA_DPS_PREVIEW, &lPreview, NULL, true);
    if (hr != S_OK) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("IsPreviewScan, Failed to read Preview Property."));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return FALSE;
    }

    return (lPreview > 0);
}

/**************************************************************************\
* IsADFEnabled
*
*   Get the current Document Handling Select setting from the item properties.
*
* Arguments:
*
*   pWiasContext - pointer to an Item context.
*
* Return Value:
*
*    TRUE - enabled, FALSE - disabled
*
* History:
*
*    5/01/2001 Original Version
*
\**************************************************************************/
BOOL CWIAScannerDevice::IsADFEnabled(BYTE *pWiasContext)
{
    HRESULT hr = S_OK;
    BOOL bEnabled = FALSE;
    //
    // Get a pointer to the root item, for property access.
    //

    BYTE *pRootItemCtx = NULL;

    hr = wiasGetRootItem(pWiasContext, &pRootItemCtx);
    if (SUCCEEDED(hr)) {

        //
        // read Document Handling Select property value
        //

        LONG lDocumentHandlingSelect = FLATBED;
        hr = wiasReadPropLong(pRootItemCtx,WIA_DPS_DOCUMENT_HANDLING_SELECT,&lDocumentHandlingSelect,NULL,TRUE);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("IsADFEnabled, wiasReadPropLong(WIA_DPS_DOCUMENT_HANDLING_SELECT) failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
        } else {
            if (lDocumentHandlingSelect & FEEDER) {

                //
                // FEEDER is set
                //

                WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("IsADFEnabled - ADF Enabled"));
                bEnabled = TRUE;
            } else {

                //
                // FEEDER is not set, default to FLATBED (WIAFBDRV only supports simple Document feeders at this time)
                //

                WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("IsADFEnabled  - ADF Disabled"));
                bEnabled = FALSE;
            }
        }
    } else {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("IsADFEnabled, wiasGetRootItem failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
    }
    return bEnabled;
}

/**************************************************************************\
* GetPageCount
*
*   Get the requested number of pages to scan from the item properties.
*   A helper for drvAcquireItemData.
*
* Arguments:
*
*   pWiasContext - pointer to an Item context.
*
* Return Value:
*
*    Number of pages to scan.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

LONG CWIAScannerDevice::GetPageCount(BYTE *pWiasContext)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::GetPageCount");
    //
    // Get a pointer to the root item, for property access.
    //

    BYTE *pRootItemCtx = NULL;

    HRESULT hr = wiasGetRootItem(pWiasContext, &pRootItemCtx);
    if (FAILED(hr)) {
        return 1;
    }

    //
    //  Get the requested page count.
    //

    LONG lPagesRequested = 0;

    hr = wiasReadPropLong(pRootItemCtx, WIA_DPS_PAGES, &lPagesRequested, NULL, true);
    if (hr != S_OK) {
        return 1;
    }

    return lPagesRequested;
}

/**************************************************************************\
* SetItemSize
*
*   Calulate the new item size, and write the new Item Size property value.
*
* Arguments:
*
*   pWiasContext       - item
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT CWIAScannerDevice::SetItemSize(
    BYTE *pWiasContext)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::SetItemSize");
    HRESULT  hr = S_OK;
    LONG lWidthInBytes = 0;
    LONG lMinBufSize   = 0;
    GUID guidFormatID  = GUID_NULL;
    MINIDRV_TRANSFER_CONTEXT mdtc;

    LONG lNumProperties = 3;
    PROPVARIANT pv[3];
    PROPSPEC ps[3] = {{PRSPEC_PROPID, WIA_IPA_ITEM_SIZE},
                      {PRSPEC_PROPID, WIA_IPA_BYTES_PER_LINE},
                      {PRSPEC_PROPID, WIA_IPA_MIN_BUFFER_SIZE}};

    //
    //  Clear the MiniDrvTransferContext
    //

    memset(&mdtc,0,sizeof(MINIDRV_TRANSFER_CONTEXT));

    //
    // read format GUID
    //

    hr = wiasReadPropGuid(pWiasContext, WIA_IPA_FORMAT, &guidFormatID, NULL, TRUE);
    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetItemSize, ReadPropLong WIA_IPA_FORMAT error"));
        return hr;
    }

    //
    // read TYMED
    //

    hr = wiasReadPropLong(pWiasContext,WIA_IPA_TYMED, (LONG*)&mdtc.tymed, NULL, TRUE);
    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetItemSize, ReadPropLong WIA_IPA_TYMED error"));
        return hr;
    }

    if ((guidFormatID == WiaImgFmt_BMP)||(guidFormatID == WiaImgFmt_MEMORYBMP)) {

        //
        // wias works for DIB, or uncompressed standard TIFF formats
        // Standard TIFFs are constructed using a DIB-like implementation.
        // The data is stored as one huge strip, rather than multiple smaller
        // strips.
        //

        hr = wiasGetImageInformation(pWiasContext, WIAS_INIT_CONTEXT, &mdtc);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetItemSize, could not get image information"));
            return hr;
        }

    } else {

        //
        // manually set the data transfer context members
        //

        mdtc.lImageSize     = 0;
        mdtc.lHeaderSize    = 0;
        mdtc.lItemSize      = 0;
        mdtc.cbWidthInBytes = 0;

    }

    //
    //  Set the MinBufferSize property.  MinBufferSize is the minimum buffer
    //  that a client can request for a data transfer.
    //

    switch (mdtc.tymed) {
    case TYMED_CALLBACK:

        //
        // callback uses driver's minimum buffer size.
        // This is could be taken from the micro driver at
        // initialization time.
        //

        lMinBufSize = m_MinBufferSize;
        break;

    case TYMED_FILE:

        //
        // file transfers, require that the minimum buffer size be the
        // entire length of the file.
        //

        lMinBufSize = mdtc.lImageSize + mdtc.lHeaderSize;
        break;

    default:

        //
        // unknown TYMED
        //

        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetItemSize, unknown tymed: 0x%08X", mdtc.tymed));
        return E_INVALIDARG;
    }

    //
    //  Initialize propvar's.  Then write the values.  Don't need to call
    //  PropVariantClear when done, since there are only LONG values.
    //

    for (int i = 0; i < lNumProperties; i++) {
        PropVariantInit(&pv[i]);
        pv[i].vt = VT_I4;
    }

    pv[0].lVal = mdtc.lItemSize;
    pv[1].lVal = mdtc.cbWidthInBytes;
    pv[2].lVal = lMinBufSize;

    //
    // Write WIA_IPA_ITEM_SIZE, WIA_IPA_BYTES_PER_LINE, and  WIA_IPA_MIN_BUFFER_SIZE
    // property values
    //

    hr = wiasWriteMultiple(pWiasContext, lNumProperties, ps, pv);
    if (SUCCEEDED(hr)) {

        //
        // Now update the MINIDRIVER TRANSFER CONTEXT with new values
        //

        //
        // Get a pointer to the associated driver item.
        //

        IWiaDrvItem* pDrvItem = NULL;

        hr = wiasGetDrvItem(pWiasContext, &pDrvItem);
        if (FAILED(hr)) {
            return hr;
        }

        //
        // Get driver item's context
        //

        PMINIDRIVERITEMCONTEXT pItemContext = NULL;

        hr = pDrvItem->GetDeviceSpecContext((BYTE**)&pItemContext);
        if (SUCCEEDED(hr)) {
            if ((guidFormatID == WiaImgFmt_BMP)||(guidFormatID == WiaImgFmt_MEMORYBMP)) {

                //
                // Calculate how many scan lines will fit in the buffer.
                //

                pItemContext->lBytesPerScanLineRaw = ((mdtc.lWidthInPixels * mdtc.lDepth) + 7)  / 8;
                pItemContext->lBytesPerScanLine    = (((mdtc.lWidthInPixels * mdtc.lDepth) + 31) / 8) & 0xfffffffc;
                pItemContext->lTotalRequested      = pItemContext->lBytesPerScanLineRaw * mdtc.lLines;
            } else {
                pItemContext->lBytesPerScanLineRaw = 0;
                pItemContext->lBytesPerScanLine    = 0;
                pItemContext->lTotalRequested      = 0;
            }
        } else {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvWriteItemProperties, NULL item context"));
        }
    } else {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetItemSize, WriteMultiple failed"));
    }

    return hr;
}

/**************************************************************************\
* CWIAScannerDevice::drvInitItemProperties
*
*   Initialize the device item properties. Called during item
*   initialization.  This is called by the WIA Class driver
*   after the item tree has been built.  It is called once for every
*   item in the tree.
*
* Arguments:
*
*   pWiasContext    - Pointer to WIA context (item information).
*   lFlags          - Operation flags, unused.
*   plDevErrVal     - Pointer to the device error value.
*
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvInitItemProperties(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvInitItemProperties");
    HRESULT hr = S_OK;

    //
    //  This device doesn't touch hardware to initialize the device item
    //  properties, so set plDevErrVal to 0.
    //

    if (plDevErrVal) {
        *plDevErrVal = 0;
    }

    //
    //  Get a pointer to the associated driver item.
    //

    IWiaDrvItem* pDrvItem;
    hr = wiasGetDrvItem(pWiasContext, &pDrvItem);
    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, wiasGetDrvItem failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    //  Set initial item properties.
    //

    LONG    lItemType = 0;

    pDrvItem->GetItemFlags(&lItemType);

    if (lItemType & WiaItemTypeRoot) {

        //
        //  This is for the root item.
        //

        //
        // Build Root Item Properties, initializing global
        // structures with their default and valid values
        //

        hr = BuildRootItemProperties();

        if(FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, BuildRootItemProperties failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            DeleteRootItemProperties();
            return hr;
        }

        //
        //  Add the device specific root item property names,
        //  using WIA service.
        //

        hr = wiasSetItemPropNames(pWiasContext,
                                  m_NumRootItemProperties,
                                  m_piRootItemDefaults,
                                  m_pszRootItemDefaults);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, wiasSetItemPropNames failed"));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_NumRootItemPropeties = %d",m_NumRootItemProperties));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_piRootItemDefaults   = %x",m_piRootItemDefaults));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_pszRootItemDefaults  = %x",m_pszRootItemDefaults));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            DeleteRootItemProperties();
            return hr;
        }

        //
        //  Set the device specific root item properties to
        //  their default values using WIA service.
        //

        hr = wiasWriteMultiple(pWiasContext,
                               m_NumRootItemProperties,
                               m_psRootItemDefaults,
                               m_pvRootItemDefaults);
        //
        // Free PROPVARIANT array, This frees any memory that was allocated for a prop variant value.
        //

        // FreePropVariantArray(m_NumRootItemProperties,m_pvRootItemDefaults);


        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, wiasWriteMultiple failed"));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_NumRootItemPropeties = %d",m_NumRootItemProperties));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_pszRootItemDefaults  = %x",m_pszRootItemDefaults));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_pvRootItemDefaults   = %x",m_pvRootItemDefaults));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            DeleteRootItemProperties();
            return hr;
        }

        //
        //  Use WIA services to set the property access and
        //  valid value information from m_wpiItemDefaults.
        //

        hr =  wiasSetItemPropAttribs(pWiasContext,
                                     m_NumRootItemProperties,
                                     m_psRootItemDefaults,
                                     m_wpiRootItemDefaults);

        if(FAILED(hr)){
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, wiasSetItemPropAttribs failed"));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_NumRootItemPropeties = %d",m_NumRootItemProperties));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_psRootItemDefaults   = %x",m_psRootItemDefaults));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_wpiRootItemDefaults  = %x",m_wpiRootItemDefaults));
            WIAS_LHRESULT(m_pIWiaLog, hr);
        }

        //
        // free allocated property arrays, for more memory
        //

        DeleteRootItemProperties();


    } else {

        //
        //  This is for the child item.(Top)
        //

        //
        // Build Top Item Properties, initializing global
        // structures with their default and valid values
        //

        hr = BuildTopItemProperties();

        if(FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, BuildTopItemProperties failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            DeleteTopItemProperties();
            return hr;
        }

        //
        //  Use the WIA service to set the item property names.
        //

        hr = wiasSetItemPropNames(pWiasContext,
                                  m_NumItemProperties,
                                  m_piItemDefaults,
                                  m_pszItemDefaults);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, wiasSetItemPropNames failed"));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_NumItemPropeties = %d",m_NumItemProperties));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_piItemDefaults   = %x",m_piItemDefaults));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_pszItemDefaults  = %x",m_pszItemDefaults));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            DeleteTopItemProperties();
            return hr;
        }

        //
        //  Use WIA services to set the item properties to their default
        //  values.
        //

        hr = wiasWriteMultiple(pWiasContext,
                               m_NumItemProperties,
                               m_psItemDefaults,
                               (PROPVARIANT*)m_pvItemDefaults);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, wiasWriteMultiple failed"));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_NumItemPropeties = %d",m_NumItemProperties));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_pszItemDefaults  = %x",m_pszItemDefaults));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_pvItemDefaults   = %x",m_pvItemDefaults));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            DeleteTopItemProperties();
            return hr;
        }

        //
        //  Use WIA services to set the property access and
        //  valid value information from m_wpiItemDefaults.
        //

        hr =  wiasSetItemPropAttribs(pWiasContext,
                                     m_NumItemProperties,
                                     m_psItemDefaults,
                                     m_wpiItemDefaults);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, wiasSetItemPropAttribs failed"));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_NumItemPropeties = %d",m_NumItemProperties));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_psItemDefaults   = %x",m_psItemDefaults));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_wpiItemDefaults  = %x",m_wpiItemDefaults));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            DeleteTopItemProperties();
            return hr;
        }

        //
        //  Set item size properties.
        //

        hr = SetItemSize(pWiasContext);
        if(FAILED(hr)){
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, SetItemSize failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
        }

        //
        // free allocated property arrays, for more memory
        //

        DeleteTopItemProperties();
    }
    return hr;
}


/**************************************************************************\
* CWIAScannerDevice::drvValidateItemProperties
*
*   Validate the device item properties.  It is called when changes are made
*   to an item's properties.  Driver should not only check that the values
*   are valid, but must update any valid values that may change as a result.
*   If an a property is not being written by the application, and it's value
*   is invalid, then "fold" it to a new value, else fail validation (because
*   the application is setting the property to an invalid value).
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA item, unused.
*   lFlags          - Operation flags, unused.
*   nPropSpec       - The number of properties that are being written
*   pPropSpec       - An array of PropSpecs identifying the properties that
*                     are being written.
*   plDevErrVal     - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
***************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvValidateItemProperties(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    ULONG                       nPropSpec,
    const PROPSPEC              *pPropSpec,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvValidateItemProperties");

    HRESULT hr      = S_OK;
    LONG lItemType  = 0;
    WIA_PROPERTY_CONTEXT Context;

    if (plDevErrVal) {
        *plDevErrVal = 0;
    }

    hr = wiasGetItemType(pWiasContext, &lItemType);
    if (SUCCEEDED(hr)) {
        if (lItemType & WiaItemTypeRoot) {

            //
            //  Validate root item
            //


            hr = wiasCreatePropContext(nPropSpec,
                                       (PROPSPEC*)pPropSpec,
                                       0,
                                       NULL,
                                       &Context);
            if (SUCCEEDED(hr)) {

                //
                // Check ADF to see if the status settings need to be updated
                // Also switch between FEEDER/FLATBED modes
                //

                hr = CheckADFStatus(pWiasContext, &Context);
                if(FAILED(hr)) {
                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, CheckADFStatus failed"));
                    WIAS_LHRESULT(m_pIWiaLog, hr);
                }

                //
                // check Preview Property only if validation is successful so far....
                //

                if (SUCCEEDED(hr)) {

                    //
                    // Check Preview property to see if the settings are valid
                    //

                    hr = CheckPreview(pWiasContext, &Context);
                    if (FAILED(hr)) {
                        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, CheckPreview failed"));
                        WIAS_LHRESULT(m_pIWiaLog, hr);
                    }
                }
            } else {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, wiasCreatePropContext failed (Root Item)"));
                WIAS_LHRESULT(m_pIWiaLog, hr);
            }

            //
            // call WIA service helper to validate other properties
            //

            if (SUCCEEDED(hr)) {
                hr = wiasValidateItemProperties(pWiasContext, nPropSpec, pPropSpec);
                if (FAILED(hr)) {
                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, wiasValidateItemProperties failed."));
                    WIAS_LHRESULT(m_pIWiaLog, hr);
                    return hr;
                }
            }

        } else {

            //
            // validate item properties here
            //

            //
            //  Create a property context needed by some WIA Service
            //  functions used below.
            //

            hr = wiasCreatePropContext(nPropSpec,
                                       (PROPSPEC*)pPropSpec,
                                       0,
                                       NULL,
                                       &Context);
            if (SUCCEEDED(hr)) {

                //
                //  Check Current Intent first
                //

                hr = CheckIntent(pWiasContext, &Context);
                if (SUCCEEDED(hr)) {

                    //
                    //  Check if DataType is being written
                    //

                    hr = CheckDataType(pWiasContext, &Context);
                    if (SUCCEEDED(hr)) {
#ifdef _SERVICE_EXTENT_VALIDATION

                        //
                        //  Use the WIA service to update the scan rect
                        //  properties and valid values.
                        //

                        LONG lBedWidth  = 0;
                        LONG lBedHeight = 0;
                        hr = m_pScanAPI->GetBedWidthAndHeight(&lBedWidth,&lBedHeight);
                        if(FAILED(hr)){
                            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, m_pScanAPI->GetBedWidthAndHeight failed"));
                            WIAS_LHRESULT(m_pIWiaLog, hr);
                            return hr;
                        }

                        hr = wiasUpdateScanRect(pWiasContext,
                                                &Context,
                                                lBedWidth,
                                                lBedHeight);

#endif
                        if (SUCCEEDED(hr)) {

                            //
                            //  Use the WIA Service to update the valid values
                            //  for Format.  These are based on the value of
                            //  WIA_IPA_TYMED, so validation is also performed
                            //  on the tymed property by the service.
                            //

                            hr = wiasUpdateValidFormat(pWiasContext,
                                                       &Context,
                                                       (IWiaMiniDrv*) this);

                            if (SUCCEEDED(hr)) {

                                //
                                // Check Preferred format
                                //

                                hr = CheckPreferredFormat(pWiasContext, &Context);
                                if(FAILED(hr)){
                                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, CheckPreferredFormat failed"));
                                    WIAS_LHRESULT(m_pIWiaLog, hr);
                                }
                            } else {
                                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, wiasUpdateValidFormat failed"));
                                WIAS_LHRESULT(m_pIWiaLog, hr);
                            }
                        } else {
                            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, wiasUpdateScanRect failed"));
                            WIAS_LHRESULT(m_pIWiaLog, hr);
                        }
                    } else {
                        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, CheckDataType failed"));
                        WIAS_LHRESULT(m_pIWiaLog, hr);
                    }
                } else {
                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, CheckIntent failed"));
                    WIAS_LHRESULT(m_pIWiaLog, hr);
                }
                wiasFreePropContext(&Context);
            } else {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, wiasCreatePropContext failed (Child Item)"));
                WIAS_LHRESULT(m_pIWiaLog, hr);
            }

            //
            //  Update the item size
            //

            if (SUCCEEDED(hr)) {
                hr = SetItemSize(pWiasContext);
                if(FAILED(hr)){
                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, SetItemSize failed"));
                    WIAS_LHRESULT(m_pIWiaLog, hr);
                }

                //
                // call WIA service helper to validate other properties
                //

                if (SUCCEEDED(hr)) {
                    hr = wiasValidateItemProperties(pWiasContext, nPropSpec, pPropSpec);
                    if (FAILED(hr)) {
                        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, wiasValidateItemProperties failed."));
                        WIAS_LHRESULT(m_pIWiaLog, hr);
                        return hr;
                    }
                }
            }

        }
    } else {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, wiasGetItemType failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
    }

    //
    // log HRESULT sent back to caller
    //

    if(FAILED(hr)){
        WIAS_LHRESULT(m_pIWiaLog, hr);
    }

    return hr;
}

/**************************************************************************\
* CWIAScannerDevice::drvWriteItemProperties
*
*   Write the device item properties to the hardware.  This is called by the
*   WIA Class driver prior to drvAcquireItemData when the client requests
*   a data transfer.
*
* Arguments:
*
*   pWiasContext - Pointer to WIA item.
*   lFlags       - Operation flags, unused.
*   pmdtc        - Pointer to mini driver context. On entry, only the
*                  portion of the mini driver context which is derived
*                  from the item properties is filled in.
*   plDevErrVal  - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvWriteItemProperties(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    PMINIDRV_TRANSFER_CONTEXT   pmdtc,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvWriteItemProperties");
    HRESULT hr = S_OK;
    if (plDevErrVal) {
        *plDevErrVal = 0;
    }
    LONG lNumProperties = 10;
    PROPVARIANT pv[10];

    //
    // The order of these should not change. They are referenced below
    // by index.
    //

    PROPSPEC ps[10] = {
        {PRSPEC_PROPID, WIA_IPS_XRES},
        {PRSPEC_PROPID, WIA_IPS_YRES},
        {PRSPEC_PROPID, WIA_IPS_XPOS},
        {PRSPEC_PROPID, WIA_IPS_YPOS},
        {PRSPEC_PROPID, WIA_IPS_XEXTENT},
        {PRSPEC_PROPID, WIA_IPS_YEXTENT},
        {PRSPEC_PROPID, WIA_IPA_DATATYPE},
        {PRSPEC_PROPID, WIA_IPS_BRIGHTNESS},
        {PRSPEC_PROPID, WIA_IPS_CONTRAST},
        {PRSPEC_PROPID, WIA_IPA_FORMAT}
    };

    //
    // initialize propvariant structures
    //

    for (int i = 0; i< lNumProperties;i++) {
        pv[i].vt = VT_I4;
    }

    //
    // read child item properties
    //

    hr = wiasReadMultiple(pWiasContext, lNumProperties, ps, pv, NULL);

    if (hr == S_OK) {

        hr = m_pScanAPI->SetXYResolution(pv[0].lVal,pv[1].lVal);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,
                        WIALOG_NO_RESOURCE_ID,
                        ("drvWriteItemProperties, Setting x any y resolutions failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }

        hr = m_pScanAPI->SetDataType(pv[6].lVal);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,
                        WIALOG_NO_RESOURCE_ID,
                        ("drvWriteItemProperties, Setting data type failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }

        hr = m_pScanAPI->SetIntensity(pv[7].lVal);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,
                        WIALOG_NO_RESOURCE_ID,
                        ("drvWriteItemProperties, Setting intensity failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }

        hr = m_pScanAPI->SetContrast(pv[8].lVal);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,
                        WIALOG_NO_RESOURCE_ID,
                        ("drvWriteItemProperties, Setting contrast failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }

        hr = m_pScanAPI->SetSelectionArea(pv[2].lVal, pv[3].lVal, pv[4].lVal, pv[5].lVal);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,
                        WIALOG_NO_RESOURCE_ID,
                        ("drvWriteItemProperties, Setting selection area (extents) failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }

        hr = m_pScanAPI->SetFormat((GUID*)pv[9].puuid);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,
                        WIALOG_NO_RESOURCE_ID,
                        ("drvWriteItemProperties, Setting current format failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            PropVariantClear(&pv[9]);
            return hr;
        }
        PropVariantClear(&pv[9]);
    }
    return hr;
}

/**************************************************************************\
* CWIAScannerDevice::drvReadItemProperties
*
*   Read the device item properties.  When a client application tries to
*   read a WIA Item's properties, the WIA Class driver will first notify
*   the driver by calling this method.
*
* Arguments:
*
*   pWiasContext - wia item
*   lFlags       - Operation flags, unused.
*   nPropSpec    - Number of elements in pPropSpec.
*   pPropSpec    - Pointer to property specification, showing which properties
*                  the application wants to read.
*   plDevErrVal  - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvReadItemProperties(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    ULONG                       nPropSpec,
    const PROPSPEC              *pPropSpec,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvReadItemProperties");
    if (plDevErrVal) {
        *plDevErrVal = 0;
    }

    return S_OK;
}

/**************************************************************************\
* CWIAScannerDevice::drvLockWiaDevice
*
*   Lock access to the device.
*
* Arguments:
*
*   pWiasContext - unused, can be NULL
*   lFlags       - Operation flags, unused.
*   plDevErrVal  - Pointer to the device error value.
*
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvLockWiaDevice(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvLockWiaDevice");
    if (plDevErrVal) {
        *plDevErrVal = 0;
    }
    return m_pStiDevice->LockDevice(m_dwLockTimeout);
}

/**************************************************************************\
* CWIAScannerDevice::drvUnLockWiaDevice
*
*   Unlock access to the device.
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA item, unused.
*   lFlags          - Operation flags, unused.
*   plDevErrVal     - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvUnLockWiaDevice(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvUnLockWiaDevice");
    if (plDevErrVal) {
        *plDevErrVal = 0;
    }
    return m_pStiDevice->UnLockDevice();
}

/**************************************************************************\
* CWIAScannerDevice::drvAnalyzeItem
*
*   This device does not support image analysis, so return E_NOTIMPL.
*
* Arguments:
*
*   pWiasContext - Pointer to the device item to be analyzed.
*   lFlags       - Operation flags.
*   plDevErrVal  - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvAnalyzeItem(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvAnalyzeItem");
    if (plDevErrVal) {
        *plDevErrVal = 0;
    }
    return E_NOTIMPL;
}

/**************************************************************************\
* CWIAScannerDevice::drvFreeDrvItemContext
*
*   Free any device specific context.
*
* Arguments:
*
*   lFlags          - Operation flags, unused.
*   pDevSpecContext - Pointer to device specific context.
*   plDevErrVal     - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvFreeDrvItemContext(
    LONG                        lFlags,
    BYTE                        *pSpecContext,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvFreeDrvItemContext");
    if (plDevErrVal) {
        *plDevErrVal = 0;
    }
    PMINIDRIVERITEMCONTEXT pContext = NULL;
    pContext = (PMINIDRIVERITEMCONTEXT) pSpecContext;

    if (pContext){
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvFreeDrvItemContext, Freeing my allocated context members"));
    }

    return S_OK;
}

/**************************************************************************\
* CWIAScannerDevice::drvInitializeWia
*
*   Initialize the WIA mini driver.  This will build up the driver item tree
*   and perform any other initialization code that's needed for WIA.
*
* Arguments:
*
*   pWiasContext          - Pointer to the WIA item, unused.
*   lFlags                - Operation flags, unused.
*   bstrDeviceID          - Device ID.
*   bstrRootFullItemName  - Full item name.
*   pIPropStg             - Device info. properties.
*   pStiDevice            - STI device interface.
*   pIUnknownOuter        - Outer unknown interface.
*   ppIDrvItemRoot        - Pointer to returned root item.
*   ppIUnknownInner       - Pointer to returned inner unknown.
*   plDevErrVal           - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvInitializeWia(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    BSTR                        bstrDeviceID,
    BSTR                        bstrRootFullItemName,
    IUnknown                    *pStiDevice,
    IUnknown                    *pIUnknownOuter,
    IWiaDrvItem                 **ppIDrvItemRoot,
    IUnknown                    **ppIUnknownInner,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvInitializeWia");
    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitializeWia, bstrDeviceID         = %ws", bstrDeviceID));
    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitializeWia, bstrRootFullItemName = %ws",bstrRootFullItemName));
    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitializeWia, lFlags               = %d",lFlags));
    HRESULT hr = S_OK;

    if (plDevErrVal) {
        *plDevErrVal = 0;
    }

    *ppIDrvItemRoot = NULL;
    *ppIUnknownInner = NULL;

    //
    //  Need to init names and STI pointer?
    //

    if (m_pStiDevice == NULL) {

        //
        // save STI device interface for locking
        //

        m_pStiDevice = (IStiDevice *)pStiDevice;

        //
        // Cache the device ID.
        //

        m_bstrDeviceID = SysAllocString(bstrDeviceID);

        if (!m_bstrDeviceID) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, unable to allocate device ID string"));
            return E_OUTOFMEMORY;
        }

        //
        // Cache the root property stream name.
        //

        m_bstrRootFullItemName = SysAllocString(bstrRootFullItemName);

        if (!m_bstrRootFullItemName) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, unable to allocate prop stream name"));
            return E_OUTOFMEMORY;
        }
    }

    //
    // Initialize Capabilities array
    //

    hr = BuildCapabilities();

    if(FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, BuildCapabilities failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // Initialize SupportedFormats array
    //

    hr = BuildSupportedFormats();

    if(FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, BuildSupportedFormats failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // Initialize Supported Data Type array
    //

    hr = BuildSupportedDataTypes();

    if(FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, BuildSupportedDataTypes failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // Initialize Supported Intents array
    //

    hr = BuildSupportedIntents();

    if(FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, BuildSupportedIntents failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // Initialize Supported TYMED array
    //

    hr = BuildSupportedTYMED();

    if(FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, BuildSuportedTYMED failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // Initialize  Supported compression types array
    //

    hr = BuildSupportedCompressions();

    if(FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, BuildSupportedCompressions"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // Initialize  Supported Preview modes array
    //

    hr = BuildSupportedPreviewModes();

    if(FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, BuildSupportedPreviewModes"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // Initialize  initial formats array
    //

    hr = BuildInitialFormats();

    if(FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, BuildInitialFormats failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // Initialize supported resolutions array
    //

    hr = BuildSupportedResolutions();
    if(FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, BuildSupportedResolutions failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    //  Build the device item tree, if it hasn't been built yet.
    //
    //  Send a Device Command to yourself, or Call BuildItemTree manually
    //

    if (!m_pIDrvItemRoot) {
        LONG    lDevErrVal = 0;
        hr = drvDeviceCommand(NULL, 0, &WIA_CMD_SYNCHRONIZE, NULL, &lDevErrVal);
        if(FAILED(hr)){
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, drvDeviceCommand(WIA_CMD_SYNCHRONIZE) failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
        }
    }

    //
    // save root item pointer. (REMEMBER TO RELEASE THIS INTERFACE)
    //

    *ppIDrvItemRoot = m_pIDrvItemRoot;

    return hr;
}

/**************************************************************************\
* CWIAScannerDevice::drvUnInitializeWia
*
*   Gets called when a client connection is going away.
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA Root item context of the client's
*                     item tree.
*
* Return Value:
*    Status
*
* History:
*
*   7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvUnInitializeWia(
    BYTE                *pWiasContext)
{
    return S_OK;
}


/**************************************************************************\
* drvGetDeviceErrorStr
*
*   Map a device error value to a string.
*
* Arguments:
*
*   lFlags        - Operation flags, unused.
*   lDevErrVal    - Device error value.
*   ppszDevErrStr - Pointer to returned error string.
*   plDevErrVal   - Pointer to the device error value.
*
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvGetDeviceErrorStr(
    LONG                        lFlags,
    LONG                        lDevErrVal,
    LPOLESTR                    *ppszDevErrStr,
    LONG                        *plDevErr)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvGetDeviceErrorStr");
    HRESULT hr = S_OK;

    //
    //  Map device errors to a string to be placed in the event log.
    //

    if (plDevErr) {
        if (*ppszDevErrStr) {

            //
            // look up error strings in resource file.
            //

            switch (lDevErrVal) {
            case 0:
                *ppszDevErrStr = L"No Error";                   // hard coded for now
                *plDevErr  = 0;
                hr = S_OK;
                break;
            default:
                *ppszDevErrStr = L"Device Error, Unknown Error";// hard coded for now
                *plDevErr  = 0;
                hr = E_FAIL;
                break;
            }
        }
    }
    return hr;
}

/**************************************************************************\
* drvDeviceCommand
*
*   Issue a command to the device.
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA item.
*   lFlags          - Operation flags, unused.
*   plCommand       - Pointer to command GUID.
*   ppWiaDrvItem    - Optional pointer to returned item, unused.
*   plDevErrVal     - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvDeviceCommand(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    const GUID                  *plCommand,
    IWiaDrvItem                 **ppWiaDrvItem,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvDeviceCommand");
    if(plDevErrVal){
        *plDevErrVal = 0;
    }

    HRESULT hr = S_OK;

    //
    //  Check which command was issued
    //

    if (*plCommand == WIA_CMD_SYNCHRONIZE) {

        //
        // SYNCHRONIZE - Build the minidriver representation of
        //               the current item list, if it doesn't exist.
        //

        if (!m_pIDrvItemRoot) {
            hr = BuildItemTree();
        } else {
            hr = S_OK;
        }
    } else {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvDeviceCommand, unknown command sent to this device"));
        hr = E_NOTIMPL;
    }

    return hr;
}


/**************************************************************************\
* CWIAScannerDevice::drvGetCapabilities
*
*   Get supported device commands and events as an array of WIA_DEV_CAPS.
*
* Arguments:
*
*   pWiasContext   - Pointer to the WIA item, unused.
*   lFlags         - Operation flags.
*   pcelt          - Pointer to returned number of elements in
*                    returned GUID array.
*   ppCapabilities - Pointer to returned GUID array.
*   plDevErrVal    - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvGetCapabilities(
    BYTE                        *pWiasContext,
    LONG                        ulFlags,
    LONG                        *pcelt,
    WIA_DEV_CAP_DRV             **ppCapabilities,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvGetCapabilites");
    if(plDevErrVal){
        *plDevErrVal = 0;
    }

    HRESULT hr = S_OK;

    //
    // Initialize Capabilities array
    //

    hr = BuildCapabilities();

    if(FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvGetCapabilities, BuildCapabilities failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    //  Return depends on flags.  Flags specify whether we should return
    //  commands, events, or both.
    //
    //

    switch (ulFlags) {
    case WIA_DEVICE_COMMANDS:

        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvGetCapabilities, (WIA_DEVICE_COMMANDS)"));

        //
        //  report commands only
        //

        *pcelt          = m_NumSupportedCommands;
        *ppCapabilities = &m_pCapabilities[m_NumSupportedEvents];
        break;
    case WIA_DEVICE_EVENTS:

        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvGetCapabilities, (WIA_DEVICE_EVENTS)"));

        //
        //  report events only
        //

        *pcelt          = m_NumSupportedEvents;
        *ppCapabilities = m_pCapabilities;
        break;
    case (WIA_DEVICE_COMMANDS | WIA_DEVICE_EVENTS):

        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvGetCapabilities, (WIA_DEVICE_COMMANDS|WIA_DEVICE_EVENTS)"));

        //
        //  report both events and commands
        //

        *pcelt          = m_NumCapabilities;
        *ppCapabilities = m_pCapabilities;
        break;
    default:

        //
        //  invalid request
        //

        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvGetCapabilities, invalid flags"));
        return E_INVALIDARG;
    }
    return hr;
}

/**************************************************************************\
* drvGetWiaFormatInfo
*
*   Returns an array of WIA_FORMAT_INFO structs, which specify the format
*   and media type pairs that are supported.
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA item context, unused.
*   lFlags          - Operation flags, unused.
*   pcelt           - Pointer to returned number of elements in
*                     returned WIA_FORMAT_INFO array.
*   ppwfi           - Pointer to returned WIA_FORMAT_INFO array.
*   plDevErrVal     - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*   7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvGetWiaFormatInfo(
    BYTE                *pWiasContext,
    LONG                lFlags,
    LONG                *pcelt,
    WIA_FORMAT_INFO     **ppwfi,
    LONG                *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvGetWiaFormatInfo");

    HRESULT hr = S_OK;

    if(NULL == m_pSupportedFormats){
        hr = BuildSupportedFormats();
    }

    if(plDevErrVal){
        *plDevErrVal = 0;
    }
    *pcelt       = m_NumSupportedFormats;
    *ppwfi       = m_pSupportedFormats;
    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvGetWiaFormatInfo, m_NumSupportedFormats = %d",m_NumSupportedFormats));
    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvGetWiaFormatInfo, m_pSupportedFormats   = %x",m_pSupportedFormats));
    return hr;
}

/**************************************************************************\
* drvNotifyPnpEvent
*
*   Pnp Event received by device manager.  This is called when a Pnp event
*   is received for this device.
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvNotifyPnpEvent(
    const GUID                  *pEventGUID,
    BSTR                        bstrDeviceID,
    ULONG                       ulReserved)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvNotifyPnpEvent");
    HRESULT hr = S_OK;

    if (*pEventGUID == WIA_EVENT_DEVICE_DISCONNECTED) {
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvNotifyPnpEvent, (WIA_EVENT_DEVICE_DISCONNECTED)"));
        hr = m_pScanAPI->DisableDevice();
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvNotifyPnpEvent, disable failed"));
        }
    }

    if (*pEventGUID == WIA_EVENT_POWER_SUSPEND){
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvNotifyPnpEvent, (WIA_EVENT_POWER_SUSPEND)"));
        hr = m_pScanAPI->DisableDevice();
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvNotifyPnpEvent, disable failed"));
        }
    }

    if (*pEventGUID == WIA_EVENT_POWER_RESUME){
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvNotifyPnpEvent, (WIA_EVENT_POWER_RESUME)"));
        hr = m_pScanAPI->EnableDevice();
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvNotifyPnpEvent, enable failed"));
        }

        if (NULL != m_hSignalEvent) {
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvNotifyPnpEvent, (restarting interrrupt event system)"));
            hr = SetNotificationHandle(m_hSignalEvent);
            if (FAILED(hr)) {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvNotifyPnpEvent, SetNotificationHandle failed"));
            }
        } else {
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvNotifyPnpEvent, (not restarting interrrupt event system), device may not need it."));
        }
    }

    return hr;
}


/*******************************************************************************
*
*                 P R I V A T E   M E T H O D S
*
*******************************************************************************/

/**************************************************************************\
* AlignInPlace
*
*   DWORD align a data buffer in place.
*
* Arguments:
*
*   pBuffer              - Pointer to the data buffer.
*   cbWritten            - Size of the data in bytes.
*   lBytesPerScanLine    - Number of bytes per scan line in the output data.
*   lBytesPerScanLineRaw - Number of bytes per scan line in the input data.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

UINT CWIAScannerDevice::AlignInPlace(
   PBYTE pBuffer,
   LONG  cbWritten,
   LONG  lBytesPerScanLine,
   LONG  lBytesPerScanLineRaw)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "::AlignInPlace");
    if (lBytesPerScanLineRaw % 4) {

      UINT  uiPadBytes          = lBytesPerScanLine - lBytesPerScanLineRaw;
      UINT  uiDevLinesWritten   = cbWritten / lBytesPerScanLineRaw;

      PBYTE pSrc = pBuffer + cbWritten - 1;
      PBYTE pDst = pBuffer + (uiDevLinesWritten * lBytesPerScanLine) - 1;

      while (pSrc >= pBuffer) {
         pDst -= uiPadBytes;

         for (LONG i = 0; i < lBytesPerScanLineRaw; i++) {
            *pDst-- = *pSrc--;
         }
      }
      return uiDevLinesWritten * lBytesPerScanLine;
   }
   return cbWritten;
}

/**************************************************************************\
* UnlinkItemTree
*
*   Call device manager to unlink and release our reference to
*   all items in the driver item tree.
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::DeleteItemTree(void)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::DeleteItemTree");
    HRESULT hr = S_OK;

    //
    // If no tree, return.
    //

    if (!m_pIDrvItemRoot) {
        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("DeleteItemTree, no tree to delete..."));
        return S_OK;
    }

    //
    //  Call device manager to unlink the driver item tree.
    //

    hr = m_pIDrvItemRoot->UnlinkItemTree(WiaItemTypeDisconnected);

    if (SUCCEEDED(hr)) {
        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("DeleteItemTree, m_pIDrvItemRoot is being released!!"));
        m_pIDrvItemRoot->Release();
        m_pIDrvItemRoot = NULL;
    }

    return hr;
}

/**************************************************************************\
* BuildItemTree
*
*   The device uses the WIA Service functions to build up a tree of
*   device items. This device supports only a single data acquisition item so
*   build a device item tree with only one child off the root.
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::BuildItemTree(void)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::BuildItemTree");
    //
    //  The device item tree must not exist.
    //

    WIAS_ASSERT( (g_hInst), (m_pIDrvItemRoot == NULL));

    //
    //  Call the class driver to create the root item.
    //

    HRESULT hr = E_FAIL;

    //
    //  Name the root.
    //

    BSTR bstrRootItemName = NULL;
    hr = GetBSTRResourceString(IDS_ROOTITEM_NAME,&bstrRootItemName,TRUE);
    if (SUCCEEDED(hr)) {
        hr = wiasCreateDrvItem(WiaItemTypeFolder |
                               WiaItemTypeDevice |
                               WiaItemTypeRoot,
                               bstrRootItemName,
                               m_bstrRootFullItemName,
                               (IWiaMiniDrv *)this,
                               sizeof(MINIDRIVERITEMCONTEXT),
                               NULL,
                               &m_pIDrvItemRoot);

        SysFreeString(bstrRootItemName);
    }

    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildItemTree, wiasCreateDrvItem failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    //  Create and add the Top/Front and Bottom/Back device items.
    //

    for (INT i = 0; i < NUM_DEVICE_ITEM; i++) {

        //
        //  Build the item names.
        //

        BSTR bstrItemName = NULL;
        hr = GetBSTRResourceString(IDS_TOPITEM_NAME,&bstrItemName,TRUE);
        if (SUCCEEDED(hr)) {

            // SBB - RAID 370299 - orenr - 2001/04/18 - Security fix -
            // potential buffer overrun.  Changed wcscpy and wcscat
            // to use _snwprintf instead

            WCHAR  szFullItemName[MAX_PATH + 1] = {0};

            _snwprintf(szFullItemName,
                       (sizeof(szFullItemName) / sizeof(WCHAR)) - 1,
                       L"%ls\\%ls",
                       m_bstrRootFullItemName,
                       bstrItemName);

            //
            //  Call the class driver to create another driver item.
            //  This will be inserted as the child item.
            //

            PMINIDRIVERITEMCONTEXT pItemContext;
            IWiaDrvItem           *pItem = NULL;

            hr = wiasCreateDrvItem(WiaItemTypeFile  |
                                   WiaItemTypeImage |
                                   WiaItemTypeDevice,
                                   bstrItemName,
                                   szFullItemName,
                                   (IWiaMiniDrv *)this,
                                   sizeof(MINIDRIVERITEMCONTEXT),
                                   (PBYTE*) &pItemContext,
                                   &pItem);

            if (SUCCEEDED(hr)) {

                //
                // Initialize device specific context.
                //

                memset(pItemContext, 0, sizeof(MINIDRIVERITEMCONTEXT));
                pItemContext->lSize = sizeof(MINIDRIVERITEMCONTEXT);

                //
                //  Call the class driver to add pItem to the folder
                //  m_pIDrvItemRoot (i.e. make pItem a child of
                //  m_pIDrvItemRoot).
                //

                hr = pItem->AddItemToFolder(m_pIDrvItemRoot);

                if (FAILED(hr)) {
                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildItemTree, AddItemToFolder failed"));
                    WIAS_LHRESULT(m_pIWiaLog, hr);
                }

                //
                // release and created items
                //

                pItem->Release();

            } else {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildItemTree, wiasCreateDrvItem failed"));
                WIAS_LHRESULT(m_pIWiaLog, hr);
            }

            //
            // free the BSTR allocated by the BSTRResourceString helper
            //

            SysFreeString(bstrItemName);

        } else {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildItemTree, unable to allocate item name"));
            hr = E_OUTOFMEMORY;
        }

        break;  // Error if here, quit iterating.
    }

    if (FAILED(hr)) {
        DeleteItemTree();
    }
    return hr;
}

/**************************************************************************\
* DeleteRootItemProperties
*
*   This helper deletes the arrays used for Property intialization.
*
*       [Array Name]            [Description]          [Array Type]
*
*   m_pszRootItemDefaults - Property name  array         (LPOLESTR)
*   m_piRootItemDefaults  - Property ID array             (PROPID)
*   m_pvRootItemDefaults  - Property Variant array      (PROPVARIANT)
*   m_psRootItemDefaults  - Property Spec array          (PROPSPEC)
*   m_wpiRootItemDefaults - WIA Property Info array  (WIA_PROPERTY_INFO)
*
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT CWIAScannerDevice::DeleteRootItemProperties()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::DeleteRootItemProperties");

    HRESULT hr = S_OK;

    //
    // delete any allocated arrays
    //

    DeleteSupportedPreviewModesArrayContents();

    if(NULL != m_pszRootItemDefaults){
        delete [] m_pszRootItemDefaults;
        m_pszRootItemDefaults = NULL;
    }

    if(NULL != m_piRootItemDefaults){
        delete [] m_piRootItemDefaults;
        m_piRootItemDefaults = NULL;
    }

    if(NULL != m_pvRootItemDefaults){
        FreePropVariantArray(m_NumRootItemProperties,m_pvRootItemDefaults);
        delete [] m_pvRootItemDefaults;
        m_pvRootItemDefaults = NULL;
    }

    if(NULL != m_psRootItemDefaults){
        delete [] m_psRootItemDefaults;
        m_psRootItemDefaults = NULL;
    }

    if(NULL != m_wpiRootItemDefaults){
        delete [] m_wpiRootItemDefaults;
        m_wpiRootItemDefaults = NULL;
    }

    return hr;
}

/**************************************************************************\
* BuildRootItemProperties
*
*   This helper creates/initializes the arrays used for Property intialization.
*
*       [Array Name]            [Description]          [Array Type]
*
*   m_pszRootItemDefaults - Property name  array         (LPOLESTR)
*   m_piRootItemDefaults  - Property ID array             (PROPID)
*   m_pvRootItemDefaults  - Property Variant array      (PROPVARIANT)
*   m_psRootItemDefaults  - Property Spec array          (PROPSPEC)
*   m_wpiRootItemDefaults - WIA Property Info array  (WIA_PROPERTY_INFO)
*
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT CWIAScannerDevice::BuildRootItemProperties()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::BuildRootItemProperties");

    HRESULT hr = S_OK;

    if(m_pScanAPI->ADFAttached() == S_OK){
        m_bADFAttached = TRUE;
    }

    WIAPROPERTIES RootItemProperties;
    memset(&RootItemProperties,0,sizeof(RootItemProperties));

    // set host driver numeric values
    RootItemProperties.NumSupportedPreviewModes = m_NumSupportedPreviewModes;

    // set host driver allocated pointers
    RootItemProperties.pSupportedPreviewModes = m_pSupportedPreviewModes;

    hr = m_pScanAPI->BuildRootItemProperties(&RootItemProperties);
    if(FAILED(hr)){
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildRootItemProperties, m_pScanAPI->BuildRootItemProperties failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        DeleteRootItemProperties();
        return hr;
    }

    //
    // assign pointers to members
    //

    m_NumRootItemProperties = RootItemProperties.NumItemProperties;
    m_piRootItemDefaults    = RootItemProperties.piItemDefaults;
    m_psRootItemDefaults    = RootItemProperties.psItemDefaults;
    m_pszRootItemDefaults   = RootItemProperties.pszItemDefaults;
    m_pvRootItemDefaults    = RootItemProperties.pvItemDefaults;
    m_wpiRootItemDefaults   = RootItemProperties.wpiItemDefaults;

    return hr;
}

/**************************************************************************\
* DeleteTopItemProperties
*
*   This helper deletes the arrays used for Property intialization.
*
*       [Array Name]            [Description]          [Array Type]
*
*   m_pszItemDefaults - Property name  array         (LPOLESTR)
*   m_piItemDefaults  - Property ID array             (PROPID)
*   m_pvItemDefaults  - Property Variant array      (PROPVARIANT)
*   m_psItemDefaults  - Property Spec array          (PROPSPEC)
*   m_wpiItemDefaults - WIA Property Info array  (WIA_PROPERTY_INFO)
*
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT CWIAScannerDevice::DeleteTopItemProperties()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::DeleteTopItemProperties");

    HRESULT hr = S_OK;

    //
    // delete any allocated arrays
    //

    DeleteSupportedFormatsArrayContents();
    DeleteSupportedDataTypesArrayContents();
    DeleteSupportedCompressionsArrayContents();
    DeleteSupportedTYMEDArrayContents();
    DeleteInitialFormatsArrayContents();
    DeleteSupportedResolutionsArrayContents();

    if(NULL != m_pszItemDefaults){
        delete [] m_pszItemDefaults;
        m_pszItemDefaults = NULL;
    }

    if(NULL != m_piItemDefaults){
        delete [] m_piItemDefaults;
        m_piItemDefaults = NULL;
    }

    if(NULL != m_pvItemDefaults){
        for(LONG lPropIndex = 0; lPropIndex < m_NumItemProperties; lPropIndex++){

            //
            // set CLSID pointers to NULL, because we freed the memory above.
            // If this pointer is not NULL FreePropVariantArray would
            // try to free it again.
            //

            if(m_pvItemDefaults[lPropIndex].vt == VT_CLSID){
                m_pvItemDefaults[lPropIndex].puuid = NULL;
            }
        }
        FreePropVariantArray(m_NumItemProperties,m_pvItemDefaults);
        delete [] m_pvItemDefaults;
        m_pvItemDefaults = NULL;
    }

    if(NULL != m_psItemDefaults){
        delete [] m_psItemDefaults;
        m_psItemDefaults = NULL;
    }

    if(NULL != m_wpiItemDefaults){
        delete [] m_wpiItemDefaults;
        m_wpiItemDefaults = NULL;
    }

    return hr;
}

/**************************************************************************\
* BuildTopItemProperties
*
*   This helper creates/initializes the arrays used for Property intialization.
*
*       [Array Name]        [Description]           [Array Type]
*
*   m_pszItemDefaults - Property name  array         (LPOLESTR)
*   m_piItemDefaults  - Property ID array             (PROPID)
*   m_pvItemDefaults  - Property Variant array      (PROPVARIANT)
*   m_psItemDefaults  - Property Spec array          (PROPSPEC)
*   m_wpiItemDefaults - WIA Property Info array  (WIA_PROPERTY_INFO)
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT CWIAScannerDevice::BuildTopItemProperties()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::BuildTopItemProperties");

    HRESULT hr = S_OK;

    WIAPROPERTIES TopItemProperties;
    memset(&TopItemProperties,0,sizeof(TopItemProperties));

    // set host driver numeric values
    TopItemProperties.NumInitialFormats             = m_NumInitialFormats;
    TopItemProperties.NumSupportedCompressionTypes  = m_NumSupportedCompressionTypes;
    TopItemProperties.NumSupportedDataTypes         = m_NumSupportedDataTypes;
    TopItemProperties.NumSupportedFormats           = m_NumSupportedFormats;
    TopItemProperties.NumSupportedIntents           = m_NumSupportedIntents;
    TopItemProperties.NumSupportedTYMED             = m_NumSupportedTYMED;
    TopItemProperties.NumSupportedResolutions       = m_NumSupportedResolutions;

    // set host driver allocated pointers
    TopItemProperties.pInitialFormats               = m_pInitialFormats;
    TopItemProperties.pSupportedCompressionTypes    = m_pSupportedCompressionTypes;
    TopItemProperties.pSupportedDataTypes           = m_pSupportedDataTypes;
    TopItemProperties.pSupportedFormats             = m_pSupportedFormats;
    TopItemProperties.pSupportedIntents             = m_pSupportedIntents;
    TopItemProperties.pSupportedTYMED               = m_pSupportedTYMED;
    TopItemProperties.pSupportedResolutions         = m_pSupportedResolutions;
    TopItemProperties.bLegacyBWRestrictions         = m_bLegacyBWRestriction;

    hr = m_pScanAPI->BuildTopItemProperties(&TopItemProperties);
    if(FAILED(hr)){
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildTopItemProperties, m_pScanAPI->BuildTopItemProperties failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        DeleteTopItemProperties();
        return hr;
    }

    //
    // assign pointers to members
    //

    m_NumItemProperties = TopItemProperties.NumItemProperties;
    m_pszItemDefaults   = TopItemProperties.pszItemDefaults;
    m_piItemDefaults    = TopItemProperties.piItemDefaults;
    m_pvItemDefaults    = TopItemProperties.pvItemDefaults;
    m_psItemDefaults    = TopItemProperties.psItemDefaults;
    m_wpiItemDefaults   = TopItemProperties.wpiItemDefaults;

    return hr;
}

/**************************************************************************\
* BuildSupportedResolutions
*
*   This helper initializes the supported resolution array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::BuildSupportedResolutions()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::BuildSupportedResolutions");

    HRESULT hr = S_OK;
    if(NULL != m_pSupportedResolutions) {

        //
        // Supported intents have already been initialized,
        // so return S_OK.
        //

        return hr;
    }
    m_NumSupportedResolutions   = 6;
    m_pSupportedResolutions     = new LONG[m_NumSupportedResolutions];
    if(m_pSupportedResolutions){
        m_pSupportedResolutions[0] = 75;
        m_pSupportedResolutions[1] = 100;
        m_pSupportedResolutions[2] = 150;
        m_pSupportedResolutions[3] = 200;
        m_pSupportedResolutions[4] = 300;
        m_pSupportedResolutions[5] = 600;
    } else
        hr = E_OUTOFMEMORY;
    return hr;
}
/**************************************************************************\
* DeleteSupportedResolutionsArrayContents
*
*   This helper deletes the supported resolutions array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::DeleteSupportedResolutionsArrayContents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::DeleteSupportedResolutionsArrayContents");

    HRESULT hr = S_OK;
    if(NULL != m_pSupportedResolutions)
        delete [] m_pSupportedResolutions;

    m_pSupportedResolutions     = NULL;
    m_NumSupportedResolutions   = 0;
    return hr;
}

/**************************************************************************\
* BuildSupportedIntents
*
*   This helper initializes the supported intent array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::BuildSupportedIntents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::BuildSupportedIntents");

    HRESULT hr = S_OK;
    if(NULL != m_pSupportedIntents) {

        //
        // Supported intents have already been initialized,
        // so return S_OK.
        //

        return hr;
    }
    m_NumSupportedIntents   = 6;
    m_pSupportedIntents     = new LONG[m_NumSupportedIntents];
    if(m_pSupportedIntents){
        m_pSupportedIntents[0] = WIA_INTENT_NONE;
        m_pSupportedIntents[1] = WIA_INTENT_IMAGE_TYPE_COLOR;
        m_pSupportedIntents[2] = WIA_INTENT_IMAGE_TYPE_GRAYSCALE;
        m_pSupportedIntents[3] = WIA_INTENT_IMAGE_TYPE_TEXT;
        m_pSupportedIntents[4] = WIA_INTENT_MINIMIZE_SIZE;
        m_pSupportedIntents[5] = WIA_INTENT_MAXIMIZE_QUALITY;
    } else
        hr = E_OUTOFMEMORY;
    return hr;
}
/**************************************************************************\
* DeleteSupportedIntentsArrayContents
*
*   This helper deletes the supported intent array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::DeleteSupportedIntentsArrayContents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::DeleteSupportedIntentsArrayContents");

    HRESULT hr = S_OK;
    if(NULL != m_pSupportedIntents)
        delete [] m_pSupportedIntents;

    m_pSupportedIntents     = NULL;
    m_NumSupportedIntents   = 0;
    return hr;
}
/**************************************************************************\
* BuildSupportedCompressions
*
*   This helper initializes the supported compression types array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::BuildSupportedCompressions()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::BuildSupportedCompressions");

    HRESULT hr = S_OK;
    if(NULL != m_pSupportedCompressionTypes) {

        //
        // Supported compression types have already been initialized,
        // so return S_OK.
        //

        return hr;
    }

    m_NumSupportedCompressionTypes  = 1;
    m_pSupportedCompressionTypes    = new LONG[m_NumSupportedCompressionTypes];
    if(m_pSupportedCompressionTypes){
        m_pSupportedCompressionTypes[0] = WIA_COMPRESSION_NONE;
    } else
        hr = E_OUTOFMEMORY;
    return hr;
}
/**************************************************************************\
* DeleteSupportedCompressionsArrayContents
*
*   This helper deletes the supported compression types array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::DeleteSupportedCompressionsArrayContents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::DeleteSupportedCompressionsArrayContents");

    HRESULT hr = S_OK;
    if (NULL != m_pSupportedCompressionTypes)
        delete [] m_pSupportedCompressionTypes;

    m_pSupportedCompressionTypes     = NULL;
    m_NumSupportedCompressionTypes   = 0;
    return hr;
}

/**************************************************************************\
* BuildSupportedPreviewModes
*
*   This helper initializes the supported preview mode array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    8/17/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::BuildSupportedPreviewModes()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::BuildSupportedPreviewModes");

    HRESULT hr = S_OK;
    if(NULL != m_pSupportedPreviewModes) {

        //
        // Supported preview modes have already been initialized,
        // so return S_OK.
        //

        return hr;
    }

    m_NumSupportedPreviewModes  = 2;
    m_pSupportedPreviewModes    = new LONG[m_NumSupportedPreviewModes];
    if(m_pSupportedPreviewModes){
        m_pSupportedPreviewModes[0] = WIA_FINAL_SCAN;
        m_pSupportedPreviewModes[1] = WIA_PREVIEW_SCAN;
    } else
        hr = E_OUTOFMEMORY;
    return hr;
}
/**************************************************************************\
* DeleteSupportedCompressionsArrayContents
*
*   This helper deletes the supported compression types array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    8/17/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::DeleteSupportedPreviewModesArrayContents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::DeleteSupportedPreviewModesArrayContents");

    HRESULT hr = S_OK;
    if (NULL != m_pSupportedPreviewModes)
        delete [] m_pSupportedPreviewModes;

    m_pSupportedPreviewModes     = NULL;
    m_NumSupportedPreviewModes   = 0;
    return hr;
}

/**************************************************************************\
* BuildSupportedDataTypes
*
*   This helper initializes the supported data types array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::BuildSupportedDataTypes()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::BuildSupportedDataTypes");

    HRESULT hr = S_OK;

    if(NULL != m_pSupportedDataTypes) {

        //
        // Supported data types have already been initialized,
        // so return S_OK.
        //

        return hr;
    }

    if (m_bLegacyBWRestriction) {
        m_NumSupportedDataTypes  = NUM_DATA_TYPES_LEGACY;
    } else {
        m_NumSupportedDataTypes  = NUM_DATA_TYPES_NONLEGACY;
    }
    m_pSupportedDataTypes = new LONG[m_NumSupportedDataTypes];

    if(m_pSupportedDataTypes){
        m_pSupportedDataTypes[0] = WIA_DATA_THRESHOLD;
        m_pSupportedDataTypes[1] = WIA_DATA_GRAYSCALE;

        //
        // Add color support to non-legacy devices only
        //

        if (m_NumSupportedDataTypes == NUM_DATA_TYPES_NONLEGACY) {
            m_pSupportedDataTypes[2] = WIA_DATA_COLOR;
        }
    } else
        hr = E_OUTOFMEMORY;
    return hr;
}
/**************************************************************************\
* DeleteSupportedDataTypesArrayContents
*
*   This helper deletes the supported data types array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::DeleteSupportedDataTypesArrayContents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::DeleteSupportedDataTypesArrayContents");

    HRESULT hr = S_OK;
    if(NULL != m_pSupportedDataTypes)
        delete [] m_pSupportedDataTypes;

    m_pSupportedDataTypes     = NULL;
    m_NumSupportedDataTypes   = 0;
    return hr;
}

/**************************************************************************\
* BuildInitialFormats
*
*   This helper initializes the initial format array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::BuildInitialFormats()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::BuildInitialFormats");

    HRESULT hr = S_OK;

    if(NULL != m_pInitialFormats) {

        //
        // Supported data types have already been initialized,
        // so return S_OK.
        //

        return hr;
    }

    m_NumInitialFormats = 1;
    m_pInitialFormats     = new GUID[m_NumInitialFormats];
    if(m_pInitialFormats){
        m_pInitialFormats[0] = WiaImgFmt_MEMORYBMP;
    } else
        hr = E_OUTOFMEMORY;

    return hr;
}
/**************************************************************************\
* DeleteInitialFormatsArrayContents
*
*   This helper deletes the initial format array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::DeleteInitialFormatsArrayContents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::DeleteInitialFormatsArrayContents");

    HRESULT hr = S_OK;
    if(NULL != m_pInitialFormats)
        delete [] m_pInitialFormats;

    m_pInitialFormats     = NULL;
    m_NumInitialFormats   = 0;
    return hr;
}

/**************************************************************************\
* BuildSupportedFormats
*
*   This helper initializes the supported format array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::BuildSupportedFormats()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::BuildSupportedFormats");

    HRESULT hr = S_OK;

    if(NULL != m_pSupportedFormats) {

        //
        // Supported formats have already been initialized,
        // so return S_OK.
        //

        return hr;
    }

    LONG lNumFileFormats = 0;
    LONG lNumMemoryFormats = 0;
    GUID *pFileFormats = NULL;
    GUID *pMemoryFormats = NULL;

    hr = m_pScanAPI->GetSupportedFileFormats(&pFileFormats, &lNumFileFormats);
    if(SUCCEEDED(hr)){
        hr = m_pScanAPI->GetSupportedMemoryFormats(&pMemoryFormats, &lNumMemoryFormats);
        if (SUCCEEDED(hr)) {
            m_NumSupportedFormats = lNumFileFormats + lNumMemoryFormats + 2;
            m_pSupportedFormats = new WIA_FORMAT_INFO[m_NumSupportedFormats];
            LONG lIndex = 0;
            if (m_pSupportedFormats) {

                // fill out file formats
                m_pSupportedFormats[lIndex].guidFormatID = WiaImgFmt_BMP;
                m_pSupportedFormats[lIndex].lTymed       = TYMED_FILE;
                lIndex++;
                for(LONG lSrcIndex = 0;lSrcIndex < lNumFileFormats; lSrcIndex++){
                    m_pSupportedFormats[lIndex].guidFormatID = pFileFormats[lSrcIndex];
                    m_pSupportedFormats[lIndex].lTymed       = TYMED_FILE;
                    lIndex ++;
                }

                //fill out memory formats
                m_pSupportedFormats[lIndex].guidFormatID = WiaImgFmt_MEMORYBMP;
                m_pSupportedFormats[lIndex].lTymed       = TYMED_CALLBACK;
                lIndex++;
                for(lSrcIndex = 0;lSrcIndex < lNumMemoryFormats; lSrcIndex++){
                    m_pSupportedFormats[lIndex].guidFormatID = pMemoryFormats[lSrcIndex];
                    m_pSupportedFormats[lIndex].lTymed       = TYMED_CALLBACK;
                    lIndex++;
                }
            } else{
                hr = E_OUTOFMEMORY;
            }
        }
    } else if(E_NOTIMPL == hr){
        // do default processing of file formats
        hr = DeleteSupportedFormatsArrayContents();
        if (SUCCEEDED(hr)) {
            m_NumSupportedFormats = 2;

            m_pSupportedFormats = new WIA_FORMAT_INFO[m_NumSupportedFormats];
            if (m_pSupportedFormats) {
                m_pSupportedFormats[0].guidFormatID = WiaImgFmt_MEMORYBMP;
                m_pSupportedFormats[0].lTymed       = TYMED_CALLBACK;
                m_pSupportedFormats[1].guidFormatID = WiaImgFmt_BMP;
                m_pSupportedFormats[1].lTymed       = TYMED_FILE;
            } else
                hr = E_OUTOFMEMORY;
        }
    } else {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildSupportedFormats, GetSupportedFileFormats Failed "));
        WIAS_LHRESULT(m_pIWiaLog, hr);
    }

    return hr;
}
/**************************************************************************\
* DeleteSupportedFormatsArrayContents
*
*   This helper deletes the supported formats array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::DeleteSupportedFormatsArrayContents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::DeleteSupportedFormatsArrayContents");

    HRESULT hr = S_OK;
    if(NULL != m_pSupportedFormats)
        delete [] m_pSupportedFormats;

    m_pSupportedFormats     = NULL;
    m_NumSupportedFormats   = 0;
    return hr;
}
/**************************************************************************\
* BuildSupportedTYMED
*
*   This helper initializes the supported TYMED array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::BuildSupportedTYMED()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::BuildSupportedTYMED");

    HRESULT hr = S_OK;

    if(NULL != m_pSupportedTYMED) {

        //
        // Supported TYMED have already been initialized,
        // so return S_OK.
        //

        return hr;
    }

    hr = DeleteSupportedTYMEDArrayContents();
    if (SUCCEEDED(hr)) {
        m_NumSupportedTYMED = 2;
        m_pSupportedTYMED   = new LONG[m_NumSupportedTYMED];
        if (m_pSupportedTYMED) {
            m_pSupportedTYMED[0] = TYMED_FILE;
            m_pSupportedTYMED[1] = TYMED_CALLBACK;

        } else
            hr = E_OUTOFMEMORY;
    }
    return hr;
}
/**************************************************************************\
* DeleteSupportedTYMEDArrayContents
*
*   This helper deletes the supported TYMED array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::DeleteSupportedTYMEDArrayContents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::DeleteSupportedTYMEDArrayContents");

    HRESULT hr = S_OK;
    if(NULL != m_pSupportedTYMED)
        delete [] m_pSupportedTYMED;

    m_pSupportedTYMED  = NULL;
    m_NumSupportedTYMED = 0;
    return hr;
}

/**************************************************************************\
* BuildCapabilities
*
*   This helper initializes the capabilities array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT CWIAScannerDevice::BuildCapabilities()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::BuildCapabilities");

    HRESULT hr = S_OK;
    if(NULL != m_pCapabilities) {

        //
        // Capabilities have already been initialized,
        // so return S_OK.
        //

        return hr;
    }

    m_NumSupportedCommands  = 0;
    m_NumSupportedEvents    = 0;
    m_NumCapabilities       = 0;

    WIACAPABILITIES WIACaps;
    memset(&WIACaps,0,sizeof(WIACaps));
    WIACaps.pCapabilities         = NULL;
    WIACaps.pNumSupportedCommands = &m_NumSupportedCommands;
    WIACaps.pNumSupportedEvents   = &m_NumSupportedEvents;

    hr = m_pScanAPI->BuildCapabilities(&WIACaps);
    LONG lDriverAddedEvents = m_NumSupportedEvents;
    m_NumSupportedCommands  = 1;
    m_NumSupportedEvents    = (lDriverAddedEvents + 2);    // 2 required events (default events for all devices)
    m_NumCapabilities       = (m_NumSupportedCommands + m_NumSupportedEvents);

    m_pCapabilities     = new WIA_DEV_CAP_DRV[m_NumCapabilities];
    if (m_pCapabilities) {

        memset(&WIACaps,0,sizeof(WIACaps));
        WIACaps.pCapabilities         = m_pCapabilities;
        WIACaps.pNumSupportedCommands = NULL;
        WIACaps.pNumSupportedEvents   = NULL;

        hr = m_pScanAPI->BuildCapabilities(&WIACaps);
        if (SUCCEEDED(hr)) {

            LONG lStartIndex = lDriverAddedEvents;

            //
            // Initialize EVENTS
            //

            // WIA_EVENT_DEVICE_CONNECTED
            GetOLESTRResourceString(IDS_EVENT_DEVICE_CONNECTED_NAME,&(m_pCapabilities[lStartIndex].wszName),TRUE);
            GetOLESTRResourceString(IDS_EVENT_DEVICE_CONNECTED_DESC,&(m_pCapabilities[lStartIndex].wszDescription),TRUE);
            m_pCapabilities[lStartIndex].guid           = (GUID*)&WIA_EVENT_DEVICE_CONNECTED;
            m_pCapabilities[lStartIndex].ulFlags        = WIA_NOTIFICATION_EVENT;
            m_pCapabilities[lStartIndex].wszIcon        = WIA_ICON_DEVICE_CONNECTED;

            lStartIndex++;

            // WIA_EVENT_DEVICE_DISCONNECTED
            GetOLESTRResourceString(IDS_EVENT_DEVICE_DISCONNECTED_NAME,&(m_pCapabilities[lStartIndex].wszName),TRUE);
            GetOLESTRResourceString(IDS_EVENT_DEVICE_DISCONNECTED_DESC,&(m_pCapabilities[lStartIndex].wszDescription),TRUE);
            m_pCapabilities[lStartIndex].guid           = (GUID*)&WIA_EVENT_DEVICE_DISCONNECTED;
            m_pCapabilities[lStartIndex].ulFlags        = WIA_NOTIFICATION_EVENT;
            m_pCapabilities[lStartIndex].wszIcon        = WIA_ICON_DEVICE_DISCONNECTED;

            lStartIndex++;

            //
            // Initialize COMMANDS
            //

            // WIA_CMD_SYNCHRONIZE
            GetOLESTRResourceString(IDS_CMD_SYNCRONIZE_NAME,&(m_pCapabilities[lStartIndex].wszName),TRUE);
            GetOLESTRResourceString(IDS_CMD_SYNCRONIZE_DESC,&(m_pCapabilities[lStartIndex].wszDescription),TRUE);
            m_pCapabilities[lStartIndex].guid           = (GUID*)&WIA_CMD_SYNCHRONIZE;
            m_pCapabilities[lStartIndex].ulFlags        = 0;
            m_pCapabilities[lStartIndex].wszIcon        = WIA_ICON_SYNCHRONIZE;
        }

    } else
        hr = E_OUTOFMEMORY;

    return hr;
}

/**************************************************************************\
* DeleteCapabilitiesArrayContents
*
*   This helper deletes the capabilities array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT CWIAScannerDevice::DeleteCapabilitiesArrayContents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::DeleteCapabilitiesArrayContents");

    HRESULT hr = S_OK;
    if(NULL != m_pCapabilities) {
        for (LONG i = 0; i < m_NumCapabilities;i++) {
            CoTaskMemFree(m_pCapabilities[i].wszName);
            CoTaskMemFree(m_pCapabilities[i].wszDescription);
        }
        delete [] m_pCapabilities;

        m_pCapabilities = NULL;
    }
    return hr;
}

/**************************************************************************\
* GetBSTRResourceString
*
*   This helper gets a BSTR from a resource location
*
* Arguments:
*
*   lResourceID - Resource ID of the target BSTR value
*   pBSTR       - pointer to a BSTR value (caller must free this string)
*   bLocal      - TRUE - for local resources, FALSE - for wiaservc resources
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::GetBSTRResourceString(LONG lResourceID,BSTR *pBSTR,BOOL bLocal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::GetBSTRResourceString");

    HRESULT hr = S_OK;
    TCHAR szStringValue[255];
    if(bLocal) {

        //
        // We are looking for a resource in our own private resource file
        //

        LoadString(g_hInst,lResourceID,szStringValue,255);

        //
        // NOTE: caller must free this allocated BSTR
        //

#ifdef UNICODE
       *pBSTR = SysAllocString(szStringValue);
#else
       WCHAR wszStringValue[255];

       //
       // convert szStringValue from char* to unsigned short* (ANSI only)
       //

       MultiByteToWideChar(CP_ACP,
                           MB_PRECOMPOSED,
                           szStringValue,
                           lstrlenA(szStringValue)+1,
                           wszStringValue,
                           (sizeof(wszStringValue)/sizeof(WCHAR)));

       *pBSTR = SysAllocString(wszStringValue);
#endif

    } else {

        //
        // We are looking for a resource in the wiaservc's resource file
        //

        hr = E_NOTIMPL;
    }
    return hr;
}

/**************************************************************************\
* GetOLESTRResourceString
*
*   This helper gets a LPOLESTR from a resource location
*
* Arguments:
*
*   lResourceID - Resource ID of the target BSTR value
*   ppsz        - pointer to a OLESTR value (caller must free this string)
*   bLocal      - TRUE - for local resources, FALSE - for wiaservc resources
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::GetOLESTRResourceString(LONG lResourceID,LPOLESTR *ppsz,BOOL bLocal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::GetOLESTRResourceString");

    HRESULT hr = S_OK;
    TCHAR szStringValue[255];
    if(bLocal) {

        //
        // We are looking for a resource in our own private resource file
        //

        LoadString(g_hInst,lResourceID,szStringValue,255);

        //
        // NOTE: caller must free this allocated BSTR
        //

#ifdef UNICODE
       *ppsz = NULL;
       *ppsz = (LPOLESTR)CoTaskMemAlloc(sizeof(szStringValue));
       if(*ppsz != NULL) {
            wcscpy(*ppsz,szStringValue);
       } else {
           return E_OUTOFMEMORY;
       }

#else
       WCHAR wszStringValue[255];

       //
       // convert szStringValue from char* to unsigned short* (ANSI only)
       //

       MultiByteToWideChar(CP_ACP,
                           MB_PRECOMPOSED,
                           szStringValue,
                           lstrlenA(szStringValue)+1,
                           wszStringValue,
                           (sizeof(wszStringValue)/sizeof(WCHAR)));

       *ppsz = NULL;
       *ppsz = (LPOLESTR)CoTaskMemAlloc(sizeof(wszStringValue));
       if(*ppsz != NULL) {
            wcscpy(*ppsz,wszStringValue);
       } else {
           return E_OUTOFMEMORY;
       }
#endif

    } else {

        //
        // We are looking for a resource in the wiaservc's resource file
        //

        hr = E_NOTIMPL;
    }
    return hr;
}

/**************************************************************************\
* VerticalFlip
*
*
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

VOID CWIAScannerDevice::VerticalFlip(
             PMINIDRIVERITEMCONTEXT     pDrvItemContext,
             PMINIDRV_TRANSFER_CONTEXT  pDataTransferContext)

{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::VerticalFlip");

    LONG        iHeight         = 0;
    LONG        iWidth          = pDrvItemContext->lBytesPerScanLineRaw;
    ULONG       uiDepth         = pDrvItemContext->lDepth;
    LONG        ScanLineWidth   = pDrvItemContext->lBytesPerScanLine;
    BITMAPINFO  UNALIGNED *pbmi = NULL;
    PBYTE       pImageTop       = NULL;

    //
    // find out if data is TYMED_FILE or TYMED_HGLOBAL
    //

    if (pDataTransferContext->tymed == TYMED_FILE) {
        pbmi = (PBITMAPINFO)(pDataTransferContext->pTransferBuffer + sizeof(BITMAPFILEHEADER));
    } else {
        return;
    }

    //
    // init memory pointer and height
    //

    pImageTop = pDataTransferContext->pTransferBuffer + pDataTransferContext->lHeaderSize;

#ifdef _64BIT_ALIGNMENT
    BITMAPINFOHEADER UNALIGNED *pbmih = &pbmi->bmiHeader;
    iHeight = pbmih->biHeight;
#else
    iHeight = pbmi->bmiHeader.biHeight;
#endif

    //
    // try to allocate a temp scan line buffer
    //

    PBYTE pBuffer = (PBYTE)LocalAlloc(LPTR,ScanLineWidth);

    if (pBuffer != NULL) {

        LONG  index         = 0;
        PBYTE pImageBottom  = NULL;

        pImageBottom = pImageTop + (iHeight-1) * ScanLineWidth;
        for (index = 0;index < (iHeight/2);index++) {
            memcpy(pBuffer,pImageTop,ScanLineWidth);
            memcpy(pImageTop,pImageBottom,ScanLineWidth);
            memcpy(pImageBottom,pBuffer,ScanLineWidth);
            pImageTop    += ScanLineWidth;
            pImageBottom -= ScanLineWidth;
        }

        LocalFree(pBuffer);
    } else {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("VerticalFlip, LocalAlloc failed allocating %d bytes",ScanLineWidth));
    }
}

/**************************************************************************\
* SwapBuffer24
*
*   Place RGB bytes in correct order for DIB format.
*
* Arguments:
*
*   pBuffer     - Pointer to the data buffer.
*   lByteCount  - Size of the data in bytes.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

VOID CWIAScannerDevice::SwapBuffer24(PBYTE pBuffer, LONG lByteCount)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::::SwapBuffer24");
    for (LONG i = 0; i < lByteCount; i+= 3) {
        BYTE bTemp = pBuffer[i];
        pBuffer[i]     = pBuffer[i + 2];
        pBuffer[i + 2] = bTemp;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\wiafbdrv\ioblockdefs.h ===
#ifndef __IOBLOCKDEFS
#define __IOBLOCKDEFS

#include "pch.h"

#define MAX_IO_HANDLES   16
#define DWORD_ALIGN      0
#define LEFT_JUSTIFIED   0
#define CENTERED         1
#define RIGHT_JUSTIFIED  2
#define TOP_JUSTIFIED    0
#define CENTERED         1
#define BOTTOM_JUSTIFIED 2

#define XRESOLUTION_ID   2
#define YRESOLUTION_ID   3
#define XPOS_ID          4
#define YPOS_ID          5
#define XEXT_ID          6
#define YEXT_ID          7
#define BRIGHTNESS_ID    8
#define CONTRAST_ID      9
#define DATA_TYPE_ID     10
#define BIT_DEPTH_ID     11
#define NEGATIVE_ID      12
#define PIXEL_PACKING_ID 13
#define PIXEL_FORMAT_ID  14
#define BED_WIDTH_ID     15
#define BED_HEIGHT_ID    16
#define XOPTICAL_ID      17
#define YOPTICAL_ID      18
#define ADF_ID           19
#define TPA_ID           20
#define ADF_WIDTH_ID     21
#define ADF_HEIGHT_ID    22
#define ADF_VJUSTIFY_ID  23
#define ADF_HJUSTIFY_ID  24
#define ADF_MAX_PAGES_ID 25
#define FIRMWARE_VER_ID  26
#define DATA_ALIGN_ID    27

typedef struct _GSD_EVENT_INFO {
    GUID *pEventGUID;       // pointer to the GUID of event that just occurred
    HANDLE hShutDownEvent;  // handle to the shutdown event (interrupt usage only)
    HANDLE *phSignalEvent;  // pointer to event handle to used to signal service (interrupt usage only)
} GSD_EVENT_INFO, *PGSD_EVENT_INFO;

typedef struct _GSD_INFO {
    LPTSTR szDeviceName;        // Device Name (Device Description from DeviceData section)
    LPTSTR szProductFileName;   // Product initialization script
    LPTSTR szFamilyFileName;    // Product family script
} GSD_INFO, *PGSD_INFO;

typedef struct _RANGEVALUEEX {
    LONG lMin;                  // minimum value
    LONG lMax;                  // maximum value
    LONG lNom;                  // nominal value
    LONG lStep;                 // increment/step value
} RANGEVALUEEX, *PRANGEVALUEEX;

typedef struct _SCANSETTINGS {
    HANDLE     DeviceIOHandles[MAX_IO_HANDLES]; // data pipes
    // string values
    TCHAR      Version[10];                 // GSD version
    TCHAR      DeviceName[255];             // Device Name ??(needed?)
    TCHAR      FirmwareVersion[10];         // firmware version
    // current values
    LONG       BUSType;                     // bus type ??(needed?)
    LONG       bNegative;                   // negative on/off
    LONG       CurrentXResolution;          // current x resolution setting
    LONG       CurrentYResolution;          // current y resolution setting
    LONG       BedWidth;                    // bed width (1/1000th inch)
    LONG       BedHeight;                   // bed height (1/1000th inch)
    LONG       FeederWidth;                 // feeder width (1/1000th inch)
    LONG       FeederHeight;                // feeder height (1/1000th inch)
    LONG       FeederJustification;         // feeder justification
    LONG       HFeederJustification;        // feeder horizontal justification
    LONG       VFeederJustification;        // feeder vertical justification
    LONG       MaxADFPageCapacity;          // max page capacity of feeder
    LONG       XOpticalResolution;          // optical x resolution
    LONG       YOpticalResolution;          // optical y resolution
    LONG       CurrentBrightness;           // current brightness setting
    LONG       CurrentContrast;             // current contrast setting
    LONG       CurrentDataType;             // current data type setting
    LONG       CurrentBitDepth;             // current bit depth setting
    LONG       CurrentXPos;                 // current x position setting
    LONG       CurrentYPos;                 // current u position setting
    LONG       CurrentXExtent;              // current x extent setting
    LONG       CurrentYExtent;              // current y extent setting
    LONG       ADFSupport;                  // ADF support TRUE/FALSE
    LONG       TPASupport;                  // TPA support TRUE/FALSE
    LONG       RawPixelPackingOrder;        // raw pixel packing order
    LONG       RawPixelFormat;              // raw pixel format
    LONG       RawDataAlignment;            // raw data alignment
    // Range values
    RANGEVALUEEX XSupportedResolutionsRange;  // valid values for x resolution
    RANGEVALUEEX YSupportedResolutionsRange;  // valid values for y resolution
    RANGEVALUEEX XExtentsRange;               // valid values for x extent
    RANGEVALUEEX YExtentsRange;               // valid values for y extent
    RANGEVALUEEX XPosRange;                   // valid values for x position
    RANGEVALUEEX YPosRange;                   // valid values for y position
    RANGEVALUEEX BrightnessRange;             // valid values for brightness
    RANGEVALUEEX ContrastRange;               // valid values for contrast
    // List values
    PLONG      XSupportedResolutionsList;   // valid values for x resolution (LIST)
    PLONG      YSupportedResolutionsList;   // valid values for y resolution (LIST)
    PLONG      SupportedDataTypesList;      // supported data types (LIST)

}SCANSETTINGS, *PSCANSETTIINGS;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\wiafbdrv\ioblock.cpp ===
#include "pch.h"
CComModule _Module;
#include <initguid.h>
DEFINE_GUID(CLSID_VBScript, 0xb54f3741, 0x5b07, 0x11cf, 0xa4, 0xb0, 0x0, 0xaa, 0x0, 0x4a, 0x55, 0xe8);

CIOBlock::CIOBlock()
{
    memset(m_szFileName,0,sizeof(m_szFileName));
}

CIOBlock::~CIOBlock()
{
    StopScriptEngine();
}

void CIOBlock::Initialize(PGSD_INFO pGSDInfo)
{
    // SBB - RAID 370299 - orenr - 2001/04/18 - Security fix -
    // potential buffer overrun.  Changed lstrcpy to use
    // _tcsncpy instead.
    //
    ZeroMemory(m_szFileName, sizeof(m_szFileName));
    _tcsncpy(m_szFileName,
             pGSDInfo->szProductFileName,
             (sizeof(m_szFileName) / sizeof(TCHAR)) - 1);
}

HRESULT CIOBlock::StartScriptEngine()
{
    HRESULT hr = S_OK;

    //
    // load scriptlets
    //

    hr = LoadScript();
    if(FAILED(hr)){
        return hr;
    }

    m_pDeviceScriptSite = new CDeviceScriptSite;
    if(m_pDeviceScriptSite){
        m_pDeviceProperty   = new CComObject<CDeviceProperty>;
        if(m_pDeviceProperty){
            m_pDeviceAction     = new CComObject<CDeviceAction>;
            if(m_pDeviceAction){
                m_pDeviceControl    = new CComObject<CDeviceControl>;
                if(m_pDeviceControl){
                    m_pLastError        = new CComObject<CLastError>;
                    if(!m_pLastError){
                        hr = E_OUTOFMEMORY;
                    }
                } else {
                    hr = E_OUTOFMEMORY;
                }
            } else {
                hr = E_OUTOFMEMORY;
            }
        } else {
            hr = E_OUTOFMEMORY;
        }
    } else {
        hr = E_OUTOFMEMORY;
    }

    if(FAILED(hr)){

        //
        // Delete site & objects
        //

        if (m_pDeviceScriptSite) {
            delete m_pDeviceScriptSite;
            m_pDeviceScriptSite = NULL;
        }
        if (m_pDeviceProperty) {
            delete m_pDeviceProperty;
            m_pDeviceProperty = NULL;
        }
        if (m_pDeviceAction) {
            delete m_pDeviceAction;
            m_pDeviceAction = NULL;
        }

        if (m_pLastError) {
            m_pLastError = NULL;
        }
    }

    //
    // Initialize objects
    //

    m_pDeviceProperty->m_pScannerSettings = &m_ScannerSettings;
    m_pDeviceControl->m_pScannerSettings = &m_ScannerSettings;
    m_pDeviceAction->m_pScannerSettings = &m_ScannerSettings;

    //
    // get type library information
    //

    ITypeLib *ptLib = 0;
    // hr = LoadTypeLib(L"wiafb.tlb", &ptLib);           // type library as a separate file
    hr = LoadTypeLib(OLESTR("wiafbdrv.dll\\2"), &ptLib); // type library as a resource
    if (SUCCEEDED(hr)) {
        Trace(TEXT("Type library loaded"));
    } else {
        Trace(TEXT("Type library failed to load"));
    }

    ptLib->GetTypeInfoOfGuid(CLSID_DeviceProperty, &m_pDeviceScriptSite->m_pTypeInfo);
    ptLib->GetTypeInfoOfGuid(CLSID_DeviceAction, &m_pDeviceScriptSite->m_pTypeInfoDeviceAction);
    ptLib->GetTypeInfoOfGuid(CLSID_DeviceControl, &m_pDeviceScriptSite->m_pTypeInfoDeviceControl);
    ptLib->GetTypeInfoOfGuid(CLSID_LastError, &m_pDeviceScriptSite->m_pTypeInfoLastError);
    ptLib->Release();

    //
    // Intialize DeviceScriptSite with IUnknowns of scripting objects
    //

    hr = m_pDeviceProperty->QueryInterface(IID_IUnknown,(void **)&m_pDeviceScriptSite->m_pUnkScriptObject);
    if (SUCCEEDED(hr)) {
        Trace(TEXT("QI on DeviceProperty success"));
    } else {
        Trace(TEXT("QI on DeviceProperty FAILED"));
    }

    hr = m_pDeviceAction->QueryInterface(IID_IUnknown,(void **)&m_pDeviceScriptSite->m_pUnkScriptObjectDeviceAction);
    if (SUCCEEDED(hr)) {
        Trace(TEXT("QI on DeviceAction success"));
    } else {
        Trace(TEXT("QI on DeviceAction FAILED"));
    }

    hr = m_pDeviceControl->QueryInterface(IID_IUnknown,(void **)&m_pDeviceScriptSite->m_pUnkScriptObjectDeviceControl);
    if (SUCCEEDED(hr)) {
        Trace(TEXT("QI on DeviceControl success"));
    } else {
        Trace(TEXT("QI on DeviceControl FAILED"));
    }

    hr = m_pLastError->QueryInterface(IID_IUnknown,(void **)&m_pDeviceScriptSite->m_pUnkScriptObjectLastError);
    if (SUCCEEDED(hr)) {
        Trace(TEXT("QI on LastError success"));
    } else {
        Trace(TEXT("QI on LastError FAILED"));
    }

    //
    // Start inproc script engine, VBSCRIPT.DLL
    //

    hr = CoCreateInstance(CLSID_VBScript,
                          NULL,
                          CLSCTX_INPROC_SERVER,
                          IID_IActiveScript, (void **)&m_pActiveScript);
    if (SUCCEEDED(hr)) {
        Trace(TEXT("CoCreateInstance, VBScript"));
    } else {
        Trace(TEXT("CoCreateInstance, VBScript FAILED"));
        Trace(TEXT("hr = %x"),hr);
    }

    //
    // Get engine's IActiveScriptParse interface.
    //

    hr = m_pActiveScript->QueryInterface(IID_IActiveScriptParse,
                             (void **)&m_pActiveScriptParser);
    if (SUCCEEDED(hr)) {
        Trace(TEXT("QI pm ActiveParse success"));
    } else {
        Trace(TEXT("QI pm ActiveParse FAILED"));
        Trace(TEXT("hr = %x"),hr);
    }

    //
    // Give engine our DeviceScriptSite interface...
    //

    hr = m_pActiveScript->SetScriptSite((IActiveScriptSite *)m_pDeviceScriptSite);
    if (SUCCEEDED(hr)) {
        Trace(TEXT("SetScriptSite "));
    } else {
        Trace(TEXT("SetScriptSite FAILED"));
        Trace(TEXT("hr = %x"),hr);
    }

    //
    // Intialize Engine
    //

    hr = m_pActiveScriptParser->InitNew();
    if (SUCCEEDED(hr)) {
        Trace(TEXT("InitNew"));
    } else {
        Trace(TEXT("InitNew FAILED"));
        Trace(TEXT("hr = %x"),hr);
    }

    //
    // Add object names to ActiveScript's known named item list
    //

    hr = m_pActiveScript->AddNamedItem(L"DeviceProperty", SCRIPTITEM_ISVISIBLE);
    if (SUCCEEDED(hr)) {
        Trace(TEXT("added item"));
    } else {
        Trace(TEXT("added item FAILED"));
        Trace(TEXT("hr = %x"),hr);
    }

    hr = m_pActiveScript->AddNamedItem(L"DeviceAction", SCRIPTITEM_ISVISIBLE | SCRIPTITEM_ISSOURCE);
    if (SUCCEEDED(hr)) {
        Trace(TEXT("added item"));
    } else {
        Trace(TEXT("added item FAILED"));
        Trace(TEXT("hr = %x"),hr);
    }

    hr = m_pActiveScript->AddNamedItem(L"DeviceControl", SCRIPTITEM_ISVISIBLE);
    if (SUCCEEDED(hr)) {
        Trace(TEXT("added item"));
    } else {
        Trace(TEXT("added item FAILED"));
        Trace(TEXT("hr = %x"),hr);
    }

    hr = m_pActiveScript->AddNamedItem(L"LastError", SCRIPTITEM_ISVISIBLE);
    if (SUCCEEDED(hr)) {
        Trace(TEXT("added item"));
    } else {
        Trace(TEXT("added item FAILED"));
        Trace(TEXT("hr = %x"),hr);
    }

    return ProcessScript();
}

HRESULT CIOBlock::StopScriptEngine()
{
    HRESULT hr = S_OK;

    //
    // Release interfaces
    //

    if(m_pActiveScriptParser){
        m_pActiveScriptParser->Release();
        m_pActiveScriptParser = NULL;
    }

    if (m_pActiveScript) {
        m_pActiveScript->Release();
        m_pActiveScript = NULL;
    }

    //
    // Delete site & objects
    //

    if (m_pDeviceScriptSite) {
        delete m_pDeviceScriptSite;
        m_pDeviceScriptSite = NULL;
    }
    if (m_pDeviceProperty) {
        delete m_pDeviceProperty;
        m_pDeviceProperty = NULL;
    }
    if (m_pDeviceAction) {
        delete m_pDeviceAction;
        m_pDeviceAction = NULL;
    }

    if (m_pLastError) {
        m_pLastError = NULL;
    }

    //
    // free scriptlets
    //

    if(m_wszScriptText){
        LocalFree(m_wszScriptText);
    }

    return hr;
}

HRESULT CIOBlock::LoadScript()
{
    return E_NOTIMPL;
}

HRESULT CIOBlock::ProcessScript()
{
    HRESULT hr = S_OK;
    EXCEPINFO ei;

    //
    // parse scriptlet
    // note: we are alloc a copy here... should we keep the original
    //       around for extra processing...manually??
    //

    BSTR pParseText = ::SysAllocString(m_wszScriptText);
    hr = m_pActiveScriptParser->ParseScriptText(pParseText, NULL,
                               NULL, NULL, 0, 0, 0L, NULL, &ei);
    if (SUCCEEDED(hr)) {
        Trace(TEXT("script parsed"));
    } else {
        Trace(TEXT("script parse FAILED"));
        Trace(TEXT("hr = %x"),hr);
    }

    ::SysFreeString(pParseText);

    //
    // Execute the scriptlet
    //

    hr = m_pActiveScript->SetScriptState(SCRIPTSTATE_CONNECTED);
    if (SUCCEEDED(hr)) {
        Trace(TEXT("Scripted connected"));
    } else {
        Trace(TEXT("Scripted connection FAILED"));
        Trace(TEXT("hr = %x"),hr);
    }

    return hr;
}

HRESULT CIOBlock::DebugDumpScannerSettings()
{
    HRESULT hr = S_OK;

    // #define _USE_DUMMY_VALUES
#ifdef _USE_DUMMY_VALUES
    lstrcpy(m_ScannerSettings.Version,TEXT("1.0"));
    lstrcpy(m_ScannerSettings.DeviceName,TEXT("HP 5P Driver"));
    lstrcpy(m_ScannerSettings.FirmwareVersion,TEXT("1.01"));

    m_ScannerSettings.BUSType                          = BUS_TYPE_SCSI;
    m_ScannerSettings.bNegative                        = TRUE;
    m_ScannerSettings.CurrentXResolution               = 300;
    m_ScannerSettings.CurrentYResolution               = 300;
    m_ScannerSettings.BedWidth                         = 8500;
    m_ScannerSettings.BedHeight                        = 11693;
    m_ScannerSettings.XOpticalResolution               = 300;
    m_ScannerSettings.YOpticalResolution               = 300;
    m_ScannerSettings.CurrentBrightness                = 32;
    m_ScannerSettings.CurrentContrast                  = 12;
    m_ScannerSettings.ADFSupport                       = FALSE;
    m_ScannerSettings.TPASupport                       = FALSE;
    m_ScannerSettings.RawPixelPackingOrder             = WIA_PACKED_PIXEL;
    m_ScannerSettings.RawPixelFormat                   = WIA_ORDER_BGR;
    m_ScannerSettings.RawDataAlignment                 = DWORD_ALIGN;

    m_ScannerSettings.FeederWidth                      = m_ScannerSettings.BedWidth;
    m_ScannerSettings.FeederHeight                     = m_ScannerSettings.BedHeight;
    m_ScannerSettings.VFeederJustification              = LEFT_JUSTIFIED;
    m_ScannerSettings.HFeederJustification              = TOP_JUSTIFIED;
    m_ScannerSettings.MaxADFPageCapacity               = 30;
    m_ScannerSettings.CurrentDataType                  = WIA_DATA_GRAYSCALE;
    m_ScannerSettings.CurrentBitDepth                  = 8;

    m_ScannerSettings.XSupportedResolutionsRange.lMax  = 1200;
    m_ScannerSettings.XSupportedResolutionsRange.lMin  = 12;
    m_ScannerSettings.XSupportedResolutionsRange.lStep = 1;

    m_ScannerSettings.YSupportedResolutionsRange.lMax  = 1200;
    m_ScannerSettings.YSupportedResolutionsRange.lMin  = 12;
    m_ScannerSettings.YSupportedResolutionsRange.lStep = 1;

    m_ScannerSettings.XExtentsRange.lMax               = 2550;
    m_ScannerSettings.XExtentsRange.lMin               = 1;
    m_ScannerSettings.XExtentsRange.lStep              = 1;

    m_ScannerSettings.YExtentsRange.lMax               = 3507;
    m_ScannerSettings.YExtentsRange.lMin               = 1;
    m_ScannerSettings.YExtentsRange.lStep              = 1;

    m_ScannerSettings.XPosRange.lMax                   = 2549;
    m_ScannerSettings.XPosRange.lMin                   = 0;
    m_ScannerSettings.XPosRange.lStep                  = 1;

    m_ScannerSettings.YPosRange.lMax                   = 3506;
    m_ScannerSettings.YPosRange.lMin                   = 0;
    m_ScannerSettings.YPosRange.lStep                  = 1;

    m_ScannerSettings.CurrentXPos                      = 0;
    m_ScannerSettings.CurrentYPos                      = 0;
    m_ScannerSettings.CurrentXExtent                   = m_ScannerSettings.XExtentsRange.lMax;
    m_ScannerSettings.CurrentYExtent                   = m_ScannerSettings.YExtentsRange.lMax;

    m_ScannerSettings.BrightnessRange.lMax             = 127;
    m_ScannerSettings.BrightnessRange.lMin             = -127;
    m_ScannerSettings.BrightnessRange.lStep            = 1;

    m_ScannerSettings.ContrastRange.lMax               = 127;
    m_ScannerSettings.ContrastRange.lMin               = -127;
    m_ScannerSettings.ContrastRange.lStep              = 1;

    m_ScannerSettings.XSupportedResolutionsList        = NULL;
    m_ScannerSettings.YSupportedResolutionsList        = NULL;

    INT iNumValues = 4; // add 1 extra for header node
    m_ScannerSettings.SupportedDataTypesList  = (PLONG)LocalAlloc(LPTR,(sizeof(LONG) * iNumValues));
    if(m_ScannerSettings.SupportedDataTypesList){
        m_ScannerSettings.SupportedDataTypesList[0] = (iNumValues - 1);
        m_ScannerSettings.SupportedDataTypesList[1] = WIA_DATA_THRESHOLD;
        m_ScannerSettings.SupportedDataTypesList[2] = WIA_DATA_GRAYSCALE;
        m_ScannerSettings.SupportedDataTypesList[3] = WIA_DATA_COLOR;
    } else {
        m_ScannerSettings.SupportedDataTypesList = NULL;
    }
#endif

    Trace(TEXT(" -- m_ScannerSettings structure dump --"));
    Trace(TEXT("BUSType = %d"),m_ScannerSettings.BUSType);
    Trace(TEXT("bNegative = %d"),m_ScannerSettings.bNegative);
    Trace(TEXT("CurrentXResolution = %d"),m_ScannerSettings.CurrentXResolution);
    Trace(TEXT("CurrentYResolution = %d"),m_ScannerSettings.CurrentYResolution);
    Trace(TEXT("BedWidth = %d"),m_ScannerSettings.BedWidth);
    Trace(TEXT("BedHeight = %d"),m_ScannerSettings.BedHeight);
    Trace(TEXT("XOpticalResolution = %d"),m_ScannerSettings.XOpticalResolution);
    Trace(TEXT("YOpticalResolution = %d"),m_ScannerSettings.YOpticalResolution);
    Trace(TEXT("CurrentBrightness = %d"),m_ScannerSettings.CurrentBrightness);
    Trace(TEXT("CurrentContrast = %d"),m_ScannerSettings.CurrentContrast);
    Trace(TEXT("ADFSupport = %d"),m_ScannerSettings.ADFSupport);
    Trace(TEXT("TPASupport = %d"),m_ScannerSettings.TPASupport);
    Trace(TEXT("RawPixelPackingOrder = %d"),m_ScannerSettings.RawPixelPackingOrder);
    Trace(TEXT("RawPixelFormat = %d"),m_ScannerSettings.RawPixelFormat);
    Trace(TEXT("RawDataAlignment = %d"),m_ScannerSettings.RawDataAlignment);
    Trace(TEXT("FeederWidth = %d"),m_ScannerSettings.FeederWidth);
    Trace(TEXT("FeederHeight = %d"),m_ScannerSettings.FeederHeight);
    Trace(TEXT("VFeederJustification = %d"),m_ScannerSettings.VFeederJustification);
    Trace(TEXT("HFeederJustification = %d"),m_ScannerSettings.HFeederJustification);
    Trace(TEXT("MaxADFPageCapacity = %d"),m_ScannerSettings.MaxADFPageCapacity);
    Trace(TEXT("CurrentDataType = %d"),m_ScannerSettings.CurrentDataType );
    Trace(TEXT("CurrentBitDepth = %d"),m_ScannerSettings.CurrentBitDepth);
    Trace(TEXT("XSupportedResolutionsRange.lMax = %d"),m_ScannerSettings.XSupportedResolutionsRange.lMax);
    Trace(TEXT("XSupportedResolutionsRange.lMin = %d"),m_ScannerSettings.XSupportedResolutionsRange.lMin);
    Trace(TEXT("XSupportedResolutionsRange.lNom = %d"),m_ScannerSettings.XSupportedResolutionsRange.lNom);
    Trace(TEXT("XSupportedResolutionsRange.lStep = %d"),m_ScannerSettings.XSupportedResolutionsRange.lStep);
    Trace(TEXT("YSupportedResolutionsRange.lMax = %d"),m_ScannerSettings.YSupportedResolutionsRange.lMax);
    Trace(TEXT("YSupportedResolutionsRange.lMin = %d"),m_ScannerSettings.YSupportedResolutionsRange.lMin);
    Trace(TEXT("YSupportedResolutionsRange.lNom = %d"),m_ScannerSettings.YSupportedResolutionsRange.lNom);
    Trace(TEXT("YSupportedResolutionsRange.lStep = %d"),m_ScannerSettings.YSupportedResolutionsRange.lStep);
    Trace(TEXT("XExtentsRange.lMax = %d"),m_ScannerSettings.XExtentsRange.lMax);
    Trace(TEXT("XExtentsRange.lMin = %d"),m_ScannerSettings.XExtentsRange.lMin);
    Trace(TEXT("XExtentsRange.lNom = %d"),m_ScannerSettings.XExtentsRange.lNom);
    Trace(TEXT("XExtentsRange.lStep = %d"),m_ScannerSettings.XExtentsRange.lStep);
    Trace(TEXT("YExtentsRange.lMax = %d"),m_ScannerSettings.YExtentsRange.lMax);
    Trace(TEXT("YExtentsRange.lMin = %d"),m_ScannerSettings.YExtentsRange.lMin);
    Trace(TEXT("YExtentsRange.lNom = %d"),m_ScannerSettings.YExtentsRange.lNom);
    Trace(TEXT("YExtentsRange.lStep = %d"),m_ScannerSettings.YExtentsRange.lStep);
    Trace(TEXT("XPosRange.lMax = %d"),m_ScannerSettings.XPosRange.lMax);
    Trace(TEXT("XPosRange.lMin = %d"),m_ScannerSettings.XPosRange.lMin);
    Trace(TEXT("XPosRange.lNom = %d"),m_ScannerSettings.XPosRange.lNom);
    Trace(TEXT("XPosRange.lStep = %d"),m_ScannerSettings.XPosRange.lStep);
    Trace(TEXT("YPosRange.lMax = %d"),m_ScannerSettings.YPosRange.lMax);
    Trace(TEXT("YPosRange.lMin = %d"),m_ScannerSettings.YPosRange.lMin);
    Trace(TEXT("YPosRange.lNom = %d"),m_ScannerSettings.YPosRange.lNom);
    Trace(TEXT("YPosRange.lStep = %d"),m_ScannerSettings.YPosRange.lStep);
    Trace(TEXT("CurrentXPos = %d"),m_ScannerSettings.CurrentXPos);
    Trace(TEXT("CurrentYPos = %d"),m_ScannerSettings.CurrentYPos);
    Trace(TEXT("CurrentXExtent = %d"),m_ScannerSettings.CurrentXExtent);
    Trace(TEXT("CurrentYExtent = %d"),m_ScannerSettings.CurrentYExtent);
    Trace(TEXT("BrightnessRange.lMax = %d"),m_ScannerSettings.BrightnessRange.lMax);
    Trace(TEXT("BrightnessRange.lMin = %d"),m_ScannerSettings.BrightnessRange.lMin);
    Trace(TEXT("BrightnessRange.lNom = %d"),m_ScannerSettings.BrightnessRange.lNom);
    Trace(TEXT("BrightnessRange.lStep = %d"),m_ScannerSettings.BrightnessRange.lStep);
    Trace(TEXT("ContrastRange.lMax = %d"),m_ScannerSettings.ContrastRange.lMax);
    Trace(TEXT("ContrastRange.lMin = %d"),m_ScannerSettings.ContrastRange.lMin);
    Trace(TEXT("ContrastRange.lNom = %d"),m_ScannerSettings.ContrastRange.lNom);
    Trace(TEXT("ContrastRange.lStep = %d"),m_ScannerSettings.ContrastRange.lStep);
    Trace(TEXT("XSupportedResolutionsList = %x"),m_ScannerSettings.XSupportedResolutionsList);
    Trace(TEXT("YSupportedResolutionsList = %x"),m_ScannerSettings.YSupportedResolutionsList);

    if(m_ScannerSettings.XSupportedResolutionsList) {
        LONG lNumResolutions = m_ScannerSettings.XSupportedResolutionsList[0];
        Trace(TEXT("Number of Supported X Resolutions = %d"),lNumResolutions);
        for(LONG i = 1;i<=lNumResolutions;i++){
            Trace(TEXT("Supported Resolution #%d = %d"),i,m_ScannerSettings.XSupportedResolutionsList[i]);
        }
    }

    if(m_ScannerSettings.YSupportedResolutionsList) {
        LONG lNumResolutions = m_ScannerSettings.YSupportedResolutionsList[0];
        Trace(TEXT("Number of Supported Y Resolutions = %d"),lNumResolutions);
        for(LONG i = 1;i<=lNumResolutions;i++){
            Trace(TEXT("Supported Resolution #%d = %d"),i,m_ScannerSettings.YSupportedResolutionsList[i]);
        }
    }

    return hr;
}

HRESULT CIOBlock::ReadValue(LONG ValueID, PLONG plValue)
{
    HRESULT hr = S_OK;

    if(NULL == plValue){
        return E_INVALIDARG;
    }

    //
    // set returned long value to 0
    //

    *plValue = 0;

    //
    // initialize LastError Object to SUCCESS
    //

    m_pLastError->m_hr            = S_OK;

    //
    // set action ID
    //

    m_pDeviceAction->m_DeviceActionID         = 102; // make #define

    //
    // set value ID
    //

    m_pDeviceAction->m_DeviceValueID   = ValueID;

    //                                            //
    // ****************************************** //
    //                                            //

    //
    // Give engine our DeviceScriptSite interface...
    //

    IActiveScript  *pActiveScript = NULL;
    hr = m_pActiveScript->Clone(&pActiveScript);

    if (SUCCEEDED(hr)) {
        Trace(TEXT("cloning script success"));
    } else {
        Trace(TEXT("cloning script FAILED"));
        Trace(TEXT("hr = %x"),hr);
    }

    hr = pActiveScript->SetScriptSite((IActiveScriptSite *)m_pDeviceScriptSite);
    if (SUCCEEDED(hr)) {
        Trace(TEXT("SetScriptSite on cloned script"));
    } else {
        Trace(TEXT("SetScriptSite on cloned script FAILED"));
        Trace(TEXT("hr = %x"),hr);
    }

    //
    // Execute the scriptlet
    //

    hr = m_pActiveScript->SetScriptState(SCRIPTSTATE_CONNECTED);
    if (SUCCEEDED(hr)) {
        Trace(TEXT("Scripted connected"));
    } else {
        Trace(TEXT("Scripted connection FAILED"));
        Trace(TEXT("hr = %x"),hr);
    }

    //                                            //
    // ****************************************** //
    //                                            //

    //
    // signal script event (DeviceActionEvent)
    //

    hr = m_pDeviceAction->Fire_DeviceActionEvent();
    if(SUCCEEDED(hr)){

        //
        // check for any script-returned errors
        //

        hr = m_pLastError->m_hr;
        if(SUCCEEDED(hr)){
            *plValue = m_pDeviceAction->m_lValue;
        }
    }
    return hr;
}

HRESULT CIOBlock::WriteValue(LONG ValueID, LONG lValue)
{
    HRESULT hr = S_OK;

    //
    // initialize LastError Object to SUCCESS
    //

    m_pLastError->m_hr            = S_OK;

    //
    // set action ID
    //

    m_pDeviceAction->m_DeviceActionID         = 101; // make #define

    //
    // set value ID
    //

    m_pDeviceAction->m_DeviceValueID   = ValueID;

    //
    // set value
    //

    m_pDeviceAction->m_lValue = lValue;

    //                                            //
    // ****************************************** //
    //                                            //

    //
    // Give engine our DeviceScriptSite interface...
    //

    IActiveScript  *pActiveScript = NULL;
    hr = m_pActiveScript->Clone(&pActiveScript);

    if (SUCCEEDED(hr)) {
        Trace(TEXT("cloning script success"));
    } else {
        Trace(TEXT("cloning script FAILED"));
        Trace(TEXT("hr = %x"),hr);
    }

    hr = pActiveScript->SetScriptSite((IActiveScriptSite *)m_pDeviceScriptSite);
    if (SUCCEEDED(hr)) {
        Trace(TEXT("SetScriptSite on cloned script"));
    } else {
        Trace(TEXT("SetScriptSite on cloned script FAILED"));
        Trace(TEXT("hr = %x"),hr);
    }

    //
    // Execute the scriptlet
    //

    hr = m_pActiveScript->SetScriptState(SCRIPTSTATE_CONNECTED);
    if (SUCCEEDED(hr)) {
        Trace(TEXT("Scripted connected"));
    } else {
        Trace(TEXT("Scripted connection FAILED"));
        Trace(TEXT("hr = %x"),hr);
    }

    //                                            //
    // ****************************************** //
    //                                            //

    //
    // signal script event (DeviceActionEvent)
    //

    hr = m_pDeviceAction->Fire_DeviceActionEvent();
    if(SUCCEEDED(hr)){

        //
        // check for any script-returned errors
        //

        hr = m_pLastError->m_hr;
    }

    pActiveScript->Release();

    return hr;
}

HRESULT CIOBlock::InitializeProperties()
{
    HRESULT hr = S_OK;

    //
    // initialize LastError Object to SUCCESS
    //

    m_pLastError->m_hr            = S_OK;

    //
    // set action ID
    //

    m_pDeviceAction->m_DeviceActionID         = 100; // make #define

    //                                            //
    // ****************************************** //
    //                                            //

    //
    // Give engine our DeviceScriptSite interface...
    //

    IActiveScript  *pActiveScript = NULL;
    hr = m_pActiveScript->Clone(&pActiveScript);

    if (SUCCEEDED(hr)) {
        Trace(TEXT("cloning script success"));
    } else {
        Trace(TEXT("cloning script FAILED"));
        Trace(TEXT("hr = %x"),hr);
    }

    hr = pActiveScript->SetScriptSite((IActiveScriptSite *)m_pDeviceScriptSite);
    if (SUCCEEDED(hr)) {
        Trace(TEXT("SetScriptSite on cloned script"));
    } else {
        Trace(TEXT("SetScriptSite on cloned script FAILED"));
        Trace(TEXT("hr = %x"),hr);
    }

    //
    // Execute the scriptlet
    //

    hr = m_pActiveScript->SetScriptState(SCRIPTSTATE_CONNECTED);
    if (SUCCEEDED(hr)) {
        Trace(TEXT("Scripted connected"));
    } else {
        Trace(TEXT("Scripted connection FAILED"));
        Trace(TEXT("hr = %x"),hr);
    }

    //                                            //
    // ****************************************** //
    //                                            //

    //
    // signal script event (DeviceActionEvent)
    //

    hr = m_pDeviceAction->Fire_DeviceActionEvent();
    if(SUCCEEDED(hr)){

        //
        // check for any script-returned errors
        //

        hr = m_pLastError->m_hr;
    }

    pActiveScript->Release();

    return hr;
}

HRESULT CIOBlock::Scan(LONG lPhase, PBYTE pBuffer, LONG lLength, LONG *plReceived)
{
    m_pDeviceControl->m_pBuffer      = pBuffer;
    m_pDeviceControl->m_lBufferSize  = lLength;
    m_pDeviceControl->m_dwBytesRead = 0;

    HRESULT hr = S_OK;

    //
    // initialize LastError Object to SUCCESS
    //

    m_pLastError->m_hr            = S_OK;
    m_pDeviceAction->m_lValue     = lLength; // set data amount requested

    //
    // set action ID
    //

    switch(lPhase){
    case SCAN_FIRST:
        m_pDeviceAction->m_DeviceActionID         = 104; // make #define
        break;
    case SCAN_NEXT:
        m_pDeviceAction->m_DeviceActionID         = 105; // make #define
        break;
    case SCAN_FINISHED:
        m_pDeviceAction->m_DeviceActionID         = 106; // make #define
        break;
    default:
        break;
    }

    //                                            //
    // ****************************************** //
    //                                            //

    //
    // Give engine our DeviceScriptSite interface...
    //

    IActiveScript  *pActiveScript = NULL;
    hr = m_pActiveScript->Clone(&pActiveScript);

    if (SUCCEEDED(hr)) {
        Trace(TEXT("cloning script success"));
    } else {
        Trace(TEXT("cloning script FAILED"));
        Trace(TEXT("hr = %x"),hr);
    }

    hr = pActiveScript->SetScriptSite((IActiveScriptSite *)m_pDeviceScriptSite);
    if (SUCCEEDED(hr)) {
        Trace(TEXT("SetScriptSite on cloned script"));
    } else {
        Trace(TEXT("SetScriptSite on cloned script FAILED"));
        Trace(TEXT("hr = %x"),hr);
    }

    //
    // Execute the scriptlet
    //

    hr = m_pActiveScript->SetScriptState(SCRIPTSTATE_CONNECTED);
    if (SUCCEEDED(hr)) {
        Trace(TEXT("Scripted connected"));
    } else {
        Trace(TEXT("Scripted connection FAILED"));
        Trace(TEXT("hr = %x"),hr);
    }

    //                                            //
    // ****************************************** //
    //                                            //

    //
    // signal script event (DeviceActionEvent)
    //

    hr = m_pDeviceAction->Fire_DeviceActionEvent();
    if(SUCCEEDED(hr)){

        //
        // check for any script-returned errors
        //

        hr = m_pLastError->m_hr;
    }

    pActiveScript->Release();

    if(NULL != plReceived){
        *plReceived = m_pDeviceControl->m_dwBytesRead;
    }

    return hr;
}

BOOL CIOBlock::GetEventStatus(PGSD_EVENT_INFO pGSDEventInfo)
{

    //
    // ask script about device reporting an event...
    // if there is an event, fill out pGSDEventInfo structure
    // and return TRUE, letting WIAFBDRV know that an event has
    // occured....or return FALSE, that nothing has happened.
    //

    // Dispatch a GETEVENT_STATUS event action to script here.

    //
    // check returned status flag... if no event happened, return FALSE;
    // else..somthing did happen..so check the returned mapping key.
    //

    //
    // script will return a mapping key that corresponds to
    // the device event.
    //

    //
    // use key to look up correct GUID from the driver's reported supported
    // event list, set GUID, and continue to return TRUE
    //

    return FALSE;
}

BOOL CIOBlock::DeviceOnLine()
{

    //
    // ask script to check that the device is ON-LINE, and
    // funtional. Return TRUE, if it is, and FALSE if it is not.
    //

    // Dispatch a DEVICE_ONLINE event action to script here.

    return TRUE;
}

HRESULT CIOBlock::ResetDevice()
{
    HRESULT hr = S_OK;

    //
    // ask script to reset the device to a power-on state.
    // Return TRUE, if it succeeded, and FALSE if it did not.
    //

    // Dispatch a DEVICE_RESET event action to script here.

    return hr;
}

HRESULT CIOBlock::EventInterrupt(PGSD_EVENT_INFO pGSDEventInfo)
{
    BYTE  InterruptData = 0;
    DWORD dwIndex       = 0;
    DWORD dwError       = 0;
    BOOL  fLooping      = TRUE;
    BOOL  bRet          = TRUE;
    DWORD dwBytesRet    = 0;

    OVERLAPPED Overlapped;
    memset(&Overlapped,0,sizeof(OVERLAPPED));

    //
    // create an event to wait on
    //

    Overlapped.hEvent = CreateEvent( NULL, TRUE, FALSE, NULL );

    HANDLE  hEventArray[2] = {pGSDEventInfo->hShutDownEvent, Overlapped.hEvent};
    HANDLE  InterruptHandle = m_ScannerSettings.DeviceIOHandles[0]; // <- SET INTERRUPT PIPE INDEX
                                                                    //    WITH REAL INDEX VALUE!!
    while (fLooping) {
        bRet = DeviceIoControl( InterruptHandle,
                                IOCTL_WAIT_ON_DEVICE_EVENT,
                                NULL,
                                0,
                                &InterruptData,
                                sizeof(InterruptData),
                                &dwError,
                                &Overlapped );

        if ( bRet || ( !bRet && ( ::GetLastError() == ERROR_IO_PENDING ))) {
            dwIndex = WaitForMultipleObjects( 2,
                                              hEventArray,
                                              FALSE,
                                              INFINITE );
            switch ( dwIndex ) {
                case WAIT_OBJECT_0+1:
                    bRet = GetOverlappedResult( InterruptHandle, &Overlapped, &dwBytesRet, FALSE );
                    if (dwBytesRet) {
                        // Change detected - signal
                        if (*pGSDEventInfo->phSignalEvent != INVALID_HANDLE_VALUE) {

                            //
                            // InterruptData contains result from device
                            // *pGSDEventInfo->pEventGUID needs to be set to
                            // the correct EVENT. (map event to result here??)
                            //

                            //
                            // ask script to report a mapping key that corresponds to
                            // the InterruptData returned information from device event.
                            //
                            // Dispatch a MAP_EVENT_RESULT_TO_KEY event action to script here.
                            //

                            //
                            // use key to look up correct GUID from the driver's reported supported
                            // event list, set GUID, and continue to set
                            // "SignalEvent" for service notification.
                            //

                            //
                            // signal service about the event
                            //

                            SetEvent(*pGSDEventInfo->phSignalEvent);
                        }
                        break;
                    }

                    //
                    // reset the overlapped event
                    //

                    ResetEvent( Overlapped.hEvent );
                    break;

                case WAIT_OBJECT_0:
                default:
                    fLooping = FALSE;
            }
        }
        else {
            dwError = ::GetLastError();
            break;
        }
    }
    return S_OK;
}

////////////////////////////////////////////////////////////
// helpers called internally, or wrapped by a script call //
////////////////////////////////////////////////////////////

LONG CIOBlock::InsertINTIntoByteBuffer(PBYTE szDest, PBYTE szSrc, BYTE cPlaceHolder, INT iValueToInsert)
{
    LONG lFinalStringSize = 0;
    INT iSrcIndex         = 0;
    INT iValueIndex       = 0;
    CHAR szValue[10];

    // clean value string, and convert INT to characters
    memset(szValue,0,sizeof(szValue));
    _itoa(iValueToInsert,szValue,10);

    while(szSrc[iSrcIndex] != '\0'){
        // check for place holder
        if (szSrc[iSrcIndex] != cPlaceHolder) {
            szDest[lFinalStringSize] = szSrc[iSrcIndex];
            iSrcIndex++;
            lFinalStringSize++; // increment size of buffer
        } else {
            // replace placeholder with integer value (in string format)
            iValueIndex = 0;
            while (szValue[iValueIndex] != '\0') {
                szDest[lFinalStringSize] = szValue[iValueIndex];
                iValueIndex++;
                lFinalStringSize++; // increment size of command buffer
            }
            iSrcIndex++;
        }
    }
    // terminate buffer with NULL character
    szDest[lFinalStringSize] = '\0';
    lFinalStringSize++;
    return lFinalStringSize;
}

LONG CIOBlock::ExtractINTFromByteBuffer(PINT iDest, PBYTE szSrc, BYTE cTerminatorByte, INT iOffset)
{
    *iDest = 0;
    BYTE szTempBuffer[25];
    INT iValueIndex = 0;
    memset(szTempBuffer,0,sizeof(szTempBuffer));

    while (szSrc[iOffset] != cTerminatorByte) {
        szTempBuffer[iValueIndex] = szSrc[iOffset];
        iValueIndex++;
        iOffset++;
    }
    iValueIndex++;
    szTempBuffer[iValueIndex] = '\0';

    *iDest = atoi((char*)szTempBuffer);
    return (LONG)*iDest;
}

VOID Trace(LPCTSTR format,...)
{

#ifdef DEBUG

    TCHAR Buffer[1024];
    va_list arglist;
    va_start(arglist, format);
    wvsprintf(Buffer, format, arglist);
    va_end(arglist);
    OutputDebugString(Buffer);
    OutputDebugString(TEXT("\n"));

#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\wiafbdrv\lasterr.h ===
// LastError.h : Declaration of the CLastError

#ifndef __LASTERROR_H_
#define __LASTERROR_H_

#include "resource.h"       // main symbols
#include "ioblockdefs.h"

/////////////////////////////////////////////////////////////////////////////
// CLastError
class ATL_NO_VTABLE CLastError :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CLastError, &CLSID_LastError>,
    public IDispatchImpl<ILastError, &IID_ILastError, &LIBID_WIAFBLib>,
    public IObjectSafetyImpl<CLastError, INTERFACESAFE_FOR_UNTRUSTED_CALLER>
{
public:

    SCANSETTINGS *m_pScannerSettings;
    HRESULT m_hr;

    CLastError()
    {
        m_hr = S_OK;
    }

DECLARE_REGISTRY_RESOURCEID(IDR_LASTERROR)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CLastError)
    COM_INTERFACE_ENTRY(ILastError)
    COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// ILastError
public:
};

#endif //__LASTERROR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\wiafbdrv\pch.h ===
#ifndef _PCH_H
#define _PCH_H

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <stdio.h>
#include <tchar.h>
#include <objbase.h>
#include <sti.h>
#include <assert.h>
#include <windows.h>
#include <stierr.h>

#define INITGUID
#include "initguid.h"
#include <stiusd.h>

#pragma intrinsic(memcmp,memset)

#include "resource.h"
#include "wiamindr.h"
#include "wiaprop.h"

#define _ATL_APARTMENT_THREADED

#include <atlbase.h>

extern CComModule _Module;
#include <atlcom.h>
#include <atlwin.h>
#include <atlctl.h>
#include "wiafb.h"
#include "wiamicro.h"

#include "cmicro.h"
#include "ioblock.h"
#include "scanapi.h"
#include "wiafbdrv.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\wiafbdrv\scanapi.cpp ===
/**************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       scanapi.cpp
*
*  VERSION:     1.0
*
*  DATE:        18 July, 2000
*
*  DESCRIPTION:
*   Fake Scanner device library
*
***************************************************************************/

#include "pch.h"

#ifdef UNICODE
    #define TSTRSTR wcsstr
    #define TSSCANF swscanf
#else
    #define TSTRSTR strstr
    #define TSSCANF sscanf
#endif

////////////////////////////////////////////////////////////////////////////////
// MICRO DRIVER SYSTEM SUPPORT                                                //
////////////////////////////////////////////////////////////////////////////////
CMicroDriverAPI::CMicroDriverAPI()
{
    // wipe supported resolutions string
    memset(m_szResolutions,0,sizeof(m_szResolutions));
    // wipe scaninfo structure
    memset(&m_ScanInfo,0,sizeof(m_ScanInfo));
    m_bDisconnected = FALSE;
}

CMicroDriverAPI::~CMicroDriverAPI()
{

    //
    // close any open Device Data handles left open by Micro Driver
    // skip index 0 because WIAFBDRV owns that handle..
    //

    for(int i = 1; i < MAX_IO_HANDLES ; i++){
        if((NULL != m_ScanInfo.DeviceIOHandles[i]) && (INVALID_HANDLE_VALUE != m_ScanInfo.DeviceIOHandles[i])){
            CloseHandle(m_ScanInfo.DeviceIOHandles[i]);
            m_ScanInfo.DeviceIOHandles[i] = NULL;
        }
    }

    if(m_pMicroDriver){
        delete m_pMicroDriver;
        m_pMicroDriver = NULL;
    }
}

//
// data acquisition functions
//

HRESULT CMicroDriverAPI::Scan(LONG lState, PBYTE pData, DWORD dwBytesToRead, PDWORD pdwBytesWritten)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::Scan");

    HRESULT hr = S_OK;
    LONG lLine = SCAN_FIRST;

    switch (lState) {
    case SCAN_START:
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("CMicroDriverAPI::Scan, SCAN_START"));
        lLine = SCAN_FIRST;
        break;
    case SCAN_CONTINUE:
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("CMicroDriverAPI::Scan, SCAN_CONTINUE"));
        lLine = SCAN_NEXT;
        break;
    case SCAN_END:
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("CMicroDriverAPI::Scan, SCAN_END"));
        lLine = SCAN_FINISHED;
    default:
        break;
    }

    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("CMicroDriverAPI::Scan, Requesting %d bytes from caller",dwBytesToRead));
    hr = m_pMicroDriver->Scan(&m_ScanInfo,lLine,pData,dwBytesToRead,(LONG*)pdwBytesWritten);
    if(pdwBytesWritten){
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("CMicroDriverAPI::Scan, Returning  %d bytes to caller",*pdwBytesWritten));
    } else {
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("CMicroDriverAPI::Scan, Returning  0 bytes to caller"));
    }

    if(FAILED(hr)){
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CMicroDriverAPI::Scan, Failed to Acquire data"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
    } else {
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("CMicroDriverAPI::Scan, Data Pointer = %x",pData));
    }

    //
    // handle device disconnection error
    //

    if(m_bDisconnected){
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("Scan, Device was disconnected, returning WIA_ERROR_OFFLINE to caller"));
        return WIA_ERROR_OFFLINE;
    }
    return hr;
}

HRESULT CMicroDriverAPI::SetDataType(LONG lDataType)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::SetDataType");

    HRESULT hr = S_OK;
    VAL Val;
    memset(&Val,0,sizeof(Val));
    Val.pScanInfo = &m_ScanInfo;

    Val.lVal = lDataType;
    hr = m_pMicroDriver->MicroEntry(CMD_SETDATATYPE, &Val);

    return hr;
}

HRESULT CMicroDriverAPI::SetXYResolution(LONG lXResolution, LONG lYResolution)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::SetXYResolution");

    HRESULT hr = S_OK;
    VAL Val;
    memset(&Val,0,sizeof(Val));
    Val.pScanInfo = &m_ScanInfo;

    Val.lVal = lXResolution;
    hr = m_pMicroDriver->MicroEntry(CMD_SETXRESOLUTION, &Val);
    if (FAILED(hr))
        return hr;

    Val.lVal = lYResolution;
    hr = m_pMicroDriver->MicroEntry(CMD_SETYRESOLUTION, &Val);

    return hr;
}

HRESULT CMicroDriverAPI::SetSelectionArea(LONG lXPos, LONG lYPos, LONG lXExt, LONG lYExt)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::SetSelectionArea");

    HRESULT hr = S_OK;
    hr = m_pMicroDriver->SetPixelWindow(&m_ScanInfo,lXPos,lYPos,lXExt,lYExt);
    return hr;
}

HRESULT CMicroDriverAPI::SetContrast(LONG lContrast)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::SetContrast");

    HRESULT hr = S_OK;
    VAL Val;
    memset(&Val,0,sizeof(Val));
    Val.pScanInfo = &m_ScanInfo;

    Val.lVal = lContrast;
    hr = m_pMicroDriver->MicroEntry(CMD_SETCONTRAST, &Val);

    return hr;
}

HRESULT CMicroDriverAPI::SetIntensity(LONG lIntensity)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::SetIntensity");

    HRESULT hr = S_OK;
    VAL Val;
    memset(&Val,0,sizeof(Val));
    Val.pScanInfo = &m_ScanInfo;

    Val.lVal = lIntensity;
    hr = m_pMicroDriver->MicroEntry(CMD_SETINTENSITY, &Val);

    return hr;
}

HRESULT CMicroDriverAPI::DisableDevice()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::DisableDevice");

    HRESULT hr = S_OK;
    m_bDisconnected = TRUE;
    return hr;
}

HRESULT CMicroDriverAPI::EnableDevice()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::EnableDevice");

    HRESULT hr = S_OK;
    m_bDisconnected = FALSE;
    return hr;
}

HRESULT CMicroDriverAPI::DeviceOnline()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::DeviceOnline");

    HRESULT hr = S_OK;
    VAL Val;
    memset(&Val,0,sizeof(Val));
    Val.pScanInfo = &m_ScanInfo;
    hr = m_pMicroDriver->MicroEntry(CMD_STI_GETSTATUS,&Val);
    if (SUCCEEDED(hr)) {
        if (Val.lVal != 1)
            hr = E_FAIL;
    }
    return hr;
}

HRESULT CMicroDriverAPI::GetDeviceEvent(GUID *pEvent)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::GetDeviceEvent");

    HRESULT hr = S_OK;
    VAL Val;
    memset(&Val,0,sizeof(Val));
    Val.pScanInfo = &m_ScanInfo;
    *pEvent = GUID_NULL;
    hr = m_pMicroDriver->MicroEntry(CMD_STI_GETSTATUS,&Val);
    if (SUCCEEDED(hr)) {
        if (Val.pGuid != NULL)
            *pEvent = *Val.pGuid;
        else
            *pEvent = GUID_NULL;
    }
    return hr;
}

HRESULT CMicroDriverAPI::DoInterruptEventThread(PINTERRUPTEVENTINFO pEventInfo)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::DoInterruptEventThread");

    HRESULT hr = S_OK;

    VAL Val;
    memset(&Val,0,sizeof(Val));
    Val.pHandle   = pEventInfo->phSignalEvent;
    Val.handle    = pEventInfo->hShutdownEvent;
    Val.pGuid     = pEventInfo->pguidEvent;
    Val.pScanInfo = &m_ScanInfo;
    lstrcpyA(Val.szVal,pEventInfo->szDeviceName);

    hr = m_pMicroDriver->MicroEntry(CMD_GET_INTERRUPT_EVENT,&Val);
    return hr;
}

HRESULT CMicroDriverAPI::Diagnostic()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::Diagnostic");

    HRESULT hr = S_OK;

    VAL Val;
    memset(&Val,0,sizeof(Val));
    Val.pScanInfo = &m_ScanInfo;
    hr = m_pMicroDriver->MicroEntry(CMD_STI_DIAGNOSTIC,&Val);

    return hr;
}

HRESULT CMicroDriverAPI::Initialize(PINITINFO pInitInfo)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::Initialize");

    HRESULT hr = S_OK;
    VAL Val;
    memset(&Val,0,sizeof(Val));

    m_pMicroDriver = NULL;
    m_pMicroDriver = new CMICRO(pInitInfo->szModuleFileName);
    if (NULL != m_pMicroDriver) {

        // set DeviceIOHandles
        m_ScanInfo.DeviceIOHandles[0] = pInitInfo->hDeviceDataHandle;
        // send HKEY
        hr = SetSTIDeviceHKEY(&pInitInfo->hKEY);
        // send Initialize call
        Val.pScanInfo  = &m_ScanInfo;
        lstrcpyA(Val.szVal,pInitInfo->szCreateFileName);
        hr = m_pMicroDriver->MicroEntry(CMD_INITIALIZE,&Val);
        if(hr == S_OK){

            //
            // perform a quick validation sweep, to make sure we didn't get bad values
            // from a micro driver
            //

            //
            // check current values, for strange negative values...or 0
            //

            if(m_ScanInfo.BedHeight <= 0){
                hr = E_INVALIDARG;
            }

            if(m_ScanInfo.BedWidth <= 0){
                hr = E_INVALIDARG;
            }

            if(m_ScanInfo.Xresolution <= 0){
                hr = E_INVALIDARG;
            }

            if(m_ScanInfo.Yresolution <= 0){
                hr = E_INVALIDARG;
            }

            if(m_ScanInfo.OpticalXResolution <= 0){
                hr = E_INVALIDARG;
            }

            if(m_ScanInfo.OpticalYResolution <= 0){
                hr = E_INVALIDARG;
            }

            if(SUCCEEDED(hr)){

                //
                // check logical values
                //

            }
        }
    } else
        hr = E_OUTOFMEMORY;
    return hr;
}

HRESULT CMicroDriverAPI::UnInitialize()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::UnInitialize");
    HRESULT hr = S_OK;
    VAL Val;
    memset(&Val,0,sizeof(Val));
    // send UnInitialize call
    Val.pScanInfo  = &m_ScanInfo;
    hr = m_pMicroDriver->MicroEntry(CMD_UNINITIALIZE,&Val);
    if(E_NOTIMPL == hr){
        hr = S_OK;
    }
    return hr;
}

//
// standard device operations
//

HRESULT CMicroDriverAPI::ResetDevice()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::ResetDevice");

    HRESULT hr = S_OK;

    VAL Val;
    memset(&Val,0,sizeof(Val));
    Val.pScanInfo = &m_ScanInfo;
    hr = m_pMicroDriver->MicroEntry(CMD_STI_DEVICERESET,&Val);

    return hr;
}
HRESULT CMicroDriverAPI::SetEmulationMode(LONG lDeviceMode)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::SetEmulationMode");

    HRESULT hr = S_OK;
    return hr;
}

//
// Automatic document feeder functions
//

HRESULT CMicroDriverAPI::ADFAttached()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::ADFAttached");

    if(m_ScanInfo.ADF == 1)
        return S_OK;
    else
        return S_FALSE;
}

HRESULT CMicroDriverAPI::ADFHasPaper()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::ADFHasPaper");

    HRESULT hr = S_OK;

    VAL Val;
    memset(&Val,0,sizeof(Val));
    Val.pScanInfo = &m_ScanInfo;
    Val.lVal      = MCRO_ERROR_GENERAL_ERROR;

    hr = m_pMicroDriver->MicroEntry(CMD_GETADFHASPAPER,&Val);
    if(hr == E_NOTIMPL)
        return S_OK;

    if(FAILED(hr))
        return hr;

    if(MicroDriverErrorToWIAError(Val.lVal) == WIA_ERROR_PAPER_EMPTY){
        hr = S_FALSE;
    }
    return hr;
}

HRESULT CMicroDriverAPI::ADFAvailable()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::ADFAvailable");

    HRESULT hr = S_OK;

    VAL Val;
    memset(&Val,0,sizeof(Val));
    Val.pScanInfo = &m_ScanInfo;
    Val.lVal      = MCRO_ERROR_GENERAL_ERROR;

    hr = m_pMicroDriver->MicroEntry(CMD_GETADFAVAILABLE,&Val);
    if(hr == E_NOTIMPL)
        return S_OK;

    if(FAILED(hr))
        return hr;

    return MicroDriverErrorToWIAError(Val.lVal);
}

HRESULT CMicroDriverAPI::ADFFeedPage()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::ADFFeedPage");

    HRESULT hr = S_OK;

    VAL Val;
    memset(&Val,0,sizeof(Val));
    Val.pScanInfo = &m_ScanInfo;
    Val.lVal      = MCRO_ERROR_GENERAL_ERROR;

    hr = m_pMicroDriver->MicroEntry(CMD_LOAD_ADF,&Val);
    if(hr == E_NOTIMPL)
        return S_OK;

    if(FAILED(hr))
        return hr;

    return MicroDriverErrorToWIAError(Val.lVal);
}

HRESULT CMicroDriverAPI::ADFUnFeedPage()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::ADFUnFeedPage");

    HRESULT hr = S_OK;

    VAL Val;
    memset(&Val,0,sizeof(Val));
    Val.pScanInfo = &m_ScanInfo;
    Val.lVal      = MCRO_ERROR_GENERAL_ERROR;

    hr = m_pMicroDriver->MicroEntry(CMD_UNLOAD_ADF,&Val);
    if(hr == E_NOTIMPL)
        return S_OK;

    if(FAILED(hr))
        return hr;

    return MicroDriverErrorToWIAError(Val.lVal);
}

HRESULT CMicroDriverAPI::ADFStatus()
{
    HRESULT hr = S_OK;

    VAL Val;
    memset(&Val,0,sizeof(Val));
    Val.pScanInfo = &m_ScanInfo;
    Val.lVal      = MCRO_ERROR_GENERAL_ERROR;

    hr = m_pMicroDriver->MicroEntry(CMD_GETADFSTATUS,&Val);
    if(hr == E_NOTIMPL)
        return S_OK;

    if(FAILED(hr))
        return hr;

    return MicroDriverErrorToWIAError(Val.lVal);
}

HRESULT CMicroDriverAPI::SetFormat(GUID *pguidFormat)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::SetFormat");

    HRESULT hr = S_OK;

    VAL Val;
    memset(&Val,0,sizeof(Val));
    Val.pScanInfo = &m_ScanInfo;
    Val.pGuid = pguidFormat;

    hr = m_pMicroDriver->MicroEntry(CMD_SETFORMAT,&Val);
    if(hr == E_NOTIMPL)
        return S_OK;

    if(FAILED(hr))
        return hr;

    return hr;
}

HRESULT CMicroDriverAPI::MicroDriverErrorToWIAError(LONG lMicroDriverError)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::MicroDriverErrorToWIAError");

    HRESULT hr = E_FAIL;
    switch(lMicroDriverError){
    case MCRO_STATUS_OK:
        hr =  S_OK;
        break;
    case MCRO_ERROR_USER_INTERVENTION:
        hr =  WIA_ERROR_USER_INTERVENTION;
        break;
    case MCRO_ERROR_PAPER_JAM:
        hr =  WIA_ERROR_PAPER_JAM;
        break;
    case MCRO_ERROR_PAPER_PROBLEM:
        hr =  WIA_ERROR_PAPER_PROBLEM;
        break;
    case MCRO_ERROR_OFFLINE:
        hr =  WIA_ERROR_OFFLINE;
        break;
    case MCRO_ERROR_GENERAL_ERROR:
        hr =  WIA_ERROR_GENERAL_ERROR;
        break;
    case MCRO_ERROR_PAPER_EMPTY:
        hr =  WIA_ERROR_PAPER_EMPTY;
        break;
    default:
        break;
    }
    return hr;
}

//
// EXPECTED FORMAT:
// Range: "MIN 75,MAX 1200,NOM 150,INC 1"
// list:  "75, 100, 150, 200, 600, 1200"
//

BOOL CMicroDriverAPI::IsValidRestriction(LONG **ppList, LONG *plNumItems, RANGEVALUEEX *pRangeValues)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::IsValidRestriction");

    // set list pointer to null
    *ppList       = NULL;
    LONG *pList   = NULL;

    // set number of items to zero
    LONG lNumItems = 0;
    *plNumItems   = 0;

    // set range stucture to zeros
    pRangeValues->lMax  = 0;
    pRangeValues->lMin  = 0;
    pRangeValues->lNom  = 0;
    pRangeValues->lStep = 0;

    // string size check
    if(lstrlen(m_szResolutions) <= 0)
        return FALSE;

    // valid range or list check
    TCHAR *psz = NULL;

    // POOP
    CHAR szTemp[20];

    // END POOP

    // valid range?
    BOOL bValidRange = FALSE;
    psz = TSTRSTR(m_szResolutions,TEXT("MIN"));
    if (psz) {
        psz = TSTRSTR(psz,TEXT(" "));
        if (psz) {
            TSSCANF(psz,TEXT("%d"),&pRangeValues->lMin);
            psz = NULL;
            psz = TSTRSTR(m_szResolutions,TEXT("MAX"));
            if (psz) {
                psz = TSTRSTR(psz,TEXT(" "));
                if (psz) {
                    TSSCANF(psz,TEXT("%d"),&pRangeValues->lMax);
                    psz = NULL;
                    psz = TSTRSTR(m_szResolutions,TEXT("NOM"));
                    if (psz) {
                        psz = TSTRSTR(psz,TEXT(" "));
                        if (psz) {
                            TSSCANF(psz,TEXT("%d"),&pRangeValues->lNom);
                            psz = NULL;
                            psz = TSTRSTR(m_szResolutions,TEXT("INC"));
                            if (psz) {
                                psz = TSTRSTR(psz,TEXT(" "));
                                if (psz) {
                                    TSSCANF(psz,TEXT("%d"),&pRangeValues->lStep);
                                    bValidRange = TRUE;
                                }
                            }
                        }
                    }
                }
            }
        }

        // check that range values are valid (to the definition of a RANGE)
        if(bValidRange){
            if(pRangeValues->lMin > pRangeValues->lMax)
                return FALSE;
            if(pRangeValues->lNom > pRangeValues->lMax)
                return FALSE;
            if(pRangeValues->lStep > pRangeValues->lMax)
                return FALSE;
            if(pRangeValues->lNom < pRangeValues->lMin)
                return FALSE;
        }
    }

    if(!bValidRange){

        // set range stucture to zeros (invalid range settings)
        pRangeValues->lMax  = 0;
        pRangeValues->lMin  = 0;
        pRangeValues->lNom  = 0;
        pRangeValues->lStep = 0;

        LONG lTempResArray[255];
        memset(lTempResArray,0,sizeof(lTempResArray));
        // not valid range?..what about a valid list?

        // valid list?

        psz = m_szResolutions;
        while(psz){

            // save value if one is found
            if(psz){
                TSSCANF(psz,TEXT("%d"),&lTempResArray[lNumItems]);
                if(lTempResArray[lNumItems] <= 0){
                    // quit list iteration.. an invalid Resolution was found
                    lNumItems = 0;
                    break;
                }
                lNumItems++;
            }

            // seek to next value
            psz = TSTRSTR(psz,TEXT(","));
            if(psz) {
                // move past ',' marker
                psz+=sizeof(TCHAR);
            }
        }

        if (lNumItems > 0) {
            // create list, and send it back to caller
            pList = new LONG[lNumItems];
            if (!pList)
                return FALSE;

            for (LONG i = 0; i < lNumItems ; i++) {
                pList[i] = lTempResArray[i];
            }

            *plNumItems = lNumItems;
            *ppList     = pList;
        } else {
            return FALSE;
        }
    }

    return TRUE;
}

//
// button
//

HRESULT CMicroDriverAPI::QueryButtonPanel(PDEVICE_BUTTON_INFO pButtonInformation)
{
    HRESULT hr = S_OK;
    return hr;
}

HRESULT CMicroDriverAPI::BuildCapabilities(PWIACAPABILITIES pCaps)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::BuildCapabilities");

    HRESULT hr = S_OK;
    VAL Val;
    memset(&Val,0,sizeof(Val));
    Val.pScanInfo = &m_ScanInfo;
    WCHAR **pszButtonNames = NULL;

    hr = m_pMicroDriver->MicroEntry(CMD_GETCAPABILITIES,&Val);
    if(SUCCEEDED(hr)) {

        //
        // if this API is called with pCapabilities == NULL, then return the
        // total number of additional events.
        //

        if (NULL == pCaps->pCapabilities) {
            if (Val.lVal > 0){
                *pCaps->pNumSupportedEvents = Val.lVal;
                WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("BuildCapabilities, Additional Supported Events from MicroDriver = %d",Val.lVal));
            }

        } else {
            for (LONG index = 0; index < Val.lVal; index++) {

                //
                // access event Names Memory
                //

                pszButtonNames = Val.ppButtonNames;

                if (pszButtonNames != NULL) {

                    pCaps->pCapabilities[index].wszName = (LPOLESTR)CoTaskMemAlloc(255);
                    if (pCaps->pCapabilities[index].wszName != NULL) {
                        wcscpy(pCaps->pCapabilities[index].wszName, pszButtonNames[index]);
                    }

                    pCaps->pCapabilities[index].wszDescription = (LPOLESTR)CoTaskMemAlloc(255);
                    if (pCaps->pCapabilities[index].wszDescription != NULL) {
                        wcscpy(pCaps->pCapabilities[index].wszDescription, pszButtonNames[index]);
                    }

                    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("BuildCapabilities, Button Name = %ws",pCaps->pCapabilities[index].wszName));
                    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("BuildCapabilities, Button Desc = %ws",pCaps->pCapabilities[index].wszDescription));

                } else {

                    //
                    // do default WIA provided Names for buttons (1,2,3,4,5,...etc)
                    //

                    WCHAR wszNumber[4];
                    swprintf(wszNumber,L"%d",(index + 1));
                    wcscat(pCaps->pCapabilities[index].wszName,wszNumber);
                    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("BuildCapabilities, Button Name = %ws",pCaps->pCapabilities[index].wszName));
                }

                //
                // assign 'ACTION' to events
                //

                pCaps->pCapabilities[index].guid           = &Val.pGuid[index];
                pCaps->pCapabilities[index].ulFlags        = WIA_NOTIFICATION_EVENT|WIA_ACTION_EVENT;
                pCaps->pCapabilities[index].wszIcon        = WIA_ICON_DEVICE_CONNECTED;
            }
        }
    }

    return hr;
}

HRESULT CMicroDriverAPI::GetBedWidthAndHeight(PLONG pWidth, PLONG pHeight)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::GetBedWidthAndHeight");

    HRESULT hr = S_OK;
    *pWidth  = m_ScanInfo.BedWidth;
    *pHeight = m_ScanInfo.BedHeight;
    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("CMicroDriverAPI::GetBedWidthAndHeight, Width = %d, Height = %d",m_ScanInfo.BedWidth,m_ScanInfo.BedHeight));
    return hr;
}

HRESULT CMicroDriverAPI::BuildRootItemProperties(PWIAPROPERTIES pProperties)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::BuildRootItemProperties");

    HRESULT hr = S_OK;
    LONG PropIndex = 0;
    //
    // set the number of properties
    //

    hr = ADFAttached();
    if(hr == S_OK){
        pProperties->NumItemProperties = 19;   // standard properties + ADF specific
    } else {
        pProperties->NumItemProperties = 10;    // standard properties only
    }

    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("CMicroDriverAPI::BuildRootItemProperties, Number of Properties = %d",pProperties->NumItemProperties));

    hr = AllocateAllProperties(pProperties);
    if(FAILED(hr)){
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CMicroDriverAPI::BuildRootItemProperties, AllocateAllProperties failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        DeleteAllProperties(pProperties);
        return hr;
    }

    // Intialize WIA_DPS_HORIZONTAL_BED_SIZE
    pProperties->pszItemDefaults[PropIndex]              = WIA_DPS_HORIZONTAL_BED_SIZE_STR;
    pProperties->piItemDefaults [PropIndex]              = WIA_DPS_HORIZONTAL_BED_SIZE;
    pProperties->pvItemDefaults [PropIndex].lVal         = m_ScanInfo.BedWidth;
    pProperties->pvItemDefaults [PropIndex].vt           = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid       = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[PropIndex].vt           = pProperties->pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_DPS_VERTICAL_BED_SIZE
    pProperties->pszItemDefaults[PropIndex]              = WIA_DPS_VERTICAL_BED_SIZE_STR;
    pProperties->piItemDefaults [PropIndex]              = WIA_DPS_VERTICAL_BED_SIZE;
    pProperties->pvItemDefaults [PropIndex].lVal         = m_ScanInfo.BedHeight;
    pProperties->pvItemDefaults [PropIndex].vt           = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid       = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[PropIndex].vt           = pProperties->pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPA_ACCESS_RIGHTS
    pProperties->pszItemDefaults[PropIndex]              = WIA_IPA_ACCESS_RIGHTS_STR;
    pProperties->piItemDefaults [PropIndex]              = WIA_IPA_ACCESS_RIGHTS;
    pProperties->pvItemDefaults [PropIndex].lVal         = WIA_ITEM_READ|WIA_ITEM_WRITE;
    pProperties->pvItemDefaults [PropIndex].vt           = VT_UI4;
    pProperties->psItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid       = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[PropIndex].vt           = pProperties->pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_DPS_OPTICAL_XRES
    pProperties->pszItemDefaults[PropIndex]              = WIA_DPS_OPTICAL_XRES_STR;
    pProperties->piItemDefaults [PropIndex]              = WIA_DPS_OPTICAL_XRES;
    pProperties->pvItemDefaults [PropIndex].lVal         = m_ScanInfo.OpticalXResolution;
    pProperties->pvItemDefaults [PropIndex].vt           = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid       = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[PropIndex].vt           = pProperties->pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_DPS_OPTICAL_YRES
    pProperties->pszItemDefaults[PropIndex]              = WIA_DPS_OPTICAL_YRES_STR;
    pProperties->piItemDefaults [PropIndex]              = WIA_DPS_OPTICAL_YRES;
    pProperties->pvItemDefaults [PropIndex].lVal         = m_ScanInfo.OpticalYResolution;
    pProperties->pvItemDefaults [PropIndex].vt           = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid       = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[PropIndex].vt           = pProperties->pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Initialize WIA_DPA_FIRMWARE_VERSION
    pProperties->pszItemDefaults[PropIndex]              = WIA_DPA_FIRMWARE_VERSION_STR;
    pProperties->piItemDefaults [PropIndex]              = WIA_DPA_FIRMWARE_VERSION;
    pProperties->pvItemDefaults [PropIndex].bstrVal      = SysAllocString(SCANNER_FIRMWARE_VERSION);
    pProperties->pvItemDefaults [PropIndex].vt           = VT_BSTR;
    pProperties->psItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid       = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[PropIndex].vt           = pProperties->pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Initialize WIA_IPA_ITEM_FLAGS
    pProperties->pszItemDefaults[PropIndex]              = WIA_IPA_ITEM_FLAGS_STR;
    pProperties->piItemDefaults [PropIndex]              = WIA_IPA_ITEM_FLAGS;
    pProperties->pvItemDefaults [PropIndex].lVal         = WiaItemTypeRoot|WiaItemTypeFolder|WiaItemTypeDevice;
    pProperties->pvItemDefaults [PropIndex].vt           = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid       = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_FLAG;
    pProperties->wpiItemDefaults[PropIndex].vt           = pProperties->pvItemDefaults [PropIndex].vt;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Flag.Nom  = pProperties->pvItemDefaults [PropIndex].lVal;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Flag.ValidBits = WiaItemTypeRoot|WiaItemTypeFolder|WiaItemTypeDevice;

    PropIndex++;

    // Intialize WIA_DPS_MAX_SCAN_TIME (NONE)
    pProperties->pszItemDefaults[PropIndex]                    = WIA_DPS_MAX_SCAN_TIME_STR;
    pProperties->piItemDefaults [PropIndex]                    = WIA_DPS_MAX_SCAN_TIME;
    pProperties->pvItemDefaults [PropIndex].lVal               = 10000;
    pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_DPS_PREVIEW (LIST)
    pProperties->pszItemDefaults[PropIndex]                    = WIA_DPS_PREVIEW_STR;
    pProperties->piItemDefaults [PropIndex]                    = WIA_DPS_PREVIEW;
    pProperties->pvItemDefaults [PropIndex].lVal               = WIA_FINAL_SCAN;
    pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_LIST;
    pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.List.pList= (BYTE*)pProperties->pSupportedPreviewModes;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.List.Nom  = pProperties->pvItemDefaults [PropIndex].lVal;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.List.cNumList = pProperties->NumSupportedPreviewModes;

    PropIndex++;

    // Initialize WIA_DPS_SHOW_PREVIEW_CONTROL (NONE)
    pProperties->pszItemDefaults[PropIndex]                    = WIA_DPS_SHOW_PREVIEW_CONTROL_STR;
    pProperties->piItemDefaults [PropIndex]                    = WIA_DPS_SHOW_PREVIEW_CONTROL;
    pProperties->pvItemDefaults [PropIndex].lVal               = WIA_SHOW_PREVIEW_CONTROL;
    pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;

    PropIndex++;

    if(m_ScanInfo.ADF == 1) {

        // Initialize WIA_DPS_HORIZONTAL_SHEET_FEED_SIZE
        pProperties->pszItemDefaults[PropIndex]              = WIA_DPS_HORIZONTAL_SHEET_FEED_SIZE_STR;
        pProperties->piItemDefaults [PropIndex]              = WIA_DPS_HORIZONTAL_SHEET_FEED_SIZE;
        pProperties->pvItemDefaults [PropIndex].lVal         = m_ScanInfo.BedWidth;
        pProperties->pvItemDefaults [PropIndex].vt           = VT_I4;
        pProperties->psItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
        pProperties->psItemDefaults [PropIndex].propid       = pProperties->piItemDefaults [PropIndex];
        pProperties->wpiItemDefaults[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
        pProperties->wpiItemDefaults[PropIndex].vt           = pProperties->pvItemDefaults [PropIndex].vt;

        PropIndex++;

        // Initialize WIA_DPS_VERTICAL_SHEET_FEED_SIZE
        pProperties->pszItemDefaults[PropIndex]              = WIA_DPS_VERTICAL_SHEET_FEED_SIZE_STR;
        pProperties->piItemDefaults [PropIndex]              = WIA_DPS_VERTICAL_SHEET_FEED_SIZE;
        pProperties->pvItemDefaults [PropIndex].lVal         = m_ScanInfo.BedHeight;
        pProperties->pvItemDefaults [PropIndex].vt           = VT_I4;
        pProperties->psItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
        pProperties->psItemDefaults [PropIndex].propid       = pProperties->piItemDefaults [PropIndex];
        pProperties->wpiItemDefaults[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
        pProperties->wpiItemDefaults[PropIndex].vt           = pProperties->pvItemDefaults [PropIndex].vt;

        PropIndex++;

        // Initialize WIA_DPS_DOCUMENT_HANDLING_CAPABILITIES
        pProperties->pszItemDefaults[PropIndex]              = WIA_DPS_DOCUMENT_HANDLING_CAPABILITIES_STR;
        pProperties->piItemDefaults [PropIndex]              = WIA_DPS_DOCUMENT_HANDLING_CAPABILITIES;
        pProperties->pvItemDefaults [PropIndex].lVal         = FLAT | FEED;
        pProperties->pvItemDefaults [PropIndex].vt           = VT_I4;
        pProperties->psItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
        pProperties->psItemDefaults [PropIndex].propid       = pProperties->piItemDefaults [PropIndex];
        pProperties->wpiItemDefaults[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_FLAG;
        pProperties->wpiItemDefaults[PropIndex].vt           = pProperties->pvItemDefaults [PropIndex].vt;

        PropIndex++;

        // Initialize WIA_DPS_DOCUMENT_HANDLING_STATUS
        pProperties->pszItemDefaults[PropIndex]              = WIA_DPS_DOCUMENT_HANDLING_STATUS_STR;
        pProperties->piItemDefaults [PropIndex]              = WIA_DPS_DOCUMENT_HANDLING_STATUS;
        pProperties->pvItemDefaults [PropIndex].lVal         = FLAT_READY;
        pProperties->pvItemDefaults [PropIndex].vt           = VT_I4;
        pProperties->psItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
        pProperties->psItemDefaults [PropIndex].propid       = pProperties->piItemDefaults [PropIndex];
        pProperties->wpiItemDefaults[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
        pProperties->wpiItemDefaults[PropIndex].vt           = pProperties->pvItemDefaults [PropIndex].vt;

        PropIndex++;

        // Initialize WIA_DPS_DOCUMENT_HANDLING_SELECT
        pProperties->pszItemDefaults[PropIndex]              = WIA_DPS_DOCUMENT_HANDLING_SELECT_STR;
        pProperties->piItemDefaults [PropIndex]              = WIA_DPS_DOCUMENT_HANDLING_SELECT;
        pProperties->pvItemDefaults [PropIndex].lVal         = FLATBED;
        pProperties->pvItemDefaults [PropIndex].vt           = VT_I4;
        pProperties->psItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
        pProperties->psItemDefaults [PropIndex].propid       = pProperties->piItemDefaults [PropIndex];
        pProperties->wpiItemDefaults[PropIndex].lAccessFlags = WIA_PROP_RW|WIA_PROP_FLAG;
        pProperties->wpiItemDefaults[PropIndex].vt           = pProperties->pvItemDefaults [PropIndex].vt;
        pProperties->wpiItemDefaults[PropIndex].ValidVal.Flag.Nom  = pProperties->pvItemDefaults [PropIndex].lVal;
        pProperties->wpiItemDefaults[PropIndex].ValidVal.Flag.ValidBits = FEEDER | FLATBED;

        PropIndex++;

        // Initialize WIA_DPS_PAGES
        pProperties->pszItemDefaults[PropIndex]              = WIA_DPS_PAGES_STR;
        pProperties->piItemDefaults [PropIndex]              = WIA_DPS_PAGES;
        pProperties->pvItemDefaults [PropIndex].lVal         = 1;
        pProperties->pvItemDefaults [PropIndex].vt           = VT_I4;
        pProperties->psItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
        pProperties->psItemDefaults [PropIndex].propid       = pProperties->piItemDefaults [PropIndex];
        pProperties->wpiItemDefaults[PropIndex].lAccessFlags = WIA_PROP_RW|WIA_PROP_RANGE;
        pProperties->wpiItemDefaults[PropIndex].vt           = pProperties->pvItemDefaults [PropIndex].vt;
        pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Inc = 1;
        pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Min = 0;
        pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Max = 25;
        pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Nom = 1;

        PropIndex++;

        // Initialize WIA_DPS_SHEET_FEEDER_REGISTRATION
        pProperties->pszItemDefaults[PropIndex]              = WIA_DPS_SHEET_FEEDER_REGISTRATION_STR;
        pProperties->piItemDefaults [PropIndex]              = WIA_DPS_SHEET_FEEDER_REGISTRATION;
        pProperties->pvItemDefaults [PropIndex].lVal         = LEFT_JUSTIFIED;
        pProperties->pvItemDefaults [PropIndex].vt           = VT_I4;
        pProperties->psItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
        pProperties->psItemDefaults [PropIndex].propid       = pProperties->piItemDefaults [PropIndex];
        pProperties->wpiItemDefaults[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
        pProperties->wpiItemDefaults[PropIndex].vt           = pProperties->pvItemDefaults [PropIndex].vt;

        PropIndex++;

        // Initialize WIA_DPS_HORIZONTAL_BED_REGISTRATION
        pProperties->pszItemDefaults[PropIndex]              = WIA_DPS_HORIZONTAL_BED_REGISTRATION_STR;
        pProperties->piItemDefaults [PropIndex]              = WIA_DPS_HORIZONTAL_BED_REGISTRATION;
        pProperties->pvItemDefaults [PropIndex].lVal         = LEFT_JUSTIFIED;
        pProperties->pvItemDefaults [PropIndex].vt           = VT_I4;
        pProperties->psItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
        pProperties->psItemDefaults [PropIndex].propid       = pProperties->piItemDefaults [PropIndex];
        pProperties->wpiItemDefaults[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
        pProperties->wpiItemDefaults[PropIndex].vt           = pProperties->pvItemDefaults [PropIndex].vt;

        PropIndex++;

        // Initialize WIA_DPS_VERTICAL_BED_REGISTRATION
        pProperties->pszItemDefaults[PropIndex]              = WIA_DPS_VERTICAL_BED_REGISTRATION_STR;
        pProperties->piItemDefaults [PropIndex]              = WIA_DPS_VERTICAL_BED_REGISTRATION;
        pProperties->pvItemDefaults [PropIndex].lVal         = TOP_JUSTIFIED;
        pProperties->pvItemDefaults [PropIndex].vt           = VT_I4;
        pProperties->psItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
        pProperties->psItemDefaults [PropIndex].propid       = pProperties->piItemDefaults [PropIndex];
        pProperties->wpiItemDefaults[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
        pProperties->wpiItemDefaults[PropIndex].vt           = pProperties->pvItemDefaults [PropIndex].vt;

        PropIndex++;

    }
    return hr;
}

HRESULT CMicroDriverAPI::DeleteAllProperties(PWIAPROPERTIES pProperties)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::DeleteAllProperties");

    if(pProperties->pszItemDefaults){
        delete [] pProperties->pszItemDefaults;
        pProperties->pszItemDefaults = NULL;
    }

    if(pProperties->piItemDefaults){
        delete [] pProperties->piItemDefaults;
        pProperties->piItemDefaults = NULL;
    }

    if(pProperties->pvItemDefaults){
        delete [] pProperties->pvItemDefaults;
        pProperties->pvItemDefaults = NULL;
    }

    if(pProperties->psItemDefaults){
        delete [] pProperties->psItemDefaults;
        pProperties->psItemDefaults = NULL;
    }

    if(pProperties->wpiItemDefaults){
        delete [] pProperties->wpiItemDefaults;
        pProperties->wpiItemDefaults = NULL;
    }

    return S_OK;
}

HRESULT CMicroDriverAPI::AllocateAllProperties(PWIAPROPERTIES pProperties)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::AllocateAllProperties");

    HRESULT hr = S_OK;

    pProperties->pszItemDefaults   = new LPOLESTR[pProperties->NumItemProperties];
    if(NULL != pProperties->pszItemDefaults){
        pProperties->piItemDefaults    = new PROPID[pProperties->NumItemProperties];
        if (NULL != pProperties->piItemDefaults) {
            pProperties->pvItemDefaults    = new PROPVARIANT[pProperties->NumItemProperties];
            if(NULL != pProperties->pvItemDefaults){
                pProperties->psItemDefaults    = new PROPSPEC[pProperties->NumItemProperties];
                if(NULL != pProperties->psItemDefaults){
                    pProperties->wpiItemDefaults   = new WIA_PROPERTY_INFO[pProperties->NumItemProperties];
                    if(NULL == pProperties->wpiItemDefaults)
                        hr = E_OUTOFMEMORY;
                } else
                    hr = E_OUTOFMEMORY;
            } else
                hr = E_OUTOFMEMORY;
        } else
            hr = E_OUTOFMEMORY;
    } else
        hr = E_OUTOFMEMORY;

    return hr;
}

HRESULT CMicroDriverAPI::BuildTopItemProperties(PWIAPROPERTIES pProperties)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::BuildTopItemProperties");

    HRESULT hr = S_OK;
    VAL Value;
    memset(&Value,0,sizeof(Value));
    Value.pScanInfo = &m_ScanInfo;

    hr = m_pMicroDriver->MicroEntry(CMD_RESETSCANNER,&Value);
    if(FAILED(hr)){
        return hr;
    }

    //
    // set the number of properties
    //

    pProperties->NumItemProperties = 29;

    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("CMicroDriverAPI::BuildTopItemProperties, Number of Properties = %d",pProperties->NumItemProperties));

    hr = AllocateAllProperties(pProperties);
    if(FAILED(hr)){
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CMicroDriverAPI::BuildTopItemProperties, AllocateAllProperties failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        DeleteAllProperties(pProperties);
        return hr;
    }

    //
    // Get Data type restrictions (backup original data types)
    // Memory used for the original set will be reused to write back
    // the new valid values.
    //

    if(pProperties->bLegacyBWRestrictions){
        //
        // The NoColor=1 registry key was set to restrict this driver from supporting
        // color... remove the valid bits, just incase the bits were set..
        // This will automatically restrict our Data type array to report
        // the correct valid values.
        m_ScanInfo.SupportedDataTypes &= ~SUPPORT_COLOR;
    }

    LONG lSupportedDataTypesArray[3];   // 3 is the maximum data type set allowed
    LONG lNumSupportedDataTypes = 0;
    memcpy(lSupportedDataTypesArray,pProperties->pSupportedDataTypes,(sizeof(lSupportedDataTypesArray)));

    //
    // Set New Data type restrictions
    //

    if (m_ScanInfo.SupportedDataTypes != 0) {
        // check for 24-bit color support
        if (m_ScanInfo.SupportedDataTypes & SUPPORT_COLOR) {
            pProperties->pSupportedDataTypes[lNumSupportedDataTypes] = WIA_DATA_COLOR;
            lNumSupportedDataTypes++;
        }
        // check for 1-bit BW support
        if (m_ScanInfo.SupportedDataTypes & SUPPORT_BW) {
            pProperties->pSupportedDataTypes[lNumSupportedDataTypes] = WIA_DATA_THRESHOLD;
            lNumSupportedDataTypes++;
        }
        // check for 8-bit grayscale support
        if (m_ScanInfo.SupportedDataTypes & SUPPORT_GRAYSCALE) {
            pProperties->pSupportedDataTypes[lNumSupportedDataTypes] = WIA_DATA_GRAYSCALE;
            lNumSupportedDataTypes++;
        }

        // set new supported data type count
        pProperties->NumSupportedDataTypes = lNumSupportedDataTypes;
    }

    LONG PropIndex = 0;

    PLONG pResolutions = NULL;
    LONG lNumItems = 0;
    RANGEVALUEEX RangeValues;
    if(IsValidRestriction(&pResolutions, &lNumItems, &RangeValues)) {
        if(lNumItems > 0){
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("BuildTopItemProperties, Using .INF provided Resolutions (LIST)"));
            // we have a list
            if(pProperties->pSupportedResolutions){
                //delete [] pProperties->pSupportedResolutions;
                pProperties->pSupportedResolutions = NULL;
                pProperties->pSupportedResolutions = pResolutions;
                pProperties->NumSupportedResolutions = lNumItems;
            }

            // Intialize WIA_IPS_XRES (LIST)
            pProperties->pszItemDefaults[PropIndex]                    = WIA_IPS_XRES_STR;
            pProperties->piItemDefaults [PropIndex]                    = WIA_IPS_XRES;
            pProperties->pvItemDefaults [PropIndex].lVal               = pProperties->pSupportedResolutions[PropIndex];
            pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
            pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
            pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
            pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_LIST;
            pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;
            pProperties->wpiItemDefaults[PropIndex].ValidVal.List.pList= (BYTE*)pProperties->pSupportedResolutions;
            pProperties->wpiItemDefaults[PropIndex].ValidVal.List.Nom  = pProperties->pvItemDefaults [PropIndex].lVal;
            pProperties->wpiItemDefaults[PropIndex].ValidVal.List.cNumList = pProperties->NumSupportedResolutions;

            PropIndex++;

            // Intialize WIA_IPS_YRES (LIST)
            pProperties->pszItemDefaults[PropIndex]                    = WIA_IPS_YRES_STR;
            pProperties->piItemDefaults [PropIndex]                    = WIA_IPS_YRES;
            pProperties->pvItemDefaults [PropIndex].lVal               = pProperties->pSupportedResolutions[PropIndex-1];
            pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
            pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
            pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
            pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_LIST;
            pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;
            pProperties->wpiItemDefaults[PropIndex].ValidVal.List.pList= (BYTE*)pProperties->pSupportedResolutions;
            pProperties->wpiItemDefaults[PropIndex].ValidVal.List.Nom  = pProperties->pvItemDefaults [PropIndex].lVal;
            pProperties->wpiItemDefaults[PropIndex].ValidVal.List.cNumList = pProperties->NumSupportedResolutions;

            PropIndex++;

        } else {
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("BuildTopItemProperties, Using .INF provided Resolutions (RANGE)"));
            // we have a range
            // Intialize WIA_IPS_XRES (RANGE)
            pProperties->pszItemDefaults[PropIndex]                    = WIA_IPS_XRES_STR;
            pProperties->piItemDefaults [PropIndex]                    = WIA_IPS_XRES;
            pProperties->pvItemDefaults [PropIndex].lVal               = RangeValues.lNom;
            pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
            pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
            pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
            pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
            pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;
            pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Inc = RangeValues.lStep;
            pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Min = RangeValues.lMin;
            pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Max = RangeValues.lMax;
            pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Nom = RangeValues.lNom;

            PropIndex++;

            // Intialize WIA_IPS_YRES (RANGE)
            pProperties->pszItemDefaults[PropIndex]                    = WIA_IPS_YRES_STR;
            pProperties->piItemDefaults [PropIndex]                    = WIA_IPS_YRES;
            pProperties->pvItemDefaults [PropIndex].lVal               = RangeValues.lNom;
            pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
            pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
            pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
            pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
            pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;
            pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Inc = RangeValues.lStep;
            pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Min = RangeValues.lMin;
            pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Max = RangeValues.lMax;
            pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Nom = RangeValues.lNom;

            PropIndex++;
        }
    } else {
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("BuildTopItemProperties, Using HOST Provided Resolution Restrictions"));
#ifdef USE_RANGE_VALUES

        // Intialize WIA_IPS_XRES (RANGE)
        pProperties->pszItemDefaults[PropIndex]                    = WIA_IPS_XRES_STR;
        pProperties->piItemDefaults [PropIndex]                    = WIA_IPS_XRES;
        pProperties->pvItemDefaults [PropIndex].lVal               = INITIAL_XRESOLUTION;
        pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
        pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
        pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
        pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
        pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;
        pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Inc = 1;
        pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Min = 12;
        pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Max = 1200;
        pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Nom = pProperties->pvItemDefaults [PropIndex].lVal;

        PropIndex++;

        // Intialize WIA_IPS_YRES (RANGE)
        pProperties->pszItemDefaults[PropIndex]                    = WIA_IPS_YRES_STR;
        pProperties->piItemDefaults [PropIndex]                    = WIA_IPS_YRES;
        pProperties->pvItemDefaults [PropIndex].lVal               = INITIAL_YRESOLUTION;
        pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
        pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
        pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
        pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
        pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;
        pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Inc = 1;
        pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Min = 12;
        pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Max = 1200;
        pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Nom = pProperties->pvItemDefaults [PropIndex].lVal;

        PropIndex++;

#else   // USE_RANGE_VALUES (different property sets for different drivers)

        // Intialize WIA_IPS_XRES (LIST)
        pProperties->pszItemDefaults[PropIndex]                    = WIA_IPS_XRES_STR;
        pProperties->piItemDefaults [PropIndex]                    = WIA_IPS_XRES;
        pProperties->pvItemDefaults [PropIndex].lVal               = INITIAL_XRESOLUTION;
        pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
        pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
        pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
        pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_LIST;
        pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;
        pProperties->wpiItemDefaults[PropIndex].ValidVal.List.pList= (BYTE*)pProperties->pSupportedResolutions;
        pProperties->wpiItemDefaults[PropIndex].ValidVal.List.Nom  = pProperties->pvItemDefaults [PropIndex].lVal;
        pProperties->wpiItemDefaults[PropIndex].ValidVal.List.cNumList = pProperties->NumSupportedResolutions;

        PropIndex++;

        // Intialize WIA_IPS_YRES (LIST)
        pProperties->pszItemDefaults[PropIndex]                    = WIA_IPS_YRES_STR;
        pProperties->piItemDefaults [PropIndex]                    = WIA_IPS_YRES;
        pProperties->pvItemDefaults [PropIndex].lVal               = INITIAL_YRESOLUTION;
        pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
        pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
        pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
        pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_LIST;
        pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;
        pProperties->wpiItemDefaults[PropIndex].ValidVal.List.pList= (BYTE*)pProperties->pSupportedResolutions;
        pProperties->wpiItemDefaults[PropIndex].ValidVal.List.Nom  = pProperties->pvItemDefaults [PropIndex].lVal;
        pProperties->wpiItemDefaults[PropIndex].ValidVal.List.cNumList = pProperties->NumSupportedResolutions;

        PropIndex++;

#endif

    }

    // Intialize WIA_IPS_XEXTENT (RANGE)
    pProperties->pszItemDefaults[PropIndex]                    = WIA_IPS_XEXTENT_STR;
    pProperties->piItemDefaults [PropIndex]                    = WIA_IPS_XEXTENT;
    pProperties->pvItemDefaults [PropIndex].lVal               = (pProperties->pvItemDefaults [PropIndex-2].lVal * m_ScanInfo.BedWidth)/1000;
    pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
    pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Inc = 1;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Min = 1;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Max = pProperties->pvItemDefaults [PropIndex].lVal;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Nom = pProperties->pvItemDefaults [PropIndex].lVal;

    PropIndex++;

    // Intialize WIA_IPS_YEXTENT (RANGE)
    pProperties->pszItemDefaults[PropIndex]                    = WIA_IPS_YEXTENT_STR;
    pProperties->piItemDefaults [PropIndex]                    = WIA_IPS_YEXTENT;
    pProperties->pvItemDefaults [PropIndex].lVal               = (pProperties->pvItemDefaults [PropIndex-2].lVal * m_ScanInfo.BedHeight)/1000;;
    pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
    pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Inc = 1;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Min = 1;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Max = pProperties->pvItemDefaults [PropIndex].lVal;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Nom = pProperties->pvItemDefaults [PropIndex].lVal;

    PropIndex++;

    // Intialize WIA_IPS_XPOS (RANGE)
    pProperties->pszItemDefaults[PropIndex]                    = WIA_IPS_XPOS_STR;
    pProperties->piItemDefaults [PropIndex]                    = WIA_IPS_XPOS;
    pProperties->pvItemDefaults [PropIndex].lVal               = 0;
    pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
    pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Inc = 1;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Min = 0;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Max = (pProperties->wpiItemDefaults[PropIndex-2].ValidVal.Range.Max - 1);
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Nom = pProperties->pvItemDefaults [PropIndex].lVal;

    PropIndex++;

    // Intialize WIA_IPS_YPOS (RANGE)
    pProperties->pszItemDefaults[PropIndex]                    = WIA_IPS_YPOS_STR;
    pProperties->piItemDefaults [PropIndex]                    = WIA_IPS_YPOS;
    pProperties->pvItemDefaults [PropIndex].lVal               = 0;
    pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
    pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Inc = 1;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Min = 0;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Max = (pProperties->wpiItemDefaults[PropIndex-2].ValidVal.Range.Max - 1);
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Nom = pProperties->pvItemDefaults [PropIndex].lVal;

    PropIndex++;

    // Intialize WIA_IPA_DATATYPE (LIST)
    pProperties->pszItemDefaults[PropIndex]                    = WIA_IPA_DATATYPE_STR;
    pProperties->piItemDefaults [PropIndex]                    = WIA_IPA_DATATYPE;
    pProperties->pvItemDefaults [PropIndex].lVal               = m_ScanInfo.DataType;
    pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_LIST;
    pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;

    pProperties->wpiItemDefaults[PropIndex].ValidVal.List.pList    = (BYTE*)pProperties->pSupportedDataTypes;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.List.Nom      = pProperties->pvItemDefaults [PropIndex].lVal;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.List.cNumList = pProperties->NumSupportedDataTypes;

    PropIndex++;

    // Intialize WIA_IPA_DEPTH (NONE)
    pProperties->pszItemDefaults[PropIndex]                    = WIA_IPA_DEPTH_STR;
    pProperties->piItemDefaults [PropIndex]                    = WIA_IPA_DEPTH;
    pProperties->pvItemDefaults [PropIndex].lVal               = m_ScanInfo.PixelBits;
    pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPS_BRIGHTNESS (RANGE)
    pProperties->pszItemDefaults[PropIndex]                    = WIA_IPS_BRIGHTNESS_STR;
    pProperties->piItemDefaults [PropIndex]                    = WIA_IPS_BRIGHTNESS;
    pProperties->pvItemDefaults [PropIndex].lVal               = m_ScanInfo.Intensity;//INITIAL_BRIGHTNESS;
    pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
    pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Inc = m_ScanInfo.IntensityRange.lStep; //   1
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Min = m_ScanInfo.IntensityRange.lMin;  //-127;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Max = m_ScanInfo.IntensityRange.lMax;  // 128;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Nom = pProperties->pvItemDefaults [PropIndex].lVal;

    PropIndex++;

    // Intialize WIA_IPS_CONTRAST (RANGE)
    pProperties->pszItemDefaults[PropIndex]                    = WIA_IPS_CONTRAST_STR;
    pProperties->piItemDefaults [PropIndex]                    = WIA_IPS_CONTRAST;
    pProperties->pvItemDefaults [PropIndex].lVal               = m_ScanInfo.Contrast;//INITIAL_CONTRAST;
    pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
    pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Inc = m_ScanInfo.ContrastRange.lStep; //   1
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Min = m_ScanInfo.ContrastRange.lMin;  //-127;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Max = m_ScanInfo.ContrastRange.lMax;  // 128;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Nom = pProperties->pvItemDefaults [PropIndex].lVal;

    PropIndex++;

    // Intialize WIA_IPS_CUR_INTENT (FLAG)
    pProperties->pszItemDefaults[PropIndex]                    = WIA_IPS_CUR_INTENT_STR;
    pProperties->piItemDefaults [PropIndex]                    = WIA_IPS_CUR_INTENT;
    pProperties->pvItemDefaults [PropIndex].lVal               = WIA_INTENT_NONE;
    pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_FLAG;
    pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Flag.Nom  = pProperties->pvItemDefaults [PropIndex].lVal;

    pProperties->wpiItemDefaults[PropIndex].ValidVal.Flag.ValidBits = WIA_INTENT_MINIMIZE_SIZE | WIA_INTENT_MAXIMIZE_QUALITY;

    // check for 24-bit color support
    if (m_ScanInfo.SupportedDataTypes & SUPPORT_COLOR) {
        pProperties->wpiItemDefaults[PropIndex].ValidVal.Flag.ValidBits |= WIA_INTENT_IMAGE_TYPE_COLOR;
    }

    // check for 1-bit BW support
    if (m_ScanInfo.SupportedDataTypes & SUPPORT_BW) {
        pProperties->wpiItemDefaults[PropIndex].ValidVal.Flag.ValidBits |= WIA_INTENT_IMAGE_TYPE_TEXT;
    }

    // check for 8-bit grayscale support
    if (m_ScanInfo.SupportedDataTypes & SUPPORT_GRAYSCALE) {
        pProperties->wpiItemDefaults[PropIndex].ValidVal.Flag.ValidBits |= WIA_INTENT_IMAGE_TYPE_GRAYSCALE;
    }

    if(pProperties->bLegacyBWRestrictions){
        //
        // The NoColor=1 registry key was set to restrict this driver from supporting
        // color... remove the valid bits, just incase the bits were set..
        // note: NoColor overrides all driver settings
        //
        pProperties->wpiItemDefaults[PropIndex].ValidVal.Flag.ValidBits &= ~ WIA_INTENT_IMAGE_TYPE_COLOR;
    }

    //////////////////////////////////////////////////////////////////////////////////////////////////
    // The full valid bits for intent for information only                                          //
    //////////////////////////////////////////////////////////////////////////////////////////////////
    //
    // pProperties->wpiItemDefaults[PropIndex].ValidVal.Flag.ValidBits = WIA_INTENT_IMAGE_TYPE_COLOR |
    //                                                                   WIA_INTENT_IMAGE_TYPE_GRAYSCALE |
    //                                                                   WIA_INTENT_IMAGE_TYPE_TEXT  |
    //                                                                   WIA_INTENT_MINIMIZE_SIZE |
    //                                                                   WIA_INTENT_MAXIMIZE_QUALITY;
    //////////////////////////////////////////////////////////////////////////////////////////////////

    PropIndex++;

    // Intialize WIA_IPA_PIXELS_PER_LINE (NONE)
    pProperties->pszItemDefaults[PropIndex]                    = WIA_IPA_PIXELS_PER_LINE_STR;
    pProperties->piItemDefaults [PropIndex]                    = WIA_IPA_PIXELS_PER_LINE;
    pProperties->pvItemDefaults [PropIndex].lVal               = pProperties->pvItemDefaults [PropIndex-9].lVal;
    pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPA_NUMER_OF_LINES (NONE)
    pProperties->pszItemDefaults[PropIndex]                    = WIA_IPA_NUMBER_OF_LINES_STR;
    pProperties->piItemDefaults [PropIndex]                    = WIA_IPA_NUMBER_OF_LINES;
    pProperties->pvItemDefaults [PropIndex].lVal               = pProperties->pvItemDefaults [PropIndex-9].lVal;
    pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_DPS_MAX_SCAN_TIME (NONE)
    pProperties->pszItemDefaults[PropIndex]                    = WIA_DPS_MAX_SCAN_TIME_STR;
    pProperties->piItemDefaults [PropIndex]                    = WIA_DPS_MAX_SCAN_TIME;
    pProperties->pvItemDefaults [PropIndex].lVal               = 10000;
    pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPA_PREFERRED_FORMAT (NONE)
    pProperties->pszItemDefaults[PropIndex]                    = WIA_IPA_PREFERRED_FORMAT_STR;
    pProperties->piItemDefaults [PropIndex]                    = WIA_IPA_PREFERRED_FORMAT;
    pProperties->pvItemDefaults [PropIndex].puuid              = &pProperties->pInitialFormats[0];;
    pProperties->pvItemDefaults [PropIndex].vt                 = VT_CLSID;
    pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPA_ITEM_SIZE (NONE)
    pProperties->pszItemDefaults[PropIndex]                    = WIA_IPA_ITEM_SIZE_STR;
    pProperties->piItemDefaults [PropIndex]                    = WIA_IPA_ITEM_SIZE;
    pProperties->pvItemDefaults [PropIndex].lVal               = 0;
    pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPS_THRESHOLD (RANGE)
    pProperties->pszItemDefaults[PropIndex]                    = WIA_IPS_THRESHOLD_STR;
    pProperties->piItemDefaults [PropIndex]                    = WIA_IPS_THRESHOLD;
    pProperties->pvItemDefaults [PropIndex].lVal               = 0;
    pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
    pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Inc = 1;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Min = -127;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Max = 128;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Range.Nom = pProperties->pvItemDefaults [PropIndex].lVal;

    PropIndex++;

    // Intialize WIA_IPA_FORMAT (LIST)
    pProperties->pszItemDefaults[PropIndex]                    = WIA_IPA_FORMAT_STR;
    pProperties->piItemDefaults [PropIndex]                    = WIA_IPA_FORMAT;
    pProperties->pvItemDefaults [PropIndex].puuid              = &pProperties->pInitialFormats[0];
    pProperties->pvItemDefaults [PropIndex].vt                 = VT_CLSID;
    pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_LIST;
    pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;

    pProperties->wpiItemDefaults[PropIndex].ValidVal.ListGuid.pList    = pProperties->pInitialFormats;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.ListGuid.Nom      = *pProperties->pvItemDefaults [PropIndex].puuid;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.ListGuid.cNumList = pProperties->NumInitialFormats;

    PropIndex++;

    // Intialize WIA_IPA_TYMED (LIST)
    pProperties->pszItemDefaults[PropIndex]                    = WIA_IPA_TYMED_STR;
    pProperties->piItemDefaults [PropIndex]                    = WIA_IPA_TYMED;
    pProperties->pvItemDefaults [PropIndex].lVal               = INITIAL_TYMED;
    pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_LIST;
    pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;

    pProperties->wpiItemDefaults[PropIndex].ValidVal.List.pList    = (BYTE*)pProperties->pSupportedTYMED;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.List.Nom      = pProperties->pvItemDefaults [PropIndex].lVal;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.List.cNumList = pProperties->NumSupportedTYMED;

    PropIndex++;

    // Intialize WIA_IPA_CHANNELS_PER_PIXEL (NONE)
    pProperties->pszItemDefaults[PropIndex]                    = WIA_IPA_CHANNELS_PER_PIXEL_STR;
    pProperties->piItemDefaults [PropIndex]                    = WIA_IPA_CHANNELS_PER_PIXEL;
    pProperties->pvItemDefaults [PropIndex].lVal               = INITIAL_CHANNELS_PER_PIXEL;
    pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPA_BITS_PER_CHANNEL (NONE)
    pProperties->pszItemDefaults[PropIndex]                    = WIA_IPA_BITS_PER_CHANNEL_STR;
    pProperties->piItemDefaults [PropIndex]                    = WIA_IPA_BITS_PER_CHANNEL;
    pProperties->pvItemDefaults [PropIndex].lVal               = INITIAL_BITS_PER_CHANNEL;
    pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPA_PLANAR (NONE)
    pProperties->pszItemDefaults[PropIndex]                    = WIA_IPA_PLANAR_STR;
    pProperties->piItemDefaults [PropIndex]                    = WIA_IPA_PLANAR;
    pProperties->pvItemDefaults [PropIndex].lVal               = INITIAL_PLANAR;
    pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPA_BYTES_PER_LINE (NONE)
    pProperties->pszItemDefaults[PropIndex]                    = WIA_IPA_BYTES_PER_LINE_STR;
    pProperties->piItemDefaults [PropIndex]                    = WIA_IPA_BYTES_PER_LINE;
    pProperties->pvItemDefaults [PropIndex].lVal               = 0;
    pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPA_MIN_BUFFER_SIZE (NONE)
    pProperties->pszItemDefaults[PropIndex]                    = WIA_IPA_MIN_BUFFER_SIZE_STR;
    pProperties->piItemDefaults [PropIndex]                    = WIA_IPA_MIN_BUFFER_SIZE;
    pProperties->pvItemDefaults [PropIndex].lVal               = MIN_BUFFER_SIZE;
    pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPA_ACCESS_RIGHTS (NONE)
    pProperties->pszItemDefaults[PropIndex]                    = WIA_IPA_ACCESS_RIGHTS_STR;
    pProperties->piItemDefaults [PropIndex]                    = WIA_IPA_ACCESS_RIGHTS;
    pProperties->pvItemDefaults [PropIndex].lVal               = WIA_ITEM_READ|WIA_ITEM_WRITE;
    pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPA_COMPRESSION (LIST)
    pProperties->pszItemDefaults[PropIndex]                    = WIA_IPA_COMPRESSION_STR;
    pProperties->piItemDefaults [PropIndex]                    = WIA_IPA_COMPRESSION;
    pProperties->pvItemDefaults [PropIndex].lVal               = INITIAL_COMPRESSION;
    pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_LIST;
    pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;

    pProperties->wpiItemDefaults[PropIndex].ValidVal.List.pList    = (BYTE*)pProperties->pSupportedCompressionTypes;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.List.Nom      = pProperties->pvItemDefaults [PropIndex].lVal;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.List.cNumList = pProperties->NumSupportedCompressionTypes;

    PropIndex++;

    // Initialize WIA_IPA_ITEM_FLAGS
    pProperties->pszItemDefaults[PropIndex]              = WIA_IPA_ITEM_FLAGS_STR;
    pProperties->piItemDefaults [PropIndex]              = WIA_IPA_ITEM_FLAGS;
    pProperties->pvItemDefaults [PropIndex].lVal         = WiaItemTypeImage|WiaItemTypeFile|WiaItemTypeDevice;
    pProperties->pvItemDefaults [PropIndex].vt           = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid       = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_FLAG;
    pProperties->wpiItemDefaults[PropIndex].vt           = pProperties->pvItemDefaults [PropIndex].vt;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Flag.Nom  = pProperties->pvItemDefaults [PropIndex].lVal;
    pProperties->wpiItemDefaults[PropIndex].ValidVal.Flag.ValidBits = WiaItemTypeImage|WiaItemTypeFile|WiaItemTypeDevice;

    PropIndex++;

    // Initialize WIA_IPS_PHOTOMETRIC_INTERP
    pProperties->pszItemDefaults[PropIndex]              = WIA_IPS_PHOTOMETRIC_INTERP_STR;
    pProperties->piItemDefaults [PropIndex]              = WIA_IPS_PHOTOMETRIC_INTERP;
    pProperties->pvItemDefaults [PropIndex].lVal         = INITIAL_PHOTOMETRIC_INTERP;
    pProperties->pvItemDefaults [PropIndex].vt           = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid       = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[PropIndex].vt           = pProperties->pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPS_WARM_UP_TIME_STR (NONE)
    pProperties->pszItemDefaults[PropIndex]                    = WIA_IPS_WARM_UP_TIME_STR;
    pProperties->piItemDefaults [PropIndex]                    = WIA_IPS_WARM_UP_TIME;
    pProperties->pvItemDefaults [PropIndex].lVal               = 10000;
    pProperties->pvItemDefaults [PropIndex].vt                 = VT_I4;
    pProperties->psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [PropIndex].propid             = pProperties->piItemDefaults [PropIndex];
    pProperties->wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[PropIndex].vt                 = pProperties->pvItemDefaults [PropIndex].vt;

    PropIndex++;

    return hr;
}

HRESULT CMicroDriverAPI::SetResolutionRestrictionString(TCHAR *szResolutions)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CMicroDriverAPI::SetResolutionRestrictionString");
    //
    // SBB - RAID 370299 - orenr - 2001/04/18 - Security fix -
    // potential buffer overrun.  Changed lstrcpy to use
    // _tcsncpy instead.
    //
    ZeroMemory(m_szResolutions, sizeof(m_szResolutions));
    _tcsncpy(m_szResolutions,
             szResolutions,
             (sizeof(m_szResolutions) / sizeof(TCHAR)) - 1);

#ifdef UNICODE
    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("CMicroDriverAPI::SetResolutionRestrictionString, szResolutions = %ws",szResolutions));
#else
    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("CMicroDriverAPI::SetResolutionRestrictionString, szResolutions = %s",szResolutions));
#endif
    return S_OK;
}

HRESULT CMicroDriverAPI::SetScanMode(INT iScanMode)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "SetScanMode");

    HRESULT hr = S_OK;
    VAL Value;
    memset(&Value,0,sizeof(Value));
    Value.pScanInfo = &m_ScanInfo;
    Value.lVal = iScanMode;

    hr = m_pMicroDriver->MicroEntry(CMD_SETSCANMODE,&Value);
    if(FAILED(hr)){
        if(E_NOTIMPL == hr){
            hr = S_OK;
        }
        return hr;
    }
    return hr;
}

HRESULT CMicroDriverAPI::SetSTIDeviceHKEY(HKEY *pHKEY)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "SetSTIDeviceHKEY");

    HRESULT hr = S_OK;
    VAL Value;
    memset(&Value,0,sizeof(Value));
    Value.pScanInfo = &m_ScanInfo;
    Value.pHandle = (HANDLE*)pHKEY;

    hr = m_pMicroDriver->MicroEntry(CMD_SETSTIDEVICEHKEY,&Value);
    if(FAILED(hr)){
        if(E_NOTIMPL == hr){
            hr = S_OK;
        }
        return hr;
    }
    return hr;
}

HRESULT CMicroDriverAPI::GetSupportedFileFormats(GUID **ppguid, LONG *plNumSupportedFormats)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "GetSupportedFileFormats");

    HRESULT hr = S_OK;
    *plNumSupportedFormats = 0;
    *ppguid = NULL;
    VAL Value;
    memset(&Value,0,sizeof(Value));
    Value.pScanInfo = &m_ScanInfo;

    hr = m_pMicroDriver->MicroEntry(CMD_GETSUPPORTEDFILEFORMATS,&Value);
    if(FAILED(hr)){
        return hr;
    }

    *plNumSupportedFormats = Value.lVal;
    *ppguid = Value.pGuid;

    return hr;
}

HRESULT CMicroDriverAPI::GetSupportedMemoryFormats(GUID **ppguid, LONG *plNumSupportedFormats)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "GetSupportedMemoryFormats");

    HRESULT hr = S_OK;
    *plNumSupportedFormats = 0;
    *ppguid = NULL;
    VAL Value;
    memset(&Value,0,sizeof(Value));
    Value.pScanInfo = &m_ScanInfo;

    hr = m_pMicroDriver->MicroEntry(CMD_GETSUPPORTEDMEMORYFORMATS,&Value);
    if(FAILED(hr)){
        return hr;
    }

    *plNumSupportedFormats = Value.lVal;
    *ppguid = Value.pGuid;

    return hr;
}

HRESULT CMicroDriverAPI::IsColorDataBGR(BOOL *pbBGR)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "IsColorDataBGR");

    HRESULT hr = S_OK;
    // WIA_ORDER_RGB 0
    // WIA_ORDER_BGR 1
    *pbBGR = (m_ScanInfo.RawPixelOrder == WIA_ORDER_BGR);
    return hr;
}

HRESULT CMicroDriverAPI::IsAlignmentNeeded(BOOL *pbALIGN)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                         WIALOG_NO_RESOURCE_ID,
                         WIALOG_LEVEL1,
                         "IsAlignmentNeeded");
    HRESULT hr = S_OK;
    *pbALIGN = m_ScanInfo.bNeedDataAlignment;
    return hr;
}

////////////////////////////////////////////////////////////////////////////////
// SCRIPT DRIVER SYSTEM SUPPORT                                                //
////////////////////////////////////////////////////////////////////////////////
CScriptDriverAPI::CScriptDriverAPI()
{

}

CScriptDriverAPI::~CScriptDriverAPI()
{

}

HRESULT CScriptDriverAPI::Scan(LONG lState, PBYTE pData, DWORD dwBytesToRead, PDWORD pdwBytesWritten)
{
    HRESULT hr = S_OK;
    LONG lLine = SCAN_FIRST;

    switch (lState) {
    case SCAN_START:
        lLine = SCAN_FIRST;
        break;
    case SCAN_CONTINUE:
        lLine = SCAN_NEXT;
        break;
    case SCAN_END:
        lLine = SCAN_FINISHED;
    default:
        break;
    }

    hr = m_pIOBlock->Scan(lLine,pData,dwBytesToRead,(LONG*)pdwBytesWritten);
    return hr;
}

HRESULT CScriptDriverAPI::SetDataType(LONG lDataType)
{
    HRESULT hr = S_OK;
    if (m_pIOBlock->m_ScannerSettings.bNegative) {
        hr = m_pIOBlock->WriteValue(NEGATIVE_ID,1);
        // save hr???
    }

    hr = m_pIOBlock->WriteValue(DATA_TYPE_ID,lDataType);
    return hr;
}

HRESULT CScriptDriverAPI::SetXYResolution(LONG lXResolution, LONG lYResolution)
{
    HRESULT hr = S_OK;
    hr = m_pIOBlock->WriteValue(XRESOLUTION_ID,lXResolution);
    if (SUCCEEDED(hr)) {
        m_pIOBlock->m_ScannerSettings.CurrentXResolution = lXResolution;

        hr = m_pIOBlock->WriteValue(YRESOLUTION_ID,lYResolution);
        if (SUCCEEDED(hr)) {
            m_pIOBlock->m_ScannerSettings.CurrentYResolution = lYResolution;
        }
    }
    return hr;
}

HRESULT CScriptDriverAPI::SetSelectionArea(LONG lXPos, LONG lYPos, LONG lXExt, LONG lYExt)
{
    HRESULT hr = S_OK;
    hr = m_pIOBlock->WriteValue(XPOS_ID, lXPos);
    if (SUCCEEDED(hr)) {
        m_pIOBlock->m_ScannerSettings.CurrentXPos = lXPos;
        hr = m_pIOBlock->WriteValue(YPOS_ID, lYPos);
        if (SUCCEEDED(hr)) {
            m_pIOBlock->m_ScannerSettings.CurrentYPos = lYPos;
            hr = m_pIOBlock->WriteValue(XEXT_ID, lXExt);
            if (SUCCEEDED(hr)) {
                m_pIOBlock->m_ScannerSettings.CurrentXExtent = lXExt;
                hr = m_pIOBlock->WriteValue(YEXT_ID, lYExt);
                if (SUCCEEDED(hr)) {
                    m_pIOBlock->m_ScannerSettings.CurrentYExtent = lYExt;
                }
            }
        }
    }
    return hr;
}

HRESULT CScriptDriverAPI::SetContrast(LONG lContrast)
{
    HRESULT hr = S_OK;
    hr = m_pIOBlock->WriteValue(CONTRAST_ID, lContrast);
    return hr;
}

HRESULT CScriptDriverAPI::SetIntensity(LONG lIntensity)
{
    HRESULT hr = S_OK;
    hr = m_pIOBlock->WriteValue(BRIGHTNESS_ID, lIntensity);
    return hr;
}

HRESULT CScriptDriverAPI::ResetDevice()
{
    HRESULT hr = S_OK;
    return hr;
}

HRESULT CScriptDriverAPI::SetEmulationMode(LONG lDeviceMode)
{
    HRESULT hr = S_OK;
    return hr;
}

HRESULT CScriptDriverAPI::DisableDevice()
{
    HRESULT hr = S_OK;
    return hr;
}

HRESULT CScriptDriverAPI::EnableDevice()
{
    HRESULT hr = S_OK;
    return hr;
}

HRESULT CScriptDriverAPI::DeviceOnline()
{
    HRESULT hr = S_OK;
    return hr;
}

HRESULT CScriptDriverAPI::GetDeviceEvent(GUID *pEvent)
{
    HRESULT hr = S_OK;
    *pEvent = GUID_NULL;
    return hr;
}

HRESULT CScriptDriverAPI::Diagnostic()
{
    HRESULT hr = S_OK;
    return hr;
}

HRESULT CScriptDriverAPI::Initialize(PINITINFO pInitInfo)
{
    HRESULT hr = S_OK;

    m_pIOBlock = new CIOBlock;
    if (NULL != m_pIOBlock) {

        GSD_INFO GSDInfo;
        memset(&GSDInfo,0,sizeof(GSD_INFO));
        lstrcpy(GSDInfo.szFamilyFileName,pInitInfo->szModuleFileName);

        // GSDInfo.szDeviceName;
        // GSDInfo.szFamilyFileName;
        // GSDInfo.szProductFileName;


        pInitInfo->szCreateFileName;

        m_pIOBlock->Initialize(&GSDInfo);

        hr = m_pIOBlock->StartScriptEngine();
        if (SUCCEEDED(hr)) {
            m_pIOBlock->m_ScannerSettings.DeviceIOHandles[0] = pInitInfo->hDeviceDataHandle;
            hr = m_pIOBlock->InitializeProperties();

            if (SUCCEEDED(hr)) {
                #ifdef DEBUG
                    m_pIOBlock->DebugDumpScannerSettings();
                #endif
            }
        }

    } else {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT CScriptDriverAPI::DoInterruptEventThread(PINTERRUPTEVENTINFO pEventInfo)
{
    HRESULT hr = S_OK;

    GSD_EVENT_INFO GSDEventInfo;

    GSDEventInfo.hShutDownEvent = pEventInfo->hShutdownEvent;
    GSDEventInfo.phSignalEvent  = pEventInfo->phSignalEvent;
    GSDEventInfo.pEventGUID     = pEventInfo->pguidEvent;

    //
    // Start IOBlock Event Wait thread.....passing GSD_EVENT_INFO
    // to thread, for event signal code
    //

    hr = m_pIOBlock->EventInterrupt(&GSDEventInfo);

    return hr;
}

HRESULT CScriptDriverAPI::ADFAttached()
{
    HRESULT hr = S_OK;
    if(m_pIOBlock->m_ScannerSettings.ADFSupport)
        hr = S_OK;
    else
        hr = S_FALSE;
    return hr;
}

HRESULT CScriptDriverAPI::ADFHasPaper()
{
    HRESULT hr = S_OK;
    return hr;
}

HRESULT CScriptDriverAPI::ADFAvailable()
{
    HRESULT hr = S_OK;
    return hr;
}

HRESULT CScriptDriverAPI::ADFFeedPage()
{
    HRESULT hr = S_OK;
    return hr;
}

HRESULT CScriptDriverAPI::ADFUnFeedPage()
{
    HRESULT hr = S_OK;
    return hr;
}

HRESULT CScriptDriverAPI::ADFStatus()
{
    HRESULT hr = S_OK;
    return hr;
}

HRESULT CScriptDriverAPI::QueryButtonPanel(PDEVICE_BUTTON_INFO pButtonInformation)
{
    HRESULT hr = S_OK;
    return hr;
}

HRESULT CScriptDriverAPI::BuildRootItemProperties(PWIAPROPERTIES pProperties)
{
    return E_FAIL;  // DISABLE FOR NOW!!
    HRESULT hr = S_OK;

    // Intialize WIA_DPS_HORIZONTAL_BED_SIZE
    pProperties->pszItemDefaults[0]              = WIA_DPS_HORIZONTAL_BED_SIZE_STR;
    pProperties->piItemDefaults [0]              = WIA_DPS_HORIZONTAL_BED_SIZE;
    pProperties->pvItemDefaults [0].lVal         = m_pIOBlock->m_ScannerSettings.BedWidth;
    pProperties->pvItemDefaults [0].vt           = VT_I4;
    pProperties->psItemDefaults [0].ulKind       = PRSPEC_PROPID;
    pProperties->psItemDefaults [0].propid       = pProperties->piItemDefaults [0];
    pProperties->wpiItemDefaults[0].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[0].vt           = pProperties->pvItemDefaults [0].vt;

    // Intialize WIA_DPS_VERTICAL_BED_SIZE
    pProperties->pszItemDefaults[1]              = WIA_DPS_VERTICAL_BED_SIZE_STR;
    pProperties->piItemDefaults [1]              = WIA_DPS_VERTICAL_BED_SIZE;
    pProperties->pvItemDefaults [1].lVal         = m_pIOBlock->m_ScannerSettings.BedHeight;
    pProperties->pvItemDefaults [1].vt           = VT_I4;
    pProperties->psItemDefaults [1].ulKind       = PRSPEC_PROPID;
    pProperties->psItemDefaults [1].propid       = pProperties->piItemDefaults [1];
    pProperties->wpiItemDefaults[1].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[1].vt           = pProperties->pvItemDefaults [1].vt;

    // Intialize WIA_IPA_ACCESS_RIGHTS
    pProperties->pszItemDefaults[2]              = WIA_IPA_ACCESS_RIGHTS_STR;
    pProperties->piItemDefaults [2]              = WIA_IPA_ACCESS_RIGHTS;
    pProperties->pvItemDefaults [2].lVal         = WIA_ITEM_READ|WIA_ITEM_WRITE;
    pProperties->pvItemDefaults [2].vt           = VT_UI4;
    pProperties->psItemDefaults [2].ulKind       = PRSPEC_PROPID;
    pProperties->psItemDefaults [2].propid       = pProperties->piItemDefaults [2];
    pProperties->wpiItemDefaults[2].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[2].vt           = pProperties->pvItemDefaults [2].vt;

    // Intialize WIA_DPS_OPTICAL_XRES
    pProperties->pszItemDefaults[3]              = WIA_DPS_OPTICAL_XRES_STR;
    pProperties->piItemDefaults [3]              = WIA_DPS_OPTICAL_XRES;
    pProperties->pvItemDefaults [3].lVal         = m_pIOBlock->m_ScannerSettings.XOpticalResolution;
    pProperties->pvItemDefaults [3].vt           = VT_I4;
    pProperties->psItemDefaults [3].ulKind       = PRSPEC_PROPID;
    pProperties->psItemDefaults [3].propid       = pProperties->piItemDefaults [3];
    pProperties->wpiItemDefaults[3].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[3].vt           = pProperties->pvItemDefaults [3].vt;

    // Intialize WIA_DPS_OPTICAL_YRES
    pProperties->pszItemDefaults[4]              = WIA_DPS_OPTICAL_YRES_STR;
    pProperties->piItemDefaults [4]              = WIA_DPS_OPTICAL_YRES;
    pProperties->pvItemDefaults [4].lVal         = m_pIOBlock->m_ScannerSettings.YOpticalResolution;
    pProperties->pvItemDefaults [4].vt           = VT_I4;
    pProperties->psItemDefaults [4].ulKind       = PRSPEC_PROPID;
    pProperties->psItemDefaults [4].propid       = pProperties->piItemDefaults [4];
    pProperties->wpiItemDefaults[4].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[4].vt           = pProperties->pvItemDefaults [4].vt;

    // Initialize WIA_DPA_FIRMWARE_VERSION
    pProperties->pszItemDefaults[5]              = WIA_DPA_FIRMWARE_VERSION_STR;
    pProperties->piItemDefaults [5]              = WIA_DPA_FIRMWARE_VERSION;
    pProperties->pvItemDefaults [5].bstrVal      = SysAllocString(SCANNER_FIRMWARE_VERSION);
    pProperties->pvItemDefaults [5].vt           = VT_BSTR;
    pProperties->psItemDefaults [5].ulKind       = PRSPEC_PROPID;
    pProperties->psItemDefaults [5].propid       = pProperties->piItemDefaults [5];
    pProperties->wpiItemDefaults[5].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[5].vt           = pProperties->pvItemDefaults [5].vt;

    // Initialize WIA_IPA_ITEM_FLAGS
    pProperties->pszItemDefaults[6]              = WIA_IPA_ITEM_FLAGS_STR;
    pProperties->piItemDefaults [6]              = WIA_IPA_ITEM_FLAGS;
    pProperties->pvItemDefaults [6].lVal         = WiaItemTypeRoot|WiaItemTypeFolder|WiaItemTypeDevice;
    pProperties->pvItemDefaults [6].vt           = VT_I4;
    pProperties->psItemDefaults [6].ulKind       = PRSPEC_PROPID;
    pProperties->psItemDefaults [6].propid       = pProperties->piItemDefaults [6];
    pProperties->wpiItemDefaults[6].lAccessFlags = WIA_PROP_READ|WIA_PROP_FLAG;
    pProperties->wpiItemDefaults[6].vt           = pProperties->pvItemDefaults [6].vt;
    pProperties->wpiItemDefaults[6].ValidVal.Flag.Nom  = pProperties->pvItemDefaults [6].lVal;
    pProperties->wpiItemDefaults[6].ValidVal.Flag.ValidBits = WiaItemTypeRoot|WiaItemTypeFolder|WiaItemTypeDevice;

    // Intialize WIA_DPS_MAX_SCAN_TIME (NONE)
    pProperties->pszItemDefaults[7]                    = WIA_DPS_MAX_SCAN_TIME_STR;
    pProperties->piItemDefaults [7]                    = WIA_DPS_MAX_SCAN_TIME;
    pProperties->pvItemDefaults [7].lVal               = 0;
    pProperties->pvItemDefaults [7].vt                 = VT_I4;
    pProperties->psItemDefaults [7].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [7].propid             = pProperties->piItemDefaults [7];
    pProperties->wpiItemDefaults[7].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[7].vt                 = pProperties->pvItemDefaults [7].vt;

    if(m_pIOBlock->m_ScannerSettings.ADFSupport) {

        // Initialize WIA_DPS_HORIZONTAL_SHEET_FEED_SIZE
        pProperties->pszItemDefaults[8]              = WIA_DPS_HORIZONTAL_SHEET_FEED_SIZE_STR;
        pProperties->piItemDefaults [8]              = WIA_DPS_HORIZONTAL_SHEET_FEED_SIZE;
        pProperties->pvItemDefaults [8].lVal         = m_pIOBlock->m_ScannerSettings.FeederWidth;
        pProperties->pvItemDefaults [8].vt           = VT_I4;
        pProperties->psItemDefaults [8].ulKind       = PRSPEC_PROPID;
        pProperties->psItemDefaults [8].propid       = pProperties->piItemDefaults [8];
        pProperties->wpiItemDefaults[8].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
        pProperties->wpiItemDefaults[8].vt           = pProperties->pvItemDefaults [8].vt;

        // Initialize WIA_DPS_VERTICAL_SHEET_FEED_SIZE
        pProperties->pszItemDefaults[9]              = WIA_DPS_VERTICAL_SHEET_FEED_SIZE_STR;
        pProperties->piItemDefaults [9]              = WIA_DPS_VERTICAL_SHEET_FEED_SIZE;
        pProperties->pvItemDefaults [9].lVal         = m_pIOBlock->m_ScannerSettings.FeederHeight;
        pProperties->pvItemDefaults [9].vt           = VT_I4;
        pProperties->psItemDefaults [9].ulKind       = PRSPEC_PROPID;
        pProperties->psItemDefaults [9].propid       = pProperties->piItemDefaults [9];
        pProperties->wpiItemDefaults[9].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
        pProperties->wpiItemDefaults[9].vt           = pProperties->pvItemDefaults [9].vt;

        // Initialize WIA_DPS_DOCUMENT_HANDLING_CAPABILITIES
        pProperties->pszItemDefaults[10]              = WIA_DPS_DOCUMENT_HANDLING_CAPABILITIES_STR;
        pProperties->piItemDefaults [10]              = WIA_DPS_DOCUMENT_HANDLING_CAPABILITIES;
        pProperties->pvItemDefaults [10].lVal         = FLAT | FEED;
        pProperties->pvItemDefaults [10].vt           = VT_I4;
        pProperties->psItemDefaults [10].ulKind       = PRSPEC_PROPID;
        pProperties->psItemDefaults [10].propid       = pProperties->piItemDefaults [10];
        pProperties->wpiItemDefaults[10].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
        pProperties->wpiItemDefaults[10].vt           = pProperties->pvItemDefaults [10].vt;

        // Initialize WIA_DPS_DOCUMENT_HANDLING_STATUS
        pProperties->pszItemDefaults[11]              = WIA_DPS_DOCUMENT_HANDLING_STATUS_STR;
        pProperties->piItemDefaults [11]              = WIA_DPS_DOCUMENT_HANDLING_STATUS;
        pProperties->pvItemDefaults [11].lVal         = FLAT_READY;
        pProperties->pvItemDefaults [11].vt           = VT_I4;
        pProperties->psItemDefaults [11].ulKind       = PRSPEC_PROPID;
        pProperties->psItemDefaults [11].propid       = pProperties->piItemDefaults [11];
        pProperties->wpiItemDefaults[11].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
        pProperties->wpiItemDefaults[11].vt           = pProperties->pvItemDefaults [11].vt;

        // Initialize WIA_DPS_DOCUMENT_HANDLING_SELECT
        pProperties->pszItemDefaults[12]              = WIA_DPS_DOCUMENT_HANDLING_SELECT_STR;
        pProperties->piItemDefaults [12]              = WIA_DPS_DOCUMENT_HANDLING_SELECT;
        pProperties->pvItemDefaults [12].lVal         = FLATBED;
        pProperties->pvItemDefaults [12].vt           = VT_I4;
        pProperties->psItemDefaults [12].ulKind       = PRSPEC_PROPID;
        pProperties->psItemDefaults [12].propid       = pProperties->piItemDefaults [12];
        pProperties->wpiItemDefaults[12].lAccessFlags = WIA_PROP_RW|WIA_PROP_FLAG;
        pProperties->wpiItemDefaults[12].vt           = pProperties->pvItemDefaults [12].vt;
        pProperties->wpiItemDefaults[12].ValidVal.Flag.Nom  = pProperties->pvItemDefaults [12].lVal;
        pProperties->wpiItemDefaults[12].ValidVal.Flag.ValidBits = FEEDER | FLATBED;

        // Initialize WIA_DPS_PAGES
        pProperties->pszItemDefaults[13]              = WIA_DPS_PAGES_STR;
        pProperties->piItemDefaults [13]              = WIA_DPS_PAGES;
        pProperties->pvItemDefaults [13].lVal         = 1;
        pProperties->pvItemDefaults [13].vt           = VT_I4;
        pProperties->psItemDefaults [13].ulKind       = PRSPEC_PROPID;
        pProperties->psItemDefaults [13].propid       = pProperties->piItemDefaults [13];
        pProperties->wpiItemDefaults[13].lAccessFlags = WIA_PROP_RW|WIA_PROP_RANGE;
        pProperties->wpiItemDefaults[13].vt           = pProperties->pvItemDefaults [13].vt;
        pProperties->wpiItemDefaults[13].ValidVal.Range.Inc = 1;
        pProperties->wpiItemDefaults[13].ValidVal.Range.Min = 0;
        pProperties->wpiItemDefaults[13].ValidVal.Range.Max = m_pIOBlock->m_ScannerSettings.MaxADFPageCapacity;
        pProperties->wpiItemDefaults[13].ValidVal.Range.Nom = 1;

        // Initialize WIA_DPS_SHEET_FEEDER_REGISTRATION
        pProperties->pszItemDefaults[14]              = WIA_DPS_SHEET_FEEDER_REGISTRATION_STR;
        pProperties->piItemDefaults [14]              = WIA_DPS_SHEET_FEEDER_REGISTRATION;
        pProperties->pvItemDefaults [14].lVal         = m_pIOBlock->m_ScannerSettings.FeederJustification;
        pProperties->pvItemDefaults [14].vt           = VT_I4;
        pProperties->psItemDefaults [14].ulKind       = PRSPEC_PROPID;
        pProperties->psItemDefaults [14].propid       = pProperties->piItemDefaults [14];
        pProperties->wpiItemDefaults[14].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
        pProperties->wpiItemDefaults[14].vt           = pProperties->pvItemDefaults [14].vt;

        // Initialize WIA_DPS_HORIZONTAL_BED_REGISTRATION
        pProperties->pszItemDefaults[15]              = WIA_DPS_HORIZONTAL_BED_REGISTRATION_STR;
        pProperties->piItemDefaults [15]              = WIA_DPS_HORIZONTAL_BED_REGISTRATION;
        pProperties->pvItemDefaults [15].lVal         = m_pIOBlock->m_ScannerSettings.HFeederJustification;
        pProperties->pvItemDefaults [15].vt           = VT_I4;
        pProperties->psItemDefaults [15].ulKind       = PRSPEC_PROPID;
        pProperties->psItemDefaults [15].propid       = pProperties->piItemDefaults [15];
        pProperties->wpiItemDefaults[15].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
        pProperties->wpiItemDefaults[15].vt           = pProperties->pvItemDefaults [15].vt;

        // Initialize WIA_DPS_VERTICAL_BED_REGISTRATION
        pProperties->pszItemDefaults[16]              = WIA_DPS_VERTICAL_BED_REGISTRATION_STR;
        pProperties->piItemDefaults [16]              = WIA_DPS_VERTICAL_BED_REGISTRATION;
        pProperties->pvItemDefaults [16].lVal         = m_pIOBlock->m_ScannerSettings.VFeederJustification;
        pProperties->pvItemDefaults [16].vt           = VT_I4;
        pProperties->psItemDefaults [16].ulKind       = PRSPEC_PROPID;
        pProperties->psItemDefaults [16].propid       = pProperties->piItemDefaults [16];
        pProperties->wpiItemDefaults[16].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
        pProperties->wpiItemDefaults[16].vt           = pProperties->pvItemDefaults [16].vt;

    }
    return hr;
}

HRESULT CScriptDriverAPI::BuildTopItemProperties(PWIAPROPERTIES pProperties)
{
    return E_FAIL;  // DISABLE FOR NOW!!
    HRESULT hr = S_OK;
    if (NULL == m_pIOBlock->m_ScannerSettings.XSupportedResolutionsList) {

        // Intialize WIA_IPS_XRES (RANGE)
        pProperties->pszItemDefaults[0]                    = WIA_IPS_XRES_STR;
        pProperties->piItemDefaults [0]                    = WIA_IPS_XRES;
        pProperties->pvItemDefaults [0].lVal               = m_pIOBlock->m_ScannerSettings.CurrentXResolution;
        pProperties->pvItemDefaults [0].vt                 = VT_I4;
        pProperties->psItemDefaults [0].ulKind             = PRSPEC_PROPID;
        pProperties->psItemDefaults [0].propid             = pProperties->piItemDefaults [0];
        pProperties->wpiItemDefaults[0].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
        pProperties->wpiItemDefaults[0].vt                 = pProperties->pvItemDefaults [0].vt;
        pProperties->wpiItemDefaults[0].ValidVal.Range.Inc = m_pIOBlock->m_ScannerSettings.XSupportedResolutionsRange.lStep;
        pProperties->wpiItemDefaults[0].ValidVal.Range.Min = m_pIOBlock->m_ScannerSettings.XSupportedResolutionsRange.lMin;
        pProperties->wpiItemDefaults[0].ValidVal.Range.Max = m_pIOBlock->m_ScannerSettings.XSupportedResolutionsRange.lMax;
        pProperties->wpiItemDefaults[0].ValidVal.Range.Nom = pProperties->pvItemDefaults [0].lVal;

        // Intialize WIA_IPS_YRES (RANGE)
        pProperties->pszItemDefaults[1]                    = WIA_IPS_YRES_STR;
        pProperties->piItemDefaults [1]                    = WIA_IPS_YRES;
        pProperties->pvItemDefaults [1].lVal               = m_pIOBlock->m_ScannerSettings.CurrentYResolution;
        pProperties->pvItemDefaults [1].vt                 = VT_I4;
        pProperties->psItemDefaults [1].ulKind             = PRSPEC_PROPID;
        pProperties->psItemDefaults [1].propid             = pProperties->piItemDefaults [1];
        pProperties->wpiItemDefaults[1].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
        pProperties->wpiItemDefaults[1].vt                 = pProperties->pvItemDefaults [1].vt;
        pProperties->wpiItemDefaults[1].ValidVal.Range.Inc = m_pIOBlock->m_ScannerSettings.YSupportedResolutionsRange.lStep;
        pProperties->wpiItemDefaults[1].ValidVal.Range.Min = m_pIOBlock->m_ScannerSettings.YSupportedResolutionsRange.lMin;
        pProperties->wpiItemDefaults[1].ValidVal.Range.Max = m_pIOBlock->m_ScannerSettings.YSupportedResolutionsRange.lMax;
        pProperties->wpiItemDefaults[1].ValidVal.Range.Nom = pProperties->pvItemDefaults [1].lVal;

    } else {

        // Intialize WIA_IPS_XRES (LIST)
        pProperties->pszItemDefaults[0]                    = WIA_IPS_XRES_STR;
        pProperties->piItemDefaults [0]                    = WIA_IPS_XRES;
        pProperties->pvItemDefaults [0].lVal               = m_pIOBlock->m_ScannerSettings.CurrentXResolution;;
        pProperties->pvItemDefaults [0].vt                 = VT_I4;
        pProperties->psItemDefaults [0].ulKind             = PRSPEC_PROPID;
        pProperties->psItemDefaults [0].propid             = pProperties->piItemDefaults [0];
        pProperties->wpiItemDefaults[0].lAccessFlags       = WIA_PROP_RW|WIA_PROP_LIST;
        pProperties->wpiItemDefaults[0].vt                 = pProperties->pvItemDefaults [0].vt;
        pProperties->wpiItemDefaults[0].ValidVal.List.pList= (BYTE*)&m_pIOBlock->m_ScannerSettings.XSupportedResolutionsList[1];
        pProperties->wpiItemDefaults[0].ValidVal.List.Nom  = pProperties->pvItemDefaults [0].lVal;
        pProperties->wpiItemDefaults[0].ValidVal.List.cNumList = m_pIOBlock->m_ScannerSettings.XSupportedResolutionsList[0];

        // Intialize WIA_IPS_YRES (LIST)
        pProperties->pszItemDefaults[1]                    = WIA_IPS_YRES_STR;
        pProperties->piItemDefaults [1]                    = WIA_IPS_YRES;
        pProperties->pvItemDefaults [1].lVal               = m_pIOBlock->m_ScannerSettings.CurrentYResolution;
        pProperties->pvItemDefaults [1].vt                 = VT_I4;
        pProperties->psItemDefaults [1].ulKind             = PRSPEC_PROPID;
        pProperties->psItemDefaults [1].propid             = pProperties->piItemDefaults [1];
        pProperties->wpiItemDefaults[1].lAccessFlags       = WIA_PROP_RW|WIA_PROP_LIST;
        pProperties->wpiItemDefaults[1].vt                 = pProperties->pvItemDefaults [1].vt;
        pProperties->wpiItemDefaults[1].ValidVal.List.pList= (BYTE*)&m_pIOBlock->m_ScannerSettings.YSupportedResolutionsList[1];
        pProperties->wpiItemDefaults[1].ValidVal.List.Nom  = pProperties->pvItemDefaults [1].lVal;
        pProperties->wpiItemDefaults[1].ValidVal.List.cNumList = m_pIOBlock->m_ScannerSettings.YSupportedResolutionsList[0];

    }

    // Intialize WIA_IPS_XEXTENT (RANGE)
    pProperties->pszItemDefaults[2]                    = WIA_IPS_XEXTENT_STR;
    pProperties->piItemDefaults [2]                    = WIA_IPS_XEXTENT;
    pProperties->pvItemDefaults [2].lVal               = (m_pIOBlock->m_ScannerSettings.CurrentXResolution * m_pIOBlock->m_ScannerSettings.BedWidth )/1000;
    pProperties->pvItemDefaults [2].vt                 = VT_I4;
    pProperties->psItemDefaults [2].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [2].propid             = pProperties->piItemDefaults [2];
    pProperties->wpiItemDefaults[2].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
    pProperties->wpiItemDefaults[2].vt                 = pProperties->pvItemDefaults [2].vt;
    pProperties->wpiItemDefaults[2].ValidVal.Range.Inc = 1;
    pProperties->wpiItemDefaults[2].ValidVal.Range.Min = 1;
    pProperties->wpiItemDefaults[2].ValidVal.Range.Max = pProperties->pvItemDefaults [2].lVal;
    pProperties->wpiItemDefaults[2].ValidVal.Range.Nom = pProperties->pvItemDefaults [2].lVal;

    // Intialize WIA_IPS_YEXTENT (RANGE)
    pProperties->pszItemDefaults[3]                    = WIA_IPS_YEXTENT_STR;
    pProperties->piItemDefaults [3]                    = WIA_IPS_YEXTENT;
    pProperties->pvItemDefaults [3].lVal               = (m_pIOBlock->m_ScannerSettings.CurrentYResolution * m_pIOBlock->m_ScannerSettings.BedHeight )/1000;
    pProperties->pvItemDefaults [3].vt                 = VT_I4;
    pProperties->psItemDefaults [3].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [3].propid             = pProperties->piItemDefaults [3];
    pProperties->wpiItemDefaults[3].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
    pProperties->wpiItemDefaults[3].vt                 = pProperties->pvItemDefaults [3].vt;
    pProperties->wpiItemDefaults[3].ValidVal.Range.Inc = 1;
    pProperties->wpiItemDefaults[3].ValidVal.Range.Min = 1;
    pProperties->wpiItemDefaults[3].ValidVal.Range.Max = pProperties->pvItemDefaults [3].lVal;
    pProperties->wpiItemDefaults[3].ValidVal.Range.Nom = pProperties->pvItemDefaults [3].lVal;

    // Intialize WIA_IPS_XPOS (RANGE)
    pProperties->pszItemDefaults[4]                    = WIA_IPS_XPOS_STR;
    pProperties->piItemDefaults [4]                    = WIA_IPS_XPOS;
    pProperties->pvItemDefaults [4].lVal               = 0;
    pProperties->pvItemDefaults [4].vt                 = VT_I4;
    pProperties->psItemDefaults [4].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [4].propid             = pProperties->piItemDefaults [4];
    pProperties->wpiItemDefaults[4].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
    pProperties->wpiItemDefaults[4].vt                 = pProperties->pvItemDefaults [4].vt;
    pProperties->wpiItemDefaults[4].ValidVal.Range.Inc = 1;
    pProperties->wpiItemDefaults[4].ValidVal.Range.Min = 0;
    pProperties->wpiItemDefaults[4].ValidVal.Range.Max = (pProperties->wpiItemDefaults[2].ValidVal.Range.Max - 1);
    pProperties->wpiItemDefaults[4].ValidVal.Range.Nom = pProperties->pvItemDefaults [4].lVal;

    // Intialize WIA_IPS_YPOS (RANGE)
    pProperties->pszItemDefaults[5]                    = WIA_IPS_YPOS_STR;
    pProperties->piItemDefaults [5]                    = WIA_IPS_YPOS;
    pProperties->pvItemDefaults [5].lVal               = 0;
    pProperties->pvItemDefaults [5].vt                 = VT_I4;
    pProperties->psItemDefaults [5].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [5].propid             = pProperties->piItemDefaults [5];
    pProperties->wpiItemDefaults[5].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
    pProperties->wpiItemDefaults[5].vt                 = pProperties->pvItemDefaults [5].vt;
    pProperties->wpiItemDefaults[5].ValidVal.Range.Inc = 1;
    pProperties->wpiItemDefaults[5].ValidVal.Range.Min = 0;
    pProperties->wpiItemDefaults[5].ValidVal.Range.Max = (pProperties->wpiItemDefaults[3].ValidVal.Range.Max - 1);
    pProperties->wpiItemDefaults[5].ValidVal.Range.Nom = pProperties->pvItemDefaults [5].lVal;

    // Intialize WIA_IPA_DATATYPE (LIST)
    pProperties->pszItemDefaults[6]                    = WIA_IPA_DATATYPE_STR;
    pProperties->piItemDefaults [6]                    = WIA_IPA_DATATYPE;
    pProperties->pvItemDefaults [6].lVal               = INITIAL_DATATYPE;
    pProperties->pvItemDefaults [6].vt                 = VT_I4;
    pProperties->psItemDefaults [6].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [6].propid             = pProperties->piItemDefaults [6];
    pProperties->wpiItemDefaults[6].lAccessFlags       = WIA_PROP_RW|WIA_PROP_LIST;
    pProperties->wpiItemDefaults[6].vt                 = pProperties->pvItemDefaults [6].vt;
    pProperties->wpiItemDefaults[6].ValidVal.List.pList    = (BYTE*)&m_pIOBlock->m_ScannerSettings.SupportedDataTypesList[1];
    pProperties->wpiItemDefaults[6].ValidVal.List.Nom      = pProperties->pvItemDefaults [6].lVal;
    pProperties->wpiItemDefaults[6].ValidVal.List.cNumList = m_pIOBlock->m_ScannerSettings.SupportedDataTypesList[0];

    // Intialize WIA_IPA_DEPTH (NONE)
    pProperties->pszItemDefaults[7]                    = WIA_IPA_DEPTH_STR;
    pProperties->piItemDefaults [7]                    = WIA_IPA_DEPTH;
    pProperties->pvItemDefaults [7].lVal               = m_pIOBlock->m_ScannerSettings.CurrentBitDepth;
    pProperties->pvItemDefaults [7].vt                 = VT_I4;
    pProperties->psItemDefaults [7].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [7].propid             = pProperties->piItemDefaults [7];
    pProperties->wpiItemDefaults[7].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[7].vt                 = pProperties->pvItemDefaults [7].vt;

    // Intialize WIA_IPS_BRIGHTNESS (RANGE)
    pProperties->pszItemDefaults[8]                    = WIA_IPS_BRIGHTNESS_STR;
    pProperties->piItemDefaults [8]                    = WIA_IPS_BRIGHTNESS;
    pProperties->pvItemDefaults [8].lVal               = m_pIOBlock->m_ScannerSettings.CurrentBrightness;
    pProperties->pvItemDefaults [8].vt                 = VT_I4;
    pProperties->psItemDefaults [8].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [8].propid             = pProperties->piItemDefaults [8];
    pProperties->wpiItemDefaults[8].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
    pProperties->wpiItemDefaults[8].vt                 = pProperties->pvItemDefaults [8].vt;
    pProperties->wpiItemDefaults[8].ValidVal.Range.Inc = m_pIOBlock->m_ScannerSettings.BrightnessRange.lStep;
    pProperties->wpiItemDefaults[8].ValidVal.Range.Min = m_pIOBlock->m_ScannerSettings.BrightnessRange.lMin;
    pProperties->wpiItemDefaults[8].ValidVal.Range.Max = m_pIOBlock->m_ScannerSettings.BrightnessRange.lMax;
    pProperties->wpiItemDefaults[8].ValidVal.Range.Nom = pProperties->pvItemDefaults [8].lVal;

    // Intialize WIA_IPS_CONTRAST (RANGE)
    pProperties->pszItemDefaults[9]                    = WIA_IPS_CONTRAST_STR;
    pProperties->piItemDefaults [9]                    = WIA_IPS_CONTRAST;
    pProperties->pvItemDefaults [9].lVal               = m_pIOBlock->m_ScannerSettings.CurrentContrast;
    pProperties->pvItemDefaults [9].vt                 = VT_I4;
    pProperties->psItemDefaults [9].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [9].propid             = pProperties->piItemDefaults [9];
    pProperties->wpiItemDefaults[9].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
    pProperties->wpiItemDefaults[9].vt                 = pProperties->pvItemDefaults [9].vt;
    pProperties->wpiItemDefaults[9].ValidVal.Range.Inc = m_pIOBlock->m_ScannerSettings.ContrastRange.lStep;
    pProperties->wpiItemDefaults[9].ValidVal.Range.Min = m_pIOBlock->m_ScannerSettings.ContrastRange.lMin;
    pProperties->wpiItemDefaults[9].ValidVal.Range.Max = m_pIOBlock->m_ScannerSettings.ContrastRange.lMax;
    pProperties->wpiItemDefaults[9].ValidVal.Range.Nom = pProperties->pvItemDefaults [9].lVal;

    // Intialize WIA_IPS_CUR_INTENT (FLAG)
    pProperties->pszItemDefaults[10]                    = WIA_IPS_CUR_INTENT_STR;
    pProperties->piItemDefaults [10]                    = WIA_IPS_CUR_INTENT;
    pProperties->pvItemDefaults [10].lVal               = WIA_INTENT_NONE;
    pProperties->pvItemDefaults [10].vt                 = VT_I4;
    pProperties->psItemDefaults [10].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [10].propid             = pProperties->piItemDefaults [10];
    pProperties->wpiItemDefaults[10].lAccessFlags       = WIA_PROP_RW|WIA_PROP_FLAG;
    pProperties->wpiItemDefaults[10].vt                 = pProperties->pvItemDefaults [10].vt;
    pProperties->wpiItemDefaults[10].ValidVal.Flag.Nom  = pProperties->pvItemDefaults [10].lVal;
    // Original (hard coded intent settings)
    // pProperties->wpiItemDefaults[10].ValidVal.Flag.ValidBits = WIA_INTENT_SIZE_MASK | WIA_INTENT_IMAGE_TYPE_MASK;

    // Dynamic intent settings
    pProperties->wpiItemDefaults[10].ValidVal.Flag.ValidBits = WIA_INTENT_SIZE_MASK;

    for(LONG DataTypeIndex = 1;DataTypeIndex <= (m_pIOBlock->m_ScannerSettings.SupportedDataTypesList[0]) ;DataTypeIndex++){
        switch(m_pIOBlock->m_ScannerSettings.SupportedDataTypesList[DataTypeIndex]){
        case WIA_DATA_COLOR:
            pProperties->wpiItemDefaults[10].ValidVal.Flag.ValidBits = pProperties->wpiItemDefaults[10].ValidVal.Flag.ValidBits|WIA_INTENT_IMAGE_TYPE_COLOR;
            break;
        case WIA_DATA_GRAYSCALE:
            pProperties->wpiItemDefaults[10].ValidVal.Flag.ValidBits = pProperties->wpiItemDefaults[10].ValidVal.Flag.ValidBits|WIA_INTENT_IMAGE_TYPE_GRAYSCALE;
            break;
        case WIA_DATA_THRESHOLD:
            pProperties->wpiItemDefaults[10].ValidVal.Flag.ValidBits = pProperties->wpiItemDefaults[10].ValidVal.Flag.ValidBits|WIA_INTENT_IMAGE_TYPE_TEXT;
            break;
        default:
            break;
        }
    }

    // Intialize WIA_IPA_PIXELS_PER_LINE (NONE)
    pProperties->pszItemDefaults[11]                    = WIA_IPA_PIXELS_PER_LINE_STR;
    pProperties->piItemDefaults [11]                    = WIA_IPA_PIXELS_PER_LINE;
    pProperties->pvItemDefaults [11].lVal               = (m_pIOBlock->m_ScannerSettings.CurrentXResolution * m_pIOBlock->m_ScannerSettings.BedWidth )/1000;
    pProperties->pvItemDefaults [11].vt                 = VT_I4;
    pProperties->psItemDefaults [11].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [11].propid             = pProperties->piItemDefaults [11];
    pProperties->wpiItemDefaults[11].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[11].vt                 = pProperties->pvItemDefaults [11].vt;

    // Intialize WIA_IPA_NUMER_OF_LINES (NONE)
    pProperties->pszItemDefaults[12]                    = WIA_IPA_NUMBER_OF_LINES_STR;
    pProperties->piItemDefaults [12]                    = WIA_IPA_NUMBER_OF_LINES;
    pProperties->pvItemDefaults [12].lVal               = (m_pIOBlock->m_ScannerSettings.CurrentYResolution * m_pIOBlock->m_ScannerSettings.BedHeight )/1000;
    pProperties->pvItemDefaults [12].vt                 = VT_I4;
    pProperties->psItemDefaults [12].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [12].propid             = pProperties->piItemDefaults [12];
    pProperties->wpiItemDefaults[12].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[12].vt                 = pProperties->pvItemDefaults [12].vt;

    // Intialize WIA_DPS_MAX_SCAN_TIME (NONE)
    pProperties->pszItemDefaults[13]                    = WIA_DPS_MAX_SCAN_TIME_STR;
    pProperties->piItemDefaults [13]                    = WIA_DPS_MAX_SCAN_TIME;
    pProperties->pvItemDefaults [13].lVal               = 10000;
    pProperties->pvItemDefaults [13].vt                 = VT_I4;
    pProperties->psItemDefaults [13].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [13].propid             = pProperties->piItemDefaults [13];
    pProperties->wpiItemDefaults[13].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[13].vt                 = pProperties->pvItemDefaults [13].vt;

    // Intialize WIA_IPA_PREFERRED_FORMAT (NONE)
    pProperties->pszItemDefaults[14]                    = WIA_IPA_PREFERRED_FORMAT_STR;
    pProperties->piItemDefaults [14]                    = WIA_IPA_PREFERRED_FORMAT;
    pProperties->pvItemDefaults [14].puuid              = INITIAL_FORMAT;
    pProperties->pvItemDefaults [14].vt                 = VT_CLSID;
    pProperties->psItemDefaults [14].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [14].propid             = pProperties->piItemDefaults [14];
    pProperties->wpiItemDefaults[14].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[14].vt                 = pProperties->pvItemDefaults [14].vt;

    // Intialize WIA_IPA_ITEM_SIZE (NONE)
    pProperties->pszItemDefaults[15]                    = WIA_IPA_ITEM_SIZE_STR;
    pProperties->piItemDefaults [15]                    = WIA_IPA_ITEM_SIZE;
    pProperties->pvItemDefaults [15].lVal               = 0;
    pProperties->pvItemDefaults [15].vt                 = VT_I4;
    pProperties->psItemDefaults [15].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [15].propid             = pProperties->piItemDefaults [15];
    pProperties->wpiItemDefaults[15].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[15].vt                 = pProperties->pvItemDefaults [15].vt;

    // Intialize WIA_IPS_THRESHOLD (RANGE)
    pProperties->pszItemDefaults[16]                    = WIA_IPS_THRESHOLD_STR;
    pProperties->piItemDefaults [16]                    = WIA_IPS_THRESHOLD;
    pProperties->pvItemDefaults [16].lVal               = 0;
    pProperties->pvItemDefaults [16].vt                 = VT_I4;
    pProperties->psItemDefaults [16].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [16].propid             = pProperties->piItemDefaults [16];
    pProperties->wpiItemDefaults[16].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
    pProperties->wpiItemDefaults[16].vt                 = pProperties->pvItemDefaults [16].vt;
    pProperties->wpiItemDefaults[16].ValidVal.Range.Inc = 1;
    pProperties->wpiItemDefaults[16].ValidVal.Range.Min = -127;
    pProperties->wpiItemDefaults[16].ValidVal.Range.Max = 128;
    pProperties->wpiItemDefaults[16].ValidVal.Range.Nom = pProperties->pvItemDefaults [16].lVal;

    // Intialize WIA_IPA_FORMAT (LIST)
    pProperties->pszItemDefaults[17]                    = WIA_IPA_FORMAT_STR;
    pProperties->piItemDefaults [17]                    = WIA_IPA_FORMAT;
    pProperties->pvItemDefaults [17].puuid              = INITIAL_FORMAT;
    pProperties->pvItemDefaults [17].vt                 = VT_CLSID;
    pProperties->psItemDefaults [17].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [17].propid             = pProperties->piItemDefaults [17];
    pProperties->wpiItemDefaults[17].lAccessFlags       = WIA_PROP_RW|WIA_PROP_LIST;
    pProperties->wpiItemDefaults[17].vt                 = pProperties->pvItemDefaults [17].vt;

    pProperties->wpiItemDefaults[17].ValidVal.ListGuid.pList    = (GUID*)pProperties->pInitialFormats;
    pProperties->wpiItemDefaults[17].ValidVal.ListGuid.Nom      = *pProperties->pvItemDefaults [17].puuid;
    pProperties->wpiItemDefaults[17].ValidVal.ListGuid.cNumList = pProperties->NumInitialFormats;

    // Intialize WIA_IPA_TYMED (LIST)
    pProperties->pszItemDefaults[18]                    = WIA_IPA_TYMED_STR;
    pProperties->piItemDefaults [18]                    = WIA_IPA_TYMED;
    pProperties->pvItemDefaults [18].lVal               = INITIAL_TYMED;
    pProperties->pvItemDefaults [18].vt                 = VT_I4;
    pProperties->psItemDefaults [18].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [18].propid             = pProperties->piItemDefaults [18];
    pProperties->wpiItemDefaults[18].lAccessFlags       = WIA_PROP_RW|WIA_PROP_LIST;
    pProperties->wpiItemDefaults[18].vt                 = pProperties->pvItemDefaults [18].vt;

    pProperties->wpiItemDefaults[18].ValidVal.List.pList    = (BYTE*)pProperties->pSupportedTYMED;
    pProperties->wpiItemDefaults[18].ValidVal.List.Nom      = pProperties->pvItemDefaults [18].lVal;
    pProperties->wpiItemDefaults[18].ValidVal.List.cNumList = pProperties->NumSupportedTYMED;

    // Intialize WIA_IPA_CHANNELS_PER_PIXEL (NONE)
    pProperties->pszItemDefaults[19]                    = WIA_IPA_CHANNELS_PER_PIXEL_STR;
    pProperties->piItemDefaults [19]                    = WIA_IPA_CHANNELS_PER_PIXEL;
    pProperties->pvItemDefaults [19].lVal               = INITIAL_CHANNELS_PER_PIXEL;
    pProperties->pvItemDefaults [19].vt                 = VT_I4;
    pProperties->psItemDefaults [19].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [19].propid             = pProperties->piItemDefaults [19];
    pProperties->wpiItemDefaults[19].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[19].vt                 = pProperties->pvItemDefaults [19].vt;

    // Intialize WIA_IPA_BITS_PER_CHANNEL (NONE)
    pProperties->pszItemDefaults[20]                    = WIA_IPA_BITS_PER_CHANNEL_STR;
    pProperties->piItemDefaults [20]                    = WIA_IPA_BITS_PER_CHANNEL;
    pProperties->pvItemDefaults [20].lVal               = INITIAL_BITS_PER_CHANNEL;
    pProperties->pvItemDefaults [20].vt                 = VT_I4;
    pProperties->psItemDefaults [20].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [20].propid             = pProperties->piItemDefaults [20];
    pProperties->wpiItemDefaults[20].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[20].vt                 = pProperties->pvItemDefaults [20].vt;

    // Intialize WIA_IPA_PLANAR (NONE)
    pProperties->pszItemDefaults[21]                    = WIA_IPA_PLANAR_STR;
    pProperties->piItemDefaults [21]                    = WIA_IPA_PLANAR;
    pProperties->pvItemDefaults [21].lVal               = INITIAL_PLANAR;
    pProperties->pvItemDefaults [21].vt                 = VT_I4;
    pProperties->psItemDefaults [21].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [21].propid             = pProperties->piItemDefaults [21];
    pProperties->wpiItemDefaults[21].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[21].vt                 = pProperties->pvItemDefaults [21].vt;

    // Intialize WIA_IPA_BYTES_PER_LINE (NONE)
    pProperties->pszItemDefaults[22]                    = WIA_IPA_BYTES_PER_LINE_STR;
    pProperties->piItemDefaults [22]                    = WIA_IPA_BYTES_PER_LINE;
    pProperties->pvItemDefaults [22].lVal               = 0;
    pProperties->pvItemDefaults [22].vt                 = VT_I4;
    pProperties->psItemDefaults [22].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [22].propid             = pProperties->piItemDefaults [22];
    pProperties->wpiItemDefaults[22].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[22].vt                 = pProperties->pvItemDefaults [22].vt;

    // Intialize WIA_IPA_MIN_BUFFER_SIZE (NONE)
    pProperties->pszItemDefaults[23]                    = WIA_IPA_MIN_BUFFER_SIZE_STR;
    pProperties->piItemDefaults [23]                    = WIA_IPA_MIN_BUFFER_SIZE;
    pProperties->pvItemDefaults [23].lVal               = MIN_BUFFER_SIZE;
    pProperties->pvItemDefaults [23].vt                 = VT_I4;
    pProperties->psItemDefaults [23].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [23].propid             = pProperties->piItemDefaults [23];
    pProperties->wpiItemDefaults[23].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[23].vt                 = pProperties->pvItemDefaults [23].vt;

    // Intialize WIA_IPA_ACCESS_RIGHTS (NONE)
    pProperties->pszItemDefaults[24]                    = WIA_IPA_ACCESS_RIGHTS_STR;
    pProperties->piItemDefaults [24]                    = WIA_IPA_ACCESS_RIGHTS;
    pProperties->pvItemDefaults [24].lVal               = WIA_ITEM_READ|WIA_ITEM_WRITE;
    pProperties->pvItemDefaults [24].vt                 = VT_I4;
    pProperties->psItemDefaults [24].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [24].propid             = pProperties->piItemDefaults [24];
    pProperties->wpiItemDefaults[24].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[24].vt                 = pProperties->pvItemDefaults [24].vt;

    // Intialize WIA_IPA_COMPRESSION (LIST)
    pProperties->pszItemDefaults[25]                    = WIA_IPA_COMPRESSION_STR;
    pProperties->piItemDefaults [25]                    = WIA_IPA_COMPRESSION;
    pProperties->pvItemDefaults [25].lVal               = INITIAL_COMPRESSION;
    pProperties->pvItemDefaults [25].vt                 = VT_I4;
    pProperties->psItemDefaults [25].ulKind             = PRSPEC_PROPID;
    pProperties->psItemDefaults [25].propid             = pProperties->piItemDefaults [25];
    pProperties->wpiItemDefaults[25].lAccessFlags       = WIA_PROP_RW|WIA_PROP_LIST;
    pProperties->wpiItemDefaults[25].vt                 = pProperties->pvItemDefaults [25].vt;

    pProperties->wpiItemDefaults[25].ValidVal.List.pList    = (BYTE*)pProperties->pSupportedCompressionTypes;
    pProperties->wpiItemDefaults[25].ValidVal.List.Nom      = pProperties->pvItemDefaults [25].lVal;
    pProperties->wpiItemDefaults[25].ValidVal.List.cNumList = pProperties->NumSupportedCompressionTypes;

    // Initialize WIA_IPA_ITEM_FLAGS
    pProperties->pszItemDefaults[26]              = WIA_IPA_ITEM_FLAGS_STR;
    pProperties->piItemDefaults [26]              = WIA_IPA_ITEM_FLAGS;
    pProperties->pvItemDefaults [26].lVal         = WiaItemTypeImage|WiaItemTypeFile|WiaItemTypeDevice;
    pProperties->pvItemDefaults [26].vt           = VT_I4;
    pProperties->psItemDefaults [26].ulKind       = PRSPEC_PROPID;
    pProperties->psItemDefaults [26].propid       = pProperties->piItemDefaults [26];
    pProperties->wpiItemDefaults[26].lAccessFlags = WIA_PROP_READ|WIA_PROP_FLAG;
    pProperties->wpiItemDefaults[26].vt           = pProperties->pvItemDefaults [26].vt;
    pProperties->wpiItemDefaults[26].ValidVal.Flag.Nom  = pProperties->pvItemDefaults [26].lVal;
    pProperties->wpiItemDefaults[26].ValidVal.Flag.ValidBits = WiaItemTypeImage|WiaItemTypeFile|WiaItemTypeDevice;

    // Initialize WIA_IPS_PHOTOMETRIC_INTERP
    pProperties->pszItemDefaults[27]              = WIA_IPS_PHOTOMETRIC_INTERP_STR;
    pProperties->piItemDefaults [27]              = WIA_IPS_PHOTOMETRIC_INTERP;
    pProperties->pvItemDefaults [27].lVal         = INITIAL_PHOTOMETRIC_INTERP;
    pProperties->pvItemDefaults [27].vt           = VT_I4;
    pProperties->psItemDefaults [27].ulKind       = PRSPEC_PROPID;
    pProperties->psItemDefaults [27].propid       = pProperties->piItemDefaults [27];
    pProperties->wpiItemDefaults[27].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
    pProperties->wpiItemDefaults[27].vt           = pProperties->pvItemDefaults [27].vt;
    return hr;
}

HRESULT CScriptDriverAPI::BuildCapabilities(PWIACAPABILITIES pCapabilities)
{
    HRESULT hr = S_OK;
    return hr;
}

HRESULT CScriptDriverAPI::GetBedWidthAndHeight(PLONG pWidth, PLONG pHeight)
{
    HRESULT hr = S_OK;

    return hr;
}

HRESULT CScriptDriverAPI::SetResolutionRestrictionString(TCHAR *szResolutions)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\wiafbdrv\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wiafbdrv.rc
//

// Device Events, and Commands (Name strings)
#define IDS_EVENT_DEVICE_CONNECTED_NAME    102
#define IDS_EVENT_DEVICE_DISCONNECTED_NAME 103
#define IDS_CMD_SYNCRONIZE_NAME            104
#define IDS_CMD_DELETE_ALL_ITEMS_NAME      105
#define IDS_CMD_DELETE_DEVICE_TREE_NAME    106
#define IDS_CMD_BUILD_DEVICE_TREE_NAME     107

// Device Events, and Commands (Description strings)
#define IDS_EVENT_DEVICE_CONNECTED_DESC    108
#define IDS_EVENT_DEVICE_DISCONNECTED_DESC 109
#define IDS_CMD_SYNCRONIZE_DESC            110
#define IDS_CMD_DELETE_ALL_ITEMS_DESC      111
#define IDS_CMD_DELETE_DEVICE_TREE_DESC    112
#define IDS_CMD_BUILD_DEVICE_TREE_DESC     113

#define IDS_FULLROOTITEM_NAME              114
#define IDS_ROOTITEM_NAME                  115
#define IDS_FULLTOPITEM_NAME               116
#define IDS_TOPITEM_NAME                   117

#define IDR_DEVICEPROPERTY                 118
#define IDR_DEVICEACTION                   119
#define IDR_DEVICECONTROL                  120
#define IDR_LASTERROR                      121

#define IDC_STATIC                      -1

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        122
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           122
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\wiafbdrv\sources.inc ===
# ############################################################
#
#Copyright (c) 2000  Microsoft Corporation
#
#Author:
#   coopp
#
#Date:
#   19-Jul-2000
#
#Module Name:
#    sources.
#
#Abstract:
#    This file specifies the target component being built and the list of
#    sources files needed to build that component.  Also specifies optional
#    compiler switches and libraries that are unique for the component being
#    built.
#
#  This directory builds
#       WIA Flatbed Scanner USD (Micro Driver / Script-based Driver support)
#
# ############################################################

!include $(PROJECT_ROOT)\wia\wiaenv.inc

TARGETNAME=wiafbdrv
TARGETTYPE=DYNLINK
TARGETPATH=$(OBJ_DIR)

USE_ATL=1
ATL_VER=30
USE_STATIC_ATL=1

DLLDEF = ..\wiafbdrv.def
DLLENTRY=DllEntryPoint
COFFBASE=usermode

DELAYLOAD_SUPPORTED=1

INCLUDES= $(INCLUDES) \
          $(DDK_INC_PATH) \
          $(PROJECT_ROOT)\wia\drivers\scanner\microdrv\inc;


TARGETLIBS= $(TARGETLIBS) \
            $(SDK_LIB_PATH)\iprop.lib           \
            $(SDK_LIB_PATH)\atl.lib             \
            $(SDK_LIB_PATH)\wiaguid.lib         \
            $(DDK_LIB_PATH)\wiaservc.lib

DELAYLOAD=wiaservc.dll

DLOAD_ERROR_HANDLER=DliHook

PASS0_HEADERDIR=$(O)
PASS0_SERVERDIR=$(O)
PASS0_CLIENTDIR=$(O)
PASS0_SOURCEDIR=$(O)

C_DEFINES=$(C_DEFINES) -DENTRY_PREFIX=WIAFB

PRECOMPILED_CXX = 1
PRECOMPILED_INCLUDE = ..\pch.h
PRECOMPILED_OBJ = pch.obj

SOURCES= \
    ..\wiafb.idl       \
    $(O)\wiafb_i.c     \
    $(O)\wiafb_p.c     \
    $(O)\dlldata.c     \
    ..\devprop.cpp     \
    ..\devaction.cpp   \
    ..\devctrl.cpp     \
    ..\lasterr.cpp     \
    ..\cmicro.cpp      \
    ..\ioblock.cpp     \
    ..\wiafbdrv.cpp    \
    ..\IStiUSD.cpp     \
    ..\IWiaMiniDrv.cpp \
    ..\validate.cpp    \
    ..\scanapi.cpp     \
    ..\dlihook.cpp     \
    ..\wiafbdrv.rc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\wiascanr\dlihook.cpp ===
#include "pch.h"
#include <delayimp.h>

FARPROC WINAPI DliHook(unsigned dliNotify, PDelayLoadInfo pdli)
{    
#ifdef DEBUG
    switch (dliNotify) {
    case dliStartProcessing:             // used to bypass or note helper only
        OutputDebugString(TEXT("dliStartProcessing reported from DliHook"));
        break;
    case dliNotePreLoadLibrary:          // called just before LoadLibrary, can
        OutputDebugString(TEXT("dliNotePreLoadLibrary reported from DliHook"));                   //  override w/ new HMODULE return val
        break;                           
    case dliNotePreGetProcAddress:       // called just before GetProcAddress, can
        OutputDebugString(TEXT("dliNotePreGetProcAddress reported from DliHook"));                   //  override w/ new FARPROC return value
        break;                           
    case dliFailLoadLib:                 // failed to load library, fix it by
        OutputDebugString(TEXT("dliFailLoadLib reported from DliHook"));                   //  returning a valid HMODULE
        break;                           
    case dliFailGetProc:                 // failed to get proc address, fix it by                                         
        OutputDebugString(TEXT("dliFailGetProc reported from DliHook"));                   //  returning a valid FARPROC
        break;                           
    case dliNoteEndProcessing:           // called after all processing is done, no
        OutputDebugString(TEXT("dliNoteEndProcessing reported from DliHook"));                   //  no bypass possible at this point except
                                         //  by longjmp()/throw()/RaiseException.
        break;
    default:
        break;
    }
#endif
    return 0;
}

PfnDliHook __pfnDliFailureHook = DliHook;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\wiafbdrv\scanapi.h ===
/**************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       scanapi.h
*
*  VERSION:     1.0
*
*  DATE:        18 July, 2000
*
*  DESCRIPTION:
*   Fake Scanner device library
*
***************************************************************************/

#ifndef _SCANAPI_H
#define _SCANAPI_H

typedef GUID* PGUID;

#define FLATBED_SCANNER_MODE        100
#define SCROLLFED_SCANNER_MODE      200
#define MULTIFUNCTION_DEVICE_MODE   300

#define SCAN_START                  0
#define SCAN_CONTINUE               1
#define SCAN_END                    3

typedef struct _DEVICE_BUTTON_INFO {
    BYTE ScanButton;
    BYTE FaxButton;
    BYTE EMailButton;
    BYTE DocumentButton;
    BYTE CancelButton;
}DEVICE_BUTTON_INFO,*PDEVICE_BUTTON_INFO;

typedef struct _INITINFO {
    HANDLE hDeviceDataHandle;
    TCHAR *szModuleFileName;
    CHAR *szCreateFileName;
    HKEY hKEY;
}INITINFO,*PINITINFO;

typedef struct _INTERRUPTEVENTINFO {
    CHAR   *szDeviceName;
    HANDLE *phSignalEvent;
    HANDLE hShutdownEvent;
    GUID   *pguidEvent;
}INTERRUPTEVENTINFO,*PINTERRUPTEVENTINFO;

typedef struct _WIAPROPERTIES {
    LONG                NumItemProperties;    // Number of item properties
    LPOLESTR            *pszItemDefaults;     // item property names
    PROPID              *piItemDefaults;      // item property ids
    PROPVARIANT         *pvItemDefaults;      // item property prop variants
    PROPSPEC            *psItemDefaults;      // item property propspecs
    WIA_PROPERTY_INFO   *wpiItemDefaults;     // item property attributes

    // valid values
    LONG                NumSupportedFormats;  // Number of supported formats
    LONG                NumSupportedTYMED;    // Number of supported TYMED
    LONG                NumInitialFormats;    // Number of Initial formats
    LONG                NumSupportedDataTypes;// Number of supported data types
    LONG                NumSupportedIntents;  // Number of supported intents
    LONG                NumSupportedCompressionTypes; // Number of supported compression types
    LONG                NumSupportedResolutions;// Number of supported resolutions
    LONG                NumSupportedPreviewModes;// Number of supported preview modes

    WIA_FORMAT_INFO     *pSupportedFormats;   // supported formats
    LONG                *pSupportedTYMED;     // supported TYMED
    GUID                *pInitialFormats;     // initial formats
    LONG                *pSupportedDataTypes; // supported data types
    LONG                *pSupportedIntents;   // supported intents
    LONG                *pSupportedCompressionTypes; // supported compression types
    LONG                *pSupportedResolutions;// supproted resolutions
    LONG                *pSupportedPreviewModes;// supported preview modes

    BOOL                bLegacyBWRestrictions;// backward compatible with older system

}WIAPROPERTIES,*PWIAPROPERTIES;

typedef struct _WIACAPABILITIES {
    PLONG pNumSupportedEvents;
    PLONG pNumSupportedCommands;
    WIA_DEV_CAP_DRV *pCapabilities;
}WIACAPABILITIES,*PWIACAPABILITIES;

class CScanAPI {
public:
    CScanAPI() :
        m_pIWiaLog(NULL) {

    }
    ~CScanAPI(){

    }

    IWiaLog  *m_pIWiaLog;            // WIA logging object

    virtual HRESULT SetLoggingInterface(IWiaLog *pLogInterface){
        if(pLogInterface){
            m_pIWiaLog = pLogInterface;
        } else {
            return E_INVALIDARG;
        }
        return S_OK;
    }

    // data acquisition functions
    virtual HRESULT Scan(LONG lState, PBYTE pData, DWORD dwBytesToRead, PDWORD pdwBytesWritten){
        return E_NOTIMPL;
    }
    virtual HRESULT SetDataType(LONG lDataType){
        return E_NOTIMPL;
    }
    virtual HRESULT SetXYResolution(LONG lXResolution, LONG lYResolution){
        return E_NOTIMPL;
    }
    virtual HRESULT SetSelectionArea(LONG lXPos, LONG lYPos, LONG lXExt, LONG lYExt){
        return E_NOTIMPL;
    }
    virtual HRESULT SetContrast(LONG lContrast){
        return E_NOTIMPL;
    }
    virtual HRESULT SetIntensity(LONG lIntensity){
        return E_NOTIMPL;
    }
    virtual HRESULT ResetDevice(){
        return E_NOTIMPL;
    }
    virtual HRESULT SetEmulationMode(LONG lDeviceMode){
        return E_NOTIMPL;
    }
    virtual HRESULT DisableDevice(){
        return E_NOTIMPL;
    }
    virtual HRESULT EnableDevice(){
        return E_NOTIMPL;
    }
    virtual HRESULT DeviceOnline(){
        return E_NOTIMPL;
    }
    virtual HRESULT GetDeviceEvent(GUID *pEvent){
        return E_NOTIMPL;
    }
    virtual HRESULT Diagnostic(){
        return E_NOTIMPL;
    }
    virtual HRESULT Initialize(PINITINFO pInitInfo){
        return E_NOTIMPL;
    }
    virtual HRESULT UnInitialize(){
        return E_NOTIMPL;
    }
    virtual HRESULT DoInterruptEventThread(PINTERRUPTEVENTINFO pEventInfo){
        return E_NOTIMPL;
    }
    virtual HRESULT ADFAttached(){
        return E_NOTIMPL;
    }
    virtual HRESULT ADFHasPaper(){
        return E_NOTIMPL;
    }
    virtual HRESULT ADFAvailable(){
        return E_NOTIMPL;
    }
    virtual HRESULT ADFFeedPage(){
        return E_NOTIMPL;
    }
    virtual HRESULT ADFUnFeedPage(){
        return E_NOTIMPL;
    }
    virtual HRESULT ADFStatus(){
        return E_NOTIMPL;
    }
    virtual HRESULT QueryButtonPanel(PDEVICE_BUTTON_INFO pButtonInformation){
        return E_NOTIMPL;
    }
    virtual HRESULT BuildRootItemProperties(PWIAPROPERTIES pProperties){
        return E_NOTIMPL;
    }
    virtual HRESULT BuildTopItemProperties(PWIAPROPERTIES pProperties){
        return E_NOTIMPL;
    }
    virtual HRESULT BuildCapabilities(PWIACAPABILITIES pCapabilities){
        return E_NOTIMPL;
    }
    virtual HRESULT GetBedWidthAndHeight(PLONG pWidth, PLONG pHeight){
        return E_NOTIMPL;
    }
    virtual HRESULT SetResolutionRestrictionString(TCHAR *szResolutions){
        return E_NOTIMPL;
    }
    virtual HRESULT SetScanMode(INT iScanMode){
        return E_NOTIMPL;
    }
    virtual HRESULT SetSTIDeviceHKEY(HKEY *pHKEY){
        return E_NOTIMPL;
    }
    virtual HRESULT GetSupportedFileFormats(GUID **ppguid, LONG *plNumSupportedFormats){
        return E_NOTIMPL;
    }
    virtual HRESULT GetSupportedMemoryFormats(GUID **ppguid, LONG *plNumSupportedFormats){
        return E_NOTIMPL;
    }
    virtual HRESULT IsColorDataBGR(BOOL *pbBGR){
        return E_NOTIMPL;
    }
    virtual HRESULT IsAlignmentNeeded(BOOL *pbALIGN){
        return E_NOTIMPL;
    }
    virtual HRESULT SetFormat(GUID *pguidFormat){
        return E_NOTIMPL;
    }
};

///////////////////////////////////////////////////////////////////////////////////
// MICRO DRIVER SYSTEM SUPPORT                                                   //
///////////////////////////////////////////////////////////////////////////////////

class CMicroDriverAPI :public CScanAPI {
public:
    CMicroDriverAPI();
    ~CMicroDriverAPI();

    CMICRO *m_pMicroDriver;         // Micro driver communication
    SCANINFO m_ScanInfo;            // ScanInfo structure
    TCHAR  m_szResolutions[255];    // restricted resolutions string
    BOOL   m_bDisconnected;         // device disconnected during operation

    HRESULT Scan(LONG lState, PBYTE pData, DWORD dwBytesToRead, PDWORD pdwBytesWritten);
    HRESULT SetDataType(LONG lDataType);
    HRESULT SetXYResolution(LONG lXResolution, LONG lYResolution);
    HRESULT SetSelectionArea(LONG lXPos, LONG lYPos, LONG lXExt, LONG lYExt);
    HRESULT SetContrast(LONG lContrast);
    HRESULT SetIntensity(LONG lIntensity);
    HRESULT ResetDevice();
    HRESULT SetEmulationMode(LONG lDeviceMode);
    HRESULT DisableDevice();
    HRESULT EnableDevice();
    HRESULT DeviceOnline();
    HRESULT GetDeviceEvent(GUID *pEvent);
    HRESULT Diagnostic();
    HRESULT Initialize(PINITINFO pInitInfo);
    HRESULT UnInitialize();
    HRESULT DoInterruptEventThread(PINTERRUPTEVENTINFO pEventInfo);
    HRESULT ADFAttached();
    HRESULT ADFHasPaper();
    HRESULT ADFAvailable();
    HRESULT ADFFeedPage();
    HRESULT ADFUnFeedPage();
    HRESULT ADFStatus();
    HRESULT QueryButtonPanel(PDEVICE_BUTTON_INFO pButtonInformation);
    HRESULT BuildRootItemProperties(PWIAPROPERTIES pProperties);
    HRESULT BuildTopItemProperties(PWIAPROPERTIES pProperties);
    HRESULT BuildCapabilities(PWIACAPABILITIES pCapabilities);
    HRESULT GetBedWidthAndHeight(PLONG pWidth, PLONG pHeight);
    HRESULT SetResolutionRestrictionString(TCHAR *szResolutions);
    HRESULT SetScanMode(INT iScanMode);
    HRESULT SetSTIDeviceHKEY(HKEY *pHKEY);
    HRESULT GetSupportedFileFormats(GUID **ppguid, LONG *plNumSupportedFormats);
    HRESULT GetSupportedMemoryFormats(GUID **ppguid, LONG *plNumSupportedFormats);
    HRESULT IsColorDataBGR(BOOL *pbBGR);
    HRESULT IsAlignmentNeeded(BOOL *pbALIGN);
    HRESULT SetFormat(GUID *pguidFormat);

    // helpers
    HRESULT MicroDriverErrorToWIAError(LONG lMicroDriverError);
    BOOL    IsValidRestriction(LONG **ppList, LONG *plNumItems, RANGEVALUEEX *pRangeValues);
    HRESULT DeleteAllProperties(PWIAPROPERTIES pProperties);
    HRESULT AllocateAllProperties(PWIAPROPERTIES pProperties);
};

///////////////////////////////////////////////////////////////////////////////////
// SCRIPT DRIVER SYSTEM SUPPORT                                                   //
///////////////////////////////////////////////////////////////////////////////////

class CScriptDriverAPI :public CScanAPI {
public:
    CScriptDriverAPI();
    ~CScriptDriverAPI();

    CIOBlock *m_pIOBlock;             // IO Communication Block

    HRESULT Scan(LONG lState, PBYTE pData, DWORD dwBytesToRead, PDWORD pdwBytesWritten);
    HRESULT SetDataType(LONG lDataType);
    HRESULT SetXYResolution(LONG lXResolution, LONG lYResolution);
    HRESULT SetSelectionArea(LONG lXPos, LONG lYPos, LONG lXExt, LONG lYExt);
    HRESULT SetContrast(LONG lContrast);
    HRESULT SetIntensity(LONG lIntensity);
    HRESULT ResetDevice();
    HRESULT SetEmulationMode(LONG lDeviceMode);
    HRESULT DisableDevice();
    HRESULT EnableDevice();
    HRESULT DeviceOnline();
    HRESULT GetDeviceEvent(GUID *pEvent);
    HRESULT Diagnostic();
    HRESULT Initialize(PINITINFO pInitInfo);
    HRESULT DoInterruptEventThread(PINTERRUPTEVENTINFO pEventInfo);
    HRESULT ADFAttached();
    HRESULT ADFHasPaper();
    HRESULT ADFAvailable();
    HRESULT ADFFeedPage();
    HRESULT ADFUnFeedPage();
    HRESULT ADFStatus();
    HRESULT QueryButtonPanel(PDEVICE_BUTTON_INFO pButtonInformation);
    HRESULT BuildRootItemProperties(PWIAPROPERTIES pProperties);
    HRESULT BuildTopItemProperties(PWIAPROPERTIES pProperties);
    HRESULT BuildCapabilities(PWIACAPABILITIES pCapabilities);
    HRESULT GetBedWidthAndHeight(PLONG pWidth, PLONG pHeight);
    HRESULT SetResolutionRestrictionString(TCHAR *szResolutions);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\wiafbdrv\wiafbdrv.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       wiafbdrv.cpp
*
*  VERSION:     1.0
*
*  DATE:        16 July, 2000
*
*  DESCRIPTION:
*   Implementation of the WIA flatbed scanner class factory and IUNKNOWN interface.
*
*******************************************************************************/

#include "pch.h"

#if !defined(dllexp)
#define DLLEXPORT __declspec( dllexport )
#endif

/*****************************************************************************
 *
 *      Globals
 *
 *****************************************************************************/

DWORD               g_cRef;            // USD reference counter.
HINSTANCE           g_hInst;           // DLL module instance.
CRITICAL_SECTION    g_csCOM;           // COM initialize syncronization.
IWiaLog            *g_pIWiaLog = NULL; // WIA Logging Interface

// Is COM initialized
BOOL    g_COMInitialized = FALSE;


/**************************************************************************\
* DllAddRef
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

void DllAddRef(void)
{
    InterlockedIncrement((LPLONG)&g_cRef);
}

/**************************************************************************\
* DllRelease
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

void DllRelease(void)
{
    InterlockedDecrement((LPLONG)&g_cRef);
}

/**************************************************************************\
* DllInitializeCOM
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

BOOL DllInitializeCOM(void)
{
    EnterCriticalSection(&g_csCOM);

    if (!g_COMInitialized) {
        if(SUCCEEDED(CoInitialize(NULL))) {
            g_COMInitialized = TRUE;
        }
    }
    LeaveCriticalSection(&g_csCOM);

    return g_COMInitialized;
}

/**************************************************************************\
* DllUnInitializeCOM
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

BOOL DllUnInitializeCOM(void)
{
    EnterCriticalSection(&g_csCOM);

    if(g_COMInitialized) {
        CoUninitialize();
        g_COMInitialized = FALSE;
    }

    LeaveCriticalSection(&g_csCOM);
    return TRUE;
}

/***************************************************************************\
*
*  CWIAScannerDeviceClassFactory
*
\****************************************************************************/

class CWIAScannerDeviceClassFactory : public IClassFactory
{
private:
    ULONG   m_cRef;

public:
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    STDMETHODIMP CreateInstance(
            /* [unique][in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

    STDMETHODIMP LockServer(
            /* [in] */ BOOL fLock);

    CWIAScannerDeviceClassFactory();
    ~CWIAScannerDeviceClassFactory();
};

/**************************************************************************\
* CWIAScannerDeviceClassFactory::CWIAScannerDeviceClassFactory(void)
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    None
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

CWIAScannerDeviceClassFactory::CWIAScannerDeviceClassFactory(void)
{
    // Constructor logic
    m_cRef = 0;

    WIAS_LTRACE(g_pIWiaLog,
                WIALOG_NO_RESOURCE_ID,
                WIALOG_LEVEL3,
                ("CWIAScannerDeviceClassFactory::CWIAScannerDeviceClassFactory, (creating)"));
}

/**************************************************************************\
* CWIAScannerDeviceClassFactory::~CWIAScannerDeviceClassFactory(void)
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    None
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

CWIAScannerDeviceClassFactory::~CWIAScannerDeviceClassFactory(void)
{
    // Destructor logic
    WIAS_LTRACE(g_pIWiaLog,
                WIALOG_NO_RESOURCE_ID,
                WIALOG_LEVEL3,
                ("CWIAScannerDeviceClassFactory::CWIAScannerDeviceClassFactory, (destroy)"));
//    WIA_DEBUG_DESTROY();
}

/**************************************************************************\
* CWIAScannerDeviceClassFactory::QueryInterface
*
*
*
* Arguments:
*
*   riid      -
*   ppvObject -
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDeviceClassFactory::QueryInterface(
    REFIID                      riid,
    void __RPC_FAR *__RPC_FAR   *ppvObject)
{
    *ppvObject = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IClassFactory)) {
        *ppvObject = (LPVOID)this;
        AddRef();
        return NOERROR;
    }
    return ResultFromScode(E_NOINTERFACE);
}

/**************************************************************************\
* CWIAScannerDeviceClassFactory::AddRef
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWIAScannerDeviceClassFactory::AddRef(void)
{
    DllAddRef();
    return ++m_cRef;
}

/**************************************************************************\
* CWIAScannerDeviceClassFactory::Release
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWIAScannerDeviceClassFactory::Release(void)
{
    DllRelease();
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }
    return m_cRef;
}

/**************************************************************************\
* CWIAScannerDeviceClassFactory::CreateInstance
*
*
*
* Arguments:
*
*    punkOuter -
*    riid,     -
*    ppvObject -
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDeviceClassFactory::CreateInstance(
    IUnknown __RPC_FAR          *punkOuter,
    REFIID                      riid,
    void __RPC_FAR *__RPC_FAR   *ppvObject)
{
    if (!IsEqualIID(riid, IID_IStiUSD) &&
        !IsEqualIID(riid, IID_IUnknown)) {
        return STIERR_NOINTERFACE;
    }

    // When created for aggregation, only IUnknown can be requested.
    if (punkOuter && !IsEqualIID(riid, IID_IUnknown)) {
        return CLASS_E_NOAGGREGATION;
    }

    CWIAScannerDevice   *pDev = NULL;
    HRESULT         hres;

    pDev = new CWIAScannerDevice(punkOuter);
    if (!pDev) {
        return STIERR_OUTOFMEMORY;
    }

    hres = pDev->PrivateInitialize();
    if(hres != S_OK) {
        delete pDev;
        return hres;
    }

    //  Move to the requested interface if we aren't aggregated.
    //  Don't do this if aggregated, or we will lose the private
    //  IUnknown and then the caller will be hosed.
    hres = pDev->NonDelegatingQueryInterface(riid,ppvObject);
    pDev->NonDelegatingRelease();

    return hres;
}

/**************************************************************************\
* CWIAScannerDeviceClassFactory::LockServer
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDeviceClassFactory::LockServer(BOOL fLock)
{
    if (fLock) {
        DllAddRef();
    } else {
        DllRelease();
    }
    return NOERROR;
}

/**************************************************************************\
* CWIAScannerDevice::NonDelegatingQueryInterface
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::NonDelegatingQueryInterface(
    REFIID  riid,
    LPVOID  *ppvObj)
{
    HRESULT hres = S_OK;

    if (!IsValid() || !ppvObj) {
        return STIERR_INVALID_PARAM;
    }

    *ppvObj = NULL;

    if (IsEqualIID( riid, IID_IUnknown )) {
        *ppvObj = static_cast<INonDelegatingUnknown*>(this);
    }
    else if (IsEqualIID( riid, IID_IStiUSD )) {
        *ppvObj = static_cast<IStiUSD*>(this);
    }
    else if (IsEqualIID( riid, IID_IWiaMiniDrv )) {
        *ppvObj = static_cast<IWiaMiniDrv*>(this);
    }
    else {
        hres =  STIERR_NOINTERFACE;
    }

    if (SUCCEEDED(hres)) {
        (reinterpret_cast<IUnknown*>(*ppvObj))->AddRef();
    }

    return hres;
}

/**************************************************************************\
* CWIAScannerDevice::NonDelegatingAddRef
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Object reference count.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWIAScannerDevice::NonDelegatingAddRef(void)
{
    return InterlockedIncrement((LPLONG)&m_cRef);
}

/**************************************************************************\
* CWIAScannerDevice::NonDelegatingRelease
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Object reference count.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWIAScannerDevice::NonDelegatingRelease(void)
{
    ULONG ulRef;

    ulRef = InterlockedDecrement((LPLONG)&m_cRef);

    if (!ulRef) {
        delete this;
    }
    return ulRef;
}

/**************************************************************************\
* CWIAScannerDevice::QueryInterface
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    return m_punkOuter->QueryInterface(riid,ppvObj);
}

/**************************************************************************\
* CWIAScannerDevice::AddRef
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWIAScannerDevice::AddRef(void)
{
    return m_punkOuter->AddRef();
}

/**************************************************************************\
* CWIAScannerDevice::Release
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWIAScannerDevice::Release(void)
{
    return m_punkOuter->Release();
}

/**************************************************************************\
* DllEntryPoint
*
*   Main library entry point. Receives DLL event notification from OS.
*
*       We are not interested in thread attaches and detaches,
*       so we disable thread notifications for performance reasons.
*
* Arguments:
*
*    hinst      -
*    dwReason   -
*    lpReserved -
*
* Return Value:
*
*    Returns TRUE to allow the DLL to load.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/


extern "C" DLLEXPORT BOOL APIENTRY DllEntryPoint(
    HINSTANCE   hinst,
    DWORD       dwReason,
    LPVOID      lpReserved)
{
    HRESULT hr = E_FAIL;
    switch (dwReason) {
        case DLL_PROCESS_ATTACH:
            g_hInst = hinst;
            DisableThreadLibraryCalls(hinst);
            __try {
                if(!InitializeCriticalSectionAndSpinCount(&g_csCOM, MINLONG)) {
                    return FALSE;
                }
            }
            __except(EXCEPTION_EXECUTE_HANDLER) {
                return FALSE;
            }
            break;

        case DLL_PROCESS_DETACH:
            if (g_cRef) {

            }

            DeleteCriticalSection(&g_csCOM);
            
            break;
    }
    return TRUE;
}

/**************************************************************************\
* DllCanUnloadNow
*
*   Determines whether the DLL has any outstanding interfaces.
*
* Arguments:
*
*    None
*
* Return Value:
*
*   Returns S_OK if the DLL can unload, S_FALSE if it is not safe to unload.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

extern "C" STDMETHODIMP DllCanUnloadNow(void)
{
    return g_cRef ? S_FALSE : S_OK;
}

/**************************************************************************\
* DllGetClassObject
*
*   Create an IClassFactory instance for this DLL. We support only one
*   class of objects, so this function does not need to go through a table
*   of supported classes, looking for the proper constructor.
*
* Arguments:
*
*    rclsid - The object being requested.
*    riid   - The desired interface on the object.
*    ppv    - Output pointer to object.
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

extern "C" STDAPI DllGetClassObject(
    REFCLSID    rclsid,
    REFIID      riid,
    LPVOID      *ppv)
{
    if (!ppv) {
        return ResultFromScode(E_FAIL);
    }

    if (!IsEqualCLSID(rclsid, CLSID_FlatbedScannerUsd) ) {
        return ResultFromScode(E_FAIL);
    }

    if (!IsEqualIID(riid, IID_IUnknown) &&
        !IsEqualIID(riid, IID_IClassFactory)) {
        return ResultFromScode(E_NOINTERFACE);
    }

    if (IsEqualCLSID(rclsid, CLSID_FlatbedScannerUsd)) {
        CWIAScannerDeviceClassFactory *pcf = new CWIAScannerDeviceClassFactory;
        if (pcf) {
            *ppv = (LPVOID)pcf;
        }
    }
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\wiafbdrv\validate.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       validate.cpp
*
*  VERSION:     1.0
*
*  DATE:        17 July, 2000
*
*  DESCRIPTION:
*
*******************************************************************************/

#include "pch.h"
extern HINSTANCE g_hInst;   // used for WIAS_LOGPROC macro

/**************************************************************************\
* ValidateDataTransferContext
*
*   Checks the data transfer context to ensure it's valid.
*
* Arguments:
*
*    pDataTransferContext - Pointer the data transfer context.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT CWIAScannerDevice::ValidateDataTransferContext(
    PMINIDRV_TRANSFER_CONTEXT pDataTransferContext)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "::ValidateDataTransferContext");

    if (pDataTransferContext->lSize != sizeof(MINIDRV_TRANSFER_CONTEXT)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ValidateDataTransferContext, invalid data transfer context"));
        return E_INVALIDARG;;
    }

    return S_OK;
}

/**************************************************************************\
* UpdateValidDepth
*
*   Helper that updates the valid value for depth based on the data type.
*
* Arguments:
*
*   pWiasContext    -   a pointer to the WiaItem context
*   lDataType   -   the value of the DataType property.
*   lDepth      -   the address of the variable where the Depth's new value
*                   will be returned.
*
* Return Value:
*
*   Status      -   S_OK if successful
*                   E_INVALIDARG if lDataType is unknown
*                   Errors are those returned by wiasReadPropLong,
*                   and wiasWritePropLong.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT CWIAScannerDevice::UpdateValidDepth(
    BYTE        *pWiasContext,
    LONG        lDataType,
    LONG        *lDepth)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::UpdateValidDepth");
    HRESULT hr = S_OK;
    LONG    pValidDepth[1];

    switch (lDataType) {
        case WIA_DATA_THRESHOLD:
            pValidDepth[0] = 1;
            break;
        case WIA_DATA_GRAYSCALE:
            pValidDepth[0] = 8;
            break;
        case WIA_DATA_COLOR:
            pValidDepth[0] = 24;
            break;
        default:
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("UpdateValidDepth, unknown data type"));
            return E_INVALIDARG;
    }

    if (lDepth) {
        *lDepth = pValidDepth[0];
    }

    return hr;
}

/**************************************************************************\
* CheckDataType
*
*   This helper method is called to check whether WIA_IPA_DATATYPE
*   property is changed.  When this property changes, other dependant
*   properties and their valid values must also be changed.
*
* Arguments:
*
*   pWiasContext    -   a pointer to the item context whose properties have
*                       changed.
*   pContext    -   a pointer to the property context (which indicates
*                   which properties are being written).
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT CWIAScannerDevice::CheckDataType(
    BYTE                    *pWiasContext,
    WIA_PROPERTY_CONTEXT    *pContext)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::CheckDataType");
    WIAS_CHANGED_VALUE_INFO cviDataType, cviDepth;
    HRESULT                 hr = S_OK;

    //
    //  Call wiasGetChangedValue for DataType. It is checked first since it's
    //  not dependant on any other property.  All properties in this method
    //  that follow are dependant properties of DataType.
    //
    //  The call to wiasGetChangedValue specifies that validation should not be
    //  skipped (since valid values for DataType never change).  Also,
    //  the address of a variable for the old value is NULL, since the old
    //  value is not needed.  The address of bDataTypeChanged is passed
    //  so that dependant properties will know whether the DataType is being
    //  changed or not.  This is important since dependant properties may need
    //  their valid values updated and may need to be folded to new valid
    //  values.
    //

    hr = wiasGetChangedValueLong(pWiasContext,
                                 pContext,
                                 FALSE,
                                 WIA_IPA_DATATYPE,
                                 &cviDataType);
    if (FAILED(hr)) {
        return hr;
    }

    //
    //  Call wiasGetChangedValue for Depth. Depth is a dependant property of
    //  DataType whose valid value changes according to what the current
    //  value of DataType is.
    //
    //  The call to wiasGetChangedValue specifies that validation should only
    //  be skipped if the DataType has changed.  This is because the valid
    //  values for Depth will change according to the new value for
    //  DataType.  The address of a variable for the old value is NULL, since
    //  the old value is not needed.  The address of bDepthChanged is passed
    //  so that dependant properties will know whether the Depth is being
    //  changed or not.  This is important since dependant properties may need
    //  their valid values updated and may need to be folded to new valid
    //  values.
    //

    hr = wiasGetChangedValueLong(pWiasContext,
                                 pContext,
                                 cviDataType.bChanged,
                                 WIA_IPA_DEPTH,
                                 &cviDepth);
    if (FAILED(hr)) {
        return hr;
    }

    if (cviDataType.bChanged) {

        //
        //  DataType changed so update valid value for Depth
        //

        hr = UpdateValidDepth(pWiasContext, cviDataType.Current.lVal, &cviDepth.Current.lVal);

        if (SUCCEEDED(hr)) {

            //
            //  Check whether we must fold.  Depth will only be folded if it
            //  is not one of the properties that the app is changing.
            //

            if (!cviDepth.bChanged) {
                hr = wiasWritePropLong(pWiasContext, WIA_IPA_DEPTH, cviDepth.Current.lVal);
            }
        }
    }

    //
    //  Update properties dependant on DataType and Depth.
    //  Here, ChannelsPerPixel and BitsPerChannel are updated.
    //

    if (cviDataType.bChanged || cviDepth.bChanged) {
        if (SUCCEEDED(hr)) {
            #define NUM_PROPS_TO_SET 2
            PROPSPEC    ps[NUM_PROPS_TO_SET] = {
                            {PRSPEC_PROPID, WIA_IPA_CHANNELS_PER_PIXEL},
                            {PRSPEC_PROPID, WIA_IPA_BITS_PER_CHANNEL}};
            PROPVARIANT pv[NUM_PROPS_TO_SET];

            for (LONG index = 0; index < NUM_PROPS_TO_SET; index++) {
                PropVariantInit(&pv[index]);
                pv[index].vt = VT_I4;
            }

            switch (cviDataType.Current.lVal) {
                case WIA_DATA_THRESHOLD:
                    pv[0].lVal = 1;
                    pv[1].lVal = 1;
                    break;

                case WIA_DATA_GRAYSCALE:
                    pv[0].lVal = 1;
                    pv[1].lVal = 8;
                    break;

                case WIA_DATA_COLOR:
                    pv[0].lVal = 3;
                    pv[1].lVal = 8;
                    break;

                default:
                    pv[0].lVal = 1;
                    pv[1].lVal = 8;
                    break;
            }
            hr = wiasWriteMultiple(pWiasContext, NUM_PROPS_TO_SET, ps, pv);
        }
    }

    return hr;
}

/**************************************************************************\
* CheckIntent
*
*   This helper method is called to make the relevant changes if the
*   Current Intent property changes.
*
* Arguments:
*
*   pWiasContext    -   a pointer to the item context whose properties have
*                       changed.
*   pContext    -   a pointer to the property context (which indicates
*                   which properties are being written).
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT CWIAScannerDevice::CheckIntent(
    BYTE            *pWiasContext,
    WIA_PROPERTY_CONTEXT *pContext)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::CheckIntent");
    HRESULT                 hr;
    WIAS_CHANGED_VALUE_INFO cviIntent;

    //
    //  Call wiasGetChangedValue for CurrentIntent. CurrentIntent is checked first
    //  since it's not dependant on any other property.  All properties in
    //  this method that follow are dependant properties of CurrentIntent.
    //
    //  The call to wiasGetChangedValue specifies that validation should not be
    //  skipped (since valid values for CurrentIntent never change). The
    //  address of the old value is specified as NULL, since it is not used.
    //  The address of bIntentChanged is passed so that dependant properties
    //  will know whether the YResolution is being changed or not.  This is
    //  important since dependant properties will need their valid values
    //  updated and may need to be folded to new valid values.
    //

    hr = wiasGetChangedValueLong(pWiasContext,
                                 pContext,
                                 FALSE,
                                 WIA_IPS_CUR_INTENT,
                                 &cviIntent);
    if (SUCCEEDED(hr)) {
        if (cviIntent.bChanged) {

            LONG lImageSizeIntent = (cviIntent.Current.lVal & WIA_INTENT_SIZE_MASK);
            LONG lImageTypeIntent = (cviIntent.Current.lVal & WIA_INTENT_IMAGE_TYPE_MASK);

            switch (lImageTypeIntent) {

                case WIA_INTENT_NONE:
                    break;

                case WIA_INTENT_IMAGE_TYPE_GRAYSCALE:
                    wiasWritePropLong(pWiasContext, WIA_IPA_DATATYPE, WIA_DATA_GRAYSCALE);
                    UpdateValidDepth (pWiasContext, WIA_DATA_GRAYSCALE, NULL);
                    wiasWritePropLong(pWiasContext, WIA_IPA_DEPTH, 8);
                    break;

                case WIA_INTENT_IMAGE_TYPE_TEXT:
                    wiasWritePropLong(pWiasContext, WIA_IPA_DATATYPE, WIA_DATA_THRESHOLD);
                    UpdateValidDepth (pWiasContext, WIA_DATA_THRESHOLD, NULL);
                    wiasWritePropLong(pWiasContext, WIA_IPA_DEPTH, 1);
                    break;

                case WIA_INTENT_IMAGE_TYPE_COLOR:
                    wiasWritePropLong(pWiasContext, WIA_IPA_DATATYPE, WIA_DATA_COLOR);
                    UpdateValidDepth(pWiasContext, WIA_DATA_COLOR, NULL);
                    wiasWritePropLong(pWiasContext, WIA_IPA_DEPTH, 24);
                    break;

                default:
                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CheckIntent, unknown intent (TYPE) = %d",lImageTypeIntent));
                    return E_INVALIDARG;

            }

            switch (lImageSizeIntent) {
            case WIA_INTENT_NONE:
                    break;
            case WIA_INTENT_MINIMIZE_SIZE:
            case WIA_INTENT_MAXIMIZE_QUALITY:
                {

                    //
                    // Set the X and Y Resolutions.
                    //

                    wiasWritePropLong(pWiasContext, WIA_IPS_XRES, lImageSizeIntent & WIA_INTENT_MINIMIZE_SIZE ? 150 : 300);
                    wiasWritePropLong(pWiasContext, WIA_IPS_YRES, lImageSizeIntent & WIA_INTENT_MINIMIZE_SIZE ? 150 : 300);

                    //
                    //  The Resolutions and DataType were set, so update the property
                    //  context to indicate that they have changed.
                    //

                    wiasSetPropChanged(WIA_IPS_XRES, pContext, TRUE);
                    wiasSetPropChanged(WIA_IPS_YRES, pContext, TRUE);
                    wiasSetPropChanged(WIA_IPA_DATATYPE, pContext, TRUE);

                    //
                    // Reset any device item properties which may have changed due to validation.
                    //

                    //
                    // update IPA_NUMBER_OF_LINES property
                    //

                    LONG lLength = 0;

                    hr = wiasReadPropLong(pWiasContext, WIA_IPS_YEXTENT, &lLength, NULL, TRUE);
                    if (SUCCEEDED(hr)) {
                        hr = wiasWritePropLong(pWiasContext, WIA_IPA_NUMBER_OF_LINES, lLength);
                        if (FAILED(hr)) {
                            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CheckIntent, could not write WIA_IPA_NUMBER_OF_LINES"));
                            return hr;
                        }
                    } else {
                        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CheckIntent, could not read WIA_IPS_YEXTENT"));
                        return hr;
                    }

                    //
                    // update IPA_PIXEL_PER_LINE property
                    //

                    LONG lWidth = 0;

                    hr = wiasReadPropLong(pWiasContext, WIA_IPS_XEXTENT, &lWidth, NULL, TRUE);
                    if (SUCCEEDED(hr)) {
                        hr = wiasWritePropLong(pWiasContext, WIA_IPA_PIXELS_PER_LINE, lWidth);
                        if (FAILED(hr)) {
                            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CheckIntent, could not write WIA_IPA_PIXELS_PER_LINE"));
                            return hr;
                        }
                    } else {
                        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CheckIntent, could not read WIA_IPS_XEXTENT"));
                        return hr;
                    }
                }
                break;
            default:
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CheckIntent, unknown intent (SIZE) = %d",lImageSizeIntent));
                return E_INVALIDARG;
            }
        }
    } else {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CheckIntent, wiasGetChangedValue (intent) failed"));
    }
    return hr;
}

/**************************************************************************\
* CheckPreferredFormat
*
*   This helper method is called to make the relevant changes if the
*   Format property changes.
*
* Arguments:
*
*   pWiasContext    -   a pointer to the item context whose properties have
*                       changed.
*   pContext    -   a pointer to the property context (which indicates
*                   which properties are being written).
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT CWIAScannerDevice::CheckPreferredFormat(
    BYTE            *pWiasContext,
    WIA_PROPERTY_CONTEXT *pContext)
{
    HRESULT hr = S_OK;

    //
    // update WIA_IPA_PREFERRED_FORMAT property
    //

    GUID FormatGUID;
    hr = wiasReadPropGuid(pWiasContext, WIA_IPA_FORMAT, &FormatGUID, NULL, TRUE);
    if (SUCCEEDED(hr)) {
        hr = wiasWritePropGuid(pWiasContext, WIA_IPA_PREFERRED_FORMAT, FormatGUID);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CheckPreferredFormat, could not write WIA_IPA_PREFERRED_FORMAT"));
            return hr;
        }
    } else {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CheckIntent, could not read WIA_IPA_FORMAT"));
    }
    return hr;
}

/**************************************************************************\
* CheckADFStatus
*
*
* Arguments:
*
*   pWiasContext - pointer to an Item.
*
* Return Value:
*
*    Byte count.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::CheckADFStatus(BYTE *pWiasContext,
                                         WIA_PROPERTY_CONTEXT *pContext)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::CheckADFStatus");

    if(!m_bADFAttached)
        return S_OK;

    HRESULT hr                 = S_OK;
    BYTE    *pRootItemCtx      = NULL;
    LONG    lDocHandlingSelect = FLATBED;

    //
    // get root item
    //

    hr = wiasGetRootItem(pWiasContext, &pRootItemCtx);
    if (SUCCEEDED(hr)) {

        //
        // read document handling select for validation
        //

        hr = wiasReadPropLong(pRootItemCtx,WIA_DPS_DOCUMENT_HANDLING_SELECT,&lDocHandlingSelect,NULL,FALSE);
        if (SUCCEEDED(hr)) {

            if (S_FALSE == hr) {
                lDocHandlingSelect = FLATBED; // default setting
            }

            if (lDocHandlingSelect & FEEDER) {
                // set to FEEDER, check hardware for status
                hr = m_pScanAPI->ADFAvailable();
                if (S_OK == hr) {
                    hr = wiasWritePropLong(pWiasContext, WIA_DPS_DOCUMENT_HANDLING_STATUS,FEED_READY);
                } else {
                    hr = wiasWritePropLong(pWiasContext, WIA_DPS_DOCUMENT_HANDLING_STATUS,PAPER_JAM);
                }
            } else if (lDocHandlingSelect & FLATBED) {
                // set to FLATBED
                hr = wiasWritePropLong(pWiasContext, WIA_DPS_DOCUMENT_HANDLING_STATUS,FLAT_READY);
            } else {
                // set to an invalid value
                hr = E_INVALIDARG;
            }

        } else {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CheckADFStatus, wiasReadPropLong (WIA_DPS_DOCUMENT_HANDLING_SELECT) Failed"));
            WIAS_LHRESULT(m_pIWiaLog,hr);
        }
    } else {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CheckADFStatus, wiasGetRootItem Failed"));
        WIAS_LHRESULT(m_pIWiaLog,hr);
    }
    return hr;
}

/**************************************************************************\
* CheckPreview
*
*
* Arguments:
*
*   pWiasContext - pointer to an Item.
*
* Return Value:
*
*    Byte count.
*
* History:
*
*    8/21/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::CheckPreview(BYTE *pWiasContext,
                                         WIA_PROPERTY_CONTEXT *pContext)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::CheckPreview");

    HRESULT hr = S_OK;

    BYTE    *pRootItemCtx   = NULL;
    LONG lPreview = 0;
    hr = wiasGetRootItem(pWiasContext, &pRootItemCtx);
    if (FAILED(hr)) {
        return E_FAIL;
    }

    hr = wiasReadPropLong(pRootItemCtx,
                          WIA_DPS_PREVIEW,
                          &lPreview,
                          NULL,
                          FALSE);
    if(hr == S_FALSE){
        // property does not exist...so return S_OK
        return S_OK;
    }

    if (SUCCEEDED(hr)) {
        switch (lPreview) {
        case WIA_FINAL_SCAN:
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("CheckPreview, Set to WIA_FINAL_SCAN"));
            hr = S_OK;
            break;
        case WIA_PREVIEW_SCAN:
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("CheckPreview, Set to WIA_PREVIEW_SCAN"));
            hr = S_OK;
            break;
        default:
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("CheckPreview, Set to invalid argument (%d)",lPreview));
            hr = E_INVALIDARG;
            break;
        }
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\wiafbdrv\wiafbdrv.h ===
/**************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       wiafbdrv.h
*
*  VERSION:     1.0
*
*  DATE:        18 July, 2000
*
*  DESCRIPTION:
*
*
***************************************************************************/

#include "pch.h"

typedef GUID* PGUID;

#if defined( _WIN32 ) && !defined( _NO_COM)
//////////////////////////////////////////////////////////////////////////
// GUID / CLSID definition section (for your specific device)           //
//                                                                      //
// IMPORTANT!! - REMEMBER TO CHANGE YOUR .INF FILE TO MATCH YOUR WIA    //
//               DRIVER'S CLSID!!                                       //
//                                                                      //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

// BB6CF8E2-1511-40bd-91BA-80D43C53064E
DEFINE_GUID(CLSID_FlatbedScannerUsd, 0xBB6CF8E2L, 0x1511, 0x40bd, 0x91, 0xBA, 0x80, 0xD4, 0x3C, 0x53, 0x06, 0x4E);

// {48A89A69-C08C-482a-B3E5-CD50B50B5DFA}
DEFINE_GUID(guidEventFirstLoaded,
0x48a89a69, 0xc08c, 0x482a, 0xb3, 0xe5, 0xcd, 0x50, 0xb5, 0xb, 0x5d, 0xfa);

#endif

//////////////////////////////////////////////////////////////////////////
// DLL #define Section                                                  //
//////////////////////////////////////////////////////////////////////////

#define DATASEG_PERINSTANCE     ".instance"
#define DATASEG_SHARED          ".shared"
#define DATASEG_READONLY        ".code"
#define DATASEG_DEFAULT         DATASEG_SHARED

#define ENTERCRITICAL   DllEnterCrit(void);
#define LEAVECRITICAL   DllLeaveCrit(void);

#pragma data_seg(DATASEG_PERINSTANCE)
#pragma data_seg(DATASEG_DEFAULT)

extern UINT g_cRefThisDll;
extern UINT g_cLocks;
extern BOOL DllInitializeCOM(void);
extern BOOL DllUnInitializeCOM(void);
extern void DllAddRef(void);
extern void DllRelease(void);

//
// Base structure for supporting non-delegating IUnknown for contained objects
//

struct INonDelegatingUnknown
{
    // IUnknown-like methods
    STDMETHOD(NonDelegatingQueryInterface)(THIS_
              REFIID riid,
              LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,NonDelegatingAddRef)(THIS) PURE;
    STDMETHOD_(ULONG,NonDelegatingRelease)( THIS) PURE;
};

// This sample WIA scanner supports a single scanning context.
#define NUM_DEVICE_ITEM     1

// Device item specific context.
typedef struct _MINIDRIVERITEMCONTEXT{
   LONG     lSize;
   LONG     lTotalWritten;                      // Total image bytes written.
   // Scan parameters:
   LONG     lDepth;                             // image bit depth
   LONG     lBytesPerScanLine;                  // bytes per scan line     (scanned data)
   LONG     lBytesPerScanLineRaw;               // bytes per scan line RAW (scanned data)
   LONG     lTotalRequested;                    // Total image bytes requested.
} MINIDRIVERITEMCONTEXT, *PMINIDRIVERITEMCONTEXT;

//
// Definitions controlling COLOR/BW support
//

#define NUM_DATA_TYPES_NONLEGACY 3
#define NUM_DATA_TYPES_LEGACY    2

//
// Class definition for sample WIA scanner object
//

class CWIAScannerDevice : public IStiUSD,               // STI USD interface
                          public IWiaMiniDrv,           // WIA Minidriver interface
                          public INonDelegatingUnknown  // NonDelegatingUnknown
{
public:

    /////////////////////////////////////////////////////////////////////////
    // Construction/Destruction Section                                    //
    /////////////////////////////////////////////////////////////////////////

    CWIAScannerDevice(LPUNKNOWN punkOuter);
    HRESULT PrivateInitialize();
    ~CWIAScannerDevice();

private:

    // COM object data
    ULONG               m_cRef;                 // Device object reference count.

    // STI information
    BOOL                m_fValid;               // Is object initialized?
    LPUNKNOWN           m_punkOuter;            // Pointer to outer unknown.
    PSTIDEVICECONTROL   m_pIStiDevControl;      // Device control interface.
    BOOLEAN             m_bUsdLoadEvent;        // Controls load event.
    DWORD               m_dwLastOperationError; // Last error.
    DWORD               m_dwLockTimeout;        // Lock timeout for LockDevice() calls
    BOOL                m_bDeviceLocked;        // device locked/unlocked
    CHAR                *m_pszDeviceNameA;      // CreateFileName for default RawRead/RawWrite handle
    HANDLE              m_DeviceDefaultDataHandle;//default RawRead/RawWrite handle

    // Event information
    CRITICAL_SECTION    m_csShutdown;           // Syncronizes shutdown.
    HANDLE              m_hSignalEvent;         // Signal event handle.
    HANDLE              m_hShutdownEvent;       // Shutdown event handle.
    HANDLE              m_hEventNotifyThread;   // Does event notification.
    GUID                m_guidLastEvent;        // Last event ID.

    // WIA information, one time initialization.
    BSTR                m_bstrDeviceID;         // WIA unique device ID.
    BSTR                m_bstrRootFullItemName; // Device name for prop streams.
    IWiaEventCallback   *m_pIWiaEventCallback;  // WIA event sink.
    IWiaDrvItem         *m_pIDrvItemRoot;       // The root item.
    IStiDevice          *m_pStiDevice;          // Sti object.

    HINSTANCE           m_hInstance;            // Module's HINSTANCE
    IWiaLog             *m_pIWiaLog;            // WIA logging object

    LONG                m_NumSupportedCommands; // Number of supported commands
    LONG                m_NumSupportedEvents;   // Number of supported events

    LONG                m_NumSupportedFormats;  // Number of supported formats
    LONG                m_NumCapabilities;      // Number of capabilities
    LONG                m_NumSupportedTYMED;    // Number of supported TYMED
    LONG                m_NumInitialFormats;    // Number of Initial formats
    LONG                m_NumSupportedDataTypes;// Number of supported data types
    LONG                m_NumSupportedIntents;  // Number of supported intents
    LONG                m_NumSupportedCompressionTypes; // Number of supported compression types
    LONG                m_NumSupportedResolutions; // Number of supported resolutions
    LONG                m_NumSupportedPreviewModes;// Number of supported preview modes

    WIA_FORMAT_INFO     *m_pSupportedFormats;   // supported formats
    WIA_DEV_CAP_DRV     *m_pCapabilities;       // capabilities
    LONG                *m_pSupportedTYMED;     // supported TYMED
    GUID                *m_pInitialFormats;     // initial formats
    LONG                *m_pSupportedDataTypes; // supported data types
    LONG                *m_pSupportedIntents;   // supported intents
    LONG                *m_pSupportedCompressionTypes; // supported compression types
    LONG                *m_pSupportedResolutions;// supported resolutions
    LONG                *m_pSupportedPreviewModes;// supported preview modes

    LONG                m_NumRootItemProperties;// Number of Root item properties
    LONG                m_NumItemProperties;    // Number of item properties

    LPOLESTR            *m_pszRootItemDefaults; // root item property names
    PROPID              *m_piRootItemDefaults;  // root item property ids
    PROPVARIANT         *m_pvRootItemDefaults;  // root item property prop variants
    PROPSPEC            *m_psRootItemDefaults;  // root item property propspecs
    WIA_PROPERTY_INFO   *m_wpiRootItemDefaults; // root item property attributes

    LPOLESTR            *m_pszItemDefaults;     // item property names
    PROPID              *m_piItemDefaults;      // item property ids
    PROPVARIANT         *m_pvItemDefaults;      // item property prop variants
    PROPSPEC            *m_psItemDefaults;      // item property propspecs
    WIA_PROPERTY_INFO   *m_wpiItemDefaults;     // item property attributes

    BOOL                m_bADFAttached;         // ADF attached

    BOOL                m_bTPAEnabled;          // TPA enabled
    BOOL                m_bTPAAttached;         // TPA attached

    LONG                m_MaxBufferSize;        // Maximum buffer for device
    LONG                m_MinBufferSize;        // Minimum buffer for device

    CScanAPI            *m_pScanAPI;            // Scanner device API class, (micro and script-based)
    BOOL                m_bLegacyBWRestriction; // flag to restrict devices to BW and Grayscale scanning only

    // inline member functions
    BOOL inline IsValid(VOID) {
        return m_fValid;
    }

public:

    /////////////////////////////////////////////////////////////////////////
    // Standard COM Section                                                //
    /////////////////////////////////////////////////////////////////////////

    STDMETHODIMP QueryInterface( REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef( void);
    STDMETHODIMP_(ULONG) Release( void);

    /////////////////////////////////////////////////////////////////////////
    // IStiUSD Interface Section (for all WIA drivers)                     //
    /////////////////////////////////////////////////////////////////////////

    //
    //  Methods for implementing the IStiUSD interface.
    //

    STDMETHOD(Initialize)(THIS_
        PSTIDEVICECONTROL pHelDcb,
        DWORD             dwStiVersion,
        HKEY              hParametersKey);

    STDMETHOD(GetCapabilities)(THIS_
        PSTI_USD_CAPS pDevCaps);

    STDMETHOD(GetStatus)(THIS_
        PSTI_DEVICE_STATUS pDevStatus);

    STDMETHOD(DeviceReset)(THIS);

    STDMETHOD(Diagnostic)(THIS_
        LPDIAG pBuffer);

    STDMETHOD(Escape)(THIS_
        STI_RAW_CONTROL_CODE EscapeFunction,
        LPVOID               lpInData,
        DWORD                cbInDataSize,
        LPVOID               pOutData,
        DWORD                dwOutDataSize,
        LPDWORD              pdwActualData);

    STDMETHOD(GetLastError)(THIS_
        LPDWORD pdwLastDeviceError);

    STDMETHOD(LockDevice)(THIS);

    STDMETHOD(UnLockDevice)(THIS);

    STDMETHOD(RawReadData)(THIS_
        LPVOID       lpBuffer,
        LPDWORD      lpdwNumberOfBytes,
        LPOVERLAPPED lpOverlapped);

    STDMETHOD(RawWriteData)(THIS_
        LPVOID       lpBuffer,
        DWORD        nNumberOfBytes,
        LPOVERLAPPED lpOverlapped);

    STDMETHOD(RawReadCommand)(THIS_
        LPVOID       lpBuffer,
        LPDWORD      lpdwNumberOfBytes,
        LPOVERLAPPED lpOverlapped);

    STDMETHOD(RawWriteCommand)(THIS_
        LPVOID       lpBuffer,
        DWORD        nNumberOfBytes,
        LPOVERLAPPED lpOverlapped);

    STDMETHOD(SetNotificationHandle)(THIS_
        HANDLE hEvent);

    STDMETHOD(GetNotificationData)(THIS_
        LPSTINOTIFY lpNotify);

    STDMETHOD(GetLastErrorInfo)(THIS_
        STI_ERROR_INFO *pLastErrorInfo);

    /////////////////////////////////////////////////////////////////////////
    // IWiaMiniDrv Interface Section (for all WIA drivers)                 //
    /////////////////////////////////////////////////////////////////////////

    //
    //  Methods for implementing WIA's Mini driver interface
    //

    STDMETHOD(drvInitializeWia)(THIS_
        BYTE        *pWiasContext,
        LONG        lFlags,
        BSTR        bstrDeviceID,
        BSTR        bstrRootFullItemName,
        IUnknown    *pStiDevice,
        IUnknown    *pIUnknownOuter,
        IWiaDrvItem **ppIDrvItemRoot,
        IUnknown    **ppIUnknownInner,
        LONG        *plDevErrVal);

    STDMETHOD(drvGetDeviceErrorStr)(THIS_
        LONG     lFlags,
        LONG     lDevErrVal,
        LPOLESTR *ppszDevErrStr,
        LONG     *plDevErr);

    STDMETHOD(drvDeviceCommand)(THIS_
        BYTE        *pWiasContext,
        LONG        lFlags,
        const GUID  *plCommand,
        IWiaDrvItem **ppWiaDrvItem,
        LONG        *plDevErrVal);

    STDMETHOD(drvAcquireItemData)(THIS_
        BYTE                      *pWiasContext,
        LONG                      lFlags,
        PMINIDRV_TRANSFER_CONTEXT pmdtc,
        LONG                      *plDevErrVal);

    STDMETHOD(drvInitItemProperties)(THIS_
        BYTE *pWiasContext,
        LONG lFlags,
        LONG *plDevErrVal);

    STDMETHOD(drvValidateItemProperties)(THIS_
        BYTE           *pWiasContext,
        LONG           lFlags,
        ULONG          nPropSpec,
        const PROPSPEC *pPropSpec,
        LONG           *plDevErrVal);

    STDMETHOD(drvWriteItemProperties)(THIS_
        BYTE                      *pWiasContext,
        LONG                      lFlags,
        PMINIDRV_TRANSFER_CONTEXT pmdtc,
        LONG                      *plDevErrVal);

    STDMETHOD(drvReadItemProperties)(THIS_
        BYTE           *pWiasContext,
        LONG           lFlags,
        ULONG          nPropSpec,
        const PROPSPEC *pPropSpec,
        LONG           *plDevErrVal);

    STDMETHOD(drvLockWiaDevice)(THIS_
        BYTE *pWiasContext,
        LONG lFlags,
        LONG *plDevErrVal);

    STDMETHOD(drvUnLockWiaDevice)(THIS_
        BYTE *pWiasContext,
        LONG lFlags,
        LONG *plDevErrVal);

    STDMETHOD(drvAnalyzeItem)(THIS_
        BYTE *pWiasContext,
        LONG lFlags,
        LONG *plDevErrVal);

    STDMETHOD(drvDeleteItem)(THIS_
        BYTE *pWiasContext,
        LONG lFlags,
        LONG *plDevErrVal);

    STDMETHOD(drvFreeDrvItemContext)(THIS_
        LONG lFlags,
        BYTE *pSpecContext,
        LONG *plDevErrVal);

    STDMETHOD(drvGetCapabilities)(THIS_
        BYTE            *pWiasContext,
        LONG            ulFlags,
        LONG            *pcelt,
        WIA_DEV_CAP_DRV **ppCapabilities,
        LONG            *plDevErrVal);

    STDMETHOD(drvGetWiaFormatInfo)(THIS_
        BYTE            *pWiasContext,
        LONG            lFlags,
        LONG            *pcelt,
        WIA_FORMAT_INFO **ppwfi,
        LONG            *plDevErrVal);

    STDMETHOD(drvNotifyPnpEvent)(THIS_
        const GUID *pEventGUID,
        BSTR       bstrDeviceID,
        ULONG      ulReserved);

    STDMETHOD(drvUnInitializeWia)(THIS_
        BYTE *pWiasContext);

    /////////////////////////////////////////////////////////////////////////
    // INonDelegating Interface Section (for all WIA drivers)              //
    /////////////////////////////////////////////////////////////////////////

    //
    //  IUnknown-like methods.  Needed in conjunction with normal IUnknown
    //  methods to implement delegating components.
    //

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) NonDelegatingAddRef();
    STDMETHODIMP_(ULONG) NonDelegatingRelease();

private:

    /////////////////////////////////////////////////////////////////////////
    // Private helper functions section (for your specific driver)         //
    /////////////////////////////////////////////////////////////////////////
    //                                                                     //
    // This section is for private helpers used for common WIA operations. //
    // These are custom to your driver.                                    //
    //                                                                     //
    //                                                                     //
    // -- WIA Item Management Helpers                                      //
    //    BuildItemTree()                                                  //
    //    DeleteItemTree()                                                 //
    //                                                                     //
    // -- WIA Property Management Helpers                                  //
    //    BuildRootItemProperties()                                        //
    //    BuildTopItemProperties()                                         //
    //                                                                     //
    // -- WIA Capability Management Helpers                                //
    //    BuildRootItemProperties()                                        //
    //    DeleteRootItemProperties()                                       //
    //    BuildTopItemProperties()                                         //
    //    DeleteTopItemProperties()                                        //
    //    BuildCapabilities()                                              //
    //    DeleteCapabilitiesArrayContents()                                //
    //    BuildSupportedFormats()                                          //
    //    DeleteSupportedFormatsArrayContents()                            //
    //    BuildSupportedDataTypes()                                        //
    //    DeleteSupportedDataTypesArrayContents()                          //
    //    BuildSupportedIntents()                                          //
    //    DeleteSupportedIntentsArrayContents()                            //
    //    BuildSupportedCompressions()                                     //
    //    DeleteSupportedCompressionsArrayContents()                       //
    //    BuildSupportedTYMED()                                            //
    //    DeleteSupportedTYMEDArrayContents()                              //
    //    BuildInitialFormats()                                            //
    //    DeleteInitialFormatsArrayContents()                              //
    //                                                                     //
    // -- WIA Validation Helpers                                           //
    //    CheckDataType()                                                  //
    //    CheckIntent()                                                    //
    //    CheckPreferredFormat()                                           //
    //    SetItemSize()                                                    //
    //    UpdateValidDepth()                                               //
    //    ValidateDataTransferContext()                                    //
    //                                                                     //
    // -- WIA Resource file Helpers                                        //
    //    GetBSTRResourceString()                                          //
    //    GetOLESTRResourceString()                                        //
    //                                                                     //
    // -- WIA Data acqusition Helpers                                      //
    //    ScanItem()                                                       //
    //    ScanItemCB()                                                     //
    //    SendBitmapHeader()                                               //
    //                                                                     //
    //                                                                     //
    //                                                                     //
    //                                                                     //
    //                                                                     //
    /////////////////////////////////////////////////////////////////////////

    HRESULT _stdcall BuildItemTree(void);

    HRESULT _stdcall DeleteItemTree(void);

    HRESULT BuildRootItemProperties();

    HRESULT DeleteRootItemProperties();

    HRESULT BuildTopItemProperties();

    HRESULT DeleteTopItemProperties();

    HRESULT BuildCapabilities();

    HRESULT DeleteCapabilitiesArrayContents();

    HRESULT BuildSupportedFormats();

    HRESULT DeleteSupportedFormatsArrayContents();

    HRESULT BuildSupportedDataTypes();

    HRESULT DeleteSupportedDataTypesArrayContents();

    HRESULT BuildSupportedIntents();

    HRESULT DeleteSupportedIntentsArrayContents();

    HRESULT BuildSupportedCompressions();

    HRESULT DeleteSupportedCompressionsArrayContents();

    HRESULT BuildSupportedPreviewModes();

    HRESULT DeleteSupportedPreviewModesArrayContents();

    HRESULT BuildSupportedTYMED();

    HRESULT DeleteSupportedTYMEDArrayContents();

    HRESULT BuildSupportedResolutions();

    HRESULT DeleteSupportedResolutionsArrayContents();

    HRESULT BuildInitialFormats();

    HRESULT DeleteInitialFormatsArrayContents();

    HRESULT CheckDataType(
        BYTE                 *pWiasContext,
        WIA_PROPERTY_CONTEXT *pContext);

    HRESULT CheckIntent(
        BYTE                 *pWiasContext,
        WIA_PROPERTY_CONTEXT *pContext);

    HRESULT CheckPreferredFormat(
        BYTE                 *pWiasContext,
        WIA_PROPERTY_CONTEXT *pContext);

    HRESULT CheckADFStatus(BYTE *pWiasContext,
                           WIA_PROPERTY_CONTEXT *pContext);

    HRESULT CheckPreview(BYTE *pWiasContext,
                         WIA_PROPERTY_CONTEXT *pContext);

    HRESULT UpdateValidDepth(
        BYTE *pWiasContext,
        LONG lDataType,
        LONG *lDepth);

    HRESULT ValidateDataTransferContext(
        PMINIDRV_TRANSFER_CONTEXT pDataTransferContext);

    HRESULT SetItemSize(
        BYTE *pWiasContext);

    HRESULT _stdcall ScanItem(
        PMINIDRIVERITEMCONTEXT,
        PMINIDRV_TRANSFER_CONTEXT,
        LONG*);

    HRESULT _stdcall ScanItemCB(
        PMINIDRIVERITEMCONTEXT,
        PMINIDRV_TRANSFER_CONTEXT,
        LONG*);

    HRESULT SendBitmapHeader(
        PMINIDRV_TRANSFER_CONTEXT pmdtc);

    HRESULT SendFilePreviewBitmapHeader(
        PMINIDRV_TRANSFER_CONTEXT pmdtc);

    HRESULT GetBSTRResourceString(
        LONG lLocalResourceID,
        BSTR *pBSTR,
        BOOL bLocal);

    HRESULT GetOLESTRResourceString(
        LONG lLocalResourceID,
        LPOLESTR *ppsz,
        BOOL bLocal);

    UINT AlignInPlace(
        PBYTE   pBuffer,
        LONG    cbWritten,
        LONG    lBytesPerScanLine,
        LONG    lBytesPerScanLineRaw);

    VOID VerticalFlip(
        PMINIDRIVERITEMCONTEXT     pDrvItemContext,
        PMINIDRV_TRANSFER_CONTEXT  pDataTransferContext);

    VOID SwapBuffer24(
        PBYTE pBuffer,
        LONG lByteCount);

    LONG GetPageCount(
        BYTE *pWiasContext);

    BOOL IsPreviewScan(
        BYTE *pWiasContext);

    BOOL IsADFEnabled(
        BYTE *pWiasContext);

public:
    HRESULT DoEventProcessing();
};

typedef CWIAScannerDevice *PWIASCANNERDEVICE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\wiascanr\pch.h ===
#ifndef _PCH_H
#define _PCH_H

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <objbase.h>

#include <sti.h>
#include <stiusd.h>
#include <wiamindr.h>

#ifdef USE_REAL_EVENTS

   #include <devioctl.h>
   #include <usbscan.h>

#endif // USE_REAL_EVENTS

#include "resource.h"
#include "wiaprop.h"
#include "scanapi.h"
#include "wiascanr.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\wiascanr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wiascanr.rc
//

// Device Events, and Commands (Name strings)
#define IDS_CMD_BUILD_DEVICE_TREE_NAME     100
#define IDS_CMD_SYNCRONIZE_NAME            101
#define IDS_EVENT_DEVICE_CONNECTED_NAME    102
#define IDS_EVENT_DEVICE_DISCONNECTED_NAME 103
#define IDS_EVENT_SCANBUTTON_NAME          104
#define IDS_EVENT_COPYBUTTON_NAME          105
#define IDS_EVENT_FAXBUTTON_NAME           106

// Device Events, and Commands (Description strings)
#define IDS_CMD_BUILD_DEVICE_TREE_DESC     200
#define IDS_CMD_SYNCRONIZE_DESC            201
#define IDS_EVENT_DEVICE_CONNECTED_DESC    202
#define IDS_EVENT_DEVICE_DISCONNECTED_DESC 203
#define IDS_EVENT_SCANBUTTON_DESC          204
#define IDS_EVENT_COPYBUTTON_DESC          205
#define IDS_EVENT_FAXBUTTON_DESC           206

#define IDS_ROOTITEM_NAME                  300
#define IDS_TOPITEM_NAME                   301

#define IDC_STATIC                      -1

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        700
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           700
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\wiascanr\istiusd.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       IStiUSD.cpp
*
*  VERSION:     1.0
*
*  DATE:        18 July, 2000
*
*  DESCRIPTION:
*   Implementation of the WIA sample scanner IStiUSD methods.
*
*******************************************************************************/
#include "pch.h"
#ifndef INITGUID
    #include <initguid.h>
#endif
extern HINSTANCE g_hInst;   // used for WIAS_LOGPROC macro

/**************************************************************************\
* CWIADevice::CWIADevice
*
*   Device class constructor
*
* Arguments:
*
*    None
*
* Return Value:
*
*    None
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

CWIADevice::CWIADevice(LPUNKNOWN punkOuter):
m_cRef(1),
m_punkOuter(NULL),
m_dwLastOperationError(0),
m_dwLockTimeout(DEFAULT_LOCK_TIMEOUT),
m_bDeviceLocked(FALSE),

m_hDeviceDataHandle(NULL),
m_bPolledEvent(FALSE),
m_hFakeEventKey(NULL),
m_guidLastEvent(GUID_NULL),

m_pIDrvItemRoot(NULL),
m_pStiDevice(NULL),
m_pIWiaLog(NULL),

m_bADFEnabled(FALSE),
m_bADFAttached(TRUE),
m_lClientsConnected(0),
m_pScanAPI(NULL),

m_NumSupportedFormats(0),
m_pSupportedFormats(NULL),
m_NumSupportedCommands(0),
m_NumSupportedEvents(0),
m_pCapabilities(NULL),
m_NumInitialFormats(0),
m_pInitialFormats(NULL)
{

    //
    // initialize internal structures
    //

    memset(&m_EventOverlapped,0,sizeof(m_EventOverlapped));
    memset(m_EventData,0,sizeof(m_EventData));
    memset(&m_SupportedTYMED,0,sizeof(m_SupportedTYMED));
    memset(&m_SupportedDataTypes,0,sizeof(m_SupportedDataTypes));
    memset(&m_SupportedIntents,0,sizeof(m_SupportedIntents));
    memset(&m_SupportedCompressionTypes,0,sizeof(m_SupportedCompressionTypes));
    memset(&m_SupportedResolutions,0,sizeof(m_SupportedResolutions));
    memset(&m_SupportedPreviewModes,0,sizeof(m_SupportedPreviewModes));
    memset(&m_RootItemInitInfo,0,sizeof(m_RootItemInitInfo));
    memset(&m_ChildItemInitInfo,0,sizeof(m_ChildItemInitInfo));

    // See if we are aggregated. If we are (almost always the case) save
    // pointer to the controlling Unknown , so subsequent calls will be
    // delegated. If not, set the same pointer to "this".
    if (punkOuter) {
        m_punkOuter = punkOuter;
    } else {
        // Cast below is needed in order to point to right virtual table
        m_punkOuter = reinterpret_cast<IUnknown*>(static_cast<INonDelegatingUnknown*>(this));
    }

#ifdef UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER

    //
    // since this driver supports a scanner that has only a feeder, the
    // ADF Enabled flag needs to be set to TRUE by default.  This will
    // control the behavior of DrvAcquireItemData() method.
    //

    m_bADFEnabled = TRUE;

#endif

}

/**************************************************************************\
* CWIADevice::~CWIADevice
*
*   Device class destructor
*
* Arguments:
*
*    None
*
* Return Value:
*
*    None
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

CWIADevice::~CWIADevice(void)
{
    SetNotificationHandle(NULL);

    //
    // WIA member destruction
    //

    // Tear down the driver item tree.
    if (m_pIDrvItemRoot) {
        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("~CWIADevice, Deleting Device Item Tree (this is OK)"));
        DeleteItemTree();
        m_pIDrvItemRoot = NULL;
    }

    // free any IO handles opened
    if (m_hDeviceDataHandle) {
        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("~CWIADevice, Closing DefaultDeviceDataHandle"));
        CloseHandle(m_hDeviceDataHandle);
        m_hDeviceDataHandle = NULL;
    }

    // Delete allocated arrays
    DeleteCapabilitiesArrayContents();
    DeleteSupportedIntentsArrayContents();

    if (m_pIWiaLog)
        m_pIWiaLog->Release();

    if (m_pScanAPI) {
        // disable fake scanner device
        m_pScanAPI->FakeScanner_DisableDevice();
        delete m_pScanAPI;
        m_pScanAPI = NULL;
    }
}

/**************************************************************************\
* CWIADevice::PrivateInitialize()
*
*   PrivateInitialize is called from the CreateInstance() method of the
*   WIA driver's class factory.  It is needed to initialize the WIA
*   driver object (CWIADevice).  If this initialization fails the
*   object will not be returned to the caller.  This prevents the creation
*   of a nonfunctional WIA device.
*
* Arguments:
*
*    None
*
* Return Value:
*
*    S_OK  - if the operation succeeded
*    E_xxx - Error code if the operation fails
*
\**************************************************************************/
HRESULT CWIADevice::PrivateInitialize()
{

    //
    // attempt to create the IWiaLog interface to log status and errors to
    // wiaservc.log file
    //

    HRESULT hr = CoCreateInstance(CLSID_WiaLog, NULL, CLSCTX_INPROC_SERVER,IID_IWiaLog,(void**)&m_pIWiaLog);
    if (S_OK == hr) {
        m_pIWiaLog->InitializeLog((LONG)(LONG_PTR)g_hInst);
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL1,("Logging COM object created successfully for wiascanr.dll"));
    } else {
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL1,("Logging COM object not be created successfully for wiascanr.dll (STI only?)"));
        hr = S_OK;
    }

    return hr;
}

/**************************************************************************\
* CWIADevice::Initialize
*
*   Initialize is called by the WIA service when the driver is first loaded.
*   Initialize is also called when a client uses the legacy STI APIs and
*   calls IStillImage::CreateDevice() method.
*
*   This method should initialize the WIA driver and the device for use.
*   WIA drivers can store the pIStiDevControl interface if it needs it at a
*   later time.  IStiDevControl::AddRef() must be called before storing this
*   interface.  If you do not need to store the interface, then ignore it.
*   DO NOT RELEASE the IStiDevControl interface if you have not called
*   IStiDevControl::AddRef() first.  This may cause unpredictable results.
*
*   The IStiDeviceControl interface is needed to get information about your
*   device's ports.  The port name used in a CreateFile call can be obtained
*   by calling the IStiDeviceControl::GetMyDevicePortName() method.
*
*   For devices on shared ports, such as serial port devices, opening the port
*   in Initialize() is not recommended.  The port should only be opened in calls
*   to IStiUsd::LockDevice().  The closing of the ports should be internally
*   controlled to provide fast access. (opening and closing in
*   LockDevice/UnLockDevice is very inefficent. CreateFile() could cause a delay
*   making the user's experience appear slow, and nonresponsive)
*
*   If this WIA driver can not support multiple CreateFile() calls on the same
*   device port, then the IStiDevControl::GetMyDeviceOpenMode() should be called.
*
*   The WIA driver should check the returned MODE value for the flag
*   STI_DEVICE_CREATE_DATA and open the port accordingly.
*
*   The following flags could be set:
*
*       STI_DEVICE_CREATE_STATUS - open port for status
*       STI_DEVICE_CREATE_DATA   - open port for data
*       STI_DEVICE_CREATE_BOTH   - open port for status and data
*
*    If the device port needs to be opened, a call to CreateFile() should be
*    used.  When opening a port the flag FILE_FLAG_OVERLAPPED should be used.
*    This will allow OVERLAPPED i/o to be used when access the device.  Using
*    OVERLAPPED i/o will help control responsive access to the hardware.  When
*    a problem is detected the WIA driver can call CancelIo() to stop all
*    current hardware access.
*
* Arguments:
*
*    pIStiDevControl - device interface used for obtaining port information
*    dwStiVersion    - STI version
*    hParametersKey  - HKEY for registry reading/writing
*
* Return Value:
*
*    S_OK - if the operation was successful
*    E_xxx - if the operation failed
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIADevice::Initialize(
                                          PSTIDEVICECONTROL   pIStiDevControl,
                                          DWORD               dwStiVersion,
                                          HKEY                hParametersKey)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIADevice::Initialize");

    if (!pIStiDevControl) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CWIADevice::Initialize, invalid device control interface"));
        return STIERR_INVALID_PARAM;
    }

    HRESULT hr = S_OK;

    //
    // Get the mode of the device to check why we were created.  status, data, or both...
    //

    DWORD dwMode = 0;
    hr = pIStiDevControl->GetMyDeviceOpenMode(&dwMode);
    if(FAILED(hr)){
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CWIADevice::Initialize, couldn't get device open mode"));
        return hr;
    }

    if(dwMode & STI_DEVICE_CREATE_DATA)
    {
        //
        // device is being opened for data
        //
    }

    if(dwMode & STI_DEVICE_CREATE_STATUS)
    {
        //
        // device is being opened for status
        //
    }

    if(dwMode & STI_DEVICE_CREATE_BOTH)
    {
        //
        // device is being opened for both data and status
        //
    }

    //
    // Get the name of the device port to be used in a call to CreateFile().
    //

    WCHAR szDevicePortNameW[MAX_PATH];
    memset(szDevicePortNameW,0,sizeof(szDevicePortNameW));

    hr = pIStiDevControl->GetMyDevicePortName(szDevicePortNameW,sizeof(szDevicePortNameW)/sizeof(WCHAR));
    if(FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CWIADevice::Initialize, couldn't get device port"));
        return hr;
    }

    //
    // uncomment the code block below to have the driver create the kernel mode file
    // handles and open a communication channel to the device.
    //

    /*

    //
    // Open kernel mode device driver. Use the FILE_FLAG_OVERLAPPED flag for proper cancellation
    // of kernel mode operations and asynchronous file IO.  The CancelIo() call will function
    // properly if this flag is used.  It is recommended to use this flag.
    //

    m_hDeviceDataHandle = CreateFileW(szDevicePortNameW,
                                     GENERIC_READ | GENERIC_WRITE,               // Access mask
                                     0,                                          // Share mode
                                     NULL,                                       // SA
                                     OPEN_EXISTING,                              // Create disposition
                                     FILE_ATTRIBUTE_SYSTEM|FILE_FLAG_OVERLAPPED, // Attributes
                                     NULL );

    m_dwLastOperationError = ::GetLastError();

    hr = (m_hDeviceDataHandle != INVALID_HANDLE_VALUE) ?
                S_OK : MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,m_dwLastOperationError);

    if (FAILED(hr)) {
        return hr;
    }

    */

    if (SUCCEEDED(hr)) {

        //
        // creation of fake scanner device is here.
        //


#ifdef UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER
        hr = CreateFakeScanner(&m_pScanAPI,UNKNOWN_FEEDER_ONLY_SCANNER_MODE);
#else
        hr = CreateFakeScanner(&m_pScanAPI,FLATBED_SCANNER_MODE);
#endif

        if (m_pScanAPI) {

            //
            // initialize fake scanner device
            //

            hr = m_pScanAPI->FakeScanner_Initialize();
        } else {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("Initialize, Could not create FakeScanner API object"));
            hr = E_OUTOFMEMORY;
            WIAS_LHRESULT(m_pIWiaLog, hr);
        }
    }


    //
    // Open DeviceData section to read driver specific information
    //

    HKEY hKey = hParametersKey;
    HKEY hOpenKey = NULL;
    if (RegOpenKeyEx(hKey,                     // handle to open key
                     TEXT("DeviceData"),       // address of name of subkey to open
                     0,                        // options (must be NULL)
                     KEY_QUERY_VALUE|KEY_READ, // just want to QUERY a value
                     &hOpenKey                 // address of handle to open key
                    ) == ERROR_SUCCESS) {



        //
        // This is where you read registry entries for your device.
        // The DeviceData section is the proper place to put this information.  Information about
        // your device should have been written using the WIA device's .INF installation file.
        // You can access this information from this location in the Registry.
        // The hParameters HKEY is owned by the WIA service.  DO NOT CLOSE THIS KEY.  Always close
        // any HKEYS opened by this WIA driver after you are finished.
        //

        //
        // close registry key when finished, reading DeviceData information.
        //

        RegCloseKey(hOpenKey);
    } else {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CWIADevice::Initialize, couldn't open DeviceData KEY"));
        return E_FAIL;
    }
    return hr;
}


/**************************************************************************\
* CWIADevice::GetCapabilities
*
*   GetCapabilities is called by the WIA service to obtain the USD's
*   capabilities.  The WIA driver should fill out the following fields in the
*   STI_USD_CAPS structure:
*
*   1. dwVersion field with STI_VERSION letting the WIA service know what
*      version of STI this driver supports.
*   2. dwGenericCaps field with supported capabilities of the WIA device.
*
*
* Arguments:
*
*   pUsdCaps    - Pointer to a STI_USD_CAPS USD capabilities structure.
*
* Return Value:
*
*    S_OK  - if the data can be written correctly
*    E_xxx - Error code if the operation fails
*
*
* Remarks:
*
*   This WIA driver sets the following capability flags:
*
*   1. STI_GENCAP_WIA - This driver supports WIA
*   2. STI_USD_GENCAP_NATIVE_PUSHSUPPORT - This driver supports push buttons
*   3. STI_GENCAP_NOTIFICATIONS - This driver requires the use of interrupt
*      events.
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIADevice::GetCapabilities(PSTI_USD_CAPS pUsdCaps)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIADevice::GetCapabilities");

    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if (!pUsdCaps) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CWIADevice::GetCapabilities, NULL parameter"));
        return E_INVALIDARG;
    }

    memset(pUsdCaps, 0, sizeof(STI_USD_CAPS));
    pUsdCaps->dwVersion     = STI_VERSION;      // STI verison
    pUsdCaps->dwGenericCaps = STI_GENCAP_WIA|   // WIA support
                              STI_USD_GENCAP_NATIVE_PUSHSUPPORT| // button support
                              STI_GENCAP_NOTIFICATIONS; // interrupt event support
    return S_OK;
}

/**************************************************************************\
* CWIADevice::GetStatus
*
*   GetStatus is called by the WIA service for two major operations:
*
*   1. Checking device ON-LINE status.
*   2. Polling for device events. (like a push button event)
*
*   Determining the operation request can be done by checking the StatusMask
*   field of the STI_DEVICE_STATUS structure.  The StatusMask field can be
*   any of the following requests. (STI_DEVSTATUS_ONLINE_STATE or
*   STI_DEVSTATUS_EVENTS_STATE)
*
*   STI_DEVSTATUS_ONLINE_STATE = check if the device is ON-LINE.
*
*   This operation request should be fill by setting the dwOnlinesState
*   field of the STI_DEVICE_STATUS structure.
*   Value that should be used are:
*
*       STI_ONLINESTATE_OPERATIONAL   - Device is ON-LINE and operational
*       STI_ONLINESTATE_OFFLINE       - Device is OFF-LINE and NOT operational
*       STI_ONLINESTATE_PENDING       - Device has I/O operations pending
*       STI_ONLINESTATE_ERROR         - Device is currently in an error state
*       STI_ONLINESTATE_PAUSED        - Device is paused
*       STI_ONLINESTATE_PAPER_JAM     - Device has a paper jam
*       STI_ONLINESTATE_PAPER_PROBLEM - Device has a paper problem
*       STI_ONLINESTATE_IO_ACTIVE     - Device is active, but not accepting
*                                       commands at this time
*       STI_ONLINESTATE_BUSY          - Device is busy
*       STI_ONLINESTATE_TRANSFERRING  - Device is currently transferring data
*       STI_ONLINESTATE_INITIALIZING  - Device is being initialized
*       STI_ONLINESTATE_WARMING_UP    - Device is warming up
*       STI_ONLINESTATE_USER_INTERVENTION - Device requires user intervention
*                                           to resolve a problem
*       STI_ONLINESTATE_POWER_SAVE    - Device is in power save mode
*
*
*   STI_DEVSTATUS_EVENTS_STATE = check for device events.
*
*   This operation request should be filled by setting the dwEventHandlingState
*   field of the STI_DEVICE_STATUS structure.
*   Values that should be used are:
*
*       STI_EVENTHANDLING_PENDING - Device has an event pending and is wanting
*                                   to report it to the WIA service.
*
*   It is always a good idea to clear the STI_EVENTHANDLING_PENDING flag from
*   the dwEventHandlingState member to make sure that it is properly set when
*   a device event occurs.
*
*   When the STI_EVENTHANDLING_PENDING is set the WIA service is signaled that
*   an event has occured in the WIA driver.  The WIA service calls the
*   GetNotificationData() entry point to get more information about the event.
*   GetNotificationData() is called for polled events and interrupt events.
*   This is where you should fill out the proper event information to return to
*   the WIA service.
*
*
* Arguments:
*
*   pDevStatus  - Pointer to a STI_DEVICE_STATUS device status structure.
*
* Return Value:
*
*   S_OK         - if the data can be written correctly
*   E_INVALIDARG - if an invalid parameter was passed in to the GetStatus
*                  method.
*   E_xxx        - Error code if the operation fails
*
*
* Remarks:
*
*   This WIA driver should set the m_guidLastEvent to the proper event GUID when
*   an event is detected.  It should also set the m_bPolledEvent flag to TRUE
*   indicating that the event was received from a "polled source" (the GetStatus()
*   call).  The m_guidLastEvent is checked at a later time when the WIA service
*   calls GetNotificationData().
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIADevice::GetStatus(PSTI_DEVICE_STATUS pDevStatus)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIADevice::GetStatus");

    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if(!pDevStatus)
    {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CWIADevice::GetStatus, NULL parameter"));
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    //
    // If we are asked, verify the device is online.
    //

    if (pDevStatus->StatusMask & STI_DEVSTATUS_ONLINE_STATE) {

        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("GetStatus, WIA is asking the device if we are ONLINE"));

        //
        // assume the device is OFF-LINE before continuing.  This will validate
        // that the on-line check was successful.
        //

        pDevStatus->dwOnlineState = STI_ONLINESTATE_OFFLINE;

        hr = m_pScanAPI->FakeScanner_DeviceOnline();
        if (SUCCEEDED(hr)) {
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("GetStatus, Device is ONLINE"));

            //
            // device is ON-LINE and operational
            //

            pDevStatus->dwOnlineState |= STI_ONLINESTATE_OPERATIONAL;
        } else {

            //
            // device is OFF-LINE and NOT operational
            //

            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("GetStatus, Device is OFFLINE"));
        }
    }

    //
    // If we are asked, verify state of an event handler (front panel buttons, user controlled attachments, etc..).
    //
    //
    // If your device requires polling, then this is where you would specify the event
    // result.
    //
    // *** It is not recommended to have polled events.  Interrupt events are better
    // for performance, and reliability.  See the SetNotificationsHandle() method for how to
    // implement interrupt events.
    //

    //
    // clear the dwEventHandlingState field first to make sure we are really setting
    // a pending event.
    //

    pDevStatus->dwEventHandlingState &= ~STI_EVENTHANDLING_PENDING;
    if (pDevStatus->StatusMask & STI_DEVSTATUS_EVENTS_STATE) {

        //
        // set the polled event source flag to true, because this will control the
        // behavior of the GetNotificationData() method.
        //

        m_bPolledEvent = TRUE;

        //
        // set the polled event result here, for the GetNotificationData() method to
        // read and report.
        //

        m_guidLastEvent = GUID_NULL;  // WIA_EVENT_SCAN_IMAGE is an example of an event GUID

        if (m_guidLastEvent != GUID_NULL) {

            //
            // if the event GUID is NOT GUID_NULL, set the STI_EVENTHANDLING_PENDING flag
            // letting the WIA service know that we have an event ready.  This will tell
            // the WIA service to call GetNotificationData() for the event specific information.
            //

            pDevStatus->dwEventHandlingState |= STI_EVENTHANDLING_PENDING;
        }
    }
    return S_OK;
}

/**************************************************************************\
* CWIADevice::DeviceReset
*
*   DeviceReset is called to reset the device to a power-on state.
*
* Arguments:
*
*   None
*
* Return Value:
*
*   S_OK  - if device reset was successful
*   E_xxx - Error code if the operation fails
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIADevice::DeviceReset(void)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIADevice::DeviceReset");
    if(!m_pScanAPI){
        return E_UNEXPECTED;
    }
    return m_pScanAPI->FakeScanner_ResetDevice();
}

/**************************************************************************\
* CWIADevice::Diagnostic
*
*   Diagnostic is called when the device needs to be tested.  The device
*   default property page "Test Device" button calls this method.
*
*   The WIA driver should set the following fields of the STI_DIAG structure:
*       sErrorInfo - error information contained in a STI_ERROR_INFO structure,
*                    detailing the test results of the the diagnostic method.
*                    The WIA device should set the following members:
*                       dwGenericError  - set to NOERROR if the device passed
*                                         the diagnostic test, or to an error
*                                         code if the device failed the test.
*                       dwVendorError   - set this to give more information
*                                         about the failure.  Remember that
*                                         this code is specific to this device
*                                         only.  The caller of Diagnostic will
*                                         not know the meaning of this vendor-
*                                         specific code.
*                       szExtendedErrorText - Extended error text.  This member
*                                             is limited to 255 characters.
*       dwBasicDiagCode - this code indicates the type of test to be performed.
*                         Currently this must be set to STI_DIAGCODE_HWPRESENCE.
*       dwVendorDiagCode - OPTIONAL - vendor supplied diagnostic test code.
*       dwStatusMask - RESERVED FOR FUTURE USE
*
* Arguments:
*
*    pBuffer    - Pointer to a STI_DIAG diagnostic result structure.
*
* Return Value:
*
*    S_OK  - if the data can be written correctly
*    E_xxx - Error code if the operation fails
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIADevice::Diagnostic(LPSTI_DIAG pBuffer)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIADevice::Diagnostic");
    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if(!pBuffer){
        return E_INVALIDARG;
    }

    if(!m_pScanAPI){
        return E_UNEXPECTED;
    }

    //
    // initialize response buffer
    //

    memset(&pBuffer->sErrorInfo,0,sizeof(pBuffer->sErrorInfo));

    //
    // This sample device does nothing during this diagnostic method call.
    // It is recommended to perform a quick test of the hardware to verify
    // that it is functional within operational parameters.
    //

    pBuffer->sErrorInfo.dwGenericError = NOERROR;
    pBuffer->sErrorInfo.dwVendorError  = 0;

    return m_pScanAPI->FakeScanner_Diagnostic();
}

/**************************************************************************\
* CWIADevice::Escape
*
*   Escape is called to pass information directly to the hardware.  This
*   method can be called directly using the original STI (legacy) APIs or
*   the IWiaItemExtras::Escape() method.
*   Any WIA application can obtain access to the IWiaItemExtras interface.
*   It is recommended that you validate all incoming and outgoing calls to
*   this method.
*
*   Recommended validation order:
*   1. validate the Function code first.  If it is not one your codes, fail
*      immediately.  This will help to prevent incorrect codes from being
*      processed in your driver.
*   2. validate the incoming buffer second.  If it is not valid, fail
*      immediately.  Bad incoming buffers coulsd crash the WIA driver.
*   3. validate the outgoing buffer third.  If it is not valid, fail
*      immediately.  If you can not complete the request by writing the
*      necessary data why process it?
*   4. validate the outgoing size buffer last.  This is important.  If you can
*      not write the amount of data you just wrote to the outgoing buffer
*      then that data can not be properly processed by the caller.
*
* Arguments:
*
*    EscapeFunction - Command to be issued.
*    pInData        - Input data to be passed with command.
*    cbInDataSize   - Size of input data.
*    pOutData       - Output data to be passed back from command.
*    cbOutDataSize  - Size of output data buffer.
*    pcbActualData  - Size of output data actually written.
*
* Return Value:
*
*    S_OK  - if the operation was successful
*    E_xxx - Error code if the operation fails
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIADevice::Escape(
                                      STI_RAW_CONTROL_CODE    EscapeFunction,
                                      LPVOID                  pInData,
                                      DWORD                   cbInDataSize,
                                      LPVOID                  pOutData,
                                      DWORD                   cbOutDataSize,
                                      LPDWORD                 pcbActualData)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIADevice::Escape");

    //
    // only process EscapeFunction codes that are known to your driver.
    // Any application can send escape calls to your driver using the
    // IWiaItemExtras interface Escape() method call.  The driver must
    // be prepared to validate all incoming calls to Escape().
    //

    //
    // since this driver does not support any escape functions it will reject all
    // incoming EscapeFunction codes.
    //
    // If your driver supports an EscapeFunction, then add your function code to the
    // switch statement, and set hr = S_OK.  This will allow the function to continue
    // to the incoming/outgoing buffer validation.
    //

    HRESULT hr = E_NOTIMPL;
    switch(EscapeFunction){
    case 0:
    default:
        break;
    }

    //
    // if an EscapeFunction code is supported, then first validate the incoming and
    // outgoing buffers.
    //

    if(S_OK == hr){

        //
        // validate the incoming data buffer
        //

        if(IsBadReadPtr(pInData,cbInDataSize)){
            hr = E_UNEXPECTED;
        }

        //
        // if the incoming buffer is valid, proceed to validate the
        // outgoing buffer
        //

        if(S_OK == hr){
            if(IsBadWritePtr(pOutData,cbOutDataSize)){
                hr = E_UNEXPECTED;
            } else {

                //
                // validate the outgoing size pointer
                //

                if(IsBadWritePtr(pcbActualData,sizeof(DWORD))){
                    hr = E_UNEXPECTED;
                }
            }
        }

        //
        // now that buffer validation is complete, proceed to process the proper
        // EscapeFunction code.
        //

        if (S_OK == hr) {

            //
            // only process a validated EscapeFunction code, and buffers
            //

        }
    }

    //
    // if your driver will not support this entry point then it needs to return
    // E_NOTIMPL. (error, not implemented)
    //

    return hr;
}

/**************************************************************************\
* CWIADevice::GetLastError
*
*   GetLastError is called to obtain the last operation error code reported
*   by the WIA device.  This is an error code that is specific to the WIA
*   driver.  If the caller wants more information about this error code then
*   they will call GetLastErrorInfo().  The GetLastErrorInfo() method is
*   responsible for adding more details about the requested error. (strings,
*   extended codes...etc)
*
* Arguments:
*
*    pdwLastDeviceError - Pointer to a DWORD indicating the last error code.
*
* Return Value:
*
*    S_OK  - if the data can be written correctly
*    E_xxx - Error code if the operation fails
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIADevice::GetLastError(LPDWORD pdwLastDeviceError)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIADevice::GetLastError");

    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if (!pdwLastDeviceError) {
        return E_INVALIDARG;
    }

    *pdwLastDeviceError = m_dwLastOperationError;
    return S_OK;
}

/**************************************************************************\
* CWIADevice::LockDevice
*
*   LockDevice is called to lock a WIA device for exclusive access.  This
*   method can be called directly by an application using the legacy STI
*   APIs, or by the WIA service.
*
*   A device should return STIERR_DEVICE_LOCKED if it has already been
*   locked by another client.  The WIA service will call LockDevice to
*   control the exclusive access to the WIA device.
*
*   Do not get this confused with drvLockWiaDevice().  IStiUsd::LockDevice
*   can get called directly by an appliation using the legacy STI APIs.
*   drvLockWiaDevice() is only called by the WIA service.  No appliation can
*   call drvLockWiaDevice().
*
* Arguments:
*
*    None
*
* Return Value:
*
*    S_OK  - if the device was successfully locked
*    STIERR_DEVICE_LOCKED - Error code if the device is already locked
*
* Remarks:
*
*    The WIA shell extension, which controls the visibility of a WIA device
*    in the "My Computer" and "Control Panel", calls LockDevice() directly.
*    This is used to lock the the device so the IStiUsd::Diagnostic() method
*    can get called when the user presses the "TEST Device" button.
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIADevice::LockDevice(void)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIADevice::LockDevice");
    //
    // be very careful about how long locks are held.  An application can
    // come in using the STI APIs only, and lock your device.  This lock,
    // if held indefinitly could prevent access to your device from other
    // applications installed on the system.

    //
    // It might be useful to implement some sort of reasonable locking timeout
    // mechanism.  If a lock is held too long, then it should be auto-unlocked.
    // to allow others to access the device.
    // *** This should only be done, if you know it is safe to unlock your hardware.
    // Cases that may take a long time (like HUGE scans) can hold a lock for the entire
    // length.  A good question to ask in a long-locking case, is, "what is my driver
    // doing, that requires such a long locking time?"
    //

    HRESULT hr = S_OK;
    if (m_bDeviceLocked) {
        hr = STIERR_DEVICE_LOCKED;
    } else {
        m_bDeviceLocked = TRUE;
    }
    return hr;
}

/**************************************************************************\
* CWIADevice::UnLockDevice
*
*   UnLockDevice is called to unlock a WIA device from exclusive access.  This
*   method can be called directly by an application using the legacy STI
*   APIs, or by the WIA service.
*
*   A device should return STIERR_NEEDS_LOCK if it has not already been
*   locked by another client.  The WIA service will call UnLockDevice to
*   release exclusive access to the WIA device.
*
*   Do not get this confused with drvUnLockWiaDevice().  IStiUsd::UnLockDevice
*   can get called directly by an appliation using the legacy STI APIs.
*   drvUnLockWiaDevice() is only called by the WIA service.  No appliation can
*   call drvUnLockWiaDevice().
*
* Arguments:
*
*    None
*
* Return Value:
*
*    S_OK  - if the device was successfully locked
*    STIERR_NEEDS_LOCK - Error code if the device isn't already locked
*
* Remarks:
*
*    The WIA shell extension, which controls the visibility of a WIA device
*    in the "My Computer" and "Control Panel", calls UnLockDevice() directly.
*    (see IStiUsd::LockDevice() for details)
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIADevice::UnLockDevice(void)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIADevice::UnLockDevice");
    HRESULT hr = S_OK;
    if (!m_bDeviceLocked)
        hr = STIERR_NEEDS_LOCK;
    else {
        m_bDeviceLocked = FALSE;
    }
    return hr;
}

/**************************************************************************\
* CWIADevice::RawReadData
*
*   RawReadData is called to access the hardware directly.  Any application
*   that uses the legacy STI APIs can call RawReadData().  This method is
*   used when an application (useally a vendor-supplied application or library)
*   wants to read data from an open device port (controlled by this WIA driver).
*
* Arguments:
*
*    lpBuffer          - buffer for returned data
*    lpdwNumberOfBytes - number of bytes to read/returned
*    lpOverlapped      - overlap
*
* Return Value:
*
*    S_OK - if the read was successful
*    E_xxx - if the operation failed
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIADevice::RawReadData(
                                           LPVOID       lpBuffer,
                                           LPDWORD      lpdwNumberOfBytes,
                                           LPOVERLAPPED lpOverlapped)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIADevice::RawReadData");

    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if(!lpdwNumberOfBytes){
        return E_INVALIDARG;
    }

    DWORD dwNumberOfBytes = *lpdwNumberOfBytes;

    if(!lpBuffer){
        return E_INVALIDARG;
    }

    //
    // lpOverlapped is used by a call to ReadFile, or DeviceIOControl call.  This
    // parameter can be NULL according to those APIs.
    //

    HRESULT hr = E_NOTIMPL;

    //
    // if your driver will not support this entry point then it needs to return
    // E_NOTIMPL. (error, not implemented)
    //

    return hr;
}

/**************************************************************************\
* CWIADevice::RawWriteData
*
*   RawWriteData is called to access the hardware directly.  Any application
*   that uses the legacy STI APIs can call RawWriteData().  This method is
*   used when an application (useally a vendor-supplied application or library)
*   wants to write data to an open device port (controlled by this WIA driver).
*
* Arguments:
*
*    lpBuffer        - buffer for returned data
*    dwNumberOfBytes - number of bytes to write
*    lpOverlapped    - overlap
*
* Return Value:
*
*    S_OK - if the write was successful
*    E_xxx - if the operation failed
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIADevice::RawWriteData(
                                            LPVOID          lpBuffer,
                                            DWORD           dwNumberOfBytes,
                                            LPOVERLAPPED    lpOverlapped)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIADevice::RawWriteData");
    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if(!lpBuffer){
        return E_INVALIDARG;
    }

    //
    // lpOverlapped is used by a call to ReadFile, or DeviceIOControl call.  This
    // parameter can be NULL according to those APIs.
    //

    HRESULT hr = E_NOTIMPL;

    //
    // if your driver will not support this entry point then it needs to return
    // E_NOTIMPL. (error, not implemented)
    //

    return hr;
}

/**************************************************************************\
* CWIADevice::RawReadCommand
*
*   RawReadCommand is called to access the hardware directly.  Any application
*   that uses the legacy STI APIs can call RawReadCommand().  This method is
*   used when an application (useally a vendor-supplied application or library)
*   wants to read data from an open device port (controlled by this WIA driver).
*
* Arguments:
*
*    lpBuffer          - buffer for returned data
*    lpdwNumberOfBytes - number of bytes to read/returned
*    lpOverlapped      - overlap
*
* Return Value:
*
*    S_OK - if the read was successful
*    E_xxx - if the operation failed
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIADevice::RawReadCommand(
                                              LPVOID          lpBuffer,
                                              LPDWORD         lpdwNumberOfBytes,
                                              LPOVERLAPPED    lpOverlapped)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIADevice::RawReadCommand");
    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if(!lpdwNumberOfBytes){
        return E_INVALIDARG;
    }

    DWORD dwNumberOfBytes = *lpdwNumberOfBytes;

    if(!lpBuffer){
        return E_INVALIDARG;
    }

    //
    // lpOverlapped is used by a call to ReadFile, or DeviceIOControl call.  This
    // parameter can be NULL according to those APIs.
    //

    HRESULT hr = E_NOTIMPL;

    //
    // if your driver will not support this entry point then it needs to return
    // E_NOTIMPL. (error, not implemented)
    //

    return hr;
}

/**************************************************************************\
* CWIADevice::RawWriteCommand
*
*   RawWriteCommand is called to access the hardware directly.  Any application
*   that uses the legacy STI APIs can call RawWriteCommand().  This method is
*   used when an application (useally a vendor-supplied application or library)
*   wants to write data to an open device port (controlled by this WIA driver).
*
* Arguments:
*
*    lpBuffer       - buffer for returned data
*    nNumberOfBytes - number of bytes to write
*    lpOverlapped   - overlap
*
* Return Value:
*
*    S_OK - if the write was successful
*    E_xxx - if the operation failed
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIADevice::RawWriteCommand(
                                               LPVOID          lpBuffer,
                                               DWORD           dwNumberOfBytes,
                                               LPOVERLAPPED    lpOverlapped)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIADevice::RawWriteCommand");
    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if(!lpBuffer){
        return E_INVALIDARG;
    }

    //
    // lpOverlapped is used by a call to ReadFile, or DeviceIOControl call.  This
    // parameter can be NULL according to those APIs.
    //

    HRESULT hr = E_NOTIMPL;

    //
    // if your driver will not support this entry point then it needs to return
    // E_NOTIMPL. (error, not implemented)
    //

    return hr;
}

/**************************************************************************\
* CWIADevice::SetNotificationHandle
*
*   SetNotificationHandle is called by the WIA service or internally by this
*   driver to start or stop event notifications.  The WIA service will pass
*   in a valid handle (created using CreateEvent() ), indicating that it
*   wants the WIA driver to signal this handle when an event occurs in the
*   hardware.
*
*   NULL can be passed to this SetNotificationHandle() method.  NULL
*   indicates that the WIA driver is to STOP all device activity, and exit
*   any event wait operations.
*
* Arguments:
*
*    hEvent -   HANDLE to an event created by the WIA service using CreateEvent()
*               This parameter can be NULL, indicating that all previous event
*               waiting should be stopped.
*
* Return Value:
*
*    S_OK - if the operation was successful
*    E_xxx - Error Code if the operation fails
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIADevice::SetNotificationHandle(HANDLE hEvent)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIADevice::SetNotificationHandle");

    HRESULT hr = S_OK;

    if (hEvent && (hEvent != INVALID_HANDLE_VALUE)) {

        //
        // A valid handle indicates that we are asked to start our "wait"
        // for device interrupt events
        //

        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetNotificationHandle, hEvent = %d",hEvent));

        //
        // reset last event GUID to GUID_NULL
        //

        m_guidLastEvent = GUID_NULL;

        //
        // clear EventOverlapped structure
        //

        memset(&m_EventOverlapped,0,sizeof(m_EventOverlapped));

        //
        // fill overlapped hEvent member with the event passed in by the WIA service.
        // This handle will be automatically signaled when an event is triggered at
        // the hardware level.
        //

        m_EventOverlapped.hEvent = hEvent;

        //
        // clear event data buffer.  This is the buffer that will be used to determine
        // what event was signaled from the device.
        //

        memset(m_EventData,0,sizeof(m_EventData));

        //
        // the code block below starts an interrupt event session using DeviceIoControl()
        //

#ifdef USE_REAL_EVENTS

        //
        // use the following call for interrupt events on your device
        //

        DWORD dwError = 0;
        BOOL bResult = DeviceIoControl( m_hDeviceDataHandle,
                                        IOCTL_WAIT_ON_DEVICE_EVENT,
                                        NULL,
                                        0,
                                        &m_EventData,
                                        sizeof(m_EventData),
                                        &dwError,
                                        &m_EventOverlapped );

        if (bResult) {
            hr = S_OK;
        } else {
            hr = HRESULT_FROM_WIN32(::GetLastError());
        }

#else // USE_REAL_EVENTS

        //
        // THIS IS FOR TESTING ONLY, DO NOT USE THIS METHOD FOR PROCESSING DEVICE EVENTS!!!
        //

        if (m_hFakeEventKey) {
            RegCloseKey(m_hFakeEventKey);
            m_hFakeEventKey = NULL;
        }

        DWORD dwDisposition = 0;
        if (RegCreateKeyEx(HKEY_CURRENT_USER,
                           HKEY_WIASCANR_FAKE_EVENTS,
                           0,
                           NULL,
                           0,
                           KEY_READ,
                           NULL,
                           &m_hFakeEventKey,
                           &dwDisposition) == ERROR_SUCCESS) {

            if (RegNotifyChangeKeyValue(
                                       m_hFakeEventKey,            // handle to key to watch
                                       FALSE,                      // subkey notification option
                                       REG_NOTIFY_CHANGE_LAST_SET, // changes to be reported
                                       m_EventOverlapped.hEvent,   // handle to event to be signaled
                                       TRUE                        // asynchronous reporting option
                                       ) == ERROR_SUCCESS ) {


            }
        }

#endif // USE_REAL_EVENTS

    } else {

        //
        // stop any hardware waiting events here, the WIA service has notified us to kill
        // all hardware event waiting
        //

        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetNotificationHandle, Disabling event Notifications"));

#ifdef USE_REAL_EVENTS

        //
        // Stop hardware interrupt events.  This will actually stop all activity on the device.
        // Since DeviceIOControl was used with OVERLAPPED i/o functionality the CancelIo()
        // can be used to stop all kernel mode activity.
        //

        //
        // NOTE: It is important to use overlapped i/o calls with all activity involving the
        //       kernel mode drivers.  This will allow for proper time-outs and cancellation
        //       of device requests.
        //

        if(m_hDeviceDataHandle){
            if(!CancelIo(m_hDeviceDataHandle)){

                //
                // cancelling of the IO failed, call GetLastError() here to determine the cause.
                //

                LONG lError = ::GetLastError();

            }
        }

#else   // USE_REAL_EVENTS

        if (m_hFakeEventKey) {
            RegCloseKey(m_hFakeEventKey);
            m_hFakeEventKey = NULL;
        }

#endif  // USE_REAL_EVENTS

    }
    return hr;
}

/**************************************************************************\
* CWIADevice::GetNotificationData
*
*   GetNotificationData is called by the WIA service to get information about
*   an event that has just been signaled.  GetNotificationsData can be called
*   as a result of one of two event operations.
*
*   1. GetStatus() reported that there was an event pending, by setting the
*      STI_EVENTHANDLING_PENDING flag in the STI_DEVICE_STATUS structure.
*
*   2. The hEvent handle passed in by SetNotificationHandle() was signaled
*      by the hardware, or by calling SetEvent() directly.
*
*   The WIA driver is responsible for filling out the STINOTIFY structure
*   members:
*       dwSize - size of the STINOTIFY structure.
*       guidNotificationCode - GUID that represents the event that is to be
*                              responded to.  This should be set to GUID_NULL
*                              if no event is to be sent.  This will tell the
*                              WIA service that no event really happened.
*       abNotificationData - OPTIONAL - vendor specific information. This data
*                            is limited to 64 bytes of data ONLY.
*
* Arguments:
*
*    pBuffer    - Pointer to a STINOTIFY structure.
*
* Return Value:
*
*    S_OK  - if the data can be written successfully
*    E_xxx - Error code if the operation fails
*
* Remarks:
*
*   This WIA driver checks the m_bPolledEvent flag to determine where to get
*   the event information from.  If this flag is TRUE, it uses the event GUID
*   already set by the GetStatus() call. (see GetStatus comments for details)
*   If this flag is FALSE, then the WIA driver needs to look at the OVERLAPPED
*   result for more information.  The m_EventData BYTE array should contain
*   information about the event.  This is also where you can ask the device
*   more information about what event just occured.
*
* Sample Notes:
*
*   This WIA sample driver uses the Windows Registry to simulate the interrupt
*   event signaling.  It is not recommended to use this method in a production
*   driver.  The #define USE_REAL_EVENTS should be defined to build a WIA driver
*   that uses real device events.
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIADevice::GetNotificationData( LPSTINOTIFY pBuffer )
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIADevice::GetNotificationData");
    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if(!pBuffer){
        return E_INVALIDARG;
    }

    DWORD dwBytesRet = 0;

    //
    // check the event source flag, m_bPolledEvent.
    // * If it is TRUE, just pass the event set in GetStatus() call to
    // the STINOTIFY buffer and continue.
    //
    // * If it is FALSE, then you need to read the m_EventData buffer
    // to determine what event was fired.
    //

    if (m_bPolledEvent == FALSE) {

#ifdef USE_REAL_EVENTS

        BOOL bResult = GetOverlappedResult(m_hDeviceDataHandle, &m_EventOverlapped, &dwBytesRet, FALSE );
        if (bResult) {
            //
            // read the m_EventData buffer to determine the proper event.
            // set the m_guidLastEvent member to the proper event GUID
            // set the m_guidLastEvent to GUID_NULL when an event has
            // not happened that you are concerned with
            //
        }

#else   // USE_REAL_EVENTS

        if(m_hFakeEventKey){
            LONG  lEventCode = 0;
            DWORD dwEventCodeSize = sizeof(lEventCode);
            DWORD dwType = REG_DWORD;
            if(RegQueryValueEx(m_hFakeEventKey,
                               WIASCANR_DWORD_FAKE_EVENT_CODE,
                               NULL,
                               &dwType,
                               (BYTE*)&lEventCode,
                               &dwEventCodeSize) == ERROR_SUCCESS){

                //
                // process event code
                //

                switch(lEventCode){
                case ID_FAKE_SCANBUTTON:
                    m_guidLastEvent = WIA_EVENT_SCAN_IMAGE;
                    break;
                case ID_FAKE_COPYBUTTON:
                    m_guidLastEvent = WIA_EVENT_SCAN_PRINT_IMAGE;
                    break;
                case ID_FAKE_FAXBUTTON:
                    m_guidLastEvent = WIA_EVENT_SCAN_FAX_IMAGE;
                    break;
                case ID_FAKE_NOEVENT:
                default:
                    break;
                }
            }
        }

#endif  // USE_REAL_EVENTS

    }

    //
    // If the event was triggered, then fill in the STINOTIFY structure with
    // the proper event information
    //

    if (m_guidLastEvent != GUID_NULL) {
        memset(pBuffer,0,sizeof(STINOTIFY));
        pBuffer->dwSize               = sizeof(STINOTIFY);
        pBuffer->guidNotificationCode = m_guidLastEvent;

        //
        // reset the Last event GUID to GUID_NULL to clear the cached event
        //

        m_guidLastEvent = GUID_NULL;
    } else {
        return STIERR_NOEVENTS;
    }

    return S_OK;
}

/**************************************************************************\
* CWIADevice::GetLastErrorInfo
*
*   GetLastErrorInfo is called to get more information about a WIA device
*   specific error code.  This code could come from the IStiUsd::GetLastError()
*   method call, or a vendor specific application may want more information
*   about a known error code.
*
*
* Arguments:
*
*    pLastErrorInfo - Pointer to extended device error data.
*
* Return Value:
*
*    S_OK  - if the data can be written correctly
*    E_xxx - Error code if the operation fails
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIADevice::GetLastErrorInfo(STI_ERROR_INFO *pLastErrorInfo)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIADevice::GetLastErrorInfo");

    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if (!pLastErrorInfo) {
        return E_INVALIDARG;
    }

    pLastErrorInfo->dwGenericError         = m_dwLastOperationError;
    pLastErrorInfo->szExtendedErrorText[0] = '\0';

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\wiafbdrv\wiaprop.h ===
/**************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       WIAProp.h
*
*  VERSION:     1.0
*
*  DATE:        18 July, 2000
*
*  DESCRIPTION:
*   Default property declarations and definitions for the
*   Sample WIA Scanner device.
*
***************************************************************************/

#ifndef _WIAPROP_H
#define _WIAPROP_H

#define SCANNER_FIRMWARE_VERSION L"1.0"
#define OPTICAL_XRESOLUTION      300
#define OPTICAL_YRESOLUTION      300
#define HORIZONTAL_BED_SIZE      8500   // in one thousandth's of an inch
#define VERTICAL_BED_SIZE        11000  // in one thousandth's of an inch

#define HORIZONTAL_ADF_BED_SIZE  8500   // in one thousandth's of an inch
#define VERTICAL_ADF_BED_SIZE    11000  // in one thousandth's of an inch

#define HORIZONTAL_TPA_BED_SIZE  8500   // in one thousandth's of an inch
#define VERTICAL_TPA_BED_SIZE    11000  // in one thousandth's of an inch

#define MIN_BUFFER_SIZE          65535

#define INITIAL_PHOTOMETRIC_INTERP WIA_PHOTO_WHITE_1
#define INITIAL_COMPRESSION        WIA_COMPRESSION_NONE
#define INITIAL_XRESOLUTION        150
#define INITIAL_YRESOLUTION        150
#define INITIAL_DATATYPE           WIA_DATA_GRAYSCALE
#define INITIAL_BITDEPTH           8
#define INITIAL_BRIGHTNESS         0
#define INITIAL_CONTRAST           0
#define INITIAL_CHANNELS_PER_PIXEL 1
#define INITIAL_BITS_PER_CHANNEL   8
#define INITIAL_PLANAR             WIA_PACKED_PIXEL
#define INITIAL_FORMAT             (GUID*) &WiaImgFmt_MEMORYBMP
#define INITIAL_TYMED              TYMED_CALLBACK

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\wiascanr\scanapi.h ===
/**************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2002
*
*  TITLE:       scanapi.h
*
*  VERSION:     1.1
*
*  DATE:        08 March, 2002
*
*  DESCRIPTION:
*   Fake Scanner device library
*
***************************************************************************/

#ifndef _SCANAPI_H
#define _SCANAPI_H

//
// ID mappings to events
//

#define ID_FAKE_NOEVENT             0
#define ID_FAKE_SCANBUTTON          100
#define ID_FAKE_COPYBUTTON          200
#define ID_FAKE_FAXBUTTON           300
#define ID_FAKE_ADFEVENT            400

//
// Scanner library modes
//

#define FLATBED_SCANNER_MODE        100
#define UNKNOWN_FEEDER_ONLY_SCANNER_MODE      200

//
// Scanning states
//

#define SCAN_START                  0
#define SCAN_CONTINUE               1
#define SCAN_END                    3

//
// Root Item information (for property initialization)
//

typedef struct _ROOT_ITEM_INFORMATION {
    LONG ScanBedWidth;          // 1/1000ths of an inch
    LONG ScanBedHeight;         // 1/1000ths of an inch
    LONG OpticalXResolution;    // Optical X Resolution of device
    LONG OpticalYResolution;    // Optical X Resolution of device
    LONG MaxScanTime;           // Milliseconds (total scan time)

    LONG DocumentFeederWidth;   // 1/1000ths of an inch
    LONG DocumentFeederHeight;  // 1/1000ths of an inch
    LONG DocumentFeederCaps;    // Capabilites of the device with feeder
    LONG DocumentFeederStatus;  // Status of document feeder
    LONG MaxPageCapacity;       // Maximum page capacity of feeder
    LONG DocumentFeederReg;     // document feeder alignment
    LONG DocumentFeederHReg;    // document feeder justification alignment (HORIZONTAL)
    LONG DocumentFeederVReg;    // document feeder justification alignment (VERTICAL)
    WCHAR FirmwareVersion[25];  // Firmware version of device
}ROOT_ITEM_INFORMATION, *PROOT_ITEM_INFORMATION;

//
// Range data type helper structure (used below)
//

typedef struct _RANGEPROPERTY {
    LONG lMin;  // minimum value
    LONG lMax;  // maximum value
    LONG lNom;  // numinal value
    LONG lInc;  // increment/step value
} RANGEPROPERTY,*PRANGEPROPERTY;

//
// Top Item information (for property initialization)
//

typedef struct _TOP_ITEM_INFORMATION {
    BOOL          bUseResolutionList;   // TRUE - use default Resolution list,
                                        // FALSE - use RANGEPROPERTY values
    RANGEPROPERTY Contrast;             // valid values for contrast
    RANGEPROPERTY Brightness;           // valid values for brightness
    RANGEPROPERTY Threshold;            // valid values for threshold
    RANGEPROPERTY XResolution;          // valid values for x resolution
    RANGEPROPERTY YResolution;          // valid values for y resolution
    LONG          lMinimumBufferSize;   // minimum buffer size
    LONG          lMaxLampWarmupTime;   // maximum lamp warmup time
} TOP_ITEM_INFORMATION, *PTOP_ITEM_INFORMATION;

//
// Scanner device constants
//

#define MAX_SCANNING_TIME    40000  // 40 seconds
#define MAX_LAMP_WARMUP_TIME 10000  // 10 seconds
#define MAX_PAGE_CAPACITY    25     // 25 pages

typedef struct _RAW_DATA_INFORMATION {
    LONG bpp;           // bits per pixel;
    LONG lWidthPixels;  // width of image in pixels
    LONG lHeightPixels; // height of image in pixels
    LONG lOffset;       // raw copy offset from top of raw buffer;
    LONG lXRes;         // x resolution
    LONG lYRes;         // y resolution
} RAW_DATA_INFORMATION,*PRAW_DATA_INFORMATION;

class CFakeScanAPI {
public:

    //
    // constructor/destructor
    //

    CFakeScanAPI();
    ~CFakeScanAPI();

    //
    // device initialization function
    //

    HRESULT FakeScanner_Initialize();

    //
    // device setting functions
    //

    HRESULT FakeScanner_GetRootPropertyInfo(PROOT_ITEM_INFORMATION pRootItemInfo);
    HRESULT FakeScanner_GetTopPropertyInfo(PTOP_ITEM_INFORMATION pTopItemInfo);
    HRESULT FakeScanner_GetBedWidthAndHeight(PLONG pWidth, PLONG pHeight);

    //
    // data acquisition functions
    //

    HRESULT FakeScanner_Scan(LONG lState, PBYTE pData, DWORD dwBytesToRead, PDWORD pdwBytesWritten);
    HRESULT FakeScanner_SetDataType(LONG lDataType);
    HRESULT FakeScanner_SetXYResolution(LONG lXResolution, LONG lYResolution);
    HRESULT FakeScanner_SetSelectionArea(LONG lXPos, LONG lYPos, LONG lXExt, LONG lYExt);
    HRESULT FakeScanner_SetContrast(LONG lContrast);

    HRESULT FakeScanner_SetIntensity(LONG lIntensity);

    //
    // standard device operations
    //

    HRESULT FakeScanner_ResetDevice();
    HRESULT FakeScanner_SetEmulationMode(LONG lDeviceMode);
    HRESULT FakeScanner_DisableDevice();
    HRESULT FakeScanner_EnableDevice();
    HRESULT FakeScanner_DeviceOnline();
    HRESULT FakeScanner_Diagnostic();

    //
    // Automatic document feeder functions
    //

    HRESULT FakeScanner_ADFAttached();
    HRESULT FakeScanner_ADFHasPaper();
    HRESULT FakeScanner_ADFAvailable();
    HRESULT FakeScanner_ADFFeedPage();
    HRESULT FakeScanner_ADFUnFeedPage();
    HRESULT FakeScanner_ADFStatus();

private:

    LONG    m_lLastEvent;           // Last Event ID
    LONG    m_lMode;                // Fake scanner library mode
    LONG    m_PagesInADF;           // Current number of pages in the ADF
    BOOL    m_ADFIsAvailable;       // ADF available TRUE/FALSE
    HRESULT m_hrLastADFError;       // ADF errors
    BOOL    m_bGreen;               // Are We Green?
    LONG    m_dwBytesWrittenSoFAR;  // How much data have we read so far?
    LONG    m_TotalDataInDevice;    // How much will we read total?

protected:

    //
    // RAW and SRC data information members
    //

    RAW_DATA_INFORMATION m_RawDataInfo; // Information about RAW data
    RAW_DATA_INFORMATION m_SrcDataInfo; // Information about SRC data

    //
    // RAW data calculation helper functions
    //

    LONG WidthToDIBWidth(LONG lWidth);
    LONG CalcTotalImageSize();
    LONG CalcRawByteWidth();
    LONG CalcSrcByteWidth();
    LONG CalcRandomDeviceDataTotalBytes();

};

HRESULT CreateFakeScanner(CFakeScanAPI **ppFakeScanAPI, LONG lMode);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\wiascanr\scanapi.cpp ===
/**************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2002
*
*  TITLE:       scanapi.cpp
*
*  VERSION:     1.1
*
*  DATE:        05 March, 2002
*
*  DESCRIPTION:
*   Fake Scanner device library.  This is a fake scanner library, intended
*   to simulate a scanner device.  This should only be used for testing
*   purposes.
*
***************************************************************************/

#include "pch.h"
#include "scanapi.h"
#include <time.h>

CFakeScanAPI::CFakeScanAPI()
{
    m_lLastEvent            = ID_FAKE_NOEVENT;
    m_hrLastADFError        = S_OK;
    m_bGreen                = TRUE;
    m_dwBytesWrittenSoFAR   = 0;
    m_TotalDataInDevice     = 0;
    m_PagesInADF            = MAX_PAGE_CAPACITY;

    memset(&m_RawDataInfo, 0,sizeof(RAW_DATA_INFORMATION));
    memset(&m_SrcDataInfo, 0,sizeof(RAW_DATA_INFORMATION));
}

CFakeScanAPI::~CFakeScanAPI()
{

}

HRESULT CFakeScanAPI::FakeScanner_Initialize()
{
    return S_OK;
}

HRESULT CFakeScanAPI::FakeScanner_GetRootPropertyInfo(PROOT_ITEM_INFORMATION pRootItemInfo)
{
    HRESULT hr = S_OK;

    //
    // Fill in Root item property defaults
    //

    if (m_lMode == UNKNOWN_FEEDER_ONLY_SCANNER_MODE) {
        pRootItemInfo->DocumentFeederCaps   = FEEDER;
        pRootItemInfo->DocumentFeederStatus = FEED_READY;
        pRootItemInfo->DocumentFeederHReg   = CENTERED;
        pRootItemInfo->DocumentFeederReg    = CENTERED;
    } else {
        pRootItemInfo->DocumentFeederCaps   = FEEDER|FLATBED;
        pRootItemInfo->DocumentFeederStatus = FLAT_READY;
        pRootItemInfo->DocumentFeederHReg   = LEFT_JUSTIFIED;
        pRootItemInfo->DocumentFeederReg    = LEFT_JUSTIFIED;
    }

    pRootItemInfo->DocumentFeederWidth  = 8500;
    pRootItemInfo->DocumentFeederHeight = 11000;
    pRootItemInfo->DocumentFeederHReg   = LEFT_JUSTIFIED;
    pRootItemInfo->DocumentFeederReg    = LEFT_JUSTIFIED;
    pRootItemInfo->DocumentFeederVReg   = TOP_JUSTIFIED;
    pRootItemInfo->MaxPageCapacity      = MAX_PAGE_CAPACITY;
    pRootItemInfo->MaxScanTime          = MAX_SCANNING_TIME;
    pRootItemInfo->OpticalXResolution   = 300;
    pRootItemInfo->OpticalYResolution   = 300;
    pRootItemInfo->ScanBedWidth         = 8500;
    pRootItemInfo->ScanBedHeight        = 11000;

    //
    // copy firmware version in string form to WCHAR array
    //

    lstrcpyW(pRootItemInfo->FirmwareVersion,L"1.0a");

    return hr;
}
HRESULT CFakeScanAPI::FakeScanner_GetTopPropertyInfo(PTOP_ITEM_INFORMATION pTopItemInfo)
{
    HRESULT hr = S_OK;
    pTopItemInfo->bUseResolutionList    = TRUE; // use default resolution list

    pTopItemInfo->Brightness.lInc       = 1;
    pTopItemInfo->Brightness.lMax       = 1000;
    pTopItemInfo->Brightness.lMin       = -1000;
    pTopItemInfo->Brightness.lNom       = 0;

    pTopItemInfo->Contrast.lInc         = 1;
    pTopItemInfo->Contrast.lMax         = 1000;
    pTopItemInfo->Contrast.lMin         = -1000;
    pTopItemInfo->Contrast.lNom         = 0;

    pTopItemInfo->Threshold.lInc        = 1;
    pTopItemInfo->Threshold.lMax        = 1000;
    pTopItemInfo->Threshold.lMin        = -1000;
    pTopItemInfo->Threshold.lNom        = 0;

    pTopItemInfo->lMaxLampWarmupTime    = MAX_LAMP_WARMUP_TIME;
    pTopItemInfo->lMinimumBufferSize    = 262140;

    pTopItemInfo->XResolution.lInc      = 1;
    pTopItemInfo->XResolution.lMax      = 600;
    pTopItemInfo->XResolution.lMin      = 75;
    pTopItemInfo->XResolution.lNom      = 150;

    pTopItemInfo->YResolution.lInc      = 1;
    pTopItemInfo->YResolution.lMax      = 600;
    pTopItemInfo->YResolution.lMin      = 75;
    pTopItemInfo->YResolution.lNom      = 150;

    return hr;
}

HRESULT CFakeScanAPI::FakeScanner_Scan(LONG lState, PBYTE pData, DWORD dwBytesToRead, PDWORD pdwBytesWritten)
{
    HRESULT hr = S_OK;

    switch (lState) {
    case SCAN_START:
        m_dwBytesWrittenSoFAR = 0;
        m_TotalDataInDevice   = CalcRandomDeviceDataTotalBytes();
        break;
    case SCAN_CONTINUE:
        break;
    case SCAN_END:
        m_bGreen = TRUE; // set back to green
        return S_OK;
    default:
        break;
    }

    if (NULL != pData) {
        switch (m_RawDataInfo.bpp) {
        case 24:
            {
                //
                // write green data for color
                //

                BYTE *pTempData = pData;
                for (DWORD dwBytes = 0; dwBytes < dwBytesToRead; dwBytes+=3) {
                    if (m_bGreen) {
                        pTempData[0] = 0;
                        pTempData[1] = 128;  // green
                        pTempData[2] = 0;
                    } else {
                        pTempData[0] = 0;
                        pTempData[1] = 0;
                        pTempData[2] = 128;  // blue
                    }
                    pTempData += 3;
                }
            }
            break;
        case 1:
        case 8:
        default:

            //
            // write simple gray for grayscale,
            // write vertical B/W stripes for threshold
            //

            if (m_bGreen) {
                memset(pData,128,dwBytesToRead);
            } else {
                memset(pData,200,dwBytesToRead);
            }
            break;
        }
    }

    //
    // fill out bytes written
    //

    if (NULL != pdwBytesWritten) {
        *pdwBytesWritten = dwBytesToRead;
    }

    if (m_bGreen) {
        m_bGreen = FALSE;
    } else {
        m_bGreen = TRUE;
    }

    if (m_lMode == UNKNOWN_FEEDER_ONLY_SCANNER_MODE) {

        //
        // keep track of bytes written so far
        //

        if (m_TotalDataInDevice == 0) {

            //
            // no data left in device
            //

            *pdwBytesWritten = 0;
            return hr;
        }

        if ((LONG)dwBytesToRead > m_TotalDataInDevice) {

            //
            // only give what is left in device
            //

            *pdwBytesWritten = dwBytesToRead;
            m_TotalDataInDevice = 0;
        } else {

            //
            // give full amount requested
            //

            m_TotalDataInDevice -= dwBytesToRead;
            if (m_TotalDataInDevice < 0) {
                m_TotalDataInDevice = 0;
            }
        }

    }

    return hr;
}

HRESULT CFakeScanAPI::FakeScanner_SetDataType(LONG lDataType)
{
    HRESULT hr = S_OK;
    switch (lDataType) {
    case WIA_DATA_COLOR:
        m_RawDataInfo.bpp = 24;
        break;
    case WIA_DATA_THRESHOLD:
        m_RawDataInfo.bpp = 1;
        break;
    case WIA_DATA_GRAYSCALE:
        m_RawDataInfo.bpp = 8;
        break;
    default:
        hr = E_INVALIDARG;
        break;
    }
    return hr;
}

HRESULT CFakeScanAPI::FakeScanner_SetXYResolution(LONG lXResolution, LONG lYResolution)
{
    HRESULT hr = S_OK;
    m_RawDataInfo.lXRes = lXResolution;
    m_RawDataInfo.lYRes = lYResolution;
    return hr;
}

HRESULT CFakeScanAPI::FakeScanner_SetSelectionArea(LONG lXPos, LONG lYPos, LONG lXExt, LONG lYExt)
{
    HRESULT hr = S_OK;

    //
    // record RAW data width and height
    //

    m_RawDataInfo.lWidthPixels  = lXExt;
    m_RawDataInfo.lHeightPixels = lYExt;
    return hr;
}

HRESULT CFakeScanAPI::FakeScanner_SetContrast(LONG lContrast)
{
    HRESULT hr = S_OK;

    //
    // do nothing.. we are not concerned with Contrast
    //

    return hr;
}

HRESULT CFakeScanAPI::FakeScanner_SetIntensity(LONG lIntensity)
{
    HRESULT hr = S_OK;

    //
    // do nothing.. we are not concerned with Intensity
    //

    return hr;
}

HRESULT CFakeScanAPI::FakeScanner_DisableDevice()
{
    return S_OK;
}

HRESULT CFakeScanAPI::FakeScanner_EnableDevice()
{
    return S_OK;
}

HRESULT CFakeScanAPI::FakeScanner_DeviceOnline()
{
    return S_OK;
}

HRESULT CFakeScanAPI::FakeScanner_Diagnostic()
{
    return S_OK;
}

HRESULT CFakeScanAPI::FakeScanner_GetBedWidthAndHeight(PLONG pWidth, PLONG pHeight)
{
    HRESULT hr = E_FAIL;

    //
    // get our Root item settings, so we can use the width and height values
    //

    ROOT_ITEM_INFORMATION RootItemInfo;
    hr = FakeScanner_GetRootPropertyInfo(&RootItemInfo);
    if (SUCCEEDED(hr)) {
        *pWidth  = RootItemInfo.ScanBedWidth;
        *pHeight = RootItemInfo.ScanBedHeight;
    }
    return hr;
}

//
// standard device operations
//

HRESULT CFakeScanAPI::FakeScanner_ResetDevice()
{
    return S_OK;
}

HRESULT CFakeScanAPI::FakeScanner_SetEmulationMode(LONG lDeviceMode)
{
    HRESULT hr = S_OK;

    switch (lDeviceMode) {
    case UNKNOWN_FEEDER_ONLY_SCANNER_MODE:
        m_lMode = UNKNOWN_FEEDER_ONLY_SCANNER_MODE;
        break;
    case FLATBED_SCANNER_MODE:
        m_lMode = FLATBED_SCANNER_MODE;
        break;
    default:
        m_lMode = 0;
        hr = E_INVALIDARG;
        break;
    }
    return hr;
}

//
// Automatic document feeder functions
//

HRESULT CFakeScanAPI::FakeScanner_ADFHasPaper()
{
    HRESULT hr = S_OK;

    //
    // check paper count
    //

    if (m_PagesInADF <= 0) {
        hr = S_FALSE;
        m_PagesInADF = MAX_PAGE_CAPACITY;
    }

    return hr;
}

HRESULT CFakeScanAPI::FakeScanner_ADFAvailable()
{
    HRESULT hr = S_OK;

    //
    // check ADF on-line
    //

    if (!m_ADFIsAvailable) {
        hr = S_FALSE;
    }

    return hr;
}

HRESULT CFakeScanAPI::FakeScanner_ADFFeedPage()
{
    HRESULT hr = S_OK;

    if (S_OK != FakeScanner_ADFHasPaper()) {

        //
        // set paper empty error code
        //

        hr = WIA_ERROR_PAPER_EMPTY;
    }

    //
    // update paper count for ADF
    //

    m_PagesInADF--;

    if (m_PagesInADF <0) {
        m_PagesInADF = 0;
    }

    return hr;
}

HRESULT CFakeScanAPI::FakeScanner_ADFUnFeedPage()
{
    return S_OK;
}

HRESULT CFakeScanAPI::FakeScanner_ADFStatus()
{
    return m_hrLastADFError;
}

HRESULT CFakeScanAPI::FakeScanner_ADFAttached()
{
    return S_OK;
}

LONG CFakeScanAPI::WidthToDIBWidth(LONG lWidth)
{
    return(lWidth+3)&0xfffffffc;
}

LONG CFakeScanAPI::CalcTotalImageSize()
{
    LONG lTotalSize = 0;
    switch (m_RawDataInfo.bpp) {
    case 1:
        lTotalSize = ((m_RawDataInfo.lHeightPixels * m_RawDataInfo.lWidthPixels) + 7) / 8;
        break;
    case 8:
        lTotalSize = m_RawDataInfo.lHeightPixels * m_RawDataInfo.lWidthPixels;
        break;
    case 24:
        lTotalSize = (m_RawDataInfo.lHeightPixels * m_RawDataInfo.lWidthPixels) * 3;
        break;
    default:
        break;
    }
    return lTotalSize;
}

LONG CFakeScanAPI::CalcRawByteWidth()
{
    LONG lRawWidthBytes = 0;
    switch (m_RawDataInfo.bpp) {
    case 1:
        lRawWidthBytes = ((m_RawDataInfo.lWidthPixels) + 7) / 8;
        break;
    case 8:
        lRawWidthBytes = m_RawDataInfo.lWidthPixels;
        break;
    case 24:
        lRawWidthBytes = (m_RawDataInfo.lWidthPixels) * 3;
        break;
    default:
        break;
    }
    return lRawWidthBytes;
}

LONG CFakeScanAPI::CalcSrcByteWidth()
{
    LONG lSrcWidthBytes = 0;
    switch (m_SrcDataInfo.bpp) {
    case 1:
        lSrcWidthBytes = ((m_SrcDataInfo.lWidthPixels) + 7) / 8;
        break;
    case 8:
        lSrcWidthBytes = m_SrcDataInfo.lWidthPixels;
        break;
    case 24:
        lSrcWidthBytes = (m_SrcDataInfo.lWidthPixels) * 3;
        break;
    default:
        break;
    }
    return lSrcWidthBytes;
}

LONG CFakeScanAPI::CalcRandomDeviceDataTotalBytes()
{
    LONG lTotalBytes = 0;
    srand((unsigned)time(NULL));
    LONG lPageLengthInches = ((rand()%17) + 5);// max 22 inches, and min of 5 inches
    LONG lImageHeight = m_RawDataInfo.lYRes * lPageLengthInches;
    lTotalBytes = (CalcRawByteWidth() * lImageHeight);
    return lTotalBytes;
}

HRESULT CreateFakeScanner(CFakeScanAPI **ppFakeScanAPI, LONG lMode)
{
    HRESULT hr = S_OK;
    if (ppFakeScanAPI) {
        *ppFakeScanAPI = NULL;
        *ppFakeScanAPI = new CFakeScanAPI;
        if (NULL == *ppFakeScanAPI) {
            hr = E_OUTOFMEMORY;
        }
        CFakeScanAPI* pScanAPI = (CFakeScanAPI*)*ppFakeScanAPI;
        pScanAPI->FakeScanner_SetEmulationMode(lMode);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\wiascanr\iwiaminidrv.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2002
*
*  TITLE:       IWiaMiniDrv.cpp
*
*  VERSION:     1.1
*
*  DATE:        05 March, 2002
*
*  DESCRIPTION:
*   Implementation of the WIA sample scanner IWiaMiniDrv methods.
*
*******************************************************************************/

#include "pch.h"
#include <stdio.h>

extern HINSTANCE g_hInst;           // used for WIAS_LOGPROC macro

/**************************************************************************\
* CWIADevice::drvInitializeWia
*
*   drvInitializeWia is called by the WIA service in response to a WIA
*   application's call to IWiaDevMgr::CreateDevice (described in the
*   Platform SDK documentation), which means that this method is
*   called once for each new client connection.
*
*   This method should initialize any private structures and create the
*   driver item tree.  The driver item tree shows the layout of all WIA
*   items supported by this WIA device.  This method is for creating the
*   initial tree structure only, NOT the contents (WIA properties).  WIA properties for
*   these WIA driver items will be populated individually by multiple calls by
*   the WIA service to IWiaMiniDrv::drvInitItemProperties().
*
*   All WIA devices have a ROOT item.  This item is the parent to all
*   WIA device items.  To create a WIA device item the WIA driver should call
*   the WIA service helper function. wiasCreateDrvItem().
*
*   Example:
*
*   Creating a WIA device ROOT item might look like the following:
*
*   LONG lItemFlags = WiaItemTypeFolder|WiaItemTypeDevice|WiaItemTypeRoot;
*
*   IWiaDrvItem  *pIWiaDrvRootItem  = NULL;
*
*   HRESULT hr = wiasCreateDrvItem(lItemFlags,           // item flags
*                                  bstrRootItemName,     // item name ("Root")
*                                  bstrRootFullItemName, // item full name ("0000\Root")
*                                  (IWiaMiniDrv *)this,  // this WIA driver object
*                                  sizeof(MINIDRIVERITEMCONTEXT), // size of context
*                                  NULL,                 // context
*                                  &pIWiaDrvRootItem);   // created ROOT item
*                                                        // (IWiaDrvItem interface)
*
*   if(S_OK == hr){
*
*       //
*       // ROOT item was created successfully
*       //
*
*   }
*
*   Example:
*
*   Creating a WIA child item, located directly under the ROOT item we created in the
*   above sample might look like the following:
*
*   NOTE: notice the calling of IWiaDrvItem::AddItemToFolder() method to add the
*         newly created chld item to the ROOT item.
*
*   LONG lItemFlags = WiaItemTypeFile|WiaItemTypeDevice|WiaItemTypeImage;
*
*   PMINIDRIVERITEMCONTEXT pItemContext    = NULL;
*   IWiaDrvItem           *pIWiaDrvNewItem = NULL;
*
*   HRESULT hr = wiasCreateDrvItem(lItemFlags,           // item flags
*                                  bstrItemName,         // item name ("Flatbed")
*                                  bstrFullItemName,     // item full name ("0000\Root\Flatbed")
*                                  (IWiaMiniDrv *)this,  // this WIA driver object
*                                  sizeof(MINIDRIVERITEMCONTEXT), // size of context
*                                  (PBYTE)&pItemContext, // context
*                                  &pIWiaDrvNewItem);    // created child item
*                                                        // (IWiaDrvItem interface)
*
*   if(S_OK == hr){
*
*       //
*       // A New WIA driver item was created successfully
*       //
*
*       hr = pIWiaDrvNewItem->AddItemToFolder(pIWiaDrvRootItem); // add the new item to the ROOT
*       if(S_OK == hr){
*
*           //
*           // successfully created and added a new WIA driver item to the WIA driver item
*           // tree.
*           //
*
*       }
*       pNewItem->Release();
*       pNewItem = NULL;
*   }
*
*
*   See the DDK documentation on the proper flags for describing a WIA driver item.
*
*
* Arguments:
*
*   pWiasContext          - Pointer to the WIA item, unused.
*   lFlags                - Operation flags, unused.
*   bstrDeviceID          - Device ID.
*   bstrRootFullItemName  - Full item name.
*   pIPropStg             - Device info. properties.
*   pStiDevice            - STI device interface.
*   pIUnknownOuter        - Outer unknown interface.
*   ppIDrvItemRoot        - Pointer to returned root item.
*   ppIUnknownInner       - Pointer to returned inner unknown.
*   plDevErrVal           - Pointer to the device error value.
*
* Return Value:
*
*   S_OK - if the operation was successful
*   E_xxx - Error Code if the operation failed
*
* Sample Notes:
*   This WIA sample driver calls an internal helper function called BuildItemTree().
*   This function follows the instructions outlined in the comments for
*   creating WIA driver items.
*   This WIA sample driver also breaks the initialization of some internal
*   structures (i.e. BuildCapabilities()) into separate helper functions.
*   When this driver's drvInitializeWia() method is called, it takes a moment
*   to create the necessary data for WIA property initialization (which happens
*   at the drvInitItemProperties)
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIADevice::drvInitializeWia(
                                                    BYTE        *pWiasContext,
                                                    LONG        lFlags,
                                                    BSTR        bstrDeviceID,
                                                    BSTR        bstrRootFullItemName,
                                                    IUnknown    *pStiDevice,
                                                    IUnknown    *pIUnknownOuter,
                                                    IWiaDrvItem **ppIDrvItemRoot,
                                                    IUnknown    **ppIUnknownInner,
                                                    LONG        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::drvInitializeWia");
    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if (!pWiasContext) {
        return E_INVALIDARG;
    }

    if (!plDevErrVal) {
        return E_INVALIDARG;
    }

    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitializeWia, bstrDeviceID         = %ws", bstrDeviceID));
    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitializeWia, bstrRootFullItemName = %ws",bstrRootFullItemName));
    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitializeWia, lFlags               = %d",lFlags));
    HRESULT hr = S_OK;

    *plDevErrVal = 0;
    *ppIDrvItemRoot = NULL;
    *ppIUnknownInner = NULL;

    //
    //  Need to init names and STI pointer?
    //

    if (m_pStiDevice == NULL) {

        //
        // save STI device interface for locking
        //

        m_pStiDevice = (IStiDevice *)pStiDevice;
    }

    //
    // Initialize Capabilities array
    //

    hr = BuildCapabilities();

    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, BuildCapabilities failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // Initialize SupportedFormats array
    //

    hr = BuildSupportedFormats();

    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, BuildSupportedFormats failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // Initialize Supported Data Type array
    //

    hr = BuildSupportedDataTypes();

    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, BuildSupportedDataTypes failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // Initialize Supported Intents array
    //

    hr = BuildSupportedIntents();

    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, BuildSupportedIntents failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // Initialize Supported TYMED array
    //

    hr = BuildSupportedTYMED();

    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, BuildSuportedTYMED failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // Initialize  Supported compression types array
    //

    hr = BuildSupportedCompressions();

    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, BuildSupportedCompressions"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // Initialize  Supported Preview modes array
    //

    hr = BuildSupportedPreviewModes();

    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, BuildSupportedPreviewModes"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // Initialize  initial formats array
    //

    hr = BuildInitialFormats();

    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, BuildInitialFormats failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // Initialize supported resolutions array
    //

    hr = BuildSupportedResolutions();
    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, BuildSupportedResolutions failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // build WIA item tree
    //

    LONG lItemFlags = WiaItemTypeFolder|WiaItemTypeDevice|WiaItemTypeRoot;

    IWiaDrvItem  *pIWiaDrvRootItem  = NULL;

    //
    // create the ROOT item of the WIA device.  This name should NOT be localized
    // in different languages. "Root" is used by WIA drivers.
    //

    BSTR bstrRootItemName = SysAllocString(WIA_DEVICE_ROOT_NAME);
    if(!bstrRootItemName) {
        return E_OUTOFMEMORY;
    }

    hr = wiasCreateDrvItem(lItemFlags,           // item flags
                           bstrRootItemName,     // item name ("Root")
                           bstrRootFullItemName, // item full name ("0000\Root")
                           (IWiaMiniDrv *)this,  // this WIA driver object
                           sizeof(MINIDRIVERITEMCONTEXT), // size of context
                           NULL,                 // context
                           &pIWiaDrvRootItem);   // created ROOT item
                                                 // (IWiaDrvItem interface)
    if (S_OK == hr) {

        //
        // ROOT item was created successfully, save the newly created Root item
        // in the pointer given by the WIA service (ppIDrvItemRoot).
        //

        *ppIDrvItemRoot = pIWiaDrvRootItem;

        //
        // Create a child item  directly under the Root WIA item
        //

        lItemFlags = WiaItemTypeFile|WiaItemTypeDevice|WiaItemTypeImage;

        PMINIDRIVERITEMCONTEXT pItemContext    = NULL;
        IWiaDrvItem           *pIWiaDrvNewItem = NULL;

        //
        // create a name for the WIA child item.  "Flatbed" is used by WIA drivers that
        // support a flatbed scanner.
        //

#ifdef UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER
        BSTR bstrItemName = SysAllocString(WIA_DEVICE_FEEDER_NAME);
#else
        BSTR bstrItemName = SysAllocString(WIA_DEVICE_FLATBED_NAME);
#endif

        if (bstrItemName) {

            WCHAR  wszFullItemName[MAX_PATH + 1] = {0};
            _snwprintf(wszFullItemName,(sizeof(wszFullItemName) / sizeof(WCHAR)) - 1,L"%ls\\%ls",
                       bstrRootFullItemName,bstrItemName);

            BSTR bstrFullItemName = SysAllocString(wszFullItemName);
            if (bstrFullItemName) {
                hr = wiasCreateDrvItem(lItemFlags,           // item flags
                                       bstrItemName,         // item name ("Flatbed")
                                       bstrFullItemName,     // item full name ("0000\Root\Flatbed")
                                       (IWiaMiniDrv *)this,  // this WIA driver object
                                       sizeof(MINIDRIVERITEMCONTEXT), // size of context
                                       (BYTE**)&pItemContext, // context
                                       &pIWiaDrvNewItem);    // created child item
                                                             // (IWiaDrvItem interface)

                if (S_OK == hr) {

                    //
                    // A New WIA driver item was created successfully
                    //

                    hr = pIWiaDrvNewItem->AddItemToFolder(pIWiaDrvRootItem); // add the new item to the ROOT
                    if (S_OK == hr) {

                        //
                        // successfully created and added a new WIA driver item to the WIA driver item
                        // tree.
                        //

                    }

                    //
                    // The new item is no longer needed, because it has been passed to the WIA
                    // service.
                    //

                    pIWiaDrvNewItem->Release();
                    pIWiaDrvNewItem = NULL;
                }
                SysFreeString(bstrFullItemName);
                bstrFullItemName = NULL;
            } else {
                hr = E_OUTOFMEMORY;
            }
            SysFreeString(bstrItemName);
            bstrItemName = NULL;
        } else {
            hr = E_OUTOFMEMORY;
        }
    }

    //
    // increment application connection count
    //

    if(S_OK == hr){
        InterlockedIncrement(&m_lClientsConnected);
    }

    return hr;
}

/**************************************************************************\
* CWIADevice::drvAcquireItemData
*
*   drvAcquireItemData is called by the WIA service when data it being
*   requested from a WIA item.  The WIA driver should determine what type of
*   transfer the application is attempting by looking at the following
*   members of the MINIDRV_TRANSFER_CONTEXT:
*
*       pmdtc->tymed - TYMED set by the application.
*           TYMED_FILE               - transfer for file.
*           TYMED_MULTIPAGE_FILE     - transfer to a multipage file format
*           TYMED_CALLBACK           - transfer to memory
*           TYMED_MULTIPAGE_CALLBACK - transfer to memory (multiple pages)
*
*   The different TYMED settings xxx_CALLBACK and xxx_FILE change the usage of
*   calling the application's callback interface.
*
*   xxx_CALLBACK:
*        call: pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback()
*
*        IT_MSG_DATA                  - we are transferring data.
*        IT_STATUS_TRANSFER_TO_CLIENT - data transfer message
*        PercentComplete              - percent complete of the entire transfer
*        pmdtc->cbOffset              - should be updated on the current location
*                                       that the application should write the next
*                                       data chunk.
*        BytesReceived                - number of bytes in the data chunk being sent to the
*                                       application.
*        pmdtc                        - MINIDRV_TRANSFER_CONTEXT context
*
*   xxx_FILE:
*        call: pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback()
*
*        IT_MSG_STATUS                - we are only sending status (NO DATA!!!)
*        IT_STATUS_TRANSFER_TO_CLIENT - data transfer message
*        PercentComplete              - percent complete of the entire transfer
*
* Arguments:
*
*   pWiasContext - Pointer to the WIA item, Item used for transfer
*   lFlags       - Operation flags, unused.
*   pmdtc        - Pointer to mini driver context.
*   plDevErrVal  - Pointer to the device error value.
*
* Return Value:
*
*   S_OK - if the operation was successful
*   E_xxx - Error Code if the operation failed
*
* Sample Notes:
*   This WIA sample driver transfers data from two different sources.
*       1. flatbed
*       2. document feeder
*          a. standard feeder type
*          b. unknown page length feeder type
*             (when the UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER is used to build the
*              driver)
*
*   Notice the percent complete calculations for the unknown page length
*   scanner.  This sample knows that it can receive any page length from
*   the user.  It also knows that the average page used in this device is
*   AVERAGE_FAKE_PAGE_HEIGHT_INCHES in height.  Taking this into account
*   it calculates a rough percentage, so it an return percent complete to
*   the application.  When it receives data larger than the average page
*   length, it halts the percent complete to 95%, allowing the scan to
*   complete.  There are better ways to do this, and this is the one this
*   sample chooses to use.
*
*   Scanning from a feeder:
*
*   This WIA sample driver performs a few checks before continuing with a
*   feeder scan.
*
*   1. check if we are in FEEDER mode.
*       - This is done by looking at the m_bADFEnabled flag.  This flag is
*         set to TRUE when an application writes the WIA_DPS_DOCUMENT_HANDLING_SELECT
*         property to FEEDER.
*   2. checks the requested page count.
*       - This is done by looking at the WIA_DPS_PAGES property, set by the
*         application.
*         zero         ( 0) = scan all pages in the feeder
*         greater than (>0) = scan up to the requested amount.
*   3. unfeeds a previous page.
*      - This could be a jammed page, or the last page in the feeder scanned.
*        Only do this if your device requires the ADF to be cleared before
*        use.
*   4. checks for paper in the feeder.
*      - Always check for paper in the feeder before attempting to scan.
*        If you are about to scan the FIRST page, and no paper is detected
*        return a WIA_ERROR_PAPER_EMPTY error code.
*        If you are scanning the SECOND + pages, and no paper is detected
*        return a WIA_ERROR_PAPER_EMPTY error code or WIA_STATUS_END_OF_MEDIA
*        success code.
*   5. feed a page into the feeder.
*      - Only do this if your device requires the page to be prefed before
*        scanning.  Some document feeders auto-feed a page while scanning.
*        if your document feeder does this...you can skip this step.
*   6. check the feeder's status.
*      - make sure the feeder is in "GO" mode.  Everything checks out, and you
*        are ready to scan.  This will help catch paper jams, or other feeder
*        related problems that can occur before scanning.
*   7. scan
*   8. repeat steps 1 - 7 until all requested pages have been scanned, or
*      until the document feeder is out of paper.
*
*
*   Why is my ITEM SIZE set to ZERO (0)???
*
*   This WIA sample driver sets the WIA item size to zero (0).  This indicates to
*   the application that the WIA driver does not know the resulting image size.
*   This indicates to the WIA service, that the WIA driver wants to allocate it's
*   own data buffers.
*
*   This WIA driver reads the WIA_IPA_BUFFER_SIZE property and allocates a chunk
*   for a single band of data.  The WIA driver can allocate any amount of memory
*   it needs here, but it is recommended to keep allocation small.
*
*   How do I know if the WIA service allocated memory for me??
*
*   check the pmdtc->bClassDrvAllocBuf flag.  If it is TRUE, then the WIA
*   service was kind enough to allocate memory for you.  To find out how
*   much memory that was, check the pmdtc->lBufferSize member.
*
*   If I allocate my own memory, how do I let the WIA service know?
*
*   Allocate memory using CoTaskMemAlloc(), and use the pointer located in
*   pmdtc->pTransferBuffer. (REMEMBER THAT YOU ALLOCATED THIS..SO YOU FREE IT!!)
*   Set the pmdtc->lBufferSize to equal the size you allocated.
*   As stated above, this WIA sample driver allocates it's WIA_IPA_BUFFER_SIZE
*   and uses that memory.
*
*   Read the comments located in the code below for more details on data
*   transfers.
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIADevice::drvAcquireItemData(
                                                      BYTE                      *pWiasContext,
                                                      LONG                      lFlags,
                                                      PMINIDRV_TRANSFER_CONTEXT pmdtc,
                                                      LONG                      *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::drvAcquireItemData");
    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if (!pWiasContext) {
        return E_INVALIDARG;
    }

    if (!pmdtc) {
        return E_INVALIDARG;
    }

    if (!plDevErrVal) {
        return E_INVALIDARG;
    }

    *plDevErrVal = 0;

    HRESULT hr = E_FAIL;
    LONG lBytesTransferredToApplication = 0;

    //
    // Check if we are in Preview Mode and take any special actions required for performing that type
    // of scan.
    //

    if (IsPreviewScan(pWiasContext)) {
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvAcquireItemData, Preview Property is SET"));
    } else {
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvAcquireItemData, Preview Property is NOT SET"));
    }

    //
    // Get number of pages requested, for ADF scanning loop
    //
    // (1-n) = number of pages to scan, or util FEEDER is empty and can not fulfill the request
    //  (0)  = scan all pages until FEEDER is empty
    //
    // NOTE: The driver should return an error in two cases only:
    //       1. fails to scan the first page (with paper empty, or other error)
    //       2. fails duing an ADF scan, and the error is unrecoverable (data loss is involved.)
    //
    //       In case #2, the driver should return a WIA_STATUS_END_OF_MEDIA code when the ADF runs
    //       out of paper, before completing the (1-n) scans requested.  This will allow the application
    //       to properly handle the transfer. (no data loss was involved, just could not complete the full
    //        request.  Some pages did transfer, and the application is holding on to the images.)
    //

    //
    // assume that we are scanning 1 page, (from a feeder or a flatbed), and we are not
    // going to empty the ADF.
    //

    BOOL bEmptyTheADF = FALSE;
    LONG lPagesRequested = 1;
    LONG lPagesScanned = 0;

    //
    // only ask for page count, if the feeder has been enabled.  If it has not, then assume
    // we are using the flatbed.
    //

    if (m_bADFEnabled) {
        lPagesRequested = GetPageCount(pWiasContext);
        if (lPagesRequested == 0) {
            bEmptyTheADF    = TRUE;
            lPagesRequested = 1;// set to 1 so we can enter our loop
                                // WIA_ERROR_PAPER_EMPTY will terminate
                                // the loop...or an error, or a cancel..
                                //
        }
    }

    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvAcquireItemData, Pages to Scan = %d",lPagesRequested));

    //
    // scan until requested page count = 0
    //

    //
    // This is the start of scanning a single page.  The while loop will continue for all pages.
    //

    while (lPagesRequested > 0) {

        //
        // If the FEEDER is enabled, then we need to perform some feeder operations to get
        // the device started.  Some operations, you may want to do here are:
        // check the feeder's status, check paper, feed a page, or even eject a jammed or
        // previous page.
        //

        if (m_bADFEnabled) {

            //
            // clear an potential paper that may be blocking the scan pathway.
            //

            hr = m_pScanAPI->FakeScanner_ADFUnFeedPage();
            if (FAILED(hr)) {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, ADFUnFeedPage (begin transfer) Failed"));
                WIAS_LHRESULT(m_pIWiaLog, hr);
                return hr;
            }

            //
            // check feeder for paper
            //

            hr = m_pScanAPI->FakeScanner_ADFHasPaper();
            if (FAILED(hr)) {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, ADFHasPaper Failed"));
                WIAS_LHRESULT(m_pIWiaLog, hr);
                return hr;
            } else if (hr == S_FALSE) {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, ADF Reports Paper Empty"));
                if (lPagesScanned == 0) {
                    return WIA_ERROR_PAPER_EMPTY;
                } else {
                    return WIA_STATUS_END_OF_MEDIA;
                }
            }

            //
            // attempt to load a page (only if needed)
            //

            hr = m_pScanAPI->FakeScanner_ADFFeedPage();
            if (FAILED(hr)) {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, ADFFeedPage Failed"));
                WIAS_LHRESULT(m_pIWiaLog, hr);
                return hr;
            }

            //
            // Check feeder's status
            //

            hr = m_pScanAPI->FakeScanner_ADFStatus();
            if (FAILED(hr)) {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, ADFStatus Failed"));
                WIAS_LHRESULT(m_pIWiaLog, hr);
                return hr;
            }
        }


        LONG lScanPhase = SCAN_START;
        LONG lClassDrvAllocSize = 0;

        //
        // (1) Memory allocation
        //

        if (pmdtc->bClassDrvAllocBuf) {

            //
            // WIA allocated the buffer for data transfers
            //

            lClassDrvAllocSize = pmdtc->lBufferSize;
            hr = S_OK;
        } else {

            //
            // Driver allocated the buffer for data transfers
            //

            hr = wiasReadPropLong(pWiasContext, WIA_IPA_BUFFER_SIZE, &lClassDrvAllocSize,NULL,TRUE);
            if (FAILED(hr)) {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, wiasReadPropLong Failed to read WIA_IPA_BUFFER_SIZE"));
                WIAS_LHRESULT(m_pIWiaLog, hr);
                return hr;
            }

            pmdtc->pTransferBuffer = (PBYTE) CoTaskMemAlloc(lClassDrvAllocSize);
            if (!pmdtc->pTransferBuffer) {
                return E_OUTOFMEMORY;
            }
            pmdtc->lBufferSize = lClassDrvAllocSize;
        }

        //
        // (2) Gather all information about data transfer settings and
        //     calculate the total data amount to transfer
        //

        if (hr == S_OK) {
            //
            // WIA service will populate the MINIDRV_TRANSFER_CONTEXT by reading the WIA properties.
            //
            // The following values will be written as a result of the wiasGetImageInformation() call
            //
            // pmdtc->lWidthInPixels
            // pmdtc->lLines
            // pmdtc->lDepth
            // pmdtc->lXRes
            // pmdtc->lYRes
            // pmdtc->lCompression
            // pmdtc->lItemSize
            // pmdtc->guidFormatID
            // pmdtc->tymed
            //
            // if the FORMAT is set to BMP or MEMORYBMP, the the following values
            // will also be set automatically
            //
            // pmdtc->cbWidthInBytes
            // pmdtc->lImageSize
            // pmdtc->lHeaderSize
            // pmdtc->lItemSize (will be updated using the known image format information)
            //

            hr = wiasGetImageInformation(pWiasContext,0,pmdtc);
            if (hr == S_OK) {

                //
                // (4) Send the image data to the application
                //

                LONG lDepth = 0;
                hr = wiasReadPropLong(pWiasContext, WIA_IPA_DEPTH, &lDepth,NULL,TRUE);
                if (FAILED(hr)) {
                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, wiasReadPropLong Failed to read WIA_IPA_DEPTH"));
                    WIAS_LHRESULT(m_pIWiaLog, hr);
                    return hr;
                }

                LONG lPixelsPerLine = 0;
                hr = wiasReadPropLong(pWiasContext, WIA_IPA_PIXELS_PER_LINE, &lPixelsPerLine,NULL,TRUE);
                if (FAILED(hr)) {
                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, wiasReadPropLong Failed to read WIA_IPA_PIXELS_PER_LINE"));
                    WIAS_LHRESULT(m_pIWiaLog, hr);
                    return hr;
                }

                LONG lBytesPerLineRaw     = ((lPixelsPerLine * lDepth) + 7) / 8;
                LONG lBytesPerLineAligned = (lPixelsPerLine * lDepth) + 31;
                lBytesPerLineAligned      = (lBytesPerLineAligned / 8) & 0xfffffffc;
                LONG lTotalImageBytes     = pmdtc->lImageSize + pmdtc->lHeaderSize;
                LONG lBytesReceived       = pmdtc->lHeaderSize;
                lBytesTransferredToApplication = 0;
                pmdtc->cbOffset = 0;

                while ((lBytesReceived)) {

#ifdef UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER

                    //
                    // since the feeder can return random length pages, it is a good idea to pick a common
                    // size, and base that as the common transfer lenght.  This will allow you to show
                    // a relativly decent progress indicator percent complete value.
                    // Note:  If you ever get a percent complete over 100%, it is a good idea to stop the
                    //        increment, and hold around 95....or close to 100.  This will keep appliations
                    //        from displaying a strange 105%.. or 365% complete to the end user.  Remember that
                    //        the application will display the exact percent complete value you return to them.
                    //        This calculation has to be accurate, or close to accurate.
                    //

                    lTotalImageBytes = lBytesPerLineRaw * (AVERAGE_FAKE_PAGE_HEIGHT_INCHES * pmdtc->lYRes);
                    LONG lPercentComplete = (LONG)(((float)lBytesTransferredToApplication/(float)lTotalImageBytes) * 100.0f);

                    //
                    // lock percent complete at 95%, until the scan is complete..
                    //

                    if (lPercentComplete >= 95) {
                        lPercentComplete = 95;
                    }
#else
                    LONG lPercentComplete = (LONG)(((float)lBytesTransferredToApplication/(float)lTotalImageBytes) * 100.0f);
#endif
                    switch (pmdtc->tymed) {
                    case TYMED_MULTIPAGE_CALLBACK:
                    case TYMED_CALLBACK:
                        {
                            hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(IT_MSG_DATA,IT_STATUS_TRANSFER_TO_CLIENT,
                                                                              lPercentComplete,pmdtc->cbOffset,lBytesReceived,pmdtc,0);
                            pmdtc->cbOffset += lBytesReceived;
                            lBytesTransferredToApplication += lBytesReceived;
                        }
                        break;
                    case TYMED_MULTIPAGE_FILE:
                    case TYMED_FILE:
                        {
                            pmdtc->lItemSize = lBytesReceived;
                            hr = wiasWriteBufToFile(0,pmdtc);
                            if (FAILED(hr)) {
                                break;
                            }

                            hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(IT_MSG_STATUS,IT_STATUS_TRANSFER_TO_CLIENT,
                                                                              lPercentComplete,0,0,NULL,0);
                            lBytesTransferredToApplication += lBytesReceived;
                        }
                        break;
                    default:
                        {
                            hr = E_FAIL;
                        }
                        break;
                    }

                    //
                    // scan from device, requesting lBytesToReadFromDevice
                    //

#ifdef UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER

                    //
                    // request buffer size, until the scanner can not return any more data
                    //

                    LONG lBytesRemainingToTransfer = pmdtc->lBufferSize;
#else
                    LONG lBytesRemainingToTransfer = (lTotalImageBytes - lBytesTransferredToApplication);
                    if (lBytesRemainingToTransfer <= 0) {
                        break;
                    }
#endif

                    //
                    // calculate number of bytes to request from device
                    //

                    LONG lBytesToReadFromDevice = (lBytesRemainingToTransfer > pmdtc->lBufferSize) ? pmdtc->lBufferSize : lBytesRemainingToTransfer;

                    // RAW data request
                    lBytesToReadFromDevice = (lBytesToReadFromDevice / lBytesPerLineAligned) * lBytesPerLineRaw;

                    // Aligned data request
                    // lBytesToReadFromDevice = (lBytesToReadFromDevice / lBytesPerLineAligned) * lBytesPerLineAligned;

                    if ((hr == S_FALSE)||FAILED(hr)) {

                        //
                        // user canceled the scan, or the callback failed for some reason
                        //

                        lPagesRequested = 0; // set pages to 0 to cleanly exit loop
                        break;
                    }

                    //
                    // request byte amount from device
                    //

                    hr = m_pScanAPI->FakeScanner_Scan(lScanPhase, pmdtc->pTransferBuffer, lBytesToReadFromDevice, (DWORD*)&lBytesReceived);
                    if (FAILED(hr)) {
                        break;
                    }

                    //
                    // This scanner, when scanning in 24-bit color mode provides RAW data with the RED and BLUE channels
                    // swapped.  If your scanner does this too, then you should call the SwapBuffer24 helper function.
                    //

                    if (pmdtc->lDepth == 24) {

                        //
                        // we are scanning color, so we need to swap the RED and BLUE values becuase our scanner
                        // scans RAW like this.
                        //

                        SwapBuffer24(pmdtc->pTransferBuffer,lBytesReceived);
                    }

                    //
                    // this scanner returns Raw data.  If your scanner does this too, then you should call the AlignInPlace
                    // helper function to align the data.
                    //

                    lBytesReceived = AlignInPlace(pmdtc->pTransferBuffer,lBytesReceived,lBytesPerLineAligned,lBytesPerLineRaw);

                    //
                    // advance to the next scanning stage for the device
                    //

                    if (lScanPhase == SCAN_START) {
                        lScanPhase = SCAN_CONTINUE;
                    }
                } // while ((lBytesReceived))
            }
        }

        //
        // force scanner to return scan head, and close device from scanning session
        //

        HRESULT Temphr = m_pScanAPI->FakeScanner_Scan(SCAN_END, NULL, 0, NULL);
        if (FAILED(Temphr)) {

            //
            // scanner failed to park scanner head in start position
            //

        }

        //
        // free any allocated memory for buffers
        //

        if (!pmdtc->bClassDrvAllocBuf) {
            CoTaskMemFree(pmdtc->pTransferBuffer);
            pmdtc->pTransferBuffer = NULL;
            pmdtc->lBufferSize = 0;
        }

#ifdef UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER

        //
        // because we are scanning with a feeder that can not determine the page height, it is necessary
        // for the driver to update the final file created.  Since this device scans only BMP files, it
        // is easy to locate the BITMAPINFOHEADER, and BITMAPFILEHEADER and update the final values.
        // Values that should be updated for BMP files:
        //
        // BITMAPFILEINFO   - bfSize      = final file size
        // BITMAPINFOHEADER - biHeight    = final image height in pixels
        // BITMAPINFOHEADER - biSizeImage = final image size
        //

        if ((pmdtc->tymed == TYMED_FILE)&&(pmdtc->guidFormatID == WiaImgFmt_BMP)) {

            BYTE BMPHeaderData[sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER)];
            memset(BMPHeaderData,0,sizeof(BMPHeaderData));

            //
            // read BMP header, already written to the file
            //

            if (SetFilePointer((HANDLE)UlongToPtr(pmdtc->hFile),0,NULL,FILE_BEGIN) != INVALID_SET_FILE_POINTER) {

                DWORD dwBytesReadFromFile = 0;
                if (ReadFile((HANDLE)UlongToPtr(pmdtc->hFile),(BYTE*)BMPHeaderData,sizeof(BMPHeaderData),&dwBytesReadFromFile,NULL)) {

                    //
                    // validate that the read was successful, by comparing sizes
                    //

                    if ((LONG)dwBytesReadFromFile != sizeof(BMPHeaderData)) {
                        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("Header was not read from the file correctly"));
                    }

                    //
                    // adjust BMP HEADER values
                    //

                    BITMAPINFOHEADER UNALIGNED *pBMPInfoHeader = (BITMAPINFOHEADER*)(&BMPHeaderData[0] + sizeof(BITMAPFILEHEADER));
                    BITMAPFILEHEADER UNALIGNED *pBMPFileHeader = (BITMAPFILEHEADER*)BMPHeaderData;

                    LONG lDepth = 0;
                    hr = wiasReadPropLong(pWiasContext, WIA_IPA_DEPTH, &lDepth,NULL,TRUE);
                    if (S_OK == hr) {
                        LONG lPixelsPerLine = 0;
                        hr = wiasReadPropLong(pWiasContext, WIA_IPA_PIXELS_PER_LINE, &lPixelsPerLine,NULL,TRUE);
                        if (S_OK == hr) {
                            LONG lBytesPerLineRaw     = ((lPixelsPerLine * lDepth) + 7) / 8;
                            LONG lBytesPerLineAligned = (lPixelsPerLine * lDepth) + 31;
                            lBytesPerLineAligned      = (lBytesPerLineAligned / 8) & 0xfffffffc;

                            pBMPInfoHeader->biHeight    = (lBytesTransferredToApplication / lBytesPerLineAligned);
                            pBMPInfoHeader->biSizeImage = (pBMPInfoHeader->biHeight * lBytesPerLineAligned);
                            pBMPFileHeader->bfSize      = pBMPInfoHeader->biSizeImage + pBMPFileHeader->bfOffBits;

                            //
                            // write BMP header, back to the file
                            //

                            if (SetFilePointer((HANDLE)UlongToPtr(pmdtc->hFile),0,NULL,FILE_BEGIN) != INVALID_SET_FILE_POINTER) {

                                DWORD dwBytesWrittenToFile = 0;
                                WriteFile((HANDLE)UlongToPtr(pmdtc->hFile),(BYTE*)BMPHeaderData,sizeof(BMPHeaderData),&dwBytesWrittenToFile,NULL);

                                //
                                // validate that the write was successful, by comparing sizes
                                //

                                if ((LONG)dwBytesWrittenToFile != sizeof(BMPHeaderData)) {
                                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ScanItem, Header was not written to file correctly"));
                                }
                            } else {

                                //
                                // could not set file pointer to beginning of file
                                //

                                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, SetFilePointer Failed to set file pointer to the beginning of the file"));
                                hr = E_FAIL;
                            }
                        } else {
                            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, wiasReadPropLong Failed to read WIA_IPA_PIXELS_PER_LINE"));
                            WIAS_LHRESULT(m_pIWiaLog, hr);
                        }
                    } else {
                        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, wiasReadPropLong Failed to read WIA_IPA_DEPTH"));
                        WIAS_LHRESULT(m_pIWiaLog, hr);
                    }
                } else {
                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, ReadFile Failed to read data file"));
                    hr = E_FAIL;
                }
            } else {

                //
                // could not set file pointer to beginning of file
                //

                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, SetFilePointer Failed to set file pointer to the beginning of the file"));
                hr = E_FAIL;
            }
        }

#endif


        //
        // if the scan is going well, we should decrement the pages requested counter
        //

        if (S_OK == hr) {

            //
            // decrease the pages requested counter
            //

            lPagesRequested--;

            //
            // if we were asked to scan all pages in the document feeder, then
            // keep the pages request counter above 0 to stay in the loop
            //

            if (bEmptyTheADF) {
                lPagesRequested = 1;
            }

            //
            // only send ENDOFPAGE messages when the driver is set to a CALLBACK mode
            //

            if ((pmdtc->tymed == TYMED_CALLBACK)||(pmdtc->tymed == TYMED_MULTIPAGE_CALLBACK)) {
                //
                // send the NEW_PAGE message, when scanning multiple pages
                // in callback mode.  This will let the calling application
                // know when an end-of-page has been hit.
                //

                hr = wiasSendEndOfPage(pWiasContext, lPagesScanned, pmdtc);
                if (FAILED(hr)) {
                    lPagesRequested = 0;
                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, wiasSendEndOfPage Failed"));
                    WIAS_LHRESULT(m_pIWiaLog, hr);
                }
            }

            //
            // incremement number of pages scanned
            //

            lPagesScanned++;

        }

    } // while (lPagesRequested > 0)
    return hr;
}

/**************************************************************************\
* CWIADevice::drvInitItemProperties
*
*   drvInitItemProperties is called to initialize the WIA properties for
*   the requested item.  To find out what item is being initialized, use the
*   pWiasContext pointer to identify it.
*
*   This method is called for every item in the tree that is accessed by
*   an application.  If an application attempts to read a WIA property on an
*   item for the first time, the WIA service will ask the WIA driver to
*   initialize the WIA property set for that item.  Once the WIA property
*   set has been initialized, any other reads/writes on that WIA item will
*   not produce a drvInitItemProperties call.
*
*   After a drvInitItemProperties method call, the WIA item is marked as
*   initialized and is ready for use. (This is on a per-application connection
*   basis.)
*
* Arguments:
*
*   pWiasContext - Pointer to WIA context (item information).
*   lFlags       - Operation flags, unused.
*   plDevErrVal  - Pointer to the device error value.
*
*
* Return Value:
*
*   S_OK  - if the operation was successful
*   E_xxx - Error code if the operation failed
*
* Sample Notes:
*   This WIA driver sample calls the internal helper functions
*   BuildRootItemProperties(), and BuildChildItemProperties() to assist in the
*   construction of the WIA item property sets.
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIADevice::drvInitItemProperties(BYTE *pWiasContext,LONG lFlags,LONG *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::drvInitItemProperties");
    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if (!pWiasContext) {
        return E_INVALIDARG;
    }

    if (!plDevErrVal) {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    //
    //  This device doesn't touch hardware to initialize the device item
    //  properties, so set plDevErrVal to 0.
    //

    *plDevErrVal = 0;

    //
    //  Get a pointer to the associated driver item.
    //

    IWiaDrvItem* pDrvItem;
    hr = wiasGetDrvItem(pWiasContext, &pDrvItem);
    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, wiasGetDrvItem failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    //  Set initial item properties.
    //

    LONG    lItemType = 0;

    pDrvItem->GetItemFlags(&lItemType);

    if (lItemType & WiaItemTypeRoot) {

        //
        //  This is for the root item.
        //

        //
        // Build Root Item Properties, initializing global
        // structures with their default and valid values
        //

        hr = BuildRootItemProperties();

        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, BuildRootItemProperties failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            DeleteRootItemProperties();
            return hr;
        }

        //
        //  Add the device specific root item property names,
        //  using WIA service.
        //

        hr = wiasSetItemPropNames(pWiasContext,
                                  m_RootItemInitInfo.lNumProps,
                                  m_RootItemInitInfo.piPropIDs,
                                  m_RootItemInitInfo.pszPropNames);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, wiasSetItemPropNames failed"));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_NumRootItemPropeties = %d",m_RootItemInitInfo.lNumProps));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_RootItemInitInfo.piPropIDs   = %x",m_RootItemInitInfo.piPropIDs));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_RootItemInitInfo.pszPropNames  = %x",m_RootItemInitInfo.pszPropNames));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            DeleteRootItemProperties();
            return hr;
        }

        //
        //  Set the device specific root item properties to
        //  their default values using WIA service.
        //

        hr = wiasWriteMultiple(pWiasContext,
                               m_RootItemInitInfo.lNumProps,
                               m_RootItemInitInfo.psPropSpec,
                               m_RootItemInitInfo.pvPropVars);
        //
        // Free PROPVARIANT array, This frees any memory that was allocated for a prop variant value.
        //

        // FreePropVariantArray(m_RootItemInitInfo.lNumProps,m_RootItemInitInfo.pvPropVars);


        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, wiasWriteMultiple failed"));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_NumRootItemPropeties = %d",m_RootItemInitInfo.lNumProps));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_RootItemInitInfo.pszPropNames  = %x",m_RootItemInitInfo.pszPropNames));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_RootItemInitInfo.pvPropVars   = %x",m_RootItemInitInfo.pvPropVars));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            DeleteRootItemProperties();
            return hr;
        }

        //
        //  Use WIA services to set the property access and
        //  valid value information from m_wpiItemDefaults.
        //

        hr =  wiasSetItemPropAttribs(pWiasContext,
                                     m_RootItemInitInfo.lNumProps,
                                     m_RootItemInitInfo.psPropSpec,
                                     m_RootItemInitInfo.pwpiPropInfo);

        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, wiasSetItemPropAttribs failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
        }

        //
        // free allocated property arrays, for more memory
        //

        DeleteRootItemProperties();
    } else {

        //
        //  This is for the child item.(Top)
        //

        //
        // Build Top Item Properties, initializing global
        // structures with their default and valid values
        //

        hr = BuildChildItemProperties();

        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, BuildChildItemProperties failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            DeleteChildItemProperties();
            return hr;
        }

        //
        //  Use the WIA service to set the item property names.
        //

        hr = wiasSetItemPropNames(pWiasContext,
                                  m_ChildItemInitInfo.lNumProps,
                                  m_ChildItemInitInfo.piPropIDs,
                                  m_ChildItemInitInfo.pszPropNames);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, wiasSetItemPropNames failed"));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_NumItemPropeties = %d",m_ChildItemInitInfo.lNumProps));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_ChildItemInitInfo.piPropIDs   = %x",m_ChildItemInitInfo.piPropIDs));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_ChildItemInitInfo.pszPropNames  = %x",m_ChildItemInitInfo.pszPropNames));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            DeleteChildItemProperties();
            return hr;
        }

        //
        //  Use WIA services to set the item properties to their default
        //  values.
        //

        hr = wiasWriteMultiple(pWiasContext,
                               m_ChildItemInitInfo.lNumProps,
                               m_ChildItemInitInfo.psPropSpec,
                               m_ChildItemInitInfo.pvPropVars);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, wiasWriteMultiple failed"));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_NumItemPropeties = %d",m_ChildItemInitInfo.lNumProps));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_ChildItemInitInfo.pszPropNames  = %x",m_ChildItemInitInfo.pszPropNames));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_ChildItemInitInfo.pvPropVars   = %x",m_ChildItemInitInfo.pvPropVars));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            DeleteChildItemProperties();
            return hr;
        }

        //
        //  Use WIA services to set the property access and
        //  valid value information from m_wpiItemDefaults.
        //

        hr =  wiasSetItemPropAttribs(pWiasContext,
                                     m_ChildItemInitInfo.lNumProps,
                                     m_ChildItemInitInfo.psPropSpec,
                                     m_ChildItemInitInfo.pwpiPropInfo);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, wiasSetItemPropAttribs failed"));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_NumItemPropeties = %d",m_ChildItemInitInfo.lNumProps));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_ChildItemInitInfo.psPropSpec   = %x",m_ChildItemInitInfo.psPropSpec));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_ChildItemInitInfo.pwpiPropInfo  = %x",m_ChildItemInitInfo.pwpiPropInfo));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            DeleteChildItemProperties();
            return hr;
        }

        //
        //  Set item size properties.
        //

        hr = SetItemSize(pWiasContext);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, SetItemSize failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
        }

        //
        // free allocated property arrays, for more memory
        //

        DeleteChildItemProperties();
    }
    return hr;
}


/**************************************************************************\
* CWIADevice::drvValidateItemProperties
*
*   drvValidateItemProperties is called when changes are made
*   to an item's WIA properties.  The WIA driver should not only check that
*   the values are valid, but must update any valid values that may change
*   as a result.
*
*   If an a WIA property is not being written by the application, and it's value
*   is invalid, then "fold" it to a new value, else fail validation (because
*   the application is setting the property to an invalid value).
*
* Arguments:
*
*   pWiasContext - Pointer to the WIA item, unused.
*   lFlags       - Operation flags, unused.
*   nPropSpec    - The number of properties that are being written
*   pPropSpec    - An array of PropSpecs identifying the properties that
*                  are being written.
*   plDevErrVal  - Pointer to the device error value.
*
* Return Value:
*
*   S_OK  - if the operation was successful
*   E_xxx - if the operation failed.
*
* History:
*
*    03/05/2002 Original Version
***************************************************************************/

HRESULT _stdcall CWIADevice::drvValidateItemProperties(
                                                             BYTE           *pWiasContext,
                                                             LONG           lFlags,
                                                             ULONG          nPropSpec,
                                                             const PROPSPEC *pPropSpec,
                                                             LONG           *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::drvValidateItemProperties");

    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if (!pWiasContext) {
        return E_INVALIDARG;
    }

    if (!plDevErrVal) {
        return E_INVALIDARG;
    }

    if (!pPropSpec) {
        return E_INVALIDARG;
    }

    HRESULT hr      = S_OK;
    LONG lItemType  = 0;
    WIA_PROPERTY_CONTEXT Context;

    *plDevErrVal = 0;

    hr = wiasGetItemType(pWiasContext, &lItemType);
    if (SUCCEEDED(hr)) {
        if (lItemType & WiaItemTypeRoot) {

            //
            //  Validate root item
            //

            hr = wiasCreatePropContext(nPropSpec,
                                       (PROPSPEC*)pPropSpec,
                                       0,
                                       NULL,
                                       &Context);
            if (SUCCEEDED(hr)) {

                //
                // Check ADF to see if the status settings need to be updated
                // Also switch between FEEDER/FLATBED modes
                //

                hr = CheckADFStatus(pWiasContext, &Context);
                if (FAILED(hr)) {
                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, CheckADFStatus failed"));
                    WIAS_LHRESULT(m_pIWiaLog, hr);
                }

                //
                // check Preview Property only if validation is successful so far....
                //

                if (SUCCEEDED(hr)) {

                    //
                    // Check Preview property to see if the settings are valid
                    //

                    hr = CheckPreview(pWiasContext, &Context);
                    if (SUCCEEDED(hr)) {

                        //
                        // call WIA service helper to validate other properties
                        //

                        hr = wiasValidateItemProperties(pWiasContext, nPropSpec, pPropSpec);
                        if (FAILED(hr)) {
                            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, wiasValidateItemProperties failed."));
                            WIAS_LHRESULT(m_pIWiaLog, hr);
                        }

                    } else {
                        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, CheckPreview failed"));
                        WIAS_LHRESULT(m_pIWiaLog, hr);
                    }
                }
            } else {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, wiasCreatePropContext failed (Root Item)"));
                WIAS_LHRESULT(m_pIWiaLog, hr);
            }

        } else {

            //
            // validate item properties here
            //

            //
            //  Create a property context needed by some WIA Service
            //  functions used below.
            //

            hr = wiasCreatePropContext(nPropSpec,
                                       (PROPSPEC*)pPropSpec,
                                       0,
                                       NULL,
                                       &Context);
            if (SUCCEEDED(hr)) {

                //
                //  Check Current Intent first
                //

                hr = CheckIntent(pWiasContext, &Context);
                if (SUCCEEDED(hr)) {

                    //
                    //  Check if DataType is being written
                    //

                    hr = CheckDataType(pWiasContext, &Context);
                    if (SUCCEEDED(hr)) {

                        //
                        //  Use the WIA service to update the scan rect
                        //  properties and valid values.
                        //

                        LONG lBedWidth  = 0;
                        LONG lBedHeight = 0;

                        hr = m_pScanAPI->FakeScanner_GetBedWidthAndHeight(&lBedWidth,&lBedHeight);
                        if (FAILED(hr)) {
                            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, FakeScanner_GetBedWidthAndHeight failed"));
                            WIAS_LHRESULT(m_pIWiaLog, hr);
                            return hr;
                        }

#ifdef UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER

                        //
                        // the unknown length feeder only scanner, formally called the scrollfed scanner
                        // has a fixed width, and only scans full pages.
                        //

                        lBedHeight = 0;

                        hr = CheckXExtent(pWiasContext,&Context,lBedWidth);
#else
                        hr = wiasUpdateScanRect(pWiasContext,&Context,lBedWidth,lBedHeight);
#endif
                        if (SUCCEEDED(hr)) {

                            //
                            //  Use the WIA Service to update the valid values
                            //  for Format.  These are based on the value of
                            //  WIA_IPA_TYMED, so validation is also performed
                            //  on the tymed property by the service.
                            //

                            hr = wiasUpdateValidFormat(pWiasContext,
                                                       &Context,
                                                       (IWiaMiniDrv*) this);

                            if (SUCCEEDED(hr)) {

                                //
                                // Check Preferred format
                                //

                                hr = CheckPreferredFormat(pWiasContext, &Context);
                                if (FAILED(hr)) {
                                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, CheckPreferredFormat failed"));
                                    WIAS_LHRESULT(m_pIWiaLog, hr);
                                }
                            } else {
                                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, wiasUpdateValidFormat failed"));
                                WIAS_LHRESULT(m_pIWiaLog, hr);
                            }
                        } else {
                            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, wiasUpdateScanRect failed"));
                            WIAS_LHRESULT(m_pIWiaLog, hr);
                        }
                    } else {
                        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, CheckDataType failed"));
                        WIAS_LHRESULT(m_pIWiaLog, hr);
                    }
                } else {
                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, CheckIntent failed"));
                    WIAS_LHRESULT(m_pIWiaLog, hr);
                }
                wiasFreePropContext(&Context);
            } else {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, wiasCreatePropContext failed (Child Item)"));
                WIAS_LHRESULT(m_pIWiaLog, hr);
            }

            //
            //  Update the item size
            //

            if (SUCCEEDED(hr)) {
                hr = SetItemSize(pWiasContext);
                if (FAILED(hr)) {
                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, SetItemSize failed"));
                    WIAS_LHRESULT(m_pIWiaLog, hr);
                }
            }

            //
            // call WIA service helper to validate other properties
            //

            if (SUCCEEDED(hr)) {

                //
                // check image format property, and validate our pages valid values
                //

                hr = UpdateValidPages(pWiasContext,&Context);
                if (SUCCEEDED(hr)) {
                    hr = wiasValidateItemProperties(pWiasContext, nPropSpec, pPropSpec);
                    if (FAILED(hr)) {
                        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, wiasValidateItemProperties failed."));
                        WIAS_LHRESULT(m_pIWiaLog, hr);
                    }
                } else {
                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, UpdateValidPages failed"));
                    WIAS_LHRESULT(m_pIWiaLog, hr);
                }
            }
        }
    } else {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, wiasGetItemType failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
    }

    //
    // log HRESULT sent back to caller
    //

    if (FAILED(hr)) {
        WIAS_LHRESULT(m_pIWiaLog, hr);
    }

    return hr;
}

/**************************************************************************\
* CWIADevice::drvWriteItemProperties
*
*   drvWriteItemProperties is called by the WIA Service prior to
*   drvAcquireItemData when the client requests a data transfer.  The WIA
*   should commit any settings it needs to the hardware before returning
*   from this method.
*
*   When this method is called, the WIA driver has been commited to
*   performing a data transfer.  Any application that attempts to acquire
*   data at this time, will be failed by the WIA service with a
*   WIA_ERROR_BUSY.
*
* Arguments:
*
*   pWiasContext - Pointer to WIA item.
*   lFlags       - Operation flags, unused.
*   pmdtc        - Pointer to mini driver context. On entry, only the
*                  portion of the mini driver context which is derived
*                  from the item properties is filled in.
*   plDevErrVal  - Pointer to the device error value.
*
* Return Value:
*
*   S_OK  - if the operation was successful
*   E_xxx - if the operation failed
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIADevice::drvWriteItemProperties(
                                                          BYTE                      *pWiasContext,
                                                          LONG                      lFlags,
                                                          PMINIDRV_TRANSFER_CONTEXT pmdtc,
                                                          LONG                      *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::drvWriteItemProperties");
    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if (!pWiasContext) {
        return E_INVALIDARG;
    }

    if (!plDevErrVal) {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    *plDevErrVal = 0;
    LONG lNumProperties = 9;
    PROPVARIANT pv[9];
    PROPSPEC ps[9] = {
        {PRSPEC_PROPID, WIA_IPS_XRES},
        {PRSPEC_PROPID, WIA_IPS_YRES},
        {PRSPEC_PROPID, WIA_IPS_XPOS},
        {PRSPEC_PROPID, WIA_IPS_YPOS},
        {PRSPEC_PROPID, WIA_IPS_XEXTENT},
        {PRSPEC_PROPID, WIA_IPS_YEXTENT},
        {PRSPEC_PROPID, WIA_IPA_DATATYPE},
        {PRSPEC_PROPID, WIA_IPS_BRIGHTNESS},
        {PRSPEC_PROPID, WIA_IPS_CONTRAST}
    };

    //
    // initialize propvariant structures
    //

    for (int i = 0; i< lNumProperties;i++) {
        pv[i].vt = VT_I4;
    }

    //
    // read child item properties
    //

    hr = wiasReadMultiple(pWiasContext, lNumProperties, ps, pv, NULL);

    if (hr == S_OK) {

        hr = m_pScanAPI->FakeScanner_SetXYResolution(pv[0].lVal,pv[1].lVal);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,
                        WIALOG_NO_RESOURCE_ID,
                        ("ScanItem, Setting x any y resolutions failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }

        hr = m_pScanAPI->FakeScanner_SetDataType(pv[6].lVal);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,
                        WIALOG_NO_RESOURCE_ID,
                        ("ScanItem, Setting data type failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }

        hr = m_pScanAPI->FakeScanner_SetIntensity(pv[7].lVal);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,
                        WIALOG_NO_RESOURCE_ID,
                        ("ScanItem, Setting intensity failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }

        hr = m_pScanAPI->FakeScanner_SetContrast(pv[8].lVal);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,
                        WIALOG_NO_RESOURCE_ID,
                        ("ScanItem, Setting contrast failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }

        hr = m_pScanAPI->FakeScanner_SetSelectionArea(pv[2].lVal, pv[3].lVal, pv[4].lVal, pv[5].lVal);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,
                        WIALOG_NO_RESOURCE_ID,
                        ("ScanItem, Setting selection area (extents) failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }
    }
    return hr;
}

/**************************************************************************\
* CWIADevice::drvReadItemProperties
*
*   drvReadItemProperties is called when an application tries to
*   read a WIA Item's properties. The WIA Service will first notify
*   the driver by calling this method.
*   The WIA driver should verify that the property being read is accurate.
*   This is a good place to access the hardware for properties that require
*   device status.
*   WIA_DPS_DOCUMENT_HANDLING_STATUS, or WIA_DPA_DEVICE_TIME if your device
*   supports a clock.
*
*   NOTE:  The WIA driver should only go to the hardware on rare occasions.
*          communicating with the hardware too much in this call, will cause
*          the WIA driver to appear sluggish and slow.
*
* Arguments:
*
*   pWiasContext - wia item
*   lFlags       - Operation flags, unused.
*   nPropSpec    - Number of elements in pPropSpec.
*   pPropSpec    - Pointer to property specification, showing which properties
*                  the application wants to read.
*   plDevErrVal  - Pointer to the device error value.
*
* Return Value:
*
*   S_OK  - if the operation was successful
*   E_xxx - Error code, if the operation failed
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIADevice::drvReadItemProperties(
                                                         BYTE           *pWiasContext,
                                                         LONG           lFlags,
                                                         ULONG          nPropSpec,
                                                         const PROPSPEC *pPropSpec,
                                                         LONG           *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::drvReadItemProperties");
    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if (!pWiasContext) {
        return E_INVALIDARG;
    }

    if (!plDevErrVal) {
        return E_INVALIDARG;
    }

    if (!pPropSpec) {
        return E_INVALIDARG;
    }

    *plDevErrVal = 0;
    return S_OK;
}

/**************************************************************************\
* CWIADevice::drvLockWiaDevice
*
*   drvLockWiaDevice will be called by the WIA service when access to the
*   device is needed.  Application's can not call this method directly.
*   The WIA driver should see many drvLockWiaDevice() method calls followed
*   by drvUnLockWiaDevice() method calls for most of the WIA operations on
*   the device.
*
*   It is recommended for the WIA driver to all the IStiDevice::LockDevice()
*   method off of the interface passed in during the drvInitializeWia() method
*   call.  This will ensure that device locking is performed correctly by the
*   WIA service.  The WIA service will assist in keeping multiple client
*   applications from connecting to the WIA driver at the same time.
*
* Arguments:
*
*   pWiasContext - unused, can be NULL
*   lFlags       - Operation flags, unused.
*   plDevErrVal  - Pointer to the device error value.
*
*
* Return Value:
*
*   S_OK  - if the lock was successful
*   E_xxx - Error code, if the operation failed
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIADevice::drvLockWiaDevice(
                                                    BYTE *pWiasContext,
                                                    LONG lFlags,
                                                    LONG *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::drvLockWiaDevice");
    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if (!pWiasContext) {
        return E_INVALIDARG;
    }

    if (!plDevErrVal) {
        return E_INVALIDARG;
    }

    *plDevErrVal = 0;
    return m_pStiDevice->LockDevice(m_dwLockTimeout);
}

/**************************************************************************\
* CWIADevice::drvUnLockWiaDevice
*
*   drvUnLockWiaDevice will be called by the WIA service when access to the
*   device needs to be released.  Application's can not call this method directly.
*
*   It is recommended for the WIA driver to all the IStiDevice::UnLockDevice()
*   method off of the interface passed in during the drvInitializeWia() method
*   call.  This will ensure that device unlocking is performed correctly by the
*   WIA service.  The WIA service will assist in keeping multiple client
*   applications from connecting to the WIA driver at the same time.
*
* Arguments:
*
*   pWiasContext - Pointer to the WIA item, unused.
*   lFlags       - Operation flags, unused.
*   plDevErrVal  - Pointer to the device error value.
*
* Return Value:
*
*   S_OK  - if the unlock was successful
*   E_xxx - Error code, if the operation failed
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIADevice::drvUnLockWiaDevice(
                                                      BYTE *pWiasContext,
                                                      LONG lFlags,
                                                      LONG *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::drvUnLockWiaDevice");
    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if (!pWiasContext) {
        return E_INVALIDARG;
    }

    if (!plDevErrVal) {
        return E_INVALIDARG;
    }

    *plDevErrVal = 0;
    return m_pStiDevice->UnLockDevice();
}

/**************************************************************************\
* CWIADevice::drvAnalyzeItem
*
*   drvAnalyzeItem is called by the WIA service in response to the application
*   call IWiaItem::AnalyzeItem() method call.
*
*   The WIA driver should analyze the passed in WIA item (found by using
*   the pWiasContext) and create/generate sub items.
*
*   This feature of WIA is not currently used by any applications and is
*   still being reviewed for more details.
*
* Arguments:
*
*   pWiasContext - Pointer to the device item to be analyzed.
*   lFlags       - Operation flags.
*   plDevErrVal  - Pointer to the device error value.
*
* Return Value:
*
*   S_OK  - if the operation was successful
*   E_xxx - Error code, if the operation failed
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIADevice::drvAnalyzeItem(
                                                  BYTE *pWiasContext,
                                                  LONG lFlags,
                                                  LONG *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::drvAnalyzeItem");
    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if (!pWiasContext) {
        return E_INVALIDARG;
    }

    if (!plDevErrVal) {
        return E_INVALIDARG;
    }

    *plDevErrVal = 0;
    return E_NOTIMPL;
}

/**************************************************************************\
* drvGetDeviceErrorStr
*
*   drvGetDeviceErrorStr is called by the WIA service to get more information
*   about device specific error codes returned by each WIA driver method call.
*   The WIA driver should map the incoming code to a user-readable string
*   explaining the details of the error.
*
* Arguments:
*
*   lFlags        - Operation flags, unused.
*   lDevErrVal    - Device error value.
*   ppszDevErrStr - Pointer to returned error string.
*   plDevErrVal   - Pointer to the device error value.
*
*
* Return Value:
*
*   S_OK  - if the operation was successful
*   E_xxx - Error code, if the operation failed
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIADevice::drvGetDeviceErrorStr(
                                                        LONG     lFlags,
                                                        LONG     lDevErrVal,
                                                        LPOLESTR *ppszDevErrStr,
                                                        LONG     *plDevErr)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::drvGetDeviceErrorStr");
    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if (!ppszDevErrStr) {
        return E_INVALIDARG;
    }

    if (!plDevErr) {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    //
    //  Map device errors to a strings
    //

    switch (lDevErrVal) {
    case 0:
        *ppszDevErrStr = NULL;
        *plDevErr  = 0;
        break;
    default:
        *ppszDevErrStr = NULL;
        *plDevErr  = 0;
        break;
    }
    return hr;
}

/**************************************************************************\
* drvDeviceCommand
*
*   drvDeviceCommand is called by the WIA service is response to the
*   application's call to IWiaItem::DeviceCommand method.
*   The WIA driver should process the received device command targeted to
*   the incoming WIA item. (determine the WIA item to receive the device
*   command by using the pWiasContext pointer).
*
*   Any command sent to the WIA driver that is not supported, should be
*   failed with an E_INVALIDARG error code.
*
* Arguments:
*
*   pWiasContext - Pointer to the WIA item.
*   lFlags       - Operation flags, unused.
*   plCommand    - Pointer to command GUID.
*   ppWiaDrvItem - Optional pointer to returned item, unused.
*   plDevErrVal  - Pointer to the device error value.
*
* Return Value:
*
*   S_OK  - if the command was successfully processed
*   E_xxx - Error code, if the operation failed.
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIADevice::drvDeviceCommand(
                                                    BYTE        *pWiasContext,
                                                    LONG        lFlags,
                                                    const GUID  *plCommand,
                                                    IWiaDrvItem **ppWiaDrvItem,
                                                    LONG        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::drvDeviceCommand");

    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if (!pWiasContext) {
        return E_INVALIDARG;
    }

    if (!plDevErrVal) {
        return E_INVALIDARG;
    }

    if (!plCommand) {
        return E_INVALIDARG;
    }

    *plDevErrVal = 0;
    HRESULT hr = S_OK;

    //
    //  Check which command was issued
    //

    if (*plCommand == WIA_CMD_SYNCHRONIZE) {
        hr = S_OK;
    } else {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvDeviceCommand, unknown command sent to this device"));
        hr = E_NOTIMPL;
    }

    return hr;
}


/**************************************************************************\
* CWIADevice::drvGetCapabilities
*
*   drvGetCapabilities is called by the WIA service to obtain the WIA device
*   supported EVENTS and COMMANDS.
*
*   The WIA driver should first look at the incoming ulFlags parameter to
*   determine what request it should be answering:
*   The following requests are used:
*
*       WIA_DEVICE_COMMANDS - requesting device commands only
*       WIA_DEVICE_EVENTS   - requesting device events only
*       WIA_DEVICE_COMMANDS|WIA_DEVICE_EVENTS - requesting commands and events.
*
*    The WIA driver should allocate memory (to be stored in this WIA driver
*    and freed by this WIA driver) to contain an array of WIA_DEV_CAP_DRV
*    structures. A pointer to this WIA driver allocated memory should be
*    assigned to ppCapabilities.
*
*    IMPORTANT NOTE!!! - The WIA service will not free this memory.  It is up
*                        up to the WIA driver to manage the allocated memory.
*
*    The WIA driver should place the number of structures allocated in the
*    out parameter called pcelt.
*
*    The WIA device should fill out each of the WIA_DEV_CAP_DRV structure fields
*    with the following information.
*
*        guid           = Event or Command GUID
*        ulFlags        = Event or Command FLAGS
*        wszName        = Event or Command NAME
*        wszDescription = Event or Command DESCRIPTION
*        wszIcon        = Event or Command ICON
*
*
*
* Arguments:
*
*   pWiasContext   - Pointer to the WIA item, unused.
*   lFlags         - Operation flags.
*   pcelt          - Pointer to returned number of elements in
*                    returned array.
*   ppCapabilities - Pointer to driver allocate and managed array.
*   plDevErrVal    - Pointer to the device error value.
*
* Return Value:
*
*   S_OK  - if the operation was successful
*   E_xxx - Error code, if the operation failed
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIADevice::drvGetCapabilities(
                                                      BYTE            *pWiasContext,
                                                      LONG            ulFlags,
                                                      LONG            *pcelt,
                                                      WIA_DEV_CAP_DRV **ppCapabilities,
                                                      LONG            *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::drvGetCapabilites");
    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if (!pWiasContext) {

        //
        // The WIA service may pass in a NULL for the pWiasContext. This is expected
        // because there is a case where no item was created at the time the event was fired.
        //
    }

    if (!plDevErrVal) {
        return E_INVALIDARG;
    }

    if (!pcelt) {
        return E_INVALIDARG;
    }

    if (!ppCapabilities) {
        return E_INVALIDARG;
    }

    *plDevErrVal = 0;

    HRESULT hr = S_OK;

    //
    // Initialize Capabilities array
    //

    hr = BuildCapabilities();

    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvGetCapabilities, BuildCapabilities failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    //  Return depends on flags.  Flags specify whether we should return
    //  commands, events, or both.
    //
    //

    switch (ulFlags) {
    case WIA_DEVICE_COMMANDS:

        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvGetCapabilities, (WIA_DEVICE_COMMANDS)"));

        //
        //  report commands only
        //

        *pcelt          = m_NumSupportedCommands;
        *ppCapabilities = &m_pCapabilities[m_NumSupportedEvents];
        break;
    case WIA_DEVICE_EVENTS:

        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvGetCapabilities, (WIA_DEVICE_EVENTS)"));

        //
        //  report events only
        //

        *pcelt          = m_NumSupportedEvents;
        *ppCapabilities = m_pCapabilities;
        break;
    case (WIA_DEVICE_COMMANDS | WIA_DEVICE_EVENTS):

        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvGetCapabilities, (WIA_DEVICE_COMMANDS|WIA_DEVICE_EVENTS)"));

        //
        //  report both events and commands
        //

        *pcelt          = (m_NumSupportedCommands + m_NumSupportedEvents);
        *ppCapabilities = m_pCapabilities;
        break;
    default:

        //
        //  invalid request
        //

        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvGetCapabilities, invalid flags"));
        return E_INVALIDARG;
    }

    return hr;
}

/**************************************************************************\
* CWIADevice::drvDeleteItem
*
*   drvDeleteItem is called by the WIA service when a WIA application calls
*   IWiaItem::DeleteItem() method to delete a WIA item.
*
*   The WIA service will verify the following before calling this method.
*       1. The item is NOT a root item.
*       2. The item is a folder, and has NO children
*       3. The item's access rights allow deletion.
*
*   Since the the WIA service verifies these conditions, it is NOT necessary
*   for the WIA driver to also verify them.
*
* Arguments:
*
*   pWiasContext  - Indicates the item to delete.
*   lFlags        - Operation flags, unused.
*   plDevErrVal   - Pointer to the device error value.
*
* Return Value:
*
*   S_OK - if the delete operation was successful
*   E_xxx - Error code, if the delete operation failed
*
* History:
*
*     03/05/2002 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIADevice::drvDeleteItem(
                                                 BYTE *pWiasContext,
                                                 LONG lFlags,
                                                 LONG *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::drvDeleteItem");

    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if (!pWiasContext) {
        return E_INVALIDARG;
    }

    if (!plDevErrVal) {
        return E_INVALIDARG;
    }

    *plDevErrVal = 0;

    //
    // if this functionality is not supported on this item, then return
    // STG_E_ACCESSDENIED as the error code.
    //

    return STG_E_ACCESSDENIED;
}

/**************************************************************************\
* CWIADevice::drvFreeDrvItemContext
*
*   drvFreeDrvItemContext is called by the WIA service to free any WIA driver
*   allocated device specific context information.
*
* Arguments:
*
*   lFlags          - Operation flags, unused.
*   pDevSpecContext - Pointer to device specific context.
*   plDevErrVal     - Pointer to the device error value.
*
* Return Value:
*
*   S_OK  - if the operation was successful
*   E_xxx - Error code, if the operation failed.
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIADevice::drvFreeDrvItemContext(
                                                         LONG lFlags,
                                                         BYTE *pSpecContext,
                                                         LONG *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::drvFreeDrvItemContext");

    if (!plDevErrVal) {
        return E_INVALIDARG;
    }

    *plDevErrVal = 0;
    PMINIDRIVERITEMCONTEXT pContext = NULL;
    pContext = (PMINIDRIVERITEMCONTEXT) pSpecContext;

    if (pContext) {
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvFreeDrvItemContext, Freeing my allocated context members"));
    }

    return S_OK;
}

/**************************************************************************\
* drvGetWiaFormatInfo
*
*   drvGetWiaFormatInfo is called by the WIA service to obtain the WIA device
*   supported TYMED and FORMAT pairs.
*
*    The WIA driver should allocate memory (to be stored in this WIA driver
*    and freed by this WIA driver) to contain an array of WIA_FORMAT_INFO
*    structures. A pointer to this WIA driver allocated memory should be
*    assigned to ppwfi.
*
*    IMPORTANT NOTE!!! - The WIA service will not free this memory.  It is up
*                        up to the WIA driver to manage the allocated memory.
*
*    The WIA driver should place the number of structures allocated in the
*    out parameter called pcelt.
*
*    The WIA device should fill out each of the WIA_FORMAT_INFO structure fields
*    with the following information.
*
*        guidFormatID  = Image Format GUID
*        lTymed        = TYMED associated with the Image Format GUID
*           Valid TYMEDs are: (Also known as "Media Type")
*               TYMED_FILE
*               TYMED_MULTIPAGE_FILE
*               TYMED_CALLBACK
*               TYMED_MULTIPAGE_CALLBACK
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA item context, unused.
*   lFlags          - Operation flags, unused.
*   pcelt           - Pointer to returned number of elements in
*                     returned WIA_FORMAT_INFO array.
*   ppwfi           - Pointer to returned WIA_FORMAT_INFO array.
*   plDevErrVal     - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*   03/05/2002 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIADevice::drvGetWiaFormatInfo(
                                                       BYTE            *pWiasContext,
                                                       LONG            lFlags,
                                                       LONG            *pcelt,
                                                       WIA_FORMAT_INFO **ppwfi,
                                                       LONG            *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::drvGetWiaFormatInfo");

    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if (!pWiasContext) {
        return E_INVALIDARG;
    }

    if (!plDevErrVal) {
        return E_INVALIDARG;
    }

    if (!pcelt) {
        return E_INVALIDARG;
    }

    if (!ppwfi) {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    if (NULL == m_pSupportedFormats) {
        hr = BuildSupportedFormats();
    }

    *plDevErrVal = 0;
    *pcelt       = m_NumSupportedFormats;
    *ppwfi       = m_pSupportedFormats;
    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvGetWiaFormatInfo, m_NumSupportedFormats = %d",m_NumSupportedFormats));
    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvGetWiaFormatInfo, m_pSupportedFormats   = %x",m_pSupportedFormats));
    return hr;
}

/**************************************************************************\
* drvNotifyPnpEvent
*
*   drvNotifyPnpEvent is called by the WIA service when system events occur.
*   The WIA driver should check the pEventGUID parameter to determine what
*   event is being processed.
*   Some common events that need to be processed are:
*
*       WIA_EVENT_POWER_SUSPEND - system is going to suspend/sleep mode
*       WIA_EVENT_POWER_RESUME  - system is waking up from suspend/sleep mode
*           The WIA driver should restore any event interrrupt wait states
*           after returning from a suspend.  This will ensure that the events
*           will still function when the system wakes up.
*
* Arguments:
*
*   pEventGUID   - Pointer to an event GUID
*   bstrDeviceID - Device ID
*   ulReserved   - reserved
*
* Return Value:
*
*   S_OK  - if the operation completed successfully
*   E_xxx - Error code if the operation failed
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIADevice::drvNotifyPnpEvent(
                                                     const GUID *pEventGUID,
                                                     BSTR       bstrDeviceID,
                                                     ULONG      ulReserved)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::DrvNotifyPnpEvent");

    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if ((!pEventGUID)||(!bstrDeviceID)) {
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;

    if(*pEventGUID == WIA_EVENT_POWER_SUSPEND) {

        //
        // disable any driver activity to make sure we properly
        // shutdown (the driver is not being unloaded, just disabled)
        //

    } else if(*pEventGUID == WIA_EVENT_POWER_RESUME) {

        //
        // re-establish any event notifications to make sure we properly setup
        // any event waiting status using the WIA service supplied event
        // handle
        //

        if(m_EventOverlapped.hEvent) {

            //
            // call ourselves with the cached EVENT handle given to
            // the WIA driver by the WIA service.
            //

            SetNotificationHandle(m_EventOverlapped.hEvent);
        }
    }

    return hr;
}

/**************************************************************************\
* CWIADevice::drvUnInitializeWia
*
*   drvUnInitializeWia is called by the WIA service when an application
*   releases its last reference to any WIA items created.
*
*   NOTE: This call does not mean all clients are disconnected.  There
*         should be one call per client disconnect.
*
*   drvUnInitializeWia should be paired with a corresponding drvInitializeWia
*   call.
*
*   The WIA driver should NOT free any driver resources in this method
*   call unless it can safely determine that NO applications are
*   currently connected.
*
*   To determine the current application connection count, the WIA driver
*   can keep a reference counter in the method calls to drvInitializeWia()
*   (incrementing the counter) and drvUnInitializeWia() (decrementing the counter).
*
* Arguments:
*
*   pWiasContext - Pointer to the WIA Root item context of the client's
*                  item tree.
*
* Return Value:
*   S_OK  - if the operation completed successfully
*   E_xxx - Error code, if the operation failed
*
* History:
*
*   03/05/2002 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIADevice::drvUnInitializeWia(
                                                      BYTE *pWiasContext)
{
    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if (!pWiasContext) {
        return E_INVALIDARG;
    }

    InterlockedDecrement(&m_lClientsConnected);

    //
    // make sure we never decrement below zero (0)
    //

    if(m_lClientsConnected < 0){
        m_lClientsConnected = 0;
    }

    //
    // check for connected applications.
    //

    if(m_lClientsConnected == 0){

        //
        // There are no application clients connected to this WIA driver
        //

    }

    return S_OK;
}

/*******************************************************************************
*
*                 P R I V A T E   M E T H O D S
*
*******************************************************************************/

/**************************************************************************\
* AlignInPlace
*
*   DWORD align a data buffer in place.
*
* Arguments:
*
*   pBuffer              - Pointer to the data buffer.
*   cbWritten            - Size of the data in bytes.
*   lBytesPerScanLine    - Number of bytes per scan line in the output data.
*   lBytesPerScanLineRaw - Number of bytes per scan line in the input data.
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

UINT CWIADevice::AlignInPlace(
                                    PBYTE pBuffer,
                                    LONG  cbWritten,
                                    LONG  lBytesPerScanLine,
                                    LONG  lBytesPerScanLineRaw)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "::AlignInPlace");

    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if (!pBuffer) {
        return 0;
    }

    if ((lBytesPerScanLine <= 0)||(lBytesPerScanLineRaw <= 0)) {
        return 0;
    }

    if (lBytesPerScanLineRaw % 4) {

        UINT  uiPadBytes          = lBytesPerScanLine - lBytesPerScanLineRaw;
        UINT  uiDevLinesWritten   = cbWritten / lBytesPerScanLineRaw;

        PBYTE pSrc = pBuffer + cbWritten - 1;
        PBYTE pDst = pBuffer + (uiDevLinesWritten * lBytesPerScanLine) - 1;

        while (pSrc >= pBuffer) {
            pDst -= uiPadBytes;

            for (LONG i = 0; i < lBytesPerScanLineRaw; i++) {
                *pDst-- = *pSrc--;
            }
        }
        return uiDevLinesWritten * lBytesPerScanLine;
    }
    return cbWritten;
}

/**************************************************************************\
* UnlinkItemTree
*
*   Call device manager to unlink and release our reference to
*   all items in the driver item tree.
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

HRESULT CWIADevice::DeleteItemTree(void)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIADevice::DeleteItemTree");
    HRESULT hr = S_OK;

    //
    // If no tree, return.
    //

    if (!m_pIDrvItemRoot) {
        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("DeleteItemTree, no tree to delete..."));
        return S_OK;
    }

    //
    //  Call device manager to unlink the driver item tree.
    //

    hr = m_pIDrvItemRoot->UnlinkItemTree(WiaItemTypeDisconnected);

    if (SUCCEEDED(hr)) {
        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("DeleteItemTree, m_pIDrvItemRoot is being released!!"));
        m_pIDrvItemRoot->Release();
        m_pIDrvItemRoot = NULL;
    }

    return hr;
}

/**************************************************************************\
* DeleteRootItemProperties
*
*   This helper deletes the arrays used for Property intialization.
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

HRESULT CWIADevice::DeleteRootItemProperties()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::DeleteRootItemProperties");

    HRESULT hr = S_OK;

    //
    // delete any allocated arrays
    //

    DeleteSupportedPreviewModesArrayContents();

    if (NULL != m_RootItemInitInfo.pszPropNames) {
        delete [] m_RootItemInitInfo.pszPropNames;
        m_RootItemInitInfo.pszPropNames = NULL;
    }

    if (NULL != m_RootItemInitInfo.piPropIDs) {
        delete [] m_RootItemInitInfo.piPropIDs;
        m_RootItemInitInfo.piPropIDs = NULL;
    }

    if (NULL != m_RootItemInitInfo.pvPropVars) {
        FreePropVariantArray(m_RootItemInitInfo.lNumProps,m_RootItemInitInfo.pvPropVars);
        delete [] m_RootItemInitInfo.pvPropVars;
        m_RootItemInitInfo.pvPropVars = NULL;
    }

    if (NULL != m_RootItemInitInfo.psPropSpec) {
        delete [] m_RootItemInitInfo.psPropSpec;
        m_RootItemInitInfo.psPropSpec = NULL;
    }

    if (NULL != m_RootItemInitInfo.pwpiPropInfo) {
        delete [] m_RootItemInitInfo.pwpiPropInfo;
        m_RootItemInitInfo.pwpiPropInfo = NULL;
    }

    m_RootItemInitInfo.lNumProps = 0;

    return hr;
}

/**************************************************************************\
* BuildRootItemProperties
*
*   This helper creates/initializes the arrays used for Property intialization.
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

HRESULT CWIADevice::BuildRootItemProperties()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::BuildRootItemProperties");

    HRESULT hr = S_OK;
    LONG PropIndex = 0;

#ifdef UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER

    m_RootItemInitInfo.lNumProps = 17;   // standard properties + ADF specific

#else

    //
    // check for ADF
    //

    if (m_pScanAPI->FakeScanner_ADFAttached() == S_OK) {
        m_bADFAttached = TRUE;
    }

    //
    // set the number of properties
    //

    if (m_bADFAttached) {
        m_RootItemInitInfo.lNumProps = 19;   // standard properties + ADF specific
    } else {
        m_RootItemInitInfo.lNumProps = 10;    // standard properties only
    }

#endif

    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("CMicroDriverAPI::BuildRootItemProperties, Number of Properties = %d",m_RootItemInitInfo.lNumProps));

    m_RootItemInitInfo.pszPropNames   = new LPOLESTR[m_RootItemInitInfo.lNumProps];
    if (NULL != m_RootItemInitInfo.pszPropNames) {
        m_RootItemInitInfo.piPropIDs    = new PROPID[m_RootItemInitInfo.lNumProps];
        if (NULL != m_RootItemInitInfo.piPropIDs) {
            m_RootItemInitInfo.pvPropVars    = new PROPVARIANT[m_RootItemInitInfo.lNumProps];
            if (NULL != m_RootItemInitInfo.pvPropVars) {
                m_RootItemInitInfo.psPropSpec    = new PROPSPEC[m_RootItemInitInfo.lNumProps];
                if (NULL != m_RootItemInitInfo.psPropSpec) {
                    m_RootItemInitInfo.pwpiPropInfo   = new WIA_PROPERTY_INFO[m_RootItemInitInfo.lNumProps];
                    if (NULL == m_RootItemInitInfo.pwpiPropInfo)
                        hr = E_OUTOFMEMORY;
                } else
                    hr = E_OUTOFMEMORY;
            } else
                hr = E_OUTOFMEMORY;
        } else
            hr = E_OUTOFMEMORY;
    } else
        hr = E_OUTOFMEMORY;

    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildRootItemProperties, memory allocation failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        DeleteRootItemProperties();
        return hr;
    }

    ROOT_ITEM_INFORMATION RootItemInfo;

    hr = m_pScanAPI->FakeScanner_GetRootPropertyInfo(&RootItemInfo);
    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildRootItemProperties, FakeScanner_GetRootPropertyInfo failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        DeleteRootItemProperties();
        return hr;
    }

#ifndef UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER

    //
    // WIA_DPS_HORIZONTAL_BED_SIZE and WIA_DPS_VERTICAL_BED_SIZE should not exist for scanners
    // that only have a feeder.  Theses are flatbed scanner properties only.
    //

    // Intialize WIA_DPS_HORIZONTAL_BED_SIZE
    m_RootItemInitInfo.pszPropNames[PropIndex]              = WIA_DPS_HORIZONTAL_BED_SIZE_STR;
    m_RootItemInitInfo.piPropIDs [PropIndex]              = WIA_DPS_HORIZONTAL_BED_SIZE;
    m_RootItemInitInfo.pvPropVars [PropIndex].lVal         = RootItemInfo.ScanBedWidth;
    m_RootItemInitInfo.pvPropVars [PropIndex].vt           = VT_I4;
    m_RootItemInitInfo.psPropSpec [PropIndex].ulKind       = PRSPEC_PROPID;
    m_RootItemInitInfo.psPropSpec [PropIndex].propid       = m_RootItemInitInfo.piPropIDs [PropIndex];
    m_RootItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
    m_RootItemInitInfo.pwpiPropInfo[PropIndex].vt           = m_RootItemInitInfo.pvPropVars [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_DPS_VERTICAL_BED_SIZE
    m_RootItemInitInfo.pszPropNames[PropIndex]              = WIA_DPS_VERTICAL_BED_SIZE_STR;
    m_RootItemInitInfo.piPropIDs [PropIndex]              = WIA_DPS_VERTICAL_BED_SIZE;
    m_RootItemInitInfo.pvPropVars [PropIndex].lVal         = RootItemInfo.ScanBedHeight;
    m_RootItemInitInfo.pvPropVars [PropIndex].vt           = VT_I4;
    m_RootItemInitInfo.psPropSpec [PropIndex].ulKind       = PRSPEC_PROPID;
    m_RootItemInitInfo.psPropSpec [PropIndex].propid       = m_RootItemInitInfo.piPropIDs [PropIndex];
    m_RootItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
    m_RootItemInitInfo.pwpiPropInfo[PropIndex].vt           = m_RootItemInitInfo.pvPropVars [PropIndex].vt;

    PropIndex++;

#endif

    // Intialize WIA_IPA_ACCESS_RIGHTS
    m_RootItemInitInfo.pszPropNames[PropIndex]              = WIA_IPA_ACCESS_RIGHTS_STR;
    m_RootItemInitInfo.piPropIDs [PropIndex]              = WIA_IPA_ACCESS_RIGHTS;
    m_RootItemInitInfo.pvPropVars [PropIndex].lVal         = WIA_ITEM_READ|WIA_ITEM_WRITE;
    m_RootItemInitInfo.pvPropVars [PropIndex].vt           = VT_UI4;
    m_RootItemInitInfo.psPropSpec [PropIndex].ulKind       = PRSPEC_PROPID;
    m_RootItemInitInfo.psPropSpec [PropIndex].propid       = m_RootItemInitInfo.piPropIDs [PropIndex];
    m_RootItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
    m_RootItemInitInfo.pwpiPropInfo[PropIndex].vt           = m_RootItemInitInfo.pvPropVars [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_DPS_OPTICAL_XRES
    m_RootItemInitInfo.pszPropNames[PropIndex]              = WIA_DPS_OPTICAL_XRES_STR;
    m_RootItemInitInfo.piPropIDs [PropIndex]              = WIA_DPS_OPTICAL_XRES;
    m_RootItemInitInfo.pvPropVars [PropIndex].lVal         = RootItemInfo.OpticalXResolution;
    m_RootItemInitInfo.pvPropVars [PropIndex].vt           = VT_I4;
    m_RootItemInitInfo.psPropSpec [PropIndex].ulKind       = PRSPEC_PROPID;
    m_RootItemInitInfo.psPropSpec [PropIndex].propid       = m_RootItemInitInfo.piPropIDs [PropIndex];
    m_RootItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
    m_RootItemInitInfo.pwpiPropInfo[PropIndex].vt           = m_RootItemInitInfo.pvPropVars [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_DPS_OPTICAL_YRES
    m_RootItemInitInfo.pszPropNames[PropIndex]              = WIA_DPS_OPTICAL_YRES_STR;
    m_RootItemInitInfo.piPropIDs [PropIndex]              = WIA_DPS_OPTICAL_YRES;
    m_RootItemInitInfo.pvPropVars [PropIndex].lVal         = RootItemInfo.OpticalYResolution;
    m_RootItemInitInfo.pvPropVars [PropIndex].vt           = VT_I4;
    m_RootItemInitInfo.psPropSpec [PropIndex].ulKind       = PRSPEC_PROPID;
    m_RootItemInitInfo.psPropSpec [PropIndex].propid       = m_RootItemInitInfo.piPropIDs [PropIndex];
    m_RootItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
    m_RootItemInitInfo.pwpiPropInfo[PropIndex].vt           = m_RootItemInitInfo.pvPropVars [PropIndex].vt;

    PropIndex++;

    // Initialize WIA_DPA_FIRMWARE_VERSION
    m_RootItemInitInfo.pszPropNames[PropIndex]              = WIA_DPA_FIRMWARE_VERSION_STR;
    m_RootItemInitInfo.piPropIDs [PropIndex]              = WIA_DPA_FIRMWARE_VERSION;
    m_RootItemInitInfo.pvPropVars [PropIndex].bstrVal      = SysAllocString(RootItemInfo.FirmwareVersion);
    m_RootItemInitInfo.pvPropVars [PropIndex].vt           = VT_BSTR;
    m_RootItemInitInfo.psPropSpec [PropIndex].ulKind       = PRSPEC_PROPID;
    m_RootItemInitInfo.psPropSpec [PropIndex].propid       = m_RootItemInitInfo.piPropIDs [PropIndex];
    m_RootItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
    m_RootItemInitInfo.pwpiPropInfo[PropIndex].vt           = m_RootItemInitInfo.pvPropVars [PropIndex].vt;

    PropIndex++;

    // Initialize WIA_IPA_ITEM_FLAGS
    m_RootItemInitInfo.pszPropNames[PropIndex]              = WIA_IPA_ITEM_FLAGS_STR;
    m_RootItemInitInfo.piPropIDs [PropIndex]              = WIA_IPA_ITEM_FLAGS;
    m_RootItemInitInfo.pvPropVars [PropIndex].lVal         = WiaItemTypeRoot|WiaItemTypeFolder|WiaItemTypeDevice;
    m_RootItemInitInfo.pvPropVars [PropIndex].vt           = VT_I4;
    m_RootItemInitInfo.psPropSpec [PropIndex].ulKind       = PRSPEC_PROPID;
    m_RootItemInitInfo.psPropSpec [PropIndex].propid       = m_RootItemInitInfo.piPropIDs [PropIndex];
    m_RootItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_FLAG;
    m_RootItemInitInfo.pwpiPropInfo[PropIndex].vt           = m_RootItemInitInfo.pvPropVars [PropIndex].vt;
    m_RootItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Flag.Nom  = m_RootItemInitInfo.pvPropVars [PropIndex].lVal;
    m_RootItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Flag.ValidBits = WiaItemTypeRoot|WiaItemTypeFolder|WiaItemTypeDevice;

    PropIndex++;

    // Intialize WIA_DPS_MAX_SCAN_TIME (NONE)
    m_RootItemInitInfo.pszPropNames[PropIndex]                    = WIA_DPS_MAX_SCAN_TIME_STR;
    m_RootItemInitInfo.piPropIDs [PropIndex]                    = WIA_DPS_MAX_SCAN_TIME;
    m_RootItemInitInfo.pvPropVars [PropIndex].lVal               = RootItemInfo.MaxScanTime;
    m_RootItemInitInfo.pvPropVars [PropIndex].vt                 = VT_I4;
    m_RootItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_RootItemInitInfo.psPropSpec [PropIndex].propid             = m_RootItemInitInfo.piPropIDs [PropIndex];
    m_RootItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_RootItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_RootItemInitInfo.pvPropVars [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_DPS_PREVIEW (LIST)
    m_RootItemInitInfo.pszPropNames[PropIndex]                    = WIA_DPS_PREVIEW_STR;
    m_RootItemInitInfo.piPropIDs [PropIndex]                    = WIA_DPS_PREVIEW;
    m_RootItemInitInfo.pvPropVars [PropIndex].lVal               = WIA_FINAL_SCAN;
    m_RootItemInitInfo.pvPropVars [PropIndex].vt                 = VT_I4;
    m_RootItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_RootItemInitInfo.psPropSpec [PropIndex].propid             = m_RootItemInitInfo.piPropIDs [PropIndex];
    m_RootItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_LIST;
    m_RootItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_RootItemInitInfo.pvPropVars [PropIndex].vt;
    m_RootItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.List.pList= (BYTE*)m_SupportedPreviewModes.plValues;
    m_RootItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.List.Nom  = m_RootItemInitInfo.pvPropVars [PropIndex].lVal;
    m_RootItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.List.cNumList = m_SupportedPreviewModes.lNumValues;

    PropIndex++;

    // Initialize WIA_DPS_SHOW_PREVIEW_CONTROL (NONE)
    m_RootItemInitInfo.pszPropNames[PropIndex]                    = WIA_DPS_SHOW_PREVIEW_CONTROL_STR;
    m_RootItemInitInfo.piPropIDs [PropIndex]                    = WIA_DPS_SHOW_PREVIEW_CONTROL;

#ifdef UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER

    //
    // Scanners that have a feeder that can not perform a preview scan should set the
    // WIA_DPS_SHOW_PREVIEW_CONTROL property to WIA_DONT_SHOW_PREVIEW_CONTROL.  This
    // will eliminate the preview control from being shown in the Microsoft common UI
    // dialogs, and the Scanner and Camera Wizard.
    //

    m_RootItemInitInfo.pvPropVars [PropIndex].lVal               = WIA_DONT_SHOW_PREVIEW_CONTROL;

#else // UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER

    m_RootItemInitInfo.pvPropVars [PropIndex].lVal               = WIA_SHOW_PREVIEW_CONTROL;

#endif // UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER

    m_RootItemInitInfo.pvPropVars [PropIndex].vt                 = VT_I4;
    m_RootItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_RootItemInitInfo.psPropSpec [PropIndex].propid             = m_RootItemInitInfo.piPropIDs [PropIndex];
    m_RootItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_RootItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_RootItemInitInfo.pvPropVars [PropIndex].vt;

    PropIndex++;

    //
    // if a Document feeder is attached...add the following properties
    //

    if (m_bADFAttached) {

        // Initialize WIA_DPS_HORIZONTAL_SHEET_FEED_SIZE
        m_RootItemInitInfo.pszPropNames[PropIndex]              = WIA_DPS_HORIZONTAL_SHEET_FEED_SIZE_STR;
        m_RootItemInitInfo.piPropIDs [PropIndex]              = WIA_DPS_HORIZONTAL_SHEET_FEED_SIZE;
        m_RootItemInitInfo.pvPropVars [PropIndex].lVal         = RootItemInfo.DocumentFeederWidth;
        m_RootItemInitInfo.pvPropVars [PropIndex].vt           = VT_I4;
        m_RootItemInitInfo.psPropSpec [PropIndex].ulKind       = PRSPEC_PROPID;
        m_RootItemInitInfo.psPropSpec [PropIndex].propid       = m_RootItemInitInfo.piPropIDs [PropIndex];
        m_RootItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
        m_RootItemInitInfo.pwpiPropInfo[PropIndex].vt           = m_RootItemInitInfo.pvPropVars [PropIndex].vt;

        PropIndex++;

        // Initialize WIA_DPS_VERTICAL_SHEET_FEED_SIZE
        m_RootItemInitInfo.pszPropNames[PropIndex]              = WIA_DPS_VERTICAL_SHEET_FEED_SIZE_STR;
        m_RootItemInitInfo.piPropIDs [PropIndex]              = WIA_DPS_VERTICAL_SHEET_FEED_SIZE;

#ifdef UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER

        //
        // scanners that can not determine the length of the page in the feeder should
        // set this property to 0.  This will tell the application that the vertical
        // sheet feed size of the scanner is unknown
        //

        m_RootItemInitInfo.pvPropVars [PropIndex].lVal         = 0;

#else // UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER

        m_RootItemInitInfo.pvPropVars [PropIndex].lVal         = RootItemInfo.DocumentFeederHeight;

#endif // UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER

        m_RootItemInitInfo.pvPropVars [PropIndex].vt           = VT_I4;
        m_RootItemInitInfo.psPropSpec [PropIndex].ulKind       = PRSPEC_PROPID;
        m_RootItemInitInfo.psPropSpec [PropIndex].propid       = m_RootItemInitInfo.piPropIDs [PropIndex];
        m_RootItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
        m_RootItemInitInfo.pwpiPropInfo[PropIndex].vt           = m_RootItemInitInfo.pvPropVars [PropIndex].vt;

        PropIndex++;

        // Initialize WIA_DPS_DOCUMENT_HANDLING_CAPABILITIES
        m_RootItemInitInfo.pszPropNames[PropIndex]              = WIA_DPS_DOCUMENT_HANDLING_CAPABILITIES_STR;
        m_RootItemInitInfo.piPropIDs [PropIndex]              = WIA_DPS_DOCUMENT_HANDLING_CAPABILITIES;
        m_RootItemInitInfo.pvPropVars [PropIndex].lVal         = RootItemInfo.DocumentFeederCaps;
        m_RootItemInitInfo.pvPropVars [PropIndex].vt           = VT_I4;
        m_RootItemInitInfo.psPropSpec [PropIndex].ulKind       = PRSPEC_PROPID;
        m_RootItemInitInfo.psPropSpec [PropIndex].propid       = m_RootItemInitInfo.piPropIDs [PropIndex];
        m_RootItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_FLAG;
        m_RootItemInitInfo.pwpiPropInfo[PropIndex].vt           = m_RootItemInitInfo.pvPropVars [PropIndex].vt;

        PropIndex++;

        // Initialize WIA_DPS_DOCUMENT_HANDLING_STATUS
        m_RootItemInitInfo.pszPropNames[PropIndex]              = WIA_DPS_DOCUMENT_HANDLING_STATUS_STR;
        m_RootItemInitInfo.piPropIDs [PropIndex]              = WIA_DPS_DOCUMENT_HANDLING_STATUS;
        m_RootItemInitInfo.pvPropVars [PropIndex].lVal         = RootItemInfo.DocumentFeederStatus;
        m_RootItemInitInfo.pvPropVars [PropIndex].vt           = VT_I4;
        m_RootItemInitInfo.psPropSpec [PropIndex].ulKind       = PRSPEC_PROPID;
        m_RootItemInitInfo.psPropSpec [PropIndex].propid       = m_RootItemInitInfo.piPropIDs [PropIndex];
        m_RootItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_FLAG;
        m_RootItemInitInfo.pwpiPropInfo[PropIndex].vt           = m_RootItemInitInfo.pvPropVars [PropIndex].vt;

        PropIndex++;

        // Initialize WIA_DPS_DOCUMENT_HANDLING_SELECT
        m_RootItemInitInfo.pszPropNames[PropIndex]              = WIA_DPS_DOCUMENT_HANDLING_SELECT_STR;
        m_RootItemInitInfo.piPropIDs [PropIndex]              = WIA_DPS_DOCUMENT_HANDLING_SELECT;

#ifdef UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER

        //
        // scanners that only have a feeder and no flatbed, should set the WIA_DPS_DOCUMENT_HANDLING_SELECT
        // property to FEEDER as the initial setting.  This will let the application know that the device
        // is currently in FEEDER mode.  The valid values for this property should be set to FEEDER only
        // as well.  This will avoid any applications trying to set the WIA_DPS_DOCUMENT_HANDLING_SELECT
        // property to FLATBED.
        //

        m_RootItemInitInfo.pvPropVars [PropIndex].lVal         = FEEDER;
        m_RootItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Flag.ValidBits = FEEDER;

#else // UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER

        m_RootItemInitInfo.pvPropVars [PropIndex].lVal         = FLATBED;
        m_RootItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Flag.ValidBits = FEEDER | FLATBED;

#endif // UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER

        m_RootItemInitInfo.pvPropVars [PropIndex].vt           = VT_I4;
        m_RootItemInitInfo.psPropSpec [PropIndex].ulKind       = PRSPEC_PROPID;
        m_RootItemInitInfo.psPropSpec [PropIndex].propid       = m_RootItemInitInfo.piPropIDs [PropIndex];
        m_RootItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags = WIA_PROP_RW|WIA_PROP_FLAG;
        m_RootItemInitInfo.pwpiPropInfo[PropIndex].vt           = m_RootItemInitInfo.pvPropVars [PropIndex].vt;
        m_RootItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Flag.Nom  = m_RootItemInitInfo.pvPropVars [PropIndex].lVal;

        PropIndex++;

        // Initialize WIA_DPS_PAGES
        m_RootItemInitInfo.pszPropNames[PropIndex]              = WIA_DPS_PAGES_STR;
        m_RootItemInitInfo.piPropIDs [PropIndex]              = WIA_DPS_PAGES;
        m_RootItemInitInfo.pvPropVars [PropIndex].lVal         = 1;
        m_RootItemInitInfo.pvPropVars [PropIndex].vt           = VT_I4;
        m_RootItemInitInfo.psPropSpec [PropIndex].ulKind       = PRSPEC_PROPID;
        m_RootItemInitInfo.psPropSpec [PropIndex].propid       = m_RootItemInitInfo.piPropIDs [PropIndex];
        m_RootItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags = WIA_PROP_RW|WIA_PROP_RANGE;
        m_RootItemInitInfo.pwpiPropInfo[PropIndex].vt           = m_RootItemInitInfo.pvPropVars [PropIndex].vt;
        m_RootItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Inc = 1;
        m_RootItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Min = 0;
        m_RootItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Max = RootItemInfo.MaxPageCapacity;
        m_RootItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Nom = 1;

        PropIndex++;

        // Initialize WIA_DPS_SHEET_FEEDER_REGISTRATION
        m_RootItemInitInfo.pszPropNames[PropIndex]              = WIA_DPS_SHEET_FEEDER_REGISTRATION_STR;
        m_RootItemInitInfo.piPropIDs [PropIndex]              = WIA_DPS_SHEET_FEEDER_REGISTRATION;
        m_RootItemInitInfo.pvPropVars [PropIndex].lVal         = RootItemInfo.DocumentFeederReg;
        m_RootItemInitInfo.pvPropVars [PropIndex].vt           = VT_I4;
        m_RootItemInitInfo.psPropSpec [PropIndex].ulKind       = PRSPEC_PROPID;
        m_RootItemInitInfo.psPropSpec [PropIndex].propid       = m_RootItemInitInfo.piPropIDs [PropIndex];
        m_RootItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
        m_RootItemInitInfo.pwpiPropInfo[PropIndex].vt           = m_RootItemInitInfo.pvPropVars [PropIndex].vt;

        PropIndex++;

        // Initialize WIA_DPS_HORIZONTAL_BED_REGISTRATION
        m_RootItemInitInfo.pszPropNames[PropIndex]              = WIA_DPS_HORIZONTAL_BED_REGISTRATION_STR;
        m_RootItemInitInfo.piPropIDs [PropIndex]              = WIA_DPS_HORIZONTAL_BED_REGISTRATION;
        m_RootItemInitInfo.pvPropVars [PropIndex].lVal         = RootItemInfo.DocumentFeederHReg;
        m_RootItemInitInfo.pvPropVars [PropIndex].vt           = VT_I4;
        m_RootItemInitInfo.psPropSpec [PropIndex].ulKind       = PRSPEC_PROPID;
        m_RootItemInitInfo.psPropSpec [PropIndex].propid       = m_RootItemInitInfo.piPropIDs [PropIndex];
        m_RootItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
        m_RootItemInitInfo.pwpiPropInfo[PropIndex].vt           = m_RootItemInitInfo.pvPropVars [PropIndex].vt;

        PropIndex++;

        // Initialize WIA_DPS_VERTICAL_BED_REGISTRATION
        m_RootItemInitInfo.pszPropNames[PropIndex]              = WIA_DPS_VERTICAL_BED_REGISTRATION_STR;
        m_RootItemInitInfo.piPropIDs [PropIndex]              = WIA_DPS_VERTICAL_BED_REGISTRATION;
        m_RootItemInitInfo.pvPropVars [PropIndex].lVal         = RootItemInfo.DocumentFeederVReg;
        m_RootItemInitInfo.pvPropVars [PropIndex].vt           = VT_I4;
        m_RootItemInitInfo.psPropSpec [PropIndex].ulKind       = PRSPEC_PROPID;
        m_RootItemInitInfo.psPropSpec [PropIndex].propid       = m_RootItemInitInfo.piPropIDs [PropIndex];
        m_RootItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
        m_RootItemInitInfo.pwpiPropInfo[PropIndex].vt           = m_RootItemInitInfo.pvPropVars [PropIndex].vt;

        PropIndex++;

    }
    return hr;
}

/**************************************************************************\
* DeleteChildItemProperties
*
*   This helper deletes the arrays used for Property intialization.
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

HRESULT CWIADevice::DeleteChildItemProperties()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::DeleteChildItemProperties");

    HRESULT hr = S_OK;

    //
    // delete any allocated arrays
    //

    DeleteSupportedFormatsArrayContents();
    DeleteSupportedDataTypesArrayContents();
    DeleteSupportedCompressionsArrayContents();
    DeleteSupportedTYMEDArrayContents();
    DeleteInitialFormatsArrayContents();
    DeleteSupportedResolutionsArrayContents();

    if (NULL != m_ChildItemInitInfo.pszPropNames) {
        delete [] m_ChildItemInitInfo.pszPropNames;
        m_ChildItemInitInfo.pszPropNames = NULL;
    }

    if (NULL != m_ChildItemInitInfo.piPropIDs) {
        delete [] m_ChildItemInitInfo.piPropIDs;
        m_ChildItemInitInfo.piPropIDs = NULL;
    }

    if (NULL != m_ChildItemInitInfo.pvPropVars) {
        for (LONG lPropIndex = 0; lPropIndex < m_ChildItemInitInfo.lNumProps; lPropIndex++) {

            //
            // set CLSID pointers to NULL, because we freed the memory above.
            // If this pointer is not NULL FreePropVariantArray would
            // try to free it again.
            //

            if (m_ChildItemInitInfo.pvPropVars[lPropIndex].vt == VT_CLSID) {
                m_ChildItemInitInfo.pvPropVars[lPropIndex].puuid = NULL;
            }
        }
        FreePropVariantArray(m_ChildItemInitInfo.lNumProps,m_ChildItemInitInfo.pvPropVars);
        delete [] m_ChildItemInitInfo.pvPropVars;
        m_ChildItemInitInfo.pvPropVars = NULL;
    }

    if (NULL != m_ChildItemInitInfo.psPropSpec) {
        delete [] m_ChildItemInitInfo.psPropSpec;
        m_ChildItemInitInfo.psPropSpec = NULL;
    }

    if (NULL != m_ChildItemInitInfo.pwpiPropInfo) {
        delete [] m_ChildItemInitInfo.pwpiPropInfo;
        m_ChildItemInitInfo.pwpiPropInfo = NULL;
    }

    m_ChildItemInitInfo.lNumProps = 0;

    return hr;
}

/**************************************************************************\
* BuildChlidItemProperties
*
*   This helper creates/initializes the arrays used for Property intialization.
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

HRESULT CWIADevice::BuildChildItemProperties()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::BuildChildItemProperties");

    HRESULT hr = S_OK;

    m_ChildItemInitInfo.lNumProps = 29;
    m_ChildItemInitInfo.pszPropNames   = new LPOLESTR[m_ChildItemInitInfo.lNumProps];
    if (NULL != m_ChildItemInitInfo.pszPropNames) {
        m_ChildItemInitInfo.piPropIDs    = new PROPID[m_ChildItemInitInfo.lNumProps];
        if (NULL != m_ChildItemInitInfo.piPropIDs) {
            m_ChildItemInitInfo.pvPropVars    = new PROPVARIANT[m_ChildItemInitInfo.lNumProps];
            if (NULL != m_ChildItemInitInfo.pvPropVars) {
                m_ChildItemInitInfo.psPropSpec    = new PROPSPEC[m_ChildItemInitInfo.lNumProps];
                if (NULL != m_ChildItemInitInfo.psPropSpec) {
                    m_ChildItemInitInfo.pwpiPropInfo   = new WIA_PROPERTY_INFO[m_ChildItemInitInfo.lNumProps];
                    if (NULL == m_ChildItemInitInfo.pwpiPropInfo)
                        hr = E_OUTOFMEMORY;
                } else
                    hr = E_OUTOFMEMORY;
            } else
                hr = E_OUTOFMEMORY;
        } else
            hr = E_OUTOFMEMORY;
    } else
        hr = E_OUTOFMEMORY;

    if (FAILED(hr)) {
        DeleteChildItemProperties();
        return hr;
    }

    ROOT_ITEM_INFORMATION RootItemInfo;
    hr = m_pScanAPI->FakeScanner_GetRootPropertyInfo(&RootItemInfo);
    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildChildItemProperties, FakeScanner_GetRootPropertyInfo failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        DeleteChildItemProperties();
        return hr;
    }

    TOP_ITEM_INFORMATION TopItemInfo;
    hr = m_pScanAPI->FakeScanner_GetTopPropertyInfo(&TopItemInfo);
    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildChildItemProperties, FakeScanner_GetTopPropertyInfo failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        DeleteChildItemProperties();
        return hr;
    }

    LONG PropIndex = 0;

    // Intialize WIA_IPS_XRES (LIST)
    m_ChildItemInitInfo.pszPropNames[PropIndex]                    = WIA_IPS_XRES_STR;
    m_ChildItemInitInfo.piPropIDs [PropIndex]                    = WIA_IPS_XRES;
    m_ChildItemInitInfo.pvPropVars [PropIndex].lVal               = m_SupportedResolutions.plValues[0];
    m_ChildItemInitInfo.pvPropVars [PropIndex].vt                 = VT_I4;
    m_ChildItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].propid             = m_ChildItemInitInfo.piPropIDs [PropIndex];
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_LIST;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_ChildItemInitInfo.pvPropVars [PropIndex].vt;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.List.pList= (BYTE*)m_SupportedResolutions.plValues;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.List.Nom  = m_ChildItemInitInfo.pvPropVars [PropIndex].lVal;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.List.cNumList = m_SupportedResolutions.lNumValues;

    PropIndex++;

    // Intialize WIA_IPS_YRES (LIST)
    m_ChildItemInitInfo.pszPropNames[PropIndex]                    = WIA_IPS_YRES_STR;
    m_ChildItemInitInfo.piPropIDs [PropIndex]                    = WIA_IPS_YRES;
    m_ChildItemInitInfo.pvPropVars [PropIndex].lVal               = m_SupportedResolutions.plValues[0];
    m_ChildItemInitInfo.pvPropVars [PropIndex].vt                 = VT_I4;
    m_ChildItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].propid             = m_ChildItemInitInfo.piPropIDs [PropIndex];
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_LIST;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_ChildItemInitInfo.pvPropVars [PropIndex].vt;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.List.pList= (BYTE*)m_SupportedResolutions.plValues;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.List.Nom  = m_ChildItemInitInfo.pvPropVars [PropIndex].lVal;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.List.cNumList = m_SupportedResolutions.lNumValues;

    PropIndex++;

    // Intialize WIA_IPS_XEXTENT (RANGE)
    m_ChildItemInitInfo.pszPropNames[PropIndex]                    = WIA_IPS_XEXTENT_STR;
    m_ChildItemInitInfo.piPropIDs [PropIndex]                    = WIA_IPS_XEXTENT;
    m_ChildItemInitInfo.pvPropVars [PropIndex].lVal               = ((m_ChildItemInitInfo.pvPropVars [PropIndex-2].lVal * RootItemInfo.ScanBedWidth)/1000);
    m_ChildItemInitInfo.pvPropVars [PropIndex].vt                 = VT_I4;
    m_ChildItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].propid             = m_ChildItemInitInfo.piPropIDs [PropIndex];
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_ChildItemInitInfo.pvPropVars [PropIndex].vt;

#ifdef UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER

    //
    // scanners that have a fixed width should set the valid values for WIA_IPS_XEXTENT to reflect that.
    // This will let the application know that this device has this behavior.
    //

    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;

#else

    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Inc = 1;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Min = 1;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Max = m_ChildItemInitInfo.pvPropVars [PropIndex].lVal;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Nom = m_ChildItemInitInfo.pvPropVars [PropIndex].lVal;

#endif

    PropIndex++;

    // Intialize WIA_IPS_YEXTENT (RANGE)
    m_ChildItemInitInfo.pszPropNames[PropIndex]                    = WIA_IPS_YEXTENT_STR;
    m_ChildItemInitInfo.piPropIDs [PropIndex]                    = WIA_IPS_YEXTENT;
    m_ChildItemInitInfo.pvPropVars [PropIndex].vt                 = VT_I4;
    m_ChildItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].propid             = m_ChildItemInitInfo.piPropIDs [PropIndex];
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_ChildItemInitInfo.pvPropVars [PropIndex].vt;
    m_ChildItemInitInfo.pvPropVars [PropIndex].lVal               = ((m_ChildItemInitInfo.pvPropVars [PropIndex-2].lVal * RootItemInfo.ScanBedHeight)/1000);
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Inc = 1;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Min = 1;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Max = m_ChildItemInitInfo.pvPropVars [PropIndex].lVal;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Nom = m_ChildItemInitInfo.pvPropVars [PropIndex].lVal;

#ifdef UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER

    //
    // scanners that have a feeder that can not determine the length of the page, should
    // have 0 as the valid values for WIA_IPS_YEXTENT.  This will let the application
    // know that this device has this behavior.
    //

    m_ChildItemInitInfo.pvPropVars [PropIndex].lVal               = 0;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Min = 0;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Max = 0;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Nom = 0;

#endif

    PropIndex++;

    // Intialize WIA_IPS_XPOS (RANGE)
    m_ChildItemInitInfo.pszPropNames[PropIndex]                    = WIA_IPS_XPOS_STR;
    m_ChildItemInitInfo.piPropIDs [PropIndex]                    = WIA_IPS_XPOS;
    m_ChildItemInitInfo.pvPropVars [PropIndex].lVal               = 0;
    m_ChildItemInitInfo.pvPropVars [PropIndex].vt                 = VT_I4;
    m_ChildItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].propid             = m_ChildItemInitInfo.piPropIDs [PropIndex];
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_ChildItemInitInfo.pvPropVars [PropIndex].vt;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Inc = 1;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Min = 0;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Max = (m_ChildItemInitInfo.pwpiPropInfo[PropIndex-2].ValidVal.Range.Max - 1);
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Nom = m_ChildItemInitInfo.pvPropVars [PropIndex].lVal;

#ifdef UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER

    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Min = 0;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Max = 0;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Nom = 0;

#endif

    PropIndex++;

    // Intialize WIA_IPS_YPOS (RANGE)
    m_ChildItemInitInfo.pszPropNames[PropIndex]                    = WIA_IPS_YPOS_STR;
    m_ChildItemInitInfo.piPropIDs [PropIndex]                    = WIA_IPS_YPOS;
    m_ChildItemInitInfo.pvPropVars [PropIndex].lVal               = 0;
    m_ChildItemInitInfo.pvPropVars [PropIndex].vt                 = VT_I4;
    m_ChildItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].propid             = m_ChildItemInitInfo.piPropIDs [PropIndex];
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_ChildItemInitInfo.pvPropVars [PropIndex].vt;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Inc = 1;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Min = 0;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Max = (m_ChildItemInitInfo.pwpiPropInfo[PropIndex-2].ValidVal.Range.Max - 1);
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Nom = m_ChildItemInitInfo.pvPropVars [PropIndex].lVal;

#ifdef UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER

    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Min = 0;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Max = 0;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Nom = 0;

#endif

    PropIndex++;

    // Intialize WIA_IPA_DATATYPE (LIST)
    m_ChildItemInitInfo.pszPropNames[PropIndex]                    = WIA_IPA_DATATYPE_STR;
    m_ChildItemInitInfo.piPropIDs [PropIndex]                    = WIA_IPA_DATATYPE;
    m_ChildItemInitInfo.pvPropVars [PropIndex].lVal               = INITIAL_DATATYPE;
    m_ChildItemInitInfo.pvPropVars [PropIndex].vt                 = VT_I4;
    m_ChildItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].propid             = m_ChildItemInitInfo.piPropIDs [PropIndex];
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_LIST;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_ChildItemInitInfo.pvPropVars [PropIndex].vt;

    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.List.pList    = (BYTE*)m_SupportedDataTypes.plValues;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.List.Nom      = m_ChildItemInitInfo.pvPropVars [PropIndex].lVal;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.List.cNumList = m_SupportedDataTypes.lNumValues;

    PropIndex++;

    // Intialize WIA_IPA_DEPTH (NONE)
    m_ChildItemInitInfo.pszPropNames[PropIndex]                    = WIA_IPA_DEPTH_STR;
    m_ChildItemInitInfo.piPropIDs [PropIndex]                    = WIA_IPA_DEPTH;
    m_ChildItemInitInfo.pvPropVars [PropIndex].lVal               = INITIAL_BITDEPTH;
    m_ChildItemInitInfo.pvPropVars [PropIndex].vt                 = VT_I4;
    m_ChildItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].propid             = m_ChildItemInitInfo.piPropIDs [PropIndex];
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_ChildItemInitInfo.pvPropVars [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPS_BRIGHTNESS (RANGE)
    m_ChildItemInitInfo.pszPropNames[PropIndex]                    = WIA_IPS_BRIGHTNESS_STR;
    m_ChildItemInitInfo.piPropIDs [PropIndex]                    = WIA_IPS_BRIGHTNESS;
    m_ChildItemInitInfo.pvPropVars [PropIndex].lVal               = TopItemInfo.Brightness.lNom;
    m_ChildItemInitInfo.pvPropVars [PropIndex].vt                 = VT_I4;
    m_ChildItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].propid             = m_ChildItemInitInfo.piPropIDs [PropIndex];
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_ChildItemInitInfo.pvPropVars [PropIndex].vt;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Inc = TopItemInfo.Brightness.lInc;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Min = TopItemInfo.Brightness.lMin;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Max = TopItemInfo.Brightness.lMax;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Nom = TopItemInfo.Brightness.lNom;

    PropIndex++;

    // Intialize WIA_IPS_CONTRAST (RANGE)
    m_ChildItemInitInfo.pszPropNames[PropIndex]                    = WIA_IPS_CONTRAST_STR;
    m_ChildItemInitInfo.piPropIDs [PropIndex]                    = WIA_IPS_CONTRAST;
    m_ChildItemInitInfo.pvPropVars [PropIndex].lVal               = TopItemInfo.Contrast.lNom;
    m_ChildItemInitInfo.pvPropVars [PropIndex].vt                 = VT_I4;
    m_ChildItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].propid             = m_ChildItemInitInfo.piPropIDs [PropIndex];
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_ChildItemInitInfo.pvPropVars [PropIndex].vt;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Inc = TopItemInfo.Contrast.lInc;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Min = TopItemInfo.Contrast.lMin;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Max = TopItemInfo.Contrast.lMax;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Nom = TopItemInfo.Contrast.lNom;

    PropIndex++;

    // Intialize WIA_IPS_CUR_INTENT (FLAG)
    m_ChildItemInitInfo.pszPropNames[PropIndex]                    = WIA_IPS_CUR_INTENT_STR;
    m_ChildItemInitInfo.piPropIDs [PropIndex]                    = WIA_IPS_CUR_INTENT;
    m_ChildItemInitInfo.pvPropVars [PropIndex].lVal               = WIA_INTENT_NONE;
    m_ChildItemInitInfo.pvPropVars [PropIndex].vt                 = VT_I4;
    m_ChildItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].propid             = m_ChildItemInitInfo.piPropIDs [PropIndex];
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_FLAG;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_ChildItemInitInfo.pvPropVars [PropIndex].vt;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Flag.Nom  = m_ChildItemInitInfo.pvPropVars [PropIndex].lVal;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Flag.ValidBits = WIA_INTENT_IMAGE_TYPE_COLOR | WIA_INTENT_IMAGE_TYPE_GRAYSCALE |
                                                           WIA_INTENT_IMAGE_TYPE_TEXT  | WIA_INTENT_MINIMIZE_SIZE |
                                                           WIA_INTENT_MAXIMIZE_QUALITY;

    PropIndex++;

    // Intialize WIA_IPA_PIXELS_PER_LINE (NONE)
    m_ChildItemInitInfo.pszPropNames[PropIndex]                    = WIA_IPA_PIXELS_PER_LINE_STR;
    m_ChildItemInitInfo.piPropIDs [PropIndex]                    = WIA_IPA_PIXELS_PER_LINE;
    m_ChildItemInitInfo.pvPropVars [PropIndex].lVal               = m_ChildItemInitInfo.pvPropVars [PropIndex-9].lVal;
    m_ChildItemInitInfo.pvPropVars [PropIndex].vt                 = VT_I4;
    m_ChildItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].propid             = m_ChildItemInitInfo.piPropIDs [PropIndex];
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_ChildItemInitInfo.pvPropVars [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPA_NUMER_OF_LINES (NONE)
    m_ChildItemInitInfo.pszPropNames[PropIndex]                    = WIA_IPA_NUMBER_OF_LINES_STR;
    m_ChildItemInitInfo.piPropIDs [PropIndex]                    = WIA_IPA_NUMBER_OF_LINES;
    m_ChildItemInitInfo.pvPropVars [PropIndex].lVal               = m_ChildItemInitInfo.pvPropVars [PropIndex-9].lVal;
    m_ChildItemInitInfo.pvPropVars [PropIndex].vt                 = VT_I4;
    m_ChildItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].propid             = m_ChildItemInitInfo.piPropIDs [PropIndex];
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_ChildItemInitInfo.pvPropVars [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPA_PREFERRED_FORMAT (NONE)
    m_ChildItemInitInfo.pszPropNames[PropIndex]                    = WIA_IPA_PREFERRED_FORMAT_STR;
    m_ChildItemInitInfo.piPropIDs [PropIndex]                    = WIA_IPA_PREFERRED_FORMAT;
    m_ChildItemInitInfo.pvPropVars [PropIndex].puuid              = &m_pInitialFormats[0];
    m_ChildItemInitInfo.pvPropVars [PropIndex].vt                 = VT_CLSID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].propid             = m_ChildItemInitInfo.piPropIDs [PropIndex];
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_ChildItemInitInfo.pvPropVars [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPA_ITEM_SIZE (NONE)
    m_ChildItemInitInfo.pszPropNames[PropIndex]                    = WIA_IPA_ITEM_SIZE_STR;
    m_ChildItemInitInfo.piPropIDs [PropIndex]                    = WIA_IPA_ITEM_SIZE;
    m_ChildItemInitInfo.pvPropVars [PropIndex].lVal               = 0;
    m_ChildItemInitInfo.pvPropVars [PropIndex].vt                 = VT_I4;
    m_ChildItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].propid             = m_ChildItemInitInfo.piPropIDs [PropIndex];
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_ChildItemInitInfo.pvPropVars [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPS_THRESHOLD (RANGE)
    m_ChildItemInitInfo.pszPropNames[PropIndex]                    = WIA_IPS_THRESHOLD_STR;
    m_ChildItemInitInfo.piPropIDs [PropIndex]                    = WIA_IPS_THRESHOLD;
    m_ChildItemInitInfo.pvPropVars [PropIndex].lVal               = TopItemInfo.Threshold.lNom;
    m_ChildItemInitInfo.pvPropVars [PropIndex].vt                 = VT_I4;
    m_ChildItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].propid             = m_ChildItemInitInfo.piPropIDs [PropIndex];
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_ChildItemInitInfo.pvPropVars [PropIndex].vt;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Inc = TopItemInfo.Threshold.lInc;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Min = TopItemInfo.Threshold.lMin;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Max = TopItemInfo.Threshold.lMax;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Range.Nom = TopItemInfo.Threshold.lNom;

    PropIndex++;

    // Intialize WIA_IPA_FORMAT (LIST)
    m_ChildItemInitInfo.pszPropNames[PropIndex]                    = WIA_IPA_FORMAT_STR;
    m_ChildItemInitInfo.piPropIDs [PropIndex]                    = WIA_IPA_FORMAT;
    m_ChildItemInitInfo.pvPropVars [PropIndex].puuid              = &m_pInitialFormats[0];
    m_ChildItemInitInfo.pvPropVars [PropIndex].vt                 = VT_CLSID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].propid             = m_ChildItemInitInfo.piPropIDs [PropIndex];
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_LIST;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_ChildItemInitInfo.pvPropVars [PropIndex].vt;

    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.ListGuid.pList    = m_pInitialFormats;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.ListGuid.Nom      = *m_ChildItemInitInfo.pvPropVars[PropIndex].puuid;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.ListGuid.cNumList = m_NumInitialFormats;

    PropIndex++;

    // Intialize WIA_IPA_FILENAME_EXTENSION (NONE)
    m_ChildItemInitInfo.pszPropNames[PropIndex]                    = WIA_IPA_FILENAME_EXTENSION_STR;
    m_ChildItemInitInfo.piPropIDs [PropIndex]                    = WIA_IPA_FILENAME_EXTENSION;
    m_ChildItemInitInfo.pvPropVars [PropIndex].bstrVal            = SysAllocString(L"BMP");
    m_ChildItemInitInfo.pvPropVars [PropIndex].vt                 = VT_BSTR;
    m_ChildItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].propid             = m_ChildItemInitInfo.piPropIDs [PropIndex];
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_ChildItemInitInfo.pvPropVars [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPA_TYMED (LIST)
    m_ChildItemInitInfo.pszPropNames[PropIndex]                    = WIA_IPA_TYMED_STR;
    m_ChildItemInitInfo.piPropIDs [PropIndex]                    = WIA_IPA_TYMED;
    m_ChildItemInitInfo.pvPropVars [PropIndex].lVal               = INITIAL_TYMED;
    m_ChildItemInitInfo.pvPropVars [PropIndex].vt                 = VT_I4;
    m_ChildItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].propid             = m_ChildItemInitInfo.piPropIDs [PropIndex];
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_LIST;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_ChildItemInitInfo.pvPropVars [PropIndex].vt;

    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.List.pList    = (BYTE*)m_SupportedTYMED.plValues;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.List.Nom      = m_ChildItemInitInfo.pvPropVars [PropIndex].lVal;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.List.cNumList = m_SupportedTYMED.lNumValues;

    PropIndex++;

    // Intialize WIA_IPA_CHANNELS_PER_PIXEL (NONE)
    m_ChildItemInitInfo.pszPropNames[PropIndex]                    = WIA_IPA_CHANNELS_PER_PIXEL_STR;
    m_ChildItemInitInfo.piPropIDs [PropIndex]                    = WIA_IPA_CHANNELS_PER_PIXEL;
    m_ChildItemInitInfo.pvPropVars [PropIndex].lVal               = INITIAL_CHANNELS_PER_PIXEL;
    m_ChildItemInitInfo.pvPropVars [PropIndex].vt                 = VT_I4;
    m_ChildItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].propid             = m_ChildItemInitInfo.piPropIDs [PropIndex];
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_ChildItemInitInfo.pvPropVars [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPA_BITS_PER_CHANNEL (NONE)
    m_ChildItemInitInfo.pszPropNames[PropIndex]                    = WIA_IPA_BITS_PER_CHANNEL_STR;
    m_ChildItemInitInfo.piPropIDs [PropIndex]                    = WIA_IPA_BITS_PER_CHANNEL;
    m_ChildItemInitInfo.pvPropVars [PropIndex].lVal               = INITIAL_BITS_PER_CHANNEL;
    m_ChildItemInitInfo.pvPropVars [PropIndex].vt                 = VT_I4;
    m_ChildItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].propid             = m_ChildItemInitInfo.piPropIDs [PropIndex];
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_ChildItemInitInfo.pvPropVars [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPA_PLANAR (NONE)
    m_ChildItemInitInfo.pszPropNames[PropIndex]                    = WIA_IPA_PLANAR_STR;
    m_ChildItemInitInfo.piPropIDs [PropIndex]                    = WIA_IPA_PLANAR;
    m_ChildItemInitInfo.pvPropVars [PropIndex].lVal               = INITIAL_PLANAR;
    m_ChildItemInitInfo.pvPropVars [PropIndex].vt                 = VT_I4;
    m_ChildItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].propid             = m_ChildItemInitInfo.piPropIDs [PropIndex];
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_ChildItemInitInfo.pvPropVars [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPA_BYTES_PER_LINE (NONE)
    m_ChildItemInitInfo.pszPropNames[PropIndex]                    = WIA_IPA_BYTES_PER_LINE_STR;
    m_ChildItemInitInfo.piPropIDs [PropIndex]                    = WIA_IPA_BYTES_PER_LINE;
    m_ChildItemInitInfo.pvPropVars [PropIndex].lVal               = 0;
    m_ChildItemInitInfo.pvPropVars [PropIndex].vt                 = VT_I4;
    m_ChildItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].propid             = m_ChildItemInitInfo.piPropIDs [PropIndex];
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_ChildItemInitInfo.pvPropVars [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPA_MIN_BUFFER_SIZE (NONE)
    m_ChildItemInitInfo.pszPropNames[PropIndex]                    = WIA_IPA_MIN_BUFFER_SIZE_STR;
    m_ChildItemInitInfo.piPropIDs [PropIndex]                    = WIA_IPA_MIN_BUFFER_SIZE;
    m_ChildItemInitInfo.pvPropVars [PropIndex].lVal               = TopItemInfo.lMinimumBufferSize;
    m_ChildItemInitInfo.pvPropVars [PropIndex].vt                 = VT_I4;
    m_ChildItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].propid             = m_ChildItemInitInfo.piPropIDs [PropIndex];
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_ChildItemInitInfo.pvPropVars [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPA_ACCESS_RIGHTS (NONE)
    m_ChildItemInitInfo.pszPropNames[PropIndex]                    = WIA_IPA_ACCESS_RIGHTS_STR;
    m_ChildItemInitInfo.piPropIDs [PropIndex]                    = WIA_IPA_ACCESS_RIGHTS;
    m_ChildItemInitInfo.pvPropVars [PropIndex].lVal               = WIA_ITEM_READ|WIA_ITEM_WRITE;
    m_ChildItemInitInfo.pvPropVars [PropIndex].vt                 = VT_I4;
    m_ChildItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].propid             = m_ChildItemInitInfo.piPropIDs [PropIndex];
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_ChildItemInitInfo.pvPropVars [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPA_COMPRESSION (LIST)
    m_ChildItemInitInfo.pszPropNames[PropIndex]                    = WIA_IPA_COMPRESSION_STR;
    m_ChildItemInitInfo.piPropIDs [PropIndex]                    = WIA_IPA_COMPRESSION;
    m_ChildItemInitInfo.pvPropVars [PropIndex].lVal               = INITIAL_COMPRESSION;
    m_ChildItemInitInfo.pvPropVars [PropIndex].vt                 = VT_I4;
    m_ChildItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].propid             = m_ChildItemInitInfo.piPropIDs [PropIndex];
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_LIST;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_ChildItemInitInfo.pvPropVars [PropIndex].vt;

    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.List.pList    = (BYTE*)m_SupportedCompressionTypes.plValues;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.List.Nom      = m_ChildItemInitInfo.pvPropVars [PropIndex].lVal;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.List.cNumList = m_SupportedCompressionTypes.lNumValues;

    PropIndex++;

    // Initialize WIA_IPA_ITEM_FLAGS
    m_ChildItemInitInfo.pszPropNames[PropIndex]              = WIA_IPA_ITEM_FLAGS_STR;
    m_ChildItemInitInfo.piPropIDs [PropIndex]              = WIA_IPA_ITEM_FLAGS;
    m_ChildItemInitInfo.pvPropVars [PropIndex].lVal         = WiaItemTypeImage|WiaItemTypeFile|WiaItemTypeDevice;
    m_ChildItemInitInfo.pvPropVars [PropIndex].vt           = VT_I4;
    m_ChildItemInitInfo.psPropSpec [PropIndex].ulKind       = PRSPEC_PROPID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].propid       = m_ChildItemInitInfo.piPropIDs [PropIndex];
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_FLAG;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].vt           = m_ChildItemInitInfo.pvPropVars [PropIndex].vt;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Flag.Nom  = m_ChildItemInitInfo.pvPropVars [PropIndex].lVal;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].ValidVal.Flag.ValidBits = WiaItemTypeImage|WiaItemTypeFile|WiaItemTypeDevice;

    PropIndex++;

    // Initialize WIA_IPS_PHOTOMETRIC_INTERP
    m_ChildItemInitInfo.pszPropNames[PropIndex]              = WIA_IPS_PHOTOMETRIC_INTERP_STR;
    m_ChildItemInitInfo.piPropIDs [PropIndex]              = WIA_IPS_PHOTOMETRIC_INTERP;
    m_ChildItemInitInfo.pvPropVars [PropIndex].lVal         = INITIAL_PHOTOMETRIC_INTERP;
    m_ChildItemInitInfo.pvPropVars [PropIndex].vt           = VT_I4;
    m_ChildItemInitInfo.psPropSpec [PropIndex].ulKind       = PRSPEC_PROPID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].propid       = m_ChildItemInitInfo.piPropIDs [PropIndex];
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].vt           = m_ChildItemInitInfo.pvPropVars [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPS_WARM_UP_TIME_STR (NONE)
    m_ChildItemInitInfo.pszPropNames[PropIndex]                    = WIA_IPS_WARM_UP_TIME_STR;
    m_ChildItemInitInfo.piPropIDs [PropIndex]                    = WIA_IPS_WARM_UP_TIME;
    m_ChildItemInitInfo.pvPropVars [PropIndex].lVal               = TopItemInfo.lMaxLampWarmupTime;
    m_ChildItemInitInfo.pvPropVars [PropIndex].vt                 = VT_I4;
    m_ChildItemInitInfo.psPropSpec [PropIndex].ulKind             = PRSPEC_PROPID;
    m_ChildItemInitInfo.psPropSpec [PropIndex].propid             = m_ChildItemInitInfo.piPropIDs [PropIndex];
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_ChildItemInitInfo.pwpiPropInfo[PropIndex].vt                 = m_ChildItemInitInfo.pvPropVars [PropIndex].vt;

    PropIndex++;

    return hr;
}

/**************************************************************************\
* BuildSupportedResolutions
*
*   This helper initializes the supported resolution array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/
HRESULT CWIADevice::BuildSupportedResolutions()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::BuildSupportedResolutions");

    HRESULT hr = S_OK;
    if (NULL != m_SupportedResolutions.plValues) {

        //
        // Supported resolutions have already been initialized,
        // so return S_OK.
        //

        return hr;
    }
    m_SupportedResolutions.lNumValues = 6;
    m_SupportedResolutions.plValues     = new LONG[m_SupportedResolutions.lNumValues];
    if (m_SupportedResolutions.plValues) {
        m_SupportedResolutions.plValues[0] = 75;
        m_SupportedResolutions.plValues[1] = 100;
        m_SupportedResolutions.plValues[2] = 150;
        m_SupportedResolutions.plValues[3] = 200;
        m_SupportedResolutions.plValues[4] = 300;
        m_SupportedResolutions.plValues[5] = 600;
    } else
        hr = E_OUTOFMEMORY;
    return hr;
}
/**************************************************************************\
* DeleteSupportedResolutionsArrayContents
*
*   This helper deletes the supported resolutions array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/
HRESULT CWIADevice::DeleteSupportedResolutionsArrayContents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::DeleteSupportedResolutionsArrayContents");

    HRESULT hr = S_OK;
    if (NULL != m_SupportedResolutions.plValues)
        delete [] m_SupportedResolutions.plValues;

    m_SupportedResolutions.plValues     = NULL;
    m_SupportedResolutions.lNumValues   = 0;
    return hr;
}

/**************************************************************************\
* BuildSupportedIntents
*
*   This helper initializes the supported intent array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/
HRESULT CWIADevice::BuildSupportedIntents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::BuildSupportedIntents");

    HRESULT hr = S_OK;
    if (NULL != m_SupportedIntents.plValues) {

        //
        // Supported intents have already been initialized,
        // so return S_OK.
        //

        return hr;
    }
    m_SupportedIntents.lNumValues   = 6;
    m_SupportedIntents.plValues     = new LONG[m_SupportedIntents.lNumValues];
    if (m_SupportedIntents.plValues) {
        m_SupportedIntents.plValues[0] = WIA_INTENT_NONE;
        m_SupportedIntents.plValues[1] = WIA_INTENT_IMAGE_TYPE_COLOR;
        m_SupportedIntents.plValues[2] = WIA_INTENT_IMAGE_TYPE_GRAYSCALE;
        m_SupportedIntents.plValues[3] = WIA_INTENT_IMAGE_TYPE_TEXT;
        m_SupportedIntents.plValues[4] = WIA_INTENT_MINIMIZE_SIZE;
        m_SupportedIntents.plValues[5] = WIA_INTENT_MAXIMIZE_QUALITY;
    } else
        hr = E_OUTOFMEMORY;
    return hr;
}
/**************************************************************************\
* DeleteSupportedIntentsArrayContents
*
*   This helper deletes the supported intent array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/
HRESULT CWIADevice::DeleteSupportedIntentsArrayContents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::DeleteSupportedIntentsArrayContents");

    HRESULT hr = S_OK;
    if (NULL != m_SupportedIntents.plValues)
        delete [] m_SupportedIntents.plValues;

    m_SupportedIntents.plValues     = NULL;
    m_SupportedIntents.lNumValues   = 0;
    return hr;
}
/**************************************************************************\
* BuildSupportedCompressions
*
*   This helper initializes the supported compression types array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/
HRESULT CWIADevice::BuildSupportedCompressions()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::BuildSupportedCompressions");

    HRESULT hr = S_OK;
    if (NULL != m_SupportedCompressionTypes.plValues) {

        //
        // Supported compression types have already been initialized,
        // so return S_OK.
        //

        return hr;
    }

    m_SupportedCompressionTypes.lNumValues  = 1;
    m_SupportedCompressionTypes.plValues    = new LONG[m_SupportedCompressionTypes.lNumValues];
    if (m_SupportedCompressionTypes.plValues) {
        m_SupportedCompressionTypes.plValues[0] = WIA_COMPRESSION_NONE;
    } else
        hr = E_OUTOFMEMORY;
    return hr;
}
/**************************************************************************\
* DeleteSupportedCompressionsArrayContents
*
*   This helper deletes the supported compression types array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/
HRESULT CWIADevice::DeleteSupportedCompressionsArrayContents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::DeleteSupportedCompressionsArrayContents");

    HRESULT hr = S_OK;
    if (NULL != m_SupportedCompressionTypes.plValues)
        delete [] m_SupportedCompressionTypes.plValues;

    m_SupportedCompressionTypes.plValues     = NULL;
    m_SupportedCompressionTypes.lNumValues   = 0;
    return hr;
}

/**************************************************************************\
* BuildSupportedPreviewModes
*
*   This helper initializes the supported preview mode array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/
HRESULT CWIADevice::BuildSupportedPreviewModes()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::BuildSupportedPreviewModes");

    HRESULT hr = S_OK;
    if (NULL != m_SupportedPreviewModes.plValues) {

        //
        // Supported preview modes have already been initialized,
        // so return S_OK.
        //

        return hr;
    }

#ifdef UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER

    //
    // if your scanner can not perform a preview scan, then
    // set the valid values for WIA_DPS_PREVIEW property to
    // WIA_FINAL_SCAN only
    //

    m_SupportedPreviewModes.lNumValues  = 1;
    m_SupportedPreviewModes.plValues    = new LONG[m_SupportedPreviewModes.lNumValues];
    if (m_SupportedPreviewModes.plValues) {
        m_SupportedPreviewModes.plValues[0] = WIA_FINAL_SCAN;
    } else
        hr = E_OUTOFMEMORY;
#else

    m_SupportedPreviewModes.lNumValues  = 2;
    m_SupportedPreviewModes.plValues    = new LONG[m_SupportedPreviewModes.lNumValues];
    if (m_SupportedPreviewModes.plValues) {
        m_SupportedPreviewModes.plValues[0] = WIA_FINAL_SCAN;
        m_SupportedPreviewModes.plValues[1] = WIA_PREVIEW_SCAN;
    } else
        hr = E_OUTOFMEMORY;
#endif

    return hr;
}
/**************************************************************************\
* DeleteSupportedCompressionsArrayContents
*
*   This helper deletes the supported compression types array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/
HRESULT CWIADevice::DeleteSupportedPreviewModesArrayContents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::DeleteSupportedPreviewModesArrayContents");

    HRESULT hr = S_OK;
    if (NULL != m_SupportedPreviewModes.plValues)
        delete [] m_SupportedPreviewModes.plValues;

    m_SupportedPreviewModes.plValues     = NULL;
    m_SupportedPreviewModes.lNumValues   = 0;
    return hr;
}

/**************************************************************************\
* BuildSupportedDataTypes
*
*   This helper initializes the supported data types array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/
HRESULT CWIADevice::BuildSupportedDataTypes()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::BuildSupportedDataTypes");

    HRESULT hr = S_OK;

    if (NULL != m_SupportedDataTypes.plValues) {

        //
        // Supported data types have already been initialized,
        // so return S_OK.
        //

        return hr;
    }
    m_SupportedDataTypes.lNumValues  = 3;
    m_SupportedDataTypes.plValues = new LONG[m_SupportedDataTypes.lNumValues];
    if (m_SupportedDataTypes.plValues) {
        m_SupportedDataTypes.plValues[0] = WIA_DATA_THRESHOLD;
        m_SupportedDataTypes.plValues[1] = WIA_DATA_GRAYSCALE;
        m_SupportedDataTypes.plValues[2] = WIA_DATA_COLOR;
    } else
        hr = E_OUTOFMEMORY;
    return hr;
}
/**************************************************************************\
* DeleteSupportedDataTypesArrayContents
*
*   This helper deletes the supported data types array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/
HRESULT CWIADevice::DeleteSupportedDataTypesArrayContents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::DeleteSupportedDataTypesArrayContents");

    HRESULT hr = S_OK;
    if (NULL != m_SupportedDataTypes.plValues)
        delete [] m_SupportedDataTypes.plValues;

    m_SupportedDataTypes.plValues     = NULL;
    m_SupportedDataTypes.lNumValues   = 0;
    return hr;
}

/**************************************************************************\
* BuildInitialFormats
*
*   This helper initializes the initial format array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/
HRESULT CWIADevice::BuildInitialFormats()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::BuildInitialFormats");

    HRESULT hr = S_OK;

    if (NULL != m_pInitialFormats) {

        //
        // Supported initial formats have already been initialized,
        // so return S_OK.
        //

        return hr;
    }

    m_NumInitialFormats = 1;
    m_pInitialFormats     = new GUID[m_NumInitialFormats];
    if (m_pInitialFormats) {
        m_pInitialFormats[0] = WiaImgFmt_MEMORYBMP;
    } else
        hr = E_OUTOFMEMORY;

    return hr;
}
/**************************************************************************\
* DeleteInitialFormatsArrayContents
*
*   This helper deletes the initial format array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/
HRESULT CWIADevice::DeleteInitialFormatsArrayContents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::DeleteInitialFormatsArrayContents");

    HRESULT hr = S_OK;
    if (NULL != m_pInitialFormats)
        delete [] m_pInitialFormats;

    m_pInitialFormats     = NULL;
    m_NumInitialFormats   = 0;
    return hr;
}

/**************************************************************************\
* BuildSupportedFormats
*
*   This helper initializes the supported format array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/
HRESULT CWIADevice::BuildSupportedFormats()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::BuildSupportedFormats");

    HRESULT hr = S_OK;

    if (NULL != m_pSupportedFormats) {

        //
        // Supported formats have already been initialized,
        // so return S_OK.
        //

        return hr;
    }

    hr = DeleteSupportedFormatsArrayContents();
    if (SUCCEEDED(hr)) {

#ifdef UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER

        //
        // the unknown length feeder only scanner, formally called the scrollfed scanner
        // only supports BMP and MEMORYBMP
        //

        m_NumSupportedFormats = 2;
        m_pSupportedFormats = new WIA_FORMAT_INFO[m_NumSupportedFormats];
        if (m_pSupportedFormats) {
            m_pSupportedFormats[0].guidFormatID = WiaImgFmt_MEMORYBMP;
            m_pSupportedFormats[0].lTymed       = TYMED_CALLBACK;
            m_pSupportedFormats[1].guidFormatID = WiaImgFmt_BMP;
            m_pSupportedFormats[1].lTymed       = TYMED_FILE;
        } else
            hr = E_OUTOFMEMORY;

#else // UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER

        m_NumSupportedFormats = 4;
        m_pSupportedFormats = new WIA_FORMAT_INFO[m_NumSupportedFormats];
        if (m_pSupportedFormats) {
            m_pSupportedFormats[0].guidFormatID = WiaImgFmt_MEMORYBMP;
            m_pSupportedFormats[0].lTymed       = TYMED_CALLBACK;
            m_pSupportedFormats[1].guidFormatID = WiaImgFmt_BMP;
            m_pSupportedFormats[1].lTymed       = TYMED_FILE;
            m_pSupportedFormats[2].guidFormatID = WiaImgFmt_TIFF;
            m_pSupportedFormats[2].lTymed       = TYMED_FILE;
            m_pSupportedFormats[3].guidFormatID = WiaImgFmt_TIFF;
            m_pSupportedFormats[3].lTymed       = TYMED_MULTIPAGE_CALLBACK;
        } else
            hr = E_OUTOFMEMORY;

#endif // UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER

    }
    return hr;
}
/**************************************************************************\
* DeleteSupportedFormatsArrayContents
*
*   This helper deletes the supported formats array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/
HRESULT CWIADevice::DeleteSupportedFormatsArrayContents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::DeleteSupportedFormatsArrayContents");

    HRESULT hr = S_OK;
    if (NULL != m_pSupportedFormats)
        delete [] m_pSupportedFormats;

    m_pSupportedFormats     = NULL;
    m_NumSupportedFormats   = 0;
    return hr;
}
/**************************************************************************\
* BuildSupportedTYMED
*
*   This helper initializes the supported TYMED array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/
HRESULT CWIADevice::BuildSupportedTYMED()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::BuildSupportedTYMED");

    HRESULT hr = S_OK;

    if (NULL != m_SupportedTYMED.plValues) {

        //
        // Supported TYMED have already been initialized,
        // so return S_OK.
        //

        return hr;
    }

    hr = DeleteSupportedTYMEDArrayContents();
    if (SUCCEEDED(hr)) {

#ifdef UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER

        //
        // if your scanner does not support multi-page
        // file formats, then only report TYMED_FILE, and
        // TYMED_CALLBACK for the WIA_IPA_TYMED property.
        // The unknown length feeder only scanner, formally called
        // the scrollfed scanner in this example does not support
        // multipage file formats
        //

        m_SupportedTYMED.lNumValues = 2;
        m_SupportedTYMED.plValues   = new LONG[m_SupportedTYMED.lNumValues];
        if (m_SupportedTYMED.plValues) {
            m_SupportedTYMED.plValues[0] = TYMED_FILE;
            m_SupportedTYMED.plValues[1] = TYMED_CALLBACK;
        } else
            hr = E_OUTOFMEMORY;

#else // UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER

        m_SupportedTYMED.lNumValues = 3;
        m_SupportedTYMED.plValues   = new LONG[m_SupportedTYMED.lNumValues];
        if (m_SupportedTYMED.plValues) {
            m_SupportedTYMED.plValues[0] = TYMED_FILE;
            m_SupportedTYMED.plValues[1] = TYMED_CALLBACK;
            m_SupportedTYMED.plValues[2] = TYMED_MULTIPAGE_CALLBACK;
        } else
            hr = E_OUTOFMEMORY;

#endif // UNKNOWN_LENGTH_FEEDER_ONLY_SCANNER

    }
    return hr;
}
/**************************************************************************\
* DeleteSupportedTYMEDArrayContents
*
*   This helper deletes the supported TYMED array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/
HRESULT CWIADevice::DeleteSupportedTYMEDArrayContents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::DeleteSupportedTYMEDArrayContents");

    HRESULT hr = S_OK;
    if (NULL != m_SupportedTYMED.plValues)
        delete [] m_SupportedTYMED.plValues;

    m_SupportedTYMED.plValues  = NULL;
    m_SupportedTYMED.lNumValues = 0;
    return hr;
}

/**************************************************************************\
* BuildCapabilities
*
*   This helper initializes the capabilities array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

HRESULT CWIADevice::BuildCapabilities()
{
    HRESULT hr = S_OK;
    if (NULL != m_pCapabilities) {

        //
        // Capabilities have already been initialized,
        // so return S_OK.
        //

        return hr;
    }

    m_NumSupportedCommands  = 1;
    m_NumSupportedEvents    = 5;
    LONG lArrayIndex        = 0;    // increment this value when adding new items to
                                    // the capabilites array

    m_pCapabilities     = new WIA_DEV_CAP_DRV[m_NumSupportedCommands + m_NumSupportedEvents];
    if (m_pCapabilities) {

        //
        // Initialize EVENTS
        //

        // WIA_EVENT_DEVICE_CONNECTED
        GetOLESTRResourceString(IDS_EVENT_DEVICE_CONNECTED_NAME,&(m_pCapabilities[lArrayIndex].wszName),TRUE);
        GetOLESTRResourceString(IDS_EVENT_DEVICE_CONNECTED_DESC,&(m_pCapabilities[lArrayIndex].wszDescription),TRUE);
        m_pCapabilities[lArrayIndex].guid           = (GUID*)&WIA_EVENT_DEVICE_CONNECTED;
        m_pCapabilities[lArrayIndex].ulFlags        = WIA_NOTIFICATION_EVENT;
        m_pCapabilities[lArrayIndex].wszIcon        = WIA_ICON_DEVICE_CONNECTED;

        lArrayIndex++;

        // WIA_EVENT_DEVICE_DISCONNECTED
        GetOLESTRResourceString(IDS_EVENT_DEVICE_DISCONNECTED_NAME,&(m_pCapabilities[lArrayIndex].wszName),TRUE);
        GetOLESTRResourceString(IDS_EVENT_DEVICE_DISCONNECTED_DESC,&(m_pCapabilities[lArrayIndex].wszDescription),TRUE);
        m_pCapabilities[lArrayIndex].guid           = (GUID*)&WIA_EVENT_DEVICE_DISCONNECTED;
        m_pCapabilities[lArrayIndex].ulFlags        = WIA_NOTIFICATION_EVENT;
        m_pCapabilities[lArrayIndex].wszIcon        = WIA_ICON_DEVICE_DISCONNECTED;

        lArrayIndex++;

        // FAX BUTTON EVENT
        GetOLESTRResourceString(IDS_EVENT_FAXBUTTON_NAME,&(m_pCapabilities[lArrayIndex].wszName),TRUE);
        GetOLESTRResourceString(IDS_EVENT_FAXBUTTON_DESC,&(m_pCapabilities[lArrayIndex].wszDescription),TRUE);
        m_pCapabilities[lArrayIndex].guid           = (GUID*)&WIA_EVENT_SCAN_FAX_IMAGE;
        m_pCapabilities[lArrayIndex].ulFlags        = WIA_NOTIFICATION_EVENT | WIA_ACTION_EVENT;
        m_pCapabilities[lArrayIndex].wszIcon        = WIA_ICON_SCAN_BUTTON_PRESS;

        lArrayIndex++;

        // COPY BUTTON EVENT
        GetOLESTRResourceString(IDS_EVENT_COPYBUTTON_NAME,&(m_pCapabilities[lArrayIndex].wszName),TRUE);
        GetOLESTRResourceString(IDS_EVENT_COPYBUTTON_DESC,&(m_pCapabilities[lArrayIndex].wszDescription),TRUE);
        m_pCapabilities[lArrayIndex].guid           = (GUID*)&WIA_EVENT_SCAN_PRINT_IMAGE;
        m_pCapabilities[lArrayIndex].ulFlags        = WIA_NOTIFICATION_EVENT | WIA_ACTION_EVENT;
        m_pCapabilities[lArrayIndex].wszIcon        = WIA_ICON_SCAN_BUTTON_PRESS;

        lArrayIndex++;

        // SCAN BUTTON EVENT
        GetOLESTRResourceString(IDS_EVENT_SCANBUTTON_NAME,&(m_pCapabilities[lArrayIndex].wszName),TRUE);
        GetOLESTRResourceString(IDS_EVENT_SCANBUTTON_DESC,&(m_pCapabilities[lArrayIndex].wszDescription),TRUE);
        m_pCapabilities[lArrayIndex].guid           = (GUID*)&WIA_EVENT_SCAN_IMAGE;
        m_pCapabilities[lArrayIndex].ulFlags        = WIA_NOTIFICATION_EVENT | WIA_ACTION_EVENT;
        m_pCapabilities[lArrayIndex].wszIcon        = WIA_ICON_SCAN_BUTTON_PRESS;

        lArrayIndex++;

        //
        // Initialize COMMANDS
        //

        // WIA_CMD_SYNCHRONIZE
        GetOLESTRResourceString(IDS_CMD_SYNCRONIZE_NAME,&(m_pCapabilities[lArrayIndex].wszName),TRUE);
        GetOLESTRResourceString(IDS_CMD_SYNCRONIZE_DESC,&(m_pCapabilities[lArrayIndex].wszDescription),TRUE);
        m_pCapabilities[lArrayIndex].guid           = (GUID*)&WIA_CMD_SYNCHRONIZE;
        m_pCapabilities[lArrayIndex].ulFlags        = 0;
        m_pCapabilities[lArrayIndex].wszIcon        = WIA_ICON_SYNCHRONIZE;

        lArrayIndex++;

    } else
        hr = E_OUTOFMEMORY;
    return hr;
}

/**************************************************************************\
* DeleteCapabilitiesArrayContents
*
*   This helper deletes the capabilities array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

HRESULT CWIADevice::DeleteCapabilitiesArrayContents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::DeleteCapabilitiesArrayContents");

    HRESULT hr = S_OK;
    if (NULL != m_pCapabilities) {
        for (LONG i = 0; i < (m_NumSupportedCommands + m_NumSupportedEvents);i++) {

            if(m_pCapabilities[i].wszName){
                CoTaskMemFree(m_pCapabilities[i].wszName);
            }

            if(m_pCapabilities[i].wszDescription) {
                CoTaskMemFree(m_pCapabilities[i].wszDescription);
            }
        }
        delete [] m_pCapabilities;
        m_pCapabilities = NULL;
    }
    return hr;
}

/**************************************************************************\
* GetBSTRResourceString
*
*   This helper gets a BSTR from a resource location
*
* Arguments:
*
*   lResourceID - Resource ID of the target BSTR value
*   pBSTR       - pointer to a BSTR value (caller must free this string)
*   bLocal      - TRUE - for local resources, FALSE - for wiaservc resources
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/
HRESULT CWIADevice::GetBSTRResourceString(LONG lResourceID,BSTR *pBSTR,BOOL bLocal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::GetBSTRResourceString");

    HRESULT hr = S_OK;
    TCHAR szStringValue[255];
    if (bLocal) {

        //
        // We are looking for a resource in our own private resource file
        //

        LoadString(g_hInst,lResourceID,szStringValue,255);

        //
        // NOTE: caller must free this allocated BSTR
        //

#ifdef UNICODE
        *pBSTR = SysAllocString(szStringValue);
#else
        WCHAR wszStringValue[255];

        //
        // convert szStringValue from char* to unsigned short* (ANSI only)
        //

        MultiByteToWideChar(CP_ACP,
                            MB_PRECOMPOSED,
                            szStringValue,
                            lstrlenA(szStringValue)+1,
                            wszStringValue,
                            (sizeof(wszStringValue)/sizeof(wszStringValue[0])));

        *pBSTR = SysAllocString(wszStringValue);
#endif

    } else {

        //
        // We are looking for a resource in the wiaservc's resource file
        //

        hr = E_NOTIMPL;
    }
    return hr;
}

/**************************************************************************\
* GetOLESTRResourceString
*
*   This helper gets a LPOLESTR from a resource location
*
* Arguments:
*
*   lResourceID - Resource ID of the target BSTR value
*   ppsz        - pointer to a OLESTR value (caller must free this string)
*   bLocal      - TRUE - for local resources, FALSE - for wiaservc resources
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/
HRESULT CWIADevice::GetOLESTRResourceString(LONG lResourceID,LPOLESTR *ppsz,BOOL bLocal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIADevice::GetOLESTRResourceString");

    HRESULT hr = S_OK;
    TCHAR szStringValue[255];
    if (bLocal) {

        //
        // We are looking for a resource in our own private resource file
        //

        LoadString(g_hInst,lResourceID,szStringValue,255);

        //
        // NOTE: caller must free this allocated BSTR
        //

#ifdef UNICODE
        *ppsz = NULL;
        *ppsz = (LPOLESTR)CoTaskMemAlloc(sizeof(szStringValue));
        if (*ppsz != NULL) {
            wcscpy(*ppsz,szStringValue);
        } else {
            return E_OUTOFMEMORY;
        }

#else
        WCHAR wszStringValue[255];

        //
        // convert szStringValue from char* to unsigned short* (ANSI only)
        //

        MultiByteToWideChar(CP_ACP,
                            MB_PRECOMPOSED,
                            szStringValue,
                            lstrlenA(szStringValue)+1,
                            wszStringValue,
                            (sizeof(wszStringValue)/sizeof(wszStringValue[0])));

        *ppsz = NULL;
        *ppsz = (LPOLESTR)CoTaskMemAlloc(sizeof(wszStringValue));
        if (*ppsz != NULL) {
            wcscpy(*ppsz,wszStringValue);
        } else {
            return E_OUTOFMEMORY;
        }
#endif

    } else {

        //
        // We are looking for a resource in the wiaservc's resource file
        //

        hr = E_NOTIMPL;
    }
    return hr;
}

/**************************************************************************\
* SwapBuffer24
*
*   Place RGB bytes in correct order for DIB format.
*
* Arguments:
*
*   pBuffer     - Pointer to the data buffer.
*   lByteCount  - Size of the data in bytes.
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

VOID CWIADevice::SwapBuffer24(PBYTE pBuffer, LONG lByteCount)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIADevice::SwapBuffer24");

    if (!pBuffer) {
        return;
    }

    for (LONG i = 0; i < lByteCount; i+= 3) {
        BYTE bTemp     = pBuffer[i];
        pBuffer[i]     = pBuffer[i + 2];
        pBuffer[i + 2] = bTemp;
    }
}

/**************************************************************************\
* IsPreviewScan
*
*   Get the current preview setting from the item properties.
*   A helper for drvAcquireItemData.
*
* Arguments:
*
*   pWiasContext - pointer to an Item context.
*
* Return Value:
*
*    TRUE - Preview is set, FALSE - Final is set
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

BOOL CWIADevice::IsPreviewScan(BYTE *pWiasContext)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIADevice::IsPreviewScan");
    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if (!pWiasContext) {
        return FALSE;
    }

    //
    // Get a pointer to the root item, for property access.
    //

    BYTE *pRootItemCtx = NULL;

    HRESULT hr = wiasGetRootItem(pWiasContext, &pRootItemCtx);
    if (FAILED(hr)) {
        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("IsPreviewScan, No Preview Property Found on ROOT item!"));
        return FALSE;
    }

    //
    //  Get the current preview setting.
    //

    LONG lPreview = 0;

    hr = wiasReadPropLong(pRootItemCtx, WIA_DPS_PREVIEW, &lPreview, NULL, true);
    if (hr != S_OK) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("IsPreviewScan, Failed to read Preview Property."));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return FALSE;
    }

    return(lPreview > 0);
}

/**************************************************************************\
* GetPageCount
*
*   Get the requested number of pages to scan from the item properties.
*   A helper for drvAcquireItemData.
*
* Arguments:
*
*   pWiasContext - pointer to an Item context.
*
* Return Value:
*
*    Number of pages to scan.
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

LONG CWIADevice::GetPageCount(BYTE *pWiasContext)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIADevice::GetPageCount");

    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if (!pWiasContext) {
        return E_INVALIDARG;
    }

    //
    // Get a pointer to the root item, for property access.
    //

    BYTE *pRootItemCtx = NULL;

    HRESULT hr = wiasGetRootItem(pWiasContext, &pRootItemCtx);
    if (FAILED(hr)) {
        return 1;
    }

    //
    //  Get the requested page count.
    //

    LONG lPagesRequested = 0;

    hr = wiasReadPropLong(pRootItemCtx, WIA_DPS_PAGES, &lPagesRequested, NULL, true);
    if (hr != S_OK) {
        return 1;
    }

    return lPagesRequested;
}

/**************************************************************************\
* SetItemSize
*
*   Calulate the new item size, and write the new Item Size property value.
*
* Arguments:
*
*   pWiasContext       - item
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

HRESULT CWIADevice::SetItemSize(BYTE *pWiasContext)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIADevice::SetItemSize");
    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if (!pWiasContext) {
        return E_INVALIDARG;
    }

    HRESULT  hr = S_OK;

    hr = wiasWritePropLong(pWiasContext,WIA_IPA_ITEM_SIZE,0);

    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetItemSize, wiasWritePropLong Failed to read WIA_IPA_ITEM_SIZE"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\wiascanr\validate.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2002
*
*  TITLE:       validate.cpp
*
*  VERSION:     1.1
*
*  DATE:        05 March, 2002
*
*  DESCRIPTION:
*
*******************************************************************************/

#include "pch.h"
extern HINSTANCE g_hInst;   // used for WIAS_LOGPROC macro
#define MAX_PAGE_CAPACITY    25     // 25 pages
/**************************************************************************\
* ValidateDataTransferContext
*
*   Checks the data transfer context to ensure it's valid.
*
* Arguments:
*
*    pDataTransferContext - Pointer the data transfer context.
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

HRESULT CWIADevice::ValidateDataTransferContext(
    PMINIDRV_TRANSFER_CONTEXT pDataTransferContext)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "::ValidateDataTransferContext");

    //
    // If the caller does not specify a MINIDRV_TRANSFER_CONTEXT structure
    // pointer then fail with E_INVALIDARG.
    //

    if(!pDataTransferContext)
    {
        return E_INVALIDARG;
    }

    //
    // If the size of the MINIDRV_TRANSFER_CONTEXT is not equal to the one
    // that is expected, then fail with E_INVALIDARG.
    //

    if (pDataTransferContext->lSize != sizeof(MINIDRV_TRANSFER_CONTEXT)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ValidateDataTransferContext, invalid data transfer context"));
        return E_INVALIDARG;
    }

    HRESULT hr = S_OK;
    switch(pDataTransferContext->tymed)
    {
    case TYMED_FILE:
        {

            //
            // If the FORMAT guid is not WiaImgFmt_BMP or WiaImgFmt_TIFF
            // then fail with E_INVALIDARG
            //

            if ((pDataTransferContext->guidFormatID != WiaImgFmt_BMP) &&
                (pDataTransferContext->guidFormatID != WiaImgFmt_TIFF)) {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ValidateDataTransferContext, invalid format for TYMED_FILE"));
                hr = E_INVALIDARG;
            }
        }
        break;
    case TYMED_CALLBACK:
        {

            //
            // If the FORMAT guid is not WiaImgFmt_MEMORYBMP
            // then fail with E_INVALIDARG
            //

            if(pDataTransferContext->guidFormatID != WiaImgFmt_MEMORYBMP){
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ValidateDataTransferContext, invalid format for TYMED_CALLBACK"));
                hr = E_INVALIDARG;
            }
        }
        break;
    case TYMED_MULTIPAGE_FILE:
        {

            //
            // If the FORMAT guid is not WiaImgFmt_TIFF
            // then fail with E_INVALIDARG
            //

            if(pDataTransferContext->guidFormatID != WiaImgFmt_TIFF){
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ValidateDataTransferContext, invalid format for TYMED_MULTIPAGE_FILE"));
                hr = E_INVALIDARG;
            }
        }
        break;
    case TYMED_MULTIPAGE_CALLBACK:
        {

            //
            // If the FORMAT guid is not WiaImgFmt_TIFF
            // then fail with E_INVALIDARG
            //

            if(pDataTransferContext->guidFormatID != WiaImgFmt_TIFF){
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ValidateDataTransferContext, invalid format for TYMED_MULTIPAGE_CALLBACK"));
                hr = E_INVALIDARG;
            }
        }
        break;
    default:
        hr = E_INVALIDARG;
        break;
    }

    return hr;
}

/**************************************************************************\
* UpdateValidDepth
*
*   Helper that updates the valid value for depth based on the data type.
*
* Arguments:
*
*   pWiasContext    -   a pointer to the WiaItem context
*   lDataType   -   the value of the DataType property.
*   lDepth      -   the address of the variable where the Depth's new value
*                   will be returned.
*
* Return Value:
*
*   Status      -   S_OK if successful
*                   E_INVALIDARG if lDataType is unknown
*                   Errors are those returned by wiasReadPropLong,
*                   and wiasWritePropLong.
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

HRESULT CWIADevice::UpdateValidDepth(
    BYTE        *pWiasContext,
    LONG        lDataType,
    LONG        *lDepth)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIADevice::UpdateValidDepth");
    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if((!pWiasContext)||(!lDepth)){
        return E_INVALIDARG;
    }

    //
    // Set the lDepth value according to the current lDataType setting
    //

    switch (lDataType) {
        case WIA_DATA_THRESHOLD:
            *lDepth = 1;
            break;
        case WIA_DATA_GRAYSCALE:
            *lDepth = 8;
            break;
        case WIA_DATA_COLOR:
            *lDepth = 24;
            break;
        default:
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("UpdateValidDepth, unknown data type"));
            return E_INVALIDARG;
    }

    return S_OK;
}

/**************************************************************************\
* CheckDataType
*
*   This helper method is called to check whether WIA_IPA_DATATYPE
*   property is changed.  When this property changes, other dependant
*   properties and their valid values must also be changed.
*
* Arguments:
*
*   pWiasContext    -   a pointer to the item context whose properties have
*                       changed.
*   pContext    -   a pointer to the property context (which indicates
*                   which properties are being written).
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

HRESULT CWIADevice::CheckDataType(
    BYTE                    *pWiasContext,
    WIA_PROPERTY_CONTEXT    *pContext)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIADevice::CheckDataType");

    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if((!pWiasContext)||(!pContext)){
        return E_INVALIDARG;
    }

    WIAS_CHANGED_VALUE_INFO cviDataType;
    memset(&cviDataType,0,sizeof(cviDataType));

    WIAS_CHANGED_VALUE_INFO cviDepth;
    memset(&cviDepth,0,sizeof(cviDepth));

    //
    //  Call wiasGetChangedValue for DataType. It is checked first since it's
    //  not dependant on any other property.  All properties in this method
    //  that follow are dependant properties of DataType.
    //
    //  The call to wiasGetChangedValue specifies that validation should not be
    //  skipped (since valid values for DataType never change).  Also,
    //  the address of a variable for the old value is NULL, since the old
    //  value is not needed.  The address of bDataTypeChanged is passed
    //  so that dependant properties will know whether the DataType is being
    //  changed or not.  This is important since dependant properties may need
    //  their valid values updated and may need to be folded to new valid
    //  values.
    //

    HRESULT hr = wiasGetChangedValueLong(pWiasContext,pContext,FALSE,WIA_IPA_DATATYPE,&cviDataType);
    if (FAILED(hr)) {
        return hr;
    }

    //
    //  Call wiasGetChangedValue for Depth. Depth is a dependant property of
    //  DataType whose valid value changes according to what the current
    //  value of DataType is.
    //
    //  The call to wiasGetChangedValue specifies that validation should only
    //  be skipped if the DataType has changed.  This is because the valid
    //  values for Depth will change according to the new value for
    //  DataType.  The address of a variable for the old value is NULL, since
    //  the old value is not needed.  The address of bDepthChanged is passed
    //  so that dependant properties will know whether the Depth is being
    //  changed or not.  This is important since dependant properties may need
    //  their valid values updated and may need to be folded to new valid
    //  values.
    //

    hr = wiasGetChangedValueLong(pWiasContext,pContext,cviDataType.bChanged,WIA_IPA_DEPTH,&cviDepth);
    if (FAILED(hr)) {
        return hr;
    }

    if (cviDataType.bChanged) {

        //
        //  DataType changed so update valid value for Depth
        //

        hr = UpdateValidDepth(pWiasContext, cviDataType.Current.lVal, &cviDepth.Current.lVal);
        if (S_OK == hr) {

            //
            //  Check whether we must fold.  Depth will only be folded if it
            //  is not one of the properties that the app is changing.
            //

            if (!cviDepth.bChanged) {
                hr = wiasWritePropLong(pWiasContext, WIA_IPA_DEPTH, cviDepth.Current.lVal);
            }
        }
    }

    //
    //  Update properties dependant on DataType and Depth.
    //  Here, ChannelsPerPixel and BitsPerChannel are updated.
    //

    if (cviDataType.bChanged || cviDepth.bChanged) {
        if (S_OK == hr) {

            //
            // initialize PROPSPEC array
            //

            PROPSPEC ps[2] = {
                {PRSPEC_PROPID, WIA_IPA_CHANNELS_PER_PIXEL},
                {PRSPEC_PROPID, WIA_IPA_BITS_PER_CHANNEL  }
                };

            //
            // initilize PROPVARIANT array
            //

            PROPVARIANT pv[2];
            for (LONG index = 0; index < 2; index++) {
                PropVariantInit(&pv[index]);
                pv[index].vt = VT_I4;
            }

            //
            // use the current WIA data type to determine the proper
            // WIA_IPA_CHANNELS_PER_PIXEL and WIA_IPA_BITS_PER_CHANNEL
            // settings
            //

            switch (cviDataType.Current.lVal) {
                case WIA_DATA_THRESHOLD:
                    pv[0].lVal = 1;
                    pv[1].lVal = 1;
                    break;
                case WIA_DATA_GRAYSCALE:
                    pv[0].lVal = 1;
                    pv[1].lVal = 8;
                    break;
                case WIA_DATA_COLOR:
                    pv[0].lVal = 3;
                    pv[1].lVal = 8;
                    break;
                default:
                    pv[0].lVal = 1;
                    pv[1].lVal = 8;
                    break;
            }
            hr = wiasWriteMultiple(pWiasContext, 2, ps, pv);
        }
    }

    return hr;
}

/**************************************************************************\
* CheckIntent
*
*   This helper method is called to make the relevant changes if the
*   Current Intent property changes.
*
* Arguments:
*
*   pWiasContext    -   a pointer to the item context whose properties have
*                       changed.
*   pContext    -   a pointer to the property context (which indicates
*                   which properties are being written).
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

HRESULT CWIADevice::CheckIntent(
    BYTE            *pWiasContext,
    WIA_PROPERTY_CONTEXT *pContext)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIADevice::CheckIntent");

    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if((!pWiasContext)||(!pContext)) {
        return E_INVALIDARG;
    }

    WIAS_CHANGED_VALUE_INFO cviIntent;
    memset(&cviIntent,0,sizeof(cviIntent));

    //
    //  Call wiasGetChangedValue for CurrentIntent. CurrentIntent is checked first
    //  since it's not dependant on any other property.  All properties in
    //  this method that follow are dependant properties of CurrentIntent.
    //
    //  The call to wiasGetChangedValue specifies that validation should not be
    //  skipped (since valid values for CurrentIntent never change). The
    //  address of the old value is specified as NULL, since it is not used.
    //  The address of bIntentChanged is passed so that dependant properties
    //  will know whether the YResolution is being changed or not.  This is
    //  important since dependant properties will need their valid values
    //  updated and may need to be folded to new valid values.
    //

    HRESULT hr = wiasGetChangedValueLong(pWiasContext,pContext,FALSE,WIA_IPS_CUR_INTENT,&cviIntent);
    if (S_OK ==hr) {

        //
        // If the WIA intent value was changed, then validate dependant values:
        // WIA_IPA_DATATYPE
        // WIA_IPA_DEPTH
        // WIA_IPS_XRES
        // WIA_IPS_YRES
        // WIA_IPS_XEXTENT
        // WIA_IPS_YEXTENT
        // WIA_IPA_PIXELS_PER_LINE
        // WIA_IPA_NUMBER_OF_LINES
        //

        if (cviIntent.bChanged) {

            LONG lImageTypeIntent = (cviIntent.Current.lVal & WIA_INTENT_IMAGE_TYPE_MASK);
            LONG lDataType = WIA_DATA_GRAYSCALE;
            LONG lDepth = 8;
            BOOL bUpdateDataTypeAndDepth = TRUE;
            switch (lImageTypeIntent) {

                case WIA_INTENT_NONE:
                    bUpdateDataTypeAndDepth = FALSE;
                    break;

                case WIA_INTENT_IMAGE_TYPE_GRAYSCALE:
                    lDataType = WIA_DATA_GRAYSCALE;
                    lDepth = 8;
                    break;

                case WIA_INTENT_IMAGE_TYPE_TEXT:
                    lDataType = WIA_DATA_THRESHOLD;
                    lDepth = 1;
                    break;

                case WIA_INTENT_IMAGE_TYPE_COLOR:
                    lDataType = WIA_DATA_COLOR;
                    lDepth = 24;
                    break;

                default:
                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CheckIntent, unknown intent (TYPE) = %d",lImageTypeIntent));
                    return E_INVALIDARG;

            }

            if (bUpdateDataTypeAndDepth) {

                //
                // update the WIA_IPA_DATATYPE property and the WIA_IPA_DEPTH property
                //

                hr = wiasWritePropLong(pWiasContext, WIA_IPA_DATATYPE, lDataType);
                if (S_OK == hr) {
                    hr = wiasWritePropLong(pWiasContext, WIA_IPA_DEPTH, lDepth);
                }
            }

            //
            // if we failed to complete the above operations, then
            // return, to avoid proceeding any more.
            //

            if(FAILED(hr)){
                return hr;
            }

            LONG lImageSizeIntent = (cviIntent.Current.lVal & WIA_INTENT_SIZE_MASK);

            switch (lImageSizeIntent) {
            case WIA_INTENT_NONE:
                    break;
            case WIA_INTENT_MINIMIZE_SIZE:
            case WIA_INTENT_MAXIMIZE_QUALITY:
                {

                    //
                    // Set the X and Y Resolutions.
                    //

                    hr = wiasWritePropLong(pWiasContext, WIA_IPS_XRES, lImageSizeIntent & WIA_INTENT_MINIMIZE_SIZE ? 150 : 300);
                    if(S_OK == hr){
                        hr = wiasWritePropLong(pWiasContext, WIA_IPS_YRES, lImageSizeIntent & WIA_INTENT_MINIMIZE_SIZE ? 150 : 300);
                    }

                    //
                    // check if we failed to update the WIA_IPS_XRES and WIA_IPS_YRES property
                    //

                    if(FAILED(hr)){
                        return hr;
                    }

                    //
                    //  The Resolutions and DataType were set, so update the property
                    //  context to indicate that they have changed.
                    //

                    hr = wiasSetPropChanged(WIA_IPS_XRES, pContext, TRUE);
                    if(S_OK == hr){
                        hr = wiasSetPropChanged(WIA_IPS_YRES, pContext, TRUE);
                        if(S_OK == hr){
                            hr = wiasSetPropChanged(WIA_IPA_DATATYPE, pContext, TRUE);
                        }
                    }

                    //
                    // check if we failed to flag WIA_IPS_XRES, WIA_IPS_YRES, and WIA_IPA_DATATYPE
                    // properties as changed
                    //

                    if(FAILED(hr)){
                        return hr;
                    }

                    //
                    // update IPA_NUMBER_OF_LINES property
                    //

                    LONG lLength = 0;

                    hr = wiasReadPropLong(pWiasContext, WIA_IPS_YEXTENT, &lLength, NULL, TRUE);
                    if (SUCCEEDED(hr)) {
                        hr = wiasWritePropLong(pWiasContext, WIA_IPA_NUMBER_OF_LINES, lLength);
                        if (FAILED(hr)) {
                            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CheckIntent, could not write WIA_IPA_NUMBER_OF_LINES"));
                            return hr;
                        }
                    } else {
                        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CheckIntent, could not read WIA_IPS_YEXTENT"));
                        return hr;
                    }

                    //
                    // update IPA_PIXEL_PER_LINE property
                    //

                    LONG lWidth = 0;

                    hr = wiasReadPropLong(pWiasContext, WIA_IPS_XEXTENT, &lWidth, NULL, TRUE);
                    if (SUCCEEDED(hr)) {
                        hr = wiasWritePropLong(pWiasContext, WIA_IPA_PIXELS_PER_LINE, lWidth);
                        if (FAILED(hr)) {
                            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CheckIntent, could not write WIA_IPA_PIXELS_PER_LINE"));
                            return hr;
                        }
                    } else {
                        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CheckIntent, could not read WIA_IPS_XEXTENT"));
                        return hr;
                    }
                }
                break;
            default:
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CheckIntent, unknown intent (SIZE) = %d",lImageSizeIntent));
                return E_INVALIDARG;
            }
        }
    } else {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CheckIntent, wiasGetChangedValue (intent) failed"));
    }
    return hr;
}

/**************************************************************************\
* CheckPreferredFormat
*
*   This helper method is called to make the relevant changes if the
*   Format property changes.
*
* Arguments:
*
*   pWiasContext    -   a pointer to the item context whose properties have
*                       changed.
*   pContext    -   a pointer to the property context (which indicates
*                   which properties are being written).
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

HRESULT CWIADevice::CheckPreferredFormat(
    BYTE            *pWiasContext,
    WIA_PROPERTY_CONTEXT *pContext)
{

    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if((!pWiasContext)||(!pContext)){
        return E_INVALIDARG;
    }

    //
    // update WIA_IPA_PREFERRED_FORMAT property to match current WIA_IPA_FORMAT setting.
    // This is a simple way of keeping the WIA_IPA_PREFERRED_FORMAT in sync with the
    // valid FORMAT.
    //
    // The proper action to take here is to choose the real preferred
    // format of your driver that fits in the valid value set of the current WIA_IPA_FORMAT
    // setting.  The preferred format is a value that appliations may use to transfer by default.
    //
    // example: if your driver supports JPEG, and you prefer the application to transfer in JPEG
    //          when ever possible, then make sure your preferred format is always JPEG.  Remember
    //          that the preferred format can only be set to JPEG if JPEG is one of the current
    //          valid values for WIA_IPA_FORMAT. (If it is not, then the application might attempt
    //          to set an invalid value, by reading the WIA_IPA_PREFERRED_FORMAT and writing it to
    //          WIA_IPA_FORMAT)
    //

    GUID FormatGUID = GUID_NULL;
    HRESULT hr = wiasReadPropGuid(pWiasContext, WIA_IPA_FORMAT, &FormatGUID, NULL, TRUE);
    if (S_OK == hr) {

        //
        // update the WIA_IPA_FILENAME_EXTENSION property to the correct file extension
        //

        BSTR bstrFileExt = NULL;

        if((FormatGUID == WiaImgFmt_BMP)||(FormatGUID == WiaImgFmt_MEMORYBMP)) {
            bstrFileExt = SysAllocString(L"BMP");
        } else if (FormatGUID == WiaImgFmt_TIFF){
            bstrFileExt = SysAllocString(L"TIF");
        }

        //
        // if the allocation of the BSTR is successful, then attempt to set the
        // WIA_IPA_FILENAME_EXTENSION property.
        //

        if(bstrFileExt) {
            hr = wiasWritePropStr(pWiasContext,WIA_IPA_FILENAME_EXTENSION,bstrFileExt);

            //
            // free the allocated BSTR file extension
            //

            SysFreeString(bstrFileExt);
            bstrFileExt = NULL;
        }

        if (S_OK == hr){
            hr = wiasWritePropGuid(pWiasContext, WIA_IPA_PREFERRED_FORMAT, FormatGUID);
            if (FAILED(hr)){
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CheckPreferredFormat, could not write WIA_IPA_PREFERRED_FORMAT"));
                return hr;
            }
        }
    } else {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CheckIntent, could not read WIA_IPA_FORMAT"));
    }
    return hr;
}

/**************************************************************************\
* CheckADFStatus
*
*
* Arguments:
*
*   pWiasContext    -   a pointer to the item context whose properties have
*                       changed.
*   pContext    -   a pointer to the property context (which indicates
*                   which properties are being written).
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/
HRESULT CWIADevice::CheckADFStatus(BYTE *pWiasContext,
                                         WIA_PROPERTY_CONTEXT *pContext)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIADevice::CheckADFStatus");

    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if((!pWiasContext)||(!pContext)){
        return E_INVALIDARG;
    }

    //
    // If there is NOT an ADF attached, just return S_OK, telling the caller that
    // everything is OK
    //

    if(!m_bADFAttached){
        return S_OK;
    }

    //
    // get the ROOT item, this is where the document feeder properties exist
    //

    BYTE *pRootItemCtx = NULL;
    HRESULT hr = wiasGetRootItem(pWiasContext, &pRootItemCtx);
    if (FAILED(hr)) {
        return E_FAIL;
    }

    //
    // read the current WIA_DPS_DOCUMENT_HANDLING_SELECT setting from the ROOT
    // item.
    //

    LONG lDocHandlingSelect = 0;
    hr = wiasReadPropLong(pRootItemCtx,
                          WIA_DPS_DOCUMENT_HANDLING_SELECT,
                          &lDocHandlingSelect,
                          NULL,
                          FALSE);

    //
    // if S_FALSE is returned, then the WIA_DPS_DOCUMENT_HANDLING_SELECT property does
    // not exist.  This means that we should default to FLATBED settings
    //

    if(hr == S_FALSE){
        lDocHandlingSelect = FLATBED;
    }

    //
    // turn ON/OFF the ADF controller flag
    //

    if (SUCCEEDED(hr)) {
        switch (lDocHandlingSelect) {
        case FEEDER:
            m_bADFEnabled = TRUE;
            hr = S_OK;
            break;
        case FLATBED:
            m_bADFEnabled = FALSE;
            hr = S_OK;
            break;
        default:
            hr = E_INVALIDARG;
            break;
        }
    }

    if (S_OK == hr) {

        //
        // update document handling status
        //

        if (m_bADFEnabled) {

            HRESULT Temphr = m_pScanAPI->FakeScanner_ADFAvailable();
            if (S_OK == Temphr) {
                hr = wiasWritePropLong(pWiasContext, WIA_DPS_DOCUMENT_HANDLING_STATUS,FEED_READY);
            } else {
                hr = wiasWritePropLong(pWiasContext, WIA_DPS_DOCUMENT_HANDLING_STATUS,PAPER_JAM);
            }

            if (FAILED(Temphr))
                hr = Temphr;
        } else {
            hr = wiasWritePropLong(pWiasContext, WIA_DPS_DOCUMENT_HANDLING_STATUS,FLAT_READY);
        }
    }
    return hr;
}

/**************************************************************************\
* CheckPreview
*
*
* Arguments:
*
*   pWiasContext    -   a pointer to the item context whose properties have
*                       changed.
*   pContext    -   a pointer to the property context (which indicates
*                   which properties are being written).
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/
HRESULT CWIADevice::CheckPreview(BYTE *pWiasContext,
                                         WIA_PROPERTY_CONTEXT *pContext)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIADevice::CheckPreview");

    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if((!pWiasContext)||(!pContext)){
        return E_INVALIDARG;
    }

    //
    // get the ROOT item, this is where the preview property exists
    //

    BYTE *pRootItemCtx = NULL;
    HRESULT hr = wiasGetRootItem(pWiasContext, &pRootItemCtx);
    if (FAILED(hr)) {
        return E_FAIL;
    }

    //
    // read the current WIA_DPS_PREVIEW setting from the ROOT item.
    //

    LONG lPreview = 0;
    hr = wiasReadPropLong(pRootItemCtx,WIA_DPS_PREVIEW,&lPreview,NULL,FALSE);
    if(hr == S_FALSE){

        //
        // if S_FALSE is returned, then the WIA_DPS_PREVIEW property does
        // not exist.  Return S_OK, because we are can not proceed any more.
        //

        return S_OK;
    }

    //
    // log the results to the debugger, to show the current status of the WIA_DPS_PREVIEW
    // property.  This is where you would normally perform an operation to set the WIA minidriver
    // into PREVIEW mode. (ON/OFF)
    //

    if (S_OK == hr) {
        switch (lPreview) {
        case WIA_FINAL_SCAN:
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("CheckPreview, Set to WIA_FINAL_SCAN"));
            break;
        case WIA_PREVIEW_SCAN:
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("CheckPreview, Set to WIA_PREVIEW_SCAN"));
            break;
        default:
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("CheckPreview, Set to invalid argument (%d)",lPreview));
            hr = E_INVALIDARG;
            break;
        }
    }
    return hr;
}

/**************************************************************************\
* UpdateValidPages
*
*   This helper method is called to make the relevant changes to the Pages
*   property if a file format can not support multi-page.
*
* Arguments:
*
*   pWiasContext    -   a pointer to the item context whose properties have
*                       changed.
*   pContext    -   a pointer to the property context (which indicates
*                   which properties are being written).
*
* Return Value:
*
*    Status
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/
HRESULT CWIADevice::UpdateValidPages(BYTE *pWiasContext,
                                            WIA_PROPERTY_CONTEXT *pContext)
{
    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if((!pWiasContext)||(!pContext)){
        return E_INVALIDARG;
    }

    //
    // get the ROOT item, this is where the pages property exists
    //

    BYTE *pRootItemCtx   = NULL;
    HRESULT hr = wiasGetRootItem(pWiasContext, &pRootItemCtx);
    if (FAILED(hr)) {
        return hr;
    }

    //
    // read the current WIA_IPA_TYMED setting from the item
    //

    LONG lTymed = TYMED_FILE;
    hr = wiasReadPropLong(pWiasContext,WIA_IPA_TYMED,&lTymed,NULL,TRUE);
    if(S_OK == hr){
        switch(lTymed)
        {
        case TYMED_FILE:
            {
                GUID FormatGUID = GUID_NULL;
                hr = wiasReadPropGuid(pWiasContext,WIA_IPA_FORMAT,&FormatGUID,NULL,TRUE);
                if (S_OK == hr) {

                    if (FormatGUID == WiaImgFmt_BMP) {

                        //
                        // set the valid values for WIA_IPA_PAGES property to 1
                        // because there is no such thing as a multipage BMP file.
                        //

                        hr = wiasSetValidRangeLong(pRootItemCtx,WIA_DPS_PAGES,1,1,1,1);
                        if (S_OK == hr) {
                            hr = wiasWritePropLong(pRootItemCtx,WIA_DPS_PAGES,1);
                        }
                    }

                    if (FormatGUID == WiaImgFmt_TIFF) {

                        //
                        // set the valid values for WIA_IPA_PAGES property to MAX_PAGE_CAPACITY
                        // because there can be multiple pages transferred to TIF.
                        //

                        hr = wiasSetValidRangeLong(pRootItemCtx,WIA_DPS_PAGES,0,1,MAX_PAGE_CAPACITY,1);
                    }
                }
            }
            break;
        case TYMED_CALLBACK:
            {

                //
                // set the valid values for WIA_IPA_PAGES property to MAX_PAGE_CAPACITY
                // because there can be multiple pages transferred to memory.  Each page
                // will be separated by a IT_MSG_NEW_PAGE message in the application's
                // callback loop.
                //

                hr = wiasSetValidRangeLong(pRootItemCtx,WIA_DPS_PAGES,0,1,MAX_PAGE_CAPACITY,1);
            }
            break;
        default:
            break;
        }
    }
    return hr;
}

/**************************************************************************\
* CheckXExtent
*
*
* Arguments:
*
*   pWiasContext - pointer to an Item.
*
* Return Value:
*
*    Byte count.
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/
HRESULT CWIADevice::CheckXExtent(BYTE *pWiasContext,
                                        WIA_PROPERTY_CONTEXT *pContext,
                                        LONG lWidth)
{
    HRESULT hr = S_OK;

    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CheckXExtent");

    //
    // If the caller did not pass in the correct parameters, then fail the
    // call with E_INVALIDARG.
    //

    if((!pWiasContext)||(!pContext)){
        return E_INVALIDARG;
    }

    LONG lMaxExtent;
    LONG lExt;
    WIAS_CHANGED_VALUE_INFO cviXRes, cviXExt;

    //
    // get x resolution changes
    //

    hr = wiasGetChangedValueLong(pWiasContext,pContext,FALSE,WIA_IPS_XRES,&cviXRes);
    if (FAILED(hr)) {
        return hr;
    }

    //
    // get x extent changes
    //

    hr = wiasGetChangedValueLong(pWiasContext,pContext,cviXRes.bChanged,WIA_IPS_XEXTENT,&cviXExt);
    if (FAILED(hr)) {
        return hr;
    }

    //
    // update extent
    //

    lMaxExtent = ((cviXRes.Current.lVal * lWidth) / 1000);

    //
    //  Update read-only property : PIXELS_PER_LINE.  The width in pixels
    //  of the scanned image is the same size as the XExtent.
    //

    if (SUCCEEDED(hr)) {
        hr = wiasWritePropLong(pWiasContext, WIA_IPS_XEXTENT, lMaxExtent);
        if(S_OK == hr){
            hr = wiasWritePropLong(pWiasContext, WIA_IPA_PIXELS_PER_LINE, lMaxExtent);
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\wiascnex\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "precomp.h"
#pragma hdrstop

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
#include <atlctl.cpp>
#include <atlwin.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\wiascanr\wiaprop.h ===
/**************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2002
*
*  TITLE:       WIAProp.h
*
*  VERSION:     1.1
*
*  DATE:        05 March, 2002
*
*  DESCRIPTION:
*   Default property declarations and definitions for the
*   Sample WIA Scanner device.
*
***************************************************************************/

#ifndef _WIAPROP_H
#define _WIAPROP_H

#define SCANNER_FIRMWARE_VERSION L"1.0"
#define OPTICAL_XRESOLUTION      300
#define OPTICAL_YRESOLUTION      300
#define HORIZONTAL_BED_SIZE      8500   // in one thousandth's of an inch
#define VERTICAL_BED_SIZE        11000  // in one thousandth's of an inch

#define HORIZONTAL_ADF_BED_SIZE  8500   // in one thousandth's of an inch
#define VERTICAL_ADF_BED_SIZE    11000  // in one thousandth's of an inch

#define HORIZONTAL_TPA_BED_SIZE  8500   // in one thousandth's of an inch
#define VERTICAL_TPA_BED_SIZE    11000  // in one thousandth's of an inch

#define MIN_BUFFER_SIZE          65535

#define INITIAL_PHOTOMETRIC_INTERP WIA_PHOTO_WHITE_1
#define INITIAL_COMPRESSION        WIA_COMPRESSION_NONE
#define INITIAL_XRESOLUTION        150
#define INITIAL_YRESOLUTION        150
#define INITIAL_DATATYPE           WIA_DATA_GRAYSCALE
#define INITIAL_BITDEPTH           8
#define INITIAL_BRIGHTNESS         0
#define INITIAL_CONTRAST           0
#define INITIAL_CHANNELS_PER_PIXEL 1
#define INITIAL_BITS_PER_CHANNEL   8
#define INITIAL_PLANAR             WIA_PACKED_PIXEL
#define INITIAL_FORMAT             (GUID*) &WiaImgFmt_MEMORYBMP
#define INITIAL_TYMED              TYMED_CALLBACK

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\wiascanr\wiascanr.h ===
/**************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2002
*
*  TITLE:       wiascanr.h
*
*  VERSION:     1.1
*
*  DATE:        05 March, 2002
*
*  DESCRIPTION:
*
*
***************************************************************************/

#include "pch.h"

//
// Base structure for supporting non-delegating IUnknown for contained objects
//

struct INonDelegatingUnknown
{
    // IUnknown-like methods
    STDMETHOD(NonDelegatingQueryInterface)(THIS_
              REFIID riid,
              LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,NonDelegatingAddRef)(THIS) PURE;
    STDMETHOD_(ULONG,NonDelegatingRelease)( THIS) PURE;
};

// WIA item specific context.
typedef struct _MINIDRIVERITEMCONTEXT{
   LONG     lSize;
   LONG     lHeaderSize;                        // Transfer header size
   LONG     lImageSize;                         // Image
   LONG     lDepth;                             // image bit depth
   LONG     lBytesPerScanLine;                  // bytes per scan line     (scanned data)
   LONG     lBytesPerScanLineRaw;               // bytes per scan line RAW (scanned data)
   LONG     lTotalRequested;                    // Total image bytes requested.
   LONG     lTotalWritten;                      // Total image bytes written.
} MINIDRIVERITEMCONTEXT, *PMINIDRIVERITEMCONTEXT;

typedef struct _BASIC_PROP_INFO {
    LONG lNumValues;
    LONG *plValues;
}BASIC_PROP_INFO,*PBASIC_PROP_INFO;

typedef struct _BASIC_PROP_INIT_INFO {
    LONG                lNumProps;     // number of item properties
    LPOLESTR            *pszPropNames; // item property names
    PROPID              *piPropIDs;    // item property ids
    PROPVARIANT         *pvPropVars;   // item property prop variants
    PROPSPEC            *psPropSpec;   // item property propspecs
    WIA_PROPERTY_INFO   *pwpiPropInfo; // item property attributes
}BASIC_PROP_INIT_INFO,*PBASIC_PROP_INIT_INFO;

#define HKEY_WIASCANR_FAKE_EVENTS TEXT("Software\\Microsoft\\WIASCANR")
#define WIASCANR_DWORD_FAKE_EVENT_CODE TEXT("EventCode")
#define AVERAGE_FAKE_PAGE_HEIGHT_INCHES 11
#define DEFAULT_LOCK_TIMEOUT 100

#define WIA_DEVICE_ROOT_NAME L"Root"       // THIS SHOULD NOT BE LOCALIZED
#define WIA_DEVICE_FLATBED_NAME L"Flatbed" // THIS SHOULD NOT BE LOCALIZED
#define WIA_DEVICE_FEEDER_NAME L"Feeder"   // THIS SHOULD NOT BE LOCALIZED

//
// Class definition for WIA device object
//

class CWIADevice : public IStiUSD,               // STI USD interface
                   public IWiaMiniDrv,           // WIA Minidriver interface
                   public INonDelegatingUnknown  // NonDelegatingUnknown
{
public:

    /////////////////////////////////////////////////////////////////////////
    // Construction/Destruction Section                                    //
    /////////////////////////////////////////////////////////////////////////

    CWIADevice(LPUNKNOWN punkOuter);
    ~CWIADevice();

    HRESULT PrivateInitialize();

private:

    // COM object data
    ULONG               m_cRef;                 // Device object reference count.

    // STI information
    LPUNKNOWN           m_punkOuter;            // Pointer to outer unknown.
    DWORD               m_dwLastOperationError; // Last error.
    DWORD               m_dwLockTimeout;        // Lock timeout for LockDevice() calls
    BOOL                m_bDeviceLocked;        // device locked/unlocked
    HANDLE              m_hDeviceDataHandle;    // Device communication handle

    // Event information
    OVERLAPPED          m_EventOverlapped;      // event overlapped IO structure
    BYTE                m_EventData[32];        // event data
    BOOL                m_bPolledEvent;         // event polling flag
    HKEY                m_hFakeEventKey;        // event HKEY for simulating notifications
    GUID                m_guidLastEvent;        // Last event ID.

    // WIA information
    IWiaDrvItem         *m_pIDrvItemRoot;       // The root item.
    IStiDevice          *m_pStiDevice;          // Sti object.
    IWiaLog             *m_pIWiaLog;            // WIA logging object
    BOOL                m_bADFEnabled;          // ADF enabled flag
    BOOL                m_bADFAttached;         // ADF attached flag
    LONG                m_lClientsConnected;    // number of applications connected

    CFakeScanAPI        *m_pScanAPI;            // FakeScanner API object

    LONG                m_NumSupportedFormats;  // Number of supported formats
    WIA_FORMAT_INFO     *m_pSupportedFormats;   // supported formats

    LONG                m_NumSupportedCommands; // Number of supported commands
    LONG                m_NumSupportedEvents;   // Number of supported events
    WIA_DEV_CAP_DRV     *m_pCapabilities;       // capabilities

    LONG                m_NumInitialFormats;    // Number of Initial formats
    GUID                *m_pInitialFormats;     // initial formats

    BASIC_PROP_INFO     m_SupportedTYMED;       // supported TYMED
    BASIC_PROP_INFO     m_SupportedDataTypes;   // supported data types
    BASIC_PROP_INFO     m_SupportedIntents;     // supported intents
    BASIC_PROP_INFO     m_SupportedCompressionTypes; // supported compression types
    BASIC_PROP_INFO     m_SupportedResolutions; // supported resolutions
    BASIC_PROP_INFO     m_SupportedPreviewModes;// supported preview modes

    LONG                m_NumRootItemProperties;// Number of Root item properties
    LONG                m_NumItemProperties;    // Number of item properties

    BASIC_PROP_INIT_INFO m_RootItemInitInfo;
    BASIC_PROP_INIT_INFO m_ChildItemInitInfo;

public:

    /////////////////////////////////////////////////////////////////////////
    // Standard COM Section                                                //
    /////////////////////////////////////////////////////////////////////////

    STDMETHODIMP QueryInterface( REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef( void);
    STDMETHODIMP_(ULONG) Release( void);

    /////////////////////////////////////////////////////////////////////////
    // IStiUSD Interface Section (for all WIA drivers)                     //
    /////////////////////////////////////////////////////////////////////////

    //
    //  Methods for implementing the IStiUSD interface.
    //

    STDMETHOD(Initialize)(THIS_
        PSTIDEVICECONTROL pHelDcb,
        DWORD             dwStiVersion,
        HKEY              hParametersKey);

    STDMETHOD(GetCapabilities)(THIS_
        PSTI_USD_CAPS pDevCaps);

    STDMETHOD(GetStatus)(THIS_
        PSTI_DEVICE_STATUS pDevStatus);

    STDMETHOD(DeviceReset)(THIS);

    STDMETHOD(Diagnostic)(THIS_
        LPDIAG pBuffer);

    STDMETHOD(Escape)(THIS_
        STI_RAW_CONTROL_CODE EscapeFunction,
        LPVOID               lpInData,
        DWORD                cbInDataSize,
        LPVOID               pOutData,
        DWORD                dwOutDataSize,
        LPDWORD              pdwActualData);

    STDMETHOD(GetLastError)(THIS_
        LPDWORD pdwLastDeviceError);

    STDMETHOD(LockDevice)(THIS);

    STDMETHOD(UnLockDevice)(THIS);

    STDMETHOD(RawReadData)(THIS_
        LPVOID       lpBuffer,
        LPDWORD      lpdwNumberOfBytes,
        LPOVERLAPPED lpOverlapped);

    STDMETHOD(RawWriteData)(THIS_
        LPVOID       lpBuffer,
        DWORD        nNumberOfBytes,
        LPOVERLAPPED lpOverlapped);

    STDMETHOD(RawReadCommand)(THIS_
        LPVOID       lpBuffer,
        LPDWORD      lpdwNumberOfBytes,
        LPOVERLAPPED lpOverlapped);

    STDMETHOD(RawWriteCommand)(THIS_
        LPVOID       lpBuffer,
        DWORD        dwNumberOfBytes,
        LPOVERLAPPED lpOverlapped);

    STDMETHOD(SetNotificationHandle)(THIS_
        HANDLE hEvent);

    STDMETHOD(GetNotificationData)(THIS_
        LPSTINOTIFY lpNotify);

    STDMETHOD(GetLastErrorInfo)(THIS_
        STI_ERROR_INFO *pLastErrorInfo);

    /////////////////////////////////////////////////////////////////////////
    // IWiaMiniDrv Interface Section (for all WIA drivers)                 //
    /////////////////////////////////////////////////////////////////////////

    //
    //  Methods for implementing WIA's Mini driver interface
    //

    STDMETHOD(drvInitializeWia)(THIS_
        BYTE        *pWiasContext,
        LONG        lFlags,
        BSTR        bstrDeviceID,
        BSTR        bstrRootFullItemName,
        IUnknown    *pStiDevice,
        IUnknown    *pIUnknownOuter,
        IWiaDrvItem **ppIDrvItemRoot,
        IUnknown    **ppIUnknownInner,
        LONG        *plDevErrVal);

    STDMETHOD(drvAcquireItemData)(THIS_
        BYTE                      *pWiasContext,
        LONG                      lFlags,
        PMINIDRV_TRANSFER_CONTEXT pmdtc,
        LONG                      *plDevErrVal);

    STDMETHOD(drvInitItemProperties)(THIS_
        BYTE *pWiasContext,
        LONG lFlags,
        LONG *plDevErrVal);

    STDMETHOD(drvValidateItemProperties)(THIS_
        BYTE           *pWiasContext,
        LONG           lFlags,
        ULONG          nPropSpec,
        const PROPSPEC *pPropSpec,
        LONG           *plDevErrVal);

    STDMETHOD(drvWriteItemProperties)(THIS_
        BYTE                      *pWiasContext,
        LONG                      lFlags,
        PMINIDRV_TRANSFER_CONTEXT pmdtc,
        LONG                      *plDevErrVal);

    STDMETHOD(drvReadItemProperties)(THIS_
        BYTE           *pWiasContext,
        LONG           lFlags,
        ULONG          nPropSpec,
        const PROPSPEC *pPropSpec,
        LONG           *plDevErrVal);

    STDMETHOD(drvLockWiaDevice)(THIS_
        BYTE *pWiasContext,
        LONG lFlags,
        LONG *plDevErrVal);

    STDMETHOD(drvUnLockWiaDevice)(THIS_
        BYTE *pWiasContext,
        LONG lFlags,
        LONG *plDevErrVal);

    STDMETHOD(drvAnalyzeItem)(THIS_
        BYTE *pWiasContext,
        LONG lFlags,
        LONG *plDevErrVal);

    STDMETHOD(drvGetDeviceErrorStr)(THIS_
        LONG     lFlags,
        LONG     lDevErrVal,
        LPOLESTR *ppszDevErrStr,
        LONG     *plDevErr);

    STDMETHOD(drvDeviceCommand)(THIS_
        BYTE        *pWiasContext,
        LONG        lFlags,
        const GUID  *plCommand,
        IWiaDrvItem **ppWiaDrvItem,
        LONG        *plDevErrVal);

    STDMETHOD(drvGetCapabilities)(THIS_
        BYTE            *pWiasContext,
        LONG            ulFlags,
        LONG            *pcelt,
        WIA_DEV_CAP_DRV **ppCapabilities,
        LONG            *plDevErrVal);

    STDMETHOD(drvDeleteItem)(THIS_
        BYTE *pWiasContext,
        LONG lFlags,
        LONG *plDevErrVal);

    STDMETHOD(drvFreeDrvItemContext)(THIS_
        LONG lFlags,
        BYTE *pSpecContext,
        LONG *plDevErrVal);

    STDMETHOD(drvGetWiaFormatInfo)(THIS_
        BYTE            *pWiasContext,
        LONG            lFlags,
        LONG            *pcelt,
        WIA_FORMAT_INFO **ppwfi,
        LONG            *plDevErrVal);

    STDMETHOD(drvNotifyPnpEvent)(THIS_
        const GUID *pEventGUID,
        BSTR       bstrDeviceID,
        ULONG      ulReserved);

    STDMETHOD(drvUnInitializeWia)(THIS_
        BYTE *pWiasContext);

    /////////////////////////////////////////////////////////////////////////
    // INonDelegating Interface Section (for all WIA drivers)              //
    /////////////////////////////////////////////////////////////////////////

    //
    //  IUnknown-like methods.  Needed in conjunction with normal IUnknown
    //  methods to implement delegating components.
    //

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) NonDelegatingAddRef();
    STDMETHODIMP_(ULONG) NonDelegatingRelease();

private:

    /////////////////////////////////////////////////////////////////////////
    // Private helper functions section (for your specific driver)         //
    /////////////////////////////////////////////////////////////////////////
    //                                                                     //
    // This section is for private helpers used for common WIA operations. //
    // These are custom to your driver.                                    //
    //                                                                     //
    //                                                                     //
    // -- WIA Item Management Helpers                                      //
    //    DeleteItemTree()                                                 //
    //                                                                     //
    // -- WIA Property Management Helpers                                  //
    //    BuildRootItemProperties()                                        //
    //    BuildTopItemProperties()                                         //
    //                                                                     //
    // -- WIA Capability Management Helpers                                //
    //    BuildRootItemProperties()                                        //
    //    DeleteRootItemProperties()                                       //
    //    BuildTopItemProperties()                                         //
    //    DeleteTopItemProperties()                                        //
    //    BuildCapabilities()                                              //
    //    DeleteCapabilitiesArrayContents()                                //
    //    BuildSupportedFormats()                                          //
    //    DeleteSupportedFormatsArrayContents()                            //
    //    BuildSupportedDataTypes()                                        //
    //    DeleteSupportedDataTypesArrayContents()                          //
    //    BuildSupportedIntents()                                          //
    //    DeleteSupportedIntentsArrayContents()                            //
    //    BuildSupportedCompressions()                                     //
    //    DeleteSupportedCompressionsArrayContents()                       //
    //    BuildSupportedPreviewModes()                                     //
    //    DeleteSupportedPreviewModesArrayContents()                       //
    //    BuildSupportedTYMED()                                            //
    //    DeleteSupportedTYMEDArrayContents()                              //
    //    BuildSupportedResolutions()                                      //
    //    DeleteSupportedResolutionsArrayContents()                        //
    //    BuildInitialFormats()                                            //
    //    DeleteInitialFormatsArrayContents()                              //
    //                                                                     //
    // -- WIA Validation Helpers                                           //
    //    CheckDataType()                                                  //
    //    CheckIntent()                                                    //
    //    CheckPreferredFormat()                                           //
    //    CheckADFStatus()                                                 //
    //    CheckPreview()                                                   //
    //    CheckXExtent()                                                   //
    //    UpdateValidDepth()                                               //
    //    UpdateValidPages()                                               //
    //    ValidateDataTransferContext()                                    //
    //                                                                     //
    // -- WIA Resource file Helpers                                        //
    //    GetBSTRResourceString()                                          //
    //    GetOLESTRResourceString()                                        //
    //                                                                     //
    // -- WIA Data Helpers                                                 //
    //    AlignInPlace()                                                   //
    //    SwapBuffer24()                                                   //
    //    GetPageCount()                                                   //
    //    IsPreviewScan()                                                  //
    //    SetItemSize()                                                    //
    //                                                                     //
    /////////////////////////////////////////////////////////////////////////

    HRESULT DeleteItemTree();

    HRESULT BuildRootItemProperties();
    HRESULT DeleteRootItemProperties();
    HRESULT BuildChildItemProperties();
    HRESULT DeleteChildItemProperties();
    HRESULT BuildCapabilities();
    HRESULT DeleteCapabilitiesArrayContents();
    HRESULT BuildSupportedFormats();
    HRESULT DeleteSupportedFormatsArrayContents();
    HRESULT BuildSupportedDataTypes();
    HRESULT DeleteSupportedDataTypesArrayContents();
    HRESULT BuildSupportedIntents();
    HRESULT DeleteSupportedIntentsArrayContents();
    HRESULT BuildSupportedCompressions();
    HRESULT DeleteSupportedCompressionsArrayContents();
    HRESULT BuildSupportedPreviewModes();
    HRESULT DeleteSupportedPreviewModesArrayContents();
    HRESULT BuildSupportedTYMED();
    HRESULT DeleteSupportedTYMEDArrayContents();
    HRESULT BuildSupportedResolutions();
    HRESULT DeleteSupportedResolutionsArrayContents();
    HRESULT BuildInitialFormats();
    HRESULT DeleteInitialFormatsArrayContents();

    HRESULT CheckDataType(BYTE *pWiasContext,WIA_PROPERTY_CONTEXT *pContext);
    HRESULT CheckIntent(BYTE *pWiasContext,WIA_PROPERTY_CONTEXT *pContext);
    HRESULT CheckPreferredFormat(BYTE *pWiasContext,WIA_PROPERTY_CONTEXT *pContext);
    HRESULT CheckADFStatus(BYTE *pWiasContext,WIA_PROPERTY_CONTEXT *pContext);
    HRESULT CheckPreview(BYTE *pWiasContext,WIA_PROPERTY_CONTEXT *pContext);
    HRESULT CheckXExtent(BYTE *pWiasContext,WIA_PROPERTY_CONTEXT *pContext,LONG lWidth);
    HRESULT UpdateValidDepth(BYTE *pWiasContext,LONG lDataType,LONG *lDepth);
    HRESULT UpdateValidPages(BYTE *pWiasContext,WIA_PROPERTY_CONTEXT *pContext);
    HRESULT ValidateDataTransferContext(PMINIDRV_TRANSFER_CONTEXT pDataTransferContext);

    HRESULT GetBSTRResourceString(LONG lLocalResourceID,BSTR *pBSTR,BOOL bLocal);
    HRESULT GetOLESTRResourceString(LONG lLocalResourceID,LPOLESTR *ppsz,BOOL bLocal);

    UINT AlignInPlace(PBYTE pBuffer,LONG cbWritten,LONG lBytesPerScanLine,LONG lBytesPerScanLineRaw);
    VOID SwapBuffer24(PBYTE pBuffer,LONG lByteCount);
    LONG GetPageCount(BYTE *pWiasContext);
    BOOL IsPreviewScan(BYTE *pWiasContext);
    HRESULT SetItemSize(BYTE *pWiasContext);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\wiascnex\resource.h ===
//(C) COPYRIGHT MICROSOFT CORP., 1998-1999

#define IDS_CATEGORYNAME                40006
#define IDS_PRESS_SCANBUTTON            30000
#define IDS_PRESS_COPYBUTTON            30001
#define IDS_PRESS_FAXBUTTON             30002

#define IDR_VIEWREG                     2001
#define IDR_CATEGORY                    2002
#define IDR_CATEGORIES                  2003
#define IDR_ELEMENT                     2004
#define IDI_TESTDEVICE                  2005
#define IDM_PRESS_SCANBUTTON            200
#define IDM_PRESS_COPYBUTTON            201
#define IDM_PRESS_FAXBUTTON             202
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\wiascnex\precomp.h ===
//(C) COPYRIGHT MICROSOFT CORP., 1998-1999
#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifndef STRICT
#define STRICT
#endif

#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED
#define _ATL_NO_UUIDOF
#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

#include <windows.h>
#include <shellapi.h>
#include <shlobj.h>
#include <initguid.h>
#include <shlguid.h>
#include "wiadevd.h"
#include "wiascidl.h"
#include "wia.h"
#include "wiaview.h"
#include "resource.h"
#include "wiascnex.h"
#include "classes.h"

#define g_hInst _Module.GetModuleInstance()
VOID Trace(LPCTSTR format,...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\wiascnex\shellext.cpp ===
///////////////////
// (C) COPYRIGHT MICROSOFT CORP., 1998-1999
//
// FILE: SHELLEXT.CPP
//
// DESCRIPTION: Implements IContextMenu and IShellPropSheetExt interfaces for
// the WIA Sample Scanner device
//
#include "precomp.h"
#pragma hdrstop

// Define a language-independent name for our menu verb

static const CHAR  g_PathVerbA[] =  "Press Scan Button";
static const WCHAR g_PathVerbW[] = L"Press Scan Button";

CShellExt :: CShellExt ()
{
    Trace(TEXT("CShellExt Constructor")); 
}

CShellExt::~CShellExt ()
{
    Trace(TEXT("CShellExt Destructor")); 
}

/*****************************************************************************

CShellExt::Initialize

Called by the shell when the user invokes context menu or property sheet for
one of our items. For context menus the dataobject may include more than one
selected item.

******************************************************************************/

STDMETHODIMP CShellExt::Initialize (LPCITEMIDLIST pidlFolder,
                                    LPDATAOBJECT lpdobj,
                                    HKEY hkeyProgID)
{
    Trace(TEXT("CShellExt::Initialize Called")); 
    LONG lType = 0;
    HRESULT hr = NOERROR;
    if (!lpdobj) {
        return E_INVALIDARG;
    }

    // For singular selections, the WIA namespace should always provide a
    // dataobject that also supports IWiaItem

    if (FAILED(lpdobj->QueryInterface (IID_IWiaItem, reinterpret_cast<LPVOID*>(&m_pItem)))) {
        // failing that, get the list of selected items from the data object
        UINT uItems         = 0;
        LPWSTR szName       = NULL;
        LPWSTR szToken      = NULL;
        
        szName = GetNamesFromDataObject (lpdobj, &uItems);

        //
        // we only support singular objects
        //

        if (uItems != 1) {
            hr = E_FAIL;
        } else {

            //
            // The name is of this format: <device id>::<item name>
            //

            LPWSTR szToken = wcstok (szName, L":");
            if (!szToken) {
                hr = E_FAIL;
            }

            //
            // Our extension only supports root items, so make sure there's no item
            // name
            //

            else if (wcstok (NULL, L":")) {
                hr = E_FAIL;
            } else {
                hr = CreateDeviceFromId (szToken, &m_pItem);
            }
        }
        if (szName) {
            delete [] szName;
        }
    }
    if (SUCCEEDED(hr)) {

        m_pItem->GetItemType (&lType);
        if (!(lType & WiaItemTypeRoot)) {
            hr = E_FAIL; // we only support changing the property on the root item
        }
    }
    return hr;
}

/*****************************************************************************

CShellExt::QueryContextMenu

Called by the shell to get our context menu strings for the selected item.

******************************************************************************/

STDMETHODIMP CShellExt::QueryContextMenu (HMENU hmenu,UINT indexMenu,UINT idCmdFirst,UINT idCmdLast,UINT uFlags)
{
    Trace(TEXT("CShellExt::QueryContextMenu Called"));
    Trace(TEXT("indexMenu  = %d"),indexMenu);
    Trace(TEXT("idCmdFirst = %d"),idCmdFirst);
    Trace(TEXT("idCmdLast  = %d"),idCmdLast);
    Trace(TEXT("uFlags     = %d"),uFlags);

    HRESULT hr = S_OK;    

    MENUITEMINFO mii;
    TCHAR szMenuItemName[MAX_PATH];
    memset(&mii,0,sizeof(mii));
    LoadString (g_hInst,IDS_PRESS_FAXBUTTON, szMenuItemName, MAX_PATH);

    mii.cbSize      = sizeof(mii);
    mii.fMask       = MIIM_STRING | MIIM_ID;
    mii.fState      = MFS_ENABLED;
    mii.wID         = idCmdFirst;
    mii.dwTypeData  = szMenuItemName;
    if (InsertMenuItem (hmenu, indexMenu, TRUE, &mii)) {
        m_FaxButtonidCmd = 0;
        memset(&mii,0,sizeof(mii));
        LoadString (g_hInst, IDS_PRESS_COPYBUTTON, szMenuItemName, MAX_PATH);

        mii.cbSize      = sizeof(mii);
        mii.fMask       = MIIM_STRING | MIIM_ID;
        mii.fState      = MFS_ENABLED;
        mii.wID         = idCmdFirst;    
        mii.dwTypeData  = szMenuItemName;
        if (InsertMenuItem (hmenu, indexMenu, TRUE, &mii)) {
            m_CopyButtonidCmd = 1;          
            memset(&mii,0,sizeof(mii));
            LoadString (g_hInst, IDS_PRESS_SCANBUTTON, szMenuItemName, MAX_PATH);

            mii.cbSize      = sizeof(mii);
            mii.fMask       = MIIM_STRING | MIIM_ID;
            mii.fState      = MFS_ENABLED;
            mii.wID         = idCmdFirst;    
            mii.dwTypeData  = szMenuItemName;
            if (InsertMenuItem (hmenu, indexMenu, TRUE, &mii)) {
                m_ScanButtonidCmd = 2;
                return MAKE_HRESULT(SEVERITY_SUCCESS, 0, 1);
            }
        }
    }    
    return hr;
}

/*****************************************************************************

CShellExt::InvokeCommand

Called by the shell when the user clicks one of our menu items

******************************************************************************/

STDMETHODIMP CShellExt::InvokeCommand    (LPCMINVOKECOMMANDINFO lpici)
{
    Trace(TEXT("CShellExt::InvokeCommand Called")); 
    HRESULT hr = S_OK;
    UINT_PTR idCmd = reinterpret_cast<UINT_PTR>(lpici->lpVerb);
    if(idCmd == 0){

        //
        // it's one of ours
        //

        MessageBox(NULL,TEXT("Context menu is Selected"),TEXT("Context Menu Verb Alert!"),MB_OK);            
    } else {
        hr = E_FAIL;
    }   
    return hr;
}

/*****************************************************************************

CShellExt::GetCommandString

Called by the shell to get our language independent verb name.

******************************************************************************/

STDMETHODIMP CShellExt::GetCommandString (UINT_PTR idCmd, UINT uType,UINT* pwReserved,LPSTR pszName,UINT cchMax)
{
    Trace(TEXT("CShellExt::GetCommandString Called")); 
    HRESULT hr = S_OK;

    if(idCmd == m_ScanButtonidCmd){
        
    } else if(idCmd == m_CopyButtonidCmd){
        
    } else if(idCmd == m_FaxButtonidCmd){
        
    } else {
        hr = E_FAIL;
    }
    
    if(FAILED(hr)){
        return hr;
    }

    switch (uType) {
    case GCS_VALIDATEA:
        if (pszName) {
            lstrcpyA (pszName, g_PathVerbA);
        }
        break;
    case GCS_VALIDATEW:
        if (pszName) {
            lstrcpyW (reinterpret_cast<LPWSTR>(pszName), g_PathVerbW);
        }
        break;
    case GCS_VERBA:
        lstrcpyA (pszName, g_PathVerbA);
        break;
    case GCS_VERBW:
        lstrcpyW (reinterpret_cast<LPWSTR>(pszName), g_PathVerbW);
        break;
    default:
        hr = E_FAIL;
        break;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\wiascanr\wiascanr.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2002
*
*  TITLE:       wiascanr.cpp
*
*  VERSION:     1.1
*
*  DATE:        05 March, 2002
*
*  DESCRIPTION:
*   Implementation of the WIA Sample scanner class factory and IUNKNOWN interface.
*
*******************************************************************************/

#include "pch.h"
#ifndef INITGUID
    #include <initguid.h>
#endif

#if !defined(dllexp)
    #define DLLEXPORT __declspec( dllexport )
#endif

HINSTANCE g_hInst; // DLL module instance.

//
// This IID_IStiUSD GUID will eventually be in uuid.lib, at which point it should be removed
// from here.
//

// {0C9BB460-51AC-11D0-90EA-00AA0060F86C}
DEFINE_GUID(IID_IStiUSD, 0x0C9BB460L, 0x51AC, 0x11D0, 0x90, 0xEA, 0x00, 0xAA, 0x00, 0x60, 0xF8, 0x6C);

// {98B3790C-0D93-4f22-ADAF-51A45B33C998}
DEFINE_GUID(CLSID_SampleWIAScannerDevice,0x98b3790c, 0xd93, 0x4f22, 0xad, 0xaf, 0x51, 0xa4, 0x5b, 0x33, 0xc9, 0x98);

/***************************************************************************\
*
*  CWIADeviceClassFactory
*
\****************************************************************************/

class CWIADeviceClassFactory : public IClassFactory {
private:
    ULONG m_cRef;
public:
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    STDMETHODIMP CreateInstance(IUnknown __RPC_FAR *pUnkOuter,REFIID riid,void __RPC_FAR *__RPC_FAR *ppvObject);
    STDMETHODIMP LockServer(BOOL fLock);
    CWIADeviceClassFactory();
    ~CWIADeviceClassFactory();
};

/**************************************************************************\
* CWIADeviceClassFactory::CWIADeviceClassFactory(void)
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    None
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

CWIADeviceClassFactory::CWIADeviceClassFactory(void)
{
    m_cRef = 0;
}

/**************************************************************************\
* CWIADeviceClassFactory::~CWIADeviceClassFactory(void)
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    None
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

CWIADeviceClassFactory::~CWIADeviceClassFactory(void)
{

}

/**************************************************************************\
* CWIADeviceClassFactory::QueryInterface
*
*
*
* Arguments:
*
*   riid      -
*   ppvObject -
*
* Return Value:
*
*    Status.
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIADeviceClassFactory::QueryInterface(
                                                          REFIID                      riid,
                                                          void __RPC_FAR *__RPC_FAR   *ppvObject)
{
    if (!ppvObject) {
        return E_INVALIDARG;
    }

    *ppvObject = NULL;

    if (IsEqualIID(riid, IID_IUnknown) || IsEqualIID(riid, IID_IClassFactory)) {
        *ppvObject = (LPVOID)this;
        AddRef();
        return NOERROR;
    }
    return E_NOINTERFACE;
}

/**************************************************************************\
* CWIADeviceClassFactory::AddRef
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWIADeviceClassFactory::AddRef(void)
{
    return InterlockedIncrement((LPLONG)&m_cRef);
}

/**************************************************************************\
* CWIADeviceClassFactory::Release
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWIADeviceClassFactory::Release(void)
{
    ULONG ulRef = 0;
    ulRef = InterlockedDecrement((LPLONG)&m_cRef);

    if (!ulRef) {
        delete this;
    }
    return ulRef;
}

/**************************************************************************\
* CWIADeviceClassFactory::CreateInstance
*
*
*
* Arguments:
*
*    punkOuter -
*    riid,     -
*    ppvObject -
*
* Return Value:
*
*    Status.
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIADeviceClassFactory::CreateInstance(
                                                          IUnknown __RPC_FAR          *punkOuter,
                                                          REFIID                      riid,
                                                          void __RPC_FAR *__RPC_FAR   *ppvObject)
{

    //
    // If the caller is not requesting IID_IUnknown or IID_IStiUsd then
    // return E_NOINTERFACE, letting the caller know that interface
    // is not supported by this COM component.
    //

    if ((!IsEqualIID(riid, IID_IStiUSD)) && (!IsEqualIID(riid, IID_IUnknown))) {
        return E_NOINTERFACE;
    }

    //
    // If the caller is creating for aggregation, only IID_IUnknown can be requested.
    //

    if ((punkOuter) && (!IsEqualIID(riid, IID_IUnknown))) {
        return CLASS_E_NOAGGREGATION;
    }

    //
    // allocate the CWIAScannerDevce object.  This is the WIA minidriver object which
    // supports the WIA interfaces.  If allocation fails for this object, return an
    // E_OUTOFMEMORY error to the caller.
    //

    CWIADevice  *pDev = NULL;
    pDev = new CWIADevice(punkOuter);
    if (!pDev) {
        return E_OUTOFMEMORY;
    }

    //
    // If the allocation is successful, call PrivateInitialize().  This function handles
    // all internal initializing of the WIA minidriver object.  The implementation of this
    // function can be found in wiascanr.cpp.  If PrivateInitialize fails, then the WIA
    // minidriver object must be destroyed and the entire CreateInstance() muct fail.
    //

    HRESULT hr = pDev->PrivateInitialize();
    if (S_OK != hr) {
        delete pDev;
        pDev = NULL;
        return hr;
    }

    //
    // Call the NonDelegating interface methods to handle nonaggregated requests.
    // Do not do this if we are aggregated or the private IUknown interface will be lost.
    //

    hr = pDev->NonDelegatingQueryInterface(riid,ppvObject);
    pDev->NonDelegatingRelease();

    return hr;
}

/**************************************************************************\
* CWIADeviceClassFactory::LockServer
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIADeviceClassFactory::LockServer(BOOL fLock)
{
    if (fLock) {

        //
        // The class factory is being locked
        //

    } else {

        //
        // The class factory is being unlocked
        //

    }
    return S_OK;
}

/**************************************************************************\
* CWIADevice::NonDelegatingQueryInterface
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIADevice::NonDelegatingQueryInterface(
                                                           REFIID  riid,
                                                           LPVOID  *ppvObj)
{
    if (!ppvObj) {
        return E_INVALIDARG;
    }

    *ppvObj = NULL;

    //
    // If the caller is asking for any interfaces supported by this WIA
    // minidriver, IID_IUnknown, IID_IStiUSD, or IID_WiaMiniDrv statis_cast
    // the "this" pointer to the requested interface.
    //

    if (IsEqualIID( riid, IID_IUnknown )) {
        *ppvObj = static_cast<INonDelegatingUnknown*>(this);
    } else if (IsEqualIID( riid, IID_IStiUSD )) {
        *ppvObj = static_cast<IStiUSD*>(this);
    } else if (IsEqualIID( riid, IID_IWiaMiniDrv )) {
        *ppvObj = static_cast<IWiaMiniDrv*>(this);
    } else {
        return STIERR_NOINTERFACE;
    }

    (reinterpret_cast<IUnknown*>(*ppvObj))->AddRef();

    return S_OK;
}

/**************************************************************************\
* CWIADevice::NonDelegatingAddRef
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Object reference count.
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWIADevice::NonDelegatingAddRef(void)
{
    return InterlockedIncrement((LPLONG)&m_cRef);
}

/**************************************************************************\
* CWIADevice::NonDelegatingRelease
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Object reference count.
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWIADevice::NonDelegatingRelease(void)
{
    ULONG ulRef = InterlockedDecrement((LPLONG)&m_cRef);
    if (!ulRef) {
        delete this;
    }
    return ulRef;
}

/**************************************************************************\
* CWIADevice::QueryInterface
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIADevice::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    if(!m_punkOuter){
        return E_NOINTERFACE;
    }
    return m_punkOuter->QueryInterface(riid,ppvObj);
}

/**************************************************************************\
* CWIADevice::AddRef
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWIADevice::AddRef(void)
{
    if(!m_punkOuter){
        return 0;
    }
    return m_punkOuter->AddRef();
}

/**************************************************************************\
* CWIADevice::Release
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWIADevice::Release(void)
{
    if(!m_punkOuter){
        return 0;
    }
    return m_punkOuter->Release();
}

/**************************************************************************\
* DllEntryPoint
*
*   Main library entry point. Receives DLL event notification from OS.
*
*       We are not interested in thread attaches and detaches,
*       so we disable thread notifications for performance reasons.
*
* Arguments:
*
*    hinst      -
*    dwReason   -
*    lpReserved -
*
* Return Value:
*
*    Returns TRUE to allow the DLL to load.
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/


extern "C" DLLEXPORT BOOL APIENTRY DllEntryPoint(
                                                HINSTANCE   hinst,
                                                DWORD       dwReason,
                                                LPVOID      lpReserved)
{
    switch (dwReason) {
    case DLL_PROCESS_ATTACH:
        g_hInst = hinst;
        DisableThreadLibraryCalls(hinst);
        break;
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}

/**************************************************************************\
* DllCanUnloadNow
*
*   Determines whether the DLL has any outstanding interfaces.
*
* Arguments:
*
*    None
*
* Return Value:
*
*   Returns S_OK if the DLL can unload, S_FALSE if it is not safe to unload.
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

extern "C" STDMETHODIMP DllCanUnloadNow(void)
{
    return S_OK;
}

/**************************************************************************\
* DllGetClassObject
*
*   Retrieves the class object from a DLL object handler or object
*   application.
*
* Arguments:
*
*    rclsid - The object being requested.
*    riid   - The desired interface on the object.
*    ppv    - Output pointer to object.
*
* Return Value:
*
*    Status.
*
* History:
*
*    03/05/2002 Original Version
*
\**************************************************************************/

extern "C" STDAPI DllGetClassObject(
                                   REFCLSID    rclsid,
                                   REFIID      riid,
                                   LPVOID      *ppv)
{
    if (!ppv) {
        return E_INVALIDARG;
    }

    //
    // If the caller is not requesting the proper WIA minidriver class
    // then fail the call with CLASS_E_CLASSNOTAVAILABLE.
    //

    if (!IsEqualCLSID(rclsid, CLSID_SampleWIAScannerDevice) ) {
        return CLASS_E_CLASSNOTAVAILABLE;
    }

    //
    // If the caller is not requesting IID_IUnknown or IID_IClassFactory
    // then fail the call with E_NOINTERFACE;
    //

    if ((!IsEqualIID(riid, IID_IUnknown)) && (!IsEqualIID(riid, IID_IClassFactory))) {
        return E_NOINTERFACE;
    }

    //
    // Allocate the WIA minidriver class factory that belongs to the WIA minidriver
    // COM object.
    //

    if (IsEqualCLSID(rclsid, CLSID_SampleWIAScannerDevice)) {
        CWIADeviceClassFactory *pcf = new CWIADeviceClassFactory;
        if (!pcf) {
            return E_OUTOFMEMORY;
        }
        *ppv = (LPVOID)pcf;
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\wiascnex\classes.h ===
//(C) COPYRIGHT MICROSOFT CORP., 1998-1999

#ifndef _CLASSES_H_
#define _CLASSES_H_


/*****************************************************************************
class CShellExt

Implement our regular shell extensions.


******************************************************************************/

class ATL_NO_VTABLE CShellExt :
    public CComObjectRootEx<CComSingleThreadModel>,
    public CComCoClass<CShellExt, &CLSID_ScannerShellExt>,
    public IShellExtInit, public IContextMenu
{
    private:
        UINT_PTR m_ScanButtonidCmd;
        UINT_PTR m_CopyButtonidCmd;
        UINT_PTR m_FaxButtonidCmd;
        CComPtr<IWiaItem> m_pItem;
        
    public:
    DECLARE_REGISTRY_RESOURCEID(IDR_VIEWREG)
    BEGIN_COM_MAP(CShellExt)
        COM_INTERFACE_ENTRY(IShellExtInit)
        COM_INTERFACE_ENTRY(IContextMenu)        
    END_COM_MAP()
        
        // IShellExtInit
        STDMETHODIMP Initialize (LPCITEMIDLIST pidlFolder,LPDATAOBJECT lpdobj,HKEY hkeyProgID);
        
        // IContextMenu
        STDMETHODIMP QueryContextMenu (HMENU hmenu,UINT indexMenu,UINT idCmdFirst,UINT idCmdLast,UINT uFlags);
        STDMETHODIMP InvokeCommand    (LPCMINVOKECOMMANDINFO lpici);
        STDMETHODIMP GetCommandString (UINT_PTR idCmd, UINT uType,UINT* pwReserved,LPSTR pszName,UINT cchMax);
        ~CShellExt ();
        CShellExt ();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\wiascnex\wiascnex.h ===
//(C) COPYRIGHT MICROSOFT CORP., 1998-1999

 #ifndef _WIASCNEX_H_
 #define _WIASCNEX_H_


 BOOL ShowMessage (HWND hParent, INT idCaption, INT idMessage);
 extern LONG                g_cRef;            // DLL reference counter.
 extern HINSTANCE           g_hInst;


void DllAddRef ();
void DllRelease ();
HRESULT CreateDeviceFromId (LPWSTR szDeviceId, IWiaItem **ppItem);
LPWSTR GetNamesFromDataObject (IDataObject *lpdobj, UINT *puItems);

// {50983B34-4F6E-448e-A2AB-3921EE71BE61}
DEFINE_GUID(CLSID_ScannerShellExt, 0x50983b34, 0x4f6e, 0x448e, 0xa2, 0xab, 0x39, 0x21, 0xee, 0x71, 0xbe, 0x61);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\wiascroll\wiaprop.h ===
/**************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       WIAProp.h
*
*  VERSION:     1.0
*
*  DATE:        18 July, 2000
*
*  DESCRIPTION:
*   Default property declarations and definitions for the
*   Sample WIA Scanner device.
*
***************************************************************************/

#ifndef _WIAPROP_H
#define _WIAPROP_H

#define SCANNER_FIRMWARE_VERSION L"1.0"
#define OPTICAL_XRESOLUTION      300
#define OPTICAL_YRESOLUTION      300
#define HORIZONTAL_BED_SIZE      8500   // in one thousandth's of an inch
#define VERTICAL_BED_SIZE        11000  // in one thousandth's of an inch

#define HORIZONTAL_ADF_BED_SIZE  8500   // in one thousandth's of an inch
#define VERTICAL_ADF_BED_SIZE    11000  // in one thousandth's of an inch

#define HORIZONTAL_TPA_BED_SIZE  8500   // in one thousandth's of an inch
#define VERTICAL_TPA_BED_SIZE    11000  // in one thousandth's of an inch

#define MIN_BUFFER_SIZE          65535

#define INITIAL_PHOTOMETRIC_INTERP WIA_PHOTO_WHITE_1
#define INITIAL_COMPRESSION        WIA_COMPRESSION_NONE
#define INITIAL_XRESOLUTION        150
#define INITIAL_YRESOLUTION        150
#define INITIAL_DATATYPE           WIA_DATA_GRAYSCALE
#define INITIAL_BITDEPTH           8
#define INITIAL_BRIGHTNESS         0
#define INITIAL_CONTRAST           0
#define INITIAL_CHANNELS_PER_PIXEL 1
#define INITIAL_BITS_PER_CHANNEL   8
#define INITIAL_PLANAR             WIA_PACKED_PIXEL
#define INITIAL_FORMAT             (GUID*) &WiaImgFmt_MEMORYBMP
#define INITIAL_TYMED              TYMED_CALLBACK

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\wiascnex\wiascnex.cpp ===
////////////////////////////////////
// (C) COPYRIGHT MICROSOFT CORP., 1998-1999
//
// FILE: WIASCNEX.CPP
//
// DESCRIPTION: Implements core DLL routines.
//
#include "precomp.h"
#pragma hdrstop
#include <string.h>
#include <tchar.h>
#include "resource.h"

#include "wiascidl_i.c"

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_ScannerShellExt,  CShellExt)
END_OBJECT_MAP()

static CComBSTR          g_strCategory;

STDAPI DllRegisterServer(void)
{

    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}


STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer();
}


EXTERN_C
BOOL
DllMain(
    HINSTANCE   hinst,
    DWORD       dwReason,
    LPVOID      lpReserved)
{
    switch (dwReason) {
        case DLL_PROCESS_ATTACH:

            _Module.Init (ObjectMap, hinst);
            DisableThreadLibraryCalls(hinst);

            break;

        case DLL_PROCESS_DETACH:
            _Module.Term();
            break;
    }
    return TRUE;
}


extern "C" STDMETHODIMP DllCanUnloadNow(void)
{
    return _Module.GetLockCount()==0 ? S_OK : S_FALSE;
}

extern "C" STDAPI DllGetClassObject(
    REFCLSID    rclsid,
    REFIID      riid,
    LPVOID      *ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);

}


/*****************************************************************************

ShowMessage

Utility function for displaying messageboxes

******************************************************************************/

BOOL ShowMessage (HWND hParent, INT idCaption, INT idMessage)
{
    MSGBOXPARAMS mbp;
    BOOL bRet;
    INT  i;

    ZeroMemory (&mbp, sizeof(mbp));
    mbp.cbSize = sizeof(mbp);
    mbp.hwndOwner = hParent;
    mbp.hInstance = g_hInst;
    mbp.lpszText = MAKEINTRESOURCE(idMessage);
    mbp.lpszCaption = MAKEINTRESOURCE(idCaption);
    mbp.dwStyle = MB_OK | MB_APPLMODAL;

    i = MessageBoxIndirect (&mbp);
    bRet = (IDOK==i);
    return bRet;
}

/*****************************************************************************

FindLastID

Utility for getting the last relative pidl from a full pidl

******************************************************************************/
// unsafe macros
#define _ILSkip(pidl, cb)       ((LPITEMIDLIST)(((BYTE*)(pidl))+cb))
#define ILNext(pidl)           _ILSkip(pidl, (pidl)->mkid.cb)

LPITEMIDLIST
FindLastID(LPCITEMIDLIST pidl)
{
    LPCITEMIDLIST pidlLast = pidl;
    LPCITEMIDLIST pidlNext = pidl;

    if (pidl == NULL)
        return NULL;

    // Find the last one
    while (pidlNext->mkid.cb)
    {
        pidlLast = pidlNext;
        pidlNext = ILNext(pidlLast);
    }

    return (LPITEMIDLIST)pidlLast;
}

/*****************************************************************************

CreateDeviceFromID

Utility for attaching to WIA and getting a root IWiaItem interface

*****************************************************************************/
HRESULT
CreateDeviceFromId (LPWSTR szDeviceId, IWiaItem **ppItem)
{
    IWiaDevMgr *pDevMgr;
    HRESULT hr = CoCreateInstance (CLSID_WiaDevMgr,
                                   NULL,
                                   CLSCTX_LOCAL_SERVER,
                                   IID_IWiaDevMgr,
                                   reinterpret_cast<LPVOID*>(&pDevMgr));
    if (SUCCEEDED(hr))
    {
        BSTR strId = SysAllocString (szDeviceId);
        hr = pDevMgr->CreateDevice (strId, ppItem);
        SysFreeString (strId);
        pDevMgr->Release ();
    }
    return hr;
}

/*****************************************************************************\

    GetNamesFromDataObject

    Return the list of selected item identifiers. Each identifier is of the form
    "<DEVICEID>::<FULL PATH NAME>". the list is double-null terminated

*****************************************************************************/

LPWSTR
GetNamesFromDataObject (IDataObject *lpdobj, UINT *puItems)
{
    FORMATETC fmt;
    STGMEDIUM stg;
    LPWSTR szRet = NULL;
    LPWSTR szCurrent;
    UINT nItems;
    size_t size;
    if (puItems)
    {
        *puItems = 0;
    }

    fmt.cfFormat = (CLIPFORMAT) RegisterClipboardFormat (TEXT("WIAItemNames"));
    fmt.dwAspect = DVASPECT_CONTENT;
    fmt.lindex = -1;
    fmt.ptd = NULL;
    fmt.tymed = TYMED_HGLOBAL;

    if (lpdobj && puItems && SUCCEEDED(lpdobj->GetData (&fmt, &stg)))
    {
        szCurrent = reinterpret_cast<LPWSTR>(GlobalLock (stg.hGlobal));

        // count the number of items in the double-null terminated string
        szRet  = szCurrent;
        nItems = 0;
        while (*szRet)
        {
            nItems++;
            while (*szRet)
            {
                szRet++;
            }
            szRet++;
        }
        *puItems = nItems;
        size = (szRet-szCurrent+1)*sizeof(WCHAR);
        szRet = new WCHAR[size];
        CopyMemory (szRet, szCurrent, size);
        GlobalUnlock (stg.hGlobal);
        GlobalFree (stg.hGlobal);
    }
    return szRet;
}

VOID Trace(LPCTSTR format,...)
{

//#ifdef DEBUG

    TCHAR Buffer[1024];
    va_list arglist;
    va_start(arglist, format);
    wvsprintf(Buffer, format, arglist);
    va_end(arglist);
    OutputDebugString(Buffer);
    OutputDebugString(TEXT("\n"));

//#endif

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\wiascroll\istiusd.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       IStiUSD.cpp
*
*  VERSION:     1.0
*
*  DATE:        18 July, 2000
*
*  DESCRIPTION:
*   Implementation of the WIA sample scanner IStiUSD methods.
*
*******************************************************************************/

#include "pch.h"
extern HINSTANCE g_hInst;   // used for WIAS_LOGPROC macro

#define THREAD_TERMINATION_TIMEOUT  10000
VOID EventThread( LPVOID  lpParameter ); // event thread

/**************************************************************************\
* CWIAScannerDevice::CWIAScannerDevice
*
*   Device class constructor
*
* Arguments:
*
*    None
*
* Return Value:
*
*    None
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

CWIAScannerDevice::CWIAScannerDevice(LPUNKNOWN punkOuter):
    m_cRef(1),
    m_fValid(FALSE),
    m_punkOuter(NULL),
    m_pIStiDevControl(NULL),
    m_bUsdLoadEvent(FALSE),
    m_dwLastOperationError(0),
    m_dwLockTimeout(100),
    m_hSignalEvent(NULL),
    m_hShutdownEvent(NULL),
    m_hEventNotifyThread(NULL),
    m_guidLastEvent(GUID_NULL),
    m_bstrDeviceID(NULL),
    m_bstrRootFullItemName(NULL),
    m_pIWiaEventCallback(NULL),
    m_pIDrvItemRoot(NULL),
    m_pStiDevice(NULL),
    m_hInstance(NULL),
    m_pIWiaLog(NULL),
    m_NumSupportedFormats(0),
    m_NumCapabilities(0),
    m_NumSupportedTYMED(0),
    m_NumInitialFormats(0),
    m_NumSupportedDataTypes(0),
    m_NumSupportedIntents(0),
    m_NumSupportedCompressionTypes(0),
    m_NumSupportedResolutions(0),
    m_pSupportedFormats(NULL),
    m_pInitialFormats(NULL),
    m_pCapabilities(NULL),
    m_pSupportedTYMED(NULL),
    m_pSupportedDataTypes(NULL),
    m_pSupportedIntents(NULL),
    m_pSupportedCompressionTypes(NULL),
    m_pSupportedResolutions(NULL),
    m_pSupportedPreviewModes(NULL),
    m_pszRootItemDefaults(NULL),
    m_piRootItemDefaults(NULL),
    m_pvRootItemDefaults(NULL),
    m_psRootItemDefaults(NULL),
    m_wpiRootItemDefaults(NULL),
    m_pszItemDefaults(NULL),
    m_piItemDefaults(NULL),
    m_pvItemDefaults(NULL),
    m_psItemDefaults(NULL),
    m_wpiItemDefaults(NULL),
    m_NumRootItemProperties(0),
    m_NumItemProperties(0),
    m_MaxBufferSize(524280),
    m_MinBufferSize(262140),
    m_bDeviceLocked(FALSE),
    m_DeviceDefaultDataHandle(NULL),
    m_pszDeviceNameA(NULL),
    m_bADFEnabled(TRUE),
    m_pScanAPI(NULL)
{
    // See if we are aggregated. If we are (almost always the case) save
    // pointer to the controlling Unknown , so subsequent calls will be
    // delegated. If not, set the same pointer to "this".
    if (punkOuter) {
        m_punkOuter = punkOuter;
    } else {
        // Cast below is needed in order to point to right virtual table
        m_punkOuter = reinterpret_cast<IUnknown*>
                      (static_cast<INonDelegatingUnknown*>
                      (this));
    }
}

/**************************************************************************\
* CWIAScannerDevice::PrivateInitialize
*
*   Device class private initialization code
*
* Arguments:
*
*    None
*
* Return Value:
*
*    HRESULT
*
\**************************************************************************/

HRESULT CWIAScannerDevice::PrivateInitialize()
{
    HRESULT hr = S_OK;

#ifdef USE_SERVICE_LOG_CREATION
    hr = wiasCreateLogInstance(g_hInst, &m_pIWiaLog);
#else

    hr = CoCreateInstance(CLSID_WiaLog, NULL, CLSCTX_INPROC_SERVER,
                          IID_IWiaLog,(void**)&m_pIWiaLog);

    if (SUCCEEDED(hr)) {
        m_pIWiaLog->InitializeLog((LONG)(LONG_PTR)g_hInst);
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL1,("Logging COM object created successfully for wiascroll.dll"));
    } else {
#ifdef DEBUG
        OutputDebugString(TEXT("Could not CoCreateInstance on Logging COM object for wiafbdrv.dll, because we are STI only\n"));
        OutputDebugString(TEXT("********* (Device must have been created for STI only) *********\n"));
#endif
    }

#endif

    __try {
        if(!InitializeCriticalSectionAndSpinCount(&m_csShutdown, MINLONG)) {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CWIAScannerDevice::PrivateInitialize, create shutdown critsec failed"));
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        hr = E_OUTOFMEMORY;
    }


    if(hr == S_OK) {
        // Create event for syncronization of notifications shutdown.
        m_hShutdownEvent =  CreateEvent(NULL,FALSE,FALSE,NULL);

        if (m_hShutdownEvent && (INVALID_HANDLE_VALUE != m_hShutdownEvent)) {
            m_fValid = TRUE;
        } else {
            hr = HRESULT_FROM_WIN32(::GetLastError());
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CWIAScannerDevice::PrivateInitialize, create shutdown event failed"));
        }
    }

    return hr;
}

/**************************************************************************\
* CWIAScannerDevice::~CWIAScannerDevice
*
*   Device class destructor
*
* Arguments:
*
*    None
*
* Return Value:
*
*    None
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

CWIAScannerDevice::~CWIAScannerDevice(void)
{

    // Kill notification thread if it exists.
    SetNotificationHandle(NULL);

    // Close event for syncronization of notifications shutdown.
    if (m_hShutdownEvent && (m_hShutdownEvent != INVALID_HANDLE_VALUE)) {
        CloseHandle(m_hShutdownEvent);
        m_hShutdownEvent = NULL;
    }

    // Release the device control interface.
    if (m_pIStiDevControl) {
        m_pIStiDevControl->Release();
        m_pIStiDevControl = NULL;
    }

    //
    // WIA member destruction
    //

    // Tear down the driver item tree.
    if (m_pIDrvItemRoot) {
        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("~CWIAScannerDevice, Deleting Device Item Tree (this is OK)"));
        DeleteItemTree();
        m_pIDrvItemRoot = NULL;
    }

    // free any IO handles opened
    if(m_DeviceDefaultDataHandle){
        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("~CWIAScannerDevice, Closing DefaultDeviceDataHandle"));
        CloseHandle(m_DeviceDefaultDataHandle);
        m_DeviceDefaultDataHandle = NULL;
    }

    // Cleanup the WIA event sink.
    if (m_pIWiaEventCallback) {
        m_pIWiaEventCallback->Release();
        m_pIWiaEventCallback = NULL;
    }

    // Free the storage for the device ID.
    if (m_bstrDeviceID) {
        SysFreeString(m_bstrDeviceID);
        m_bstrDeviceID = NULL;
    }

    // Release the objects supporting device property storage.
    if (m_bstrRootFullItemName) {
        SysFreeString(m_bstrRootFullItemName);
        m_bstrRootFullItemName = NULL;
    }

    // Delete allocated arrays
    DeleteCapabilitiesArrayContents();
    DeleteSupportedIntentsArrayContents();

    // Free the critical section.
    DeleteCriticalSection(&m_csShutdown);
    if(m_pIWiaLog)
        m_pIWiaLog->Release();

    if(m_pScanAPI){
        // disable fake scanner device
        m_pScanAPI->FakeScanner_DisableDevice();
        delete m_pScanAPI;
    }
}

/**************************************************************************\
* CWIAScannerDevice::GetCapabilities
*
*   Get the device STI capabilities.
*
* Arguments:
*
*   pUsdCaps    - Pointer to USD capabilities data.
*
* Return Value:
*
*    Status.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::GetCapabilities(PSTI_USD_CAPS pUsdCaps)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::GetCapabilities");
    memset(pUsdCaps, 0, sizeof(STI_USD_CAPS));
    pUsdCaps->dwVersion     = STI_VERSION;
    pUsdCaps->dwGenericCaps = STI_USD_GENCAP_NATIVE_PUSHSUPPORT|
                              STI_GENCAP_NOTIFICATIONS |
                              STI_GENCAP_POLLING_NEEDED;
    return STI_OK;
}

/**************************************************************************\
* CWIAScannerDevice::GetStatus
*
*   Query device online and/or event status.
*
* Arguments:
*
*   pDevStatus  - Pointer to device status data.
*
* Return Value:
*
*    Status.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::GetStatus(PSTI_DEVICE_STATUS pDevStatus)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::GetStatus");
    HRESULT hr = S_OK;

    // Validate parameters.
    if (!pDevStatus) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CWIAScannerDevice::GetStatus, NULL parameter"));
        return E_INVALIDARG;
    }

    // If we are asked, verify the device is online.
    if (pDevStatus->StatusMask & STI_DEVSTATUS_ONLINE_STATE)  {
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("GetStatus, WIA is asking the device if we are ONLINE"));
        pDevStatus->dwOnlineState = 0L;
        hr = m_pScanAPI->FakeScanner_DeviceOnline();
        if(SUCCEEDED(hr)){
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("GetStatus, Device is ONLINE"));
            pDevStatus->dwOnlineState |= STI_ONLINESTATE_OPERATIONAL;
        } else {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("GetStatus, Device is OFFLINE"));
        }
    }

    // If we are asked, verify state of event.
    pDevStatus->dwEventHandlingState &= ~STI_EVENTHANDLING_PENDING;
    if (pDevStatus->StatusMask & STI_DEVSTATUS_EVENTS_STATE) {

        // Generate an event the first time we load.
        if (m_bUsdLoadEvent) {
            pDevStatus->dwEventHandlingState = STI_EVENTHANDLING_PENDING;
            m_guidLastEvent                  = guidEventFirstLoaded;
            m_bUsdLoadEvent                  = FALSE;
        }

        // check for device events
        LONG lButtonIndex = ID_FAKE_NOEVENT;
        hr = m_pScanAPI->FakeScanner_GetDeviceEvent(&lButtonIndex);
        if(SUCCEEDED(hr)){
            switch(lButtonIndex){
            case ID_FAKE_SCANBUTTON:
                m_guidLastEvent = WIA_EVENT_SCAN_IMAGE;
                WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("GetStatus, Scan Button Pressed!"));
                break;
            case ID_FAKE_COPYBUTTON:
                m_guidLastEvent = WIA_EVENT_SCAN_PRINT_IMAGE;
                WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("GetStatus, Copy Button Pressed!"));
                break;
            case ID_FAKE_FAXBUTTON:
                m_guidLastEvent = WIA_EVENT_SCAN_FAX_IMAGE;
                WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("GetStatus, Fax Button Pressed!"));
                break;
            default:
                m_guidLastEvent = GUID_NULL;
                break;
            }

            if(m_guidLastEvent != GUID_NULL){
                pDevStatus->dwEventHandlingState |= STI_EVENTHANDLING_PENDING;
            }
        }
    }
    return STI_OK;
}

/**************************************************************************\
* CWIAScannerDevice::DeviceReset
*
*   Reset device.
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::DeviceReset(void)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::DeviceReset");

    return m_pScanAPI->FakeScanner_ResetDevice();
}

/**************************************************************************\
* CWIAScannerDevice::Diagnostic
*
*   The test device always passes the diagnostic.
*
* Arguments:
*
*    pBuffer    - Pointer o diagnostic result data.
*
* Return Value:
*
*    None
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::Diagnostic(LPSTI_DIAG pBuffer)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::Diagnostic");

    // Initialize response buffer
    memset(&pBuffer->sErrorInfo,0,sizeof(pBuffer->sErrorInfo));
    pBuffer->dwStatusMask = 0;
    pBuffer->sErrorInfo.dwGenericError  = NOERROR;
    pBuffer->sErrorInfo.dwVendorError   = 0;

    return m_pScanAPI->FakeScanner_Diagnostic();
}

/**************************************************************************\
* CWIAScannerDevice::SetNotificationHandle
*
*   Starts and stops the event notification thread.
*
* Arguments:
*
*    hEvent -   If not valid start the notification thread otherwise kill
*               the notification thread.
*
* Return Value:
*
*    Status.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::SetNotificationHandle(HANDLE hEvent)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::SetNotificationHandle");
    HRESULT hr = STI_OK;

    EnterCriticalSection(&m_csShutdown);

    // Are we starting or stopping the notification thread?
    if (hEvent && (hEvent != INVALID_HANDLE_VALUE)) {
        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetNotificationHandle, hEvent   = %d",hEvent));
        m_hSignalEvent  = hEvent;
        m_guidLastEvent = GUID_NULL;

        if (NULL == m_hEventNotifyThread) {
            DWORD dwThread = 0;
            m_hEventNotifyThread = ::CreateThread(NULL,
                                                  0,
                                                  (LPTHREAD_START_ROUTINE)EventThread,
                                                  (LPVOID)this,
                                                  0,
                                                  &dwThread);
            if (!m_hEventNotifyThread) {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("FlatbedScannerUsdDevice::SetNotificationHandle, CreateThread failed"));
                hr = STIERR_UNSUPPORTED;
            }
        }
    } else {
        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetNotificationHandle, Disabling event Notifications"));
        // Disable event notifications.
        if (m_hShutdownEvent && (m_hShutdownEvent != INVALID_HANDLE_VALUE)) {
            if (!SetEvent(m_hShutdownEvent)) {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetNotificationHandle, Setting Shutdown event failed.."));
            } else {

                if (NULL != m_hEventNotifyThread) {

                    //
                    // WAIT for thread to terminate, if one exists
                    //

                    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("SetNotificationHandle, Waiting for Event Thread to terminate (%d ms timeout)",THREAD_TERMINATION_TIMEOUT));
                    DWORD dwResult = WaitForSingleObject(m_hEventNotifyThread,THREAD_TERMINATION_TIMEOUT);
                    switch (dwResult) {
                    case WAIT_TIMEOUT:
                        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("SetNotificationHandle, Event Thread termination TIMED OUT!"));
                        break;
                    case WAIT_OBJECT_0:
                        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("SetNotificationHandle, We are signaled...YAY!"));
                        break;
                    case WAIT_ABANDONED:
                        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("SetNotificationHandle, Event Thread was abandoned.."));
                        break;
                    case WAIT_FAILED:
                        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("SetNotificationHandle, Event Thread returned a failure..."));
                        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("SetNotificationHandle, GetLastError() Code = %d",::GetLastError()));
                        break;
                    default:
                        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetNotificationHandle, Unknown signal (%d) received from WaitForSingleObject() call",dwResult));
                        break;
                    }
                }

                //
                // Close event for syncronization of notifications shutdown.
                //

                WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("SetNotificationHandle, Closing m_hShutdownEvent handle (it has been signaled)"));
                CloseHandle(m_hShutdownEvent);
                m_hShutdownEvent = NULL;
            }
        }

        //
        // terminate thread
        //

        if (NULL != m_hEventNotifyThread) {
            WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetNotificationHandle, closing event Notifications thread handle"));
            CloseHandle(m_hEventNotifyThread);
            m_hEventNotifyThread = NULL;
        }

        m_guidLastEvent      = GUID_NULL;
    }

    LeaveCriticalSection(&m_csShutdown);
    return hr;
}

/**************************************************************************\
* CWIAScannerDevice::GetNotificationData
*
*   Provides data on an event.
*
* Arguments:
*
*    pBuffer    - Pointer to event data.
*
* Return Value:
*
*    Status.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::GetNotificationData( LPSTINOTIFY pBuffer )
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::GetNotificationData");
    // If we have notification ready - return it's guid
    if (!IsEqualIID(m_guidLastEvent, GUID_NULL)) {
        memset(&pBuffer->abNotificationData,0,sizeof(pBuffer->abNotificationData));
        pBuffer->dwSize               = sizeof(STINOTIFY);
        pBuffer->guidNotificationCode = m_guidLastEvent;
        m_guidLastEvent               = GUID_NULL;
    } else {
        return STIERR_NOEVENTS;
    }
    return STI_OK;
}

/**************************************************************************\
* CWIAScannerDevice::Escape
*
*   Issue a command to the device.
*
* Arguments:
*
*    EscapeFunction - Command to be issued.
*    pInData        - Input data to be passed with command.
*    cbInDataSize   - Size of input data.
*    pOutData       - Output data to be passed back from command.
*    cbOutDataSize  - Size of output data buffer.
*    pcbActualData  - Size of output data actually written.
*
* Return Value:
*
*    None
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::Escape(
    STI_RAW_CONTROL_CODE    EscapeFunction,
    LPVOID                  pInData,
    DWORD                   cbInDataSize,
    LPVOID                  pOutData,
    DWORD                   cbOutDataSize,
    LPDWORD                 pcbActualData)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::Escape");

    // Write command to device if needed.
    return STIERR_UNSUPPORTED;
}

/**************************************************************************\
* CWIAScannerDevice::GetLastError
*
*   Get the last error from the device.
*
* Arguments:
*
*    pdwLastDeviceError - Pointer to last error data.
*
* Return Value:
*
*    Status.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::GetLastError(LPDWORD pdwLastDeviceError)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::GetLastError");

    if (IsBadWritePtr(pdwLastDeviceError, sizeof(DWORD))) {
        return STIERR_INVALID_PARAM;
    }

    *pdwLastDeviceError = m_dwLastOperationError;
    return STI_OK;
}

/**************************************************************************\
* CWIAScannerDevice::GetLastErrorInfo
*
*   Get extended error information from the device.
*
* Arguments:
*
*    pLastErrorInfo - Pointer to extended device error data.
*
* Return Value:
*
*    Status.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::GetLastErrorInfo(STI_ERROR_INFO *pLastErrorInfo)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::GetLastErrorInfo");

    if (IsBadWritePtr(pLastErrorInfo, sizeof(STI_ERROR_INFO))) {
        return STIERR_INVALID_PARAM;
    }

    pLastErrorInfo->dwGenericError          = m_dwLastOperationError;
    pLastErrorInfo->szExtendedErrorText[0]  = '\0';

    return STI_OK;
}

/**************************************************************************\
* CWIAScannerDevice::LockDevice
*
*   Lock access to the device.
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::LockDevice(void)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::LockDevice");
    HRESULT hr = STI_OK;
    if(m_bDeviceLocked)
        hr = STIERR_DEVICE_LOCKED;
    else {
        m_bDeviceLocked = TRUE;
    }
    return hr;
}

/**************************************************************************\
* CWIAScannerDevice::UnLockDevice
*
*   Unlock access to the device.
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::UnLockDevice(void)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::UnLockDevice");
    HRESULT hr = STI_OK;
    if(!m_bDeviceLocked)
        hr = STIERR_NEEDS_LOCK;
    else {
        m_bDeviceLocked = FALSE;
    }
    return hr;
}

/**************************************************************************\
* CWIAScannerDevice::RawReadData
*
*   Read raw data from the device.
*
* Arguments:
*
*    lpBuffer           - buffer for returned data
*    lpdwNumberOfBytes  - number of bytes to read/returned
*    lpOverlapped       - overlap
*
* Return Value:
*
*    Status.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::RawReadData(
    LPVOID          lpBuffer,
    LPDWORD         lpdwNumberOfBytes,
    LPOVERLAPPED    lpOverlapped)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::RawReadData");
    HRESULT hr = STI_OK;
    BOOL    fRet = FALSE;
    DWORD   dwBytesReturned = 0;

    if (INVALID_HANDLE_VALUE != m_DeviceDefaultDataHandle) {
        fRet = ReadFile( m_DeviceDefaultDataHandle,
                         lpBuffer,
                         *lpdwNumberOfBytes,
                         &dwBytesReturned,
                         lpOverlapped );

        m_dwLastOperationError = ::GetLastError();
        hr = fRet ? STI_OK : HRESULT_FROM_WIN32(m_dwLastOperationError);

        *lpdwNumberOfBytes = (fRet) ? dwBytesReturned : 0;
    } else {
        hr = STIERR_NOT_INITIALIZED;
    }
    return hr;
}

/**************************************************************************\
* CWIAScannerDevice::RawWriteData
*
*   Write raw data to the device.
*
* Arguments:
*
*    lpBuffer           - buffer for returned data
*    dwNumberOfBytes    - number of bytes to write
*    lpOverlapped       - overlap
*
* Return Value:
*
*    Status.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::RawWriteData(
    LPVOID          lpBuffer,
    DWORD           dwNumberOfBytes,
    LPOVERLAPPED    lpOverlapped)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::RawWriteData");
    HRESULT hr   = STI_OK;
    BOOL    fRet = FALSE;
    DWORD   dwBytesReturned = 0;

    if (INVALID_HANDLE_VALUE != m_DeviceDefaultDataHandle) {
        fRet = WriteFile(m_DeviceDefaultDataHandle,lpBuffer,dwNumberOfBytes,&dwBytesReturned,lpOverlapped);
        m_dwLastOperationError = ::GetLastError();
        hr = fRet ? STI_OK : HRESULT_FROM_WIN32(m_dwLastOperationError);
    } else {
        hr = STIERR_NOT_INITIALIZED;
    }
    return STI_OK;
}

/**************************************************************************\
* CWIAScannerDevice::RawReadCommand
*
*
*
* Arguments:
*
*    lpBuffer           - buffer for returned data
*    lpdwNumberOfBytes  - number of bytes to read/returned
*    lpOverlapped       - overlap
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::RawReadCommand(
    LPVOID          lpBuffer,
    LPDWORD         lpdwNumberOfBytes,
    LPOVERLAPPED    lpOverlapped)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::RawReadCommand");
    return STIERR_UNSUPPORTED;
}

/**************************************************************************\
* CWIAScannerDevice::RawWriteCommand
*
*
*
* Arguments:
*
*    lpBuffer           - buffer for returned data
*    nNumberOfBytes     - number of bytes to write
*    lpOverlapped       - overlap
*
* Return Value:
*
*    Status.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::RawWriteCommand(
    LPVOID          lpBuffer,
    DWORD           nNumberOfBytes,
    LPOVERLAPPED    lpOverlapped)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::RawWriteCommand");
    return STIERR_UNSUPPORTED;
}

/**************************************************************************\
* CWIAScannerDevice::Initialize
*
*   Initialize the device object.
*
* Arguments:
*
*    pIStiDevControlNone    - device interface
*    dwStiVersion           - STI version
*    hParametersKey         - HKEY for registry reading/writing
*
* Return Value:
*
*    Status.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::Initialize(
    PSTIDEVICECONTROL   pIStiDevControl,
    DWORD               dwStiVersion,
    HKEY                hParametersKey)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::Initialize");

    HRESULT hr = STI_OK;
    WCHAR szDeviceNameW[255];
    UINT uiNameLen = 0;

    if (!pIStiDevControl) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CWIAScannerDevice::Initialize, invalid device control interface"));
        return STIERR_INVALID_PARAM;
    }

    // Cache the device control interface.
    m_pIStiDevControl = pIStiDevControl;
    m_pIStiDevControl->AddRef();

    //
    // Get the name of the device port
    //

    hr = m_pIStiDevControl->GetMyDevicePortName(szDeviceNameW,sizeof(szDeviceNameW)/sizeof(WCHAR));
    if (!SUCCEEDED(hr) || !*szDeviceNameW) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CWIAScannerDevice::Initialize, couldn't get device port"));
        return hr;
    }

    uiNameLen = WideCharToMultiByte(CP_ACP, 0, szDeviceNameW, -1, NULL, NULL, 0, 0);
    if (!uiNameLen) {
        return STIERR_INVALID_PARAM;
    }

    m_pszDeviceNameA = new CHAR[uiNameLen+1];
    if (!m_pszDeviceNameA) {
        return STIERR_INVALID_PARAM;
    }

    WideCharToMultiByte(CP_ACP, 0, szDeviceNameW, -1, m_pszDeviceNameA, uiNameLen, 0, 0);

    //
    // Uncomment the comment block below to have the driver create the kernel mode file
    // handles.
    //

    /*

    //
    // Open kernel mode device driver.
    //

    m_DeviceDefaultDataHandle = CreateFileA(m_pszDeviceNameA,
                                     GENERIC_READ | GENERIC_WRITE, // Access mask
                                     0,                            // Share mode
                                     NULL,                         // SA
                                     OPEN_EXISTING,                // Create disposition
                                     FILE_ATTRIBUTE_SYSTEM,        // Attributes
                                     NULL );

    m_dwLastOperationError = ::GetLastError();

    hr = (m_DeviceDefaultDataHandle != INVALID_HANDLE_VALUE) ?
                S_OK : MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,m_dwLastOperationError);

    if (FAILED(hr)) {
        return hr;
    }

    */

    //
    // Load BITMAP file, (used only as sample scanned data by sample scanner driver)
    //

    if (SUCCEEDED(hr)) {
        hr = CreateInstance(&m_pScanAPI,SCROLLFED_SCANNER_MODE);
        if (m_pScanAPI) {
            hr = m_pScanAPI->FakeScanner_Initialize();
        } else {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("Initialize, Could not create FakeScanner API object"));
            hr = E_OUTOFMEMORY;
            WIAS_LHRESULT(m_pIWiaLog, hr);
        }
    }


    //
    // Open DeviceData section to read driver specific information
    //

    HKEY hKey = hParametersKey;
    HKEY hOpenKey = NULL;
    if (RegOpenKeyEx(hKey,                     // handle to open key
                     TEXT("DeviceData"),       // address of name of subkey to open
                     0,                        // options (must be NULL)
                     KEY_QUERY_VALUE|KEY_READ, // just want to QUERY a value
                     &hOpenKey                 // address of handle to open key
                    ) == ERROR_SUCCESS) {



        //
        // This is where you read registry entries for your device.
        // The DeviceData section is the proper place to put this information
        //


        //
        // close registry key when finished
        //

        RegCloseKey(hOpenKey);
    } else {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CWIAScannerDevice::Initialize, couldn't open DeviceData KEY"));
        return E_FAIL;
    }
    return hr;
}

/**************************************************************************\
* CWIAScannerDevice::DoEventProcessing
*
*   Process device events
*
* Arguments:
*
*
* Return Value:
*
*    Status.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::DoEventProcessing()
{
    HRESULT hr = S_OK;

    OVERLAPPED Overlapped;
    ZeroMemory( &Overlapped, sizeof( Overlapped ));

    //
    // create an Event for the device to signal
    //

    Overlapped.hEvent = CreateEvent( NULL, TRUE, FALSE, NULL );

    BYTE    InterruptData   = 0;
    DWORD   dwIndex         = 0;
    DWORD   dwError         = 0;
    LONG    lButtonIndex    = ID_FAKE_NOEVENT;

    //
    // initialize the Event handle array for WaitForMultipleObjects() call
    //

    HANDLE  hEventArray[2] = {m_hShutdownEvent, Overlapped.hEvent};

    //
    // Initialize thread control variables
    //

    BOOL    fLooping = TRUE;
    BOOL    bRet     = TRUE;

    while (fLooping) {

#ifdef _USE_REAL_DEVICE_FOR_EVENTS

        //
        // use the following call for interrupt events on your device
        //

        bRet = DeviceIoControl( m_DeviceDefaultDataHandle,
                                IOCTL_WAIT_ON_DEVICE_EVENT,
                                NULL,
                                0,
                                &InterruptData,
                                sizeof(InterruptData),
                                &dwError,
                                &Overlapped );

#else

        //
        // This for the FakeScanner API calls
        //

        bRet = TRUE;
        m_pScanAPI->FakeScanner_SetInterruptEventHandle(Overlapped.hEvent);

#endif
        if ( bRet || ( !bRet && ( ::GetLastError() == ERROR_IO_PENDING ))) {

            //
            // wait for event to happen from device, or a Shutdown event from the WIA service
            //

            dwIndex = WaitForMultipleObjects( 2, hEventArray,FALSE, INFINITE );

            //
            // determine how to handle event from device here
            //

            switch ( dwIndex ) {
            case WAIT_OBJECT_0+1:   // EVENT FROM THE DEVICE

#ifdef _USE_REAL_DEVICE_FOR_EVENTS

                DWORD dwBytesRet = 0;

                //
                // use the following call for interrupt events on your device
                //

                bRet = GetOverlappedResult( m_DeviceDefaultDataHandle, &Overlapped, &dwBytesRet, FALSE );
#else
                //
                // Fake Scanner API
                //

                //
                // check for device event information
                //

                lButtonIndex = ID_FAKE_NOEVENT;
                hr = m_pScanAPI->FakeScanner_GetDeviceEvent(&lButtonIndex);
                if (SUCCEEDED(hr)) {
                    switch (lButtonIndex) {
                    case ID_FAKE_SCANBUTTON:
                        m_guidLastEvent = WIA_EVENT_SCAN_IMAGE;
                        break;
                    case ID_FAKE_COPYBUTTON:
                        m_guidLastEvent = WIA_EVENT_SCAN_PRINT_IMAGE;
                        break;
                    case ID_FAKE_FAXBUTTON:
                        m_guidLastEvent = WIA_EVENT_SCAN_FAX_IMAGE;
                        break;
                    default:
                        m_guidLastEvent = GUID_NULL;
                        break;
                    }

                    if (m_guidLastEvent != GUID_NULL) {
                        SetEvent(m_hSignalEvent);
                    }
                }

#endif

                //
                // manually reset device event, after it has been signaled
                //

                ResetEvent( Overlapped.hEvent );
                break;
            case WAIT_OBJECT_0:     // SHUTDOWN EVENT
            default:
                fLooping = FALSE;   // for loop to stop
            }
        } else {
            dwError = ::GetLastError();
            break;
        }
    } // end while (fLooping)

    return hr;
}

////////////////////////////////////////////////////////////////////////////////////////
// THREADS SECTION                                                                    //
////////////////////////////////////////////////////////////////////////////////////////

VOID EventThread( LPVOID  lpParameter )
{
    PWIASCANNERDEVICE pThisDevice = (PWIASCANNERDEVICE)lpParameter;
    pThisDevice->DoEventProcessing();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\wiascroll\pch.h ===
#ifndef _PCH_H
#define _PCH_H

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <stdio.h>
#include <tchar.h>
#include <objbase.h>
#include <sti.h>
#include <assert.h>
#include <windows.h>
#include <stierr.h>

#define INITGUID
#include "initguid.h"
#include <stiusd.h>

#pragma intrinsic(memcmp,memset)

#include "resource.h"
#include "wiamindr.h"
#include "wiaprop.h"
#include "fscanapi.h"
#include "wiascroll.h"

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\wiascroll\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wiascroll.rc
//

// Device Events, and Commands (Name strings)
#define IDS_CMD_BUILD_DEVICE_TREE_NAME     100
#define IDS_CMD_SYNCRONIZE_NAME            101
#define IDS_EVENT_DEVICE_CONNECTED_NAME    102
#define IDS_EVENT_DEVICE_DISCONNECTED_NAME 103
#define IDS_EVENT_SCANBUTTON_NAME          104
#define IDS_EVENT_COPYBUTTON_NAME          105
#define IDS_EVENT_FAXBUTTON_NAME           106

// Device Events, and Commands (Description strings)
#define IDS_CMD_BUILD_DEVICE_TREE_DESC     200
#define IDS_CMD_SYNCRONIZE_DESC            201
#define IDS_EVENT_DEVICE_CONNECTED_DESC    202
#define IDS_EVENT_DEVICE_DISCONNECTED_DESC 203
#define IDS_EVENT_SCANBUTTON_DESC          204
#define IDS_EVENT_COPYBUTTON_DESC          205
#define IDS_EVENT_FAXBUTTON_DESC           206

#define IDS_ROOTITEM_NAME                  300
#define IDS_TOPITEM_NAME                   301

#define IDC_STATIC                      -1

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        700
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           700
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\wiascroll\iwiaminidrv.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       IWiaMiniDrv.cpp
*
*  VERSION:     1.0
*
*  DATE:        18 July, 2000
*
*  DESCRIPTION:
*   Implementation of the WIA sample scanner IWiaMiniDrv methods.
*
*******************************************************************************/

#include "pch.h"
extern HINSTANCE g_hInst;           // used for WIAS_LOGPROC macro

#define EST_PAGE_LENGTH_INCHES      17 // 17 inches
/**************************************************************************\
* CWIAScannerDevice::drvDeleteItem
*
*   This helper is called to delete a device item.
*   Note: Device items for this device may not be modified.
*         Return access denied.
*
* Arguments:
*
*   pWiasContext  - Indicates the item to delete.
*   lFlags        - Operation flags, unused.
*   plDevErrVal   - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*     7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvDeleteItem(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    LONG                        *plDevErrVal)
{
    *plDevErrVal = 0;
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvDeleteItem");
    return STG_E_ACCESSDENIED;
}

/**************************************************************************\
* SendImageHeader
*
*   This helper is called to send the bitmap header info to the callback
*   routine.
*   Note: This is a helper function used in TYMED_CALLBACK transfers.
*
* Arguments:
*
*   pmdtc   -   a pointer to a transfer context.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT CWIAScannerDevice::SendImageHeader(
    PMINIDRV_TRANSFER_CONTEXT   pmdtc)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::SendImageHeader");

    HRESULT hr = S_OK;

    if(pmdtc->guidFormatID == WiaImgFmt_BMP){
        BITMAPINFO UNALIGNED *pbmi = (LPBITMAPINFO)pmdtc->pTransferBuffer;
        UNALIGNED BITMAPINFOHEADER *pbmih = &pbmi->bmiHeader;
        pbmih->biHeight = -pbmih->biHeight;
    }

    //
    //  Send to class driver.  WIA Class driver will pass
    //  data through to client.
    //

    hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(IT_MSG_DATA,
                                                     IT_STATUS_TRANSFER_TO_CLIENT,
                                                     0,
                                                     0,
                                                     pmdtc->lHeaderSize,
                                                     pmdtc,
                                                     0);

    if (hr == S_OK) {

        //
        //  If the transfer was successfull, advance offset for
        //  destination copy by the size of the data just sent.
        //

        pmdtc->cbOffset += pmdtc->lHeaderSize;
    }
    return hr;
}

/**************************************************************************\
* SendFilePreviewBitmapHeader
*
*   This helper is called to send the bitmap header info to the callback
*   routine.
*   Note: This is a helper function used in TYMED_FILE transfers with
*         (out of band data) enabled.
*
* Arguments:
*
*   pmdtc   -   a pointer to a transfer context.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT CWIAScannerDevice::SendFilePreviewImageHeader(
    PMINIDRV_TRANSFER_CONTEXT   pmdtc)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::SendImageHeader");

    HRESULT hr = S_OK;

    WIAS_DOWN_SAMPLE_INFO DownSampleInfo;
    memset(&DownSampleInfo,0,sizeof(DownSampleInfo));

    DownSampleInfo.ulBitsPerPixel       = pmdtc->lDepth;
    DownSampleInfo.ulOriginalWidth      = pmdtc->lWidthInPixels;
    DownSampleInfo.ulOriginalHeight     = pmdtc->lLines;
    DownSampleInfo.ulDownSampledHeight  = 0;
    DownSampleInfo.ulDownSampledWidth   = 0;
    DownSampleInfo.ulXRes               = pmdtc->lXRes;
    DownSampleInfo.ulYRes               = pmdtc->lYRes;

    hr = wiasDownSampleBuffer(0x1/*WIAS_GET_DOWNSAMPLED_SIZE_ONLY*/,
                              &DownSampleInfo);
    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SendFilePreviewBitmapHeader, wiasDownSampleBuffer Failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
    } else {

        //
        // acquire BITMAPHEADER pointer from pmdtc
        //

        pmdtc->pBaseBuffer          = pmdtc->pTransferBuffer + sizeof(BITMAPFILEHEADER);
        BITMAPINFO UNALIGNED *pbmi = (LPBITMAPINFO)pmdtc->pBaseBuffer;
        UNALIGNED BITMAPINFOHEADER *pbmih = &pbmi->bmiHeader;

        //
        // adjust width and height
        //

        pbmih->biHeight    = 0;                                 // set height to zero (0)
        pbmih->biWidth     = DownSampleInfo.ulDownSampledWidth; // set down sampled width

        //
        //  Send to class driver.  WIA Class driver will pass
        //  data through to client.
        //

        hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(IT_MSG_FILE_PREVIEW_DATA,
                                                          IT_STATUS_TRANSFER_TO_CLIENT,
                                                          0,
                                                          0,
                                                          pmdtc->lHeaderSize - sizeof(BITMAPFILEHEADER),
                                                          pmdtc,
                                                          0);
    }

    return hr;
}

/**************************************************************************\
* ScanItem
*
*   This helper is called to do a FILE transfer.
*   Note: This routine must fill the complete buffer, and return percent
*         complete status back to the client if a callback routine is
*         provided.
*
* Arguments:
*
*   pItemContext        - private item data
*   pMiniTranCtx        - minidriver supplied transfer info
*   plDevErrVal         - device error value
*
* Return Value:
*
*    Status
*
* History:
*
*     7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::ScanItem(
    PMINIDRIVERITEMCONTEXT  pItemContext,
    PMINIDRV_TRANSFER_CONTEXT   pmdtc,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::ScanItem");
    HRESULT hr = S_OK;

    LONG  lScanPhase   = SCAN_START;
    DWORD cbWritten    = 0;
    LONG  cbSize       = 0;
    PBYTE pBuf         = pmdtc->pTransferBuffer + pmdtc->lHeaderSize;
    LONG  lItemSize    = pmdtc->lHeaderSize;
    BYTE *pImageHeader = NULL;

    LONG  cbEstimatedPageSize = (pItemContext->lBytesPerScanLine * (pmdtc->lYRes * EST_PAGE_LENGTH_INCHES));

    //
    // data operation variables
    //

    BOOL  bSwapBGRData       = TRUE;
    BOOL  bDWORDAlign        = TRUE;
    BOOL  bVerticalFlip      = FALSE;
    LONG  lTotalLinesWritten = 0;
    ULONG ulDestDataOffset   = 0;

    pImageHeader = (BYTE*)LocalAlloc(LPTR,pmdtc->lHeaderSize);
    if (pImageHeader) {

        //
        // save image header, so we can update it later with correct number of lines..and size
        //

        memcpy(pImageHeader,pmdtc->pTransferBuffer,pmdtc->lHeaderSize);
    } else {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ScanItem, Could not allocate memory for FILE HEADER"));
        return E_OUTOFMEMORY;
    }

    //
    // send down sample header for out of band data
    //

    WIAS_DOWN_SAMPLE_INFO DownSampleInfo;
    memset(&DownSampleInfo,0,sizeof(DownSampleInfo));

    hr = SendFilePreviewImageHeader(pmdtc);
    if(hr == S_OK){

        //
        // move offset past file header
        //

        ulDestDataOffset += (pmdtc->lHeaderSize - sizeof(BITMAPFILEHEADER));
    } else {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ScanItem, SendFilePreviewImageHeader Failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // scan until buffer runs out or scanner completes transfer
    //

    while ((lScanPhase == SCAN_START) || (cbWritten)) {

        //
        // Limit requests to max buffer size or less.
        //

        cbSize = m_MaxBufferSize;

        //
        // Request size to scanner must be modula the raw bytes per scan row.
        // Enough space for the alignment padding must be reserved.
        // These are requirements for AlignInPlace
        //

        cbSize = (cbSize / pItemContext->lBytesPerScanLine) * pItemContext->lBytesPerScanLineRaw;

        //
        //  Device specific call to get data from the scanner and put it into
        //  a buffer.  lScanPhase indicates whether this is the first call to Scan,
        //  pBuf is a pointer to the buffer, cbSize is the amount of data
        //  requested from the scanner, and cbWritten will be set to the actual
        //  amount of data returned by the scanner.
        //

        hr = m_pScanAPI->FakeScanner_Scan(lScanPhase, pBuf, cbSize, &cbWritten);

        //
        // set flag to SCAN_CONTINUE, for other calls
        //

        lScanPhase = SCAN_CONTINUE;

        if (hr == S_OK) {
            if (cbWritten) {

                //
                // keep track of how many lines were written
                //

                lTotalLinesWritten += (cbWritten / pItemContext->lBytesPerScanLine);

                //
                // Place the scan data in correct byte order for 3 bytes ber pixel data.
                //

                if  ((pmdtc->lDepth       == 24) &&
                    ((pmdtc->guidFormatID == WiaImgFmt_BMP) ||
                    ((pmdtc->guidFormatID == WiaImgFmt_MEMORYBMP)))) {

                    if (bSwapBGRData) {
                        SwapBuffer24(pBuf, cbWritten);
                    }
                }

                if (((pmdtc->guidFormatID == WiaImgFmt_BMP) ||
                    ((pmdtc->guidFormatID == WiaImgFmt_MEMORYBMP)))) {

                    //
                    // Align the data on DWORD boundries.
                    //

                    if (bDWORDAlign) {
                        cbWritten = AlignInPlace(pBuf,
                                                 cbWritten,
                                                 pItemContext->lBytesPerScanLine,
                                                 pItemContext->lBytesPerScanLineRaw);
                    }
                }

                //
                // update lItemSize
                //

                if(lItemSize > 0){

                    //
                    // we have a header size already calculated in lItemSize,
                    // so add cbWritten to current size.
                    //

                    lItemSize += cbWritten;
                } else {

                    //
                    // this is pure data, no header
                    //

                    lItemSize = cbWritten;
                }

                //
                // decrease estimated page size, for (estimated percent complete calculation)
                //

                cbEstimatedPageSize -= lItemSize;

                //
                // avoid division by zero, by setting cbEstimatedPageSize to 1
                //

                if(cbEstimatedPageSize < 0){
                    cbEstimatedPageSize = 1;
                }

                //
                // If a status callback was specified callback the class driver.
                //

                if (pmdtc->pIWiaMiniDrvCallBack) {

                    FLOAT FractionComplete = 0.0f;
                    LONG  PercentComplete  = 0;

                    FractionComplete = (FLOAT)(lTotalLinesWritten * pItemContext->lBytesPerScanLineRaw) / (FLOAT)cbEstimatedPageSize;
                    if (FractionComplete > 0.9f) {
                        FractionComplete = 0.9f; // hold at 90% complete...until done
                    }

                    //
                    // calculate percent complete
                    //

                    PercentComplete = (LONG)(100 * FractionComplete);

                    //
                    // call back client with status on the transfer
                    //

                    hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(IT_MSG_STATUS,
                                                                      IT_STATUS_TRANSFER_TO_CLIENT,
                                                                      PercentComplete,
                                                                      0,
                                                                      0,
                                                                      NULL,
                                                                      0);
                    //
                    // check for user cancel (from IT_MSG_STATUS callback)
                    //

                    if (hr == S_FALSE) {

                        WIAS_LTRACE(m_pIWiaLog,
                                    WIALOG_NO_RESOURCE_ID,
                                    WIALOG_LEVEL4,
                                    ("ScanItem, Transfer canceled by client (IT_MSG_STATUS callback)"));
                        break;

                    } else if (FAILED(hr)) {

                        //
                        // transfer failed
                        //

                        WIAS_LERROR(m_pIWiaLog,
                                    WIALOG_NO_RESOURCE_ID,
                                    ("ScanItem, MiniDrvCallback failed (IT_MSG_STATUS callback)"));
                        WIAS_LHRESULT(m_pIWiaLog, hr);
                        break;
                    }

                    //
                    // call back client with status on out of band data transfer
                    //

                    DownSampleInfo.pDestBuffer          = NULL;
                    DownSampleInfo.pSrcBuffer           = pBuf;
                    DownSampleInfo.ulActualSize         = 0;
                    DownSampleInfo.ulBitsPerPixel       = pmdtc->lDepth;
                    DownSampleInfo.ulDestBufSize        = 0;
                    DownSampleInfo.ulDownSampledHeight  = 0;
                    DownSampleInfo.ulDownSampledWidth   = 0;
                    DownSampleInfo.ulOriginalHeight     = (cbWritten / pItemContext->lBytesPerScanLine);
                    DownSampleInfo.ulOriginalWidth      = pmdtc->lWidthInPixels;
                    DownSampleInfo.ulSrcBufSize         = cbWritten;
                    DownSampleInfo.ulXRes               = pmdtc->lXRes;
                    DownSampleInfo.ulYRes               = pmdtc->lYRes;

                    //
                    // down sample data
                    //

                    hr = wiasDownSampleBuffer(0, &DownSampleInfo);
                    if(FAILED(hr)){
                        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ScanItem, wiasDownSampleBuffer Failed"));
                        WIAS_LHRESULT(m_pIWiaLog, hr);
                    } else {

                        pmdtc->pBaseBuffer = DownSampleInfo.pDestBuffer;

                        //
                        // call back client with down sampled buffer
                        //

                        hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(IT_MSG_FILE_PREVIEW_DATA,
                                                                          IT_STATUS_TRANSFER_TO_CLIENT,
                                                                          PercentComplete,
                                                                          ulDestDataOffset,
                                                                          DownSampleInfo.ulActualSize,
                                                                          pmdtc,
                                                                          0);
                        //
                        // update offset
                        //

                        ulDestDataOffset += DownSampleInfo.ulActualSize;
                    }

                    //
                    // check for user cancel (from IT_MSG_FILE_PREVIEW_DATA callback)
                    //

                    if (hr == S_FALSE) {

                        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL4,
                                    ("ScanItem, Transfer canceled by client (IT_MSG_FILE_PREVIEW_DATA callback)"));
                        break;

                    } else if (FAILED(hr)) {

                        //
                        // transfer failed
                        //

                        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,
                                    ("ScanItem, MiniDrvCallback failed (IT_MSG_FILE_PREVIEW_DATA callback)"));
                        WIAS_LHRESULT(m_pIWiaLog, hr);
                        break;
                    }
                }

                //
                //  If the mini driver allocated a buffer, we need to write the
                //  buffer to the open file handle (opened by class driver).
                //

                if (!pmdtc->bClassDrvAllocBuf) {

                    //
                    //  Now that we know the true item size, update the mini driver
                    //  context.
                    //

                    pmdtc->lItemSize   = lItemSize;
                    pmdtc->lBufferSize = lItemSize;

                    //
                    // reset lItemSize
                    //

                    lItemSize = 0;

                    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("ScanItem, Final lItemSize = %d bytes",lItemSize));

                    //
                    // write image data to disk (note: The first call of this will write the file header too!)
                    //

                    hr = wiasWritePageBufToFile(pmdtc);
                    if (FAILED(hr)) {
                        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ScanItem, WritePageBufToFile failed"));
                        WIAS_LHRESULT(m_pIWiaLog, hr);
                    }

                    //
                    // set pBuf to proper location
                    //

                    pBuf = pmdtc->pTransferBuffer;
                }

            }

        } else {

            //
            //  Get the device error
            //

            *plDevErrVal = (LONG) hr;
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ScanItem, data transfer failed, status: 0x%X", hr));
            break;
        }
    }

    if (hr == S_OK) {
        if (pmdtc->guidFormatID == WiaImgFmt_BMP) {
            if(pImageHeader){

                BITMAPINFOHEADER UNALIGNED *pBMPInfoHeader = (BITMAPINFOHEADER*)(pImageHeader + sizeof(BITMAPFILEHEADER));
                BITMAPFILEHEADER UNALIGNED *pBMPFileHeader = (BITMAPFILEHEADER*)pImageHeader;

                //
                // set updated image height
                //

                pBMPInfoHeader->biHeight    = lTotalLinesWritten;

                //
                // set updated image size
                //

                pBMPInfoHeader->biSizeImage = (pBMPInfoHeader->biHeight * pItemContext->lBytesPerScanLine);

                //
                // set updated file size
                //

                pBMPFileHeader->bfSize      = pBMPInfoHeader->biSizeImage + pBMPFileHeader->bfOffBits;

                //
                // update file written to disk, by rewriting the header
                //

                DWORD dwBytesWrittenToFile = 0;

                //
                // reset file pointer to start of file
                //

                SetFilePointer((HANDLE)ULongToPtr(pmdtc->hFile),0,NULL,FILE_BEGIN);

                //
                // write (header size) bytes to the file, using the stored
                // file header above.
                //

                WriteFile((HANDLE)ULongToPtr(pmdtc->hFile),pImageHeader,pmdtc->lHeaderSize,&dwBytesWrittenToFile,NULL);

                //
                // validate that the write was successful, by comparing sizes
                //

                if((LONG)dwBytesWrittenToFile != pmdtc->lHeaderSize){
                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ScanItem, Header was not written to file correctly"));
                }

                //
                // this driver writes the data up-side-down..
                // so the final file needs to be flipped.
                // note: read the file, and flip it here??

                if (bVerticalFlip) {
                    // VerticalFlip(pItemContext, pmdtc);
                }
            }
        }

        //
        // call back client with status on the transfer
        //

        hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(IT_MSG_STATUS,
                                                          IT_STATUS_TRANSFER_TO_CLIENT,
                                                          100, // 100 percent complete!
                                                          0,
                                                          0,
                                                          NULL,
                                                          0);
        if(hr == S_OK){

            //
            // Since we are out of data.. we should send the WIA_STATUS_END_OF_MEDIA
            //

            // hr = WIA_STATUS_END_OF_MEDIA;
            hr = S_OK;
        }
    }

    HRESULT Temphr = m_pScanAPI->FakeScanner_Scan(SCAN_END, NULL, 0, NULL);
    if (FAILED(Temphr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ScanItem, Ending a scanning session failed"));
        hr = Temphr;
    }

    //
    // free down sampled, temporary buffer
    //

    if(DownSampleInfo.pDestBuffer){
        CoTaskMemFree(DownSampleInfo.pDestBuffer);
        DownSampleInfo.pDestBuffer = NULL;
    }

    return hr;
}

/**************************************************************************\
* ScanItemCB
*
*   This helper is called to do a MEMORY transfer.
*   Note: This routine must fill buffers, adjust the buffer offset and
*         return percent complete status back to the client via a callback
*         routine. (a callback interface must be supplied by the caller for
*         this routine to function).
*
* Arguments:
*
*   pItemContext    - private item data
*   pmdtc           - buffer and callback information
*   plDevErrVal     - device error value
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::ScanItemCB(
    PMINIDRIVERITEMCONTEXT  pItemContext,
    PMINIDRV_TRANSFER_CONTEXT   pmdtc,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::ScanItemCB");
    HRESULT hr = S_OK;

    LONG  lScanPhase   = SCAN_START;
    DWORD cbWritten    = 0;
    LONG  cbSize       = 0;
    LONG  lItemSize    = pmdtc->lHeaderSize;
    BOOL  bSwapBGRData = TRUE;
    BOOL  bDWORDAlign  = TRUE;
    pmdtc->cbOffset    = 0;
    LONG  lTotalLinesWritten = 0;
    LONG  cbEstimatedPageSize = (pItemContext->lBytesPerScanLine * (pmdtc->lYRes * EST_PAGE_LENGTH_INCHES));
    BOOL  bIncludeHeaderData = TRUE;
    //
    //  This must be a callback transfer request
    //

    if ((pmdtc->pIWiaMiniDrvCallBack == NULL) ||
        (!pmdtc->bTransferDataCB)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ScanItemCB, invalid callback params"));
        return E_INVALIDARG;
    }

    //
    //  SEND HEADER to client
    //

    hr = SendImageHeader(pmdtc);
    if(hr != S_OK) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ScanItemCB, SendImageHeader failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // scan until buffer runs out or scanner completes transfer
    //

    while ((lScanPhase == SCAN_START) || (cbWritten)) {

        PBYTE pBuf         = pmdtc->pTransferBuffer;

        //
        // Limit requests to max buffer size or less.
        //

        cbSize = m_MaxBufferSize;

        //
        // Request size to scanner must be modula the raw bytes per scan row.
        // Enough space for the alignment padding must be reserved.
        // These are requirements for AlignInPlace
        //

        cbSize = (cbSize / pItemContext->lBytesPerScanLine) * pItemContext->lBytesPerScanLineRaw;

        //
        //  Device specific call to get data from the scanner and put it into
        //  a buffer.  lScanPhase indicates whether this is the first call to Scan,
        //  pBuf is a pointer to the buffer, cbSize is the amount of data
        //  requested from the scanner, and cbWritten will be set to the actual
        //  amount of data returned by the scanner.
        //

        hr = m_pScanAPI->FakeScanner_Scan(lScanPhase, pBuf, cbSize, &cbWritten);

        //
        // set flag to SCAN_CONTINUE, for other calls
        //

        lScanPhase = SCAN_CONTINUE;

        if (hr == S_OK) {
            if (cbWritten) {

                //
                // keep track of how many lines were written
                //

                lTotalLinesWritten += (cbWritten / pItemContext->lBytesPerScanLine);

                //
                // Place the scan data in correct byte order for 3 bytes ber pixel data.
                //

                if ((pmdtc->lDepth == 24) &&
                   ((pmdtc->guidFormatID == WiaImgFmt_BMP) ||
                   ((pmdtc->guidFormatID == WiaImgFmt_MEMORYBMP)))) {

                     //
                     // swap data if needed
                     //

                     if(bSwapBGRData) {
                         SwapBuffer24(pBuf, cbWritten);
                     }
                }

                if (bDWORDAlign) {

                    //
                    // Align the data on DWORD boundries.
                    //

                    cbWritten = AlignInPlace(pBuf,
                                             cbWritten,
                                             pItemContext->lBytesPerScanLine,
                                             pItemContext->lBytesPerScanLineRaw);
                }

                //
                // decrease estimated page size, for (estimated percent complete calculation)
                //

                cbEstimatedPageSize -= cbWritten;

                //
                // update cbWritten to account for the image data header (if one exists), on first callback
                //

                if(bIncludeHeaderData){
                    cbWritten += lItemSize;
                    bIncludeHeaderData = FALSE;
                } else {

                    //
                    // update data offset (data written so far, from the start of the data buffer, (including image headers))
                    //

                    pmdtc->cbOffset += cbWritten;
                }

                //
                // avoid division by zero, by setting cbEstimatedPageSize to 1
                //

                if(cbEstimatedPageSize < 0){
                    cbEstimatedPageSize = 1;
                }

                //
                // If a status callback was specified callback the class driver.
                // There has to be a callback provided, this is the callback
                // transfer.
                //

                if (pmdtc->pIWiaMiniDrvCallBack) {

                    FLOAT FractionComplete = 0.0f;
                    LONG  PercentComplete  = 0;

                    FractionComplete = (FLOAT)(lTotalLinesWritten * pItemContext->lBytesPerScanLineRaw) / (FLOAT)cbEstimatedPageSize;
                    if (FractionComplete > 0.9f) {
                        FractionComplete = 0.9f; // hold at 90% complete...until done
                    }

                    //
                    // calculate percent complete
                    //

                    PercentComplete = (LONG)(100 * FractionComplete);

                    //
                    // call back client with status on the transfer and data offset
                    //

                    hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(IT_MSG_DATA,
                                                                      IT_STATUS_TRANSFER_TO_CLIENT,
                                                                      PercentComplete,
                                                                      pmdtc->cbOffset,
                                                                      cbWritten,
                                                                      pmdtc,
                                                                      0);
                    //
                    // check for user cancel
                    //

                    if (hr == S_FALSE) {

                        WIAS_LTRACE(m_pIWiaLog,
                                    WIALOG_NO_RESOURCE_ID,
                                    WIALOG_LEVEL4,
                                    ("ScanItemCB, Transfer canceled by client (IT_MSG_DATA callback)"));
                        break;

                    } else if (FAILED(hr)) {

                        //
                        // transfer failed
                        //

                        WIAS_LERROR(m_pIWiaLog,
                                    WIALOG_NO_RESOURCE_ID,
                                    ("ScanItemCB, MiniDrvCallback failed (IT_MSG_DATA callback)"));
                        WIAS_LHRESULT(m_pIWiaLog, hr);
                        break;
                    }
                }
            }

        } else {

            //
            //  Get the device error
            //

            *plDevErrVal = (LONG) hr;
            WIAS_LERROR(m_pIWiaLog,
                        WIALOG_NO_RESOURCE_ID,
                        ("ScanItemCB, data transfer failed, status: 0x%X", hr));
            break;
        }
    }

    if (S_OK == hr) {

        //
        // call back client with status on the transfer
        //

        hr = pmdtc->pIWiaMiniDrvCallBack->MiniDrvCallback(IT_MSG_DATA,
                                                          IT_STATUS_TRANSFER_TO_CLIENT,
                                                          100, // 100 percent complete!
                                                          0,
                                                          0,
                                                          NULL,
                                                          0);

        if (S_OK == hr) {

            //
            // Since we are out of data.. we should send the WIA_STATUS_END_OF_MEDIA
            //

            hr = WIA_STATUS_END_OF_MEDIA;
        }
    }

    //
    // end the scan
    //

    HRESULT Temphr = m_pScanAPI->FakeScanner_Scan(SCAN_END, NULL, 0, NULL);
    if(FAILED(Temphr)){
        WIAS_LERROR(m_pIWiaLog,
                    WIALOG_NO_RESOURCE_ID,
                    ("ScanItemCB, Ending a scanning session failed"));
        return Temphr;
    }

    return hr;
}

/**************************************************************************\
* CWIAScannerDevice::drvAcquireItemData
*
*   This driver entry point is called when image data is requested from the
*   device.
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA item.
*   lFlags          - Operation flags, unused.
*   pmdtc           - Pointer to mini driver context. On entry, only the
*                     portion of the mini driver context which is derived
*                     from the item properties is filled in.
*   plDevErrVal     - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvAcquireItemData(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    PMINIDRV_TRANSFER_CONTEXT   pmdtc,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvAcquireItemData");
    HRESULT hr = S_OK;
    *plDevErrVal = 0;

    //
    // Get a pointer to the associated driver item.
    //

    IWiaDrvItem* pDrvItem;

    hr = wiasGetDrvItem(pWiasContext, &pDrvItem);
    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, wiasGetDrvItem() failed."));
        WIAS_LHRESULT(m_pIWiaLog,hr);
        return hr;
    }

    //
    // Validate the data transfer context.
    //

    hr = ValidateDataTransferContext(pmdtc);

    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, ValidateDataTransferContext() failed."));
        WIAS_LHRESULT(m_pIWiaLog,hr);
        return hr;
    }

    //
    //  Get item specific driver data
    //

    PMINIDRIVERITEMCONTEXT  pItemContext = NULL;

    hr = pDrvItem->GetDeviceSpecContext((BYTE**)&pItemContext);

    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, NULL item context"));
        WIAS_LHRESULT(m_pIWiaLog,hr);
        return hr;
    }

    //
    // for compressed data, unknown page lengths..or multipage transfers, the mini driver does not know the
    // size of the image, so a temporary buffer needs to be maintained by the WIA
    // minidriver.
    //

    if (!pmdtc->bClassDrvAllocBuf) {

        LONG lClassDrvAllocSize = pItemContext->lHeaderSize + m_MaxBufferSize; // header + max buffer band size
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvAcquireItemData, lHeaderSize = %d",pItemContext->lHeaderSize));
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvAcquireItemData, Attempting to Allocate (%d)bytes for pmdtc->pTransferBuffer",lClassDrvAllocSize));

        pmdtc->pTransferBuffer = (PBYTE) CoTaskMemAlloc(lClassDrvAllocSize);
        if (!pmdtc->pTransferBuffer) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, unable to allocate temp transfer buffer, size: %d",(pmdtc->lImageSize + pmdtc->lHeaderSize)));
            return E_OUTOFMEMORY;
        }

        //
        // set new buffer size
        //

        pmdtc->lBufferSize = lClassDrvAllocSize;
    }

    //
    //  Use WIA services to fetch format specific info.  This information
    //  is based on the property settings.
    //

    hr = wiasGetImageInformation(pWiasContext, 0, pmdtc);

    if (hr != S_OK) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, wiasGetImageInformation failed."));
        WIAS_LHRESULT(m_pIWiaLog,hr);
        return hr;
    }

    //
    // Get number of pages requested, for ADF scanning loop
    //

    BOOL bEmptyTheADF = FALSE;
    LONG lPagesRequested = GetPageCount(pWiasContext);
    if (lPagesRequested == 0) {
        bEmptyTheADF    = TRUE;
        lPagesRequested = 1;// set to 1 so we can enter our loop
                            // WIA_ERROR_PAPER_EMPTY will terminate
                            // the loop...or an error, or a cancel..
                            //
    }

    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvAcquireItemData, Pages to Scan = %d",lPagesRequested));

    if (m_bADFEnabled) { // FEEDER is enabled for scanning

        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvAcquireItemData, Feeder is enabled for use"));

        //
        // clear an potential paper that may be blocking the
        // scan pathway.
        //

        hr = m_pScanAPI->FakeScanner_ADFUnFeedPage();
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, ADFUnFeedPage (begin transfer) Failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }

    } else {            // FLATBED is enabled for scanning

        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvAcquireItemData, Feeder is disabled or no feeder exists"));

        //
        // Transfer only a single image
        //

        bEmptyTheADF    = FALSE;
        lPagesRequested = 1;
    }

    //
    // WIA document scanning loop
    //

    LONG lPagesScanned      = 0;        // number of pages currently scanned
    BOOL bCallBackTransfer  = FALSE;    // callback transfer flag
    while (lPagesRequested > 0) {

        if (m_bADFEnabled) {

            //
            // Check feeder for paper
            //

            hr = m_pScanAPI->FakeScanner_ADFHasPaper();
            if (FAILED(hr)) {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, ADFHasPaper Failed"));
                WIAS_LHRESULT(m_pIWiaLog, hr);
                return hr;
            }

            //
            // Attempt to load a page (only if needed)
            //

            hr = m_pScanAPI->FakeScanner_ADFFeedPage();
            if (FAILED(hr)) {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, ADFFeedPage Failed"));
                WIAS_LHRESULT(m_pIWiaLog, hr);
                return hr;
            }

            //
            // Check feeder's status
            //

            hr = m_pScanAPI->FakeScanner_ADFStatus();
            if (FAILED(hr)) {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, ADFStatus Failed"));
                WIAS_LHRESULT(m_pIWiaLog, hr);
                return hr;
            }
        }

        //
        // update image information
        //

        hr = wiasGetImageInformation(pWiasContext, 0, pmdtc);
        if(FAILED(hr)){
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, wiasGetImageInformation Failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);

            //
            // free any allocated memory
            //

            if (!pmdtc->bClassDrvAllocBuf) {
                WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvAcquireItemData, Freeing any allocated memory (entire scan operation complete)"));
                if (NULL != pmdtc->pTransferBuffer) {
                    CoTaskMemFree(pmdtc->pTransferBuffer);
                    pmdtc->pTransferBuffer = NULL;
                }
            }
            return hr;
        }

        //
        //  Determine if this is a callback or file transfer.
        //

        if (pmdtc->tymed == TYMED_CALLBACK) {

            //
            // Scan the page to memory
            //

            bCallBackTransfer = TRUE;

            hr = ScanItemCB(pItemContext,
                            pmdtc,
                            plDevErrVal);

        } else {

            //
            // Scan the page to file
            //

            hr = ScanItem(pItemContext,
                          pmdtc,
                          plDevErrVal);

        }

        if (!bEmptyTheADF) {

            //
            // update pages requested counter
            //

            lPagesRequested--;
        }

        if (hr == S_FALSE) {

            //
            // user canceled the scan
            //

            lPagesRequested = 0; // set pages to 0 to cleanly exit loop
        }

        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvAcquireItemData, Pages left to scan = %d",lPagesRequested));

        if (m_bADFEnabled) {

            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvAcquireItemData, Unloading a page from the feeder"));

            //
            // Attempt to unload the scanned page (only if needed)
            //

            hr = m_pScanAPI->FakeScanner_ADFUnFeedPage();
            if (SUCCEEDED(hr)) {
                if (bCallBackTransfer) {

                    //
                    // send the NEW_PAGE message, when scanning multiple pages
                    // in callback mode.  This will let the calling application
                    // know when an end-of-page has been hit.
                    //

                    hr = wiasSendEndOfPage(pWiasContext, lPagesScanned, pmdtc);
                    if (FAILED(hr)) {
                        lPagesRequested = 0;
                        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, wiasSendEndOfPage Failed"));
                        WIAS_LHRESULT(m_pIWiaLog, hr);
                    }

                    //
                    // increment pages scanned counter
                    //

                    lPagesScanned++;
                }
            } else {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvAcquireItemData, ADFUnFeedPage (end transfer) Failed"));
                WIAS_LHRESULT(m_pIWiaLog, hr);
            }
        }

        /*
        //
        // free any allocated memory between scans to avoid memory leaks
        //

        if (!pmdtc->bClassDrvAllocBuf) {
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvAcquireItemData, Freeing any allocated memory (single scan operation complete)"));
            if (NULL != pmdtc->pTransferBuffer) {
                CoTaskMemFree(pmdtc->pTransferBuffer);
                pmdtc->pTransferBuffer = NULL;
            }
        }
        */
    }

    //
    // we are now finished scanning all documents
    //

    if (!pmdtc->bClassDrvAllocBuf) {
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvAcquireItemData, Freeing any allocated memory (entire scan operation complete)"));
        if (NULL != pmdtc->pTransferBuffer) {
            CoTaskMemFree(pmdtc->pTransferBuffer);
            pmdtc->pTransferBuffer = NULL;
        }
    }

    return hr;
}

/**************************************************************************\
* IsPreviewScan
*
*   Get the current preview setting from the item properties.
*   A helper for drvAcquireItemData.
*
* Arguments:
*
*   pWiasContext - pointer to an Item context.
*
* Return Value:
*
*    TRUE - Preview is set, FALSE - Final is set
*
* History:
*
*    8/10/2000 Original Version
*
\**************************************************************************/

BOOL CWIAScannerDevice::IsPreviewScan(BYTE *pWiasContext)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::IsPreviewScan");
    //
    // Get a pointer to the root item, for property access.
    //

    BYTE *pRootItemCtx = NULL;

    HRESULT hr = wiasGetRootItem(pWiasContext, &pRootItemCtx);
    if (FAILED(hr)) {
        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("IsPreviewScan, No Preview Property Found on ROOT item!"));
        return FALSE;
    }

    //
    //  Get the current preview setting.
    //

    LONG lPreview = 0;

    hr = wiasReadPropLong(pRootItemCtx, WIA_DPS_PREVIEW, &lPreview, NULL, true);
    if (hr != S_OK) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("IsPreviewScan, Failed to read Preview Property."));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return FALSE;
    }

    return (lPreview > 0);
}

/**************************************************************************\
* GetPageCount
*
*   Get the requested number of pages to scan from the item properties.
*   A helper for drvAcquireItemData.
*
* Arguments:
*
*   pWiasContext - pointer to an Item context.
*
* Return Value:
*
*    Number of pages to scan.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

LONG CWIAScannerDevice::GetPageCount(BYTE *pWiasContext)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::GetPageCount");
    //
    // Get a pointer to the root item, for property access.
    //

    BYTE *pRootItemCtx = NULL;

    HRESULT hr = wiasGetRootItem(pWiasContext, &pRootItemCtx);
    if (FAILED(hr)) {
        return 1;
    }

    //
    //  Get the requested page count.
    //

    LONG lPagesRequested = 0;

    hr = wiasReadPropLong(pRootItemCtx, WIA_DPS_PAGES, &lPagesRequested, NULL, true);
    if (hr != S_OK) {
        return 1;
    }

    return lPagesRequested;
}

/**************************************************************************\
* SetItemSize
*
*   Calulate the new item size, and write the new Item Size property value.
*
* Arguments:
*
*   pWiasContext       - item
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT CWIAScannerDevice::SetItemSize(
    BYTE *pWiasContext)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::SetItemSize");
    HRESULT  hr = S_OK;
    LONG lWidthInBytes = 0;
    LONG lMinBufSize   = 0;
    GUID guidFormatID  = GUID_NULL;
    MINIDRV_TRANSFER_CONTEXT mdtc;

    LONG lNumProperties = 3;
    PROPVARIANT pv[3];
    PROPSPEC ps[3] = {{PRSPEC_PROPID, WIA_IPA_ITEM_SIZE},
                      {PRSPEC_PROPID, WIA_IPA_BYTES_PER_LINE},
                      {PRSPEC_PROPID, WIA_IPA_MIN_BUFFER_SIZE}};

    //
    //  Clear the MiniDrvTransferContext
    //

    memset(&mdtc,0,sizeof(MINIDRV_TRANSFER_CONTEXT));

    //
    // read format GUID
    //

    hr = wiasReadPropGuid(pWiasContext, WIA_IPA_FORMAT, &guidFormatID, NULL, TRUE);
    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetItemSize, ReadPropLong WIA_IPA_FORMAT error"));
        return hr;
    }

    //
    // read TYMED
    //

    hr = wiasReadPropLong(pWiasContext,WIA_IPA_TYMED, (LONG*)&mdtc.tymed, NULL, TRUE);
    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetItemSize, ReadPropLong WIA_IPA_TYMED error"));
        return hr;
    }

    //
    // wias works for DIB, or uncompressed standard TIFF formats
    // Standard TIFFs are constructed using a DIB-like implementation.
    // The data is stored as one huge strip, rather than multiple smaller
    // strips.
    //

    hr = wiasGetImageInformation(pWiasContext, WIAS_INIT_CONTEXT, &mdtc);
    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetItemSize, could not get image information"));
        return hr;
    }

    //
    // we want our driver to allocate the memory for our transfer bands,
    // and control the writing of them. To do this, Set item size to 0
    //

    mdtc.lItemSize = 0;

    //
    //  Set the MinBufferSize property.  MinBufferSize is the minimum buffer
    //  that a client can request for a data transfer.
    //

    switch (mdtc.tymed) {
    case TYMED_CALLBACK:

        //
        // callback uses driver's minimum buffer size.
        // This is could be taken from the driver at
        // initialization time.
        //

        lMinBufSize = m_MinBufferSize;
        break;

    case TYMED_FILE:

        //
        // file transfers, require that the minimum buffer size be the
        // entire length of the file.
        //

        lMinBufSize = m_MinBufferSize;//mdtc.lImageSize + mdtc.lHeaderSize;
        break;

    default:

        //
        // unknown TYMED
        //

        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetItemSize, unknown tymed: 0x%08X", mdtc.tymed));
        return E_INVALIDARG;
    }

    //
    //  Initialize propvar's.  Then write the values.  Don't need to call
    //  PropVariantClear when done, since there are only LONG values.
    //

    for (int i = 0; i < lNumProperties; i++) {
        PropVariantInit(&pv[i]);
        pv[i].vt = VT_I4;
    }

    pv[0].lVal = mdtc.lItemSize;
    pv[1].lVal = mdtc.cbWidthInBytes;
    pv[2].lVal = lMinBufSize;

    //
    // Write WIA_IPA_ITEM_SIZE, WIA_IPA_BYTES_PER_LINE, and  WIA_IPA_MIN_BUFFER_SIZE
    // property values
    //

    hr = wiasWriteMultiple(pWiasContext, lNumProperties, ps, pv);
    if (SUCCEEDED(hr)) {

        //
        // Now update the MINIDRIVER TRANSFER CONTEXT with new values
        //

        //
        // Get a pointer to the associated driver item.
        //

        IWiaDrvItem* pDrvItem = NULL;

        hr = wiasGetDrvItem(pWiasContext, &pDrvItem);
        if (FAILED(hr)) {
            return hr;
        }

        //
        // Get driver item's context
        //

        PMINIDRIVERITEMCONTEXT pItemContext = NULL;

        hr = pDrvItem->GetDeviceSpecContext((BYTE**)&pItemContext);

        if (SUCCEEDED(hr)) {

            //
            // Calculate how many scan lines will fit in the buffer.
            //

            pItemContext->lBytesPerScanLineRaw = ((mdtc.lWidthInPixels * mdtc.lDepth) + 7)  / 8;
            pItemContext->lBytesPerScanLine    = (((mdtc.lWidthInPixels * mdtc.lDepth) + 31) / 8) & 0xfffffffc;
            pItemContext->lTotalRequested      = 0;// we don't know the image size
            pItemContext->lImageSize           = 0;// we don't know the image size
            pItemContext->lHeaderSize          = mdtc.lHeaderSize;

        } else {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvWriteItemProperties, NULL item context"));
        }
    } else {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("SetItemSize, WriteMultiple failed"));
    }

    return hr;
}

/**************************************************************************\
* CWIAScannerDevice::drvInitItemProperties
*
*   Initialize the device item properties. Called during item
*   initialization.  This is called by the WIA Class driver
*   after the item tree has been built.  It is called once for every
*   item in the tree.
*
* Arguments:
*
*   pWiasContext    - Pointer to WIA context (item information).
*   lFlags          - Operation flags, unused.
*   plDevErrVal     - Pointer to the device error value.
*
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvInitItemProperties(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvInitItemProperties");
    HRESULT hr = S_OK;

    //
    //  This device doesn't touch hardware to initialize the device item
    //  properties, so set plDevErrVal to 0.
    //

    *plDevErrVal = 0;

    //
    //  Get a pointer to the associated driver item.
    //

    IWiaDrvItem* pDrvItem;
    hr = wiasGetDrvItem(pWiasContext, &pDrvItem);
    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, wiasGetDrvItem failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    //  Set initial item properties.
    //

    LONG    lItemType = 0;

    pDrvItem->GetItemFlags(&lItemType);

    if (lItemType & WiaItemTypeRoot) {

        //
        //  This is for the root item.
        //

        //
        // Build Root Item Properties, initializing global
        // structures with their default and valid values
        //

        hr = BuildRootItemProperties();

        if(FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, BuildRootItemProperties failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            DeleteRootItemProperties();
            return hr;
        }

        //
        //  Add the device specific root item property names,
        //  using WIA service.
        //

        hr = wiasSetItemPropNames(pWiasContext,
                                  m_NumRootItemProperties,
                                  m_piRootItemDefaults,
                                  m_pszRootItemDefaults);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, wiasSetItemPropNames failed"));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_NumRootItemPropeties = %d",m_NumRootItemProperties));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_piRootItemDefaults   = %x",m_piRootItemDefaults));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_pszRootItemDefaults  = %x",m_pszRootItemDefaults));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            DeleteRootItemProperties();
            return hr;
        }

        //
        //  Set the device specific root item properties to
        //  their default values using WIA service.
        //

        hr = wiasWriteMultiple(pWiasContext,
                               m_NumRootItemProperties,
                               m_psRootItemDefaults,
                               m_pvRootItemDefaults);
        //
        // Free PROPVARIANT array, This frees any memory that was allocated for a prop variant value.
        //

        // FreePropVariantArray(m_NumRootItemProperties,m_pvRootItemDefaults);


        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, wiasWriteMultiple failed"));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_NumRootItemPropeties = %d",m_NumRootItemProperties));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_pszRootItemDefaults  = %x",m_pszRootItemDefaults));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_pvRootItemDefaults   = %x",m_pvRootItemDefaults));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            DeleteRootItemProperties();
            return hr;
        }

        //
        //  Use WIA services to set the property access and
        //  valid value information from m_wpiItemDefaults.
        //

        hr =  wiasSetItemPropAttribs(pWiasContext,
                                     m_NumRootItemProperties,
                                     m_psRootItemDefaults,
                                     m_wpiRootItemDefaults);

        if(FAILED(hr)){
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, wiasSetItemPropAttribs failed"));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_NumRootItemPropeties = %d",m_NumRootItemProperties));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_psRootItemDefaults   = %x",m_psRootItemDefaults));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_wpiRootItemDefaults  = %x",m_wpiRootItemDefaults));
            WIAS_LHRESULT(m_pIWiaLog, hr);
        }

        //
        // free allocated property arrays, for more memory
        //

        DeleteRootItemProperties();
    } else {

        //
        //  This is for the child item.(Top)
        //

        //
        // Build Top Item Properties, initializing global
        // structures with their default and valid values
        //

        hr = BuildTopItemProperties();

        if(FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, BuildTopItemProperties failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            DeleteTopItemProperties();
            return hr;
        }

        //
        //  Use the WIA service to set the item property names.
        //

        hr = wiasSetItemPropNames(pWiasContext,
                                  m_NumItemProperties,
                                  m_piItemDefaults,
                                  m_pszItemDefaults);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, wiasSetItemPropNames failed"));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_NumItemPropeties = %d",m_NumItemProperties));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_piItemDefaults   = %x",m_piItemDefaults));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_pszItemDefaults  = %x",m_pszItemDefaults));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            DeleteTopItemProperties();
            return hr;
        }

        //
        //  Use WIA services to set the item properties to their default
        //  values.
        //

        hr = wiasWriteMultiple(pWiasContext,
                               m_NumItemProperties,
                               m_psItemDefaults,
                               (PROPVARIANT*)m_pvItemDefaults);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, wiasWriteMultiple failed"));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_NumItemPropeties = %d",m_NumItemProperties));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_pszItemDefaults  = %x",m_pszItemDefaults));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_pvItemDefaults   = %x",m_pvItemDefaults));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            DeleteTopItemProperties();
            return hr;
        }

        //
        //  Use WIA services to set the property access and
        //  valid value information from m_wpiItemDefaults.
        //

        hr =  wiasSetItemPropAttribs(pWiasContext,
                                     m_NumItemProperties,
                                     m_psItemDefaults,
                                     m_wpiItemDefaults);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, wiasSetItemPropAttribs failed"));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_NumItemPropeties = %d",m_NumItemProperties));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_psItemDefaults   = %x",m_psItemDefaults));
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitItemProperties, m_wpiItemDefaults  = %x",m_wpiItemDefaults));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            DeleteTopItemProperties();
            return hr;
        }

        //
        //  Set item size properties.
        //

        hr = SetItemSize(pWiasContext);
        if(FAILED(hr)){
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitItemProperties, SetItemSize failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
        }

        //
        // free allocated property arrays, for more memory
        //

        DeleteTopItemProperties();
    }
    return hr;
}


/**************************************************************************\
* CWIAScannerDevice::drvValidateItemProperties
*
*   Validate the device item properties.  It is called when changes are made
*   to an item's properties.  Driver should not only check that the values
*   are valid, but must update any valid values that may change as a result.
*   If an a property is not being written by the application, and it's value
*   is invalid, then "fold" it to a new value, else fail validation (because
*   the application is setting the property to an invalid value).
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA item, unused.
*   lFlags          - Operation flags, unused.
*   nPropSpec       - The number of properties that are being written
*   pPropSpec       - An array of PropSpecs identifying the properties that
*                     are being written.
*   plDevErrVal     - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
***************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvValidateItemProperties(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    ULONG                       nPropSpec,
    const PROPSPEC              *pPropSpec,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvValidateItemProperties");

    HRESULT hr      = S_OK;
    LONG lItemType  = 0;
    WIA_PROPERTY_CONTEXT Context;

    *plDevErrVal = 0;

    hr = wiasGetItemType(pWiasContext, &lItemType);
    if (SUCCEEDED(hr)) {
        if (lItemType & WiaItemTypeRoot) {

            //
            //  Validate root item
            //

            hr = wiasCreatePropContext(nPropSpec,
                                       (PROPSPEC*)pPropSpec,
                                       0,
                                       NULL,
                                       &Context);
            if (SUCCEEDED(hr)) {

                //
                // Check ADF to see if the status settings need to be updated
                // Also switch between FEEDER/FLATBED modes
                //

                hr = CheckADFStatus(pWiasContext, &Context);
                if(FAILED(hr)) {
                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, CheckADFStatus failed"));
                    WIAS_LHRESULT(m_pIWiaLog, hr);
                }

                //
                // check Preview Property only if validation is successful so far....
                //

                if (SUCCEEDED(hr)) {

                    //
                    // Check Preview property to see if the settings are valid
                    //

                    hr = CheckPreview(pWiasContext, &Context);
                    if (FAILED(hr)) {
                        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, CheckPreview failed"));
                        WIAS_LHRESULT(m_pIWiaLog, hr);
                    }

                    //
                    // call WIA service helper to validate other properties
                    //

                    if (SUCCEEDED(hr)) {
                        hr = wiasValidateItemProperties(pWiasContext, nPropSpec, pPropSpec);
                        if (FAILED(hr)) {
                            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, wiasValidateItemProperties failed."));
                            WIAS_LHRESULT(m_pIWiaLog, hr);
                        }
                    }
                }
            } else {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, wiasCreatePropContext failed (Root Item)"));
                WIAS_LHRESULT(m_pIWiaLog, hr);
            }

        } else {

            //
            // validate item properties here
            //

            //
            //  Create a property context needed by some WIA Service
            //  functions used below.
            //

            hr = wiasCreatePropContext(nPropSpec,
                                       (PROPSPEC*)pPropSpec,
                                       0,
                                       NULL,
                                       &Context);
            if (SUCCEEDED(hr)) {

                //
                //  Check Current Intent first
                //

                hr = CheckIntent(pWiasContext, &Context);
                if (SUCCEEDED(hr)) {

                    //
                    //  Check if DataType is being written
                    //

                    hr = CheckDataType(pWiasContext, &Context);
                    if (SUCCEEDED(hr)) {

                        //
                        //  update the extent properties and valid values.
                        //

                        LONG lBedWidth  = 0;
                        LONG lBedHeight = 0;
                        hr = m_pScanAPI->FakeScanner_GetBedWidthAndHeight(&lBedWidth,&lBedHeight);
                        if(FAILED(hr)){
                            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, FakeScanner_GetBedWidthAndHeight failed"));
                            WIAS_LHRESULT(m_pIWiaLog, hr);
                            return hr;
                        }

                        hr = CheckXExtent(pWiasContext,&Context,lBedWidth);

                        if (SUCCEEDED(hr)) {

                            //
                            //  Use the WIA Service to update the valid values
                            //  for Format.  These are based on the value of
                            //  WIA_IPA_TYMED, so validation is also performed
                            //  on the tymed property by the service.
                            //

                            hr = wiasUpdateValidFormat(pWiasContext,
                                                       &Context,
                                                       (IWiaMiniDrv*) this);

                            if (SUCCEEDED(hr)) {

                                //
                                // Check Preferred format
                                //

                                hr = CheckPreferredFormat(pWiasContext, &Context);
                                if(FAILED(hr)){
                                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, CheckPreferredFormat failed"));
                                    WIAS_LHRESULT(m_pIWiaLog, hr);
                                }
                            } else {
                                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, wiasUpdateValidFormat failed"));
                                WIAS_LHRESULT(m_pIWiaLog, hr);
                            }
                        } else {
                            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, wiasUpdateScanRect failed"));
                            WIAS_LHRESULT(m_pIWiaLog, hr);
                        }
                    } else {
                        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, CheckDataType failed"));
                        WIAS_LHRESULT(m_pIWiaLog, hr);
                    }
                } else {
                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, CheckIntent failed"));
                    WIAS_LHRESULT(m_pIWiaLog, hr);
                }
                wiasFreePropContext(&Context);
            } else {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, wiasCreatePropContext failed (Child Item)"));
                WIAS_LHRESULT(m_pIWiaLog, hr);
            }

            //
            //  Update the item size
            //

            if (SUCCEEDED(hr)) {
                hr = SetItemSize(pWiasContext);
                if(FAILED(hr)){
                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, SetItemSize failed"));
                    WIAS_LHRESULT(m_pIWiaLog, hr);
                }
            }

            //
            // call WIA service helper to validate other properties
            //

            if (SUCCEEDED(hr)) {
                hr = wiasValidateItemProperties(pWiasContext, nPropSpec, pPropSpec);
                if(FAILED(hr)){
                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, wiasValidateItemProperties failed."));
                    WIAS_LHRESULT(m_pIWiaLog, hr);
                }
            }
        }
    } else {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvValidateItemProperties, wiasGetItemType failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
    }

    //
    // log HRESULT sent back to caller
    //

    if(FAILED(hr)){
        WIAS_LHRESULT(m_pIWiaLog, hr);
    }

    return hr;
}

/**************************************************************************\
* CWIAScannerDevice::drvWriteItemProperties
*
*   Write the device item properties to the hardware.  This is called by the
*   WIA Class driver prior to drvAcquireItemData when the client requests
*   a data transfer.
*
* Arguments:
*
*   pWiasContext - Pointer to WIA item.
*   lFlags       - Operation flags, unused.
*   pmdtc        - Pointer to mini driver context. On entry, only the
*                  portion of the mini driver context which is derived
*                  from the item properties is filled in.
*   plDevErrVal  - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvWriteItemProperties(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    PMINIDRV_TRANSFER_CONTEXT   pmdtc,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvWriteItemProperties");
    HRESULT hr = S_OK;
    *plDevErrVal = 0;
    LONG lNumProperties = 9;
    PROPVARIANT pv[9];
    PROPSPEC ps[9] = {
        {PRSPEC_PROPID, WIA_IPS_XRES},
        {PRSPEC_PROPID, WIA_IPS_YRES},
        {PRSPEC_PROPID, WIA_IPS_XPOS},
        {PRSPEC_PROPID, WIA_IPS_YPOS},
        {PRSPEC_PROPID, WIA_IPS_XEXTENT},
        {PRSPEC_PROPID, WIA_IPS_YEXTENT},
        {PRSPEC_PROPID, WIA_IPA_DATATYPE},
        {PRSPEC_PROPID, WIA_IPS_BRIGHTNESS},
        {PRSPEC_PROPID, WIA_IPS_CONTRAST}
    };

    //
    // initialize propvariant structures
    //

    for (int i = 0; i< lNumProperties;i++) {
        pv[i].vt = VT_I4;
    }

    //
    // read child item properties
    //

    hr = wiasReadMultiple(pWiasContext, lNumProperties, ps, pv, NULL);

    if (hr == S_OK) {

        hr = m_pScanAPI->FakeScanner_SetXYResolution(pv[0].lVal,pv[1].lVal);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,
                        WIALOG_NO_RESOURCE_ID,
                        ("ScanItem, Setting x any y resolutions failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }

        hr = m_pScanAPI->FakeScanner_SetDataType(pv[6].lVal);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,
                        WIALOG_NO_RESOURCE_ID,
                        ("ScanItem, Setting data type failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }

        hr = m_pScanAPI->FakeScanner_SetIntensity(pv[7].lVal);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,
                        WIALOG_NO_RESOURCE_ID,
                        ("ScanItem, Setting intensity failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }

        hr = m_pScanAPI->FakeScanner_SetContrast(pv[8].lVal);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,
                        WIALOG_NO_RESOURCE_ID,
                        ("ScanItem, Setting contrast failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }

        hr = m_pScanAPI->FakeScanner_SetSelectionArea(pv[2].lVal, pv[3].lVal, pv[4].lVal, pv[5].lVal);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,
                        WIALOG_NO_RESOURCE_ID,
                        ("ScanItem, Setting selection area (extents) failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
            return hr;
        }
    }
    return hr;
}

/**************************************************************************\
* CWIAScannerDevice::drvReadItemProperties
*
*   Read the device item properties.  When a client application tries to
*   read a WIA Item's properties, the WIA Class driver will first notify
*   the driver by calling this method.
*
* Arguments:
*
*   pWiasContext - wia item
*   lFlags       - Operation flags, unused.
*   nPropSpec    - Number of elements in pPropSpec.
*   pPropSpec    - Pointer to property specification, showing which properties
*                  the application wants to read.
*   plDevErrVal  - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvReadItemProperties(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    ULONG                       nPropSpec,
    const PROPSPEC              *pPropSpec,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvReadItemProperties");
    *plDevErrVal = 0;
    return S_OK;
}

/**************************************************************************\
* CWIAScannerDevice::drvLockWiaDevice
*
*   Lock access to the device.
*
* Arguments:
*
*   pWiasContext - unused, can be NULL
*   lFlags       - Operation flags, unused.
*   plDevErrVal  - Pointer to the device error value.
*
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvLockWiaDevice(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvLockWiaDevice");
    *plDevErrVal = 0;
    return m_pStiDevice->LockDevice(m_dwLockTimeout);
}

/**************************************************************************\
* CWIAScannerDevice::drvUnLockWiaDevice
*
*   Unlock access to the device.
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA item, unused.
*   lFlags          - Operation flags, unused.
*   plDevErrVal     - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvUnLockWiaDevice(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvUnLockWiaDevice");
    *plDevErrVal = 0;
    return m_pStiDevice->UnLockDevice();
}

/**************************************************************************\
* CWIAScannerDevice::drvAnalyzeItem
*
*   This device does not support image analysis, so return E_NOTIMPL.
*
* Arguments:
*
*   pWiasContext - Pointer to the device item to be analyzed.
*   lFlags       - Operation flags.
*   plDevErrVal  - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvAnalyzeItem(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvAnalyzeItem");
    *plDevErrVal = 0;
    return E_NOTIMPL;
}

/**************************************************************************\
* CWIAScannerDevice::drvFreeDrvItemContext
*
*   Free any device specific context.
*
* Arguments:
*
*   lFlags          - Operation flags, unused.
*   pDevSpecContext - Pointer to device specific context.
*   plDevErrVal     - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvFreeDrvItemContext(
    LONG                        lFlags,
    BYTE                        *pSpecContext,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvFreeDrvItemContext");
    *plDevErrVal = 0;
    PMINIDRIVERITEMCONTEXT pContext = NULL;
    pContext = (PMINIDRIVERITEMCONTEXT) pSpecContext;

    if (pContext){
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvFreeDrvItemContext, Freeing my allocated context members"));
    }

    return S_OK;
}

/**************************************************************************\
* CWIAScannerDevice::drvInitializeWia
*
*   Initialize the WIA mini driver.  This will build up the driver item tree
*   and perform any other initialization code that's needed for WIA.
*
* Arguments:
*
*   pWiasContext          - Pointer to the WIA item, unused.
*   lFlags                - Operation flags, unused.
*   bstrDeviceID          - Device ID.
*   bstrRootFullItemName  - Full item name.
*   pIPropStg             - Device info. properties.
*   pStiDevice            - STI device interface.
*   pIUnknownOuter        - Outer unknown interface.
*   ppIDrvItemRoot        - Pointer to returned root item.
*   ppIUnknownInner       - Pointer to returned inner unknown.
*   plDevErrVal           - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvInitializeWia(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    BSTR                        bstrDeviceID,
    BSTR                        bstrRootFullItemName,
    IUnknown                    *pStiDevice,
    IUnknown                    *pIUnknownOuter,
    IWiaDrvItem                 **ppIDrvItemRoot,
    IUnknown                    **ppIUnknownInner,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvInitializeWia");
    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitializeWia, bstrDeviceID         = %ws", bstrDeviceID));
    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitializeWia, bstrRootFullItemName = %ws",bstrRootFullItemName));
    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvInitializeWia, lFlags               = %d",lFlags));
    HRESULT hr = S_OK;

    *plDevErrVal = 0;

    *ppIDrvItemRoot = NULL;
    *ppIUnknownInner = NULL;

    //
    //  Need to init names and STI pointer?
    //

    if (m_pStiDevice == NULL) {

        //
        // save STI device interface for locking
        //

        m_pStiDevice = (IStiDevice *)pStiDevice;

        //
        // Cache the device ID.
        //

        m_bstrDeviceID = SysAllocString(bstrDeviceID);

        if (!m_bstrDeviceID) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, unable to allocate device ID string"));
            return E_OUTOFMEMORY;
        }

        //
        // Cache the root property stream name.
        //

        m_bstrRootFullItemName = SysAllocString(bstrRootFullItemName);

        if (!m_bstrRootFullItemName) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, unable to allocate prop stream name"));
            return E_OUTOFMEMORY;
        }
    }

    //
    // Initialize Capabilities array
    //

    hr = BuildCapabilities();

    if(FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, BuildCapabilities failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // Initialize SupportedFormats array
    //

    hr = BuildSupportedFormats();

    if(FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, BuildSupportedFormats failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // Initialize Supported Data Type array
    //

    hr = BuildSupportedDataTypes();

    if(FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, BuildSupportedDataTypes failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // Initialize Supported Intents array
    //

    hr = BuildSupportedIntents();

    if(FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, BuildSupportedIntents failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // Initialize Supported TYMED array
    //

    hr = BuildSupportedTYMED();

    if(FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, BuildSuportedTYMED failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // Initialize  Supported compression types array
    //

    hr = BuildSupportedCompressions();

    if(FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, BuildSupportedCompressions"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // Initialize  Supported Preview modes array
    //

    hr = BuildSupportedPreviewModes();

    if(FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, BuildSupportedPreviewModes"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // Initialize  initial formats array
    //

    hr = BuildInitialFormats();

    if(FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, BuildInitialFormats failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    // Initialize supported resolutions array
    //

    hr = BuildSupportedResolutions();
    if(FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, BuildSupportedResolutions failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    //  Build the device item tree, if it hasn't been built yet.
    //
    //  Send a Device Command to yourself, or Call BuildItemTree manually
    //

    if (!m_pIDrvItemRoot) {
        LONG    lDevErrVal = 0;
        hr = drvDeviceCommand(NULL, 0, &WIA_CMD_SYNCHRONIZE, NULL, &lDevErrVal);
        if(FAILED(hr)){
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvInitializeWia, drvDeviceCommand(WIA_CMD_SYNCHRONIZE) failed"));
            WIAS_LHRESULT(m_pIWiaLog, hr);
        }
    }

    //
    // save root item pointer. (REMEMBER TO RELEASE THIS INTERFACE)
    //

    *ppIDrvItemRoot = m_pIDrvItemRoot;

    return hr;
}

/**************************************************************************\
* CWIAScannerDevice::drvUnInitializeWia
*
*   Gets called when a client connection is going away.
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA Root item context of the client's
*                     item tree.
*
* Return Value:
*    Status
*
* History:
*
*   7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvUnInitializeWia(
    BYTE                *pWiasContext)
{
    return S_OK;
}


/**************************************************************************\
* drvGetDeviceErrorStr
*
*   Map a device error value to a string.
*
* Arguments:
*
*   lFlags        - Operation flags, unused.
*   lDevErrVal    - Device error value.
*   ppszDevErrStr - Pointer to returned error string.
*   plDevErrVal   - Pointer to the device error value.
*
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvGetDeviceErrorStr(
    LONG                        lFlags,
    LONG                        lDevErrVal,
    LPOLESTR                    *ppszDevErrStr,
    LONG                        *plDevErr)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvGetDeviceErrorStr");
    HRESULT hr = S_OK;

    //
    //  Map device errors to a string to be placed in the event log.
    //

    //
    // look up error strings in resource file.
    //

    switch (lDevErrVal) {
        case 0:
            *ppszDevErrStr = L"No Error";                   // hard coded for now
            *plDevErr  = 0;
            hr = S_OK;
            break;
        default:
            *ppszDevErrStr = L"Device Error, Unknown Error";// hard coded for now
            *plDevErr  = 0;
            hr = E_FAIL;
            break;
    }
    return hr;
}

/**************************************************************************\
* drvDeviceCommand
*
*   Issue a command to the device.
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA item.
*   lFlags          - Operation flags, unused.
*   plCommand       - Pointer to command GUID.
*   ppWiaDrvItem    - Optional pointer to returned item, unused.
*   plDevErrVal     - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvDeviceCommand(
    BYTE                        *pWiasContext,
    LONG                        lFlags,
    const GUID                  *plCommand,
    IWiaDrvItem                 **ppWiaDrvItem,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvDeviceCommand");
    *plDevErrVal = 0;
    HRESULT hr = S_OK;

    //
    //  Check which command was issued
    //

    if (*plCommand == WIA_CMD_SYNCHRONIZE) {

        //
        // SYNCHRONIZE - Build the minidriver representation of
        //               the current item list, if it doesn't exist.
        //

        if (!m_pIDrvItemRoot) {
            hr = BuildItemTree();
        } else {
            hr = S_OK;
        }
    } else {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvDeviceCommand, unknown command sent to this device"));
        hr = E_NOTIMPL;
    }

    return hr;
}


/**************************************************************************\
* CWIAScannerDevice::drvGetCapabilities
*
*   Get supported device commands and events as an array of WIA_DEV_CAPS.
*
* Arguments:
*
*   pWiasContext   - Pointer to the WIA item, unused.
*   lFlags         - Operation flags.
*   pcelt          - Pointer to returned number of elements in
*                    returned GUID array.
*   ppCapabilities - Pointer to returned GUID array.
*   plDevErrVal    - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvGetCapabilities(
    BYTE                        *pWiasContext,
    LONG                        ulFlags,
    LONG                        *pcelt,
    WIA_DEV_CAP_DRV             **ppCapabilities,
    LONG                        *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvGetCapabilites");
    *plDevErrVal = 0;

    HRESULT hr = S_OK;

    //
    // Initialize Capabilities array
    //

    hr = BuildCapabilities();

    if(FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvGetCapabilities, BuildCapabilities failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    //  Return depends on flags.  Flags specify whether we should return
    //  commands, events, or both.
    //
    //

    switch (ulFlags) {
    case WIA_DEVICE_COMMANDS:

        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvGetCapabilities, (WIA_DEVICE_COMMANDS)"));

        //
        //  report commands only
        //

        *pcelt          = m_NumSupportedCommands;
        *ppCapabilities = &m_pCapabilities[m_NumSupportedEvents];
        break;
    case WIA_DEVICE_EVENTS:

        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvGetCapabilities, (WIA_DEVICE_EVENTS)"));

        //
        //  report events only
        //

        *pcelt          = m_NumSupportedEvents;
        *ppCapabilities = m_pCapabilities;
        break;
    case (WIA_DEVICE_COMMANDS | WIA_DEVICE_EVENTS):

        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvGetCapabilities, (WIA_DEVICE_COMMANDS|WIA_DEVICE_EVENTS)"));

        //
        //  report both events and commands
        //

        *pcelt          = m_NumCapabilities;
        *ppCapabilities = m_pCapabilities;
        break;
    default:

        //
        //  invalid request
        //

        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvGetCapabilities, invalid flags"));
        return E_INVALIDARG;
    }
    return hr;
}

/**************************************************************************\
* drvGetWiaFormatInfo
*
*   Returns an array of WIA_FORMAT_INFO structs, which specify the format
*   and media type pairs that are supported.
*
* Arguments:
*
*   pWiasContext    - Pointer to the WIA item context, unused.
*   lFlags          - Operation flags, unused.
*   pcelt           - Pointer to returned number of elements in
*                     returned WIA_FORMAT_INFO array.
*   ppwfi           - Pointer to returned WIA_FORMAT_INFO array.
*   plDevErrVal     - Pointer to the device error value.
*
* Return Value:
*
*    Status
*
* History:
*
*   7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvGetWiaFormatInfo(
    BYTE                *pWiasContext,
    LONG                lFlags,
    LONG                *pcelt,
    WIA_FORMAT_INFO     **ppwfi,
    LONG                *plDevErrVal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::drvGetWiaFormatInfo");

    HRESULT hr = S_OK;

    if(NULL == m_pSupportedFormats){
        hr = BuildSupportedFormats();
    }

    *plDevErrVal = 0;
    *pcelt       = m_NumSupportedFormats;
    *ppwfi       = m_pSupportedFormats;
    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvGetWiaFormatInfo, m_NumSupportedFormats = %d",m_NumSupportedFormats));
    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvGetWiaFormatInfo, m_pSupportedFormats   = %x",m_pSupportedFormats));
    return hr;
}

/**************************************************************************\
* drvNotifyPnpEvent
*
*   Pnp Event received by device manager.  This is called when a Pnp event
*   is received for this device.
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::drvNotifyPnpEvent(
    const GUID                  *pEventGUID,
    BSTR                        bstrDeviceID,
    ULONG                       ulReserved)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::DrvNotifyPnpEvent");
    HRESULT hr = S_OK;

    if (*pEventGUID == WIA_EVENT_DEVICE_DISCONNECTED) {
        WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("drvNotifyPnpEvent, (WIA_EVENT_DEVICE_DISCONNECTED)"));
        hr = m_pScanAPI->FakeScanner_DisableDevice();
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("drvNotifyPnpEvent, disable failed"));
        }
    }

    return hr;
}


/*******************************************************************************
*
*                 P R I V A T E   M E T H O D S
*
*******************************************************************************/

/**************************************************************************\
* AlignInPlace
*
*   DWORD align a data buffer in place.
*
* Arguments:
*
*   pBuffer              - Pointer to the data buffer.
*   cbWritten            - Size of the data in bytes.
*   lBytesPerScanLine    - Number of bytes per scan line in the output data.
*   lBytesPerScanLineRaw - Number of bytes per scan line in the input data.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

UINT CWIAScannerDevice::AlignInPlace(
   PBYTE pBuffer,
   LONG  cbWritten,
   LONG  lBytesPerScanLine,
   LONG  lBytesPerScanLineRaw)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "::AlignInPlace");
    if (lBytesPerScanLineRaw % 4) {

      UINT  uiPadBytes          = lBytesPerScanLine - lBytesPerScanLineRaw;
      UINT  uiDevLinesWritten   = cbWritten / lBytesPerScanLineRaw;

      PBYTE pSrc = pBuffer + cbWritten - 1;
      PBYTE pDst = pBuffer + (uiDevLinesWritten * lBytesPerScanLine) - 1;

      while (pSrc >= pBuffer) {
         pDst -= uiPadBytes;

         for (LONG i = 0; i < lBytesPerScanLineRaw; i++) {
            *pDst-- = *pSrc--;
         }
      }
      return uiDevLinesWritten * lBytesPerScanLine;
   }
   return cbWritten;
}

/**************************************************************************\
* UnlinkItemTree
*
*   Call device manager to unlink and release our reference to
*   all items in the driver item tree.
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::DeleteItemTree(void)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::DeleteItemTree");
    HRESULT hr = S_OK;

    //
    // If no tree, return.
    //

    if (!m_pIDrvItemRoot) {
        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("DeleteItemTree, no tree to delete..."));
        return S_OK;
    }

    //
    //  Call device manager to unlink the driver item tree.
    //

    hr = m_pIDrvItemRoot->UnlinkItemTree(WiaItemTypeDisconnected);

    if (SUCCEEDED(hr)) {
        WIAS_LWARNING(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("DeleteItemTree, m_pIDrvItemRoot is being released!!"));
        m_pIDrvItemRoot->Release();
        m_pIDrvItemRoot = NULL;
    }

    return hr;
}

/**************************************************************************\
* BuildItemTree
*
*   The device uses the WIA Service functions to build up a tree of
*   device items. This device supports only a single data acquisition item so
*   build a device item tree with only one child off the root.
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT _stdcall CWIAScannerDevice::BuildItemTree(void)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::BuildItemTree");
    //
    //  The device item tree must not exist.
    //

    WIAS_ASSERT( (g_hInst), (m_pIDrvItemRoot == NULL));

    //
    //  Call the class driver to create the root item.
    //

    HRESULT hr = E_FAIL;

    //
    //  Name the root.
    //

    BSTR bstrRootItemName = NULL;
    hr = GetBSTRResourceString(IDS_ROOTITEM_NAME,&bstrRootItemName,TRUE);
    if (SUCCEEDED(hr)) {
        hr = wiasCreateDrvItem(WiaItemTypeFolder |
                               WiaItemTypeDevice |
                               WiaItemTypeRoot,
                               bstrRootItemName,
                               m_bstrRootFullItemName,
                               (IWiaMiniDrv *)this,
                               sizeof(MINIDRIVERITEMCONTEXT),
                               NULL,
                               &m_pIDrvItemRoot);

        SysFreeString(bstrRootItemName);
    }

    if (FAILED(hr)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildItemTree, wiasCreateDrvItem failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        return hr;
    }

    //
    //  Create and add the Top/Front and Bottom/Back device items.
    //

    for (INT i = 0; i < NUM_DEVICE_ITEM; i++) {

        //
        //  Build the item names.
        //

        BSTR bstrItemName = NULL;
        hr = GetBSTRResourceString(IDS_TOPITEM_NAME,&bstrItemName,TRUE);
        if (SUCCEEDED(hr)) {

            // SBB - RAID 370299 - orenr - 2001/04/18 - Security fix - 
            // potential buffer overrun.  Changed wcscpy and wcscat
            // to use _snwprintf instead

            WCHAR  szFullItemName[MAX_PATH + 1] = {0};
            _snwprintf(szFullItemName,
                       (sizeof(szFullItemName) / sizeof(WCHAR)) - 1,
                       L"%ls\\%ls",
                       m_bstrRootFullItemName,
                       bstrItemName);

            //
            //  Call the class driver to create another driver item.
            //  This will be inserted as the child item.
            //

            PMINIDRIVERITEMCONTEXT pItemContext;
            IWiaDrvItem           *pItem = NULL;

            hr = wiasCreateDrvItem(WiaItemTypeFile  |
                                   WiaItemTypeImage |
                                   WiaItemTypeDevice,
                                   bstrItemName,
                                   szFullItemName,
                                   (IWiaMiniDrv *)this,
                                   sizeof(MINIDRIVERITEMCONTEXT),
                                   (PBYTE*) &pItemContext,
                                   &pItem);

            if (SUCCEEDED(hr)) {

                //
                // Initialize device specific context.
                //

                memset(pItemContext, 0, sizeof(MINIDRIVERITEMCONTEXT));
                pItemContext->lSize = sizeof(MINIDRIVERITEMCONTEXT);

                //
                //  Call the class driver to add pItem to the folder
                //  m_pIDrvItemRoot (i.e. make pItem a child of
                //  m_pIDrvItemRoot).
                //

                hr = pItem->AddItemToFolder(m_pIDrvItemRoot);

                if (FAILED(hr)) {
                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildItemTree, AddItemToFolder failed"));
                    WIAS_LHRESULT(m_pIWiaLog, hr);
                }

                //
                // release and created items
                //

                pItem->Release();

            } else {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildItemTree, wiasCreateDrvItem failed"));
                WIAS_LHRESULT(m_pIWiaLog, hr);
            }

            //
            // free the BSTR allocated by the BSTRResourceString helper
            //

            SysFreeString(bstrItemName);

        } else {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildItemTree, unable to allocate item name"));
            hr = E_OUTOFMEMORY;
        }

        break;  // Error if here, quit iterating.
    }

    if (FAILED(hr)) {
        DeleteItemTree();
    }
    return hr;
}

/**************************************************************************\
* DeleteRootItemProperties
*
*   This helper deletes the arrays used for Property intialization.
*
*       [Array Name]            [Description]          [Array Type]
*
*   m_pszRootItemDefaults - Property name  array         (LPOLESTR)
*   m_piRootItemDefaults  - Property ID array             (PROPID)
*   m_pvRootItemDefaults  - Property Variant array      (PROPVARIANT)
*   m_psRootItemDefaults  - Property Spec array          (PROPSPEC)
*   m_wpiRootItemDefaults - WIA Property Info array  (WIA_PROPERTY_INFO)
*
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT CWIAScannerDevice::DeleteRootItemProperties()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::DeleteRootItemProperties");

    HRESULT hr = S_OK;

    //
    // delete any allocated arrays
    //

    DeleteSupportedPreviewModesArrayContents();

    if(NULL != m_pszRootItemDefaults){
        delete [] m_pszRootItemDefaults;
        m_pszRootItemDefaults = NULL;
    }

    if(NULL != m_piRootItemDefaults){
        delete [] m_piRootItemDefaults;
        m_piRootItemDefaults = NULL;
    }

    if(NULL != m_pvRootItemDefaults){
        FreePropVariantArray(m_NumRootItemProperties,m_pvRootItemDefaults);
        delete [] m_pvRootItemDefaults;
        m_pvRootItemDefaults = NULL;
    }

    if(NULL != m_psRootItemDefaults){
        delete [] m_psRootItemDefaults;
        m_psRootItemDefaults = NULL;
    }

    if(NULL != m_wpiRootItemDefaults){
        delete [] m_wpiRootItemDefaults;
        m_wpiRootItemDefaults = NULL;
    }

    return hr;
}

/**************************************************************************\
* BuildRootItemProperties
*
*   This helper creates/initializes the arrays used for Property intialization.
*
*       [Array Name]            [Description]          [Array Type]
*
*   m_pszRootItemDefaults - Property name  array         (LPOLESTR)
*   m_piRootItemDefaults  - Property ID array             (PROPID)
*   m_pvRootItemDefaults  - Property Variant array      (PROPVARIANT)
*   m_psRootItemDefaults  - Property Spec array          (PROPSPEC)
*   m_wpiRootItemDefaults - WIA Property Info array  (WIA_PROPERTY_INFO)
*
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT CWIAScannerDevice::BuildRootItemProperties()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::BuildRootItemProperties");

    HRESULT hr = S_OK;
    LONG PropIndex = 0;

    //
    // check for ADF
    //

    if(m_pScanAPI->FakeScanner_ADFAttached() == S_OK){
        m_bADFAttached = TRUE;
    }

    //
    // set the number of properties
    //

    if(m_bADFAttached){
        m_NumRootItemProperties = 16;   // standard properties + ADF specific
    } else {
        m_NumRootItemProperties = 7;    // standard properties only
    }

    WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("BuildRootItemProperties, Number of Properties = %d",m_NumRootItemProperties));

    m_pszRootItemDefaults   = new LPOLESTR[m_NumRootItemProperties];
    if(NULL != m_pszRootItemDefaults){
        m_piRootItemDefaults    = new PROPID[m_NumRootItemProperties];
        if (NULL != m_piRootItemDefaults) {
            m_pvRootItemDefaults    = new PROPVARIANT[m_NumRootItemProperties];
            if(NULL != m_pvRootItemDefaults){
                m_psRootItemDefaults    = new PROPSPEC[m_NumRootItemProperties];
                if(NULL != m_psRootItemDefaults){
                    m_wpiRootItemDefaults   = new WIA_PROPERTY_INFO[m_NumRootItemProperties];
                    if(NULL == m_wpiRootItemDefaults)
                        hr = E_OUTOFMEMORY;
                } else
                    hr = E_OUTOFMEMORY;
            } else
                hr = E_OUTOFMEMORY;
        } else
            hr = E_OUTOFMEMORY;
    } else
        hr = E_OUTOFMEMORY;

    if(FAILED(hr)){
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildRootItemProperties, memory allocation failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        DeleteRootItemProperties();
        return hr;
    }

    ROOT_ITEM_INFORMATION RootItemInfo;

    hr = m_pScanAPI->FakeScanner_GetRootPropertyInfo(&RootItemInfo);
    if(FAILED(hr)){
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildRootItemProperties, FakeScanner_GetRootPropertyInfo failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        DeleteRootItemProperties();
        return hr;
    }

    // Intialize WIA_IPA_ACCESS_RIGHTS
    m_pszRootItemDefaults[PropIndex]              = WIA_IPA_ACCESS_RIGHTS_STR;
    m_piRootItemDefaults [PropIndex]              = WIA_IPA_ACCESS_RIGHTS;
    m_pvRootItemDefaults [PropIndex].lVal         = WIA_ITEM_READ|WIA_ITEM_WRITE;
    m_pvRootItemDefaults [PropIndex].vt           = VT_UI4;
    m_psRootItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
    m_psRootItemDefaults [PropIndex].propid       = m_piRootItemDefaults [PropIndex];
    m_wpiRootItemDefaults[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
    m_wpiRootItemDefaults[PropIndex].vt           = m_pvRootItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_DPS_OPTICAL_XRES
    m_pszRootItemDefaults[PropIndex]              = WIA_DPS_OPTICAL_XRES_STR;
    m_piRootItemDefaults [PropIndex]              = WIA_DPS_OPTICAL_XRES;
    m_pvRootItemDefaults [PropIndex].lVal         = RootItemInfo.OpticalXResolution;
    m_pvRootItemDefaults [PropIndex].vt           = VT_I4;
    m_psRootItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
    m_psRootItemDefaults [PropIndex].propid       = m_piRootItemDefaults [PropIndex];
    m_wpiRootItemDefaults[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
    m_wpiRootItemDefaults[PropIndex].vt           = m_pvRootItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_DPS_OPTICAL_YRES
    m_pszRootItemDefaults[PropIndex]              = WIA_DPS_OPTICAL_YRES_STR;
    m_piRootItemDefaults [PropIndex]              = WIA_DPS_OPTICAL_YRES;
    m_pvRootItemDefaults [PropIndex].lVal         = RootItemInfo.OpticalYResolution;
    m_pvRootItemDefaults [PropIndex].vt           = VT_I4;
    m_psRootItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
    m_psRootItemDefaults [PropIndex].propid       = m_piRootItemDefaults [PropIndex];
    m_wpiRootItemDefaults[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
    m_wpiRootItemDefaults[PropIndex].vt           = m_pvRootItemDefaults [PropIndex].vt;

    PropIndex++;

    // Initialize WIA_DPA_FIRMWARE_VERSION
    m_pszRootItemDefaults[PropIndex]              = WIA_DPA_FIRMWARE_VERSION_STR;
    m_piRootItemDefaults [PropIndex]              = WIA_DPA_FIRMWARE_VERSION;
    m_pvRootItemDefaults [PropIndex].bstrVal      = SysAllocString(RootItemInfo.FirmwareVersion);
    m_pvRootItemDefaults [PropIndex].vt           = VT_BSTR;
    m_psRootItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
    m_psRootItemDefaults [PropIndex].propid       = m_piRootItemDefaults [PropIndex];
    m_wpiRootItemDefaults[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
    m_wpiRootItemDefaults[PropIndex].vt           = m_pvRootItemDefaults [PropIndex].vt;

    PropIndex++;

    // Initialize WIA_IPA_ITEM_FLAGS
    m_pszRootItemDefaults[PropIndex]              = WIA_IPA_ITEM_FLAGS_STR;
    m_piRootItemDefaults [PropIndex]              = WIA_IPA_ITEM_FLAGS;
    m_pvRootItemDefaults [PropIndex].lVal         = WiaItemTypeRoot|WiaItemTypeFolder|WiaItemTypeDevice;
    m_pvRootItemDefaults [PropIndex].vt           = VT_I4;
    m_psRootItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
    m_psRootItemDefaults [PropIndex].propid       = m_piRootItemDefaults [PropIndex];
    m_wpiRootItemDefaults[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_FLAG;
    m_wpiRootItemDefaults[PropIndex].vt           = m_pvRootItemDefaults [PropIndex].vt;
    m_wpiRootItemDefaults[PropIndex].ValidVal.Flag.Nom  = m_pvRootItemDefaults [PropIndex].lVal;
    m_wpiRootItemDefaults[PropIndex].ValidVal.Flag.ValidBits = WiaItemTypeRoot|WiaItemTypeFolder|WiaItemTypeDevice;

    PropIndex++;

    // Intialize WIA_DPS_MAX_SCAN_TIME (NONE)
    m_pszRootItemDefaults[PropIndex]                    = WIA_DPS_MAX_SCAN_TIME_STR;
    m_piRootItemDefaults [PropIndex]                    = WIA_DPS_MAX_SCAN_TIME;
    m_pvRootItemDefaults [PropIndex].lVal               = RootItemInfo.MaxScanTime;
    m_pvRootItemDefaults [PropIndex].vt                 = VT_I4;
    m_psRootItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    m_psRootItemDefaults [PropIndex].propid             = m_piRootItemDefaults [PropIndex];
    m_wpiRootItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_wpiRootItemDefaults[PropIndex].vt                 = m_pvRootItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_DPS_PREVIEW (LIST)
    m_pszRootItemDefaults[PropIndex]                    = WIA_DPS_PREVIEW_STR;
    m_piRootItemDefaults [PropIndex]                    = WIA_DPS_PREVIEW;
    m_pvRootItemDefaults [PropIndex].lVal               = WIA_FINAL_SCAN;
    m_pvRootItemDefaults [PropIndex].vt                 = VT_I4;
    m_psRootItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    m_psRootItemDefaults [PropIndex].propid             = m_piRootItemDefaults [PropIndex];
    m_wpiRootItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_LIST;
    m_wpiRootItemDefaults[PropIndex].vt                 = m_pvRootItemDefaults [PropIndex].vt;
    m_wpiRootItemDefaults[PropIndex].ValidVal.List.pList= (BYTE*)m_pSupportedPreviewModes;
    m_wpiRootItemDefaults[PropIndex].ValidVal.List.Nom  = m_pvRootItemDefaults [PropIndex].lVal;
    m_wpiRootItemDefaults[PropIndex].ValidVal.List.cNumList = m_NumSupportedPreviewModes;

    PropIndex++;

    // Initialize WIA_DPS_SHOW_PREVIEW_CONTROL (NONE)
    m_pszRootItemDefaults[PropIndex]                    = WIA_DPS_SHOW_PREVIEW_CONTROL_STR;
    m_piRootItemDefaults [PropIndex]                    = WIA_DPS_SHOW_PREVIEW_CONTROL;
    m_pvRootItemDefaults [PropIndex].lVal               = WIA_DONT_SHOW_PREVIEW_CONTROL;
    m_pvRootItemDefaults [PropIndex].vt                 = VT_I4;
    m_psRootItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    m_psRootItemDefaults [PropIndex].propid             = m_piRootItemDefaults [PropIndex];
    m_wpiRootItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_wpiRootItemDefaults[PropIndex].vt                 = m_pvRootItemDefaults [PropIndex].vt;

    PropIndex++;

    //
    // if a Document feeder is attached...add the following properties
    //

    if(m_bADFAttached) {

        // Initialize WIA_DPS_HORIZONTAL_SHEET_FEED_SIZE
        m_pszRootItemDefaults[PropIndex]              = WIA_DPS_HORIZONTAL_SHEET_FEED_SIZE_STR;
        m_piRootItemDefaults [PropIndex]              = WIA_DPS_HORIZONTAL_SHEET_FEED_SIZE;
        m_pvRootItemDefaults [PropIndex].lVal         = RootItemInfo.DocumentFeederWidth;
        m_pvRootItemDefaults [PropIndex].vt           = VT_I4;
        m_psRootItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
        m_psRootItemDefaults [PropIndex].propid       = m_piRootItemDefaults [PropIndex];
        m_wpiRootItemDefaults[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
        m_wpiRootItemDefaults[PropIndex].vt           = m_pvRootItemDefaults [PropIndex].vt;

        PropIndex++;

        // Initialize WIA_DPS_DOCUMENT_HANDLING_CAPABILITIES
        m_pszRootItemDefaults[PropIndex]              = WIA_DPS_DOCUMENT_HANDLING_CAPABILITIES_STR;
        m_piRootItemDefaults [PropIndex]              = WIA_DPS_DOCUMENT_HANDLING_CAPABILITIES;
        m_pvRootItemDefaults [PropIndex].lVal         = RootItemInfo.DocumentFeederCaps;
        m_pvRootItemDefaults [PropIndex].vt           = VT_I4;
        m_psRootItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
        m_psRootItemDefaults [PropIndex].propid       = m_piRootItemDefaults [PropIndex];
        m_wpiRootItemDefaults[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
        m_wpiRootItemDefaults[PropIndex].vt           = m_pvRootItemDefaults [PropIndex].vt;

        PropIndex++;

        // Initialize WIA_DPS_DOCUMENT_HANDLING_STATUS
        m_pszRootItemDefaults[PropIndex]              = WIA_DPS_DOCUMENT_HANDLING_STATUS_STR;
        m_piRootItemDefaults [PropIndex]              = WIA_DPS_DOCUMENT_HANDLING_STATUS;
        m_pvRootItemDefaults [PropIndex].lVal         = RootItemInfo.DocumentFeederStatus;
        m_pvRootItemDefaults [PropIndex].vt           = VT_I4;
        m_psRootItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
        m_psRootItemDefaults [PropIndex].propid       = m_piRootItemDefaults [PropIndex];
        m_wpiRootItemDefaults[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
        m_wpiRootItemDefaults[PropIndex].vt           = m_pvRootItemDefaults [PropIndex].vt;

        PropIndex++;

        // Initialize WIA_DPS_DOCUMENT_HANDLING_SELECT
        m_pszRootItemDefaults[PropIndex]              = WIA_DPS_DOCUMENT_HANDLING_SELECT_STR;
        m_piRootItemDefaults [PropIndex]              = WIA_DPS_DOCUMENT_HANDLING_SELECT;
        m_pvRootItemDefaults [PropIndex].lVal         = FEEDER;
        m_pvRootItemDefaults [PropIndex].vt           = VT_I4;
        m_psRootItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
        m_psRootItemDefaults [PropIndex].propid       = m_piRootItemDefaults [PropIndex];
        m_wpiRootItemDefaults[PropIndex].lAccessFlags = WIA_PROP_RW|WIA_PROP_FLAG;
        m_wpiRootItemDefaults[PropIndex].vt           = m_pvRootItemDefaults [PropIndex].vt;
        m_wpiRootItemDefaults[PropIndex].ValidVal.Flag.Nom  = m_pvRootItemDefaults [PropIndex].lVal;
        m_wpiRootItemDefaults[PropIndex].ValidVal.Flag.ValidBits = FEEDER | FLATBED;

        PropIndex++;

        // Initialize WIA_DPS_PAGES
        m_pszRootItemDefaults[PropIndex]              = WIA_DPS_PAGES_STR;
        m_piRootItemDefaults [PropIndex]              = WIA_DPS_PAGES;
        m_pvRootItemDefaults [PropIndex].lVal         = 1;
        m_pvRootItemDefaults [PropIndex].vt           = VT_I4;
        m_psRootItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
        m_psRootItemDefaults [PropIndex].propid       = m_piRootItemDefaults [PropIndex];
        m_wpiRootItemDefaults[PropIndex].lAccessFlags = WIA_PROP_RW|WIA_PROP_RANGE;
        m_wpiRootItemDefaults[PropIndex].vt           = m_pvRootItemDefaults [PropIndex].vt;
        m_wpiRootItemDefaults[PropIndex].ValidVal.Range.Inc = 1;
        m_wpiRootItemDefaults[PropIndex].ValidVal.Range.Min = 0;
        m_wpiRootItemDefaults[PropIndex].ValidVal.Range.Max = RootItemInfo.MaxPageCapacity;
        m_wpiRootItemDefaults[PropIndex].ValidVal.Range.Nom = 1;

        PropIndex++;

        // Initialize WIA_DPS_SHEET_FEEDER_REGISTRATION
        m_pszRootItemDefaults[PropIndex]              = WIA_DPS_SHEET_FEEDER_REGISTRATION_STR;
        m_piRootItemDefaults [PropIndex]              = WIA_DPS_SHEET_FEEDER_REGISTRATION;
        m_pvRootItemDefaults [PropIndex].lVal         = RootItemInfo.DocumentFeederReg;
        m_pvRootItemDefaults [PropIndex].vt           = VT_I4;
        m_psRootItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
        m_psRootItemDefaults [PropIndex].propid       = m_piRootItemDefaults [PropIndex];
        m_wpiRootItemDefaults[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
        m_wpiRootItemDefaults[PropIndex].vt           = m_pvRootItemDefaults [PropIndex].vt;

        PropIndex++;

        // Initialize WIA_DPS_HORIZONTAL_BED_REGISTRATION
        m_pszRootItemDefaults[PropIndex]              = WIA_DPS_HORIZONTAL_BED_REGISTRATION_STR;
        m_piRootItemDefaults [PropIndex]              = WIA_DPS_HORIZONTAL_BED_REGISTRATION;
        m_pvRootItemDefaults [PropIndex].lVal         = RootItemInfo.DocumentFeederHReg;
        m_pvRootItemDefaults [PropIndex].vt           = VT_I4;
        m_psRootItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
        m_psRootItemDefaults [PropIndex].propid       = m_piRootItemDefaults [PropIndex];
        m_wpiRootItemDefaults[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
        m_wpiRootItemDefaults[PropIndex].vt           = m_pvRootItemDefaults [PropIndex].vt;

        PropIndex++;

        // Initialize WIA_DPS_VERTICAL_BED_REGISTRATION
        m_pszRootItemDefaults[PropIndex]              = WIA_DPS_VERTICAL_BED_REGISTRATION_STR;
        m_piRootItemDefaults [PropIndex]              = WIA_DPS_VERTICAL_BED_REGISTRATION;
        m_pvRootItemDefaults [PropIndex].lVal         = RootItemInfo.DocumentFeederVReg;
        m_pvRootItemDefaults [PropIndex].vt           = VT_I4;
        m_psRootItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
        m_psRootItemDefaults [PropIndex].propid       = m_piRootItemDefaults [PropIndex];
        m_wpiRootItemDefaults[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
        m_wpiRootItemDefaults[PropIndex].vt           = m_pvRootItemDefaults [PropIndex].vt;

        PropIndex++;

    }
    return hr;
}

/**************************************************************************\
* DeleteTopItemProperties
*
*   This helper deletes the arrays used for Property intialization.
*
*       [Array Name]            [Description]          [Array Type]
*
*   m_pszItemDefaults - Property name  array         (LPOLESTR)
*   m_piItemDefaults  - Property ID array             (PROPID)
*   m_pvItemDefaults  - Property Variant array      (PROPVARIANT)
*   m_psItemDefaults  - Property Spec array          (PROPSPEC)
*   m_wpiItemDefaults - WIA Property Info array  (WIA_PROPERTY_INFO)
*
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT CWIAScannerDevice::DeleteTopItemProperties()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::DeleteTopItemProperties");

    HRESULT hr = S_OK;

    //
    // delete any allocated arrays
    //

    DeleteSupportedFormatsArrayContents();
    DeleteSupportedDataTypesArrayContents();
    DeleteSupportedCompressionsArrayContents();
    DeleteSupportedTYMEDArrayContents();
    DeleteInitialFormatsArrayContents();
    DeleteSupportedResolutionsArrayContents();

    if(NULL != m_pszItemDefaults){
        delete [] m_pszItemDefaults;
        m_pszItemDefaults = NULL;
    }

    if(NULL != m_piItemDefaults){
        delete [] m_piItemDefaults;
        m_piItemDefaults = NULL;
    }

    if(NULL != m_pvItemDefaults){
        for(LONG lPropIndex = 0; lPropIndex < m_NumItemProperties; lPropIndex++){

            //
            // set CLSID pointers to NULL, because we freed the memory above.
            // If this pointer is not NULL FreePropVariantArray would
            // try to free it again.
            //

            if(m_pvItemDefaults[lPropIndex].vt == VT_CLSID){
                m_pvItemDefaults[lPropIndex].puuid = NULL;
            }
        }
        FreePropVariantArray(m_NumItemProperties,m_pvItemDefaults);
        delete [] m_pvItemDefaults;
        m_pvItemDefaults = NULL;
    }

    if(NULL != m_psItemDefaults){
        delete [] m_psItemDefaults;
        m_psItemDefaults = NULL;
    }

    if(NULL != m_wpiItemDefaults){
        delete [] m_wpiItemDefaults;
        m_wpiItemDefaults = NULL;
    }

    return hr;
}

/**************************************************************************\
* BuildTopItemProperties
*
*   This helper creates/initializes the arrays used for Property intialization.
*
*       [Array Name]        [Description]           [Array Type]
*
*   m_pszItemDefaults - Property name  array         (LPOLESTR)
*   m_piItemDefaults  - Property ID array             (PROPID)
*   m_pvItemDefaults  - Property Variant array      (PROPVARIANT)
*   m_psItemDefaults  - Property Spec array          (PROPSPEC)
*   m_wpiItemDefaults - WIA Property Info array  (WIA_PROPERTY_INFO)
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT CWIAScannerDevice::BuildTopItemProperties()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::BuildTopItemProperties");

    HRESULT hr = S_OK;

    m_NumItemProperties = 27;
    m_pszItemDefaults   = new LPOLESTR[m_NumItemProperties];
    if(NULL != m_pszItemDefaults){
        m_piItemDefaults    = new PROPID[m_NumItemProperties];
        if (NULL != m_piItemDefaults) {
            m_pvItemDefaults    = new PROPVARIANT[m_NumItemProperties];
            if(NULL != m_pvItemDefaults){
                m_psItemDefaults    = new PROPSPEC[m_NumItemProperties];
                if(NULL != m_psItemDefaults){
                    m_wpiItemDefaults   = new WIA_PROPERTY_INFO[m_NumItemProperties];
                    if(NULL == m_wpiItemDefaults)
                        hr = E_OUTOFMEMORY;
                } else
                    hr = E_OUTOFMEMORY;
            } else
                hr = E_OUTOFMEMORY;
        } else
            hr = E_OUTOFMEMORY;
    } else
        hr = E_OUTOFMEMORY;

    if(FAILED(hr)){
        DeleteTopItemProperties();
        return hr;
    }

    ROOT_ITEM_INFORMATION RootItemInfo;
    hr = m_pScanAPI->FakeScanner_GetRootPropertyInfo(&RootItemInfo);
    if(FAILED(hr)){
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildTopItemProperties, FakeScanner_GetRootPropertyInfo failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        DeleteTopItemProperties();
        return hr;
    }

    TOP_ITEM_INFORMATION TopItemInfo;
    hr = m_pScanAPI->FakeScanner_GetTopPropertyInfo(&TopItemInfo);
    if(FAILED(hr)){
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("BuildTopItemProperties, FakeScanner_GetTopPropertyInfo failed"));
        WIAS_LHRESULT(m_pIWiaLog, hr);
        DeleteTopItemProperties();
        return hr;
    }

    LONG PropIndex = 0;

    if (TopItemInfo.bUseResolutionList) {

        // Intialize WIA_IPS_XRES (LIST)
        m_pszItemDefaults[PropIndex]                    = WIA_IPS_XRES_STR;
        m_piItemDefaults [PropIndex]                    = WIA_IPS_XRES;
        m_pvItemDefaults [PropIndex].lVal               = m_pSupportedResolutions[PropIndex];
        m_pvItemDefaults [PropIndex].vt                 = VT_I4;
        m_psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
        m_psItemDefaults [PropIndex].propid             = m_piItemDefaults [PropIndex];
        m_wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_LIST;
        m_wpiItemDefaults[PropIndex].vt                 = m_pvItemDefaults [PropIndex].vt;
        m_wpiItemDefaults[PropIndex].ValidVal.List.pList= (BYTE*)m_pSupportedResolutions;
        m_wpiItemDefaults[PropIndex].ValidVal.List.Nom  = m_pvItemDefaults [PropIndex].lVal;
        m_wpiItemDefaults[PropIndex].ValidVal.List.cNumList = m_NumSupportedResolutions;

        PropIndex++;

        // Intialize WIA_IPS_YRES (LIST)
        m_pszItemDefaults[PropIndex]                    = WIA_IPS_YRES_STR;
        m_piItemDefaults [PropIndex]                    = WIA_IPS_YRES;
        m_pvItemDefaults [PropIndex].lVal               = m_pSupportedResolutions[PropIndex-1];
        m_pvItemDefaults [PropIndex].vt                 = VT_I4;
        m_psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
        m_psItemDefaults [PropIndex].propid             = m_piItemDefaults [PropIndex];
        m_wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_LIST;
        m_wpiItemDefaults[PropIndex].vt                 = m_pvItemDefaults [PropIndex].vt;
        m_wpiItemDefaults[PropIndex].ValidVal.List.pList= (BYTE*)m_pSupportedResolutions;
        m_wpiItemDefaults[PropIndex].ValidVal.List.Nom  = m_pvItemDefaults [PropIndex].lVal;
        m_wpiItemDefaults[PropIndex].ValidVal.List.cNumList = m_NumSupportedResolutions;

        PropIndex++;

    } else {
        // we have a range
        // Intialize WIA_IPS_XRES (RANGE)
        m_pszItemDefaults[PropIndex]                    = WIA_IPS_XRES_STR;
        m_piItemDefaults [PropIndex]                    = WIA_IPS_XRES;
        m_pvItemDefaults [PropIndex].lVal               = TopItemInfo.XResolution.lNom;
        m_pvItemDefaults [PropIndex].vt                 = VT_I4;
        m_psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
        m_psItemDefaults [PropIndex].propid             = m_piItemDefaults [PropIndex];
        m_wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
        m_wpiItemDefaults[PropIndex].vt                 = m_pvItemDefaults [PropIndex].vt;
        m_wpiItemDefaults[PropIndex].ValidVal.Range.Inc = TopItemInfo.XResolution.lInc;
        m_wpiItemDefaults[PropIndex].ValidVal.Range.Min = TopItemInfo.XResolution.lMin;
        m_wpiItemDefaults[PropIndex].ValidVal.Range.Max = TopItemInfo.XResolution.lMax;
        m_wpiItemDefaults[PropIndex].ValidVal.Range.Nom = TopItemInfo.XResolution.lNom;

        PropIndex++;

        // Intialize WIA_IPS_YRES (RANGE)
        m_pszItemDefaults[PropIndex]                    = WIA_IPS_YRES_STR;
        m_piItemDefaults [PropIndex]                    = WIA_IPS_YRES;
        m_pvItemDefaults [PropIndex].lVal               = TopItemInfo.YResolution.lNom;
        m_pvItemDefaults [PropIndex].vt                 = VT_I4;
        m_psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
        m_psItemDefaults [PropIndex].propid             = m_piItemDefaults [PropIndex];
        m_wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
        m_wpiItemDefaults[PropIndex].vt                 = m_pvItemDefaults [PropIndex].vt;
        m_wpiItemDefaults[PropIndex].ValidVal.Range.Inc = TopItemInfo.YResolution.lInc;
        m_wpiItemDefaults[PropIndex].ValidVal.Range.Min = TopItemInfo.YResolution.lMin;
        m_wpiItemDefaults[PropIndex].ValidVal.Range.Max = TopItemInfo.YResolution.lMax;
        m_wpiItemDefaults[PropIndex].ValidVal.Range.Nom = TopItemInfo.YResolution.lNom;

        PropIndex++;
    }

    // Intialize WIA_IPS_XEXTENT (RANGE)
    m_pszItemDefaults[PropIndex]                    = WIA_IPS_XEXTENT_STR;
    m_piItemDefaults [PropIndex]                    = WIA_IPS_XEXTENT;
    m_pvItemDefaults [PropIndex].lVal               = (m_pvItemDefaults [PropIndex-2].lVal * RootItemInfo.ScanBedWidth)/1000;
    m_pvItemDefaults [PropIndex].vt                 = VT_I4;
    m_psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    m_psItemDefaults [PropIndex].propid             = m_piItemDefaults [PropIndex];
    m_wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_wpiItemDefaults[PropIndex].vt                 = m_pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPS_XPOS (NONE)
    m_pszItemDefaults[PropIndex]                    = WIA_IPS_XPOS_STR;
    m_piItemDefaults [PropIndex]                    = WIA_IPS_XPOS;
    m_pvItemDefaults [PropIndex].lVal               = 0;
    m_pvItemDefaults [PropIndex].vt                 = VT_I4;
    m_psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    m_psItemDefaults [PropIndex].propid             = m_piItemDefaults [PropIndex];
    m_wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_wpiItemDefaults[PropIndex].vt                 = m_pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPS_YPOS (NONE)
    m_pszItemDefaults[PropIndex]                    = WIA_IPS_YPOS_STR;
    m_piItemDefaults [PropIndex]                    = WIA_IPS_YPOS;
    m_pvItemDefaults [PropIndex].lVal               = 0;
    m_pvItemDefaults [PropIndex].vt                 = VT_I4;
    m_psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    m_psItemDefaults [PropIndex].propid             = m_piItemDefaults [PropIndex];
    m_wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_wpiItemDefaults[PropIndex].vt                 = m_pvItemDefaults [PropIndex].vt;


    PropIndex++;

    // Intialize WIA_IPA_DATATYPE (LIST)
    m_pszItemDefaults[PropIndex]                    = WIA_IPA_DATATYPE_STR;
    m_piItemDefaults [PropIndex]                    = WIA_IPA_DATATYPE;
    m_pvItemDefaults [PropIndex].lVal               = INITIAL_DATATYPE;
    m_pvItemDefaults [PropIndex].vt                 = VT_I4;
    m_psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    m_psItemDefaults [PropIndex].propid             = m_piItemDefaults [PropIndex];
    m_wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_LIST;
    m_wpiItemDefaults[PropIndex].vt                 = m_pvItemDefaults [PropIndex].vt;

    m_wpiItemDefaults[PropIndex].ValidVal.List.pList    = (BYTE*)m_pSupportedDataTypes;
    m_wpiItemDefaults[PropIndex].ValidVal.List.Nom      = m_pvItemDefaults [PropIndex].lVal;
    m_wpiItemDefaults[PropIndex].ValidVal.List.cNumList = m_NumSupportedDataTypes;

    PropIndex++;

    // Intialize WIA_IPA_DEPTH (NONE)
    m_pszItemDefaults[PropIndex]                    = WIA_IPA_DEPTH_STR;
    m_piItemDefaults [PropIndex]                    = WIA_IPA_DEPTH;
    m_pvItemDefaults [PropIndex].lVal               = INITIAL_BITDEPTH;
    m_pvItemDefaults [PropIndex].vt                 = VT_I4;
    m_psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    m_psItemDefaults [PropIndex].propid             = m_piItemDefaults [PropIndex];
    m_wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_wpiItemDefaults[PropIndex].vt                 = m_pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPS_BRIGHTNESS (RANGE)
    m_pszItemDefaults[PropIndex]                    = WIA_IPS_BRIGHTNESS_STR;
    m_piItemDefaults [PropIndex]                    = WIA_IPS_BRIGHTNESS;
    m_pvItemDefaults [PropIndex].lVal               = TopItemInfo.Brightness.lNom;
    m_pvItemDefaults [PropIndex].vt                 = VT_I4;
    m_psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    m_psItemDefaults [PropIndex].propid             = m_piItemDefaults [PropIndex];
    m_wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
    m_wpiItemDefaults[PropIndex].vt                 = m_pvItemDefaults [PropIndex].vt;
    m_wpiItemDefaults[PropIndex].ValidVal.Range.Inc = TopItemInfo.Brightness.lInc;
    m_wpiItemDefaults[PropIndex].ValidVal.Range.Min = TopItemInfo.Brightness.lMin;
    m_wpiItemDefaults[PropIndex].ValidVal.Range.Max = TopItemInfo.Brightness.lMax;
    m_wpiItemDefaults[PropIndex].ValidVal.Range.Nom = TopItemInfo.Brightness.lNom;

    PropIndex++;

    // Intialize WIA_IPS_CONTRAST (RANGE)
    m_pszItemDefaults[PropIndex]                    = WIA_IPS_CONTRAST_STR;
    m_piItemDefaults [PropIndex]                    = WIA_IPS_CONTRAST;
    m_pvItemDefaults [PropIndex].lVal               = TopItemInfo.Contrast.lNom;
    m_pvItemDefaults [PropIndex].vt                 = VT_I4;
    m_psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    m_psItemDefaults [PropIndex].propid             = m_piItemDefaults [PropIndex];
    m_wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
    m_wpiItemDefaults[PropIndex].vt                 = m_pvItemDefaults [PropIndex].vt;
    m_wpiItemDefaults[PropIndex].ValidVal.Range.Inc = TopItemInfo.Contrast.lInc;
    m_wpiItemDefaults[PropIndex].ValidVal.Range.Min = TopItemInfo.Contrast.lMin;
    m_wpiItemDefaults[PropIndex].ValidVal.Range.Max = TopItemInfo.Contrast.lMax;
    m_wpiItemDefaults[PropIndex].ValidVal.Range.Nom = TopItemInfo.Contrast.lNom;

    PropIndex++;

    // Intialize WIA_IPS_CUR_INTENT (FLAG)
    m_pszItemDefaults[PropIndex]                    = WIA_IPS_CUR_INTENT_STR;
    m_piItemDefaults [PropIndex]                    = WIA_IPS_CUR_INTENT;
    m_pvItemDefaults [PropIndex].lVal               = WIA_INTENT_NONE;
    m_pvItemDefaults [PropIndex].vt                 = VT_I4;
    m_psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    m_psItemDefaults [PropIndex].propid             = m_piItemDefaults [PropIndex];
    m_wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_FLAG;
    m_wpiItemDefaults[PropIndex].vt                 = m_pvItemDefaults [PropIndex].vt;
    m_wpiItemDefaults[PropIndex].ValidVal.Flag.Nom  = m_pvItemDefaults [PropIndex].lVal;
    m_wpiItemDefaults[PropIndex].ValidVal.Flag.ValidBits = WIA_INTENT_IMAGE_TYPE_COLOR | WIA_INTENT_IMAGE_TYPE_GRAYSCALE |
                                                           WIA_INTENT_IMAGE_TYPE_TEXT  | WIA_INTENT_MINIMIZE_SIZE |
                                                           WIA_INTENT_MAXIMIZE_QUALITY;

    PropIndex++;

    // Intialize WIA_IPA_PIXELS_PER_LINE (NONE)
    m_pszItemDefaults[PropIndex]                    = WIA_IPA_PIXELS_PER_LINE_STR;
    m_piItemDefaults [PropIndex]                    = WIA_IPA_PIXELS_PER_LINE;
    m_pvItemDefaults [PropIndex].lVal               = m_pvItemDefaults[PropIndex-8].lVal;
    m_pvItemDefaults [PropIndex].vt                 = VT_I4;
    m_psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    m_psItemDefaults [PropIndex].propid             = m_piItemDefaults [PropIndex];
    m_wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_wpiItemDefaults[PropIndex].vt                 = m_pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPA_NUMER_OF_LINES (NONE)
    m_pszItemDefaults[PropIndex]                    = WIA_IPA_NUMBER_OF_LINES_STR;
    m_piItemDefaults [PropIndex]                    = WIA_IPA_NUMBER_OF_LINES;
    m_pvItemDefaults [PropIndex].lVal               = 0;
    m_pvItemDefaults [PropIndex].vt                 = VT_I4;
    m_psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    m_psItemDefaults [PropIndex].propid             = m_piItemDefaults [PropIndex];
    m_wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_wpiItemDefaults[PropIndex].vt                 = m_pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPA_PREFERRED_FORMAT (NONE)
    m_pszItemDefaults[PropIndex]                    = WIA_IPA_PREFERRED_FORMAT_STR;
    m_piItemDefaults [PropIndex]                    = WIA_IPA_PREFERRED_FORMAT;
    m_pvItemDefaults [PropIndex].puuid              = &m_pInitialFormats[0];
    m_pvItemDefaults [PropIndex].vt                 = VT_CLSID;
    m_psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    m_psItemDefaults [PropIndex].propid             = m_piItemDefaults [PropIndex];
    m_wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_wpiItemDefaults[PropIndex].vt                 = m_pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPA_ITEM_SIZE (NONE)
    m_pszItemDefaults[PropIndex]                    = WIA_IPA_ITEM_SIZE_STR;
    m_piItemDefaults [PropIndex]                    = WIA_IPA_ITEM_SIZE;
    m_pvItemDefaults [PropIndex].lVal               = 0;
    m_pvItemDefaults [PropIndex].vt                 = VT_I4;
    m_psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    m_psItemDefaults [PropIndex].propid             = m_piItemDefaults [PropIndex];
    m_wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_wpiItemDefaults[PropIndex].vt                 = m_pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPS_THRESHOLD (RANGE)
    m_pszItemDefaults[PropIndex]                    = WIA_IPS_THRESHOLD_STR;
    m_piItemDefaults [PropIndex]                    = WIA_IPS_THRESHOLD;
    m_pvItemDefaults [PropIndex].lVal               = TopItemInfo.Threshold.lNom;
    m_pvItemDefaults [PropIndex].vt                 = VT_I4;
    m_psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    m_psItemDefaults [PropIndex].propid             = m_piItemDefaults [PropIndex];
    m_wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_RANGE;
    m_wpiItemDefaults[PropIndex].vt                 = m_pvItemDefaults [PropIndex].vt;
    m_wpiItemDefaults[PropIndex].ValidVal.Range.Inc = TopItemInfo.Threshold.lInc;
    m_wpiItemDefaults[PropIndex].ValidVal.Range.Min = TopItemInfo.Threshold.lMin;
    m_wpiItemDefaults[PropIndex].ValidVal.Range.Max = TopItemInfo.Threshold.lMax;
    m_wpiItemDefaults[PropIndex].ValidVal.Range.Nom = TopItemInfo.Threshold.lNom;

    PropIndex++;

    // Intialize WIA_IPA_FORMAT (LIST)
    m_pszItemDefaults[PropIndex]                    = WIA_IPA_FORMAT_STR;
    m_piItemDefaults [PropIndex]                    = WIA_IPA_FORMAT;
    m_pvItemDefaults [PropIndex].puuid              = &m_pInitialFormats[0];
    m_pvItemDefaults [PropIndex].vt                 = VT_CLSID;
    m_psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    m_psItemDefaults [PropIndex].propid             = m_piItemDefaults [PropIndex];
    m_wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_LIST;
    m_wpiItemDefaults[PropIndex].vt                 = m_pvItemDefaults [PropIndex].vt;

    m_wpiItemDefaults[PropIndex].ValidVal.ListGuid.pList    = m_pInitialFormats;
    m_wpiItemDefaults[PropIndex].ValidVal.ListGuid.Nom      = *m_pvItemDefaults[PropIndex].puuid;
    m_wpiItemDefaults[PropIndex].ValidVal.ListGuid.cNumList = m_NumInitialFormats;

    PropIndex++;

    // Intialize WIA_IPA_TYMED (LIST)
    m_pszItemDefaults[PropIndex]                    = WIA_IPA_TYMED_STR;
    m_piItemDefaults [PropIndex]                    = WIA_IPA_TYMED;
    m_pvItemDefaults [PropIndex].lVal               = INITIAL_TYMED;
    m_pvItemDefaults [PropIndex].vt                 = VT_I4;
    m_psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    m_psItemDefaults [PropIndex].propid             = m_piItemDefaults [PropIndex];
    m_wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_LIST;
    m_wpiItemDefaults[PropIndex].vt                 = m_pvItemDefaults [PropIndex].vt;

    m_wpiItemDefaults[PropIndex].ValidVal.List.pList    = (BYTE*)m_pSupportedTYMED;
    m_wpiItemDefaults[PropIndex].ValidVal.List.Nom      = m_pvItemDefaults [PropIndex].lVal;
    m_wpiItemDefaults[PropIndex].ValidVal.List.cNumList = m_NumSupportedTYMED;

    PropIndex++;

    // Intialize WIA_IPA_CHANNELS_PER_PIXEL (NONE)
    m_pszItemDefaults[PropIndex]                    = WIA_IPA_CHANNELS_PER_PIXEL_STR;
    m_piItemDefaults [PropIndex]                    = WIA_IPA_CHANNELS_PER_PIXEL;
    m_pvItemDefaults [PropIndex].lVal               = INITIAL_CHANNELS_PER_PIXEL;
    m_pvItemDefaults [PropIndex].vt                 = VT_I4;
    m_psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    m_psItemDefaults [PropIndex].propid             = m_piItemDefaults [PropIndex];
    m_wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_wpiItemDefaults[PropIndex].vt                 = m_pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPA_BITS_PER_CHANNEL (NONE)
    m_pszItemDefaults[PropIndex]                    = WIA_IPA_BITS_PER_CHANNEL_STR;
    m_piItemDefaults [PropIndex]                    = WIA_IPA_BITS_PER_CHANNEL;
    m_pvItemDefaults [PropIndex].lVal               = INITIAL_BITS_PER_CHANNEL;
    m_pvItemDefaults [PropIndex].vt                 = VT_I4;
    m_psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    m_psItemDefaults [PropIndex].propid             = m_piItemDefaults [PropIndex];
    m_wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_wpiItemDefaults[PropIndex].vt                 = m_pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPA_PLANAR (NONE)
    m_pszItemDefaults[PropIndex]                    = WIA_IPA_PLANAR_STR;
    m_piItemDefaults [PropIndex]                    = WIA_IPA_PLANAR;
    m_pvItemDefaults [PropIndex].lVal               = INITIAL_PLANAR;
    m_pvItemDefaults [PropIndex].vt                 = VT_I4;
    m_psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    m_psItemDefaults [PropIndex].propid             = m_piItemDefaults [PropIndex];
    m_wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_wpiItemDefaults[PropIndex].vt                 = m_pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPA_BYTES_PER_LINE (NONE)
    m_pszItemDefaults[PropIndex]                    = WIA_IPA_BYTES_PER_LINE_STR;
    m_piItemDefaults [PropIndex]                    = WIA_IPA_BYTES_PER_LINE;
    m_pvItemDefaults [PropIndex].lVal               = 0;
    m_pvItemDefaults [PropIndex].vt                 = VT_I4;
    m_psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    m_psItemDefaults [PropIndex].propid             = m_piItemDefaults [PropIndex];
    m_wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_wpiItemDefaults[PropIndex].vt                 = m_pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPA_MIN_BUFFER_SIZE (NONE)
    m_pszItemDefaults[PropIndex]                    = WIA_IPA_MIN_BUFFER_SIZE_STR;
    m_piItemDefaults [PropIndex]                    = WIA_IPA_MIN_BUFFER_SIZE;
    m_pvItemDefaults [PropIndex].lVal               = TopItemInfo.lMinimumBufferSize;
    m_pvItemDefaults [PropIndex].vt                 = VT_I4;
    m_psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    m_psItemDefaults [PropIndex].propid             = m_piItemDefaults [PropIndex];
    m_wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_wpiItemDefaults[PropIndex].vt                 = m_pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPA_ACCESS_RIGHTS (NONE)
    m_pszItemDefaults[PropIndex]                    = WIA_IPA_ACCESS_RIGHTS_STR;
    m_piItemDefaults [PropIndex]                    = WIA_IPA_ACCESS_RIGHTS;
    m_pvItemDefaults [PropIndex].lVal               = WIA_ITEM_READ|WIA_ITEM_WRITE;
    m_pvItemDefaults [PropIndex].vt                 = VT_I4;
    m_psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    m_psItemDefaults [PropIndex].propid             = m_piItemDefaults [PropIndex];
    m_wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_wpiItemDefaults[PropIndex].vt                 = m_pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPA_COMPRESSION (LIST)
    m_pszItemDefaults[PropIndex]                    = WIA_IPA_COMPRESSION_STR;
    m_piItemDefaults [PropIndex]                    = WIA_IPA_COMPRESSION;
    m_pvItemDefaults [PropIndex].lVal               = INITIAL_COMPRESSION;
    m_pvItemDefaults [PropIndex].vt                 = VT_I4;
    m_psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    m_psItemDefaults [PropIndex].propid             = m_piItemDefaults [PropIndex];
    m_wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_RW|WIA_PROP_LIST;
    m_wpiItemDefaults[PropIndex].vt                 = m_pvItemDefaults [PropIndex].vt;

    m_wpiItemDefaults[PropIndex].ValidVal.List.pList    = (BYTE*)m_pSupportedCompressionTypes;
    m_wpiItemDefaults[PropIndex].ValidVal.List.Nom      = m_pvItemDefaults [PropIndex].lVal;
    m_wpiItemDefaults[PropIndex].ValidVal.List.cNumList = m_NumSupportedCompressionTypes;

    PropIndex++;

    // Initialize WIA_IPA_ITEM_FLAGS
    m_pszItemDefaults[PropIndex]              = WIA_IPA_ITEM_FLAGS_STR;
    m_piItemDefaults [PropIndex]              = WIA_IPA_ITEM_FLAGS;
    m_pvItemDefaults [PropIndex].lVal         = WiaItemTypeImage|WiaItemTypeFile|WiaItemTypeDevice;
    m_pvItemDefaults [PropIndex].vt           = VT_I4;
    m_psItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
    m_psItemDefaults [PropIndex].propid       = m_piItemDefaults [PropIndex];
    m_wpiItemDefaults[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_FLAG;
    m_wpiItemDefaults[PropIndex].vt           = m_pvItemDefaults [PropIndex].vt;
    m_wpiItemDefaults[PropIndex].ValidVal.Flag.Nom  = m_pvItemDefaults [PropIndex].lVal;
    m_wpiItemDefaults[PropIndex].ValidVal.Flag.ValidBits = WiaItemTypeImage|WiaItemTypeFile|WiaItemTypeDevice;

    PropIndex++;

    // Initialize WIA_IPS_PHOTOMETRIC_INTERP
    m_pszItemDefaults[PropIndex]              = WIA_IPS_PHOTOMETRIC_INTERP_STR;
    m_piItemDefaults [PropIndex]              = WIA_IPS_PHOTOMETRIC_INTERP;
    m_pvItemDefaults [PropIndex].lVal         = INITIAL_PHOTOMETRIC_INTERP;
    m_pvItemDefaults [PropIndex].vt           = VT_I4;
    m_psItemDefaults [PropIndex].ulKind       = PRSPEC_PROPID;
    m_psItemDefaults [PropIndex].propid       = m_piItemDefaults [PropIndex];
    m_wpiItemDefaults[PropIndex].lAccessFlags = WIA_PROP_READ|WIA_PROP_NONE;
    m_wpiItemDefaults[PropIndex].vt           = m_pvItemDefaults [PropIndex].vt;

    PropIndex++;

    // Intialize WIA_IPS_WARM_UP_TIME_STR (NONE)
    m_pszItemDefaults[PropIndex]                    = WIA_IPS_WARM_UP_TIME_STR;
    m_piItemDefaults [PropIndex]                    = WIA_IPS_WARM_UP_TIME;
    m_pvItemDefaults [PropIndex].lVal               = TopItemInfo.lMaxLampWarmupTime;
    m_pvItemDefaults [PropIndex].vt                 = VT_I4;
    m_psItemDefaults [PropIndex].ulKind             = PRSPEC_PROPID;
    m_psItemDefaults [PropIndex].propid             = m_piItemDefaults [PropIndex];
    m_wpiItemDefaults[PropIndex].lAccessFlags       = WIA_PROP_READ|WIA_PROP_NONE;
    m_wpiItemDefaults[PropIndex].vt                 = m_pvItemDefaults [PropIndex].vt;

    PropIndex++;

    return hr;
}

/**************************************************************************\
* BuildSupportedResolutions
*
*   This helper initializes the supported resolution array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::BuildSupportedResolutions()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::BuildSupportedResolutions");

    HRESULT hr = S_OK;
    if(NULL != m_pSupportedResolutions) {

        //
        // Supported intents have already been initialized,
        // so return S_OK.
        //

        return hr;
    }
    m_NumSupportedResolutions   = 6;
    m_pSupportedResolutions     = new LONG[m_NumSupportedResolutions];
    if(m_pSupportedResolutions){
        m_pSupportedResolutions[0] = 75;
        m_pSupportedResolutions[1] = 100;
        m_pSupportedResolutions[2] = 150;
        m_pSupportedResolutions[3] = 200;
        m_pSupportedResolutions[4] = 300;
        m_pSupportedResolutions[5] = 600;
    } else
        hr = E_OUTOFMEMORY;
    return hr;
}
/**************************************************************************\
* DeleteSupportedResolutionsArrayContents
*
*   This helper deletes the supported resolutions array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::DeleteSupportedResolutionsArrayContents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::DeleteSupportedResolutionsArrayContents");

    HRESULT hr = S_OK;
    if(NULL != m_pSupportedResolutions)
        delete [] m_pSupportedResolutions;

    m_pSupportedResolutions     = NULL;
    m_NumSupportedResolutions   = 0;
    return hr;
}

/**************************************************************************\
* BuildSupportedIntents
*
*   This helper initializes the supported intent array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::BuildSupportedIntents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::BuildSupportedIntents");

    HRESULT hr = S_OK;
    if(NULL != m_pSupportedIntents) {

        //
        // Supported intents have already been initialized,
        // so return S_OK.
        //

        return hr;
    }
    m_NumSupportedIntents   = 6;
    m_pSupportedIntents     = new LONG[m_NumSupportedIntents];
    if(m_pSupportedIntents){
        m_pSupportedIntents[0] = WIA_INTENT_NONE;
        m_pSupportedIntents[1] = WIA_INTENT_IMAGE_TYPE_COLOR;
        m_pSupportedIntents[2] = WIA_INTENT_IMAGE_TYPE_GRAYSCALE;
        m_pSupportedIntents[3] = WIA_INTENT_IMAGE_TYPE_TEXT;
        m_pSupportedIntents[4] = WIA_INTENT_MINIMIZE_SIZE;
        m_pSupportedIntents[5] = WIA_INTENT_MAXIMIZE_QUALITY;
    } else
        hr = E_OUTOFMEMORY;
    return hr;
}
/**************************************************************************\
* DeleteSupportedIntentsArrayContents
*
*   This helper deletes the supported intent array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::DeleteSupportedIntentsArrayContents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::DeleteSupportedIntentsArrayContents");

    HRESULT hr = S_OK;
    if(NULL != m_pSupportedIntents)
        delete [] m_pSupportedIntents;

    m_pSupportedIntents     = NULL;
    m_NumSupportedIntents   = 0;
    return hr;
}
/**************************************************************************\
* BuildSupportedCompressions
*
*   This helper initializes the supported compression types array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::BuildSupportedCompressions()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::BuildSupportedCompressions");

    HRESULT hr = S_OK;
    if(NULL != m_pSupportedCompressionTypes) {

        //
        // Supported compression types have already been initialized,
        // so return S_OK.
        //

        return hr;
    }

    m_NumSupportedCompressionTypes  = 1;
    m_pSupportedCompressionTypes    = new LONG[m_NumSupportedCompressionTypes];
    if(m_pSupportedCompressionTypes){
        m_pSupportedCompressionTypes[0] = WIA_COMPRESSION_NONE;
    } else
        hr = E_OUTOFMEMORY;
    return hr;
}
/**************************************************************************\
* DeleteSupportedCompressionsArrayContents
*
*   This helper deletes the supported compression types array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::DeleteSupportedCompressionsArrayContents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::DeleteSupportedCompressionsArrayContents");

    HRESULT hr = S_OK;
    if (NULL != m_pSupportedCompressionTypes)
        delete [] m_pSupportedCompressionTypes;

    m_pSupportedCompressionTypes     = NULL;
    m_NumSupportedCompressionTypes   = 0;
    return hr;
}

/**************************************************************************\
* BuildSupportedPreviewModes
*
*   This helper initializes the supported preview mode array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    8/17/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::BuildSupportedPreviewModes()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::BuildSupportedPreviewModes");

    HRESULT hr = S_OK;
    if(NULL != m_pSupportedPreviewModes) {

        //
        // Supported preview modes have already been initialized,
        // so return S_OK.
        //

        return hr;
    }

    m_NumSupportedPreviewModes  = 1;
    m_pSupportedPreviewModes    = new LONG[m_NumSupportedPreviewModes];
    if(m_pSupportedPreviewModes){
        m_pSupportedPreviewModes[0] = WIA_FINAL_SCAN;
    } else
        hr = E_OUTOFMEMORY;
    return hr;
}
/**************************************************************************\
* DeleteSupportedCompressionsArrayContents
*
*   This helper deletes the supported compression types array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    8/17/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::DeleteSupportedPreviewModesArrayContents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::DeleteSupportedPreviewModesArrayContents");

    HRESULT hr = S_OK;
    if (NULL != m_pSupportedPreviewModes)
        delete [] m_pSupportedPreviewModes;

    m_pSupportedPreviewModes     = NULL;
    m_NumSupportedPreviewModes   = 0;
    return hr;
}

/**************************************************************************\
* BuildSupportedDataTypes
*
*   This helper initializes the supported data types array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::BuildSupportedDataTypes()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::BuildSupportedDataTypes");

    HRESULT hr = S_OK;

    if(NULL != m_pSupportedDataTypes) {

        //
        // Supported data types have already been initialized,
        // so return S_OK.
        //

        return hr;
    }
    m_NumSupportedDataTypes  = 3;
    m_pSupportedDataTypes = new LONG[m_NumSupportedDataTypes];
    if(m_pSupportedDataTypes){
        m_pSupportedDataTypes[0] = WIA_DATA_THRESHOLD;
        m_pSupportedDataTypes[1] = WIA_DATA_GRAYSCALE;
        m_pSupportedDataTypes[2] = WIA_DATA_COLOR;
    } else
        hr = E_OUTOFMEMORY;
    return hr;
}
/**************************************************************************\
* DeleteSupportedDataTypesArrayContents
*
*   This helper deletes the supported data types array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::DeleteSupportedDataTypesArrayContents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::DeleteSupportedDataTypesArrayContents");

    HRESULT hr = S_OK;
    if(NULL != m_pSupportedDataTypes)
        delete [] m_pSupportedDataTypes;

    m_pSupportedDataTypes     = NULL;
    m_NumSupportedDataTypes   = 0;
    return hr;
}

/**************************************************************************\
* BuildInitialFormats
*
*   This helper initializes the initial format array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::BuildInitialFormats()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::BuildInitialFormats");

    HRESULT hr = S_OK;

    if(NULL != m_pInitialFormats) {

        //
        // Supported data types have already been initialized,
        // so return S_OK.
        //

        return hr;
    }

    m_NumInitialFormats = 1;
    m_pInitialFormats     = new GUID[m_NumInitialFormats];
    if(m_pInitialFormats){
        m_pInitialFormats[0] = WiaImgFmt_MEMORYBMP;
    } else
        hr = E_OUTOFMEMORY;

    return hr;
}
/**************************************************************************\
* DeleteInitialFormatsArrayContents
*
*   This helper deletes the initial format array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::DeleteInitialFormatsArrayContents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::DeleteInitialFormatsArrayContents");

    HRESULT hr = S_OK;
    if(NULL != m_pInitialFormats)
        delete [] m_pInitialFormats;

    m_pInitialFormats     = NULL;
    m_NumInitialFormats   = 0;
    return hr;
}

/**************************************************************************\
* BuildSupportedFormats
*
*   This helper initializes the supported format array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::BuildSupportedFormats()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::BuildSupportedFormats");

    HRESULT hr = S_OK;

    if(NULL != m_pSupportedFormats) {

        //
        // Supported formats have already been initialized,
        // so return S_OK.
        //

        return hr;
    }

    hr = DeleteSupportedFormatsArrayContents();
    if (SUCCEEDED(hr)) {
        m_NumSupportedFormats = 2;

        m_pSupportedFormats = new WIA_FORMAT_INFO[m_NumSupportedFormats];
        if (m_pSupportedFormats) {
            m_pSupportedFormats[0].guidFormatID = WiaImgFmt_MEMORYBMP;
            m_pSupportedFormats[0].lTymed       = TYMED_CALLBACK;
            m_pSupportedFormats[1].guidFormatID = WiaImgFmt_BMP;
            m_pSupportedFormats[1].lTymed       = TYMED_FILE;
        } else
            hr = E_OUTOFMEMORY;
    }
    return hr;
}
/**************************************************************************\
* DeleteSupportedFormatsArrayContents
*
*   This helper deletes the supported formats array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::DeleteSupportedFormatsArrayContents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::DeleteSupportedFormatsArrayContents");

    HRESULT hr = S_OK;
    if(NULL != m_pSupportedFormats)
        delete [] m_pSupportedFormats;

    m_pSupportedFormats     = NULL;
    m_NumSupportedFormats   = 0;
    return hr;
}
/**************************************************************************\
* BuildSupportedTYMED
*
*   This helper initializes the supported TYMED array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::BuildSupportedTYMED()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::BuildSupportedTYMED");

    HRESULT hr = S_OK;

    if(NULL != m_pSupportedTYMED) {

        //
        // Supported TYMED have already been initialized,
        // so return S_OK.
        //

        return hr;
    }

    hr = DeleteSupportedTYMEDArrayContents();
    if (SUCCEEDED(hr)) {
        m_NumSupportedTYMED = 2;
        m_pSupportedTYMED   = new LONG[m_NumSupportedTYMED];
        if (m_pSupportedTYMED) {
            m_pSupportedTYMED[0] = TYMED_FILE;
            m_pSupportedTYMED[1] = TYMED_CALLBACK;

        } else
            hr = E_OUTOFMEMORY;
    }
    return hr;
}
/**************************************************************************\
* DeleteSupportedTYMEDArrayContents
*
*   This helper deletes the supported TYMED array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::DeleteSupportedTYMEDArrayContents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::DeleteSupportedTYMEDArrayContents");

    HRESULT hr = S_OK;
    if(NULL != m_pSupportedTYMED)
        delete [] m_pSupportedTYMED;

    m_pSupportedTYMED  = NULL;
    m_NumSupportedTYMED = 0;
    return hr;
}

/**************************************************************************\
* BuildCapabilities
*
*   This helper initializes the capabilities array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT CWIAScannerDevice::BuildCapabilities()
{
    HRESULT hr = S_OK;
    if(NULL != m_pCapabilities) {

        //
        // Capabilities have already been initialized,
        // so return S_OK.
        //

        return hr;
    }

    m_NumSupportedCommands  = 1;
    m_NumSupportedEvents    = 5;
    m_NumCapabilities       = (m_NumSupportedCommands + m_NumSupportedEvents);
    LONG lArrayIndex        = 0;    // increment this value when adding new items to
                                    // the capabilites array

    m_pCapabilities     = new WIA_DEV_CAP_DRV[m_NumCapabilities];
    if (m_pCapabilities) {

        //
        // Initialize EVENTS
        //

        // WIA_EVENT_DEVICE_CONNECTED
        GetOLESTRResourceString(IDS_EVENT_DEVICE_CONNECTED_NAME,&(m_pCapabilities[lArrayIndex].wszName),TRUE);
        GetOLESTRResourceString(IDS_EVENT_DEVICE_CONNECTED_DESC,&(m_pCapabilities[lArrayIndex].wszDescription),TRUE);
        m_pCapabilities[lArrayIndex].guid           = (GUID*)&WIA_EVENT_DEVICE_CONNECTED;
        m_pCapabilities[lArrayIndex].ulFlags        = WIA_NOTIFICATION_EVENT;
        m_pCapabilities[lArrayIndex].wszIcon        = WIA_ICON_DEVICE_CONNECTED;

        lArrayIndex++;

        // WIA_EVENT_DEVICE_DISCONNECTED
        GetOLESTRResourceString(IDS_EVENT_DEVICE_DISCONNECTED_NAME,&(m_pCapabilities[lArrayIndex].wszName),TRUE);
        GetOLESTRResourceString(IDS_EVENT_DEVICE_DISCONNECTED_DESC,&(m_pCapabilities[lArrayIndex].wszDescription),TRUE);
        m_pCapabilities[lArrayIndex].guid           = (GUID*)&WIA_EVENT_DEVICE_DISCONNECTED;
        m_pCapabilities[lArrayIndex].ulFlags        = WIA_NOTIFICATION_EVENT;
        m_pCapabilities[lArrayIndex].wszIcon        = WIA_ICON_DEVICE_DISCONNECTED;

        lArrayIndex++;

        // FAX BUTTON EVENT
        GetOLESTRResourceString(IDS_EVENT_FAXBUTTON_NAME,&(m_pCapabilities[lArrayIndex].wszName),TRUE);
        GetOLESTRResourceString(IDS_EVENT_FAXBUTTON_DESC,&(m_pCapabilities[lArrayIndex].wszDescription),TRUE);
        m_pCapabilities[lArrayIndex].guid           = (GUID*)&WIA_EVENT_SCAN_FAX_IMAGE;
        m_pCapabilities[lArrayIndex].ulFlags        = WIA_NOTIFICATION_EVENT | WIA_ACTION_EVENT;
        m_pCapabilities[lArrayIndex].wszIcon        = WIA_ICON_SCAN_BUTTON_PRESS;

        lArrayIndex++;

        // COPY BUTTON EVENT
        GetOLESTRResourceString(IDS_EVENT_COPYBUTTON_NAME,&(m_pCapabilities[lArrayIndex].wszName),TRUE);
        GetOLESTRResourceString(IDS_EVENT_COPYBUTTON_DESC,&(m_pCapabilities[lArrayIndex].wszDescription),TRUE);
        m_pCapabilities[lArrayIndex].guid           = (GUID*)&WIA_EVENT_SCAN_PRINT_IMAGE;
        m_pCapabilities[lArrayIndex].ulFlags        = WIA_NOTIFICATION_EVENT | WIA_ACTION_EVENT;
        m_pCapabilities[lArrayIndex].wszIcon        = WIA_ICON_SCAN_BUTTON_PRESS;

        lArrayIndex++;

        // SCAN BUTTON EVENT
        GetOLESTRResourceString(IDS_EVENT_SCANBUTTON_NAME,&(m_pCapabilities[lArrayIndex].wszName),TRUE);
        GetOLESTRResourceString(IDS_EVENT_SCANBUTTON_DESC,&(m_pCapabilities[lArrayIndex].wszDescription),TRUE);
        m_pCapabilities[lArrayIndex].guid           = (GUID*)&WIA_EVENT_SCAN_IMAGE;
        m_pCapabilities[lArrayIndex].ulFlags        = WIA_NOTIFICATION_EVENT | WIA_ACTION_EVENT;
        m_pCapabilities[lArrayIndex].wszIcon        = WIA_ICON_SCAN_BUTTON_PRESS;

        lArrayIndex++;

        //
        // Initialize COMMANDS
        //

        // WIA_CMD_SYNCHRONIZE
        GetOLESTRResourceString(IDS_CMD_SYNCRONIZE_NAME,&(m_pCapabilities[lArrayIndex].wszName),TRUE);
        GetOLESTRResourceString(IDS_CMD_SYNCRONIZE_DESC,&(m_pCapabilities[lArrayIndex].wszDescription),TRUE);
        m_pCapabilities[lArrayIndex].guid           = (GUID*)&WIA_CMD_SYNCHRONIZE;
        m_pCapabilities[lArrayIndex].ulFlags        = 0;
        m_pCapabilities[lArrayIndex].wszIcon        = WIA_ICON_SYNCHRONIZE;

        lArrayIndex++;

    } else
        hr = E_OUTOFMEMORY;
    return hr;
}

/**************************************************************************\
* DeleteCapabilitiesArrayContents
*
*   This helper deletes the capabilities array
*
* Arguments:
*
*    none
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT CWIAScannerDevice::DeleteCapabilitiesArrayContents()
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::DeleteCapabilitiesArrayContents");

    HRESULT hr = S_OK;
    if(NULL != m_pCapabilities) {
        for (LONG i = 0; i < m_NumCapabilities;i++) {
            CoTaskMemFree(m_pCapabilities[i].wszName);
            CoTaskMemFree(m_pCapabilities[i].wszDescription);
        }
        delete [] m_pCapabilities;

        m_pCapabilities = NULL;
    }
    return hr;
}

/**************************************************************************\
* GetBSTRResourceString
*
*   This helper gets a BSTR from a resource location
*
* Arguments:
*
*   lResourceID - Resource ID of the target BSTR value
*   pBSTR       - pointer to a BSTR value (caller must free this string)
*   bLocal      - TRUE - for local resources, FALSE - for wiaservc resources
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::GetBSTRResourceString(LONG lResourceID,BSTR *pBSTR,BOOL bLocal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::GetBSTRResourceString");

    HRESULT hr = S_OK;
    TCHAR szStringValue[255];
    if(bLocal) {

        //
        // We are looking for a resource in our own private resource file
        //

        LoadString(g_hInst,lResourceID,szStringValue,255);

        //
        // NOTE: caller must free this allocated BSTR
        //

#ifdef UNICODE
       *pBSTR = SysAllocString(szStringValue);
#else
       WCHAR wszStringValue[255];

       //
       // convert szStringValue from char* to unsigned short* (ANSI only)
       //

       MultiByteToWideChar(CP_ACP,
                           MB_PRECOMPOSED,
                           szStringValue,
                           lstrlenA(szStringValue)+1,
                           wszStringValue,
                           (sizeof(wszStringValue)/sizeof(WCHAR)));

       *pBSTR = SysAllocString(wszStringValue);
#endif

    } else {

        //
        // We are looking for a resource in the wiaservc's resource file
        //

        hr = E_NOTIMPL;
    }
    return hr;
}

/**************************************************************************\
* GetOLESTRResourceString
*
*   This helper gets a LPOLESTR from a resource location
*
* Arguments:
*
*   lResourceID - Resource ID of the target BSTR value
*   ppsz        - pointer to a OLESTR value (caller must free this string)
*   bLocal      - TRUE - for local resources, FALSE - for wiaservc resources
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::GetOLESTRResourceString(LONG lResourceID,LPOLESTR *ppsz,BOOL bLocal)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL1,
                             "CWIAScannerDevice::GetOLESTRResourceString");

    HRESULT hr = S_OK;
    TCHAR szStringValue[255];
    if(bLocal) {

        //
        // We are looking for a resource in our own private resource file
        //

        LoadString(g_hInst,lResourceID,szStringValue,255);

        //
        // NOTE: caller must free this allocated BSTR
        //

#ifdef UNICODE
       *ppsz = NULL;
       *ppsz = (LPOLESTR)CoTaskMemAlloc(sizeof(szStringValue));
       if(*ppsz != NULL) {
            wcscpy(*ppsz,szStringValue);
       } else {
           return E_OUTOFMEMORY;
       }

#else
       WCHAR wszStringValue[255];

       //
       // convert szStringValue from char* to unsigned short* (ANSI only)
       //

       MultiByteToWideChar(CP_ACP,
                           MB_PRECOMPOSED,
                           szStringValue,
                           lstrlenA(szStringValue)+1,
                           wszStringValue,
                           (sizeof(wszStringValue)/sizeof(WCHAR)));

       *ppsz = NULL;
       *ppsz = (LPOLESTR)CoTaskMemAlloc(sizeof(wszStringValue));
       if(*ppsz != NULL) {
            wcscpy(*ppsz,wszStringValue);
       } else {
           return E_OUTOFMEMORY;
       }
#endif

    } else {

        //
        // We are looking for a resource in the wiaservc's resource file
        //

        hr = E_NOTIMPL;
    }
    return hr;
}

/**************************************************************************\
* VerticalFlip
*
*
*
* Arguments:
*
*
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

VOID CWIAScannerDevice::VerticalFlip(
             PMINIDRIVERITEMCONTEXT     pDrvItemContext,
             PMINIDRV_TRANSFER_CONTEXT  pDataTransferContext)

{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::VerticalFlip");
    LONG        iHeight;
    LONG        iWidth          = pDrvItemContext->lBytesPerScanLineRaw;
    ULONG       uiDepth         = pDrvItemContext->lDepth;
    LONG        ScanLineWidth   = pDrvItemContext->lBytesPerScanLine;
    BITMAPINFO  UNALIGNED *pbmi = NULL;
    PBYTE       pImageTop       = NULL;
    UNALIGNED BITMAPINFOHEADER *pbmih = NULL;
    //
    // find out if data is TYMED_FILE or TYMED_HGLOBAL
    //

    if (pDataTransferContext->tymed == TYMED_FILE) {

        pbmi = (PBITMAPINFO)(pDataTransferContext->pTransferBuffer + sizeof(BITMAPFILEHEADER));

    } else if (pDataTransferContext->tymed == TYMED_HGLOBAL) {

        pbmi = (PBITMAPINFO)(pDataTransferContext->pTransferBuffer);

    } else {
        return;
    }

    //
    // init memory pointer and height
    //

    pbmih = (BITMAPINFOHEADER*)&pbmi->bmiHeader;

    pImageTop = &pDataTransferContext->pTransferBuffer[0] + pDataTransferContext->lHeaderSize;
    iHeight = pbmih->biHeight;

    //
    // try to allocat a temp scan line buffer
    //

    PBYTE pBuffer = (PBYTE)LocalAlloc(LPTR,ScanLineWidth);

    if (pBuffer != NULL) {

        LONG  index;
        PBYTE pImageBottom;

        pImageBottom = pImageTop + (iHeight-1) * ScanLineWidth;

        for (index = 0;index < (iHeight/2);index++) {
            memcpy(pBuffer,pImageTop,ScanLineWidth);
            memcpy(pImageTop,pImageBottom,ScanLineWidth);
            memcpy(pImageBottom,pBuffer,ScanLineWidth);

            pImageTop    += ScanLineWidth;
            pImageBottom -= ScanLineWidth;
        }

        LocalFree(pBuffer);
    } else {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("VerticalFlip, LocalAlloc failed allocating %d bytes",ScanLineWidth));
    }
}

/**************************************************************************\
* SwapBuffer24
*
*   Place RGB bytes in correct order for DIB format.
*
* Arguments:
*
*   pBuffer     - Pointer to the data buffer.
*   lByteCount  - Size of the data in bytes.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

VOID CWIAScannerDevice::SwapBuffer24(PBYTE pBuffer, LONG lByteCount)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::::SwapBuffer24");
    for (LONG i = 0; i < lByteCount; i+= 3) {
        BYTE bTemp = pBuffer[i];
        pBuffer[i]     = pBuffer[i + 2];
        pBuffer[i + 2] = bTemp;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\wiascroll\wiascroll.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       wiascroll.cpp
*
*  VERSION:     1.0
*
*  DATE:        16 July, 2000
*
*  DESCRIPTION:
*   Implementation of the WIA Sample scanner class factory and IUNKNOWN interface.
*
*******************************************************************************/

#include "pch.h"

#if !defined(dllexp)
#define DLLEXPORT __declspec( dllexport )
#endif

/*****************************************************************************
 *
 *      Globals
 *
 *****************************************************************************/

DWORD               g_cRef;            // USD reference counter.
HINSTANCE           g_hInst;           // DLL module instance.
CRITICAL_SECTION    g_csCOM;           // COM initialize syncronization.
IWiaLog            *g_pIWiaLog = NULL; // WIA Logging Interface

// Is COM initialized
BOOL    g_COMInitialized = FALSE;


/**************************************************************************\
* DllAddRef
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

void DllAddRef(void)
{
    InterlockedIncrement((LPLONG)&g_cRef);
}

/**************************************************************************\
* DllRelease
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

void DllRelease(void)
{
    InterlockedDecrement((LPLONG)&g_cRef);
}

/**************************************************************************\
* DllInitializeCOM
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

BOOL DllInitializeCOM(void)
{
    EnterCriticalSection(&g_csCOM);

    if (!g_COMInitialized) {
        if(SUCCEEDED(CoInitialize(NULL))) {
            g_COMInitialized = TRUE;
        }
    }
    LeaveCriticalSection(&g_csCOM);

    return g_COMInitialized;
}

/**************************************************************************\
* DllUnInitializeCOM
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

BOOL DllUnInitializeCOM(void)
{
    EnterCriticalSection(&g_csCOM);

    if(g_COMInitialized) {
        CoUninitialize();
        g_COMInitialized = FALSE;
    }

    LeaveCriticalSection(&g_csCOM);
    return TRUE;
}

/***************************************************************************\
*
*  CWIAScannerDeviceClassFactory
*
\****************************************************************************/

class CWIAScannerDeviceClassFactory : public IClassFactory
{
private:
    ULONG   m_cRef;

public:
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    STDMETHODIMP CreateInstance(
            /* [unique][in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

    STDMETHODIMP LockServer(
            /* [in] */ BOOL fLock);

    CWIAScannerDeviceClassFactory();
    ~CWIAScannerDeviceClassFactory();
};

/**************************************************************************\
* CWIAScannerDeviceClassFactory::CWIAScannerDeviceClassFactory(void)
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    None
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

CWIAScannerDeviceClassFactory::CWIAScannerDeviceClassFactory(void)
{
    // Constructor logic
    m_cRef = 0;

    WIAS_LTRACE(g_pIWiaLog,
                WIALOG_NO_RESOURCE_ID,
                WIALOG_LEVEL3,
                ("CWIAScannerDeviceClassFactory::CWIAScannerDeviceClassFactory, (creating)"));
}

/**************************************************************************\
* CWIAScannerDeviceClassFactory::~CWIAScannerDeviceClassFactory(void)
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    None
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

CWIAScannerDeviceClassFactory::~CWIAScannerDeviceClassFactory(void)
{
    // Destructor logic
    WIAS_LTRACE(g_pIWiaLog,
                WIALOG_NO_RESOURCE_ID,
                WIALOG_LEVEL3,
                ("CWIAScannerDeviceClassFactory::CWIAScannerDeviceClassFactory, (destroy)"));
//    WIA_DEBUG_DESTROY();
}

/**************************************************************************\
* CWIAScannerDeviceClassFactory::QueryInterface
*
*
*
* Arguments:
*
*   riid      -
*   ppvObject -
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDeviceClassFactory::QueryInterface(
    REFIID                      riid,
    void __RPC_FAR *__RPC_FAR   *ppvObject)
{
    *ppvObject = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IClassFactory)) {
        *ppvObject = (LPVOID)this;
        AddRef();
        return NOERROR;
    }
    return ResultFromScode(E_NOINTERFACE);
}

/**************************************************************************\
* CWIAScannerDeviceClassFactory::AddRef
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWIAScannerDeviceClassFactory::AddRef(void)
{
    DllAddRef();
    return ++m_cRef;
}

/**************************************************************************\
* CWIAScannerDeviceClassFactory::Release
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWIAScannerDeviceClassFactory::Release(void)
{
    DllRelease();
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }
    return m_cRef;
}

/**************************************************************************\
* CWIAScannerDeviceClassFactory::CreateInstance
*
*
*
* Arguments:
*
*    punkOuter -
*    riid,     -
*    ppvObject -
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDeviceClassFactory::CreateInstance(
    IUnknown __RPC_FAR          *punkOuter,
    REFIID                      riid,
    void __RPC_FAR *__RPC_FAR   *ppvObject)
{
    if (!IsEqualIID(riid, IID_IStiUSD) &&
        !IsEqualIID(riid, IID_IUnknown)) {
        return STIERR_NOINTERFACE;
    }

    // When created for aggregation, only IUnknown can be requested.
    if (punkOuter && !IsEqualIID(riid, IID_IUnknown)) {
        return CLASS_E_NOAGGREGATION;
    }

    CWIAScannerDevice   *pDev = NULL;
    HRESULT         hres;

    pDev = new CWIAScannerDevice(punkOuter);
    if (!pDev) {
        return STIERR_OUTOFMEMORY;
    }

    hres = pDev->PrivateInitialize();
    if(hres != S_OK) {
        delete pDev;
        return hres;
    }

    //  Move to the requested interface if we aren't aggregated.
    //  Don't do this if aggregated, or we will lose the private
    //  IUnknown and then the caller will be hosed.
    hres = pDev->NonDelegatingQueryInterface(riid,ppvObject);
    pDev->NonDelegatingRelease();

    return hres;
}

/**************************************************************************\
* CWIAScannerDeviceClassFactory::LockServer
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDeviceClassFactory::LockServer(BOOL fLock)
{
    if (fLock) {
        DllAddRef();
    } else {
        DllRelease();
    }
    return NOERROR;
}

/**************************************************************************\
* CWIAScannerDevice::NonDelegatingQueryInterface
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::NonDelegatingQueryInterface(
    REFIID  riid,
    LPVOID  *ppvObj)
{
    HRESULT hres = S_OK;

    if (!IsValid() || !ppvObj) {
        return STIERR_INVALID_PARAM;
    }

    *ppvObj = NULL;

    if (IsEqualIID( riid, IID_IUnknown )) {
        *ppvObj = static_cast<INonDelegatingUnknown*>(this);
    }
    else if (IsEqualIID( riid, IID_IStiUSD )) {
        *ppvObj = static_cast<IStiUSD*>(this);
    }
    else if (IsEqualIID( riid, IID_IWiaMiniDrv )) {
        *ppvObj = static_cast<IWiaMiniDrv*>(this);
    }
    else {
        hres =  STIERR_NOINTERFACE;
    }

    if (SUCCEEDED(hres)) {
        (reinterpret_cast<IUnknown*>(*ppvObj))->AddRef();
    }

    return hres;
}

/**************************************************************************\
* CWIAScannerDevice::NonDelegatingAddRef
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Object reference count.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWIAScannerDevice::NonDelegatingAddRef(void)
{
    return InterlockedIncrement((LPLONG)&m_cRef);
}

/**************************************************************************\
* CWIAScannerDevice::NonDelegatingRelease
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Object reference count.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWIAScannerDevice::NonDelegatingRelease(void)
{
    ULONG ulRef;

    ulRef = InterlockedDecrement((LPLONG)&m_cRef);

    if (!ulRef) {
        delete this;
    }
    return ulRef;
}

/**************************************************************************\
* CWIAScannerDevice::QueryInterface
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP CWIAScannerDevice::QueryInterface(REFIID riid, LPVOID* ppvObj)
{
    return m_punkOuter->QueryInterface(riid,ppvObj);
}

/**************************************************************************\
* CWIAScannerDevice::AddRef
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWIAScannerDevice::AddRef(void)
{
    return m_punkOuter->AddRef();
}

/**************************************************************************\
* CWIAScannerDevice::Release
*
*
*
* Arguments:
*
*    None
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

STDMETHODIMP_(ULONG) CWIAScannerDevice::Release(void)
{
    return m_punkOuter->Release();
}

/**************************************************************************\
* DllEntryPoint
*
*   Main library entry point. Receives DLL event notification from OS.
*
*       We are not interested in thread attaches and detaches,
*       so we disable thread notifications for performance reasons.
*
* Arguments:
*
*    hinst      -
*    dwReason   -
*    lpReserved -
*
* Return Value:
*
*    Returns TRUE to allow the DLL to load.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/


extern "C" DLLEXPORT BOOL APIENTRY DllEntryPoint(
    HINSTANCE   hinst,
    DWORD       dwReason,
    LPVOID      lpReserved)
{
    HRESULT hr = E_FAIL;
    switch (dwReason) {
        case DLL_PROCESS_ATTACH:
            g_hInst = hinst;
            DisableThreadLibraryCalls(hinst);
            
            __try {
                if(!InitializeCriticalSectionAndSpinCount(&g_csCOM, MINLONG)) {
                    return FALSE;
                }
            }
            __except(EXCEPTION_EXECUTE_HANDLER) {
                return FALSE;
            }
            break;

        case DLL_PROCESS_DETACH:
            if (g_cRef) {

            }

            DeleteCriticalSection(&g_csCOM);
            
            break;
    }
    return TRUE;
}

/**************************************************************************\
* DllCanUnloadNow
*
*   Determines whether the DLL has any outstanding interfaces.
*
* Arguments:
*
*    None
*
* Return Value:
*
*   Returns S_OK if the DLL can unload, S_FALSE if it is not safe to unload.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

extern "C" STDMETHODIMP DllCanUnloadNow(void)
{
    return g_cRef ? S_FALSE : S_OK;
}

/**************************************************************************\
* DllGetClassObject
*
*   Create an IClassFactory instance for this DLL. We support only one
*   class of objects, so this function does not need to go through a table
*   of supported classes, looking for the proper constructor.
*
* Arguments:
*
*    rclsid - The object being requested.
*    riid   - The desired interface on the object.
*    ppv    - Output pointer to object.
*
* Return Value:
*
*    Status.
*
* History:
*
*    9/11/1998 Original Version
*
\**************************************************************************/

extern "C" STDAPI DllGetClassObject(
    REFCLSID    rclsid,
    REFIID      riid,
    LPVOID      *ppv)
{
    if (!ppv) {
        return ResultFromScode(E_FAIL);
    }

    if (!IsEqualCLSID(rclsid, CLSID_SampleWIAScannerDevice) ) {
        return ResultFromScode(E_FAIL);
    }

    if (!IsEqualIID(riid, IID_IUnknown) &&
        !IsEqualIID(riid, IID_IClassFactory)) {
        return ResultFromScode(E_NOINTERFACE);
    }

    if (IsEqualCLSID(rclsid, CLSID_SampleWIAScannerDevice)) {
        CWIAScannerDeviceClassFactory *pcf = new CWIAScannerDeviceClassFactory;
        if (pcf) {
            *ppv = (LPVOID)pcf;
        }
    }
    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\wiascroll\validate.cpp ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       validate.cpp
*
*  VERSION:     1.0
*
*  DATE:        17 July, 2000
*
*  DESCRIPTION:
*
*******************************************************************************/

#include "pch.h"
extern HINSTANCE g_hInst;   // used for WIAS_LOGPROC macro

/**************************************************************************\
* ValidateDataTransferContext
*
*   Checks the data transfer context to ensure it's valid.
*
* Arguments:
*
*    pDataTransferContext - Pointer the data transfer context.
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT CWIAScannerDevice::ValidateDataTransferContext(
    PMINIDRV_TRANSFER_CONTEXT pDataTransferContext)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "::ValidateDataTransferContext");

    if (pDataTransferContext->lSize != sizeof(MINIDRV_TRANSFER_CONTEXT)) {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ValidateDataTransferContext, invalid data transfer context"));
        return E_INVALIDARG;;
    }

    //
    //  for TYMED file, only WiaImgFmt_BMP is allowed by this driver
    //

    if (pDataTransferContext->tymed == TYMED_FILE) {

        if (pDataTransferContext->guidFormatID != WiaImgFmt_BMP) {
            if (pDataTransferContext->guidFormatID != WiaImgFmt_TIFF) {
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ValidateDataTransferContext, invalid format for TYMED_FILE"));
                return E_INVALIDARG;
            }
        }
    }

    //
    //  for TYMED CALLBACK, only WiaImgFmt_MEMORYBMP is allowed by this driver
    //

    if (pDataTransferContext->tymed == TYMED_CALLBACK) {

        if (pDataTransferContext->guidFormatID != WiaImgFmt_MEMORYBMP) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("ValidateDataTransferContext, invalid format for TYMED_CALLBACK"));
            return E_INVALIDARG;;
        }
    }

    return S_OK;
}

/**************************************************************************\
* UpdateValidDepth
*
*   Helper that updates the valid value for depth based on the data type.
*
* Arguments:
*
*   pWiasContext    -   a pointer to the WiaItem context
*   lDataType   -   the value of the DataType property.
*   lDepth      -   the address of the variable where the Depth's new value
*                   will be returned.
*
* Return Value:
*
*   Status      -   S_OK if successful
*                   E_INVALIDARG if lDataType is unknown
*                   Errors are those returned by wiasReadPropLong,
*                   and wiasWritePropLong.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT CWIAScannerDevice::UpdateValidDepth(
    BYTE        *pWiasContext,
    LONG        lDataType,
    LONG        *lDepth)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::UpdateValidDepth");
    HRESULT hr = S_OK;
    LONG    pValidDepth[1];

    switch (lDataType) {
        case WIA_DATA_THRESHOLD:
            pValidDepth[0] = 1;
            break;
        case WIA_DATA_GRAYSCALE:
            pValidDepth[0] = 8;
            break;
        case WIA_DATA_COLOR:
            pValidDepth[0] = 24;
            break;
        default:
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("UpdateValidDepth, unknown data type"));
            return E_INVALIDARG;
    }

    if (lDepth) {
        *lDepth = pValidDepth[0];
    }

    return hr;
}

/**************************************************************************\
* CheckDataType
*
*   This helper method is called to check whether WIA_IPA_DATATYPE
*   property is changed.  When this property changes, other dependant
*   properties and their valid values must also be changed.
*
* Arguments:
*
*   pWiasContext    -   a pointer to the item context whose properties have
*                       changed.
*   pContext    -   a pointer to the property context (which indicates
*                   which properties are being written).
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT CWIAScannerDevice::CheckDataType(
    BYTE                    *pWiasContext,
    WIA_PROPERTY_CONTEXT    *pContext)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::CheckDataType");
    WIAS_CHANGED_VALUE_INFO cviDataType, cviDepth;
    HRESULT                 hr = S_OK;

    //
    //  Call wiasGetChangedValue for DataType. It is checked first since it's
    //  not dependant on any other property.  All properties in this method
    //  that follow are dependant properties of DataType.
    //
    //  The call to wiasGetChangedValue specifies that validation should not be
    //  skipped (since valid values for DataType never change).  Also,
    //  the address of a variable for the old value is NULL, since the old
    //  value is not needed.  The address of bDataTypeChanged is passed
    //  so that dependant properties will know whether the DataType is being
    //  changed or not.  This is important since dependant properties may need
    //  their valid values updated and may need to be folded to new valid
    //  values.
    //

    hr = wiasGetChangedValueLong(pWiasContext,
                                 pContext,
                                 FALSE,
                                 WIA_IPA_DATATYPE,
                                 &cviDataType);
    if (FAILED(hr)) {
        return hr;
    }

    //
    //  Call wiasGetChangedValue for Depth. Depth is a dependant property of
    //  DataType whose valid value changes according to what the current
    //  value of DataType is.
    //
    //  The call to wiasGetChangedValue specifies that validation should only
    //  be skipped if the DataType has changed.  This is because the valid
    //  values for Depth will change according to the new value for
    //  DataType.  The address of a variable for the old value is NULL, since
    //  the old value is not needed.  The address of bDepthChanged is passed
    //  so that dependant properties will know whether the Depth is being
    //  changed or not.  This is important since dependant properties may need
    //  their valid values updated and may need to be folded to new valid
    //  values.
    //

    hr = wiasGetChangedValueLong(pWiasContext,
                                 pContext,
                                 cviDataType.bChanged,
                                 WIA_IPA_DEPTH,
                                 &cviDepth);
    if (FAILED(hr)) {
        return hr;
    }

    if (cviDataType.bChanged) {

        //
        //  DataType changed so update valid value for Depth
        //

        hr = UpdateValidDepth(pWiasContext, cviDataType.Current.lVal, &cviDepth.Current.lVal);

        if (SUCCEEDED(hr)) {

            //
            //  Check whether we must fold.  Depth will only be folded if it
            //  is not one of the properties that the app is changing.
            //

            if (!cviDepth.bChanged) {
                hr = wiasWritePropLong(pWiasContext, WIA_IPA_DEPTH, cviDepth.Current.lVal);
            }
        }
    }

    //
    //  Update properties dependant on DataType and Depth.
    //  Here, ChannelsPerPixel and BitsPerChannel are updated.
    //

    if (cviDataType.bChanged || cviDepth.bChanged) {
        if (SUCCEEDED(hr)) {
            #define NUM_PROPS_TO_SET 2
            PROPSPEC    ps[NUM_PROPS_TO_SET] = {
                            {PRSPEC_PROPID, WIA_IPA_CHANNELS_PER_PIXEL},
                            {PRSPEC_PROPID, WIA_IPA_BITS_PER_CHANNEL}};
            PROPVARIANT pv[NUM_PROPS_TO_SET];

            for (LONG index = 0; index < NUM_PROPS_TO_SET; index++) {
                PropVariantInit(&pv[index]);
                pv[index].vt = VT_I4;
            }

            switch (cviDataType.Current.lVal) {
                case WIA_DATA_THRESHOLD:
                    pv[0].lVal = 1;
                    pv[1].lVal = 1;
                    break;

                case WIA_DATA_GRAYSCALE:
                    pv[0].lVal = 1;
                    pv[1].lVal = 8;
                    break;

                case WIA_DATA_COLOR:
                    pv[0].lVal = 3;
                    pv[1].lVal = 8;
                    break;

                default:
                    pv[0].lVal = 1;
                    pv[1].lVal = 8;
                    break;
            }
            hr = wiasWriteMultiple(pWiasContext, NUM_PROPS_TO_SET, ps, pv);
        }
    }

    return hr;
}

/**************************************************************************\
* CheckIntent
*
*   This helper method is called to make the relevant changes if the
*   Current Intent property changes.
*
* Arguments:
*
*   pWiasContext    -   a pointer to the item context whose properties have
*                       changed.
*   pContext    -   a pointer to the property context (which indicates
*                   which properties are being written).
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT CWIAScannerDevice::CheckIntent(
    BYTE            *pWiasContext,
    WIA_PROPERTY_CONTEXT *pContext)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::CheckIntent");
    HRESULT                 hr;
    WIAS_CHANGED_VALUE_INFO cviIntent;

    //
    //  Call wiasGetChangedValue for CurrentIntent. CurrentIntent is checked first
    //  since it's not dependant on any other property.  All properties in
    //  this method that follow are dependant properties of CurrentIntent.
    //
    //  The call to wiasGetChangedValue specifies that validation should not be
    //  skipped (since valid values for CurrentIntent never change). The
    //  address of the old value is specified as NULL, since it is not used.
    //  The address of bIntentChanged is passed so that dependant properties
    //  will know whether the YResolution is being changed or not.  This is
    //  important since dependant properties will need their valid values
    //  updated and may need to be folded to new valid values.
    //

    hr = wiasGetChangedValueLong(pWiasContext,
                                 pContext,
                                 FALSE,
                                 WIA_IPS_CUR_INTENT,
                                 &cviIntent);
    if (SUCCEEDED(hr)) {
        if (cviIntent.bChanged) {

            LONG lImageSizeIntent = (cviIntent.Current.lVal & WIA_INTENT_SIZE_MASK);
            LONG lImageTypeIntent = (cviIntent.Current.lVal & WIA_INTENT_IMAGE_TYPE_MASK);

            switch (lImageTypeIntent) {

                case WIA_INTENT_NONE:
                    break;

                case WIA_INTENT_IMAGE_TYPE_GRAYSCALE:
                    wiasWritePropLong(pWiasContext, WIA_IPA_DATATYPE, WIA_DATA_GRAYSCALE);
                    UpdateValidDepth (pWiasContext, WIA_DATA_GRAYSCALE, NULL);
                    wiasWritePropLong(pWiasContext, WIA_IPA_DEPTH, 8);
                    break;

                case WIA_INTENT_IMAGE_TYPE_TEXT:
                    wiasWritePropLong(pWiasContext, WIA_IPA_DATATYPE, WIA_DATA_THRESHOLD);
                    UpdateValidDepth (pWiasContext, WIA_DATA_THRESHOLD, NULL);
                    wiasWritePropLong(pWiasContext, WIA_IPA_DEPTH, 1);
                    break;

                case WIA_INTENT_IMAGE_TYPE_COLOR:
                    wiasWritePropLong(pWiasContext, WIA_IPA_DATATYPE, WIA_DATA_COLOR);
                    UpdateValidDepth(pWiasContext, WIA_DATA_COLOR, NULL);
                    wiasWritePropLong(pWiasContext, WIA_IPA_DEPTH, 24);
                    break;

                default:
                    WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CheckIntent, unknown intent (TYPE) = %d",lImageTypeIntent));
                    return E_INVALIDARG;

            }

            switch (lImageSizeIntent) {
            case WIA_INTENT_NONE:
                    break;
            case WIA_INTENT_MINIMIZE_SIZE:
            case WIA_INTENT_MAXIMIZE_QUALITY:
                {

                    //
                    // Set the X and Y Resolutions.
                    //

                    wiasWritePropLong(pWiasContext, WIA_IPS_XRES, lImageSizeIntent & WIA_INTENT_MINIMIZE_SIZE ? 150 : 300);
                    wiasWritePropLong(pWiasContext, WIA_IPS_YRES, lImageSizeIntent & WIA_INTENT_MINIMIZE_SIZE ? 150 : 300);

                    //
                    //  The Resolutions and DataType were set, so update the property
                    //  context to indicate that they have changed.
                    //

                    wiasSetPropChanged(WIA_IPS_XRES, pContext, TRUE);
                    wiasSetPropChanged(WIA_IPS_YRES, pContext, TRUE);
                    wiasSetPropChanged(WIA_IPA_DATATYPE, pContext, TRUE);
                }
                break;
            default:
                WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CheckIntent, unknown intent (SIZE) = %d",lImageSizeIntent));
                return E_INVALIDARG;
            }
        }
    } else {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CheckIntent, wiasGetChangedValue (intent) failed"));
    }
    return hr;
}

/**************************************************************************\
* CheckPreferredFormat
*
*   This helper method is called to make the relevant changes if the
*   Format property changes.
*
* Arguments:
*
*   pWiasContext    -   a pointer to the item context whose properties have
*                       changed.
*   pContext    -   a pointer to the property context (which indicates
*                   which properties are being written).
*
* Return Value:
*
*    Status
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/

HRESULT CWIAScannerDevice::CheckPreferredFormat(
    BYTE            *pWiasContext,
    WIA_PROPERTY_CONTEXT *pContext)
{
    HRESULT hr = S_OK;

    //
    // update WIA_IPA_PREFERRED_FORMAT property
    //

    GUID FormatGUID;
    hr = wiasReadPropGuid(pWiasContext, WIA_IPA_FORMAT, &FormatGUID, NULL, TRUE);
    if (SUCCEEDED(hr)) {
        hr = wiasWritePropGuid(pWiasContext, WIA_IPA_PREFERRED_FORMAT, FormatGUID);
        if (FAILED(hr)) {
            WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CheckPreferredFormat, could not write WIA_IPA_PREFERRED_FORMAT"));
            return hr;
        }
    } else {
        WIAS_LERROR(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,("CheckIntent, could not read WIA_IPA_FORMAT"));
    }
    return hr;
}

/**************************************************************************\
* CheckADFStatus
*
*
* Arguments:
*
*   pWiasContext - pointer to an Item.
*
* Return Value:
*
*    Byte count.
*
* History:
*
*    7/18/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::CheckADFStatus(BYTE *pWiasContext,
                                         WIA_PROPERTY_CONTEXT *pContext)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::CheckADFStatus");

    if(!m_bADFAttached)
        return S_OK;

    HRESULT hr = S_OK;

    BYTE    *pRootItemCtx   = NULL;
    LONG lDocHandlingSelect = 0;
    hr = wiasGetRootItem(pWiasContext, &pRootItemCtx);
    if (FAILED(hr)) {
        return E_FAIL;
    }

    hr = wiasReadPropLong(pRootItemCtx,
                          WIA_DPS_DOCUMENT_HANDLING_SELECT,
                          &lDocHandlingSelect,
                          NULL,
                          FALSE);
    if(hr == S_FALSE){
        lDocHandlingSelect = FEEDER;
    }

    if (SUCCEEDED(hr)) {
        switch (lDocHandlingSelect) {
        case FEEDER:
            m_bADFEnabled = TRUE;
            hr = S_OK;
            break;
        default:
            hr = E_INVALIDARG;
            return hr;
            break;
        }
    }

    //
    // update document handling status
    //

    if (m_bADFEnabled) {

        HRESULT Temphr = m_pScanAPI->FakeScanner_ADFAvailable();
        if (S_OK == Temphr) {
            hr = wiasWritePropLong(pWiasContext, WIA_DPS_DOCUMENT_HANDLING_STATUS,FEED_READY);
        } else {
            hr = wiasWritePropLong(pWiasContext, WIA_DPS_DOCUMENT_HANDLING_STATUS,PAPER_JAM);
        }

        if (FAILED(Temphr))
            hr = Temphr;
    } else {
        hr = wiasWritePropLong(pWiasContext, WIA_DPS_DOCUMENT_HANDLING_STATUS,FLAT_READY);
    }
    return hr;
}

/**************************************************************************\
* CheckPreview
*
*
* Arguments:
*
*   pWiasContext - pointer to an Item.
*
* Return Value:
*
*    Byte count.
*
* History:
*
*    8/21/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::CheckPreview(BYTE *pWiasContext,
                                         WIA_PROPERTY_CONTEXT *pContext)
{
    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CWIAScannerDevice::CheckPreview");

    HRESULT hr = S_OK;

    BYTE    *pRootItemCtx   = NULL;
    LONG lPreview = 0;
    hr = wiasGetRootItem(pWiasContext, &pRootItemCtx);
    if (FAILED(hr)) {
        return E_FAIL;
    }

    hr = wiasReadPropLong(pRootItemCtx,
                          WIA_DPS_PREVIEW,
                          &lPreview,
                          NULL,
                          FALSE);
    if(hr == S_FALSE){
        // property does not exist...so return S_OK
        return S_OK;
    }

    if (SUCCEEDED(hr)) {
        switch (lPreview) {
        case WIA_FINAL_SCAN:
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("CheckPreview, Set to WIA_FINAL_SCAN"));
            hr = S_OK;
            break;
        default:
            WIAS_LTRACE(m_pIWiaLog,WIALOG_NO_RESOURCE_ID,WIALOG_LEVEL2,("CheckPreview, Set to invalid argument (%d)",lPreview));
            hr = E_INVALIDARG;
            break;
        }
    }
    return hr;
}

/**************************************************************************\
* CheckXExtent
*
*
* Arguments:
*
*   pWiasContext - pointer to an Item.
*
* Return Value:
*
*    Byte count.
*
* History:
*
*    8/21/2000 Original Version
*
\**************************************************************************/
HRESULT CWIAScannerDevice::CheckXExtent(BYTE *pWiasContext,
                                        WIA_PROPERTY_CONTEXT *pContext,
                                        LONG lWidth)
{
    HRESULT hr = S_OK;

    CWiaLogProc WIAS_LOGPROC(m_pIWiaLog,
                             WIALOG_NO_RESOURCE_ID,
                             WIALOG_LEVEL3,
                             "CheckXExtent");

    LONG lMaxExtent;
    LONG lExt;
    WIAS_CHANGED_VALUE_INFO cviXRes, cviXExt;

    //
    // get x resolution changes
    //

    hr = wiasGetChangedValueLong(pWiasContext,pContext,FALSE,WIA_IPS_XRES,&cviXRes);
    if (FAILED(hr)) {
        return hr;
    }

    //
    // get x extent changes
    //

    hr = wiasGetChangedValueLong(pWiasContext,pContext,cviXRes.bChanged,WIA_IPS_XEXTENT,&cviXExt);
    if (FAILED(hr)) {
        return hr;
    }

    //
    // update extent
    //

    lMaxExtent = ((cviXRes.Current.lVal * lWidth) / 1000);

    //
    //  Update read-only property : PIXELS_PER_LINE.  The width in pixels
    //  of the scanned image is the same size as the XExtent.
    //

    if (SUCCEEDED(hr)) {
        hr = wiasWritePropLong(pWiasContext, WIA_IPS_XEXTENT, lMaxExtent);
        hr = wiasWritePropLong(pWiasContext, WIA_IPA_PIXELS_PER_LINE, lMaxExtent);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\sti\sampcpl\sampcpl.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       sampcpl.h
//
//--------------------------------------------------------------------------

// Copyright (c) Microsoft 1998, All Rights Reserved

#include <windows.h>
#include <windowsx.h>
#include <commdlg.h>
#pragma intrinsic(memcmp,memset)

#include <objbase.h>

#include <sti.h>
#include <stireg.h>
#include <stierr.h>
#include <stiusd.h>

#if !defined(DLLEXPORT)
#define DLLEXPORT __declspec( dllexport )
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\sti\sampcpl\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by sampusd.rc
// Copyright (c) Microsoft 1998, All Rights Reserved
//
#define IDC_STATIC                      -1
#define IDD_PAGE_GENERAL                106
#define IDC_EDIT_PATH                   1000
#define IDC_BUTTON_BROWSE               1001

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1002
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\scanner\microsft\wiascroll\wiascroll.h ===
/**************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 2000
*
*  TITLE:       wiascroll.h
*
*  VERSION:     1.0
*
*  DATE:        18 July, 2000
*
*  DESCRIPTION:
*
*
***************************************************************************/

#include "pch.h"

typedef GUID* PGUID;

#if defined( _WIN32 ) && !defined( _NO_COM)
//////////////////////////////////////////////////////////////////////////
// GUID / CLSID definition section (for your specific device)           //
//                                                                      //
// IMPORTANT!! - REMEMBER TO CHANGE YOUR .INF FILE TO MATCH YOUR WIA    //
//               DRIVER'S CLSID!!                                       //
//                                                                      //
//                                                                      //
//////////////////////////////////////////////////////////////////////////

// {98B3790C-0D93-4f22-ADAF-51A45B33C998}
DEFINE_GUID(CLSID_SampleWIAScannerDevice,
0x98b3790c, 0xd93, 0x4f22, 0xad, 0xaf, 0x51, 0xa4, 0x5b, 0x33, 0xc9, 0x99);

// {48A89A69-C08C-482a-B3E5-CD50B50B5DFA}
DEFINE_GUID(guidEventFirstLoaded,
0x48a89a69, 0xc08c, 0x482a, 0xb3, 0xe5, 0xcd, 0x50, 0xb5, 0xb, 0x5d, 0xfa);

#endif

//////////////////////////////////////////////////////////////////////////
// DLL #define Section                                                  //
//////////////////////////////////////////////////////////////////////////

#define DATASEG_PERINSTANCE     ".instance"
#define DATASEG_SHARED          ".shared"
#define DATASEG_READONLY        ".code"
#define DATASEG_DEFAULT         DATASEG_SHARED

#define ENTERCRITICAL   DllEnterCrit(void);
#define LEAVECRITICAL   DllLeaveCrit(void);

#pragma data_seg(DATASEG_PERINSTANCE)
#pragma data_seg(DATASEG_DEFAULT)

extern UINT g_cRefThisDll;
extern UINT g_cLocks;
extern BOOL DllInitializeCOM(void);
extern BOOL DllUnInitializeCOM(void);
extern void DllAddRef(void);
extern void DllRelease(void);

//
// Base structure for supporting non-delegating IUnknown for contained objects
//

struct INonDelegatingUnknown
{
    // IUnknown-like methods
    STDMETHOD(NonDelegatingQueryInterface)(THIS_
              REFIID riid,
              LPVOID *ppvObj) PURE;
    STDMETHOD_(ULONG,NonDelegatingAddRef)(THIS) PURE;
    STDMETHOD_(ULONG,NonDelegatingRelease)( THIS) PURE;
};

// This sample WIA scanner supports a single scanning context.
#define NUM_DEVICE_ITEM     1

// Device item specific context.
typedef struct _MINIDRIVERITEMCONTEXT{
   LONG     lSize;
   LONG     lTotalWritten;                      // Total image bytes written.
   // Scan parameters:
   LONG     lDepth;                             // image bit depth
   LONG     lBytesPerScanLine;                  // bytes per scan line     (scanned data)
   LONG     lBytesPerScanLineRaw;               // bytes per scan line RAW (scanned data)
   LONG     lTotalRequested;                    // Total image bytes requested.
   // pTransferBuffer information
   LONG     lImageSize;                         // Image
   LONG     lHeaderSize;                        // Transfer header size
} MINIDRIVERITEMCONTEXT, *PMINIDRIVERITEMCONTEXT;

//
// Class definition for sample WIA scanner object
//

class CWIAScannerDevice : public IStiUSD,               // STI USD interface
                          public IWiaMiniDrv,           // WIA Minidriver interface
                          public INonDelegatingUnknown  // NonDelegatingUnknown
{
public:

    /////////////////////////////////////////////////////////////////////////
    // Construction/Destruction Section                                    //
    /////////////////////////////////////////////////////////////////////////

    CWIAScannerDevice(LPUNKNOWN punkOuter);
    HRESULT PrivateInitialize();
    ~CWIAScannerDevice();

private:

    // COM object data
    ULONG               m_cRef;                 // Device object reference count.

    // STI information
    BOOL                m_fValid;               // Is object initialized?
    LPUNKNOWN           m_punkOuter;            // Pointer to outer unknown.
    PSTIDEVICECONTROL   m_pIStiDevControl;      // Device control interface.
    BOOLEAN             m_bUsdLoadEvent;        // Controls load event.
    DWORD               m_dwLastOperationError; // Last error.
    DWORD               m_dwLockTimeout;        // Lock timeout for LockDevice() calls
    BOOL                m_bDeviceLocked;        // device locked/unlocked
    CHAR                *m_pszDeviceNameA;      // CreateFileName for default RawRead/RawWrite handle
    HANDLE              m_DeviceDefaultDataHandle;//default RawRead/RawWrite handle

    // Event information
    CRITICAL_SECTION    m_csShutdown;           // Syncronizes shutdown.
    HANDLE              m_hSignalEvent;         // Signal event handle.
    HANDLE              m_hShutdownEvent;       // Shutdown event handle.
    HANDLE              m_hEventNotifyThread;   // Does event notification.
    GUID                m_guidLastEvent;        // Last event ID.

    // WIA information, one time initialization.
    BSTR                m_bstrDeviceID;         // WIA unique device ID.
    BSTR                m_bstrRootFullItemName; // Device name for prop streams.
    IWiaEventCallback   *m_pIWiaEventCallback;  // WIA event sink.
    IWiaDrvItem         *m_pIDrvItemRoot;       // The root item.
    IStiDevice          *m_pStiDevice;          // Sti object.

    HINSTANCE           m_hInstance;            // Module's HINSTANCE
    IWiaLog             *m_pIWiaLog;            // WIA logging object

    LONG                m_NumSupportedCommands; // Number of supported commands
    LONG                m_NumSupportedEvents;   // Number of supported events

    LONG                m_NumSupportedFormats;  // Number of supported formats
    LONG                m_NumCapabilities;      // Number of capabilities
    LONG                m_NumSupportedTYMED;    // Number of supported TYMED
    LONG                m_NumInitialFormats;    // Number of Initial formats
    LONG                m_NumSupportedDataTypes;// Number of supported data types
    LONG                m_NumSupportedIntents;  // Number of supported intents
    LONG                m_NumSupportedCompressionTypes; // Number of supported compression types
    LONG                m_NumSupportedResolutions; // Number of supported resolutions
    LONG                m_NumSupportedPreviewModes;// Number of supported preview modes

    WIA_FORMAT_INFO     *m_pSupportedFormats;   // supported formats
    WIA_DEV_CAP_DRV     *m_pCapabilities;       // capabilities
    LONG                *m_pSupportedTYMED;     // supported TYMED
    GUID                *m_pInitialFormats;     // initial formats
    LONG                *m_pSupportedDataTypes; // supported data types
    LONG                *m_pSupportedIntents;   // supported intents
    LONG                *m_pSupportedCompressionTypes; // supported compression types
    LONG                *m_pSupportedResolutions;// supported resolutions
    LONG                *m_pSupportedPreviewModes;// supported preview modes

    LONG                m_NumRootItemProperties;// Number of Root item properties
    LONG                m_NumItemProperties;    // Number of item properties

    LPOLESTR            *m_pszRootItemDefaults; // root item property names
    PROPID              *m_piRootItemDefaults;  // root item property ids
    PROPVARIANT         *m_pvRootItemDefaults;  // root item property prop variants
    PROPSPEC            *m_psRootItemDefaults;  // root item property propspecs
    WIA_PROPERTY_INFO   *m_wpiRootItemDefaults; // root item property attributes

    LPOLESTR            *m_pszItemDefaults;     // item property names
    PROPID              *m_piItemDefaults;      // item property ids
    PROPVARIANT         *m_pvItemDefaults;      // item property prop variants
    PROPSPEC            *m_psItemDefaults;      // item property propspecs
    WIA_PROPERTY_INFO   *m_wpiItemDefaults;     // item property attributes

    BOOL                m_bADFEnabled;          // ADF enabled
    BOOL                m_bADFAttached;         // ADF attached

    BOOL                m_bTPAEnabled;          // TPA enabled
    BOOL                m_bTPAAttached;         // TPA attached

    LONG                m_MaxBufferSize;        // Maximum buffer for device
    LONG                m_MinBufferSize;        // Minimum buffer for device

    CFakeScanAPI        *m_pScanAPI;            // FakeScanner API object

    // inline member functions
    BOOL inline IsValid(VOID) {
        return m_fValid;
    }

public:

    /////////////////////////////////////////////////////////////////////////
    // Standard COM Section                                                //
    /////////////////////////////////////////////////////////////////////////

    STDMETHODIMP QueryInterface( REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef( void);
    STDMETHODIMP_(ULONG) Release( void);

    /////////////////////////////////////////////////////////////////////////
    // IStiUSD Interface Section (for all WIA drivers)                     //
    /////////////////////////////////////////////////////////////////////////

    //
    //  Methods for implementing the IStiUSD interface.
    //

    STDMETHOD(Initialize)(THIS_
        PSTIDEVICECONTROL pHelDcb,
        DWORD             dwStiVersion,
        HKEY              hParametersKey);

    STDMETHOD(GetCapabilities)(THIS_
        PSTI_USD_CAPS pDevCaps);

    STDMETHOD(GetStatus)(THIS_
        PSTI_DEVICE_STATUS pDevStatus);

    STDMETHOD(DeviceReset)(THIS);

    STDMETHOD(Diagnostic)(THIS_
        LPDIAG pBuffer);

    STDMETHOD(Escape)(THIS_
        STI_RAW_CONTROL_CODE EscapeFunction,
        LPVOID               lpInData,
        DWORD                cbInDataSize,
        LPVOID               pOutData,
        DWORD                dwOutDataSize,
        LPDWORD              pdwActualData);

    STDMETHOD(GetLastError)(THIS_
        LPDWORD pdwLastDeviceError);

    STDMETHOD(LockDevice)(THIS);

    STDMETHOD(UnLockDevice)(THIS);

    STDMETHOD(RawReadData)(THIS_
        LPVOID       lpBuffer,
        LPDWORD      lpdwNumberOfBytes,
        LPOVERLAPPED lpOverlapped);

    STDMETHOD(RawWriteData)(THIS_
        LPVOID       lpBuffer,
        DWORD        nNumberOfBytes,
        LPOVERLAPPED lpOverlapped);

    STDMETHOD(RawReadCommand)(THIS_
        LPVOID       lpBuffer,
        LPDWORD      lpdwNumberOfBytes,
        LPOVERLAPPED lpOverlapped);

    STDMETHOD(RawWriteCommand)(THIS_
        LPVOID       lpBuffer,
        DWORD        nNumberOfBytes,
        LPOVERLAPPED lpOverlapped);

    STDMETHOD(SetNotificationHandle)(THIS_
        HANDLE hEvent);

    STDMETHOD(GetNotificationData)(THIS_
        LPSTINOTIFY lpNotify);

    STDMETHOD(GetLastErrorInfo)(THIS_
        STI_ERROR_INFO *pLastErrorInfo);

    /////////////////////////////////////////////////////////////////////////
    // IWiaMiniDrv Interface Section (for all WIA drivers)                 //
    /////////////////////////////////////////////////////////////////////////

    //
    //  Methods for implementing WIA's Mini driver interface
    //

    STDMETHOD(drvInitializeWia)(THIS_
        BYTE        *pWiasContext,
        LONG        lFlags,
        BSTR        bstrDeviceID,
        BSTR        bstrRootFullItemName,
        IUnknown    *pStiDevice,
        IUnknown    *pIUnknownOuter,
        IWiaDrvItem **ppIDrvItemRoot,
        IUnknown    **ppIUnknownInner,
        LONG        *plDevErrVal);

    STDMETHOD(drvGetDeviceErrorStr)(THIS_
        LONG     lFlags,
        LONG     lDevErrVal,
        LPOLESTR *ppszDevErrStr,
        LONG     *plDevErr);

    STDMETHOD(drvDeviceCommand)(THIS_
        BYTE        *pWiasContext,
        LONG        lFlags,
        const GUID  *plCommand,
        IWiaDrvItem **ppWiaDrvItem,
        LONG        *plDevErrVal);

    STDMETHOD(drvAcquireItemData)(THIS_
        BYTE                      *pWiasContext,
        LONG                      lFlags,
        PMINIDRV_TRANSFER_CONTEXT pmdtc,
        LONG                      *plDevErrVal);

    STDMETHOD(drvInitItemProperties)(THIS_
        BYTE *pWiasContext,
        LONG lFlags,
        LONG *plDevErrVal);

    STDMETHOD(drvValidateItemProperties)(THIS_
        BYTE           *pWiasContext,
        LONG           lFlags,
        ULONG          nPropSpec,
        const PROPSPEC *pPropSpec,
        LONG           *plDevErrVal);

    STDMETHOD(drvWriteItemProperties)(THIS_
        BYTE                      *pWiasContext,
        LONG                      lFlags,
        PMINIDRV_TRANSFER_CONTEXT pmdtc,
        LONG                      *plDevErrVal);

    STDMETHOD(drvReadItemProperties)(THIS_
        BYTE           *pWiasContext,
        LONG           lFlags,
        ULONG          nPropSpec,
        const PROPSPEC *pPropSpec,
        LONG           *plDevErrVal);

    STDMETHOD(drvLockWiaDevice)(THIS_
        BYTE *pWiasContext,
        LONG lFlags,
        LONG *plDevErrVal);

    STDMETHOD(drvUnLockWiaDevice)(THIS_
        BYTE *pWiasContext,
        LONG lFlags,
        LONG *plDevErrVal);

    STDMETHOD(drvAnalyzeItem)(THIS_
        BYTE *pWiasContext,
        LONG lFlags,
        LONG *plDevErrVal);

    STDMETHOD(drvDeleteItem)(THIS_
        BYTE *pWiasContext,
        LONG lFlags,
        LONG *plDevErrVal);

    STDMETHOD(drvFreeDrvItemContext)(THIS_
        LONG lFlags,
        BYTE *pSpecContext,
        LONG *plDevErrVal);

    STDMETHOD(drvGetCapabilities)(THIS_
        BYTE            *pWiasContext,
        LONG            ulFlags,
        LONG            *pcelt,
        WIA_DEV_CAP_DRV **ppCapabilities,
        LONG            *plDevErrVal);

    STDMETHOD(drvGetWiaFormatInfo)(THIS_
        BYTE            *pWiasContext,
        LONG            lFlags,
        LONG            *pcelt,
        WIA_FORMAT_INFO **ppwfi,
        LONG            *plDevErrVal);

    STDMETHOD(drvNotifyPnpEvent)(THIS_
        const GUID *pEventGUID,
        BSTR       bstrDeviceID,
        ULONG      ulReserved);

    STDMETHOD(drvUnInitializeWia)(THIS_
        BYTE *pWiasContext);

    /////////////////////////////////////////////////////////////////////////
    // INonDelegating Interface Section (for all WIA drivers)              //
    /////////////////////////////////////////////////////////////////////////

    //
    //  IUnknown-like methods.  Needed in conjunction with normal IUnknown
    //  methods to implement delegating components.
    //

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) NonDelegatingAddRef();
    STDMETHODIMP_(ULONG) NonDelegatingRelease();

private:

    /////////////////////////////////////////////////////////////////////////
    // Private helper functions section (for your specific driver)         //
    /////////////////////////////////////////////////////////////////////////
    //                                                                     //
    // This section is for private helpers used for common WIA operations. //
    // These are custom to your driver.                                    //
    //                                                                     //
    //                                                                     //
    // -- WIA Item Management Helpers                                      //
    //    BuildItemTree()                                                  //
    //    DeleteItemTree()                                                 //
    //                                                                     //
    // -- WIA Property Management Helpers                                  //
    //    BuildRootItemProperties()                                        //
    //    BuildTopItemProperties()                                         //
    //                                                                     //
    // -- WIA Capability Management Helpers                                //
    //    BuildRootItemProperties()                                        //
    //    DeleteRootItemProperties()                                       //
    //    BuildTopItemProperties()                                         //
    //    DeleteTopItemProperties()                                        //
    //    BuildCapabilities()                                              //
    //    DeleteCapabilitiesArrayContents()                                //
    //    BuildSupportedFormats()                                          //
    //    DeleteSupportedFormatsArrayContents()                            //
    //    BuildSupportedDataTypes()                                        //
    //    DeleteSupportedDataTypesArrayContents()                          //
    //    BuildSupportedIntents()                                          //
    //    DeleteSupportedIntentsArrayContents()                            //
    //    BuildSupportedCompressions()                                     //
    //    DeleteSupportedCompressionsArrayContents()                       //
    //    BuildSupportedTYMED()                                            //
    //    DeleteSupportedTYMEDArrayContents()                              //
    //    BuildInitialFormats()                                            //
    //    DeleteInitialFormatsArrayContents()                              //
    //                                                                     //
    // -- WIA Validation Helpers                                           //
    //    CheckDataType()                                                  //
    //    CheckIntent()                                                    //
    //    CheckPreferredFormat()                                           //
    //    SetItemSize()                                                    //
    //    UpdateValidDepth()                                               //
    //    ValidateDataTransferContext()                                    //
    //                                                                     //
    // -- WIA Resource file Helpers                                        //
    //    GetBSTRResourceString()                                          //
    //    GetOLESTRResourceString()                                        //
    //                                                                     //
    // -- WIA Data acqusition Helpers                                      //
    //    ScanItem()                                                       //
    //    ScanItemCB()                                                     //
    //    SendImageHeader()                                               //
    //                                                                     //
    //                                                                     //
    //                                                                     //
    //                                                                     //
    //                                                                     //
    /////////////////////////////////////////////////////////////////////////

    HRESULT _stdcall BuildItemTree(void);

    HRESULT _stdcall DeleteItemTree(void);

    HRESULT BuildRootItemProperties();

    HRESULT DeleteRootItemProperties();

    HRESULT BuildTopItemProperties();

    HRESULT DeleteTopItemProperties();

    HRESULT BuildCapabilities();

    HRESULT DeleteCapabilitiesArrayContents();

    HRESULT BuildSupportedFormats();

    HRESULT DeleteSupportedFormatsArrayContents();

    HRESULT BuildSupportedDataTypes();

    HRESULT DeleteSupportedDataTypesArrayContents();

    HRESULT BuildSupportedIntents();

    HRESULT DeleteSupportedIntentsArrayContents();

    HRESULT BuildSupportedCompressions();

    HRESULT DeleteSupportedCompressionsArrayContents();

    HRESULT BuildSupportedPreviewModes();

    HRESULT DeleteSupportedPreviewModesArrayContents();

    HRESULT BuildSupportedTYMED();

    HRESULT DeleteSupportedTYMEDArrayContents();

    HRESULT BuildSupportedResolutions();

    HRESULT DeleteSupportedResolutionsArrayContents();

    HRESULT BuildInitialFormats();

    HRESULT DeleteInitialFormatsArrayContents();

    HRESULT CheckDataType(
        BYTE                 *pWiasContext,
        WIA_PROPERTY_CONTEXT *pContext);

    HRESULT CheckIntent(
        BYTE                 *pWiasContext,
        WIA_PROPERTY_CONTEXT *pContext);

    HRESULT CheckPreferredFormat(
        BYTE                 *pWiasContext,
        WIA_PROPERTY_CONTEXT *pContext);

    HRESULT CheckADFStatus(BYTE *pWiasContext,
                           WIA_PROPERTY_CONTEXT *pContext);

    HRESULT CheckPreview(BYTE *pWiasContext,
                         WIA_PROPERTY_CONTEXT *pContext);

    HRESULT CheckXExtent(BYTE *pWiasContext,
                         WIA_PROPERTY_CONTEXT *pContext,
                         LONG lWidth);

    HRESULT UpdateValidDepth(
        BYTE *pWiasContext,
        LONG lDataType,
        LONG *lDepth);

    HRESULT ValidateDataTransferContext(
        PMINIDRV_TRANSFER_CONTEXT pDataTransferContext);

    HRESULT SetItemSize(
        BYTE *pWiasContext);

    HRESULT _stdcall ScanItem(
        PMINIDRIVERITEMCONTEXT,
        PMINIDRV_TRANSFER_CONTEXT,
        LONG*);

    HRESULT _stdcall ScanItemCB(
        PMINIDRIVERITEMCONTEXT,
        PMINIDRV_TRANSFER_CONTEXT,
        LONG*);

    HRESULT SendImageHeader(
        PMINIDRV_TRANSFER_CONTEXT pmdtc);

    HRESULT SendFilePreviewImageHeader(
        PMINIDRV_TRANSFER_CONTEXT pmdtc);

    HRESULT GetBSTRResourceString(
        LONG lLocalResourceID,
        BSTR *pBSTR,
        BOOL bLocal);

    HRESULT GetOLESTRResourceString(
        LONG lLocalResourceID,
        LPOLESTR *ppsz,
        BOOL bLocal);

    UINT AlignInPlace(
        PBYTE   pBuffer,
        LONG    cbWritten,
        LONG    lBytesPerScanLine,
        LONG    lBytesPerScanLineRaw);

    VOID VerticalFlip(
        PMINIDRIVERITEMCONTEXT     pDrvItemContext,
        PMINIDRV_TRANSFER_CONTEXT  pDataTransferContext);

    VOID SwapBuffer24(
        PBYTE pBuffer,
        LONG lByteCount);

    LONG GetPageCount(
        BYTE *pWiasContext);

    BOOL IsPreviewScan(
        BYTE *pWiasContext);

public:
    HRESULT DoEventProcessing();
};

typedef CWIAScannerDevice *PWIASCANNERDEVICE;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\sti\sampcpl\sampcpl.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       sampcpl.cpp
//
//--------------------------------------------------------------------------


#define INITGUID

#include "Sampcpl.h"
#include <prsht.h>
#include "resource.h"

BOOL WINAPI IsPlatformNT();

/*****************************************************************************
 *
 *      Globals
 *
 *****************************************************************************/

// Reference counter for the whole library
DWORD       g_cRef;

// DLL module instance
HINSTANCE   g_hInst;

// Can we use UNICODE APIs
BOOL    g_NoUnicodePlatform = TRUE;

// Is COM initialized
BOOL    g_COMInitialized = FALSE;

//
PSTI        g_pSti = NULL;

/*****************************************************************************
 *
 *     Code
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | DllEntryPoint |
 *
 *          Called to notify the DLL about various things that can happen.
 *
 *          We are not interested in thread attaches and detaches,
 *          so we disable thread notifications for performance reasons.
 *
 *  @parm   HINSTANCE | hinst |
 *
 *          The instance handle of this DLL.
 *
 *  @parm   DWORD | dwReason |
 *
 *          Notification code.
 *
 *  @parm   LPVOID | lpReserved |
 *
 *          Not used.
 *
 *  @returns
 *
 *          Returns <c TRUE> to allow the DLL to load.
 *
 *****************************************************************************/


extern "C"
DLLEXPORT
BOOL APIENTRY
DllEntryPoint(HINSTANCE hinst, DWORD dwReason, LPVOID lpReserved)
{
    switch (dwReason) {
        case DLL_PROCESS_ATTACH:

        g_hInst = hinst;

        ::DisableThreadLibraryCalls(hinst);

        // Set global flags
        g_NoUnicodePlatform = !IsPlatformNT();

        break;

    case DLL_PROCESS_DETACH:
        if (g_cRef) {
        }

        break;
    }

    return 1;
}


extern "C"
DLLEXPORT
BOOL WINAPI
DllMain(HINSTANCE hinst, DWORD dwReason, LPVOID lpReserved)
{
    return DllEntryPoint(hinst, dwReason, lpReserved);
}

BOOL
CALLBACK
USDSampPropDialog(
    HWND    hwnd,
    UINT    uMessage,
    WPARAM  wp,
    LPARAM  lp
    )
{
    PSTI_DEVICE_INFORMATION psdi;
    HRESULT     hres;

    switch (uMessage)
    {
        case WM_INITDIALOG:

            //  On WM_INITDIALOG, the LPARAM points at the PROPSHEETPAGE that created
            //  us.  We walk down to the lParam member to find the pointer to this
            //  STI device.
           TCHAR szPath[MAX_PATH];

            // Request STI interface pointer
            g_pSti = NULL;

            hres = ::StiCreateInstance(::GetModuleHandle(NULL),
                                        STI_VERSION,
                                        &g_pSti,
                                        NULL);

            psdi = (PSTI_DEVICE_INFORMATION) ((LPPROPSHEETPAGE) lp) -> lParam;

            SetWindowLongPtr(hwnd, DWLP_USER, (LONG_PTR) psdi);

            *szPath = TEXT('\0');

            #ifndef UNICODE
            WideCharToMultiByte(CP_ACP, 0,
                                psdi->pszPortName,-1,
                                szPath,sizeof(szPath),
                                NULL,NULL);
            #else
            lstrcpy(szPath,psdi->pszPortName);
            #endif

            Edit_SetText(GetDlgItem(hwnd,IDC_EDIT_PATH),szPath);
            Edit_LimitText(GetDlgItem(hwnd,IDC_EDIT_PATH), MAX_PATH);

            return TRUE;

        case WM_COMMAND:
            {
                if (GET_WM_COMMAND_ID(wp,lp) == IDC_BUTTON_BROWSE &&
                    GET_WM_COMMAND_CMD(wp,lp) == BN_CLICKED) {

                    static  TCHAR    szAppFilter[]=TEXT("Files\0*.*\0All Files\0*.*\0");

                    TCHAR szFileName[MAX_PATH];
                    OPENFILENAME ofn;

                    DWORD   dwLastError;

                    szFileName[0] = TEXT('\0');

                    /* prompt user for file to open */
                    ofn.lStructSize = sizeof(OPENFILENAME);
                    ofn.hwndOwner = hwnd;
                    ofn.hInstance = NULL;
                    ofn.lpstrFilter = szAppFilter;
                    ofn.lpstrCustomFilter = NULL;
                    ofn.nMaxCustFilter = 0;
                    ofn.nFilterIndex = 0;
                    ofn.lpstrFile = szFileName;
                    ofn.nMaxFile = sizeof(szFileName);
                    ofn.lpstrFileTitle = NULL;
                    ofn.nMaxFileTitle = 0;
                    ofn.lpstrInitialDir = NULL;
                    ofn.lpstrTitle = NULL;
                    ofn.Flags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_EXPLORER;
                    ofn.nFileOffset = 0;
                    ofn.nFileExtension = 0;
                    ofn.lpstrDefExt = NULL;
                    ofn.lCustData = 0;
                    ofn.lpfnHook = NULL;
                    ofn.lpTemplateName = NULL;

                    if (GetOpenFileName(&ofn)) {
                        Edit_SetText(GetDlgItem(hwnd,IDC_EDIT_PATH),szFileName);
                    }
                    else {
                        dwLastError = ::GetLastError();
                    }

                    return TRUE;
                }
                else
                    if (GET_WM_COMMAND_ID(wp,lp) == IDC_EDIT_PATH  &&
                        GET_WM_COMMAND_CMD(wp,lp) == EN_CHANGE ) {
                        // Enable Apply button
                            SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM)hwnd, 0);
                        return TRUE;
                    }

            }
            break;

        case WM_DESTROY:
            // Destroy things
            g_pSti->Release();
            g_pSti = NULL;
            break;

        case WM_NOTIFY:
            {
                LPNMHDR lpnmh = (LPNMHDR) lp;

                if ( lpnmh -> code == PSN_APPLY ) {

                    // Write path to the registry

                    psdi = (PSTI_DEVICE_INFORMATION)GetWindowLong(hwnd, DWLP_USER);

                    if (psdi && g_pSti) {

                        TCHAR    szPath[MAX_PATH];
                        WCHAR   wszPath[MAX_PATH];

                        szPath[0] = '\0';
                        wszPath[0] = L'\0';

                        g_pSti->WriteToErrorLog(STI_TRACE_INFORMATION,
                                                L"Writing new path to the registry for Sample USD"
                                                );


                        GetWindowText(GetDlgItem(hwnd,IDC_EDIT_PATH),szPath,sizeof(szPath));

                        if (*szPath) {

                            HRESULT hres;
                            STI_DEVICE_INFORMATION  sdiNew;
                            STI_DEVICE_INFORMATION  *psdiNew = &sdiNew;

                            CopyMemory(psdiNew,psdi,sizeof(STI_DEVICE_INFORMATION));

                            #ifndef UNICODE
                            MultiByteToWideChar(CP_ACP, 0,
                                                szPath,-1,
                                                wszPath,sizeof(wszPath));
                            #else
                            lstrcpy(wszPath,szPath);
                            #endif

                            psdiNew->pszPortName = wszPath;

                            hres = g_pSti->SetupDeviceParameters(psdiNew);

                            if (!SUCCEEDED(hres)) {
                                g_pSti->WriteToErrorLog(STI_TRACE_ERROR,
                                                        L"Could not save new port name"
                                                        );
                            }
                        }
                    }
                }
            }

        default:   ;
    }

    return  FALSE;
}

PROPSHEETPAGE    psp = {sizeof psp, PSP_DEFAULT };

typedef BOOL    (WINAPI *ADDER)(HPROPSHEETPAGE hpsp, LPARAM lp);

extern "C"
BOOL
WINAPI
EnumStiPropPages(
    PSTI_DEVICE_INFORMATION psdi,
    ADDER                   adder,
    LPARAM lp
    ) {

    psp.hInstance = g_hInst;

    psp.pszTemplate = MAKEINTRESOURCE(IDD_PAGE_GENERAL);
    psp.pfnDlgProc = (DLGPROC)USDSampPropDialog;
    psp.lParam = (LPARAM) psdi;

    HPROPSHEETPAGE  hpsp = CreatePropertySheetPage(&psp);

    if  (!hpsp || !(*adder)(hpsp, lp)) {
        if  (hpsp)  {
            DestroyPropertySheetPage(hpsp);
        }

        return  FALSE;  //  We failed to add anything...
    }

    return  TRUE;
}


BOOL WINAPI
IsPlatformNT(
    VOID
    )
{
    OSVERSIONINFO  ver;
    BOOL            bReturn = FALSE;

    ZeroMemory(&ver,sizeof(ver));
    ver.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    if(!GetVersionEx(&ver)) {
        bReturn = FALSE;
    }
    else {
        switch(ver.dwPlatformId) {

            case VER_PLATFORM_WIN32_WINDOWS:
                bReturn = FALSE;
                break;

            case VER_PLATFORM_WIN32_NT:
                bReturn = TRUE;
                break;

            default:
                bReturn = FALSE;
                break;
        }
    }

    return bReturn;

}  //  endproc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\sti\sampusd\resource.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       resource.h
//
//--------------------------------------------------------------------------

// Copyright (c) Microsoft 1998, All Rights Reserved
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\sti\sampusd\device.cpp ===
/****************************************************************************
 *
 *  DEVICE.CPP
 *
 *  Copyright (C) Microsoft Corporation 1996-1999
 *  All rights reserved
 *
 ***************************************************************************/

#include "Sampusd.h"

#include <stdio.h>

VOID
FileChangeThread(
    LPVOID  lpParameter
    );


UsdSampDevice::UsdSampDevice( LPUNKNOWN punkOuter ):
    m_cRef(1),
    m_punkOuter(NULL),
    m_fValid(FALSE),
    m_pDcb(NULL),
    m_DeviceDataHandle(INVALID_HANDLE_VALUE),
    m_hSignalEvent(INVALID_HANDLE_VALUE),
    m_hThread(NULL),
    m_guidLastEvent(GUID_NULL),
    m_EventSignalState(TRUE)
{

    //
    // See if we are aggregated. If we are ( which will be almost always the case )
    // save pointer to controlling Unknown , so subsequent calls will be delegated
    // If not, set the same pointer to "this" .
    // N.b. cast below is important in order to point to right virtual table
    //
    if (punkOuter) {
        m_punkOuter = punkOuter;
    }
    else {
        m_punkOuter = reinterpret_cast<IUnknown*>
                      (static_cast<INonDelegatingUnknown*>
                      (this));
    }

    m_hShutdownEvent =  CreateEvent( NULL,   // Attributes
                                   TRUE,     // Manual reset
                                   FALSE,    // Initial state - not set
                                   NULL );   // Anonymous

    if ( (INVALID_HANDLE_VALUE !=m_hShutdownEvent) && (NULL != m_hShutdownEvent)) {
        m_fValid = TRUE;
    }
}

UsdSampDevice::~UsdSampDevice( VOID )
{
    // Kill notification thread if it exists
    SetNotificationHandle(NULL);

    if (m_hShutdownEvent && m_hShutdownEvent!=INVALID_HANDLE_VALUE) {
        CloseHandle(m_hShutdownEvent);
    }

    if( INVALID_HANDLE_VALUE != m_DeviceDataHandle ) {
        CloseHandle( m_DeviceDataHandle );
    }

    if (m_pszDeviceNameA) {
        delete [] m_pszDeviceNameA;
        m_pszDeviceNameA = NULL;
    }
}

STDMETHODIMP UsdSampDevice::GetCapabilities( PSTI_USD_CAPS pUsdCaps )
{
    HRESULT hres = STI_OK;

    ZeroMemory(pUsdCaps,sizeof(*pUsdCaps));

    pUsdCaps->dwVersion = STI_VERSION;

    // We do support device notifications, but not reuiring polling
    pUsdCaps->dwGenericCaps = STI_USD_GENCAP_NATIVE_PUSHSUPPORT;

    return hres;
}

STDMETHODIMP UsdSampDevice::GetStatus( PSTI_DEVICE_STATUS pDevStatus )
{
    HRESULT hres = STI_OK;

    //
    // If we are asked, verify whether device is online
    //
    pDevStatus->dwOnlineState = 0L;
    if( pDevStatus->StatusMask & STI_DEVSTATUS_ONLINE_STATE )  {
        if (INVALID_HANDLE_VALUE != m_DeviceDataHandle) {
            // File is always on-line
            pDevStatus->dwOnlineState |= STI_ONLINESTATE_OPERATIONAL;
        }
    }

    //
    // If we are asked, verify state of event
    //
    pDevStatus->dwEventHandlingState &= ~STI_EVENTHANDLING_PENDING;
    if( pDevStatus->StatusMask & STI_DEVSTATUS_EVENTS_STATE ) {

        //
        // Launch app very first time we load
        //
        if(m_EventSignalState) {
            pDevStatus->dwEventHandlingState = STI_EVENTHANDLING_PENDING;

            m_guidLastEvent = guidEventFirstLoaded;

            m_EventSignalState = FALSE;
        }

        if (IsChangeDetected(NULL,FALSE)) {
            pDevStatus->dwEventHandlingState |= STI_EVENTHANDLING_PENDING;
        }
    }

    return hres;
}

STDMETHODIMP UsdSampDevice::DeviceReset( VOID )
{
    HRESULT hres = STI_OK;

    // Reset current active device
    if (INVALID_HANDLE_VALUE != m_DeviceDataHandle) {

        ::SetFilePointer( m_DeviceDataHandle, 0, NULL, FILE_BEGIN);

        m_dwLastOperationError = ::GetLastError();
    }

    hres = HRESULT_FROM_WIN32(m_dwLastOperationError);

    return hres;
}

STDMETHODIMP UsdSampDevice::Diagnostic( LPDIAG pBuffer )
{
    HRESULT hres = STI_OK;

    // Initialize response buffer
    pBuffer->dwStatusMask = 0;

    ZeroMemory(&pBuffer->sErrorInfo,sizeof(pBuffer->sErrorInfo));

    pBuffer->sErrorInfo.dwGenericError = NOERROR;
    pBuffer->sErrorInfo.dwVendorError = 0;

    // This example always returns that the unit passed diagnostics

    return hres;
}

STDMETHODIMP UsdSampDevice:: SetNotificationHandle( HANDLE hEvent )
// SYNCHRONIZED
{
    HRESULT hres = STI_OK;

    TAKE_CRIT_SECT t(m_cs);

    if (hEvent && (hEvent !=INVALID_HANDLE_VALUE)) {

        m_hSignalEvent = hEvent;

        if (m_DeviceDataHandle != INVALID_HANDLE_VALUE) {
            //
            // if we need to be asyncronous, create notification thread
            //
            m_dwAsync = 1;
            m_guidLastEvent = GUID_NULL;

            if (m_dwAsync) {

                if (!m_hThread) {

                    DWORD   dwThread;

                    m_hThread = ::CreateThread(NULL,
                                           0,
                                           (LPTHREAD_START_ROUTINE)FileChangeThread,
                                           (LPVOID)this,
                                           0,
                                           &dwThread);

                    m_pDcb->WriteToErrorLog(STI_TRACE_INFORMATION,
                                    L"SampUSD::Enabling notification monitoring",
                                    NOERROR) ;
                }
            }
            else {
                hres = STIERR_UNSUPPORTED;
            }
        }
        else {
            hres = STIERR_NOT_INITIALIZED;
        }
    }
    else {

        //
        // Disable hardware notifications
        //
        SetEvent(m_hShutdownEvent);
        if ( m_hThread ) {
            WaitForSingleObject(m_hThread,400);
            CloseHandle(m_hThread);
            m_hThread = NULL;
            m_guidLastEvent = GUID_NULL;
        }

        m_pDcb->WriteToErrorLog(STI_TRACE_INFORMATION,
                        L"SampUSD::Disabling notification monitoring",
                        NOERROR) ;

    }

    return hres;
}


STDMETHODIMP UsdSampDevice::GetNotificationData( LPSTINOTIFY pBuffer )
// SYNCHRONIZED
{
    HRESULT hres = STI_OK;

    TAKE_CRIT_SECT t(m_cs);

    //
    // If we have notification ready - return it's guid
    //
    if (!IsEqualIID(m_guidLastEvent,GUID_NULL)) {
        pBuffer->guidNotificationCode  = m_guidLastEvent;
        m_guidLastEvent = GUID_NULL;
        pBuffer->dwSize = sizeof(STINOTIFY);
    }
    else {
        hres = STIERR_NOEVENTS;
    }

    return hres;
}

STDMETHODIMP UsdSampDevice::Escape( STI_RAW_CONTROL_CODE    EscapeFunction,
                                    LPVOID                  pInData,
                                    DWORD                   cbInDataSize,
                                    LPVOID                  pOutData,
                                    DWORD                   cbOutDataSize,
                                    LPDWORD                 pcbActualData )
{
    HRESULT hres = STI_OK;
    //
    // Write indata to device  if needed.
    //

    hres = STIERR_UNSUPPORTED;
    return hres;
}

STDMETHODIMP UsdSampDevice::GetLastError( LPDWORD pdwLastDeviceError )
// SYNCHRONIZED
{
    HRESULT hres = STI_OK;

    TAKE_CRIT_SECT t(m_cs);

    if ( IsBadWritePtr( pdwLastDeviceError,4 ))
    {
        hres = STIERR_INVALID_PARAM;
    }
    else
    {
        *pdwLastDeviceError = m_dwLastOperationError;
    }

    return hres;
}

STDMETHODIMP UsdSampDevice::GetLastErrorInfo(STI_ERROR_INFO *pLastErrorInfo)
// SYNCHRONIZED
{
    HRESULT hres = STI_OK;

    TAKE_CRIT_SECT t(m_cs);

    if ( IsBadWritePtr( pLastErrorInfo,4 ))
    {
        hres = STIERR_INVALID_PARAM;
    }
    else
    {
        pLastErrorInfo->dwGenericError = m_dwLastOperationError;
        pLastErrorInfo->szExtendedErrorText[0] = L'\0';
    }

    return hres;
}


STDMETHODIMP UsdSampDevice::LockDevice( VOID )
{
    HRESULT hres = STI_OK;

    return hres;
}

STDMETHODIMP UsdSampDevice::UnLockDevice( VOID )
{
    HRESULT hres = STI_OK;

    return hres;
}

STDMETHODIMP UsdSampDevice::RawReadData( LPVOID lpBuffer, LPDWORD lpdwNumberOfBytes,
                                        LPOVERLAPPED lpOverlapped )
{
    HRESULT hres = STI_OK;
    BOOL    fRet = FALSE;
    DWORD   dwBytesReturned = 0;

    if (INVALID_HANDLE_VALUE != m_DeviceDataHandle)
    {
        m_dwLastOperationError = NOERROR;

        fRet = ::ReadFile(m_DeviceDataHandle,
                    lpBuffer,
                    *lpdwNumberOfBytes,
                    lpdwNumberOfBytes,
                    lpOverlapped);

        if (!fRet) {
            m_dwLastOperationError = ::GetLastError();
        }

        hres = HRESULT_FROM_WIN32(m_dwLastOperationError);
    }
    else
    {
        hres = STIERR_NOT_INITIALIZED;
    }

    return hres;
}

STDMETHODIMP UsdSampDevice::RawWriteData( LPVOID lpBuffer, DWORD dwNumberOfBytes,
                                            LPOVERLAPPED lpOverlapped )
{
    HRESULT hres = STI_OK;
    BOOL    fRet = FALSE;;
    DWORD   dwBytesReturned = 0;

    if (INVALID_HANDLE_VALUE != m_DeviceDataHandle)
    {
        fRet = ::WriteFile(m_DeviceDataHandle,
                            lpBuffer,
                            dwNumberOfBytes,
                            &dwBytesReturned,
                            lpOverlapped);

        if (!fRet) {
            m_dwLastOperationError = ::GetLastError();
        }

        hres = HRESULT_FROM_WIN32(m_dwLastOperationError);

    }
    else
    {
        hres = STIERR_NOT_INITIALIZED;
    }

    return hres;
}

STDMETHODIMP UsdSampDevice::RawReadCommand( LPVOID lpBuffer, LPDWORD lpdwNumberOfBytes,
                                            LPOVERLAPPED lpOverlapped )
{
    HRESULT hres = STIERR_UNSUPPORTED;

    return hres;
}

STDMETHODIMP UsdSampDevice::RawWriteCommand( LPVOID lpBuffer, DWORD nNumberOfBytes,
                                            LPOVERLAPPED lpOverlapped )
{
    HRESULT hres = STIERR_UNSUPPORTED;

    return hres;
}


STDMETHODIMP UsdSampDevice::Initialize( PSTIDEVICECONTROL pDcb, DWORD dwStiVersion,
                                        HKEY hParametersKey )
{
    HRESULT hres = STI_OK;
    UINT    uiNameLen = 0;
    WCHAR   szDeviceNameW[MAX_PATH];


    if (!pDcb) {
        return STIERR_INVALID_PARAM;
    }

    *szDeviceNameW = L'\0';

    // Check STI specification version number
    m_pDcb = pDcb;
    m_pDcb->AddRef();

    // Get the name of the device port we need to open
    hres = m_pDcb->GetMyDevicePortName(szDeviceNameW,sizeof(szDeviceNameW)/sizeof(WCHAR));
    if (!SUCCEEDED(hres) || !*szDeviceNameW) {
        return hres;
    }

    // Convert name to SBCS
    uiNameLen = WideCharToMultiByte(CP_ACP, 0, szDeviceNameW, -1, NULL, NULL, 0, 0);
    if (!uiNameLen) {
        return STIERR_INVALID_PARAM;
    }

    m_pszDeviceNameA = new CHAR[uiNameLen+1];
    if (!m_pszDeviceNameA) {
        return STIERR_INVALID_PARAM;
    }

    WideCharToMultiByte(CP_ACP, 0, szDeviceNameW, -1, m_pszDeviceNameA, uiNameLen, 0, 0);

    //
    // Open device ourselves
    //
    m_DeviceDataHandle = CreateFileA( m_pszDeviceNameA,
                                     GENERIC_READ ,                     // Access mask
                                     FILE_SHARE_READ | FILE_SHARE_WRITE,    // Share mode
                                     NULL,                              // SA
                                     OPEN_EXISTING,                     // Create disposition
                                     FILE_ATTRIBUTE_SYSTEM,             // Attributes
                                     NULL );
    m_dwLastOperationError = ::GetLastError();

    hres = (m_DeviceDataHandle != INVALID_HANDLE_VALUE) ?
                S_OK : MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,m_dwLastOperationError);

    return hres;

}

VOID
UsdSampDevice::
RunNotifications(VOID)
{

    HANDLE  hNotifyFileSystemChange = INVALID_HANDLE_VALUE;
    DWORD   dwErr;

    CHAR    szDirPath[MAX_PATH];
    CHAR    *pszLastSlash;

    //
    // Find name of the parent directory for out file and set up waiting on any
    // changes in it.
    //
    lstrcpyA(szDirPath,m_pszDeviceNameA);
    pszLastSlash = strrchr(szDirPath,'\\');
    if (pszLastSlash) {
        *pszLastSlash = '\0';
    }

    hNotifyFileSystemChange = FindFirstChangeNotificationA(
                                szDirPath,
                                FALSE,
                                FILE_NOTIFY_CHANGE_SIZE |
                                FILE_NOTIFY_CHANGE_LAST_WRITE |
                                FILE_NOTIFY_CHANGE_FILE_NAME |
                                FILE_NOTIFY_CHANGE_DIR_NAME
                                );

    if (hNotifyFileSystemChange == INVALID_HANDLE_VALUE) {
        dwErr = ::GetLastError();
        return;
    }

    // Set initial values for time and size
    IsChangeDetected(NULL);

    //
    HANDLE  hEvents[2] = {m_hShutdownEvent,hNotifyFileSystemChange};
    BOOL    fLooping = TRUE;

    while (fLooping) {
        dwErr = ::WaitForMultipleObjects(2,
                                         hEvents,
                                         FALSE,
                                         INFINITE );
        switch(dwErr) {
            case WAIT_OBJECT_0+1:

                // Change detected - signal
                if (m_hSignalEvent !=INVALID_HANDLE_VALUE) {

                    // Which change ?
                    if (IsChangeDetected(&m_guidLastEvent)) {

                        m_pDcb->WriteToErrorLog(STI_TRACE_INFORMATION,
                                        L"SampUSD::Monitored file change detected",
                                        NOERROR) ;


                        ::SetEvent(m_hSignalEvent);
                    }
                }

                // Go back to waiting for next file system event
                FindNextChangeNotification(hNotifyFileSystemChange);
                break;

            case WAIT_OBJECT_0:
                // Fall through
            default:
                fLooping = FALSE;
        }
    }

    FindCloseChangeNotification(hNotifyFileSystemChange);
}

BOOL
UsdSampDevice::
IsChangeDetected(
    GUID    *pguidEvent,
    BOOL    fRefresh    // TRUE
    )
{

    BOOL            fRet = FALSE;
    LARGE_INTEGER   liNewHugeSize;
    FILETIME        ftLastWriteTime;
    DWORD           dwError;

    WIN32_FILE_ATTRIBUTE_DATA sNewFileAttributes;

    ZeroMemory(&sNewFileAttributes,sizeof(sNewFileAttributes));

    dwError = NOERROR;

    if ( GetFileAttributesExA(m_pszDeviceNameA,GetFileExInfoStandard, &sNewFileAttributes)) {

        ftLastWriteTime =sNewFileAttributes.ftLastWriteTime;
        liNewHugeSize.LowPart = sNewFileAttributes.nFileSizeLow;
        liNewHugeSize.HighPart= sNewFileAttributes.nFileSizeHigh ;
    }
    else {

        BY_HANDLE_FILE_INFORMATION sFileInfo;

        if (GetFileInformationByHandle(m_DeviceDataHandle,&sFileInfo)) {
            ftLastWriteTime =sFileInfo.ftLastWriteTime;
            liNewHugeSize.LowPart = sFileInfo.nFileSizeLow;
            liNewHugeSize.HighPart= sFileInfo.nFileSizeHigh ;
        }
        else {
            dwError = ::GetLastError();
        }
    }

    if (NOERROR == dwError ) {

        //
        // First check size, because it is easy to change time without changing size
        //
        if (m_dwLastHugeSize.QuadPart != liNewHugeSize.QuadPart) {
            if (pguidEvent) {
                *pguidEvent = guidEventSizeChanged;
            }
            fRet = TRUE;
        }
        else {
            if (CompareFileTime(&m_ftLastWriteTime,&ftLastWriteTime) == -1 ) {
                if (pguidEvent) {
                    *pguidEvent = guidEventTimeChanged;
                }
                fRet = TRUE;
            }
            else {
                // Nothing really changed
            }
        }

        m_ftLastWriteTime = ftLastWriteTime;
        m_dwLastHugeSize = liNewHugeSize;
    }

    return fRet;
}

VOID
FileChangeThread(
    LPVOID  lpParameter
    )
{
    UsdSampDevice   *pThisDevice = (UsdSampDevice *)lpParameter;

    pThisDevice->RunNotifications();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\util\private.h ===
/****************************************************************************
*
*  (C) COPYRIGHT 2000, MICROSOFT CORP.
*
*  FILE:        private.h
*
*  VERSION:     1.0
*
*  DATE:        11/8/2000
*
*  AUTHOR:      Dave Parsons
*
*  DESCRIPTION:
*    Definitions for the wiautil.lib library, which should not be public.
*
*****************************************************************************/

#ifndef _PRIVATE_H_
#define _PRIVATE_H_

class CImageStream : public IStream
{
public:
	CImageStream();
	~CImageStream();

    STDMETHOD(SetBuffer)(BYTE *pBuffer, INT iSize, SKIP_AMOUNT iSkipAmt = SKIP_OFF);
    
    // IUnknown 

    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObject);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // ISequentialStream

    STDMETHOD(Read)(void *pv, ULONG cb, ULONG *pcbRead);
    STDMETHOD(Write)(const void *pv, ULONG cb, ULONG *pcbWritten);

    // IStream

    STDMETHOD(Seek)(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition);
    STDMETHOD(SetSize)(ULARGE_INTEGER libNewSize);
    STDMETHOD(CopyTo)(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten);
    STDMETHOD(Commit)(DWORD grfCommitFlags);
    STDMETHOD(Revert)();
    STDMETHOD(LockRegion)(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHOD(UnlockRegion)(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType);
    STDMETHOD(Stat)(STATSTG *pstatstg, DWORD grfStatFlag);
    STDMETHOD(Clone)(IStream **ppstm);

private:
    LONG                m_cRef;         // Reference count
    
    BYTE               *m_pBuffer;      // Buffer to use for reads and writes
    INT                 m_iSize;        // Size of the buffer
    INT                 m_iPosition;    // Current position in the buffer
    INT                 m_iOffset;      // Offset to apply to reads and writes
    BYTE                m_Header[sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER)];
                                        // Location to store bmp file and info headers
};

#endif // _PRIVATE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\util\other.cpp ===
/*++

Copyright (C) 2000 Microsoft Corporation

Module Name:

    gdipconv.cpp

Abstract:

    Helper functions for using GDI+ to convert image formats

Author:

    DavePar

Revision History:


--*/

#include "pch.h"

/**************************************************************************\
* wiauGetDrvItemContext
\**************************************************************************/

HRESULT wiauGetDrvItemContext(BYTE *pWiasContext, VOID **ppItemCtx, IWiaDrvItem **ppDrvItem)
{
    HRESULT hr = S_OK;

    //
    // Locals
    //
    IWiaDrvItem *pWiaDrvItem = NULL;

    REQUIRE_ARGS(!pWiasContext || !ppItemCtx, hr, "wiauGetDrvItemContext");
    
    *ppItemCtx = NULL;
    if (ppDrvItem)
        *ppDrvItem = NULL;

    hr = wiasGetDrvItem(pWiasContext, &pWiaDrvItem);
    REQUIRE_SUCCESS(hr, "wiauGetDrvItemContext", "wiasGetDrvItem failed");

    hr = pWiaDrvItem->GetDeviceSpecContext((BYTE **) ppItemCtx);
    REQUIRE_SUCCESS(hr, "wiauGetDrvItemContext", "GetDeviceSpecContext failed");
    
    if (!*ppItemCtx)
    {
        wiauDbgError("wiauGetDrvItemContext", "Item context is null");
        hr = E_FAIL;
        goto Cleanup;
    }

    if (ppDrvItem)
    {
        *ppDrvItem = pWiaDrvItem;
    }

Cleanup:
    return hr;
}

/**************************************************************************\
* wiauSetImageItemSize
\**************************************************************************/

HRESULT wiauSetImageItemSize(BYTE *pWiasContext, LONG lWidth, LONG lHeight,
                             LONG lDepth, LONG lSize, PWSTR pwszExt)
{
    HRESULT  hr = S_OK;

    LONG lNewSize     = 0;
    LONG lWidthInBytes = 0;
    GUID guidFormatID  = GUID_NULL;
    BSTR bstrExt = NULL;

    LONG lNumProperties = 2;
    PROPVARIANT pv[3];
    PROPSPEC ps[3] = {{PRSPEC_PROPID, WIA_IPA_ITEM_SIZE},
                      {PRSPEC_PROPID, WIA_IPA_BYTES_PER_LINE},
                      {PRSPEC_PROPID, WIA_IPA_FILENAME_EXTENSION}};

    //
    // Read the current format GUID
    //
    hr = wiasReadPropGuid(pWiasContext, WIA_IPA_FORMAT, &guidFormatID, NULL, TRUE);
    REQUIRE_SUCCESS(hr, "wiauSetImageItemSize", "wiasReadPropGuid failed");

    if (IsEqualCLSID(guidFormatID, WiaImgFmt_BMP) ||
        IsEqualCLSID(guidFormatID, WiaImgFmt_MEMORYBMP))
    {
        lNewSize = sizeof(BITMAPINFOHEADER);

        //
        // if this is a file, add file header to size
        //
        if (IsEqualCLSID(guidFormatID, WiaImgFmt_BMP))
        {
            lNewSize += sizeof(BITMAPFILEHEADER);
        }

        //
        // Calculate number of bytes per line, width must be
        // aligned to 4 byte boundary.
        //
        lWidthInBytes = ((lWidth * lDepth + 31) & ~31) / 8;

        //
        // Calculate image size
        //
        lNewSize += lWidthInBytes * lHeight;

        //
        // Set the extension property
        //
        if (pwszExt) {
            bstrExt = SysAllocString(L"BMP");
            REQUIRE_ALLOC(bstrExt, hr, "wiauSetImageItemSize");
        }
    }
    else
    {
        lNewSize = lSize;
        lWidthInBytes = 0;
        
        //
        // Set the extension property
        //
        if (pwszExt) {
            bstrExt = SysAllocString(pwszExt);
            REQUIRE_ALLOC(bstrExt, hr, "wiauSetImageItemSize");
        }
    }

    //
    // Initialize propvar's.  Then write the values.  Don't need to call
    // PropVariantClear when done, since no memory was allocated.
    //
    if (bstrExt)
        lNumProperties++;

    for (int i = 0; i < lNumProperties; i++) {
        PropVariantInit(&pv[i]);
    }

    pv[0].vt = VT_I4;
    pv[0].lVal = lNewSize;
    pv[1].vt = VT_I4;
    pv[1].lVal = lWidthInBytes;
    pv[2].vt = VT_BSTR;
    pv[2].bstrVal = bstrExt;

    //
    // Write WIA_IPA_ITEM_SIZE and WIA_IPA_BYTES_PER_LINE property values
    //

    hr = wiasWriteMultiple(pWiasContext, lNumProperties, ps, pv);
    REQUIRE_SUCCESS(hr, "wiauSetImageItemSize", "wiasWriteMultiple failed");

Cleanup:
    if (bstrExt)
        SysFreeString(bstrExt);

    return hr;
}

/**************************************************************************\
* wiauPropsInPropSpec
\**************************************************************************/

BOOL wiauPropsInPropSpec(LONG NumPropSpecs, const PROPSPEC *pPropSpecs,
                         int NumProps, PROPID *pProps)
{
    for (int count = 0; count < NumProps; count++)
        if (wiauPropInPropSpec(NumPropSpecs, pPropSpecs, pProps[count]))
            return TRUE;

    return FALSE;
}

/**************************************************************************\
* wiauPropInPropSpec
\**************************************************************************/

BOOL wiauPropInPropSpec(LONG NumPropSpecs, const PROPSPEC *pPropSpecs,
                        PROPID PropId, int *pIdx)
{
    for (int count = 0; count < NumPropSpecs; count++)
        if (pPropSpecs[count].propid == PropId)
        {
            if (pIdx)
                *pIdx = count;
            return TRUE;
        }

    return FALSE;
}

/**************************************************************************\
* wiauGetValidFormats
\**************************************************************************/

HRESULT wiauGetValidFormats(IWiaMiniDrv *pDrv, BYTE *pWiasContext, LONG TymedValue,
                            int *pNumFormats, GUID **ppFormatArray)
{
    HRESULT hr = S_OK;

    LONG NumFi = 0;
    WIA_FORMAT_INFO *pFiArray = NULL;
    LONG lErrVal = 0;
    GUID *pFA = NULL;

    REQUIRE_ARGS(!ppFormatArray || !pNumFormats, hr, "wiauGetValidFormats");

    *ppFormatArray = NULL;
    *pNumFormats = 0;

    hr = pDrv->drvGetWiaFormatInfo(pWiasContext, 0, &NumFi, &pFiArray, &lErrVal);
    REQUIRE_SUCCESS(hr, "wiauGetValidFormats", "drvGetWiaFormatInfo failed");

    //
    // This will allocate more spots than necessary, but pNumFormats will be set correctly
    //
    pFA = new GUID[NumFi];
    REQUIRE_ALLOC(pFA, hr, "wiauGetValidFormats");

    for (int count = 0; count < NumFi; count++)
    {
        if (pFiArray[count].lTymed == TymedValue)
        {
            pFA[*pNumFormats] = pFiArray[count].guidFormatID;
            (*pNumFormats)++;
        }
    }

    *ppFormatArray = pFA;

Cleanup:
    return hr;
}

/**************************************************************************\
* wiauGetResourceString
\**************************************************************************/
HRESULT wiauGetResourceString(HINSTANCE hInst, LONG lResourceID, BSTR *pbstrStr)
{
    DBG_FN("GetResourceString");
    
    HRESULT hr = S_OK;

    //
    // Locals
    //
    INT iLen = 0;
    TCHAR tszTempStr[MAX_PATH] = TEXT("");
    WCHAR wszTempStr[MAX_PATH] = L"";

    REQUIRE_ARGS(!pbstrStr, hr, "GetResourceString");
    *pbstrStr = NULL;

    //
    // Get the string from the resource
    //
    iLen = LoadString(hInst, lResourceID, tszTempStr, MAX_PATH);
    REQUIRE_FILEIO(iLen, hr, "GetResourceString", "LoadString failed");

    hr = wiauStrT2W(tszTempStr, wszTempStr, sizeof(wszTempStr));
    REQUIRE_SUCCESS(hr, "GetResourceString", "wiauStrT2W failed");

    //
    // Caller must free this allocated BSTR
    //
    *pbstrStr = SysAllocString(wszTempStr);
    REQUIRE_ALLOC(*pbstrStr, hr, "GetResourceString");

Cleanup:
    return hr;
}

/**************************************************************************\
* wiauRegOpenDataW
\**************************************************************************/
HRESULT wiauRegOpenDataW(HKEY hkeyAncestor, HKEY *phkeyDeviceData)
{
    DBG_FN("wiauRegOpenDataW");

    HRESULT hr = S_OK;
    
    //
    // Locals
    //
    LONG lReturn = 0;

    REQUIRE_ARGS(!hkeyAncestor || !phkeyDeviceData, hr, "wiauRegOpenDataW");

    lReturn = ::RegOpenKeyExW(hkeyAncestor, L"DeviceData", 0, KEY_READ, phkeyDeviceData);
    REQUIRE_WIN32(lReturn, hr, "wiauRegOpenDataW", "RegOpenKeyExW failed");

Cleanup:
    return hr;
}

/**************************************************************************\
* wiauRegOpenDataA
\**************************************************************************/
HRESULT wiauRegOpenDataA(HKEY hkeyAncestor, HKEY *phkeyDeviceData)
{
    DBG_FN("wiauRegOpenDataA");

    HRESULT hr = S_OK;
    
    //
    // Locals
    //
    LONG lReturn = 0;

    REQUIRE_ARGS(!hkeyAncestor || !phkeyDeviceData, hr, "wiauRegOpenDataA");

    lReturn = ::RegOpenKeyExA(hkeyAncestor, "DeviceData", 0, KEY_READ, phkeyDeviceData);
    REQUIRE_WIN32(lReturn, hr, "wiauRegOpenDataA", "RegOpenKeyExA failed");

Cleanup:
    return hr;
}

/**************************************************************************\
* wiauRegGetStrW
\**************************************************************************/
HRESULT wiauRegGetStrW(HKEY hkKey, PCWSTR pwszValueName, PWSTR pwszValue, DWORD *pdwLength)
{
    DBG_FN("wiauRegGetStrW");

    HRESULT hr = S_OK;
    
    //
    // Locals
    //
    LONG lReturn = 0;
    DWORD dwType = 0;

    REQUIRE_ARGS(!hkKey || !pwszValueName || !pwszValue || !pdwLength, hr, "wiauRegGetStrW");

    lReturn = ::RegQueryValueExW(hkKey, pwszValueName, NULL, &dwType, (BYTE *) pwszValue, pdwLength);
    REQUIRE_WIN32(lReturn, hr, "wiauRegGetStrW", "RegQueryValueExW failed");

    if ((dwType != REG_SZ) &&
        (dwType != REG_EXPAND_SZ) &&
        (dwType != REG_MULTI_SZ)) {

        wiauDbgError("wiauRegGetStrW", "ReqQueryValueEx returned wrong type for key, %d", dwType);
        hr = E_FAIL;
        goto Cleanup;
    }

Cleanup:
    return hr;
}

/**************************************************************************\
* wiauRegGetStrA
\**************************************************************************/
HRESULT wiauRegGetStrA(HKEY hkKey, PCSTR pszValueName, PSTR pszValue, DWORD *pdwLength)
{
    DBG_FN("wiauRegGetStrA");

    HRESULT hr = S_OK;
    
    //
    // Locals
    //
    LONG lReturn = 0;
    DWORD dwType = 0;

    REQUIRE_ARGS(!hkKey || !pszValueName || !pszValue || !pdwLength, hr, "wiauRegGetStrA");

    lReturn = ::RegQueryValueExA(hkKey, pszValueName, NULL, &dwType, (BYTE *) pszValue, pdwLength);
    REQUIRE_WIN32(lReturn, hr, "wiauRegGetStrA", "RegQueryValueExA failed");

    if ((dwType != REG_SZ) &&
        (dwType != REG_EXPAND_SZ) &&
        (dwType != REG_MULTI_SZ)) {

        wiauDbgError("wiauRegGetStrA", "ReqQueryValueEx returned wrong type for key, %d", dwType);
        hr = E_FAIL;
        goto Cleanup;
    }

Cleanup:
    return hr;
}

/**************************************************************************\
* wiauRegGetDwordW
\**************************************************************************/
HRESULT wiauRegGetDwordW(HKEY hkKey, PCTSTR pwszValueName, DWORD *pdwValue)
{
    DBG_FN("wiauRegGetDwordW");

    HRESULT hr = S_OK;
    
    //
    // Locals
    //
    LONG lReturn = 0;
    DWORD dwType = 0;
    DWORD dwLength = sizeof(*pdwValue);

    REQUIRE_ARGS(!hkKey || !pwszValueName || !pdwValue, hr, "wiauRegGetDwordW");

    lReturn = ::RegQueryValueExW(hkKey, pwszValueName, NULL, &dwType, (BYTE *) pdwValue, &dwLength);
    REQUIRE_WIN32(lReturn, hr, "wiauRegGetDwordW", "RegQueryValueExW failed");

    if (dwType != REG_DWORD) {

        wiauDbgError("wiauRegGetDwordW", "ReqQueryValueEx returned wrong type for key, %d", dwType);
        hr = E_FAIL;
        goto Cleanup;
    }

Cleanup:    
    return hr;
}

/**************************************************************************\
* wiauRegGetDwordA
\**************************************************************************/
HRESULT wiauRegGetDwordA(HKEY hkKey, PCSTR pszValueName, DWORD *pdwValue)
{
    DBG_FN("wiauRegGetDwordA");

    HRESULT hr = S_OK;
    
    //
    // Locals
    //
    LONG lReturn = 0;
    DWORD dwType = 0;
    DWORD dwLength = sizeof(*pdwValue);

    REQUIRE_ARGS(!hkKey || !pszValueName || !pdwValue, hr, "wiauRegGetDword");

    lReturn = ::RegQueryValueExA(hkKey, pszValueName, NULL, &dwType, (BYTE *) pdwValue, &dwLength);
    REQUIRE_WIN32(lReturn, hr, "wiauRegGetDwordA", "RegQueryValueExA failed");

    if (dwType != REG_DWORD) {

        wiauDbgError("wiauRegGetDwordA", "ReqQueryValueExA returned wrong type for key, %d", dwType);
        hr = E_FAIL;
        goto Cleanup;
    }

Cleanup:    
    return hr;
}

/**************************************************************************\
* wiauStrW2C
\**************************************************************************/

HRESULT wiauStrW2C(WCHAR *pwszSrc, CHAR *pszDst, INT iSize)
{
    HRESULT hr = S_OK;
    INT iWritten = 0;

    REQUIRE_ARGS(!pwszSrc || !pszDst || iSize < 1, hr, "wiauStrW2C");

    iWritten = WideCharToMultiByte(CP_ACP, 0, pwszSrc, -1, pszDst, iSize, NULL, NULL);
    REQUIRE_FILEIO(iWritten != 0, hr, "wiauStrW2C", "WideCharToMultiByte failed");

Cleanup:
    return hr;
}

/**************************************************************************\
* wiauStrC2W
\**************************************************************************/

HRESULT wiauStrC2W(CHAR *pszSrc, WCHAR *pwszDst, INT iSize)
{
    HRESULT hr = S_OK;
    INT iWritten = 0;

    REQUIRE_ARGS(!pszSrc || !pwszDst || iSize < 1, hr, "wiauStrC2W");

    iWritten = MultiByteToWideChar(CP_ACP, 0, pszSrc, -1, pwszDst, iSize / sizeof(*pwszDst));
    REQUIRE_FILEIO(iWritten != 0, hr, "wiauStrC2W", "MultiByteToWideChar failed");

Cleanup:
    return hr;
}

/**************************************************************************\
* wiauStrW2W
\**************************************************************************/

HRESULT wiauStrW2W(WCHAR *pwszSrc, WCHAR *pwszDst, INT iSize)
{
    HRESULT hr = S_OK;

    REQUIRE_ARGS(!pwszSrc || !pwszDst || iSize < 1, hr, "wiauStrW2W");

    if ((lstrlenW(pwszSrc) + 1) > (iSize / (INT) sizeof(*pwszDst))) {
        hr = ERROR_INSUFFICIENT_BUFFER;
        goto Cleanup;
    }

    lstrcpyW(pwszDst, pwszSrc);

Cleanup:
    return hr;
}

/**************************************************************************\
* wiauStrC2C
\**************************************************************************/

HRESULT wiauStrC2C(CHAR *pszSrc, CHAR *pszDst, INT iSize)
{
    HRESULT hr = S_OK;

    REQUIRE_ARGS(!pszSrc || !pszDst || iSize < 1, hr, "wiauStrC2C");

    if ((lstrlenA(pszSrc) + 1) > iSize) {
        hr = ERROR_INSUFFICIENT_BUFFER;
        goto Cleanup;
    }

    lstrcpyA(pszDst, pszSrc);

Cleanup:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\sti\sampusd\sampusd.cpp ===
/****************************************************************************
 *
 *  SampUSD.CPP
 *
 *  Copyright (C) Microsoft Corporation 1996-1999
 *  All rights reserved
 *
 ***************************************************************************/

#define INITGUID

#include "Sampusd.h"
#include "resource.h"

/*****************************************************************************
 *
 *      Globals
 *
 *****************************************************************************/

// Reference counter for the whole library
DWORD       g_cRef;

// DLL module instance
HINSTANCE   g_hInst;

// Critical section for low level syncronization
CRITICAL_SECTION g_crstDll;

// Can we use UNICODE APIs
BOOL    g_NoUnicodePlatform = TRUE;

// Is COM initialized
BOOL    g_COMInitialized = FALSE;

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllEnterCrit |
 *
 *          Take the DLL critical section.
 *
 *          The DLL critical section is the lowest level critical section.
 *          You may not attempt to acquire any other critical sections or
 *          yield while the DLL critical section is held.
 *
 *****************************************************************************/

void
DllEnterCrit(void)
{
    EnterCriticalSection(&g_crstDll);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllLeaveCrit |
 *
 *          Leave the DLL critical section.
 *
 *****************************************************************************/

void
DllLeaveCrit(void)
{
    LeaveCriticalSection(&g_crstDll);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllAddRef |
 *
 *          Increment the reference count on the DLL.
 *
 *****************************************************************************/

void
DllAddRef(void)
{
    InterlockedIncrement((LPLONG)&g_cRef);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   void | DllRelease |
 *
 *          Decrement the reference count on the DLL.
 *
 *****************************************************************************/

void
DllRelease(void)
{
    InterlockedDecrement((LPLONG)&g_cRef);
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DllInitializeCOM |
 *
 *          Initialize COM libraries
 *
 *  @parm   IN  |  |
 *
 *  @returns
 *
 *          Returns a boolean error code.
 *
 *****************************************************************************/

BOOL
DllInitializeCOM(
    void
    )
{
    DllEnterCrit();

    if(!g_COMInitialized) {
        if(SUCCEEDED(CoInitialize(NULL))) {
            g_COMInitialized = TRUE;
        }
    }

    DllLeaveCrit();

    return g_COMInitialized;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DllUnInitializeCOM |
 *
 *          UnInitialize COM libraries
 *
 *  @parm   IN  |  |
 *
 *  @returns
 *
 *          Returns a boolean error code.
 *
 *****************************************************************************/
BOOL
DllUnInitializeCOM(
    void
    )
{
    DllEnterCrit();

    if(g_COMInitialized) {
        CoUninitialize();
        g_COMInitialized = FALSE;
    }

    DllLeaveCrit();

    return TRUE;
}

/*****************************************************************************
 *
 *  @class UsdSampClassFactory |
 *
 *****************************************************************************/

class UsdSampClassFactory : public IClassFactory
{
private:
    ULONG   m_cRef;

public:
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID *ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    STDMETHODIMP CreateInstance(
            /* [unique][in] */ IUnknown __RPC_FAR *pUnkOuter,
            /* [in] */ REFIID riid,
            /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject);

    STDMETHODIMP LockServer(
            /* [in] */ BOOL fLock);

    UsdSampClassFactory();
};

UsdSampClassFactory::UsdSampClassFactory()
{
    //DEBUGPRINTF((DBG_LVL_DEBUG, TEXT("UsdSampClassFactory: Constructor")));

    // Constructor logic
    m_cRef = 0;
}


STDMETHODIMP UsdSampClassFactory::QueryInterface(
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject)
{
    // DEBUGPRINTF((DBG_LVL_DEBUG, TEXT("UsdSampClassFactory: QueryInterface")));

    *ppvObject = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IClassFactory)) {
        *ppvObject = (LPVOID)this;
        AddRef();
        return NOERROR;
    }
    return ResultFromScode(E_NOINTERFACE);
}


STDMETHODIMP_(ULONG) UsdSampClassFactory::AddRef(void)
{
    DllAddRef();
    return ++m_cRef;
}


STDMETHODIMP_(ULONG) UsdSampClassFactory::Release(void)
{
    DllRelease();
    if (--m_cRef == 0) {
        delete this;
        return 0;
    }
    return m_cRef;
}


STDMETHODIMP UsdSampClassFactory::CreateInstance(
    /* [unique][in] */ IUnknown __RPC_FAR *punkOuter,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject)
{

    if (!IsEqualIID(riid, IID_IStiUSD) &&
        !IsEqualIID(riid, IID_IUnknown)) {
        return STIERR_NOINTERFACE;
    }

    // When created for aggregation, only IUnknown can be requested, so fail
    // call if not.
    if (punkOuter && !IsEqualIID(riid, IID_IUnknown)) {
        return CLASS_E_NOAGGREGATION;
    }

    UsdSampDevice    *pDev = NULL;
    HRESULT         hres;

    pDev = new UsdSampDevice(punkOuter);
    if (!pDev) {
        return STIERR_OUTOFMEMORY;
    }

    //
    // Move to the requested interface
    //
    hres = pDev->NonDelegatingQueryInterface(riid,ppvObject);
    pDev->NonDelegatingRelease();

    return hres;
}


STDMETHODIMP UsdSampClassFactory::LockServer(
    /* [in] */ BOOL fLock)
{
    if (fLock) {
        DllAddRef();
    } else {
        DllRelease();
    }

    return NOERROR;
}

/*****************************************************************************
 *
 *  @class UsdSampDevice | INonDelegatingUnknown
 *
 *****************************************************************************/
STDMETHODIMP UsdSampDevice::NonDelegatingQueryInterface( REFIID riid, LPVOID* ppvObj )
{
    HRESULT hres;

    if( !IsValid() || !ppvObj )
    {
        return STIERR_INVALID_PARAM;
    }

    *ppvObj = NULL;

    if( IsEqualIID( riid, IID_IUnknown ))
    {
        *ppvObj = static_cast<INonDelegatingUnknown*>(this);
        hres = S_OK;
    }
    else if( IsEqualIID( riid, IID_IStiUSD ))
    {
        *ppvObj = static_cast<IStiUSD*>(this);
        hres = S_OK;
    }
    else
    {
        hres =  STIERR_NOINTERFACE;
    }

    if (SUCCEEDED(hres)) {
        (reinterpret_cast<IUnknown*>(*ppvObj))->AddRef();
    }

    return hres;
}


STDMETHODIMP_(ULONG) UsdSampDevice::NonDelegatingAddRef( VOID )
{
    ULONG ulRef;
    ulRef = InterlockedIncrement((LPLONG)&m_cRef);
    return ulRef;
}

STDMETHODIMP_(ULONG) UsdSampDevice::NonDelegatingRelease( VOID )
{
    ULONG ulRef;
    ulRef = InterlockedDecrement((LPLONG)&m_cRef);

    if(!ulRef)
    {
        delete this;
    }

    return ulRef;
}

/*****************************************************************************
 *
 *  @class UsdSampDevice | IUnknown (Delegating)
 *
 *         Delegating unknown methods.
 *
 *****************************************************************************/

STDMETHODIMP UsdSampDevice::QueryInterface( REFIID riid, LPVOID* ppvObj )
{
    return m_punkOuter->QueryInterface(riid,ppvObj);
}


STDMETHODIMP_(ULONG) UsdSampDevice::AddRef( VOID )
{
    return m_punkOuter->AddRef();
}

STDMETHODIMP_(ULONG) UsdSampDevice::Release( VOID )
{
    return m_punkOuter->Release();
}


/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   BOOL | DllEntryPoint |
 *
 *          Called to notify the DLL about various things that can happen.
 *
 *          We are not interested in thread attaches and detaches,
 *          so we disable thread notifications for performance reasons.
 *
 *  @parm   HINSTANCE | hinst |
 *
 *          The instance handle of this DLL.
 *
 *  @parm   DWORD | dwReason |
 *
 *          Notification code.
 *
 *  @parm   LPVOID | lpReserved |
 *
 *          Not used.
 *
 *  @returns
 *
 *          Returns <c TRUE> to allow the DLL to load.
 *
 *****************************************************************************/


extern "C"
DLLEXPORT
BOOL APIENTRY
DllEntryPoint(HINSTANCE hinst, DWORD dwReason, LPVOID lpReserved)
{
    switch (dwReason) {
        case DLL_PROCESS_ATTACH:

        g_hInst = hinst;

        // Disable thread library calls to avoid
        // deadlock when we spin up the worker thread

        DisableThreadLibraryCalls(hinst);
        InitializeCriticalSection(&g_crstDll);

        // Set global flags
        // g_NoUnicodePlatform = !OSUtil_IsPlatformUnicode();

        break;

    case DLL_PROCESS_DETACH:
        if (g_cRef) {
            // DPRINTF("Sampusd: Unloaded before all objects Release()d! Crash soon!\r\n");
        }

        // Free COM libraries if connected to them
        // DllUnInitializeCOM();

        break;
    }

    return 1;
}


extern "C"
DLLEXPORT
BOOL WINAPI
DllMain(HINSTANCE hinst, DWORD dwReason, LPVOID lpReserved)
{
    return DllEntryPoint(hinst, dwReason, lpReserved);
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DllCanUnloadNow |
 *
 *          Determine whether the DLL has any outstanding interfaces.
 *
 *  @returns
 *
 *          Returns <c S_OK> if the DLL can unload, <c S_FALSE> if
 *          it is not safe to unload.
 *
 *****************************************************************************/
extern "C"
STDMETHODIMP
DllCanUnloadNow(void)
{
    HRESULT hres;

    hres = g_cRef ? S_FALSE : S_OK;

    return hres;
}

/*****************************************************************************
 *
 *  @doc    INTERNAL
 *
 *  @func   HRESULT | DllGetClassObject |
 *
 *          Create an <i IClassFactory> instance for this DLL.
 *
 *  @parm   REFCLSID | rclsid |
 *
 *          The object being requested.
 *
 *  @parm   RIID | riid |
 *
 *          The desired interface on the object.
 *
 *  @parm   PPV | ppvOut |
 *
 *          Output pointer.
 *
 *  @notes
 *          We support only one class of objects , so this function does not need
 *          to go through table of supported classes , looking for proper constructor
 *
 *
 *****************************************************************************/
extern "C"
STDAPI DllGetClassObject(
    REFCLSID    rclsid,
    REFIID      riid,
    LPVOID      *ppv)
{

    if (!ppv) {
        return ResultFromScode(E_FAIL);
    }

    if (!IsEqualCLSID(rclsid, CLSID_SampUSDObj) ) {
        return ResultFromScode(E_FAIL);
    }

    if (!IsEqualIID(riid, IID_IUnknown) &&
        !IsEqualIID(riid, IID_IClassFactory)) {
        return ResultFromScode(E_NOINTERFACE);
    }

    if (IsEqualCLSID(rclsid, CLSID_SampUSDObj)) {
        UsdSampClassFactory *pcf = new UsdSampClassFactory;
        if (pcf) {
            *ppv = (LPVOID)pcf;
        }
    }

    return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\sti\sampusd\sampusd.h ===
/****************************g************************************************
 *
 *  SampUSD.H
 *
 *  Copyright (C) Microsoft Corporation 1996-1997
 *  All rights reserved
 *
 ***************************************************************************/

//#define WIN32_LEAN_AND_MEAN

#include <windows.h>

#pragma intrinsic(memcmp,memset)

#include <objbase.h>

#include "sti.h"
#include "stierr.h"
#include "stiusd.h"

#if !defined(DLLEXPORT)
#define DLLEXPORT __declspec( dllexport )
#endif

/*
 * Class IID's
 */
#if defined( _WIN32 ) && !defined( _NO_COM)

// This GUID must match that use in the .inf file for this device.

DEFINE_GUID(GUID_NULL, 0L, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);

// {61127F40-E1A5-11D0-B454-00A02438AD48}
DEFINE_GUID(guidEventTimeChanged, 0x61127F40L, 0xE1A5, 0x11D0, 0xB4, 0x54, 0x00, 0xA0, 0x24, 0x38, 0xAD, 0x48);

// {052ED270-28A3-11D1-ACAD-00A02438AD48}
DEFINE_GUID(guidEventSizeChanged, 0x052ED270L, 0x28A3, 0x11D1, 0xAC, 0xAD, 0x00, 0xA0, 0x24, 0x38, 0xAD, 0x48);

// {052ED270-28A3-11D1-ACAD-00A02438AD48}
DEFINE_GUID(guidEventFirstLoaded, 0x052ED270L, 0x28A3, 0x11D3, 0xAC, 0xAD, 0x00, 0xA0, 0x24, 0x38, 0xAD, 0x48);


// {C3A80960-28B1-11D1-ACAD-00A02438AD48}
DEFINE_GUID(CLSID_SampUSDObj, 0xC3A80960L, 0x28B1, 0x11D1, 0xAC, 0xAD, 0x00, 0xA0, 0x24, 0x38, 0xAD, 0x48);

#endif


#define DATASEG_PERINSTANCE     ".instance"
#define DATASEG_SHARED          ".shared"
#define DATASEG_READONLY        ".code"

#define DATASEG_DEFAULT         DATASEG_SHARED

#pragma data_seg(DATASEG_PERINSTANCE)

// Set the default data segment
#pragma data_seg(DATASEG_DEFAULT)

//
// Module ref counting
//
extern  UINT g_cRefThisDll;
extern  UINT g_cLocks;
extern  HINSTANCE   g_hInst;

extern  BOOL DllInitializeCOM(void);
extern  BOOL DllUnInitializeCOM(void);

extern  void DllAddRef(void);
extern  void DllRelease(void);

//
// Auto critical section clss
//

class CRIT_SECT
{
public:
    void Lock() {EnterCriticalSection(&m_sec);}
    void Unlock() {LeaveCriticalSection(&m_sec);}
    CRIT_SECT() {InitializeCriticalSection(&m_sec);}
    ~CRIT_SECT() {DeleteCriticalSection(&m_sec);}
    CRITICAL_SECTION m_sec;
};

class TAKE_CRIT_SECT
{
private:
    CRIT_SECT& _syncres;

public:
    inline TAKE_CRIT_SECT(CRIT_SECT& syncres) : _syncres(syncres) { _syncres.Lock(); }
    inline ~TAKE_CRIT_SECT() { _syncres.Unlock(); }
};

//
// Base class for supporting non-delegating IUnknown for contained objects
//
struct INonDelegatingUnknown
{
    // *** IUnknown-like methods ***
    STDMETHOD(NonDelegatingQueryInterface)( THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,NonDelegatingAddRef)(THIS)  PURE;
    STDMETHOD_(ULONG,NonDelegatingRelease)( THIS) PURE;
};

//
// Class definition for object
//

class UsdSampDevice :  public IStiUSD, public INonDelegatingUnknown
{
private:
    ULONG       m_cRef;
    BOOL        m_fValid;

    CRIT_SECT   m_cs;

    LPUNKNOWN   m_punkOuter;
    PSTIDEVICECONTROL   m_pDcb;
    CHAR        *m_pszDeviceNameA;
    HANDLE      m_DeviceDataHandle;
    DWORD       m_dwLastOperationError;
    DWORD       m_dwAsync ;
    HANDLE      m_hSignalEvent;
    HANDLE      m_hShutdownEvent;
    HANDLE      m_hThread;
    BOOL        m_EventSignalState;


    FILETIME    m_ftLastWriteTime;
    LARGE_INTEGER   m_dwLastHugeSize;

    GUID        m_guidLastEvent;

    BOOL inline IsValid(VOID) {
        return m_fValid;
    }

public:
    // *** IUnknown-like methods ***
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) NonDelegatingAddRef();
    STDMETHODIMP_(ULONG) NonDelegatingRelease();


    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface( REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef( void);
    STDMETHODIMP_(ULONG) Release( void);

    /*** IStiUSD methods ***/
    STDMETHOD(Initialize) (THIS_ PSTIDEVICECONTROL pHelDcb,DWORD dwStiVersion,HKEY hParametersKey)  ;
    STDMETHOD(GetCapabilities) (THIS_ PSTI_USD_CAPS pDevCaps)  ;
    STDMETHOD(GetStatus) (THIS_ PSTI_DEVICE_STATUS pDevStatus)  ;
    STDMETHOD(DeviceReset)(THIS )  ;
    STDMETHOD(Diagnostic)(THIS_ LPDIAG pBuffer)  ;
    STDMETHOD(Escape)(THIS_ STI_RAW_CONTROL_CODE    EscapeFunction,LPVOID  lpInData,DWORD   cbInDataSize,LPVOID pOutData,DWORD dwOutDataSize,LPDWORD pdwActualData)   ;
    STDMETHOD(GetLastError) (THIS_ LPDWORD pdwLastDeviceError)  ;
    STDMETHOD(LockDevice) (THIS )  ;
    STDMETHOD(UnLockDevice) (THIS )  ;
    STDMETHOD(RawReadData)(THIS_ LPVOID lpBuffer,LPDWORD lpdwNumberOfBytes,LPOVERLAPPED lpOverlapped)  ;
    STDMETHOD(RawWriteData)(THIS_ LPVOID lpBuffer,DWORD nNumberOfBytes,LPOVERLAPPED lpOverlapped)  ;
    STDMETHOD(RawReadCommand)(THIS_ LPVOID lpBuffer,LPDWORD lpdwNumberOfBytes,LPOVERLAPPED lpOverlapped)  ;
    STDMETHOD(RawWriteCommand)(THIS_ LPVOID lpBuffer,DWORD nNumberOfBytes,LPOVERLAPPED lpOverlapped)  ;
    STDMETHOD(SetNotificationHandle)(THIS_ HANDLE hEvent)  ;
    STDMETHOD(GetNotificationData)(THIS_ LPSTINOTIFY   lpNotify)  ;
    STDMETHOD(GetLastErrorInfo) (THIS_ STI_ERROR_INFO *pLastErrorInfo);

    /****               ***/
    UsdSampDevice(LPUNKNOWN punkOuter);
    ~UsdSampDevice();

    VOID    RunNotifications(VOID);
    BOOL    IsChangeDetected(GUID    *pguidEvent,BOOL   fRefresh=TRUE);
};

typedef UsdSampDevice *PUsdSampDevice;

//
// Syncronization mechanisms
//
#define ENTERCRITICAL   DllEnterCrit(void);
#define LEAVECRITICAL   DllLeaveCrit(void);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\util\pch.h ===
#include <windows.h>
#include <stddef.h>
#include <objbase.h>
#include <gdiplus.h>
#include <wiamindr.h>
#include "wiautil.h"
#include "private.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\util\cimagestream.cpp ===
/****************************************************************************
*
*  (C) COPYRIGHT 2000, MICROSOFT CORP.
*
*  FILE:        CImageStream.cpp
*
*  VERSION:     1.0
*
*  DATE:        11/8/2000
*
*  AUTHOR:      Dave Parsons
*
*  DESCRIPTION:
*    Implements a special IStream, which can be used with GDI+ image
*    format conversions.
*
*****************************************************************************/

#include "pch.h"

CImageStream::CImageStream() :
    m_pBuffer(NULL),
    m_iSize(0),
    m_iPosition(0),
    m_iOffset(0),

    m_cRef(1)
{
}

CImageStream::~CImageStream()
{
}

STDMETHODIMP CImageStream::SetBuffer(BYTE *pBuffer, INT iSize, SKIP_AMOUNT iSkipAmt)
{
    HRESULT hr = S_OK;

    REQUIRE_ARGS(!pBuffer, hr, "SetBuffer");

    // wiauDbgDump("SetBuffer", "Buffer set to size %d bytes", iSize);

    m_pBuffer = pBuffer;
    m_iSize = iSize;
    m_iPosition = 0;
    switch (iSkipAmt) {
    case SKIP_OFF:
        m_iOffset = 0;
        break;
    case SKIP_FILEHDR:
        m_iOffset = sizeof(BITMAPFILEHEADER);
        break;
    case SKIP_BOTHHDR:
        m_iOffset = sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER);
        break;
    default:
        m_iOffset = 0;
        break;
    }
    memset(&m_Header, 0, sizeof(m_Header));

Cleanup:
    return hr;
}

STDMETHODIMP CImageStream::QueryInterface(REFIID riid, void **ppvObject)
{
    if (ppvObject == 0)
    {
	    return E_POINTER;
    }

    if (riid == IID_IUnknown)
    {
	    AddRef();
	    *ppvObject = (IUnknown*) this;
	    return S_OK;
    }

    if (riid == IID_IStream)
    {
	    AddRef();
	    *ppvObject = (IStream *) this;
	    return S_OK;
    }

    *ppvObject = 0;
    return E_NOINTERFACE;
}

ULONG CImageStream::AddRef(VOID)
{
	return InterlockedIncrement(&m_cRef);
}

ULONG CImageStream::Release(VOID)
{
	ULONG result;

	result = InterlockedDecrement(&m_cRef);

	if(result == 0) {
		delete this;
	}

	return result;
}

STDMETHODIMP CImageStream::Read(void *pv, ULONG cb, ULONG *pcbRead)
{
    HRESULT hr = S_OK;

    // wiauDbgDump("Read", "Reading %d bytes from buffer", cb);

    if (pcbRead)
    {
        *pcbRead = 0;
    }

    if (cb > 0)
    {
        if (m_iPosition >= m_iOffset + m_iSize)
        {
            wiauDbgError("Read", "Attempting to read past end of buffer");
            hr = S_FALSE;
            goto Cleanup;
        }
        
        if ((INT) cb > m_iOffset + m_iSize - m_iPosition)
        {
            hr = S_FALSE;
            cb = m_iOffset + m_iSize - m_iPosition;
        }

        if (m_iPosition < m_iOffset)
        {
            INT iBytesToReadInHeader = min((INT) cb, m_iOffset - m_iPosition);

            memcpy(pv, &m_Header + m_iPosition, iBytesToReadInHeader);
            pv = (PBYTE) pv + iBytesToReadInHeader;
            cb -= iBytesToReadInHeader;
            m_iPosition += iBytesToReadInHeader;

            if (pcbRead)
            {
                *pcbRead += iBytesToReadInHeader;
            }
        }

        if (cb > 0)
        {
            memcpy(pv, m_pBuffer + m_iPosition - m_iOffset, cb);
            m_iPosition += cb;

            if (pcbRead)
            {
                *pcbRead += cb;
            }
        }
    }

Cleanup:
    return hr;
}
    
STDMETHODIMP CImageStream::Write(const void *pv, ULONG cb, ULONG *pcbWritten)
{
    HRESULT hr = S_OK;

    // wiauDbgDump("Write", "Writing %d bytes into buffer", cb);

    if (pcbWritten)
    {
        *pcbWritten = 0;
    }

    if (cb > 0)
    {
        if (m_iPosition >= m_iOffset + m_iSize)
        {
            wiauDbgError("Write", "Attempting to write past end of buffer");
            hr = S_FALSE;
            goto Cleanup;
        }
        
        if ((INT) cb > m_iOffset + m_iSize - m_iPosition)
        {
            hr = S_FALSE;
            cb = m_iOffset + m_iSize - m_iPosition;
        }

        if (m_iPosition < m_iOffset)
        {
            INT iBytesToWriteInHeader = min((INT) cb, m_iOffset - m_iPosition);

            memcpy((PBYTE) &m_Header + m_iPosition, pv, iBytesToWriteInHeader);
            pv = (PBYTE) pv + iBytesToWriteInHeader;
            cb -= iBytesToWriteInHeader;
            m_iPosition += iBytesToWriteInHeader;

            if (pcbWritten)
            {
                *pcbWritten += iBytesToWriteInHeader;
            }
        }

        if (cb > 0)
        {
            memcpy(m_pBuffer + m_iPosition - m_iOffset, pv, cb);
            m_iPosition += cb;

            if (pcbWritten)
            {
                *pcbWritten += cb;
            }
        }
    }

Cleanup:
    return hr;
}

STDMETHODIMP CImageStream::Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER *plibNewPosition)
{
    HRESULT hr = S_OK;

    switch (dwOrigin)
    { 
        case STREAM_SEEK_SET: 
            m_iPosition = dlibMove.LowPart; 
            break;

        case STREAM_SEEK_CUR: 
            m_iPosition += (LONG) dlibMove.LowPart; 
            break;

        case STREAM_SEEK_END: 
            m_iPosition = m_iSize - (LONG) dlibMove.LowPart; 
            break;

        default:
            hr = E_INVALIDARG;
            goto Cleanup;
    }

    if (plibNewPosition)
    {
        plibNewPosition->HighPart = 0;
        plibNewPosition->LowPart = m_iPosition;
    }

    // wiauDbgDump("Seek", "Position set to %d in the buffer", m_iPosition);

Cleanup:
    return hr;
}

STDMETHODIMP CImageStream::SetSize(ULARGE_INTEGER libNewSize)
{
    HRESULT hr = S_OK;

    if (libNewSize.HighPart != 0 ||
        (LONG) libNewSize.LowPart > (m_iSize + m_iOffset)) {
        hr = STG_E_INVALIDFUNCTION;
    }

    return hr;
}

STDMETHODIMP CImageStream::CopyTo(IStream *pstm, ULARGE_INTEGER cb, ULARGE_INTEGER *pcbRead, ULARGE_INTEGER *pcbWritten)
{
	return E_NOTIMPL;
}

STDMETHODIMP CImageStream::Commit(DWORD grfCommitFlags)
{
	return E_NOTIMPL;
}

STDMETHODIMP CImageStream::Revert( void)
{
	return E_NOTIMPL;
}

STDMETHODIMP CImageStream::LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
	return E_NOTIMPL;
}

STDMETHODIMP CImageStream::UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType)
{
	return E_NOTIMPL;
}

STDMETHODIMP CImageStream::Stat(STATSTG *pstatstg, DWORD grfStatFlag)
{     
    ZeroMemory(pstatstg, sizeof(STATSTG));

    pstatstg->type = STGTY_STREAM;
    pstatstg->cbSize.QuadPart = m_iSize;
    pstatstg->grfMode = STGM_READ;

    if (!(grfStatFlag & STATFLAG_NONAME))
    {
        pstatstg->pwcsName = NULL;
    }

    return S_OK;
}

STDMETHODIMP CImageStream::Clone(IStream **ppstm)
{
	return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\util\gdipconv.cpp ===
/****************************************************************************
*
*  (C) COPYRIGHT 2000, MICROSOFT CORP.
*
*  FILE:        gdipconv.cpp
*
*  VERSION:     1.0
*
*  DATE:        11/10/2000
*
*  AUTHOR:      Dave Parsons
*
*  DESCRIPTION:
*    Helper functions for using GDI+ to convert image formats.
*
*****************************************************************************/

#include "pch.h"

using namespace Gdiplus;

CWiauFormatConverter::CWiauFormatConverter() :
    m_Token(NULL),
    m_EncoderCount(0),
    m_pEncoderInfo(NULL)
{
    memset(&m_guidCodecBmp, 0, sizeof(m_guidCodecBmp));
}

CWiauFormatConverter::~CWiauFormatConverter()
{
    if (m_pEncoderInfo)
    {
        delete []m_pEncoderInfo;
        m_pEncoderInfo = NULL;
    }
    
    if (m_Token)
    {
        GdiplusShutdown(m_Token);
        m_Token = NULL;
    }
}

HRESULT CWiauFormatConverter::Init()
{
    HRESULT hr = S_OK;
    GpStatus Status = Ok;

    //
    // Locals
    //
    GdiplusStartupInput gsi;
    ImageCodecInfo *pEncoderInfo = NULL;

    if (m_pEncoderInfo != NULL) {
        wiauDbgError("Init", "Init has already been called");
        goto Cleanup;
    }

    //
    // Start up GDI+
    //
    Status = GdiplusStartup(&m_Token, &gsi, NULL);
    if (Status != Ok)
    {
        wiauDbgError("Init", "GdiplusStartup failed");
        hr = E_FAIL;
        goto Cleanup;
    }

    UINT cbCodecs = 0;

    Status = GetImageEncodersSize(&m_EncoderCount, &cbCodecs);
    if (Status != Ok)
    {
        wiauDbgError("Init", "GetImageEncodersSize failed");
        hr = E_FAIL;
        goto Cleanup;
    }

    m_pEncoderInfo = new BYTE[cbCodecs];
    REQUIRE_ALLOC(m_pEncoderInfo, hr, "Init");

    pEncoderInfo = (ImageCodecInfo *) m_pEncoderInfo;
    
    Status = GetImageEncoders(m_EncoderCount, cbCodecs, pEncoderInfo);
    if (Ok != Status)
    {
        wiauDbgError("Init", "GetImageEncoders failed");
        hr = E_FAIL;
        goto Cleanup;
    }

    for (UINT count = 0; count < m_EncoderCount; count++)
    {
        if (pEncoderInfo[count].FormatID == ImageFormatBMP)
        {
            m_guidCodecBmp = pEncoderInfo[count].Clsid;
            break;
        }
    }

Cleanup:
    if (FAILED(hr)) {
        if (m_pEncoderInfo)
            delete []m_pEncoderInfo;
        m_pEncoderInfo = NULL;
    }
    return hr;
}

BOOL CWiauFormatConverter::IsFormatSupported(const GUID *pguidFormat)
{
    BOOL result = FALSE;

    ImageCodecInfo *pEncoderInfo = (ImageCodecInfo *) m_pEncoderInfo;
    
    for (UINT count = 0; count < m_EncoderCount; count++)
    {
        if (pEncoderInfo[count].FormatID == *pguidFormat)
        {
            result = TRUE;
            break;
        }
    }

    return result;
}

HRESULT CWiauFormatConverter::ConvertToBmp(BYTE *pSource, INT iSourceSize,
                                           BYTE **ppDest, INT *piDestSize,
                                           BMP_IMAGE_INFO *pBmpImageInfo, SKIP_AMOUNT iSkipAmt)
{
    HRESULT hr = S_OK;

    //
    // Locals
    //
    GpStatus Status = Ok;
    CImageStream *pInStream = NULL;
    CImageStream *pOutStream = NULL;
    Image *pSourceImage = NULL;
    BYTE *pTempBuf = NULL;
    SizeF gdipSize;

    //
    // Check args
    //
    REQUIRE_ARGS(!pSource || !ppDest || !piDestSize || !pBmpImageInfo, hr, "ConvertToBmp");

    memset(pBmpImageInfo, 0, sizeof(*pBmpImageInfo));

    //
    // Create a CImageStream from the source memory
    //
    pInStream = new CImageStream;
    REQUIRE_ALLOC(pInStream, hr, "ConvertToBmp");

    hr = pInStream->SetBuffer(pSource, iSourceSize);
    REQUIRE_SUCCESS(hr, "ConvertToBmp", "SetBuffer failed");

    //
    // Create a GDI+ Image object from the IStream
    //
    pSourceImage = new Image(pInStream);
    REQUIRE_ALLOC(pSourceImage, hr, "ConvertToBmp");
    
    if (pSourceImage->GetLastStatus() != Ok)
    {
        wiauDbgError("ConvertToBmp", "Image constructor failed");
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    // Ask GDI+ for the image dimensions, and fill in the
    // passed structure
    //
    Status = pSourceImage->GetPhysicalDimension(&gdipSize);
    if (Status != Ok)
    {
        wiauDbgError("ConvertToBmp", "GetPhysicalDimension failed");
        hr = E_FAIL;
        goto Cleanup;
    }

    pBmpImageInfo->Width = (INT) gdipSize.Width;
    pBmpImageInfo->Height = (INT) gdipSize.Height;
    
    PixelFormat PixFmt = pSourceImage->GetPixelFormat();
    DWORD PixDepth = (PixFmt & 0xFFFF) >> 8;   // Cannot assume image is always 24bits/pixel
    if( PixDepth < 24 ) 
        PixDepth = 24; 
    pBmpImageInfo->ByteWidth = ((pBmpImageInfo->Width * PixDepth + 31) & ~31) / 8;
    pBmpImageInfo->Size = pBmpImageInfo->ByteWidth * pBmpImageInfo->Height;

    switch (iSkipAmt) {
    case SKIP_OFF:
        pBmpImageInfo->Size += sizeof(BITMAPFILEHEADER) + sizeof(BITMAPINFOHEADER);
        break;
    case SKIP_FILEHDR:
        pBmpImageInfo->Size += sizeof(BITMAPINFOHEADER);
        break;
    case SKIP_BOTHHDR:
        break;
    default:
        break;
    }
    
    if (pBmpImageInfo->Size == 0)
    {
        wiauDbgError("ConvertToBmp", "Size of image is zero");
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    // See if the caller passed in a destination buffer, and make sure
    // it is big enough.
    //
    if (*ppDest) {
        if (*piDestSize < pBmpImageInfo->Size) {
            wiauDbgError("ConvertToBmp", "Passed buffer is too small");
            hr = E_INVALIDARG;
            goto Cleanup;
        }
    }

    //
    // Otherwise allocate memory for a buffer
    //
    else
    {
        pTempBuf = new BYTE[pBmpImageInfo->Size];
        REQUIRE_ALLOC(pTempBuf, hr, "ConvertToBmp");

        *ppDest = pTempBuf;
        *piDestSize = pBmpImageInfo->Size;
    }

    //
    // Create output IStream
    //
    pOutStream = new CImageStream;
    REQUIRE_ALLOC(pOutStream, hr, "ConvertToBmp");

    hr = pOutStream->SetBuffer(*ppDest, pBmpImageInfo->Size, iSkipAmt);
    REQUIRE_SUCCESS(hr, "ConvertToBmp", "SetBuffer failed");

    //
    // Write the Image to the output IStream in BMP format
    //
    pSourceImage->Save(pOutStream, &m_guidCodecBmp, NULL);
    if (pSourceImage->GetLastStatus() != Ok)
    {
        wiauDbgError("ConvertToBmp", "GDI+ Save failed");
        hr = E_FAIL;
        goto Cleanup;
    }

Cleanup:
    if (FAILED(hr)) {
        if (pTempBuf) {
            delete []pTempBuf;
            pTempBuf = NULL;
            *ppDest = NULL;
            *piDestSize = 0;
        }
    }
    if (pInStream) {
        pInStream->Release();
    }
    if (pOutStream) {
        pOutStream->Release();
    }
    if (pSourceImage) {
        delete pSourceImage;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\util\sources.inc ===
#############################################################
#
#Copyright (c) 2000  Microsoft Corporation
#
#Author:
#   DavePar
#
#Date:
#    3-Nov-2000
#
#Module Name:
#    sources.inc
#
#Abstract:
#    This file specifies the target component being built and the list of
#    sources files needed to build that component.  Also specifies optional
#    compiler switches and libraries that are unique for the component being
#    built.
#
#  This directory builds
#     WIA driver utility library
#
#############################################################

!include $(PROJECT_ROOT)\wia\wiaenv.inc

TARGETNAME=wiautil
TARGETTYPE=LIBRARY
TARGETPATH=$(OBJ_DIR)

PASS1_PUBLISH= \
        {$(O)\wiautil.lib=$(DDK_LIB_PATH)\wiautil.lib}

INCLUDES= \
        $(INCLUDES); \
        $(DDK_INC_PATH)

PRECOMPILED_CXX = 1
PRECOMPILED_INCLUDE = ..\pch.h
PRECOMPILED_OBJ = pch.obj

SOURCES= \
        ..\wiaprop.cpp \
        ..\gdipconv.cpp \
        ..\CImageStream.cpp \
        ..\wiaudbg.cpp \
        ..\other.cpp

#TARGETLIBS= $(TARGETLIBS) \
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\util\wiaprop.cpp ===
/****************************************************************************
*
*  (C) COPYRIGHT 2000, MICROSOFT CORP.
*
*  FILE:        wiaprop.cpp
*
*  VERSION:     1.0
*
*  DATE:        11/10/2000
*
*  AUTHOR:      Dave Parsons
*
*  DESCRIPTION:
*    Helper functions for initializing WIA driver properties.
*
*****************************************************************************/

#include "pch.h"

//
// Constructor
//
CWiauPropertyList::CWiauPropertyList() :
        m_NumAlloc(0),
        m_NumProps(0),
        m_pId(NULL),
        m_pNames(NULL),
        m_pCurrent(NULL),
        m_pPropSpec(NULL),
        m_pAttrib(NULL)
{
}

//
// Destructor
//
CWiauPropertyList::~CWiauPropertyList()
{
    if (m_pId)
        delete []m_pId;
    if (m_pNames)
        delete []m_pNames;
    if (m_pCurrent)
        delete []m_pCurrent;
    if (m_pPropSpec)
        delete []m_pPropSpec;
    if (m_pAttrib)
        delete []m_pAttrib;
}

//
// This function allocates the property arrays
//
// Input:
//   NumProps -- number of properties to reserve space for. This number can be larger
//               than the actual number used, but cannot be smaller.
//
HRESULT
CWiauPropertyList::Init(INT NumProps)
{
    HRESULT hr = S_OK;

    REQUIRE_ARGS(NumProps < 1, hr, "Init");

    if (m_NumAlloc > 0)
    {
        wiauDbgError("Init", "Property list already initialized");
        hr = E_FAIL;
        goto Cleanup;
    }

    m_pId       = new PROPID[NumProps];
    m_pNames    = new LPOLESTR[NumProps];
    m_pCurrent  = new PROPVARIANT[NumProps];
    m_pPropSpec = new PROPSPEC[NumProps];
    m_pAttrib   = new WIA_PROPERTY_INFO[NumProps];

    REQUIRE_ALLOC(m_pId, hr, "Init");
    REQUIRE_ALLOC(m_pNames, hr, "Init");
    REQUIRE_ALLOC(m_pCurrent, hr, "Init");
    REQUIRE_ALLOC(m_pPropSpec, hr, "Init");
    REQUIRE_ALLOC(m_pAttrib, hr, "Init");

    m_NumAlloc = NumProps;
    m_NumProps = 0;

Cleanup:
    return hr;
}

//
// This function adds a property definition to the arrays
//
// Input:
//   index -- pointer to an int that will be set to the array index, useful
//            for passing to other property functions
//   PropId -- property ID constant
//   PropName -- property name string
//   Access -- determines access to the property, usually either
//             WIA_PROP_READ or WIA_PROP_RW
//   SubType -- indicates subtype of the property, usually either WIA_PROP_NONE,
//              WIA_PROP_RANGE, or WIA_PROP_LIST
//
HRESULT
CWiauPropertyList::DefineProperty(int *pIdx, PROPID PropId, LPOLESTR PropName, ULONG Access, ULONG SubType)
{
    HRESULT hr = S_OK;

    REQUIRE_ARGS(!pIdx, hr, "DefineProperty");

    if (m_NumProps >= m_NumAlloc)
    {
        wiauDbgError("DefineProperty", "PropertyList is full. Increase number passed to Init");
        hr = E_FAIL;
        goto Cleanup;
    }

    int idx = m_NumProps++;

    m_pId[idx] = PropId;

    m_pNames[idx] = PropName;

    m_pCurrent[idx].vt = VT_EMPTY;

    m_pPropSpec[idx].ulKind = PRSPEC_PROPID;
    m_pPropSpec[idx].propid = PropId;

    m_pAttrib[idx].vt = VT_EMPTY;
    m_pAttrib[idx].lAccessFlags = Access | SubType;

    if (pIdx)
        *pIdx = idx;

Cleanup:
    return hr;
}

//
// This function sends all the newly created properties to WIA
//
// Input:
//   pWiasContext -- pointer to the context passed to drvInitItemProperties
//
HRESULT
CWiauPropertyList::SendToWia(BYTE *pWiasContext)
{
    HRESULT hr = S_OK;

    REQUIRE_ARGS(!pWiasContext, hr, "SendToWia");

    if (m_NumProps == 0)
    {
        wiauDbgError("SendToWia", "No properties in the array, use DefineProperty");
        hr = E_FAIL;
        goto Cleanup;
    }

    //
    //  Set the property names
    //
    hr = wiasSetItemPropNames(pWiasContext, m_NumProps, m_pId, m_pNames);
    REQUIRE_SUCCESS(hr, "SendToWia", "wiasSetItemPropNames failed");

    //
    // Set the default values for the properties
    //
    hr = wiasWriteMultiple(pWiasContext, m_NumProps, m_pPropSpec, m_pCurrent);
    REQUIRE_SUCCESS(hr, "SendToWia", "wiasWriteMultiple failed");

    //
    // Set property access and valid value info
    //
    hr =  wiasSetItemPropAttribs(pWiasContext, m_NumProps, m_pPropSpec, m_pAttrib);
    REQUIRE_SUCCESS(hr, "SendToWia", "wiasSetItemPropAttribs failed");

Cleanup:
    return hr;
}

//
// This function can be used to reset the access and subtype of a property
//
// Input:
//   index -- the index into the arrays, pass in value returned from DefineProperty
//   Access -- determines access to the property, usually either
//             WIA_PROP_READ or WIA_PROP_RW
//   SubType -- indicates subtype of the property, usually either WIA_PROP_NONE,
//              WIA_PROP_RANGE, or WIA_PROP_LIST
//
VOID
CWiauPropertyList::SetAccessSubType(INT index, ULONG Access, ULONG SubType)
{
    m_pAttrib[index].lAccessFlags = Access | SubType;
}

//
// Polymorphic function for setting the type and current, default, and valid values of a
// property. This function handles flag properties.
//
// Input:
//   index -- the index into the arrays, pass in value returned from DefineProperty
//   defaultValue -- default setting of this property on the device
//   currentValue -- current setting of this property on the device
//   validFlags -- combination of all valid flags
//
VOID
CWiauPropertyList::SetValidValues(INT index, LONG defaultValue, LONG currentValue, LONG validFlags)
{
    m_pAttrib[index].vt                       = VT_I4;
    m_pAttrib[index].ValidVal.Flag.Nom        = defaultValue;
    m_pAttrib[index].ValidVal.Flag.ValidBits  = validFlags;
    m_pAttrib[index].lAccessFlags            |= WIA_PROP_FLAG;
    
    m_pCurrent[index].vt   = VT_I4;
    m_pCurrent[index].lVal = currentValue;

    return;
}

//
// Polymorphic function for setting the type and current, default, and valid values of a
// property. This function handles VT_I4 range.
//
// Input:
//   index -- the index into the arrays, pass in value returned from DefineProperty
//   defaultValue -- default setting of this property on the device
//   currentValue -- current setting of this property on the device
//   minValue -- minimum value for the range
//   maxValue -- maximum value for the range
//   stepValue -- step value for the range
//
VOID
CWiauPropertyList::SetValidValues(INT index, LONG defaultValue, LONG currentValue,
                                 LONG minValue, LONG maxValue, LONG stepValue)
{
    m_pAttrib[index].vt                  = VT_I4;
    m_pAttrib[index].ValidVal.Range.Nom  = defaultValue;
    m_pAttrib[index].ValidVal.Range.Min  = minValue;
    m_pAttrib[index].ValidVal.Range.Max  = maxValue;
    m_pAttrib[index].ValidVal.Range.Inc  = stepValue;
    m_pAttrib[index].lAccessFlags       |= WIA_PROP_RANGE;
    
    m_pCurrent[index].vt   = VT_I4;
    m_pCurrent[index].lVal = currentValue;

    return;
}

//
// Polymorphic function for setting the type and current, default, and valid values of a
// property. This function handles VT_I4 list.
//
// Input:
//   index -- the index into the arrays, pass in value returned from DefineProperty
//   defaultValue -- default setting of this property on the device
//   currentValue -- current setting of this property on the device
//   numValues -- number of values in the list
//   pValues -- pointer to the value list
//
VOID
CWiauPropertyList::SetValidValues(INT index, LONG defaultValue, LONG currentValue,
                                 INT numValues, PLONG pValues)
{
    m_pAttrib[index].vt                      = VT_I4;
    m_pAttrib[index].ValidVal.List.Nom       = defaultValue;
    m_pAttrib[index].ValidVal.List.cNumList  = numValues;
    m_pAttrib[index].ValidVal.List.pList     = (BYTE*)pValues;
    m_pAttrib[index].lAccessFlags           |= WIA_PROP_LIST;

    m_pCurrent[index].vt   = VT_I4;
    m_pCurrent[index].lVal = currentValue;

    return;    
}

//
// Polymorphic function for setting the type and current, default, and valid values of a
// property. This function handles VT_BSTR list.
//
// Input:
//   index -- the index into the arrays, pass in value returned from DefineProperty
//   defaultValue -- default setting of this property on the device
//   currentValue -- current setting of this property on the device
//   numValues -- number of values in the list
//   pValues -- pointer to the value list
//
VOID
CWiauPropertyList::SetValidValues(INT index, BSTR defaultValue, BSTR currentValue,
                                 INT numValues, BSTR *pValues)
{
    m_pAttrib[index].vt                          = VT_BSTR;
    m_pAttrib[index].ValidVal.ListBStr.Nom       = defaultValue;
    m_pAttrib[index].ValidVal.ListBStr.cNumList  = numValues;
    m_pAttrib[index].ValidVal.ListBStr.pList     = pValues;
    m_pAttrib[index].lAccessFlags               |= WIA_PROP_LIST;

    m_pCurrent[index].vt      = VT_BSTR;
    m_pCurrent[index].bstrVal = currentValue;

    return;    
}

//
// Polymorphic function for setting the type and current, default, and valid values of a
// property. This function handles VT_R4 range.
//
// Input:
//   index -- the index into the arrays, pass in value returned from DefineProperty
//   defaultValue -- default setting of this property on the device
//   currentValue -- current setting of this property on the device
//   minValue -- minimum value for the range
//   maxValue -- maximum value for the range
//   stepValue -- step value for the range
//
VOID
CWiauPropertyList::SetValidValues(INT index, FLOAT defaultValue, FLOAT currentValue,
                                 FLOAT minValue, FLOAT maxValue, FLOAT stepValue)
{
    m_pAttrib[index].vt                       = VT_R4;
    m_pAttrib[index].ValidVal.RangeFloat.Nom  = defaultValue;
    m_pAttrib[index].ValidVal.RangeFloat.Min  = minValue;
    m_pAttrib[index].ValidVal.RangeFloat.Max  = maxValue;
    m_pAttrib[index].ValidVal.RangeFloat.Inc  = stepValue;
    m_pAttrib[index].lAccessFlags            |= WIA_PROP_RANGE;
    
    m_pCurrent[index].vt     = VT_R4;
    m_pCurrent[index].fltVal = currentValue;

    return;
}

//
// Polymorphic function for setting the type and current, default, and valid values of a
// property. This function handles VT_R4 list.
//
// Input:
//   index -- the index into the arrays, pass in value returned from DefineProperty
//   defaultValue -- default setting of this property on the device
//   currentValue -- current setting of this property on the device
//   numValues -- number of values in the list
//   pValues -- pointer to the value list
//
VOID
CWiauPropertyList::SetValidValues(INT index, FLOAT defaultValue, FLOAT currentValue,
                                 INT numValues, PFLOAT pValues)
{
    m_pAttrib[index].vt                           = VT_R4;
    m_pAttrib[index].ValidVal.ListFloat.Nom       = defaultValue;
    m_pAttrib[index].ValidVal.ListFloat.cNumList  = numValues;
    m_pAttrib[index].ValidVal.ListFloat.pList     = (BYTE*)pValues;
    m_pAttrib[index].lAccessFlags                |= WIA_PROP_LIST;

    m_pCurrent[index].vt     = VT_R4;
    m_pCurrent[index].fltVal = currentValue;

    return;    
}

//
// Polymorphic function for setting the type and current, default, and valid values of a
// property. This function handles VT_CLSID list.
//
// Input:
//   index -- the index into the arrays, pass in value returned from DefineProperty
//   defaultValue -- default setting of this property on the device
//   currentValue -- current setting of this property on the device
//   numValues -- number of values in the list
//   pValues -- pointer to the value list
//
VOID
CWiauPropertyList::SetValidValues(INT index, CLSID *defaultValue, CLSID *currentValue,
                                 INT numValues, CLSID **pValues)
{
    m_pAttrib[index].vt                          = VT_CLSID;
    m_pAttrib[index].ValidVal.ListGuid.Nom       = *defaultValue;
    m_pAttrib[index].ValidVal.ListGuid.cNumList  = numValues;
    m_pAttrib[index].ValidVal.ListGuid.pList     = *pValues;
    m_pAttrib[index].lAccessFlags               |= WIA_PROP_LIST;

    m_pCurrent[index].vt    = VT_CLSID;
    m_pCurrent[index].puuid = currentValue;

    return;    
}

//
// Polymorphic function for setting the type and current value for a VT_I4
//
// Input:
//   index -- the index into the arrays, pass in value returned from DefineProperty
//   value -- value to use for the current value
//
VOID
CWiauPropertyList::SetCurrentValue(INT index, LONG value)
{
    m_pCurrent[index].vt   = VT_I4;
    m_pAttrib[index].vt    = VT_I4;
    m_pCurrent[index].lVal = value;

    return;
}

//
// Polymorphic function for setting the type and current value for a VT_BSTR
//
// Input:
//   index -- the index into the arrays, pass in value returned from DefineProperty
//   value -- value to use for the current value
//
VOID
CWiauPropertyList::SetCurrentValue(INT index, BSTR value)
{
    m_pCurrent[index].vt      = VT_BSTR;
    m_pAttrib[index].vt       = VT_BSTR;
    m_pCurrent[index].bstrVal = value;

    return;
}

//
// Polymorphic function for setting the type and current value for a VT_R4
//
// Input:
//   index -- the index into the arrays, pass in value returned from DefineProperty
//   value -- value to use for the current value
//
VOID
CWiauPropertyList::SetCurrentValue(INT index, FLOAT value)
{
    m_pCurrent[index].vt     = VT_R4;
    m_pAttrib[index].vt      = VT_R4;
    m_pCurrent[index].fltVal = value;

    return;
}

//
// Polymorphic function for setting the type and current value for a VT_CLSID
//
// Input:
//   index -- the index into the arrays, pass in value returned from DefineProperty
//   value -- value to use for the current value
//
VOID
CWiauPropertyList::SetCurrentValue(INT index, CLSID *pValue)
{
    m_pCurrent[index].vt     = VT_CLSID;
    m_pAttrib[index].vt      = VT_CLSID;
    m_pCurrent[index].puuid  = pValue;

    return;
}

//
// Polymorphic function for setting the type and current value for a property which holds a SYSTEMTIME
//
// Input:
//   index -- the index into the arrays, pass in value returned from DefineProperty
//   value -- value to use for the current value
//
VOID
CWiauPropertyList::SetCurrentValue(INT index, PSYSTEMTIME value)
{
    m_pCurrent[index].vt           = VT_UI2 | VT_VECTOR;
    m_pAttrib[index].vt            = VT_UI2 | VT_VECTOR;
    m_pAttrib[index].lAccessFlags |= WIA_PROP_NONE;
    m_pCurrent[index].caui.cElems  = sizeof(SYSTEMTIME)/sizeof(WORD);
    m_pCurrent[index].caui.pElems  = (USHORT *) value;

    return;
}

//
// Polymorphic function for setting the type and current value for a property which holds a VT_UI1 vector
//
// Input:
//   index -- the index into the arrays, pass in value returned from DefineProperty
//   value -- value to use for the current value
//   size -- number of elements in the vector
//
VOID
CWiauPropertyList::SetCurrentValue(INT index, BYTE *value, INT size)
{
    m_pCurrent[index].vt          = VT_UI1 | VT_VECTOR;
    m_pAttrib[index].vt           = VT_UI1 | VT_VECTOR;
    m_pCurrent[index].caub.cElems = size;
    m_pCurrent[index].caub.pElems = value;

    return;
}

//
// Finds the index given a property ID
//
INT
CWiauPropertyList::LookupPropId(PROPID PropId)
{
    for (int count = 0; count < m_NumProps; count++)
    {
        if (m_pId[count] == PropId)
            return count;
    }

    //
    // Value not found
    //
    return -1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\video\filter\inpin.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       inpin.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu (taken from WilliamH src)
 *
 *  DATE:        9/7/99
 *
 *  DESCRIPTION: input pin definitions
 *
 *****************************************************************************/

#ifndef __INPIN_H_
#define __INPIN_H_

class CStillFilter;
class CStillOutputPin;

class CStillInputPin : public CBaseInputPin
{

    friend class CStillOutputPin;
    friend class CStillFilter;

public:
    CStillInputPin(TCHAR        *pObjName, 
                   CStillFilter *pStillFilter, 
                   HRESULT      *phr, 
                   LPCWSTR      pPinName);

    HRESULT         CheckMediaType(const CMediaType* pmt);
    HRESULT         SetMediaType(const CMediaType *pmt);
    STDMETHODIMP    Receive(IMediaSample* pSample);
    STDMETHODIMP    BeginFlush();
    STDMETHODIMP    EndFlush();
    STDMETHODIMP    EndOfStream();
    STDMETHODIMP    NewSegment(REFERENCE_TIME tStart,REFERENCE_TIME tStop,double dRate);
    HRESULT         Active();
    HRESULT         Inactive();
    HRESULT         SetSamplingSize(int Size);
    int             GetSamplingSize();
    HRESULT         Snapshot(ULONG TimeStamp);
    HRESULT         InitializeSampleQueue(int Size);
    HRESULT         UnInitializeSampleQueue();

    IMemAllocator* GetAllocator();

private:

    HRESULT CreateBitmap(BYTE       *pBits, 
                         HGLOBAL    *phDib);

    HRESULT DeliverBitmap(HGLOBAL hDib);

    HRESULT FreeBitmap(HGLOBAL hDib);

    HRESULT AddFrameToQueue(BYTE *pBits);

#ifdef DEBUG
    void DumpSampleQueue(ULONG ulRequestedTimestamp);
#endif

    CCritSec        m_QueueLock;

    int             m_SamplingSize;
    DWORD           m_BitsSize;
    int             m_SampleHead;
    int             m_SampleTail;
    STILL_SAMPLE   *m_pSamples;
    BYTE           *m_pBits;

};

inline IMemAllocator* CStillInputPin::GetAllocator()
{
    // The input pin only has an allocator if it is connected.
    ASSERT(IsConnected());

    // m_pAllocator should never be NULL if the input pin is connected.
    ASSERT(m_pAllocator != NULL);

    return m_pAllocator;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\video\filter\inpin.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998-2000
 *
 *  TITLE:       inpin.cpp
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        9/7/98
 *               2000/11/13 - OrenR - Major bug fixes 
 *
 *  DESCRIPTION: This module implements CStillInputPin object.
 *
 *****************************************************************************/

#include <precomp.h>
#pragma hdrstop

///////////////////////////////
// g_AcceptedMediaSubtypes
//
const CLSID* g_AcceptedMediaSubtypes[] =
{
     &MEDIATYPE_NULL,
     &MEDIASUBTYPE_RGB8,
     &MEDIASUBTYPE_RGB555,
     &MEDIASUBTYPE_RGB565,
     &MEDIASUBTYPE_RGB24,
     &MEDIASUBTYPE_RGB32,
     NULL
};

/*****************************************************************************

   CStillInputPin Constructor

   <Notes>

 *****************************************************************************/

CStillInputPin::CStillInputPin(TCHAR        *pObjName,
                               CStillFilter *pStillFilter,
                               HRESULT      *phr,
                               LPCWSTR      pPinName) :
    m_pSamples(NULL),
    m_SampleHead(0),
    m_SampleTail(0),
    m_SamplingSize(0),
    m_pBits(NULL),
    m_BitsSize(0),
    CBaseInputPin(pObjName, (CBaseFilter *)pStillFilter, &m_QueueLock, phr, pPinName)
{
    DBG_FN("CStillInputPin::CStillInputPin");
}


/*****************************************************************************

   CStillInputPin::CheckMediaType

   <Notes>

 *****************************************************************************/

HRESULT
CStillInputPin::CheckMediaType(const CMediaType* pmt)
{
    DBG_FN("CStillInputPin::CheckMediaType");
    ASSERT(this     !=NULL);
    ASSERT(pmt      !=NULL);

    HRESULT hr            = S_OK;
    INT     iMediaSubtype = 0; 

    //
    // Check for bad params
    //

    if (pmt == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CStillInputPin::CheckMediaType, failed because we received a "
                         "NULL CMediaType pointer"));
    }

    //
    // we only accept the subtypes in our 
    // g_AcceptedMediaSubtypes list above.
    //

    if (hr == S_OK)
    {
        //
        // This should be a Video media type, otherwise, no point in 
        // continuing.
        //
        const GUID *pType = pmt->Type();

        if ((pType  == NULL) ||
            (*pType != MEDIATYPE_Video))
        {
            hr = VFW_E_TYPE_NOT_ACCEPTED;    
        }
    }

    //
    // Search our g_AcceptedMediaSubtypes list to see if the we support
    // the subtype being requested.
    //
    if (hr == S_OK)
    {
        BOOL       bFound    = FALSE;
        const GUID *pSubType = pmt->Subtype();

        iMediaSubtype = 0;

        while ((g_AcceptedMediaSubtypes[iMediaSubtype] != NULL) && 
               (!bFound))
        {
            //
            // Check if the GUID passed in to us is equal to the
            //

            if ((pSubType) &&
                (*pSubType == *g_AcceptedMediaSubtypes[iMediaSubtype]))
            {
                hr = S_OK;
                bFound = TRUE;
            }
            else
            {
                ++iMediaSubtype;
            }
        }

        if (!bFound)
        {
            hr = VFW_E_TYPE_NOT_ACCEPTED;
        }
    }

    //
    // So far so good.  We found the requested SubType, so now verify
    // that we aren't using any compression.
    //
    if (hr == S_OK)
    {
        //
        // Assume that this won't work.
        //
        hr = VFW_E_TYPE_NOT_ACCEPTED;

        //
        // media type and subtype are acceptable 
        // check for compression. 
        //
        // We do not do any decompression at all.
        //

        BITMAPINFOHEADER *pBitmapInfoHeader = NULL;
        const GUID       *pFormatType       = pmt->FormatType();

        if (pFormatType)
        {
            if (*pFormatType == FORMAT_VideoInfo)
            {
                VIDEOINFOHEADER  *pVideoInfoHeader  = NULL;

                DBG_TRC(("CStillInputPin::CheckMediaType, FORMAT_VideoInfo"));
                pVideoInfoHeader = reinterpret_cast<VIDEOINFOHEADER*>(pmt->Format());

                if (pVideoInfoHeader)
                {
                    pBitmapInfoHeader = &(pVideoInfoHeader->bmiHeader);
                }
            }
        }

        if (pBitmapInfoHeader)
        {
            if ((pBitmapInfoHeader->biCompression == BI_RGB) ||
                (pBitmapInfoHeader->biCompression == BI_BITFIELDS))
            {
                //
                // Cool, this is an acceptable media type, return 
                // success
                //
                hr = S_OK;
            }
        }
    }

    //
    // Okay, we like this media type.  We now check it against the
    // current display.  For example, if the bit depth of this 
    // media type is greater than the video card currently supports,
    // then this will reject it, and ask for another.
    //
    if (hr == S_OK)
    {
        CImageDisplay ImageDisplay;

        hr = ImageDisplay.CheckMediaType(pmt);
    }

    return hr;
}


/*****************************************************************************

   CStillInputPin::EndOfStream

   This is just a filter -- we pretty much just forward this message on.

 *****************************************************************************/

HRESULT
CStillInputPin::EndOfStream()
{
    DBG_FN("CStillInputPin::EndOfStream");
    ASSERT(this!=NULL);
    ASSERT(m_pFilter!=NULL);

    //
    // We must call this according to the MSDN documentation.  It states
    // that this must be called to ensure that the state of the filter
    // is okay before we proceed to deliver this indicator.
    //
    HRESULT hr = CheckStreaming();

    if (hr == S_OK)
    {
        if (m_pFilter && ((CStillFilter*)m_pFilter)->m_pOutputPin)
        {
            hr =  ((CStillFilter*)m_pFilter)->m_pOutputPin->DeliverEndOfStream();

            CHECK_S_OK2(hr,("m_pOutputPin->DeliverEndOfStream()"));
    
            if (VFW_E_NOT_CONNECTED == hr)
            {
                hr = S_OK;
            }
        }
    }

    CHECK_S_OK(hr);
    return hr;
}


/*****************************************************************************

   CStillInputPin::BeginFlush

   This is just a filter -- we pretty much just forward this message on.

 *****************************************************************************/

HRESULT
CStillInputPin::BeginFlush()
{
    DBG_FN("CStillInputPin::BeginFlush");
    ASSERT(this!=NULL);
    ASSERT(m_pFilter!=NULL);

    //
    // We must call BeginFlush on the base input pin because it will set the
    // state of the object so that it cannot receive anymore media samples
    // while we are flushing.  Make sure we do this at the beginning of this
    // function.
    //
    HRESULT hr = CBaseInputPin::BeginFlush();

    if (FAILED(hr))
    {
        return hr;
    }

    //
    // Begin flush means we must empty out our sample queue.
    //

    int iSampleSize = m_SamplingSize;

    //
    // UnInitalize our sample queue to discard any samples we may currently
    // have queued.
    //
    hr = UnInitializeSampleQueue();
    CHECK_S_OK2(hr, ("CStillInputPin::BeginFlush, failed to uninitialize "
                     "sample queue"));

    //
    // Re-Initialize the sample queue so that we have our buffer, but it
    // is empty.
    //
    hr = InitializeSampleQueue(iSampleSize);
    CHECK_S_OK2(hr, ("CStillInputPin::BeginFlush, failed to re-initialize "
                     "the sample queue"));

    //
    // Deliver the BeginFlush message downstream
    //
    if (m_pFilter && ((CStillFilter*)m_pFilter)->m_pOutputPin)
    {
        hr =  ((CStillFilter*)m_pFilter)->m_pOutputPin->DeliverBeginFlush();
        if (VFW_E_NOT_CONNECTED == hr)
        {
            hr = S_OK;
        }
        CHECK_S_OK2(hr,("m_pOutputPin->DeliverBeginFlush()"));
    }

    CHECK_S_OK(hr);
    return hr;
}


/*****************************************************************************

   CStillInputPin::EndFlush

   This is just a filter -- we pretty much just forward this message on.

 *****************************************************************************/

HRESULT
CStillInputPin::EndFlush()
{
    DBG_FN("CStillInputPin::EndFlush");
    ASSERT(this!=NULL);
    ASSERT(m_pFilter!=NULL);

    HRESULT hr = E_POINTER;

    //
    // Deliver the EndFlush message downstream.
    //
    if (m_pFilter && ((CStillFilter*)m_pFilter)->m_pOutputPin)
    {
        hr = ((CStillFilter*)m_pFilter)->m_pOutputPin->DeliverEndFlush();

        if (VFW_E_NOT_CONNECTED == hr)
        {
            hr = S_OK;
        }

        CHECK_S_OK2(hr,("m_pOutputPin->DeliverEndFlush()"));
    }

    if (FAILED(hr))
    {
        return hr;
    }

    //
    // We must call the EndFlush function implemented by the base input
    // pin as it will set the state of the object such that we are now
    // ready to receive new media samples again.  Make sure we call this at
    // the end of this function.
    //
    hr = CBaseInputPin::EndFlush();

    CHECK_S_OK(hr);
    return hr;
}


/*****************************************************************************

   CStillInputPin::NewSegment

   This is just a filter -- we pretty much just forward this message on.

 *****************************************************************************/
HRESULT
CStillInputPin::NewSegment(REFERENCE_TIME tStart,
                           REFERENCE_TIME tStop,
                           double dRate)
{
    DBG_FN("CStillInputPin::NewSegment");
    ASSERT(this!=NULL);
    ASSERT(m_pFilter!=NULL);

    HRESULT hr = E_POINTER;

    if (m_pFilter && ((CStillFilter*)m_pFilter)->m_pOutputPin)
    {
        hr = ((CStillFilter*)m_pFilter)->m_pOutputPin->DeliverNewSegment(
                                                                tStart, 
                                                                tStop, 
                                                                dRate);

        if (VFW_E_NOT_CONNECTED == hr)
        {
            hr = S_OK;
        }

        CHECK_S_OK2(hr,("m_pOutputPin->DeliverNewSegment"
                        "(tStart, tStop, dRate)"));
    }

    CHECK_S_OK(hr);
    return hr;
}


/*****************************************************************************

   CStillInputPin::SetMediaType

   <Notes>

 *****************************************************************************/
HRESULT
CStillInputPin::SetMediaType(const CMediaType *pmt)
{
    DBG_FN("CStillInputPin::SetMediaType");

    ASSERT(this         !=NULL);
    ASSERT(m_pFilter    !=NULL);
    ASSERT(pmt          !=NULL);

    HRESULT hr = S_OK;

#ifdef DEBUG
    // Display the type of the media for debugging perposes
//    DBG_TRC(("CStillInputPin::SetMediaType, setting the following "
//             "media type for Still Filter"));
//    DisplayMediaType( pmt );
#endif


    if ((m_pFilter == NULL) ||
        (pmt       == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CStillInputPin::SetMediaType, received either a NULL "
                         "media type pointer, or our filter pointer is NULL.  "
                         "pmt = 0x%08lx, m_pFilter = 0x%08lx", pmt, m_pFilter));

        return hr;
    }
    
    BITMAPINFOHEADER    *pBitmapInfoHeader = NULL;
    const GUID          *pFormatType       = pFormatType = pmt->FormatType();

    if (hr == S_OK)
    {
        ASSERT(pFormatType != NULL);

        if (pFormatType)
        {
            // We need to get the BitmapInfoHeader

            if (*pFormatType == FORMAT_VideoInfo)
            {
                VIDEOINFOHEADER *pHdr = reinterpret_cast<VIDEOINFOHEADER*>(pmt->Format());

                if (pHdr)
                {
                    pBitmapInfoHeader = &(pHdr->bmiHeader);
                }
            }
            else
            {
                hr = E_FAIL;
                CHECK_S_OK2(hr, ("CStillInputPin::SetMediaType, received a Format Type other "
                         "than a FORMAT_VideoInfo.  This is the "
                         "only supported format"));
            }
            
            ASSERT (pBitmapInfoHeader != NULL);
        }
        else
        {
            hr = E_FAIL;
            CHECK_S_OK2(hr, ("CStillInputPin::SetMediaType, pFormatType is NULL, this should "
                             "never happen"));
        }
    
        if (pBitmapInfoHeader)
        {
            hr = ((CStillFilter*)m_pFilter)->InitializeBitmapInfo(pBitmapInfoHeader);
        
            CHECK_S_OK2(hr,("m_pFilter->InitializeBitmapInfo()"));
        
            m_BitsSize = ((CStillFilter*)m_pFilter)->GetBitsSize();
        
            //
            // see if the base class likes it
            //
        
            hr = CBaseInputPin::SetMediaType(pmt);
            CHECK_S_OK2(hr,("CBaseInputPin::SetMediaType(pmt)"));
        }
        else
        {
            hr = E_FAIL;
            CHECK_S_OK2(hr, ("CStillInputPin::SetMediaType, pBitmapInfoHeader is NULL, "
                             "this should never happen"));
        }
    }

    CHECK_S_OK(hr);
    return hr;
}


/*****************************************************************************

   CStillInputPin::Receive

   A new frame has arrived. If we have a sampling queue, put it into the
   queue, otherwise, deliver to the filter immediately.

 *****************************************************************************/

HRESULT
CStillInputPin::Receive(IMediaSample* pSample)
{
    ASSERT(this!=NULL);
    ASSERT(m_pFilter!=NULL);
    ASSERT(pSample!=NULL);

    HRESULT hr = E_POINTER;

    // 
    // Check all is well with the base class Receive function.
    //
    hr = CBaseInputPin::Receive(pSample);

    //
    // Check for bad args
    //

    if (hr == S_OK)
    {
        //
        // copy the sample data to the sampling queue
        //

        if ((DWORD)pSample->GetActualDataLength() == m_BitsSize)
        {
            BYTE *pBits = NULL;

            hr = pSample->GetPointer(&pBits);
            CHECK_S_OK2(hr,("CStillInputPin::Receive, "
                            "pSample->GetPointer(&pBits)"));

            if (SUCCEEDED(hr) && pBits)
            {
                if (m_SamplingSize > 1)
                {
                    //
                    // Add this sample's bits to our queue.
                    //
                    AddFrameToQueue(pBits);
                }
                else
                {
                    //
                    // single sample. send  it immediately
                    //

                    if (m_pFilter)
                    {
                        HRESULT hr2 = S_OK;

                        HGLOBAL hDib = NULL;

                        hr2 = CreateBitmap(pBits, &hDib);

                        CHECK_S_OK2(hr2, ("CStillInputFilter::Receive, "
                                          "CreateBitmap failed.  This "
                                          "is non fatal"));

                        if (hDib)
                        {
                            hr2 = DeliverBitmap(hDib);

                            CHECK_S_OK2(hr2, 
                                        ("CStillInputFilter::Receive, "
                                         "DeliverBitmap failed.  This "
                                         "is non fatal"));

                            hr2 = FreeBitmap(hDib);

                            CHECK_S_OK2(hr2, 
                                        ("CStillInputFilter::Receive, "
                                         "FreeBitmap failed.  This is "
                                         "non fatal"));
                        }
                    }
                    else
                    {
                        DBG_ERR(("CStillInputPin::Receive .m_pFilter is NULL, "
                                 "not calling DeliverSnapshot"));
                    }
                }
            }
            else
            {
                if (!pBits)
                {
                    DBG_ERR(("CStillInputPin::Receive, pBits is NULL"));
                }
            }
        }
        else
        {
            DBG_ERR(("CStillInputPin::Receive, pSample->GetActualDataLength "
                     "!= m_BitsSize"));
        }

        if (m_pFilter)
        {
            if (((CStillFilter*)m_pFilter)->m_pOutputPin)
            {
                hr = ((CStillFilter*)m_pFilter)->m_pOutputPin->Deliver(pSample);

                CHECK_S_OK2(hr,("CStillInputPin::Receive, "
                                "m_pFilter->m_pOutputPin->Deliver(pSample) "
                                "failed"));
            }
            else
            {
                hr = E_POINTER;
                CHECK_S_OK2(hr, ("CStillInputPin::Receive, "
                                 "m_pFilter->m_pOutputPin is NULL, not "
                                 "calling Deliver"));
            }
        }
        else
        {
            hr = E_POINTER;
            CHECK_S_OK2(hr, ("CStillInputPin::Receive, m_pFilter is NULL, "
                             "not calling m_pOutputPin->Deliver"));
            
        }

        //
        // it is possible that our output pin is not connected
        // we fake an error here.
        //

        if (VFW_E_NOT_CONNECTED == hr)
        {
            hr = S_OK;
        }
    }
    else
    {
        DBG_ERR(("CStillInputPin::Receive bad args detected, pSample is "
                 "NULL!"));
    }

    CHECK_S_OK(hr);
    return hr;
}

/*****************************************************************************

   CStillInputPin::Active

   <Notes>

 *****************************************************************************/

HRESULT
CStillInputPin::Active()
{
    DBG_FN("CStillInputPin::Active");
    ASSERT(this!=NULL);

    HRESULT hr;

    //
    // time to allocate sample queue
    //

    hr = InitializeSampleQueue(m_SamplingSize);
    CHECK_S_OK2(hr,("InitializeSampleQueue"));

    return hr;
}


/*****************************************************************************

   CStillInputPin::Inactive

   <Notes>

 *****************************************************************************/

HRESULT
CStillInputPin::Inactive()
{
    DBG_FN("CStillInputPin::Inactive");
    ASSERT(this!=NULL);

    HRESULT hr = S_OK;

    hr = UnInitializeSampleQueue();

    CHECK_S_OK(hr);
    return hr;
}


/*****************************************************************************

   CStillInputPin::GetSamplingSize

   <Notes>

 *****************************************************************************/

int
CStillInputPin::GetSamplingSize()
{
    DBG_FN("CStillInputPin::GetSamplingSize");
    ASSERT(this!=NULL);

    return m_SamplingSize;
}


/*****************************************************************************

   CStillInputPin::SetSamplingSize

   <Notes>

 *****************************************************************************/

HRESULT
CStillInputPin::SetSamplingSize(int Size)
{
    DBG_FN("CStillInputPin::SetSamplingSize");
    ASSERT(this!=NULL);

    //
    // this can only be done when we are in stopped state
    //

    if (!IsStopped())
    {
        DBG_ERR(("Setting sampling size while not in stopped state"));
        return VFW_E_NOT_STOPPED;
    }

    return InitializeSampleQueue(Size);
}



/*****************************************************************************

   CStillInputPin::InitializeSampleQueue

   Initialize sampling queue. Each sample in the queue contain a frame and
   timestamp.

 *****************************************************************************/

HRESULT
CStillInputPin::InitializeSampleQueue(int Size)
{
    DBG_FN("CStillInputPin::InitializeSampleQueue");
    ASSERT(this!=NULL);

    HRESULT hr = S_OK;

    //
    // Check for bad args
    //

    if (Size < 0 || Size > MAX_SAMPLE_SIZE)
    {
        hr = E_INVALIDARG;
    }

    if (hr == S_OK)
    {
        m_QueueLock.Lock();

        if (!m_pSamples || Size != m_SamplingSize)
        {
            m_SamplingSize = Size;
            if (m_pSamples)
            {
                delete [] m_pSamples;
                m_pSamples = NULL;

                if (m_pBits)
                {
                    delete [] m_pBits;
                    m_pBits = NULL;
                }
            }

            //
            // if size is one, we do not allocate any sample cache at all.
            //

            if (Size > 1)
            {
                m_pSamples = new STILL_SAMPLE[Size];
                if (m_pSamples)
                {
                    m_pBits = new BYTE[m_BitsSize * Size];
                    if (m_pBits)
                    {
                        for (int i = 0; i < Size ; i++)
                        {
                            m_pSamples[i].pBits = m_pBits + i * m_BitsSize;
                        }
                    }
                    else
                    {
                        delete [] m_pSamples;
                        m_pSamples = NULL;

                        hr = E_OUTOFMEMORY;
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }

        m_SampleHead = 0;
        m_SampleTail = 0;

        m_QueueLock.Unlock();

        hr = S_OK;
    }

    CHECK_S_OK(hr);
    return hr;
}

/*****************************************************************************

   CStillInputPin::UnInitializeSampleQueue

   Initialize sampling queue. Each sample in the queue contain a frame and
   timestamp.

 *****************************************************************************/

HRESULT
CStillInputPin::UnInitializeSampleQueue()
{
    DBG_FN("CStillInputPin::UnInitializeSampleQueue");

    ASSERT(this!=NULL);

    HRESULT hr = S_OK;

    if (hr == S_OK)
    {
        m_QueueLock.Lock();

        if (m_pSamples)
        {
            delete [] m_pSamples;
            m_pSamples = NULL;

            delete [] m_pBits;
            m_pBits = NULL;
        }

        m_SampleHead = 0;
        m_SampleTail = 0;

        m_QueueLock.Unlock();
    }

    return hr;
}



/*****************************************************************************

   CStillInputPin::Snapshot

   Does a snapshot on the video stream.
   The give timestamp is compared against each queued sample and
   a final candidate is determined and delivered.

 *****************************************************************************/

HRESULT
CStillInputPin::Snapshot(ULONG TimeStamp)
{
    DBG_FN("CStillInputPin::Snapshot");

    ASSERT(this!=NULL);
    ASSERT(m_pFilter!=NULL);

    HRESULT hr = S_OK;

    //
    // if we do not have cache at all, do nothing
    //

    if (m_SamplingSize > 1 || m_pSamples)
    {
        m_QueueLock.Lock();

        HGLOBAL hDib                = NULL;
        int     MinTimeDifference   = INT_MAX;
        int     TimeDifference      = 0;
        int     PreferSampleIndex   = -1;
        int     iSampleHead         = m_SampleHead;
        int     iSampleTail         = m_SampleTail;

        if (iSampleTail == iSampleHead)
        {
            DBG_ERR(("CStillInputPin::Snapshot, sample queue is empty, "
                     "not able to deliver a snapshot"));
        }

        //
        // Search for the sample who's timestamp is closest to the requested 
        // timestamp.
        //
        while (iSampleTail != iSampleHead)
        {
            if (m_pSamples)
            {
                TimeDifference = abs(m_pSamples[iSampleTail].TimeStamp - 
                                     TimeStamp);
            }
            else
            {
                TimeDifference = 0;
            }

            if (MinTimeDifference > TimeDifference)
            {
                PreferSampleIndex = iSampleTail;
                MinTimeDifference = TimeDifference;
            }

            if (++iSampleTail >= m_SamplingSize)
                iSampleTail = 0;
        }

        //
        // We found our sample, now deliver it.
        // Notice that we unlock the queue after we created our bitmap AND 
        // before we deliver it.
        //
        // ***NOTE***
        // It is VERY important that we free the lock before delivering 
        // the bitmap because the delivery process will probably involve 
        // saving to a file which is very time consuming, which would 
        // guarantee that we drop frames, which we would like to try and 
        // avoid.
        //

        //
        // Create our bitmap.  This copies the bits out of the sample queue
        // so that they can be delivered.  Since the bits are copied out of 
        // the queue, we are safe in releasing the queue lock after the 
        // copy operation.
        //
        if (PreferSampleIndex != -1)
        {
            hr = CreateBitmap(m_pSamples[PreferSampleIndex].pBits, &hDib);
        }
        else
        {
            //
            // We couldn't find a sample, tell someone, and also dump
            // the sample queue for analysis, since this shouldn't really 
            // happen considering we receive about 15 to 30 samples per second.
            //
            DBG_WRN(("CStillInputPin::Snapshot, could not find sample with "
                     "close enough timestamp to requested timestamp of '%d'",
                     TimeStamp));

#ifdef DEBUG
            DumpSampleQueue(TimeStamp);
#endif
        }

        //
        // Unlock our queue.
        //
        m_QueueLock.Unlock();

        //
        // If we successfully created the bitmap, then deliver it, and then
        // free it.
        //
        if (hDib)
        {
            //
            // Deliver the bitmap via the registered callback function in the 
            // filter.
            //
            hr = DeliverBitmap(hDib);

            CHECK_S_OK2(hr, ("CStillInputPin::Snapshot, failed to deliver "
                             "bitmap"));

            //
            // Free the bitmap
            //
            FreeBitmap(hDib);
            hDib = NULL;
        }
    }
    

    CHECK_S_OK(hr);
    return hr;
}

/*****************************************************************************

   CStillInputPin::AddFrameToQueue

   <Notes>

 *****************************************************************************/

HRESULT
CStillInputPin::AddFrameToQueue(BYTE *pBits)
{
    HRESULT hr = S_OK;

    m_QueueLock.Lock();

    if (m_pSamples)
    {
        m_pSamples[m_SampleHead].TimeStamp = GetTickCount();

        memcpy(m_pSamples[m_SampleHead].pBits, pBits, m_BitsSize);

        if (++m_SampleHead >= m_SamplingSize)
        {
            m_SampleHead = 0;
        }

        if (m_SampleHead == m_SampleTail)
        {
            //
            //overflowing, discard the very last one
            //

            if (++m_SampleTail >= m_SamplingSize)
                m_SampleTail = 0;
        }
    }
    else
    {
        DBG_ERR(("CStillInputPin::AddFrameToQueue, m_pSamples is NULL!"));
    }

    m_QueueLock.Unlock();

    return hr;
}

/*****************************************************************************

   CStillInputPin::CreateBitmap

   <Notes>

 *****************************************************************************/

HRESULT 
CStillInputPin::CreateBitmap(BYTE    *pBits, 
                             HGLOBAL *phDib)
{
    DBG_FN("CStillInputPin::CreateBitmap");

    ASSERT(m_pFilter != NULL);
    ASSERT(this      != NULL);
    ASSERT(pBits     != NULL);
    ASSERT(phDib     != NULL);

    HRESULT hr = S_OK;

    if ((pBits == NULL) ||
        (phDib == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CStillInputPin::CreateBitmap received NULL param"));
    }
    else if (m_pFilter == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CStillInputPin::CreateBitmap, m_pFilter is NULL"));
    }

    if (hr == S_OK)
    {
        HGLOBAL hDIB = GlobalAlloc(GHND, 
                                   ((CStillFilter*)m_pFilter)->m_DIBSize);

        if (hDIB)
        {
            BYTE *pDIB = NULL;

            pDIB = (BYTE*) GlobalLock(hDIB);

            if (pDIB && ((CStillFilter*) m_pFilter)->m_pbmi)
            {
                memcpy(pDIB, 
                       ((CStillFilter*) m_pFilter)->m_pbmi, 
                       ((CStillFilter*) m_pFilter)->m_bmiSize);

                memcpy(pDIB + ((CStillFilter*) m_pFilter)->m_bmiSize, 
                       pBits, 
                       ((CStillFilter*) m_pFilter)->m_BitsSize);

                GlobalUnlock(hDIB);

                *phDib = hDIB;
            }
            else
            {
                GlobalFree(hDIB);
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}

/*****************************************************************************

   CStillInputPin::FreeBitmap

   <Notes>

 *****************************************************************************/

HRESULT
CStillInputPin::FreeBitmap(HGLOBAL hDib)
{
    DBG_FN("CStillInputPin::FreeBitmap");

    HRESULT hr = S_OK;

    if (hDib)
    {
        GlobalFree(hDib);
    }

    return hr;
}

/*****************************************************************************

   CStillInputPin::DeliverBitmap

   <Notes>

 *****************************************************************************/

HRESULT
CStillInputPin::DeliverBitmap(HGLOBAL hDib)
{
    DBG_FN("CStillInputPin::DeliverBitmap");

    ASSERT(m_pFilter != NULL);
    ASSERT(hDib      != NULL);

    HRESULT hr = S_OK;

    if ((m_pFilter == NULL) ||
        (hDib      == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CStillInputPin::DeliverBitmap received NULL "
                         "param"));
    }

    if (hr == S_OK)
    {
        hr = ((CStillFilter*)m_pFilter)->DeliverSnapshot(hDib);
    }

    return hr;
}


#ifdef DEBUG
/*****************************************************************************

   CStillInputPin::DumpSampleQueue

   Used for debugging, dumps the queue of samples showing their
   timestamps

 *****************************************************************************/

void
CStillInputPin::DumpSampleQueue(ULONG ulRequestedTimestamp)
{
    DBG_TRC(("***CStillPin::DumpSampleQueue, dumping queued filter samples, "
             "Requested TimeStamp = '%lu' ***", ulRequestedTimestamp));

    if (m_SamplingSize > 1 || m_pSamples)
    {
        for (int i = 0; i < m_SamplingSize; i++)
        {
            int TimeDifference;

            if (m_pSamples)
            {
                TimeDifference = abs(m_pSamples[i].TimeStamp - 
                                     ulRequestedTimestamp);
            }
            else
            {
                TimeDifference = 0;
            }

            DBG_PRT(("Sample: '%d',  Timestamp: '%lu', Abs Diff: '%d'",
                     i,
                     m_pSamples[i].TimeStamp,
                     TimeDifference));
        }
    }

    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\util\rwspy\detours.h ===
//////////////////////////////////////////////////////////////////////////////
//
//  File:       detours.h
//  Module:     detours.lib
//
//  Detours for binary functions.  Version 1.3. (Build 43)
//
//  Copyright 1995-1999, Microsoft Corporation
//
//  http://research.microsoft.com/sn/detours
//

#pragma once
#ifndef _DETOURS_H_
#define _DETOURS_H_

#pragma comment(lib, "detours")

//////////////////////////////////////////////////////////////////////////////
//
#ifndef GUID_DEFINED
#define GUID_DEFINED
typedef struct  _GUID
{
    DWORD Data1;
    WORD Data2;
    WORD Data3;
    BYTE Data4[ 8 ];
} GUID;
#endif // !GUID_DEFINED

#if defined(__cplusplus)
#ifndef _REFGUID_DEFINED
#define _REFGUID_DEFINED
#define REFGUID             const GUID &
#endif // !_REFGUID_DEFINED
#else // !__cplusplus
#ifndef _REFGUID_DEFINED
#define _REFGUID_DEFINED
#define REFGUID             const GUID * const
#endif // !_REFGUID_DEFINED
#endif // !__cplusplus
//
//////////////////////////////////////////////////////////////////////////////

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/////////////////////////////////////////////////// Instruction Target Macros.
//
#define DETOUR_INSTRUCTION_TARGET_NONE          ((PBYTE)0)
#define DETOUR_INSTRUCTION_TARGET_DYNAMIC       ((PBYTE)~0ul)

/////////////////////////////////////////////////////////// Trampoline Macros.
//
// DETOUR_TRAMPOLINE(trampoline_prototype, target_name)
//
// The naked trampoline must be at least DETOUR_TRAMPOLINE_SIZE bytes.
//
#define DETOUR_TRAMPOLINE_SIZE          32
#define DETOUR_SECTION_HEADER_SIGNATURE 0x00727444   // "Dtr\0"

#define DETOUR_TRAMPOLINE(trampoline,target) \
static PVOID __fastcall _Detours_GetVA_##target(VOID) \
{ \
    return &target; \
} \
\
__declspec(naked) trampoline \
{ \
    __asm { nop };\
    __asm { nop };\
    __asm { call _Detours_GetVA_##target };\
    __asm { jmp eax };\
    __asm { ret };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
}

#define DETOUR_TRAMPOLINE_EMPTY(trampoline) \
__declspec(naked) trampoline \
{ \
    __asm { nop };\
    __asm { nop };\
    __asm { xor eax, eax };\
    __asm { mov eax, [eax] };\
    __asm { ret };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
    __asm { nop };\
}

/////////////////////////////////////////////////////////// Binary Structures.
//
#pragma pack(push, 8)
typedef struct _DETOUR_SECTION_HEADER
{
    DWORD       cbHeaderSize;
    DWORD       nSignature;
    DWORD       nDataOffset;
    DWORD       cbDataSize;
    
    DWORD       nOriginalImportVirtualAddress;
    DWORD       nOriginalImportSize;
    DWORD       nOriginalBoundImportVirtualAddress;
    DWORD       nOriginalBoundImportSize;
    
    DWORD       nOriginalIatVirtualAddress;
    DWORD       nOriginalIatSize;
    DWORD       nOriginalSizeOfImage;
    DWORD       nReserve;
} DETOUR_SECTION_HEADER, *PDETOUR_SECTION_HEADER;

typedef struct _DETOUR_SECTION_RECORD
{
    DWORD       cbBytes;
    DWORD       nReserved;
    GUID        guid;
} DETOUR_SECTION_RECORD, *PDETOUR_SECTION_RECORD;
#pragma pack(pop)

#define DETOUR_SECTION_HEADER_DECLARE(cbSectionSize) \
{ \
      sizeof(DETOUR_SECTION_HEADER),\
      DETOUR_SECTION_HEADER_SIGNATURE,\
      sizeof(DETOUR_SECTION_HEADER),\
      (cbSectionSize),\
      \
      0,\
      0,\
      0,\
      0,\
      \
      0,\
      0,\
      0,\
      0,\
}

///////////////////////////////////////////////////////////// Binary Typedefs.
//
typedef BOOL (CALLBACK *PF_DETOUR_BINARY_BYWAY_CALLBACK)(PVOID pContext,
                                                         PCHAR pszFile,
                                                         PCHAR *ppszOutFile);
typedef BOOL (CALLBACK *PF_DETOUR_BINARY_FILE_CALLBACK)(PVOID pContext,
                                                        PCHAR pszOrigFile,
                                                        PCHAR pszFile,
                                                        PCHAR *ppszOutFile);
typedef BOOL (CALLBACK *PF_DETOUR_BINARY_SYMBOL_CALLBACK)(PVOID pContext,
                                                          DWORD nOrdinal,
                                                          PCHAR pszOrigSymbol,
                                                          PCHAR pszSymbol,
                                                          PCHAR *ppszOutSymbol);
typedef BOOL (CALLBACK *PF_DETOUR_BINARY_FINAL_CALLBACK)(PVOID pContext);
typedef BOOL (CALLBACK *PF_DETOUR_BINARY_EXPORT_CALLBACK)(PVOID pContext,
                                                          DWORD nOrdinal,
                                                          PCHAR pszName,
                                                          PBYTE pbCode);

typedef VOID * PDETOUR_BINARY;
typedef VOID * PDETOUR_LOADED_BINARY;

//////////////////////////////////////////////////////// Trampoline Functions.
//
PBYTE WINAPI DetourFunction(PBYTE pbTargetFunction,
                            PBYTE pbDetourFunction);

BOOL WINAPI DetourFunctionWithEmptyTrampoline(PBYTE pbTrampoline,
                                              PBYTE pbTarget,
                                              PBYTE pbDetour);

BOOL WINAPI DetourFunctionWithEmptyTrampolineEx(PBYTE pbTrampoline,
                                                PBYTE pbTarget,
                                                PBYTE pbDetour,
                                                PBYTE *ppbRealTrampoline,
                                                PBYTE *ppbRealTarget,
                                                PBYTE *ppbRealDetour);

BOOL  WINAPI DetourFunctionWithTrampoline(PBYTE pbTrampoline,
                                          PBYTE pbDetour);

BOOL  WINAPI DetourFunctionWithTrampolineEx(PBYTE pbTrampoline,
                                            PBYTE pbDetour,
                                            PBYTE *ppbRealTrampoline,
                                            PBYTE *ppbRealTarget);

BOOL  WINAPI DetourRemove(PBYTE pbTrampoline, PBYTE pbDetour);

////////////////////////////////////////////////////////////// Code Functions.
//
PBYTE WINAPI DetourFindFunction(PCHAR pszModule, PCHAR pszFunction);
PBYTE WINAPI DetourGetFinalCode(PBYTE pbCode, BOOL fSkipJmp);

PBYTE WINAPI DetourCopyInstruction(PBYTE pbDst, PBYTE pbSrc, PBYTE *ppbTarget);
PBYTE WINAPI DetourCopyInstructionEx(PBYTE pbDst,
                                     PBYTE pbSrc,
                                     PBYTE *ppbTarget,
                                     LONG *plExtra);

///////////////////////////////////////////////////// Loaded Binary Functions.
//
HMODULE WINAPI DetourEnumerateModules(HMODULE hModuleLast);
PBYTE WINAPI DetourGetEntryPoint(HMODULE hModule);
BOOL WINAPI DetourEnumerateExports(HMODULE hModule,
                                   PVOID pContext,
                                   PF_DETOUR_BINARY_EXPORT_CALLBACK pfExport);

PBYTE WINAPI DetourFindPayload(HMODULE hModule, REFGUID rguid, DWORD *pcbData);
DWORD WINAPI DetourGetSizeOfPayloads(HMODULE hModule);

///////////////////////////////////////////////// Persistent Binary Functions.
//
BOOL WINAPI DetourBinaryBindA(PCHAR pszFile, PCHAR pszDll, PCHAR pszPath);
BOOL WINAPI DetourBinaryBindW(PWCHAR pwzFile, PWCHAR pwzDll, PWCHAR pwzPath);
#ifdef UNICODE
#define DetourBinaryBind  DetourBinaryBindW
#else
#define DetourBinaryBind  DetourBinaryBindA
#endif // !UNICODE

PDETOUR_BINARY WINAPI DetourBinaryOpen(HANDLE hFile);
PBYTE WINAPI DetourBinaryEnumeratePayloads(PDETOUR_BINARY pBinary,
                                           GUID *pGuid,
                                           DWORD *pcbData,
                                           DWORD *pnIterator);
PBYTE WINAPI DetourBinaryFindPayload(PDETOUR_BINARY pBinary,
                                     REFGUID rguid,
                                     DWORD *pcbData);
PBYTE WINAPI DetourBinarySetPayload(PDETOUR_BINARY pBinary,
                                    REFGUID rguid,
                                    PBYTE pbData,
                                    DWORD cbData);
BOOL WINAPI DetourBinaryDeletePayload(PDETOUR_BINARY pBinary, REFGUID rguid);
BOOL WINAPI DetourBinaryPurgePayloads(PDETOUR_BINARY pBinary);
BOOL WINAPI DetourBinaryResetImports(PDETOUR_BINARY pBinary);
BOOL WINAPI DetourBinaryEditImports(PDETOUR_BINARY pBinary,
                                    PVOID pContext,
                                    PF_DETOUR_BINARY_BYWAY_CALLBACK pfByway,
                                    PF_DETOUR_BINARY_FILE_CALLBACK pfFile,
                                    PF_DETOUR_BINARY_SYMBOL_CALLBACK pfSymbol,
                                    PF_DETOUR_BINARY_FINAL_CALLBACK pfFinal);
BOOL WINAPI DetourBinaryWrite(PDETOUR_BINARY pBinary, HANDLE hFile);
BOOL WINAPI DetourBinaryClose(PDETOUR_BINARY pBinary);

/////////////////////////////////////////////// First Chance Exception Filter.
//
LPTOP_LEVEL_EXCEPTION_FILTER WINAPI
DetourFirstChanceExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelFilter);

///////////////////////////////////////////////// Create Process & Inject Dll.
//
typedef BOOL (WINAPI *PDETOUR_CREATE_PROCESS_ROUTINEA)
    (LPCSTR lpApplicationName,
     LPSTR lpCommandLine,
     LPSECURITY_ATTRIBUTES lpProcessAttributes,
     LPSECURITY_ATTRIBUTES lpThreadAttributes,
     BOOL bInheritHandles,
     DWORD dwCreationFlags,
     LPVOID lpEnvironment,
     LPCSTR lpCurrentDirectory,
     LPSTARTUPINFOA lpStartupInfo,
     LPPROCESS_INFORMATION lpProcessInformation);

typedef BOOL (WINAPI *PDETOUR_CREATE_PROCESS_ROUTINEW)
    (LPCWSTR lpApplicationName,
     LPWSTR lpCommandLine,
     LPSECURITY_ATTRIBUTES lpProcessAttributes,
     LPSECURITY_ATTRIBUTES lpThreadAttributes,
     BOOL bInheritHandles,
     DWORD dwCreationFlags,
     LPVOID lpEnvironment,
     LPCWSTR lpCurrentDirectory,
     LPSTARTUPINFOW lpStartupInfo,
     LPPROCESS_INFORMATION lpProcessInformation);
                                  
BOOL WINAPI DetourCreateProcessWithDllA(LPCSTR lpApplicationName,
                                        LPSTR lpCommandLine,
                                        LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                        LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                        BOOL bInheritHandles,
                                        DWORD dwCreationFlags,
                                        LPVOID lpEnvironment,
                                        LPCSTR lpCurrentDirectory,
                                        LPSTARTUPINFOA lpStartupInfo,
                                        LPPROCESS_INFORMATION lpProcessInformation,
                                        LPCSTR lpDllName,
                                        PDETOUR_CREATE_PROCESS_ROUTINEA
                                        pfCreateProcessA);

BOOL WINAPI DetourCreateProcessWithDllW(LPCWSTR lpApplicationName,
                                        LPWSTR lpCommandLine,
                                        LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                        LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                        BOOL bInheritHandles,
                                        DWORD dwCreationFlags,
                                        LPVOID lpEnvironment,
                                        LPCWSTR lpCurrentDirectory,
                                        LPSTARTUPINFOW lpStartupInfo,
                                        LPPROCESS_INFORMATION lpProcessInformation,
                                        LPCWSTR lpDllName,
                                        PDETOUR_CREATE_PROCESS_ROUTINEW
                                        pfCreateProcessW);
                  
#ifdef UNICODE
#define DetourCreateProcessWithDll  DetourCreateProcessWithDllW
#define PDETOUR_CREATE_PROCESS_ROUTINE     PDETOUR_CREATE_PROCESS_ROUTINEW
#else
#define DetourCreateProcessWithDll  DetourCreateProcessWithDllA
#define PDETOUR_CREATE_PROCESS_ROUTINE     PDETOUR_CREATE_PROCESS_ROUTINEA
#endif // !UNICODE

BOOL WINAPI DetourContinueProcessWithDllA(HANDLE hProcess, LPCSTR lpDllName);
BOOL WINAPI DetourContinueProcessWithDllW(HANDLE hProcess, LPCWSTR lpDllName);

#ifdef UNICODE
#define DetourContinueProcessWithDll    DetourContinueProcessWithDllW
#else
#define DetourContinueProcessWithDll    DetourContinueProcessWithDllA
#endif // !UNICODE
//
//////////////////////////////////////////////////////////////////////////////
#ifdef __cplusplus
}
#endif // __cplusplus

/////////////////////////////////////////////////////////////////// Old Names.
//
#define ContinueProcessWithDll            DetourContinueProcessWithDll 
#define ContinueProcessWithDllA           DetourContinueProcessWithDllA
#define ContinueProcessWithDllW           DetourContinueProcessWithDllW
#define CreateProcessWithDll              DetourCreateProcessWithDll 
#define CreateProcessWithDllA             DetourCreateProcessWithDllA
#define CreateProcessWithDllW             DetourCreateProcessWithDllW
#define DETOUR_TRAMPOLINE_WO_TARGET       DETOUR_TRAMPOLINE_EMPTY
#define DetourBinaryPurgePayload          DetourBinaryPurgePayloads
#define DetourEnumerateExportsForInstance DetourEnumerateExports
#define DetourEnumerateInstances          DetourEnumerateModules
#define DetourFindEntryPointForInstance   DetourGetEntryPoint
#define DetourFindFinalCode               DetourGetFinalCode
#define DetourFindPayloadInBinary         DetourFindPayload
#define DetourGetSizeOfBinary             DetourGetSizeOfPayloads
#define DetourRemoveWithTrampoline        DetourRemove
#define PCREATE_PROCESS_ROUTINE           PDETOUR_CREATE_PROCESS_ROUTINE
#define PCREATE_PROCESS_ROUTINEA          PDETOUR_CREATE_PROCESS_ROUTINEA
#define PCREATE_PROCESS_ROUTINEW          PDETOUR_CREATE_PROCESS_ROUTINEW
//

#endif // _DETOURS_H_

////////////////////////////////////////////////////////////////  End of File.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\util\wiaudbg.cpp ===
/****************************************************************************
*
*  (C) COPYRIGHT 2000, MICROSOFT CORP.
*
*  FILE:        wiaudbg.cpp
*
*  VERSION:     1.0
*
*  DATE:        11/21/2000
*
*  AUTHOR:      
*
*  DESCRIPTION:
*    Implementation of debugging functions.
*
*****************************************************************************/

#include "pch.h"

//#include "cplusinc.h"
#include "stdlib.h"
#include "stdio.h"

// debug log is saved to this file 
#define WIAUDBG_FILE_NAME "%systemroot%\\wiadebug.log"
// registry key location
#define WIAUDBG_FLAGS_REGKEY "System\\CurrentControlSet\\Control\\StillImage\\Debug"
// registry DWORD value name
#define WIAUDBG_FLAGS_REGVAL "DebugFlags"
// registry DWORD for max log file size
#define WIAUDBG_REGVAL_FILE_SIZE_LIMIT "DebugFileSizeLimit"
#define WIAUDBG_FILE_SIZE_LIMIT (512 * 1024) // bytes
// Prefix for all messages
const CHAR PREFIX_WIA[] = "WIA: ";

// if we fail to acquire mutex within this time, shutdown tracing
const INT WIAUDBG_DEBUG_TIMEOUT = 10000;

// globals
DWORD  g_dwDebugFlags         = WIAUDBG_DEFAULT_FLAGS;
HANDLE g_hDebugFile           = INVALID_HANDLE_VALUE;
DWORD  g_dwDebugFileSizeLimit = WIAUDBG_FILE_SIZE_LIMIT;
BOOL   g_bDebugInited         = FALSE;

static CHAR   g_szDebugFileName[MAX_PATH] = "";
static CHAR   g_szModuleName[MAX_PATH]    = "";
static HANDLE g_hDebugFileMutex           = NULL;
static BOOL   g_bInited                   = FALSE;
static BOOL   g_bBannerPrinted            = FALSE;

#undef TRACE
#ifdef DEBUG
#define TRACE(x) WiauInternalTrace x
#else
#define TRACE(x)
#endif

////////////////////////////////////////////////
// WiauInternalTrace
//
// Internal tracing for problems in DebugWrite
//
static void WiauInternalTrace(LPCSTR fmt, ...)
{
    char buffer[1024];
    size_t len = 0;
    va_list marker;

    va_start(marker, fmt);

    _vsnprintf(buffer, 1024, fmt, marker);
    len = strlen(buffer);
    if(len > 0) 
    {
        // make sure the line has terminating "\n"
        if(buffer[len - 1] != '\n') {
            buffer[len++] = '\n';
            buffer[len] = '\0';
        }
        OutputDebugStringA(buffer);
    }

    va_end(marker);
}


////////////////////////////////////////////////
// WiauCreateLogFileMutex
//
// Create logfile mutex with appropriate DACL
//
BOOL WiauCreateLogFileMutex(void)
{
#undef CHECK
#define CHECK(x) if(!(x)) { \
     TRACE(("%s(%d): %s failed (%d)", __FILE__, __LINE__, #x, GetLastError())); \
     goto Cleanup; } 
#undef CHECK2
#define CHECK2(x, y) if(!(x)) { \
     TRACE(("%s(%d): %s failed (%d)", __FILE__, __LINE__, #x, GetLastError())); \
     TRACE(y); goto Cleanup; } 

    BOOL success = FALSE;
    char rgchSD[SECURITY_DESCRIPTOR_MIN_LENGTH];
    PSECURITY_DESCRIPTOR pSD = (PSECURITY_DESCRIPTOR) &rgchSD;
    SECURITY_ATTRIBUTES     sa;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    PSID AuthenticatedUsers = NULL;
    PSID BuiltinAdministrators = NULL;
    ULONG AclSize;
    ACL *pAcl = NULL;

    CHECK(AllocateAndInitializeSid(&NtAuthority, 2,
                                   SECURITY_BUILTIN_DOMAIN_RID,
                                   DOMAIN_ALIAS_RID_ADMINS,
                                   0, 0, 0, 0, 0, 0,
                                   &BuiltinAdministrators));
    CHECK(AllocateAndInitializeSid(&NtAuthority, 1,
                                   SECURITY_BUILTIN_DOMAIN_RID,
                                   SECURITY_AUTHENTICATED_USER_RID,
                                   0, 0, 0, 0, 0, 0,
                                   &AuthenticatedUsers));
    AclSize = sizeof(ACL) +
              2 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(ULONG)) +
              GetLengthSid(BuiltinAdministrators) +
              GetLengthSid(AuthenticatedUsers);
    pAcl = (ACL *)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, AclSize);
    CHECK(pAcl);

    CHECK(InitializeAcl(pAcl, AclSize, ACL_REVISION));
    CHECK(AddAccessAllowedAce(pAcl, ACL_REVISION,
                              GENERIC_ALL, BuiltinAdministrators));
    CHECK(AddAccessAllowedAce(pAcl, ACL_REVISION,
                              SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE,
                              AuthenticatedUsers));

    CHECK(InitializeSecurityDescriptor(pSD, SECURITY_DESCRIPTOR_REVISION));
    sa.nLength = sizeof(sa);
    sa.bInheritHandle = TRUE;
    CHECK(SetSecurityDescriptorDacl(pSD, TRUE, pAcl, FALSE));
    sa.lpSecurityDescriptor = pSD;

    CHECK((g_hDebugFileMutex = CreateMutexA(&sa, FALSE, "Global\\WiaDebugFileMut")) != NULL);

    success = TRUE;

Cleanup:
    if(!success) {
        if(BuiltinAdministrators) FreeSid(BuiltinAdministrators);
        if(AuthenticatedUsers)  FreeSid(AuthenticatedUsers);
        if(pAcl) HeapFree(GetProcessHeap(), 0, pAcl);
    }

    return success;
}

////////////////////////////////////////////////
// DebugWrite
//
// Writes specified number of bytes to a debug 
// file, creating it if needed. Thread-safe. 
// Registers any failure and from that point returns 
// immediately.
//
static void 
DebugWrite(LPCSTR buffer, DWORD n)
{
#undef CHECK
#define CHECK(x) if(!(x)) { \
    TRACE(("%s(%d): %s failed (%d)", __FILE__, __LINE__, #x, GetLastError())); \
    bCatastrophicFailure = TRUE; goto Cleanup; } 
#undef CHECK2
#define CHECK2(x, y) if(!(x)) { \
    TRACE(("%s(%d): %s failed (%d)", __FILE__, __LINE__, #x, GetLastError())); \
    TRACE(y); bCatastrophicFailure = TRUE; goto Cleanup; } 

    DWORD cbWritten;
    DWORD dwWaitResult;
    LARGE_INTEGER newPos = { 0, 0 };
    static BOOL bCatastrophicFailure = FALSE;
    BOOL bMutexAcquired = FALSE;

    // if something is broken, return immediately
    if(bCatastrophicFailure) return;

    // make sure we have file mutex
    if(!g_hDebugFileMutex) 
    {
        CHECK(WiauCreateLogFileMutex());
    }

    // acquire mutex
    dwWaitResult = WaitForSingleObject(g_hDebugFileMutex, WIAUDBG_DEBUG_TIMEOUT);

    // if we failed to acquire mutex within the specified timeout,
    // shutdown tracing (on free builds users will not know this)
    CHECK(dwWaitResult == WAIT_OBJECT_0 || dwWaitResult == WAIT_ABANDONED);

    bMutexAcquired = TRUE;

    // make sure we have open file
    if(g_hDebugFile == INVALID_HANDLE_VALUE)
    {
        // attempt to open file
        CHECK(ExpandEnvironmentStringsA(WIAUDBG_FILE_NAME, g_szDebugFileName, MAX_PATH));

        g_hDebugFile = CreateFileA(g_szDebugFileName, GENERIC_WRITE, 
            FILE_SHARE_READ | FILE_SHARE_WRITE, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

        CHECK2(g_hDebugFile != INVALID_HANDLE_VALUE, 
            ("g_szDebugFileName = '%s'", g_szDebugFileName)); 
    }

    // seek to the end of file
    CHECK(SetFilePointerEx(g_hDebugFile, newPos, &newPos, SEEK_END));

    // check the file size
    if(newPos.HighPart != 0 || newPos.LowPart > g_dwDebugFileSizeLimit)
    {
        static CHAR LogFullMessage[128];

        TRACE(("Reached log file maximum size of %d", g_dwDebugFileSizeLimit));

        sprintf(LogFullMessage, "Log file reached maximum size of %d, logging stopped.", g_dwDebugFileSizeLimit);
        CHECK2(WriteFile(g_hDebugFile, LogFullMessage, strlen(LogFullMessage), &cbWritten, NULL), ("%d", cbWritten));
        bCatastrophicFailure = TRUE;
    }

    // write data
    CHECK2(WriteFile(g_hDebugFile, buffer, n, &cbWritten, NULL),
        ("%d %d", cbWritten, n));

    // make sure we write to the disk now.
    FlushFileBuffers(g_hDebugFile);

    CHECK2(cbWritten == n, ("%d %d", n, cbWritten))

Cleanup:
    if(bMutexAcquired) ReleaseMutex(g_hDebugFileMutex);
    return;
}

////////////////////////////////////////////////
// PrintBanner
//
// Since we append to the log file, we need a 
// seperator of some sort so we know when a 
// new execution has started.
//
void PrintBanner(void)
{
    char buffer[1024];
    size_t len = 0;

    SYSTEMTIME SysTime;
    GetLocalTime(&SysTime);

    if (g_dwDebugFlags)
    {
        _snprintf(buffer, sizeof(buffer), 
                  "====================Start '%s' Debug - Time: %d/%02d/%02d %02d:%02d:%02d:%02d====================",
                  g_szModuleName,
                  SysTime.wYear,
                  SysTime.wMonth,
                  SysTime.wDay,
                  SysTime.wHour,
                  SysTime.wMinute,
                  SysTime.wSecond,
                  SysTime.wMilliseconds);
    }

    len = strlen(buffer);
    if(len > 0) 
    {
        // make sure the line has terminating "\n"
        if(buffer[len - 1] != '\n') 
        {
            buffer[len++] = '\r';
            buffer[len++] = '\n';
            buffer[len] = '\0';
        }

        if(!(g_dwDebugFlags & WIAUDBG_DONT_LOG_TO_FILE))
        {
            DebugWrite(buffer, len);
        }

        if(!(g_dwDebugFlags & WIAUDBG_DONT_LOG_TO_DEBUGGER))
        {
            OutputDebugStringA(buffer);
        }
    }

    return;
}


////////////////////////////////////////////////
// wiauDbgHelper
//
// Formats message and writes it into log file 
// and/or debugger;
//
void wiauDbgHelper(LPCSTR prefix,
                   LPCSTR fname,
                   LPCSTR fmt,
                   va_list marker)
{
    char buffer[1024];
    size_t len = 0;

    if(!g_bDebugInited) 
    {
        wiauDbgInit(NULL);  
    }
    
    //
    // The first time we ever print a debug statement, lets 
    // output a seperator line since when we output to file
    // we append, this way we can seperate different execution
    // sessions.
    //
    if (!g_bBannerPrinted)
    {
        PrintBanner();
        g_bBannerPrinted = TRUE;
    }

    lstrcpyA(buffer, PREFIX_WIA);
    lstrcatA(buffer, prefix);

    if (g_dwDebugFlags & WIAUDBG_PRINT_TIME) {
        
        SYSTEMTIME MsgTime;
        GetLocalTime(&MsgTime);
        sprintf(buffer + strlen(buffer),
                "[%02d:%02d:%02d.%03d] ", MsgTime.wHour, MsgTime.wMinute, MsgTime.wSecond, MsgTime.wMilliseconds);
    }

    lstrcatA(buffer, fname);
    
    len = strlen(buffer);
    buffer[len++] = ':';
    buffer[len++] = ' ';

    _vsnprintf(buffer + len, 1024, fmt, marker);

    len = strlen(buffer);
    if(len > 0) 
    {
        // make sure the line has terminating "\n"
        if(buffer[len - 1] != '\n') 
        {
            buffer[len++] = '\r';
            buffer[len++] = '\n';
            buffer[len] = '\0';
        }

        if(!(g_dwDebugFlags & WIAUDBG_DONT_LOG_TO_FILE))
        {
            DebugWrite(buffer, len);
        }

        if(!(g_dwDebugFlags & WIAUDBG_DONT_LOG_TO_DEBUGGER))
        {
            OutputDebugStringA(buffer);
        }
    }
}


////////////////////////////////////////////////
// wiauDbgHelper2
//
// Takes printf style arguments and calls wiauDbgHelper
//
void wiauDbgHelper2(LPCSTR prefix,
                    LPCSTR fname,
                    LPCSTR fmt,
                    ...)
{
    va_list marker;

    va_start(marker, fmt);
    wiauDbgHelper(prefix, fname, fmt, marker);
    va_end(marker);
}


////////////////////////////////////////////////
// GetRegDWORD
//
// Attempts to get a DWORD from the specified
// location.  If bSetIfNotExist is set, it 
// writes the registry setting to the current
// value in pdwValue.
//
LRESULT GetRegDWORD(HKEY        hKey,
                    const CHAR  *pszRegValName,
                    DWORD       *pdwValue,
                    BOOL        bSetIfNotExist)
{
    LRESULT lResult = ERROR_SUCCESS;
    DWORD   dwSize  = 0;
    DWORD   dwType  = REG_DWORD;

    if ((hKey          == NULL) ||
        (pszRegValName == NULL) ||
        (pdwValue      == NULL))
    {
        return ERROR_INVALID_HANDLE;
    }

    dwSize = sizeof(DWORD);

    lResult = RegQueryValueExA(hKey, 
                               pszRegValName, 
                               NULL, 
                               &dwType,
                               (BYTE*) pdwValue, 
                               &dwSize);

    // if we didn't find the key, create it.
    if (bSetIfNotExist)
    {
        if ((lResult != ERROR_SUCCESS) || 
            (dwType  != REG_DWORD))
        {
            lResult = RegSetValueExA(hKey, 
                                     pszRegValName, 
                                     0, 
                                     REG_DWORD, 
                                     (BYTE*) pdwValue, 
                                     dwSize);
        }
    }

    return lResult;
}

////////////////////////////////////////////////
// wiauDbgInit
//
// Overwrite g_dwDebugFlags and g_dwDebugFileSizeLimit 
// from registry
//
void wiauDbgInit(HINSTANCE hInstance)
{
    HKEY        hKey         = NULL;
    DWORD       dwDispositon = 0;
    DWORD       dwData;
    DWORD       dwDisposition               = 0;
    CHAR        szModulePath[MAX_PATH + 1]  = {0};
    CHAR        szDebugKey[1023 + 1]        = {0};
    CHAR        *pszFileName                = NULL;

    GetModuleFileNameA(hInstance, szModulePath, sizeof(szModulePath));
    pszFileName = strrchr(szModulePath, '\\');

    if (pszFileName == NULL) 
    {
        pszFileName = szModulePath;
    } 
    else 
    {
        pszFileName++;
    }

    //
    // build the registry key.
    //
    _snprintf(szDebugKey, sizeof(szDebugKey), "%s\\%s", WIAUDBG_FLAGS_REGKEY, pszFileName);
    lstrcpynA(g_szModuleName, pszFileName, sizeof(g_szModuleName));

    //
    // get/set the debug subkey.  The DebugValues value is stored on a per module
    // basis
    //
    if(RegCreateKeyExA(HKEY_LOCAL_MACHINE,
        szDebugKey,
        0,
        NULL,
        0,
        KEY_READ | KEY_WRITE,
        NULL,
        &hKey,
        &dwDisposition) == ERROR_SUCCESS) 
    {
        dwData = g_dwDebugFlags;

        if (GetRegDWORD(hKey, WIAUDBG_FLAGS_REGVAL, &dwData, TRUE) == ERROR_SUCCESS)
        {
            g_dwDebugFlags = dwData;
        }

        RegCloseKey(hKey);
        hKey = NULL;
    }

    //
    // get/set the Max File Size value.  This is global to all debug modules since
    // the all write to the same file.
    //
    if(RegCreateKeyExA(HKEY_LOCAL_MACHINE,
        WIAUDBG_FLAGS_REGKEY,
        0,
        NULL,
        0,
        KEY_READ | KEY_WRITE,
        NULL,
        &hKey,
        &dwDisposition) == ERROR_SUCCESS) 
    {
        dwData = g_dwDebugFileSizeLimit;

        if (GetRegDWORD(hKey, WIAUDBG_REGVAL_FILE_SIZE_LIMIT, &dwData, TRUE) == ERROR_SUCCESS)
        {
            g_dwDebugFileSizeLimit = dwData;
        }

        RegCloseKey(hKey);
        hKey = NULL;
    }

    g_bDebugInited = TRUE;

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\video\filter\istillf.h ===
/*++
Copyright (c) 1998- Microsoft Corporation

Module Name:

    istillf.h

Abstract:
    Header file that declares IID_IStillSnapshot interface which is implemented
    in stillf.cpp

Author:

    William Hsieh (williamh) created

Revision History:

--*/
#ifndef __ISTILLF_H_
#define __ISTILLF_H_

DEFINE_GUID(CLSID_STILL_FILTER,
0xbc7acb90, 0x622b, 0x11d2, 0x82, 0x9d, 0x00, 0xc0, 0x4f, 0x8e, 0xc1, 0x83);

DEFINE_GUID(IID_IStillSnapshot,
0x19da0cc0, 0x6ea7, 0x11d2, 0x82, 0xb8, 0x00, 0xc0, 0x4f, 0x8e, 0xc1, 0x83);



//
// This is the callback function for ReadBits method
// Count contain how many DIB bits are returned
// while lParam is the context parameter passed
// in ReadBits call.
//


typedef BOOL (*LPSNAPSHOTCALLBACK)(HGLOBAL hDIB, LPARAM lParam);


extern "C"
{
    #undef  INTERFACE
    #define INTERFACE   IStillSnapshot


    DECLARE_INTERFACE_(IStillSnapshot, IUnknown)
    {
        STDMETHOD(Snapshot)(ULONG TimeStamp) PURE;
        STDMETHOD(SetSamplingSize)(int Size) PURE;
        STDMETHOD_(int, GetSamplingSize)() PURE;
        STDMETHOD_(DWORD, GetBitsSize)() PURE;
        STDMETHOD_(DWORD, GetBitmapInfoSize)() PURE;
        STDMETHOD(GetBitmapInfo)(BYTE* Buffer, DWORD BufferSize) PURE;
        STDMETHOD(RegisterSnapshotCallback)(LPSNAPSHOTCALLBACK pCallback, LPARAM lParam) PURE;
        STDMETHOD(GetBitmapInfoHeader)(BITMAPINFOHEADER *pbmih) PURE;
    };
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\util\rwspy\rwspy.c ===
#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#ifndef STRICT
#define STRICT
#endif

#ifndef _WIN32_WINNT
#define _WIN32_WINNT        0x0500
#endif

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include "detours.h"

//
// Registry information used by RWSpy
//
WCHAR RWSpyKey[] = L"Software\\Microsoft\\RWSpy";

WCHAR DeviceValueName[] = L"FileToSpyOn";
WCHAR DeviceNameToSpyOn[MAX_PATH] = L"";

WCHAR LogFileValueName[] = L"Log File";
WCHAR DefaultLogFileName[] = L"%SystemRoot%\\rwspy.log";
WCHAR LogFileName[MAX_PATH] = L"\0";

//
// Globals
//
HANDLE g_hDeviceToSpyOn = INVALID_HANDLE_VALUE;
HANDLE g_hLogFile = INVALID_HANDLE_VALUE;

//
// Detours trampolines
//
DETOUR_TRAMPOLINE(HANDLE WINAPI Real_CreateFileW(LPCWSTR a0, DWORD a1, DWORD a2,
    LPSECURITY_ATTRIBUTES a3, DWORD a4, DWORD a5, HANDLE a6), CreateFileW);

DETOUR_TRAMPOLINE(BOOL WINAPI Real_WriteFile(HANDLE hFile, LPCVOID lpBuffer,
                                             DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped), WriteFile);

DETOUR_TRAMPOLINE(BOOL WINAPI Real_WriteFileEx(HANDLE hFile, LPCVOID lpBuffer, DWORD dwNumberOfBytesToWrite,
                                               LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletion), WriteFileEx);

DETOUR_TRAMPOLINE(BOOL WINAPI Real_ReadFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToRead,
                                            LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped), ReadFile);

DETOUR_TRAMPOLINE(BOOL WINAPI Real_ReadFileEx(HANDLE hFile, LPCVOID lpBuffer, DWORD dwNumberOfBytesToRead,
                                               LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletion), ReadFileEx);

DETOUR_TRAMPOLINE(BOOL WINAPI Real_DeviceIoControl(HANDLE hFile, DWORD code, LPVOID inBuffer, DWORD cbIn,
    LPVOID outBuffer, DWORD cbOutSize, LPDWORD cbOutActual, LPOVERLAPPED lpOverlapped), DeviceIoControl);

DETOUR_TRAMPOLINE(BOOL WINAPI Real_CloseHandle(HANDLE hObject), CloseHandle);


// closes log and makes further writing impossible until log reopened
void CloseLog(void)
{
    if(g_hLogFile != INVALID_HANDLE_VALUE) {
        Real_CloseHandle(g_hLogFile);
        g_hLogFile = INVALID_HANDLE_VALUE;
    }
}

// Attempts to open log file. Assumes that LogFileName[] is already set
// elsewhere.
BOOL OpenLog(void)
{
    BOOL success = FALSE;

    CloseLog();

    g_hLogFile = Real_CreateFileW(LogFileName, GENERIC_WRITE, FILE_SHARE_READ, NULL,
                                  CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

    if(g_hLogFile != INVALID_HANDLE_VALUE) {
        success = TRUE;
    }

    return success;
}

// Writes specified number of characters to the log file
BOOL WriteToLog(CHAR *bytes, DWORD len)
{
    BOOL success = FALSE;
                   
    if(g_hLogFile != INVALID_HANDLE_VALUE && len && bytes) {
        DWORD cbWritten;
        if(Real_WriteFile(g_hLogFile, bytes, len, &cbWritten, NULL) && len == cbWritten) {
            success = TRUE;
        } else {
            CloseLog();
        }
    }
    return success;
}

// writes printf-style string to the log file
void Log(LPCSTR fmt, ...)
{
    va_list marker;
    CHAR buffer[1024];
    DWORD cbToWrite;

    if(g_hLogFile == INVALID_HANDLE_VALUE || fmt == NULL)
        return;

    va_start(marker, fmt);
    _vsnprintf(buffer, sizeof(buffer), fmt, marker);
    cbToWrite = lstrlenA(buffer);
    
    WriteToLog(buffer, cbToWrite);
}

// writes db-style bytes to the log file
void LogBytes(BYTE *pBytes, DWORD dwBytes)
{
    DWORD nBytes = min(dwBytes, 8192L);
    const static CHAR hex[] = "0123456789ABCDEF";
    CHAR buffer[80];
    DWORD cbToWrite = 75;
    DWORD byte = 0;
    int pos;

    if(g_hLogFile == INVALID_HANDLE_VALUE || pBytes == NULL || nBytes == 0)
        return;
    
    while(byte < nBytes) {
        
        if((byte % 16) == 0) {

            if(byte != 0) {
                // write previous line into file
                if(!WriteToLog(buffer, cbToWrite))
                    break;
            }

            memset(buffer, ' ', cbToWrite - 1);
            buffer[cbToWrite - 1] = '\n';
            
            buffer[0] = hex[(byte >> 12) & 0xF];
            buffer[1] = hex[(byte >> 8) & 0xF];
            buffer[2] = hex[(byte >> 4) & 0xF];
            buffer[3] = hex[byte & 0xF];
        }

        pos = (byte % 16 < 8 ? 5 : 6)+ (byte % 16) * 3;
        
        buffer[pos] = hex[(pBytes[byte] >> 4) & 0xF];
        buffer[pos + 1] = hex[pBytes[byte] & 0xF];

        pos = 5 + 16 * 3 + 2 + (byte % 16);
        buffer[pos] = pBytes[byte] >= ' ' && pBytes[byte] <= 127 ? pBytes[byte] : '.';

        byte++;
    }

    // write one final line
    WriteToLog(buffer, cbToWrite);
}


HANDLE WINAPI
   My_CreateFileW(LPCWSTR a0,
                    DWORD a1,
                    DWORD a2,
                    LPSECURITY_ATTRIBUTES a3,
                    DWORD a4,
                    DWORD a5,
                    HANDLE a6)
{
    HANDLE hResult;

    __try {
        hResult = Real_CreateFileW(a0, a1, a2, a3, a4, a5, a6);
    }

    __finally {
        // if we have a file to spy on
        if(DeviceNameToSpyOn[0]) {
            WCHAR *pw = DeviceNameToSpyOn;
            LPCWSTR p = a0;

            while(*p && *pw) {
                WCHAR w = *p;
                if(w != *pw)
                    break;
                p++;
                pw++;
            }

            if(*p == L'\0' && *pw == L'\0') {
                // we got our file
                if(hResult == INVALID_HANDLE_VALUE) {
                    Log("Tried creating '%S', LastError() = : %d\n", a0 ? a0 : L"NULL", GetLastError());
                } else {
                    Log("Created '%S', handle: %x\n", a0 ? a0 : L"NULL", hResult);
                }

                if(hResult != INVALID_HANDLE_VALUE) {
                    // successsfully created
                    if(g_hDeviceToSpyOn != INVALID_HANDLE_VALUE && hResult != g_hDeviceToSpyOn) {
                        // hmm... it was already open. Let user know
                        // this happened:
                        Log("Note: we were already spying on this device with handle %x. Changing to %x\n",
                              g_hDeviceToSpyOn, hResult);
                    }
                    g_hDeviceToSpyOn = hResult;
                }
            }

        } else {
            // simply record the file name into output file
            Log("Creating file: '%S', result: %x\n", a0 ? a0 : L"NULL", hResult); 
        }
    }

    return hResult;
}


BOOL WINAPI
   My_WriteFile(HANDLE hFile,
                  LPCVOID lpBuffer,
                  DWORD nNumberOfBytesToWrite,
                  LPDWORD lpNumberOfBytesWritten,
                  LPOVERLAPPED lpOverlapped)
{
    BOOL bresult;
    DWORD bytesWritten;

    __try {
        bresult = Real_WriteFile(hFile, lpBuffer, nNumberOfBytesToWrite, lpNumberOfBytesWritten, lpOverlapped);
    }

    __finally {
        if(g_hDeviceToSpyOn != INVALID_HANDLE_VALUE && hFile == g_hDeviceToSpyOn) {
            bytesWritten = lpNumberOfBytesWritten ? *lpNumberOfBytesWritten :
                           nNumberOfBytesToWrite;
            if(bresult) {
                Log("Wrote %d bytes:\n", bytesWritten);
            } else {
                Log("Failure writing %d bytes, LastError() = %d:\n",
                      nNumberOfBytesToWrite, GetLastError());
            }
            LogBytes((BYTE *)lpBuffer, bytesWritten);
        }
    }

    return bresult;
}


BOOL WINAPI
   My_WriteFileEx(HANDLE hFile,
                  LPCVOID lpBuffer,
                  DWORD nNumberOfBytesToWrite,
                  LPOVERLAPPED lpOverlapped,
                  LPOVERLAPPED_COMPLETION_ROUTINE lpOverlappedCompletion)
{
    BOOL bresult;

    __try {
        bresult = Real_WriteFileEx(hFile, lpBuffer, nNumberOfBytesToWrite, lpOverlapped, lpOverlappedCompletion);
    }

    __finally {
        if(g_hDeviceToSpyOn != INVALID_HANDLE_VALUE && hFile == g_hDeviceToSpyOn) {
            if(bresult) {
                Log("Submitted %d bytes to WriteEx:\n", nNumberOfBytesToWrite);
            } else {
                Log("Failed to submit %d bytes to WriteEx, LastError() = %d:\n",
                      nNumberOfBytesToWrite, GetLastError());
            }
            LogBytes((BYTE *)lpBuffer, nNumberOfBytesToWrite);
        }
    }

    return bresult;
}



BOOL WINAPI
   My_ReadFile(HANDLE hFile,
                 LPCVOID lpBuffer,
                 DWORD nNumberOfBytesToRead,
                 LPDWORD lpNumberOfBytesRead,
                 LPOVERLAPPED lpOverlapped)
{
    BOOL bresult;
    DWORD bytesRead;

    __try {
        bresult = Real_ReadFile(hFile, lpBuffer, nNumberOfBytesToRead, lpNumberOfBytesRead, lpOverlapped);
    }

    __finally {
        if(g_hDeviceToSpyOn != INVALID_HANDLE_VALUE && hFile == g_hDeviceToSpyOn) {
            bytesRead = lpNumberOfBytesRead ? *lpNumberOfBytesRead :
                        nNumberOfBytesToRead;
            if(bresult) {
                Log("Read %d bytes:\n", bytesRead);
                LogBytes((BYTE *)lpBuffer, bytesRead);
            } else {
                Log("Failure to read %d bytes, LastError() = %d:\n",
                      nNumberOfBytesToRead, GetLastError());
            }
        }
    }

    return bresult;
}

//
// Please, note that to see ReadEx bytes one needs to detour 
// the completion routine (we don't do it here).
//
BOOL WINAPI
   My_ReadFileEx(HANDLE hFile,
                   LPCVOID lpBuffer,
                   DWORD nNumberOfBytesToRead,
                   LPOVERLAPPED lpOverlapped,
                   LPOVERLAPPED_COMPLETION_ROUTINE lpOverlappedCompletion)
{
    BOOL bresult;

    __try {
        bresult = Real_ReadFileEx(hFile, lpBuffer, nNumberOfBytesToRead, lpOverlapped, lpOverlappedCompletion);
    }

    __finally {
        if(g_hDeviceToSpyOn != INVALID_HANDLE_VALUE && hFile == g_hDeviceToSpyOn) {
            if(bresult) {
                Log("Submitted ReadEx for %d bytes:\n", nNumberOfBytesToRead);
            } else {
                Log("Failed to sumbit ReadEx for %d bytes, LastError() = %d:\n",
                      nNumberOfBytesToRead, GetLastError());
            }
        }
    }

    return bresult;
}



BOOL WINAPI
   My_DeviceIoControl(HANDLE hFile, DWORD code, LPVOID inBuffer, DWORD cbIn,
                        LPVOID outBuffer, DWORD cbOutSize, LPDWORD pcbOutActual, LPOVERLAPPED lpOverlapped)
{
    BOOL result;
    DWORD outBytes;
    DWORD Function; 
    __try {
        result = Real_DeviceIoControl(hFile, code, inBuffer, cbIn, outBuffer, cbOutSize, pcbOutActual, lpOverlapped);
    }
    __finally {
        if(g_hDeviceToSpyOn != INVALID_HANDLE_VALUE && hFile == g_hDeviceToSpyOn) {
            outBytes = pcbOutActual ? *pcbOutActual : cbOutSize;

            Function = (code >> 2) & 0xFFF;
            
            Log("DeviceIoControl code = %x, Function = %x, %d bytes in:\n",
                  code, Function, cbIn);
            LogBytes((BYTE *)inBuffer, cbIn);
            if(outBytes) {
                Log("   %d bytes out:\n", outBytes);
                LogBytes((BYTE *)outBuffer, outBytes);
            }
        }
    }
    
    return result;
}


BOOL WINAPI
   My_CloseHandle(HANDLE hObject)
{
    BOOL bresult;

    __try {
        bresult = Real_CloseHandle(hObject);
    }

    __finally {
        if(g_hDeviceToSpyOn != INVALID_HANDLE_VALUE && hObject == g_hDeviceToSpyOn) {
            Log("Closed handle %x\n", hObject);
            g_hDeviceToSpyOn = INVALID_HANDLE_VALUE;
        }
    }

    return bresult;
}


void PrepareLogger()
{
    HKEY hKey;
    WCHAR buffer[MAX_PATH];

    // retrieve our configuration from the registry
    if(ERROR_SUCCESS == RegCreateKeyExW(HKEY_LOCAL_MACHINE, RWSpyKey,
                                        0, NULL, 0, KEY_ALL_ACCESS, NULL, &hKey, NULL))
    {
        DWORD dwType, cbData = sizeof(buffer);

        cbData = sizeof(buffer);
        if(ERROR_SUCCESS == RegQueryValueExW(hKey, LogFileValueName, 0, &dwType, (BYTE *) buffer, &cbData) &&
           cbData)
        {
            ExpandEnvironmentStringsW(buffer, LogFileName, MAX_PATH);
        } else {
            // no log file name value found, create it so that users 
            // would know what its name is
            cbData = lstrlenW(DefaultLogFileName) * sizeof(DefaultLogFileName[0]);
            RegSetValueExW(hKey, LogFileValueName, 0, REG_EXPAND_SZ, (BYTE *) DefaultLogFileName, cbData);
        }

        DeviceNameToSpyOn[0] = L'\0';
        cbData = sizeof(DeviceNameToSpyOn);
        if(ERROR_SUCCESS != RegQueryValueExW(hKey, DeviceValueName, NULL, &dwType, (LPBYTE) DeviceNameToSpyOn, &cbData)
           || !DeviceNameToSpyOn[0])
        {
            // no "FileToSpyOn" value found, create it so that users
            // would know what the value name is
            RegSetValueExW(hKey, DeviceValueName, 0, REG_SZ, (BYTE *)DeviceNameToSpyOn, sizeof(WCHAR));
        }
        RegCloseKey(hKey);
    }

    // if we still don't have file name, use the default one
    if(!LogFileName[0]) {
        ExpandEnvironmentStringsW(DefaultLogFileName, LogFileName, MAX_PATH);
    }

    OpenLog();
                                     
    DetourFunctionWithTrampoline((PBYTE) Real_CreateFileW, (PBYTE) My_CreateFileW);
    DetourFunctionWithTrampoline((PBYTE) Real_WriteFile, (PBYTE) My_WriteFile);
    DetourFunctionWithTrampoline((PBYTE) Real_WriteFileEx, (PBYTE) My_WriteFileEx);
    DetourFunctionWithTrampoline((PBYTE) Real_ReadFile, (PBYTE) My_ReadFile);
    DetourFunctionWithTrampoline((PBYTE) Real_ReadFileEx, (PBYTE) My_ReadFileEx);
    DetourFunctionWithTrampoline((PBYTE) Real_DeviceIoControl, (PBYTE) My_DeviceIoControl);
    DetourFunctionWithTrampoline((PBYTE) Real_CloseHandle, (PBYTE) My_CloseHandle);
}



BOOL APIENTRY DllMain(HINSTANCE hModule, DWORD dwReason, PVOID lpReserved)
{
    switch (dwReason) {
        case DLL_PROCESS_ATTACH:
            PrepareLogger();
            break;
        case DLL_PROCESS_DETACH:
            CloseLog();
            break;
        case DLL_THREAD_ATTACH:
        case DLL_THREAD_DETACH:
            break;
    }
    return TRUE;
}


// This is necessary for detours static injection code (see detours
// code if you need to understand why)  
void NullExport()
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\video\filter\precomp.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999-2000
 *
 *  TITLE:       precomp.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        9/7/99
 *
 *  DESCRIPTION: Precomplied header for filter
 *
 *****************************************************************************/

#ifndef _WIA_VIDEO_FILTER_PRECOMP_
#define _WIA_VIDEO_FILTER_PRECOMP_

#include <streams.h>

#include <tchar.h>
#include <initguid.h>
#include <atlbase.h>
#include <psnew.h>
#include <istillf.h>
#include <stillf.h>         // stillf.h must come before inpin.h & outpin.h
#include <inpin.h>
#include <outpin.h>
#include <limits.h>
#include <objbase.h>
#include <vfwmsgs.h>
#include <coredbg.h>

extern HINSTANCE g_hInstance;
#ifdef DEBUG
void DisplayMediaType(const CMediaType *pmt);
#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\video\filter\sources.inc ===
!include          $(PROJECT_ROOT)\wia\wiaenv.inc

MAJORCOMP=DirectShow
MINORCOMP=StillFilter

TARGETNAME=wiasf
TARGETPATH=$(OBJ_DIR)

TARGETTYPE=DYNLINK
TARGETEXT=ax
DLLDEF=..\wiasf.def
DLLENTRY        = _DllMainCRTStartup
#DLLENTRY=DllMain

USE_MSVCRT=1

#Common include files

INCLUDES= $(INCLUDES) \
    $(PROJECT_ROOT)\inc\psutil; \
    $(PROJECT_ROOT)\inc; \
    $(BASEDIR)\public\sdk\amovie\inc; \
    $(SDK_INC_PATH)\atl30;

!if ("$(NTDEBUG)" == "") || ("$(NTDEBUG)" == "ntsdnodbg")
LINKLIBS=$(BASEDIR)\public\sdk\lib\*\strmbase.lib
!ELSE
LINKLIBS=$(BASEDIR)\public\sdk\lib\*\strmbasd.lib
!ENDIF

TARGETLIBS= \
            $(SDK_LIB_PATH)\ADVAPI32.lib \
            $(SDK_LIB_PATH)\GDI32.lib    \
            $(SDK_LIB_PATH)\KERNEL32.lib \
            $(SDK_LIB_PATH)\user32.lib   \
            $(SDK_LIB_PATH)\oleaut32.lib \
            $(SDK_LIB_PATH)\ole32.lib    \
            $(SDK_LIB_PATH)\uuid.lib     \
            $(SDK_LIB_PATH)\winmm.lib    \
            $(PROJECT_ROOT)\lib\$(PLATFORM_SUFFIX)\*\psutil.lib \
            $(WIA_LIB_PATH)\stirt.lib


SOURCES= \
    ..\inpin.cpp \
    ..\outpin.cpp \
    ..\stillf.cpp \
    ..\stillf.rc


PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\video\usd\defprop.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1998
*
*  TITLE:       DefProp.h
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        30 July, 1998
*
*  DESCRIPTION:
*   Default property Declarations and definitions for the
*   WIA test scanner.
*
*******************************************************************************/


#define VT_V_UI1   (VT_VECTOR | VT_UI1)

#define PREFFERED_FORMAT_NOM        &WiaImgFmt_JPEG
#define FORMAT_NOM                  &WiaImgFmt_JPEG

#define NUM_CAM_ITEM_PROPS  (19)
#define NUM_CAM_DEV_PROPS   (7)
#define NUM_CAP_ENTRIES     (5)
#define NUM_EVENTS          (4)

extern PROPID             gItemPropIDs[NUM_CAM_ITEM_PROPS];
extern LPOLESTR           gItemPropNames[NUM_CAM_ITEM_PROPS];
extern PROPID             gItemCameraPropIDs[WIA_NUM_IPC];
extern LPOLESTR           gItemCameraPropNames[WIA_NUM_IPC];
extern PROPID             gDevicePropIDs[NUM_CAM_DEV_PROPS];
extern LPOLESTR           gDevicePropNames[NUM_CAM_DEV_PROPS];
extern PROPSPEC           gDevicePropSpecDefaults[NUM_CAM_DEV_PROPS];
extern WIA_PROPERTY_INFO  gDevPropInfoDefaults[NUM_CAM_DEV_PROPS];
extern PROPSPEC           gPropSpecDefaults[NUM_CAM_ITEM_PROPS];
extern LONG               gPropVarDefaults[];
extern WIA_PROPERTY_INFO  gWiaPropInfoDefaults[NUM_CAM_ITEM_PROPS];
extern WIA_DEV_CAP_DRV    gCapabilities[NUM_CAP_ENTRIES];
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\video\filter\stillf.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998-2000
 *
 *  TITLE:       stillf.cpp
 *
 *  VERSION:     1.1
 *
 *  AUTHOR:      WilliamH (created)
 *               RickTu
 *
 *  DATE:        9/7/98
 *
 *  DESCRIPTION: This module implements video stream capture filter.
 *               It implements CStillFilter objects.
 *               implements IID_IStillGraph interface provided for the caller
 *
 *****************************************************************************/

#include <precomp.h>
#pragma hdrstop

HINSTANCE g_hInstance;

extern "C" BOOL WINAPI DllEntryPoint(HINSTANCE hInstance, ULONG ulReason, LPVOID pv);

/*****************************************************************************

   DllMain

   <Notes>

 *****************************************************************************/

BOOL
DllMain(HINSTANCE   hInstance,
        DWORD       dwReason,
        LPVOID      lpReserved)
{
    switch (dwReason)
    {
        case DLL_PROCESS_ATTACH:
        {
            //
            // Init Debug subsystem
            //
            DBG_INIT(hInstance);
    
            //
            // Requires '{' and '}' since DBG_FN is an object with a
            // constructor and a destructor.
            //

            DBG_FN("DllMain - ProcessAttach");
    
            //
            // We do not need thread attach/detach calls
            //
    
            DisableThreadLibraryCalls(hInstance);
    
            //
            // Record what instance we are
            //
    
            g_hInstance = hInstance;
        }
        break;
    
        case DLL_PROCESS_DETACH:
        {
    
            //
            // Requires '{' and '}' since DBG_FN is an object with a
            // constructor and a destructor.
            //

            DBG_FN("DllMain - ProcessDetach");
        }
        break;
    }

    return DllEntryPoint(hInstance, dwReason, lpReserved);

}


///////////////////////////////
// sudPinTypes
//
// template definitions for CClassFactorySample
//
const AMOVIESETUP_MEDIATYPE sudPinTypes =
{
    &MEDIATYPE_Video,       // major media type GUID
    &MEDIASUBTYPE_NULL      // subtype GUID
};


///////////////////////////////
// psudPins
//
const AMOVIESETUP_PIN   psudPins[] =
{
    {
                    // CStillInputPin
    L"Input",           // pin name
    FALSE,              // not rendered
    FALSE,              // not output pin
    FALSE,              // not allow none
    FALSE,              // not allow many
    &CLSID_NULL,            // connect to any filter
    L"Output",          // connect to output pin
    1,              // one media type
    &sudPinTypes            // the media type
    },
    {
                    // CStillInputPin
    L"Output",          // pin name
    FALSE,              // not rendered
    TRUE,               // not output pin
    FALSE,              // not allow none
    FALSE,              // not allow many
    &CLSID_NULL,            // connect to any filter
    L"Input",           // connect to input pin
    1,              // one media type
    &sudPinTypes            // the media type
    }
};

///////////////////////////////
// sudStillFilter
//
const AMOVIESETUP_FILTER sudStillFilter =
{
    &CLSID_STILL_FILTER,        // filter clsid
    L"WIA Stream Snapshot Filter",      // filter name
    MERIT_DO_NOT_USE,           //
    2,                  // two pins
    psudPins,               // our pins
};

///////////////////////////////
// g_Templates
//
CFactoryTemplate g_Templates[1] =
{
    {
    L"WIA Stream Snapshot Filter",  // filter name
    &CLSID_STILL_FILTER,        // filter clsid
    CStillFilter::CreateInstance,   // API used to create filter instances
    NULL,               // no init function provided.
    &sudStillFilter         // the filter itself
    },
};

int g_cTemplates = sizeof(g_Templates) / sizeof(g_Templates[0]);



/*****************************************************************************

   DllRegisterServer

   Used to register the classes provided in this dll.

 *****************************************************************************/

STDAPI DllRegisterServer()
{
    return AMovieDllRegisterServer2(TRUE);
}


/*****************************************************************************

   DllUnregisterServer

   Used to unregister classes provided by this dll.

 *****************************************************************************/

STDAPI
DllUnregisterServer()
{
    return AMovieDllRegisterServer2(FALSE);
}


/*****************************************************************************

   CStillFilter::CreateInstance

   CreateInstance API to create CStillFilter instances

 *****************************************************************************/

CUnknown* WINAPI CStillFilter::CreateInstance(LPUNKNOWN pUnk, 
                                              HRESULT   *phr )
{
    return new CStillFilter(TEXT("Stream Snapshot Filter"), pUnk, phr );
}

#ifdef DEBUG


/*****************************************************************************

   DisplayMediaType

   <Notes>

 *****************************************************************************/

void DisplayMediaType(const CMediaType *pmt)
{

    //
    // Dump the GUID types and a short description
    //

    DBG_TRC(("<--- CMediaType 0x%x --->",pmt));

    DBG_PRT(("Major type  == %S",
             GuidNames[*pmt->Type()]));

    DBG_PRT(("Subtype     == %S (%S)",
             GuidNames[*pmt->Subtype()],GetSubtypeName(pmt->Subtype())));

    DBG_PRT(("Format size == %d",pmt->cbFormat));
    DBG_PRT(("Sample size == %d",pmt->GetSampleSize()));

    //
    // Dump the generic media types
    //

    if (pmt->IsFixedSize())
    {
        DBG_PRT(("==> This media type IS a fixed size sample"));
    }
    else
    {
        DBG_PRT(("==> This media type IS NOT a fixed size sample >"));
    }

    if (pmt->IsTemporalCompressed())
    {
        DBG_PRT(("==> This media type IS temporally compressed"));
    }
    else
    {
        DBG_PRT(("==> This media type IS NOT temporally compressed"));
    }

}
#endif


/*****************************************************************************

   DefaultGetBitsCallback

   <Notes>

 *****************************************************************************/

void DefaultGetBitsCallback(int     Count, 
                            LPARAM  lParam)
{
    SetEvent((HANDLE)lParam);
}


/*****************************************************************************

   CStillFilter constructor

   <Notes>

 *****************************************************************************/

CStillFilter::CStillFilter(TCHAR        *pObjName, 
                           LPUNKNOWN    pUnk, 
                           HRESULT      *phr) :
    m_pInputPin(NULL),
    m_pOutputPin(NULL),
    m_pbmi(NULL),
    m_pBits(NULL),
    m_BitsSize(0),
    m_bmiSize(0),
    m_pCallback(NULL),
    CBaseFilter(pObjName, pUnk, &m_Lock, CLSID_STILL_FILTER)
{
    DBG_FN("CStillFilter::CStillFilter");

    // create our input and output pin
    m_pInputPin  = new CStillInputPin(TEXT("WIA Still Input Pin"),  
                                      this, 
                                      phr, 
                                      L"Input");

    if (!m_pInputPin)
    {
        DBG_ERR(("Unable to create new CStillInputPin!"));
        *phr = E_OUTOFMEMORY;
        return;
    }

    m_pOutputPin = new CStillOutputPin(TEXT("WIA Still Output Pin"), 
                                       this, 
                                       phr, 
                                       L"Output");

    if (!m_pOutputPin)
    {
        DBG_ERR(("Unable to create new CStillOutputPin!"));
        *phr = E_OUTOFMEMORY;
        return;
    }
}

/*****************************************************************************

   CStillFilter desctructor

   <Notes>

 *****************************************************************************/

CStillFilter::~CStillFilter()
{
    DBG_FN("CStillFilter::~CStillFilter");

    if (m_pInputPin)
    {
        delete m_pInputPin;
        m_pInputPin = NULL;
    }

    if (m_pOutputPin)
    {
        if (m_pOutputPin->m_pMediaUnk)
        {
            m_pOutputPin->m_pMediaUnk->Release();
            m_pOutputPin->m_pMediaUnk = NULL;
        }

        delete m_pOutputPin;
        m_pOutputPin = NULL;
    }


    if (m_pbmi)
    {
        delete [] m_pbmi;
        m_pbmi = NULL;
    }

    if (m_pBits)
    {
        delete [] m_pBits;
        m_pBits = NULL;
    }
}


/*****************************************************************************

   CStillFilter::NonDelegatingQueryInterface

   Add our logic to the base class QI.

 *****************************************************************************/

STDMETHODIMP
CStillFilter::NonDelegatingQueryInterface(REFIID riid, 
                                          void **ppv)
{
    DBG_FN("CStillFilter::NonDelegatingQueryInterface");
    ASSERT(this!=NULL);
    ASSERT(ppv!=NULL);

    HRESULT hr;

    if (!ppv)
    {
        hr = E_INVALIDARG;
    }
    else if (riid == IID_IStillSnapshot)
    {
        hr = GetInterface((IStillSnapshot *)this, ppv);
    }
    else
    {
        hr = CBaseFilter::NonDelegatingQueryInterface(riid, ppv);
    }

    return hr;
}


/*****************************************************************************

   CStillFilter::GetPinCount

   <Notes>

 *****************************************************************************/

int
CStillFilter::GetPinCount()
{
    return 2;  // input & output
}


/*****************************************************************************

   CStillFilter::GetPin

   <Notes>

 *****************************************************************************/

CBasePin*
CStillFilter::GetPin( int n )
{
    ASSERT(this!=NULL);

    if (0 == n)
    {
        ASSERT(m_pInputPin!=NULL);
        return (CBasePin *)m_pInputPin;
    }
    else if (1 == n)
    {
        ASSERT(m_pOutputPin!=NULL);
        return (CBasePin *)m_pOutputPin;
    }

    return NULL;
}


/*****************************************************************************

   CStillFilter::Snapshot

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CStillFilter::Snapshot( ULONG TimeStamp )
{
    DBG_FN("CStillFilter::Snapshot");
    ASSERT(this!=NULL);
    ASSERT(m_pInputPin!=NULL);

    HRESULT hr = E_POINTER;

    if (m_pInputPin)
    {
        hr = m_pInputPin->Snapshot(TimeStamp);
    }

    CHECK_S_OK(hr);
    return hr;
}


/*****************************************************************************

   CStillFilter::GetBitsSize

   <Notes>

 *****************************************************************************/

STDMETHODIMP_(DWORD)
CStillFilter::GetBitsSize()
{
    DBG_FN("CStillFilter::GetBitsSize");
    ASSERT(this!=NULL);

    return m_BitsSize;
}


/*****************************************************************************

   CStillFilter::GetBitmapInfoSize

   <Notes>

 *****************************************************************************/

STDMETHODIMP_(DWORD)
CStillFilter::GetBitmapInfoSize()
{
    DBG_FN("CStillFilter::GetBitmapInfoSize");
    ASSERT(this!=NULL);

    return m_bmiSize;
}


/*****************************************************************************

   CStillFilter::GetBitmapInfo

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CStillFilter::GetBitmapInfo( BYTE* Buffer, DWORD BufferSize )
{
    DBG_FN("CStillFilter::GetBitmapInfo");

    ASSERT(this     !=NULL);
    ASSERT(m_pbmi   !=NULL);

    if (BufferSize && !Buffer)
        return E_INVALIDARG;

    if (BufferSize < m_bmiSize)
        return HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);

    if (!m_pbmi)
        return E_UNEXPECTED;

    memcpy(Buffer, m_pbmi, m_bmiSize);

    return NOERROR;
}


/*****************************************************************************

   CStillFilter::GetBitmapInfoHeader

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CStillFilter::GetBitmapInfoHeader( BITMAPINFOHEADER *pbmih )
{
    DBG_FN("CStillFilter::GetBitmapInfoHeader");

    ASSERT(this     !=NULL);
    ASSERT(m_pbmi   !=NULL);
    ASSERT(pbmih    !=NULL);

    HRESULT hr;

    if (!pbmih)
    {
        hr = E_INVALIDARG;
    }
    else if (!m_pbmi)
    {
        hr = E_POINTER;
    }
    else
    {
        *pbmih = *(BITMAPINFOHEADER*)m_pbmi;
        hr = S_OK;
    }

    CHECK_S_OK(hr);
    return hr;
}


/*****************************************************************************

   CStillFilter::SetSamplingSize

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CStillFilter::SetSamplingSize( int Size )
{
    DBG_FN("CStillFilter::SetSamplingSize");

    ASSERT(this         !=NULL);
    ASSERT(m_pInputPin  !=NULL);

    HRESULT hr = E_POINTER;

    if (m_pInputPin)
    {
        hr = m_pInputPin->SetSamplingSize(Size);
    }

    CHECK_S_OK(hr);
    return hr;
}


/*****************************************************************************

   CStillFilter::GetSamplingSize

   <Notes>

 *****************************************************************************/

STDMETHODIMP_(int)
CStillFilter::GetSamplingSize()
{
    DBG_FN("CStillFilter::GetSamplingSize");

    ASSERT(this         !=NULL);
    ASSERT(m_pInputPin  !=NULL);

    HRESULT hr = E_POINTER;

    if (m_pInputPin)
    {
        hr = m_pInputPin->GetSamplingSize();
    }

    CHECK_S_OK(hr);
    return hr;
}



/*****************************************************************************

   CStillFilter::RegisterSnapshotCallback

   This function registers a notification callback for newly
   arrived frames.  Without registering a callback, all captured
   frames are discarded.

 *****************************************************************************/

STDMETHODIMP
CStillFilter::RegisterSnapshotCallback( LPSNAPSHOTCALLBACK pCallback,
                                        LPARAM lParam
                                       )
{
    DBG_FN("CStillFilter::RegisterSnapshotCallback");

    ASSERT(this != NULL);

    HRESULT hr = S_OK;

    m_Lock.Lock();

    if (pCallback && !m_pCallback)
    {
        m_pCallback     = pCallback;
        m_CallbackParam = lParam;
    }
    else if (!pCallback)
    {
        m_pCallback     = NULL;
        m_CallbackParam = 0;
    }
    else if (m_pCallback)
    {
        DBG_TRC(("registering snapshot callback when it is already registered"));
        hr = E_INVALIDARG;
    }

    m_Lock.Unlock();

    CHECK_S_OK(hr);
    return hr;
}


/*****************************************************************************

   CStillFilter::DeliverSnapshot

   This function is called from the input pin whenever a new frame is captured.
   The given parameter points to the pixel data (BITMAPINFOHEADER is already
   cached in *m_pbmi).  A new DIB is allocated to store away the newly arrived
   bits.  The new bits are ignored, however, if the callback is not registered.

 *****************************************************************************/

HRESULT
CStillFilter::DeliverSnapshot(HGLOBAL hDib)
{
    DBG_FN("CStillFilter::DeliverSnapshot");

    ASSERT(this !=NULL);
    ASSERT(hDib !=NULL);

    HRESULT hr = S_OK;

    if (hDib == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CStillFilter::DeliverSnapshot received NULL param"));
    }

    if (hr == S_OK)
    {
        m_Lock.Lock();
    
        if (m_pCallback && hDib)
        {
            BOOL bSuccess = TRUE;
    
            bSuccess = (*m_pCallback)(hDib, m_CallbackParam);
        }
    
        m_Lock.Unlock();
    }

    return hr;
}


/*****************************************************************************

   CStillFilter::InitializeBitmapInfo

   This function intialize allocates a BITMAPINFO and copies BITMAPINFOHEADER
   and necessary color table or color mask fromt the given VIDEOINFO.

 *****************************************************************************/

HRESULT
CStillFilter::InitializeBitmapInfo( BITMAPINFOHEADER *pbmiHeader )
{
    DBG_FN("CStillFilter::InitializeBitmapInfo");
    ASSERT(this       !=NULL);
    ASSERT(pbmiHeader !=NULL);

    HRESULT hr = E_OUTOFMEMORY;

    if (!pbmiHeader)
    {
        hr = E_INVALIDARG;
    }
    else
    {
        int               ColorTableSize = 0;

        m_bmiSize = pbmiHeader->biSize;

        if (pbmiHeader->biBitCount <= 8)
        {
            //
            // If biClrUsed is zero, it indicates (1 << biBitCount) entries
            //

            if (pbmiHeader->biClrUsed)
                ColorTableSize = pbmiHeader->biClrUsed * sizeof(RGBQUAD);
            else
                ColorTableSize = ((DWORD)1 << pbmiHeader->biBitCount) * 
                                              sizeof(RGBQUAD);

            m_bmiSize += ColorTableSize;
        }

        //
        // color mask
        //

        if (BI_BITFIELDS == pbmiHeader->biCompression)
        {
            //
            // 3 dword of mask
            //

            m_bmiSize += 3 * sizeof(DWORD);
        }

        //
        // now calculate bits size
        // each scanline must be 32 bits aligned.
        //

        m_BitsSize = (((pbmiHeader->biWidth * pbmiHeader->biBitCount + 31) 
                        & ~31) >> 3)
                        * ((pbmiHeader->biHeight < 0) ? -pbmiHeader->biHeight:
                            pbmiHeader->biHeight);

        m_DIBSize = m_bmiSize + m_BitsSize;

        if (m_pbmi)
            delete [] m_pbmi;

        m_pbmi = new BYTE[m_bmiSize];

        if (m_pbmi)
        {
            BYTE *pColorTable = ((BYTE*)pbmiHeader + (WORD)(pbmiHeader->biSize));

            //
            // Copy BITMAPINFOHEADER
            //

            memcpy(m_pbmi, pbmiHeader, pbmiHeader->biSize);

            //
            // copy the color table or color masks if there are any
            //

            if (BI_BITFIELDS == pbmiHeader->biCompression)
                memcpy(m_pbmi + pbmiHeader->biSize, 
                       pColorTable, 
                       3 * sizeof(DWORD));

            if (ColorTableSize)
                memcpy(m_pbmi + pbmiHeader->biSize, 
                       pColorTable, 
                       ColorTableSize);

            hr = S_OK;
        }
    }

    CHECK_S_OK(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\video\filter\stillf.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998 - 2000
 *
 *  TITLE:       stillf.h
 *
 *  VERSION:     1.1
 *
 *  AUTHOR:      WilliamH (original)
 *               RickTu   (revision)
 *
 *  DATE:        9/7/99
 *
 *  DESCRIPTION: Declarations for still filter class
 *
 *****************************************************************************/

#ifndef __STILLF_H_
#define __STILLF_H_

class CStillFilter;
class CStillOutputPin;
class CStillInputPin;

const int MAX_SAMPLE_SIZE = 16;

typedef struct StillSample
{
    ULONG   TimeStamp;
    BYTE*   pBits;
}STILL_SAMPLE, *PSTILL_SAMPLE;


class CStillFilter : public CBaseFilter, public IStillSnapshot
{
    friend class CStillInputPin;
    friend class CStillOutputPin;

public:
    CStillFilter(TCHAR* pObjName, LPUNKNOWN pUnk, HRESULT* phr);
    ~CStillFilter();
    static CUnknown* WINAPI CreateInstance(LPUNKNOWN pUnk, HRESULT* phr);
    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void **ppv);
    DECLARE_IUNKNOWN;

    int GetPinCount();
    CBasePin* GetPin( int n);
    HRESULT Active();
    HRESULT Inactive();

    //
    // IStillSnapshot interface
    //
    STDMETHODIMP Snapshot(ULONG TimeStamp);
    STDMETHODIMP SetSamplingSize(int Size);
    STDMETHODIMP_(int) GetSamplingSize();
    STDMETHODIMP_(DWORD) GetBitsSize();
    STDMETHODIMP_(DWORD) GetBitmapInfoSize();
    STDMETHODIMP GetBitmapInfo(BYTE* pBuffer, DWORD BufferSize);
    STDMETHODIMP RegisterSnapshotCallback(LPSNAPSHOTCALLBACK pCallback, LPARAM lParam);
    STDMETHODIMP GetBitmapInfoHeader(BITMAPINFOHEADER *pbmih);
    //
    // support functions
    //
    HRESULT InitializeBitmapInfo( BITMAPINFOHEADER *pbmiHeader );
    HRESULT DeliverSnapshot(HGLOBAL hDib);

private:
    CCritSec            m_Lock;
    CStillOutputPin     *m_pOutputPin;
    CStillInputPin      *m_pInputPin;
    BYTE                *m_pBits;
    BYTE                *m_pbmi;
    DWORD               m_bmiSize;
    DWORD               m_BitsSize;
    DWORD               m_DIBSize;
    LPSNAPSHOTCALLBACK  m_pCallback;
    LPARAM              m_CallbackParam;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\video\filter\outpin.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998-2000
 *
 *  TITLE:       outpin.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu (taken from WilliamH src)
 *
 *  DATE:        9/7/99
 *
 *  DESCRIPTION: Output pin definitions
 *
 *****************************************************************************/

#ifndef __OUTPIN_H_
#define __OUTPIN_H_

class CStillFilter;
class CStillInputPin;

class CStillOutputPin : public CBaseOutputPin
{
    friend CStillInputPin;
    friend CStillFilter;

public:
    CStillOutputPin(TCHAR           *pObjName, 
                    CStillFilter    *pStillFilter, 
                    HRESULT         *phr, 
                    LPCWSTR         pPinName);

    virtual ~CStillOutputPin();

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, void** ppv);
    STDMETHODIMP Notify(IBaseFilter* pSender, Quality q);
    HRESULT CheckMediaType(const CMediaType* pmt);
    HRESULT DecideAllocator(IMemInputPin *pPin, IMemAllocator **ppAlloc);
    HRESULT DecideBufferSize(IMemAllocator* pAllocator,ALLOCATOR_PROPERTIES* pProperty);
    HRESULT SetMediaType(const CMediaType* pmt);
    HRESULT GetMediaType(int iPosition, CMediaType* pmt);

private:
    CStillInputPin* GetInputPin();

    IUnknown*       m_pMediaUnk;
};

inline CStillInputPin* CStillOutputPin::GetInputPin()
{
    // m_pFilter should never be NULL because a valid filter pointer is
    // always passed to CStillOutputPin's constructor.
    ASSERT(m_pFilter != NULL);

    // m_pInputPin should never be NULL because CoCreateInstance() will not
    // create a CStillFilter object if an error occurs in CStillFilter's 
    // constructor.
    ASSERT(((CStillFilter*) m_pFilter)->m_pInputPin != NULL);

    if (((CStillFilter*) m_pFilter)->m_pInputPin)
    {
        return ((CStillFilter*) m_pFilter)->m_pInputPin;
    }
    else
    {
        return NULL;
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\video\filter\outpin.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998-2000
 *
 *  TITLE:       stillf.cpp
 *
 *  VERSION:     1.1
 *
 *  AUTHOR:      WilliamH (created)
 *               RickTu
 *
 *  DATE:        9/7/98
 *
 *  DESCRIPTION: This module implements video stream capture filter.
 *               It implements CStillInputPin, CStillOutputPin and CStillFilter objects.
 *               implements IID_IStillGraph interface provided for the caller
 *
 *****************************************************************************/

#include <precomp.h>
#pragma hdrstop

/*****************************************************************************

   CStillOutputPin constructor

   <Notes>

 *****************************************************************************/

CStillOutputPin::CStillOutputPin(TCHAR          *pObjName,
                                 CStillFilter   *pStillFilter,
                                 HRESULT        *phr,
                                 LPCWSTR        pPinName)
  : m_pMediaUnk(NULL),
    CBaseOutputPin(pObjName, 
                   (CBaseFilter *)pStillFilter, 
                   &pStillFilter->m_Lock, 
                   phr, 
                   pPinName)
{
    DBG_FN("CStillOutputPin::CStillOutputPin");

    CHECK_S_OK2(*phr,("CBaseOutputPin constructor"));
}

/*****************************************************************************

   CStillOutputPin Destructor

   <Notes>

 *****************************************************************************/

CStillOutputPin::~CStillOutputPin()
{
    if (m_pMediaUnk)
    {
        m_pMediaUnk->Release();
        m_pMediaUnk = NULL;
    }
}

/*****************************************************************************

   CStillOutputPin::NonDelegatingQueryInterface

   Add our stuff to the base class QI.

 *****************************************************************************/

STDMETHODIMP
CStillOutputPin::NonDelegatingQueryInterface(REFIID riid, 
                                             PVOID  *ppv )
{
    DBG_FN("CStillOutputPin::NonDelegatingQueryInterface");

    ASSERT(this!=NULL);
    ASSERT(ppv!=NULL);
    ASSERT(m_pFilter!=NULL);

    HRESULT hr = E_POINTER;

    if (!ppv)
    {
        hr = E_INVALIDARG;
    }
    else if (riid == IID_IMediaPosition || riid == IID_IMediaSeeking)
    {
        if (!m_pMediaUnk && m_pFilter)
        {
            ASSERT(m_pFilter!=NULL);
            hr = CreatePosPassThru(
                                GetOwner(),
                                FALSE,
                                (IPin*)((CStillFilter*)m_pFilter)->m_pInputPin,
                                &m_pMediaUnk);
        }

        if (m_pMediaUnk)
        {
            hr = m_pMediaUnk->QueryInterface(riid, ppv);
        }
        else
        {
            hr = E_NOINTERFACE;
            *ppv = NULL;
        }
    }
    else
    {
        hr = CBaseOutputPin::NonDelegatingQueryInterface(riid, ppv);
    }

    return hr;
}

/*****************************************************************************

   CStillOutputPin::DecideAllocator

   <Notes>

 *****************************************************************************/

HRESULT
CStillOutputPin::DecideAllocator(IMemInputPin *pPin, IMemAllocator **ppAlloc)
{
    HRESULT         hr                  = S_OK;
    CStillInputPin  *pInputPin          = NULL;
    IMemAllocator   *pInputPinAllocator = NULL;

    // The caller should passes in valid arguments.
    ASSERT((pPin != NULL) && (ppAlloc != NULL));

    if ((pPin == NULL) || (ppAlloc == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CStillOutputPin::DecideAllocator received a NULL pointer"));
        return hr;
    }

    if (hr == S_OK)
    {
        *ppAlloc = NULL;
    
        pInputPin = GetInputPin();
    
        if (pInputPin == NULL)
        {
            hr = E_POINTER;
            CHECK_S_OK2(hr, ("CStillOutputPin::DecideAllocator, pInputPin is NULL, "
                             "this should never happen"));
        }
    }

    if (hr == S_OK)
    {
        if (!pInputPin->IsConnected()) 
        {
            hr = VFW_E_NOT_CONNECTED;
            CHECK_S_OK2(hr, ("CStillOutputPin::DecideAllocator input pin is not connected"));
        }
    }

    if (hr == S_OK)
    {
        pInputPinAllocator = pInputPin->GetAllocator();

        hr = pPin->NotifyAllocator(pInputPinAllocator, pInputPin->IsReadOnly());
    
        if (FAILED(hr)) 
        {
            CHECK_S_OK2(hr, ("CStillOutputPin::DecideAllocator failed to notify downstream "
                             "pin of new allocator"));
        }

        if (pInputPinAllocator == NULL)
        {
            hr = E_POINTER;
            CHECK_S_OK2(hr, ("CStillOutputPin::DecideAllocator, pInputPinAllocator is NULL, "
                             "this should never happen"));
        }
    }


    if (hr == S_OK)
    {
        pInputPinAllocator->AddRef();
        *ppAlloc = pInputPinAllocator;
    }

    return hr;
}

/*****************************************************************************

   CStillOutputPin::DecideBufferSize

   <Notes>

 *****************************************************************************/

HRESULT
CStillOutputPin::DecideBufferSize(IMemAllocator        *pMemAllocator,
                                  ALLOCATOR_PROPERTIES *pAllocProperty)
{
    // This function is never called because we overrode 
    // CBaseOutputPin::DecideAllocator().  We have to define 
    // it because it is a virtual function in CBaseOutputPin.
    return E_UNEXPECTED;
}


/*****************************************************************************

   CStillOutputPin::CheckMediaType

   <Notes>

 *****************************************************************************/

HRESULT
CStillOutputPin::CheckMediaType(const CMediaType* pmt)
{
    DBG_FN("CStillOutputPin::CheckMediaType");

    ASSERT(this         !=NULL);
    ASSERT(m_pFilter    !=NULL);
    ASSERT(pmt          !=NULL);

    HRESULT hr = E_POINTER;

    //
    // the input pin must be connected first because we only accept
    // media type determined by our input pin.
    //

    if (m_pFilter && ((CStillFilter*)m_pFilter)->m_pInputPin)
    {
        if (((CStillFilter*)m_pFilter)->m_pInputPin->m_Connected != NULL)
        {
            //
            // if our input pin is connected, we only accept the
            // the media type agreed on the input pin.
            //

            if (pmt && (((CStillFilter*)m_pFilter)->m_pInputPin->m_mt == *pmt))
            {
                hr = S_OK;
            }
            else
            {
                hr = VFW_E_TYPE_NOT_ACCEPTED;
            }
        }
        else
        {
            DBG_ERR(("m_pFilter->m_pInputPin->m_Connected is NULL!"));
        }
    }
    else
    {
#ifdef DEBUG
        if (!m_pFilter)
        {
            DBG_ERR(("m_pFilter is NULL!"));
        }
        else if (!((CStillFilter*)m_pFilter)->m_pInputPin)
        {
            DBG_ERR(("m_pFilter->m_pInputPin is NULL!"));
        }
#endif
    }

    return hr;
}


/*****************************************************************************

   CStillOutputPin::GetMediaType

   <Notes>

 *****************************************************************************/

HRESULT
CStillOutputPin::GetMediaType(int        iPosition, 
                              CMediaType *pmt)
{
    DBG_FN("CStillOutputPin::GetMediaType");

    ASSERT(this     !=NULL);
    ASSERT(m_pFilter!=NULL);
    ASSERT(pmt      !=NULL);

    HRESULT hr = E_POINTER;

    if (!pmt)
    {
        hr = E_INVALIDARG;

        DBG_ERR(("CStillOutputPin::GetMediaType CMediaType 'pmt' param "
                 "is NULL! returning hr = 0x%08lx", hr));
    }
    else if (m_pFilter && ((CStillFilter*)m_pFilter)->m_pInputPin)
    {
        //
        // if the input is not connected, we do not have preferred
        // media type
        //

        if (!((CStillFilter*)m_pFilter)->m_pInputPin->IsConnected())
        {
            hr = E_UNEXPECTED;

            DBG_ERR(("CStillOutputPin::GetMediaType was called but "
                     "the input pin is not connected, Returning hr = "
                     "0x%08lx", hr));
        }
        else if (iPosition < 0)
        {
            hr = E_INVALIDARG;
            DBG_ERR(("CStillOutputPin::GetMediaType requesting a media type "
                     "in position %d, which is invalid, returning hr = "
                     "0x%08lx", iPosition, hr));
        }
        else if (iPosition > 0 )
        {
            //
            // this is not an error case since the caller is enumerating all the
            // media types we support.  We return that we don't have any more
            // items that we support.
            //
            hr = VFW_S_NO_MORE_ITEMS;
        }
        else
        {
            // 
            // Position being requested is position 0, since less than or
            // greater than 0 are unsupported.  
            // In effect, our output pin supports any media our input pin 
            // supports, we don't do any conversions.
            //
            *pmt = ((CStillFilter*)m_pFilter)->m_pInputPin->m_mt;
            hr = S_OK;
        }
    }
    else
    {
#ifdef DEBUG
        if (!m_pFilter)
        {
            DBG_ERR(("CStillOutputPin::GetMediaType, m_pFilter is NULL, "
                     "this should never happen!"));
        }
        else if (!((CStillFilter*)m_pFilter)->m_pInputPin)
        {
            DBG_ERR(("CStillOutputPin::GetMediaType "
                     "m_pFilter->m_pInputPin "
                     "is NULL.  The input pin should always "
                     "exist if the filter exists!"));
        }
#endif
    }

    return hr;
}


/*****************************************************************************

   CStillOutputPin::SetMediaType

   <Notes>

 *****************************************************************************/

HRESULT
CStillOutputPin::SetMediaType(const CMediaType* pmt)
{
    DBG_FN("CStillOutputPin::SetMediaType");

    ASSERT(this !=NULL);
    ASSERT(pmt);

    HRESULT hr = S_OK;

#ifdef DEBUG
    // Display the type of the media for debugging perposes
//    DBG_TRC(("CStillOutputPin::SetMediaType, setting the following media "
//             "type for Still Filter"));
//    DisplayMediaType( pmt );
#endif

    hr = CBaseOutputPin::SetMediaType(pmt);
    CHECK_S_OK2(hr,("CBaseOutputPin::SetMediaType(pmt)"));

    return hr;
}


/*****************************************************************************

   CStillOutputPin::Notify

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CStillOutputPin::Notify(IBaseFilter *pSender, 
                        Quality     q)
{
    ASSERT(this     !=NULL);
    ASSERT(m_pFilter!=NULL);

    HRESULT hr = E_POINTER;

    if (m_pFilter && ((CStillFilter*)m_pFilter)->m_pInputPin)
    {
        hr = ((CStillFilter*)m_pFilter)->m_pInputPin->PassNotify(q);
    }
    else
    {
#ifdef DEBUG
        if (!m_pFilter)
        {
            DBG_ERR(("m_pFilter is NULL"));
        }
        else if (!((CStillFilter*)m_pFilter)->m_pInputPin)
        {
            DBG_ERR(("m_pFilter->m_pInputPin is NULL"));
        }
#endif

    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\video\usd\globals.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999 - 2000
 *
 *  TITLE:       globals.cpp
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        9/16/99
 *
 *  DESCRIPTION: Globals for this module
 *
 *****************************************************************************/

#include <precomp.h>
#pragma hdrstop

PROPID gItemPropIDs[NUM_CAM_ITEM_PROPS] = {
    WIA_IPA_DATATYPE,
    WIA_IPA_DEPTH,
    WIA_IPA_PIXELS_PER_LINE,
    WIA_IPA_NUMBER_OF_LINES,
    WIA_IPC_THUMBNAIL,
    WIA_IPA_ITEM_TIME,
    WIA_IPC_THUMB_WIDTH,
    WIA_IPC_THUMB_HEIGHT,
    WIA_IPA_PREFERRED_FORMAT,
    WIA_IPA_ITEM_SIZE,
    WIA_IPA_FORMAT,
    WIA_IPA_TYMED,
    WIA_IPA_COMPRESSION,
    WIA_IPA_CHANNELS_PER_PIXEL,
    WIA_IPA_BITS_PER_CHANNEL,
    WIA_IPA_PLANAR,
    WIA_IPA_BYTES_PER_LINE,
    WIA_IPA_ACCESS_RIGHTS,
    WIA_IPA_MIN_BUFFER_SIZE
};

LPOLESTR gItemPropNames[NUM_CAM_ITEM_PROPS] =
{
    WIA_IPA_DATATYPE_STR,
    WIA_IPA_DEPTH_STR,
    WIA_IPA_PIXELS_PER_LINE_STR,
    WIA_IPA_NUMBER_OF_LINES_STR,
    WIA_IPC_THUMBNAIL_STR,
    WIA_IPA_ITEM_TIME_STR,
    WIA_IPC_THUMB_WIDTH_STR,
    WIA_IPC_THUMB_HEIGHT_STR,
    WIA_IPA_PREFERRED_FORMAT_STR,
    WIA_IPA_ITEM_SIZE_STR,
    WIA_IPA_FORMAT_STR,
    WIA_IPA_TYMED_STR,
    WIA_IPA_COMPRESSION_STR,
    WIA_IPA_CHANNELS_PER_PIXEL_STR,
    WIA_IPA_BITS_PER_CHANNEL_STR,
    WIA_IPA_PLANAR_STR,
    WIA_IPA_BYTES_PER_LINE_STR,
    WIA_IPA_ACCESS_RIGHTS_STR,
    WIA_IPA_MIN_BUFFER_SIZE_STR
};

PROPID gItemCameraPropIDs[WIA_NUM_IPC] = {
    WIA_IPC_AUDIO_AVAILABLE,
    WIA_IPC_AUDIO_DATA
};

LPOLESTR gItemCameraPropNames[WIA_NUM_IPC] =
{
    WIA_IPC_AUDIO_AVAILABLE_STR,
    WIA_IPC_AUDIO_DATA_STR,
};

PROPID gDevicePropIDs[NUM_CAM_DEV_PROPS] =
{
    WIA_DPA_CONNECT_STATUS,
    WIA_DPC_PICTURES_TAKEN,
    WIA_DPC_THUMB_WIDTH,
    WIA_DPC_THUMB_HEIGHT,
    WIA_DPV_DSHOW_DEVICE_PATH,
    WIA_DPV_IMAGES_DIRECTORY,
    WIA_DPV_LAST_PICTURE_TAKEN
};

LPOLESTR gDevicePropNames[NUM_CAM_DEV_PROPS] =
{
    WIA_DPA_CONNECT_STATUS_STR,
    WIA_DPC_PICTURES_TAKEN_STR,
    WIA_DPC_THUMB_WIDTH_STR,
    WIA_DPC_THUMB_HEIGHT_STR,
    WIA_DPV_DSHOW_DEVICE_PATH_STR,
    WIA_DPV_IMAGES_DIRECTORY_STR,
    WIA_DPV_LAST_PICTURE_TAKEN_STR
};

PROPSPEC gDevicePropSpecDefaults[NUM_CAM_DEV_PROPS] = {

    {PRSPEC_PROPID, WIA_DPA_CONNECT_STATUS},
    {PRSPEC_PROPID, WIA_DPC_PICTURES_TAKEN},
    {PRSPEC_PROPID, WIA_DPC_THUMB_WIDTH},
    {PRSPEC_PROPID, WIA_DPC_THUMB_HEIGHT},
    {PRSPEC_PROPID, WIA_DPV_DSHOW_DEVICE_PATH},
    {PRSPEC_PROPID, WIA_DPV_IMAGES_DIRECTORY},
    {PRSPEC_PROPID, WIA_DPV_LAST_PICTURE_TAKEN}
};

WIA_PROPERTY_INFO  gDevPropInfoDefaults[NUM_CAM_DEV_PROPS] = {
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4,       0,    0,    0,    0}, // WIA_DPA_CONNECT_STATUS
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4,       0,    0,    0,    0}, // WIA_DPC_PICTURES_TAKEN
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4,       0,    0,    0,    0}, // WIA_DPC_THUMB_WIDTH
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_I4,       0,    0,    0,    0}, // WIA_DPC_THUMB_HEIGHT
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_LPWSTR,   0,    0,    0,    0}, // WIA_DPV_DSHOW_DEVICE_PATH
    {WIA_PROP_READ | WIA_PROP_NONE,    VT_LPWSTR,   0,    0,    0,    0}, // WIA_DPV_IMAGES_DIRECTORY
    {WIA_PROP_RW   | WIA_PROP_NONE,    VT_LPWSTR,   0,    0,    0,    0}  // WIA_DPV_LAST_PICTURE_TAKEN
};

PROPSPEC gPropSpecDefaults[NUM_CAM_ITEM_PROPS] = {
   {PRSPEC_PROPID, WIA_IPA_DATATYPE},
   {PRSPEC_PROPID, WIA_IPA_DEPTH},
   {PRSPEC_PROPID, WIA_IPA_PIXELS_PER_LINE},
   {PRSPEC_PROPID, WIA_IPA_NUMBER_OF_LINES},
   {PRSPEC_PROPID, WIA_IPC_THUMBNAIL},
   {PRSPEC_PROPID, WIA_IPA_ITEM_TIME},
   {PRSPEC_PROPID, WIA_IPC_THUMB_WIDTH},
   {PRSPEC_PROPID, WIA_IPC_THUMB_HEIGHT},
   {PRSPEC_PROPID, WIA_IPA_PREFERRED_FORMAT},
   {PRSPEC_PROPID, WIA_IPA_ITEM_SIZE},
   {PRSPEC_PROPID, WIA_IPA_FORMAT},
   {PRSPEC_PROPID, WIA_IPA_TYMED},
   {PRSPEC_PROPID, WIA_IPA_COMPRESSION},
   {PRSPEC_PROPID, WIA_IPA_CHANNELS_PER_PIXEL},
   {PRSPEC_PROPID, WIA_IPA_BITS_PER_CHANNEL},
   {PRSPEC_PROPID, WIA_IPA_PLANAR},
   {PRSPEC_PROPID, WIA_IPA_BYTES_PER_LINE},
   {PRSPEC_PROPID, WIA_IPA_ACCESS_RIGHTS},
   {PRSPEC_PROPID, WIA_IPA_MIN_BUFFER_SIZE},
};

LONG  gPropVarDefaults[(sizeof(PROPVARIANT) / sizeof(LONG)) * (NUM_CAM_ITEM_PROPS)] = {
   // VARTYPE                 reserved    val               pad/array ptr
   (LONG)VT_I4,               0x00000000, WIA_DATA_COLOR,0x00000000,            // WIA_IPA_DATATYPE
   (LONG)VT_I4,               0x00000000, 24,                 0x00000000,            // WIA_IPA_DEPTH

   (LONG)VT_I4,               0x00000000, 0,                 0x00000000,            // WIA_IPA_PIXELS_PER_LINE
   (LONG)VT_I4,               0x00000000, 0,                 0x00000000,            // WIA_IPA_NUMBER_OF_LINES

   (LONG)VT_VECTOR | VT_UI1,  0x00000000, 0,                 0x00000000,            // WIA_IPC_THUMBNAIL
   (LONG)VT_VECTOR | VT_I4,   0x00000000, 0,                 0x00000000,            // WIA_IPA_ITEM_TIME
   (LONG)VT_I4,               0x00000000, 0,                 0x00000000,            // WIA_IPC_THUMB_WIDTH
   (LONG)VT_I4,               0x00000000, 0,                 0x00000000,            // WIA_IPC_THUMB_HEIGHT
   (LONG)VT_CLSID,            0x00000000, PtrToLong(PREFFERED_FORMAT_NOM)/* BUGBUG can our dll be loaded at > 4gig ??*/,0x00000000,    // WIA_IPA_PREFERRED_FORMAT
   (LONG)VT_I4,               0x00000000, 0,                 0x00000000,            // WIA_IPA_ITEM_SIZE
   (LONG)VT_CLSID,            0x00000000, PtrToLong(FORMAT_NOM)/* BUGBUG can our dll be loaded at > 4gig ??*/,  0x00000000,            // WIA_IPA_FORMAT
   (LONG)VT_I4,               0x00000000, TYMED_FILE,        0x00000000,            // WIA_IPA_TYMED
   (LONG)VT_I4,               0x00000000, 0,                 0x00000000,            // WIA_IPA_COMPRESSION
   (LONG)VT_I4,               0x00000000, 3,                 0x00000000,            // WIA_IPA_CHANNELS PER PIXEL
   (LONG)VT_I4,               0x00000000, 8,                 0x00000000,            // WIA_IPA_BITS PER CHANNEL
   (LONG)VT_I4,               0x00000000, WIA_PACKED_PIXEL,  0x00000000,            // WIA_IPA_PLANAR
   (LONG)VT_I4,               0x00000000, 0,                 0x00000000,            // WIA_IPA_WIDTH IN BYTES
   (LONG)VT_I4,               0x00000000, WIA_ITEM_RD,       0x00000000,             // WIA_IPA_ACCESS_RIGHTS

   (LONG)VT_I4,               0x00000000, 65535,             0x00000000,            // WIA_IPA_MIN_BUFFER_SIZE
};


// Default device extended properties.

#define NUM_DATATYPE 1
LONG lDataTypes[NUM_DATATYPE] = {
    WIA_DATA_COLOR
};

#define NUM_DEPTH 1
LONG lDepths[NUM_DEPTH] = {
    24
};

//
//  Different formats supported
//

#define NUM_FORMAT 3

GUID* pguidFormats[NUM_FORMAT] =
{
    (GUID*) &WiaImgFmt_JPEG,
    (GUID*) &WiaImgFmt_MEMORYBMP,
    (GUID*) &WiaImgFmt_BMP
};

GUID g_guidFormats[NUM_FORMAT];   // FormatID's specified in pguidFormats are copied to g_guidFormats
                                  // during SetFormatAttribs

//
//  This is an array of WIA_FORMAT_INFOs, describing the different formats
//  and their corresponding media types.  Initialized in minidrvr.cpp
//

WIA_FORMAT_INFO* g_wfiTable = NULL;

//
//  Different media types supported
//

#define NUM_TYMED  2
LONG lTymeds [NUM_TYMED]= {
    TYMED_FILE,
    TYMED_CALLBACK,
};

//
// Extended information for each property
//

WIA_PROPERTY_INFO  gWiaPropInfoDefaults[NUM_CAM_ITEM_PROPS] = {

    {WIA_PROP_READ | WIA_PROP_LIST, VT_I4, NUM_DATATYPE, WIA_DATA_COLOR, PtrToLong(lDataTypes)/* BUGBUG can our dll be loaded at > 4gig ??*/, 0}, // WIA_IPA_DATATYPE
    {WIA_PROP_READ | WIA_PROP_LIST, VT_I4, NUM_DEPTH,    24,                  PtrToLong(lDepths)/* BUGBUG can our dll be loaded at > 4gig ??*/,    0}, // WIA_IPA_DEPTH

    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_PIXELS_PER_LINE
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_NUMBER_OF_LINES
    {WIA_PROP_READ | WIA_PROP_NONE, VT_V_UI1, 0,    0,    0,    0}, // WIA_IPC_THUMBNAIL
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_ITEM_TIME
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPC_THUMB_WIDTH
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPC_THUMB_HEIGHT
    {WIA_PROP_READ | WIA_PROP_NONE, VT_CLSID, 0,    0,    0,    0}, // WIA_IPA_PREFERRED_FORMAT, set later
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_ITEM_SIZE

    {WIA_PROP_RW   | WIA_PROP_LIST, VT_CLSID, 0,    0,    0,    0}, // WIA_IPA_FORMAT, set later
    {WIA_PROP_RW   | WIA_PROP_LIST, VT_I4,    NUM_TYMED,    TYMED_FILE, PtrToLong(lTymeds)/* BUGBUG can our dll be loaded at > 4gig ??*/,     0}, // WIA_IPA_TYMED
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_COMPRESSION
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_CHANNELS
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_BITS_PER_CHANNEL
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_PLANAR
    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_BYTES_PER_LINE
    {WIA_PROP_RW   | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_ACCESS_RIGHTS

    {WIA_PROP_READ | WIA_PROP_NONE, VT_I4,    0,    0,    0,    0}, // WIA_IPA_MIN_BUFFER_SIZE

};



//
// Device capabilities.  Events are listed before commands to simplify the
// implementation of drvGetCapabilities(...)
//

#define N   WIA_NOTIFICATION_EVENT
#define A   WIA_ACTION_EVENT
#define NA  (WIA_NOTIFICATION_EVENT | WIA_ACTION_EVENT)

WIA_DEV_CAP_DRV gCapabilities[NUM_CAP_ENTRIES] =
{
    {(GUID *)&WIA_EVENT_DEVICE_CONNECTED,    N,  L"Device connected",    L"Device connected",    WIA_ICON_DEVICE_CONNECTED},
    {(GUID *)&WIA_EVENT_DEVICE_DISCONNECTED, N,  L"Device disconnected", L"Device disconnected", WIA_ICON_DEVICE_DISCONNECTED},
    {(GUID *)&WIA_EVENT_ITEM_CREATED,        N,  L"New picture created", L"New picture created", WIA_ICON_ITEM_CREATED},
    {(GUID *)&WIA_EVENT_ITEM_DELETED,        N,  L"Picture deleted",     L"Picture deleted",     WIA_ICON_ITEM_DELETED},
    {(GUID *)&WIA_CMD_TAKE_PICTURE,          0,  L"Take picture",        L"Take picture",        WIA_ICON_TAKE_PICTURE}

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\video\usd\precomp.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       precomp.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        9/7/99
 *
 *  DESCRIPTION: Precompiled header file for video usd
 *
 *****************************************************************************/


#ifndef _WIA_VIDEO_USD_PRECOMP_H_
#define _WIA_VIDEO_USD_PRECOMP_H_

#ifdef DBG
#ifndef DEBUG
#define DEBUG
#endif
#endif

#include <windows.h>

#include <psnew.h>
#include <simstr.h>
#include <simreg.h>
#include <simbstr.h>
#include <simlist.h>
#include <wiadebug.h>

#include <winioctl.h>
#include <ole2.h>
#include <initguid.h>
#include <gdiplus.h>
#include <uuids.h>
#include <sti.h>
#include <stiusd.h>
#include <stierr.h>
#include <atlbase.h>
#include <wiamindr.h>
#include <resource.h>
#include <istillf.h>
#include <vcamprop.h>
#include <image.h>
#include <vstiusd.h>
#include <defprop.h>
#include <coredbg.h>

extern HINSTANCE g_hInstance;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\video\usd\image.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999 - 2000
 *
 *  TITLE:       image.cpp
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        9/16/99
 *
 *  DESCRIPTION: Image class that encapsulates stored images from the
 *               streaming video device.
 *
 *****************************************************************************/

#include <precomp.h>
#pragma hdrstop

CLSID g_clsidBMPEncoder = GUID_NULL;

using namespace Gdiplus;

/*****************************************************************************

   CImage constructor/desctructor

   <Notes>

 *****************************************************************************/

CImage::CImage(LPCTSTR     pszStillPath,
               BSTR        bstrRootFullItemName,
               LPCTSTR     pszPath,
               LPCTSTR     pszName,
               LONG        FolderType)
  : m_strRootPath(pszStillPath),
    m_strPathItem(pszPath),
    m_strName(pszName),
    m_bstrItemName(pszName),
    m_bstrRootFullItemName(bstrRootFullItemName),
    m_FolderType(FolderType),
    m_bImageTimeValid(FALSE),
    m_pThumb(NULL)
{
    DBG_FN("CImage::CImage");

    CSimpleStringWide str;
    CSimpleStringWide strName(m_bstrItemName);

    //
    // First, we need to strip off the extensions
    // from the appropriate places
    //

    strName = strName.Left(strName.ReverseFind( TEXT('.') ));

    m_bstrItemName = CSimpleBStr(strName);

    str = bstrRootFullItemName;
    str.Concat(L"\\");
    str += CSimpleStringWide(m_bstrItemName);

    m_bstrFullItemName = str.String();
}


CImage::~CImage()
{
    if (m_pThumb)
    {
        delete [] m_pThumb;
    }
}

/*****************************************************************************

   CImage::LoadImageInfo

   Loads information about the image such as its width, height, type, etc.

 *****************************************************************************/

STDMETHODIMP
CImage::LoadImageInfo( BYTE * pWiasContext )
{
    ASSERT(pWiasContext != NULL);

    HRESULT hr = S_OK;
    LONG    lBitsPerChannel     = 0;
    LONG    lBitsPerPixel       = 0;
    LONG    lWidth              = 0;
    LONG    lHeight             = 0;
    LONG    lChannelsPerPixel   = 0;
    LONG    lBytesPerLine       = 0;
    Bitmap  Image(CSimpleStringConvert::WideString(m_strPathItem));

    if (pWiasContext == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("LoadImageInfo received a NULL pointer"));
        return hr;
    }
    else if (Image.GetLastStatus() != Ok)
    {
        hr = E_FAIL;
        CHECK_S_OK2(hr, ("CImage::LoadImageInfo failed to get the image information"
                         "for file '%ls'", CSimpleStringConvert::WideString(m_strPathItem)));

        return hr;
    }

    if (hr == S_OK)
    {
        PixelFormat lFormat;
        lFormat = Image.GetPixelFormat();

        if ((lFormat == PixelFormat16bppGrayScale) ||
            (lFormat == PixelFormat16bppRGB555)    ||
            (lFormat == PixelFormat16bppRGB565)    ||
            (lFormat == PixelFormat16bppARGB1555))
        {
            lBitsPerPixel   = 16;
            lBitsPerChannel = 5;   // this is actually not completely correct for RGB565, but anyway...
        }
        else if (lFormat == PixelFormat24bppRGB)
        {
            lBitsPerPixel   = 24;
            lBitsPerChannel = 8;
        }
        else if ((lFormat == PixelFormat32bppRGB)   ||
                 (lFormat == PixelFormat32bppARGB)  ||
                 (lFormat == PixelFormat32bppPARGB))
        {
            lBitsPerPixel   = 32;
            lBitsPerChannel = 10; // well, video cap won't have alpha in it, 
        }

        lWidth            = (LONG) Image.GetWidth();
        lHeight           = (LONG) Image.GetHeight();
        lChannelsPerPixel = 3;
        lBytesPerLine     = lWidth * (lBitsPerPixel / 8);
    }

    if (hr == S_OK)
    {
        PROPSPEC    propSpecs[7];
        PROPVARIANT propVars[7];

        ZeroMemory(&propSpecs, sizeof(propSpecs));

        // WIA_IPA_DATATYPE
        propSpecs[0].ulKind = PRSPEC_PROPID;
        propSpecs[0].propid = WIA_IPA_DATATYPE;
        propVars[0].vt      = VT_I4;
        propVars[0].lVal    = WIA_DATA_COLOR;

        // WIA_IPA_DEPTH
        propSpecs[1].ulKind = PRSPEC_PROPID;
        propSpecs[1].propid = WIA_IPA_DEPTH;
        propVars[1].vt      = VT_I4;
        propVars[1].lVal    = lBitsPerPixel;

        // WIA_IPA_PIXELS_PER_LINE
        propSpecs[2].ulKind = PRSPEC_PROPID;
        propSpecs[2].propid = WIA_IPA_PIXELS_PER_LINE;
        propVars[2].vt      = VT_I4;
        propVars[2].lVal    = lWidth;

        // WIA_IPA_NUMBER_OF_LINES
        propSpecs[3].ulKind = PRSPEC_PROPID;
        propSpecs[3].propid = WIA_IPA_NUMBER_OF_LINES;
        propVars[3].vt      = VT_I4;
        propVars[3].lVal    = lHeight;

        // WIA_IPA_CHANNELS_PER_PIXEL
        propSpecs[4].ulKind = PRSPEC_PROPID;
        propSpecs[4].propid = WIA_IPA_CHANNELS_PER_PIXEL;
        propVars[4].vt      = VT_I4;
        propVars[4].lVal    = lChannelsPerPixel;

        // WIA_IPA_BITS_PER_CHANNEL
        propSpecs[5].ulKind = PRSPEC_PROPID;
        propSpecs[5].propid = WIA_IPA_BITS_PER_CHANNEL;
        propVars[5].vt      = VT_I4;
        propVars[5].lVal    = lBitsPerChannel;

        // WIA_IPA_BYTES_PER_LINE
        propSpecs[6].ulKind = PRSPEC_PROPID;
        propSpecs[6].propid = WIA_IPA_BYTES_PER_LINE;
        propVars[6].vt      = VT_I4;
        propVars[6].lVal    = lBytesPerLine;

        // write the values of the properties.
        hr = wiasWriteMultiple(pWiasContext, 
                               sizeof(propVars) / sizeof(propVars[0]), 
                               propSpecs, 
                               propVars);

        CHECK_S_OK2(hr, ("CImage::LoadImageInfo, failed to write image properties"));
    }

    return hr;
}



/*****************************************************************************

   CImage::SetItemSize

   Call wia to calc new item size

 *****************************************************************************/

STDMETHODIMP
CImage::SetItemSize(BYTE                     * pWiasContext, 
                    MINIDRV_TRANSFER_CONTEXT * pDrvTranCtx)
{
    HRESULT                    hr;
    MINIDRV_TRANSFER_CONTEXT   drvTranCtx;
    GUID                       guidFormatID;
    BOOL                       bWriteProps = (pDrvTranCtx == NULL);

    DBG_FN("CImage::SetItemSize");

    ZeroMemory(&drvTranCtx, sizeof(MINIDRV_TRANSFER_CONTEXT));

    if (!pDrvTranCtx)
    {
        pDrvTranCtx = &drvTranCtx;
    }

    hr = wiasReadPropGuid(pWiasContext,
                          WIA_IPA_FORMAT,
                          (GUID*)&(pDrvTranCtx->guidFormatID),
                          NULL,
                          FALSE);

    CHECK_S_OK2(hr,("wiasReadPropGuid( WIA_IPA_FORMAT )"));

    if (FAILED(hr))
    {
        return hr;
    }

    hr = wiasReadPropLong( pWiasContext,
                           WIA_IPA_TYMED,
                           (LONG*)&(pDrvTranCtx->tymed),
                           NULL,
                           FALSE
                         );
    CHECK_S_OK2(hr,("wiasReadPropLong( WIA_IPA_TYMED )"));

    if (FAILED(hr))
    {
        return hr;
    }

    //
    // Wias works for DIB, and minidriver support native formats
    //

    if ((pDrvTranCtx->guidFormatID != WiaImgFmt_JPEG) &&
        (pDrvTranCtx->guidFormatID != WiaImgFmt_FLASHPIX) &&
        (pDrvTranCtx->guidFormatID != WiaImgFmt_TIFF))
    {
        //
        // Create the image from the file.
        //
        Bitmap BitmapImage(CSimpleStringConvert::WideString(m_strPathItem));
        if (Ok == BitmapImage.GetLastStatus())
        {
            //
            // Get the image's dimensions
            //
            UINT nSourceWidth = BitmapImage.GetWidth();
            UINT nSourceHeight = BitmapImage.GetHeight();
            if (nSourceWidth && nSourceHeight)
            {
                //
                // Fill in info for drvTranCtx
                //
                pDrvTranCtx->lCompression   = WIA_COMPRESSION_NONE;
                pDrvTranCtx->lWidthInPixels = nSourceWidth;
                pDrvTranCtx->lLines         = nSourceHeight;
                pDrvTranCtx->lDepth         = 24;

                hr = wiasGetImageInformation( pWiasContext, 0, pDrvTranCtx );

                //
                // We need to write out the item size based on
                // the JPEG converted to a BMP.  But we only need
                // to do this if the incoming context was NULL.
                //
                if (bWriteProps)
                {
                    hr = wiasWritePropLong( pWiasContext,
                                            WIA_IPA_ITEM_SIZE,
                                            pDrvTranCtx->lItemSize
                                          );
                    CHECK_S_OK2(hr,("wiasWritePropLong( WIA_IPA_ITEM_SIZE )"));

                    hr = wiasWritePropLong( pWiasContext,
                                            WIA_IPA_BYTES_PER_LINE,
                                            pDrvTranCtx->cbWidthInBytes
                                          );
                    CHECK_S_OK2(hr,("wiasWritePropLong( WIA_IPA_BYTES_PER_LINE )"));
                }

            }
            else
            {
                DBG_ERR(("nSourceWidth OR nSourceHeight were zero"));
                hr = E_FAIL;
            }

        }
        else
        {
            DBG_ERR(("Ok == BitmapImage.GetLastStatus failed"));
            hr = E_FAIL;
        }

    }
    else
    {

        CMappedView cmv( ActualImagePath(), 0, OPEN_EXISTING );

        LARGE_INTEGER liSize = cmv.FileSize();
        ULONG         ulSize;

        if (liSize.HighPart)
        {
            ulSize = 0;
            DBG_ERR(("The file was bigger than 4GB!!!"));
        }
        else
        {
            //
            // We could truncate here, I know, but that would have to be one huge file...
            // Anyway, the size wouldn't fit in te properties, which expects a LONG
            //
            ulSize = (ULONG)liSize.LowPart;
        }

        pDrvTranCtx->lItemSize      = ulSize;
        pDrvTranCtx->cbWidthInBytes = 0;

        if (bWriteProps)
        {
            //
            // We need to write out the item size based on the file size...
            //

            hr = wiasWritePropLong(pWiasContext,
                                   WIA_IPA_ITEM_SIZE,
                                   ulSize);

            CHECK_S_OK2(hr,("wiasWritePropLong( WIA_IPA_ITEM_SIZE )"));

            hr = wiasWritePropLong(pWiasContext,
                                   WIA_IPA_BYTES_PER_LINE,
                                   0);
        }

        CHECK_S_OK2(hr,("wiasWritePropLong( WIA_IPA_BYTES_PER_LINE )"));
    }

    CHECK_S_OK(hr);
    return hr;
}



/*****************************************************************************

   CImage::LoadThumbnail

   Loads (or creates if not already present) the thumbnail for this item.
   We also write the thumbnail as a property for this item.

 *****************************************************************************/

STDMETHODIMP
CImage::LoadThumbnail( BYTE * pWiasContext )
{

    HRESULT hr = E_FAIL;
    DBG_FN("CImage::LoadThumbnail");

    //
    // Only create the thumbnail if we haven't done so already
    //
    if (!m_pThumb)
    {
        Status StatusResult = Ok;

        //
        // Open the source image and make sure it is OK
        //
        Bitmap SourceImage( CSimpleStringConvert::WideString(m_strPathItem) );

        StatusResult = SourceImage.GetLastStatus();
        if (Ok == StatusResult)
        {

            //
            // Create the scaled bitmap and make sure it is OK
            //
            Bitmap ScaledImage(THUMB_WIDTH, THUMB_HEIGHT);

            StatusResult = ScaledImage.GetLastStatus();
            if (Ok == StatusResult)
            {
                //
                // Get a graphics to render the scaled image to and make sure it isn't NULL
                //
                Graphics *pScaledGraphics = Graphics::FromImage(&ScaledImage);
                if (pScaledGraphics)
                {
                    //
                    // Make sure it is valid
                    //
                    StatusResult = pScaledGraphics->GetLastStatus();
                    if (StatusResult == Ok)
                    {
                        //
                        // Draw the image scaled to thumbnail size
                        //
                        StatusResult = pScaledGraphics->DrawImage(&SourceImage, 0, 0, THUMB_WIDTH, THUMB_HEIGHT );
                        if (Ok == StatusResult)
                        {
                            //
                            // Create a bitmap to hold the flipped thumbnail and make sure it is OK
                            //
                            Bitmap FlippedImage(THUMB_WIDTH, THUMB_HEIGHT);

                            StatusResult = FlippedImage.GetLastStatus();
                            if (Ok == StatusResult)
                            {
                                //
                                // Create a graphics object to render the flipped image to and make sure it isn't NULL
                                //
                                Graphics *pFlippedGraphics = Graphics::FromImage(&FlippedImage);
                                if (pFlippedGraphics)
                                {
                                    //
                                    // Make sure it is valid
                                    //
                                    StatusResult = pFlippedGraphics->GetLastStatus();
                                    if (Ok == StatusResult)
                                    {
                                        //
                                        // Set up the parallelogram to flip the image
                                        //
                                        Point SourcePoints[3];
                                        SourcePoints[0].X = 0;
                                        SourcePoints[0].Y = THUMB_HEIGHT;
                                        SourcePoints[1].X = THUMB_WIDTH;
                                        SourcePoints[1].Y = THUMB_HEIGHT;
                                        SourcePoints[2].X = 0;
                                        SourcePoints[2].Y = 0;

                                        //
                                        // Draw the image, flipped
                                        //
                                        StatusResult = pFlippedGraphics->DrawImage(&ScaledImage, SourcePoints, 3);
                                        if (StatusResult == Ok)
                                        {
                                            //
                                            // Get the scaled and flipped image bits
                                            //
                                            Rect rcThumb( 0, 0, THUMB_WIDTH, THUMB_HEIGHT );
                                            BitmapData BitmapData;

// This ifdef is due to an API change in GDI+.  Notice
// that the first param to LockBits in the new version 
// takes a ptr to RECT.  Old version takes a reference
// to a RECT.
#ifdef DCR_USE_NEW_293849
                                            StatusResult = FlippedImage.LockBits( &rcThumb, ImageLockModeRead, PixelFormat24bppRGB, &BitmapData );
#else
                                            StatusResult = FlippedImage.LockBits( rcThumb, ImageLockModeRead, PixelFormat24bppRGB, &BitmapData );
#endif
                                            if (Ok == StatusResult)
                                            {
                                                //
                                                // Allocate the thumbnail data
                                                //
                                                m_pThumb = new BYTE[THUMB_SIZE_BYTES];
                                                if (m_pThumb)
                                                {
                                                    //
                                                    // Copy the thumbnail data over
                                                    //
                                                    CopyMemory( m_pThumb, BitmapData.Scan0, THUMB_SIZE_BYTES );
                                                }
                                                else
                                                {
                                                    hr = E_OUTOFMEMORY;
                                                    CHECK_S_OK2(hr, ("m_pThumb is NULL, couldn't allocate memory"));
                                                }
                                                //
                                                // Unlock the bits
                                                //
                                                FlippedImage.UnlockBits( &BitmapData );
                                            }
                                            else
                                            {
                                                DBG_ERR(("FlippedImage.LockBits( &rcThumb, ImageLockModeRead, PixelFormat24bppRGB, &BitmapData ) failed"));
                                            }
                                        }
                                        else
                                        {
                                            DBG_ERR(("pFlippedGraphics->DrawImage(&ScaledImage, SourcePoints, 3) failed"));
                                        }
                                    }
                                    else
                                    {
                                        DBG_ERR(("Ok == pFlippedGraphics->GetLastStatus() failed = '%d' (0x%08x)",
                                                 StatusResult, StatusResult));
                                    }
                                    //
                                    // Free the graphics object
                                    //
                                    delete pFlippedGraphics;
                                }
                                else
                                {
                                    DBG_ERR(("Graphics *pFlippedGraphics = Graphics::FromImage(&FlippedImage); returned NULL"));
                                }
                            }
                            else
                            {
                                DBG_ERR(("Ok == FlippedImage.GetLastStatus() failed = '%d',(0x%08x)",
                                         StatusResult, StatusResult));
                            }
                        }
                        else
                        {
                            DBG_ERR(("pScaledGraphics->DrawImage(&SourceImage, 0, 0, THUMB_WIDTH, THUMB_HEIGHT ) failed"));
                        }
                    }
                    else
                    {
                        DBG_ERR(("pScaledGraphics->GetLastStatus() failed = '%d' (0x%08x)",
                                 StatusResult, StatusResult));
                    }
                    //
                    // Free the graphics object
                    //
                    delete pScaledGraphics;
                }
                else
                {
                    DBG_ERR(("Graphics *pScaledGraphics = Graphics::FromImage(&ScaledImage); returned NULL"));
                }
            }
            else
            {
                DBG_ERR(("ScaledImage.GetLastStatus() failed = '%d' (0x%08x)",
                         StatusResult, StatusResult));
            }
        }
        else
        {
            DBG_ERR(("SourceImage.GetLastStatus() failed = '%d' (0x%08x)",
                     StatusResult, StatusResult));
        }
    }

    if (m_pThumb)
    {
        //
        // We have the bits, write them out as a property
        //

        PROPSPEC    propSpec;
        PROPVARIANT propVar;

        PropVariantInit(&propVar);

        propVar.vt          = VT_VECTOR | VT_UI1;
        propVar.caub.cElems = THUMB_SIZE_BYTES;
        propVar.caub.pElems = m_pThumb;

        propSpec.ulKind = PRSPEC_PROPID;
        propSpec.propid = WIA_IPC_THUMBNAIL;

        hr = wiasWriteMultiple(pWiasContext, 1, &propSpec, &propVar);
        CHECK_S_OK2(hr,("wiasWriteMultiple( WIA_IPC_THUMBNAIL )"));
    }
    else
    {
        if (SUCCEEDED(hr))
        {
            hr = E_FAIL;
        }
    }

    CHECK_S_OK(hr);
    return hr;
}


/*****************************************************************************

   CImage::InitImageInformation

   Called to initialize the properties for this image.  In the process,
   we also load (or create if needed) the thumbnail for this item.

 *****************************************************************************/

STDMETHODIMP
CImage::InitImageInformation(BYTE *pWiasContext,
                             LONG *plDevErrVal)
{
    HRESULT hr = S_OK;
    SYSTEMTIME st;


    DBG_FN("CImage::InitImageInformation");

    //
    // Use WIA services to set the extended property access and
    // valid value information from gWiaPropInfoDefaults.
    //

    hr = wiasSetItemPropAttribs( pWiasContext,
                                 NUM_CAM_ITEM_PROPS,
                                 gPropSpecDefaults,
                                 gWiaPropInfoDefaults
                               );
    //
    // Use WIA services to write image properties.
    //

    hr = wiasWritePropLong(pWiasContext, WIA_IPC_THUMB_WIDTH, ThumbWidth());
    CHECK_S_OK2(hr,("wiasWritePropLong( WIA_IPC_THUMB_WIDTH )"));

    hr = wiasWritePropLong(pWiasContext, WIA_IPC_THUMB_HEIGHT, ThumbHeight());
    CHECK_S_OK2(hr,("wiasWritePropLong( WIA_IPC_THUMB_HEIGHT )"));

    hr = wiasWritePropGuid(pWiasContext, WIA_IPA_PREFERRED_FORMAT, WiaImgFmt_JPEG);
    CHECK_S_OK2(hr,("wiasWritePropGuid( WIA_IPA_PREFERRED_FORMAT )"));

    GetImageTimeStamp( &st );
    hr = wiasWritePropBin( pWiasContext, WIA_IPA_ITEM_TIME, sizeof(SYSTEMTIME), (PBYTE)&st);
    CHECK_S_OK2(hr,("wiasWritePropBin( WIA_IPA_ITEM_TIME )"));

    //
    // calc item size
    //

    hr = SetItemSize(pWiasContext,NULL);
    CHECK_S_OK2(hr,("SetItemSize"));

    //
    // load thumbnail
    //

    hr = LoadThumbnail( pWiasContext );
    CHECK_S_OK2(hr,("LoadThumbnail"));

    //
    // Load additional image information such as the pixels per line, 
    // number of lines, etc.
    //
    hr = LoadImageInfo(pWiasContext);

    CHECK_S_OK2(hr,("wiaSetItemPropAttribs"));

    return hr;
}


/*****************************************************************************

   CImage::bstrItemName

   Returns the item name in the form of a BSTR.

 *****************************************************************************/

BSTR
CImage::bstrItemName()
{
    DBG_FN("CImage::bstrItemName");

    return m_bstrItemName;
}


/*****************************************************************************

   CImage::bstrFullItemName

   Returns the full item name in the form of a BSTR.

 *****************************************************************************/

BSTR
CImage::bstrFullItemName()
{
    DBG_FN("CImage::bstrFullItemName");

    return m_bstrFullItemName;
}



/*****************************************************************************

   CImage::ThumbWidth

   returns the thumbnail width

 *****************************************************************************/

LONG
CImage::ThumbWidth()
{
    DBG_FN("CImage::ThumbWidth");

    return THUMB_WIDTH;
}



/*****************************************************************************

   CImage::ThumbHeight

   returns the thumbnail height

 *****************************************************************************/

LONG
CImage::ThumbHeight()
{
    DBG_FN("CImage::ThumbHeight");

    return THUMB_HEIGHT;
}


/*****************************************************************************

   CImage::ImageTimeStamp

   returns creation time of image

 *****************************************************************************/

void
CImage::GetImageTimeStamp(SYSTEMTIME * pst)
{
    DBG_FN("CImage::ImageTimeStamp");

    if (!m_bImageTimeValid)
    {
        HANDLE hFile = CreateFile(m_strPathItem,
                                  GENERIC_READ,
                                  FILE_SHARE_READ | FILE_SHARE_WRITE,
                                  NULL,
                                  OPEN_EXISTING,
                                  FILE_ATTRIBUTE_NORMAL,
                                  NULL);

        if (hFile != INVALID_HANDLE_VALUE)
        {
            FILETIME ft;

            if (GetFileTime( hFile, &ft, NULL, NULL ))
            {
                FILETIME ftLocal;

                if (FileTimeToLocalFileTime(&ft, &ftLocal))
                {
                    if (FileTimeToSystemTime( &ftLocal, &m_ImageTime ))
                    {

                        m_bImageTimeValid = TRUE;
                    }

                }

            }

            CloseHandle( hFile );
        }
        else
        {
            DBG_ERR(("CreateFile( %ls ) failed, GLE = %d",
                     m_strPathItem.String(), GetLastError()));

            //
            // default to filling in structure w/zeros
            //

            memset( pst, 0, sizeof(SYSTEMTIME) );
        }
    }

    if (m_bImageTimeValid && pst)
    {
        *pst = m_ImageTime;
    }
}



/*****************************************************************************

   CImage::ActualImagePath

   Returns filename path of actual image

 *****************************************************************************/

LPCTSTR
CImage::ActualImagePath()
{
    DBG_FN("CImage::ActualImagePath");

    return m_strPathItem.String();
}



/*****************************************************************************

   CImage::DoDelete

   Deletes the file (and thumbail) from the disk.

 *****************************************************************************/

HRESULT
CImage::DoDelete()
{
    HRESULT hr = S_OK;
    BOOL    bResFile;

    DBG_FN("CImage::DoDelete");

    //
    // Make sure we have a file to delete...
    //

    if (!m_strPathItem.Length())
    {
        DBG_ERR(("filename for item is zero length!"));
        hr = E_INVALIDARG;
    }
    else
    {
        //
        // We've got an item, so delete it and the thumbnail file
        //

        bResFile = DeleteFile(m_strPathItem.String());

        if (!bResFile)
        {
            DBG_ERR(("DeleteFile( %ls ) failed, GLE = %d",
                     m_strPathItem.String(),GetLastError()));
        }

        if (bResFile)
        {
            m_strPathItem           = NULL;
            m_strRootPath           = NULL;
            m_strName               = NULL;
            m_bstrRootFullItemName  = NULL;
            m_bstrFullItemName      = NULL;
            m_bImageTimeValid       = FALSE;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }

    }

    CHECK_S_OK(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\video\usd\itemtree.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999-2000
 *
 *  TITLE:       ItemTree.cpp
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        9/10/99        RickTu
 *               2000/11/09     OrenR
 *
 *  DESCRIPTION: This code was originally in 'camera.cpp' but was broken out.
 *               This code builds and maintains the camera's IWiaDrvItem tree.
 *
 *
 *****************************************************************************/

#include <precomp.h>
#pragma hdrstop


/*****************************************************************************

   CVideoStiUsd::BuildItemTree

   Constructs an item tree which represents the layout of this
   WIA camera...

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::BuildItemTree(IWiaDrvItem **  ppIDrvItemRoot,
                            LONG *          plDevErrVal)
{
    HRESULT hr;

    DBG_FN("CVideoStiUsd::BuildItemTree");

    EnterCriticalSection( &m_csItemTree );

    //
    // Check for bad args
    //

    if (!ppIDrvItemRoot)
    {
        hr = E_POINTER;
    }

    //
    // Make sure that there is only one item tree
    //

    else if (m_pRootItem)
    {
        *ppIDrvItemRoot = m_pRootItem;

        //
        // refresh our tree.  We prune out all files which no longer exist
        // but for some reason remain in our tree (this can happen if someone
        // manually deletes a file from the temp WIA directory where we store
        // these images before they are transfered)
        //

        RefreshTree(m_pRootItem, plDevErrVal);

        hr = S_OK;
    }

    //
    // Lastly, build the tree if we need to
    //

    else
    {
        //
        // First check to see if we have a corresponding DShow device id
        // in the registry -- if not, then bail.
        //

        if (!m_strDShowDeviceId.Length())
        {
            hr = E_FAIL;
            CHECK_S_OK2(hr, ("CVideoStiUsd::BuildItemTree, the DShow Device ID"
                             "is empty, this should never happen"));
        }
        else
        {
            //
            // Create the new root
            //

            CSimpleBStr bstrRoot(L"Root");

            //
            // Call Wia service library to create new root item
            //

            hr = wiasCreateDrvItem(WiaItemTypeFolder | 
                                   WiaItemTypeRoot   | 
                                   WiaItemTypeDevice,
                                   bstrRoot.BString(),
                                   CSimpleBStr(m_strRootFullItemName),
                                   (IWiaMiniDrv *)this,
                                   sizeof(STILLCAM_IMAGE_CONTEXT),
                                   NULL,
                                   ppIDrvItemRoot);

            CHECK_S_OK2( hr, ("wiaCreateDrvItem" ));

            if (SUCCEEDED(hr) && *ppIDrvItemRoot)
            {
                m_pRootItem = *ppIDrvItemRoot;

                //
                // Add the items for this device
                //

                hr = EnumSavedImages( m_pRootItem );
                CHECK_S_OK2( hr, ("EnumSavedImages" ));


            }
        }
    }

    LeaveCriticalSection(&m_csItemTree);

    CHECK_S_OK(hr);
    return hr;
}

/*****************************************************************************

   CVideoStiUsd::AddTreeItem

   <Notes>

 *****************************************************************************/

HRESULT
CVideoStiUsd::AddTreeItem(CSimpleString *pstrFullImagePath,
                          IWiaDrvItem   **ppDrvItem)
{
    HRESULT hr          = S_OK;
    INT     iPos        = 0;
    LPCTSTR pszFileName = NULL;

    if (pstrFullImagePath == NULL)
    {
        hr = E_INVALIDARG;
        CHECK_S_OK2(hr, ("CVideoStiUsd::AddTreeItem, received NULL "
                         "param"));
        return hr;
    }

    //
    // Extract the file name from the full path.  We do this by searching 
    // for the  first '\' from the end of the string.
    //
    iPos = pstrFullImagePath->ReverseFind('\\');

    if (iPos < (INT) pstrFullImagePath->Length())
    {
        //
        // increment the position by 1 because we want to skip over the 
        // backslash.
        //
        ++iPos;

        // 
        // point to the filename within the full path.
        //
        pszFileName = &(*pstrFullImagePath)[iPos];
    }

    if (pszFileName)
    {
        //
        // Create a new DrvItem for this image and add it to the
        // DrvItem tree.
        //

        IWiaDrvItem *pNewFolder = NULL;

        hr = CreateItemFromFileName(WiaItemTypeFile | WiaItemTypeImage,
                                    pstrFullImagePath->String(),
                                    pszFileName,
                                    &pNewFolder);

        CHECK_S_OK2( hr, ("CVideoStiUsd::AddTreeItem, "
                          "CreateItemFromFileName failed"));

        if (hr == S_OK)
        {
            hr = pNewFolder->AddItemToFolder(m_pRootItem);

            CHECK_S_OK2( hr, ("CVideoStiUsd::AddTreeItem, "
                              "pNewFolder->AddItemToFolder failed"));
        }

        if (ppDrvItem)
        {
            *ppDrvItem = pNewFolder;
            (*ppDrvItem)->AddRef();
        }

        pNewFolder->Release();
    }

    return hr;
}



/*****************************************************************************

   CVideoStiUsd::EnumSavedImages

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::EnumSavedImages(IWiaDrvItem * pRootItem)
{
    DBG_FN("CVideoStiUsd::EnumSavedImages");

    HRESULT          hr = S_OK;
    WIN32_FIND_DATA  FindData;

    if (!m_strStillPath.Length())
    {
        DBG_ERR(("m_strStillPath is NULL, can't continue!"));
        return E_FAIL;
    }

    CSimpleString strTempName(m_strStillPath);
    strTempName.Concat( TEXT("\\*.jpg") );

    //
    // look for files at this level
    //

    HANDLE hFile = FindFirstFile(strTempName.String(), &FindData);

    if (hFile != INVALID_HANDLE_VALUE)
    {

        BOOL bStatus = FALSE;

        do
        {
            //
            // generate file name
            //

            strTempName.Assign( m_strStillPath );
            strTempName.Concat( TEXT("\\") );
            strTempName.Concat( FindData.cFileName );

            hr = AddTreeItem(&strTempName, NULL);

            if (FAILED(hr))
            {

                continue;
            }

            //
            // look for more images
            //

            bStatus = FindNextFile(hFile,&FindData);

        } while (bStatus);

        FindClose(hFile);
    }

    return S_OK;
}

/*****************************************************************************

   CVideoStiUsd::DoesFileExist

   <Notes>

 *****************************************************************************/

BOOL 
CVideoStiUsd::DoesFileExist(BSTR bstrFileName)
{
    DBG_FN("CVideoStiUsd::DoesFileExist");

    BOOL  bExists  = FALSE;
    DWORD dwAttrib = 0;

    if (bstrFileName == NULL)
    {
        return FALSE;
    }

    CSimpleString strTempName(m_strStillPath);
    strTempName.Concat(TEXT("\\"));
    strTempName.Concat(bstrFileName);
    strTempName.Concat(TEXT(".jpg"));

    dwAttrib = ::GetFileAttributes(strTempName);

    if (dwAttrib != 0xFFFFFFFF)
    {
        bExists = TRUE;
    }
    else
    {
        bExists = FALSE;
    }

    return bExists;
}


/*****************************************************************************

   CVideoStiUsd::PruneTree

   Removes nodes from the tree whose filenames no longer exist in the temp
   directory

 *****************************************************************************/

HRESULT 
CVideoStiUsd::PruneTree(IWiaDrvItem * pRootItem,
                        BOOL        * pbTreeChanged)
{
    DBG_FN("CVideoStiUsd::PruneTree");

    HRESULT                 hr             = S_OK;
    BOOL                    bTreeChanged   = FALSE;
    IWiaDrvItem             *pCurrentItem  = NULL;
    IWiaDrvItem             *pNextItem     = NULL;
    BSTR                    bstrItemName   = NULL;

    if ((pRootItem == NULL) || (pbTreeChanged == NULL))
    {
        return E_INVALIDARG;
    }
    else if (!m_strStillPath.Length())
    {
        DBG_ERR(("m_strStillPath is NULL, can't continue!"));
        return E_FAIL;
    }

    // This function DOES NOT do an AddRef
    hr = pRootItem->GetFirstChildItem(&pCurrentItem);

    while ((hr == S_OK) && (pCurrentItem != NULL))
    {
        pNextItem = NULL;

        pCurrentItem->AddRef();

        hr = pCurrentItem->GetItemName(&bstrItemName);

        if (SUCCEEDED(hr) && (bstrItemName != NULL))
        {
            //
            // if the filename for this item does not exist, 
            // then remove it from our tree.
            //
            if (!DoesFileExist(bstrItemName))
            {
                //
                // get the next item in the list so we don't lose our place
                // in the list after removing the current item.
                //
                hr = pCurrentItem->GetNextSiblingItem(&pNextItem);
                CHECK_S_OK2(hr, ("pCurrentItem->GetNextSiblingItem"));

                //
                // remove the item from the folder, we no longer need it.
                //
                hr = pCurrentItem->RemoveItemFromFolder(WiaItemTypeDeleted);
                CHECK_S_OK2(hr, ("pItemToRemove->RemoveItemFromFolder"));

                //
                // Report the error, but continue.  If we failed to 
                // remove the item from the tree, for whatever reason, 
                // there really is nothing we can do but proceed and 
                // prune the remainder of the tree.  
                //
                if (hr != S_OK)
                {
                    DBG_ERR(("Failed to remove item from folder, "
                             "hr = 0x%08lx", 
                             hr));

                    hr = S_OK;
                }

                if (m_lPicsTaken > 0)
                {
                    //
                    // Decrement the # of pics taken only if the 
                    // current # of pics is greater than 0.
                    //
                    InterlockedCompareExchange(
                                     &m_lPicsTaken, 
                                     m_lPicsTaken - 1,
                                     (m_lPicsTaken > 0) ? m_lPicsTaken : -1);
                }

                //
                // Indicate the tree was changed so we can send a notification
                // when we are done.
                //
                bTreeChanged = TRUE;
            }
            else
            {
                // file does exist, all is well in the world, move on to next
                // item in the tree.
                hr = pCurrentItem->GetNextSiblingItem(&pNextItem);
            }
        }

        //
        // release the current item since we AddRef'd it at the start of this 
        // loop.  
        //
        pCurrentItem->Release();
        pCurrentItem = NULL;

        // 
        // set our next item to be our current item.  It is possible that
        // pNextItem is NULL.
        //
        pCurrentItem = pNextItem;

        //
        // Free the BSTR.
        //
        if (bstrItemName)
        {
            ::SysFreeString(bstrItemName);
            bstrItemName = NULL;
        }
    }

    hr = S_OK;

    if (pbTreeChanged)
    {
        *pbTreeChanged = bTreeChanged;
    }


    return hr;
}

/*****************************************************************************

   CVideoStiUsd::IsFileAlreadyInTree

   <Notes>

 *****************************************************************************/

BOOL 
CVideoStiUsd::IsFileAlreadyInTree(IWiaDrvItem * pRootItem,
                                  LPCTSTR       pszFileName)
{
    DBG_FN("CVideoStiUsd::IsFileAlreadyInTree");

    HRESULT         hr                          = S_OK;
    BOOL            bFound                      = FALSE;
    IWiaDrvItem     *pCurrentItem               = NULL;

    if ((pRootItem   == NULL) ||
        (pszFileName == NULL))
    {
        bFound = FALSE;
        DBG_ERR(("CVideoStiUsd::IsFileAlreadyInTree received a NULL pointer, "
                 "returning FALSE, item not found in tree."));

        return bFound;
    }

    CSimpleString strFileName( m_strStillPath );
    CSimpleString strBaseName( pszFileName );
    strFileName.Concat( TEXT("\\") );
    strFileName.Concat( strBaseName );

    CImage Image(m_strStillPath,
                 CSimpleBStr(m_strRootFullItemName),
                 strFileName.String(),
                 strBaseName.String(),
                 WiaItemTypeFile | WiaItemTypeImage);

    hr = pRootItem->FindItemByName(0, 
                                   Image.bstrFullItemName(),
                                   &pCurrentItem);

    if (hr == S_OK)
    {
        bFound = TRUE;
        //
        // Don't forget to release the driver item, since it was AddRef'd by
        // FindItemByName(..)
        //
        pCurrentItem->Release();
    }
    else
    {
        bFound = FALSE;
    }

    return bFound;
}


/*****************************************************************************

   CVideoStiUsd::AddNewFilesToTree

   <Notes>

 *****************************************************************************/

HRESULT
CVideoStiUsd::AddNewFilesToTree(IWiaDrvItem * pRootItem,
                                BOOL        * pbTreeChanged)
{
    DBG_FN("CVideoStiUsd::AddNewFilesToTree");

    HRESULT          hr           = E_FAIL;
    BOOL             bTreeChanged = FALSE;
    HANDLE           hFile        = NULL;
    BOOL             bFileFound   = FALSE;
    WIN32_FIND_DATA  FindData;

    if ((pRootItem     == NULL) ||
        (pbTreeChanged == NULL))
    {
        return E_INVALIDARG;
    }

    if (!m_strStillPath.Length())
    {
        DBG_ERR(("m_strStillPath is NULL, can't continue!"));
        return E_FAIL;
    }

    CSimpleString strTempName(m_strStillPath);
    strTempName.Concat( TEXT("\\*.jpg") );

    //
    // Find all JPG files in the m_strStillPath directory.
    // This directory is %windir%\temp\wia\{Device GUID}\XXXX
    // where X is numeric.
    //
    hFile = FindFirstFile(strTempName.String(), &FindData);

    if (hFile != INVALID_HANDLE_VALUE)
    {
        bFileFound = TRUE;
    }

    //
    // Iterate through all files in the directory and for each
    // one check to see if it is already in the tree.  If it 
    // isn't, then add it to the tree.  If it is, do nothing
    // and move to the next file in the directory
    //
    while (bFileFound)
    {
        //
        // Check if the file in the directory is already in our
        // tree.
        //
        if (!IsFileAlreadyInTree(pRootItem, FindData.cFileName))
        {
            //
            // add an image to this folder
            //
            // generate file name
            //
    
            strTempName.Assign( m_strStillPath );
            strTempName.Concat( TEXT("\\") );
            strTempName.Concat( FindData.cFileName );

            hr = AddTreeItem(&strTempName, NULL);

            // 
            // Set this flag to indicate that changes were made to the 
            // tree, hence we will send an event indicating this when we
            // are done.
            //
            bTreeChanged = TRUE;
        }

        //
        // look for more images
        //
    
        bFileFound = FindNextFile(hFile,&FindData);
    }

    if (hFile)
    {
        FindClose(hFile);
        hFile = NULL;
    }

    if (pbTreeChanged)
    {
        *pbTreeChanged = bTreeChanged;
    }

    return S_OK;
}


/*****************************************************************************

   CVideoStiUsd::RefreshTree

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::RefreshTree(IWiaDrvItem * pRootItem,
                          LONG *        plDevErrVal)
{
    DBG_FN("CVideoStiUsd::RefreshTree");

    BOOL    bItemsAdded    = FALSE;
    BOOL    bItemsRemoved  = FALSE;
    HRESULT hr             = S_OK;

    //
    // Remove any dead nodes from the tree.  A dead node is a node in the tree
    // whose file has been deleted from the directory in m_strStillPath, 
    // but we still have a tree item for it.  
    //
    hr = PruneTree(pRootItem, &bItemsRemoved);
    CHECK_S_OK2(hr, ("PruneTree"));

    //
    // Add any news files that have been added to the folder but for some 
    // reason we don't have a tree node for them.
    //
    hr = AddNewFilesToTree(pRootItem, &bItemsAdded);
    CHECK_S_OK2(hr, ("AddNewFilesToTree"));
    
    //
    // If we added new nodes, removed some nodes, or both, then notify the 
    // guys upstairs (in the UI world) that the tree has been updated.
    //
    if ((bItemsAdded) || (bItemsRemoved))
    {
        hr = wiasQueueEvent(CSimpleBStr(m_strDeviceId), 
                            &WIA_EVENT_TREE_UPDATED, 
                            NULL);
    }

    return hr;
}



/*****************************************************************************

   CVideoStiUsd::CreateItemFromFileName

   Helper function that creates a WIA item from a filename (which is a .jpg).

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::CreateItemFromFileName(LONG              FolderType,
                                     LPCTSTR           pszPath,
                                     LPCTSTR           pszName,
                                     IWiaDrvItem **    ppNewFolder)
{
    HRESULT                 hr         = E_FAIL;
    IWiaDrvItem *           pNewFolder = NULL;
    PSTILLCAM_IMAGE_CONTEXT pContext   = NULL;

    DBG_FN("CVideoStiUsd::CreateItemFromFileName");

    //
    // Check for bad args
    //

    if (!ppNewFolder)
    {
        DBG_ERR(("ppNewFolder is NULL, returning E_INVALIDARG"));
        return E_INVALIDARG;
    }

    //
    // Set up return value
    //

    *ppNewFolder = NULL;

    //
    // Create new image object
    //

    CImage * pImage = new CImage(m_strStillPath,
                                 CSimpleBStr(m_strRootFullItemName),
                                 pszPath,
                                 pszName,
                                 FolderType);

    if (!pImage)
    {
        DBG_ERR(("Couldn't create new CImage, returning E_OUTOFMEMORY"));
        return E_OUTOFMEMORY;
    }

    //
    // call Wia to create new DrvItem
    //


    hr = wiasCreateDrvItem(FolderType,
                           pImage->bstrItemName(),
                           pImage->bstrFullItemName(),
                           (IWiaMiniDrv *)this,
                           sizeof(STILLCAM_IMAGE_CONTEXT),
                           (BYTE **)&pContext,
                           &pNewFolder);

    CHECK_S_OK2( hr, ("wiasCreateDrvItem"));

    if (SUCCEEDED(hr) && pNewFolder)
    {

        //
        // init device specific context
        //

        pContext->pImage = pImage;

        //
        // Return the item
        //

        *ppNewFolder = pNewFolder;


        //
        // Inc the number of pictures taken
        //

        InterlockedIncrement(&m_lPicsTaken);

    }
    else
    {
        DBG_ERR(("CVideoStiUsd::CreateItemFromFileName - wiasCreateItem "
                 "failed or returned NULL pNewFolder, hr = 0x%08lx, "
                 "pNewFolder = 0x%08lx, pContext = 0x%08lx", 
                 hr,
                 pNewFolder,pContext ));

        delete pImage;
        hr = E_OUTOFMEMORY;
    }

    return hr;
}


/*****************************************************************************

   CVideoStiUsd::InitDeviceProperties

   Initializes properties for the device on the device root item.

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::InitDeviceProperties(BYTE *  pWiasContext,
                                   LONG *  plDevErrVal)
{
    HRESULT                  hr             = S_OK;
    BSTR                     bstrFirmwreVer = NULL;
    int                      i              = 0;
    SYSTEMTIME               camTime;
    PROPVARIANT              propVar;

    DBG_FN("CVideoStiUsd::InitDeviceProperties");

    //
    // This device doesn't touch hardware to initialize the device properties.
    //

    if (plDevErrVal)
    {
        *plDevErrVal = 0;
    }

    //
    // Parameter validation.
    //

    if (pWiasContext == NULL)
    {
        hr = E_INVALIDARG;

        CHECK_S_OK2(hr, ("CVideoStiUsd::InitDeviceProperties received "
                         "NULL param."));

        return hr;
    }

    //
    // Write standard property names
    //

    hr = wiasSetItemPropNames(pWiasContext,
                              sizeof(gDevicePropIDs)/sizeof(PROPID),
                              gDevicePropIDs,
                              gDevicePropNames);

    CHECK_S_OK2(hr, ("wiaSetItemPropNames"));

    if (hr == S_OK)
    {

        //
        // Write the properties supported by all WIA devices
        //
    
        bstrFirmwreVer = SysAllocString(L"<NA>");
        if (bstrFirmwreVer)
        {
            wiasWritePropStr(pWiasContext, 
                             WIA_DPA_FIRMWARE_VERSION, 
                             bstrFirmwreVer);

            SysFreeString(bstrFirmwreVer);
        }
    
        hr = wiasWritePropLong(pWiasContext, WIA_DPA_CONNECT_STATUS, 1);
        hr = wiasWritePropLong(pWiasContext, WIA_DPC_PICTURES_TAKEN, 0);
    
        //
        // Write the camera properties, just default values, it may 
        // vary with items
        //
    
        hr = wiasWritePropLong(pWiasContext, WIA_DPC_THUMB_WIDTH,  80);
        hr = wiasWritePropLong(pWiasContext, WIA_DPC_THUMB_HEIGHT, 60);
    
        //
        // Write the Directshow Device ID
        //
        hr = wiasWritePropStr(pWiasContext, 
                              WIA_DPV_DSHOW_DEVICE_PATH, 
                              CSimpleBStr(m_strDShowDeviceId));
    
        //
        // Write the Images Directory
        //
        hr = wiasWritePropStr(pWiasContext, 
                              WIA_DPV_IMAGES_DIRECTORY, 
                              CSimpleBStr(m_strStillPath));
    
        //
        // Write the Last Picture Taken
        //
        hr = wiasWritePropStr(pWiasContext, 
                              WIA_DPV_LAST_PICTURE_TAKEN, 
                              CSimpleBStr(TEXT("")));
    
    
        //
        // Use WIA services to set the property access and
        // valid value information from gDevPropInfoDefaults.
        //
    
        hr =  wiasSetItemPropAttribs(pWiasContext,
                                     NUM_CAM_DEV_PROPS,
                                     gDevicePropSpecDefaults,
                                     gDevPropInfoDefaults);
    }

    return S_OK;
}


/*****************************************************************************

   CVideoStiUsd::InitImageInformation

   Used to initialize device items (images) from this device.

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::InitImageInformation( BYTE *                  pWiasContext,
                                    PSTILLCAM_IMAGE_CONTEXT pContext,
                                    LONG *                  plDevErrVal
                                  )
{
    HRESULT hr = S_OK;

    DBG_FN("CVideoStiUsd::InitImageInformation");

    //
    // Check for bad args
    //

    if ((pWiasContext == NULL) || 
        (pContext     == NULL))
    {
        hr = E_INVALIDARG;
        CHECK_S_OK2(hr, ("CVideoStiUsd::InitImageInformation, received "
                         "NULL params"));
        return hr;
    }

    //
    // Get the image in question
    //

    CImage * pImage = pContext->pImage;

    if (pImage == NULL)
    {
        hr = E_INVALIDARG;
    }

    if (hr == S_OK)
    {
        //
        // Ask the image to initialize the information
        //
    
        hr = pImage->InitImageInformation(pWiasContext, plDevErrVal);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\video\usd\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by dsusd.rc
//

#define IDS_SNAPSHOT                201

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        202
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\video\usd\image.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999 - 2000
 *
 *  TITLE:       image.h
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        9/16/99
 *
 *  DESCRIPTION: CImage class for WIA still from video driver.  Encapsulate
 *               saved images into a class (one instace for each class)
 *
 *****************************************************************************/


#ifndef __WIA_STILL_DRIVER_IMAGE_H_
#define __WIA_STILL_DRIVER_IMAGE_H_


#define THUMB_WIDTH     80
#define THUMB_HEIGHT    60
#define THUMB_BPP       3
#define THUMB_SIZE_BYTES (THUMB_WIDTH * THUMB_HEIGHT * THUMB_BPP)

extern CLSID g_clsidBMPEncoder;


class CImage
{
public:
    CImage(LPCTSTR  pszStillPath,
           BSTR     bstrRootFullItemName,
           LPCTSTR  pszPath,
           LPCTSTR  pszName,
           LONG     FolderType);

    ~CImage();

    //
    // Methods
    //

    STDMETHOD(InitImageInformation)(BYTE *pWiasContext,LONG *plDevErrVal);
    STDMETHOD(SetItemSize)(BYTE *pWiasContext, MINIDRV_TRANSFER_CONTEXT * pDrvTranCtx);
    STDMETHOD(LoadThumbnail)(BYTE *pWiasContext);
    STDMETHOD(LoadImageInfo)(BYTE *pWiasContext);

    void    GetImageTimeStamp( SYSTEMTIME * pst );
    void    GetImageSizes();
    LPCTSTR ActualImagePath();
    HRESULT DoDelete();

    //
    // "Properties" -- still methods but just returning information
    //

    BSTR        bstrItemName();
    BSTR        bstrFullItemName();
    LONG        ThumbWidth();
    LONG        ThumbHeight();

private:
    CSimpleString       m_strRootPath;
    CSimpleString       m_strPathItem;
    CSimpleString       m_strName;
    CSimpleBStr         m_bstrRootFullItemName;
    CSimpleBStr         m_bstrFullItemName;
    CSimpleBStr         m_bstrItemName;
    LONG                m_FolderType;
    SYSTEMTIME          m_ImageTime;
    BOOL                m_bImageTimeValid;
    CRITICAL_SECTION    m_cs;
    PBYTE               m_pThumb;
};

typedef struct _STILLCAM_IMAGE_CONTEXT
{
    CImage *        pImage;

} STILLCAM_IMAGE_CONTEXT,*PSTILLCAM_IMAGE_CONTEXT;


class CMappedView
{

private:
    BYTE * m_pBits;
    HANDLE m_hFile;
    HANDLE m_hMap;
    LONG   m_lSize;

public:
    CMappedView( LPCTSTR pszFile, LONG lSize, DWORD dwOpen )
      : m_pBits(NULL),
        m_hFile(INVALID_HANDLE_VALUE),
        m_hMap(NULL),
        m_lSize(lSize)
    {
        m_hFile = CreateFile( pszFile,
                              GENERIC_READ | GENERIC_WRITE,
                              FILE_SHARE_WRITE | FILE_SHARE_READ,
                              NULL,
                              dwOpen,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL
                             );

        if (m_hFile == INVALID_HANDLE_VALUE)
        {
            WIA_ERROR((TEXT("CreateFile failed w/GLE = %d"),GetLastError()));
        }

        WIA_TRACE((TEXT("CMappedView(0x%x) for %s"),m_hFile,pszFile));

        DoCreateFileMapping();
    }

    CMappedView( HANDLE hFile, LONG lSize )
      : m_pBits(NULL),
        m_hFile(hFile),
        m_hMap(INVALID_HANDLE_VALUE),
        m_lSize(lSize)
    {
        WIA_TRACE((TEXT("CMappedView(0x%x)"),m_hFile));

        DoCreateFileMapping();
    }

    void DoCreateFileMapping()
    {
        if (m_hFile != INVALID_HANDLE_VALUE)
        {
            m_hMap = CreateFileMapping( m_hFile,
                                        NULL,
                                        PAGE_READWRITE,
                                        0,
                                        m_lSize,
                                        NULL
                                       );

            if (m_hMap)
            {
                m_pBits = (PBYTE)MapViewOfFileEx( m_hMap,
                                                  FILE_MAP_READ | FILE_MAP_WRITE,
                                                  0,
                                                  0,
                                                  0,
                                                  NULL
                                                 );
            }
            else
            {
                WIA_ERROR((TEXT("CreateFileMapping failed w/GLE = %d"),GetLastError()));
            }
        }
    }

    LARGE_INTEGER FileSize()
    {
        WIA_TRACE((TEXT("CMappedView::FileSize")));

        LARGE_INTEGER li;

        li.QuadPart = 0;

#ifdef WINNT
        GetFileSizeEx( m_hFile, &li );
#else
        DWORD LowPart = 0;


        LowPart = GetFileSize( m_hFile, (DWORD *)&li.HighPart );

        if (LowPart != -1)
        {
            li.LowPart = LowPart;
        }
#endif

        return li;
    }

    void CloseAndRelease()
    {
        WIA_TRACE((TEXT("CMappedView::CloseAndRelease()")));

        if (m_pBits)
        {
            if (!UnmapViewOfFile( m_pBits ))
            {
                WIA_ERROR((TEXT("UnmapViewOfFile failed w/GLE = %d"),GetLastError()));
            }
            m_pBits = NULL;
        }

        if (m_hMap)
        {
            if (!CloseHandle( m_hMap ))
            {
                WIA_ERROR((TEXT("CloseHandle( m_hMap ) failed w/GLE = %s"),GetLastError()));
            }
            m_hMap = NULL;
        }

        if (m_hFile != INVALID_HANDLE_VALUE)
        {
            WIA_TRACE((TEXT("Closing file handle (0x%x)"),m_hFile));

            if (!CloseHandle( m_hFile ))
            {
                WIA_ERROR((TEXT("CloseHandle( m_hFile ) failed w/GLE = %s"),GetLastError()));
            }
            m_hFile = INVALID_HANDLE_VALUE;
        }
    }

    ~CMappedView()
    {
        WIA_TRACE((TEXT("~CMappedView")));
        CloseAndRelease();
    }

    PBYTE Bits()
    {
        return m_pBits;
    }

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\video\usd\sources.inc ===
!include          $(PROJECT_ROOT)\wia\wiaenv.inc

MAJORCOMP=STIUSD
MINORCOMP=Video

TARGETNAME=wiavusd
TARGETPATH=$(OBJ_DIR)
TARGETTYPE=DYNLINK
TARGETEXT=dll
DLLENTRY=_DllMainCRTStartup

DLLDEF=..\wiavusd.def

        #Common include files


# Utilities flags

# External references
INCLUDES = $(INCLUDES); \
        $(PROJECT_ROOT)\inc\psutil; \
        $(SDK_INC_PATH)\atl30;                \
        $(BASEDIR)\public\internal\shell\inc;\
        $(PROJECT_ROOT)\wia\drivers\video\filter; \
        $(PROJECT_ROOT)\wia\drivers\video\usd;


TARGETLIBS= \
        $(SDK_LIB_PATH)\kernel32.lib \
        $(SDK_LIB_PATH)\advapi32.lib \
        $(SDK_LIB_PATH)\user32.lib \
        $(SDK_LIB_PATH)\gdi32.lib \
        $(SDK_LIB_PATH)\ole32.lib \
        $(SDK_LIB_PATH)\oleaut32.lib \
        $(SDK_LIB_PATH)\uuid.lib \
        $(SDK_LIB_PATH)\strmiids.lib \
        $(SDK_LIB_PATH)\wiaguid.lib \
        $(SDK_LIB_PATH)\gdiplus.lib \
        $(SDK_LIB_PATH)\shfolder.lib \
        $(DDK_LIB_PATH)\wiaservc.lib \
        $(WIA_LIB_PATH)\stirt.lib \
        $(PROJECT_ROOT)\lib\$(PLATFORM_SUFFIX)\*\psutil.lib

# Source files
SOURCES= \
     ..\itemtree.cpp \
     ..\transfer.cpp \
     ..\globals.cpp  \
     ..\image.cpp    \
     ..\minidrv.cpp  \
     ..\videousd.cpp \
     ..\vstiusd.cpp  \
     ..\videousd.rc



PRECOMPILED_CXX=1
PRECOMPILED_INCLUDE=..\precomp.h
PRECOMPILED_PCH=precomp.pch
PRECOMPILED_OBJ=precomp.obj
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\video\usd\minidrv.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998 - 2000
 *
 *  TITLE:       minidrv.cpp
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        9/9/99
 *
 *  DESCRIPTION: This module implements IWiaMiniDrv for this device.
 *
 *****************************************************************************/

#include <precomp.h>
#pragma hdrstop

#include "wiamindr_i.c"
#include <sddl.h>
#include <shlobj.h>

///////////////////////////////
// Constants
//
const TCHAR* EVENT_PREFIX_GLOBAL        = TEXT("Global\\");
const TCHAR* EVENT_SUFFIX_TAKE_PICTURE  = TEXT("_TAKE_PICTURE");
const TCHAR* EVENT_SUFFIX_PICTURE_READY = TEXT("_PICTURE_READY");
const UINT   TAKE_PICTURE_TIMEOUT       = 1000 * 15;  // 15 seconds
//const UINT   DEFAULT_LOCK_TIMEOUT       = 1000 * 2;  // 2 seconds

// This is the Security Descriptor Language
// - Each ACE (access control entry) is represented in by parentheses.
// - A      = Allow ACE (as opposed to a Deny ACE)
// - OICI   = Allow Object Inheritance and Container Inheritence
// - GA     = Generic All Access (Full Control)
// - SY     = System account (SID)
// - BA     = Builtin Administrators Group
// - CO     = Creator/Owner
// - GR     = Generic Read
// - GW     = Generic Write
// - GX     = Generic Execute.
// - IU     = Interactive Users (User's logged on at the computer)
//
// More info, go to http://msdn.microsoft.com/library/psdk/winbase/accctrl_2n1v.htm
//
//
//                                                   
const TCHAR *OBJECT_DACLS= TEXT("D:(A;OICI;GA;;;SY)")                   // SYSTEM
                             TEXT("(A;OICI;GA;;;BA)")                   // Admin
                             TEXT("(A;OICI;GRGWGXDTSDCCLC;;;WD)")       // Everyone
                             TEXT("(A;OICI;GRGWGXDTSDCCLC;;;PU)")       // Power Users
                             TEXT("(A;OICI;GRGWGXDTSDCCLC;;;BU)");      // Users




/*****************************************************************************

   DirectoryExists

   Checks to see whether the given fully qualified directory exists.

 *****************************************************************************/

BOOL DirectoryExists(LPCTSTR pszDirectoryName)
{
    BOOL bExists = FALSE;

    //
    // Try to determine if this directory exists
    //

    if (pszDirectoryName)
    {
        DWORD dwFileAttributes = GetFileAttributes(pszDirectoryName);
    
        if (dwFileAttributes == 0xFFFFFFFF || 
            !(dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            bExists = FALSE;
        }
        else
        {
            bExists = TRUE;
        }
    }
    else
    {
        bExists = FALSE;
    }

    return bExists;
}


/*****************************************************************************

   RecursiveCreateDirectory

   Take a fully qualified path and create the directory in pieces as needed.

 *****************************************************************************/

BOOL RecursiveCreateDirectory(CSimpleString *pstrDirectoryName)
{
    ASSERT(pstrDirectoryName != NULL);

    //
    // If this directory already exists, return true.
    //

    if (DirectoryExists(*pstrDirectoryName))
    {
        return TRUE;
    }

    //
    // Otherwise try to create it.
    //

    CreateDirectory(*pstrDirectoryName, NULL );

    //
    // If it now exists, return true
    //

    if (DirectoryExists(*pstrDirectoryName))
    {
        return TRUE;
    }
    else
    {
        //
        // Remove the last subdir and try again
        //

        int nFind = pstrDirectoryName->ReverseFind(TEXT('\\'));
        if (nFind >= 0)
        {
            RecursiveCreateDirectory(&(pstrDirectoryName->Left(nFind)));

            //
            // Now try to create it.
            //

            CreateDirectory(*pstrDirectoryName, NULL);
        }
    }

    //
    //Does it exist now?
    //

    return DirectoryExists(*pstrDirectoryName);
}

///////////////////////////////
// SetDirectorySecurity
//
HRESULT SetDirectorySecurity(CSimpleString *pstrDirectoryName)
{
    HRESULT             hr       = S_OK;
    BOOL                bSuccess = TRUE;
    SECURITY_ATTRIBUTES SA;

    SA.nLength = sizeof(SECURITY_ATTRIBUTES);
    SA.bInheritHandle = TRUE;

    if (ConvertStringSecurityDescriptorToSecurityDescriptor(
            OBJECT_DACLS,
            SDDL_REVISION_1, 
            &(SA.lpSecurityDescriptor), 
            NULL)) 
    {
        bSuccess = SetFileSecurity(*pstrDirectoryName, 
                                   DACL_SECURITY_INFORMATION, 
                                   SA.lpSecurityDescriptor);

        if (!bSuccess)
        {
            hr = HRESULT_FROM_WIN32(GetLastError());
        }

        if (SA.lpSecurityDescriptor)
        {
            LocalFree(SA.lpSecurityDescriptor);
        }
    } 
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }

    return hr;
}


/*****************************************************************************

   CVideoStiUsd::drvInitializeWia [IWiaMiniDrv]

   WIA calls this method to ask us to do the following:

       * Initialize our mini driver.
       * Setup our optional private interface(s).
       * Build our device item tree.

   During initializiation we:

       * Cache the STI device pointer for locking.
       * Cache the device ID and root item full item name.
       * Initialize and hook up the DirectShow stream.


 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::drvInitializeWia( BYTE            *pWiasContext,
                                LONG            lFlags,
                                BSTR            bstrDeviceID,
                                BSTR            bstrRootFullItemName,
                                IUnknown        *pStiDevice,
                                IUnknown        *pIUnknownOuter,
                                IWiaDrvItem     **ppIDrvItemRoot,
                                IUnknown        **ppIUnknownInner,
                                LONG            *plDevErrVal
                               )
{
    HRESULT hr = S_OK;

    DBG_FN("CVideoStiUsd::drvInitializeWia");

    //
    // Initialize return values
    //

    if (ppIDrvItemRoot)
    {
        *ppIDrvItemRoot = NULL;
    }

    if (ppIUnknownInner)
    {
        *ppIUnknownInner = NULL;
    }

    if (plDevErrVal)
    {
        *plDevErrVal = 0;
    }

    //
    // Enter the critical section.
    //
    EnterCriticalSection(&m_csItemTree);

    m_dwConnectedApps++;

    DBG_TRC(("CVideoStiUsd::drvInitializeWia - Initializing Video Driver, "
             "Num Connected Apps = '%lu', device id = '%ws', Root Item Name = '%ws'", 
             m_dwConnectedApps,
             bstrDeviceID, 
             bstrRootFullItemName));

    if (m_dwConnectedApps == 1)
    {
        //
        // Cache what we need to
        //
    
        if (pStiDevice)
        {
            pStiDevice->QueryInterface( IID_IStiDevice, (void **)&m_pStiDevice );
        }
    
        m_strDeviceId.Assign(CSimpleStringWide(bstrDeviceID));
        m_strRootFullItemName.Assign(CSimpleStringWide(bstrRootFullItemName));
    
        //
        // Set the images directory.  The first param is NULL, which indicates 
        // that a default directory should be set.
        //
        if (hr == S_OK)
        {
            hr = SetImagesDirectory(NULL,
                                    pWiasContext,
                                    &m_pRootItem,
                                    plDevErrVal);
        }

        //
        // Enable the take picture event so that an app can send this driver
        // the take picture command, and this driver can signal the appliation
        // that owns wiavideo to take the picture.
        //
        if (hr == S_OK)
        {
            EnableTakePicture(pWiasContext);
        }
    }
    else
    {
        RefreshTree(m_pRootItem, plDevErrVal);
    }

    if (ppIDrvItemRoot)
    {
        *ppIDrvItemRoot = m_pRootItem;
    }

    //
    // Leave the critical section
    //
    LeaveCriticalSection(&m_csItemTree);

    CHECK_S_OK(hr);
    return hr;
}

/**************************************************************************\

 CVideoStiUsd::drvUnInitializeWia [IWiaMiniDrv]

   Gets called when a client connection is going away.
   WIA calls this method to ask us to do the following:

       * Cleanup any resources that are releated to this client connection
         (identified by pWiasContext)

 *************************************************************************/

STDMETHODIMP
CVideoStiUsd::drvUnInitializeWia(BYTE *pWiasContext)
{
    HRESULT hr = S_OK;

    DBG_FN("CVideoStiUsd::drvUnInitializeWia");

    EnterCriticalSection(&m_csItemTree);

    if (m_dwConnectedApps > 0)
    {
        m_dwConnectedApps--;
    }

    DBG_TRC(("CVideoStiUsd::drvUnInitializeWia, Num Connected Apps = '%lu'",
             m_dwConnectedApps));

    if ((m_dwConnectedApps == 0) && (m_pRootItem))
    {
        DisableTakePicture(pWiasContext, TRUE);

        DBG_TRC(("CVideoStiUsd::drvUnInitializeWia, no more connected apps, deleting tree"));

        hr = m_pRootItem->UnlinkItemTree(WiaItemTypeDisconnected);
        CHECK_S_OK2(hr,("m_pRootItem->UnlinkItemTree()"));

        // Clear the root item
        m_pRootItem = NULL;

        // Clear the pointer to the STI device we received
        m_pStiDevice = NULL;

        // reset the num pictures taken to 0.
        m_lPicsTaken = 0;
    }

    LeaveCriticalSection(&m_csItemTree);

    CHECK_S_OK(hr);
    return hr;
}


/*****************************************************************************

   CVideoStiUsd::drvGetDeviceErrorStr [IWiaMiniDrv]

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::drvGetDeviceErrorStr(LONG        lFlags,
                                   LONG        lDevErrVal,
                                   LPOLESTR *  ppszDevErrStr,
                                   LONG *      plDevErr)
{
    HRESULT hr = E_NOTIMPL;

    DBG_FN("CVideoStiUsd::drvGetDeviceErrorStr");

    CHECK_S_OK(hr);
    return hr;
}


/*****************************************************************************

   CVideoStiUsd::drvDeviceCommand [IWiaMiniDrv]

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::drvDeviceCommand(BYTE *          pWiasContext,
                               LONG            lFlags,
                               const GUID *    pGUIDCommand,
                               IWiaDrvItem **  ppMiniDrvItem,
                               LONG *          plDevErrVal)
{
    HRESULT hr = S_OK;

    DBG_FN("CVideoStiUsd::drvDeviceCommand");

    if (plDevErrVal)
    {
        *plDevErrVal = 0;
    }

    //
    // We support "Take snapshot" 
    //

    if (*pGUIDCommand == WIA_CMD_TAKE_PICTURE)
    {
        DBG_TRC(("CVideoStiUsd::drvDeviceCommand received command "
                 "WIA_CMD_TAKE_PICTURE"));

        //
        // Take a picture
        //
        hr = TakePicture(pWiasContext, ppMiniDrvItem);
    }
    else if (*pGUIDCommand == WIA_CMD_ENABLE_TAKE_PICTURE)
    {
        //
        // This command doesn't do anything.  However WiaVideo still expects
        // it to succeed, so if you remove this, remove the call from WiaVideo too.
        //
        DBG_TRC(("CVideoStiUsd::drvDeviceCommand received command "
                 "WIA_CMD_ENABLE_TAKE_PICTURE"));

        hr = S_OK;
    }
    else if (*pGUIDCommand == WIA_CMD_DISABLE_TAKE_PICTURE)
    {
        //
        // This command doesn't do anything.  However WiaVideo still expects
        // it to succeed, so if you remove this, remove the call from WiaVideo too.
        //

        DBG_TRC(("CVideoStiUsd::drvDeviceCommand received command "
                 "WIA_CMD_DISABLE_TAKE_PICTURE"));

        hr = S_OK;
    }

    CHECK_S_OK(hr);
    return hr;
}


/*****************************************************************************

   CVideoStiUsd::ValidateDataTransferContext

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::ValidateDataTransferContext(
                               PMINIDRV_TRANSFER_CONTEXT pDataTransferContext)
{
    DBG_FN("CVideoStiUsd::ValidateDataTransferContext");

    if (pDataTransferContext->lSize != sizeof(MINIDRV_TRANSFER_CONTEXT))
    {
        DBG_ERR(("invalid data transfer context -- wrong lSize"));
        return E_INVALIDARG;;
    }

    //
    // for tymed file or hglobal, only WiaImgFmt_BMP || WiaImgFmt_JPEG 
    // is allowed
    //

    if ((pDataTransferContext->tymed == TYMED_FILE) ||
        (pDataTransferContext->tymed == TYMED_HGLOBAL)
       )
    {
  
        if ((pDataTransferContext->guidFormatID != WiaImgFmt_BMP) &&
            (pDataTransferContext->guidFormatID != WiaImgFmt_JPEG))
        {
           DBG_ERR(("invalid format -- asked for TYMED_FILE or TYMED_HGLOBAL "
                    "but guidFormatID != (WiaImgFmt_BMP | WiaImgFmt_JPEG)"));

           return E_INVALIDARG;;
        }
  
    }

    //
    // for tymed CALLBACK, only WiaImgFmt_MEMORYBMP, WiaImgFmt_BMP and 
    // WiaImgFmt_JPEG are allowed
    //

    if (pDataTransferContext->tymed == TYMED_CALLBACK)
    {
        if ((pDataTransferContext->guidFormatID != WiaImgFmt_BMP) &&
            (pDataTransferContext->guidFormatID != WiaImgFmt_MEMORYBMP) &&
            (pDataTransferContext->guidFormatID != WiaImgFmt_JPEG))
        {
           DBG_ERR(("invalid format -- asked for TYMED_CALLBACK but "
                    "guidFormatID != (WiaImgFmt_BMP | WiaImgFmt_MEMORYBMP "
                    "| WiaImgFmt_JPEG)"));

           return E_INVALIDARG;;
        }
    } 


    //
    // callback is always double buffered, non-callback never is
    //

    if (pDataTransferContext->pTransferBuffer == NULL)
    {
        DBG_ERR(("invalid transfer context -- pTransferBuffer is NULL!"));
        return E_INVALIDARG;
    } 

    return S_OK;
}



/*****************************************************************************

   CVideoStiUsd::SendBitmapHeader

   Sends bitmap header during banded transfer

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::SendBitmapHeader(IWiaDrvItem *               pDrvItem,
                               PMINIDRV_TRANSFER_CONTEXT   pTranCtx)
{
    HRESULT hr = S_OK;

    DBG_FN("CVideoStiUsd::SendBitmapHeader");

    //
    // driver is sending TOPDOWN data, must swap biHeight
    //
    // this routine assumes pTranCtx->pHeader points to a
    // BITMAPINFO header (TYMED_FILE doesn't use this path
    // and DIB is the only format supported now)
    //

    PBITMAPINFO pbmi = (PBITMAPINFO)pTranCtx->pTransferBuffer;

    if (pTranCtx->guidFormatID == WiaImgFmt_MEMORYBMP)
    {
        pbmi->bmiHeader.biHeight = -pbmi->bmiHeader.biHeight;
    }

    hr = pTranCtx->pIWiaMiniDrvCallBack->MiniDrvCallback(
                                            IT_MSG_DATA,
                                            IT_STATUS_TRANSFER_TO_CLIENT,
                                            0,
                                            0,
                                            pTranCtx->lHeaderSize,
                                            pTranCtx,
                                            0);

    if (hr == S_OK) 
    {
        //
        // advance offset for destination copy
        //

        pTranCtx->cbOffset += pTranCtx->lHeaderSize;

    }

    CHECK_S_OK(hr);
    return hr;
}



/*****************************************************************************

   CVideoStiUsd::drvAquireItemData [IWiaMiniDrv]

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::drvAcquireItemData(BYTE *                    pWiasContext,
                                 LONG                      lFlags,
                                 PMINIDRV_TRANSFER_CONTEXT pDataContext,
                                 LONG *                    plDevErrVal)
{
    HRESULT hr = E_NOTIMPL;

    DBG_FN("CVideoStiUsd::drvAcquireItemData");

    *plDevErrVal = 0;

    //
    // Get a pointer to the associated driver item.
    //

    IWiaDrvItem* pDrvItem;

    hr = wiasGetDrvItem(pWiasContext, &pDrvItem);

    if (FAILED(hr))
    {
        CHECK_S_OK2(hr, ("wiaGetDrvItem Failed"));
        return hr;
    }

    //
    // Validate the data transfer context.
    //

    hr = ValidateDataTransferContext( pDataContext );

    if (FAILED(hr))
    {
        CHECK_S_OK2(hr, ("ValidateTransferContext failed"));
        return hr;
    }

#ifdef DEBUG
    //
    // Dump the request
    //

    DBG_TRC(("Asking for TYMED of 0x%x", pDataContext->tymed));

    if (pDataContext->guidFormatID == WiaImgFmt_BMP)
    {
        DBG_TRC(("Asking for WiaImgFmt_BMP"));
    }
    else if (pDataContext->guidFormatID == WiaImgFmt_MEMORYBMP)
    {
        DBG_TRC(("Asking for WiaImgFmt_MEMORYBMP"));
    }
    else if (pDataContext->guidFormatID == WiaImgFmt_JPEG)
    {
        DBG_TRC(("Asking for WiaImgFmt_JPEG"));
    }
#endif

    //
    // get item specific driver data
    //

    STILLCAM_IMAGE_CONTEXT  *pContext;

    pDrvItem->GetDeviceSpecContext((BYTE **)&pContext);

    if (!pContext)
    {
        hr = E_INVALIDARG;
        CHECK_S_OK2(hr, ("drvAcquireItemData, NULL item context"));
        return hr;
    }

    //
    // Use our internal routines to get format specific info...
    //

    if (pContext->pImage)
    {
        hr = pContext->pImage->SetItemSize( pWiasContext, pDataContext );
        CHECK_S_OK2(hr, ("pContext->pImage->SetItemSize()"));
    }
    else
    {
        DBG_ERR(("Couldn't use our internal routines to compute image "
                 "information, this is bad!"));

        //
        // As a last resort, use WIA services to fetch format specific info.
        //

        hr = wiasGetImageInformation(pWiasContext,
                                     0,
                                     pDataContext);

        CHECK_S_OK2(hr,("wiaGetImageInformation()"));
    }


    if (FAILED(hr))
    {
        CHECK_S_OK2(hr, ("wiasGetImageInformation failed"));
        return hr;
    }

    //
    // determine if this is a callback or buffered transfer
    //

    if (pDataContext->tymed == TYMED_CALLBACK)
    {
        DBG_TRC(("Caller wants callback"));

        //
        // For formats that have a data header, send it to the client
        //

        if (pDataContext->lHeaderSize > 0)
        {
            DBG_TRC(("Sending Bitmap Header..."));
            hr = SendBitmapHeader( pDrvItem, pDataContext );

            CHECK_S_OK2(hr,("SendBitmapHeader( pDrvItem, pDataContext )"));
        }

        if (hr == S_OK)
        {
            DBG_TRC(("Calling LoadImageCB..."));
            hr = LoadImageCB( pContext, pDataContext, plDevErrVal );
            CHECK_S_OK2(hr, ("LoadImageCB( pContext, pDataContext, "
                             "plDevErrVal"));
        }
    } 
    else 
    {
        DBG_TRC(("Caller doesn't want callback"));

        //
        // inc past header
        //

        pDataContext->cbOffset += pDataContext->lHeaderSize;

        DBG_TRC(("Calling LoadImage..."));
        hr = LoadImage( pContext, pDataContext, plDevErrVal );
        CHECK_S_OK2(hr, ("LoadImage( pContext, pDataContext, "
                         "plDevErrVal )"));
    }

    CHECK_S_OK(hr);
    return hr;
}


/*****************************************************************************

   CVideoStiUsd::drvInitItemProperties [IWiaMiniDrv]

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::drvInitItemProperties(BYTE * pWiasContext,
                                    LONG   lFlags,
                                    LONG * plDevErrVal)
{
    DBG_FN("CVideoStiUsd::drvInitItemProperties");

    HRESULT                  hr = S_OK;
    LONG                     lItemType;
    PSTILLCAM_IMAGE_CONTEXT  pContext;
    IWiaDrvItem *            pDrvItem;  // This is not a CComPtr because there
                                        // is no addref for us to release
    //
    // This device doesn't touch hardware to initialize the
    // device item properties.
    //

    *plDevErrVal = 0;

    //
    // Parameter validation.
    //

    if (!pWiasContext)
    {
        DBG_ERR(("drvInitItemProperties, invalid input pointers"));
        return E_INVALIDARG;
    }

    //
    // Get a pointer to the associated driver item.
    //

    if (hr == S_OK)
    {
        hr = wiasGetDrvItem(pWiasContext, &pDrvItem);
        CHECK_S_OK2(hr,("wiaGetDrvItem"));
    }

    if (hr == S_OK)
    {
        //
        // Root item has the all the device properties
        //
    
        hr = pDrvItem->GetItemFlags(&lItemType);
        CHECK_S_OK2(hr,("pDrvItem->GetItemFlags"));
    }

    if (hr == S_OK)
    {
        if (lItemType & WiaItemTypeRoot) 
        {
            //
            // Root item property init finishes here
            //
    
            hr = InitDeviceProperties( pWiasContext, plDevErrVal );
            CHECK_S_OK2(hr,("InitDeviceProperties for root item"));

        }
        else if (lItemType & WiaItemTypeFile)
        {
            //
            // If this is a file, init the properties
            //
    
            //
            // Add the item property names.
            //
    
            if (hr == S_OK)
            {
                hr = wiasSetItemPropNames(pWiasContext,
                                          NUM_CAM_ITEM_PROPS,
                                          gItemPropIDs,
                                          gItemPropNames);

                CHECK_S_OK2(hr,("wiaSetItemPropNames for item"));
            }

            if (hr == S_OK)
            {
                //
                // Use WIA services to set the default item properties.
                //
        
                hr = wiasWriteMultiple(pWiasContext,
                                       NUM_CAM_ITEM_PROPS,
                                       gPropSpecDefaults,
                                       (PROPVARIANT*)gPropVarDefaults);

                CHECK_S_OK2(hr,("wiaWriteMultiple for item props"));
            }
            
            if (hr == S_OK)
            {
                hr = pDrvItem->GetDeviceSpecContext( (BYTE **)&pContext );
                CHECK_S_OK2(hr,("GetDeviceSpecContext"));
            }

            if (hr == S_OK)
            {
                hr = InitImageInformation(pWiasContext, pContext, plDevErrVal);
                CHECK_S_OK2(hr,("InitImageInformation"));
            }
        }
    }

    return hr;
}

/*****************************************************************************

   CVideoStiUsd::ValidateItemProperties

   <Notes>

 *****************************************************************************/
HRESULT
CVideoStiUsd::ValidateItemProperties(BYTE               *pWiasContext,
                                     LONG               lFlags,
                                     ULONG              nPropSpec,
                                     const PROPSPEC     *pPropSpec,
                                     LONG               *plDevErrVal,
                                     IWiaDrvItem        *pDrvItem)
{
    DBG_FN("CVideoStiUsd::ValidateFileProperties");

    HRESULT hr = S_OK;

    if ((pWiasContext == NULL) || 
        (pPropSpec    == NULL))
    {
        hr = E_INVALIDARG;

        CHECK_S_OK2(hr, ("CVideoStiUsd::ValidateItemProperties received "
                         "NULL params"));
        return hr;
    }

    STILLCAM_IMAGE_CONTEXT  *pContext = NULL;

    hr = pDrvItem->GetDeviceSpecContext( (BYTE **)&pContext);

    CHECK_S_OK2(hr,("CVideoStiUsd::ValidateItemProperties, "
                    "GetDeviceSpecContext failed"));

    if (SUCCEEDED(hr) && pContext)
    {
        CImage * pImage = pContext->pImage;

        if (pImage)
        {
            //
            // calc item size
            //

            hr = pImage->SetItemSize( pWiasContext, NULL );
            CHECK_S_OK2(hr,("SetItemSize( pWiasContext )"));
        }


        //
        //  Change MinBufferSize property.  Need to get Tymed and
        //  ItemSize first, since MinBufferSize in dependant on these
        //  properties.
        //

        LONG        lTymed;
        LONG        lItemSize;
        LONG        lMinBufSize = 0;

        hr = wiasReadPropLong(pWiasContext, 
                              WIA_IPA_TYMED, 
                              &lTymed, 
                              NULL, 
                              TRUE);

        CHECK_S_OK2(hr, ("wiasReadPropLong( WIA_IPA_TYPMED )"));

        if (SUCCEEDED(hr))
        {
            hr = wiasReadPropLong(pWiasContext, 
                                  WIA_IPA_ITEM_SIZE, 
                                  &lItemSize, 
                                  NULL, 
                                  TRUE);

            CHECK_S_OK2(hr,("wiasReadPropLong( WIA_IPA_ITEM_SIZE )"));

            if (SUCCEEDED(hr))
            {
                //
                //  Update the MinBufferSize property.
                //

                switch (lTymed)
                {
                    case TYMED_CALLBACK:
                        lMinBufSize = 65535;
                    break;

                    default:
                        lMinBufSize = lItemSize;
                    break;
                }

                if (lMinBufSize)
                {
                    hr = wiasWritePropLong(pWiasContext, 
                                           WIA_IPA_MIN_BUFFER_SIZE, 
                                           lMinBufSize);

                    CHECK_S_OK2(hr, ("wiasWritePropLong( "
                                     "WIA_IPA_MIN_BUFFER_SIZE )"));
                }

                DBG_TRC(("WIA_IPA_MIN_BUFFER_SIZE set to %d bytes",
                         lMinBufSize));
            }
        }
    }

    return hr;
}

/*****************************************************************************

   CVideoStiUsd::ValidateDeviceProperties

   <Notes>

 *****************************************************************************/
HRESULT
CVideoStiUsd::ValidateDeviceProperties(BYTE             *pWiasContext,
                                       LONG             lFlags,
                                       ULONG            nPropSpec,
                                       const PROPSPEC   *pPropSpec,
                                       LONG             *plDevErrVal,
                                       IWiaDrvItem      *pDrvItem)
{
    DBG_FN("CVideoStiUsd::ValidateRootProperties");

    HRESULT hr = S_OK;

    //
    // Parameter validation.
    //

    if ((pWiasContext == NULL) || 
        (pPropSpec    == NULL))
    {
        hr = E_INVALIDARG;

        CHECK_S_OK2(hr, ("CVideoStiUsd::ValidateDeviceProperties received "
                         "NULL params"));
        return hr;
    }

    for (ULONG i = 0; i < nPropSpec; i++)
    {
        if ((pPropSpec[i].ulKind == PRSPEC_PROPID) &&
            (pPropSpec[i].propid == WIA_DPV_LAST_PICTURE_TAKEN))
        {
            DBG_TRC(("CVideoStiUsd::ValidateDeviceProperties, setting the "
                     "WIA_DPV_LAST_PICTURE_TAKEN property."));

            EnterCriticalSection(&m_csItemTree);

            //
            // process the last picture taken property change.
            //
    
            BSTR bstrLastPictureTaken = NULL;
    
            //
            // Read in the value for last picture taken.
            //
            hr = wiasReadPropStr(pWiasContext, 
                                 WIA_DPV_LAST_PICTURE_TAKEN, 
                                 &bstrLastPictureTaken, 
                                 NULL, 
                                 TRUE);
    
            if (hr == S_OK)
            {
                m_strLastPictureTaken = bstrLastPictureTaken;

                DBG_TRC(("CVideoStiUsd::ValidateDeviceProperties, last picture "
                         "taken = '%ls'", m_strLastPictureTaken.String()));

                //
                // This will add the new item to the tree and queue an 
                // ITEM_CREATED event
                // 
                hr = SignalNewImage(bstrLastPictureTaken);
            }

            // reset the last picture taken value.  This is needed because the
            // service checks to see if the new value being set is the same as 
            // the current value, and if it is, it doesn't forward it on to us.
            // This is bad in the event of the Scanner and Camera wizard, where
            // it takes 1 picture, (so LAST_PICTURE_TAKEN has a value of "Picture 1"),
            // then deletes it, then user backs up the wizard, and takes a picture
            // again.  This new picture will have a value of "Picture 1" but we won't
            // add it to the tree because the value of the property hasn't changed
            // as far as the wia service is concerned.
            //
            if (hr == S_OK)
            {
                //
                // Write the Last Picture Taken
                //
                hr = wiasWritePropStr(pWiasContext, 
                                      WIA_DPV_LAST_PICTURE_TAKEN, 
                                      CSimpleBStr(TEXT("")));

            }
    
            //
            // Free the BSTR
            //
            if (bstrLastPictureTaken)
            {
                ::SysFreeString(bstrLastPictureTaken);
                bstrLastPictureTaken = NULL;
            }

            LeaveCriticalSection(&m_csItemTree);
        }
        else if ((pPropSpec[i].ulKind == PRSPEC_PROPID) &&
                 (pPropSpec[i].propid == WIA_DPV_IMAGES_DIRECTORY))
        {
            //
            // DPV_IMAGES_DIRECTORY - 
            //
    
            hr = E_FAIL;
            CHECK_S_OK2(hr, ("CVideoStiUsd::ValidateRootProperties, "
                             "attempting to validate the Images Directory "
                             "property, but this is a read-only "
                             "property"));
        }
        else if ((pPropSpec[i].ulKind == PRSPEC_PROPID) &&
                 (pPropSpec[i].propid == WIA_DPV_DSHOW_DEVICE_PATH))
        {
            //
            // process the DShowDeviceID change.
            //
    
            hr = E_FAIL;
            CHECK_S_OK2(hr, ("CVideoStiUsd::ValidateRootProperties, "
                             "attempting to validate the DShow Device "
                             "ID property, but this is a read-only "
                             "property"));
        }
    }

    return hr;
}

/*****************************************************************************

   CVideoStiUsd::drvValidateItemProperties [IWiaMiniDrv]

   <Notes>

 *****************************************************************************/
STDMETHODIMP
CVideoStiUsd::drvValidateItemProperties(BYTE           *pWiasContext,
                                        LONG           lFlags,
                                        ULONG          nPropSpec,
                                        const PROPSPEC *pPropSpec,
                                        LONG           *plDevErrVal)
{
    HRESULT hr = S_OK;

    DBG_FN("CVideoStiUsd::drvValidateItemProperties");

    if (plDevErrVal)
    {
        *plDevErrVal = 0;
    }

    //
    // Parameter validation.
    //

    if ((pWiasContext == NULL) || 
        (pPropSpec    == NULL))
    {
        hr = E_INVALIDARG;

        CHECK_S_OK2(hr, ("CVideoStiUsd::drvValidateItemProperties received "
                         "NULL params"));
        return hr;
    }

    //
    // Get item in question
    //

    //
    // not a CComPtr because there isn't an extra ref
    // on this guy from the caller
    //
    IWiaDrvItem* pDrvItem = NULL;  
                                   

    hr = wiasGetDrvItem(pWiasContext, &pDrvItem);

    CHECK_S_OK2(hr,("wiasGetDrvItem( pWiasContext, &pDrvItem )"));

    if (SUCCEEDED(hr))
    {
        LONG lItemType = 0;

        //
        // What kind of item is this?
        //

        hr = pDrvItem->GetItemFlags(&lItemType);
        CHECK_S_OK2(hr,("pDrvItem->GetItemFlags( &lItemType )"));

        if (SUCCEEDED(hr))
        {
            if (lItemType & WiaItemTypeFile)
            {
                hr = ValidateItemProperties(pWiasContext, 
                                            lFlags,
                                            nPropSpec,
                                            pPropSpec,
                                            plDevErrVal,
                                            pDrvItem);
            }
            else if (lItemType & WiaItemTypeRoot)
            {
                hr = ValidateDeviceProperties(pWiasContext, 
                                              lFlags,
                                              nPropSpec,
                                              pPropSpec,
                                              plDevErrVal,
                                              pDrvItem);
            }
        }
    }

    CHECK_S_OK(hr);

    return hr;
}


/*****************************************************************************

   CVideoStiUsd::drvWriteItemProperties [IWiaMiniDrv]

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::drvWriteItemProperties(BYTE *                    pWiasContext,
                                     LONG                      lFLags,
                                     PMINIDRV_TRANSFER_CONTEXT pmdtc,
                                     LONG *                    plDevErrVal)
{
    HRESULT hr = S_OK;

    DBG_FN("CVideoStiUsd::drvWriteItemProperties");

    if (plDevErrVal)
    {
        *plDevErrVal = 0;
    }

    CHECK_S_OK(hr);
    return hr;
}

/*****************************************************************************

   CVideoStiUsd::ReadItemProperties

   We only support reading thumbnails on demand for items

 *****************************************************************************/

HRESULT
CVideoStiUsd::ReadItemProperties(BYTE           *pWiasContext,
                                 LONG           lFlags,
                                 ULONG          nPropSpec,
                                 const PROPSPEC *pPropSpec,
                                 LONG           *plDevErrVal,
                                 IWiaDrvItem    *pDrvItem)
{
    HRESULT                 hr        = S_OK;
    STILLCAM_IMAGE_CONTEXT  *pContext = NULL;

    if ((pPropSpec == NULL) ||
        (pDrvItem  == NULL))
    {
        hr = E_INVALIDARG;
        CHECK_S_OK2(hr, ("CVideoStiUsd::ReadItemProperties received a "
                         "NULL param"));
        return hr;
    }

    //
    // It's an item, now loop through the requested properties
    // and see if they're looking for the Thumbnail
    //

    for (ULONG i = 0; i < nPropSpec; i++)
    {
        if (((pPropSpec[i].ulKind == PRSPEC_PROPID) && 
             (pPropSpec[i].propid == WIA_IPC_THUMBNAIL)) ||
            ((pPropSpec[i].ulKind == PRSPEC_LPWSTR) && 
             (wcscmp(pPropSpec[i].lpwstr, WIA_IPC_THUMBNAIL_STR) == 0)))
        {
            //
            // They'd like the thumbnail
            //

            hr = pDrvItem->GetDeviceSpecContext((BYTE **)&pContext);
            CHECK_S_OK2(hr,("pDrvItem->GetDeviceSpecContext()"));

            if (SUCCEEDED(hr) && pContext)
            {
                if (pContext->pImage)
                {
                    //
                    // Use our internal routines to load the thumbnail...
                    //

                    hr = pContext->pImage->LoadThumbnail(pWiasContext);
                    break;
                }
                else
                {
                    DBG_ERR(("pContext->pImage was NULL!"));
                }
            }
            else
            {
                DBG_ERR(("Couldn't get pContext"));
            }
        }
    }

    return hr;
}

/*****************************************************************************

   CVideoStiUsd::ReadDeviceProperties

   We support all our custom properties

 *****************************************************************************/

HRESULT
CVideoStiUsd::ReadDeviceProperties(BYTE             *pWiasContext,
                                   LONG             lFlags,
                                   ULONG            nPropSpec,
                                   const PROPSPEC   *pPropSpec,
                                   LONG             *plDevErrVal,
                                   IWiaDrvItem      *pDrvItem)
{
    HRESULT hr = S_OK;

    if ((pPropSpec == NULL) ||
        (pDrvItem  == NULL))
    {
        hr = E_INVALIDARG;
        CHECK_S_OK2(hr, ("CVideoStiUsd::ReadItemProperties received a "
                         "NULL param"));
        return hr;
    }

    for (ULONG i = 0; i < nPropSpec; i++)
    {
        if (((pPropSpec[i].ulKind == PRSPEC_PROPID) && 
             (pPropSpec[i].propid == WIA_DPC_PICTURES_TAKEN)) ||
            ((pPropSpec[i].ulKind == PRSPEC_LPWSTR) && 
             (!wcscmp(pPropSpec[i].lpwstr, WIA_DPC_PICTURES_TAKEN_STR))))
        {
            //
            // Requesting the number of pictures taken.
            //

            DBG_TRC(("CVideoStiUsd::ReadDeviceProperties, reading propID "
                     "'%lu' (0x%08lx) WIA_DPC_PICTURES_TAKEN = '%lu'", 
                     pPropSpec[i].propid, 
                     pPropSpec[i].propid, 
                     m_lPicsTaken));

            wiasWritePropLong(pWiasContext, 
                              WIA_DPC_PICTURES_TAKEN, 
                              m_lPicsTaken);

        }
        else if (((pPropSpec[i].ulKind == PRSPEC_PROPID) && 
                  (pPropSpec[i].propid == WIA_DPV_DSHOW_DEVICE_PATH)) ||
                 ((pPropSpec[i].ulKind == PRSPEC_LPWSTR) && 
                  (!wcscmp(pPropSpec[i].lpwstr, WIA_DPV_DSHOW_DEVICE_PATH_STR))))
        {
            //
            // Requesting the DShow Device ID.
            //

            DBG_TRC(("CVideoStiUsd::ReadDeviceProperties, reading propID "
                     "'%lu' (0x%08lx) WIA_DPV_DSHOW_DEVICE_PATH = '%ls'", 
                     pPropSpec[i].propid, 
                     pPropSpec[i].propid, 
                     m_strDShowDeviceId.String()));
            
            wiasWritePropStr(pWiasContext, 
                             WIA_DPV_DSHOW_DEVICE_PATH, 
                             CSimpleBStr(m_strDShowDeviceId).BString());

        }
        else if (((pPropSpec[i].ulKind == PRSPEC_PROPID) && 
                  (pPropSpec[i].propid == WIA_DPV_IMAGES_DIRECTORY)) ||
                 ((pPropSpec[i].ulKind == PRSPEC_LPWSTR) && 
                  (!wcscmp(pPropSpec[i].lpwstr, WIA_DPV_IMAGES_DIRECTORY_STR))))
        {
            //
            // Requesting the Images Directory.
            //

            DBG_TRC(("CVideoStiUsd::ReadDeviceProperties, reading propID "
                     "'%lu' (0x%08lx) WIA_DPV_IMAGES_DIRECTORY = '%ls'", 
                     pPropSpec[i].propid, 
                     pPropSpec[i].propid, 
                     m_strStillPath.String()));

            wiasWritePropStr(pWiasContext, 
                             WIA_DPV_IMAGES_DIRECTORY, 
                             CSimpleBStr(m_strStillPath).BString());
        }
        else if (((pPropSpec[i].ulKind == PRSPEC_PROPID) && 
                  (pPropSpec[i].propid == WIA_DPV_LAST_PICTURE_TAKEN)) ||
                 ((pPropSpec[i].ulKind == PRSPEC_LPWSTR) && 
                  (!wcscmp(pPropSpec[i].lpwstr, WIA_DPV_LAST_PICTURE_TAKEN_STR))))
        {
            //
            // Requesting the last picture taken
            //

            DBG_TRC(("CVideoStiUsd::ReadDeviceProperties, reading propID "
                     "'%lu' (0x%08lx) WIA_DPV_LAST_PICTURE_TAKEN = '%ls'", 
                     pPropSpec[i].propid, 
                     pPropSpec[i].propid, 
                     m_strLastPictureTaken.String()));

            wiasWritePropStr(pWiasContext, 
                             WIA_DPV_LAST_PICTURE_TAKEN, 
                             CSimpleBStr(m_strLastPictureTaken).BString());
        }
    }

    return hr;
}


/*****************************************************************************

   CVideoStiUsd::drvReadItemProperties [IWiaMiniDrv]

   We only support reading thumbnails on demand.

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::drvReadItemProperties(BYTE            *pWiasContext,
                                    LONG            lFlags,
                                    ULONG           nPropSpec,
                                    const PROPSPEC  *pPropSpec,
                                    LONG            *plDevErrVal)
{
    HRESULT     hr          = S_OK;
    LONG        lItemType   = 0;
    IWiaDrvItem *pDrvItem   = NULL;

    DBG_FN("CVideoStiUsd::drvReadItemProperties");

    //
    // Check for bad args
    //

    if ((nPropSpec    == 0)    ||
        (pPropSpec    == NULL) ||
        (pWiasContext == NULL))
    {
        hr = E_INVALIDARG;
        CHECK_S_OK2(hr, ("CVideoStiUsd::drvReadItemProperties received "
                         "NULL params"));

        return hr;
    }

    if (hr == S_OK)
    {
        //
        // Make sure we're dealing with an item, not the root item.
        //

        //
        // Get minidriver item
        //

        hr = wiasGetDrvItem(pWiasContext, &pDrvItem);

        if ((hr == S_OK) && (pDrvItem == NULL))
        {
            hr = E_FAIL;
        }

        CHECK_S_OK2(hr,("CVideoStiUsd::drvReadItemProperties, wiasGetDrvItem "
                        "failed"));
    }


    if (hr == S_OK)
    {
        hr = pDrvItem->GetItemFlags(&lItemType);
        CHECK_S_OK2(hr,("pDrvItem->GetItemFlags()"));
    }

    if (hr == S_OK)
    {
        if ((lItemType & WiaItemTypeFile) && (!(lItemType & WiaItemTypeRoot)))
        {
            //
            // If property being requested is a file and it is NOT the root, 
            // then read in the item property.
            //

            hr = ReadItemProperties(pWiasContext,
                                    lFlags,
                                    nPropSpec,
                                    pPropSpec,
                                    plDevErrVal,
                                    pDrvItem);
        }
        else if ((lItemType & WiaItemTypeFolder) && 
                 (lItemType & WiaItemTypeRoot))
        {
            // 
            // If the property being requested is the root, then read in 
            // the device properties.
            //

            hr = ReadDeviceProperties(pWiasContext,
                                      lFlags,
                                      nPropSpec,
                                      pPropSpec,
                                      plDevErrVal,
                                      pDrvItem);
        }
    }

    if (plDevErrVal)
    {
        *plDevErrVal = 0;
    }

    CHECK_S_OK(hr);
    return hr;
}


/*****************************************************************************

   CVideoStiUsd::drvLockWiaDevice [IWiaMiniDrv]

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::drvLockWiaDevice(BYTE *pWiasContext,
                               LONG lFlags,
                               LONG *plDevErrVal)
{
    HRESULT hr = S_OK;

    DBG_FN("CVideoStiUsd::drvLockWiaDevice");

    if (plDevErrVal)
    {
        *plDevErrVal = 0;
    }

    //
    // We are purposely not locking the driver.  This driver is thread 
    // safe and it looks like with large volumes of images (>1000) 
    // you get better performance if the driver manages synchronization.
    //
    // return m_pStiDevice->LockDevice(DEFAULT_LOCK_TIMEOUT);

    return hr;
}


/*****************************************************************************

   CVideoStiUsd::drvUnLockWiaDevice [IWiaMiniDrv]

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::drvUnLockWiaDevice(BYTE *pWiasContext,
                                 LONG lFlags,
                                 LONG *plDevErrVal)
{
    HRESULT hr = S_OK;

    DBG_FN("CVideoStiUsd::drvUnLockWiaDevice");

    if (plDevErrVal)
    {
        *plDevErrVal = 0;
    }

    //
    // We are purposely not locking the driver.  This driver is thread 
    // safe and it looks like with large volumes of images (>1000) 
    // you get better performance if the driver manages synchronization.
    //
    // return m_pStiDevice->UnLockDevice();

    return hr;
}


/*****************************************************************************

   CVideoStiUsd::drvAnalyzeItem [IWiaMiniDrv]

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::drvAnalyzeItem(BYTE *pWiasContext,
                             LONG lFlags,
                             LONG *plDevErrVal)
{
    HRESULT hr = E_NOTIMPL;

    DBG_FN("CVideoStiUsd::drvAnalyzeItem");

    if (plDevErrVal)
    {
        *plDevErrVal = 0;
    }

    CHECK_S_OK(hr);
    return hr;
}


/*****************************************************************************

   CVideoStiUsd::drvDeleteItem [IWiaMiniDrv]

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::drvDeleteItem(BYTE *pWiasContext,
                            LONG lFlags,
                            LONG *plDevErrVal)
{
    HRESULT hr = E_FAIL;

    DBG_FN("CVideoStiUsd::drvDeleteItem");

    //
    // check for bad params
    //

    if (pWiasContext == NULL)
    {
        DBG_ERR(("pWiasContext is NULL!"));
        return E_INVALIDARG;
    }

    if (plDevErrVal)
    {
        *plDevErrVal = 0;
    }

    EnterCriticalSection(&m_csItemTree);

    //
    // Get a pointer to the associated driver item.
    //

    IWiaDrvItem * pDrvItem = NULL;

    hr = wiasGetDrvItem(pWiasContext, &pDrvItem);
    CHECK_S_OK2(hr,("wiasGetDrvItem"));

    if (SUCCEEDED(hr) && pDrvItem)
    {
        //
        // get item specific driver data
        //

        STILLCAM_IMAGE_CONTEXT  *pContext = NULL;

        pDrvItem->GetDeviceSpecContext((BYTE **)&pContext);

        CHECK_S_OK2(hr,("pDrvItem->GetDeviceSpecContext"));

        if (SUCCEEDED(hr) && pContext && pContext->pImage)
        {

            //
            // Delete the file in question
            //

            hr = pContext->pImage->DoDelete();
            CHECK_S_OK2(hr,("pContext->pImage->DoDelete()"));

            //
            // Dec the number of pictures taken
            //

            InterlockedDecrement(&m_lPicsTaken);

            //
            // write out the new amount
            //

            wiasWritePropLong(pWiasContext, 
                              WIA_DPC_PICTURES_TAKEN, 
                              m_lPicsTaken);


            if (SUCCEEDED(hr))
            {
                HRESULT hr2;

                BSTR bstrItemName = NULL;

                //
                // Get bstr of full item name
                //

                hr2 = pDrvItem->GetFullItemName(&bstrItemName);
                CHECK_S_OK2(hr2,("pDrvItem->GetFullItemName()"));

                //
                // Send event that item was deleted
                //

                hr2 = wiasQueueEvent(CSimpleBStr(m_strDeviceId), 
                                     &WIA_EVENT_ITEM_DELETED, 
                                     bstrItemName);

                CHECK_S_OK2(hr2, 
                            ("wiasQueueEvent( WIA_EVENT_ITEM_DELETED )"));

                //
                // Cleanup
                //

                if (bstrItemName)
                {
                    SysFreeString(bstrItemName);
                    bstrItemName = NULL;
                }
            }
        }
        else
        {
            DBG_ERR(("pContext or pContext->pImage are NULL!"));
            hr = E_FAIL;
        }
    }

    LeaveCriticalSection( &m_csItemTree );

    CHECK_S_OK(hr);
    return hr;
}



/*****************************************************************************

   CVideoStiUsd::drvFreeDrvItem [IWiaMiniDrv]

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::drvFreeDrvItemContext(LONG lFlags,
                                    BYTE *pDevContext,
                                    LONG *plDevErrVal)
{
    HRESULT hr = S_OK;

    DBG_FN("CVideoStiUsd::drvFreeDrvItemContext");

    PSTILLCAM_IMAGE_CONTEXT pContext = (PSTILLCAM_IMAGE_CONTEXT)pDevContext;

    if (pContext != NULL) 
    {
        //
        // delete is safe even if param is NULL.
        //
        delete pContext->pImage;
        pContext->pImage = NULL;
    }

    if (plDevErrVal)
    {
        *plDevErrVal = 0;
    }

    CHECK_S_OK(hr);
    return hr;
}


/*****************************************************************************

   CMiniDev::drvGetCapabilities [IWiaMiniDrv]

   Let WIA know what things this driver can do.

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::drvGetCapabilities(BYTE            *pWiasContext,
                                 LONG            lFlags,
                                 LONG            *pCelt,
                                 WIA_DEV_CAP_DRV **ppCapabilities,
                                 LONG            *plDevErrVal)
{
    HRESULT hr = S_OK;

    DBG_FN("CVideoStiUsd::drvGetCapabilities");

    if (plDevErrVal)
    {
        *plDevErrVal = 0;
    }

    //
    // Return Commmand and/or Events depending on flags
    //

    switch (lFlags)
    {
        case WIA_DEVICE_COMMANDS:

            //
            //  Only commands
            //
            *pCelt = NUM_CAP_ENTRIES - NUM_EVENTS;
            *ppCapabilities = &gCapabilities[NUM_EVENTS];                
        break;

        case WIA_DEVICE_EVENTS:

            //
            //  Only events
            //

            *pCelt = NUM_EVENTS;
            *ppCapabilities = gCapabilities;
        break;

        case (WIA_DEVICE_COMMANDS | WIA_DEVICE_EVENTS):

            //
            //  Both events and commands
            //

            *pCelt = NUM_CAP_ENTRIES;
            *ppCapabilities = gCapabilities;
        break;

        default:

            //
            // Flags is invalid
            //

            DBG_ERR(("drvGetCapabilities, flags was invalid"));
            hr =  E_INVALIDARG;
        break;
    }

    CHECK_S_OK(hr);
    return hr;
}


/*****************************************************************************

   CVideoStiUsd::drvGetWiaFormatInfo [IWiaMiniDrv]

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::drvGetWiaFormatInfo(BYTE            *pWiasContext,
                                  LONG            lFlags,
                                  LONG            *pCelt,
                                  WIA_FORMAT_INFO **ppwfi,
                                  LONG            *plDevErrVal)
{
    HRESULT hr = S_OK;

    DBG_FN("CVideoStiUsd::drvGetWiaFormatInfo");

    if (plDevErrVal)
    {
        *plDevErrVal = 0;
    }

    //
    //  If it hasn't been done already, set up the g_wfiTable table
    //

    if (!m_wfi)
    {
        DBG_ERR(("drvGetWiaFormatInfo, m_wfi is NULL!"));
        return E_OUTOFMEMORY;
    }

    if (pCelt)
    {
        *pCelt = NUM_WIA_FORMAT_INFO;
    }

    if (ppwfi)
    {
        *ppwfi = m_wfi;
    }

    CHECK_S_OK(hr);
    return hr;
}

/*****************************************************************************

   CVideoStiUsd::drvNotifyPnpEvent [IWiaMiniDrv]

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::drvNotifyPnpEvent(const GUID *pEventGUID,
                                BSTR       bstrDeviceID,
                                ULONG      ulReserved)
{
    HRESULT hr = S_OK;

    DBG_FN("CVideoStiUsd::drvNotifyPnpEvent");

    //
    // CONNECTED event is of no interest, because a new USD is always created
    //

    if (*pEventGUID == WIA_EVENT_DEVICE_DISCONNECTED)
    {
        DBG_TRC(("got a WIA_EVENT_DISCONNECTED"));
    }

    CHECK_S_OK(hr);
    return hr;
}

/*****************************************************************************

   CVideoStiUsd::VerifyCorrectImagePath

   <Notes>

 *****************************************************************************/

HRESULT
CVideoStiUsd::VerifyCorrectImagePath(BSTR bstrNewImageFullPath)
{
    DBG_FN("CVideoStiUsd::VerifyCorrectImagePath");

    HRESULT        hr       = S_OK;
    INT            iIndex   = 0;
    CSimpleString  strImageFullPath;

    if (bstrNewImageFullPath == NULL)
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CVideoStiUsd::VerifyCorrectImagePath received a NULL pointer"));
        return hr;
    }

    if (hr == S_OK)
    {
        strImageFullPath = CSimpleStringConvert::NaturalString(
                                       CSimpleStringWide(bstrNewImageFullPath));

        //
        // Get the filename out of the full path.  Find the last backslash.
        //
        iIndex = strImageFullPath.ReverseFind('\\');
        strImageFullPath[iIndex] = 0;

        if (strImageFullPath != m_strStillPath)
        {
            hr = E_ACCESSDENIED;
            CHECK_S_OK2(hr, ("CVideoStiUsd::VerifyCorrectImagePath, the file that is "
                             "being added to the tree '%ls' is not in the allowed directory, "
                             "denying request with an E_ACCESSDENIED",
                              CSimpleStringWide(strImageFullPath).String()));
        }
    }

    return hr;
}

/*****************************************************************************

   CVideoStiUsd::SignalNewImage

   <Notes>

 *****************************************************************************/

HRESULT
CVideoStiUsd::SignalNewImage(BSTR bstrNewImageFullPath)
{
    DBG_FN("CVideoStiUsd::SignalNewImage");

    HRESULT              hr               = S_OK;
    CComPtr<IWiaDrvItem> pDrvItem         = NULL;
    BSTR                 bstrFullItemName = NULL;
    CSimpleString        strImageFullPath;

    if (hr == S_OK)
    {
        hr = VerifyCorrectImagePath(bstrNewImageFullPath);
    }

    if (hr == S_OK)
    {
        strImageFullPath = CSimpleStringConvert::NaturalString(
                                       CSimpleStringWide(bstrNewImageFullPath));
    
        DBG_TRC(("CVideoStiUsd::SignalNewImage, adding image '%ls' to "
                 "tree of device '%ls'",
                 CSimpleStringWide(strImageFullPath).String(),
                 m_strDeviceId.String()));
    
        // Add the new item to the tree if doesn't already exist
        //
    
        // Get the filename out of the full path.  Find the last backslash and
        // move 1 beyond it.
        //
        INT iIndex = strImageFullPath.ReverseFind('\\') + 1;
    
        if (!IsFileAlreadyInTree(m_pRootItem, &(strImageFullPath[iIndex])))
        {
            hr = AddTreeItem(&strImageFullPath, &pDrvItem);
    
            CHECK_S_OK2(hr, ("CVideoStiUsd::SignalNewImage, failed to add "
                             "image '%ls' to tree of device '%ls'",
                             CSimpleStringWide(strImageFullPath).String(),
                             m_strDeviceId.String()));
        
            if (hr == S_OK)
            {
                //
                // Get the full item name for this item
                //
        
                m_pLastItemCreated = pDrvItem;
                hr = pDrvItem->GetFullItemName(&bstrFullItemName);
                CHECK_S_OK2(hr,("CVideoStiUsd::SignalNewImage, failed to get Item "
                                "name for newly added item"));
            }
        
            if (hr == S_OK)
            {
                //
                // Queue an event that a new item was created.
                //
        
                hr = wiasQueueEvent(CSimpleBStr(m_strDeviceId), 
                                    &WIA_EVENT_ITEM_CREATED, 
                                    bstrFullItemName);
        
                CHECK_S_OK2(hr,("CVideoStiUsd::SignalNewImage, failed to "
                                "queue a new WIA_EVENT_ITEM_CREATED event"));
            }
    
            if (bstrFullItemName)
            {
                SysFreeString(bstrFullItemName);
                bstrFullItemName = NULL;
            }
        }
        else
        {
            DBG_TRC(("CVideoStiUsd::SignalNewImage, item '%ls' is already in the "
                     "tree.  Probably tree was recently refreshed",
                     bstrNewImageFullPath));
        }
    }

    return hr;
}


/*****************************************************************************

   CVideoStiUsd::SetImagesDirectory

   <Notes>

 *****************************************************************************/

HRESULT
CVideoStiUsd::SetImagesDirectory(BSTR        bstrNewImagesDirectory,
                                 BYTE        *pWiasContext,
                                 IWiaDrvItem **ppIDrvItemRoot,
                                 LONG        *plDevErrVal)
{
    DBG_FN("CVideoStiUsd::SetImagesDirectory");

    HRESULT         hr = S_OK;
    CSimpleString   strOriginalDirectory;

    //
    // If we received a NULL Images directory, then build up our own 
    // generated one, then build the item tree.
    //

    strOriginalDirectory = m_strStillPath;

    if (bstrNewImagesDirectory == NULL)
    {
        //
        // If this path is not in the registry, we default to constructing
        // a path of this type:
        //
        // %TEMP%\WIA\%DeviceID%

        TCHAR szTempPath[MAX_PATH + 1] = {0};

        hr = SHGetFolderPath(NULL, CSIDL_COMMON_APPDATA, NULL, SHGFP_TYPE_DEFAULT, szTempPath);

        //
        // We allow for the case of S_FALSE which indicates that the folder doesn't
        // exist.  This is fine since we recursively create it below.
        //
        if ((hr == S_OK) || (hr == S_FALSE))
        {
            if (szTempPath[_tcslen(szTempPath) - 1] != '\\')
            {
                _tcscat(szTempPath, TEXT("\\"));
            }

            //
            // Set path to "Documents and Settings\Application Data\Microsoft\Wia\{deviceid}"
            //
            m_strStillPath.Assign(szTempPath);
            m_strStillPath += TEXT("Microsoft\\WIA\\");
            m_strStillPath += m_strDeviceId;
        }
    }
    else
    {
        // we received a valid BSTR, attempt to create the directory.

        m_strStillPath = bstrNewImagesDirectory;
    }

    if (!RecursiveCreateDirectory(&m_strStillPath))
    {
        hr = E_FAIL;

        CHECK_S_OK2(hr, ("RecursiveCreateDirectory( %ws ) failed w/GLE=%d",
                         m_strStillPath.String(), 
                         ::GetLastError() ));
    }

    //
    // Set the security DACL on the directory so that users and power users
    // will be able to write and delete from it too.
    //
    if (hr == S_OK)
    {
        //
        // We only set this directory security if we are using our default directory
        // path.  This isn't an issue now since the user cannot update the directory,
        // but in the future if we allow them to, this could expose a security whole.
        //
        if (bstrNewImagesDirectory == NULL)
        {
            hr = SetDirectorySecurity(&m_strStillPath);
        }

    }

    if (hr == S_OK)
    {
        if (m_strStillPath.Length())
        {
            BOOL bSendUpdateEvent = FALSE;

            //
            // If the original directory is different from the new directory 
            // and we already have a tree, then we should destroy our 
            // existing tree, and recreate it for the new directory.
            //
            if ((strOriginalDirectory.CompareNoCase(m_strStillPath) != 0) &&
                (m_pRootItem != NULL))
            {
                EnterCriticalSection( &m_csItemTree );

                hr = m_pRootItem->UnlinkItemTree(WiaItemTypeDisconnected);
                CHECK_S_OK2(hr,("m_pRootItem->UnlinkItemTree()"));

                if (SUCCEEDED(hr))
                {
                    bSendUpdateEvent = TRUE;
                    m_pRootItem = NULL;
                }

                LeaveCriticalSection( &m_csItemTree );
            }

            //
            // Build the item tree.
            //

            hr = BuildItemTree(ppIDrvItemRoot, plDevErrVal);

            //
            // write out the new amount of pictures taken
            //
    
            wiasWritePropLong(pWiasContext, 
                              WIA_DPC_PICTURES_TAKEN, 
                              m_lPicsTaken);

            if (bSendUpdateEvent)
            {
                wiasQueueEvent(CSimpleBStr(m_strDeviceId), 
                               &WIA_EVENT_TREE_UPDATED, 
                               NULL);
            }
        }
        else
        {
            hr = E_FAIL;
            CHECK_S_OK2(hr, 
                        ("CVideoStiUsd::SetImagesDirectory, new directory "
                         "path has a length of 0, Directory = '%ls'", 
                         m_strStillPath.String()));
        }
    }

    return hr;
}


/*****************************************************************************

   CVideoStiUsd::TakePicture

   <Notes>

 *****************************************************************************/

HRESULT
CVideoStiUsd::TakePicture(BYTE        *pTakePictureOwner,
                          IWiaDrvItem **ppNewDrvItem)
{
    HRESULT hr = S_OK;

    //
    // Notice that we are allowing multiple applications to call the 
    // take picture command, even if they weren't the owns that enabled
    // it.  
    //

    DBG_TRC(("CVideoStiUsd::drvDeviceCommand received command "
             "WIA_CMD_TAKE_PICTURE"));

    if ((m_hTakePictureEvent) && (m_hPictureReadyEvent))
    {
        DWORD dwResult = 0;

        m_pLastItemCreated = NULL;

        //
        // Tell the WiaVideo object that pertains to this device ID to 
        // take a picture.
        //
        SetEvent(m_hTakePictureEvent);

        // The WiaVideo object has a thread waiting on the 
        // m_hTakePictureEvent. When it is signalled, the WiaVideo object
        // takes the picture, then sets the driver's custom 
        // "LastPictureTaken" property.  This causes the driver to update 
        // its tree and queue an ITEM_CREATED event.  Once this is complete,
        // the WiaVideo object sets the PictureReady Event, at which point 
        // we return from this function call.

//        dwResult = WaitForSingleObject(m_hPictureReadyEvent, 
//                                       TAKE_PICTURE_TIMEOUT);

        if (dwResult == WAIT_OBJECT_0)
        {
//            *ppNewDrvItem = m_pLastItemCreated;
        }
        else
        {
            if (dwResult == WAIT_TIMEOUT)
            {
                hr = E_FAIL;
                CHECK_S_OK2(hr, ("CVideoStiUsd::TakePicture timed out "
                                 "after waiting for '%lu' seconds for the "
                                 "WiaVideo object to take a picture",
                                 TAKE_PICTURE_TIMEOUT));
            }
            else if (dwResult == WAIT_ABANDONED)
            {
                hr = E_FAIL;
                CHECK_S_OK2(hr, ("CVideoStiUsd::TakePicture failed, received "
                                 "a WAIT_ABANDONED from the Wait function"));
            }
            else
            {
                hr = E_FAIL;
                CHECK_S_OK2(hr, ("CVideoStiUsd::TakePicture failed to take a "
                                 "picture."));
            }
        }
    }
    else
    {
        DBG_TRC(("CVideoStiUsd::drvDeviceCommand, ignoring "
                 "WIA_CMD_TAKE_PICTURE request, events created "
                 "by WiaVideo are not open"));
    }

    return hr;
}

/*****************************************************************************

   CVideoStiUsd::EnableTakePicture

   <Notes>

 *****************************************************************************/

HRESULT
CVideoStiUsd::EnableTakePicture(BYTE *pTakePictureOwner)
{
    DBG_FN("CVideoStiUsd::EnableTakePicture");

    HRESULT             hr = S_OK;
    CSimpleString       strTakePictureEvent;
    CSimpleString       strPictureReadyEvent;
    CSimpleString       strDeviceID;
    SECURITY_ATTRIBUTES SA;

    SA.nLength        = sizeof(SECURITY_ATTRIBUTES);
    SA.bInheritHandle = TRUE;

    //
    // Convert to security descriptor
    //
    ConvertStringSecurityDescriptorToSecurityDescriptor(OBJECT_DACLS,
                                                        SDDL_REVISION_1, 
                                                        &(SA.lpSecurityDescriptor), 
                                                        NULL);

    
    strDeviceID = CSimpleStringConvert::NaturalString(m_strDeviceId);

    m_pTakePictureOwner = pTakePictureOwner;

    if (hr == S_OK)
    {
        INT             iPosition = 0;
        CSimpleString   strModifiedDeviceID;

        // Change the device ID from {6B...}\xxxx, to {6B...}_xxxx

        iPosition = strDeviceID.ReverseFind('\\');
        strModifiedDeviceID = strDeviceID.MakeUpper();
        strModifiedDeviceID.SetAt(iPosition, '_');

        //
        // Generate the event names.  These names contain the Device ID in 
        // them so that they are unique across devices.
        //
        strTakePictureEvent  = EVENT_PREFIX_GLOBAL;
        strTakePictureEvent += strModifiedDeviceID;
        strTakePictureEvent += EVENT_SUFFIX_TAKE_PICTURE;

        strPictureReadyEvent  = EVENT_PREFIX_GLOBAL;
        strPictureReadyEvent += strModifiedDeviceID;
        strPictureReadyEvent += EVENT_SUFFIX_PICTURE_READY;
    }

    if (hr == S_OK)
    {
        m_hTakePictureEvent = CreateEvent(&SA,
                                          FALSE,
                                          FALSE, 
                                          strTakePictureEvent);
        //
        // This is not really an error since the events will not have been created until
        // the WiaVideo object comes up.
        //
        if (m_hTakePictureEvent == NULL)
        {
            hr = E_FAIL;
            DBG_TRC(("CVideoStiUsd::EnableTakePicture, failed to open the "
                     "WIA event '%ls', this is not fatal (LastError = '%lu' "
                     "(0x%08lx))", 
                     strTakePictureEvent.String(),
                     ::GetLastError(), 
                     ::GetLastError()));
        }
    }

    if (hr == S_OK)
    {
        m_hPictureReadyEvent = CreateEvent(&SA,
                                           FALSE,
                                           FALSE, 
                                           strPictureReadyEvent);

        //
        // This is not really an error since the events will not have been created until
        // the WiaVideo object comes up.
        //
        if (m_hPictureReadyEvent == NULL)
        {
            hr = E_FAIL;

            DBG_TRC(("CVideoStiUsd::EnableTakePicture, failed to open the WIA "
                     "event '%ls', this is not fatal (LastError = '%lu' "
                     "(0x%08lx))", 
                     strPictureReadyEvent.String(),
                     ::GetLastError(), 
                     ::GetLastError()));
        }
    }

    if (SA.lpSecurityDescriptor)
    {
        LocalFree(SA.lpSecurityDescriptor);
    }

    return hr;
}

/*****************************************************************************

   CVideoStiUsd::DisableTakePicture

   <Notes>

 *****************************************************************************/

HRESULT
CVideoStiUsd::DisableTakePicture(BYTE *pTakePictureOwner,
                                 BOOL bShuttingDown)
{
    HRESULT hr = S_OK;

    if (m_hTakePictureEvent)
    {
        ::CloseHandle(m_hTakePictureEvent);
        m_hTakePictureEvent = NULL;
    }

    if (m_hPictureReadyEvent)
    {
        ::CloseHandle(m_hPictureReadyEvent);
        m_hPictureReadyEvent = NULL;
    }

    m_pTakePictureOwner = NULL;

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\video\usd\transfer.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999-2000
 *
 *  TITLE:       Transfer.cpp
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      RickTu
 *
 *  DATE:        9/10/99        RickTu
 *               2000/11/09     OrenR
 *
 *  DESCRIPTION: This was originally in camera.cpp but was broken out for
 *               clarity.  The functions in this file are responsible for
 *               transfering the image to the requesting application.
 *
 *****************************************************************************/
#include <precomp.h>
#pragma hdrstop
#include <gphelper.h>

using namespace Gdiplus;

/*****************************************************************************

   CVideoStiUsd::DoBandedTransfer

   hand back the given bits in the specified chunk sizes

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::DoBandedTransfer(MINIDRV_TRANSFER_CONTEXT *pTransCtx,
                               PBYTE                    pSrc,
                               LONG                     lBytesToTransfer)
{
    HRESULT hr = E_FAIL;

    DBG_FN("CVideoStiUsd::DoBandedTransfer");

    //
    // Check for bad args
    //

    if ((pTransCtx        == NULL) ||
        (pSrc             == NULL) ||
        (lBytesToTransfer == 0))
    {
        hr = E_INVALIDARG;
        CHECK_S_OK2(hr, ("CVideoStiUsd::DoBandedTransfer, received "
                         "NULL param"));
        return hr;
    }

    //
    // callback loop
    //

    LONG  lTransferSize     = 0;
    LONG  lPercentComplete  = 0;

    do
    {

        PBYTE pDst = pTransCtx->pTransferBuffer;

        //
        // transfer up to entire buffer size
        //

        lTransferSize = lBytesToTransfer;

        if (lBytesToTransfer > pTransCtx->lBufferSize)
        {
            lTransferSize = pTransCtx->lBufferSize;
        }

        //
        // copy data
        //

        DBG_TRC(("memcpy(src=0x%x,dst=0x%x,size=0x%x)",
                 pDst,
                 pSrc,
                 lTransferSize));

        memcpy(pDst, pSrc, lTransferSize);

        lPercentComplete = 100 * (pTransCtx->cbOffset + lTransferSize);
        lPercentComplete /= pTransCtx->lItemSize;

        //
        // make callback
        //

        hr = pTransCtx->pIWiaMiniDrvCallBack->MiniDrvCallback(
                                                 IT_MSG_DATA,
                                                 IT_STATUS_TRANSFER_TO_CLIENT,
                                                 lPercentComplete,
                                                 pTransCtx->cbOffset,
                                                 lTransferSize,
                                                 pTransCtx,
                                                 0);

        CHECK_S_OK2(hr,("pTransCtx->pWiaMiniDrvCallback->MiniDrvCallback"));

        DBG_TRC(("%d percent complete",lPercentComplete));

        //
        // inc pointers (redundant pointers here)
        //

        pSrc                += lTransferSize;
        pTransCtx->cbOffset += lTransferSize;
        lBytesToTransfer    -= lTransferSize;

        if (hr != S_OK)
        {
            break;
        }

    } while (lBytesToTransfer > 0);


    CHECK_S_OK(hr);
    return hr;
}



/*****************************************************************************

   CVideoStiUsd::DoTransfer

   Transfers the given bits all at once

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::DoTransfer(MINIDRV_TRANSFER_CONTEXT *pTransCtx,
                         PBYTE                    pSrc,
                         LONG                     lBytesToTransfer)
{

    HRESULT hr = E_FAIL;

    DBG_FN("CVideoStiUsd::DoTransfer");

    //
    // Check for bad args
    //

    if ((pTransCtx        == NULL) ||
        (pSrc             == NULL) ||
        (lBytesToTransfer == 0))
    {
        hr = E_INVALIDARG;
        CHECK_S_OK2(hr, ("CVideoStiUsd::DoTransfer, received "
                         "NULL param"));
        return hr;
    }

    if (lBytesToTransfer > (LONG)(pTransCtx->lBufferSize - pTransCtx->cbOffset))
    {
        DBG_TRC(("lBytesToTransfer = %d, (lBufferSize = %d) - "
                 "(cbOffset = %d) is %d",
                 lBytesToTransfer,
                 pTransCtx->lBufferSize,
                 pTransCtx->cbOffset,
                 (pTransCtx->lBufferSize - pTransCtx->cbOffset)));

        DBG_ERR(("lBytesToTransfer is bigger than supplied buffer!"));

        hr = HRESULT_FROM_WIN32(ERROR_BUFFER_OVERFLOW);
    }
    else
    {

        //
        // Show 20% completion
        //

        if (pTransCtx->pIWiaMiniDrvCallBack)
        {
            pTransCtx->pIWiaMiniDrvCallBack->MiniDrvCallback(
                                           IT_MSG_STATUS,
                                           IT_STATUS_TRANSFER_FROM_DEVICE,
                                           (LONG)20,  // Percentage Complete,
                                           0,
                                           0,
                                           pTransCtx,
                                           0);
        }


        PBYTE pDst = pTransCtx->pTransferBuffer;
        pDst += pTransCtx->cbOffset;

        //
        // copy the bits
        //

        memcpy(pDst, pSrc, lBytesToTransfer);

        hr = S_OK;

        // Since we are copying all the bits in one shot, any status
        // callback is just a simulation anyway.  So lets give enough
        // increments to bring the progress dialog up to 100 %.

        if (pTransCtx->pIWiaMiniDrvCallBack)
        {

            // Show 60% completion
            pTransCtx->pIWiaMiniDrvCallBack->MiniDrvCallback(
                                           IT_MSG_STATUS,
                                           IT_STATUS_TRANSFER_FROM_DEVICE,
                                           (LONG)60,  // Percentage Complete,
                                           0,
                                           0,
                                           pTransCtx,
                                           0);

            // Show 90% completion
            pTransCtx->pIWiaMiniDrvCallBack->MiniDrvCallback(
                                           IT_MSG_STATUS,
                                           IT_STATUS_TRANSFER_FROM_DEVICE,
                                           (LONG)90,  // Percentage Complete,
                                           0,
                                           0,
                                           pTransCtx,
                                           0);

            // Show 99% completion
            pTransCtx->pIWiaMiniDrvCallBack->MiniDrvCallback(
                                           IT_MSG_STATUS,
                                           IT_STATUS_TRANSFER_FROM_DEVICE,
                                           (LONG)99,  // Percentage Complete,
                                           0,
                                           0,
                                           pTransCtx,
                                           0);


            // Show 100% completion
            pTransCtx->pIWiaMiniDrvCallBack->MiniDrvCallback(
                                           IT_MSG_STATUS,
                                           IT_STATUS_TRANSFER_FROM_DEVICE,
                                           (LONG)100,  // Percentage Complete,
                                           0,
                                           0,
                                           pTransCtx,
                                           0);
        }
    }

    CHECK_S_OK(hr);
    return hr;
}



/*****************************************************************************

   CVideoUsd::StreamJPEGBits

   Transfers the JPEG bits of a file

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::StreamJPEGBits(STILLCAM_IMAGE_CONTEXT   *pContext,
                             MINIDRV_TRANSFER_CONTEXT *pTransCtx,
                             BOOL                     bBanded)
{
    HRESULT hr   = E_FAIL;
    PBYTE   pSrc = NULL;

    DBG_FN("CVideoStiUsd::StreamJPEGBits");

    //
    // Check for invalid args
    //

    if ((pContext         == NULL) ||
        (pContext->pImage == NULL) ||
        (pTransCtx        == NULL))
    {
        hr = E_INVALIDARG;
        CHECK_S_OK2(hr, ("CVideoStiUsd::StreamJPEGBits received NULL "
                         "params"));
        return hr;
    }

    //
    // try to open mapping to disk file -- we will use this if it is a JPEG
    // file because we just want to stream the bits back.
    //

    CMappedView cmvImage(pContext->pImage->ActualImagePath(), 
                         0, 
                         OPEN_EXISTING);

    pSrc = cmvImage.Bits();

    if (pSrc)
    {
        //
        // We only handle 2GB of data (that's all WIA handles as well)
        //

        LARGE_INTEGER liSize = cmvImage.FileSize();
        LONG lBytes = liSize.LowPart;

        if (bBanded)
        {
            hr = DoBandedTransfer(pTransCtx, pSrc, lBytes);
        }
        else
        {
            hr = DoTransfer(pTransCtx, pSrc, lBytes);
        }
    }

    CHECK_S_OK(hr);
    return hr;
}




/*****************************************************************************

   CVideoStiUsd::StreamBMPBits

   Transfers the BMP bits of a file

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::StreamBMPBits(STILLCAM_IMAGE_CONTEXT   *pContext,
                            MINIDRV_TRANSFER_CONTEXT *pTransCtx,
                            BOOL                     bBanded)
{
    DBG_FN("CVideoStiUsd::StreamBMPBits");

    //
    // Assume failure
    //
    HRESULT hr = E_FAIL;

    if ((pContext         == NULL) ||
        (pContext->pImage == NULL) ||
        (pTransCtx        == NULL))
    {
        hr = E_INVALIDARG;
        CHECK_S_OK2(hr, ("CVideoStiUsd::StreamBMPBits received NULL params"));
        return hr;
    }

    //
    // Open the file
    //
    Bitmap SourceBitmap(CSimpleStringConvert::WideString(
                                    CSimpleString(
                                        pContext->pImage->ActualImagePath())));

    if (Ok == SourceBitmap.GetLastStatus())
    {
        //
        // Get the image dimensions
        //
        UINT nSourceWidth = SourceBitmap.GetWidth();
        UINT nSourceHeight = SourceBitmap.GetHeight();
        if (nSourceWidth && nSourceHeight)
        {
            //
            // Create the target bitmap
            //
            Bitmap TargetBitmap( nSourceWidth, nSourceWidth );
            if (Ok == TargetBitmap.GetLastStatus())
            {
                //
                // Assume failure
                //
                bool bDrawSucceeded = false;

                //
                // Create a graphics object
                //
                Graphics *pGraphics = Graphics::FromImage(&TargetBitmap);
                if (pGraphics)
                {
                    //
                    // Make sure it is valid
                    //
                    if (pGraphics->GetLastStatus() == Ok)
                    {
                        //
                        // Flip the image, if they asked for a BMP
                        //
                        if (pTransCtx->guidFormatID == WiaImgFmt_BMP)
                        {
                            //
                            // Set up the parallelogram to flip the image
                            //
                            Point SourcePoints[3];
                            SourcePoints[0].X = 0;
                            SourcePoints[0].Y = nSourceHeight;
                            SourcePoints[1].X = nSourceWidth;
                            SourcePoints[1].Y = nSourceHeight;
                            SourcePoints[2].X = 0;
                            SourcePoints[2].Y = 0;

                            //
                            // Draw the image, flipped
                            //
                            if (pGraphics->DrawImage(&SourceBitmap, 
                                                     SourcePoints, 3) == Ok)
                            {
                                //
                                // We've got a good target image
                                //
                                bDrawSucceeded = true;
                            }
                        }
                        else
                        {
                            //
                            // Draw the image normally
                            //
                            if (pGraphics->DrawImage(&SourceBitmap,0,0) == Ok)
                            {
                                //
                                // We've got a good target image
                                //
                                bDrawSucceeded = true;
                            }
                        }
                    }
                    //
                    // Clean up our dynamically allocated graphics
                    //
                    delete pGraphics;
                }

                if (bDrawSucceeded)
                {
                    Rect rcTarget( 0, 0, nSourceWidth, nSourceHeight );
                    Gdiplus::BitmapData BitmapData;

                    //
                    // Get to the bits of the image
                    //
                    if (Ok == TargetBitmap.LockBits(&rcTarget, 
                                                    ImageLockModeRead, 
                                                    PixelFormat24bppRGB, 
                                                    &BitmapData))
                    {
                        if (bBanded)
                        {
                            //
                            // This will be our return value
                            //
                            hr = DoBandedTransfer(
                                     pTransCtx, 
                                     (PBYTE)BitmapData.Scan0, 
                                     (BitmapData.Stride * BitmapData.Height));
                        }
                        else
                        {
                            //
                            // This will be our return value
                            //
                            hr = DoTransfer(
                                    pTransCtx, 
                                    (PBYTE)BitmapData.Scan0, 
                                    (BitmapData.Stride * BitmapData.Height));
                        }

                        TargetBitmap.UnlockBits( &BitmapData );

                    }
                }
            }
        }
    }

    CHECK_S_OK(hr);
    return hr;
}



/*****************************************************************************

   CVideoUsd::LoadImageCB

   Loads an image one piece at a time.

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::LoadImageCB(STILLCAM_IMAGE_CONTEXT    *pContext,
                          MINIDRV_TRANSFER_CONTEXT  *pTransCtx,
                          PLONG                     plDevErrVal)
{
    HRESULT hr = E_FAIL;

    DBG_FN("CVideoStiUsd::LoadImageCB");

    //
    // verify parameters
    //

    if ((pContext         == NULL) ||
        (pContext->pImage == NULL) ||
        (pTransCtx        == NULL))
    {
        hr = E_INVALIDARG;
        CHECK_S_OK2(hr, ("CVideoStiUsd::LoadImageCB received NULL params"));
        return hr;
    }

    if (pTransCtx->guidFormatID == WiaImgFmt_JPEG)
    {
        hr = StreamJPEGBits( pContext, pTransCtx, TRUE );
    }
    else if (pTransCtx->guidFormatID == WiaImgFmt_BMP)
    {
        hr = StreamBMPBits( pContext, pTransCtx, TRUE );
    }
    else if (pTransCtx->guidFormatID == WiaImgFmt_MEMORYBMP)
    {
        hr = StreamBMPBits( pContext, pTransCtx, TRUE );
    }
    else
    {
        DBG_ERR(("Asking for unsupported format"));
        return E_NOTIMPL;
    }

    CHECK_S_OK(hr);
    return hr;
}


/*****************************************************************************

   CVideoStiUsd::LoadImage

   Loads an image in a single transfer

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::LoadImage(STILLCAM_IMAGE_CONTEXT     *pContext,
                        MINIDRV_TRANSFER_CONTEXT   *pTransCtx,
                        PLONG                       plDevErrVal)
{
    HRESULT hr = S_OK;

    DBG_FN("CVideoStiUsd::LoadImage");

    //
    // verify some params
    //

    if ((pContext         == NULL) ||
        (pTransCtx        == NULL))
    {
        hr = E_INVALIDARG;
        CHECK_S_OK2(hr, ("CVideoStiUsd::LoadImage received NULL params"));
        return hr;
    }

    if ((pTransCtx->guidFormatID == WiaImgFmt_BMP))
    {
        hr = StreamBMPBits( pContext, pTransCtx, FALSE );
    }
    else if (pTransCtx->guidFormatID == WiaImgFmt_JPEG)
    {
        hr = StreamJPEGBits( pContext, pTransCtx, FALSE );
    }
    else
    {
        DBG_ERR(("Unsupported format"));
        return E_NOTIMPL;
    }

    CHECK_S_OK(hr);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\video\usd\_simreg.cpp ===
#include <precomp.h>
#pragma hdrstop

#include <atlbase.h>
#include <wia.h>

#include "..\..\..\ui\uicommon\simreg.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\video\usd\vstiusd.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999 - 2000
 *
 *  TITLE:       vstiusd.cpp
 *
 *  VERSION:     1.1
 *
 *  AUTHOR:      WilliamH (created)
 *               RickTu   (ported to WIA)
 *
 *  DATE:        9/7/99
 *
 *  DESCRIPTION: This module implements the CVideoStiUsd object &
 *               supported classes.
 *
 *****************************************************************************/


#include <precomp.h>
#pragma hdrstop

DEFINE_GUID(CLSID_VIDEO_STIUSD,0x0527d1d0, 0x88c2, 0x11d2, 0x82, 0xc7, 0x00, 0xc0, 0x4f, 0x8e, 0xc1, 0x83);


/*****************************************************************************

   CVideoUsdClassFactory constructor / desctructor

   <Notes>

 *****************************************************************************/

ULONG g_cDllRef = 0;

CVideoUsdClassFactory::CVideoUsdClassFactory()
{
}


/*****************************************************************************

   CVideoUsdClassFactory::QueryInterface

   Add our info to the base class QI code.

 *****************************************************************************/

STDMETHODIMP
CVideoUsdClassFactory::QueryInterface( REFIID riid, void **ppvObject)
{
    DBG_FN("CVideoUsdClassFactory::QueryInterface");

    *ppvObject = NULL;

    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IClassFactory))
    {
        *ppvObject = (LPVOID)this;
        AddRef();
        return NOERROR;
    }
    return ResultFromScode(E_NOINTERFACE);
}


/*****************************************************************************

   CVideoUsdClassFactory::AddRef

   <Notes>

 *****************************************************************************/

STDMETHODIMP_(ULONG) CVideoUsdClassFactory::AddRef(void)
{
    DBG_FN("CVideoUsdClassFactory::AddRef");

    InterlockedIncrement((LONG *)&g_cDllRef);
    InterlockedIncrement((LONG *)&m_cRef);
    return m_cRef;
}


/*****************************************************************************

   CVideoUsdClassFactory::Release

   <Notes>

 *****************************************************************************/

STDMETHODIMP_(ULONG)
CVideoUsdClassFactory::Release(void)
{
    DBG_FN("CVideoUsdClassFactory::Release");

    InterlockedDecrement((LONG *)&g_cDllRef);
    InterlockedDecrement((LONG *)&m_cRef);

    if (m_cRef == 0) 
    {
        delete this;
        return 0;
    }

    return m_cRef;
}



/*****************************************************************************

   CVideoUsdClassFactory::CreateInstance

   Instantiate one of the objects we are responsible for.

 *****************************************************************************/

STDMETHODIMP
CVideoUsdClassFactory::CreateInstance(IUnknown  *pOuterUnk, 
                                      REFIID    riid, 
                                      void      **ppv)
{
    DBG_FN("CVideoUsdClassFactory::CreateInstance");

    //
    // Check for bad args
    //

    if (!ppv)
    {
        DBG_ERR(("ppv is NULL.  returning E_INVALIDARG"));
        return E_INVALIDARG;
    }

    *ppv = NULL;

    //
    // If it's not an interface we support, bail early
    //

    if (!IsEqualIID(riid, IID_IStiUSD)     &&
        !IsEqualIID(riid, IID_IWiaMiniDrv) &&
        !IsEqualIID(riid, IID_IUnknown))
    {
        return E_NOINTERFACE;
    }

    //
    // When created for aggregation, only IUnknown can be requested.
    //

    if (pOuterUnk &&
        !IsEqualIID(riid, IID_IUnknown))
    {
        return CLASS_E_NOAGGREGATION;
    }

    //
    // Create our Usd/Wia mini driver
    //

    CVideoStiUsd   *pUsd = NULL;
    HRESULT         hr;

    pUsd = new CVideoStiUsd(pOuterUnk);

    if (!pUsd) 
    {
        DBG_ERR(("Couldn't create new CVideoStiUsd class, "
                 "returning E_OUTOFMEMORY"));

        return E_OUTOFMEMORY;
    }

    hr = pUsd->PrivateInitialize();

    if (hr != S_OK) 
    {
        CHECK_S_OK2( hr, ("pUsd->PrivateInitialize" ));
        delete pUsd;
        return hr;
    }

    //  Move to the requested interface if we aren't aggregated.
    //  Don't do this if aggregated, or we will lose the private
    //  IUnknown and then the caller will be hosed.

    hr = pUsd->NonDelegatingQueryInterface(riid, ppv);
    CHECK_S_OK2( hr, ("pUsd->NonDelegatingQueryInterface" ));

    pUsd->NonDelegatingRelease();

    return hr;
}


/*****************************************************************************

   CVideoUsdClassFactory::LockServer

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CVideoUsdClassFactory::LockServer(BOOL fLock)
{
    DBG_FN("CVideoUsdClassFactory::LockServer");

    if (fLock)
    {
        InterlockedIncrement((LONG*)&g_cDllRef);
    }
    else
    {
        InterlockedDecrement((LONG*)&g_cDllRef);
    }

    return S_OK;
}


/*****************************************************************************

   CVideoUsdClassFactory::GetClassObject

   <Notes>

 *****************************************************************************/

HRESULT
CVideoUsdClassFactory::GetClassObject(REFCLSID rclsid, 
                                      REFIID   riid, 
                                      void     **ppv)
{
    DBG_FN("CVideoUsdClassFactory::GetClassObject");

    if (!ppv)
    {
        return E_INVALIDARG;
    }

    if (rclsid == CLSID_VIDEO_STIUSD &&
        (riid == IID_IUnknown || riid == IID_IClassFactory))
    {
        CVideoUsdClassFactory *pFactory = NULL;

        pFactory = new CVideoUsdClassFactory();

        if (pFactory)
        {
            *ppv = pFactory;
            pFactory->AddRef();
            return S_OK;
        }
        else
        {
            *ppv = NULL;
            return E_OUTOFMEMORY;
        }
    }
    else
    {
        *ppv = NULL;
        return E_NOINTERFACE;
    }
}


/*****************************************************************************

   CVideoUsdClassFactory::CanUnloadNow

   Lets the outside world know if we can be unloaded.

 *****************************************************************************/

HRESULT
CVideoUsdClassFactory::CanUnloadNow()
{
    DBG_FN("CVideoUsdClassFactory::CanUnloadNow");

    return (0 == g_cDllRef) ? S_OK : S_FALSE;
}


/*****************************************************************************

   CVideoStiUsd constructor/destructor

   <Notes>

 *****************************************************************************/

CVideoStiUsd::CVideoStiUsd(IUnknown * pUnkOuter)
 :  m_bDeviceIsOpened(FALSE),
    m_lPicsTaken(0),
    m_hTakePictureEvent(NULL),
    m_hPictureReadyEvent(NULL),
    m_pTakePictureOwner(NULL),
    m_pLastItemCreated(NULL),
    m_dwConnectedApps(0),
    m_cRef(1)
{
    //
    // See if we are aggregated. If we are (almost always the case) save
    // pointer to the controlling Unknown , so subsequent calls will be
    // delegated. If not, set the same pointer to "this".
    //

    if (pUnkOuter)
    {
        m_pUnkOuter = pUnkOuter;
    }
    else
    {
        //
        // Cast below is needed in order to point to right virtual table
        //

        m_pUnkOuter = reinterpret_cast<IUnknown*>
                      (static_cast<INonDelegatingUnknown*>
                      (this));
    }

}

HRESULT CVideoStiUsd::PrivateInitialize()
{
    HRESULT hr = S_OK;
    
    HANDLE hThread = NULL;
    DWORD  dwId    = 0;

    //
    // Set up some global info
    //

    m_wfi = (WIA_FORMAT_INFO*) CoTaskMemAlloc(sizeof(WIA_FORMAT_INFO) * 
                                              NUM_WIA_FORMAT_INFO);

    if (m_wfi)
    {
        //
        //  Set up the format/tymed pairs
        //

        m_wfi[0].guidFormatID = WiaImgFmt_JPEG;
        m_wfi[0].lTymed = TYMED_CALLBACK;

        m_wfi[1].guidFormatID = WiaImgFmt_JPEG;
        m_wfi[1].lTymed = TYMED_FILE;

        m_wfi[2].guidFormatID = WiaImgFmt_MEMORYBMP;
        m_wfi[2].lTymed = TYMED_CALLBACK;

        m_wfi[3].guidFormatID = WiaImgFmt_BMP;
        m_wfi[3].lTymed = TYMED_CALLBACK;

        m_wfi[4].guidFormatID = WiaImgFmt_BMP;
        m_wfi[4].lTymed = TYMED_FILE;
    }

    //
    // Initialize critical sections
    //

    __try 
    {
        if (!InitializeCriticalSectionAndSpinCount(&m_csItemTree, MINLONG))
        {
            hr = HRESULT_FROM_WIN32(::GetLastError());

            DBG_ERR(("ERROR: Failed to initialize one of critsections "
                     "(0x%08X)", 
                     hr));
        }
    }
    __except(EXCEPTION_EXECUTE_HANDLER) 
    {
        hr = E_OUTOFMEMORY;
    }

    //
    // Initialize GDI+
    //

    Gdiplus::Status                 StatusResult     = Gdiplus::Ok;
    Gdiplus::GdiplusStartupInput    StartupInput;
    m_ulGdiPlusToken = NULL;

    if (hr == S_OK) 
    {
        StatusResult = Gdiplus::GdiplusStartup(&m_ulGdiPlusToken,
                                               &StartupInput,
                                               NULL);

        if (StatusResult != Gdiplus::Ok)
        {
            DBG_ERR(("ERROR: Failed to start up GDI+, Status code returned "
                     "by GDI+ = '%d'",
                     StatusResult));

            hr = HRESULT_FROM_WIN32(StatusResult);
        }
    }

    return hr;
}

CVideoStiUsd::~CVideoStiUsd()
{

    if (m_pRootItem)
    {
        HRESULT hr = S_OK;

        DBG_TRC(("CVideoStiUsd::~CVideoStiUsd, driver is being destroyed, "
                 "and for some reason the tree still exists, deleting tree..."));

        hr = m_pRootItem->UnlinkItemTree(WiaItemTypeDisconnected);

        // Clear the root item
        m_pRootItem = NULL;
    }

    //
    // Disable Take Picture command.
    //
    DisableTakePicture(NULL, TRUE);

    //
    // Shutdown GDI+
    //
    Gdiplus::GdiplusShutdown(m_ulGdiPlusToken);

    CloseDevice();

    if (m_wfi)
    {
        CoTaskMemFree( (LPVOID)m_wfi );
        m_wfi = NULL;
    }

    DeleteCriticalSection(&m_csItemTree);
}


/*****************************************************************************

   CVideoStiUsd::NonDelegatingQueryInterface

   This is the inner object QI -- in other words, handle QI's for the
   interfaces our object supports.

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::NonDelegatingQueryInterface(REFIID  riid, 
                                          LPVOID  *ppvObj )
{
    HRESULT hr = S_OK;

    DBG_FN("CVideoStiUsd::NonDelegatingQueryInterface");

    //
    // Check for invalid args
    //

    if (!ppvObj)
    {
        DBG_ERR(("ppvObj is NULL, returning E_INVALIDARG"));
        return E_INVALIDARG;
    }

    *ppvObj = NULL;

    if (IsEqualIID(riid, IID_IUnknown))
    {
        *ppvObj = static_cast<INonDelegatingUnknown*>(this);
    }
    else if (IsEqualIID(riid, IID_IStiUSD))
    {
        *ppvObj = static_cast<IStiUSD*>(this);
    }
    else if (IsEqualIID(riid, IID_IWiaMiniDrv))
    {
        *ppvObj = static_cast<IWiaMiniDrv*>(this);
    }
    else
    {
        hr =  E_NOINTERFACE;
        DBG_ERR(("CVideoStiUsd::NonDelegatingQueryInterface requested "
                 "interface we don't support, returning hr = 0x%08lx", hr));
    }

    if (SUCCEEDED(hr)) 
    {
        (reinterpret_cast<IUnknown*>(*ppvObj))->AddRef();
    }

    CHECK_S_OK(hr);
    return hr;
}



/*****************************************************************************

   CVideoStiUsd::NonDelegatingAddRef

   This is the inner object AddRef -- actually inc the ref count
   for our interfaces.

 *****************************************************************************/

STDMETHODIMP_(ULONG)
CVideoStiUsd::NonDelegatingAddRef(void)
{
    DBG_FN("CVideoStiUsd::NonDelegatingAddRef");

    return InterlockedIncrement((LPLONG)&m_cRef);
}



/*****************************************************************************

   CVideoStiUsd::NonDelegatingRelease

   This is the inner object Release -- actually dec the ref count
   for our interfaces.

 *****************************************************************************/

STDMETHODIMP_(ULONG)
CVideoStiUsd::NonDelegatingRelease(void)
{
    DBG_FN("CVideoStiUsd::NonDelegatingRelease");

    ULONG ulRef = 0;

    ulRef = InterlockedDecrement((LPLONG)&m_cRef);

    if (!ulRef) 
    {
        delete this;
    }

    return ulRef;
}


/*****************************************************************************

   CVideoStiUsd::QueryInterface

   Outer QI -- used for aggregation

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::QueryInterface(REFIID riid, LPVOID *ppvObj)
{
    DBG_FN("CVideoStiUsd::QueryInterface");

    return m_pUnkOuter->QueryInterface( riid, ppvObj );
}


/*****************************************************************************

   CVideoStiUsd::AddRef

   Outer AddRef -- used for aggregation

 *****************************************************************************/

STDMETHODIMP_(ULONG)
CVideoStiUsd::AddRef(void)
{
    DBG_FN("CVideoStiUsd::AddRef");
    return m_pUnkOuter->AddRef();
}


/*****************************************************************************

   CVideoStiUsd::Release

   Outer Release -- used for aggregation

 *****************************************************************************/

STDMETHODIMP_(ULONG)
CVideoStiUsd::Release(void)
{
    DBG_FN("CVideoStiUsd::Release");
    return m_pUnkOuter->Release();
}


/*****************************************************************************

   CVideoStiUsd::Initialize [IStillUsd]

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::Initialize(PSTIDEVICECONTROL pDcb,
                         DWORD             dwStiVersion,
                         HKEY              hParameterKey)
{
    DBG_FN("CVideoStiUsd::Initialize");

    HRESULT hr = S_OK;
    WCHAR DeviceName[MAX_PATH] = {0};

    if ((pDcb == NULL) || (hParameterKey == NULL))
    {
        hr = E_POINTER;
        CHECK_S_OK2(hr, ("CVideoStiUsd::Initialize, received a "
                         "NULL pointer, either 'pDcb = 0x%08lx' is NULL "
                         "or 'hParameterKey = 0x%08lx' is NULL",
                         pDcb, hParameterKey));
    }

    if (hr == S_OK)
    {
        //
        // get the device symbolic name. We use the name to get an IMoniker to
        // the device filter proxy.
        //
        hr = pDcb->GetMyDevicePortName(DeviceName, 
                                       sizeof(DeviceName)/sizeof(WCHAR));

        if (SUCCEEDED(hr))
        {
            hr = OpenDevice(DeviceName);
        }
    }

    if (hr == S_OK)
    {
        HKEY    hKey    = NULL;
        DWORD   dwType  = 0;
        LRESULT lResult = ERROR_SUCCESS;
        TCHAR   szValue[MAX_PATH + 1] = {0};
        DWORD   dwSize  = sizeof(szValue);

        lResult = RegOpenKeyEx(hParameterKey, 
                               TEXT("DeviceData"),
                               0, 
                               KEY_READ, 
                               &hKey);

        if (lResult == ERROR_SUCCESS)
        {
            //
            // Read DShow device ID from DeviceData registry
            //
            lResult = RegQueryValueEx(hKey, 
                                      TEXT("DShowDeviceId"), 
                                      NULL,
                                      &dwType, 
                                      (BYTE*) szValue,
                                      &dwSize);
        }

        if (hKey)
        {
            RegCloseKey(hKey);
            hKey = NULL;
        }

        if (lResult == ERROR_SUCCESS)
        {
            m_strDShowDeviceId = szValue;
        }
        else
        {
            hr = E_FAIL;
            CHECK_S_OK2(hr, ("CVideoStiUsd::Initialize, failed to retrieve the "
                             "DShow Device ID."));
        }
    }

    return hr;
}


/*****************************************************************************

   CVideoStiUsd::CloseDevice [IStillUsd]

   <Notes>

 *****************************************************************************/

HRESULT
CVideoStiUsd::CloseDevice()
{
    DBG_FN("CVideoStiUsd::CloseDevice");

    m_bDeviceIsOpened = FALSE;

    return S_OK;
}


/*****************************************************************************

   CVideoStiUsd::OpenDevice [IStillUsd]

   <Notes>

 *****************************************************************************/

HRESULT
CVideoStiUsd::OpenDevice(LPCWSTR DeviceName)
{
    DBG_FN("CVideoStiUsd::OpenDevice");

    //
    // Check for bad args
    //

    if (!DeviceName || (0 == *DeviceName))
    {
        return E_INVALIDARG;
    }


    m_bDeviceIsOpened = TRUE;

    return S_OK;
}


/*****************************************************************************

   CVideoStiUsd::GetCapabilities [IStillUsd]

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::GetCapabilities(PSTI_USD_CAPS pDevCaps)
{
    DBG_FN("CVideoStiUsd::GetCapabilities");

    //
    // Check for bad args
    //

    if (!pDevCaps)
    {
        return E_INVALIDARG;
    }


    memset(pDevCaps, 0, sizeof(STI_USD_CAPS));

    pDevCaps->dwVersion     = STI_VERSION;
    pDevCaps->dwGenericCaps = STI_USD_GENCAP_NATIVE_PUSHSUPPORT;

    return S_OK;
}


/*****************************************************************************

   CVideoStiUsd::GetStatus [IStillUsd]

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::GetStatus(PSTI_DEVICE_STATUS pDevStatus)
{
    DBG_FN("CVideoStiUsd::GetStatus");

    if (!pDevStatus)
    {
        return E_INVALIDARG;
    }

    if (pDevStatus->StatusMask & STI_DEVSTATUS_ONLINE_STATE )
    {
        if (m_bDeviceIsOpened)
        {
            pDevStatus->dwOnlineState |= STI_ONLINESTATE_OPERATIONAL;
        }
        else
        {
            pDevStatus->dwOnlineState &= ~STI_ONLINESTATE_OPERATIONAL;
        }
    }

    return S_OK;
}



/*****************************************************************************

   CVideoStiUsd::DeviceReset [IStillUsd]

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::DeviceReset()
{
    DBG_FN("CVideoStiUsd::DeviceReset");

    return S_OK;
}


/*****************************************************************************

   CVideoStiUsd::Diagnostic [IStillUsd]

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::Diagnostic(LPSTI_DIAG pStiDiag)
{
    DBG_FN("CVideoStiUsd::Diagnostic");

    //
    // Check for bad args
    //

    if (!pStiDiag)
    {
        return E_INVALIDARG;
    }

    //
    // Return diag info
    //

    pStiDiag->dwStatusMask = 0;
    memset(&pStiDiag->sErrorInfo, 0, sizeof(pStiDiag->sErrorInfo));

    if (m_bDeviceIsOpened)
    {
        pStiDiag->sErrorInfo.dwGenericError = NOERROR;
    }
    else
    {
        pStiDiag->sErrorInfo.dwGenericError = STI_NOTCONNECTED;
    }

    pStiDiag->sErrorInfo.dwVendorError = 0;

    return S_OK;
}


/*****************************************************************************

   CVideoStiUsd::Escape [IStillUsd]

   <Notes>

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::Escape(STI_RAW_CONTROL_CODE Function,
                     LPVOID               DataIn,
                     DWORD                DataInSize,
                     LPVOID               DataOut,
                     DWORD                DataOutSize,
                     DWORD                *pActualSize)
{

    DBG_FN("CVideoStiUsd::Escape");

    return S_OK;
}


/*****************************************************************************

   CVideoStiUsd::GetLastError [IStillUsd]

   Not implemented yet.

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::GetLastError(LPDWORD pLastError)
{
    DBG_FN("CVideoStiUsd::GetLastError( NOT_IMPL )");

    return E_NOTIMPL;
}


/*****************************************************************************

   CVideoStiUsd::LockDevice [IStillUsd]

   No actual locking of the device has to happen, so just return success.

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::LockDevice()
{
    DBG_FN("CVideoStiUsd::LockDevice");

    return S_OK;
}


/*****************************************************************************

   CVideoStiUsd::UnLockDevice [IStillUsd]

   No actual locking/unlocking of the device has to happen, so just return
   success.

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::UnLockDevice()
{
    DBG_FN("CVideoStiUsd::UnlockDevice");

    return S_OK;
}


/*****************************************************************************

   CVideoStiUsd::RawReadData [IStillUsd]

   Not implemented yet.

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::RawReadData(LPVOID        Buffer,
                          LPDWORD       BufferSize,
                          LPOVERLAPPED  lpOverlapped)
{
    DBG_FN("CVideoStiUsd::RawReadData( NOT_IMPL )");

    return E_NOTIMPL;
}


/*****************************************************************************

   CVideoStiUsd::RawWriteData [IStillUsd]

   Not implemented yet.

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::RawWriteData(LPVOID Buffer,
                           DWORD BufferSize,
                           LPOVERLAPPED lpOverlapped)
{
    DBG_FN("CVideoStiUsd::RawWriteData( NOT_IMPL )");

    return E_NOTIMPL;
}


/*****************************************************************************

   CVideoStiUsd::RawReadCommand [IStillUsd]

   Not implemented yet.

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::RawReadCommand(LPVOID Buffer,
                             LPDWORD BufferSize,
                             LPOVERLAPPED lpOverlapped)
{
    DBG_FN("CVideoStiUsd::RawReadCommand( NOT_IMPL )");

    return E_NOTIMPL;
}


/*****************************************************************************

   CVideoStiUsd::RawWriteCommand [IStillUsd]

   Not implemented yet.

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::RawWriteCommand(LPVOID Buffer,
                              DWORD BufferSize,
                              LPOVERLAPPED lpOverlapped)
{
    DBG_FN("CVideoStiUsd::RawWriteCommand( NOT_IMPL )");

    return E_NOTIMPL;
}


/*****************************************************************************

   CVideoStiUsd::SetNotificationHandle [IStillUsd]

   Sets the event notification handle.

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::SetNotificationHandle(HANDLE hEvent)
{
    DBG_FN("CVideoStiUsd::SetNotificationHandle");

    return S_OK;
}


/*****************************************************************************

   CVideoStiUsd::GetNotificationData [IStillUsd]

   Returns the current event notification handle.

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::GetNotificationData(LPSTINOTIFY lpNotify)
{
    DBG_FN("CVideoStiUsd::GetNotificationData");

    HRESULT hr = STIERR_NOEVENTS;

    DBG_ERR(("We were called, but no events are present -- why?"));

    CHECK_S_OK(hr);
    return hr;
}


/*****************************************************************************

   CVideoStiUsd::GetLastErrorInfo [IStillUsd]

   Not implemented yet.

 *****************************************************************************/

STDMETHODIMP
CVideoStiUsd::GetLastErrorInfo(STI_ERROR_INFO *pLastErrorInfo)
{
    DBG_FN("CVideoStiUsd::GetLastErrorInfo( NOT_IMPL )");

    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\video\usd\videousd.cpp ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998 - 2000
 *
 *  TITLE:       videousd.cpp
 *
 *  VERSION:     1.1
 *
 *  AUTHOR:      WilliamH (created)
 *               RickTu   (modified for WIA)
 *
 *  DATE:        9/7/99
 *
 *  DESCRIPTION: This module implements wiavideo.dll
 *
 *****************************************************************************/

#include <precomp.h>
#pragma hdrstop

#include <advpub.h>

HINSTANCE g_hInstance;


/*****************************************************************************

   DllMain

   <Notes>

 *****************************************************************************/

BOOL
DllMain(HINSTANCE   hInstance,
        DWORD       dwReason,
        LPVOID      lpReserved)
{
    switch (dwReason)
    {

        case DLL_PROCESS_ATTACH:
            // 
            // Init the debug library
            // 
            DBG_INIT(hInstance);
    
            //
            // We do not need thread attach/detach calls
            //
    
            DisableThreadLibraryCalls(hInstance);
    
            //
            // Record what instance we are
            //
    
            g_hInstance = hInstance;
        break;
    
        case DLL_PROCESS_DETACH:
    
        break;

    }
    return TRUE;
}


/*****************************************************************************

   DllCanUnloadNow

   Let the outside world know when they can unload this dll

 *****************************************************************************/

STDAPI DllCanUnloadNow(void)
{
    return CVideoUsdClassFactory::CanUnloadNow();
}


/*****************************************************************************

   DllGetClassObject

   This is what the outside world calls to get an object of ours
   instantiated.

 *****************************************************************************/

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return CVideoUsdClassFactory::GetClassObject(rclsid, riid, ppv);
}



/*****************************************************************************

   Installs information in an .inf that is in our resource fork.

   <Notes>

 *****************************************************************************/


HRESULT InstallInfFromResource(HINSTANCE hInstance, 
                               LPCSTR    pszSectionName)
{
    HRESULT hr;
    HINSTANCE hInstAdvPackDll = LoadLibrary(TEXT("ADVPACK.DLL"));

    if (hInstAdvPackDll)
    {
        REGINSTALL pfnRegInstall = reinterpret_cast<REGINSTALL>(GetProcAddress( hInstAdvPackDll, "RegInstall" ));
        if (pfnRegInstall)
        {
#if defined(WINNT)
            STRENTRY astrEntry[] =
            {
                { "25", "%SystemRoot%"           },
                { "11", "%SystemRoot%\\system32" }
            };
            STRTABLE strTable = { sizeof(astrEntry)/sizeof(astrEntry[0]), astrEntry };
            hr = pfnRegInstall(hInstance, pszSectionName, &strTable);
#else
            hr = pfnRegInstall(hInstance, pszSectionName, NULL);
#endif
        } else hr = HRESULT_FROM_WIN32(GetLastError());
        FreeLibrary(hInstAdvPackDll);
    } else hr = HRESULT_FROM_WIN32(GetLastError());
    return hr;
}


/*****************************************************************************

   DllRegisterServer

   Register the objects we provide.

 *****************************************************************************/

STDAPI DllRegisterServer(void)
{

    return InstallInfFromResource( g_hInstance, "RegDll" );
}


/*****************************************************************************

   DllUnregisterServer

   Unregister the objects we provide.

 *****************************************************************************/

STDAPI DllUnregisterServer(void)
{
    return InstallInfFromResource( g_hInstance, "UnregDll" );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\drivers\video\usd\vstiusd.h ===
/*****************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1999 - 2000
 *
 *  TITLE:       vstiusd.h
 *
 *  VERSION:     1.1
 *
 *  AUTHOR:      WilliamH (original for Twain)
 *               RickTu (port for WIA)
 *
 *  DATE:       9/16/99
 *
 *  DESCRIPTION: Header file that decalres CVideoSTiUsd class and other
 *               needed classes.
 *
 *****************************************************************************/


#ifndef _WIA_STILL_DRIVER_VSTIUSD_H_
#define _WIA_STILL_DRIVER_VSTIUSD_H_

extern HINSTANCE g_hInstance;
extern ULONG     g_cDllRef;

#define NUM_WIA_FORMAT_INFO 5

HRESULT FindEncoder(const GUID &guidFormat, CLSID *pClsid);

//
// Base class for supporting non-delegating IUnknown for contained objects
//

struct INonDelegatingUnknown
{
    // *** IUnknown-like methods ***
    STDMETHOD(NonDelegatingQueryInterface)( THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,NonDelegatingAddRef)(THIS)  PURE;
    STDMETHOD_(ULONG,NonDelegatingRelease)( THIS) PURE;
};


///////////////////////////////
// CVideoUsdClassFactory
//
class CVideoUsdClassFactory : public IClassFactory
{
private:
    ULONG m_cRef;

public:
    CVideoUsdClassFactory();

    //
    // Declare IUnknown methods
    //

    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);

    //
    // IClassFactory implemenation
    //
    STDMETHODIMP LockServer(BOOL fLock);
    STDMETHODIMP CreateInstance(IUnknown *pOuterUnk, REFIID riid, void **ppv);

    static HRESULT GetClassObject(REFCLSID rclsid, REFIID riid, void **ppv);
    static HRESULT CanUnloadNow();
};


///////////////////////////////
// CVideoStiUsd
//
class CVideoStiUsd : public IStiUSD,
                     public IWiaMiniDrv,
                     public INonDelegatingUnknown
                     
{
public:
    CVideoStiUsd(IUnknown * pUnkOuter);
    HRESULT PrivateInitialize();
    ~CVideoStiUsd();

    //
    // Real IUnknown methods
    //

    STDMETHODIMP NonDelegatingQueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) NonDelegatingAddRef();
    STDMETHODIMP_(ULONG) NonDelegatingRelease();

    //
    // Aggregate IUnknown methods
    //

    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    //
    // IStillUsd implementation
    //
    STDMETHODIMP Initialize(PSTIDEVICECONTROL pDcb, DWORD dwStiVersion, HKEY hParameterKey);
    STDMETHODIMP GetCapabilities(PSTI_USD_CAPS pDevCaps);
    STDMETHODIMP GetStatus(PSTI_DEVICE_STATUS pDevStatus);
    STDMETHODIMP DeviceReset();
    STDMETHODIMP Diagnostic(LPSTI_DIAG pBuffer);
    STDMETHODIMP Escape(STI_RAW_CONTROL_CODE Function, LPVOID DataIn, DWORD DataInSize, LPVOID DataOut, DWORD DataOutSize, DWORD *pActualSize);
    STDMETHODIMP GetLastError(LPDWORD pLastError);
    STDMETHODIMP LockDevice();
    STDMETHODIMP UnLockDevice();
    STDMETHODIMP RawReadData(LPVOID Buffer, LPDWORD BufferSize, LPOVERLAPPED lpOverlapped);
    STDMETHODIMP RawWriteData(LPVOID Buffer, DWORD BufferSize, LPOVERLAPPED lpOverlapped);
    STDMETHODIMP RawReadCommand(LPVOID Buffer, LPDWORD BufferSize, LPOVERLAPPED lpOverlapped);
    STDMETHODIMP RawWriteCommand(LPVOID Buffer, DWORD BufferSize, LPOVERLAPPED lpOverlapped);
    STDMETHODIMP SetNotificationHandle(HANDLE hEvent);
    STDMETHODIMP GetNotificationData(LPSTINOTIFY lpNotify);
    STDMETHODIMP GetLastErrorInfo(STI_ERROR_INFO *pLastErrorInfo);

    //
    // IWiaMiniDrv methods
    //

    STDMETHOD(drvInitializeWia)(THIS_
        BYTE*                       pWiasContext,
        LONG                        lFlags,
        BSTR                        bstrDeviceID,
        BSTR                        bstrRootFullItemName,
        IUnknown                   *pStiDevice,
        IUnknown                   *pIUnknownOuter,
        IWiaDrvItem               **ppIDrvItemRoot,
        IUnknown                  **ppIUnknownInner,
        LONG                       *plDevErrVal);

    STDMETHOD(drvGetDeviceErrorStr)(THIS_
        LONG                        lFlags,
        LONG                        lDevErrVal,
        LPOLESTR                   *ppszDevErrStr,
        LONG                       *plDevErr);

    STDMETHOD(drvDeviceCommand)(THIS_
        BYTE                       *pWiasContext,
        LONG                        lFlags,
        const GUID                 *pGUIDCommand,
        IWiaDrvItem               **ppMiniDrvItem,
        LONG                       *plDevErrVal);

    STDMETHOD(drvAcquireItemData)(THIS_
        BYTE                       *pWiasContext,
        LONG                        lFlags,
        PMINIDRV_TRANSFER_CONTEXT   pDataContext,
        LONG                       *plDevErrVal);

    STDMETHOD(drvInitItemProperties)(THIS_
        BYTE                       *pWiasContext,
        LONG                        lFlags,
        LONG                       *plDevErrVal);

    STDMETHOD(drvValidateItemProperties)(THIS_
        BYTE                       *pWiasContext,
        LONG                        lFlags,
        ULONG                       nPropSpec,
        const PROPSPEC             *pPropSpec,
        LONG                       *plDevErrVal);

    STDMETHOD(drvWriteItemProperties)(THIS_
        BYTE                       *pWiasContext,
        LONG                        lFLags,
        PMINIDRV_TRANSFER_CONTEXT   pmdtc,
        LONG                       *plDevErrVal);

    STDMETHOD(drvReadItemProperties)(THIS_
        BYTE                       *pWiaItem,
        LONG                        lFlags,
        ULONG                       nPropSpec,
        const PROPSPEC             *pPropSpec,
        LONG                       *plDevErrVal);

    STDMETHOD(drvLockWiaDevice)(THIS_
        BYTE                       *pWiasContext,
        LONG                        lFlags,
        LONG                       *plDevErrVal);

    STDMETHOD(drvUnLockWiaDevice)(THIS_
        BYTE                       *pWiasContext,
        LONG                        lFlags,
        LONG                       *plDevErrVal );

    STDMETHOD(drvAnalyzeItem)(THIS_
        BYTE                       *pWiasContext,
        LONG                        lFlags,
        LONG                       *plDevErrVal);

    STDMETHOD(drvDeleteItem)(THIS_
        BYTE                       *pWiasContext,
        LONG                        lFlags,
        LONG                       *plDevErrVal);

    STDMETHOD(drvFreeDrvItemContext)(THIS_
        LONG                        lFlags,
        BYTE                       *pDevContext,
        LONG                       *plDevErrVal);

    STDMETHOD(drvGetCapabilities)(THIS_
        BYTE                       *pWiasContext,
        LONG                        lFlags,
        LONG                       *pCelt,
        WIA_DEV_CAP_DRV           **ppCapabilities,
        LONG                       *plDevErrVal);

    STDMETHOD(drvGetWiaFormatInfo)(THIS_
        BYTE                       *pWiasContext,
        LONG                        lFlags,
        LONG                       *pCelt,
        WIA_FORMAT_INFO            **ppwfi,
        LONG                       *plDevErrVal);

    STDMETHOD(drvNotifyPnpEvent)(THIS_
        const GUID                 *pEventGUID,
        BSTR                        bstrDeviceID,
        ULONG                       ulReserved);

    STDMETHOD(drvUnInitializeWia)(THIS_
        BYTE*);


    //
    // Utility functions
    //

    STDMETHOD(BuildItemTree)(IWiaDrvItem **ppIDrvItemRoot, LONG *plDevErrVal);
    STDMETHOD(RefreshTree)(IWiaDrvItem *pIDrvItemRoot, LONG *plDevErrVal);
    STDMETHOD(EnumSavedImages)(IWiaDrvItem *pRootItem);
    STDMETHOD(CreateItemFromFileName)(LONG FolderType,LPCTSTR pszPath,LPCTSTR pszName,IWiaDrvItem **ppNewFolder);
    STDMETHOD(InitDeviceProperties)(BYTE *pWiasContext, LONG *plDevErrVal);
    STDMETHOD(InitImageInformation)(BYTE *pWiasContext, PSTILLCAM_IMAGE_CONTEXT pContext, LONG *plDevErrVal);
    STDMETHOD(SendBitmapHeader)( IWiaDrvItem *pDrvItem, PMINIDRV_TRANSFER_CONTEXT pTranCtx);
    STDMETHOD(ValidateDataTransferContext)(PMINIDRV_TRANSFER_CONTEXT  pDataTransferContext);
    STDMETHOD(LoadImageCB)(STILLCAM_IMAGE_CONTEXT *pContext,MINIDRV_TRANSFER_CONTEXT *pTransCtx, PLONG plDevErrVal);
    STDMETHOD(LoadImage)(STILLCAM_IMAGE_CONTEXT *pContext,MINIDRV_TRANSFER_CONTEXT *pTransCtx, PLONG plDevErrVal);
    STDMETHODIMP_(VOID) HandleNewBits(HGLOBAL hDib,IWiaDrvItem **ppItem);
    STDMETHOD(DoBandedTransfer)(MINIDRV_TRANSFER_CONTEXT *pTransCtx,PBYTE pSrc,LONG lBytesToTransfer);
    STDMETHOD(DoTransfer)(MINIDRV_TRANSFER_CONTEXT *pTransCtx,PBYTE pSrc,LONG lBytesToTransfer);
    STDMETHOD(StreamJPEGBits)(STILLCAM_IMAGE_CONTEXT *pContext, MINIDRV_TRANSFER_CONTEXT *pTransCtx, BOOL bBanded);
    STDMETHOD(StreamBMPBits)(STILLCAM_IMAGE_CONTEXT *pContext, MINIDRV_TRANSFER_CONTEXT *pTransCtx, BOOL bBanded);


private:

    //
    // IStiUSD stuff
    //

    HRESULT     OpenDevice(LPCWSTR DeviceName);
    HRESULT     CloseDevice();

    //
    // Misc functions
    //

    HRESULT VerifyCorrectImagePath(BSTR bstrNewImageFullPath);

    HRESULT SignalNewImage(BSTR bstrNewImageFullPath);

    BOOL FindCaptureFilter( LPCTSTR             pszDeviceId,
                            CComPtr<IMoniker> & pCaptureFilterMoniker );

    BOOL DoesFileExist(BSTR bstrFileName);
    BOOL IsFileAlreadyInTree( IWiaDrvItem * pRootItem,
                              LPCTSTR       pszFileName );

    HRESULT PruneTree( IWiaDrvItem * pRootItem,
                       BOOL        * pbTreeChanged );

    HRESULT AddNewFilesToTree( IWiaDrvItem * pRootItem,
                               BOOL        * pbTreeChanged );

    HRESULT AddTreeItem(CSimpleString *pstrFullImagePath,
                        IWiaDrvItem   **ppDrvItem);

    HRESULT SetImagesDirectory(BSTR           bstrNewImagesDirectory,
                               BYTE           *pWiasContext,
                               IWiaDrvItem    **ppIDrvItemRoot,
                               LONG           *plDevErrVal);

    HRESULT ValidateItemProperties(BYTE *             pWiasContext,
                                   LONG               lFlags,
                                   ULONG              nPropSpec,
                                   const PROPSPEC *   pPropSpec,
                                   LONG *             plDevErrVal,
                                   IWiaDrvItem *      pDrvItem);

        
    HRESULT ValidateDeviceProperties(BYTE *             pWiasContext,
                                     LONG               lFlags,
                                     ULONG              nPropSpec,
                                     const PROPSPEC *   pPropSpec,
                                     LONG *             plDevErrVal,
                                     IWiaDrvItem *      pDrvItem);

    HRESULT ReadItemProperties(BYTE *             pWiasContext,
                               LONG               lFlags,
                               ULONG              nPropSpec,
                               const PROPSPEC *   pPropSpec,
                               LONG *             plDevErrVal,
                               IWiaDrvItem *      pDrvItem);


    HRESULT ReadDeviceProperties(BYTE *             pWiasContext,
                                 LONG               lFlags,
                                 ULONG              nPropSpec,
                                 const PROPSPEC *   pPropSpec,
                                 LONG *             plDevErrVal,
                                 IWiaDrvItem *      pDrvItem);


    HRESULT EnableTakePicture(BYTE *pTakePictureOwner);
    HRESULT TakePicture(BYTE *pTakePictureOwner, IWiaDrvItem ** ppNewDrvItem);
    HRESULT DisableTakePicture(BYTE *pTakePictureOwner, BOOL bShuttingDown);

    //
    // IWiaMiniDrv stuff
    //

    CSimpleStringWide       m_strDeviceId;
    CSimpleStringWide       m_strRootFullItemName;
    CSimpleStringWide       m_strStillPath;
    CSimpleStringWide       m_strDShowDeviceId;
    CSimpleStringWide       m_strLastPictureTaken;
    CRITICAL_SECTION        m_csItemTree;

    CComPtr<IWiaDrvItem>    m_pRootItem;
    CComPtr<IStiDevice>     m_pStiDevice;
    WIA_FORMAT_INFO *       m_wfi;
    LONG                    m_lPicsTaken;
    HANDLE                  m_hTakePictureEvent;
    HANDLE                  m_hPictureReadyEvent;
    ULONG_PTR               m_ulGdiPlusToken;
    IWiaDrvItem *           m_pLastItemCreated;  // only valid while inside m_csSnapshot
    BYTE *                  m_pTakePictureOwner;

    DWORD                   m_dwConnectedApps;

    //
    // IUnknown stuff
    //

    ULONG       m_cRef;                 // Device object reference count.
    LPUNKNOWN   m_pUnkOuter;            // Pointer to outer unknown.


    //
    // IStiUSD stuff
    //
    BOOL        m_bDeviceIsOpened;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\inc\apiutil.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    stiapi.h

Abstract:

    Various definitions and constants, needed for internal client/server API interface

Author:

    Vlad Sadovsky   (vlads) 26-Jan-1997

Revision History:

    26-Jan-1997     VladS       created

--*/

#ifndef _APIUTIL_H_
#define _APIUTIL_h_

# ifdef __cplusplus
extern "C"   {
# endif // __cplusplus


#ifdef MIDL_PASS
#define RPC_STATUS      long
#define STI_API_STATUS  long
#define STI_API_FUNCTION stdcall
#else
# include <rpc.h>
#endif // MIDL_PASS

//
//  RPC utilities
//

//
// COnnection options for named-pipe transport
//
# define PROT_SEQ_NP_OPTIONS_W    L"Security=Impersonation Dynamic False"

//
// Transport sequences
//
//#define  IRPC_LRPC_SEQ    "mswmsg"
#define STI_LRPC_SEQ        TEXT("ncalrpc")

//
// Interface name for named-pipe transport
//
#define STI_INTERFACE       "\\pipe\\stiapis"
#define STI_INTERFACE_W     L"\\pipe\\stiapis"
//
// Local RPC end-point
//
#define STI_LRPC_ENDPOINT   TEXT("STI_LRPC")
#define STI_LRPC_ENDPOINT_W L"STI_LRPC"

//
// Local RPC max concurrent calls
//
#define STI_LRPC_MAX_REQS   RPC_C_LISTEN_MAX_CALLS_DEFAULT

//
// Number of concurrent RPC threads
//
#define STI_LRPC_THREADS            1


//
// Useful types
//
#ifdef UNICODE
typedef unsigned short *RPC_STRING ;
#else
typedef unsigned char *RPC_STRING ;

#endif

extern PVOID
MIDL_user_allocate( IN size_t Size);

extern VOID
MIDL_user_free( IN PVOID pvBlob);

extern RPC_STATUS
RpcBindHandleForServer( OUT handle_t * pBindingHandle,
                       IN LPWSTR      pwszServerName,
                       IN LPWSTR      pwszInterfaceName,
                       IN LPWSTR      pwszOptions
                       );

extern RPC_STATUS
RpcBindHandleFree( IN OUT handle_t * pBindingHandle);

# ifdef __cplusplus
};
# endif // __cplusplus


#endif // _APIUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\inc\base.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    base.h

Abstract:

    Universal base class for error cascading and debugging information

Author:

    Vlad Sadovsky   (vlads) 26-Jan-1997

Revision History:

    26-Jan-1997     VladS       created

--*/

#ifndef _BASE_H_
#define _BASE_H_

/*************************************************************************

    NAME:   BASE (base)

    SYNOPSIS:   Universal base object, root of every class.
        It contains universal error status and debugging
        support.

    INTERFACE:  ReportError()   - report an error on the object from
                  within the object.

        QueryError()    - return the current error state,
                  or 0 if no error outstanding.

        operator!() - return TRUE if an error is outstanding.
                  Typically means that construction failed.

    CAVEATS:    This sort of error reporting is safe enough in a single-
        threaded system, but loses robustness when multiple threads
        access shared objects.  Use it for constructor-time error
        handling primarily.

*************************************************************************/

class BASE : public IUnknown
{
private:
    UINT    m_err;

protected:

    LONG    m_cRef;

    BASE() { m_err = 0; m_cRef = 1;}
    VOID    ReportError( UINT err ) { m_err = err; }

public:

    // *** IUnknown methods ***
    STDMETHOD(QueryInterface)( THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS)  PURE;
    STDMETHOD_(ULONG,Release)( THIS) PURE;

    // *** BASE Methods
    UINT    QueryError() const { return m_err; }
    LONG    QueryRefCount() { return m_cRef;}
    BOOL    operator!() const  { return (m_err != 0); }
};

#endif // _BASE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\inc\buffer.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    buffer.h

Abstract:

    Definition of BUFFER class.

Author:

    Vlad Sadovsky   (vlads) 26-Jan-1997

Revision History:

    26-Jan-1997     VladS       created

--*/

#ifndef _INC_BUFFER
#define _INC_BUFFER

extern "C"
{

# include <windows.h>
};


/*************************************************************************

    NAME:       BUFFER (buf)

    SYNOPSIS:   A resizable object which lives in the application heap.

                Upon construction, the buffer takes a requested size in
                bytes; it allocates storage sufficient to hold that size.
                The client can later change this size with Resize, Trim,
                and FillOut.  QuerySize returns the current size of
                the buffer; QueryPtr returns a pointer to its storage.

                Note that a buffer may have size 0, in which case it
                keeps no allocated storage.

    INTERFACE:  BUFFER()        - Constructor, naming initial size in bytes

                QuerySize()     - return size in bytes
                QueryPtr()      - return pointer to data buffer

                Resize()        - resize the object to the given number
                                  of bytes.  Returns TRUE if the resize was
                                  successful; otherwise returns FALSE (use
                                  GetLastError for error code)

                Trim()          - force block to occupy no more storage
                                  than the client has requested.

    PARENT:

**************************************************************************/

class BUFFER
{
private:
    BYTE *  _pb;        // pointer to storage
    UINT    _cb;        // size of storage, as requested by client

    inline VOID VerifyState() const;

    UINT QueryActualSize();
    dllexp BOOL GetNewStorage( UINT cbRequested );
    BOOL ReallocStorage( UINT cbNewlyRequested );

public:
    dllexp BUFFER( UINT cbRequested = 0 )
    {
        _pb = NULL;
        _cb = 0;

        if ( cbRequested != 0 )
        {
            GetNewStorage(cbRequested);
        }
    }

    dllexp ~BUFFER()
    {
        if ( _pb )
        {
            ::LocalFree( (HANDLE) _pb );
        }
    }

    dllexp VOID * QueryPtr() const
        { return _pb; }

    dllexp UINT QuerySize() const
        { return _cb; }

    //
    //  If a resize is needed, added cbSlop to it
    //

    dllexp BOOL Resize( UINT cbNewReqestedSize,
                        UINT cbSlop = 0);

    // The following method deals with the difference between the
    // actual memory size and the requested size.  These methods are
    // intended to be used when optimization is key.
    // Trim reallocates the buffer so that the actual space allocated is
    // minimally more than the size requested
    //
    dllexp VOID Trim();
};

//
//  This class is a single item in a chain of buffers
//

class BUFFER_CHAIN_ITEM : public BUFFER
{

friend class BUFFER_CHAIN;

public:
    dllexp BUFFER_CHAIN_ITEM( UINT cbReq = 0 )
      : BUFFER( cbReq ),
        _cbUsed( 0 )
        { _ListEntry.Flink = NULL; }

    dllexp ~BUFFER_CHAIN_ITEM()
        { if ( _ListEntry.Flink )
              RemoveEntryList( &_ListEntry );
        }

    dllexp DWORD QueryUsed( VOID ) const
        { return _cbUsed; }

    dllexp VOID SetUsed( DWORD cbUsed )
        { _cbUsed = cbUsed; }

private:
    LIST_ENTRY _ListEntry;
    DWORD      _cbUsed;     // Bytes of valid data in this buffer
};

class BUFFER_CHAIN
{
public:
    dllexp BUFFER_CHAIN()
        { InitializeListHead( &_ListHead ); }

    dllexp ~BUFFER_CHAIN()
        { DeleteChain(); }

    dllexp BOOL AppendBuffer( BUFFER_CHAIN_ITEM * pBCI );

    //
    //  Returns total number of bytes freed by deleting all of the buffer
    //  chain items
    //

    dllexp DWORD DeleteChain();

    //
    //  Enums buffer chain.  Pass pBCI as NULL on first call, pass return
    //  value till NULL on subsequent calls
    //

    dllexp BUFFER_CHAIN_ITEM * NextBuffer( BUFFER_CHAIN_ITEM * pBCI );

    //
    //  Gives back total number of bytes allocated by chain (includes unused
    //  bytes)
    //

    dllexp DWORD CalcTotalSize( BOOL fUsed = FALSE ) const;

private:

    LIST_ENTRY _ListHead;

};

#endif  /* _INC_BUFFER */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\inc\cdlg.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    cdlg.h

Abstract:

    Imitation of MFC CDialog class

Author:

    Vlad Sadovsky   (vlads) 26-Mar-1997

Revision History:

    26-Mar-1997     VladS       created

--*/

#ifndef _CDLG_H
#define _CDLG_H

#define ID_TIMER_EVENT  1000

class CDlg
{
public:
    void SetInstance(HINSTANCE hInst);
    void SetDlgID(UINT id);
    void Destroy();

    CDlg(int DlgID, HWND hWndParent, HINSTANCE hInst,UINT   msElapseTimePeriod=0);
    ~CDlg();

    HWND GetWindow() const { return m_hDlg; }
    HWND GetParent() const { return ::GetParent(m_hDlg); }
    HWND GetDlgItem(int iD) const { return ::GetDlgItem(m_hDlg,iD); }
    HINSTANCE GetInstance() const { return m_Inst;}
    UINT_PTR GetTimerId(VOID) const {return m_uiTimerId;}
    BOOL EndDialog(int iRet) { return ::EndDialog(m_hDlg,iRet); }

    // If you want your own dlg proc.
    INT_PTR CreateModal();
    HWND    CreateModeless();

    virtual BOOL CALLBACK DlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
    virtual int OnCommand(UINT id,HWND    hwndCtl, UINT codeNotify);
    virtual void OnInit();
    virtual int OnNotify(NMHDR * pHdr);

private:
    BOOL m_bCreatedModeless;
    void SetWindow(HWND hDlg) { m_hDlg=hDlg; }
    int             m_DlgID;
    HWND            m_hDlg;
    HWND            m_hParent;
    HINSTANCE       m_Inst;
    UINT            m_msElapseTimePeriod;
    UINT_PTR        m_uiTimerId;

protected:
    static INT_PTR CALLBACK BaseDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam);
};


#endif  // _CDLG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\inc\coredbg.h ===
#pragma once
// this is incompatible with stidebug.h, so don't include stidebug.h
#define _STIDEBUG_H_ 
#undef ASSERT
#undef REQUIRE
#undef DPRINTF
#undef DPRINTF2
#undef DPRINTF_NOINFO

//
// predefined bits in debug flags
//

// something is really wrong, should not go unnoticed
#define COREDBG_ERRORS                  0x00000001

// something that may be of interest to debugging person
#define COREDBG_WARNINGS                0x00000002

// trace random low-priority things with DBG_TRC
#define COREDBG_TRACES                  0x00000004

// trace function entries, exits (if so equipped) 
// with DBG_FN
#define COREDBG_FNS                     0x00000008

// break on errors
#define COREDBG_BREAK_ON_ERRORS         0x80000000

// log to file (default) 
#define COREDBG_DONT_LOG_TO_FILE        0x40000000

// log to debugger (default)
#define COREDBG_DONT_LOG_TO_DEBUGGER    0x20000000


// debug log is saved to this file 
#define COREDBG_FILE_NAME "%systemroot%\\wiadebug.log"
// registry key location
#define COREDBG_FLAGS_REGKEY "System\\CurrentControlSet\\Control\\StillImage\\Debug"
// registry DWORD value name
#define COREDBG_FLAGS_REGVAL "DebugFlags"
// registry DWORD for max log file size
#define COREDBG_REGVAL_FILE_SIZE_LIMIT "DebugFileSizeLimit"
#define COREDBG_FILE_SIZE_LIMIT (512 * 1024) // bytes

#ifdef DEBUG
// by default log errors only in debug builds
#define COREDBG_DEFAULT_FLAGS COREDBG_ERRORS
#else
// by default log errors only in free builds
#define COREDBG_DEFAULT_FLAGS COREDBG_ERRORS
#endif

/****************************************************************************

HOW TO USE WIA CORE DEBUG (main macros)
======================================

- DBG_INIT(hInstance)
  Call from WinMain or DllMain to enable debug flags on a per module
  basis.  If you don't call it, all DLLs will inherit the debug flags
  of the process that creates them.

- DBG_ERR(("Something happened, hr = 0x%x", hr));
  Use when an error condition occurred.
  
- DBG_WRN(("Warning, something happening, Value=%d", iValue));
  Use in a situation warranting a warning.
  
- DBG_TRC(("Random trace statement, Value=%s", szValue));
  Use sparingly to trace certain parts of your code.  Minimize spew!!!
  
- DBG_PRT(("Output without standard File,Line,ThreadID info, Value=%d", iValue));
  Same as DBG_TRC, but doesn't output the File,Line,ThreadID line.  
  ***Use this only if you are doing some special formatting (use sparingly)***
  
- DBG_FN(FnName)
  Tracks entry and exits from a given scope.
  
- CHECK_NOERR   (VarName)
  CHECK_NOERR2  (VarName, (YourMsg,...))
  Does GetLastError and if not 0, outputs error.
    
- CHECK_S_OK    (hr)
  CHECK_S_OK2   (hr, (YourMsg,...))
  Checks if hr == S_OK, if not, outputs error.
    
- CHECK_SUCCESS (lResult)
  CHECK_SUCCESS2(lResult, (YourMsg,...))
  Checks if lResult == ERROR_SUCCESS, if not, outputs error.
    
- REQUIRE_NOERR   (VarName)
  REQUIRE_NOERR2  (VarName, (YourMsg,...))
  Same as equivalent CHECK_* macros above, but calls "goto Cleanup" as well
  
- REQUIRE_S_OK    (hr)
  REQUIRE_S_OK2   (hr, (YourMsg,...))
  Same as equivalent CHECK_* macros above, but calls "goto Cleanup" as well
  
- REQUIRE_SUCCESS (lResult)
  REQUIRE_SUCCESS2(lResult, (YourMsg,...))
  Same as equivalent CHECK_* macros above, but calls "goto Cleanup" as well    
  
HOW TO TURN ON WIA CORE DEBUG (3 ways)
======================================

1) Set registry HKLM\System\CurrentControlSet\Control\StillImage\Debug\<ModuleName>, 
   DWORD value "DebugFlags" to an OR'd value of above COREDBG_* flags.  
   Need to restart app to pick up new settings. Key is auto created the first time
   the app is run.  (Note: <ModuleName> above is the name 
   of your DLL or EXE.  e.g. wiavusd.dll has a registry key of 
   "HKLM\System\CurrentControlSet\Control\StillImage\Debug\wiavusd.dll")

                            OR

2) In the debugger, set g_dwDebugFlags to OR'd value of COREDBG_* flags above.
   You can do this anytime during the debug session.
   
                            OR

3) Call in your code WIA_SET_FLAGS(COREDBG_ERRORS | COREDBG_WARNINGS | COREDBG_TRACES);
   or any combo of the COREDBG_* flags.
   
*****************************************************************************/


#define DBG_INIT(x) DINIT(x)
#define DBG_TERM()  DTERM()
#define DBG_ERR(x)  DPRINTF(COREDBG_ERRORS, x)
#define DBG_WRN(x)  DPRINTF(COREDBG_WARNINGS, x)
#define DBG_TRC(x)  DPRINTF(COREDBG_TRACES, x)
#define DBG_PRT(x)  DPRINTF_NOINFO(COREDBG_TRACES, x)
#define DBG_SET_FLAGS(x) g_dwDebugFlags = (x)

#ifdef __cplusplus
extern "C" {
#endif

    //
    // accessible to your startup code and at runtime in debugger
    // defined in wia\common\stirt\coredbg.cpp
    //
    extern DWORD  g_dwDebugFlags; 
    extern HANDLE g_hDebugFile;
    extern DWORD  g_dwDebugFileSizeLimit;
    extern BOOL   g_bDebugInited;
    void __stdcall CoreDbgTrace(LPCSTR fmt, ...);
    void __stdcall CoreDbgTraceWithTab(LPCSTR fmt, ...);
    void __stdcall CoreDbgInit(HINSTANCE hInstance);
    void __stdcall CoreDbgTerm();


#ifdef DEBUG

#define DINIT(x) CoreDbgInit(x)
#define DTERM()  CoreDbgTerm()

#define ASSERT(x) \
    if(!(x)) { \
        DWORD threadId = GetCurrentThreadId(); \
        CoreDbgTrace("WIA: [%s(%d): Thread 0x%X (%d)]", __FILE__, __LINE__, threadId, threadId, #x); \
        CoreDbgTraceWithTab("ASSERT FAILED. '%s'", #x); \
        DebugBreak(); \
    }

    
#define VERIFY(x) ASSERT(x)
#define REQUIRE(x) ASSERT(x)
    
#define DPRINTF(flags, x) \
    if(!g_bDebugInited) \
    { \
        CoreDbgInit(NULL); \
    } \
    if(flags & g_dwDebugFlags) { \
        DWORD threadId = GetCurrentThreadId(); \
        CoreDbgTrace("WIA: [%s(%d): Thread 0x%X (%d)]", __FILE__, __LINE__, threadId, threadId); \
        CoreDbgTraceWithTab x; \
        if((flags & COREDBG_ERRORS) && (g_dwDebugFlags & COREDBG_BREAK_ON_ERRORS)) { \
            DebugBreak(); \
        } \
    }
    
#define DPRINTF2(flags, x, y) \
    if(!g_bDebugInited) \
    { \
        CoreDbgInit(NULL); \
    } \
    if (flags & g_dwDebugFlags) { \
        DWORD threadId = GetCurrentThreadId(); \
        CoreDbgTrace("WIA: [%s(%d): Thread 0x%X (%d)]", __FILE__, __LINE__, threadId, threadId); \
        CoreDbgTraceWithTab x; \
        CoreDbgTraceWithTab y; \
        if((flags & COREDBG_ERRORS) && (g_dwDebugFlags & COREDBG_BREAK_ON_ERRORS)) { \
            DebugBreak(); \
        } \
    }
    
#define DPRINTF_NOINFO(flags, x) \
    if(!g_bDebugInited) \
    { \
        CoreDbgInit(NULL); \
    } \
    if (flags & g_dwDebugFlags) { \
        CoreDbgTraceWithTab x; \
        if((flags & COREDBG_ERRORS) && (g_dwDebugFlags & COREDBG_BREAK_ON_ERRORS)) { \
            DebugBreak(); \
        } \
    }

#ifdef __cplusplus
#define DBG_FN(x) CoreDbgFn __CoreDbgFnObject(#x)
#else
#define DBG_FN(x) 
#endif
        

#else // begin NODEBUG

#define DINIT(x) CoreDbgInit(x)
#define DTERM()  CoreDbgTerm()
#define ASSERT(x) 
#define VERIFY(x) x
#define REQUIRE(x) x    

#define DPRINTF(flags, x) \
    if(!g_bDebugInited) \
    { \
        CoreDbgInit(NULL); \
    } \
    if(flags & g_dwDebugFlags) { \
        CoreDbgTraceWithTab x; \
    }
    
#define DPRINTF2(flags, x, y) \
    if(!g_bDebugInited) \
    { \
        CoreDbgInit(NULL); \
    } \
    if(flags & g_dwDebugFlags) { \
        CoreDbgTraceWithTab x; \
        CoreDbgTraceWithTab y; \
    }

#define DPRINTF_NOINFO(flags, x) \
    if(!g_bDebugInited) \
    { \
        CoreDbgInit(NULL); \
    } \
    if(flags & g_dwDebugFlags) { \
        CoreDbgTraceWithTab x; \
    }

#ifdef __cplusplus
#define DBG_FN(x) CoreDbgFn __CoreDbgFnObject(#x)
#else
#define DBG_FN(x) 
#endif

#endif // end NODEBUG

#define COREDBG_MFMT_FLAGS (FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM | \
    FORMAT_MESSAGE_MAX_WIDTH_MASK)

#define REQUIRE_NOERR(x) \
    if(!(x)) { \
        DWORD __dwCoreDbgLastError = GetLastError(); \
        CHAR szError[80]; \
        if(!FormatMessageA(COREDBG_MFMT_FLAGS, NULL, __dwCoreDbgLastError, 0, szError, 80, NULL)) \
        { \
            wsprintfA(szError, "Unknown error"); \
        } \
        DBG_ERR(("ERROR: %s = %d (0x%08X), '%s'", #x, __dwCoreDbgLastError, __dwCoreDbgLastError, szError)); \
        goto Cleanup; \
    }

#define REQUIRE_NOERR2(x, y) \
    if(!(x)) { \
        DWORD __dwCoreDbgLastError = GetLastError(); \
        CHAR szError[80]; \
        if(!FormatMessageA(COREDBG_MFMT_FLAGS, NULL, __dwCoreDbgLastError, 0, szError, 80, NULL)) \
        { \
            wsprintfA(szError, "Unknown error"); \
        } \
        DPRINTF2(COREDBG_ERRORS, ("ERROR: %s = %d (0x%08X), '%s'", #x, __dwCoreDbgLastError, __dwCoreDbgLastError, szError), y); \
        goto Cleanup; \
    }
    
#define REQUIRE_S_OK(x) { \
    HRESULT __hrCoreDbg = S_OK; \
    __hrCoreDbg = (x); \
    if(__hrCoreDbg != S_OK) { \
        CHAR szError[80]; \
        if(!FormatMessageA(COREDBG_MFMT_FLAGS, NULL, __hrCoreDbg, 0, szError, 80, NULL)) \
        { \
            wsprintfA(szError, "Unknown hr"); \
        } \
        DBG_ERR(("ERROR: %s = 0x%08X, '%s'", #x, __hrCoreDbg, szError)); \
        goto Cleanup; \
    } \
}

#define REQUIRE_S_OK2(x,y) { \
    HRESULT __hrCoreDbg = S_OK; \
    __hrCoreDbg = (x); \
    if(__hrCoreDbg != S_OK) { \
        CHAR szError[80]; \
        if(!FormatMessageA(COREDBG_MFMT_FLAGS, NULL, __hrCoreDbg, 0, szError, 80, NULL)) \
        { \
            wsprintfA(szError, "Unknown hr"); \
        } \
        DPRINTF2(COREDBG_ERRORS, ("ERROR: %s = 0x%08X, '%s'", #x, __hrCoreDbg, szError), y); \
        goto Cleanup; \
    } \
} 

#define REQUIRE_SUCCESS(x) { \
    UINT __resultCoreDbg = (x); \
    if(__resultCoreDbg != ERROR_SUCCESS) { \
        CHAR szError[80]; \
        if(!FormatMessageA(COREDBG_MFMT_FLAGS, NULL, __resultCoreDbg, 0, szError, 80, NULL)) \
        { \
            wsprintfA(szError, "Unknown error"); \
        } \
        DBG_ERR(("ERROR: %s = 0x%08X, '%s'", #x, __resultCoreDbg, szError)); \
        goto Cleanup; \
    } \
} 

#define REQUIRE_SUCCESS2(x, y) { \
    UINT __resultCoreDbg = (x); \
    if(__resultCoreDbg != ERROR_SUCCESS) { \
        CHAR szError[80]; \
        if(!FormatMessageA(COREDBG_MFMT_FLAGS, NULL, __resultCoreDbg, 0, szError, 80, NULL)) \
        { \
            wsprintfA(szError, "Unknown error"); \
        } \
        DPRINTF2(COREDBG_ERRORS, ("ERROR: %s = 0x%08X, '%s'", #x, __resultCoreDbg, szError), y); \
        goto Cleanup; \
    } \
} 

#define CHECK_NOERR(x) \
    if(!(x)) { \
        DWORD __dwCoreDbgLastError = GetLastError(); \
        CHAR szError[80]; \
        if(!FormatMessageA(COREDBG_MFMT_FLAGS, NULL, __dwCoreDbgLastError, 0, szError, 80, NULL)) \
        { \
            wsprintfA(szError, "Unknown error"); \
        } \
        DBG_ERR(("ERROR: %s = %d (0x%08X), '%s'", #x, __dwCoreDbgLastError, __dwCoreDbgLastError, szError)); \
    }

#define CHECK_NOERR2(x, y) \
    if(!(x)) { \
        DWORD __dwCoreDbgLastError = GetLastError(); \
        CHAR szError[80]; \
        if(!FormatMessageA(COREDBG_MFMT_FLAGS, NULL, __dwCoreDbgLastError, 0, szError, 80, NULL)) \
        { \
            wsprintfA(szError, "Unknown error", __dwCoreDbgLastError, __dwCoreDbgLastError); \
        } \
        DPRINTF2(COREDBG_ERRORS, ("ERROR: %s = %d (0x%08X), '%s'", #x, __dwCoreDbgLastError, szError), y); \
    }

#define CHECK_S_OK(x) { \
    HRESULT __hrCoreDbg = S_OK; \
    __hrCoreDbg = (x); \
    if(__hrCoreDbg != S_OK) { \
        CHAR szError[80]; \
        if(!FormatMessageA(COREDBG_MFMT_FLAGS, NULL, __hrCoreDbg, 0, szError, 80, NULL)) \
        { \
            wsprintfA(szError, "Unknown hr"); \
        } \
        DBG_ERR(("ERROR: %s = 0x%08X, '%s'", #x, __hrCoreDbg, szError)); \
    } \
}

#define CHECK_S_OK2(x,y) { \
    HRESULT __hrCoreDbg = S_OK; \
    __hrCoreDbg = (x); \
    if(__hrCoreDbg != S_OK) { \
        CHAR szError[80]; \
        if(!FormatMessageA(COREDBG_MFMT_FLAGS, NULL, __hrCoreDbg, 0, szError, 80, NULL)) \
        { \
            wsprintfA(szError, "Unknown hr"); \
        } \
        DPRINTF2(COREDBG_ERRORS, ("ERROR: %s = 0x%08X, '%s'", #x, __hrCoreDbg, szError), y); \
    } \
}

#define CHECK_SUCCESS(x) { \
    UINT __resultCoreDbg = (x); \
    if(__resultCoreDbg != ERROR_SUCCESS) { \
        CHAR szError[80]; \
        if(!FormatMessageA(COREDBG_MFMT_FLAGS, NULL, __resultCoreDbg, 0, szError, 80, NULL)) \
        { \
            wsprintfA(szError, "Unknown error"); \
        } \
        DBG_ERR(("ERROR: %s = 0x%08X, '%s'", #x, __resultCoreDbg, szError)); \
    } \
} 

#define CHECK_SUCCESS2(x, y) { \
    UINT __resultCoreDbg = (x); \
    if(__resultCoreDbg != ERROR_SUCCESS) { \
        CHAR szError[80]; \
        if(!FormatMessageA(COREDBG_MFMT_FLAGS, NULL, __resultCoreDbg, 0, szError, 80, NULL)) \
        { \
            wsprintfA(szError, "Unknown error"); \
        } \
        DPRINTF2(COREDBG_ERRORS, ("ERROR: %s = 0x%08X, '%s'", #x, __resultCoreDbg, szError), y); \
    } \
} 

#ifdef __cplusplus
    class CoreDbgFn {
    private:
        LPCSTR m_fn;
        DWORD m_threadId;
    public:

        CoreDbgFn(LPCSTR fn)
        { 
            m_fn = fn;
            m_threadId = GetCurrentThreadId();
            if(!g_bDebugInited) 
            {
                CoreDbgInit(NULL);
            }
            if(g_dwDebugFlags & COREDBG_FNS) 
            {
                CoreDbgTraceWithTab("WIA: Thread 0x%X (%d) Entering %s", m_threadId, m_threadId, m_fn);
            }
        } 
        
        ~CoreDbgFn() 
        { 
            if(g_dwDebugFlags & COREDBG_FNS) 
            {
                CoreDbgTraceWithTab("WIA: Thread 0x%X (%d) Leaving  %s", m_threadId, m_threadId, m_fn); 
            }
        }
    };
#endif



#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\inc\debug.h ===
/***************************************************************************
 *
 *  Copyright (C) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       debug.h
 *  Content:    debugging macros and prototypes
 *@@BEGIN_MSINTERNAL
 *
 *  History:
 *
 *   10/27/96   vlads   Loosely based on somebody's else debugging support
 *
 *@@END_MSINTERNAL
 *
 *  THIS CODE AND INFORMATION IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY
 *  KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE
 *  IMPLIED WARRANTIES OF MERCHANTABILITY AND/OR FITNESS FOR A PARTICULAR
 *  PURPOSE.
 *
 ***************************************************************************/

#ifndef _INC_DEBUG
#define _INC_DEBUG

#ifdef __cplusplus
extern "C"
{
#endif

#ifdef MAXDEBUG
    #define RD(x)       x
    #ifdef DEBUG
        #define D(x)    x
    #else
        #define D(x)
    #endif
#else
    #define RD(x)
    #define D(x)
#endif

/*****************************************************************************
 *
 *  assert.c - Assertion stuff
 *
 *****************************************************************************/

typedef enum {
    DbgFlAlways  = 0x00000000,   /* Unconditional    */
    DbgFlDll     = 0x00000001,   /* Dll bookkeeping  */
    DbgFlFactory = 0x00000002,   /* IClassFactory    */
    DbgFlSti     = 0x00000004,   /* ISti             */
    DbgFlStiObj  = 0x00000008,   /* ISti objects     */
    DbgFlDevice  = 0x00000010,   /* Device code      */
    DbgFlUtil    = 0x10000000,   /* Misc utility fns */
    DbgFlCommon  = 0x40000000,   /* common.c         */
    DbgFlError   = 0x80000000,   /* Errors           */
} DBGFL;                         /* debug output flags       */

VOID  EXTERNAL  InitializeDebuggingSupport(VOID);
VOID  EXTERNAL  SetDebugLogFileA(CHAR *pszLogFileName);
DBGFL EXTERNAL  SetCurrentDebugFlags(DBGFL NewFlags) ;

void EXTERNAL WarnPszV(LPCSTR ptsz, ...);
void EXTERNAL DebugOutPtszV(DBGFL DebFl, LPCTSTR ptsz, ...);
int  EXTERNAL AssertPtszPtszLn(LPCTSTR ptszExpr, LPCTSTR ptszFile, int iLine);

#ifndef DEBUG
#define DebugOutPtszV  1?(void)0 : (void)
#endif

#ifdef MAXDEBUG
    #define RPF WarnPszV
#else
    #define WarnPszV 1?(void)0 : (void)
    #define RPF 1?(void)0 : (void)
    #define iarg 0
#endif

/*****************************************************************************
 *
 *      Buffer scrambling
 *
 *      All output buffers should be scrambled on entry to any function.
 *
 *      Each output bitmask should set an unused bit randomly to ensure
 *      that callers ignore bits that aren't defined.
 *
 *****************************************************************************/

#ifdef MAXDEBUG

void EXTERNAL ScrambleBuf(LPVOID pv, UINT cb);
void EXTERNAL ScrambleBit(LPDWORD pdw, DWORD flMask);

#else

#define ScrambleBuf(pv, cb)
#define ScrambleBit(pdw, flRandom)

#endif

/*****************************************************************************
 *
 *      Procedure enter/exit tracking.
 *
 *      Start a procedure with
 *
 *      EnterProc(ProcedureName, (_ "format", arg, arg, arg, ...));
 *      EnterProcS(ProcedureName, (_ "format", arg, arg, arg, ...));
 *      EnterProcI(ProcedureName, (_ "format", arg, arg, arg, ...));
 *      EnterProcR(ProcedureName, (_ "format", arg, arg, arg, ...));
 *
 *      The format string is documented in EmitPal.
 *
 *      Suffixing an "S" indicates that the macro should not generate
 *      a procedure name because there is a formal parameter with the
 *      name s_szProc.  This is a hack.
 *
 *      Suffixing an "R" indicates that the macro should generate a
 *      procedure name in RDEBUG.
 *
 *      Suffixing an "I" indicates that the macro should emit a dummy
 *      procedure name in RDEBUG because the interface is internal.
 *
 *      End a procedure with one of the following:
 *
 *          ExitProc();
 *
 *              Procedure returns no value.
 *
 *          ExitProcX();
 *
 *              Procedure returns an arbitrary DWORD.
 *
 *          ExitOleProc();
 *
 *              Procedure returns an HRESULT (named "hres").
 *
 *          ExitOleProcPpv(ppvOut);
 *
 *              Procedure returns an HRESULT (named "hres") and, on success,
 *              puts a new object in ppvOut.
 *
 *****************************************************************************/

#define cpvArgMax   10  /* Max of 10 args per procedure */

typedef struct ARGLIST {
    LPCSTR pszProc;
    LPCSTR pszFormat;
    PV rgpv[cpvArgMax];
} ARGLIST, *PARGLIST;

void EXTERNAL ArgsPalPszV(PARGLIST pal, LPCSTR psz, ...);
void EXTERNAL EnterDbgflPszPal(DBGFL Dbgfl, LPCSTR psz, PARGLIST pal);
void EXTERNAL ExitDbgflPalHresPpv(DBGFL, PARGLIST, HRESULT, PPV);

#ifdef DEBUG_VALIDATE

extern DBGFL DbgFlCur;

#define AssertFPtsz(c, ptsz) \
        ((c) ? 0 : AssertPtszPtszLn(ptsz, TEXT(__FILE__), __LINE__))
#define ValidateF(c, arg) \
        ((c) ? 0 : (RPF arg, ValidationException(), 0))
#define ConfirmF(c) \
    ((c) ? 0 : AssertPtszPtszLn(TEXT(#c), TEXT(__FILE__), __LINE__))

#else   /* !DEBUG */

#define AssertFPtsz(c, ptsz)
#define ValidateF(c, arg)
#define ConfirmF(c)     (c)

#endif

/*
 *  CAssertF - compile-time assertion.
 */
#define CAssertF(c)     switch(0) case c: case 0:

#define _SetupEnterProc(nm)                             \
        static CHAR s_szProc[] = #nm;                   \
        ARGLIST _al[1]                                  \

#define _ _al,

#define ppvDword ((PPV)1)
#define ppvVoid  ((PPV)2)
#define ppvBool  ((PPV)3)

#define _DoEnterProc(v)                                 \
        ArgsPalPszV v;                                  \
        EnterDbgflPszPal(DbgFl, s_szProc, _al)            \

#define _EnterProc(nm, v)                               \
        _SetupEnterProc(nm);                            \
        _DoEnterProc(v)                                 \

#define _ExitOleProcPpv(ppv)                            \
        ExitDbgflPalHresPpv(DbgFl, _al, hres, (PPV)(ppv)) \

#define _ExitOleProc()                                  \
        _ExitOleProcPpv(0)                              \

#define _ExitProc()                                     \
        ExitDbgflPalHresPpv(DbgFl, _al, 0, ppvVoid)       \

#define _ExitProcX(x)                                   \
        ExitDbgflPalHresPpv(DbgFl, _al, (HRESULT)(x), ppvDword) \

#define _ExitProcF(x)                                   \
        ExitDbgflPalHresPpv(DbgFl, _al, (HRESULT)(x), ppvBool) \

#if defined(DEBUG)

#define EnterProc           _EnterProc
#define ExitOleProcPpv      _ExitOleProcPpv
#define ExitOleProc         _ExitOleProc
#define ExitProc            _ExitProc
#define ExitProcX           _ExitProcX
#define ExitProcF           _ExitProcF

#define EnterProcS(nm, v)                               \
        static CHAR s_szProc2[] = #nm;                  \
        ARGLIST _al[1];                                 \
        ArgsPalPszV v;                                  \
        EnterDbgflPszPal(DbgFl, s_szProc2, _al)           \

#define EnterProcI          _EnterProc
#define EnterProcR          _EnterProc
#define ExitOleProcPpvR     _ExitOleProcPpv
#define ExitOleProcR        _ExitOleProc
#define ExitProcR           _ExitProc
#define ExitProcXR          _ExitProcX
#define ExitProcFR          _ExitProcF

#elif defined(RDEBUG)

#define EnterProc(nm, v)
#define ExitOleProcPpv(ppv)
#define ExitOleProc()
#define ExitProc()
#define ExitProcX(x)
#define ExitProcF(x)

#define EnterProcS(nm, v)
#define EnterProcI(nm, v)   static CHAR s_szProc[] = ""
#define EnterProcR(nm, v)   static CHAR s_szProc[] = #nm
#define ExitOleProcPpvR(ppv)
#define ExitOleProcR()
#define ExitProcR()
#define ExitProcXR()
#define ExitProcFR()

#else

#define EnterProc(nm, v)
#define ExitOleProcPpv(ppv)
#define ExitOleProc()
#define ExitProc()
#define ExitProcX(x)
#define ExitProcF(x)

#define EnterProcS(nm, v)
#define EnterProcI(nm, v)
#define EnterProcR(nm, v)
#define ExitOleProcPpvR(ppv)
#define ExitOleProcR()
#define ExitProcR()
#define ExitProcXR(x)
#define ExitProcFR(x)

#endif

#define AssertF(c)      AssertFPtsz(c, TEXT(#c))


#ifdef __cplusplus
}
#endif
#endif  // _INC_DEBUG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\inc\digitaer.h ===
/*++

Copyright (c) 1997-1998  Microsoft Corporation

Module Name:

    digitaer.h

Abstract:

    FlashPoint Digita command language error codes

Notes:

    Non-portable, for use with Win32 environment.

Author:

    Vlad Sadovsky   (VladS)    11/13/1998

Environment:

    User Mode - Win32

Revision History:

    11/13/1998      VladS       Created

--*/

#pragma once

typedef     UINT    CDPERROR   ;

//
// No error detected
//
#define CDPERR_NOERROR          0

//
// Illegal command or command not implemented
//
#define CDPERR_UNIMPLEMENTED    1

//
// Protocol error
//
#define CDPERR_PROT_ERROR       2

//
// Timeout of interface
//
#define CDPERR_APPTIMEOUT       3

//
// Memory errors, corrupted image, OS errors, media read/write errors , etc
//
#define CDPERR_INTERNAL         4

//
// INvalid parameter value
//
#define CDPERR_INVALID_PARAM    5

//
// File system is full
//
#define CDPERR_FILESYS_FULL     6

//
// Specified file is not found
//
#define CDPERR_FILE_NOT_FOUND   7

//
// Image does not contain data section ( f.e. thumbnail, audio )
//
#define CDPERR_DATA_NOT_FOUND   8

//
// Unknown file type
//
#define CDPERR_INVALID_FILE_TYPE  9

//
// Unknown drive name
//
#define CDPERR_UNKNOWN_DRIVE    10

//
// Specified drive is not mounted
//
#define CDPERR_DRIVE_NOT_MOUNTED 11

//
// System is currently busy
//
#define CDPERR_SYSTEM_BUSY      12

//
// Low battery
//
#define CDPERR_BATTERY_LOW      13


#ifndef CDPERR_CANCEL_CALLBACK
//BUGBUG
#define CDPERR_CANCEL_CALLBACK  141
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\inc\digita.h ===
/*++

Copyright (c) 1997-1998  Microsoft Corporation

Module Name:

    digita.h

Abstract:

    FlashPoint Digita command language

Notes:

    Non-portable, for use with Win32 environment.

    CDP == Camera Device Protocol

    Structure types , defined in this file are used to fill protocol buffer.
    It is important to keep packing option set to single byte setting.

Author:

    Vlad Sadovsky   (VladS)    11/13/1998

Environment:

    User Mode - Win32

Revision History:

    11/13/1998      VladS       Created

--*/

#if !defined( _DIGITA_H_ )
#define _DIGITA_H_


#if _MSC_VER > 1000
#pragma once
#endif

#ifndef RC_INVOKED
#include <pshpack1.h>
#endif // RC_INVOKED

//
// Include files
//
#include <digitaer.h>

//
// Local definitions
//

#define INT16   short
#define UINT16  unsigned short


typedef INT32   TINT32 ;
typedef UINT32  TUINT32 ;
typedef INT16   TINT16;
typedef UINT16  TUINT16;
typedef UINT32  TBITFLAGS;

typedef BYTE    TPName[4];
typedef BYTE    TDOSName[16];
typedef BYTE    TString[32];


//
// Big-endian <-> little-endian Macro DEFINITIONS
//
// Camera software expects big-endian representation of numbers, so when we send
// integers from x86 to it, we need to do a swap. Same applies to all integers
// we receive from camera
//

#if defined(_X86_) || defined(_IA64_)

#define LB8(b) (b)
#define BL8(b) LB8(b)
#define LB16(w) (((INT16)(HIBYTE(w))) | ((LOBYTE(w) << 8) & 0xFF00))
#define BL16(w) LB16(w)
#define LB32(l) (((INT32)(LB16(HIWORD(l)))) | ((INT32)(LB16(LOWORD(l))) << 16))
#define BL32(l) LB32(l)

#else

#define LB8(b) (b)
#define BL8(b) (b)
#define LB16(w) (w)
#define BL16(w) (w)
#define LB32(l) (l)
#define BL32(l) (l)

#endif

//
// Protocol definitions
//
typedef struct {

    ULONG   ulLength;   // Length of the structure minus length of this field
    BYTE    bVersion;   // the version of the CDP packet
    CHAR    cReserved[3]; // reserved
    SHORT   shCommand;  // the command
    SHORT   shResult;   // the result code
} TCDPHeader;

typedef struct {
    TCDPHeader  sCDPHeader; // the header fields of the camera device protocol
    BYTE        bData[1];   // this is the start of the data to be sent with the message
} TCDP;


//
// Definitions
//
typedef enum {
    VTUInt  = 1,
    VTInt   = 2,
    VTFixed = 3,
    VTBool  = 4,
    VTBitFlags = 5,
    VTPname = 6,
    VTDOSName = 7,
    VTString = 8,
    VTUIList = 9
} TValueType;


typedef struct {
    TPName       Name;
    TValueType   Type;
    union {
        UINT    fUInt;
        INT     fInt;
        UINT    fFixed;
        BOOL    fBool;
        UINT    fBitFlags;
        TPName   fPName;
        TDOSName fDOSName;
        TString  fString;
    } Data;
    //PNameValue
}  PNameTypeValueStruct;


//
// Protocol command ranges
//

#define CDP_CMN_HOST2CAM_MIN        0x0000
#define CDP_CMN_HOST2CAM_MAX        0x5fff

#define CDP_PROD_HOST2CAM_MIN       0x6000
#define CDP_PROD_HOST2CAM_MAX       0x6FFF

#define CDP_TEST_HOST2CAM_MIN       0x7000
#define CDP_TEST_HOST2CAM_MAX       0x7FFF

#define CDP_RESRV_HOST2CAM_MIN      0x8000
#define CDP_RESRV_HOST2CAM_MAX      0xFFFF

//
// Protocol command values
//
typedef enum {
    kCDPGetProductInfo = 0x0001,
    kCDPGetImageSpecifications = 0x0002,
    kCDPGetCameraStatus = 0x0003,
    kCDPSetProductInfo = 0x0005,
    kCDPGetCameraCapabilities = 0x0010,
    kCDPGetCameraState = 0x0011,
    kCDPSetCameraState = 0x0012,
    kCDPGetCameraDefaults = 0x0013,
    kCDPSetCameraDefaults = 0x0014,
    kCDPRestoreCameraStates = 0x0015,
    kCDPGetSceneAnalysis = 0x0018,
    kCDPGetPowerMode = 0x0019,
    kCDPSetPowerMode = 0x001a,
    kCDPGetS1Mode = 0x001d,
    kCDPSetS1Mode = 0x001e,
    kCDPStartCapture = 0x0030,
    kCDPGetFileList = 0x0040,
    kCDPGetNewFileList = 0x0041,
    kCDPGetFileData = 0x0042,
    kCDPEraseFile = 0x0043,
    kCDPGetStorageStatus = 0x0044,
    kCDPSetFileData = 0x0047,
    kCDPGetFileTag = 0x0048,
    kCDPSetUserFileTag = 0x0049,
    kCDPGetClock = 0x0070,
    kCDPSetClock = 0x0071,
    kCDPGetError = 0x0078,
    kCDPGetInterfaceTimeout = 0x0090,
    kCDPSetInterfaceTimeout = 0x0091,

} TCDPHostToCameraNewCommands;


typedef enum {
    kCHNoErr = 0x0000
} TCHCommonErrorCodes;


//
// Properties names for product info
//
// Nb: defined as 4 byte-long  packed string , always in lowercase
//

#define PI_FIRMWARE         (UINT32)'fwc'
#define PI_PRODUCTTYPEINFO  (UINT32)'pti'
#define PI_IPC              (UINT32)'ipc'
#define PI_CARV             (UINT32)'carv'

//
// Public functions and types
//

//
// GetImageSpecifications
//
typedef struct {

    // CCD Specifications
    TUINT32 CCDPattern;
    TUINT32 CCDPixelsHorz;
    TUINT32 CCDPixelsVert;
    TUINT32 CCDRingPixelsHorz;
    TUINT32 CCDRingPixelsVert;
    TUINT32 BadColumns;
    TUINT32 BadPixels;

    // Thumbnail specifications
    TUINT32 ThumbnailType;
    TUINT32 ThumbnailPixelsHorz;
    TUINT32 ThumbnailPixelsVert;
    TUINT32 ThumbnailFileSize;

    // Screennail specifications
    TUINT32 ScreennailType;
    TUINT32 ScreennailPixelsHorz;
    TUINT32 ScreennailPixelsVert;

    // Focus zone specifications
    TUINT32 FocusZoneType;
    TUINT32 FocusZoneNumHorz;
    TUINT32 FocusZoneNumVert;
    TUINT32 FocusZoneOriginHorz;
    TUINT32 FocusZoneOriginVert;
    TUINT32 FocusZoneSizeHorz;
    TUINT32 FocusZoneSizeVert;

    // Exposure zone specifications
    TUINT32 ExposureZoneType;
    TUINT32 ExposureZoneNumHorz;
    TUINT32 ExposureZoneNumVert;
    TUINT32 ExposureZoneOriginHorz;
    TUINT32 ExposureZoneOriginVert;
    TUINT32 ExposureZoneSizeHorz;
    TUINT32 ExposureZoneSizeVert;

} TImageSpecifications;

//
// GetError
//
typedef struct {
    TUINT32 Date;
    TUINT32 Time;
    TINT32  ErrorCode;
    TString ErrorDescription;
} TErrorData;

//
// GetCameraState
//

//
// GetFileList
//

typedef enum {
    kFSDriveRAM         = 1 ,     // internal RAM disk
    kFSDriveRemovable   = 2       // removable disk
} TDriveType;

typedef struct {
    TUINT32     DriveNo;
    TString     PathName;
    TDOSName    DOSName;
} TFileNameStruct;

typedef struct {
    TUINT32     DriveNo;
    TString     PathName;
    TDOSName    DOSName;
    TUINT32     FileLength;
    TBITFLAGS   FileStatus;
} TFileItem;


typedef struct {
    TUINT32     Offset;         // Starting relative position of requested data
    TUINT32     Length;         // Byte count of requested data
    TUINT32     FileSize;       // Total size of the file
} TPartialTag;

typedef struct {
    TUINT32     DataSize;       // Length of data returned
    TUINT32     Height;         // Height in pixels
    TUINT32     Width;          // Width in pixels
    TUINT32     Type;           // Format of the data

    BYTE        Data[1];        // Actual data

} TThumbnailData;

#ifndef RC_INVOKED
#include <poppack.h>
#endif // RC_INVOKED

#endif // _DIGITA_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\inc\cfactory.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1997
*
*  TITLE:       CFactory.h
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        26 Dec, 1997
*
*  DESCRIPTION:
*   Declarations and definitions for Class factory.
*
*******************************************************************************/

typedef HRESULT (*FPCREATEINSTANCE)(const IID& iid, void** ppv);

// FACTORY_DATA - Information CFactory needs to create a component

typedef struct _FACTORY_DATA
{
    FPCREATEINSTANCE    CreateInstance; // Pointer to creating function.
    IClassFactory*      pIClassFactory; // Pointer to running class factory.
    DWORD               dwRegister;     // ID for running object.

    const CLSID* pclsid;                // The class ID for the component.
    const GUID*  plibid;                // Type library ID.

    // Registry strings:

    LPCTSTR szRegName;                   // Name of the component.
    LPCTSTR szProgID;                    // Program ID.
    LPCTSTR szVerIndProgID;              // Version-independent program ID.
    LPCTSTR szService;                   // Name of service.

} FACTORY_DATA, *PFACTORY_DATA;

// Class Factory

class CFactory : public IClassFactory
{
public:
	// IUnknown
	virtual HRESULT __stdcall QueryInterface(const IID& iid, void** ppv) ;
	virtual ULONG   __stdcall AddRef() ;
	virtual ULONG   __stdcall Release() ;
	
	// IClassFactory
	virtual HRESULT __stdcall CreateInstance(IUnknown* pUnknownOuter,
	                                         const IID& iid,
                                             void** ppv) ;

    virtual HRESULT __stdcall LockServer(BOOL bLock) ; 

	// Constructor - Pass pointer to data of component to create.
    CFactory(const PFACTORY_DATA pFactoryData);

	// Destructor
	~CFactory() { }

	// Static FactoryData support functions

    // Helper function for CanUnloadNow
 	static BOOL IsLocked()
		{ return (s_cServerLocks > 0) ;}

	// Functions to [un]register all components
    static HRESULT RegisterUnregisterAll(
        PFACTORY_DATA   pFactoryData,
        UINT            uiFactoryDataCount,
        BOOLEAN         bRegister,
        BOOLEAN         bOutProc);

	// Function to determine if component can be unloaded
	static HRESULT CanUnloadNow() ;

	// Out-of-process server support

    static BOOL StartFactories(
        PFACTORY_DATA   pFactoryData,
        UINT            uiFactoryDataCount);

    static void StopFactories(
        PFACTORY_DATA   pFactoryData,
        UINT            uiFactoryDataCount);

	static DWORD s_dwThreadID ;

	// Shut down the application.
	static void CloseExe()
	{
		if (CanUnloadNow() == S_OK)
		{
			::PostThreadMessage(s_dwThreadID, WM_QUIT, 0, 0) ;
		}
	}

public:
	// Reference Count
	LONG m_cRef ;

	// Pointer to information about class this factory creates
    PFACTORY_DATA m_pFactoryData;

	// Count of locks
    static LONG s_cServerLocks;

	// Module handle
    static HMODULE s_hModule;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\inc\hpojsti.h ===
/*++

Copyright (c) 1997-1998  Microsoft Corporation

Module Name:

    hpojsti.h

Abstract:


Notes:

Author:

    Vlad Sadovsky   (VladS)    6/4/1999

Environment:

    User Mode - Win32

Revision History:

    6/4/1999        VladS       Created

--*/


//
// Set packing
//
#include <pshpack8.h>

//
// Escape function codes
//

//
// Get timeout values
//
#define HPOJ_STI_GET_TIMEOUTS   1


//
// Set timeout values
//
#define HPOJ_STI_SET_TIMEOUTS   2



//
// Escape data structures
//
typedef struct _PTIMEOUTS_INFO
{
    DWORD   dwReadTimeout;
    DWORD   dwWriteTimeout;

} TIMEOUTS_INFO, *PTIMEOUTS_INFO;

EXTERN_C
INT32
WINAPI
GetScannerTimeouts(
    INT32    *puiReadTimeout,
    INT32    *puiWriteTimeout
    );

EXTERN_C
INT32
WINAPI
SetScannerTimeouts(
    INT32    uiReadTimeout,
    INT32    uiWriteTimeout
    );

//
// Reset packing
//

#include <poppack.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\inc\enum.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    enum.h

Abstract:

Author:

        Keisuke Tsuchida    (KeisukeT)    01-Jun-2000

Revision History:


--*/

#ifndef _ENUM_H_
#define _ENUM_H_


//
// Define
//


#define MONITOR_NAME            TEXT("STIMON.EXE")
#define RUNDLL32                TEXT("RUNDLL32.EXE")
#define STILL_IMAGE             TEXT("StillImage")
#define FRIENDLYNAME            TEXT("FriendlyName")
#define VENDORSETUP             TEXT("VendorSetup")
#define DEVICESECTION           TEXT("DeviceData")
#define PORTNAME                TEXT("PortName")
#define DEVICETYPE              TEXT("DeviceType")
#define DEVICESUBTYPE           TEXT("DeviceSubType")
#define CREATEFILENAME          TEXT("CreateFileName")
#define CAPABILITIES            TEXT("Capabilities")
#define EVENTS                  TEXT("Events")
#define PROPERTYPAGES           TEXT("PropertyPages")
#define VENDOR                  TEXT("Vendor")
#define UNINSTALLSECTION        TEXT("UninstallSection")
#define SUBCLASS                TEXT("SubClass")
#define ICMPROFILES             TEXT("ICMProfiles")
#define INFPATH                 TEXT("InfPath")
#define INFSECTION              TEXT("InfSection")
#define ISPNP                   TEXT("IsPnP")
#define LPTENUM                 TEXT("LptEnum")
#define ENUM                    TEXT("\\Enum")
#define PORTS                   TEXT("Ports")
#define DONT_LOAD               TEXT("don't load")
#define CONTROL_INI             TEXT("control.ini")
#define CPL_NAME                TEXT("sticpl.cpl")
#define NO                      TEXT("no")
#define LAUNCH_APP              TEXT("LaunchApplications")
#define SZ_GUID                 TEXT("GUID")
#define CONNECTION              TEXT("Connection")
#define SERIAL                  TEXT("Serial")
#define PARALLEL                TEXT("Parallel")
#define BOTH                    TEXT("Both")
#define AUTO                    TEXT("AUTO")
#define VIDEO_PATH_ID           TEXT("DShowDeviceId")
#define DEVICESECTION           TEXT("DeviceData")
#define WIAACMGR_PATH           TEXT("wiaacmgr.exe")
#define WIAACMGR_ARG            TEXT("-SelectDevice")
#define WIADEVLISTMUTEX         TEXT("WiaDeviceListMutex")
#define WIA_GUIDSTRING          TEXT("{6BDD1FC6-810F-11D0-BEC7-08002BE2092F}")

#define REGKEY_DEVICE_PARMS             TEXT("Device Parameters")
#define REGKEY_CONTROLINIFILEMAPPING    TEXT("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\IniFileMapping\\control.ini")
#define REGSTR_VAL_FRIENDLY_NAME        TEXT("FriendlyName")
#define REGSTR_VAL_FRIENDLY_NAME_A      "FriendlyName"
#define REGSTR_VAL_DEVICE_ID            TEXT("DeviceID")
#define REGSTR_VAL_DEVICE_ID_W          L"DeviceID"
#define REGSTR_VAL_DEVICE_ID_A          "DeviceID"

#define FLAG_NO_LPTENUM         1
#define ENUMLPT_HOLDTIME        3000    // in millisec

//
// Typedef
//

typedef struct _WIA_DEVPROP {

    BOOL    bIsPlugged;
    ULONG   ulProblem;
    ULONG   ulStatus;
    HKEY    hkDeviceRegistry;

} WIA_DEVPROP, *PWIA_DEVPROP;

typedef struct _WIA_DEVKEYLIST {

    DWORD           dwNumberOfDevices;
    WIA_DEVPROP     Dev[1];

} WIA_DEVKEYLIST, *PWIA_DEVKEYLIST;



//
// Prototype
//

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

PWIA_DEVKEYLIST
WiaCreateDeviceRegistryList(
    BOOL    bEnumActiveOnly
    );

VOID
WiaDestroyDeviceRegistryList(
    PWIA_DEVKEYLIST pWiaDevKeyList
    );

BOOL IsStiRegKey(
    HKEY    hkDevRegKey);

BOOL
IsPnpLptExisting(
    VOID
    );
    
VOID
EnumLpt(
    VOID
    );


#ifdef __cplusplus
}
#endif // __cplusplus



#endif // _ENUM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\inc\eventlog.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    eventlog.h

Abstract:

    This file defines functions and types required for logging events to the event logger.

Author:

    Vlad Sadovsky (vlads)   10-Jan-1997


Environment:

    User Mode - Win32

Revision History:

    26-Jan-1997     VladS       created

--*/

# ifndef _EVENTLOG_H_
# define _EVENTLOG_H_

# include <windows.h>

/***********************************************************
 *    Type Definitions
 ************************************************************/

class EVENT_LOG  {

  private:

     DWORD     m_ErrorCode;     // error code for last operation
     HANDLE    m_hEventSource;  // handle for reporting events
     LPCTSTR   m_lpszSource;    // source name for event log

  public:

     dllexp
     EVENT_LOG( IN LPCTSTR lpszSourceName);   // name of source for event log

     dllexp
    ~EVENT_LOG( VOID);

     dllexp
     VOID
     LogEvent(
        IN DWORD  idMessage,                  // id for log message
        IN WORD   cSubStrings,                // count of substrings
        IN const  CHAR * apszSubStrings[],    // substrings in the message
        IN DWORD  errCode = 0);               // error code if any

     VOID
     LogEvent(
        IN DWORD  idMessage,                  // id for log message
        IN WORD   cSubStrings,                // count of substrings
        IN CHAR * apszSubStrings[],           // substrings in the message
        IN DWORD  errCode = 0)                // error code if any
    {
        LogEvent(idMessage, cSubStrings,
                 (const CHAR **) apszSubStrings, errCode);
    }

     dllexp
     VOID
     LogEvent(
        IN DWORD   idMessage,                  // id for log message
        IN WORD    cSubStrings,                // count of substrings
        IN WCHAR * apszSubStrings[],           // substrings in the message
        IN DWORD   errCode = 0);               // error code if any

     BOOL Success( VOID) const
     { return ( m_ErrorCode == NO_ERROR); }

     DWORD GetErrorCode( VOID) const
     { return ( m_ErrorCode); }

  private:

     dllexp VOID
     LogEventPrivate(
        IN DWORD idMessage,
        IN WORD  wEventType,
        IN WORD  cSubStrings,
        IN const CHAR * apszSubStrings[],
        IN DWORD  errCode);

};

typedef EVENT_LOG * LPEVENT_LOG;

VOID
WINAPI
RegisterStiEventSources(VOID);

# endif // _EVENTLOG_H_

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\inc\linklist.h ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    linklist.h

Abstract:

    This file contains the generic doubly-linked list manipulation package
    stolen from NT & made digestible by Win95

Author:

    Vlad Sadovsky   (VladS)    11-Feb-1997

Revision History:

    VladS   02-11-97    Extracted from NT SDK headers to use on Win9x

--*/


#ifndef _LINKLIST_H_
#define _LINKLIST_H_


//
// Calculate the address of the base of the structure given its type, and an
// address of a field within the structure.
//

#ifndef CONTAINING_RECORD
#define CONTAINING_RECORD(address, type, field) ((type *)( \
                                                  (PCHAR)(address) - \
                                                  (PCHAR)(&((type *)0)->field)))
#endif  // CONTAINING_RECORD

//
//  Doubly-linked list manipulation routines.  Implemented as macros
//  but logically these are procedures.
//


//
//  VOID
//  InitializeListHead(
//      PLIST_ENTRY ListHead
//      );
//

#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))

//
//  BOOLEAN
//  IsListEmpty(
//      PLIST_ENTRY ListHead
//      );
//

#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))

//
//  PLIST_ENTRY
//  RemoveHeadList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}

//
//  PLIST_ENTRY
//  RemoveTailList(
//      PLIST_ENTRY ListHead
//      );
//

#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}

//
//  VOID
//  RemoveEntryList(
//      PLIST_ENTRY Entry
//      );
//

#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }

//
//  VOID
//  InsertTailList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }

//
//  VOID
//  InsertHeadList(
//      PLIST_ENTRY ListHead,
//      PLIST_ENTRY Entry
//      );
//

#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }


#endif  // _LINKLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\inc\cstring.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    cstring.h

Abstract:

    Extracted from MFC

Author:

Revision History:

--*/

#ifndef _CSTRING_H_
#define _CSTRING_H_

# include <ctype.h>
# include <tchar.h>
#include <stidebug.h>

#define _AFX_NO_BSTR_SUPPORT    1

#define AFX_CDECL               CDECL
#define AFXAPI                  WINAPI
#define AFX_DATA
#define AFX_DATADEF
#define DEBUG_NEW           new
#define TRACE1(s,x)         DPRINTF(DM_TRACE,s,x)
#define VERIFY              REQUIRE
#define _AFX_INLINE         inline


BOOL
AfxIsValidString(
    LPCWSTR     lpsz,
    int         nLength
    ) ;

BOOL
AfxIsValidString(
    LPCSTR  lpsz,
    int     nLength
    ) ;

BOOL
AfxIsValidAddress(
    const void* lp,
    UINT nBytes,
    BOOL bReadWrite
    );

/////////////////////////////////////////////////////////////////////////////
// Strings

#ifndef _OLEAUTO_H_
#ifdef OLE2ANSI
    typedef LPSTR BSTR;
#else
    typedef LPWSTR BSTR;// must (semantically) match typedef in oleauto.h
#endif
#endif

struct CStringData
{
    long    nRefs;     // reference count
    int     nDataLength;
    int     nAllocLength;
    // TCHAR data[nAllocLength]

    TCHAR* data()
        { return (TCHAR*)(this+1); }
};

class CString
{
public:
// Constructors
    CString();
    CString(const CString& stringSrc);
    CString(TCHAR ch, int nRepeat = 1);
    CString(LPCSTR lpsz);
    CString(LPCWSTR lpsz);
    CString(LPCTSTR lpch, int nLength);
    CString(const unsigned char* psz);

// Attributes & Operations
    // as an array of characters
    int GetLength() const;
    BOOL IsEmpty() const;
    void Empty();                       // free up the data

    TCHAR GetAt(int nIndex) const;      // 0 based
    TCHAR operator[](int nIndex) const; // same as GetAt
    void SetAt(int nIndex, TCHAR ch);
    operator LPCTSTR() const;           // as a C string

    // overloaded assignment
    const CString& operator=(const CString& stringSrc);
    const CString& operator=(TCHAR ch);
#ifdef _UNICODE
    const CString& operator=(char ch);
#endif
    const CString& operator=(LPCSTR lpsz);
    const CString& operator=(LPCWSTR lpsz);
    const CString& operator=(const unsigned char* psz);

    // string concatenation
    const CString& operator+=(const CString& string);
    const CString& operator+=(TCHAR ch);
#ifdef _UNICODE
    const CString& operator+=(char ch);
#endif
    const CString& operator+=(LPCTSTR lpsz);

    friend CString AFXAPI operator+(const CString& string1,
            const CString& string2);
    friend CString AFXAPI operator+(const CString& string, TCHAR ch);
    friend CString AFXAPI operator+(TCHAR ch, const CString& string);
#ifdef _UNICODE
    friend CString AFXAPI operator+(const CString& string, char ch);
    friend CString AFXAPI operator+(char ch, const CString& string);
#endif
    friend CString AFXAPI operator+(const CString& string, LPCTSTR lpsz);
    friend CString AFXAPI operator+(LPCTSTR lpsz, const CString& string);

    // string comparison
    int Compare(LPCTSTR lpsz) const;         // straight character
    int CompareNoCase(LPCTSTR lpsz) const;   // ignore case
    int Collate(LPCTSTR lpsz) const;         // NLS aware

    // simple sub-string extraction
    CString Mid(int nFirst, int nCount) const;
    CString Mid(int nFirst) const;
    CString Left(int nCount) const;
    CString Right(int nCount) const;

    CString SpanIncluding(LPCTSTR lpszCharSet) const;
    CString SpanExcluding(LPCTSTR lpszCharSet) const;

    // upper/lower/reverse conversion
    void MakeUpper();
    void MakeLower();
    void MakeReverse();

    // trimming whitespace (either side)
    void TrimRight();
    void TrimLeft();

    // searching (return starting index, or -1 if not found)
    // look for a single character match
    int Find(TCHAR ch) const;               // like "C" strchr
    int ReverseFind(TCHAR ch) const;
    int FindOneOf(LPCTSTR lpszCharSet) const;

    // look for a specific sub-string
    int Find(LPCTSTR lpszSub) const;        // like "C" strstr

    // simple formatting
    void AFX_CDECL Format(LPCTSTR lpszFormat, ...);
    void AFX_CDECL Format(UINT nFormatID, ...);

    // formatting for localization (uses FormatMessage API)
    void AFX_CDECL FormatMessage(LPCTSTR lpszFormat, ...);
    void AFX_CDECL FormatMessage(UINT nFormatID, ...);

    // input and output
    //friend CArchive& AFXAPI operator<<(CArchive& ar, const CString& string);
    //friend CArchive& AFXAPI operator>>(CArchive& ar, CString& string);

    // Windows support
    BOOL LoadString(UINT nID);          // load from string resource
                                        // 255 chars max
#ifndef _UNICODE
    // ANSI <-> OEM support (convert string in place)
    void AnsiToOem();
    void OemToAnsi();
#endif

#ifndef _AFX_NO_BSTR_SUPPORT
    // OLE BSTR support (use for OLE automation)
    BSTR AllocSysString() const;
    BSTR SetSysString(BSTR* pbstr) const;
#endif

    // Access to string implementation buffer as "C" character array
    LPTSTR GetBuffer(int nMinBufLength);
    void ReleaseBuffer(int nNewLength = -1);
    LPTSTR GetBufferSetLength(int nNewLength);
    void FreeExtra();

    // Use LockBuffer/UnlockBuffer to turn refcounting off
    LPTSTR LockBuffer();
    void UnlockBuffer();

// Implementation
public:
    ~CString();
    int GetAllocLength() const;

protected:
    LPTSTR m_pchData;   // pointer to ref counted string data

    // implementation helpers
    CStringData* GetData() const;
    void Init();
    void AllocCopy(CString& dest, int nCopyLen, int nCopyIndex, int nExtraLen) const;
    void AllocBuffer(int nLen);
    void AssignCopy(int nSrcLen, LPCTSTR lpszSrcData);
    void ConcatCopy(int nSrc1Len, LPCTSTR lpszSrc1Data, int nSrc2Len, LPCTSTR lpszSrc2Data);
    void ConcatInPlace(int nSrcLen, LPCTSTR lpszSrcData);
    void FormatV(LPCTSTR lpszFormat, va_list argList);
    void CopyBeforeWrite();
    void AllocBeforeWrite(int nLen);
    void Release();
    static void PASCAL Release(CStringData* pData);
    static int PASCAL SafeStrlen(LPCTSTR lpsz);
};

// Compare helpers
bool AFXAPI operator==(const CString& s1, const CString& s2);
bool AFXAPI operator==(const CString& s1, LPCTSTR s2);
bool AFXAPI operator==(LPCTSTR s1, const CString& s2);
bool AFXAPI operator!=(const CString& s1, const CString& s2);
bool AFXAPI operator!=(const CString& s1, LPCTSTR s2);
bool AFXAPI operator!=(LPCTSTR s1, const CString& s2);
bool AFXAPI operator<(const CString& s1, const CString& s2);
bool AFXAPI operator<(const CString& s1, LPCTSTR s2);
bool AFXAPI operator<(LPCTSTR s1, const CString& s2);
bool AFXAPI operator>(const CString& s1, const CString& s2);
bool AFXAPI operator>(const CString& s1, LPCTSTR s2);
bool AFXAPI operator>(LPCTSTR s1, const CString& s2);
bool AFXAPI operator<=(const CString& s1, const CString& s2);
bool AFXAPI operator<=(const CString& s1, LPCTSTR s2);
bool AFXAPI operator<=(LPCTSTR s1, const CString& s2);
bool AFXAPI operator>=(const CString& s1, const CString& s2);
bool AFXAPI operator>=(const CString& s1, LPCTSTR s2);
bool AFXAPI operator>=(LPCTSTR s1, const CString& s2);

// conversion helpers
int AFX_CDECL _wcstombsz(char* mbstr, const wchar_t* wcstr, size_t count);
int AFX_CDECL _mbstowcsz(wchar_t* wcstr, const char* mbstr, size_t count);

// Globals
//extern AFX_DATA TCHAR afxChNil;
const CString& AFXAPI AfxGetEmptyString();
#define afxEmptyString AfxGetEmptyString()

// CString
_AFX_INLINE CStringData* CString::GetData() const
    { ASSERT(m_pchData != NULL); return ((CStringData*)m_pchData)-1; }
_AFX_INLINE void CString::Init()
    { m_pchData = afxEmptyString.m_pchData; }
_AFX_INLINE CString::CString(const unsigned char* lpsz)
    { Init(); *this = (LPCSTR)lpsz; }
_AFX_INLINE const CString& CString::operator=(const unsigned char* lpsz)
    { *this = (LPCSTR)lpsz; return *this; }
#ifdef _UNICODE
_AFX_INLINE const CString& CString::operator+=(char ch)
    { *this += (TCHAR)ch; return *this; }
_AFX_INLINE const CString& CString::operator=(char ch)
    { *this = (TCHAR)ch; return *this; }
_AFX_INLINE CString AFXAPI operator+(const CString& string, char ch)
    { return string + (TCHAR)ch; }
_AFX_INLINE CString AFXAPI operator+(char ch, const CString& string)
    { return (TCHAR)ch + string; }
#endif

_AFX_INLINE int CString::GetLength() const
    { return GetData()->nDataLength; }
_AFX_INLINE int CString::GetAllocLength() const
    { return GetData()->nAllocLength; }
_AFX_INLINE BOOL CString::IsEmpty() const
    { return GetData()->nDataLength == 0; }
_AFX_INLINE CString::operator LPCTSTR() const
    { return m_pchData; }
_AFX_INLINE int PASCAL CString::SafeStrlen(LPCTSTR lpsz)
    { return (lpsz == NULL) ? 0 : lstrlen(lpsz); }

// CString support (windows specific)
_AFX_INLINE int CString::Compare(LPCTSTR lpsz) const
    { return _tcscmp(m_pchData, lpsz); }    // MBCS/Unicode aware
_AFX_INLINE int CString::CompareNoCase(LPCTSTR lpsz) const
    { return _tcsicmp(m_pchData, lpsz); }   // MBCS/Unicode aware
// CString::Collate is often slower than Compare but is MBSC/Unicode
//  aware as well as locale-sensitive with respect to sort order.
_AFX_INLINE int CString::Collate(LPCTSTR lpsz) const
    { return _tcscoll(m_pchData, lpsz); }   // locale sensitive

_AFX_INLINE TCHAR CString::GetAt(int nIndex) const
{
    ASSERT(nIndex >= 0);
    ASSERT(nIndex < GetData()->nDataLength);
    return m_pchData[nIndex];
}
_AFX_INLINE TCHAR CString::operator[](int nIndex) const
{
    // same as GetAt
    ASSERT(nIndex >= 0);
    ASSERT(nIndex < GetData()->nDataLength);
    return m_pchData[nIndex];
}
_AFX_INLINE bool AFXAPI operator==(const CString& s1, const CString& s2)
    { return s1.Compare(s2) == 0; }
_AFX_INLINE bool AFXAPI operator==(const CString& s1, LPCTSTR s2)
    { return s1.Compare(s2) == 0; }
_AFX_INLINE bool AFXAPI operator==(LPCTSTR s1, const CString& s2)
    { return s2.Compare(s1) == 0; }
_AFX_INLINE bool AFXAPI operator!=(const CString& s1, const CString& s2)
    { return s1.Compare(s2) != 0; }
_AFX_INLINE bool AFXAPI operator!=(const CString& s1, LPCTSTR s2)
    { return s1.Compare(s2) != 0; }
_AFX_INLINE bool AFXAPI operator!=(LPCTSTR s1, const CString& s2)
    { return s2.Compare(s1) != 0; }
_AFX_INLINE bool AFXAPI operator<(const CString& s1, const CString& s2)
    { return s1.Compare(s2) < 0; }
_AFX_INLINE bool AFXAPI operator<(const CString& s1, LPCTSTR s2)
    { return s1.Compare(s2) < 0; }
_AFX_INLINE bool AFXAPI operator<(LPCTSTR s1, const CString& s2)
    { return s2.Compare(s1) > 0; }
_AFX_INLINE bool AFXAPI operator>(const CString& s1, const CString& s2)
    { return s1.Compare(s2) > 0; }
_AFX_INLINE bool AFXAPI operator>(const CString& s1, LPCTSTR s2)
    { return s1.Compare(s2) > 0; }
_AFX_INLINE bool AFXAPI operator>(LPCTSTR s1, const CString& s2)
    { return s2.Compare(s1) < 0; }
_AFX_INLINE bool AFXAPI operator<=(const CString& s1, const CString& s2)
    { return s1.Compare(s2) <= 0; }
_AFX_INLINE bool AFXAPI operator<=(const CString& s1, LPCTSTR s2)
    { return s1.Compare(s2) <= 0; }
_AFX_INLINE bool AFXAPI operator<=(LPCTSTR s1, const CString& s2)
    { return s2.Compare(s1) >= 0; }
_AFX_INLINE bool AFXAPI operator>=(const CString& s1, const CString& s2)
    { return s1.Compare(s2) >= 0; }
_AFX_INLINE bool AFXAPI operator>=(const CString& s1, LPCTSTR s2)
    { return s1.Compare(s2) >= 0; }
_AFX_INLINE bool AFXAPI operator>=(LPCTSTR s1, const CString& s2)
    { return s2.Compare(s1) <= 0; }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\inc\lock.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    lock.h

Abstract:

    Portable synronization primitive class ( between Win9x and NT)
    Win9x does not

Author:

    Vlad Sadovsky (vlads)   02-Jan-1997


Environment:

    User Mode - Win32

Revision History:

    02-Jan-1997     VladS       created

--*/


# ifndef _LOCK_H_
# define _LOCK_H_

/************************************************************
 *     Include Headers
 ************************************************************/

# ifdef _cplusplus
extern "C" {
# endif // _cplusplus

# ifdef _cplusplus
}; // extern "C"
# endif // _cplusplus

#ifndef DBG_REQUIRE
#define DBG_REQUIRE REQUIRE
#endif


#ifndef RTL_RESOURCE

//
//  Shared resource function definitions. It is declared in NTRTL , but not in windows SDK header files
//

typedef struct _RTL_RESOURCE {

    //
    //  The following field controls entering and exiting the critical
    //  section for the resource
    //

    RTL_CRITICAL_SECTION CriticalSection;

    //
    //  The following four fields indicate the number of both shared or
    //  exclusive waiters
    //

    HANDLE SharedSemaphore;
    ULONG NumberOfWaitingShared;
    HANDLE ExclusiveSemaphore;
    ULONG NumberOfWaitingExclusive;

    //
    //  The following indicates the current state of the resource
    //
    //      <0 the resource is acquired for exclusive access with the
    //         absolute value indicating the number of recursive accesses
    //         to the resource
    //
    //       0 the resource is available
    //
    //      >0 the resource is acquired for shared access with the
    //         value indicating the number of shared accesses to the resource
    //

    LONG NumberOfActive;
    HANDLE ExclusiveOwnerThread;

    ULONG Flags;        // See RTL_RESOURCE_FLAG_ equates below.

    PVOID DebugInfo;
} RTL_RESOURCE, *PRTL_RESOURCE;

#define RTL_RESOURCE_FLAG_LONG_TERM     ((ULONG) 0x00000001)

#endif // RTL_RESOURCE

/************************************************************
 *   Type Definitions
 ************************************************************/

# ifdef _cplusplus
extern "C" {
# endif // _cplusplus


BOOL
InitializeResource(
    IN PRTL_RESOURCE Resource
    );


BOOL
AcquireResourceShared(
    IN PRTL_RESOURCE Resource,
    IN BOOL          Wait
    );


BOOL
AcquireResourceExclusive(
    IN PRTL_RESOURCE Resource,
    IN BOOL Wait
    );


BOOL
ReleaseResource(
    IN PRTL_RESOURCE Resource
    );


BOOL
ConvertSharedToExclusive(
    IN PRTL_RESOURCE Resource
    );


BOOL
ConvertExclusiveToShared(
    IN PRTL_RESOURCE Resource
    );


VOID
DeleteResource (
    IN PRTL_RESOURCE Resource
    );

# ifdef _cplusplus
}; // extern "C"
# endif // _cplusplus


///////////////////////////////////////////////////////////////////////
//
//  Simple RTL_RESOURCE Wrapper class
//
//////////////////////////////////////////////////////////////////////

enum SYNC_LOCK_TYPE
{
    SYNC_LOCK_READ = 0,        // Take the lock for read only
    SYNC_LOCK_WRITE            // Take the lock for write
};

enum SYNC_CONV_TYPE
{
    SYNC_CONV_READ = 0,        // Convert the lock from write to read
    SYNC_CONV_WRITE            // Convert the lock from read to write
};

class SYNC_RESOURCE
{

friend class TAKE_SYNC_RESOURCE;

public:

    SYNC_RESOURCE()
        {  InitializeResource( &_rtlres ); }

    ~SYNC_RESOURCE()
        { DeleteResource( &_rtlres ); }

    void Lock( enum SYNC_LOCK_TYPE type )
        { if ( type == SYNC_LOCK_READ ) {
              DBG_REQUIRE( AcquireResourceShared( &_rtlres, TRUE ) );
           } else {
              DBG_REQUIRE( AcquireResourceExclusive( &_rtlres, TRUE ));
           }
        }

    void Convert( enum SYNC_CONV_TYPE type )
        { if ( type == SYNC_CONV_READ ) {
              DBG_REQUIRE( ConvertExclusiveToShared( &_rtlres ));
          } else {
              DBG_REQUIRE( ConvertSharedToExclusive( &_rtlres ));
          }
        }

    void Unlock( VOID )
        { DBG_REQUIRE( ReleaseResource( &_rtlres )); }

private:
    RTL_RESOURCE _rtlres;
};


///////////////////////////////////////////////////////////////////
// Instantiate one of these classes in a block of code
// when you want that block of code to be protected
// against re-entrancy.
// The Take() and Release() functions should rarely be necessary,
// and must be used in matched pairs with Release() called first.
///////////////////////////////////////////////////////////////////

class TAKE_SYNC_RESOURCE
{
private:
    SYNC_RESOURCE& _syncres;

public:
    void Take(void) { _syncres.Lock(SYNC_LOCK_WRITE); }
    void Release(void) { _syncres.Unlock(); }
    TAKE_SYNC_RESOURCE(SYNC_RESOURCE& syncres) : _syncres(syncres) { Take(); }
    ~TAKE_SYNC_RESOURCE() { Release(); }
};

//
// Auto critical section clss
//

class CRIT_SECT
{
public:
    BOOL Lock()
    {
        if (m_bInitialized) {
            EnterCriticalSection(&m_sec);
            return TRUE;
        }
        return FALSE;
    }

    void Unlock()
    {
        LeaveCriticalSection(&m_sec);
    }

    CRIT_SECT()
    {
        m_bInitialized = FALSE;
        __try {
            #ifdef UNICODE
            if(InitializeCriticalSectionAndSpinCount(&m_sec, MINLONG)) {
            #else
            InitializeCriticalSection(&m_sec); {
            #endif
                m_bInitialized = TRUE;
            }
        }
        __except (EXCEPTION_EXECUTE_HANDLER) {
        }
    }

    ~CRIT_SECT()
    {
        if (m_bInitialized) {
            DeleteCriticalSection(&m_sec);
            m_bInitialized = FALSE;
        }
    }
    BOOL    IsInitialized() {return m_bInitialized;}

    CRITICAL_SECTION m_sec;
    BOOL       m_bInitialized;
};

class TAKE_CRIT_SECT
{
private:
    CRIT_SECT& _syncres;
    BOOL       m_bLocked;

public:
    inline TAKE_CRIT_SECT(CRIT_SECT& syncres) : _syncres(syncres), m_bLocked(FALSE) { m_bLocked = _syncres.Lock(); }
    inline ~TAKE_CRIT_SECT() { if (m_bLocked) {_syncres.Unlock(); m_bLocked = FALSE;}; }
};

//
// Auto mutex class
//

class MUTEX_OBJ
{
private:
    HANDLE m_hMutex;

public:
    BOOL inline  IsValid(VOID) {return (m_hMutex!=INVALID_HANDLE_VALUE);}
    void Lock() { ::WaitForSingleObject(m_hMutex, INFINITE); }
    void Unlock() { ::ReleaseMutex(m_hMutex); }
    MUTEX_OBJ(LPCTSTR   pszName) {
        m_hMutex = ::CreateMutex(NULL,
                                 FALSE,
                                 pszName
                                 );
    }

    ~MUTEX_OBJ() {CloseHandle(m_hMutex);m_hMutex = INVALID_HANDLE_VALUE;}
};

class TAKE_MUTEX
{
private:
    HANDLE const m_hMutex;

public:
    void Take(void) { ::WaitForSingleObject(m_hMutex, INFINITE); }
    void Release(void) { ::ReleaseMutex(m_hMutex); }
    TAKE_MUTEX(HANDLE hMutex) : m_hMutex(hMutex) { Take(); }
    ~TAKE_MUTEX() { Release(); }
};

class TAKE_MUTEX_OBJ
{
private:
    MUTEX_OBJ& _syncres;

public:
    inline TAKE_MUTEX_OBJ(MUTEX_OBJ& syncres) : _syncres(syncres) { _syncres.Lock(); }
    inline ~TAKE_MUTEX_OBJ() { _syncres.Unlock(); }
};

# endif // _LOCK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\inc\missdef.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       MISSDEF.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      KeisukeT
 *
 *  DATE:        1/14/2000
 *
 *  DESCRIPTION: Where to put definitions which should be common header file.
 *
 *******************************************************************************/
#ifndef _MISSDEF_H_INCLUDED
#define _MISSDEF_H_INCLUDED


#endif // !_MISSDEF_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\inc\makefile.inc ===
# If this is NT, define robust flag and /Oicf switch, but for Chicago platforms define
# the switch only (robust is not valid)
!ifndef CHICAGO_PRODUCT
MIDL_FLAGS=$(MIDL_FLAGS) -robust /Oicf
!else
MIDL_FLAGS=$(MIDL_FLAGS) /Oicf
!endif


$(TARGETSRCS_WIA) : $(WIA_INC_DIR)\wia.idl $(WIA_INC_DIR)\wia.acf
    midl $(MIDL_FLAGS) /I$(WIA_INC_DIR) /I$(SDK_INC_PATH) \
         /h $(O)\wia.h \
         /dlldata $(O)\wia_a.c \
         /acf wia.acf \
         /tlb $(O)\wia.tlb \
         /proxy $(O)\wia_p.c \
         /iid $(O)\wia_i.c \
         wia.idl

$(TARGETSRCS_MINI)   : $(WIA_INC_DIR)\wiamindr.idl $(WIA_INC_DIR)\wia.idl
    midl $(MIDL_FLAGS) /I$(WIA_INC_DIR) /I$(SDK_INC_PATH) \
         /h $(O)\wiamindr.h \
         /dlldata $(O)\wiamindr_a.c \
         /tlb $(O)\wiamindr.tlb \
         /proxy $(O)\wiamindr_p.c \
         /iid $(O)\wiamindr_i.c \
         wiamindr.idl

$(TARGETSRCS_WIASCRIPT) : $(WIA_INC_DIR)\wiascr.idl
    midl $(MIDL_FLAGS) /I$(WIA_INC_DIR) /I$(SDK_INC_PATH) \
         /h $(O)\wiascr.h \
         /dlldata $(O)\wiascr_a.c \
         /tlb $(O)\wiascr.tlb \
         /proxy $(O)\wiascr_p.c \
         /iid $(O)\wiascr_i.c \
         wiascr.idl

$(TARGETSRCS_PRIV) : $(WIA_INC_DIR)\wiapriv.idl
    midl $(MIDL_FLAGS) /I$(WIA_INC_DIR) /I$(SDK_INC_PATH) \
         /h $(O)\wiapriv.h \
         /dlldata $(O)\wia_a.c \
         /tlb $(O)\wiapriv.tlb \
         /proxy $(O)\wiapriv_p.c \
         /iid $(O)\wiapriv_i.c \
         wiapriv.idl

$(TARGETSRCS_VIDEO) : $(WIA_INC_DIR)\wiavideo.idl
    midl $(MIDL_FLAGS) /I$(WIA_INC_DIR) /I$(SDK_INC_PATH) \
         /h $(O)\wiavideo.h \
         /dlldata $(O)\wiavideo_a.c \
         /tlb $(O)\wiavideo.tlb \
         /proxy $(O)\wiavideo_p.c \
         /iid $(O)\wiavideo_i.c \
         wiavideo.idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\inc\scsiscan.h ===
/****************************************************************************
*
*  (C) COPYRIGHT 1996-2000, MICROSOFT CORP.
*
*  FILE:        scsiscan.h
*
*  VERSION:     1.0
*
*  DATE:        2/11/1997
*
*  DESCRIPTION:
*    IOCTL definitions for the SCSI scanner device driver.
*
*****************************************************************************/

//
// Turns off []
//
#pragma warning(disable : 4200)

#ifndef _SCSISCAN_H_
#define _SCSISCAN_H_

// SCSISCAN_CMD.SrbFlags

#define SRB_FLAGS_DISABLE_SYNCH_TRANSFER    0x00000008
#define SRB_FLAGS_DISABLE_AUTOSENSE         0x00000020
#define SRB_FLAGS_DATA_IN                   0x00000040
#define SRB_FLAGS_DATA_OUT                  0x00000080
#define SRB_FLAGS_NO_DATA_TRANSFER          0x00000000

// SCSISCAN_CMD.SrbStatus definitions

#define SRB_STATUS_PENDING                  0x00
#define SRB_STATUS_SUCCESS                  0x01
#define SRB_STATUS_ABORTED                  0x02
#define SRB_STATUS_ABORT_FAILED             0x03
#define SRB_STATUS_ERROR                    0x04
#define SRB_STATUS_BUSY                     0x05
#define SRB_STATUS_INVALID_REQUEST          0x06
#define SRB_STATUS_INVALID_PATH_ID          0x07
#define SRB_STATUS_NO_DEVICE                0x08
#define SRB_STATUS_TIMEOUT                  0x09
#define SRB_STATUS_SELECTION_TIMEOUT        0x0A
#define SRB_STATUS_COMMAND_TIMEOUT          0x0B
#define SRB_STATUS_MESSAGE_REJECTED         0x0D
#define SRB_STATUS_BUS_RESET                0x0E
#define SRB_STATUS_PARITY_ERROR             0x0F
#define SRB_STATUS_REQUEST_SENSE_FAILED     0x10
#define SRB_STATUS_NO_HBA                   0x11
#define SRB_STATUS_DATA_OVERRUN             0x12
#define SRB_STATUS_UNEXPECTED_BUS_FREE      0x13
#define SRB_STATUS_PHASE_SEQUENCE_FAILURE   0x14
#define SRB_STATUS_BAD_SRB_BLOCK_LENGTH     0x15
#define SRB_STATUS_REQUEST_FLUSHED          0x16
#define SRB_STATUS_INVALID_LUN              0x20
#define SRB_STATUS_INVALID_TARGET_ID        0x21
#define SRB_STATUS_BAD_FUNCTION             0x22
#define SRB_STATUS_ERROR_RECOVERY           0x23

#define SRB_STATUS_QUEUE_FROZEN             0x40
#define SRB_STATUS_AUTOSENSE_VALID          0x80

#define SRB_STATUS(Status) (Status & ~(SRB_STATUS_AUTOSENSE_VALID | SRB_STATUS_QUEUE_FROZEN))

typedef struct _SCSISCAN_CMD {
	ULONG   Reserved1;	
	ULONG   Size;
	ULONG   SrbFlags;				
	UCHAR   CdbLength;
	UCHAR   SenseLength;
	UCHAR	Reserved2;
	UCHAR	Reserved3;
	ULONG   TransferLength;
	UCHAR	Cdb[16];	
	PUCHAR  pSrbStatus;
	PUCHAR	pSenseBuffer;
} SCSISCAN_CMD, *PSCSISCAN_CMD;
	
// Temporarily set to 128. Should be determined by other definition.
#define MAX_STRING 128

typedef struct _SCSISCAN_INFO{
	ULONG   Size;
	ULONG   Flags;
    UCHAR   PortNumber;
    UCHAR   PathId;
    UCHAR   TargetId;
    UCHAR   Lun;
    UCHAR   AdapterName[MAX_STRING];
	ULONG   Reserved;
} SCSISCAN_INFO, *PSCSISCAN_INFO;

#define SCSISCAN_RESERVED         0x000
#define SCSISCAN_CMD_CODE         0x004
#define SCSISCAN_LOCKDEVICE       0x005
#define SCSISCAN_UNLOCKDEVICE     0x006
#define SCSISCAN_SET_TIMEOUT      0x007
#define SCSISCAN_GET_INFO         0x008

//---------------------------------------------------------------------------
// IOCTL definitions.
// Use these definitions when calling DeviceIoControl
//---------------------------------------------------------------------------
#define IOCTL_SCSISCAN_CMD		     CTL_CODE(FILE_DEVICE_SCANNER, SCSISCAN_CMD_CODE,	    METHOD_OUT_DIRECT, FILE_ANY_ACCESS)
#define IOCTL_SCSISCAN_LOCKDEVICE    CTL_CODE(FILE_DEVICE_SCANNER, SCSISCAN_LOCKDEVICE,		METHOD_OUT_DIRECT, FILE_ANY_ACCESS)
#define IOCTL_SCSISCAN_UNLOCKDEVICE  CTL_CODE(FILE_DEVICE_SCANNER, SCSISCAN_UNLOCKDEVICE,	METHOD_OUT_DIRECT, FILE_ANY_ACCESS)
#define IOCTL_SCSISCAN_SET_TIMEOUT   CTL_CODE(FILE_DEVICE_SCANNER, SCSISCAN_SET_TIMEOUT,	METHOD_BUFFERED,   FILE_ANY_ACCESS)
#define IOCTL_SCSISCAN_GET_INFO      CTL_CODE(FILE_DEVICE_SCANNER, SCSISCAN_GET_INFO   ,	METHOD_OUT_DIRECT, FILE_ANY_ACCESS)

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\inc\sti.h ===
/*++

Copyright (c) 1986-1997  Microsoft Corporation

Module Name:

    sti.h

Abstract:

    This module contains the user mode still image APIs in COM format

Revision History:


--*/

#ifndef _STICOM_
#define _STICOM_

//
// Set packing
//
#include <pshpack8.h>

//
// Only use UNICODE STI interfaces
//
#define STI_UNICODE 1

//
// Include COM definitions
//
#ifndef _NO_COM
#include <objbase.h>
#endif

#include <stireg.h>
#include <stierr.h>

//
// Compiler pragmas
//
#pragma warning(disable:4200)       // warning about zero-sized arrays being non-stadard C extension

#define DLLEXP __declspec( dllexport )

#ifdef __cplusplus
extern "C" {
#endif

#if defined( _WIN32 ) && !defined( _NO_COM)

/*
 * Class IID's
 */

// B323F8E0-2E68-11D0-90EA-00AA0060F86C
DEFINE_GUID(CLSID_Sti, 0xB323F8E0L, 0x2E68, 0x11D0, 0x90, 0xEA, 0x00, 0xAA, 0x00, 0x60, 0xF8, 0x6C);

/*
 * Interface IID's
 */

// {641BD880-2DC8-11D0-90EA-00AA0060F86C}
DEFINE_GUID(IID_IStillImageW, 0x641BD880L, 0x2DC8, 0x11D0, 0x90, 0xEA, 0x00, 0xAA, 0x00, 0x60, 0xF8, 0x6C);

// {A7B1F740-1D7F-11D1-ACA9-00A02438AD48}
DEFINE_GUID(IID_IStillImageA, 0xA7B1F740L, 0x1D7F, 0x11D1, 0xAC, 0xA9, 0x00, 0xA0, 0x24, 0x38, 0xAD, 0x48);


// {6CFA5A80-2DC8-11D0-90EA-00AA0060F86C}
DEFINE_GUID(IID_IStiDevice, 0x6CFA5A80L, 0x2DC8, 0x11D0, 0x90, 0xEA, 0x00, 0xAA, 0x00, 0x60, 0xF8, 0x6C);

/*
 * Standard event GUIDs
 */

// {740D9EE6-70F1-11d1-AD10-00A02438AD48}
DEFINE_GUID(GUID_DeviceArrivedLaunch, 0x740d9ee6, 0x70f1, 0x11d1, 0xad, 0x10, 0x0, 0xa0, 0x24, 0x38, 0xad, 0x48);

// {A6C5A715-8C6E-11d2-977A-0000F87A926F}
DEFINE_GUID(GUID_ScanImage,
0xa6c5a715, 0x8c6e, 0x11d2, 0x97, 0x7a, 0x0, 0x0, 0xf8, 0x7a, 0x92, 0x6f);

 // {B441F425-8C6E-11d2-977A-0000F87A926F}
DEFINE_GUID(GUID_ScanPrintImage,
0xb441f425, 0x8c6e, 0x11d2, 0x97, 0x7a, 0x0, 0x0, 0xf8, 0x7a, 0x92, 0x6f);


// {C00EB793-8C6E-11d2-977A-0000F87A926F}
DEFINE_GUID(GUID_ScanFaxImage,
0xc00eb793, 0x8c6e, 0x11d2, 0x97, 0x7a, 0x0, 0x0, 0xf8, 0x7a, 0x92, 0x6f);


// {C00EB795-8C6E-11d2-977A-0000F87A926F}
DEFINE_GUID(GUID_STIUserDefined1,
0xc00eb795, 0x8c6e, 0x11d2, 0x97, 0x7a, 0x0, 0x0, 0xf8, 0x7a, 0x92, 0x6f);


// {C77AE9C5-8C6E-11d2-977A-0000F87A926F}
DEFINE_GUID(GUID_STIUserDefined2,
0xc77ae9c5, 0x8c6e, 0x11d2, 0x97, 0x7a, 0x0, 0x0, 0xf8, 0x7a, 0x92, 0x6f);


// {C77AE9C6-8C6E-11d2-977A-0000F87A926F}
DEFINE_GUID(GUID_STIUserDefined3,
0xc77ae9c6, 0x8c6e, 0x11d2, 0x97, 0x7a, 0x0, 0x0, 0xf8, 0x7a, 0x92, 0x6f);

#endif

//
// Generic constants and definitions
//
#define STI_VERSION_FLAG_MASK       0xff000000
#define STI_VERSION_FLAG_UNICODE    0x01000000

#define GET_STIVER_MAJOR(dwVersion)   (HIWORD(dwVersion) & ~STI_VERSION_FLAG_MASK)
#define GET_STIVER_MINOR(dwVersion)   LOWORD(dwVersion)

#define STI_VERSION_REAL            0x00000002
#define STI_VERSION_MIN_ALLOWED     0x00000002

#ifdef UNICODE
#define STI_VERSION                 (STI_VERSION_REAL | STI_VERSION_FLAG_UNICODE)
#else
#define STI_VERSION                 (STI_VERSION_REAL)
#endif

//
// Maximum length of internal device name
//
#define STI_MAX_INTERNAL_NAME_LENGTH    128

// begin sti_device_information

//
//  Device information definitions and prototypes
// ----------------------------------------------
//

//
//  Following information is used for enumerating still image devices , currently configured
//  in the system. Presence of the device in the enumerated list does not mean availability
// of the device, it only means that device was installed at least once and had not been removed since.
//

//
// Type of device ( scanner, camera) is represented by DWORD value with
// hi word containing generic device type , and lo word containing sub-type
//
typedef enum _STI_DEVICE_MJ_TYPE {
    StiDeviceTypeDefault          = 0,
    StiDeviceTypeScanner          = 1,
    StiDeviceTypeDigitalCamera    = 2,
    StiDeviceTypeStreamingVideo   = 3
} STI_DEVICE_MJ_TYPE;

typedef DWORD STI_DEVICE_TYPE;

//
// Macros to extract device type/subtype from single type field
//
#define GET_STIDEVICE_TYPE(dwDevType)   HIWORD(dwDevType)
#define GET_STIDEVICE_SUBTYPE(dwDevType)   LOWORD(dwDevType)

//
// Device capabilities bits.
// Various capabilities are grouped into separate bitmasks
//

typedef struct _STI_DEV_CAPS {
    DWORD   dwGeneric;
} STI_DEV_CAPS, *PSTI_DEV_CAPS;

//
// Generic capabilities mask contain 16 bits , common for all devices, maintained by MS
// and 16 bits , which USD can use for proprietary capbailities reporting.
//

#define GET_STIDCOMMON_CAPS(dwGenericCaps)   LOWORD(dwGenericCaps)
#define GET_STIVENDOR_CAPS(dwGenericCaps)    HIWORD(dwGenericCaps)

#define STI_GENCAP_COMMON_MASK  (DWORD)0x00ff

//
// Notifications are supported.
// If this capability set , device can be subscribed to .
//
#define STI_GENCAP_NOTIFICATIONS    0x00000001

//
// Polling required .
// This capability is used when previous is set to TRUE. Presence of it means
// that device is not capable of issuing "truly" asyncronous notifications, but can
// be polled to determine the moment when event happened
#define STI_GENCAP_POLLING_NEEDED   0x00000002

//
// Generate event on device arrival
// If this capability is set, still image service will generate event when device
// instance is successfully initialized ( typically in response to PnP arrival)

//
// Note: on initial service enumeration events will nto be generated to avoid
// end-user confusion.
//
#define STI_GENCAP_GENERATE_ARRIVALEVENT    0x00000004

//
// Auto port selection on non-PnP buses
// This capability indicates that USD is able to detect non-PnP device on a
// bus , device is supposed to be attached to.
//
#define STI_GENCAP_AUTO_PORTSELECT   0x00000008

//
// WIA capability bit.
// This capability indicates that USD is WIA capable.
//
#define STI_GENCAP_WIA              0x00000010

//
// Subset driver bit.
// This capability indicates that there is more featured driver exists. All 
// of inbox driver has this bit set. Fully featured (IHV) driver shouldn't have
// this bit set.
//
#define STI_GENCAP_SUBSET           0x00000020

//
//
// Type of bus connection for those in need to know
//
#define STI_HW_CONFIG_UNKNOWN   0x0001
#define STI_HW_CONFIG_SCSI      0x0002
#define STI_HW_CONFIG_USB       0x0004
#define STI_HW_CONFIG_SERIAL    0x0008
#define STI_HW_CONFIG_PARALLEL  0x0010

//
// Device information structure, this is not configurable. This data is returned from
// device enumeration API and is used for populating UI or selecting which device
// should be used in current session
//
typedef struct _STI_DEVICE_INFORMATIONW {
    DWORD   dwSize;

    // Type of the hardware imaging device
    STI_DEVICE_TYPE   DeviceType;

    // Device identifier for reference when creating device object
    WCHAR   szDeviceInternalName[STI_MAX_INTERNAL_NAME_LENGTH];

    // Set of capabilities flags
    STI_DEV_CAPS   DeviceCapabilities;

    // This includes bus type
    DWORD   dwHardwareConfiguration;

    // Vendor description string
    LPWSTR    pszVendorDescription;

    // Device description , provided by vendor
    LPWSTR    pszDeviceDescription;

    // String , representing port on which device is accessible.
    LPWSTR    pszPortName;

    // Control panel propery provider
    LPWSTR    pszPropProvider;

    // Local specific ("friendly") name of the device, mainly used for showing in the UI
    LPWSTR    pszLocalName;

} STI_DEVICE_INFORMATIONW, *PSTI_DEVICE_INFORMATIONW;

typedef struct _STI_DEVICE_INFORMATIONA {
    DWORD   dwSize;

    // Type of the hardware imaging device
    STI_DEVICE_TYPE   DeviceType;

    // Device identifier for reference when creating device object
    CHAR    szDeviceInternalName[STI_MAX_INTERNAL_NAME_LENGTH];

    // Set of capabilities flags
    STI_DEV_CAPS   DeviceCapabilities;

    // This includes bus type
    DWORD   dwHardwareConfiguration;

    // Vendor description string
    LPCSTR    pszVendorDescription;

    // Device description , provided by vendor
    LPCSTR    pszDeviceDescription;

    // String , representing port on which device is accessible.
    LPCSTR    pszPortName;

    // Control panel propery provider
    LPCSTR    pszPropProvider;

    // Local specific ("friendly") name of the device, mainly used for showing in the UI
    LPCSTR    pszLocalName;

} STI_DEVICE_INFORMATIONA, *PSTI_DEVICE_INFORMATIONA;

#if defined(UNICODE) || defined(STI_UNICODE)
typedef STI_DEVICE_INFORMATIONW STI_DEVICE_INFORMATION;
typedef PSTI_DEVICE_INFORMATIONW PSTI_DEVICE_INFORMATION;
#else
typedef STI_DEVICE_INFORMATIONA STI_DEVICE_INFORMATION;
typedef PSTI_DEVICE_INFORMATIONA PSTI_DEVICE_INFORMATION;
#endif

//
// EXTENDED STI INFORMATION TO COVER WIA
//

typedef struct _STI_WIA_DEVICE_INFORMATIONW {
    DWORD   dwSize;

    // Type of the hardware imaging device
    STI_DEVICE_TYPE   DeviceType;

    // Device identifier for reference when creating device object
    WCHAR   szDeviceInternalName[STI_MAX_INTERNAL_NAME_LENGTH];

    // Set of capabilities flags
    STI_DEV_CAPS   DeviceCapabilities;

    // This includes bus type
    DWORD   dwHardwareConfiguration;

    // Vendor description string
    LPWSTR    pszVendorDescription;

    // Device description , provided by vendor
    LPWSTR    pszDeviceDescription;

    // String , representing port on which device is accessible.
    LPWSTR    pszPortName;

    // Control panel propery provider
    LPWSTR    pszPropProvider;

    // Local specific ("friendly") name of the device, mainly used for showing in the UI
    LPWSTR    pszLocalName;

    //
    // WIA values
    //

    LPWSTR    pszUiDll;
    LPWSTR    pszServer;

} STI_WIA_DEVICE_INFORMATIONW, *PSTI_WIA_DEVICE_INFORMATIONW;


typedef struct _STI_WIA_DEVICE_INFORMATIONA {
    DWORD   dwSize;

    // Type of the hardware imaging device
    STI_DEVICE_TYPE   DeviceType;

    // Device identifier for reference when creating device object
    CHAR    szDeviceInternalName[STI_MAX_INTERNAL_NAME_LENGTH];

    // Set of capabilities flags
    STI_DEV_CAPS   DeviceCapabilities;

    // This includes bus type
    DWORD   dwHardwareConfiguration;

    // Vendor description string
    LPCSTR    pszVendorDescription;

    // Device description , provided by vendor
    LPCSTR    pszDeviceDescription;

    // String , representing port on which device is accessible.
    LPCSTR    pszPortName;

    // Control panel propery provider
    LPCSTR    pszPropProvider;

    // Local specific ("friendly") name of the device, mainly used for showing in the UI
    LPCSTR    pszLocalName;

    //
    // WIA values
    //

    LPCSTR    pszUiDll;
    LPCSTR    pszServer;

} STI_WIA_DEVICE_INFORMATIONA, *PSTI_WIA_DEVICE_INFORMATIONA;


#if defined(UNICODE) || defined(STI_UNICODE)
typedef STI_WIA_DEVICE_INFORMATIONW STI_WIA_DEVICE_INFORMATION;
typedef PSTI_WIA_DEVICE_INFORMATIONW PSTI_WIA_DEVICE_INFORMATION;
#else
typedef STI_WIA_DEVICE_INFORMATIONA STI_WIA_DEVICE_INFORMATION;
typedef PSTI_WIA_DEVICE_INFORMATIONA PSTI_WIA_DEVICE_INFORMATION;
#endif


// end sti_device_information

//
// Device state information.
// ------------------------
//
// Following types  are used to inquire state characteristics of the device after
// it had been opened.
//
// Device configuration structure contains configurable parameters reflecting
// current state of the device
//
//
// Device hardware status.
//

//
// Individual bits for state acquiring  through StatusMask
//

// State of hardware as known to USD
#define STI_DEVSTATUS_ONLINE_STATE      0x0001

// State of pending events ( as known to USD)
#define STI_DEVSTATUS_EVENTS_STATE      0x0002

//
// Online state values
//
#define STI_ONLINESTATE_OPERATIONAL         0x00000001
#define STI_ONLINESTATE_PENDING             0x00000002
#define STI_ONLINESTATE_ERROR               0x00000004
#define STI_ONLINESTATE_PAUSED              0x00000008
#define STI_ONLINESTATE_PAPER_JAM           0x00000010
#define STI_ONLINESTATE_PAPER_PROBLEM       0x00000020
#define STI_ONLINESTATE_OFFLINE             0x00000040
#define STI_ONLINESTATE_IO_ACTIVE           0x00000080
#define STI_ONLINESTATE_BUSY                0x00000100
#define STI_ONLINESTATE_TRANSFERRING        0x00000200
#define STI_ONLINESTATE_INITIALIZING        0x00000400
#define STI_ONLINESTATE_WARMING_UP          0x00000800
#define STI_ONLINESTATE_USER_INTERVENTION   0x00001000
#define STI_ONLINESTATE_POWER_SAVE          0x00002000

//
// Event processing parameters
//
#define STI_EVENTHANDLING_ENABLED           0x00000001
#define STI_EVENTHANDLING_POLLING           0x00000002
#define STI_EVENTHANDLING_PENDING           0x00000004

typedef struct _STI_DEVICE_STATUS {

    DWORD   dwSize;

    // Request field - bits of status to verify
    DWORD   StatusMask;

    //
    // Fields are set when status mask contains STI_DEVSTATUS_ONLINE_STATE bit set
    //
    // Bitmask describing  device state
    DWORD   dwOnlineState;

    // Device status code as defined by vendor
    DWORD   dwHardwareStatusCode;

    //
    // Fields are set when status mask contains STI_DEVSTATUS_EVENTS_STATE bit set
    //

    // State of device notification processing (enabled, pending)
    DWORD   dwEventHandlingState;

    // If device is polled, polling interval in ms
    DWORD   dwPollingInterval;

} STI_DEVICE_STATUS,*PSTI_DEVICE_STATUS;

//
// Structure to describe diagnostic ( test ) request to be processed by USD
//

// Basic test for presence of associated hardware
#define STI_DIAGCODE_HWPRESENCE         0x00000001

//
// Status bits for diagnostic
//

//
// generic diagnostic errors
//

typedef struct _ERROR_INFOW {

    DWORD   dwSize;

    // Generic error , describing results of last operation
    DWORD   dwGenericError;

    // vendor specific error code
    DWORD   dwVendorError;

    // String, describing in more details results of last operation if it failed
    WCHAR   szExtendedErrorText[255];

} STI_ERROR_INFOW,*PSTI_ERROR_INFOW;

typedef struct _ERROR_INFOA {

    DWORD   dwSize;

    DWORD   dwGenericError;
    DWORD   dwVendorError;

    CHAR   szExtendedErrorText[255];

} STI_ERROR_INFOA,*PSTI_ERROR_INFOA;

#if defined(UNICODE) || defined(STI_UNICODE)
typedef STI_ERROR_INFOW STI_ERROR_INFO;
#else
typedef STI_ERROR_INFOA STI_ERROR_INFO;
#endif

typedef STI_ERROR_INFO* PSTI_ERROR_INFO;

typedef struct _STI_DIAG {

    DWORD   dwSize;

    // Diagnostic request fields. Are set on request by caller

    // One of the
    DWORD   dwBasicDiagCode;
    DWORD   dwVendorDiagCode;

    // Response fields
    DWORD   dwStatusMask;

    STI_ERROR_INFO  sErrorInfo;

} STI_DIAG,*LPSTI_DIAG;

//
typedef STI_DIAG    DIAG;
typedef LPSTI_DIAG  LPDIAG;


// end device state information.

//
// Flags passed to WriteToErrorLog call in a first parameter, indicating type of the message
// which needs to be logged
//
#define STI_TRACE_INFORMATION       0x00000001
#define STI_TRACE_WARNING           0x00000002
#define STI_TRACE_ERROR             0x00000004

//
// Event notification mechansims.
// ------------------------------
//
// Those are used to inform last subscribed caller of the changes in device state, initiated by
// device.
//
// The only supported discipline of notification is stack. The last caller to subscribe will be notified
// and will receive notification data. After caller unsubscribes , the previously subscribed caller will
// become active.
//

// Notifications are sent to subscriber via window message. Window handle is passed as
// parameter
#define STI_SUBSCRIBE_FLAG_WINDOW   0x0001

// Device notification is signalling Win32 event ( auto-set event). Event handle
// is passed as a parameter
#define STI_SUBSCRIBE_FLAG_EVENT    0x0002

typedef struct _STISUBSCRIBE {

    DWORD   dwSize;

    DWORD   dwFlags;

    // Not used . Will be used for subscriber to set bit mask filtering different events
    DWORD   dwFilter;

    // When STI_SUBSCRIBE_FLAG_WINDOW bit is set, following fields should be set
    // Handle of the window which will receive notification message
    HWND    hWndNotify;

    // Handle of Win32 auto-reset event , which will be signalled whenever device has
    // notification pending
    HANDLE  hEvent;

    // Code of notification message, sent to window
    UINT    uiNotificationMessage;

} STISUBSCRIBE,*LPSTISUBSCRIBE;

#define MAX_NOTIFICATION_DATA   64


//
// Structure to describe notification information
//
typedef struct _STINOTIFY {

    DWORD   dwSize;                 // Total size of the notification structure

    // GUID of the notification being retrieved
    GUID    guidNotificationCode;

    // Vendor specific notification description
    BYTE    abNotificationData[MAX_NOTIFICATION_DATA];     // USD specific

} STINOTIFY,*LPSTINOTIFY;


// end event_mechanisms

//
// STI device broadcasting
//

//
// When STI Device is being added or removed, PnP broadacst is being sent , but it is not obvious
// for application code to recognize if it is STI device and if so, what is the name of the
// device. STI subsystem will analyze PnP broadcasts and rebroadcast another message via
// BroadcastSystemMessage / WM_DEVICECHANGE / DBT_USERDEFINED .

// String passed as user defined message contains STI prefix, action and device name

#define STI_ADD_DEVICE_BROADCAST_ACTION     "Arrival"
#define STI_REMOVE_DEVICE_BROADCAST_ACTION  "Removal"

#define STI_ADD_DEVICE_BROADCAST_STRING     "STI\\" STI_ADD_DEVICE_BROADCAST_ACTION "\\%s"
#define STI_REMOVE_DEVICE_BROADCAST_STRING  "STI\\" STI_REMOVE_DEVICE_BROADCAST_ACTION "\\%s"


// end STI broadcasting


//
// Device create modes
//

// Device is being opened only for status querying and notifications receiving
#define STI_DEVICE_CREATE_STATUS         0x00000001

// Device is being opened for data transfer ( supersedes status mode)
#define STI_DEVICE_CREATE_DATA           0x00000002

#define STI_DEVICE_CREATE_BOTH           0x00000003

//
// Bit mask for legitimate mode bits, which can be used when calling CreateDevice
//
#define STI_DEVICE_CREATE_MASK           0x0000FFFF

//
// Flags controlling device enumeration
//
#define STIEDFL_ALLDEVICES             0x00000000
#define STIEDFL_ATTACHEDONLY           0x00000001

//
// Control code , sent to the device through raw control interface
//
typedef  DWORD STI_RAW_CONTROL_CODE;

//
// All raw codes below this one are reserved for future use.
//
#define STI_RAW_RESERVED    0x1000

 /*
  * COM Interfaces to STI
  */

#ifdef __cplusplus

/* 'struct' not 'class' per the way DECLARE_INTERFACE_ is defined */
interface IStillImageW;
interface IStillImageA;

interface IStiDevice;

#endif

#ifndef MIDL_PASS

//DLLEXP STDMETHODIMP StiCreateInstanceW(HINSTANCE hinst, DWORD dwVer, interface IStillImageW **ppSti, LPUNKNOWN punkOuter);
//DLLEXP STDMETHODIMP StiCreateInstanceA(HINSTANCE hinst, DWORD dwVer, interface IStillImageA **ppSti, LPUNKNOWN punkOuter);
STDMETHODIMP StiCreateInstanceW(HINSTANCE hinst, DWORD dwVer, interface IStillImageW **ppSti, LPUNKNOWN punkOuter);
STDMETHODIMP StiCreateInstanceA(HINSTANCE hinst, DWORD dwVer, interface IStillImageA **ppSti, LPUNKNOWN punkOuter);

#if defined(UNICODE) || defined(STI_UNICODE)
#define IID_IStillImage     IID_IStillImageW
#define IStillImage         IStillImageW
#define StiCreateInstance   StiCreateInstanceW
#else
#define IID_IStillImage     IID_IStillImageA
#define IStillImage         IStillImageA
#define StiCreateInstance   StiCreateInstanceA
#endif

typedef interface IStiDevice              *LPSTILLIMAGEDEVICE;

typedef interface IStillImage             *PSTI;
typedef interface IStiDevice              *PSTIDEVICE;

typedef interface IStillImageA            *PSTIA;
typedef interface IStiDeviceA             *PSTIDEVICEA;

typedef interface IStillImageW            *PSTIW;
typedef interface IStiDeviceW             *PSTIDEVICEW;

//DLLEXP STDMETHODIMP StiCreateInstance(HINSTANCE hinst, DWORD dwVer, PSTI *ppSti, LPUNKNOWN punkOuter);

/*
 * IStillImage interface
 *
 * Top level STI access interface.
 *
 */

#undef INTERFACE
#define INTERFACE IStillImageW
DECLARE_INTERFACE_(IStillImageW, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    /*** IStillImage methods ***/
    STDMETHOD(Initialize) (THIS_ HINSTANCE hinst,DWORD dwVersion) PURE;

    STDMETHOD(GetDeviceList)(THIS_ DWORD dwType,DWORD dwFlags,DWORD *pdwItemsReturned,LPVOID *ppBuffer) PURE;
    STDMETHOD(GetDeviceInfo)(THIS_ LPWSTR  pwszDeviceName, LPVOID *ppBuffer) PURE;

    STDMETHOD(CreateDevice) (THIS_ LPWSTR  pwszDeviceName, DWORD   dwMode, PSTIDEVICE *pDevice,LPUNKNOWN punkOuter) PURE;

    //
    // Device instance values. Used to associate various data with device.
    //
    STDMETHOD(GetDeviceValue)(THIS_ LPWSTR  pwszDeviceName,LPWSTR    pValueName,LPDWORD  pType,LPBYTE   pData,LPDWORD    cbData);
    STDMETHOD(SetDeviceValue)(THIS_ LPWSTR  pwszDeviceName,LPWSTR   pValueName,DWORD   Type,LPBYTE  pData,DWORD   cbData);

    //
    // For appllication started through push model launch, returns associated information
    //
    STDMETHOD(GetSTILaunchInformation)(THIS_ LPWSTR  pwszDeviceName, DWORD *pdwEventCode,LPWSTR  pwszEventName) PURE;
    STDMETHOD(RegisterLaunchApplication)(THIS_ LPWSTR  pwszAppName,LPWSTR  pwszCommandLine) PURE;
    STDMETHOD(UnregisterLaunchApplication)(THIS_ LPWSTR  pwszAppName) PURE;

    //
    // To control state of notification handling. For polled devices this means state of monitor
    // polling, for true notification devices means enabling/disabling notification flow
    // from monitor to registered applications
    //
    STDMETHOD(EnableHwNotifications)(THIS_ LPCWSTR  pwszDeviceName,BOOL bNewState) PURE;
    STDMETHOD(GetHwNotificationState)(THIS_ LPCWSTR  pwszDeviceName,BOOL *pbCurrentState) PURE;

    //
    // When device is installed but not accessible, application may request bus refresh
    // which in some cases will make device known. This is mainly used for nonPnP buses
    // like SCSI, when device was powered on after PnP enumeration
    //
    //
    STDMETHOD(RefreshDeviceBus)(THIS_ LPCWSTR  pwszDeviceName) PURE;

    //
    // Launch application to emulate event on a device. Used by "control center" style components,
    // which intercept device event , analyze and later force launch based on certain criteria.
    //
    STDMETHOD(LaunchApplicationForDevice)(THIS_ LPWSTR  pwszDeviceName,LPWSTR    pwszAppName,LPSTINOTIFY    pStiNotify);

    //
    // For non-PnP devices with non-known bus type connection, setup extension, associated with the
    // device can set it's parameters
    //
    STDMETHOD(SetupDeviceParameters)(THIS_ PSTI_DEVICE_INFORMATIONW);

    //
    // Write message to STI error log
    //
    STDMETHOD(WriteToErrorLog)(THIS_ DWORD dwMessageType,LPCWSTR pszMessage) PURE;

    #ifdef NOT_IMPLEMENTED

        //
        // TO register application for receiving various STI notifications
        //
        STIMETHOD(RegisterDeviceNotification(THIS_ LPWSTR  pwszAppName,LPSUBSCRIBE lpSubscribe) PURE;
        STIMETHOD(UnregisterDeviceNotification(THIS_ ) PURE;

    #endif //NOT_IMPLEMENTED

};

typedef struct IStillImageW *LPSTILLIMAGEW;

#undef INTERFACE
#define INTERFACE IStillImageA
DECLARE_INTERFACE_(IStillImageA, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    /*** IStillImage methods ***/
    STDMETHOD(Initialize) (THIS_ HINSTANCE hinst,DWORD dwVersion) PURE;

    STDMETHOD(GetDeviceList)(THIS_ DWORD dwType,DWORD dwFlags,DWORD *pdwItemsReturned,LPVOID *ppBuffer) PURE;
    STDMETHOD(GetDeviceInfo)(THIS_ LPCSTR  pwszDeviceName, LPVOID *ppBuffer) PURE;

    STDMETHOD(CreateDevice) (THIS_ LPCSTR  pwszDeviceName, DWORD   dwMode, PSTIDEVICE *pDevice,LPUNKNOWN punkOuter) PURE;

    //
    // Device instance values. Used to associate various data with device.
    //
    STDMETHOD(GetDeviceValue)(THIS_ LPCSTR  pwszDeviceName,LPCSTR   pValueName,LPDWORD  pType,LPBYTE   pData,LPDWORD    cbData);
    STDMETHOD(SetDeviceValue)(THIS_ LPCSTR  pwszDeviceName,LPCSTR   pValueName,DWORD   Type,LPBYTE  pData,DWORD   cbData);

    //
    // For appllication started through push model launch, returns associated information
    //
    STDMETHOD(GetSTILaunchInformation)(THIS_ LPSTR  pwszDeviceName, DWORD *pdwEventCode,LPSTR  pwszEventName) PURE;
    STDMETHOD(RegisterLaunchApplication)(THIS_ LPCSTR  pwszAppName,LPCSTR  pwszCommandLine) PURE;
    STDMETHOD(UnregisterLaunchApplication)(THIS_ LPCSTR  pwszAppName) PURE;

    //
    // To control state of notification handling. For polled devices this means state of monitor
    // polling, for true notification devices means enabling/disabling notification flow
    // from monitor to registered applications
    //
    STDMETHOD(EnableHwNotifications)(THIS_ LPCSTR  pwszDeviceName,BOOL bNewState) PURE;
    STDMETHOD(GetHwNotificationState)(THIS_ LPCSTR  pwszDeviceName,BOOL *pbCurrentState) PURE;

    //
    // When device is installed but not accessible, application may request bus refresh
    // which in some cases will make device known. This is mainly used for nonPnP buses
    // like SCSI, when device was powered on after PnP enumeration
    //
    //
    STDMETHOD(RefreshDeviceBus)(THIS_ LPCSTR  pwszDeviceName) PURE;

    //
    // Launch application to emulate event on a device. Used by "control center" style components,
    // which intercept device event , analyze and later force launch based on certain criteria.
    //
    STDMETHOD(LaunchApplicationForDevice)(THIS_ LPCSTR    pwszDeviceName,LPCSTR    pwszAppName,LPSTINOTIFY    pStiNotify);


    //
    // For non-PnP devices with non-known bus type connection, setup extension, associated with the
    // device can set it's parameters
    //
    STDMETHOD(SetupDeviceParameters)(THIS_ PSTI_DEVICE_INFORMATIONA);

    //
    // Write message to STI error log
    //
    STDMETHOD(WriteToErrorLog)(THIS_ DWORD dwMessageType,LPCSTR pszMessage) PURE;

    #ifdef NOT_IMPLEMENTED

        //
        // TO register application for receiving various STI notifications
        //
        STIMETHOD(RegisterDeviceNotification(THIS_ LPWSTR  pwszAppName,LPSUBSCRIBE lpSubscribe) PURE;
        STIMETHOD(UnregisterDeviceNotification(THIS_ ) PURE;

    #endif //NOT_IMPLEMENTED

};

typedef struct IStillImageA *LPSTILLIMAGEA;

#if defined(UNICODE) || defined(STI_UNICODE)
#define IStillImageVtbl     IStillImageWVtbl
#else
#define IStillImageVtbl     IStillImageAVtbl
#endif

typedef struct IStillImage  *LPSTILLIMAGE;

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IStillImage_QueryInterface(p,a,b)       (p)->lpVtbl->QueryInterface(p,a,b)
#define IStillImage_AddRef(p)                   (p)->lpVtbl->AddRef(p)
#define IStillImage_Release(p)                  (p)->lpVtbl->Release(p)
#define IStillImage_Initialize(p,a,b)           (p)->lpVtbl->Initialize(p,a,b)

#define IStillImage_GetDeviceList(p,a,b,c,d)    (p)->lpVtbl->GetDeviceList(p,a,b,c,d)
#define IStillImage_GetDeviceInfo(p,a,b)        (p)->lpVtbl->GetDeviceInfo(p,a,b)
#define IStillImage_CreateDevice(p,a,b,c,d)     (p)->lpVtbl->CreateDevice(p,a,b,c,d)
#define IStillImage_GetDeviceValue(p,a,b,c,d,e)           (p)->lpVtbl->GetDeviceValue(p,a,b,c,d,e)
#define IStillImage_SetDeviceValue(p,a,b,c,d,e)           (p)->lpVtbl->SetDeviceValue(p,a,b,c,d,e)
#define IStillImage_GetSTILaunchInformation(p,a,b,c)      (p)->lpVtbl->GetSTILaunchInformation(p,a,b,c)
#define IStillImage_RegisterLaunchApplication(p,a,b)      (p)->lpVtbl->RegisterLaunchApplication(p,a,b)
#define IStillImage_UnregisterLaunchApplication(p,a)      (p)->lpVtbl->UnregisterLaunchApplication(p,a)
#define IStillImage_EnableHwNotifications(p,a,b)          (p)->lpVtbl->EnableHwNotifications(p,a,b)
#define IStillImage_GetHwNotificationState(p,a,b)         (p)->lpVtbl->GetHwNotificationState(p,a,b)
#define IStillImage_RefreshDeviceBus(p,a)                 (p)->lpVtbl->RefreshDeviceBus(p,a)

#endif

/*
 * IStillImage_Device interface
 *
 * This is generic per device interface. Specialized interfaces are also
 * available
 */
#undef INTERFACE
#define INTERFACE IStiDevice
DECLARE_INTERFACE_(IStiDevice, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    /*** IStiDevice methods ***/
    STDMETHOD(Initialize) (THIS_ HINSTANCE hinst,LPCWSTR pwszDeviceName,DWORD dwVersion,DWORD  dwMode) PURE;

    STDMETHOD(GetCapabilities) (THIS_ PSTI_DEV_CAPS pDevCaps) PURE;

    STDMETHOD(GetStatus) (THIS_ PSTI_DEVICE_STATUS pDevStatus) PURE;

    STDMETHOD(DeviceReset)(THIS ) PURE;
    STDMETHOD(Diagnostic)(THIS_ LPSTI_DIAG pBuffer) PURE;

    STDMETHOD(Escape)(THIS_ STI_RAW_CONTROL_CODE    EscapeFunction,LPVOID  lpInData,DWORD   cbInDataSize,LPVOID pOutData,DWORD dwOutDataSize,LPDWORD pdwActualData) PURE ;

    STDMETHOD(GetLastError) (THIS_ LPDWORD pdwLastDeviceError) PURE;

    STDMETHOD(LockDevice) (THIS_ DWORD dwTimeOut) PURE;
    STDMETHOD(UnLockDevice) (THIS ) PURE;

    STDMETHOD(RawReadData)(THIS_ LPVOID lpBuffer,LPDWORD lpdwNumberOfBytes,LPOVERLAPPED lpOverlapped) PURE;
    STDMETHOD(RawWriteData)(THIS_ LPVOID lpBuffer,DWORD nNumberOfBytes,LPOVERLAPPED lpOverlapped) PURE;

    STDMETHOD(RawReadCommand)(THIS_ LPVOID lpBuffer,LPDWORD lpdwNumberOfBytes,LPOVERLAPPED lpOverlapped) PURE;
    STDMETHOD(RawWriteCommand)(THIS_ LPVOID lpBuffer,DWORD nNumberOfBytes,LPOVERLAPPED lpOverlapped) PURE;

    //
    // Subscription is used to enable "control center" style applications , where flow of
    // notifications should be redirected from monitor itself to another "launcher"
    //
    STDMETHOD(Subscribe)(THIS_ LPSTISUBSCRIBE lpSubsribe) PURE;
    STDMETHOD(GetLastNotificationData)(THIS_ LPSTINOTIFY   lpNotify) PURE;
    STDMETHOD(UnSubscribe)(THIS ) PURE;

    STDMETHOD(GetLastErrorInfo) (THIS_ STI_ERROR_INFO *pLastErrorInfo) PURE;
};

#if !defined(__cplusplus) || defined(CINTERFACE)
#define IStiDevice_QueryInterface(p,a,b)        (p)->lpVtbl->QueryInterface(p,a,b)
#define IStiDevice_AddRef(p)                    (p)->lpVtbl->AddRef(p)
#define IStiDevice_Release(p)                   (p)->lpVtbl->Release(p)
#define IStiDevice_Initialize(p,a,b,c,d)        (p)->lpVtbl->Initialize(p,a,b,c,d)

#define IStiDevice_GetCapabilities(p,a)         (p)->lpVtbl->GetCapabilities(p,a)
#define IStiDevice_GetStatus(p,a)               (p)->lpVtbl->GetStatus(p,a)
#define IStiDevice_DeviceReset(p)               (p)->lpVtbl->DeviceReset(p)
#define IStiDevice_LockDevice(p,a)              (p)->lpVtbl->LockDevice(p,a)
#define IStiDevice_UnLockDevice(p)              (p)->lpVtbl->UnLockDevice(p)

#define IStiDevice_Diagnostic(p,a)              (p)->lpVtbl->Diagnostic(p,a)
#define IStiDevice_Escape(p,a,b,c,d,e,f)        (p)->lpVtbl->Escape(p,a,b,c,d,e,f)
#define IStiDevice_GetLastError(p,a)            (p)->lpVtbl->GetLastError(p,a)
#define IStiDevice_RawReadData(p,a,b,c)         (p)->lpVtbl->RawReadData(p,a,b,c)
#define IStiDevice_RawWriteData(p,a,b,c)        (p)->lpVtbl->RawWriteData(p,a,b,c)
#define IStiDevice_RawReadCommand(p,a,b,c)      (p)->lpVtbl->RawReadCommand(p,a,b,c)
#define IStiDevice_RawWriteCommand(p,a,b,c)     (p)->lpVtbl->RawWriteCommand(p,a,b,c)

#define IStiDevice_Subscribe(p,a)               (p)->lpVtbl->Subscribe(p,a)
#define IStiDevice_GetNotificationData(p,a)     (p)->lpVtbl->GetNotificationData(p,a)
#define IStiDevice_UnSubscribe(p)               (p)->lpVtbl->UnSubscribe(p)

#define IStiDevice_GetLastErrorInfo(p,a)        (p)->lpVtbl->GetLastErrorInfo(p,a)

#endif

#endif  // MIDL_PASS

#ifdef __cplusplus
};
#endif

//
// Reset packing
//
#include <poppack.h>

#endif // _STICOM_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\inc\stidev.h ===
/*++

Copyright (c) 1997-1998  Microsoft Corporation

Module Name:

    stidev.h

Abstract:

    Prototypes for commonly used STI related routines

Notes:

Author:

    Vlad Sadovsky   (VladS)    9/23/1998

Environment:

    User Mode - Win32

Revision History:

    9/23/1998       VladS       Created

--*/


#ifdef __cplusplus
extern "C"{
#endif

HRESULT
VenStiGetDeviceByModelID(
                LPCTSTR lpszModelID,
                LPCTSTR lpszVendor,
                LPCTSTR lpszFriendlyName,
                LPWSTR pStiDeviceName
                );

BOOL
VenStiInitializeDeviceCache(
    VOID
    );

BOOL
VenStiTerminateDeviceCache(
    VOID
    );

HRESULT
VenStiGetDeviceInterface(
    LPWSTR      pStiDeviceName,
    PSTIDEVICE  *ppStiDevice
    );


#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\inc\stiapi.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    stiapi.h

Abstract:

    Prototypes for RPC based interface between client and server
    sides of STI

Author:

    Vlad Sadovsky   (vlads) 26-Jan-1997

Revision History:

    26-Jan-1997     VladS       created

--*/

#ifndef _STIAPI_H_
#define _STIAPI_h_

# ifdef __cplusplus
extern "C"   {
# endif // __cplusplus

#ifndef STI_DEVICE_HANDLE
typedef HANDLE STI_DEVICE_HANDLE;
#endif

//
// Custom STI monitor messages. Used by monitor internally or
// by control panel in cases when we don't want to use RPC APIs
//

#define STIMON_WINDOW_CLASS         TEXT("STIExe_Window_Class")

#define STISVC_WINDOW_CLASS         TEXT("STISvcHiddenWindow")

#define STIMON_MSG_REFRESH          WM_USER+201
#define STIMON_MSG_ADD_DEVICE       WM_USER+202
#define STIMON_MSG_REMOVE_DEVICE    WM_USER+203
#define STIMON_MSG_SET_PARAMETERS   WM_USER+204
#define STIMON_MSG_LOG_MESSAGE      WM_USER+205
#define STIMON_MSG_VISUALIZE        WM_USER+206
#define STIMON_MSG_ENABLE_NOTIFICATIONS WM_USER+207


//
// Subcommand values for main message
// Passed via wParam ( should fit WORD)
//
#define STIMON_MSG_SET_TIMEOUT      1

#define STIMON_MSG_REFRESH_REREAD   2
#define STIMON_MSG_REFRESH_SUSPEND  3
#define STIMON_MSG_REFRESH_RESUME   4
#define STIMON_MSG_REFRESH_SET_FLAG 5
#define STIMON_MSG_REFRESH_CLEAR_FLAG  6
#define STIMON_MSG_REFRESH_PURGE    7
#define STIMON_MSG_REFRESH_DEV_INFO 8


#define STIMON_MSG_NOTIF_ENABLE     1
#define STIMON_MSG_NOTIF_DISABLE    2
#define STIMON_MSG_NOTIF_QUERY      3
#define STIMON_MSG_NOTIF_SET_INACTIVE 5



//
// Bit flags for refresh message
// Passed via lParam ( should fit WORD)
//
#define STIMON_MSG_REFRESH_NEW      0x0001
#define STIMON_MSG_REFRESH_EXISTING 0x0002
#define STIMON_MSG_PURGE_REMOVED    0x0004
#define STIMON_MSG_BOOT             0x0008


//

DWORD
RpcStiApiGetVersion(
    LPCWSTR pszServer,
    DWORD   dwReserved,
    DWORD   *pdwVersion
    );

DWORD
WINAPI
RpcStiApiOpenDevice(
    IN  LPCWSTR  pszServer,
    IN  LPCWSTR  pdeviceName,
    IN  DWORD   dwMode,
    IN  DWORD   dwAccessRequired,
    IN  DWORD   dwProcessId,
    OUT STI_DEVICE_HANDLE *pHandle
    );

DWORD
WINAPI
RpcStiApiCloseDevice(
    IN  LPCWSTR       pszServer,
    IN  STI_DEVICE_HANDLE hDevice
    );

DWORD
WINAPI
RpcStiApiSubscribe(
    IN STI_DEVICE_HANDLE Handle,
    IN LPSTISUBSCRIBE    lpSubscribe
    );

DWORD
WINAPI
RpcStiApiGetLastNotificationData(
    IN  STI_DEVICE_HANDLE Handle,
    OUT LPSTINOTIFY   lpNotify
    );

DWORD
WINAPI
RpcStiApiUnSubscribe(
    IN STI_DEVICE_HANDLE Handle
    );

DWORD
WINAPI
RpcStiApiEnableHwNotifications(
    IN  LPCWSTR  pszServer,
    IN  LPCWSTR  pdeviceName,
    IN  BOOL     bNewState
    ) ;

DWORD
WINAPI
RpcStiApiGetHwNotificationState(
    IN  LPCWSTR  pszServer,
    IN  LPCWSTR  pdeviceName,
    OUT LPDWORD  pState
    );

DWORD
WINAPI
RpcStiApiLaunchApplication(
    IN  LPCWSTR  pszServer,
    IN  LPCWSTR  pdeviceName,
    IN  LPCWSTR  pAppName,
    IN  LPSTINOTIFY   pStiNotify
    );

DWORD
WINAPI
RpcStiApiLockDevice(
    IN  LPCWSTR  pdeviceName,
    IN  DWORD    dwWait,
    IN  BOOL     bInServerProcess
    );

DWORD
WINAPI
RpcStiApiUnlockDevice(
    IN  LPCWSTR  pdeviceName,
    IN  BOOL     bInServerProcess
    );

///////////////////////////////////////////////////////////////


DWORD
RpcStiApiRegisterDeviceNotification(

    );

DWORD
RpcStiApiUnregisterDeviceNotification(

    );

DWORD
RpcStiApiGetDeviceNotification(

    );

DWORD
RpcStiApiEnableDeviceNotifications(

    BOOL    fEnable
    );


DWORD
RpcStiApiEnumerateDevices(

    );

DWORD
RpcStiApiReadDeviceData(

    );

DWORD
RpcStiApiWriteDeviceData(

    );

DWORD
RpcStiApiReadDeviceCommand(

    );

DWORD
RpcStiApiWriteDeviceCommand(

    );


DWORD
RpcStiApiReadDeviceValue(

    );

DWORD
RpcStiApiWriteDeviceValue(

    );

DWORD
RpcStiApiDeviceEscape(

    );

DWORD
RpcStiApiGetDeviceStatus(

    );

DWORD
RpcStiApiGetDeviceLastError(

    );

DWORD
RpcStiApiResetDevice(

    );

VOID
WINAPI
MigrateRegisteredSTIAppsForWIAEvents(
    HWND        hWnd,
    HINSTANCE   hInst,
    PTSTR       pszCommandLine,
    INT         iParam
    );


# ifdef __cplusplus
};
# endif // __cplusplus


#endif // _STIAPI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\inc\out_stidebug.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    stidebug.h

Abstract:

    Environment independent assertion/logging routines

    Usage:

        ASSERT(exp)     Evaluates its argument.  If "exp" evals to
                        FALSE, then the app will terminate, naming
                        the file name and line number of the assertion
                        in the source.

        UIASSERT(exp)   Synonym for ASSERT.

        ASSERTSZ(exp,sz) As ASSERT, except will also print the message
                        "sz" with the assertion message should it fail.

        REQUIRE(exp)    As ASSERT, except that its expression is still
                        evaluated in retail versions.  (Other versions
                        of ASSERT disappear completely in retail builds.)

    The ASSERT macros expect a symbol _FILENAME_DEFINED_ONCE, and will
    use the value of that symbol as the filename if found; otherwise,
    they will emit a new copy of the filename, using the ANSI C __FILE__
    macro.  A client sourcefile may therefore define __FILENAME_DEFINED_ONCE
    in order to minimize the DGROUP footprint of a number of ASSERTs.

Author:

    Vlad Sadovsky   (vlads) 26-Jan-1997

Revision History:

    26-Jan-1997     VladS       created

--*/



#ifndef _STIDEBUG_H_
#define _STIDEBUG_H_

#if defined(DEBUG)
static const CHAR szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif

#if defined(__cplusplus)
extern "C"
{
#endif

VOID UIAssertHelper( const CHAR* pszFileName, UINT nLine );
VOID UIAssertSzHelper( const CHAR* pszMessage, const CHAR* pszFileName, UINT nLine );

VOID AssertHelper( const CHAR* pszFileName, UINT nLine );
VOID AssertSzHelper( const CHAR* pszMessage, const CHAR* pszFileName, UINT nLine );

#if defined(DEBUG)

# ifdef USE_MESSAGEBOX_UI

#  define ASSERT(exp) \
    { if (!(exp)) UIAssertHelper(__FILE__, __LINE__); }

#  define ASSERTSZ(exp, sz) \
    { if (!(exp)) UIAssertSzHelper((sz), __FILE__, __LINE__); }

# else

#ifndef ASSERT
#  define ASSERT(exp) \
    { if (!(exp)) AssertHelper(__FILE__, __LINE__); }
#endif

#  define ASSERTSZ(exp, sz) \
    { if (!(exp)) AssertSzHelper((sz), __FILE__, __LINE__); }

#define EVAL(exp)   \
    ((exp) || AssertHelper(__FILE__, __LINE__))

# endif // USE_MESSAGEBOX_UI

# define UIASSERT(exp)  ASSERT(exp)
# define REQUIRE(exp)   ASSERT(exp)

#else // !DEBUG

#ifndef ASSERT
# define ASSERT(exp)        ;
#endif

# define EVAL(exp)          ;
# define UIASSERT(exp)      ;
# define ASSERTSZ(exp, sz)  ;
# define REQUIRE(exp)       { (exp); }

#endif // DEBUG



//
// Debug mask management.
//

// NOTE: You can #define your own DM_* values using bits in the HI BYTE

#define DM_TRACE    0x0001      // Trace messages
#define DM_WARNING  0x0002      // Warning
#define DM_ERROR    0x0004      // Error
#define DM_ASSERT   0x0008      // Assertions
#define DM_DATA     0x0010      // Data Transfered
#define DM_INFO         0x0020      // Info we are currently interested in

#define DM_LOG_FILE 0x0100
#define DM_PREFIX   0x0200


#if !defined(StiDebugMsg)

//
// StiDebugMsg(mask, msg, args...) - Generate wsprintf-formatted msg using
// specified debug mask.  System debug mask governs whether message is output.
//

#define REGVAL_STR_DEBUGMASK_A    "DebugMask"
#define REGVAL_STR_DEBUGMASK_W    L"DebugMask"

void __cdecl StiDebugMsg(UINT mask, LPCSTR psz, ...);

UINT WINAPI  StiSetDebugParameters(PSTR pszName,PSTR pszLogFile);
UINT WINAPI  StiSetDebugMask(UINT mask);
UINT WINAPI  StiGetDebugMask(void);

#endif

#ifdef  DEBUG

#define Break()  DebugBreak()
#define DPRINTF  StiDebugMsg

#else

#define Break()

//
// Nb: Following definition is needed to avoid compiler complaining
// about empty function name in expression. In retail builds using this macro
// will cause string parameters not appear in executable
//
#define DPRINTF     1?(void)0 : (void)

#endif

#if defined(__cplusplus)
}
#endif

#if defined(__cplusplus)

#ifdef  DEBUG

class DBGTRACE
{
private:
    TCHAR   m_szMessage[200];

public:
    inline DBGTRACE(LPTSTR szMsg) {
        lstrcpy(m_szMessage,szMsg);
        DPRINTF(DM_TRACE,"ProcTraceEnter:%s",m_szMessage);
    }

    inline ~DBGTRACE() {
        DPRINTF(DM_TRACE,"ProcTraceExit:%s",m_szMessage);
    }
};


#else

class DBGTRACE
{
public:
    inline DBGTRACE(LPTSTR szMsg) {
    }

    inline ~DBGTRACE() {
    }
};
#endif

#endif

#endif // _STIDEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\inc\regentry.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    regentry.h

Abstract:

    Wrapper for registry access Win32 APIs


Usage:

    Construct a RegEntry object by specifying the subkey (under
    HKEY_CURRENT_USER by default, but can be overridden.)

    All member functions are inline so there is minimal overhead.

    All member functions (except the destructor) set an internal
    error state which can be retrieved with GetError().
    Zero indicates no error.

    RegEntry works only with strings and DWORDS which are both set
    using the overloaded function SetValue()

        SetValue("valuename", "string");
        SetValue("valuename", 42);

    Values are retrieved with GetString() and GetNumber().  GetNumber()
    allows you to specificy a default if the valuename doesn't exist.

    DeleteValue() removes the valuename and value pair.

Author:

    Vlad Sadovsky   (vlads) 26-Jan-1997

Revision History:

    26-Jan-1997     VladS       created

--*/


#ifndef REGENTRY_INC
#define REGENTRY_INC

#ifndef STRICT
#define STRICT
#endif


#include <windows.h>

class StiCString;

class RegEntry
{
    public:
        RegEntry();
        RegEntry(const TCHAR *pszSubKey, HKEY hkey = HKEY_CURRENT_USER);
        ~RegEntry();
        BOOL    Open(const TCHAR *pszSubKey, HKEY hkey = HKEY_CURRENT_USER);
        BOOL    Close();
        long    GetError()  { return m_error; }
        long    SetValue(const TCHAR *pszValue, const TCHAR *string);
        long    SetValue(const TCHAR *pszValue, const TCHAR *string, DWORD dwType);
        long    SetValue(const TCHAR *pszValue, unsigned long dwNumber);
        long    SetValue(const TCHAR *pszValue, BYTE * pValue,unsigned long dwNumber);
        TCHAR*  GetString(const TCHAR *pszValue, TCHAR *string, unsigned long length);
        VOID    GetValue(const TCHAR *pszValueName, BUFFER *pValue);
        long    GetNumber(const TCHAR *pszValue, long dwDefault = 0);
        long    DeleteValue(const TCHAR *pszValue);
        long    FlushKey();
        VOID    MoveToSubKey(const TCHAR *pszSubKeyName);
        BOOL    EnumSubKey(DWORD index, StiCString *pStrString);
        BOOL    GetSubKeyInfo(DWORD *NumberOfSubKeys, DWORD *pMaxSubKeyLength);
        HKEY    GetKey()    { return m_hkey; };
        BOOL    IsValid()   { return bhkeyValid;};

    private:
        HKEY    m_hkey;
        long    m_error;
        BOOL    bhkeyValid;
};

class RegEnumValues
{
    public:
        RegEnumValues(RegEntry *pRegEntry);
        ~RegEnumValues();
        long    Next();
        TCHAR *  GetName()       {return pchName;}
        DWORD   GetType()       {return dwType;}
        LPBYTE  GetData()       {return pbValue;}
        DWORD   GetDataLength() {return dwDataLength;}

    private:
        RegEntry * pRegEntry;
        DWORD   iEnum;
        DWORD   cEntries;
        TCHAR *  pchName;
        LPBYTE  pbValue;
        DWORD   dwType;
        DWORD   dwDataLength;
        DWORD   cMaxValueName;
        DWORD   cMaxData;
        LONG    m_error;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\inc\ptpusd.h ===
/****************************************************************************
*
*  (C) COPYRIGHT 2000, MICROSOFT CORP.
*
*  FILE:        ptpusd.h
*
*  VERSION:     1.0
*
*  DATE:        12/12/2000
*
*  AUTHOR:      Dave Parsons
*
*  DESCRIPTION:
*    Structures and constants needed to issue vendor-specific Picture
*    Transfer Protocol (PIMA 15740 - digital still camera command
*    protocol) commands through the WIA PTP driver.
*
*****************************************************************************/

//
// Pass this value in the dwEscapeCode argument of IWiaItemExtras::Escape
// to execute a PTP vendor command
//
const DWORD ESCAPE_PTP_CLEAR_STALLS   = 0x0200; 
const DWORD ESCAPE_PTP_VENDOR_COMMAND = 0x0100;
const DWORD ESCAPE_PTP_ADD_OBJ_CMD    = 0x0010;
const DWORD ESCAPE_PTP_REM_OBJ_CMD    = 0x0020;
const DWORD ESCAPE_PTP_ADD_OBJ_RESP   = 0x0040;
const DWORD ESCAPE_PTP_REM_OBJ_RESP   = 0x0080;
const DWORD ESCAPE_PTP_ADDREM_PARM1   = 0x0000;
const DWORD ESCAPE_PTP_ADDREM_PARM2   = 0x0001;
const DWORD ESCAPE_PTP_ADDREM_PARM3   = 0x0002;
const DWORD ESCAPE_PTP_ADDREM_PARM4   = 0x0003;
const DWORD ESCAPE_PTP_ADDREM_PARM5   = 0x0004;

//
// PTP command request
//
const DWORD PTP_MAX_PARAMS = 5;

#pragma pack(push, Old, 1)

typedef struct _PTP_VENDOR_DATA_IN
{
    WORD    OpCode;                 // Opcode
    DWORD   SessionId;              // Session id
    DWORD   TransactionId;          // Transaction id
    DWORD   Params[PTP_MAX_PARAMS]; // Parameters to the command
    DWORD   NumParams;              // Number of parameters passed in
    DWORD   NextPhase;              // Indicates whether to read data,
    BYTE    VendorWriteData[1];     // Optional first byte of data to
                                    // write to the device

} PTP_VENDOR_DATA_IN, *PPTP_VENDOR_DATA_IN;

//
// PTP response block
//
typedef struct _PTP_VENDOR_DATA_OUT
{
    WORD    ResponseCode;           // Response code
    DWORD   SessionId;              // Session id
    DWORD   TransactionId;          // Transaction id
    DWORD   Params[PTP_MAX_PARAMS]; // Parameters of the response
    BYTE    VendorReadData[1];      // Optional first byte of data to
                                    // read from the device

} PTP_VENDOR_DATA_OUT, *PPTP_VENDOR_DATA_OUT;

#pragma pack(pop, Old)

//
// Handy structure size constants
//
const DWORD SIZEOF_REQUIRED_VENDOR_DATA_IN = sizeof(PTP_VENDOR_DATA_IN) - 1;
const DWORD SIZEOF_REQUIRED_VENDOR_DATA_OUT = sizeof(PTP_VENDOR_DATA_OUT) - 1;

//
// NextPhase constants
//
const DWORD PTP_NEXTPHASE_READ_DATA = 3;
const DWORD PTP_NEXTPHASE_WRITE_DATA = 4;
const DWORD PTP_NEXTPHASE_NO_DATA = 5;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\inc\stidebug.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    stidebug.h

Abstract:

    Environment independent assertion/logging routines

    Usage:

        ASSERT(exp)     Evaluates its argument.  If "exp" evals to
                        FALSE, then the app will terminate, naming
                        the file name and line number of the assertion
                        in the source.

        UIASSERT(exp)   Synonym for ASSERT.

        ASSERTSZ(exp,sz) As ASSERT, except will also print the message
                        "sz" with the assertion message should it fail.

        REQUIRE(exp)    As ASSERT, except that its expression is still
                        evaluated in retail versions.  (Other versions
                        of ASSERT disappear completely in retail builds.)

    The ASSERT macros expect a symbol _FILENAME_DEFINED_ONCE, and will
    use the value of that symbol as the filename if found; otherwise,
    they will emit a new copy of the filename, using the ANSI C __FILE__
    macro.  A client sourcefile may therefore define __FILENAME_DEFINED_ONCE
    in order to minimize the DGROUP footprint of a number of ASSERTs.

Author:

    Vlad Sadovsky   (vlads) 26-Jan-1997

Revision History:

    26-Jan-1997     VladS       created
    13-Apr-1999     VladS       make UNICODE aware

--*/


#ifndef _STIDEBUG_H_
#define _STIDEBUG_H_

#if defined(DEBUG)
static const char szFileName[] = __FILE__;
#define _FILENAME_DEFINED_ONCE szFileName
#endif

#if defined(__cplusplus)
extern "C"
{
#endif

extern VOID UIAssertHelper( const CHAR* pszFileName, UINT nLine );
extern VOID UIAssertSzHelper( const TCHAR* pszMessage, const CHAR* pszFileName, UINT nLine );

extern VOID AssertHelper( const CHAR* pszFileName, UINT nLine );
extern VOID AssertSzHelper( const TCHAR* pszMessage, const CHAR* pszFileName, UINT nLine );

#if defined(DEBUG)

# ifdef USE_MESSAGEBOX_UI

#  define ASSERT(exp) \
    { if (!(exp)) UIAssertHelper(__FILE__, __LINE__); }

#  define ASSERTSZ(exp, sz) \
    { if (!(exp)) UIAssertSzHelper((sz), __FILE__, __LINE__); }

# else

#  define ASSERT(exp) \
    { if (!(exp)) AssertHelper(__FILE__, __LINE__); }

#  define ASSERTSZ(exp, sz) \
    { if (!(exp)) AssertSzHelper((sz), __FILE__, __LINE__); }

#define EVAL(exp)   \
    ((exp) || AssertHelper(__FILE__, __LINE__))

# endif // USE_MESSAGEBOX_UI

# define UIASSERT(exp)  ASSERT(exp)
# define REQUIRE(exp)   ASSERT(exp)

#else // !DEBUG

# define ASSERT(exp)        ;
# define EVAL(exp)          ;
# define UIASSERT(exp)      ;
# define ASSERTSZ(exp, sz)  ;
# define REQUIRE(exp)       { (exp); }

#endif // DEBUG



//
// Debug mask management.
//

// NOTE: You can #define your own DM_* values using bits in the HI BYTE

#define DM_TRACE    0x0001      // Trace messages
#define DM_WARNING  0x0002      // Warning
#define DM_ERROR    0x0004      // Error
#define DM_ASSERT   0x0008      // Assertions

#define DM_LOG_FILE 0x0100
#define DM_PREFIX   0x0200


#if !defined(StiDebugMsg)

//
// StiDebugMsg(mask, msg, args...) - Generate wsprintf-formatted msg using
// specified debug mask.  System debug mask governs whether message is output.
//

#define REGVAL_STR_DEBUGMASK_A    "DebugMask"
#define REGVAL_STR_DEBUGMASK_W    L"DebugMask"

void __cdecl StiDebugMsg(UINT mask, LPCTSTR psz, ...);

UINT WINAPI  StiSetDebugParameters(PTSTR pszName,PTSTR pszLogFile);
UINT WINAPI  StiSetDebugMask(UINT mask);
UINT WINAPI  StiGetDebugMask(void);

#endif

#ifdef  DEBUG

#define Break()  DebugBreak()
#define DPRINTF  StiDebugMsg

#else

#define Break()

//
// Nb: Following definition is needed to avoid compiler complaining
// about empty function name in expression. In retail builds using this macro
// will cause string parameters not appear in executable
//
#define DPRINTF     1?(void)0 : (void)

#endif

#if defined(__cplusplus)
}
#endif

#if defined(__cplusplus)

#ifdef  DEBUG

class DBGTRACE
{
private:
    TCHAR   m_szMessage[200];

public:
    inline DBGTRACE(LPTSTR szMsg) {
        lstrcpy(m_szMessage,szMsg);
        DPRINTF(DM_TRACE,TEXT("ProcTraceEnter:%s At sec =%d "),
                m_szMessage,::GetTickCount()/1000);
    }

    inline ~DBGTRACE() {
        DPRINTF(DM_TRACE,TEXT("ProcTraceExit:%s At sec. =%d "),m_szMessage,::GetTickCount()/1000);
    }
};

#else

class DBGTRACE
{
public:
    inline DBGTRACE(LPTSTR szMsg) {
    }

    inline ~DBGTRACE() {
    }
};

#endif

#endif


//
// Performance monitoring
//

#if defined(__cplusplus)

#ifdef  DEBUG

class TICK_COUNTER
{
private:
    UINT    m_uiStartingCount;
    TCHAR   m_szMessage[200];

public:
    inline TICK_COUNTER(LPTSTR szMsg) {
        lstrcpy(m_szMessage,szMsg);
        m_uiStartingCount = ::GetTickCount();
    }

    inline ~TICK_COUNTER() {
        DPRINTF(DM_TRACE,TEXT("Elapsed time in (%s) is: %d ticks, %d seconds"),
                m_szMessage,
                ::GetTickCount() - m_uiStartingCount,
                (::GetTickCount() - m_uiStartingCount) / 1000
                );
    }

    inline ElapsedTicks(VOID) { return (::GetTickCount() - m_uiStartingCount);}

};

#else

class TICK_COUNTER
{
public:
    inline TICK_COUNTER(LPTSTR szMsg) {
    }

    inline ~TICK_COUNTER() {
    }
};

#endif
#endif


#endif // _STIDEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\inc\stilib.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    stilib.h

Abstract:

    Various library definitions , common for multiple STI subprojects

Author:

    Vlad Sadovsky   (vlads) 26-Jan-1997

Revision History:

    26-Jan-1997     VladS       created

--*/

#ifndef _INC_STILIB
#define _INC_STILIB

# if !defined( dllexp)
# define dllexp               __declspec( dllexport)
# endif // !defined( dllexp)

#include <linklist.h>
#include <buffer.h>
//#include <stistr.h>

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif  /* __cplusplus */


#if !defined(DEBUG)
#if defined(_DEBUG) || defined(DBG)
#define DEBUG
#endif
#endif

#ifdef DBCS
#define IS_LEAD_BYTE(c)     IsDBCSLeadByte(c)
#else
#define IS_LEAD_BYTE(c)     0
#endif

#ifdef DEBUG
void            cdecl nprintf(const char *, ...);
#endif

#ifdef DBCS
#define ADVANCE(p)  (p += IS_LEAD_BYTE(*p) ? 2 : 1)
#else
#define ADVANCE(p)  (++p)
#endif

#define SPN_SET(bits,ch)    bits[(ch)/8] |= (1<<((ch) & 7))
#define SPN_TEST(bits,ch)   (bits[(ch)/8] & (1<<((ch) & 7)))

int sbufchkf(const char FAR *, unsigned short);


// I_IsBadStringPtrA()
//
// Private Win32 version of IsBadStringPtr that works properly, i.e.
// like the Win16 version, it returns TRUE if the string is not
// null-terminated.
BOOL WINAPI I_IsBadStringPtrA(LPCSTR lpsz, UINT ucchMax);

//
//
//
#define     IS_EMPTY_STRING(pch) (!(pch) || !(*(pch)))

//
// String run-time calls
//
//
#define strcpyf(d,s)    lstrcpy((d),(s))
#define strcatf(d,s)    lstrcat((d),(s))
#define strlenf(s)      lstrlen((s))

#define strcmpf(s1,s2)  lstrcmp(s1,s2)
#define stricmpf(s1,s2) lstrcmpi(s1,s2)

#pragma intrinsic(memcmp,memset)
#define memcmpf(d,s,l)  memcmp((d),(s),(l))
#define memsetf(s,c,l)  memset((s),(c),(l))
#define memmovef(d,s,l) MoveMemory((d),(s),(l))
#define memcpyf(d,s,l)  CopyMemory((d),(s),(l))

/*
 * WaitAndYield processes all input messages.  WaitAndProcessSends only
 * processes SendMessages.
 *
 * WaitAndYield takes an optional parameter which is the ID of another
 * thread concerned with the waiting.  If it's not NULL, WM_QUIT messages
 * will be posted to that thread's queue when they are seen in the message
 * loop.
 */
DWORD WaitAndYield(HANDLE hObject, DWORD dwTimeout, volatile DWORD *pidOtherThread = NULL);
DWORD WaitAndProcessSends(HANDLE hObject, DWORD dwTimeout);

//
// Message box routines
//

#define IDS_MSGTITLE    1024

//extern int MsgBox( HWND hwndDlg, UINT idMsg, UINT wFlags, const STR **aps = NULL );
//extern UINT MsgBoxPrintf(HWND hwnd,UINT uiMsg,UINT uiTitle,UINT uiFlags,...);
//extern UINT LoadMsgPrintf(STR& strMessage,UINT  uiMsg,...);

//
// Registry access class
//
//#include <regentry.h>

#ifdef __cplusplus
}
#endif  /* __cplusplus */

#if !defined(DBG) && !defined(DEBUG)
//
// Overloaded allocation operators
//

inline void  * __cdecl operator new(size_t size)
{
    return (void *)LocalAlloc(LPTR,size);
}
inline void  __cdecl operator delete(void *ptr)
{
    LocalFree(ptr);
}

#if 0
inline UINT __cdecl allocated_size(void *ptr)
{
    return ptr ? (UINT)LocalSize(ptr) : 0;
}
#endif

#endif

#endif /* _INC_STILIB */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\inc\stilog.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    stitrace.h

Abstract:

    This file defines functions and types required to support file logging
    for all STI components


Author:

    Vlad Sadovsky (vlads)   02-Sep-1997


Environment:

    User Mode - Win32

Revision History:

    02-Sep-1997     VladS       created

--*/

# ifndef _STITRACE_H_
# define _STITRACE_H_

# include <windows.h>

/***********************************************************
 *    Named constants  definitions
 ************************************************************/

#define STI_MAX_LOG_SIZE            1000000         // in bytes

#define STI_TRACE_INFORMATION       0x00000001
#define STI_TRACE_WARNING           0x00000002
#define STI_TRACE_ERROR             0x00000004

#define STI_TRACE_ADD_TIME          0x00010000
#define STI_TRACE_ADD_MODULE        0x00020000
#define STI_TRACE_ADD_THREAD        0x00040000
#define STI_TRACE_ADD_PROCESS       0x00080000
#define STI_TRACE_LOG_TOUI          0x00100000

#define STI_TRACE_MESSAGE_TYPE_MASK 0x0000ffff
#define STI_TRACE_MESSAGE_FLAGS_MASK  0xffff0000

#ifndef STIMON_MSG_LOG_MESSAGE
// BUGBUG
#define STIMON_MSG_LOG_MESSAGE      WM_USER+205
#endif

#ifdef __cplusplus
//
// Class definitions used only in C++ code
//

#include <base.h>
#include <lock.h>
#include <stistr.h>

#ifndef DLLEXP
//#define DLLEXP __declspec( dllexport )
#define DLLEXP
#endif


/***********************************************************
 *    Type Definitions
 ************************************************************/

#define SIGNATURE_FILE_LOG      (DWORD)'SFLa'
#define SIGNATURE_FILE_LOG_FREE (DWORD)'SFLf'

#define STIFILELOG_CHECK_TRUNCATE_ON_BOOT   0x00000001                      
                        
class STI_FILE_LOG  : public BASE {

private:

    DWORD       m_dwSignature;
    LPCTSTR     m_lpszSource;       // Name of the file , containing log
    DWORD       m_dwReportMode;     // Bit mask , describing which messages types get reported
    DWORD       m_dwMaxSize;        // Maximum size ( in bytes )
    HANDLE      m_hLogFile;
    CRIT_SECT   m_CritSect;
    HANDLE      m_hMutex;
    HMODULE     m_hDefaultMessageModule;
    LONG        m_lWrittenHeader;

    TCHAR       m_szLogFilePath[MAX_PATH];
    TCHAR       m_szTracerName[16];
    TCHAR       m_szProcessName[13];

    HWND        m_hLogWindow ;

    VOID
    WriteStringToLog(
        LPCTSTR pszTextBuffer,
        BOOL    fFlush=FALSE
    );

public:

    DLLEXP
    STI_FILE_LOG(
        IN LPCTSTR lpszTracerName,
        IN LPCTSTR lpszLogName,
        IN DWORD   dwFlags = 0,
        IN HMODULE hMessageModule = NULL
        );

    DLLEXP
    ~STI_FILE_LOG( VOID);

    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface( REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef( void);
    STDMETHODIMP_(ULONG) Release( void);

    BOOL
    inline
    IsValid(VOID)
    {
        return (( QueryError() == NO_ERROR) && (m_dwSignature == SIGNATURE_FILE_LOG));
    }

    DWORD
    inline
    SetReportMode(
        DWORD   dwNewMode
        ) {
        DWORD   dwOldMode = m_dwReportMode;
        m_dwReportMode = dwNewMode;
        return dwOldMode;
    }

    DWORD
    inline
    QueryReportMode(
        VOID
        ) {
        return m_dwReportMode;
    }

    VOID
    inline
    SetLogWindowHandle(
        HWND    hwnd
        )
    {
        m_hLogWindow = hwnd;
    }

    VOID
    WriteLogSessionHeader(
        VOID
    );


    DLLEXP
    void
    ReportMessage(
        DWORD   dwType,
        LPCTSTR psz,
        ...
        );

    DLLEXP
    void
    STI_FILE_LOG::
    ReportMessage(
        DWORD   dwType,
        DWORD   idMessage,
        ...
    );

    DLLEXP
    void
    vReportMessage(
        DWORD   dwType,
        LPCTSTR psz,
        va_list arglist
        );


};

typedef STI_FILE_LOG * LPSTI_FILE_LOG;

#endif // C++

//
// C calls to allow non-C++ code access file logging objects
//

#ifdef __cplusplus
extern "C" {
#endif

HANDLE
WINAPI
CreateStiFileLog(
    IN  LPCTSTR lpszTracerName,
    IN  LPCTSTR lpszLogName,
    IN  DWORD   dwReportMode
    );

DWORD
WINAPI
CloseStiFileLog(
    IN  HANDLE  hFileLog
    );

DWORD
WINAPI
ReportStiLogMessage(
    IN  HANDLE  hFileLog,
    IN  DWORD   dwType,
    IN  LPCTSTR psz,
    ...
    );

#ifdef __cplusplus
}
#endif

#endif // _STITRACE_H_

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\inc\stirc.h ===
#include "stimsg.h"

#define IDS_STIDEVICE   4001
#define IDS_STIOBJ      4002
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\inc\stimsg.h ===
/*++;

Copyright (c) 1997  Microsoft Corporation

Module Name:

    sti.mc, sti.h

Abstract:

    This file contains the message definitions for the STI DLL 

Author:

    Vlad Sadovsky   (VladS)    01-Oct-1997

Revision History:

Notes:

--*/

//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: MSG_FAILED_OPEN_DEVICE_KEY
//
// MessageText:
//
//  Loading USD, cannot open device registry key.
//
#define MSG_FAILED_OPEN_DEVICE_KEY       0xC0002001L

//
// MessageId: MSG_FAILED_READ_DEVICE_NAME
//
// MessageText:
//
//  Loading USD, cannot read device name from registry.
//
#define MSG_FAILED_READ_DEVICE_NAME      0xC0002002L

//
// MessageId: MSG_FAILED_CREATE_DCB
//
// MessageText:
//
//  Loading USD, failed to create device control block. Error code (hex)=%1!x!.
//
#define MSG_FAILED_CREATE_DCB            0xC0002003L

//
// MessageId: MSG_LOADING_USD
//
// MessageText:
//
//  Attempting to load user-mode driver (USD) for the device.
//
#define MSG_LOADING_USD                  0x40002004L

//
// MessageId: MSG_LOADING_PASSTHROUGH_USD
//
// MessageText:
//
//  Could not create instance for registered USD, possibly incorrect class ID or problems loading DLL. Trying to initialize pass-through USD.Error code (hex)=%1!x!. 
//
#define MSG_LOADING_PASSTHROUGH_USD      0x40002005L

//
// MessageId: MSG_INITIALIZING_USD
//
// MessageText:
//
//  Completed loading USD, calling initialization routine.
//
#define MSG_INITIALIZING_USD             0x40002006L

//
// MessageId: MSG_OLD_USD
//
// MessageText:
//
//  Version of USD is either too old or too new , will not work with this version of sti dll.
//
#define MSG_OLD_USD                      0xC0002008L

//
// MessageId: MSG_SUCCESS_USD
//
// MessageText:
//
//  Successfully loaded user mode driver.
//
#define MSG_SUCCESS_USD                  0x40002009L

//
// MessageId: MSG_FAILED_INIT_USD
//
// MessageText:
//
//  USD failed Initialize method, returned error code (hex)=%1!x!.
//  .               
//  
//  
//
#define MSG_FAILED_INIT_USD              0xC000200AL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\inc\stipriv.h ===
/***************************************************************************
 *
 *  Copyright (C) 1996 Microsoft Corporation.  All Rights Reserved.
 *
 *  File:       stipriv.h
 *  Content:    Internal include file
 *@@BEGIN_MSINTERNAL
 *  History:
 *
 *   10/28/96   vlads   Starting code for STI
 *
 *@@END_MSINTERNAL
 *
 ***************************************************************************/


#ifdef __cplusplus
extern "C" {
#endif

#ifndef FINAL
    #define EXPIRE_YEAR 2001
    #define EXPIRE_MONTH  01
    #define EXPIRE_DAY    24
#endif

typedef LPUNKNOWN   PUNK;
typedef LPVOID      PV, *PPV;
typedef CONST VOID *PCV;
typedef REFIID      RIID;
typedef CONST GUID *PCGUID;

#define MAX_REG_CHAR    128

//
// We need to use free-threading model, definitions for which are guarded
// with the following define ( in VC 5.0).
//
#ifndef  _WIN32_DCOM
//#define _WIN32_DCOM
#endif


/***************************************************************************
 *
 *      Global variables
 *
 ***************************************************************************/

extern  HINSTANCE   g_hInst;
extern  BOOL        g_NoUnicodePlatform;
extern  BOOL        g_COMInitialized;
extern  HANDLE  g_hStiFileLog;

/*****************************************************************************
 *
 *      stiobj.c - ISti objectimplementation
 *
 *****************************************************************************/

STDMETHODIMP CStiObj_New(PUNK punkOuter, RIID riid, PPV ppvOut);

STDMETHODIMP StiCreateHelper(
    HINSTANCE hinst,
    DWORD dwVer,
    PPV ppvObj,
    PUNK punkOuter,
    RIID riid
    );

STDMETHODIMP StiPrivateGetDeviceInfoHelperW(
    LPWSTR  pwszDeviceName,
    LPVOID  *ppBuffer
    );

/*****************************************************************************
 *
 *
 *****************************************************************************/

#define INTERNAL NTAPI  /* Called only within a translation unit */
#define EXTERNAL NTAPI  /* Called from other translation units */
#define INLINE static __inline

#define BEGIN_CONST_DATA data_seg(".text", "CODE")
#define END_CONST_DATA data_seg(".data", "DATA")

/*
 *  Arithmetic on pointers.
 */
#define pvSubPvCb(pv, cb) ((PV)((PBYTE)pv - (cb)))
#define pvAddPvCb(pv, cb) ((PV)((PBYTE)pv + (cb)))
#define cbSubPvPv(p1, p2) ((PBYTE)(p1) - (PBYTE)(p2))

/*
 * Convert an object (X) to a count of bytes (cb).
 */
#define cbX(X) sizeof(X)

/*
 * Convert an array name (A) to a generic count (c).
 */
#define cA(a) (cbX(a)/cbX(a[0]))

/*
 * Convert a count of X's (cx) into a count of bytes.
 */
#define  cbCxX(cx, X) ((cx) * cbX(X))

/*
 * Convert a count of chars (cch), tchars (ctch), wchars (cwch),
 * or dwords (cdw) into a count of bytes.
 */
#define  cbCch(cch)  cbCxX( cch,  CHAR)
#define cbCwch(cwch) cbCxX(cwch, WCHAR)
#define cbCtch(ctch) cbCxX(ctch, TCHAR)
#define  cbCdw(cdw)  cbCxX( cdw, DWORD)

/*
 * Zero an arbitrary buffer.  It is a common error to get the second
 * and third parameters to memset backwards.
 */
#define ZeroBuf(pv, cb) memset(pv, 0, cb)

/*
 * Zero an arbitrary object.
 */
#define ZeroX(x) ZeroBuf(&(x), cbX(x))

/*
 * land -- Logical and.  Evaluate the first.  If the first is zero,
 * then return zero.  Otherwise, return the second.
 */

#define fLandFF(f1, f2) ((f1) ? (f2) : 0)

/*
 * limp - logical implication.  True unless the first is nonzero and
 * the second is zero.
 */
#define fLimpFF(f1, f2) (!(f1) || (f2))

/*
 * leqv - logical equivalence.  True if both are zero or both are nonzero.
 */
#define fLeqvFF(f1, f2) (!(f1) == !(f2))


/*
 *  fInOrder - checks that i1 <= i2 < i3.
 */
#define fInOrder(i1, i2, i3) ((unsigned)((i2)-(i1)) < (unsigned)((i3)-(i1)))

/*
 * Words to keep preprocessor happy.
 */
#define comma ,
#define empty

/*
 *  Atomically exchange one value for another.
 */
#define pvExchangePpvPv(ppv, pv) \
        (PV)InterlockedExchangePointer((PPV)(ppv), (PV)(pv))

/*
 *  Creating HRESULTs from a USHORT or from a LASTERROR.
 */
#define hresUs(us) MAKE_HRESULT(SEVERITY_SUCCESS, 0, (USHORT)(us))
#define hresLe(le) MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIN32, (USHORT)(le))

/***************************************************************************
 *
 *  Debug / RDebug / Retail
 *
 *  If either DEBUG or RDEBUG, set MAXDEBUG.
 *
 *  Retail defines nothing.
 *
 ***************************************************************************/

#if defined(DEBUG) || defined(RDEBUG)
//#define MAXDEBUG
#endif

/***************************************************************************
 *
 *                            Validation Code....
 *
 *  "If it crashes in retail, it must crash in debug."
 *
 *  What we don't want is an app that works fine under debug, but crashes
 *  under retail.
 *
 *  So if we find an invalid parameter in debug that would not have been
 *  detected by retail, let it pass through after a warning.  That way,
 *  the invalid parameter continues onward through the system and creates
 *  as much (or more) havoc in debug as it would under retail.
 *
 *  The _fFastValidXxx functions perform cursory validation.
 *  The _fFullValidXxx functions perform full validation.
 *
 *  In retail, fFastValidXxx maps to _fFastValidXxx.
 *
 *  In debug, fFastValidXxx performs a full validation and throws away
 *  the error value, then returns the value of _fFastValidXxx.
 *
 *  The hresFullValidXxx functions return HRESULTs instead of BOOLs.
 *
 *  Values for Xxx:
 *
 *      Hwnd      - hwnd = window handle
 *      Pdw       - pdw = pointer to a dword
 *      PdwOut    - pdw = pointer to a dword that will be set initially to 0
 *      Pfn       - pfn = function pointer
 *      riid      - riid = pointer to IID
 *      guid      - pguid = pointer to GUID
 *
 *      ReadPx    - p -> structure for reading, X = structure name
 *      WritePx   - p -> structure for writing, X = structure name
 *
 *      ReadPxCb  - p -> structure for reading, X = structure name
 *                  first field of structure is dwSize which must be
 *                  equal to cbX(X).
 *
 *      WritePxCb - p -> structure for writing, X = structure name
 *                  first field of structure is dwSize which must be
 *                  equal to cbX(X).
 *
 *      ReadPvCb  - p -> buffer, cb = size of buffer
 *      WritePvCb - p -> buffer, cb = size of buffer
 *
 *      Pobj      - p -> internal interface
 *
 *      fl        - fl = incoming flags, flV = valid flags
 *
 ***************************************************************************/

#ifndef MAXDEBUG

/*
 *  Wrappers that throw away the szProc and iarg info.
 */

#define hresFullValidHwnd_(hwnd, z, i)                              \
       _hresFullValidHwnd_(hwnd)                                    \

#define hresFullValidPdwOut_(pdw, z, i)                             \
       _hresFullValidPdwOut_(pdw)                                   \

#define hresFullValidReadPxCb_(pv, cb, pszProc, iarg)               \
       _hresFullValidReadPxCb_(pv, cb)                              \

#define hresFullValidReadPvCb_(pv, cb, pszProc, iarg)               \
       _hresFullValidReadPvCb_(pv, cb)                              \

#define hresFullValidWritePxCb_(pv, cb, pszProc, iarg)              \
       _hresFullValidWritePxCb_(pv, cb)                             \

#define hresFullValidWritePvCb_(pv, cb, pszProc, iarg)              \
       _hresFullValidWritePvCb_(pv, cb)                             \

#define hresFullValidFl_(fl, flV, pszProc, iarg)                    \
       _hresFullValidFl_(fl, flV)                                   \

#define hresFullValidPfn_(pfn, pszProc, iarg)                       \
       _hresFullValidPfn_(pfn)                                      \

#define hresFullValidPitf_(punk, pszProc, iarg)                     \
       _hresFullValidPitf_(punk)                                    \

#define hresFullValidHwnd0_(hwnd, pszProc, iarg)                    \
       _hresFullValidHwnd0_(hwnd)                                   \

#define hresFullValidPitf0_(punk, pszProc, iarg)                    \
       _hresFullValidPitf0_(punk)                                   \

#endif

/*
 *  The actual functions.
 */

STDMETHODIMP hresFullValidHwnd_(HWND hwnd, LPCSTR pszProc, int iarg);
STDMETHODIMP hresFullValidPdwOut_(PV pdw, LPCSTR pszProc, int iarg);
STDMETHODIMP hresFullValidReadPxCb_(PCV pv, UINT cb, LPCSTR pszProc, int iarg);
STDMETHODIMP hresFullValidReadPvCb_(PCV pv, UINT cb, LPCSTR pszProc, int iarg);
STDMETHODIMP hresFullValidWritePxCb_(PV pv, UINT cb, LPCSTR pszProc, int iarg);
STDMETHODIMP hresFullValidWritePvCb_(PV pv, UINT cb, LPCSTR pszProc, int iarg);
STDMETHODIMP hresFullValidFl_(DWORD fl, DWORD flV, LPCSTR pszProc, int iarg);
STDMETHODIMP hresFullValidPfn_(FARPROC pfn, LPCSTR pszProc, int iarg);
STDMETHODIMP hresFullValidPitf_(PUNK punk, LPCSTR pszProc, int iarg);

HRESULT INLINE
hresFullValidHwnd0_(HWND hwnd, LPCSTR pszProc, int iarg)
{
    HRESULT hres;
    if (hwnd) {
        hres = hresFullValidHwnd_(hwnd, pszProc, iarg);
    } else {
        hres = S_OK;
    }
    return hres;
}

HRESULT INLINE
hresFullValidPitf0_(PUNK punk, LPCSTR pszProc, int iarg)
{
    HRESULT hres;
    if (punk) {
        hres = hresFullValidPitf_(punk, pszProc, iarg);
    } else {
        hres = S_OK;
    }
    return hres;
}

/*
 *  Wrappers for derived types.
 */

#define hresFullValidRiid_(riid, s_szProc, iarg)                    \
        hresFullValidReadPvCb_(riid, cbX(IID), s_szProc, iarg)      \

/*
 *  Wrapers that add the szProc and iarg info.
 */

#define hresFullValidHwnd(hwnd, iarg)                               \
        hresFullValidHwnd_(hwnd, s_szProc, iarg)                    \

#define hresFullValidPdwOut(pdw, i)                                 \
        hresFullValidPdwOut_(pdw, s_szProc, i)                      \

#define hresFullValidReadPdw_(pdw, z, i)                            \
        hresFullValidReadPvCb_(pdw, cbX(DWORD), z, i)               \

#define hresFullValidRiid(riid, iarg)                               \
        hresFullValidRiid_(riid, s_szProc, iarg)                    \

#define hresFullValidGuid(pguid, iarg)                              \
        hresFullValidReadPvCb_(pguid, cbX(GUID), s_szProc, iarg)    \

#define hresFullValidReadPxCb(pv, X, iarg)                          \
        hresFullValidReadPxCb_(pv, cbX(X), s_szProc, iarg)          \

#define hresFullValidReadPvCb(pv, cb, iarg)                         \
        hresFullValidReadPvCb_(pv, cb, s_szProc, iarg)              \

#define hresFullValidReadPx(pv, X, iarg)                            \
        hresFullValidReadPvCb_(pv, cbX(X), s_szProc, iarg)          \

#define hresFullValidWritePxCb(pv, X, iarg)                         \
        hresFullValidWritePxCb_(pv, cbX(X), s_szProc, iarg)         \

#define hresFullValidWritePvCb(pv, cb, iarg)                        \
        hresFullValidWritePvCb_(pv, cb, s_szProc, iarg)             \

#define hresFullValidWritePx(pv, X, iarg)                           \
        hresFullValidWritePvCb_(pv, cbX(X), s_szProc, iarg)         \

#define hresFullValidReadPdw(pdw, iarg)                             \
        hresFullValidReadPdw_(pdw, s_szProc, iarg)                  \

#define hresFullValidFl(fl, flV, iarg)                              \
        hresFullValidFl_(fl, flV, s_szProc, iarg)                   \

#define hresFullValidPfn(pfn, iarg)                                 \
        hresFullValidPfn_((FARPROC)(pfn), s_szProc, iarg)           \

#define hresFullValidPitf(pitf, iarg)                               \
        hresFullValidPitf_((PUNK)(pitf), s_szProc, iarg)            \

#define hresFullValidHwnd0(hwnd, iarg)                              \
        hresFullValidHwnd0_(hwnd, s_szProc, iarg)                   \

#define hresFullValidPitf0(pitf, iarg)                              \
        hresFullValidPitf0_((PUNK)(pitf), s_szProc, iarg)           \

/*****************************************************************************
 *
 *  @doc INTERNAL
 *
 *  @func   void | ValidationException |
 *
 *          Raises a parameter validation exception in MAXDEBUG.
 *
 *****************************************************************************/

#define ecValidation (ERROR_SEVERITY_ERROR | hresLe(ERROR_INVALID_PARAMETER))

#ifdef MAXDEBUG
#define ValidationException() RaiseException(ecValidation, 0, 0, 0)
#else
#define ValidationException()
#endif

/*
 * TFORM(x) expands to x##A if ANSI or x##W if UNICODE.
 *          This T-izes a symbol, in the sense of TCHAR or PTSTR.
 *
 * SFORM(x) expands to x##W if ANSI or x##A if UNICODE.
 *          This anti-T-izes a symbol.
 */

#ifdef UNICODE
#define _TFORM(x) x##W
#define _SFORM(x) x##A
#else
#define _TFORM(x) x##A
#define _SFORM(x) x##W
#endif

#define TFORM(x)    _TFORM(x)
#define SFORM(x)    _SFORM(x)


/*
 *  SToT(dst, cchDst, src) - convert S to T
 *  TToS(dst, cchDst, src) - convert T to S
 *
 *  Remember, "T" means "ANSI if ANSI, or UNICODE if UNICODE",
 *  and "S" is the anti-T.
 *
 *  So SToT converts to the preferred character set, and TToS converts
 *  to the alternate character set.
 *
 */

#define AToU(dst, cchDst, src) \
    MultiByteToWideChar(CP_ACP, 0, src, -1, dst, cchDst)
#define UToA(dst, cchDst, src) \
    WideCharToMultiByte(CP_ACP, 0, src, -1, dst, cchDst, 0, 0)

#ifdef UNICODE
#define SToT AToU
#define TToS UToA
#define AToT AToU
#define TToU(dst, cchDst, src)  lstrcpyn(dst, src, cchDst)
#else
#define SToT UToA
#define TToS AToU
#define AToT(dst, cchDst, src)  lstrcpyn(dst, src, cchDst)
#define TToU AToU
#endif

/*****************************************************************************
 *
 *      Unicode wrappers for Win95
 *
 *****************************************************************************/

#ifndef UNICODE

#define LoadStringW     _LoadStringW

int EXTERNAL LoadStringW(HINSTANCE hinst, UINT ids, LPWSTR pwsz, int cwch);

#endif


//
// Migration function
//
BOOL
RegisterSTIAppForWIAEvents(
    WCHAR   *pszName,
    WCHAR   *pszWide,
    BOOL    fSetAsDefault
    );

HRESULT RunRegisterProcess(
    CHAR   *szAppName,
    CHAR   *szCmdLine);

//
// C specific macros, not needed in C++ code
//
#ifndef __cplusplus

/*****************************************************************************
 *
 *      Common Object Managers for the Component Object Model
 *
 *      OLE wrapper macros and structures.  For more information, see
 *      the beginning of common.c
 *
 *****************************************************************************/

/*****************************************************************************
 *
 *      Pre-vtbl structures
 *
 *      Careful!  If you change these structures, you must also adjust
 *      common.c accordingly.
 *
 *****************************************************************************/

typedef struct PREVTBL {                /* Shared vtbl prefix */
    RIID riid;                          /* Type of this object */
    ULONG lib;                          /* offset from start of object */
} PREVTBL, *PPREVTBL;

typedef struct PREVTBLP {               /* Prefix for primary vtbl */
    PPV rgvtbl;                         /* Array of standard vtbls */
    UINT cbvtbl;                        /* Size of vtbl array in bytes */
    STDMETHOD(QIHelper)(PV pv, RIID riid, PPV ppvOut); /* QI helper */
    STDMETHOD_(void,FinalizeProc)(PV pv);/* Finalization procedure */
    PREVTBL prevtbl;                    /* lib must be zero */
} PREVTBLP, *PPREVTBLP;

/*
 *      A fuller implementation is in common.c.  Out here, we need only
 *      concern ourselves with getting to the primary interface.
 */

#define _thisPv(pitf)                                                   \
        pvSubPvCb(pitf, (*(PPREVTBL*)(pitf))[-1].lib)

#define _thisPvNm(pitf, nm)                                             \
        pvSubPvCb(pitf, FIELD_OFFSET(ThisClass, nm))                    \

#ifndef MAXDEBUG

#define hresPvVtbl_(pv, vtbl, pszProc)                                  \
       _hresPvVtbl_(pv, vtbl)                                           \

#endif

HRESULT EXTERNAL
hresPvVtbl_(PV pv, PV vtbl, LPCSTR pszProc);

#define hresPvVtbl(pv, vtbl)                                            \
        hresPvVtbl_(pv, vtbl, s_szProc)                                 \

#define hresPvI(pv, I)                                                  \
        hresPvVtbl(pv, Class_Vtbl(ThisClass, I))                        \

#define hresPv(pv)                                                      \
        hresPvI(pv, ThisInterface)                                      \

#ifdef MAXDEBUG

#define hresPvT(pv)                                                     \
        hresPvVtbl(pv, vtblExpected)                                    \

#else

#define hresPvT(pv)                                                     \
        hresPv(pv)                                                      \

#endif

/*****************************************************************************
 *
 *      Declaring interfaces
 *
 *      The extra level of indirection on _Primary_Interface et al
 *      allow the interface name to be a macro which expands to the
 *      *real* name of the interface.
 *
 *****************************************************************************/

#define __Class_Vtbl(C, I)              &c_##I##_##C##VI.vtbl
#define  _Class_Vtbl(C, I)            __Class_Vtbl(C, I)
#define   Class_Vtbl(C, I)             _Class_Vtbl(C, I)

#define Num_Interfaces(C)               cA(c_rgpv##C##Vtbl)

#ifdef  DEBUG

#define Simple_Interface(C)             Primary_Interface(C, IUnknown); \
                                        Default_QueryInterface(C)       \
                                        Default_AddRef(C)               \
                                        Default_Release(C)
#define Simple_Vtbl(C)                  Class_Vtbl(C)
#define Simple_Interface_Begin(C)       Primary_Interface_Begin(C, IUnknown)
#define Simple_Interface_End(C)         Primary_Interface_End(C, IUnknown)

#else

#define Simple_Interface(C)             Primary_Interface(C, IUnknown)
#define Simple_Vtbl(C)                  Class_Vtbl(C)
#define Simple_Interface_Begin(C)                                       \
        struct S_##C##Vtbl c_##I##_##C##VI = { {                        \
            c_rgpv##C##Vtbl,                                            \
            cbX(c_rgpv##C##Vtbl),                                       \
            C##_QIHelper,                                               \
            C##_Finalize,                                               \
            { &IID_##IUnknown, 0 },                                     \
        }, {                                                            \
            Common##_QueryInterface,                                    \
            Common##_AddRef,                                            \
            Common##_Release,                                           \

#define Simple_Interface_End(C)                                         \
        } };                                                            \

#endif

#define _Primary_Interface(C, I)                                        \
        extern struct S_##C##Vtbl {                                     \
            PREVTBLP prevtbl;                                           \
            I##Vtbl vtbl;                                               \
        } c_##I##_##C##VI                                               \

#define Primary_Interface(C, I)                                         \
       _Primary_Interface(C, I)                                         \

#define _Primary_Interface_Begin(C, I)                                  \
        struct S_##C##Vtbl c_##I##_##C##VI = { {                        \
            c_rgpv##C##Vtbl,                                            \
            cbX(c_rgpv##C##Vtbl),                                       \
            C##_QIHelper,                                               \
            C##_Finalize,                                               \
            { &IID_##I, 0, },                                           \
        }, {                                                            \
            C##_QueryInterface,                                         \
            C##_AddRef,                                                 \
            C##_Release,                                                \

#define Primary_Interface_Begin(C, I)                                   \
       _Primary_Interface_Begin(C, I)                                   \

#define Primary_Interface_End(C, I)                                     \
        } };                                                            \

#define _Secondary_Interface(C, I)                                      \
        extern struct S_##I##_##C##Vtbl {                               \
            PREVTBL prevtbl;                                            \
            I##Vtbl vtbl;                                               \
        } c_##I##_##C##VI                                               \

#define Secondary_Interface(C, I)                                       \
       _Secondary_Interface(C, I)                                       \

/*
 *  Secret backdoor for the "private" IUnknown in common.c
 */
#define _Secondary_Interface_Begin(C, I, ofs, Pfx)                      \
        struct S_##I##_##C##Vtbl c_##I##_##C##VI = { {                  \
            &IID_##I,                                                   \
            ofs,                                                        \
        }, {                                                            \
            Pfx##QueryInterface,                                        \
            Pfx##AddRef,                                                \
            Pfx##Release,                                               \

#define Secondary_Interface_Begin(C, I, nm)                             \
       _Secondary_Interface_Begin(C, I, FIELD_OFFSET(C, nm), Common_)   \

#define _Secondary_Interface_End(C, I)                                   \
        } };                                                            \

#define Secondary_Interface_End(C, I, nm)                               \
       _Secondary_Interface_End(C, I)                                   \

#define Interface_Template_Begin(C)                                     \
        PV c_rgpv##C##Vtbl[] = {                                        \

#define Primary_Interface_Template(C, I)                                \
        Class_Vtbl(C, I),                                               \

#define Secondary_Interface_Template(C, I)                              \
        Class_Vtbl(C, I),                                               \

#define Interface_Template_End(C)                                       \
        };                                                              \


STDMETHODIMP Common_QueryInterface(PV, RIID, PPV);
STDMETHODIMP_(ULONG) Common_AddRef(PV pv);
STDMETHODIMP_(ULONG) Common_Release(PV pv);

STDMETHODIMP Common_QIHelper(PV, RIID, PPV);
void EXTERNAL Common_Finalize(PV);

#ifndef MAXDEBUG

#define _Common_New_(cb, punkOuter, vtbl, pvpObj, z)                \
       __Common_New_(cb, punkOuter, vtbl, pvpObj)                   \

#define _Common_NewRiid_(cb, vtbl, punkOuter, riid, pvpObj, z)      \
       __Common_NewRiid_(cb, vtbl, punkOuter, riid, pvpObj)         \

#endif

STDMETHODIMP
_Common_New_(ULONG cb, PUNK punkOuter, PV vtbl, PPV ppvObj, LPCSTR s_szProc);

STDMETHODIMP
_Common_NewRiid_(ULONG cb, PV vtbl, PUNK punkOuter, RIID riid, PPV pvpObj,
                 LPCSTR s_szProc);

#define Common_NewCb(cb, C, punkOuter, ppvObj)                          \
       _Common_New_(cb, punkOuter, Class_Vtbl(C, ThisInterface), ppvObj, s_szProc)

#define Common_New(C, punkOuter, ppvObj)                                \
        Common_NewCb(cbX(C), C, punkOuter, ppvObj)                      \

#define Common_NewCbRiid(cb, C, punkOuter, riid, ppvObj) \
       _Common_NewRiid_(cb, Class_Vtbl(C, ThisInterface), punkOuter, riid, ppvObj, s_szProc)

#define Common_NewRiid(C, punkOuter, riid, ppvObj) \
   _Common_NewRiid_(cbX(C), Class_Vtbl(C, ThisInterface), punkOuter, riid, ppvObj, s_szProc)

#ifdef DEBUG
PV EXTERNAL Common_IsType(PV pv);
#else
#define Common_IsType
#endif
#define Assert_CommonType Common_IsType

STDMETHODIMP Forward_QueryInterface(PV pv, RIID riid, PPV ppvObj);
STDMETHODIMP_(ULONG) Forward_AddRef(PV pv);
STDMETHODIMP_(ULONG) Forward_Release(PV pv);

void EXTERNAL Invoke_Release(PPV pv);

#define Common_DumpObjects()

/*****************************************************************************
 *
 *      OLE wrappers
 *
 *      These basically do the same as IUnknown_Mumble, except that they
 *      avoid side-effects in evaluation by being inline functions.
 *
 *****************************************************************************/

HRESULT INLINE
OLE_QueryInterface(PV pv, RIID riid, PPV ppvObj)
{
    PUNK punk = pv;
    return punk->lpVtbl->QueryInterface(punk, riid, ppvObj);
}

ULONG INLINE
OLE_AddRef(PV pv)
{
    PUNK punk = pv;
    return punk->lpVtbl->AddRef(punk);
}

ULONG INLINE
OLE_Release(PV pv)
{
    PUNK punk = pv;
    return punk->lpVtbl->Release(punk);
}

/*****************************************************************************
 *
 *      Macros that forward to the common handlers after DebugOuting.
 *      Use these only in DEBUG.
 *
 *      It is assumed that DbgFl has been #define'd to the appropriate DbgFl.
 *
 *****************************************************************************/

#ifdef  DEBUG

#define Default_QueryInterface(Class)                           \
STDMETHODIMP                                                    \
Class##_QueryInterface(PV pv, RIID riid, PPV ppvObj)            \
{                                                               \
    DebugOutPtszV(DbgFl, TEXT(#Class) TEXT("_QueryInterface()")); \
    return Common_QueryInterface(pv, riid, ppvObj);             \
}                                                               \

#define Default_AddRef(Class)                                   \
STDMETHODIMP_(ULONG)                                            \
Class##_AddRef(PV pv)                                           \
{                                                               \
    ULONG ulRc = Common_AddRef(pv);                             \
    DebugOutPtszV(DbgFl, TEXT(#Class)                          \
                        TEXT("_AddRef(%08x) -> %d"), pv, ulRc); \
    return ulRc;                                                \
}                                                               \

#define Default_Release(Class)                                  \
STDMETHODIMP_(ULONG)                                            \
Class##_Release(PV pv)                                          \
{                                                               \
    ULONG ulRc = Common_Release(pv);                            \
    DebugOutPtszV(DbgFl, TEXT(#Class)                          \
                       TEXT("_Release(%08x) -> %d"), pv, ulRc); \
    return ulRc;                                                \
}                                                               \

#endif

/*****************************************************************************
 *
 *      Paranoid callbacks
 *
 *      Callback() performs a callback.  The callback must accept exactly
 *      two parameters, both pointers.  (All our callbacks are like this.)
 *      And it must return a BOOL.
 *
 *****************************************************************************/

typedef BOOL (FAR PASCAL * STICALLBACKPROC)(LPVOID, LPVOID);

#ifdef MAXDEBUG
BOOL EXTERNAL Callback(STICALLBACKPROC, PVOID, PVOID);
#else
#define Callback(pec, pv1, pv2) pec(pv1, pv2)
#endif

/*
 *  Describes the CLSIDs we provide to OLE.
 */

typedef STDMETHOD(CREATEFUNC)(PUNK punkOuter, RIID riid, PPV ppvOut);

typedef struct CLSIDMAP {
    REFCLSID rclsid;        /* The clsid */
    CREATEFUNC pfnCreate;   /* How to create it */
    UINT    ids;            /* String that describes it */
} CLSIDMAP, *PCLSIDMAP;

#define cclsidmap   1       /* CLSID_Sti */

extern CLSIDMAP c_rgclsidmap[cclsidmap];

/*****************************************************************************
 *
 *      sti.c - Basic DLL stuff
 *
 *****************************************************************************/

void EXTERNAL DllEnterCrit(void);
void EXTERNAL DllLeaveCrit(void);

void EXTERNAL DllAddRef(void);
void EXTERNAL DllRelease(void);

BOOL EXTERNAL DllInitializeCOM(void);
BOOL EXTERNAL DllUnInitializeCOM(void);

extern CHAR   szProcessCommandLine[];

#ifdef DEBUG

extern UINT g_thidCrit;

#define InCrit() (g_thidCrit == GetCurrentThreadId())

#endif


/*****************************************************************************
 *
 *      sticf.c - IClassFactory implementation
 *
 *****************************************************************************/

STDMETHODIMP CSti_Factory_New(CREATEFUNC pfnCreate, RIID riid, PPV ppvObj);

/*****************************************************************************
 *
 *      device.c - IStiDevice implementation
 *
 *****************************************************************************/

 #define    STI_MUTEXNAME_PREFIX            L"STIDeviceMutex_"

STDMETHODIMP CStiDevice_New(PUNK punkOuter, RIID riid, PPV ppvObj);
STDMETHODIMP OpenDeviceRegistryKey(LPCWSTR  pwszDeviceName,LPCWSTR      pwszSubKeyName,HKEY *phkeyDeviceParameters);

/*****************************************************************************
 *
 *      passusd.c - Pass through USD
 *
 *****************************************************************************/

#define     StiReadControlInfo        STI_RAW_RESERVED+1
#define     StiWriteControlInfo       STI_RAW_RESERVED+2
#define     StiTransact               STI_RAW_RESERVED+3

STDMETHODIMP CStiEmptyUSD_New(PUNK punkOuter, RIID riid, PPV ppvObj);

/*****************************************************************************
 *
 *      hel.c - Hardware emulation layer
 *
 *****************************************************************************/

//
// Device types
//
#define HEL_DEVICE_TYPE_WDM          1
#define HEL_DEVICE_TYPE_PARALLEL     2
#define HEL_DEVICE_TYPE_SERIAL       3

//
// Device open flags
//
#define STI_HEL_OPEN_CONTROL         0x00000001
#define STI_HEL_OPEN_DATA            0x00000002

STDMETHODIMP    NewDeviceControl(DWORD dwDeviceType,DWORD dwMode,LPCWSTR pwszPortName,DWORD dwFlags,PSTIDEVICECONTROL *ppDevCtl);

STDMETHODIMP    CWDMDeviceControl_New(PUNK punkOuter, RIID riid, PPV ppvObj);
STDMETHODIMP    CCommDeviceControl_New(PUNK punkOuter, RIID riid, PPV ppvObj);


/*****************************************************************************
 *
 *      util.c - Misc utilities
 *
 *****************************************************************************/

#define ctchGuid    (1 + 8 + 1 + 4 + 1 + 4 + 1 + 4 + 1 + 12 + 1 + 1)

#ifndef     MAXDEBUG

#define hresValidInstanceVer_(hinst, dwVer, z)                      \
       _hresValidInstanceVer_(hinst, dwVer)                         \

#endif

HRESULT EXTERNAL
hresValidInstanceVer_(HINSTANCE hinst, DWORD dwVersion, LPCSTR s_szProc);

#define hresValidInstanceVer(hinst, dwVer)                          \
        hresValidInstanceVer_(hinst, dwVer, s_szProc)               \

HRESULT
EXTERNAL
DupEventHandle(HANDLE h, LPHANDLE phOut);

PV EXTERNAL
pvFindResource(HINSTANCE hinst, DWORD id, LPCTSTR rt);

HRESULT
ParseCommandLine(LPSTR   lpszCmdLine,UINT    *pargc,LPTSTR  *argv);

void    WINAPI
StiLogTrace(
    DWORD   dwType,
    DWORD   idMessage,
    ...
    );


#endif //  __cplusplus

/*****************************************************************************
 *
 *      olesupp.c - Misc utilities
 *
 *****************************************************************************/

STDMETHODIMP
MyCoCreateInstanceW(
    LPWSTR      pwszClsid,
    LPUNKNOWN   punkOuter,
    RIID        riid,
    PPV         ppvOut,
    HINSTANCE   *phinst
    );

STDMETHODIMP
MyCoCreateInstanceA(
    LPSTR       ptszClsid,
    LPUNKNOWN   punkOuter,
    RIID        riid,
    PPV         ppvOut,
    HINSTANCE   *phinst
    );


/*****************************************************************************
 *
 *      osutil.c - Misc utilities , specific for platform
 *
 *****************************************************************************/
BOOL EXTERNAL   OSUtil_IsPlatformUnicode(VOID);
HRESULT WINAPI EXTERNAL OSUtil_GetWideString(LPWSTR *ppszWide,LPCSTR pszAnsi);
HRESULT WINAPI EXTERNAL OSUtil_GetAnsiString(LPSTR *     ppszAnsi,LPCWSTR     lpszWide);

HRESULT WINAPI
OSUtil_RegOpenKeyExW(HKEY   hKey,LPCWSTR lpszKeyStrW,DWORD      dwReserved,REGSAM       samDesired,PHKEY        phkResult);

LONG WINAPI
OSUtil_RegCreateKeyExW(
    HKEY hKey, LPWSTR lpszSubKeyW, DWORD dwReserved, LPWSTR lpszClassW, DWORD dwOptions,
    REGSAM samDesired, LPSECURITY_ATTRIBUTES lpSecurityAttributes, PHKEY phkResult, LPDWORD lpdwDisposition);

LONG WINAPI
OSUtil_RegQueryValueExW(HKEY hKey,LPCWSTR lpszValueNameW,DWORD  *pdwType,BYTE* lpData,DWORD     *pcbData,BOOL fUnicodeCaller);

LONG WINAPI
OSUtil_RegSetValueExW(HKEY  hKey,LPCWSTR lpszValueNameW,DWORD   dwType,BYTE* lpData,DWORD       cbData,BOOL fUnicodeCaller);

HRESULT
ReadRegistryStringA(HKEY     hkey,LPCWSTR  pszValueNameW,LPCWSTR  pszDefaultValueW,BOOL     fExpand,LPWSTR * ppwszResult);
HRESULT
ReadRegistryStringW(HKEY     hkey,LPCWSTR  pszValueNameW,LPCWSTR  pszDefaultValueW,BOOL     fExpand,LPWSTR * ppwszResult);

#ifdef UNICODE
    #define ReadRegistryString ReadRegistryStringW
#else
    #define ReadRegistryString ReadRegistryStringA
#endif    

DWORD
ReadRegistryDwordW( HKEY   hkey,LPCWSTR pszValueNameW,DWORD   dwDefaultValue );

DWORD
WriteRegistryStringA(
    IN HKEY hkey,
    IN LPCSTR  pszValueName,
    IN LPCSTR  pszValue,
    IN DWORD   cbValue,
    IN DWORD   fdwType);

DWORD
WriteRegistryStringW(IN HKEY     hkey,
    IN LPCWSTR  pszValueNameW,IN LPCWSTR  pszValueW,IN DWORD    cbValue,IN DWORD    fdwType);

LONG WINAPI
OSUtil_RegDeleteValueW(HKEY hKey,LPWSTR lpszValueNameW);

HANDLE WINAPI
OSUtil_CreateFileW(
    LPCWSTR lpszFileNameW,DWORD dwDesiredAccess,DWORD dwShareMode,LPSECURITY_ATTRIBUTES lpSecurityAttributes,
    DWORD dwCreationDisposition,DWORD dwFlagsAndAttributes,HANDLE hTemplateFile);

HRESULT
WINAPI
ExtractCommandLineArgumentW(
    LPCSTR  lpszSwitchName,
    LPWSTR  pwszSwitchValue
    );

HRESULT
WINAPI
ExtractCommandLineArgumentA(
    LPCSTR  lpszSwitchName,
    LPSTR   pszSwitchValue
    );

/*****************************************************************************
 *
 *      string.c - Misc utilities , specific for platform
 *      Nb: Prorotypes for Cruntime string functions are in string.h
 *
 *****************************************************************************/
#pragma intrinsic(memcmp,memset,memcpy)

#define OSUtil_StrLenW  wcslen
#define OSUtil_StrCmpW  wcscmp
#define OSUtil_lstrcpyW wcscpy
#define OSUtil_lstrcatW wcscat
#define OSUtil_lstrcpynW wcsncpy

// Security.c
DWORD
CreateWellKnownSids(
        VOID
        );

VOID
FreeWellKnownSids(
    VOID
    );

DWORD
CreateGlobalSyncObjectSD(
    OUT PSECURITY_DESCRIPTOR *NewDescriptor
    );


/*****************************************************************************
 *
 *      mem.c - Memory management
 *
 *      Be extremely careful with FreePv, because it doesn't work if
 *      the pointer is null.
 *
 *****************************************************************************/

HRESULT  INLINE
AllocCbPpv(UINT cb, PPV ppv)
{
    HRESULT hres;
    *ppv = LocalAlloc(LPTR, cb);
    hres = *ppv ? NOERROR : E_OUTOFMEMORY;
    return hres;
}

#define FreePv(pv) LocalFree((HLOCAL)(pv))

void  INLINE
FreePpv(PPV ppv)
{
    PV pv = (PV)InterlockedExchangePointer(ppv,(PV) 0);
    if (pv) {
        FreePv(pv);
    }
}

#if 0
#define NEED_REALLOC

STDMETHODIMP EXTERNAL ReallocCbPpv(UINT cb, PV ppvObj);
STDMETHODIMP EXTERNAL AllocCbPpv(UINT cb, PV ppvObj);

#ifdef NEED_REALLOC
#define FreePpv(ppv) (void)ReallocCbPpv(0, ppv)
#else
void EXTERNAL FreePpv(PV ppv);
#define FreePpv(ppv) FreePpv(ppv)
#endif
#endif

#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\inc\stiregi.h ===
/*++

Copyright (c) 1986-1997  Microsoft Corporation

Module Name:

    stiregi.h

Abstract:

    This module contains internal only STI registry entries

Author:


Revision History:


--*/

#ifndef _STIREGI_
#define _STIREGI_

#include <stireg.h>

//
//
// Private flags to communicate with class installer
#define SCIW_PRIV_SHOW_FIRST        0x00000001
#define SCIW_PRIV_CALLED_FROMCPL    0x00000002

//

//
// Registry names
//
#define REGSTR_PATH_STICONTROL_W        L"System\\CurrentControlSet\\Control\\StillImage"
#define REGSTR_PATH_STIDEVICES_W        L"System\\CurrentControlSet\\Services\\Class"
#define REGSTR_PATH_STIDEVICES_NT_W     L"System\\CurrentControlSet\\Control\\Class"
#define REGSTR_PATH_REG_APPS_W          L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\StillImage\\Registered Applications"
#define REGSTR_PATH_ENUM_W              L"Enum"
#define REGSTR_PATH_EVENTS_W            L"\\Events"
#define REGSTR_PATH_LOGGING_W           L"\\Logging"
#define REGSTR_VAL_STIWIASVCDLL_W       L"WiaServiceDll"
#define REGSTR_VAL_LOCK_MGR_COOKIE_W    L"StiLockMgr"
#define REGSTR_PATH_STICONTROL_DEVLIST_W L"System\\CurrentControlSet\\Control\\StillImage\\DevList"
#define REGSTR_PATH_WIA_MSCDEVICES_W    L"System\\CurrentControlSet\\Control\\StillImage\\MSCDeviceList"

#define REGSTR_PATH_STICONTROL_A        "System\\CurrentControlSet\\Control\\StillImage"
#define REGSTR_PATH_STIDEVICES_A        "System\\CurrentControlSet\\Services\\Class"
#define REGSTR_PATH_STIDEVICES_NT_A     "System\\CurrentControlSet\\Control\\Class"
#define REGSTR_PATH_REG_APPS_A          "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\StillImage\\Registered Applications"
#define REGSTR_PATH_NT_ENUM_A           "System\\CurrentControlSet\\Enum"
#define REGSTR_PATH_EVENTS_A            "\\Events"
#define REGSTR_PATH_LOGGING_A           "\\Logging"
#define REGSTR_VAL_STIWIASVCDLL_A       "WiaServiceDll"
#define REGSTR_VAL_LOCK_MGR_COOKIE_A    "StiLockMgr"

#define REGSTR_PATH_SHAREDDLL       TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\SharedDlls")
#define REGSTR_PATH_SOFT_STI        TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\StillImage")

//  FIX:  This should be moved to stireg.h
#define STI_DEVICE_VALUE_HOLDINGTIME_A      "LockHoldingTime"
#define STI_DEVICE_VALUE_HOLDINGTIME_W      L"LockHoldingTime"


#if defined(UNICODE)
#define REGSTR_PATH_EVENTS           REGSTR_PATH_EVENTS_W
#define REGSTR_PATH_STIDEVICES_NT    REGSTR_PATH_STIDEVICES_NT_W
#define REGSTR_PATH_STIDEVICES       REGSTR_PATH_STIDEVICES_W
#define REGSTR_PATH_STICONTROL       REGSTR_PATH_STICONTROL_W
#define REGSTR_PATH_LOGGING          REGSTR_PATH_LOGGING_W
#define REGSTR_VAL_STIWIASVCDLL      REGSTR_VAL_STIWIASVCDLL_W
#define REGSTR_PATH_REG_APPS         REGSTR_PATH_REG_APPS_W
#define REGSTR_VAL_LOCK_MGR_COOKIE   REGSTR_VAL_LOCK_MGR_COOKIE_W
#define STI_DEVICE_VALUE_HOLDINGTIME STI_DEVICE_VALUE_HOLDINGTIME_W

#else
#define REGSTR_PATH_EVENTS         REGSTR_PATH_EVENTS_A
#define REGSTR_PATH_STIDEVICES_NT  REGSTR_PATH_STIDEVICES_NT_A
#define REGSTR_PATH_STIDEVICES     REGSTR_PATH_STIDEVICES_A
#define REGSTR_PATH_STICONTROL     REGSTR_PATH_STICONTROL_A
#define REGSTR_PATH_LOGGING        REGSTR_PATH_LOGGING_A
#define REGSTR_VAL_STIWIASVCDLL    REGSTR_VAL_STIWIASVCDLL_A
#define REGSTR_PATH_REG_APPS       REGSTR_PATH_REG_APPS_A
#define REGSTR_VAL_LOCK_MGR_COOKIE REGSTR_VAL_LOCK_MGR_COOKIE_A
#define STI_DEVICE_VALUE_HOLDINGTIME STI_DEVICE_VALUE_HOLDINGTIME_A

#endif

//
// Registry keys and values
//
#define REGSTR_VAL_DEVICEPORT_W      L"CreateFileName"
#define REGSTR_VAL_USD_CLASS_W       L"USDClass"
#define REGSTR_VAL_USD_CLASS_A       "USDClass"
#define REGSTR_VAL_DEV_NAME_W        L"DeviceName"
#define REGSTR_VAL_DRIVER_DESC_W     L"DriverDesc"
#define REGSTR_VAL_FRIENDLY_NAME_W   L"FriendlyName"
#define REGSTR_VAL_FRIENDLY_NAME     TEXT("FriendlyName")
#define REGSTR_VAL_GENERIC_CAPS_W    L"Capabilities"
#define REGSTR_VAL_HARDWARE_W        L"HardwareConfig"
#define REGSTR_VAL_DEVICE_NAME_W     L"DriverDesc"
#define REGSTR_VAL_PROP_PROVIDER_W   L"PropertyPages"
#define REGSTR_VAL_DATA_W            L"DeviceData"
#define REGSTR_VAL_SUBCLASS_W        L"SubClass"
#define REGSTR_VAL_SUBCLASS           TEXT("SubClass")
#define REGSTR_VAL_LAUNCH_APPS_W     L"LaunchApplications"
#define REGSTR_VAL_LAUNCH_APPS        TEXT("LaunchApplications")
#define REGSTR_VAL_LAUNCHABLE_W      L"Launchable"
#define REGSTR_VAL_LAUNCHABLE         TEXT("Launchable")
#define REGSTR_VAL_LOG_LEVEL          TEXT("Level")
#define REGSTR_VAL_LOG_MODE           TEXT("Mode")
#define REGSTR_VAL_LOG_MAXSIZE        TEXT("MaxSize")
#define REGSTR_VAL_LOG_TRUNCATE_ON_BOOT TEXT("TruncateOnBoot")
#define REGSTR_VAL_LOG_DETAIL         TEXT("Detail")
#define REGSTR_VAL_LOG_CLEARLOG_ON_BOOT TEXT("ClearLogOnBoot")
#define REGSTR_VAL_LOG_TO_DEBUGGER  TEXT("LogToDebugger")
#define REGSTR_VAL_INFPATH          TEXT("InfPath")
#define REGSTR_VAL_INFSECTION       TEXT("InfSection")
#define REGSTR_VAL_ISPNP            TEXT("IsPnP")
#define REGSTR_VAL_MONITOR          TEXT("StillImageMonitor")
#define REGSTR_VAL_WIA_PRESENT      TEXT("WIADevicePresent")
#define REGSTR_VAL_MAX_LOCK_WAIT_TIME  TEXT("MaxLockWaitTime")
#define REGSTR_VAL_ENABLE_VOLUMES_W   L"EnableVolumeDevices"
#define REGSTR_VAL_MAKE_VOLUMES_VISIBLE_W L"MakeVolumeDevicesVisible"
#define REGSTR_VAL_WIA_EVENT_DEVICE_CONNECTED   L"{a28bbade-64b6-11d2-a231-00c04fa31809}";
#define REGSTR_VAL_QUERYDEVICEFORNAME   TEXT("QueryDeviceForName")  // used by PTP driver to determine if it should ask the device for its model name

//
// Still Image Class Name defines
//

#define CLASSNAME                    TEXT("Image")
#define STILLIMAGE                   TEXT("StillImage")

// #define CLASSNAME                 "Image"              <- Original
#define CLASSNAME_W                  L"Image"
//#define STILLIMAGE                    "StillImage"      <- Original
#define STILLIMAGE_W                 L"StillImage"



//
// Event logging
//
#define REGSTR_VAL_EVENT_LOG_DIRECTORY_A   "EventLogDirectory"


#define REGSTR_VAL_DEBUG_FLAGS_W     L"DebugFlags"
#define REGSTR_VAL_DEBUG_FILE_W      L"DebugLogFile"
#define REGSTR_VAL_DEBUG_STIMONUI_W  L"DebugStiMonUI"
#define REGSTR_VAL_DEBUG_STIMONUIWIN_W  L"StiMonUIWin"
#define REGVAL_STR_STIMON_DEBUGMASK_W L"StiMonDebugMask"
#define REGSTR_VAL_MIGRATE_STI_W        L"MigrateSTIApps"

#define REGSTR_VAL_DEBUG_FLAGS_A     "DebugFlags"
#define REGSTR_VAL_DEBUG_FILE_A      "DebugLogFile"
#define REGSTR_VAL_DEBUG_STIMONUI_A  "DebugStiMonUI"
#define REGSTR_VAL_DEBUG_STIMONUIWIN_A  "StiMonUIWin"
#define REGVAL_STR_STIMON_DEBUGMASK_A "StiMonDebugMask"
#define REGSTR_VAL_MIGRATE_STI_A        "MigrateSTIApps"

#if defined(UNICODE)

#define REGSTR_VAL_USD_CLASS         REGSTR_VAL_USD_CLASS_W
#define REGSTR_VAL_DEBUG_FLAGS       REGSTR_VAL_DEBUG_FLAGS_W
#define REGSTR_VAL_DEBUG_FILE        REGSTR_VAL_DEBUG_FILE_W
#define REGSTR_VAL_DEBUG_STIMONUI    REGSTR_VAL_DEBUG_STIMONUI_W
#define REGSTR_VAL_DEBUG_STIMONUIWIN REGSTR_VAL_DEBUG_STIMONUIWIN_W
#define REGVAL_STR_STIMON_DEBUGMASK  REGVAL_STR_STIMON_DEBUGMASK_W
#define REGSTR_VAL_MIGRATE_STI       REGSTR_VAL_MIGRATE_STI_W

#else

#define REGSTR_VAL_USD_CLASS         REGSTR_VAL_USD_CLASS_A
#define REGSTR_VAL_DEBUG_FLAGS       REGSTR_VAL_DEBUG_FLAGS_A
#define REGSTR_VAL_DEBUG_FILE        REGSTR_VAL_DEBUG_FILE_A
#define REGSTR_VAL_DEBUG_STIMONUI    REGSTR_VAL_DEBUG_STIMONUI_A
#define REGSTR_VAL_DEBUG_STIMONUIWIN REGSTR_VAL_DEBUG_STIMONUIWIN_A
#define REGVAL_STR_STIMON_DEBUGMASK  REGVAL_STR_STIMON_DEBUGMASK_A
#define REGSTR_VAL_MIGRATE_STI       REGSTR_VAL_MIGRATE_STI_A

#endif


#endif // _STIREGI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\inc\stierr.h ===
/*++

Copyright (c) 1986-1997  Microsoft Corporation

Module Name:

    stierr.h

Abstract:

    This module contains the user mode still image APIs error and status codes

Author:


Revision History:


--*/

#ifndef _STIERR_
#define _STIERR_


//
// Generic test for success on any status value (non-negative numbers
// indicate success).
//

#define NT_SUCCESS(Status) ((NTSTATUS)(Status) >= 0)

//
// Generic test for information on any status value.
//

#define NT_INFORMATION(Status) ((ULONG)(Status) >> 30 == 1)

//
// Generic test for warning on any status value.
//

#define NT_WARNING(Status) ((ULONG)(Status) >> 30 == 2)

//
// Generic test for error on any status value.
//

#define NT_ERROR(Status) ((ULONG)(Status) >> 30 == 3)

//
// Error codes are constructed as compound COM status codes
//

/*
 * The operation completed successfully
 */
#define STI_OK  S_OK
#define STI_ERROR_NO_ERROR          STI_OK

/*
 * The device exists but not currently attached to the system
 */
#define STI_NOTCONNECTED            S_FALSE

/*
 * The requested change in device mode settings had no effect
 */
#define STI_CHANGENOEFFECT          S_FALSE

/*
 * The application requires newer version
 */
#define STIERR_OLD_VERSION      \
        MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,ERROR_OLD_WIN_VERSION)

/*
 * The application was written for pre-release version of provider DLL
 */
#define STIERR_BETA_VERSION     \
        MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,ERROR_RMODE_APP)

/*
 * The requested object could not be created due to incompatible or mismatched driver
 */
#define STIERR_BADDRIVER        \
        MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,ERROR_BAD_DRIVER_LEVEL)

/*
 * The device is not registered
 */
#define STIERR_DEVICENOTREG     REGDB_E_CLASSNOTREG

/*
 * The requested container does not exist
 */
#define STIERR_OBJECTNOTFOUND \
        MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,ERROR_FILE_NOT_FOUND)

/*
 * An invalid or not state matching parameter was passed to the API
 */
#define STIERR_INVALID_PARAM    E_INVALIDARG

/*
 * The specified interface is not supported
 */
#define STIERR_NOINTERFACE      E_NOINTERFACE

/*
 * The undetermined error occured
 */
#define STIERR_GENERIC          E_FAIL

/*
 * There is not enough memory to perform requested operation
 */
#define STIERR_OUTOFMEMORY      E_OUTOFMEMORY

/*
 * The application called unsupported (at this time)function
 */
#define STIERR_UNSUPPORTED      E_NOTIMPL

/*
 * The application requires newer version
 */
#define STIERR_NOT_INITIALIZED     \
        MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,ERROR_NOT_READY)

/*
 * The application requires newer version
 */
#define STIERR_ALREADY_INITIALIZED     \
        MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,ERROR_ALREADY_INITIALIZED)

/*
 * The operation can not performed while device is locked
 */
#define STIERR_DEVICE_LOCKED    \
        MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,ERROR_LOCK_VIOLATION)

/*
 * The specified propery can not be changed for this device
 */
#define STIERR_READONLY         E_ACCESSDENIED

/*
 * The device already has notification handle associated with it
 */
#define STIERR_NOTINITIALIZED   E_ACCESSDENIED


/*
 * The device needs to be locked before attempting this operation
 */
#define STIERR_NEEDS_LOCK    \
        MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,ERROR_NOT_LOCKED)

/*
 * The device is opened by another application in data mode
 */
#define STIERR_SHARING_VIOLATION    \
        MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,ERROR_SHARING_VIOLATION)


/*
 * Handle already set for this context
 */
#define STIERR_HANDLEEXISTS     \
        MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,ERROR_ALREADY_EXISTS)

 /*
  * Device name is not recognized
  */
#define STIERR_INVALID_DEVICE_NAME     \
        MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,ERROR_INVALID_NAME)

 /*
  * Device hardware type is not valid
  */
#define STIERR_INVALID_HW_TYPE     \
        MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,ERROR_INVALID_DATA)


 /*
  * Device hardware type is not valid
  */
#define STIERR_INVALID_HW_TYPE     \
        MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,ERROR_INVALID_DATA)

 /*
  * No events available
  */
#define STIERR_NOEVENTS     \
        MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,ERROR_NO_MORE_ITEMS)

 /*
  * Device appears as not ready
  */
#define STIERR_DEVICE_NOTREADY     \
        MAKE_HRESULT(SEVERITY_ERROR,FACILITY_WIN32,ERROR_NOT_READY)


//#define STIERR_


#endif // _STIERR_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\inc\stireg.h ===
/*++

Copyright (c) 1986-1997  Microsoft Corporation

Module Name:

    stireg.h

Abstract:

    This module contains the STI registry entries

Author:


Revision History:


--*/

#ifndef _STIREG_
#define _STIREG_

//
// Registry keys and values
//
#define REGSTR_VAL_TYPE_W            L"Type"
#define REGSTR_VAL_VENDOR_NAME_W     L"Vendor"
#define REGSTR_VAL_DEVICETYPE_W      L"DeviceType"
#define REGSTR_VAL_DEVICESUBTYPE_W   L"DeviceSubType"
#define REGSTR_VAL_DEV_NAME_W        L"DeviceName"
#define REGSTR_VAL_DRIVER_DESC_W     L"DriverDesc"
#define REGSTR_VAL_FRIENDLY_NAME_W   L"FriendlyName"
#define REGSTR_VAL_GENERIC_CAPS_W    L"Capabilities"
#define REGSTR_VAL_HARDWARE_W        L"HardwareConfig"
#define REGSTR_VAL_HARDWARE          TEXT("HardwareConfig")
#define REGSTR_VAL_DEVICE_NAME_W     L"DriverDesc"
#define REGSTR_VAL_DATA_W            L"DeviceData"
#define REGSTR_VAL_GUID_W            L"GUID"
#define REGSTR_VAL_GUID               TEXT("GUID")
#define REGSTR_VAL_LAUNCH_APPS_W     L"LaunchApplications"
#define REGSTR_VAL_LAUNCH_APPS        TEXT("LaunchApplications")
#define REGSTR_VAL_LAUNCHABLE_W      L"Launchable"
#define REGSTR_VAL_LAUNCHABLE         TEXT("Launchable")

//
// CustomDeviceProperty names and values
//
#define IS_DIGITAL_CAMERA_STR   L"IsDigitalCamera"
#define IS_DIGITAL_CAMERA_VAL   1
#define SUPPORTS_MSCPLUS_STR    L"SupportsMSCPlus"
#define SUPPORTS_MSCPLUS_VAL    1

//
// Device instance value names
//
#define STI_DEVICE_VALUE_TWAIN_NAME    L"TwainDS"
#define STI_DEVICE_VALUE_ISIS_NAME     L"ISISDriverName"
#define STI_DEVICE_VALUE_ICM_PROFILE   L"ICMProfile"
#define STI_DEVICE_VALUE_DEFAULT_LAUNCHAPP  L"DefaultLaunchApp"
#define STI_DEVICE_VALUE_TIMEOUT       L"PollTimeout"
#define STI_DEVICE_VALUE_DISABLE_NOTIFICATIONS  L"DisableNotifications"
#define REGSTR_VAL_BAUDRATE            L"BaudRate"

#define STI_DEVICE_VALUE_TWAIN_NAME_A  "TwainDS"
#define STI_DEVICE_VALUE_ISIS_NAME_A   "ISISDriverName"
#define STI_DEVICE_VALUE_ICM_PROFILE_A   "ICMProfile"
#define STI_DEVICE_VALUE_DEFAULT_LAUNCHAPP_A  "DefaultLaunchApp"
#define STI_DEVICE_VALUE_TIMEOUT_A       "PollTimeout"
#define STI_DEVICE_VALUE_DISABLE_NOTIFICATIONS_A  "DisableNotifications"
#define REGSTR_VAL_BAUDRATE_A            "BaudRate"


#endif // _STIREG_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\inc\stitwn.h ===
#ifdef __cplusplus
extern "C"{
#endif


//
//  NLS -- to TWAIN conversion
//
VOID
SetIdentityNLSParameters(
    TW_IDENTITY *pIdentityStruct,
    SHORT       *pDeviceKind
);


#ifdef __cplusplus
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\inc\stiusd.h ===
/*++

Copyright (c) 1986-1997  Microsoft Corporation

Module Name:

    stiusd.h

Abstract:

    Definitions file for creating STI User-mode Still-image Drivers ( USD).

Author:


Revision History:


--*/

#ifndef _STIUSD_
#define _STIUSD_

// Include COM definitions
#define COM_NO_WINDOWS_H

//
#pragma intrinsic(memcmp,memset)

//
// Include COM definitions
//
#ifndef _NO_COM
#include <objbase.h>
#endif

#include <stireg.h>
#include <stierr.h>

#ifdef __cplusplus
extern "C" {
#endif

/*
 * Class IID's
 */


/*
 * Interface IID's
 */
#if defined( _WIN32 ) && !defined( _NO_COM)

// {0C9BB460-51AC-11D0-90EA-00AA0060F86C}
DEFINE_GUID(IID_IStiUSD, 0x0C9BB460L, 0x51AC, 0x11D0, 0x90, 0xEA, 0x00, 0xAA, 0x00, 0x60, 0xF8, 0x6C);

// {128A9860-52DC-11D0-9EDF-444553540000}
DEFINE_GUID(IID_IStiDeviceControl, 0x128A9860L, 0x52DC, 0x11D0, 0x9E, 0xDF, 0x44, 0x45, 0x53, 0x54, 0x00, 0x00);

#endif

/*
 * Data structures
 */

typedef struct _STI_USD_CAPS {

    DWORD   dwVersion;          // STI version used to build this USD

    DWORD   dwGenericCaps;

} STI_USD_CAPS,*PSTI_USD_CAPS;


//
// Claims to support device notifications asyncronously ( without polling)
//
#define STI_USD_GENCAP_NATIVE_PUSHSUPPORT STI_GENCAP_NOTIFICATIONS

//
// Asks to open device automatically ( not implemented now)
//
// #define STI_USD_GENCAP_OPEN_DEVICE_FOR_ME 0x00000002

typedef DWORD   USD_CONTROL_CODE;

/*
 * Generic constants and definitions
 */

//
// Internally used flags for open device mode.

// USD receives this  bit only when associated device instance is created by monitor process
//
#define STI_DEVICE_CREATE_FOR_MONITOR   0x01000000


#ifdef __cplusplus

struct IStiUSD;
struct IStiDeviceControl;

#endif

typedef struct IStiUSD             *PSTIUSD;
typedef struct IStiDeviceControl   *PSTIDEVICECONTROL;


/*
 * IStiDeviceControl interface
 *
 * Instance of object supporting this interface is passed to USD at the moment
 * of device object initialization.
 */
#undef INTERFACE
#define INTERFACE IStiDeviceControl
DECLARE_INTERFACE_(IStiDeviceControl, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    /*** IStiDeviceControl methods ***/
    STDMETHOD(Initialize) (THIS_ DWORD dwDeviceType,DWORD dwMode,LPCWSTR pwszPortName,DWORD dwFlags )PURE;
    STDMETHOD(RawReadData)(THIS_ LPVOID lpBuffer,LPDWORD lpdwNumberOfBytes,LPOVERLAPPED lpOverlapped) PURE;
    STDMETHOD(RawWriteData)(THIS_ LPVOID lpBuffer,DWORD nNumberOfBytes,LPOVERLAPPED lpOverlapped) PURE;
    STDMETHOD(RawReadCommand)(THIS_ LPVOID lpBuffer,LPDWORD lpdwNumberOfBytes,LPOVERLAPPED lpOverlapped) PURE;
    STDMETHOD(RawWriteCommand)(THIS_ LPVOID lpBuffer,DWORD nNumberOfBytes,LPOVERLAPPED lpOverlapped) PURE;
    STDMETHOD(RawDeviceControl)(THIS_ USD_CONTROL_CODE EscapeFunction,LPVOID  lpInData,DWORD   cbInDataSize,LPVOID pOutData,DWORD dwOutDataSize,LPDWORD pdwActualData) PURE ;
    STDMETHOD(GetLastError)(THIS_ LPDWORD     lpdwLastError) PURE;
    STDMETHOD(GetMyDevicePortName)(THIS_ LPWSTR lpszDevicePath,DWORD cwDevicePathSize ) PURE;
    STDMETHOD(GetMyDeviceHandle)(THIS_ LPHANDLE lph) PURE;
    STDMETHOD(GetMyDeviceOpenMode)(THIS_ LPDWORD pdwOpenMode ) PURE;
    STDMETHOD(WriteToErrorLog)(THIS_ DWORD dwMessageType,LPCWSTR pszMessage,DWORD dwErrorCode) PURE;
} ;

#if !defined(__cplusplus) || defined(CINTERFACE)

#define IStiDeviceControl_QueryInterface(p,a,b)    (p)->lpVtbl->QueryInterface(p,a,b)
#define IStiDeviceControl_AddRef(p)                (p)->lpVtbl->AddRef(p)
#define IStiDeviceControl_Release(p)               (p)->lpVtbl->Release(p)
#define IStiDeviceControl_Initialize(p,a,b,c,d)    (p)->lpVtbl->Initialize(p,a,b,c,d)

#define IStiDeviceControl_RawReadData(p,a,b,c)     (p)->lpVtbl->RawReadData(p,a,b,c)
#define IStiDeviceControl_RawWriteData(p,a,b,c)    (p)->lpVtbl->RawWriteData(p,a,b,c)
#define IStiDeviceControl_RawReadCommand(p,a,b,c)  (p)->lpVtbl->RawReadCommand(p,a,b,c)
#define IStiDeviceControl_RawWriteCommand(p,a,b,c) (p)->lpVtbl->RawWriteCommand(p,a,b,c)
#define IStiDeviceControl_RawDeviceControl(p,a,b,c,d,e,f)   (p)->lpVtbl->RawDeviceControl(p,a,b,c,d,e,f)
#define IStiDeviceControl_GetLastError(p,a)        (p)->lpVtbl->GetLastError(p,a)
#define IStiDeviceControl_GetMyDevicePortName(p,a,b) (p)->lpVtbl->GetMyDevicePortName(p,a,b)
#define IStiDeviceControl_GetMyDeviceHandle(p,a)    (p)->lpVtbl->GetMyDeviceHandle(p,a)
#define IStiDeviceControl_GetMyDeviceOpenMode(p,a)  (p)->lpVtbl->GetMyDeviceOpenMode(p,a)
#define IStiDeviceControl_WriteToErrorLog(p,a,b,c)  (p)->lpVtbl->WriteToErrorLog(p,a,b,c)

#endif

/*
 * IStiUSD interface
 */
#undef INTERFACE
#define INTERFACE IStiUSD
DECLARE_INTERFACE_(IStiUSD, IUnknown)
{
    /*** IUnknown methods ***/
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    /*** IStiUSD methods ***/
    STDMETHOD(Initialize) (THIS_ PSTIDEVICECONTROL pHelDcb,DWORD dwStiVersion,HKEY hParametersKey) PURE;
    STDMETHOD(GetCapabilities) (THIS_ PSTI_USD_CAPS pDevCaps) PURE;
    STDMETHOD(GetStatus) (THIS_ PSTI_DEVICE_STATUS pDevStatus) PURE;
    STDMETHOD(DeviceReset)(THIS ) PURE;
    STDMETHOD(Diagnostic)(THIS_ LPSTI_DIAG pBuffer) PURE;
    STDMETHOD(Escape)(THIS_ STI_RAW_CONTROL_CODE    EscapeFunction,LPVOID  lpInData,DWORD   cbInDataSize,LPVOID pOutData,DWORD dwOutDataSize,LPDWORD pdwActualData) PURE ;
    STDMETHOD(GetLastError) (THIS_ LPDWORD pdwLastDeviceError) PURE;
    STDMETHOD(LockDevice) (THIS ) PURE;
    STDMETHOD(UnLockDevice) (THIS ) PURE;
    STDMETHOD(RawReadData)(THIS_ LPVOID lpBuffer,LPDWORD lpdwNumberOfBytes,LPOVERLAPPED lpOverlapped) PURE;
    STDMETHOD(RawWriteData)(THIS_ LPVOID lpBuffer,DWORD nNumberOfBytes,LPOVERLAPPED lpOverlapped) PURE;
    STDMETHOD(RawReadCommand)(THIS_ LPVOID lpBuffer,LPDWORD lpdwNumberOfBytes,LPOVERLAPPED lpOverlapped) PURE;
    STDMETHOD(RawWriteCommand)(THIS_ LPVOID lpBuffer,DWORD nNumberOfBytes,LPOVERLAPPED lpOverlapped) PURE;
    STDMETHOD(SetNotificationHandle)(THIS_ HANDLE hEvent) PURE;
    STDMETHOD(GetNotificationData)(THIS_ LPSTINOTIFY   lpNotify) PURE;
    STDMETHOD(GetLastErrorInfo) (THIS_ STI_ERROR_INFO *pLastErrorInfo) PURE;
} ;

#if !defined(__cplusplus) || defined(CINTERFACE)

#define IStiUSD_QueryInterface(p,a,b)    (p)->lpVtbl->QueryInterface(p,a,b)
#define IStiUSD_AddRef(p)                (p)->lpVtbl->AddRef(p)
#define IStiUSD_Release(p)               (p)->lpVtbl->Release(p)
#define IStiUSD_Initialize(p,a,b,c)      (p)->lpVtbl->Initialize(p,a,b,c)
#define IStiUSD_GetCapabilities(p,a)     (p)->lpVtbl->GetCapabilities(p,a)
#define IStiUSD_GetStatus(p,a)           (p)->lpVtbl->GetStatus(p,a)
#define IStiUSD_DeviceReset(p)           (p)->lpVtbl->DeviceReset(p)
#define IStiUSD_Diagnostic(p,a)          (p)->lpVtbl->Diagnostic(p,a)
#define IStiUSD_Escape(p,a,b,c,d,e,f)    (p)->lpVtbl->Escape(p,a,b,c,d,e,f)
#define IStiUSD_GetLastError(p,a)        (p)->lpVtbl->GetLastError(p,a)
#define IStiUSD_LockDevice(p)            (p)->lpVtbl->LockDevice(p)
#define IStiUSD_UnLockDevice(p)          (p)->lpVtbl->UnLockDevice(p)
#define IStiUSD_RawReadData(p,a,b,c)     (p)->lpVtbl->RawReadData(p,a,b,c)
#define IStiUSD_RawWriteData(p,a,b,c)    (p)->lpVtbl->RawWriteData(p,a,b,c)
#define IStiUSD_RawReadCommand(p,a,b,c)  (p)->lpVtbl->RawReadCommand(p,a,b,c)
#define IStiUSD_RawWriteCommand(p,a,b,c) (p)->lpVtbl->RawWriteCommand(p,a,b,c)
#define IStiUSD_SetNotificationHandle(p,a) (p)->lpVtbl->SetNotificationHandle(p,a)
#define IStiUSD_GetNotificationData(p,a) (p)->lpVtbl->GetNotificationData(p,a)
#define IStiUSD_GetLastErrorInfo(p,a)    (p)->lpVtbl->GetLastErrorInfo(p,a)

#endif

#ifdef __cplusplus
};
#endif

#endif // _STIUSD_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\inc\stistr.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    stistr.h

Abstract:

    Lightweight string classes: definition.
    Supports both UNICODE and single-byte character strings

Author:

    Vlad Sadovsky   (vlads) 26-Jan-1997
        (Lifted from another C++ project with some modifications and adjustments)

Revision History:

    26-Jan-1997     VladS       created
    20-Apr-1999     VladS       redesigned to inherit from ATL Cstring class

--*/


#ifndef _STRING_H_
#define _STRING_H_

#ifndef USE_OLD_STI_STRINGS

class StiCString : public CString
{

friend class RegEntry;

public:
    StiCString()
    {
        CString::CString();
    }

    ~StiCString()
    {
    }

    VOID
    CopyString(LPCTSTR  lpszT)
    {
        AssignCopy(lstrlen(lpszT),lpszT);
    }
};

class STRArray : public CSimpleArray<StiCString *>
{

public:

    STRArray()
    {

    }

    ~STRArray()
    {
        // Free all allocated strings
        for(int i = 0; i < m_nSize; i++)
        {
            if(m_aT[i] != NULL) {
                delete m_aT[i];
                m_aT[i] = NULL;
            }
        }
    }

    BOOL
    Add(
        LPCTSTR lpszT
        )
    {
        StiCString  *pNew;

        pNew = new StiCString;

        if (pNew) {
            pNew->CopyString(lpszT);
            return Add(pNew);
        }

        return FALSE;
    }


    BOOL
    Add(
        StiCString* pstr
        )
    {
        StiCString  *pNew;

        pNew = new StiCString;

        if (pNew) {
            *pNew = *pstr;
            return CSimpleArray<StiCString *>::Add(pNew);
        }

        return FALSE;
    }


};

VOID
TokenizeIntoStringArray(
    STRArray&   array,
    LPCTSTR lpstrIn,
    TCHAR tcSplitter
    );


#else

//
//
//


# include <buffer.h>


//
//  Maximum number of characters a loadable string resource can be
//

# define STR_MAX_RES_SIZE            ( 260)



class STR;

//
//  If an application defines STR_MODULE_NAME, it will be used
//  as the default module name on string loads
//

#ifndef STR_MODULE_NAME
#define STR_MODULE_NAME   NULL
#endif

//
//  These are the characters that are considered to be white space
//
#define ISWHITE( ch )       ((ch) == L'\t' || (ch) == L' ' || (ch) == L'\r')
#define ISWHITEA( ch )      ((ch) == '\t' || (ch) == ' ' || (ch) == '\r')


class STR : public BUFFER
{

friend class RegEntry;

public:

    STR()
    {
        _fUnicode = FALSE;
        _fValid   = TRUE;
    }

     STR( const CHAR  * pchInit );
     STR( const WCHAR * pwchInit );
     STR( const STR & str );
     //STR( UINT dwSize );

     BOOL Append( const CHAR  * pchInit );
     BOOL Append( const WCHAR * pwchInit );
     BOOL Append( const STR   & str );

     BOOL Copy( const CHAR  * pchInit );
     BOOL Copy( const WCHAR * pwchInit );
     BOOL Copy( const STR   & str );

     BOOL Resize( UINT cbNewReqestedSize );

    //
    //  Loads a string from this module's string resource table
    //

     BOOL LoadString( IN DWORD   dwResID,IN LPCTSTR lpszModuleName = STR_MODULE_NAME);
     BOOL LoadString( IN DWORD   dwResID,IN HMODULE hModule);

    //
    //  Loads a string with insert params from this module's .mc resource
    //  table.  Pass zero for the resource ID to use *this.
    //

    BOOL FormatStringV(
    IN LPCTSTR lpszModuleName,
    ...
    );

     BOOL FormatString( IN DWORD   dwResID,
                              IN LPCTSTR apszInsertParams[],
                              IN LPCTSTR lpszModuleName = STR_MODULE_NAME);

    //
    //  Returns the number of bytes in the string excluding the terminating
    //  NULL
    //
     UINT QueryCB( VOID ) const
        { return IsUnicode() ? ::wcslen((WCHAR *)QueryStrW()) * sizeof(WCHAR) :
                               ::strlen((CHAR *) QueryStrA());  }

    //
    //  Returns the number of characters in the string excluding the terminating
    //  NULL
    //
     UINT QueryCCH( VOID ) const
        { return IsUnicode() ? ::wcslen((WCHAR *)QueryStrW()) :
                               ::strlen((CHAR *) QueryStrA());  }

    //
    // Makes a Widechar copy of the stored string in given buffer
    //
     BOOL CopyToBuffer( WCHAR * lpszBuffer, LPDWORD lpcch) const;

    //
    // Makes a schar copy of the stored string in given buffer
    //
     BOOL CopyToBufferA( CHAR * lpszBuffer, LPDWORD lpcch) const;

    //
    // In-place conversion
    //
    BOOL ConvertToW(VOID);
    BOOL ConvertToA(VOID);

    //
    //  If the string buffer is empty, returns the empty string, otherwise
    //  returns a pointer to the buffer
    //
#if 1
     CHAR * QueryStrA( VOID ) const;
     WCHAR * QueryStrW( VOID ) const;
#else
    //
    // _pszEmptyString doesn't get imported corectly, results in unresolved
    // externals
    //
     CHAR * QueryStrA( VOID ) const
        { return (QueryPtr() ? (CHAR *) QueryPtr() : (CHAR *) _pszEmptyString); }

     WCHAR * QueryStrW( VOID ) const
        { return (QueryPtr() ? (WCHAR *) QueryPtr() : (WCHAR *) _pszEmptyString); }
#endif //!DBG


#ifdef UNICODE
     WCHAR * QueryStr( VOID ) const
        { return QueryStrW(); }
#else
     CHAR * QueryStr( VOID ) const
        { return QueryStrA(); }
#endif

     BOOL IsUnicode( VOID ) const
        { return _fUnicode; }

     VOID SetUnicode( BOOL fUnicode )
        { _fUnicode = fUnicode; }

     BOOL IsValid( VOID ) const
        { return _fValid; }

    //
    //  Checks and returns TRUE if this string has no valid data else FALSE
    //
     BOOL IsEmpty( VOID) const
         {    //return ( *QueryStr() == '\0'); }
                 if (!QuerySize()  || !QueryPtr()) {
                         return TRUE;
                 }
                 LPBYTE pb = (BYTE *)QueryPtr();

                 return (_fUnicode) ?
                         ((WCHAR)*pb==L'\0') : ((CHAR)*pb=='\0') ;
         }


    //
    //  Makes a clone of the current string in the string pointer passed in.
    //
     BOOL
      Clone( OUT STR * pstrClone) const
        {
            if ( pstrClone == NULL) {
               SetLastError( ERROR_INVALID_PARAMETER);
               return ( FALSE);
            } else {

                return ( pstrClone->Copy( *this));
            }
        } // STR::Clone()

    //
    // Useful operators
    //

    operator const TCHAR *() const { return QueryStr(); }

    const inline STR&  operator =(LPCSTR lpstr) { Copy(lpstr); return  *this; }
    const inline STR&  operator =(LPCWSTR lpwstr) { Copy(lpwstr); return  *this; }
    const inline STR&  operator =(STR& cs) { Copy(cs);return  *this;  }


    const inline STR&  operator +=(LPCSTR lpstr) { Append(lpstr);return  *this;  }
    const inline STR&  operator +=(LPCWSTR lpwstr) { Append(lpwstr);return  *this;  }
    const inline STR&  operator +=(STR& cs) { Append(cs);return  *this;  }


private:


    //
    //  TRUE if the string has already been mapped to Unicode
    //  FALSE if the string is in Latin1
    //

    BOOL  _fUnicode;
    BOOL  _fValid;

    //
    //  Returned when our buffer is empty
    //
     static WCHAR _pszEmptyString[];

    VOID AuxInit( PBYTE pInit, BOOL fUnicode );
    BOOL AuxAppend( PBYTE pInit, UINT cbStr, BOOL fAddSlop = TRUE );

};

class STRArray {
    STR     *m_pcsContents, m_csEmpty;
    unsigned    m_ucItems, m_ucMax, m_uGrowBy;

    void    Grow();

public:

    STRArray(UINT uGrowBy = 10);
    ~STRArray();

    UINT    Count() const { return m_ucItems; }

    void    Add(LPCSTR lpstrNew);
    void    Add(LPCWSTR lpstrNew);

    STR&    operator[](UINT u) {
        return  u < m_ucItems ? m_pcsContents[u] : m_csEmpty;
    }

    void    Tokenize(LPCTSTR lpstrIn, TCHAR tcSplitter);
};

#endif

#endif // !_STRING_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\inc\usbscan.h ===
/*++

Copyright (C) 1997, Logitech Inc.

Module Name:
    UsbScan.h

Abstract:
    Interface with UsbScan kernel driver

Environment:
    User and kernel mode use

Notes:
    Interface definition for USB still image driver.

--*/

#ifndef _USBSCAN_H_
#define _USBSCAN_H_

#ifndef MAX_NUM_PIPES
 #define MAX_NUM_PIPES   8
#endif

#define BULKIN_FLAG 0x80

typedef struct _DRV_VERSION {
    OUT     unsigned    major;
    OUT     unsigned    minor;
    OUT     unsigned    internal;
} DRV_VERSION, *PDRV_VERSION;

typedef struct _IO_BLOCK {
    IN      unsigned    uOffset;
    IN      unsigned    uLength;
    IN OUT  PUCHAR      pbyData;
    IN      unsigned    uIndex;
} IO_BLOCK, *PIO_BLOCK;

typedef struct _IO_BLOCK_EX {
    IN      unsigned    uOffset;
    IN      unsigned    uLength;
    IN OUT  PUCHAR      pbyData;
    IN      unsigned    uIndex;

    //
    // Following two fields are described in sec. 9.3.1,2 USB specification
    //
    IN      UCHAR       bRequest;               // Specific request
    IN      UCHAR       bmRequestType;          // Bitmap - charateristics of request
    IN      UCHAR       fTransferDirectionIn;   // TRUE - Device-->Host; FALSE - Host-->Device

} IO_BLOCK_EX, *PIO_BLOCK_EX;


typedef struct _CHANNEL_INFO {
    OUT     unsigned    EventChannelSize;
    OUT     unsigned    uReadDataAlignment;
    OUT     unsigned    uWriteDataAlignment;
} CHANNEL_INFO, *PCHANNEL_INFO;

typedef enum {
    EVENT_PIPE,
    READ_DATA_PIPE,
    WRITE_DATA_PIPE,
    ALL_PIPE
} PIPE_TYPE;


typedef struct _USBSCAN_GET_DESCRIPTOR {
    IN      UCHAR   DescriptorType;             // high byte of wValue field in USB spec.
    IN      UCHAR   Index;                      // low byte of wValue field in USB spec.
    IN      USHORT  LanguageId;                 // wIndex field in USB spec.
} USBSCAN_GET_DESCRIPTOR, *PUSBSCAN_GET_DESCRIPTOR;


//
// The device descriptor structure reports information define in the hardware.
// If there is enough space to copy the strings, it will be done otherwise
// only the three first fields:
//
//   USHORT usVendorId;
//   USHORT usProductId;
//   USHORT usBcdDevice;
//
// will contain valid data.  Remember: The strings are UNICODE format.
//

typedef struct _DEVICE_DESCRIPTOR {
    OUT     USHORT   usVendorId;
    OUT     USHORT   usProductId;
    OUT     USHORT   usBcdDevice;
    OUT     USHORT   usLanguageId;
//    IN OUT  PWCHAR   pszManufacturer;
//    IN OUT  unsigned uManufacturerStrSize;
//    IN OUT  PWCHAR   pszProduct;
//    IN OUT  unsigned uProductStrSize;
//    IN OUT  PWCHAR   pszSerialNb;
//    IN OUT  unsigned uSerialNbStrSize;
} DEVICE_DESCRIPTOR, *PDEVICE_DESCRIPTOR;

typedef enum _RAW_PIPE_TYPE {
    USBSCAN_PIPE_CONTROL,
    USBSCAN_PIPE_ISOCHRONOUS,
    USBSCAN_PIPE_BULK,
    USBSCAN_PIPE_INTERRUPT
} RAW_PIPE_TYPE;

typedef struct _USBSCAN_PIPE_INFORMATION {
    USHORT          MaximumPacketSize;  // Maximum packet size for this pipe
    UCHAR           EndpointAddress;    // 8 bit USB endpoint address (includes direction)
    UCHAR           Interval;           // Polling interval in ms if interrupt pipe 
    RAW_PIPE_TYPE   PipeType;           // PipeType identifies type of transfer valid for this pipe
} USBSCAN_PIPE_INFORMATION, *PUSBSCAN_PIPE_INFORMATION;

typedef struct _USBSCAN_PIPE_CONFIGURATION {
    OUT     ULONG                          NumberOfPipes;
    OUT     USBSCAN_PIPE_INFORMATION       PipeInfo[MAX_NUM_PIPES];
} USBSCAN_PIPE_CONFIGURATION, *PUSBSCAN_PIPE_CONFIGURATION;

typedef struct _USBSCAN_TIMEOUT {
    ULONG           TimeoutRead;
    ULONG           TimeoutWrite;
    ULONG           TimeoutEvent;
} USBSCAN_TIMEOUT, *PUSBSCAN_TIMEOUT;


#define FILE_DEVICE_USB_SCAN    0x8000
#define IOCTL_INDEX             0x0800

#define IOCTL_GET_VERSION               CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX,   METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_CANCEL_IO                 CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+1, METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_WAIT_ON_DEVICE_EVENT      CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+2, METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_READ_REGISTERS            CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+3, METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_WRITE_REGISTERS           CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+4, METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_GET_CHANNEL_ALIGN_RQST    CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+5, METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_GET_DEVICE_DESCRIPTOR     CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+6, METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_RESET_PIPE                CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+7, METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_GET_USB_DESCRIPTOR        CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+8, METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SEND_USB_REQUEST          CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+9, METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_GET_PIPE_CONFIGURATION    CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+10,METHOD_BUFFERED,FILE_ANY_ACCESS)
#define IOCTL_SET_TIMEOUT               CTL_CODE(FILE_DEVICE_USB_SCAN,IOCTL_INDEX+11,METHOD_BUFFERED,FILE_ANY_ACCESS)

//
// Temporary to avoid breaking LOGISCAN code
//
#define ALL ALL_PIPE
#define IOCTL_ABORT_PIPE        IOCTL_CANCEL_IO
//
//
#endif // _USBSCAN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\inc\svcinfo.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    svcinfo.h

Abstract:

Author:

    Vlad Sadovsky (vlads)   22-Sep-1997


Environment:

    User Mode - Win32

Revision History:

    22-Sep-1997     VladS       created

--*/


# ifndef _SVCINFO_H_
# define _SVCINFO_H_

/************************************************************
 *     Include Headers
 ************************************************************/

#include <base.h>

/***********************************************************
 *    Named constants  definitions
 ************************************************************/

/************************************************************
 *    Private Constants
 ************************************************************/

#define NULL_SERVICE_STATUS_HANDLE      ( (SERVICE_STATUS_HANDLE ) NULL)
#define SERVICE_START_WAIT_HINT         ( 10000)        // milliseconds
#define SERVICE_STOP_WAIT_HINT          ( 10000)        // milliseconds

#ifndef DLLEXP
//#define DLLEXP __declspec( dllexport )
#define DLLEXP
#endif


/************************************************************
 *   Type Definitions
 ************************************************************/

#define SIGNATURE_SVC      (DWORD)'SVCa'
#define SIGNATURE_SVC_FREE (DWORD)'SVCf'

//
// These functions get called back with the pointer to SvcInfo object
// as the context parameter.
//
typedef   DWORD ( *PFN_SERVICE_SPECIFIC_INITIALIZE) ( LPVOID pContext);

typedef   DWORD ( *PFN_SERVICE_SPECIFIC_CLEANUP)    ( LPVOID pContext);

typedef   DWORD ( *PFN_SERVICE_SPECIFIC_PNPPWRHANDLER) ( LPVOID pContext,UINT   msg,WPARAM wParam,LPARAM lParam);

typedef   VOID  ( *PFN_SERVICE_CTRL_HANDLER)        ( DWORD  OpCode);

class  SVC_INFO : public BASE  {

    private:

      DWORD       m_dwSignature;

      SERVICE_STATUS          m_svcStatus;
      SERVICE_STATUS_HANDLE   m_hsvcStatus;
      HANDLE                  m_hShutdownEvent;

      STR       m_sServiceName;
      STR       m_sModuleName;

      //
      //  Call back functions for service specific data/function
      //

      PFN_SERVICE_SPECIFIC_INITIALIZE m_pfnInitialize;
      PFN_SERVICE_SPECIFIC_CLEANUP    m_pfnCleanup;
      PFN_SERVICE_SPECIFIC_PNPPWRHANDLER m_pfnPnpPower;

      DWORD ReportServiceStatus( VOID);
      VOID  InterrogateService( VOID );
      VOID  StopService( VOID );
      VOID  PauseService( VOID );
      VOID  ContinueService( VOID );
      VOID  ShutdownService( VOID );

  public:

    // *** IUnknown methods ***
    STDMETHODIMP QueryInterface( REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef( void);
    STDMETHODIMP_(ULONG) Release( void);

    //
    //  Initialization/Termination related methods
    //


    SVC_INFO(
        IN  LPCTSTR                          lpszServiceName,
        IN  TCHAR  *                         lpszModuleName,
        IN  PFN_SERVICE_SPECIFIC_INITIALIZE  pfnInitialize,
        IN  PFN_SERVICE_SPECIFIC_CLEANUP     pfnCleanup,
        IN  PFN_SERVICE_SPECIFIC_PNPPWRHANDLER pfnPnpPower
        );

      ~SVC_INFO( VOID);


    BOOL IsValid(VOID) const
    {
        return (( QueryError() == NO_ERROR) && (m_dwSignature == SIGNATURE_SVC));
    }

    DWORD QueryCurrentServiceState( VOID) const
    {
        return ( m_svcStatus.dwCurrentState);
    }

    //
    //  Parameter access methods.
    //


    //
    //  Service control related methods
    //

    LPCTSTR QueryServiceName(VOID) const
    {
        return m_sServiceName.QueryStr();
    }

    DWORD
    QueryServiceSpecificExitCode( VOID) const
    {
        return ( m_svcStatus.dwServiceSpecificExitCode);
    }

    VOID
    SetServiceSpecificExitCode( DWORD err)
    {
        m_svcStatus.dwServiceSpecificExitCode = err;
    }

    DWORD
    DelayCurrentServiceCtrlOperation( IN DWORD dwWaitHint)
    {
        return
          UpdateServiceStatus(m_svcStatus.dwCurrentState,
                              m_svcStatus.dwWin32ExitCode,
                              m_svcStatus.dwCheckPoint,
                              dwWaitHint);
    }

    DWORD
    UpdateServiceStatus(IN DWORD State,
                          IN DWORD Win32ExitCode,
                          IN DWORD CheckPoint,
                          IN DWORD WaitHint );

    VOID
    ServiceCtrlHandler( IN DWORD dwOpCode);

    DWORD
    StartServiceOperation(
        IN  PFN_SERVICE_CTRL_HANDLER         pfnCtrlHandler
        );


    //
    //  Miscellaneous methods
    //

};  // class SVC_INFO

typedef SVC_INFO * PSVC_INFO;


/************************************************************
 *    Macros
 ************************************************************/


//
//
//  Use the following macro once in outer scope of the file
//  where we construct the global SvcInfo object.
//
//  Every client of SvcInfo should define the following macro
//  passing as parameter their global pointer to SvcInfo object
//  This is required to generate certain stub functions, since
//  the service controller call-back functions do not return
//  the context information.
//
//  Also we define the global g_pSvcInfo variable and
//  a static variable gs_pfnSch,which is a pointer to the local service control handler function.
//

# define   _INTERNAL_DEFINE_SVCINFO_INTERFACE( pSvcInfo)   \
                                                    \
    static  VOID ServiceCtrlHandler( DWORD OpCode)  \
        {                                           \
            ( pSvcInfo)->ServiceCtrlHandler( OpCode); \
        }                                           \
                                                    \
    static PFN_SERVICE_CTRL_HANDLER gs_pfnSch = ServiceCtrlHandler;

//
// Since all the services should use the global variable called g_pSvcInfo
// this is a convenience macro for defining the interface for services
// structure
//
# define DEFINE_SVC_INFO_INTERFACE()   \
        PSVC_INFO         g_pSvcInfo;                \
        _INTERNAL_DEFINE_SVCINFO_INTERFACE( g_pSvcInfo);

//
//  Use the macro SERVICE_CTRL_HANDLER() to pass the parameter for
//  service control handler when we initialize the SvcInfo object
//
# define   SERVICE_CTRL_HANDLER()       ( gs_pfnSch)

# endif // _SVCINFO_H_

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\inc\stitrace.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    stitrace.h

Abstract:

    This file defines functions and types required to support file logging
    for all STI components
    

Author:

    Vlad Sadovsky (vlads)   02-Sep-1997


Environment:

    User Mode - Win32

Revision History:

    02-Sep-1997     VladS       created

--*/

# ifndef _STITRACE_H_
# define _STITRACE_H_

# include <windows.h>

#include <base.h>

/***********************************************************
 *    Named constants  definitions
 ************************************************************/

#define STI_TRACE_INFORMATION       0x0001
#define STI_TRACE_WARNING           0x0002
#define STI_TRACE_ERROR             0x0004

/***********************************************************
 *    Type Definitions
 ************************************************************/

class STI_FILE_LOG  : public BASE {

  private:

     LPCTSTR   m_lpszSource;    // Name of the file , containing log

  public:

     dllexp
     STI_FILE_LOG( IN LPCTSTR lpszSourceName);   // name of source for event log

     dllexp
    ~STI_FILE_LOG( VOID);

     dllexp
     VOID
     LogEvent(
        IN DWORD  idMessage,                  // id for log message
        IN WORD   cSubStrings,                // count of substrings
        IN const CHAR * apszSubStrings[],     // substrings in the message
        IN DWORD  errCode = 0);               // error code if any

     VOID
     LogEvent(
        IN DWORD  idMessage,                  // id for log message
        IN WORD   cSubStrings,                // count of substrings
        IN CHAR * apszSubStrings[],           // substrings in the message
        IN DWORD  errCode = 0)                // error code if any
    {
        LogEvent(idMessage, cSubStrings,
                 (const CHAR **) apszSubStrings, errCode);
    }

     dllexp
     VOID
     LogEvent(
        IN DWORD   idMessage,                  // id for log message
        IN WORD    cSubStrings,                // count of substrings
        IN WCHAR * apszSubStrings[],           // substrings in the message
        IN DWORD   errCode = 0);               // error code if any

     BOOL Success( VOID) const
     { return ( m_ErrorCode == NO_ERROR); }

     DWORD GetErrorCode( VOID) const
     { return ( m_ErrorCode); }

  private:

     dllexp VOID
     LogEventPrivate(
        IN DWORD idMessage,
        IN WORD  wEventType,
        IN WORD  cSubStrings,
        IN const CHAR * apszSubStrings[],
        IN DWORD  errCode);

};

typedef EVENT_LOG * LPEVENT_LOG;

# endif // _STITRACE_H_

/************************ End of File ***********************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\inc\stisvc.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    svcinfo.h

Abstract:

Author:

    Vlad Sadovsky (vlads)   22-Sep-1997


Environment:

    User Mode - Win32

Revision History:

    22-Sep-1997     VladS       created

--*/


# ifndef _STISVC_H_
# define _STISVC_H_

//
// Service name.  Note:  Some strings are filename dependant, and must be
// updated if the filenames change.
//
#define STI_SERVICE_NAME        TEXT("StiSvc")
#define STI_DISPLAY_NAME        TEXT("Windows Image Acquisition (WIA)")
#define STI_IMAGE_NAME          TEXT("%systemroot%\\system32\\stisvc.exe")
#define STI_IMAGE_NAME_SVCHOST  TEXT("%SystemRoot%\\system32\\svchost.exe -k imgsvc")
#define STI_IMGSVC              TEXT("imgsvc")
#define REGSTR_SERVICEDLL       TEXT("ServiceDll")
#define STI_SERVICE__DATA       0x19732305
#define STI_SVC_HOST            REGSTR_PATH_NT_CURRENTVERSION TEXT("\\svchost")
#define STI_SERVICE_PARAMS      REGSTR_PATH_SERVICES TEXT("\\") STI_SERVICE_NAME TEXT("\\Parameters")
#define STI_SVC_DEPENDENCIES    TEXT("RpcSs\0\0")

#ifdef WINNT
    #define SYSTEM_PATH         TEXT("%SystemRoot%\\system32\\")
    #define PATH_REG_TYPE       REG_EXPAND_SZ
    #define SERVICE_FILE_NAME   TEXT("svchost.exe")
#else
    #define SYSTEM_PATH         TEXT("\\system\\")
    #define PATH_REG_TYPE       REG_SZ
    #define SERVICE_FILE_NAME   TEXT("stimon.exe")
#endif



//
// SCM parameters
//
#define START_HINT  4000
#define PAUSE_HINT  2000

#define STI_STOP_FOR_REMOVE_TIMEOUT 1000

//
// STI API specific access rights
//

//#define STI_SVC_SERVICE_TYPE    (SERVICE_WIN32_OWN_PROCESS | SERVICE_INTERACTIVE_PROCESS)
#define STI_SVC_SERVICE_TYPE    (SERVICE_WIN32_SHARE_PROCESS | SERVICE_INTERACTIVE_PROCESS)


#define STI_QUERY_SECURITY              0x0001
#define STI_SET_SECURITY                0x0002
#define STI_QUERY_STATISTICS            0x0004
#define STI_CLEAR_STATISTICS            0x0008
#define STI_QUERY_ADMIN_INFORMATION     0x0010
#define STI_SET_ADMIN_INFORMATION       0x0020

#define STI_ALL_ACCESS         (STANDARD_RIGHTS_REQUIRED       | \
                                 SYNCHRONIZE                   | \
                                 STI_QUERY_SECURITY            | \
                                 STI_SET_SECURITY              | \
                                 STI_QUERY_STATISTICS          | \
                                 STI_CLEAR_STATISTICS          | \
                                 STI_QUERY_ADMIN_INFORMATION   | \
                                 STI_SET_ADMIN_INFORMATION       \
                                )

#define STI_GENERIC_READ       (STANDARD_RIGHTS_READ           | \
                                 STI_QUERY_SECURITY            | \
                                 STI_QUERY_ADMIN_INFORMATION   | \
                                 STI_QUERY_STATISTICS)

#define STI_GENERIC_WRITE      (STANDARD_RIGHTS_WRITE          | \
                                 STI_SET_SECURITY              | \
                                 STI_SET_ADMIN_INFORMATION     | \
                                 STI_CLEAR_STATISTICS)

#define STI_GENERIC_EXECUTE    (STANDARD_RIGHTS_EXECUTE)

#define STI_SERVICE_CONTROL_BEGIN           128
#define STI_SERVICE_CONTROL_REFRESH         STI_SERVICE_CONTROL_BEGIN
#define STI_SERVICE_CONTROL_LPTENUM         STI_SERVICE_CONTROL_BEGIN+1
#define STI_SERVICE_CONTROL_EVENT_REREAD    STI_SERVICE_CONTROL_BEGIN+2
#define STI_SERVICE_CONTROL_END             STI_SERVICE_CONTROL_BEGIN+2

#endif // _STISVC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\inc\vcamprop.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1998
*
*  TITLE:       VCamProp.H
*
*  VERSION:     1.0
*
*  AUTHOR:      RickTu
*
*  DATE:        29 Sept, 1999
*
*  DESCRIPTION:
*   Definitions and declarations for DS Camera's private properties.
*
*******************************************************************************/

#ifndef __VCAMPROP_H__
#define __VCAMPROP_H__

#include  <guiddef.h>

//
// Private commands enabling WIA Video to respond to 
// TAKE_PICTURE commands sent to Video Driver.
//

const GUID WIA_CMD_ENABLE_TAKE_PICTURE =
{ /* 9bc87d4d-e949-44ce-866c-c6921302032d */
    0x9bc87d4d,
    0xe949,
    0x44ce,
    {0x86, 0x6c, 0xc6, 0x92, 0x13, 0x02, 0x03, 0x2d}
};

//
// Private command to tell the driver to create the DirectShow graph
//

const GUID WIA_CMD_DISABLE_TAKE_PICTURE =
{ /* 8127f490-1beb-4271-9f04-9c8e983f51fd */
    0x8127f490,
    0x1beb,
    0x4271,
    { 0x9f, 0x04, 0x9c, 0x8e, 0x98, 0x3f, 0x51, 0xfd}
};



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\inc\waitcurs.h ===
/*******************************************************************************
 *
 *  (C) COPYRIGHT MICROSOFT CORPORATION, 1998
 *
 *  TITLE:       WAITCURS.H
 *
 *  VERSION:     1.0
 *
 *  AUTHOR:      ShaunIv
 *
 *  DATE:        5/3/1999
 *
 *  DESCRIPTION: Change the cursor to an hourglass during lengthy operations.  To
 *               use, just put a CWaitCursor wc; in your function.  It will restore
 *               the cursor when the class is destroyed (usually when the function
 *               is exited.
 *
 *******************************************************************************/
#ifndef __WAITCURS_H_INCLUDED
#define __WAITCURS_H_INCLUDED

class CWaitCursor
{
private:
    HCURSOR m_hCurOld;
public:
    CWaitCursor(void)
    {
        m_hCurOld = SetCursor( LoadCursor( NULL, IDC_WAIT ) );
    }
    ~CWaitCursor(void)
    {
        SetCursor(m_hCurOld);
    }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\inc\validate.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    validate.h

Abstract:

Author:

    Vlad Sadovsky   (vlads) 26-Jun-1998

Revision History:

    26-Jun-1998     VladS       created

--*/

#ifndef _validate_h_
#define _validate_h_

#include <stidebug.h>

#ifdef __cplusplus
extern "C" {
#endif

/* parameter validation macros */

/*
 * call as:
 *
 * bOK = IS_VALID_READ_PTR(pfoo, CFOO);
 *
 * bOK = IS_VALID_HANDLE(hfoo, FOO);
 */

#ifdef DEBUG

#define IS_VALID_READ_PTR(ptr, type) \
   (IsBadReadPtr((ptr), sizeof(type)) ? \
    (DPRINTF(DM_ERROR, TEXT("invalid %hs read pointer - %#08lx"), (LPCSTR)#type TEXT(" *"), (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_WRITE_PTR(ptr, type) \
   (IsBadWritePtr((PVOID)(ptr), sizeof(type)) ? \
    (DPRINTF(DM_ERROR, TEXT("invalid %hs write pointer - %#08lx"), (LPCSTR)#type TEXT(" *"), (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_STRING_PTRA(ptr, cch) \
   ((IsBadReadPtr((ptr), sizeof(char)) || IsBadStringPtrA((ptr), (UINT)(cch))) ? \
    (DPRINTF(DM_ERROR, TEXT("invalid LPSTR pointer - %#08lx"), (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_STRING_PTRW(ptr, cch) \
   ((IsBadReadPtr((ptr), sizeof(WCHAR)) || IsBadStringPtrW((ptr), (UINT)(cch))) ? \
    (DPRINTF(DM_ERROR, TEXT("invalid LPWSTR pointer - %#08lx"), (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_CODE_PTR(ptr, type) \
   (IsBadCodePtr((FARPROC)(ptr)) ? \
    (DPRINTF(DM_ERROR, TEXT("invalid %hs code pointer - %#08lx"), (LPCSTR)#type, (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_READ_BUFFER(ptr, type, len) \
   (IsBadReadPtr((ptr), sizeof(type)*(len)) ? \
    (DPRINTF(DM_ERROR, TEXT("invalid %hs read buffer pointer - %#08lx"), (LPCSTR)#type TEXT(" *"), (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_WRITE_BUFFER(ptr, type, len) \
   (IsBadWritePtr((ptr), sizeof(type)*(len)) ? \
    (DPRINTF(DM_ERROR, TEXT("invalid %hs write buffer pointer - %#08lx"), (LPCSTR)#type TEXT(" *"), (ptr)), FALSE) : \
    TRUE)

#define FLAGS_ARE_VALID(dwFlags, dwAllFlags) \
   (((dwFlags) & (~(dwAllFlags))) ? \
    (DPRINTF(DM_ERROR, TEXT("invalid flags set - %#08lx"), ((dwFlags) & (~(dwAllFlags)))), FALSE) : \
    TRUE)

#define IS_VALID_PIDL(ptr) \
   ( !IsValidPIDL(ptr) ? \
    (DPRINTF(DM_ERROR, TEXT("invalid PIDL pointer - %#08lx"), (ptr)), FALSE) : \
    TRUE)

#define IS_VALID_SIZE(cb, cbExpected) \
   ((cb) != (cbExpected) ? \
    (DPRINTF(DM_ERROR, TEXT("invalid size - is %#08lx, expected %#08lx"), (cb), (cbExpected)), FALSE) : \
    TRUE)


#else

#define IS_VALID_READ_PTR(ptr, type) \
   (! IsBadReadPtr((ptr), sizeof(type)))

#define IS_VALID_WRITE_PTR(ptr, type) \
   (! IsBadWritePtr((PVOID)(ptr), sizeof(type)))

#define IS_VALID_STRING_PTRA(ptr, cch) \
   (! IsBadStringPtrA((ptr), (UINT)(cch)))

#define IS_VALID_STRING_PTRW(ptr, cch) \
   (! IsBadStringPtrW((ptr), (UINT)(cch)))

#define IS_VALID_CODE_PTR(ptr, type) \
   (! IsBadCodePtr((FARPROC)(ptr)))

#define IS_VALID_READ_BUFFER(ptr, type, len) \
   (! IsBadReadPtr((ptr), sizeof(type)*(len)))

#define IS_VALID_WRITE_BUFFER(ptr, type, len) \
   (! IsBadWritePtr((ptr), sizeof(type)*(len)))

#define FLAGS_ARE_VALID(dwFlags, dwAllFlags) \
   (((dwFlags) & (~(dwAllFlags))) ? FALSE : TRUE)

#define IS_VALID_PIDL(ptr) \
   (IsValidPIDL(ptr))

#define IS_VALID_SIZE(cb, cbExpected) \
   ((cb) == (cbExpected))

#endif

#ifdef UNICODE
#define IS_VALID_STRING_PTR     IS_VALID_STRING_PTRW
#else
#define IS_VALID_STRING_PTR     IS_VALID_STRING_PTRA
#endif


/* handle validation macros */

#ifdef DEBUG

#define IS_VALID_HANDLET(hnd, type) \
   (IsValidH##type(hnd) ? \
    TRUE : \
    (DPRINTF(DM_ERROR, TEXT("invalid H") #type TEXT(" - %#08lx"), (hnd)), FALSE))

#else

#define IS_VALID_HANDLET(hnd, type) \
   (IsValidH##type(hnd))

#endif

//
// Validation macros
//

//#define IS_VALID_HANDLE(h)  (((h) != NULL) && ((h) != INVALID_HANDLE_VALUE))

#define IS_VALID_HANDLE(hnd)    (IsValidHANDLE(hnd))

/* structure validation macros */

// Define VSTF if you want to validate the fields in structures.  This
// requires a handler function (of the form IsValid*()) that knows how
// to validate the specific structure type.

#ifdef VSTF

#ifdef DEBUG

#define IS_VALID_STRUCT_PTR(ptr, type) \
   (IsValidP##type(ptr) ? \
    TRUE : \
    (DPRINTF(DM_ERROR, TEXT("invalid %hs pointer - %#08lx"), (LPCSTR)#type TEXT(" *"), (ptr)), FALSE))

#define IS_VALID_STRUCTEX_PTR(ptr, type, x) \
   (IsValidP##type(ptr, x) ? \
    TRUE : \
    (DPRINTF(DM_ERROR, TEXT("invalid %hs pointer - %#08lx"), (LPCSTR)#type TEXT(" *"), (ptr)), FALSE))

#else

#define IS_VALID_STRUCT_PTR(ptr, type) \
   (IsValidP##type(ptr))

#define IS_VALID_STRUCTEX_PTR(ptr, type, x) \
   (IsValidP##type(ptr, x))

#endif

#else

#define IS_VALID_STRUCT_PTR(ptr, type) \
   (! IsBadReadPtr((ptr), sizeof(type)))

#define IS_VALID_STRUCTEX_PTR(ptr, type, x) \
   (! IsBadReadPtr((ptr), sizeof(type)))

#endif  // VSTF

/* OLE interface validation macro */

#define IS_VALID_INTERFACE_PTR(ptr, iface) \
   IS_VALID_STRUCT_PTR(ptr, ##iface)



BOOL IsValidHANDLE(HANDLE hnd);         // Compares with NULL and INVALID_HANDLE_VALUE
BOOL IsValidHANDLE2(HANDLE hnd);        // Compares with INVALID_HANDLE_VALUE

BOOL
IsValidHWND(
    HWND hwnd);

BOOL
IsValidHMENU(
    HMENU hmenu);

BOOL
IsValidShowCmd(
    int nShow);

#ifdef __cplusplus
};
#endif

#endif // _validate_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\inc\wiaconv.h ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    conv.h

Abstract:

    UNICODE / ASCII conversion macros

Author:

    Hakki T. Bostanci (hakkib)  5-Aug-1998

Revision History:

    Vlad Sadovsky ( vlads )     15-Jan-2001 Adopted for more common use


--*/

#ifndef __WIACONV_H__
#define __WIACONV_H__

#include <malloc.h>

//
// in case MFC or ATL conversion helpers are already defined, undef these
//

#undef USES_CONVERSION
#undef W2A
#undef A2W
#undef T2A
#undef A2T
#undef T2W
#undef W2T
#undef T2O
#undef O2T
#undef T2DA
#undef A2DT
#undef T2DW
#undef W2DT
#undef _wcsdupa
#undef _strdupa
#undef _tcsdupa

// USES_CONVERSION must be defined in every function that uses the
// conversion macros

#define USES_CONVERSION int __nLength; PCWSTR __pUnicode; PCSTR __pAscii

//////////////////////////////////////////////////////////////////////////
//
// W2A
//
// Routine Description:
//   Converts a UNICODE string to ASCII. Allocates the coversion buffer
//   off the stack using _alloca
//
// Arguments:
//   pStr          UNICODE string
//
// Return Value:
//   the converted ASCII string
//

#define W2A(pStr)                                               \
                                                                \
    ((__pUnicode = pStr) == 0 ? (PSTR) 0 : (                    \
                                                                \
    __nLength = WideCharToMultiByte(                            \
        CP_ACP,                                                 \
        0,                                                      \
        __pUnicode,                                             \
        -1,                                                     \
        0,                                                      \
        0,                                                      \
        0,                                                      \
        0                                                       \
    ),                                                          \
                                                                \
    __pAscii = (PCSTR) _alloca(__nLength * sizeof(CHAR)),       \
                                                                \
    WideCharToMultiByte(                                        \
        CP_ACP,                                                 \
        0,                                                      \
        __pUnicode,                                             \
        -1,                                                     \
        (PSTR) __pAscii,                                        \
        __nLength,                                              \
        0,                                                      \
        0                                                       \
    ),                                                          \
                                                                \
    (PSTR) __pAscii))                                           \


//////////////////////////////////////////////////////////////////////////
//
// A2W
//
// Routine Description:
//   Converts an ASCII string to UNICODE. Allocates the coversion buffer
//   off the stack using _alloca
//
// Arguments:
//   pStr          ASCII string
//
// Return Value:
//   the converted UNICODE string
//

#define A2W(pStr)                                               \
                                                                \
    ((__pAscii = pStr) == 0 ? (PWSTR) 0 : (                     \
                                                                \
    __nLength = MultiByteToWideChar(                            \
        CP_ACP,                                                 \
        MB_PRECOMPOSED,                                         \
        __pAscii,                                               \
        -1,                                                     \
        0,                                                      \
        0                                                       \
    ),                                                          \
                                                                \
    __pUnicode = (PCWSTR) _alloca(__nLength * sizeof(WCHAR)),   \
                                                                \
    MultiByteToWideChar(                                        \
        CP_ACP,                                                 \
        MB_PRECOMPOSED,                                         \
        __pAscii,                                               \
        -1,                                                     \
        (PWSTR) __pUnicode,                                     \
        __nLength                                               \
    ),                                                          \
                                                                \
    (PWSTR) __pUnicode))                                        \

//////////////////////////////////////////////////////////////////////////
//
// _tcsdupa
//
// Routine Description:
//   Duplicates a string to a buffer allocated off the stack using _alloca
//
// Arguments:
//   pStr          input string
//
// Return Value:
//   duplicated string
//

#define _wcsdupa(pStr)                                                  \
                                                                        \
    (__pAscii, (__pUnicode = pStr) == 0 ? (PWSTR) 0 : (                 \
                                                                        \
    __nLength = wcslen(__pUnicode) + 1,                                 \
                                                                        \
    lstrcpyW((PWSTR) _alloca(__nLength * sizeof(WCHAR)), __pUnicode)))  \


#define _strdupa(pStr)                                                  \
                                                                        \
    (__pUnicode, (__pAscii = pStr) == 0 ? (PSTR) 0 : (                  \
                                                                        \
    __nLength = strlen(__pAscii) + 1,                                   \
                                                                        \
    lstrcpyA((PSTR) _alloca(__nLength * sizeof(CHAR)), __pAscii)))      \


#ifdef UNICODE
#define _tcsdupa _wcsdupa
#else
#define _tcsdupa _strdupa
#endif

//////////////////////////////////////////////////////////////////////////
//
// T2A, A2T, T2W, W2T, T2O, O2T, T2DA, A2DT, T2DW, W2DT
//
// Routine Description:
//   These macros expand to the corresponding correct form according to the
//   #definition of UNICODE.
//
//   We use the cryptic form (__nLength, __pAscii, __pUnicode, pStr) to avoid
//   the compiler warning "symbol defined but not used" due to the variables
//   defined in USES_CONVERSION macro.
//

#ifdef UNICODE
    #define T2A(pStr)   W2A(pStr)
    #define A2T(pStr)   A2W(pStr)
    #define T2W(pStr)   (__nLength, __pAscii, __pUnicode, pStr)
    #define W2T(pStr)   (__nLength, __pAscii, __pUnicode, pStr)
    #define T2O(pStr)   W2A(pStr)
    #define O2T(pStr)   A2W(pStr)
    #define T2DA(pStr)  W2A(pStr)
    #define A2DT(pStr)  A2W(pStr)
    #define T2DW(pStr)  _wcsdupa(pStr)
    #define W2DT(pStr)  _wcsdupa(pStr)
    typedef CHAR        OCHAR, *LPOSTR, *POSTR;
    typedef CONST CHAR  *LPCOSTR, *PCOSTR;
#else //UNICODE
    #define T2A(pStr)   (__nLength, __pAscii, __pUnicode, pStr)
    #define A2T(pStr)   (__nLength, __pAscii, __pUnicode, pStr)
    #define T2W(pStr)   A2W(pStr)
    #define W2T(pStr)   W2A(pStr)
    #define T2O(pStr)   A2W(pStr)
    #define O2T(pStr)   W2A(pStr)
    #define T2DA(pStr)  _strdupa(pStr)
    #define A2DT(pStr)  _strdupa(pStr)
    #define T2DW(pStr)  A2W(pStr)
    #define W2DT(pStr)  W2A(pStr)
    typedef WCHAR       OCHAR, *LPOSTR, *POSTR;
    typedef CONST WCHAR *LPCOSTR, *PCOSTR;
#endif //UNICODE

#endif //__WIACONV_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\inc\wiadef.h ===
/****************************************************************************
*
*  (C) COPYRIGHT 1998-2000, MICROSOFT CORP.
*
*  FILE:        wiadef.h
*
*  VERSION:     2.0
*
*  DATE:        7/27/2000
*
*  DESCRIPTION:
*    Defines WIA constants.
*
*****************************************************************************/

#ifndef _WIADEF_H_
#define _WIADEF_H_

//
// Set packing
//
#include <pshpack8.h>

//
// Include COM definitions
//
#ifndef _NO_COM
#include <objbase.h>
#endif

#ifdef __cplusplus
extern "C" {
#endif

/**************************************************************************
*
* WIA Errors
*
***************************************************************************/

//
// Define the facility code. Move this to sdk\inc???
//

#define FACILITY_WIA 33

//
// Definitions for WIA_ERRORs and WIA_STATUSs. Applications can test for these returns
// on API return, to keep users informed of conditions which a user
// could correct.
//

#define BASE_VAL_WIA_ERROR   0x00000000
#define BASE_VAL_WIA_SUCCESS 0x00000000

#define WIA_ERROR_GENERAL_ERROR              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIA, (BASE_VAL_WIA_ERROR + 1))
#define WIA_ERROR_PAPER_JAM                  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIA, (BASE_VAL_WIA_ERROR + 2))
#define WIA_ERROR_PAPER_EMPTY                MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIA, (BASE_VAL_WIA_ERROR + 3))
#define WIA_ERROR_PAPER_PROBLEM              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIA, (BASE_VAL_WIA_ERROR + 4))
#define WIA_ERROR_OFFLINE                    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIA, (BASE_VAL_WIA_ERROR + 5))
#define WIA_ERROR_BUSY                       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIA, (BASE_VAL_WIA_ERROR + 6))
#define WIA_ERROR_WARMING_UP                 MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIA, (BASE_VAL_WIA_ERROR + 7))
#define WIA_ERROR_USER_INTERVENTION          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIA, (BASE_VAL_WIA_ERROR + 8))
#define WIA_ERROR_ITEM_DELETED               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIA, (BASE_VAL_WIA_ERROR + 9))
#define WIA_ERROR_DEVICE_COMMUNICATION       MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIA, (BASE_VAL_WIA_ERROR + 10))
#define WIA_ERROR_INVALID_COMMAND            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIA, (BASE_VAL_WIA_ERROR + 11))
#define WIA_ERROR_INCORRECT_HARDWARE_SETTING MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIA, (BASE_VAL_WIA_ERROR + 12))
#define WIA_ERROR_DEVICE_LOCKED              MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIA, (BASE_VAL_WIA_ERROR + 13))
#define WIA_ERROR_EXCEPTION_IN_DRIVER        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIA, (BASE_VAL_WIA_ERROR + 14))
#define WIA_ERROR_INVALID_DRIVER_RESPONSE    MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIA, (BASE_VAL_WIA_ERROR + 15))


#define WIA_STATUS_END_OF_MEDIA              MAKE_HRESULT(SEVERITY_SUCCESS, FACILITY_WIA, (BASE_VAL_WIA_SUCCESS + 1))

//
// Returned by SelectDeviceDlg and SelectDeviceDlgId when there are no devices avaiable
//
#define WIA_S_NO_DEVICE_AVAILABLE            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_WIA, (BASE_VAL_WIA_ERROR + 21))

//
// SelectDeviceDlg & GetImageDlg flags
//

#define WIA_SELECT_DEVICE_NODEFAULT          0x00000001

//
// GetImageDlg & DeviceDlg flags
//

#define WIA_DEVICE_DIALOG_SINGLE_IMAGE       0x00000002  // Only allow one image to be selected
#define WIA_DEVICE_DIALOG_USE_COMMON_UI      0x00000004  // Give preference to the system-provided UI, if available

//**************************************************************************
//
// Image types
//
//**************************************************************************

DEFINE_GUID(WiaImgFmt_UNDEFINED, 0xb96b3ca9,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(WiaImgFmt_RAWRGB, 0xbca48b55,0xf272,0x4371,0xb0,0xf1,0x4a,0x15,0xd,0x5,0x7b,0xb4);
DEFINE_GUID(WiaImgFmt_MEMORYBMP, 0xb96b3caa,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(WiaImgFmt_BMP, 0xb96b3cab,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(WiaImgFmt_EMF, 0xb96b3cac,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(WiaImgFmt_WMF, 0xb96b3cad,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(WiaImgFmt_JPEG, 0xb96b3cae,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(WiaImgFmt_PNG, 0xb96b3caf,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(WiaImgFmt_GIF, 0xb96b3cb0,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(WiaImgFmt_TIFF, 0xb96b3cb1,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(WiaImgFmt_EXIF, 0xb96b3cb2,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(WiaImgFmt_PHOTOCD, 0xb96b3cb3,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(WiaImgFmt_FLASHPIX, 0xb96b3cb4,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
DEFINE_GUID(WiaImgFmt_ICO, 0xb96b3cb5,0x0728,0x11d3,0x9d,0x7b,0x00,0x00,0xf8,0x1e,0xf3,0x2e);
// Canon Image File Format
DEFINE_GUID(WiaImgFmt_CIFF,0x9821a8ab,0x3a7e,0x4215,0x94,0xe0,0xd2,0x7a,0x46,0x0c,0x03,0xb2);
// Quickdraw Image Format
DEFINE_GUID(WiaImgFmt_PICT,0xa6bc85d8,0x6b3e,0x40ee,0xa9,0x5c,0x25,0xd4,0x82,0xe4,0x1a,0xdc);
// JPEG 2000 baseline file format
DEFINE_GUID(WiaImgFmt_JPEG2K,0x344ee2b2,0x39db,0x4dde,0x81,0x73,0xc4,0xb7,0x5f,0x8f,0x1e,0x49);
// JPEG 2000 extended file format
DEFINE_GUID(WiaImgFmt_JPEG2KX,0x43e14614,0xc80a,0x4850,0xba,0xf3,0x4b,0x15,0x2d,0xc8,0xda,0x27);


//**************************************************************************
//
// Document and other types
//
// Note: HTML, AVI, and MPEG used to have different GUIDs. Use the GUIDs
//       defined below from now on.
//
//**************************************************************************

DEFINE_GUID(WiaImgFmt_RTF, 0x573dd6a3,0x4834,0x432d,0xa9,0xb5,0xe1,0x98,0xdd,0x9e,0x89,0xd);
DEFINE_GUID(WiaImgFmt_XML, 0xb9171457,0xdac8,0x4884,0xb3,0x93,0x15,0xb4,0x71,0xd5,0xf0,0x7e);
DEFINE_GUID(WiaImgFmt_HTML, 0xc99a4e62,0x99de,0x4a94,0xac,0xca,0x71,0x95,0x6a,0xc2,0x97,0x7d);
DEFINE_GUID(WiaImgFmt_TXT, 0xfafd4d82,0x723f,0x421f,0x93,0x18,0x30,0x50,0x1a,0xc4,0x4b,0x59);
DEFINE_GUID(WiaImgFmt_MPG, 0xecd757e4,0xd2ec,0x4f57,0x95,0x5d,0xbc,0xf8,0xa9,0x7c,0x4e,0x52);
DEFINE_GUID(WiaImgFmt_AVI, 0x32f8ca14,0x87c,0x4908,0xb7,0xc4,0x67,0x57,0xfe,0x7e,0x90,0xab);
DEFINE_GUID(WiaImgFmt_ASF, 0x8d948ee9,0xd0aa,0x4a12,0x9d,0x9a,0x9c,0xc5,0xde,0x36,0x19,0x9b);
DEFINE_GUID(WiaImgFmt_SCRIPT, 0xfe7d6c53,0x2dac,0x446a,0xb0,0xbd,0xd7,0x3e,0x21,0xe9,0x24,0xc9);
DEFINE_GUID(WiaImgFmt_EXEC, 0x485da097,0x141e,0x4aa5,0xbb,0x3b,0xa5,0x61,0x8d,0x95,0xd0,0x2b);
DEFINE_GUID(WiaImgFmt_UNICODE16,0x1b7639b6,0x6357,0x47d1,0x9a,0x07,0x12,0x45,0x2d,0xc0,0x73,0xe9);
DEFINE_GUID(WiaImgFmt_DPOF,0x369eeeab,0xa0e8,0x45ca,0x86,0xa6,0xa8,0x3c,0xe5,0x69,0x7e,0x28);


//**************************************************************************
//
// Audio types
//
//**************************************************************************

DEFINE_GUID(WiaAudFmt_WAV, 0xf818e146,0x07af,0x40ff,0xae,0x55,0xbe,0x8f,0x2c,0x06,0x5d,0xbe);
DEFINE_GUID(WiaAudFmt_MP3, 0x0fbc71fb,0x43bf,0x49f2,0x91,0x90,0xe6,0xfe,0xcf,0xf3,0x7e,0x54);
DEFINE_GUID(WiaAudFmt_AIFF, 0x66e2bf4f,0xb6fc,0x443f,0x94,0xc8,0x2f,0x33,0xc8,0xa6,0x5a,0xaf);
DEFINE_GUID(WiaAudFmt_WMA, 0xd61d6413,0x8bc2,0x438f,0x93,0xad,0x21,0xbd,0x48,0x4d,0xb6,0xa1);


//**************************************************************************
//
// WIA Events
//
//**************************************************************************

//
// Event registration flags, used by RegisterEventLaunch,
// RegisterEventCallbackInterface and RegisterEventCallbackCLSID.
//

#define  WIA_REGISTER_EVENT_CALLBACK        0x00000001
#define  WIA_UNREGISTER_EVENT_CALLBACK      0x00000002
#define  WIA_SET_DEFAULT_HANDLER            0x00000004

//
// Event type : individual bits of the possible event type combinations
//

#define  WIA_NOTIFICATION_EVENT             0x00000001
#define  WIA_ACTION_EVENT                   0x00000002

//
// Flag to indicate the corresponding persistent handler is default
//

#define  WIA_IS_DEFAULT_HANDLER             0x00000001

//
// Event GUIDs
//

DEFINE_GUID(WIA_EVENT_DEVICE_DISCONNECTED,  0x143e4e83, 0x6497, 0x11d2, 0xa2, 0x31, 0x0, 0xc0, 0x4f, 0xa3, 0x18, 0x9);
DEFINE_GUID(WIA_EVENT_DEVICE_CONNECTED,     0xa28bbade, 0x64b6, 0x11d2, 0xa2, 0x31, 0x0, 0xc0, 0x4f, 0xa3, 0x18, 0x9);
DEFINE_GUID(WIA_EVENT_ITEM_DELETED,         0x1d22a559, 0xe14f, 0x11d2, 0xb3, 0x26, 0x00, 0xc0, 0x4f, 0x68, 0xce, 0x61);
DEFINE_GUID(WIA_EVENT_ITEM_CREATED,         0x4c8f4ef5, 0xe14f, 0x11d2, 0xb3, 0x26, 0x00, 0xc0, 0x4f, 0x68, 0xce, 0x61);
DEFINE_GUID(WIA_EVENT_TREE_UPDATED,         0xc9859b91, 0x4ab2, 0x4cd6, 0xa1, 0xfc, 0x58, 0x2e, 0xec, 0x55, 0xe5, 0x85);
DEFINE_GUID(WIA_EVENT_VOLUME_INSERT,        0x9638bbfd, 0xd1bd, 0x11d2, 0xb3, 0x1f, 0x00, 0xc0, 0x4f, 0x68, 0xce, 0x61);
DEFINE_GUID(WIA_EVENT_SCAN_IMAGE,           0xa6c5a715, 0x8c6e, 0x11d2, 0x97, 0x7a, 0x0, 0x0, 0xf8, 0x7a, 0x92, 0x6f);
DEFINE_GUID(WIA_EVENT_SCAN_PRINT_IMAGE,     0xb441f425, 0x8c6e, 0x11d2, 0x97, 0x7a, 0x0, 0x0, 0xf8, 0x7a, 0x92, 0x6f);
DEFINE_GUID(WIA_EVENT_SCAN_FAX_IMAGE,       0xc00eb793, 0x8c6e, 0x11d2, 0x97, 0x7a, 0x0, 0x0, 0xf8, 0x7a, 0x92, 0x6f);
DEFINE_GUID(WIA_EVENT_SCAN_OCR_IMAGE,       0x9d095b89, 0x37d6, 0x4877, 0xaf, 0xed, 0x62, 0xa2, 0x97, 0xdc, 0x6d, 0xbe);
DEFINE_GUID(WIA_EVENT_SCAN_EMAIL_IMAGE,     0xc686dcee, 0x54f2, 0x419e, 0x9a, 0x27, 0x2f, 0xc7, 0xf2, 0xe9, 0x8f, 0x9e);
DEFINE_GUID(WIA_EVENT_SCAN_FILM_IMAGE,      0x9b2b662c, 0x6185, 0x438c, 0xb6, 0x8b, 0xe3, 0x9e, 0xe2, 0x5e, 0x71, 0xcb);
DEFINE_GUID(WIA_EVENT_SCAN_IMAGE2,          0xfc4767c1, 0xc8b3, 0x48a2, 0x9c, 0xfa, 0x2e, 0x90, 0xcb, 0x3d, 0x35, 0x90);
DEFINE_GUID(WIA_EVENT_SCAN_IMAGE3,          0x154e27be, 0xb617, 0x4653, 0xac, 0xc5, 0xf, 0xd7, 0xbd, 0x4c, 0x65, 0xce);
DEFINE_GUID(WIA_EVENT_SCAN_IMAGE4,          0xa65b704a, 0x7f3c, 0x4447, 0xa7, 0x5d, 0x8a, 0x26, 0xdf, 0xca, 0x1f, 0xdf);
DEFINE_GUID(WIA_EVENT_STORAGE_CREATED,      0x353308b2, 0xfe73, 0x46c8, 0x89, 0x5e, 0xfa, 0x45, 0x51, 0xcc, 0xc8, 0x5a);
DEFINE_GUID(WIA_EVENT_STORAGE_DELETED,      0x5e41e75e, 0x9390, 0x44c5, 0x9a, 0x51, 0xe4, 0x70, 0x19, 0xe3, 0x90, 0xcf);
DEFINE_GUID(WIA_EVENT_STI_PROXY,            0xd711f81f, 0x1f0d, 0x422d, 0x86, 0x41, 0x92, 0x7d, 0x1b, 0x93, 0xe5, 0xe5);
DEFINE_GUID(WIA_EVENT_CANCEL_IO,            0xc860f7b8, 0x9ccd, 0x41ea, 0xbb, 0xbf, 0x4d, 0xd0, 0x9c, 0x5b, 0x17, 0x95);

//
// Power management event GUIDs, sent by the WIA service to drivers
//

DEFINE_GUID(WIA_EVENT_POWER_SUSPEND,    0xa0922ff9, 0xc3b4, 0x411c, 0x9e, 0x29, 0x03, 0xa6, 0x69, 0x93, 0xd2, 0xbe);
DEFINE_GUID(WIA_EVENT_POWER_RESUME,     0x618f153e, 0xf686, 0x4350, 0x96, 0x34, 0x41, 0x15, 0xa3, 0x04, 0x83, 0x0c);


//
// No action handler and prompt handler
//

DEFINE_GUID(WIA_EVENT_HANDLER_NO_ACTION, 0xe0372b7d, 0xe115, 0x4525, 0xbc, 0x55, 0xb6, 0x29, 0xe6, 0x8c, 0x74, 0x5a);
DEFINE_GUID(WIA_EVENT_HANDLER_PROMPT, 0x5f4baad0, 0x4d59, 0x4fcd, 0xb2, 0x13, 0x78, 0x3c, 0xe7, 0xa9, 0x2f, 0x22);

#define WIA_EVENT_DEVICE_DISCONNECTED_STR   L"Device Disconnected"
#define WIA_EVENT_DEVICE_CONNECTED_STR      L"Device Connected"


//**************************************************************************
//
// WIA Commands
//
//**************************************************************************

DEFINE_GUID(WIA_CMD_SYNCHRONIZE, 0x9b26b7b2, 0xacad, 0x11d2, 0xa0, 0x93, 0x00, 0xc0, 0x4f, 0x72, 0xdc, 0x3c);
DEFINE_GUID(WIA_CMD_TAKE_PICTURE, 0xaf933cac, 0xacad, 0x11d2, 0xa0, 0x93, 0x00, 0xc0, 0x4f, 0x72, 0xdc, 0x3c);
DEFINE_GUID(WIA_CMD_DELETE_ALL_ITEMS, 0xe208c170, 0xacad, 0x11d2, 0xa0, 0x93, 0x00, 0xc0, 0x4f, 0x72, 0xdc, 0x3c);
DEFINE_GUID(WIA_CMD_CHANGE_DOCUMENT, 0x04e725b0, 0xacae, 0x11d2, 0xa0, 0x93, 0x00, 0xc0, 0x4f, 0x72, 0xdc, 0x3c);
DEFINE_GUID(WIA_CMD_UNLOAD_DOCUMENT, 0x1f3b3d8e, 0xacae, 0x11d2, 0xa0, 0x93, 0x00, 0xc0, 0x4f, 0x72, 0xdc, 0x3c);
DEFINE_GUID(WIA_CMD_DIAGNOSTIC, 0x10ff52f5, 0xde04, 0x4cf0, 0xa5, 0xad, 0x69, 0x1f, 0x8d, 0xce, 0x01, 0x41);

//
// The following are private commands for debugging use only.
//

DEFINE_GUID(WIA_CMD_DELETE_DEVICE_TREE, 0x73815942, 0xdbea, 0x11d2, 0x84, 0x16, 0x00, 0xc0, 0x4f, 0xa3, 0x61, 0x45);
DEFINE_GUID(WIA_CMD_BUILD_DEVICE_TREE, 0x9cba5ce0, 0xdbea, 0x11d2, 0x84, 0x16, 0x00, 0xc0, 0x4f, 0xa3, 0x61, 0x45);


//**************************************************************************
//
// WIA Icons
//
//   Event   : -1000 to -1499 (Standard), -1500 to -1999 (Custom)
//   Command : -2000 to -2499 (Standard), -2500 to -2999 (Custom)
//
//**************************************************************************

#define WIA_ICON_DEVICE_DISCONNECTED    (L"sti.dll,-1001")
#define WIA_ICON_DEVICE_CONNECTED       (L"sti.dll,-1001")
#define WIA_ICON_ITEM_DELETED           (L"sti.dll,-1001")
#define WIA_ICON_ITEM_CREATED           (L"sti.dll,-1001")
#define WIA_ICON_VOLUME_INSERT          (L"sti.dll,-1001")
#define WIA_ICON_SCAN_BUTTON_PRESS      (L"sti.dll,-1001")
#define WIA_ICON_SYNCHRONIZE            (L"sti.dll,-2000")
#define WIA_ICON_TAKE_PICTURE           (L"sti.dll,-2001")
#define WIA_ICON_DELETE_ALL_ITEMS       (L"sti.dll,-2002")
#define WIA_ICON_CHANGE_DOCUMENT        (L"sti.dll,-2003")
#define WIA_ICON_UNLOAD_DOCUMENT        (L"sti.dll,-2004")
#define WIA_ICON_DELETE_DEVICE_TREE     (L"sti.dll,-2005")
#define WIA_ICON_BUILD_DEVICE_TREE      (L"sti.dll,-2006")


//**************************************************************************
//
// WIA Callbacks
//
//**************************************************************************

//
// IImageTransfer TYMED
//

#define TYMED_CALLBACK                          128
#define TYMED_MULTIPAGE_FILE                    256
#define TYMED_MULTIPAGE_CALLBACK                512

//
// IImageTransfer Callback Status. Messages must be a single value
//

#define IT_MSG_DATA_HEADER                      0x0001
#define IT_MSG_DATA                             0x0002
#define IT_MSG_STATUS                           0x0003
#define IT_MSG_TERMINATION                      0x0004
#define IT_MSG_NEW_PAGE                         0x0005
#define IT_MSG_FILE_PREVIEW_DATA                0x0006
#define IT_MSG_FILE_PREVIEW_DATA_HEADER         0x0007

//
//  Flags may be bit field combinations
//

#define IT_STATUS_TRANSFER_FROM_DEVICE          0x0001
#define IT_STATUS_PROCESSING_DATA               0x0002
#define IT_STATUS_TRANSFER_TO_CLIENT            0x0004

//
// IWIAEventCallback codes
//

#define WIA_MAJOR_EVENT_DEVICE_CONNECT          0x01
#define WIA_MAJOR_EVENT_DEVICE_DISCONNECT       0x02
#define WIA_MAJOR_EVENT_PICTURE_TAKEN           0x03
#define WIA_MAJOR_EVENT_PICTURE_DELETED         0x04

//
// Device connection status
//

#define  WIA_DEVICE_NOT_CONNECTED               0
#define  WIA_DEVICE_CONNECTED                   1


//**************************************************************************
//
// WIA Enumeration Flags
//
//**************************************************************************

//
// EnumDeviceCapabilities flags
//

#define WIA_DEVICE_COMMANDS 1
#define WIA_DEVICE_EVENTS 2

//
// EnumDeviceInfo Flags
//

#define WIA_DEVINFO_ENUM_LOCAL                  0x00000010


//**************************************************************************
//
// WIA Item constants
//
//**************************************************************************

//
// Item Types
//

#define WiaItemTypeFree                         0x00000000
#define WiaItemTypeImage                        0x00000001
#define WiaItemTypeFile                         0x00000002
#define WiaItemTypeFolder                       0x00000004
#define WiaItemTypeRoot                         0x00000008
#define WiaItemTypeAnalyze                      0x00000010
#define WiaItemTypeAudio                        0x00000020
#define WiaItemTypeDevice                       0x00000040
#define WiaItemTypeDeleted                      0x00000080
#define WiaItemTypeDisconnected                 0x00000100
#define WiaItemTypeHPanorama                    0x00000200
#define WiaItemTypeVPanorama                    0x00000400
#define WiaItemTypeBurst                        0x00000800
#define WiaItemTypeStorage                      0x00001000
#define WiaItemTypeTransfer                     0x00002000
#define WiaItemTypeGenerated                    0x00004000
#define WiaItemTypeHasAttachments               0x00008000
#define WiaItemTypeVideo                        0x00010000

//
// 0x00020000 has been reserved for the TWAIN compatiblity layer
// pass-through feature.
//

#define WiaItemTypeRemoved                      0x80000000

#define WiaItemTypeMask                         0x8003FFFF

//
// Big max device specific item context
//

#define WIA_MAX_CTX_SIZE                        0x01000000


//**************************************************************************
//
// WIA Properties
//
//**************************************************************************

//
// Property access flags
//

#define WIA_PROP_READ            0x01
#define WIA_PROP_WRITE           0x02
#define WIA_PROP_RW              (WIA_PROP_READ | WIA_PROP_WRITE)
#define WIA_PROP_SYNC_REQUIRED   0x04

#define WIA_PROP_NONE            0x08
#define WIA_PROP_RANGE           0x10
#define WIA_PROP_LIST            0x20
#define WIA_PROP_FLAG            0x40

#define WIA_PROP_CACHEABLE       0x10000

//
// Item access flags
//

#define WIA_ITEM_CAN_BE_DELETED  0x80
#define WIA_ITEM_READ            WIA_PROP_READ
#define WIA_ITEM_WRITE           WIA_PROP_WRITE
#define WIA_ITEM_RD              (WIA_ITEM_READ | WIA_ITEM_CAN_BE_DELETED)
#define WIA_ITEM_RWD             (WIA_ITEM_READ | WIA_ITEM_WRITE | WIA_ITEM_CAN_BE_DELETED)

#ifndef __WIAPROP_H_INCLUDED
#define __WIAPROP_H_INCLUDED

//
// Device information properties
//

#define WIA_RESERVED_FOR_SMALL_NEW_PROPS        256
#define WIA_RESERVED_FOR_NEW_PROPS              1024
#define WIA_RESERVED_FOR_ALL_MS_PROPS           (1024*32)

#define WIA_DIP_FIRST                           2
#define WIA_DIP_DEV_ID                          2
#define WIA_DIP_VEND_DESC                       3
#define WIA_DIP_DEV_DESC                        4
#define WIA_DIP_DEV_TYPE                        5
#define WIA_DIP_PORT_NAME                       6
#define WIA_DIP_DEV_NAME                        7
#define WIA_DIP_SERVER_NAME                     8
#define WIA_DIP_REMOTE_DEV_ID                   9
#define WIA_DIP_UI_CLSID                        10
#define WIA_DIP_HW_CONFIG                       11
#define WIA_DIP_BAUDRATE                        12
#define WIA_DIP_STI_GEN_CAPABILITIES            13
#define WIA_DIP_WIA_VERSION                     14
#define WIA_DIP_DRIVER_VERSION                  15
#define WIA_DIP_LAST                            15

#define WIA_NUM_DIP          1 + WIA_DIP_LAST - WIA_DIP_FIRST

#define WIA_DIP_DEV_ID_STR                      L"Unique Device ID"
#define WIA_DIP_VEND_DESC_STR                   L"Manufacturer"
#define WIA_DIP_DEV_DESC_STR                    L"Description"
#define WIA_DIP_DEV_TYPE_STR                    L"Type"
#define WIA_DIP_PORT_NAME_STR                   L"Port"
#define WIA_DIP_DEV_NAME_STR                    L"Name"
#define WIA_DIP_SERVER_NAME_STR                 L"Server"
#define WIA_DIP_REMOTE_DEV_ID_STR               L"Remote Device ID"
#define WIA_DIP_UI_CLSID_STR                    L"UI Class ID"
#define WIA_DIP_HW_CONFIG_STR                   L"Hardware Configuration"
#define WIA_DIP_BAUDRATE_STR                    L"BaudRate"
#define WIA_DIP_STI_GEN_CAPABILITIES_STR        L"STI Generic Capabilities"
#define WIA_DIP_WIA_VERSION_STR                 L"WIA Version"
#define WIA_DIP_DRIVER_VERSION_STR              L"Driver Version"


//
// Constant arrays for device information property init
//

#ifdef WIA_DECLARE_DEVINFO_PROP_ARRAY

PROPSPEC g_psDeviceInfo[WIA_NUM_DIP] =
{
    {PRSPEC_PROPID, WIA_DIP_DEV_ID},
    {PRSPEC_PROPID, WIA_DIP_VEND_DESC},
    {PRSPEC_PROPID, WIA_DIP_DEV_DESC},
    {PRSPEC_PROPID, WIA_DIP_DEV_TYPE},
    {PRSPEC_PROPID, WIA_DIP_PORT_NAME},
    {PRSPEC_PROPID, WIA_DIP_DEV_NAME},
    {PRSPEC_PROPID, WIA_DIP_SERVER_NAME},
    {PRSPEC_PROPID, WIA_DIP_REMOTE_DEV_ID},
    {PRSPEC_PROPID, WIA_DIP_UI_CLSID},
    {PRSPEC_PROPID, WIA_DIP_HW_CONFIG},
    {PRSPEC_PROPID, WIA_DIP_BAUDRATE},
    {PRSPEC_PROPID, WIA_DIP_STI_GEN_CAPABILITIES},
    {PRSPEC_PROPID, WIA_DIP_WIA_VERSION},
    {PRSPEC_PROPID, WIA_DIP_DRIVER_VERSION},
};

PROPID g_piDeviceInfo[WIA_NUM_DIP] =
{
    WIA_DIP_DEV_ID,
    WIA_DIP_VEND_DESC,
    WIA_DIP_DEV_DESC,
    WIA_DIP_DEV_TYPE,
    WIA_DIP_PORT_NAME,
    WIA_DIP_DEV_NAME,
    WIA_DIP_SERVER_NAME,
    WIA_DIP_REMOTE_DEV_ID,
    WIA_DIP_UI_CLSID,
    WIA_DIP_HW_CONFIG,
    WIA_DIP_BAUDRATE,
    WIA_DIP_STI_GEN_CAPABILITIES,
    WIA_DIP_WIA_VERSION,
    WIA_DIP_DRIVER_VERSION,
};

LPOLESTR g_pszDeviceInfo[WIA_NUM_DIP] =
{
    WIA_DIP_DEV_ID_STR,
    WIA_DIP_VEND_DESC_STR,
    WIA_DIP_DEV_DESC_STR,
    WIA_DIP_DEV_TYPE_STR,
    WIA_DIP_PORT_NAME_STR,
    WIA_DIP_DEV_NAME_STR,
    WIA_DIP_SERVER_NAME_STR,
    WIA_DIP_REMOTE_DEV_ID_STR,
    WIA_DIP_UI_CLSID_STR,
    WIA_DIP_HW_CONFIG_STR,
    WIA_DIP_BAUDRATE_STR,
    WIA_DIP_STI_GEN_CAPABILITIES_STR,
    WIA_DIP_WIA_VERSION_STR,
    WIA_DIP_DRIVER_VERSION_STR,
};

#else

extern PROPSPEC             g_psDeviceInfo[WIA_NUM_DIP];
extern PROPID               g_piDeviceInfo[WIA_NUM_DIP];
extern LPOLESTR             g_pszDeviceInfo[WIA_NUM_DIP];

#endif


//
// Common device properties
//

#define WIA_DPA_FIRST                           WIA_DIP_FIRST + WIA_RESERVED_FOR_NEW_PROPS
#define WIA_DPA_FIRMWARE_VERSION                WIA_DPA_FIRST + 0
#define WIA_DPA_CONNECT_STATUS                  WIA_DPA_FIRST + 1
#define WIA_DPA_DEVICE_TIME                     WIA_DPA_FIRST + 2
#define WIA_DPA_LAST                            WIA_DPA_FIRST + 3

#define WIA_DPA_FIRMWARE_VERSION_STR            L"Firmware Version"
#define WIA_DPA_CONNECT_STATUS_STR              L"Connect Status"
#define WIA_DPA_DEVICE_TIME_STR                 L"Device Time"

#define WIA_NUM_DPA (1 + WIA_DPA_LAST - WIA_DPA_FIRST)


//
// Camera device properties
//

#define WIA_DPC_FIRST                           WIA_DPA_FIRST + WIA_RESERVED_FOR_NEW_PROPS
#define WIA_DPC_PICTURES_TAKEN                  WIA_DPC_FIRST + 0
#define WIA_DPC_PICTURES_REMAINING              WIA_DPC_FIRST + 1
#define WIA_DPC_EXPOSURE_MODE                   WIA_DPC_FIRST + 2
#define WIA_DPC_EXPOSURE_COMP                   WIA_DPC_FIRST + 3
#define WIA_DPC_EXPOSURE_TIME                   WIA_DPC_FIRST + 4
#define WIA_DPC_FNUMBER                         WIA_DPC_FIRST + 5
#define WIA_DPC_FLASH_MODE                      WIA_DPC_FIRST + 6
#define WIA_DPC_FOCUS_MODE                      WIA_DPC_FIRST + 7
#define WIA_DPC_FOCUS_MANUAL_DIST               WIA_DPC_FIRST + 8
#define WIA_DPC_ZOOM_POSITION                   WIA_DPC_FIRST + 9
#define WIA_DPC_PAN_POSITION                    WIA_DPC_FIRST + 10
#define WIA_DPC_TILT_POSITION                   WIA_DPC_FIRST + 11
#define WIA_DPC_TIMER_MODE                      WIA_DPC_FIRST + 12
#define WIA_DPC_TIMER_VALUE                     WIA_DPC_FIRST + 13
#define WIA_DPC_POWER_MODE                      WIA_DPC_FIRST + 14
#define WIA_DPC_BATTERY_STATUS                  WIA_DPC_FIRST + 15
#define WIA_DPC_THUMB_WIDTH                     WIA_DPC_FIRST + 16
#define WIA_DPC_THUMB_HEIGHT                    WIA_DPC_FIRST + 17
#define WIA_DPC_PICT_WIDTH                      WIA_DPC_FIRST + 18
#define WIA_DPC_PICT_HEIGHT                     WIA_DPC_FIRST + 19
#define WIA_DPC_DIMENSION                       WIA_DPC_FIRST + 20
#define WIA_DPC_COMPRESSION_SETTING             WIA_DPC_FIRST + 21
#define WIA_DPC_FOCUS_METERING                  WIA_DPC_FIRST + 22
#define WIA_DPC_TIMELAPSE_INTERVAL              WIA_DPC_FIRST + 23
#define WIA_DPC_TIMELAPSE_NUMBER                WIA_DPC_FIRST + 24
#define WIA_DPC_BURST_INTERVAL                  WIA_DPC_FIRST + 25
#define WIA_DPC_BURST_NUMBER                    WIA_DPC_FIRST + 26
#define WIA_DPC_EFFECT_MODE                     WIA_DPC_FIRST + 27
#define WIA_DPC_DIGITAL_ZOOM                    WIA_DPC_FIRST + 28
#define WIA_DPC_SHARPNESS                       WIA_DPC_FIRST + 29
#define WIA_DPC_CONTRAST                        WIA_DPC_FIRST + 30
#define WIA_DPC_CAPTURE_MODE                    WIA_DPC_FIRST + 31
#define WIA_DPC_CAPTURE_DELAY                   WIA_DPC_FIRST + 32
#define WIA_DPC_EXPOSURE_INDEX                  WIA_DPC_FIRST + 33
#define WIA_DPC_EXPOSURE_METERING_MODE          WIA_DPC_FIRST + 34
#define WIA_DPC_FOCUS_METERING_MODE             WIA_DPC_FIRST + 35
#define WIA_DPC_FOCUS_DISTANCE                  WIA_DPC_FIRST + 36
#define WIA_DPC_FOCAL_LENGTH                    WIA_DPC_FIRST + 37
#define WIA_DPC_RGB_GAIN                        WIA_DPC_FIRST + 38
#define WIA_DPC_WHITE_BALANCE                   WIA_DPC_FIRST + 39
#define WIA_DPC_UPLOAD_URL                      WIA_DPC_FIRST + 40
#define WIA_DPC_ARTIST                          WIA_DPC_FIRST + 41
#define WIA_DPC_COPYRIGHT_INFO                  WIA_DPC_FIRST + 42
#define WIA_DPC_LAST                            WIA_DPC_FIRST + 42

#define WIA_DPC_PICTURES_TAKEN_STR              L"Pictures Taken"
#define WIA_DPC_PICTURES_REMAINING_STR          L"Pictures Remaining"
#define WIA_DPC_EXPOSURE_MODE_STR               L"Exposure Mode"
#define WIA_DPC_EXPOSURE_COMP_STR               L"Exposure Compensation"
#define WIA_DPC_EXPOSURE_TIME_STR               L"Exposure Time"
#define WIA_DPC_FNUMBER_STR                     L"F Number"
#define WIA_DPC_FLASH_MODE_STR                  L"Flash Mode"
#define WIA_DPC_FOCUS_MODE_STR                  L"Focus Mode"
#define WIA_DPC_FOCUS_MANUAL_DIST_STR           L"Focus Manual Dist"
#define WIA_DPC_ZOOM_POSITION_STR               L"Zoom Position"
#define WIA_DPC_PAN_POSITION_STR                L"Pan Position"
#define WIA_DPC_TILT_POSITION_STR               L"Tilt Position"
#define WIA_DPC_TIMER_MODE_STR                  L"Timer Mode"
#define WIA_DPC_TIMER_VALUE_STR                 L"Timer Value"
#define WIA_DPC_POWER_MODE_STR                  L"Power Mode"
#define WIA_DPC_BATTERY_STATUS_STR              L"Battery Status"
#define WIA_DPC_THUMB_WIDTH_STR                 L"Thumbnail Width"
#define WIA_DPC_THUMB_HEIGHT_STR                L"Thumbnail Height"
#define WIA_DPC_PICT_WIDTH_STR                  L"Picture Width"
#define WIA_DPC_PICT_HEIGHT_STR                 L"Picture Height"
#define WIA_DPC_DIMENSION_STR                   L"Dimension"
#define WIA_DPC_COMPRESSION_SETTING_STR         L"Compression Setting"
#define WIA_DPC_FOCUS_METERING_MODE_STR         L"Focus Metering Mode"
#define WIA_DPC_TIMELAPSE_INTERVAL_STR          L"Timelapse Interval"
#define WIA_DPC_TIMELAPSE_NUMBER_STR            L"Timelapse Number"
#define WIA_DPC_BURST_INTERVAL_STR              L"Burst Interval"
#define WIA_DPC_BURST_NUMBER_STR                L"Burst Number"
#define WIA_DPC_EFFECT_MODE_STR                 L"Effect Mode"
#define WIA_DPC_DIGITAL_ZOOM_STR                L"Digital Zoom"
#define WIA_DPC_SHARPNESS_STR                   L"Sharpness"
#define WIA_DPC_CONTRAST_STR                    L"Contrast"
#define WIA_DPC_CAPTURE_MODE_STR                L"Capture Mode"
#define WIA_DPC_CAPTURE_DELAY_STR               L"Capture Delay"
#define WIA_DPC_EXPOSURE_INDEX_STR              L"Exposure Index"
#define WIA_DPC_EXPOSURE_METERING_MODE_STR      L"Exposure Metering Mode"
#define WIA_DPC_FOCUS_DISTANCE_STR              L"Focus Distance"
#define WIA_DPC_FOCAL_LENGTH_STR                L"Focus Length"
#define WIA_DPC_RGB_GAIN_STR                    L"RGB Gain"
#define WIA_DPC_WHITE_BALANCE_STR               L"White Balance"
#define WIA_DPC_UPLOAD_URL_STR                  L"Upload URL"
#define WIA_DPC_ARTIST_STR                      L"Artist"
#define WIA_DPC_COPYRIGHT_INFO_STR              L"Copyright Info"

#define WIA_NUM_DPC (1 + WIA_DPC_LAST - WIA_DPC_FIRST)


//
// Scanner device properties
//

#define WIA_DPS_FIRST                                  WIA_DPC_FIRST + WIA_RESERVED_FOR_NEW_PROPS
#define WIA_DPS_HORIZONTAL_BED_SIZE                    WIA_DPS_FIRST + 0
#define WIA_DPS_VERTICAL_BED_SIZE                      WIA_DPS_FIRST + 1
#define WIA_DPS_HORIZONTAL_SHEET_FEED_SIZE             WIA_DPS_FIRST + 2
#define WIA_DPS_VERTICAL_SHEET_FEED_SIZE               WIA_DPS_FIRST + 3
#define WIA_DPS_SHEET_FEEDER_REGISTRATION              WIA_DPS_FIRST + 4
#define WIA_DPS_HORIZONTAL_BED_REGISTRATION            WIA_DPS_FIRST + 5
#define WIA_DPS_VERTICAL_BED_REGISTRATION              WIA_DPS_FIRST + 6
#define WIA_DPS_PLATEN_COLOR                           WIA_DPS_FIRST + 7
#define WIA_DPS_PAD_COLOR                              WIA_DPS_FIRST + 8
#define WIA_DPS_FILTER_SELECT                          WIA_DPS_FIRST + 9
#define WIA_DPS_DITHER_SELECT                          WIA_DPS_FIRST + 10
#define WIA_DPS_DITHER_PATTERN_DATA                    WIA_DPS_FIRST + 11
#define WIA_DPS_DOCUMENT_HANDLING_CAPABILITIES         WIA_DPS_FIRST + 12
#define WIA_DPS_DOCUMENT_HANDLING_STATUS               WIA_DPS_FIRST + 13
#define WIA_DPS_DOCUMENT_HANDLING_SELECT               WIA_DPS_FIRST + 14
#define WIA_DPS_DOCUMENT_HANDLING_CAPACITY             WIA_DPS_FIRST + 15
#define WIA_DPS_OPTICAL_XRES                           WIA_DPS_FIRST + 16
#define WIA_DPS_OPTICAL_YRES                           WIA_DPS_FIRST + 17
#define WIA_DPS_ENDORSER_CHARACTERS                    WIA_DPS_FIRST + 18
#define WIA_DPS_ENDORSER_STRING                        WIA_DPS_FIRST + 19
#define WIA_DPS_SCAN_AHEAD_PAGES                       WIA_DPS_FIRST + 20
#define WIA_DPS_MAX_SCAN_TIME                          WIA_DPS_FIRST + 21
#define WIA_DPS_PAGES                                  WIA_DPS_FIRST + 22
#define WIA_DPS_PAGE_SIZE                              WIA_DPS_FIRST + 23
#define WIA_DPS_PAGE_WIDTH                             WIA_DPS_FIRST + 24
#define WIA_DPS_PAGE_HEIGHT                            WIA_DPS_FIRST + 25
#define WIA_DPS_PREVIEW                                WIA_DPS_FIRST + 26
#define WIA_DPS_TRANSPARENCY                           WIA_DPS_FIRST + 27
#define WIA_DPS_TRANSPARENCY_SELECT                    WIA_DPS_FIRST + 28
#define WIA_DPS_SHOW_PREVIEW_CONTROL                   WIA_DPS_FIRST + 29
#define WIA_DPS_MIN_HORIZONTAL_SHEET_FEED_SIZE         WIA_DPS_FIRST + 30
#define WIA_DPS_MIN_VERTICAL_SHEET_FEED_SIZE           WIA_DPS_FIRST + 31
#define WIA_DPS_LAST                                   WIA_DPS_FIRST + 31

#define WIA_DPS_HORIZONTAL_BED_SIZE_STR                L"Horizontal Bed Size"
#define WIA_DPS_VERTICAL_BED_SIZE_STR                  L"Vertical Bed Size"
#define WIA_DPS_HORIZONTAL_SHEET_FEED_SIZE_STR         L"Horizontal Sheet Feed Size"
#define WIA_DPS_VERTICAL_SHEET_FEED_SIZE_STR           L"Vertical Sheet Feed Size"
#define WIA_DPS_SHEET_FEEDER_REGISTRATION_STR          L"Sheet Feeder Registration"
#define WIA_DPS_HORIZONTAL_BED_REGISTRATION_STR        L"Horizontal Bed Registration"
#define WIA_DPS_VERTICAL_BED_REGISTRATION_STR          L"Vertical Bed Registration"
#define WIA_DPS_PLATEN_COLOR_STR                       L"Platen Color"
#define WIA_DPS_PAD_COLOR_STR                          L"Pad Color"
#define WIA_DPS_FILTER_SELECT_STR                      L"Filter Select"
#define WIA_DPS_DITHER_SELECT_STR                      L"Dither Select"
#define WIA_DPS_DITHER_PATTERN_DATA_STR                L"Dither Pattern Data"
#define WIA_DPS_DOCUMENT_HANDLING_CAPABILITIES_STR     L"Document Handling Capabilities"
#define WIA_DPS_DOCUMENT_HANDLING_STATUS_STR           L"Document Handling Status"
#define WIA_DPS_DOCUMENT_HANDLING_SELECT_STR           L"Document Handling Select"
#define WIA_DPS_DOCUMENT_HANDLING_CAPACITY_STR         L"Document Handling Capacity"
#define WIA_DPS_OPTICAL_XRES_STR                       L"Horizontal Optical Resolution"
#define WIA_DPS_OPTICAL_YRES_STR                       L"Vertical Optical Resolution"
#define WIA_DPS_ENDORSER_CHARACTERS_STR                L"Endorser Characters"
#define WIA_DPS_ENDORSER_STRING_STR                    L"Endorser String"
#define WIA_DPS_SCAN_AHEAD_PAGES_STR                   L"Scan Ahead Pages"
#define WIA_DPS_MAX_SCAN_TIME_STR                      L"Max Scan Time"
#define WIA_DPS_PAGES_STR                              L"Pages"
#define WIA_DPS_PAGE_SIZE_STR                          L"Page Size"
#define WIA_DPS_PAGE_WIDTH_STR                         L"Page Width"
#define WIA_DPS_PAGE_HEIGHT_STR                        L"Page Height"
#define WIA_DPS_PREVIEW_STR                            L"Preview"
#define WIA_DPS_TRANSPARENCY_STR                       L"Transparency Adapter"
#define WIA_DPS_TRANSPARENCY_SELECT_STR                L"Transparency Adapter Select"
#define WIA_DPS_SHOW_PREVIEW_CONTROL_STR               L"Show preview control"
#define WIA_DPS_MIN_HORIZONTAL_SHEET_FEED_SIZE_STR     L"Minimum Horizontal Sheet Feed Size"
#define WIA_DPS_MIN_VERTICAL_SHEET_FEED_SIZE_STR       L"Minimum Vertical Sheet Feed Size"

#define WIA_NUM_DPS (1 + WIA_DPS_LAST - WIA_DPS_FIRST)


//
// File System Properties
//
#define WIA_DPF_FIRST                           WIA_DPS_FIRST + WIA_RESERVED_FOR_SMALL_NEW_PROPS
#define WIA_DPF_MOUNT_POINT                     WIA_DPF_FIRST + 0
#define WIA_DPF_LAST                            WIA_DPF_FIRST + 0

#define WIA_DPF_MOUNT_POINT_STR                 L"Directory mount point"

#define WIA_NUM_DPF (1 + WIA_DPF_LAST - WIA_DPF_FIRST)

//
// Video Camera properties.
//
//
#define WIA_DPV_FIRST                           WIA_DPF_FIRST + WIA_RESERVED_FOR_SMALL_NEW_PROPS
#define WIA_DPV_LAST_PICTURE_TAKEN              WIA_DPV_FIRST + 0
#define WIA_DPV_IMAGES_DIRECTORY                WIA_DPV_FIRST + 1
#define WIA_DPV_DSHOW_DEVICE_PATH               WIA_DPV_FIRST + 2
#define WIA_DPV_LAST                            WIA_DPV_FIRST + 2

#define WIA_DPV_LAST_PICTURE_TAKEN_STR          L"Last Picture Taken"
#define WIA_DPV_IMAGES_DIRECTORY_STR            L"Images Directory"
#define WIA_DPV_DSHOW_DEVICE_PATH_STR           L"Directshow Device Path"

#define WIA_NUM_DPV (1 + WIA_DPV_LAST - WIA_DPV_FIRST)


//
// Common item properties
//

#define WIA_IPA_FIRST                           WIA_DPS_FIRST + WIA_RESERVED_FOR_NEW_PROPS
#define WIA_IPA_ITEM_NAME                       WIA_IPA_FIRST + 0
#define WIA_IPA_FULL_ITEM_NAME                  WIA_IPA_FIRST + 1
#define WIA_IPA_ITEM_TIME                       WIA_IPA_FIRST + 2
#define WIA_IPA_ITEM_FLAGS                      WIA_IPA_FIRST + 3
#define WIA_IPA_ACCESS_RIGHTS                   WIA_IPA_FIRST + 4
#define WIA_IPA_DATATYPE                        WIA_IPA_FIRST + 5
#define WIA_IPA_DEPTH                           WIA_IPA_FIRST + 6
#define WIA_IPA_PREFERRED_FORMAT                WIA_IPA_FIRST + 7
#define WIA_IPA_FORMAT                          WIA_IPA_FIRST + 8
#define WIA_IPA_COMPRESSION                     WIA_IPA_FIRST + 9
#define WIA_IPA_TYMED                           WIA_IPA_FIRST + 10
#define WIA_IPA_CHANNELS_PER_PIXEL              WIA_IPA_FIRST + 11
#define WIA_IPA_BITS_PER_CHANNEL                WIA_IPA_FIRST + 12
#define WIA_IPA_PLANAR                          WIA_IPA_FIRST + 13
#define WIA_IPA_PIXELS_PER_LINE                 WIA_IPA_FIRST + 14
#define WIA_IPA_BYTES_PER_LINE                  WIA_IPA_FIRST + 15
#define WIA_IPA_NUMBER_OF_LINES                 WIA_IPA_FIRST + 16
#define WIA_IPA_GAMMA_CURVES                    WIA_IPA_FIRST + 17
#define WIA_IPA_ITEM_SIZE                       WIA_IPA_FIRST + 18
#define WIA_IPA_COLOR_PROFILE                   WIA_IPA_FIRST + 19
#define WIA_IPA_MIN_BUFFER_SIZE                 WIA_IPA_FIRST + 20
// Note:  BUFFER_SIZE and MIN_BUFFER_SIZE have the same propids
#define WIA_IPA_BUFFER_SIZE                     WIA_IPA_FIRST + 20
#define WIA_IPA_REGION_TYPE                     WIA_IPA_FIRST + 21
#define WIA_IPA_ICM_PROFILE_NAME                WIA_IPA_FIRST + 22
#define WIA_IPA_APP_COLOR_MAPPING               WIA_IPA_FIRST + 23
#define WIA_IPA_PROP_STREAM_COMPAT_ID           WIA_IPA_FIRST + 24
#define WIA_IPA_FILENAME_EXTENSION              WIA_IPA_FIRST + 25
#define WIA_IPA_SUPPRESS_PROPERTY_PAGE          WIA_IPA_FIRST + 26
#define WIA_IPA_LAST                            WIA_IPA_FIRST + 26

#define  WIA_IPA_ITEM_NAME_STR                  L"Item Name"
#define  WIA_IPA_FULL_ITEM_NAME_STR             L"Full Item Name"
#define  WIA_IPA_ITEM_TIME_STR                  L"Item Time Stamp"
#define  WIA_IPA_ITEM_FLAGS_STR                 L"Item Flags"
#define  WIA_IPA_ACCESS_RIGHTS_STR              L"Access Rights"
#define  WIA_IPA_DATATYPE_STR                   L"Data Type"
#define  WIA_IPA_DEPTH_STR                      L"Bits Per Pixel"
#define  WIA_IPA_PREFERRED_FORMAT_STR           L"Preferred Format"
#define  WIA_IPA_FORMAT_STR                     L"Format"
#define  WIA_IPA_COMPRESSION_STR                L"Compression"
#define  WIA_IPA_TYMED_STR                      L"Media Type"
#define  WIA_IPA_CHANNELS_PER_PIXEL_STR         L"Channels Per Pixel"
#define  WIA_IPA_BITS_PER_CHANNEL_STR           L"Bits Per Channel"
#define  WIA_IPA_PLANAR_STR                     L"Planar"
#define  WIA_IPA_PIXELS_PER_LINE_STR            L"Pixels Per Line"
#define  WIA_IPA_BYTES_PER_LINE_STR             L"Bytes Per Line"
#define  WIA_IPA_NUMBER_OF_LINES_STR            L"Number of Lines"
#define  WIA_IPA_GAMMA_CURVES_STR               L"Gamma Curves"
#define  WIA_IPA_ITEM_SIZE_STR                  L"Item Size"
#define  WIA_IPA_COLOR_PROFILE_STR              L"Color Profiles"
#define  WIA_IPA_MIN_BUFFER_SIZE_STR            L"Buffer Size"
#define  WIA_IPA_REGION_TYPE_STR                L"Region Type"
#define  WIA_IPA_ICM_PROFILE_NAME_STR           L"Color Profile Name"
#define  WIA_IPA_APP_COLOR_MAPPING_STR          L"Application Applies Color Mapping"
#define  WIA_IPA_PROP_STREAM_COMPAT_ID_STR      L"Stream Compatibility ID"
#define  WIA_IPA_FILENAME_EXTENSION_STR         L"Filename extension"
#define  WIA_IPA_SUPPRESS_PROPERTY_PAGE_STR     L"Suppress a property page"

#define  WIA_NUM_IPA (1 + WIA_IPA_LAST - WIA_IPA_FIRST)


//
// Camera item properties
//

#define WIA_IPC_FIRST                          WIA_IPA_FIRST + WIA_RESERVED_FOR_NEW_PROPS
#define WIA_IPC_THUMBNAIL                      WIA_IPC_FIRST + 0
#define WIA_IPC_THUMB_WIDTH                    WIA_IPC_FIRST + 1
#define WIA_IPC_THUMB_HEIGHT                   WIA_IPC_FIRST + 2
#define WIA_IPC_AUDIO_AVAILABLE                WIA_IPC_FIRST + 3
#define WIA_IPC_AUDIO_DATA_FORMAT              WIA_IPC_FIRST + 4
#define WIA_IPC_AUDIO_DATA                     WIA_IPC_FIRST + 5
#define WIA_IPC_NUM_PICT_PER_ROW               WIA_IPC_FIRST + 6
#define WIA_IPC_SEQUENCE                       WIA_IPC_FIRST + 7
#define WIA_IPC_TIMEDELAY                      WIA_IPC_FIRST + 8
#define WIA_IPC_LAST                           WIA_IPC_FIRST + 8

#define WIA_IPC_THUMBNAIL_STR                  L"Thumbnail Data"
#define WIA_IPC_THUMB_WIDTH_STR                L"Thumbnail Width"
#define WIA_IPC_THUMB_HEIGHT_STR               L"Thumbnail Height"
#define WIA_IPC_AUDIO_AVAILABLE_STR            L"Audio Available"
#define WIA_IPC_AUDIO_DATA_FORMAT_STR          L"Audio Format"
#define WIA_IPC_AUDIO_DATA_STR                 L"Audio Data"
#define WIA_IPC_NUM_PICT_PER_ROW_STR           L"Pictures per Row"
#define WIA_IPC_SEQUENCE_STR                   L"Sequence Number"
#define WIA_IPC_TIMEDELAY_STR                  L"Time Delay"

#define WIA_NUM_IPC (1 + WIA_IPC_LAST - WIA_IPC_FIRST)


//
// Scanner item properties
//
#define WIA_IPS_FIRST                          WIA_IPC_FIRST + WIA_RESERVED_FOR_NEW_PROPS
#define WIA_IPS_CUR_INTENT                     WIA_IPS_FIRST + 0
#define WIA_IPS_XRES                           WIA_IPS_FIRST + 1
#define WIA_IPS_YRES                           WIA_IPS_FIRST + 2
#define WIA_IPS_XPOS                           WIA_IPS_FIRST + 3
#define WIA_IPS_YPOS                           WIA_IPS_FIRST + 4
#define WIA_IPS_XEXTENT                        WIA_IPS_FIRST + 5
#define WIA_IPS_YEXTENT                        WIA_IPS_FIRST + 6
#define WIA_IPS_PHOTOMETRIC_INTERP             WIA_IPS_FIRST + 7
#define WIA_IPS_BRIGHTNESS                     WIA_IPS_FIRST + 8
#define WIA_IPS_CONTRAST                       WIA_IPS_FIRST + 9
#define WIA_IPS_ORIENTATION                    WIA_IPS_FIRST + 10
#define WIA_IPS_ROTATION                       WIA_IPS_FIRST + 11
#define WIA_IPS_MIRROR                         WIA_IPS_FIRST + 12
#define WIA_IPS_THRESHOLD                      WIA_IPS_FIRST + 13
#define WIA_IPS_INVERT                         WIA_IPS_FIRST + 14
#define WIA_IPS_WARM_UP_TIME                   WIA_IPS_FIRST + 15
#define WIA_IPS_LAST                           WIA_IPS_FIRST + 15

#define WIA_IPS_CUR_INTENT_STR                 L"Current Intent"
#define WIA_IPS_XRES_STR                       L"Horizontal Resolution"
#define WIA_IPS_YRES_STR                       L"Vertical Resolution"
#define WIA_IPS_XPOS_STR                       L"Horizontal Start Position"
#define WIA_IPS_YPOS_STR                       L"Vertical Start Position"
#define WIA_IPS_XEXTENT_STR                    L"Horizontal Extent"
#define WIA_IPS_YEXTENT_STR                    L"Vertical Extent"
#define WIA_IPS_PHOTOMETRIC_INTERP_STR         L"Photometric Interpretation"
#define WIA_IPS_BRIGHTNESS_STR                 L"Brightness"
#define WIA_IPS_CONTRAST_STR                   L"Contrast"
#define WIA_IPS_ORIENTATION_STR                L"Orientation"
#define WIA_IPS_ROTATION_STR                   L"Rotation"
#define WIA_IPS_MIRROR_STR                     L"Mirror"
#define WIA_IPS_THRESHOLD_STR                  L"Threshold"
#define WIA_IPS_INVERT_STR                     L"Invert"
#define WIA_IPS_WARM_UP_TIME_STR               L"Lamp Warm up Time"

#define WIA_NUM_IPS (1 + WIA_IPS_LAST - WIA_IPS_FIRST)

//**************************************************************************
//
// Vendor defined property area
//
//**************************************************************************

#define WIA_PRIVATE_DEVPROP    (WIA_IPS_FIRST + WIA_RESERVED_FOR_ALL_MS_PROPS)
#define WIA_PRIVATE_ITEMPROP   (WIA_PRIVATE_DEVPROP + WIA_RESERVED_FOR_ALL_MS_PROPS)


//**************************************************************************
//
// WIA Property Constants
//
//**************************************************************************

//
// WIA_DPC_WHITE_BALANCE constants
//

#define WHITEBALANCE_MANUAL        1
#define WHITEBALANCE_AUTO          2
#define WHITEBALANCE_ONEPUSH_AUTO      3
#define WHITEBALANCE_DAYLIGHT          4
#define WHITEBALANCE_FLORESCENT        5
#define WHITEBALANCE_TUNGSTEN          6
#define WHITEBALANCE_FLASH         7

//
// WIA_DPC_FOCUS_MODE constants
//

#define FOCUSMODE_MANUAL        1
#define FOCUSMODE_AUTO          2
#define FOCUSMODE_MACROAUTO     3

//
// WIA_DPC_EXPOSURE_METERING_MODE constants
//

#define EXPOSUREMETERING_AVERAGE    1
#define EXPOSUREMETERING_CENTERWEIGHT   2
#define EXPOSUREMETERING_MULTISPOT  3
#define EXPOSUREMETERING_CENTERSPOT 4

//
// WIA_DPC_FLASH_MODE constants
//

#define FLASHMODE_AUTO          1
#define FLASHMODE_OFF           2
#define FLASHMODE_FILL          3
#define FLASHMODE_REDEYE_AUTO       4
#define FLASHMODE_REDEYE_FILL       5
#define FLASHMODE_EXTERNALSYNC      6

//
// WIA_DPC_EXPOSURE_MODE constants
//

#define EXPOSUREMODE_MANUAL     1
#define EXPOSUREMODE_AUTO       2
#define EXPOSUREMODE_APERTURE_PRIORITY  3
#define EXPOSUREMODE_SHUTTER_PRIORITY   4
#define EXPOSUREMODE_PROGRAM_CREATIVE   5
#define EXPOSUREMODE_PROGRAM_ACTION 6
#define EXPOSUREMODE_PORTRAIT       7

//
// WIA_DPC_CAPTURE_MODE constants
//

#define CAPTUREMODE_NORMAL      1
#define CAPTUREMODE_BURST       2
#define CAPTUREMODE_TIMELAPSE       3

//
// WIA_DPC_EFFECT_MODE constants
//

#define EFFECTMODE_STANDARD     1
#define EFFECTMODE_BW           2
#define EFFECTMODE_SEPIA        3

//
// WIA_DPC_FOCUS_METERING_MODE constants
//

#define FOCUSMETERING_CENTERSPOT    1
#define FOCUSMETERING_MULTISPOT     2

//
// WIA_DPC_POWER_MODE constants
//

#define POWERMODE_LINE              1
#define POWERMODE_BATTERY           2

//
// WIA_DPS_SHEET_FEEDER_REGISTRATION and
// WIA_DPS_HORIZONTAL_BED_REGISTRATION constants
//

#define  LEFT_JUSTIFIED             0
#define  CENTERED                   1
#define  RIGHT_JUSTIFIED            2

//
// WIA_DPS_VERTICAL_BED_REGISTRATION constants
//

#define  TOP_JUSTIFIED              0
#define  CENTERED                   1
#define  BOTTOM_JUSTIFIED           2

//
// WIA_DPS_ORIENTATION and WIA_DPS_ROTATION constants
//

#define  PORTRAIT                   0
#define  LANSCAPE                   1
#define  ROT180                     2
#define  ROT270                     3

//
// WIA_DPS_MIRROR flags
//

#define  MIRRORED                   0x01

//
// WIA_DPS_DOCUMENT_HANDLING_CAPABILITIES flags
//

#define  FEED                       0x01
#define  FLAT                       0x02
#define  DUP                        0x04
#define  DETECT_FLAT                0x08
#define  DETECT_SCAN                0x10
#define  DETECT_FEED                0x20
#define  DETECT_DUP                 0x40
#define  DETECT_FEED_AVAIL          0x80
#define  DETECT_DUP_AVAIL           0x100

//
// WIA_DPS_DOCUMENT_HANDLING_STATUS flags
//

#define  FEED_READY                 0x01
#define  FLAT_READY                 0x02
#define  DUP_READY                  0x04
#define  FLAT_COVER_UP              0x08
#define  PATH_COVER_UP              0x10
#define  PAPER_JAM                  0x20

//
// WIA_DPS_DOCUMENT_HANDLING_SELECT flags
//

#define  FEEDER                     0x001
#define  FLATBED                    0x002
#define  DUPLEX                     0x004
#define  FRONT_FIRST                0x008
#define  BACK_FIRST                 0x010
#define  FRONT_ONLY                 0x020
#define  BACK_ONLY                  0x040
#define  NEXT_PAGE                  0x080
#define  PREFEED                    0x100
#define  AUTO_ADVANCE               0x200

//
// WIA_DPS_TRANSPARENCY flags
//

#define  LIGHT_SOURCE_PRESENT_DETECT 0x01
#define  LIGHT_SOURCE_PRESENT        0x02
#define  LIGHT_SOURCE_DETECT_READY   0x04
#define  LIGHT_SOURCE_READY          0x08

//
// WIA_DPS_TRANSPARENCY_SELECT flags
//

#define  LIGHT_SOURCE_SELECT        0x001

//
// WIA_DPS_SCAN_AHEAD_PAGES constants
//

#define  WIA_SCAN_AHEAD_ALL         0

//
// WIA_DPS_PAGES constants
//

#define  ALL_PAGES                  0

//
// WIA_DPS_PREVIEW constants
//

#define WIA_FINAL_SCAN              0
#define WIA_PREVIEW_SCAN            1

//
// WIA_DPS_SHOW_PREVIEW_CONTROL constants
//

#define WIA_SHOW_PREVIEW_CONTROL        0
#define WIA_DONT_SHOW_PREVIEW_CONTROL   1

//
// Predefined strings for WIA_DPS_ENDORSER_STRING
//

#define WIA_ENDORSER_TOK_DATE       L"$DATE$"
#define WIA_ENDORSER_TOK_TIME       L"$TIME$"
#define WIA_ENDORSER_TOK_PAGE_COUNT L"$PAGE_COUNT$"
#define WIA_ENDORSER_TOK_DAY        L"$DAY$"
#define WIA_ENDORSER_TOK_MONTH      L"$MONTH$"
#define WIA_ENDORSER_TOK_YEAR       L"$YEAR$"

//
// WIA_DPS_PAGE_SIZE constants
//

#define WIA_PAGE_A4         0
#define WIA_PAGE_LETTER     1
#define WIA_PAGE_CUSTOM     2

//
// WIA_IPA_COMPRESSION constants
//

#define WIA_COMPRESSION_NONE        0
#define WIA_COMPRESSION_BI_RLE4     1
#define WIA_COMPRESSION_BI_RLE8     2
#define WIA_COMPRESSION_G3          3
#define WIA_COMPRESSION_G4          4
#define WIA_COMPRESSION_JPEG        5


//
// WIA_IPA_PLANAR constants
//

#define WIA_PACKED_PIXEL            0
#define WIA_PLANAR                  1

//
// WIA_IPA_DATATYPE constants
//

#define WIA_DATA_THRESHOLD                      0
#define WIA_DATA_DITHER                         1
#define WIA_DATA_GRAYSCALE                      2
#define WIA_DATA_COLOR                          3
#define WIA_DATA_COLOR_THRESHOLD                4
#define WIA_DATA_COLOR_DITHER                   5

//
// WIA_IPA_SUPPRESS_PROPERTY_PAGE flags
//

#define WIA_PROPPAGE_SCANNER_ITEM_GENERAL       0x00000001
#define WIA_PROPPAGE_CAMERA_ITEM_GENERAL        0x00000002

//
// WIA_IPS_CUR_INTENT flags
//
#define WIA_INTENT_NONE                 0x00000000
#define WIA_INTENT_IMAGE_TYPE_COLOR     0x00000001
#define WIA_INTENT_IMAGE_TYPE_GRAYSCALE 0x00000002
#define WIA_INTENT_IMAGE_TYPE_TEXT      0x00000004
#define WIA_INTENT_IMAGE_TYPE_MASK      0x0000000F
#define WIA_INTENT_MINIMIZE_SIZE        0x00010000
#define WIA_INTENT_MAXIMIZE_QUALITY     0x00020000
#define WIA_INTENT_BEST_PREVIEW         0x00040000
#define WIA_INTENT_SIZE_MASK            0x000F0000

//
// WIA_IPS_PHOTOMETRIC_INTERP constants
//

#define WIA_PHOTO_WHITE_1      0   // default, white is 1, black is 0
#define WIA_PHOTO_WHITE_0      1   // default, white is 0, black is 1


//**************************************************************************
//
// WIA Extended Property Identifiers
//
//**************************************************************************

#define  WIA_RANGE_MIN                          0
#define  WIA_RANGE_NOM                          1
#define  WIA_RANGE_MAX                          2
#define  WIA_RANGE_STEP                         3
#define  WIA_RANGE_NUM_ELEMS                    4

#define  WIA_LIST_COUNT                         0
#define  WIA_LIST_NOM                           1
#define  WIA_LIST_VALUES                        2
#define  WIA_LIST_NUM_ELEMS                     2

#define  WIA_FLAG_NOM                           0
#define  WIA_FLAG_VALUES                        1
#define  WIA_FLAG_NUM_ELEMS                     2


//**************************************************************************
//
// Property id to string mapping
//
//**************************************************************************

#ifdef DEFINE_WIA_PROPID_TO_NAME

WIA_PROPID_TO_NAME g_wiaPropIdToName[] =
{
    {WIA_DIP_DEV_ID,                          WIA_DIP_DEV_ID_STR},
    {WIA_DIP_VEND_DESC,                       WIA_DIP_VEND_DESC_STR},
    {WIA_DIP_DEV_DESC,                        WIA_DIP_DEV_DESC_STR},
    {WIA_DIP_DEV_TYPE,                        WIA_DIP_DEV_TYPE_STR},
    {WIA_DIP_PORT_NAME,                       WIA_DIP_PORT_NAME_STR},
    {WIA_DIP_DEV_NAME,                        WIA_DIP_DEV_NAME_STR},
    {WIA_DIP_SERVER_NAME,                     WIA_DIP_SERVER_NAME_STR},
    {WIA_DIP_REMOTE_DEV_ID,                   WIA_DIP_REMOTE_DEV_ID_STR},
    {WIA_DIP_UI_CLSID,                        WIA_DIP_UI_CLSID_STR},
    {WIA_DIP_HW_CONFIG,                       WIA_DIP_HW_CONFIG_STR},
    {WIA_DIP_BAUDRATE,                        WIA_DIP_BAUDRATE_STR},
    {WIA_DIP_STI_GEN_CAPABILITIES,            WIA_DIP_STI_GEN_CAPABILITIES_STR},
    {WIA_DIP_WIA_VERSION,                     WIA_DIP_WIA_VERSION_STR},
    {WIA_DIP_DRIVER_VERSION,                  WIA_DIP_DRIVER_VERSION_STR},
    {WIA_DPA_FIRMWARE_VERSION,                WIA_DPA_FIRMWARE_VERSION_STR},
    {WIA_DPA_CONNECT_STATUS,                  WIA_DPA_CONNECT_STATUS_STR},
    {WIA_DPA_DEVICE_TIME,                     WIA_DPA_DEVICE_TIME_STR},
    {WIA_DPC_PICTURES_TAKEN,                  WIA_DPC_PICTURES_TAKEN_STR},
    {WIA_DPC_PICTURES_REMAINING,              WIA_DPC_PICTURES_REMAINING_STR},
    {WIA_DPC_EXPOSURE_MODE,                   WIA_DPC_EXPOSURE_MODE_STR},
    {WIA_DPC_EXPOSURE_COMP,                   WIA_DPC_EXPOSURE_COMP_STR},
    {WIA_DPC_EXPOSURE_TIME,                   WIA_DPC_EXPOSURE_TIME_STR},
    {WIA_DPC_FNUMBER,                         WIA_DPC_FNUMBER_STR},
    {WIA_DPC_FLASH_MODE,                      WIA_DPC_FLASH_MODE_STR},
    {WIA_DPC_FOCUS_MODE,                      WIA_DPC_FOCUS_MODE_STR},
    {WIA_DPC_FOCUS_MANUAL_DIST,               WIA_DPC_FOCUS_MANUAL_DIST_STR},
    {WIA_DPC_ZOOM_POSITION,                   WIA_DPC_ZOOM_POSITION_STR},
    {WIA_DPC_PAN_POSITION,                    WIA_DPC_PAN_POSITION_STR},
    {WIA_DPC_TILT_POSITION,                   WIA_DPC_TILT_POSITION_STR},
    {WIA_DPC_TIMER_MODE,                      WIA_DPC_TIMER_MODE_STR},
    {WIA_DPC_TIMER_VALUE,                     WIA_DPC_TIMER_VALUE_STR},
    {WIA_DPC_POWER_MODE,                      WIA_DPC_POWER_MODE_STR},
    {WIA_DPC_BATTERY_STATUS,                  WIA_DPC_BATTERY_STATUS_STR},
    {WIA_DPC_DIMENSION,                       WIA_DPC_DIMENSION_STR},
    {WIA_DPS_HORIZONTAL_BED_SIZE,             WIA_DPS_HORIZONTAL_BED_SIZE_STR},
    {WIA_DPS_VERTICAL_BED_SIZE,               WIA_DPS_VERTICAL_BED_SIZE_STR},
    {WIA_DPS_HORIZONTAL_SHEET_FEED_SIZE,      WIA_DPS_HORIZONTAL_SHEET_FEED_SIZE_STR},
    {WIA_DPS_VERTICAL_SHEET_FEED_SIZE,        WIA_DPS_VERTICAL_SHEET_FEED_SIZE_STR},
    {WIA_DPS_SHEET_FEEDER_REGISTRATION,       WIA_DPS_SHEET_FEEDER_REGISTRATION_STR},
    {WIA_DPS_HORIZONTAL_BED_REGISTRATION,     WIA_DPS_HORIZONTAL_BED_REGISTRATION_STR},
    {WIA_DPS_VERTICAL_BED_REGISTRATION,       WIA_DPS_VERTICAL_BED_REGISTRATION_STR},
    {WIA_DPS_PLATEN_COLOR,                    WIA_DPS_PLATEN_COLOR_STR},
    {WIA_DPS_PAD_COLOR,                       WIA_DPS_PAD_COLOR_STR},
    {WIA_DPS_FILTER_SELECT,                   WIA_DPS_FILTER_SELECT_STR},
    {WIA_DPS_DITHER_SELECT,                   WIA_DPS_DITHER_SELECT_STR},
    {WIA_DPS_DITHER_PATTERN_DATA,             WIA_DPS_DITHER_PATTERN_DATA_STR},
    {WIA_DPS_DOCUMENT_HANDLING_CAPABILITIES,  WIA_DPS_DOCUMENT_HANDLING_CAPABILITIES_STR},
    {WIA_DPS_DOCUMENT_HANDLING_STATUS,        WIA_DPS_DOCUMENT_HANDLING_STATUS_STR},
    {WIA_DPS_DOCUMENT_HANDLING_SELECT,        WIA_DPS_DOCUMENT_HANDLING_SELECT_STR},
    {WIA_DPS_DOCUMENT_HANDLING_CAPACITY,      WIA_DPS_DOCUMENT_HANDLING_CAPACITY_STR},
    {WIA_DPS_OPTICAL_XRES,                    WIA_DPS_OPTICAL_XRES_STR},
    {WIA_DPS_OPTICAL_YRES,                    WIA_DPS_OPTICAL_YRES_STR},
    {WIA_DPS_ENDORSER_CHARACTERS,             WIA_DPS_ENDORSER_CHARACTERS_STR},
    {WIA_DPS_ENDORSER_STRING,                 WIA_DPS_ENDORSER_STRING_STR},
    {WIA_DPS_SCAN_AHEAD_PAGES,                WIA_DPS_SCAN_AHEAD_PAGES_STR},
    {WIA_DPS_MAX_SCAN_TIME,                   WIA_DPS_MAX_SCAN_TIME_STR},
    {WIA_DPS_PAGES,                           WIA_DPS_PAGES_STR},
    {WIA_DPS_PAGE_SIZE,                       WIA_DPS_PAGE_SIZE_STR},
    {WIA_DPS_PAGE_WIDTH,                      WIA_DPS_PAGE_WIDTH_STR},
    {WIA_DPS_PAGE_HEIGHT,                     WIA_DPS_PAGE_HEIGHT_STR},
    {WIA_DPS_PREVIEW,                         WIA_DPS_PREVIEW_STR},
    {WIA_DPS_TRANSPARENCY,                    WIA_DPS_TRANSPARENCY_STR},
    {WIA_DPS_TRANSPARENCY_SELECT,             WIA_DPS_TRANSPARENCY_SELECT_STR},
    {WIA_DPS_SHOW_PREVIEW_CONTROL,            WIA_DPS_SHOW_PREVIEW_CONTROL_STR},
    {WIA_DPS_MIN_HORIZONTAL_SHEET_FEED_SIZE,  WIA_DPS_MIN_HORIZONTAL_SHEET_FEED_SIZE_STR},
    {WIA_DPS_MIN_VERTICAL_SHEET_FEED_SIZE,    WIA_DPS_MIN_VERTICAL_SHEET_FEED_SIZE_STR},
    {WIA_DPV_LAST_PICTURE_TAKEN,              WIA_DPV_LAST_PICTURE_TAKEN_STR},
    {WIA_DPV_IMAGES_DIRECTORY,                WIA_DPV_IMAGES_DIRECTORY_STR},
    {WIA_DPV_DSHOW_DEVICE_PATH,               WIA_DPV_DSHOW_DEVICE_PATH_STR},
    {WIA_DPF_MOUNT_POINT,                     WIA_DPF_MOUNT_POINT_STR},
    {WIA_IPA_ITEM_NAME,                       WIA_IPA_ITEM_NAME_STR},
    {WIA_IPA_FULL_ITEM_NAME,                  WIA_IPA_FULL_ITEM_NAME_STR},
    {WIA_IPA_ITEM_TIME,                       WIA_IPA_ITEM_TIME_STR},
    {WIA_IPA_ITEM_FLAGS,                      WIA_IPA_ITEM_FLAGS_STR},
    {WIA_IPA_ACCESS_RIGHTS,                   WIA_IPA_ACCESS_RIGHTS_STR},
    {WIA_IPA_DATATYPE,                        WIA_IPA_DATATYPE_STR},
    {WIA_IPA_DEPTH,                           WIA_IPA_DEPTH_STR},
    {WIA_IPA_PREFERRED_FORMAT,                WIA_IPA_PREFERRED_FORMAT_STR},
    {WIA_IPA_FORMAT,                          WIA_IPA_FORMAT_STR},
    {WIA_IPA_COMPRESSION,                     WIA_IPA_COMPRESSION_STR},
    {WIA_IPA_TYMED,                           WIA_IPA_TYMED_STR},
    {WIA_IPA_CHANNELS_PER_PIXEL,              WIA_IPA_CHANNELS_PER_PIXEL_STR},
    {WIA_IPA_BITS_PER_CHANNEL,                WIA_IPA_BITS_PER_CHANNEL_STR},
    {WIA_IPA_PLANAR,                          WIA_IPA_PLANAR_STR},
    {WIA_IPA_PIXELS_PER_LINE,                 WIA_IPA_PIXELS_PER_LINE_STR},
    {WIA_IPA_BYTES_PER_LINE,                  WIA_IPA_BYTES_PER_LINE_STR},
    {WIA_IPA_NUMBER_OF_LINES,                 WIA_IPA_NUMBER_OF_LINES_STR},
    {WIA_IPA_GAMMA_CURVES,                    WIA_IPA_GAMMA_CURVES_STR},
    {WIA_IPA_ITEM_SIZE,                       WIA_IPA_ITEM_SIZE_STR},
    {WIA_IPA_COLOR_PROFILE,                   WIA_IPA_COLOR_PROFILE_STR},
    {WIA_IPA_MIN_BUFFER_SIZE,                 WIA_IPA_MIN_BUFFER_SIZE_STR},
    {WIA_IPA_REGION_TYPE,                     WIA_IPA_REGION_TYPE_STR},
    {WIA_IPA_ICM_PROFILE_NAME,                WIA_IPA_ICM_PROFILE_NAME_STR},
    {WIA_IPA_APP_COLOR_MAPPING,               WIA_IPA_APP_COLOR_MAPPING_STR},
    {WIA_IPA_PROP_STREAM_COMPAT_ID,           WIA_IPA_PROP_STREAM_COMPAT_ID_STR},
    {WIA_IPA_FILENAME_EXTENSION,              WIA_IPA_FILENAME_EXTENSION_STR},
    {WIA_IPA_SUPPRESS_PROPERTY_PAGE,          WIA_IPA_SUPPRESS_PROPERTY_PAGE_STR},
    {WIA_IPC_THUMBNAIL,                       WIA_IPC_THUMBNAIL_STR},
    {WIA_IPC_THUMB_WIDTH,                     WIA_IPC_THUMB_WIDTH_STR},
    {WIA_IPC_THUMB_HEIGHT,                    WIA_IPC_THUMB_HEIGHT_STR},
    {WIA_IPC_AUDIO_AVAILABLE,                 WIA_IPC_AUDIO_AVAILABLE_STR},
    {WIA_IPC_AUDIO_DATA_FORMAT,               WIA_IPC_AUDIO_DATA_FORMAT_STR},
    {WIA_IPC_AUDIO_DATA,                      WIA_IPC_AUDIO_DATA_STR},
    {WIA_IPC_NUM_PICT_PER_ROW,                WIA_IPC_NUM_PICT_PER_ROW_STR},
    {WIA_IPC_SEQUENCE,                        WIA_IPC_SEQUENCE_STR},
    {WIA_IPC_TIMEDELAY,                       WIA_IPC_TIMEDELAY_STR},
    {WIA_IPS_CUR_INTENT,                      WIA_IPS_CUR_INTENT_STR},
    {WIA_IPS_XRES,                            WIA_IPS_XRES_STR},
    {WIA_IPS_YRES,                            WIA_IPS_YRES_STR},
    {WIA_IPS_XPOS,                            WIA_IPS_XPOS_STR},
    {WIA_IPS_YPOS,                            WIA_IPS_YPOS_STR},
    {WIA_IPS_XEXTENT,                         WIA_IPS_XEXTENT_STR},
    {WIA_IPS_YEXTENT,                         WIA_IPS_YEXTENT_STR},
    {WIA_IPS_PHOTOMETRIC_INTERP,              WIA_IPS_PHOTOMETRIC_INTERP_STR},
    {WIA_IPS_BRIGHTNESS,                      WIA_IPS_BRIGHTNESS_STR},
    {WIA_IPS_CONTRAST,                        WIA_IPS_CONTRAST_STR},
    {WIA_IPS_ORIENTATION,                     WIA_IPS_ORIENTATION_STR},
    {WIA_IPS_ROTATION,                        WIA_IPS_ROTATION_STR},
    {WIA_IPS_MIRROR,                          WIA_IPS_MIRROR_STR},
    {WIA_IPS_THRESHOLD,                       WIA_IPS_THRESHOLD_STR},
    {WIA_IPS_INVERT,                          WIA_IPS_INVERT_STR},
    {WIA_IPS_WARM_UP_TIME,                    WIA_IPS_WARM_UP_TIME_STR},
    {0,                                       L"Not a WIA property"}
};

#else

extern WIA_PROPID_TO_NAME g_wiaPropIdToName[];

#endif

#endif //WIAPROP_H_INCLUDED


//
//   Macro Helpers
//

#define WIA_PROP_LIST_COUNT(ppv) (((PROPVARIANT*)ppv)->cal.cElems - WIA_LIST_VALUES)

#define WIA_PROP_LIST_VALUE(ppv, index)                              \\
     ((index > ((PROPVARIANT*) ppv)->cal.cElems - WIA_LIST_VALUES) || (index < -WIA_LIST_NOM)) ?\\
     NULL :                                                          \\
     (((PROPVARIANT*) ppv)->vt == VT_UI1) ?                          \\
     ((PROPVARIANT*) ppv)->caub.pElems[WIA_LIST_VALUES + index] :    \\
     (((PROPVARIANT*) ppv)->vt == VT_UI2) ?                          \\
     ((PROPVARIANT*) ppv)->caui.pElems[WIA_LIST_VALUES + index] :    \\
     (((PROPVARIANT*) ppv)->vt == VT_UI4) ?                          \\
     ((PROPVARIANT*) ppv)->caul.pElems[WIA_LIST_VALUES + index] :    \\
     (((PROPVARIANT*) ppv)->vt == VT_I2) ?                           \\
     ((PROPVARIANT*) ppv)->cai.pElems[WIA_LIST_VALUES + index] :     \\
     (((PROPVARIANT*) ppv)->vt == VT_I4) ?                           \\
     ((PROPVARIANT*) ppv)->cal.pElems[WIA_LIST_VALUES + index] :     \\
     (((PROPVARIANT*) ppv)->vt == VT_R4) ?                           \\
     ((PROPVARIANT*) ppv)->caflt.pElems[WIA_LIST_VALUES + index] :   \\
     (((PROPVARIANT*) ppv)->vt == VT_R8) ?                           \\
     ((PROPVARIANT*) ppv)->cadbl.pElems[WIA_LIST_VALUES + index] :   \\
     (((PROPVARIANT*) ppv)->vt == VT_BSTR) ?                         \\
     (LONG)(((PROPVARIANT*) ppv)->cabstr.pElems[WIA_LIST_VALUES + index]) : \\
     NULL


//
//   End of Macro Helpers
//

#ifdef __cplusplus
};
#endif

//
// Reset packing
//
#include <poppack.h>

#endif // _WIADEF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\inc\wiadbg.h ===
#ifndef __WIADBG_H_INCLUDED
#define __WIADBG_H_INCLUDED

#if defined(DBG) || defined(_DEBUG) || defined(DEBUG)
#define WIA_DEBUG
#endif

#if defined(WIA_DEBUG)

// This will eliminate the warning "conditional expression is constant"
// that we get when compiling the do { ... } while (false) stuff in the
// debug macros when /W4 is set
#pragma warning(disable:4127)


    #define WIA_DEBUG_CREATE( hInstance, pszModuleName, bDisplayUi, bLogFile)\
    do\
    {\
        _global_pWiaDebugger = CWiaDebugger::Create( hInstance, pszModuleName, bDisplayUi, bLogFile );\
    } while (false)

    #define WIA_DEBUG_EXISTS() (_global_pWiaDebugger != NULL)

    #define WIA_DEBUG_DESTROY()\
    do\
    {\
        if (NULL != _global_pWiaDebugger) {\
            _global_pWiaDebugger->Destroy();\
            _global_pWiaDebugger = NULL;\
        }\
    } while (false)

    #define WIA_TRACE(args)\
    do\
    {\
        if (NULL != _global_pWiaDebugger)\
            _global_pWiaDebugger->WiaTrace args;\
    } while (false)

    #define WIA_ERROR(args)\
    do\
    {\
        if (NULL != _global_pWiaDebugger)\
            _global_pWiaDebugger->WiaError args;\
    } while (false)

    #define WIA_PRINT_COLOR(args)\
    do\
    {\
        if (NULL != _global_pWiaDebugger)\
            _global_pWiaDebugger->PrintColor args;\
    } while (false)

    #define WIA_SETFLAGS(flags)\
    do\
    {\
        if (NULL != _global_pWiaDebugger)\
            _global_pWiaDebugger->SetDebugFlags(flags);\
    } while (false)

    #define WIA_GETFLAGS(flags)\
    do\
    {\
        if (NULL != _global_pWiaDebugger)\
            flags = _global_pWiaDebugger->GetDebugFlags();\
    } while (false)

    #define WIA_SETFILEHANDLE(hndl)\
    do\
    {\
        if (NULL != _global_pWiaDebugger)\
            _global_pWiaDebugger->SetLogFileHandle;\
    } while (false)

#ifdef WINNT
    #define WIA_ASSERT(x)\
    do\
    {\
        if (!(x))\
        {\
            WIA_ERROR((TEXT("ASSERTION FAILED: %hs(%d): %hs"),__FILE__,__LINE__,#x));\
            DebugBreak();\
        }\
    }\
    while (false)
#else
    #define WIA_ASSERT(x)\
    do\
    {\
        if (!(x))\
        {\
            WIA_ERROR((TEXT("ASSERTION FAILED: %hs(%d): %hs"),__FILE__,__LINE__,#x));\
            _asm { int 3 };\
        }\
    }\
    while (false)
#endif

    #define WIA_PUSHFUNCTION(n)\
        CDebugFunctionPushPop _debugFunctionPushPop( &_global_pWiaDebugger, n )

    #define WIA_DECLARE_DEBUGGER()

    #define WIA_CHECK_HR(hr,fnc)\
    if (FAILED(hr))\
    {\
        WIA_ERROR((TEXT("%s failed, hr=0x%08X" ), fnc, hr));\
    }

    #define WIA_RETURN_HR(hr)\
    if (FAILED(hr))\
    {\
        WIA_ERROR((TEXT("Returning WiaError (hr=0x%08X)"),hr));\
    }\
    return hr;


#else

    #define WIA_DEBUG_CREATE(hInstance, pszModuleName, bDisplayUi, bLogFile)
    #define WIA_DEBUG_EXISTS() (0)
    #define WIA_DEBUG_DESTROY()
    #define WIA_TRACE(args)
    #define WIA_ERROR(args)
    #define WIA_PRINT_COLOR(args)
    #define WIA_SETFLAGS(flags)
    #define WIA_GETFLAGS(flags)
    #define WIA_SETFILEHANDLE(hndl)
    #define WIA_ASSERT(x)
    #define WIA_PUSHFUNCTION(n)
    #define WIA_DECLARE_DEBUGGER()
    #define WIA_CHECK_HR(hr,fnc)
    #define WIA_RETURN_HR(hr)        return hr;

#endif

class CWiaDebugger
{
private:
    HWND      m_hWnd;
    HANDLE    m_hLogFile;
    int       m_nStackLevel;
    TCHAR     m_szModuleName[MAX_PATH];
    BOOL      m_bDisplayUi;
    BOOL      m_bLogFile;
    HANDLE    m_hThread;
    HANDLE    m_hStartedEvent;
    DWORD     m_dwThreadId;
    int       m_nFlags;
    HINSTANCE m_hInstance;
    enum      { m_nBufferMax = 2048 };
private:
    CWiaDebugger( HINSTANCE hInstance, LPTSTR pszModuleName, BOOL bDisplayUi, BOOL bLogFile, HANDLE hStartedEvent );
    DWORD DebugLoop(void);
    static DWORD ThreadProc( LPVOID pParam );
public:
    ~CWiaDebugger(void);
    static CWiaDebugger * __stdcall Create( HINSTANCE hInstance, LPTSTR pszModuleName, BOOL bDisplayUi=TRUE, BOOL bLogFile=TRUE );

    void Destroy(void)
    {
        PostMessage( WM_CLOSE );
    }
    void PostMessage( UINT uMsg, WPARAM wParam=0, LPARAM lParam=0 )
    {
        if (m_hWnd)
            ::PostMessage( m_hWnd, uMsg, wParam, lParam );
        else PostThreadMessage( m_dwThreadId, uMsg, wParam, lParam );
    }
    const HANDLE ThreadHandle(void) const
    {
        return m_hThread;
    }

    HANDLE   SetLogFileHandle(HANDLE hFile);
    HANDLE   GetLogFileHandle(void);

    // Various forms of the WiaTrace commands
    void     WiaTrace( LPCWSTR lpszFormat, ... );
    void     WiaTrace( LPCSTR lpszFormat, ... );
    void     WiaTrace( HRESULT hr );

    // Various forms of the WiaError commands
    void     WiaError( LPCWSTR lpszFormat, ... );
    void     WiaError( LPCSTR lpszFormat, ... );
    void     WiaError( HRESULT hr );

    // Print in color
    void     PrintColor( COLORREF crColor, LPCWSTR lpszMsg );
    void     PrintColor( COLORREF crColor, LPCSTR lpszMsg );

    // Set the default debug level
    int      SetDebugFlags( int nDebugLevel );
    int      GetDebugFlags(void);

    // Call stack indenting
    int      PushLevel( LPCTSTR lpszFunctionName );
    int      PopLevel( LPCTSTR lpszFunctionName );
    int      GetStackLevel(void);

    enum
    {
        DebugNone            = 0x00000000,
        DebugToWindow        = 0x00000001,
        DebugToFile          = 0x00000002,
        DebugToDebugger      = 0x00000004,
        DebugPrintThreadId   = 0x00010000,
        DebugPrintModuleName = 0x00020000,
        DebugMaximum         = 0xFFFFFFFF
    };
protected:
    void   RouteString( LPWSTR lpszMsg, COLORREF nColor );
    void   RouteString( LPSTR lpszMsg, COLORREF nColor );
    void   WriteMessageToFile( LPTSTR lpszMsg );
    LPTSTR RemoveTrailingCrLf( LPTSTR lpszStr );
    LPSTR  UnicodeToAnsi( LPSTR lpszAnsi, LPTSTR lpszUnicode );
    LPTSTR AnsiToTChar( LPCSTR pszAnsi, LPTSTR pszTChar );
    LPTSTR WideToTChar( LPWSTR pszWide, LPTSTR pszTChar );
    int    AddString( const LPCTSTR sz, COLORREF cr );
    void   PrependString( LPTSTR lpszTgt, LPCTSTR lpszStr );
    void   PrependThreadId( LPTSTR lpszMsg );
    void   PrependModuleName( LPTSTR lpszMsg );
    void   InsertStackLevelIndent( LPTSTR lpszMsg, int nStackLevel );
};

class CDebugFunctionPushPop
{
    typedef (*CPushFunction)( LPCTSTR );
    typedef (*CPopFunction)( LPCTSTR );
    CWiaDebugger **m_ppDebugger;
    CPushFunction m_pfnPush;
    CPushFunction m_pfnPop;
    LPCTSTR m_lpszFunctionName;
public:
    CDebugFunctionPushPop( CWiaDebugger **ppDebugger, LPCTSTR lpszFunctionName=NULL )
        : m_ppDebugger(ppDebugger),
          m_lpszFunctionName(lpszFunctionName)
    {
        if (m_ppDebugger && *m_ppDebugger)
            (*m_ppDebugger)->PushLevel(m_lpszFunctionName);
    }
    ~CDebugFunctionPushPop(void)
    {
        if (m_ppDebugger && *m_ppDebugger)
            (*m_ppDebugger)->PopLevel(m_lpszFunctionName);
    }
};

#ifdef WIA_DEBUG
extern CWiaDebugger *_global_pWiaDebugger;
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\inc\wiacammc.h ===
/**************************************************************************** 
*
*  (C) COPYRIGHT 2000, MICROSOFT CORP.
*
*  FILE:        wiacammc.h
*
*  VERSION:     1.0
*
*  DATE:        12/16/2000
*
*  DESCRIPTION:
*    Header for WIA camera microdriver.
*
*****************************************************************************/

#pragma once

#define WIACAMMICRO_API __declspec(dllexport) HRESULT __stdcall

#include <pshpack8.h>

/****************************************************************************\
* Camera microdriver definitions
\****************************************************************************/

//
// GetItemData state bit masks
//
const UINT MCAM_STATE_NEXT   = 0x00;
const UINT MCAM_STATE_FIRST  = 0x01;
const UINT MCAM_STATE_LAST   = 0x02;
const UINT MCAM_STATE_CANCEL = 0x04;

//
// Item type definition
//
enum {
    WiaMCamTypeUndef,
    WiaMCamTypeFolder,
    WiaMCamTypeOther,
    WiaMCamTypeImage,
    WiaMCamTypeAudio,
    WiaMCamTypeVideo
};

enum {
    WiaMCamEventItemAdded,
    WiaMCamEventItemDeleted,
    WiaMCamEventPropChanged
};

//
// Other constants
//
const INT MCAM_VERSION = 100;
const INT MCAM_EXT_LEN = 4;

//
// Structures
//
typedef struct _MCAM_DEVICE_INFO {
    INT          iSize;                // Size of this structure
    INT          iMcamVersion;         // Microcamera architecture version
    BYTE        *pPrivateStorage;      // Pointer to an area where the microdriver can store it's own device information
    BOOL         bSyncNeeded;          // Should be set if the driver can get out-of-sync with the camera (i.e. for serial cameras)
    BOOL         bSlowConnection;      // Indicates that the driver should optimize for a slow connection (i.e. serial)
    BOOL         bExclusivePort;       // Indicates that the device should be opened/closed for every operation (i.e. serial)
    BOOL         bEventsSupported;     // Set if the driver supports events
    PWSTR        pwszFirmwareVer;      // String representing the firmware version of the device, set to NULL if unknown
    LONG         lPicturesTaken;       // Number of pictures stored on the camera
    LONG         lPicturesRemaining;   // Space available on the camera, in pictures at the current resolution
    LONG         lTotalItems;          // Total number of items on the camera, including folders, images, audio, etc.
    SYSTEMTIME   Time;                 // Current time on the device
    LONG         Reserved[8];          // Reserved for future use
} MCAM_DEVICE_INFO, *PMCAM_DEVICE_INFO;

typedef struct _MCAM_ITEM_INFO {
    INT          iSize;                // Size of this structure
    BYTE        *pPrivateStorage;      // Pointer to an area where the microdriver can store it's own item information
    IWiaDrvItem *pDrvItem;             // Pointer to the driver item created from this item--should not be used by microdriver

    struct _MCAM_ITEM_INFO *pParent;   // Pointer to this item's parent, equal to NULL if this is a top level item
    struct _MCAM_ITEM_INFO *pNext;     // Next item in the list
    struct _MCAM_ITEM_INFO *pPrev;     // Previous item in the list

    PWSTR        pwszName;             // Name of the item without the extension
    SYSTEMTIME   Time;                 // Last modified time of the item
    INT          iType;                // Type of the item (e.g. folder, image, etc.)
    const GUID  *pguidFormat;          // Format of the item
    const GUID  *pguidThumbFormat;     // Format of the thumbnail for the item
    LONG         lWidth;               // Width of the image in pixels, zero for non-images
    LONG         lHeight;              // Height of the image in pixels, zero for non-images
    LONG         lDepth;               // Pixel depth in pixels (e.g. 8, 16, 24)
    LONG         lChannels;            // Number of color channels per pixel (e.g. 1, 3)
    LONG         lBitsPerChannel;      // Number of bits per color channel, normally 8
    LONG         lSize;                // Size of the image in bytes
    LONG         lSequenceNum;         // If image is part of a sequence, the sequence number
    LONG         lThumbWidth;          // Width of thumbnail (can be set to zero until thumbnail is read by app)
    LONG         lThumbHeight;         // Height of thumbnail (can be set to zero until thumbnail is read by app)
    BOOL         bHasAttachments;      // Indicates whether an image has attachments
    BOOL         bReadOnly;            // Indicates if item can or cannot be deleted by app
    BOOL         bCanSetReadOnly;      // Indicates if the app can change the read-only status on and off
    WCHAR        wszExt[MCAM_EXT_LEN]; // Filename extension
    LONG         Reserved[8];          // Reserved for future use    
} MCAM_ITEM_INFO, *PMCAM_ITEM_INFO;

typedef struct _MCAM_PROP_INFO {
    INT          iSize;                // Size of this structure

    struct _MCAM_PROP_INFO *pNext;

    WIA_PROPERTY_INFO *pWiaPropInfo;

    LONG         Reserved[8];
} MCAM_PROP_INFO, *PMCAM_PROP_INFO;

typedef struct _MCAM_EVENT_INFO {
    INT          iSize;                // Size of this structure

    struct _MCAM_EVENT_INFO *pNext;

    INT          iType;                // Event type

    MCAM_ITEM_INFO *pItemInfo;
    MCAM_PROP_INFO *pPropInfo;

    LONG         Reserved[8];
} MCAM_EVENT_INFO, *PMCAM_EVENT_INFO;

//
// Interface to micro camera driver
//
WIACAMMICRO_API WiaMCamInit(MCAM_DEVICE_INFO **ppDeviceInfo);
WIACAMMICRO_API WiaMCamUnInit(MCAM_DEVICE_INFO *pDeviceInfo);
WIACAMMICRO_API WiaMCamOpen(MCAM_DEVICE_INFO *pDeviceInfo, PWSTR pwszPortName);
WIACAMMICRO_API WiaMCamClose(MCAM_DEVICE_INFO *pDeviceInfo);
WIACAMMICRO_API WiaMCamGetDeviceInfo(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO **ppItemList);
WIACAMMICRO_API WiaMCamReadEvent(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_EVENT_INFO **ppEventList);
WIACAMMICRO_API WiaMCamStopEvents(MCAM_DEVICE_INFO *pDeviceInfo);
WIACAMMICRO_API WiaMCamGetItemInfo(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItemInfo);
WIACAMMICRO_API WiaMCamFreeItemInfo(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItemInfo);
WIACAMMICRO_API WiaMCamGetThumbnail(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItem, INT *pThumbSize, BYTE **ppThumb);
WIACAMMICRO_API WiaMCamFreeThumbnail(MCAM_DEVICE_INFO *pDeviceInfo, BYTE *pThumb);
WIACAMMICRO_API WiaMCamGetItemData(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItem, UINT uiState, BYTE *pBuf, DWORD dwLength);
WIACAMMICRO_API WiaMCamDeleteItem(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItem);
WIACAMMICRO_API WiaMCamSetItemProt(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO *pItem, BOOL bReadOnly);
WIACAMMICRO_API WiaMCamTakePicture(MCAM_DEVICE_INFO *pDeviceInfo, MCAM_ITEM_INFO **ppItemInfo);
WIACAMMICRO_API WiaMCamStatus(MCAM_DEVICE_INFO *pDeviceInfo);
WIACAMMICRO_API WiaMCamReset(MCAM_DEVICE_INFO *pDeviceInfo);

#include <poppack.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\inc\wiadevd.h ===
/****************************************************************************
*
*  (C) COPYRIGHT 1998-2000, MICROSOFT CORP.
*
*  FILE:        wiadevd.h
*
*  VERSION:     1.0
*
*  DATE:        7/5/1999
*
*  DESCRIPTION:
*    Device Dialog and UI extensibility declarations.
*
*****************************************************************************/

#ifndef _WIADEVD_H_INCLUDED
#define _WIADEVD_H_INCLUDED

#include "wia.h"

#if defined(__cplusplus)
extern "C" {
#endif

#include <pshpack8.h>

typedef struct tagDEVICEDIALOGDATA
{
    DWORD            cbSize;           // Size of the structure in bytes
    HWND             hwndParent;       // Parent window
    IWiaItem         *pIWiaItemRoot;   // Valid root item
    DWORD            dwFlags;          // Flags
    LONG             lIntent;          // Intent flags
    LONG             lItemCount;       // Number of items in ppWiaItems array.  Filled on return.
    IWiaItem         **ppWiaItems;     // Array of IWiaItem interface pointers.  Array must
                                       // be allocated using LocalAlloc, all interface pointers must be AddRef'ed
} DEVICEDIALOGDATA, *LPDEVICEDIALOGDATA, *PDEVICEDIALOGDATA;

HRESULT WINAPI DeviceDialog( PDEVICEDIALOGDATA pDeviceDialogData );

// IWiaUIExtension provides a means to replace a device's image acquisition dialog
// and to provide custom icons and logo bitmaps to appear on the standard dialog
#undef  INTERFACE
#define INTERFACE IWiaUIExtension
DECLARE_INTERFACE_(IWiaUIExtension, IUnknown)
{
    // *** IUnknown methods ***
    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID FAR* ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef) (THIS) PURE;
    STDMETHOD_(ULONG,Release) (THIS) PURE;

    // *** IWiaUIExtension methods ***
    STDMETHOD(DeviceDialog)( THIS_ PDEVICEDIALOGDATA pDeviceDialogData ) PURE;
    STDMETHOD(GetDeviceIcon)(THIS_ BSTR bstrDeviceId, HICON *phIcon, ULONG nSize ) PURE;
    STDMETHOD(GetDeviceBitmapLogo)(THIS_ BSTR bstrDeviceId, HBITMAP *phBitmap, ULONG nMaxWidth, ULONG nMaxHeight ) PURE;
};

// {da319113-50ee-4c80-b460-57d005d44a2c}
DEFINE_GUID(IID_IWiaUIExtension, 0xDA319113, 0x50EE, 0x4C80, 0xB4, 0x60, 0x57, 0xD0, 0x05, 0xD4, 0x4A, 0x2C);

typedef HRESULT (WINAPI *DeviceDialogFunction)(PDEVICEDIALOGDATA);

#define SHELLEX_WIAUIEXTENSION_NAME TEXT("WiaDialogExtensionHandlers")

// Define clipboard format names for retrieving data from an IDataObject
#define CFSTR_WIAITEMNAMES TEXT("WIAItemNames")
#define CFSTR_WIAITEMPTR   TEXT("WIAItemPointer")

#include <poppack.h>

#if defined(__cplusplus)
};
#endif

#endif // !_WIADEVD_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\inc\wiaintfc.h ===
/*++

Copyright (c) 1986-2002  Microsoft Corporation

Module Name:

    wiaintfc.h

Abstract:

    This module contains interface class GUID for WIA.

Revision History:


--*/


#ifndef _WIAINTFC_H_
#define _WIAINTFC_H_

//
// Set packing
//

#include <pshpack8.h>
#include <guiddef.h>

//
// GUID for Image class device interface.
//

DEFINE_GUID(GUID_DEVINTERFACE_IMAGE, 0x6bdd1fc6L, 0x810f, 0x11d0, 0xbe, 0xc7, 0x08, 0x00, 0x2b, 0xe2, 0x09, 0x2f);

#endif // _WIAINTFC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\inc\wiamdef.h ===
/******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1998-1999
*
*  TITLE:       wiamdef.h
*
*  VERSION:     2.0
*
*  DATE:        28 July, 1999
*
*  DESCRIPTION:
*   Header file used to define WIA constants and globals.
*
******************************************************************************/

#pragma once

//
//  The following array of PROPIDs identifies properties that are ALWAYS
//  present in a WIA_PROPERTY_CONTEXT.  Drivers can specify additional
//  properties when creating a property context with wiasCreatePropContext.
//

#ifdef STD_PROPS_IN_CONTEXT

#define NUM_STD_PROPS_IN_CONTEXT 13
PROPID  WIA_StdPropsInContext[NUM_STD_PROPS_IN_CONTEXT] = {
    WIA_IPA_DATATYPE,
    WIA_IPA_DEPTH,
    WIA_IPS_XRES,
    WIA_IPS_XPOS,
    WIA_IPS_XEXTENT,
    WIA_IPA_PIXELS_PER_LINE,
    WIA_IPS_YRES,
    WIA_IPS_YPOS,
    WIA_IPS_YEXTENT,
    WIA_IPA_NUMBER_OF_LINES,
    WIA_IPS_CUR_INTENT,
    WIA_IPA_TYMED,
    WIA_IPA_FORMAT,
    };
#endif

//**************************************************************************
//
//  WIA Service prototypes
//
//
// History:
//
//    4/27/1999 - Initial Version
//
//**************************************************************************

// Flag used by wiasGetImageInformation.

#define WIAS_INIT_CONTEXT 1

// Flag used by wiasDownSampleBuffer

#define WIAS_GET_DOWNSAMPLED_SIZE_ONLY 0x1

//
// IWiaMiniDrvService methods
//

#ifdef __cplusplus
extern "C" {
#endif

HRESULT _stdcall wiasCreateDrvItem(LONG, BSTR, BSTR, IWiaMiniDrv*, LONG, BYTE**, IWiaDrvItem**);
HRESULT _stdcall wiasGetImageInformation(BYTE*, LONG, PMINIDRV_TRANSFER_CONTEXT);
HRESULT _stdcall wiasWritePageBufToFile(PMINIDRV_TRANSFER_CONTEXT);
HRESULT _stdcall wiasWriteBufToFile(LONG, PMINIDRV_TRANSFER_CONTEXT);
HRESULT _stdcall wiasReadMultiple(BYTE*, ULONG, const PROPSPEC*, PROPVARIANT*, PROPVARIANT*);
HRESULT _stdcall wiasReadPropStr(BYTE*, PROPID, BSTR*, BSTR*, BOOL);
HRESULT _stdcall wiasReadPropLong(BYTE*, PROPID, LONG*, LONG*, BOOL);
HRESULT _stdcall wiasReadPropFloat(BYTE*, PROPID, FLOAT*, FLOAT*, BOOL);
HRESULT _stdcall wiasReadPropGuid(BYTE*, PROPID, GUID*, GUID*, BOOL);
HRESULT _stdcall wiasReadPropBin(BYTE*, PROPID, BYTE**, BYTE**, BOOL);
HRESULT _stdcall wiasWriteMultiple(BYTE*, ULONG, const PROPSPEC*, const PROPVARIANT*);
HRESULT _stdcall wiasWritePropStr(BYTE*, PROPID, BSTR);
HRESULT _stdcall wiasWritePropLong(BYTE*, PROPID, LONG);
HRESULT _stdcall wiasWritePropFloat(BYTE*, PROPID, FLOAT);
HRESULT _stdcall wiasWritePropGuid(BYTE*, PROPID, GUID);
HRESULT _stdcall wiasWritePropBin(BYTE*, PROPID, LONG, BYTE*);
HRESULT _stdcall wiasGetPropertyAttributes(BYTE*, LONG, PROPSPEC*, ULONG*,  PROPVARIANT*);
HRESULT _stdcall wiasSetPropertyAttributes(BYTE*, LONG, PROPSPEC*, ULONG*,  PROPVARIANT*);
HRESULT _stdcall wiasSetItemPropNames(BYTE*, LONG, PROPID*, LPOLESTR*);
HRESULT _stdcall wiasSetItemPropAttribs(BYTE*, LONG, PROPSPEC*, PWIA_PROPERTY_INFO);
HRESULT _stdcall wiasValidateItemProperties(BYTE*, ULONG, const PROPSPEC*);
HRESULT _stdcall wiasSendEndOfPage(BYTE*, LONG, PMINIDRV_TRANSFER_CONTEXT);
HRESULT _stdcall wiasGetItemType(BYTE*, LONG*);
HRESULT _stdcall wiasGetDrvItem(BYTE*, IWiaDrvItem**);
HRESULT _stdcall wiasGetRootItem(BYTE*, BYTE**);

HRESULT _stdcall wiasSetValidFlag(BYTE*,         PROPID, ULONG, ULONG);
HRESULT _stdcall wiasSetValidRangeLong(BYTE*,    PROPID, LONG,  LONG,   LONG,   LONG);
HRESULT _stdcall wiasSetValidRangeFloat(BYTE*,   PROPID, FLOAT, FLOAT,  FLOAT,  FLOAT);
HRESULT _stdcall wiasSetValidListLong(BYTE*,     PROPID, ULONG, LONG,  LONG*);
HRESULT _stdcall wiasSetValidListFloat(BYTE*,    PROPID, ULONG, FLOAT, FLOAT*);
HRESULT _stdcall wiasSetValidListGuid(BYTE*,    PROPID, ULONG, GUID, GUID*);
HRESULT _stdcall wiasSetValidListStr(BYTE*,      PROPID, ULONG, BSTR,  BSTR*);

HRESULT _stdcall wiasCreatePropContext(ULONG, PROPSPEC*, ULONG, PROPID*, WIA_PROPERTY_CONTEXT*);
HRESULT _stdcall wiasFreePropContext(WIA_PROPERTY_CONTEXT*);
HRESULT _stdcall wiasIsPropChanged(PROPID, WIA_PROPERTY_CONTEXT*, BOOL*);
HRESULT _stdcall wiasSetPropChanged(PROPID, WIA_PROPERTY_CONTEXT*, BOOL);
HRESULT _stdcall wiasGetChangedValueLong(BYTE*,  WIA_PROPERTY_CONTEXT*, BOOL, PROPID, WIAS_CHANGED_VALUE_INFO*);
HRESULT _stdcall wiasGetChangedValueFloat(BYTE*, WIA_PROPERTY_CONTEXT*, BOOL, PROPID, WIAS_CHANGED_VALUE_INFO*);
HRESULT _stdcall wiasGetChangedValueGuid(BYTE*, WIA_PROPERTY_CONTEXT*, BOOL, PROPID, WIAS_CHANGED_VALUE_INFO*);
HRESULT _stdcall wiasGetChangedValueStr(BYTE*,   WIA_PROPERTY_CONTEXT*, BOOL, PROPID, WIAS_CHANGED_VALUE_INFO*);

HRESULT _stdcall wiasGetContextFromName(BYTE*, LONG, BSTR, BYTE**);

HRESULT _stdcall wiasUpdateScanRect(BYTE*, WIA_PROPERTY_CONTEXT*, LONG, LONG);
HRESULT _stdcall wiasUpdateValidFormat(BYTE*, WIA_PROPERTY_CONTEXT*, IWiaMiniDrv*);

HRESULT _stdcall wiasGetChildrenContexts(BYTE*, ULONG*, BYTE***);

HRESULT _stdcall wiasQueueEvent(BSTR, const GUID*, BSTR);

VOID    __cdecl   wiasDebugTrace(HINSTANCE, LPCSTR, ...);
VOID    __cdecl   wiasDebugError(HINSTANCE, LPCSTR, ...);
VOID    __stdcall wiasPrintDebugHResult(HINSTANCE, HRESULT);

BSTR    __cdecl   wiasFormatArgs(LPCSTR lpszFormat, ...);

HRESULT _stdcall wiasCreateChildAppItem(BYTE*, LONG, BSTR, BSTR, BYTE**);

HRESULT _stdcall wiasCreateLogInstance(BYTE*, IWiaLogEx**);
HRESULT _stdcall wiasDownSampleBuffer(LONG, WIAS_DOWN_SAMPLE_INFO*);
HRESULT _stdcall wiasParseEndorserString(BYTE*, LONG, WIAS_ENDORSER_INFO*, BSTR*);

#ifndef WIA_MAP_OLD_DEBUG

#if defined(_DEBUG) || defined(DBG) || defined(WIA_DEBUG)

#define WIAS_TRACE(x) wiasDebugTrace x
#define WIAS_ERROR(x) wiasDebugError x
#define WIAS_HRESULT(x) wiasPrintDebugHResult x
#define WIAS_ASSERT(x, y) \
        if (!(y)) { \
            WIAS_ERROR((x, (char*) TEXT("ASSERTION FAILED: %hs(%d): %hs"), __FILE__,__LINE__,#x)); \
            DebugBreak(); \
        }

#else

#define WIAS_TRACE(x)
#define WIAS_ERROR(x)
#define WIAS_HRESULT(x)
#define WIAS_ASSERT(x, y)

#endif

#define WIAS_LTRACE(pILog,ResID,Detail,Args) \
         { if ( pILog ) \
            pILog->Log(WIALOG_TRACE, ResID, Detail, wiasFormatArgs Args);\
         };
#define WIAS_LERROR(pILog,ResID,Args) \
         {if ( pILog )\
            pILog->Log(WIALOG_ERROR, ResID, WIALOG_NO_LEVEL, wiasFormatArgs Args);\
         };
#define WIAS_LWARNING(pILog,ResID,Args) \
         {if ( pILog )\
            pILog->Log(WIALOG_WARNING, ResID, WIALOG_NO_LEVEL, wiasFormatArgs Args);\
         };
#define WIAS_LHRESULT(pILog,hr) \
         {if ( pILog )\
            pILog->hResult(hr);\
         };

//
// IWiaLog Defines
//

// Type of logging
#define WIALOG_TRACE   0x00000001
#define WIALOG_WARNING 0x00000002
#define WIALOG_ERROR   0x00000004

// level of detail for TRACE logging
#define WIALOG_LEVEL1  1 // Entry and Exit point of each function/method
#define WIALOG_LEVEL2  2 // LEVEL 1, + traces within the function/method
#define WIALOG_LEVEL3  3 // LEVEL 1, LEVEL 2, and any extra debugging information
#define WIALOG_LEVEL4  4 // USER DEFINED data + all LEVELS of tracing

#define WIALOG_NO_RESOURCE_ID   0
#define WIALOG_NO_LEVEL         0

//
// Entering / Leaving class
//

class CWiaLogProc {
private:
    CHAR   m_szMessage[MAX_PATH];
    IWiaLog *m_pIWiaLog;
    INT     m_DetailLevel;
    INT     m_ResourceID;

public:
    inline CWiaLogProc(IWiaLog *pIWiaLog, INT ResourceID, INT DetailLevel, CHAR *pszMsg) {
        lstrcpyA(m_szMessage,pszMsg);
        m_pIWiaLog = pIWiaLog;
        m_DetailLevel = DetailLevel;
        m_ResourceID = ResourceID;
        WIAS_LTRACE(pIWiaLog,
                    ResourceID,
                    DetailLevel,
                    ("%s, entering",m_szMessage));
    }

    inline ~CWiaLogProc() {
        WIAS_LTRACE(m_pIWiaLog,
                    m_ResourceID,
                    m_DetailLevel,
                    ("%s, leaving",m_szMessage));
    }
};

class CWiaLogProcEx {
private:
    CHAR        m_szMessage[MAX_PATH];
    IWiaLogEx   *m_pIWiaLog;
    INT         m_DetailLevel;
    INT         m_ResourceID;

public:
    inline CWiaLogProcEx(IWiaLogEx *pIWiaLog, INT ResourceID, INT DetailLevel, CHAR *pszMsg, LONG lMethodId = 0) {
        lstrcpyA(m_szMessage,pszMsg);
        m_pIWiaLog = pIWiaLog;
        m_DetailLevel = DetailLevel;
        m_ResourceID = ResourceID;
        WIAS_LTRACE(pIWiaLog,
                    ResourceID,
                    DetailLevel,
                    ("%s, entering",m_szMessage));
    }

    inline ~CWiaLogProcEx() {
        WIAS_LTRACE(m_pIWiaLog,
                    m_ResourceID,
                    m_DetailLevel,
                    ("%s, leaving",m_szMessage));
    }
};

#endif // WIA_MAP_OLD_DEBUG


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\inc\wialog.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1997
*
*  TITLE:       WiaLog.h
*
*  VERSION:     1.0
*
*  AUTHOR:      CoopP
*
*  DATE:        20 Aug, 1999
*
*  DESCRIPTION:
*   Declarations and definitions for the WIA logging object.
*
*******************************************************************************/
#ifndef WIALOG_H
#define WIALOG_H

#include <wia.h>

// Flush state
#ifdef WINNT
    #define FLUSH_STATE FALSE
#else
//  Must be TRUE for Win9x
    #define FLUSH_STATE TRUE
#endif    

#define MAX_TEXT_BUFFER                1024
#define MAX_NAME_BUFFER                  64
#define NUM_BYTES_TO_LOCK_LOW          4096
#define NUM_BYTES_TO_LOCK_HIGH            0
#define WIA_MAX_LOG_SIZE            1000000
#define MAX_SIG_LEN                      64

// Type of logging
#define WIALOG_TRACE   0x00000001
#define WIALOG_WARNING 0x00000002
#define WIALOG_ERROR   0x00000004

// level of detail for TRACE logging
#define WIALOG_LEVEL1  1 // Entry and Exit point of each function/method
#define WIALOG_LEVEL2  2 // LEVEL 1, + traces within the function/method
#define WIALOG_LEVEL3  3 // LEVEL 1, LEVEL 2, and any extra debugging information
#define WIALOG_LEVEL4  4 // USER DEFINED data + all LEVELS of tracing

#define WIALOG_NO_RESOURCE_ID   0
#define WIALOG_NO_LEVEL         0


// format details for logging
#define WIALOG_ADD_TIME           0x00010000
#define WIALOG_ADD_MODULE         0x00020000
#define WIALOG_ADD_THREAD         0x00040000
#define WIALOG_ADD_THREADTIME     0x00080000
#define WIALOG_LOG_TOUI           0x00100000

#define WIALOG_MESSAGE_TYPE_MASK  0x0000ffff
#define WIALOG_MESSAGE_FLAGS_MASK 0xffff0000
#define WIALOG_CHECK_TRUNCATE_ON_BOOT   0x00000001

#define WIALOG_DEBUGGER           0x00000008
#define WIALOG_UI                 0x00000016

#define MAX_TRUNCATE_SIZE 350000

//
// NB!!! Move this to the IDL as soon as IWiaLogEx is in
//
// This struct is used to match a MethodId / MethodName pair
//

typedef struct _MapTableEntry {
    LONG    lSize;
    LONG    lMethodId;
    BSTR    bstrMethodName;
} MapTableEntry;

typedef struct _MappingTable {
    LONG            lSize;
    LONG            lNumEntries;
    MapTableEntry   *pEntries;
} MappingTable;

class CFactory;

class CWiaLog : public IWiaLog,
                public IWiaLogEx
{
public:

    //
    // IWiaLog public methods
    //

    static HRESULT CreateInstance(const IID& iid, void** ppv);

private:

    //
    // IUnknown methods
    //

    HRESULT _stdcall QueryInterface(const IID& iid, void** ppv);
    ULONG   _stdcall AddRef();
    ULONG   _stdcall Release();

    friend CFactory;

    //
    // Construction / Destruction
    //

    CWiaLog();
    ~CWiaLog();

    //
    // IWiaLog private methods (exposed to the client)
    //

    HRESULT _stdcall InitializeLog (LONG hInstance);
    HRESULT _stdcall Log    (LONG lFlags, LONG lResID, LONG lDetail, BSTR bstrText);
    HRESULT _stdcall hResult(HRESULT hr);

    //
    // IWiaLogEx private methods (exposed to the client)
    //

    HRESULT _stdcall InitializeLogEx     (BYTE* hInstance);
    HRESULT _stdcall LogEx               (LONG lMethodId, LONG lFlags, LONG lResID, LONG lDetail, BSTR bstrText);
    HRESULT _stdcall hResultEx           (LONG lMethodId, HRESULT hr);
    HRESULT _stdcall UpdateSettingsEx    (LONG lCount, LONG *plMethodIds);
    HRESULT _stdcall ExportMappingTableEx(MappingTable **ppTable);

    //
    // IWiaLog private methods (not exposed to the client)
    //

    HRESULT Initialize();
    HRESULT Trace  (BSTR bstrText, LONG lDetail = 0, LONG lMethodId = 0);
    HRESULT Warning(BSTR bstrText, LONG lMethodId = 0);
    HRESULT Error  (BSTR bstrText, LONG lMethodId = 0);

    //
    // IWiaLog private helpers (not exposed to the client)
    //

    BOOL OpenLogFile();
    VOID WriteStringToLog(LPTSTR pszTextBuffer,BOOL fFlush = FALSE);
    VOID WriteLogSessionHeader();

    BOOL QueryLoggingSettings();

    VOID ConstructText();
    BOOL FormatDLLName(HINSTANCE hInstance,TCHAR *pchBuffer,INT cbBuffer);
    BOOL FormatStdTime(const SYSTEMTIME *pstNow,TCHAR *pchBuffer);
    BOOL NeedsToBeFreed(BSTR* pBSTR);
    VOID ProcessTruncation();

    //
    // member variables
    //

    ULONG      m_cRef;                          // Reference count for this object.
    ITypeInfo* m_pITypeInfo;                    // Pointer to type information.

    DWORD      m_dwReportMode;                  // bit mask, describing which messages types get reported
    DWORD      m_dwMaxSize;                     // maximum size ( in bytes ) of LOG file
    HANDLE     m_hLogFile;                      // handle to active log file
    HINSTANCE  m_hInstance;                     // handle to caller's instance
    TCHAR      m_szFmtDLLName[MAX_NAME_BUFFER]; // calling DLL's name
    LONG       m_lDetail;                       // level of detailing for TRACE
    TCHAR      m_szLogFilePath[MAX_PATH];       // log file path
    BOOL       m_bLogToDebugger;                // log to the debugger
    BOOL       m_bLogToUI;                      // log to a UI, (window?)
    TCHAR      m_szKeyName[MAX_NAME_BUFFER];    // KEY name (registry)
    BOOL       m_bLoggerInitialized;            // Logger has valid data to function correctly
    TCHAR      m_szModeText[MAX_PATH * 2];     // Formatted logging text
    TCHAR      m_szTextBuffer[MAX_PATH];        // shared temporary text buffer
    TCHAR      m_szColumnHeader[MAX_PATH];      // column header information
    BOOL       m_bTruncate;                     // Truncate file on BOOT
    BOOL       m_bClear;                        // Clear Log file on BOOT
};

//
//  TEMPROARY ONLY!!!!
//  Define CWiaLogProc to be CWiaLogProcEx.  This is only until drivers are moved over to the new system!
//

#define CWiaLogProc CWiaLogProcEx

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\inc\wiacfact.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1997
*
*  TITLE:       WiaCFact.h
*
*  VERSION:     2.0
*
*  AUTHOR:      ReedB
*
*  DATE:        26 Dec, 1997
*
*  DESCRIPTION:
*   Declarations and definitions for Class factory.
*
*******************************************************************************/

typedef HRESULT (*FPCREATEINSTANCE)(const IID& iid, void** ppv);

// FACTORY_DATA - Information CFactory needs to create a component

typedef struct _FACTORY_DATA
{
    FPCREATEINSTANCE    CreateInstance; // Pointer to creating function.
    IClassFactory*      pIClassFactory; // Pointer to running class factory.
    DWORD               dwRegister;     // ID for running object.

    const CLSID* pclsid;                // The class ID for the component.
    const GUID*  plibid;                // Type library ID.

    // Registry strings:

    LPCTSTR szRegName;                   // Name of the component.
    LPCTSTR szProgID;                    // Program ID.
    LPCTSTR szVerIndProgID;              // Version-independent program ID.
    LPCTSTR szService;                   // Name of service.
    LPCTSTR szModuleFileName;            // Filename of module.

} FACTORY_DATA, *PFACTORY_DATA;

// Class Factory

class CFactory : public IClassFactory
{
public:
	// IUnknown
	virtual HRESULT __stdcall QueryInterface(const IID& iid, void** ppv) ;
	virtual ULONG   __stdcall AddRef() ;
	virtual ULONG   __stdcall Release() ;
	
	// IClassFactory
	virtual HRESULT __stdcall CreateInstance(IUnknown* pUnknownOuter,
	                                         const IID& iid,
                                             void** ppv) ;

    virtual HRESULT __stdcall LockServer(BOOL bLock) ; 

	// Constructor - Pass pointer to data of component to create.
    CFactory(const PFACTORY_DATA pFactoryData);

	// Destructor
	~CFactory() { }

	// Static FactoryData support functions

    // Helper function for CanUnloadNow
 	static BOOL IsLocked()
		{ return (s_cServerLocks > 0) ;}

	// Functions to [un]register all components
    static HRESULT RegisterUnregisterAll(
        PFACTORY_DATA   pFactoryData,
        UINT            uiFactoryDataCount,
        BOOLEAN         bRegister,
        BOOLEAN         bOutProc);

	// Function to determine if component can be unloaded
	static HRESULT CanUnloadNow() ;

	// Out-of-process server support

    static BOOL StartFactories(
        PFACTORY_DATA   pFactoryData,
        UINT            uiFactoryDataCount);

    static void StopFactories(
        PFACTORY_DATA   pFactoryData,
        UINT            uiFactoryDataCount);

	static DWORD s_dwThreadID ;

	// Shut down the application.
	static void CloseExe()
	{
		if (CanUnloadNow() == S_OK)
		{
			::PostThreadMessage(s_dwThreadID, WM_QUIT, 0, 0) ;
		}
	}

public:
	// Reference Count
	LONG m_cRef ;

	// Pointer to information about class this factory creates
    PFACTORY_DATA m_pFactoryData;

	// Count of locks
    static LONG s_cServerLocks;

	// Module handle
    static HMODULE s_hModule;
} ;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\inc\wiapropui.h ===
#ifndef __WIAPROPUI_H_INCLUDED
#define __WIAPROPUI_H_INCLUDED

/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1999
*
*  TITLE:       WiaPropUI.H
*
*
*
*  DESCRIPTION:
*   Definitions and declarations for querying, displaying, and setting
*   WIA device and item properties
*
*******************************************************************************/


#include <objbase.h>

#ifdef __cplusplus
extern "C" {
#endif

 /* 83bbcbf3-b28a-4919-a5aa-73027445d672 */
// helper object for other WIA UI components
DEFINE_GUID (CLSID_WiaPropHelp, 0x83bbcbf3,0xb28a,0x4919,0xa5, 0xaa, 0x73, 0x02, 0x74, 0x45, 0xd6, 0x72);

DEFINE_GUID (IID_IWiaPropUI,  /* 7eed2e9b-acda-11d2-8080-00805f6596d2 */
    0x7eed2e9b,
    0xacda,
    0x11d2,
    0x80, 0x80, 0x00, 0x80, 0x5f, 0x65, 0x96, 0xd2
  );

// property sheet handler
DEFINE_GUID (CLSID_WiaPropUI,0x905667aa,0xacd6,0x11d2,0x80, 0x80,0x00,0x80,0x5f,0x65,0x96,0xd2);


#ifdef __cplusplus
}
#endif

// Define a structure for storing camera download options
typedef struct tagCamOptions
{
    BOOL bAutoCopy;        // TRUE if download should happen when camera is plugged in
    BOOL bShowUI;          // TRUE if the download should be interactive
    BOOL bDeleteFromDevice;// TRUE if images are removed from device after copy
    BOOL bCopyAsGroup;
    BSTR bstrDestination;  // path to default download site
    BSTR bstrAuthor;       // default image author
} CAMOPTIONS, *PCAMOPTIONS;

//
// Flags
//
#define PROPUI_DEFAULT            0
#define PROPUI_MODELESS           0
#define PROPUI_MODAL              1
#define PROPUI_READONLY           2




interface IWiaItem;
interface IWiaItem;

#undef INTERFACE
#define INTERFACE IWiaPropUI
//
// IWiaPropUI is meant to encapsulate the display and management of
// property sheets for camera and scanner devices, and for items saved
// in camera memory. Once a caller has a pointer to this interface, he can
// use it to open property sheets for multiple items; the implementation
// of the interface must support multiple active sheets and should also
// prevent duplicate sheets being displayed.
// Once the interface's ref count reaches zero, any open property sheets
// will be closed.
//
DECLARE_INTERFACE_(IWiaPropUI, IUnknown)
{
    // IUnknown methods

    STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) PURE;
    STDMETHOD_(ULONG, AddRef) (THIS) PURE;
    STDMETHOD_(ULONG, Release) (THIS) PURE;

    // IWiaPropUI methods

    STDMETHOD(ShowItemProperties)(THIS_ HWND hParent, IN LPCWSTR szDeviceId, IN LPCWSTR szItem, DWORD dwFlags) PURE;
    STDMETHOD(GetItemPropertyPages) (THIS_ IWiaItem *pItem, IN OUT LPPROPSHEETHEADER ppsh);


};

#endif //__WIAPROPUI_H_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\inc\wiamonk.h ===
/******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1999
*
*  TITLE:       wiamonk.h
*
*  VERSION:     1.0
*
*  DATE:        10 Nov, 1999
*
*  DESCRIPTION:
*   This file describes the class used by WIA to imlement an instance moniker.
*
******************************************************************************/

class CWiaInstMonk : public IMoniker,
                     public IROTData
{
public:

    //
    //  Constructor, Destructor, Initialize
    //

    CWiaInstMonk();
    ~CWiaInstMonk();
    HRESULT _stdcall Initialize(LPOLESTR strName);

    //
	// IUnknown
    //

	HRESULT _stdcall QueryInterface(const IID& iid, void** ppv);
	ULONG   _stdcall AddRef();
	ULONG   _stdcall Release();

    //
    //  IROTData
    //

    HRESULT _stdcall GetComparisonData(
        BYTE *pbData,
        ULONG cbMax,   
        ULONG *pcbData);

    //
    // IMoniker
    //

    HRESULT _stdcall BindToObject(
        IBindCtx *pbc,
        IMoniker *pmkToLeft,
        REFIID riidResult,
        void **ppvResult);

    HRESULT _stdcall BindToStorage(
        IBindCtx *pbc,
        IMoniker *pmkToLeft,
        REFIID riid,
        void **ppvObj);

    HRESULT _stdcall Reduce(
        IBindCtx *pbc,
        DWORD dwReduceHowFar,
        IMoniker **ppmkToLeft,
        IMoniker **ppmkReduced);

    HRESULT _stdcall ComposeWith(
        IMoniker *pmkRight,
        BOOL fOnlyIfNotGeneric,
        IMoniker **ppmkComposite);

    HRESULT _stdcall Enum(
        BOOL fForward,
        IEnumMoniker **ppenumMoniker);

    HRESULT _stdcall IsEqual(
        IMoniker *pmkOtherMoniker);

    HRESULT _stdcall Hash(
        DWORD *pdwHash);

    HRESULT _stdcall IsRunning(
        IBindCtx *pbc,
        IMoniker *pmkToLeft,
        IMoniker *pmkNewlyRunning);

    HRESULT _stdcall GetTimeOfLastChange(
        IBindCtx *pbc,
        IMoniker *pmkToLeft,
        FILETIME *pFileTime);

    HRESULT _stdcall Inverse(
        IMoniker **ppmk);

    HRESULT _stdcall CommonPrefixWith(
        IMoniker *pmkOther,
        IMoniker **ppmkPrefix);

    HRESULT _stdcall RelativePathTo(
        IMoniker *pmkOther,
        IMoniker **ppmkRelPath);

    HRESULT _stdcall GetDisplayName(
        IBindCtx *pbc,
        IMoniker *pmkToLeft,
        LPOLESTR *ppszDisplayName);

    HRESULT _stdcall ParseDisplayName(
        IBindCtx *pbc,
        IMoniker *pmkToLeft,
        LPOLESTR pszDisplayName,
        ULONG    *pchEaten,
        IMoniker **ppmkOut);

    HRESULT _stdcall IsSystemMoniker(
        DWORD *pdwMksys);

    //
    //  IPersistStream
    //

    HRESULT _stdcall IsDirty();
    HRESULT _stdcall Load(IStream *pStm);
    HRESULT _stdcall Save(IStream *pStm, BOOL fClearDirty);
    HRESULT _stdcall GetSizeMax(ULARGE_INTEGER *pcbSize);

    //
    //  IPersist
    //

    HRESULT _stdcall GetClassID(LPCLSID pClassID);

private:
    LONG        m_cRef;
    BSTR        m_bstrName;
    IUnknown    *m_pIUnknownInner;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\inc\wiamicro.h ===
/****************************************************************************
*
*  (C) COPYRIGHT 1999-2000, MICROSOFT CORP.
*
*  FILE:        wiamicro.h
*
*  VERSION:     3.0
*
*  DESCRIPTION:
*    Definitions to support WIA scanner and camera microdrivers.
*
*****************************************************************************/

#pragma once

#include <SCSISCAN.H>

#define WIAMICRO_API __declspec(dllexport)

#include <pshpack8.h>

/****************************************************************************\
* Scanner microdriver definitions
\****************************************************************************/

//
// Private #defines
//

#define MAX_IO_HANDLES 16
#define MAX_RESERVED    4
#define MAX_ANSI_CHAR 255

//
// Common BUS types
//

#define BUS_TYPE_SCSI         200
#define BUS_TYPE_USB          201
#define BUS_TYPE_PARALLEL     202
#define BUS_TYPE_FIREWIRE     203

//
// command list
//

#define SCAN_FIRST             10
#define SCAN_NEXT              20
#define SCAN_FINISHED          30

#define SCANMODE_FINALSCAN     0
#define SCANMODE_PREVIEWSCAN   1

#define CMD_INITIALIZE        100
#define CMD_UNINITIALIZE      101
#define CMD_SETXRESOLUTION    102
#define CMD_SETYRESOLUTION    103
#define CMD_SETCONTRAST       104
#define CMD_SETINTENSITY      105
#define CMD_SETDATATYPE       106
#define CMD_SETDITHER         107
#define CMD_SETMIRROR         108
#define CMD_SETNEGATIVE       109
#define CMD_SETTONEMAP        110
#define CMD_SETCOLORDITHER    111
#define CMD_SETMATRIX         112
#define CMD_SETSPEED          113
#define CMD_SETFILTER         114
#define CMD_LOAD_ADF          115
#define CMD_UNLOAD_ADF        116
#define CMD_GETADFAVAILABLE   117
#define CMD_GETADFOPEN        118
#define CMD_GETADFREADY       119
#define CMD_GETADFHASPAPER    120
#define CMD_GETADFSTATUS      121
#define CMD_GETADFUNLOADREADY 122
#define CMD_GETTPAAVAILABLE   123
#define CMD_GETTPAOPENED      124
#define CMD_TPAREADY          125
#define CMD_SETLAMP           126
#define CMD_SENDSCSICOMMAND   127
#define CMD_STI_DEVICERESET   128
#define CMD_STI_GETSTATUS     129
#define CMD_STI_DIAGNOSTIC    130
#define CMD_RESETSCANNER      131
#define CMD_GETCAPABILITIES   132
#define CMD_GET_INTERRUPT_EVENT 133
#define CMD_SETGSDNAME        134
#define CMD_SETSCANMODE       135
#define CMD_SETSTIDEVICEHKEY  136
#define CMD_GETSUPPORTEDFILEFORMATS 138
#define CMD_GETSUPPORTEDMEMORYFORMATS 139
#define CMD_SETFORMAT   140

#define SUPPORT_COLOR      0x00000001
#define SUPPORT_BW         0x00000002
#define SUPPORT_GRAYSCALE  0x00000004

//
// Error Codes
//

#define MCRO_ERROR_GENERAL_ERROR     0 // All lVal values are initialized to '0'
#define MCRO_STATUS_OK               1 // General success status return
#define MCRO_ERROR_PAPER_JAM         2 // ADF has a paper Jam
#define MCRO_ERROR_PAPER_PROBLEM     3 // ADF has a paper problem
#define MCRO_ERROR_PAPER_EMPTY       4 // ADF has no paper
#define MCRO_ERROR_OFFLINE           5 // ADF or Device is offline
#define MCRO_ERROR_USER_INTERVENTION 6 // User needs to interact with the physical device

//
// WIA compatible #defines
//

#define WIA_PACKED_PIXEL         0
#define WIA_PLANAR               1

#define WIA_ORDER_RGB            0
#define WIA_ORDER_BGR            1

#define WIA_DATA_THRESHOLD       0
#define WIA_DATA_DITHER          1
#define WIA_DATA_GRAYSCALE       2
#define WIA_DATA_COLOR           3
#define WIA_DATA_COLOR_THRESHOLD 4
#define WIA_DATA_COLOR_DITHER    5

//
// structure definitions
//

typedef struct _RANGEVALUE {
    LONG lMin;                  // minimum value
    LONG lMax;                  // maximum value
    LONG lStep;                 // increment/step value
} RANGEVALUE, *PRANGEVALUE;

typedef struct _SCANWINDOW {
    LONG xPos;                  // X position (left)
    LONG yPos;                  // Y position (top)
    LONG xExtent;               // X extent   (right)
    LONG yExtent;               // Y extent   (bottom)
} SCANWINDOW, *PSCANWINDOW;

typedef struct _SCANINFO {
    // Common Scanner specs
    LONG ADF;                   // (0 - no support,  1 - supported, 2 - supported and It can duplex)
    LONG TPA;                   // (0 - no support,  1 - supported)
    LONG Endorser;              // (0 - no endorser, 1 - supported)
    LONG OpticalXResolution;    // (dpi setting of optics)
    LONG OpticalYResolution;    // (dpi setting of optics)
    LONG BedWidth;              // (bed width in 1000's of an inch)
    LONG BedHeight;             // (bed height in 1000's of an inch)
    RANGEVALUE IntensityRange;  // (Intensity/Brightness ranges)
    RANGEVALUE ContrastRange;   // (Contrast ranges)
    LONG SupportedCompressionType; // (mask of supported compression types, 0 - None)
    LONG SupportedDataTypes;    // (mask of supported types, (ie. SUPPORT_COLOR|SUPPORT_BW...))
    // Current Image Info
    LONG WidthPixels;           // (width of image, using current scanner settings in pixels)
    LONG WidthBytes;            // (width of image, using current scanner settings in bytes)
    LONG Lines;                 // (height of image, using current scanner settings in pixles)
    LONG DataType;              // (current data type set)
    LONG PixelBits;             // (current bit depth setting)
    // Current Scanner settings
    LONG Intensity;             // (current Intensity/Brightness setting)
    LONG Contrast;              // (current contrast setting)
    LONG Xresolution;           // (current X Resolution)
    LONG Yresolution;           // (current Y Resolution
    SCANWINDOW Window;          // (current scanner window settings)
    // Scanner options
    LONG DitherPattern;
    LONG Negative;              // (0 - off,        1 - Negative is on)
    LONG Mirror;                // (0 - off,        1 - Mirror is on)
    LONG AutoBack;              // (0 - off,        1 - AutoBack is on)
    LONG ColorDitherPattern;    // (dither pattern??)
    LONG ToneMap;               // (tone map ??)
    LONG Compression;           // (0 - off,        1 - Compression is on)
    LONG RawDataFormat;         // (0 - Packed data 1 - Planar data)
    LONG RawPixelOrder;         // (0 - RGB,        1 - BGR)
    LONG bNeedDataAlignment;    // (0 - FALSE,      1 - TRUE)
    LONG DelayBetweenRead;      // delay between WIA Scan() calls requesting data (milliseconds)
    LONG MaxBufferSize;         // maximum buffer size in scanner
    HANDLE DeviceIOHandles[MAX_IO_HANDLES]; // Device IO handles needed for device communication
    LONG lReserved[MAX_RESERVED]; // (silly reserved bits)
    VOID *pMicroDriverContext;  // private data for Micro driver's only.
                                // The Micro Driver is responsible for allocating and freeing.
                                // CMD_INITIALIZE - allocate, CMD_UNINITIALIZE - free
}SCANINFO, *PSCANINFO;

typedef struct VAL {
        LONG      lVal;             // long value
        double    dblVal;           // float/double value
        GUID     *pGuid;            // GUID pointer
        PSCANINFO pScanInfo;        // pointer to the shared ScanInfo struct
        HGLOBAL   handle;           // handle value
        WCHAR   **ppButtonNames;    // pointer to button names array
        HANDLE   *pHandle;          // pointer to a Handle value
        LONG      lReserved;        // lone value
        CHAR   szVal[MAX_ANSI_CHAR];// ANSI string
}VAL, *PVAL;

//
// Micro driver entry points
//

WIAMICRO_API HRESULT MicroEntry(LONG lCommand, PVAL pValue);
WIAMICRO_API HRESULT Scan(PSCANINFO pScanInfo, LONG lPhase, PBYTE pBuffer, LONG lLength, LONG *plReceived);
WIAMICRO_API HRESULT SetPixelWindow(PSCANINFO pScanInfo, LONG x, LONG y, LONG xExtent, LONG yExtent);

//
// optional debug trace
//

VOID Trace(LPCTSTR Format, ...);

#include <poppack.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\inc\wiaregst.h ===
/*******************************************************************************
*
*  (C) COPYRIGHT MICROSOFT CORP., 1999
*
*  TITLE:       wiaregst.h
*
*
*  DESCRIPTION:
*   Definition of registry paths for WIA and STI components.
*
*******************************************************************************/
#ifndef _WIAREGST_H_
#define _WIAREGST_H_


// These paths may be accessed by multiple components. Do not put paths to keys that only one
// component needs.


#define REGSTR_PATH_NAMESPACE_CLSID TEXT("CLSID\\{E211B736-43FD-11D1-9EFB-0000F8757FCD}")
#define REGSTR_PATH_USER_SETTINGS   TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\WIA")
#define REGSTR_PATH_SHELL_USER_SETTINGS TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\WIA\\Shell")

// These values control what happens when a camera connects to the PC
#define REGSTR_VALUE_CONNECTACT  TEXT("Action")
#define REGSTR_VALUE_AUTODELETE  TEXT("DeleteOnSave")
#define REGSTR_VALUE_SAVEFOLDER  TEXT("DestinationFolder")
#define REGSTR_VALUE_USEDATE     TEXT("UseDate")
#ifndef NO_STI_REGSTR
#include "stiregi.h"
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\inc\wiautil.h ===
/****************************************************************************
*
*  (C) COPYRIGHT 2000, MICROSOFT CORP.
*
*  FILE:        wiautil.h
*
*  VERSION:     1.0
*
*  DATE:        11/17/2000
*
*  DESCRIPTION:
*    Definitions for WIA driver helper classes and functions.
*    NOTE: This header requires wiamindr.h to be included.
*
*****************************************************************************/

#pragma once

/**************************************************************************\
* CWiauFormatConverter
*
*   Helper class for converting images to BMP format.
*
\**************************************************************************/

typedef struct _BMP_IMAGE_INFO
{
    INT     Width;      // Width of the image in pixels
    INT     Height;     // Height of the image in lines
    INT     ByteWidth;  // Width of the image in bytes
    INT     Size;       // Total size of the image, including headers
} BMP_IMAGE_INFO, *PBMP_IMAGE_INFO;

typedef enum
{
    SKIP_OFF,
    SKIP_FILEHDR,
    SKIP_BOTHHDR

} SKIP_AMOUNT;

class CWiauFormatConverter
{
public:
    CWiauFormatConverter();
    ~CWiauFormatConverter();

    /**************************************************************************\
    * Init
    *
    *   Intializes this class and GDI+ for converting images. This method
    *   should be called just once.
    *
    \**************************************************************************/

    HRESULT Init();


    /**************************************************************************\
    * IsFormatSupported
    *
    *   This method will verify that GDI+ supports the image format
    *   that is to be converted.
    *
    * Arguments:
    *
    *   pguidFormat - pointer to GUID format from gdiplusimaging.h
    *
    \**************************************************************************/

    BOOL IsFormatSupported(const GUID *pguidFormat);


    /**************************************************************************\
    * ConvertToBmp
    *
    *   This method will convert an image to BMP format. The caller can pass
    *   a result buffer in ppDest and the size in piDestSize. Alternatively
    *   the caller can set *ppDest to NULL and *piDestSize to zero to
    *   indicate that this method should allocate the memory. The caller is
    *   responsible for freeing the memory with "delete []".
    *
    * Arguments:
    *
    *    pSource         - pointer to memory location of source image
    *    iSourceSize     - size of source image
    *    ppDest          - location to receive memory location of result image
    *    piDestSize      - location to receive size of result image
    *    pBmpImageInfo   - location to receive stats about the BMP
    *    iSkipAmt        - Indicates how much of the BMP header to skip:
    *                       SKIP_OFF     = skip neither header
    *                       SKIP_FILEHDR = skip the file header
    *                       SKIP_BOTHHDR = skip the file and info headers
    *
    \**************************************************************************/

    HRESULT ConvertToBmp(BYTE *pSource, INT iSourceSize, BYTE **ppDest, INT *piDestSize,
                         BMP_IMAGE_INFO *pBmpImageInfo, SKIP_AMOUNT iSkipAmt = SKIP_OFF);


private:
    ULONG_PTR   m_Token;
    UINT        m_EncoderCount;
    BYTE       *m_pEncoderInfo;
    GUID        m_guidCodecBmp;
};


/**************************************************************************\
* CWiauPropertyList
*
*   Helper class for definining and initializing WIA properties
*
\**************************************************************************/

class CWiauPropertyList
{
private:

    int                  m_NumAlloc;    // number of slots allocated
    int                  m_NumProps;    // number of properties defined
    PROPID              *m_pId;         // property ids
    LPOLESTR            *m_pNames;      // property names
    PROPVARIANT         *m_pCurrent;    // current value
    PROPSPEC            *m_pPropSpec;   // property spec (used for WriteMultiple)
    WIA_PROPERTY_INFO   *m_pAttrib;     // property attributes

public:

    CWiauPropertyList();
    ~CWiauPropertyList();
    
    /**************************************************************************\
    * Init
    *
    *   Initializes the property info object.
    *
    * Arguments:
    *   NumProps - number of properties to reserve space for. This number can
    *              be larger than the actual number used, but cannot be smaller.
    *
    \**************************************************************************/
    
    HRESULT Init(INT NumProps);
    
    
    /**************************************************************************\
    * DefineProperty
    *
    *   Adds a property definition to the object.
    *
    * Arguments:
    *   index    - pointer to an int that will be set to the property index
    *              within the object, useful for passing to other property
    *              info methods
    *   PropId   - property ID constant
    *   PropName - property name string
    *   Access   - determines access to the property, usually either
    *              WIA_PROP_READ or WIA_PROP_RW
    *   SubType  - indicates subtype of the property, usually either
    *              WIA_PROP_NONE, WIA_PROP_FLAG, WIA_PROP_RANGE, or WIA_PROP_LIST
    *
    \**************************************************************************/

    HRESULT DefineProperty(int *pIdx, PROPID PropId, LPOLESTR PropName,
                           ULONG Access, ULONG SubType);
    
    
    /**************************************************************************\
    * SendToWia
    *
    *   Calls the WIA service to define all of the properties currently
    *   contained in the object. Should be called once after all properties
    *   are defined and set.
    *
    * Arguments:
    *   pWiasContext - pointer to the context passed into drvInitItemProperties
    *
    \**************************************************************************/
    
    HRESULT SendToWia(BYTE *pWiasContext);
    
    
    /**************************************************************************\
    * SetAccessSubType
    *
    *   Used to reset the access and subtype of a property.
    *
    * Arguments:
    *   index   - the property index, from DefineProperty
    *   Access  - determines access to the property, usually either
    *             WIA_PROP_READ or WIA_PROP_RW
    *   SubType - indicates subtype of the property, usually either
    *             WIA_PROP_NONE, WIA_PROP_FLAG, WIA_PROP_RANGE, or WIA_PROP_LIST
    *
    \**************************************************************************/
    
    VOID SetAccessSubType(INT index, ULONG Access, ULONG SubType);
    
    
    /**************************************************************************\
    * SetValidValues (flag)
    *
    *   Sets the type and current, default, and valid values of a property.
    *   Also sets property type to VT_I4 and subtype to WIA_PROP_FLAG.
    *
    * Arguments:
    *   index        - the property index, from DefineProperty
    *   defaultValue - default setting of this property on the device
    *   currentValue - current setting of this property on the device
    *   validFlags   - combination of all valid flags
    *
    \**************************************************************************/
    
    VOID SetValidValues(INT index, LONG defaultValue, LONG currentValue, LONG validFlags);
    
    
    /**************************************************************************\
    * SetValidValues (signed long, range)
    *
    *   Sets the type and current, default, and valid values of a property.
    *   Also sets property type to VT_I4 and subtype to WIA_PROP_RANGE.
    *
    * Arguments:
    *   index        - the property index, from DefineProperty
    *   defaultValue - default setting of this property on the device
    *   currentValue - current setting of this property on the device
    *   minValue     - minimum value for the range
    *   maxValue     - maximum value for the range
    *   stepValue    - step value for the range
    *
    \**************************************************************************/
    
    VOID SetValidValues(INT index, LONG defaultValue, LONG currentValue,
                        LONG minValue, LONG maxValue, LONG stepValue);
    
    
    /**************************************************************************\
    * SetValidValues (signed long, list)
    *
    *   Sets the type and current, default, and valid values of a property.
    *   Also sets property type to VT_I4 and subtype to WIA_PROP_LIST.
    *
    * Arguments:
    *   index        - the property index, from DefineProperty
    *   defaultValue - default setting of this property on the device
    *   currentValue - current setting of this property on the device
    *   numValues    - number of values in the list
    *   pValues      - pointer to the value list (must be valid until SendToWia
    *                  is called)
    *
    \**************************************************************************/
    
    VOID SetValidValues(INT index, LONG defaultValue, LONG currentValue,
                        INT numValues, PLONG pValues);
    
    
    /**************************************************************************\
    * SetValidValues (BSTR, list)
    *
    *   Sets the type and current, default, and valid values of a property.
    *   Also sets property type to VT_BSTR and subtype to WIA_PROP_LIST.
    *
    * Arguments:
    *   index        - the property index, from DefineProperty
    *   defaultValue - default setting of this property on the device
    *   currentValue - current setting of this property on the device
    *   numValues    - number of values in the list
    *   pValues      - pointer to the value list (must be valid until SendToWia
    *                  is called)
    *
    \**************************************************************************/
    
    VOID SetValidValues(INT index, BSTR defaultValue, BSTR currentValue,
                        INT numValues, BSTR *pValues);
    
    
    /**************************************************************************\
    * SetValidValues (float, range)
    *
    *   Sets the type and current, default, and valid values of a property.
    *   Also sets property type to VT_R4 and subtype to WIA_PROP_RANGE.
    *
    * Arguments:
    *   index        - the property index, from DefineProperty
    *   defaultValue - default setting of this property on the device
    *   currentValue - current setting of this property on the device
    *   minValue     - minimum value for the range
    *   maxValue     - maximum value for the range
    *   stepValue    - step value for the range
    *
    \**************************************************************************/
    
    VOID SetValidValues(INT index, FLOAT defaultValue, FLOAT currentValue,
                        FLOAT minValue, FLOAT maxValue, FLOAT stepValue);
    
    
    /**************************************************************************\
    * SetValidValues (float, list)
    *
    *   Sets the type and current, default, and valid values of a property.
    *   Also sets property type to VT_R4 and subtype to WIA_PROP_LIST.
    *
    * Arguments:
    *   index        - the property index, from DefineProperty
    *   defaultValue - default setting of this property on the device
    *   currentValue - current setting of this property on the device
    *   numValues    - number of values in the list
    *   pValues      - pointer to the value list (must be valid until SendToWia
    *                  is called)
    *
    \**************************************************************************/
    
    VOID SetValidValues(INT index, FLOAT defaultValue, FLOAT currentValue,
                        INT numValues, PFLOAT pValues);
    
    
    /**************************************************************************\
    * SetValidValues (CLSID, list)
    *
    *   Sets the type and current, default, and valid values of a property.
    *   Also sets property type to VT_CLSID and subtype to WIA_PROP_LIST.
    *
    * Arguments:
    *   index        - the property index, from DefineProperty
    *   defaultValue - default setting of this property on the device
    *   currentValue - current setting of this property on the device
    *   numValues    - number of values in the list
    *   pValues      - pointer to the value list (must be valid until SendToWia
    *                  is called)
    *
    \**************************************************************************/
    
    VOID SetValidValues(INT index, CLSID *defaultValue, CLSID *currentValue,
                        INT numValues, CLSID **pValues);
    
    
    /**************************************************************************\
    * SetCurrentValue (signed long)
    *
    *   Sets the current value for a property. Also sets the type to VT_I4.
    *
    * Arguments:
    *   index  - the property index, from DefineProperty
    *   value  - current setting of this property on the device
    *
    \**************************************************************************/
    
    VOID SetCurrentValue(INT index, LONG value);
    
    
    /**************************************************************************\
    * SetCurrentValue (BSTR)
    *
    *   Sets the current value for a property. Also sets the type to VT_BSTR.
    *
    * Arguments:
    *   index  - the property index, from DefineProperty
    *   value  - current setting of this property on the device
    *            (must be valid until SendToWia is called)
    *
    \**************************************************************************/
    
    VOID SetCurrentValue(INT index, BSTR value);
    
    
    /**************************************************************************\
    * SetCurrentValue (float)
    *
    *   Sets the current value for a property. Also sets the type to VT_R4.
    *
    * Arguments:
    *   index  - the property index, from DefineProperty
    *   value  - current setting of this property on the device
    *
    \**************************************************************************/
    
    VOID SetCurrentValue(INT index, FLOAT value);
    
    
    /**************************************************************************\
    * SetCurrentValue (CLSID)
    *
    *   Sets the current value for a property. Also sets the type to VT_CLSID.
    *
    * Arguments:
    *   index  - the property index, from DefineProperty
    *   value  - current setting of this property on the device
    *            (must be valid until SendToWia is called)
    *
    \**************************************************************************/
    
    VOID SetCurrentValue(INT index, CLSID *pValue);
    
    
    /**************************************************************************\
    * SetCurrentValue (SYSTEMTIME)
    *
    *   Sets the current value for a property. Also sets the type to
    *   VT_UI2 | VT_VECTOR.
    *
    * Arguments:
    *   index  - the property index, from DefineProperty
    *   value  - current setting of this property on the device
    *            (must be valid until SendToWia is called)
    *
    \**************************************************************************/
    
    VOID SetCurrentValue(INT index, PSYSTEMTIME value);
    
    
    /**************************************************************************\
    * SetCurrentValue (byte array)
    *
    *   Sets the current value for a property. Also sets the type to
    *   VT_UI1 | VT_VECTOR.
    *
    * Arguments:
    *   index  - the property index, from DefineProperty
    *   value  - pointer to current setting of this property on the device
    *            (must be valid until SendToWia is called)
    *
    \**************************************************************************/
    
    VOID SetCurrentValue(INT index, BYTE *value, INT size);

    
    /**************************************************************************\
    * GetPropId
    *
    *   Returns the property id given a property index.
    *
    \**************************************************************************/
    
    PROPID GetPropId(INT index) { return m_pId[index]; }
    
    
    /**************************************************************************\
    * LookupPropId
    *
    *   Finds the property index given a property ID.
    *
    \**************************************************************************/
    
    INT LookupPropId(PROPID PropId);
};


/**************************************************************************\
* wiauGetDrvItemContext
*
*   This helper function gets the driver item context, and optionally
*   return the driver item
*
* Arguments:
*
*   pWiasContext - pointer to the item context
*   ppItemCtx    - location to store pointer to driver item context
*   ppDrvItem    - location to store pointer to driver item (can be NULL)
*
\**************************************************************************/

HRESULT wiauGetDrvItemContext(BYTE *pWiasContext, VOID **ppItemCtx, IWiaDrvItem **ppDrvItem = NULL);


/**************************************************************************\
* wiauSetImageItemSize
*
*   Calulates the size and width in bytes for an image based on the current
*   WIA_IPA_FORMAT setting, and writes the new values to the appropriate
*   properties. If the format is not BMP, this function assumes that the
*   value passed in lSize is correct for the current format.
*
* Arguments:
*
*   pWiasContext    - pointer to item context
*   lWidth          - width of the image in pixels
*   lHeight         - height of the image in lines
*   lDepth          - depth of the image in bits
*   lSize           - size of the image as stored on the device
*   pwszExt         - optional pointer to the 3 letter extension for the
*                     item's native format (if this is NULL, the extension
*                     property won't be updated)
*
\**************************************************************************/

HRESULT wiauSetImageItemSize(BYTE *pWiasContext, LONG lWidth, LONG lHeight, LONG lDepth,
                             LONG lSize, PWSTR pwszExt = NULL);


/**************************************************************************\
* wiauPropsInPropSpec
*
*   Returns true if one or more of the property ids in pProps are
*   contained in pPropSpecs.
*
* Arguments:
*
*   NumPropSpecs - number of property specs in the array
*   pPropSpecs   - the property specs array
*   NumProps     - number of property ids to search for
*   pProps       - pointer to the array of property ids to search for
*
\**************************************************************************/

BOOL wiauPropsInPropSpec(LONG NumPropSpecs, const PROPSPEC *pPropSpecs, int NumProps, PROPID *pProps);


/**************************************************************************\
* wiauPropInPropSpec
*
*   Returns true if the PropId property ID is in the passed pPropSpecs
*   array. Optionally will return the index of where the ID was found.
*
* Arguments:
*
*   NumPropSpecs - number of property specs in the array
*   pPropSpecs   - the property specs array
*   PropId       - property id to search for
*   pIdx         - optional pointer to the location to store the index
*
\**************************************************************************/

BOOL wiauPropInPropSpec(LONG NumPropSpecs, const PROPSPEC *pPropSpecs, PROPID PropId, int *pIdx = NULL);


/**************************************************************************\
* wiauGetValidFormats
*
*   Calls drvGetWiaFormatInfo and makes a list of valid formats given
*   a tymed value. Caller is responsible for freeing the format array
*   with []delete.
*
* Arguments:
*
*   pDrv          - Pointer to WIA minidriver object (use "this")
*   pWiasContext  - WIA service context
*   TymedValue    - tymed value to search for
*   pNumFormats   - pointer to value to receive number of formats
*   ppFormatArray - pointer to a location to receive array address
*
\**************************************************************************/

HRESULT wiauGetValidFormats(IWiaMiniDrv *pDrv, BYTE *pWiasContext, LONG TymedValue,
                            int *pNumFormats, GUID **ppFormatArray);

/**************************************************************************\
* wiauGetResourceString
*
*   This helper gets a resource string and returns it as a BSTR
*
* Arguments:
*
*   hInst       - Handle to module instance
*   lResourceID - Resource ID of the target BSTR value
*   pbstrStr    - Location to store the retrieved string (caller must
*                 free this string with SysFreeString())
*
\**************************************************************************/
HRESULT wiauGetResourceString(HINSTANCE hInst, LONG lResourceID, BSTR *pbstrStr);


/**************************************************************************\
* wiauRegOpenDataW
*
*   Opens the DeviceData key. Call this function only in the STI Initialize
*   function. Call RegCloseKey when finished.
*
* Arguments:
*
*   hkeyAncestor    - HKey of parent (use hkey passed into Initialize)
*   phkeyDeviceData - Location to store opened hkey
*
\**************************************************************************/
HRESULT wiauRegOpenDataW(HKEY hkeyAncestor, HKEY *phkeyDeviceData);


/**************************************************************************\
* wiauRegOpenDataA
*
*   Opens the DeviceData key. Call this function only in the STI Initialize
*   function. Call RegCloseKey when finished.
*
* Arguments:
*
*   hkeyAncestor    - HKey of parent (use hkey passed into Initialize)
*   phkeyDeviceData - Location to store opened hkey
*
\**************************************************************************/
HRESULT wiauRegOpenDataA(HKEY hkeyAncestor, HKEY *phkeyDeviceData);


/**************************************************************************\
* wiauRegGetStrW
*
*   Use to get string value from the DeviceData section of the registry.
*
* Arguments:
*
*   hkey          - Use hkey returned from wiauRegOpenData
*   pwszValueName - Name of registry entry
*   pwszValue     - Location to store returned string
*   pdwLength     - Size of location in bytes
*
\**************************************************************************/
HRESULT wiauRegGetStrW(HKEY hkKey, PCWSTR pwszValueName, PWSTR pwszValue, DWORD *pdwLength);


/**************************************************************************\
* wiauRegGetStrA
*
*   Use to get string value from the DeviceData section of the registry.
*
* Arguments:
*
*   hkey          - Use hkey returned from wiauRegOpenData
*   pszValueName  - Name of registry entry
*   pszValue      - Location to store returned string
*   pdwLength     - Size of location in bytes
*
\**************************************************************************/
HRESULT wiauRegGetStrA(HKEY hkKey, PCSTR pszValueName, PSTR pszValue, DWORD *pdwLength);


/**************************************************************************\
* wiauRegGetDwordW
*
*   Use to get DWORD value from the DeviceData section of the registry.
*
* Arguments:
*
*   hkey          - Use hkey returned from wiauRegOpenData
*   pwszValueName - Name of registry entry
*   pdwValue      - Location to store returned DWORD
*
\**************************************************************************/
HRESULT wiauRegGetDwordW(HKEY hkKey, PCWSTR pwszValueName, DWORD *pdwValue);


/**************************************************************************\
* wiauRegGetDwordA
*
*   Use to get DWORD value from the DeviceData section of the registry.
*
* Arguments:
*
*   hkey          - Use hkey returned from wiauRegOpenData
*   pszValueName  - Name of registry entry
*   pdwValue      - Location to store returned DWORD
*
\**************************************************************************/
HRESULT wiauRegGetDwordA(HKEY hkKey, PCSTR pszValueName, DWORD *pdwValue);


/**************************************************************************\
* WiauStrW2C
*
*   Converts a wide character string to an ANSI character string
*
* Arguments:
*   pwszSrc - wide character string to be converted
*   pszDst  - location to store the ANSI conversion
*   iSize   - size of the buffer pointed to by pszDst, in bytes
*
\**************************************************************************/

HRESULT wiauStrW2C(WCHAR *pwszSrc, CHAR *pszDst, INT iSize);


/**************************************************************************\
* WiauStrC2W
*
*   Converts an ANSI character string to a wide character string
*
* Arguments:
*   pszSrc  - ANSI string to convert
*   wpszDst - location to store the wide string
*   iSize   - size of the buffer pointed to by wpszDst, in bytes
*
\**************************************************************************/
HRESULT wiauStrC2W(CHAR *pszSrc, WCHAR *pwszDst, INT iSize);


/**************************************************************************\
* WiauStrW2W
*
*   Copies a wide character string to another wide character string
*
* Arguments:
*   pwszSrc - wide character string to be copied
*   pwszDst - location to copy to
*   iSize   - size of the buffer pointed to by pwszDst, in bytes
*
\**************************************************************************/

HRESULT wiauStrW2W(WCHAR *pwszSrc, WCHAR *pwszDst, INT iSize);


/**************************************************************************\
* WiauStrC2C
*
*   Copies an ANSI character string to another ANSI character string
*
* Arguments:
*   pszSrc - ANSI string to be copied
*   pszDst - location to copy to
*   iSize  - size of the buffer pointed to by pszDst, in bytes
*
\**************************************************************************/

HRESULT wiauStrC2C(CHAR *pszSrc, CHAR *pszDst, INT iSize);


#ifdef UNICODE

#define wiauRegOpenData wiauRegOpenDataW
#define wiauRegGetStr wiauRegGetStrW
#define wiauRegGetDword wiauRegGetDwordW

#define wiauStrT2C wiauStrW2C
#define wiauStrC2T wiauStrC2W
#define wiauStrT2W wiauStrW2W
#define wiauStrW2T wiauStrW2W
#define WIAU_DEBUG_TSTR "S"

#else

#define wiauRegOpenData wiauRegOpenDataA
#define wiauRegGetStr wiauRegGetStrA
#define wiauRegGetDword wiauRegGetDwordA

#define wiauStrT2C wiauStrC2C
#define wiauStrC2T wiauStrC2C
#define wiauStrT2W wiauStrC2W
#define wiauStrW2T wiauStrW2C
#define WIAU_DEBUG_TSTR "s"

#endif // UNICODE


/**************************************************************************\
* WIA Debugging
*
*   Definitions for debug messages. To use WIA debugging:
*   1. Set registry HKLM\System\CurrentControlSet\Control\StillImage\Debug\<ModuleName>,
*      DWORD value "DebugFlags" to the combination of the WIAUDBG_* flags
*      desired. The application and possibly the WIA service will need to be
*      restarted to pick up the new settings. The key is auto created the
*      first time the module is executed. (Note: <ModuleName> above is the
*      name of the DLL or EXE, e.g. wiavusd.dll has a registry key of
*      "HKLM\System\CurrentControlSet\Control\StillImage\Debug\wiavusd.dll".)
*   2. Or in the debugger, set g_dwDebugFlags to the combination of the
*      WIAUDBG_* flags desired. This can be done anytime during the debug
*      session.
*   3. From the module, call wiauDbgSetFlags(<flags>), where <flags> is the
*      combination of the WIAUDBG_* flags desired.
*
*   Messages will be logged to the debugger and the file
*   %systemroot%\\wiadebug.log, unless the WIAUDBG_DONT_LOG_* flags are set.
*   Setting both flags will turn off all messages.
*
*   All strings should be ASCII. Use %S in the format string to print a
*   Unicode string.
*
\**************************************************************************/

#define _STIDEBUG_H_ // WIA debugging is incompatible with stidebug.h, so don't include it

//
// Predefined debug flags
//

const DWORD WIAUDBG_ERRORS                = 0x00000001;
const DWORD WIAUDBG_WARNINGS              = 0x00000002;
const DWORD WIAUDBG_TRACES                = 0x00000004;
const DWORD WIAUDBG_FNS                   = 0x00000008;  // Function entry and exit
const DWORD WIAUDBG_DUMP                  = 0x00000010;  // Dump data
const DWORD WIAUDBG_PRINT_TIME            = 0x08000000;  // Prints time for each message
const DWORD WIAUDBG_PRINT_INFO            = 0x10000000;  // Turns on thread, file, line info
const DWORD WIAUDBG_DONT_LOG_TO_DEBUGGER  = 0x20000000;
const DWORD WIAUDBG_DONT_LOG_TO_FILE      = 0x40000000;
const DWORD WIAUDBG_BREAK_ON_ERRORS       = 0x80000000;  // Do DebugBreak on errors

//
// Don't log at all
//
const DWORD WIAUDBG_DONT_LOG = WIAUDBG_DONT_LOG_TO_FILE | WIAUDBG_DONT_LOG_TO_DEBUGGER;

//
// Set default flags
//
#ifdef DEBUG
const DWORD WIAUDBG_DEFAULT_FLAGS = WIAUDBG_ERRORS;
#else
const DWORD WIAUDBG_DEFAULT_FLAGS = WIAUDBG_DONT_LOG;
#endif

//
// FormatMessage flags
//
const DWORD WIAUDBG_MFMT_FLAGS = FORMAT_MESSAGE_IGNORE_INSERTS |
                                 FORMAT_MESSAGE_FROM_SYSTEM |
                                 FORMAT_MESSAGE_MAX_WIDTH_MASK;

#ifdef __cplusplus
extern "C" {
#endif

//
// WIA Debugging has very little overhead and should be put into retail
// code for drivers. If it's really desired to remove it, define NO_WIA_DEBUG.
//

#ifdef NO_WIA_DEBUG

#define g_dwDebugFlags 0
#define wiauDbgInit(a)
#define wiauDbgHelper(a,b,c,d)
#define wiauDbgHelper2  wiauNull3
#define wiauDbgFlags    wiauNull4
#define wiauDbgError    wiauNull2
#define wiauDbgErrorHr  wiauNull3hr
#define wiauDbgWarning  wiauNull2
#define wiauDbgTrace    wiauNull2
#define wiauDbgDump     wiauNull2
#define wiauDbgSetFlags(a) 0
#define wiauDbgLegacyError      wiauNull1
#define wiauDbgLegacyWarning    wiauNull1
#define wiauDbgLegacyTrace      wiauNull1
#define wiauDbgLegacyError2     wiauNull2h
#define wiauDbgLegacyTrace2     wiauNull2h
#define wiauDbgLegacyHresult2   wiauNullHHr

inline void wiauNull1(LPCSTR a, ...) {}
inline void wiauNull2(LPCSTR a, LPCSTR b,...) {}
inline void wiauNull2h(HINSTANCE hInstance, LPCSTR b,...) {}
inline void wiauNull3(LPCSTR a, LPCSTR b, LPCSTR c, ...) {}
inline void wiauNull3hr(HRESULT a, LPCSTR b, LPCSTR c, ...) {}
inline void wiauNull4(DWORD a, LPCSTR b, LPCSTR c, LPCSTR d, ...) {}
inline void wiauNullHHr(HINSTANCE hInstance, HRESULT hr) {}


#else // NO_WIA_DEBUG

extern DWORD  g_dwDebugFlags; 
extern HANDLE g_hDebugFile;
extern DWORD  g_dwDebugFileSizeLimit;
extern BOOL   g_bDebugInited;


/**************************************************************************\
* wiauDbgInit
*
*   Call to initialize WIA debugging. If it's not called, all DLLs will
*   inherit the debug flags of the process that creates them.
*
* Arguments:
*
*   hInstance - DLL instance handle
*
\**************************************************************************/

void __stdcall wiauDbgInit(HINSTANCE hInstance);
void __stdcall wiauDbgHelper(LPCSTR prefix, LPCSTR fname, LPCSTR fmt, va_list marker);
void __stdcall wiauDbgHelper2(LPCSTR prefix, LPCSTR fname, LPCSTR fmt, ...);

inline void __stdcall wiauDbgFlags(DWORD flags, LPCSTR prefix,
                                   LPCSTR fname, LPCSTR fmt, ...)
{
    va_list marker;

    //
    // See if log messages are enabled and the flag is enabled
    //
    if (((g_dwDebugFlags & WIAUDBG_DONT_LOG) ^ WIAUDBG_DONT_LOG) &&
        (g_dwDebugFlags & flags)) {

        va_start(marker, fmt);
        wiauDbgHelper(prefix, fname, fmt, marker);
        va_end(marker);
    }
}

inline void __stdcall wiauDbgError(LPCSTR fname, LPCSTR fmt, ...)
{
    va_list marker;

    //
    // See if log messages are enabled and error messages are turned on
    //
    if (((g_dwDebugFlags & WIAUDBG_DONT_LOG) ^ WIAUDBG_DONT_LOG) &&
        (g_dwDebugFlags & WIAUDBG_ERRORS)) {

        va_start(marker, fmt);
        wiauDbgHelper("ERROR ", fname, fmt, marker);
        va_end(marker);
    }

    if (g_dwDebugFlags & WIAUDBG_BREAK_ON_ERRORS) {
        DebugBreak();
    }
}

inline void __stdcall wiauDbgErrorHr(HRESULT hr, LPCSTR fname, LPCSTR fmt, ...)
{
    va_list marker;

    //
    // See if log messages are enabled and error messages are turned on
    //
    if (((g_dwDebugFlags & WIAUDBG_DONT_LOG) ^ WIAUDBG_DONT_LOG) &&
        (g_dwDebugFlags & WIAUDBG_ERRORS)) {

        va_start(marker, fmt);
        wiauDbgHelper("ERROR ", fname, fmt, marker);
        va_end(marker);

        CHAR szError[MAX_PATH]; \
        if(!FormatMessageA(WIAUDBG_MFMT_FLAGS, NULL, hr, 0, szError, MAX_PATH, NULL))
        {
            strcpy(szError, "Unknown HRESULT");
        }
        wiauDbgHelper2("ERROR ", fname, "HRESULT = 0x%08x, %s", hr, szError);
    }

    if (g_dwDebugFlags & WIAUDBG_BREAK_ON_ERRORS) {
        DebugBreak();
    }
}

inline void __stdcall wiauDbgWarning(LPCSTR fname, LPCSTR fmt, ...)
{
    va_list marker;

    //
    // See if log messages are enabled and warning messages are turned on
    //
    if (((g_dwDebugFlags & WIAUDBG_DONT_LOG) ^ WIAUDBG_DONT_LOG) &&
        (g_dwDebugFlags & WIAUDBG_WARNINGS)) {

        va_start(marker, fmt);
        wiauDbgHelper("WARN  ", fname, fmt, marker);
        va_end(marker);
    }
}

inline void __stdcall wiauDbgTrace(LPCSTR fname, LPCSTR fmt, ...)
{
    va_list marker;

    //
    // See if log messages are enabled and trace messages are turned on
    //
    if (((g_dwDebugFlags & WIAUDBG_DONT_LOG) ^ WIAUDBG_DONT_LOG) &&
        (g_dwDebugFlags & WIAUDBG_TRACES)) {

        va_start(marker, fmt);
        wiauDbgHelper("      ", fname, fmt, marker);
        va_end(marker);
    }
}

inline void __stdcall wiauDbgDump(LPCSTR fname, LPCSTR fmt, ...)
{
    va_list marker;

    //
    // See if log messages are enabled and trace messages are turned on
    //
    if (((g_dwDebugFlags & WIAUDBG_DONT_LOG) ^ WIAUDBG_DONT_LOG) &&
        (g_dwDebugFlags & WIAUDBG_DUMP)) {

        va_start(marker, fmt);
        wiauDbgHelper("      ", fname, fmt, marker);
        va_end(marker);
    }
}

inline DWORD __stdcall wiauDbgSetFlags(DWORD flags)
{
    DWORD dwOld = g_dwDebugFlags;
    g_dwDebugFlags = flags;
    return dwOld;
}


inline void __stdcall wiauDbgLegacyError(LPCSTR fmt, ...)
{
    va_list marker;

    //
    // See if log messages are enabled and error messages are turned on
    //
    if (((g_dwDebugFlags & WIAUDBG_DONT_LOG) ^ WIAUDBG_DONT_LOG) &&
        (g_dwDebugFlags & WIAUDBG_ERRORS)) {

        va_start(marker, fmt);
        wiauDbgHelper("ERROR ", "", fmt, marker);
        va_end(marker);
    }

    if (g_dwDebugFlags & WIAUDBG_BREAK_ON_ERRORS) {
        DebugBreak();
    }
}

inline void __stdcall wiauDbgLegacyWarning(LPCSTR fmt, ...)
{
    va_list marker;

    //
    // See if log messages are enabled and warning messages are turned on
    //
    if (((g_dwDebugFlags & WIAUDBG_DONT_LOG) ^ WIAUDBG_DONT_LOG) &&
        (g_dwDebugFlags & WIAUDBG_WARNINGS)) {

        va_start(marker, fmt);
        wiauDbgHelper("WARN  ", "", fmt, marker);
        va_end(marker);
    }
}

inline void __stdcall wiauDbgLegacyTrace(LPCSTR fmt, ...)
{
    va_list marker;

    //
    // See if log messages are enabled and trace messages are turned on
    //
    if (((g_dwDebugFlags & WIAUDBG_DONT_LOG) ^ WIAUDBG_DONT_LOG) &&
        (g_dwDebugFlags & WIAUDBG_TRACES)) {

        va_start(marker, fmt);
        wiauDbgHelper("      ", "", fmt, marker);
        va_end(marker);
    }
}

inline void __stdcall wiauDbgLegacyError2(HINSTANCE hInstance, LPCSTR fmt, ...)
{
    va_list marker;

    //
    // See if log messages are enabled and error messages are turned on
    //
    if (((g_dwDebugFlags & WIAUDBG_DONT_LOG) ^ WIAUDBG_DONT_LOG) &&
        (g_dwDebugFlags & WIAUDBG_ERRORS)) {

        va_start(marker, fmt);
        wiauDbgHelper("ERROR ", "", fmt, marker);
        va_end(marker);
    }

    if (g_dwDebugFlags & WIAUDBG_BREAK_ON_ERRORS) {
        DebugBreak();
    }
}

inline void __stdcall wiauDbgLegacyTrace2(HINSTANCE hInstance, LPCSTR fmt, ...)
{
    va_list marker;

    //
    // See if log messages are enabled and trace messages are turned on
    //
    if (((g_dwDebugFlags & WIAUDBG_DONT_LOG) ^ WIAUDBG_DONT_LOG) &&
        (g_dwDebugFlags & WIAUDBG_TRACES)) {

        va_start(marker, fmt);
        wiauDbgHelper("      ", "", fmt, marker);
        va_end(marker);
    }
}

inline void __stdcall wiauDbgLegacyHresult2(HINSTANCE hInstance, HRESULT hr)
{
    wiauDbgErrorHr(hr, "", "");
}

#endif // NO_WIA_DEBUG


//
// Macros for mapping the old WIA logging to the new system
//
#ifdef WIA_MAP_OLD_DEBUG

#define CWiaLogProc
#define WIAS_LOGPROC(x, y, z, fname) CWiauDbgFn __CWiauDbgFnObject(fname)
#define WIAS_LERROR(x,y,params) wiauDbgLegacyError ## params
#define WIAS_LWARNING(x,y,params) wiauDbgLegacyWarning ## params
#define WIAS_LTRACE(x,y,z,params) wiauDbgLegacyTrace ## params
#define WIAS_LHRESULT(x,y) wiauDbgErrorHr(y, "", "")

#define WIAS_TRACE(x) wiauDbgLegacyTrace2 ## x
#define WIAS_ERROR(x) wiauDbgLegacyError2 ## x
#define WIAS_HRESULT(x) wiauDbgLegacyHresult2 ## x
#define WIAS_ASSERT(x, y) \
        if (!(y)) { \
            WIAS_ERROR((x, (char*) TEXT("ASSERTION FAILED: %hs(%d): %hs"), __FILE__,__LINE__,#x)); \
            DebugBreak(); \
        }
        
#endif // WIA_MAP_OLD_DEBUG


//
// Macros for checking return values and common error conditions
//

#define REQUIRE_SUCCESS(hr, fname, msg) \
    if (FAILED(hr)) { \
        if (g_dwDebugFlags & WIAUDBG_PRINT_INFO) { \
            DWORD threadId = GetCurrentThreadId(); \
            wiauDbgError(fname, "[%s(%d): Thread 0x%X (%d)]", __FILE__, __LINE__, threadId, threadId); \
        } \
        wiauDbgErrorHr(hr, fname, msg); \
        goto Cleanup; \
    }

#define REQUIRE_OK(hr, fname, msg) \
    if ((hr) != S_OK) { \
        if (g_dwDebugFlags & WIAUDBG_PRINT_INFO) { \
            DWORD threadId = GetCurrentThreadId(); \
            wiauDbgError(fname, "[%s(%d): Thread 0x%X (%d)]", __FILE__, __LINE__, threadId, threadId); \
        } \
        wiauDbgErrorHr(hr, fname, msg); \
        goto Cleanup; \
    }

#define REQUIRE_ARGS(args, hr, fname) \
    if (args) { \
        if (g_dwDebugFlags & WIAUDBG_PRINT_INFO) { \
            DWORD threadId = GetCurrentThreadId(); \
            wiauDbgError(fname, "[%s(%d): Thread 0x%X (%d)]", __FILE__, __LINE__, threadId, threadId); \
        } \
        wiauDbgError(fname, "Invalid arg"); \
        hr = E_INVALIDARG; \
        goto Cleanup; \
    }

#define REQUIRE_ALLOC(var, hr, fname) \
    if (!(var)) { \
        if (g_dwDebugFlags & WIAUDBG_PRINT_INFO) { \
            DWORD threadId = GetCurrentThreadId(); \
            wiauDbgError(fname, "[%s(%d): Thread 0x%X (%d)]", __FILE__, __LINE__, threadId, threadId); \
        } \
        wiauDbgError(fname, "Memory allocation failed on " #var); \
        hr = E_OUTOFMEMORY; \
        goto Cleanup; \
    }

#define REQUIRE_FILEHANDLE(handle, hr, fname, msg) \
    if ((handle) == NULL || (handle) == INVALID_HANDLE_VALUE) { \
        hr = HRESULT_FROM_WIN32(::GetLastError()); \
        if (g_dwDebugFlags & WIAUDBG_PRINT_INFO) { \
            DWORD threadId = GetCurrentThreadId(); \
            wiauDbgError(fname, "[%s(%d): Thread 0x%X (%d)]", __FILE__, __LINE__, threadId, threadId); \
        } \
        wiauDbgErrorHr(hr, fname, msg); \
        goto Cleanup; \
    }

#define REQUIRE_FILEIO(ret, hr, fname, msg) \
    if (!(ret)) { \
        hr = HRESULT_FROM_WIN32(::GetLastError()); \
        if (g_dwDebugFlags & WIAUDBG_PRINT_INFO) { \
            DWORD threadId = GetCurrentThreadId(); \
            wiauDbgError(fname, "[%s(%d): Thread 0x%X (%d)]", __FILE__, __LINE__, threadId, threadId); \
        } \
        wiauDbgErrorHr(hr, fname, msg); \
        goto Cleanup; \
    }

#define REQUIRE_WIN32(err, hr, fname, msg) \
    if ((err) != ERROR_SUCCESS) { \
        hr = HRESULT_FROM_WIN32(err); \
        if (g_dwDebugFlags & WIAUDBG_PRINT_INFO) { \
            DWORD threadId = GetCurrentThreadId(); \
            wiauDbgError(fname, "[%s(%d): Thread 0x%X (%d)]", __FILE__, __LINE__, threadId, threadId); \
        } \
        wiauDbgErrorHr(hr, fname, msg); \
        goto Cleanup; \
    }


//
// Macro and class for entry/exit point tracing
//

#ifdef __cplusplus

#ifdef NO_WIA_DEBUG

#define DBG_FN(fname)

#else // NO_WIA_DEBUG

#define DBG_FN(fname) CWiauDbgFn __CWiauDbgFnObject(fname)

class CWiauDbgFn {
public:

    CWiauDbgFn(LPCSTR fname)
    { 
        m_fname = fname;
        m_threadId = GetCurrentThreadId();
        wiauDbgFlags(WIAUDBG_FNS, "      ", m_fname, "Entering, thread 0x%x (%d)",
                     m_threadId, m_threadId);

    } 
    
    ~CWiauDbgFn() 
    { 
        wiauDbgFlags(WIAUDBG_FNS, "      ", m_fname, "Exiting, thread 0x%x (%d)",
                     m_threadId, m_threadId);
    }

private:
    LPCSTR m_fname;
    DWORD  m_threadId;
};
#endif // NO_WIA_DEBUG

}

#else // __cplusplus

#define DBG_FN(fname) wiauDbgFlags(WIAUDBG_FNS, "      ", fname, "Entering");
#endif // __cplusplus
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\inc\wiatwcmp.h ===
/****************************************************************************
*
*  (C) COPYRIGHT 1998-2001, MICROSOFT CORP.
*
*  FILE:        wiatwcmp.h
*
*  VERSION:     1.0
*
*  DATE:        6/01/2001
*
*  DESCRIPTION:
*    Defines TWAIN Compatibility Layer - Capability pass-through constants.
*    To support existing TWAIN applications that have private capabilities,
*    WIA drivers can utilize the Pass-through functionality.
*
*****************************************************************************/

#ifndef _WIATWCMP_H_
#define _WIATWCMP_H_

#define WiaItemTypeTwainCapabilityPassThrough   0x00020000

//**************************************************************************
//
// TWAIN capability pass-through
//
//**************************************************************************

//
// Escape code ranges 2001 - 3000 are reserved for future ESC_ commands
//

#define ESC_TWAIN_CAPABILITY                2001    // private TWAIN capability negotiation
#define ESC_TWAIN_PRIVATE_SUPPORTED_CAPS    2002    // query for supported private capabilities

typedef struct _TWAIN_CAPABILITY {
    LONG  lSize;    // size of TWAIN_CAPABILITY structure
    LONG  lMSG;     // TWAIN Message, MSG_GET, MSG_GETCURRENT, MSG_SET, etc..
    LONG  lCapID;   // id of capability to set or get
    LONG  lConType; // container type of capability
    LONG  lRC;      // TWAIN return code, TWRC_SUCCESS, TWRC_FAILURE, etc..
    LONG  lCC;      // TWAIN condition code, TWCC_SUCCESS, TWCC_BUMMER, etc..
    LONG  lDataSize;// data size
    BYTE  Data[1];  // first BYTE of data
}TWAIN_CAPABILITY,*PTWAIN_CAPABILITY;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\kernel\scsiscan\private.h ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    private.h

Abstract:

    Prototypes and definitions for the scsi scanner device driver.

Author:

    Ray Patrick (raypat)

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#ifndef _SCSISCAN_PRIAVATE_
#define _SCSISCAN_PRIAVATE_


// Includes
#include "debug.h"
#include "scsiscan.h"


// Defines

#define MAXIMUM_RETRIES     4
#define SCSISCAN_TIMEOUT    600

#define SRB SCSI_REQUEST_BLOCK
#define PSRB PSCSI_REQUEST_BLOCK

// Typedefs

typedef struct _SCSISCAN_DEVICE_EXTENSION {
    ULONG                       Signature;
    PDEVICE_OBJECT              pStackDeviceObject;
    PDEVICE_OBJECT              pPhysicalDeviceObject;
    ULONG                       SrbFlags;
    UCHAR                       PortNumber;
    ULONG                       TimeOutValue;
    ULONG                       ErrorCount;
    ULONG                       SelecTimeoutCount;
    ULONG                       LastSrbError;
    ULONG                       DeviceInstance;
    ULONG                       PnpDeviceNumber;
    USHORT                      DeviceFlags;
    PSTORAGE_ADAPTER_DESCRIPTOR pAdapterDescriptor;
    UNICODE_STRING              DeviceName;
    //UNICODE_STRING              SymbolicLinkName;

    KEVENT                      PendingIoEvent;
    ULONG                       PendingIoCount;
    BOOLEAN                     AcceptingRequests;
    PVOID                       DeviceLock;
    ULONG                       OpenInstanceCount;
    PIRP                        pPowerIrp;
    DEVICE_POWER_STATE          CurrentDevicePowerState;

    //
    // Records whether we actually created the symbolic link name
    // at driver load time.  If we didn't create it, we won't try
    // to distroy it when we unload.
    //
    BOOLEAN         CreatedSymbolicLink;

    //
    // This points to the symbolic link name that was
    // linked to the actual nt device name.
    //
    UNICODE_STRING  SymbolicLinkName;

    //
    // This points to the class name used to create the
    // device and the symbolic link.  We carry this
    // around for a short while...
    UNICODE_STRING  ClassName;

    //
    // Name of the device interface
    //
    UNICODE_STRING  InterfaceNameString;

} SCSISCAN_DEVICE_EXTENSION, *PSCSISCAN_DEVICE_EXTENSION;

typedef struct _TRANSFER_CONTEXT {
    ULONG              Signature;
    PSCSISCAN_CMD      pCmd;
    SRB                Srb;
    PUCHAR             pTransferBuffer;
    ULONG              TransferLength;
    LONG               RemainingTransferLength;
    LONG               NBytesTransferred;
    ULONG              RetryCount;
    PUCHAR             pSenseBuffer;
    PMDL               pSenseMdl;
    PMDL               pSrbStatusMdl;
} TRANSFER_CONTEXT, *PTRANSFER_CONTEXT;

typedef struct _COMPLETION_CONTEXT {
        ULONG                           Signature;
    PDEVICE_OBJECT      pDeviceObject;
    SRB                 Srb;
}COMPLETION_CONTEXT, *PCOMPLETION_CONTEXT;

#ifdef _WIN64
// For 32bit client on 64bit OS.
typedef struct _SCSISCAN_CMD_32 {
    ULONG               Reserved1;
    ULONG               Size;
    ULONG               SrbFlags;
    UCHAR               CdbLength;
    UCHAR               SenseLength;
    UCHAR               Reserved2;
    UCHAR               Reserved3;
    ULONG               TransferLength;
    UCHAR               Cdb[16];    
    UCHAR * POINTER_32  pSrbStatus;
    UCHAR * POINTER_32  pSenseBuffer;
} SCSISCAN_CMD_32, *PSCSISCAN_CMD_32;
#endif // _WIN64

//
// Prototypes
//
NTSTATUS
DriverEntry(                                                    // in scsiscan.c
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS SSPnp (                                                // in scsiscan.c
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
   );

NTSTATUS
SSPnpAddDevice(                                                 // in scsiscan.c
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDevice
    );

NTSTATUS
SSOpen(                                                                 // in scsiscan.c
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

NTSTATUS
SSClose(                                                        // in scsiscan.c
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

NTSTATUS
SSReadWrite(                                                    // in scsiscan.c
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

NTSTATUS
SSDeviceControl(                                                // in scsiscan.c
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    );

NTSTATUS
SSGetInfo(                                                              // in scsiscan.c
    IN  PDEVICE_OBJECT pDeviceObject,
    IN  ULONG ControlCode,
    OUT PVOID *ppv
    );


VOID
SSSendScannerRequest(                                   // in scsiscan.c
        PDEVICE_OBJECT pDeviceObject,
        PIRP pIrp,
        PTRANSFER_CONTEXT pTransferContext,
        BOOLEAN Retry
        );

NTSTATUS
SSReadWriteIoComplete(                                  // in scsiscan.c
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID Context
    );

NTSTATUS
SSIoctlIoComplete(                                              // in scsiscan.c
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID Context
    );

NTSTATUS
SSDeviceControl(                                                // in scsiscan.c
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
    );


VOID
SSAdjustTransferSize(                                   // in scsiscan.c
    PSCSISCAN_DEVICE_EXTENSION  pde,
    PTRANSFER_CONTEXT pTransferContext
    );


PTRANSFER_CONTEXT                                               // in scsiscan.c
SSBuildTransferContext(
    PSCSISCAN_DEVICE_EXTENSION  pde,
    PIRP                        pIrp,
    PSCSISCAN_CMD               pCmd,
    ULONG                       CmdLength,
    PMDL                        pTransferMdl,
    BOOLEAN                     AllowMultipleTransfer
    );

NTSTATUS                                                                // in scsiscan.c
SSCreateSymbolicLink(
    PSCSISCAN_DEVICE_EXTENSION  pde
    );

NTSTATUS                                                                // in scsiscan.c
SSDestroySymbolicLink(
    PSCSISCAN_DEVICE_EXTENSION  pde
    );

VOID                                    // in scsiscan.c
SSIncrementIoCount(
    IN PDEVICE_OBJECT pDeviceObject
    );

LONG                                    // in scsiscan.c
SSDecrementIoCount(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS                                // in scsiscan.c
SSDeferIrpCompletion(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID Context
    );


NTSTATUS                                // in scsiscan.c
SSPower(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
    );

VOID                                    // in scsiscan.c
SSUnload(
    IN PDRIVER_OBJECT pDriverObject
    );

VOID
SSSetTransferLengthToCdb(
    PCDB  pCdb,
    ULONG TransferLength
    );                                  // in scsiscan.c

NTSTATUS
SSCallNextDriverSynch(
    IN PSCSISCAN_DEVICE_EXTENSION   pde,
    IN PIRP                         pIrp
    );


NTSTATUS
ClassGetDescriptor(                                             // in class.c
    IN PDEVICE_OBJECT DeviceObject,
    IN PSTORAGE_PROPERTY_ID PropertyId,
    OUT PVOID *pDescriptor
    );

BOOLEAN
ClassInterpretSenseInfo(                                // in class.c
    IN PDEVICE_OBJECT pDeviceObject,
    IN PSRB pSrb,
    IN UCHAR MajorFunctionCode,
    IN ULONG IoDeviceCode,
    IN ULONG RetryCount,
    OUT NTSTATUS *Status
    );

VOID                                                                    // in class.c
ClassReleaseQueue(
    IN PDEVICE_OBJECT pDeviceObject
    );

NTSTATUS
ClassAsynchronousCompletion(            // in class.c
    PDEVICE_OBJECT pDeviceObject,
    PIRP pIrp,
    PCOMPLETION_CONTEXT pContext
    );

NTSTATUS
ClassGetInfo(                          // in class.c
    IN PDEVICE_OBJECT pDeviceObject,
    OUT PSCSISCAN_INFO pTargetInfo
    );

NTSTATUS
ScsiScanHandleInterface(
    PDEVICE_OBJECT      DeviceObject,
    PUNICODE_STRING     InterfaceName,
    BOOLEAN             Create
    );

#endif // _SCSISCAN_PRIAVATE_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\kernel\scsiscan\debug.h ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    debug.h

Abstract:

    Prototypes and definitions for debugging.

Author: 

    Keisuke Tsuchida (KeisukeT)

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#ifndef __MYDEBUG__
#define __MYDEBUG__

//
// Driver specific difinition
//


#define NAME_DRIVER             "Scsican.sys: "     // Prefix of output message. (Should be driver name)
#define NAME_POOLTAG            'SITS'              // Pool tag for this driver.
#define MAXNUM_POOL             100                 // Maximum number of pool. (# of alloc - # of free)
#define MAX_DUMPSIZE            1024                // Maximum bytes to dump.

//
// Defines
//

#define REG_DEBUGLEVEL          L"DebugTraceLevel"
#define MAX_TEMPBUF             256

// Bit mask for trace level and flags
#define BITMASK_TRACE_LEVEL     0x0000000f
#define BITMASK_TRACE_FLAG      0x00000ff0
#define BITMASK_DEBUG_FLAG      0x0000f000

// Basic trace level 
#define NO_TRACE                0                   // Shows nothing.
#define MIN_TRACE               1                   // Shows only error or warning.
#define MAX_TRACE               2                   // Shows progress and status.
#define ULTRA_TRACE             3                   // Shows progress and status in retail.
#define NEVER_TRACE             4                   // Never show this unless specific bit is set.

// Trace flag to enable specific message spew. (1=on)
#define TRACE_FLAG_PROC          0x10                // Show message when entering process.(1=on)
#define TRACE_FLAG_RET           0x20                // Show message when leaving process.(1=on)
#define TRACE_FLAG_DUMP_READ     0x40                // Show user buffer when read.
#define TRACE_FLAG_DUMP_WRITE    0x80                // Show user buffer when write.

// Conbination of trace level and flag.
#define TRACE_PROC_ENTER        ULTRA_TRACE | TRACE_FLAG_PROC     // Entering procedure.
#define TRACE_PROC_LEAVE        ULTRA_TRACE | TRACE_FLAG_RET      // Leaving procedure.
#define TRACE_CRITICAL          MIN_TRACE                         // Critical error. Spew always.
#define TRACE_ERROR             MIN_TRACE                         // Error.
#define TRACE_WARNING           MIN_TRACE                         // Possible wrong behavior.
//#define TRACE_DUMP_DATA         NEVER_TRACE | TRACE_FLAG_DUMP     // Dump transaction data.
#define TRACE_DEVICE_DATA       MAX_TRACE                         // Show device data.
#define TRACE_STATUS            MAX_TRACE                         // Show status.

// Debug flag to enable/disable  DEBUG_BREAKPOINT()
#define DEBUG_FLAG_DISABLE      0x1000                          // Disable DEBUG_BREAK. (1=disable)
#define DEBUG_PROC_BREAK        0x2000                          // Stop at the beginning of each procedure.


//
// Macro
//


#if DBG

 //
 // Macro for debug output
 //
 // Note: If trace level is higher than DebugTraceLevel or specific bit is set, 
 //       debug message will be shown.
 //

extern ULONG DebugTraceLevel;
 #define DebugTrace(_t_, _x_) {                                                                 \
            if ( ((DebugTraceLevel & BITMASK_TRACE_LEVEL) >= (_t_ & BITMASK_TRACE_LEVEL )) ||   \
                 (DebugTraceLevel & BITMASK_TRACE_FLAG & (_t_)) ) {                             \
                DbgPrint(NAME_DRIVER);                                                          \
                DbgPrint _x_ ;                                                                  \
            }                                                                                   \
            if( (DebugTraceLevel & DEBUG_PROC_BREAK & (_t_)) &&                                 \
                (DebugTraceLevel & TRACE_FLAG_PROC) )  {                                        \
                DEBUG_BREAKPOINT();                                                             \
            }                                                                                   \
          }

 //
 // Macro for BreakPoint
 //

 #define DEBUG_BREAKPOINT() {                                              \
           if (DebugTraceLevel & DEBUG_FLAG_DISABLE) {                     \
               DbgPrint(NAME_DRIVER);                                      \
               DbgPrint("*** Hit DEBUG_BREAKPOINT ***\n");                 \
           } else {                                                        \
               DbgBreakPoint();                                            \
           }                                                               \
         }

#else    // DBG
 #define DEBUG_BREAKPOINT()
 #define DebugTrace(_t_, _x_)
#endif   // DBG


//
// Prototypes
//


#ifdef ORIGINAL_POOLTRACK

PVOID
MyAllocatePool(
    IN POOL_TYPE PoolType,
    IN ULONG     ulNumberOfBytes
);

VOID
MyFreePool(
    IN PVOID     pvAddress
);

#else       // ORIGINAL_POOLTRACK
 #define MyAllocatePool(a, b)   ExAllocatePoolWithTag(a, b, NAME_POOLTAG)
 #define MyFreePool(a)          ExFreePool(a)
#endif      // ORIGINAL_POOLTRACK

VOID
MyDebugInit(
    IN  PUNICODE_STRING pRegistryPath
);

VOID
MyDumpMemory(
    PUCHAR  pDumpBuffer,
    ULONG   dwSize,
    BOOLEAN bRead
);

#endif //  __MYDEBUG__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\kernel\scsiscan\debug.c ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    debug.c

Abstract:

    Common code for debugging.

Author: 

    Keisuke Tsuchida (KeisukeT)

Environment:

    kernel mode only

Notes:

Revision History:

--*/

//
// Includes
//

#include "stddef.h"
#include "wdm.h"
#include "debug.h"

//
// Globals
//

ULONG   DebugTraceLevel = MIN_TRACE | DEBUG_FLAG_DISABLE;
// ULONG  DebugTraceLevel = MAX_TRACE | DEBUG_FLAG_DISABLE | TRACE_PROC_ENTER | TRACE_PROC_LEAVE;
LONG    AllocateCount = 0;
ULONG   DebugDumpMax    = MAX_DUMPSIZE;

#ifdef ORIGINAL_POOLTRACK

PVOID
MyAllocatePool(
    IN POOL_TYPE PoolType,
    IN ULONG     ulNumberOfBytes
)
/*++

Routine Description:

    Wrapper for pool allocation. Use tag to avoid heap corruption.

Arguments:

    PoolType - type of pool memory to allocate
    ulNumberOfBytes - number of bytes to allocate

Return Value:

    Pointer to the allocated memory

--*/
{
    PVOID pvRet;

    DebugTrace(TRACE_PROC_ENTER,("MyAllocatePool: Enter.. Size = %d\n", ulNumberOfBytes));

    pvRet = ExAllocatePoolWithTag(PoolType,
                                  ulNumberOfBytes,
                                  NAME_POOLTAG);

#if DBG
    if(NULL == pvRet){
        DebugTrace(TRACE_ERROR,("MyAllocatePool: ERROR!! Cannot allocate pool.\n"));
    } else {
        if(++AllocateCount > MAXNUM_POOL){
            DebugTrace(TRACE_WARNING,("MyAllocatePool: WARNING!! Allocate called %dtimes more than Free\n", MAXNUM_POOL));
        }
        DebugTrace(TRACE_STATUS,("MyAllocatePool: Count = %d\n", AllocateCount));
    }
#endif // DBG

    DebugTrace(TRACE_PROC_LEAVE,("MyAllocatePool: Leaving.. pvRet = %x\n", pvRet));
    return pvRet;
}


VOID
MyFreePool(
    IN PVOID     pvAddress
)
/*++

Routine Description:

    Wrapper for pool free. Check tag to avoid heap corruption

Arguments:

    pvAddress - Pointer to the allocated memory

Return Value:

    none.

--*/
{

    DebugTrace(TRACE_PROC_ENTER,("USFreePool: Enter..\n"));

#if DBG
    {
        ULONG ulTag;
    
        ulTag = *((PULONG)pvAddress-1);
//        if( (NAME_POOLTAG == ulTag) || (DebugTraceLevel & TRACE_IGNORE_TAG) ){
        if(NAME_POOLTAG == ulTag){
            if(--AllocateCount < 0){
                DebugTrace(TRACE_WARNING,("MyFreePool: Warning!! Free called more than Allocate.\n"));
            }
        } else {
            DebugTrace(TRACE_WARNING,("MyFreePool: WARNING!! tag = %c%c%c%c\n",
                                        ((PUCHAR)&ulTag)[0],
                                        ((PUCHAR)&ulTag)[1],
                                        ((PUCHAR)&ulTag)[2],
                                        ((PUCHAR)&ulTag)[3]  ));
        }
    }
#endif // DBG

    ExFreePool(pvAddress);

    DebugTrace(TRACE_PROC_LEAVE,("MyFreePool: Leaving.. Return = NONE\n"));
}
#endif // ORIGINAL_POOLTRACK


VOID
MyDebugInit(
    IN  PUNICODE_STRING pRegistryPath
)
/*++

Routine Description:

    Read DebugTraceLevel key from driver's registry if exists.

Arguments:

    pRegistryPath   -   pointer to a unicode string representing the path
                        to driver-specific key in the registry

Return Value:

    none.

--*/
{

    HANDLE                          hDriverRegistry;
    OBJECT_ATTRIBUTES               ObjectAttributes;
    UNICODE_STRING                  unicodeKeyName;
    ULONG                           DataSize;
    PKEY_VALUE_PARTIAL_INFORMATION  pValueInfo;
    NTSTATUS                        Status;
    
    DebugTrace(TRACE_PROC_ENTER,("MyDebugInit: Enter... \n"));
    
    //
    // Initialize local variables.
    //
    
    Status          = STATUS_SUCCESS;
    hDriverRegistry = NULL;
    pValueInfo      = NULL;
    DataSize        = 0;

    //
    // Initialize object attribute and open registry key.
    //
    
    RtlZeroMemory(&ObjectAttributes, sizeof(ObjectAttributes));
    InitializeObjectAttributes(&ObjectAttributes,
                               pRegistryPath,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);
    
    Status = ZwOpenKey(&hDriverRegistry,
                       KEY_READ,
                       &ObjectAttributes);
    if(!NT_SUCCESS(Status)){
        DebugTrace(TRACE_ERROR,("MyDebugInit: ERROR!! Can't open driver registry key.\n"));
        goto MyDebugInit_return;
    }
    
    //
    // Read "DebugTraceLevel" key.
    //

    DebugTrace(TRACE_CRITICAL,("MyDebugInit: Query %wZ\\%ws.\n", pRegistryPath, REG_DEBUGLEVEL));

    //
    // Query required size.
    //
    
    RtlInitUnicodeString(&unicodeKeyName, REG_DEBUGLEVEL);
    Status = ZwQueryValueKey(hDriverRegistry,
                             &unicodeKeyName,
                             KeyValuePartialInformation,
                             NULL,
                             0,
                             &DataSize);
    if( (Status != STATUS_BUFFER_OVERFLOW)
     && (Status != STATUS_BUFFER_TOO_SMALL)
     && (Status != STATUS_SUCCESS) )
    {
        if(Status == STATUS_OBJECT_NAME_NOT_FOUND){
            DebugTrace(TRACE_STATUS,("MyDebugInit: DebugTraceLevel doesn't exist. Use default(0x%x).\n", DebugTraceLevel));
        } else {
            DebugTrace(TRACE_ERROR,("MyDebugInit: ERROR!! ZwQueryValueKey failed. Status=0x%x\n", Status));
        }
        goto MyDebugInit_return;
    }
    
    //
    // Check size of data.
    //
    
    if (MAX_TEMPBUF < DataSize) {
        DebugTrace(TRACE_ERROR, ("MyDebugInit: ERROR!! DataSize (0x%x) is too big.\n", DataSize));
        goto MyDebugInit_return;
    }

    if (0 == DataSize) {
        DebugTrace(TRACE_ERROR, ("MyDebugInit: ERROR!! Cannot retrieve required data size.\n"));
        goto MyDebugInit_return;
    }

    //
    // Allocate memory for temp buffer. size +2 for NULL.
    //

    pValueInfo = MyAllocatePool(NonPagedPool, DataSize+2);
    if(NULL == pValueInfo){
        DebugTrace(TRACE_CRITICAL, ("MyDebugInit: ERROR!! Buffer allocate failed.\n"));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto MyDebugInit_return;
    }
    RtlZeroMemory(pValueInfo, DataSize+2);

    //
    // Query specified value.
    //
    
    Status = ZwQueryValueKey(hDriverRegistry,
                             &unicodeKeyName,
                             KeyValuePartialInformation,
                             pValueInfo,
                             DataSize,
                             &DataSize);
    if(!NT_SUCCESS(Status)){
        DebugTrace(TRACE_ERROR, ("MyDebugInit: ERROR!! ZwQueryValueKey failed.\n"));
        goto MyDebugInit_return;
    }
    
    //
    // Set DebugTraceLevel.
    //
    
    DebugTraceLevel = *((PULONG)pValueInfo->Data);
    DebugTrace(TRACE_CRITICAL, ("MyDebugInit: Reg-key found. DebugTraceLevel=0x%x.\n", *((PULONG)pValueInfo->Data)));

MyDebugInit_return:

    //
    // Clean up.
    //
    
    if(pValueInfo){
        MyFreePool(pValueInfo);
    }
    
    if(NULL != hDriverRegistry){
        ZwClose(hDriverRegistry);
    }

    DebugTrace(TRACE_PROC_LEAVE,("MyDebugInit: Leaving... Status=0x%x, Ret=VOID.\n", Status));
    return;
}

#if DBG

VOID
MyDumpMemory(
    PUCHAR  pDumpBuffer,
    ULONG   dwSize,
    BOOLEAN bRead
)
{
    NTSTATUS    Status;
    ULONG       ulCounter;
    ULONG       ulMaxSize;

    //
    // Check the flag first.
    //

    if(bRead){
        if(!(DebugTraceLevel & TRACE_FLAG_DUMP_READ)){
            return;
        }
    } else { // if(bRead)
        if(!(DebugTraceLevel & TRACE_FLAG_DUMP_WRITE)){
            return;
        }
    } // if(bRead)

    DebugTrace(TRACE_PROC_ENTER,("MyDebugDump: Enter... \n"));
        
    //
    // Initialize local.
    //
        
    Status          = STATUS_SUCCESS;
    ulCounter       = 0;
    ulMaxSize       = DebugDumpMax;
    
    //
    // Check the arguments.
    //
        
    if(NULL == pDumpBuffer){
        DebugTrace(TRACE_WARNING,("MyDebugDump: WARNING!! pDumpBuffer = NULL \n"));
        Status = STATUS_INVALID_PARAMETER_1;
        goto MyDumpMemory_return;
    }

    if(0 == dwSize){
        DebugTrace(TRACE_STATUS,("MyDebugDump: WARNING!! dwSize = 0 \n"));
        Status = STATUS_INVALID_PARAMETER_2;
        goto MyDumpMemory_return;
    }

    if(bRead){
        DebugTrace(TRACE_ERROR,("MyDebugDump: Received buffer. Size=0x%x.\n", dwSize));
    } else {
        DebugTrace(TRACE_ERROR,("MyDebugDump: Passing buffer. Size=0x%x.\n", dwSize));
    }

/*
    //
    // Probe the buffer.
    //

    try {
        ProbeForRead(pDumpBuffer,
                     dwSize,
                     sizeof(UCHAR));
    } except(EXCEPTION_EXECUTE_HANDLER) {
        Status = GetExceptionCode();
        DebugTrace(TRACE_ERROR,("MyDebugDump: Buffer pointer (0x%x) is invalid. Status=0x%x\n", pDumpBuffer, Status));
        goto MyDumpMemory_return;
    } // except
*/
    //
    // Max dump size = 1k;
    //
    
    ulMaxSize = min(ulMaxSize , dwSize);

    //
    // Dump the buffer.
    //
    
    for(ulCounter = 0; ulCounter < ulMaxSize; ulCounter++){
        if(0 == (ulCounter & 0xfF)){
            DbgPrint("\n");
            DbgPrint(NAME_DRIVER);
            DbgPrint("           +0 +1 +2 +3 +4 +5 +6 +7   +8 +9 +a +b +c +d +e +f\n");
            DbgPrint(NAME_DRIVER);
            DbgPrint("------------------------------------------------------------\n");
        }

        if(0 == (ulCounter & 0xf)){
            DbgPrint(NAME_DRIVER);
            DbgPrint("%p :", pDumpBuffer+ulCounter);
        }

        DbgPrint(" %02x", *(pDumpBuffer+ulCounter));

        if(0x7 == (ulCounter & 0xf)){
            DbgPrint(" -");
        }

        if(0xf == (ulCounter & 0xf)){
            DbgPrint("\n");
        }
    }

    DbgPrint("\n");
    DbgPrint(NAME_DRIVER);
    DbgPrint("------------------------------------------------------------\n\n");

MyDumpMemory_return:
    DebugTrace(TRACE_PROC_LEAVE,("MyDebugDump: Leaving... Status=0x%x, Ret=VOID.\n", Status));
    return;

} // MyDumpMemory(

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\kernel\qv2kux\qv2kux.c ===
//----------------- Original Sig ------------------------
/*++
Copyright (c) 1991-1999  Microsoft Corporation

Module Name:
    fpfilter.c
--*/


#define INITGUID

#include "wdm.h"
#include "stdarg.h"
#include "stdio.h"
#include "usbdi.h"
#include "usbdlib.h"

//
// Bit Flag Macros
//

#define SET_FLAG(Flags, Bit)    ((Flags) |= (Bit))
#define CLEAR_FLAG(Flags, Bit)  ((Flags) &= ~(Bit))
#define TEST_FLAG(Flags, Bit)   (((Flags) & (Bit)) != 0)

//
// Remove lock
//
#define REMLOCK_TAG 'QV2K'
#define REMLOCK_MAXIMUM 1      // Max minutes system allows lock to be held
#define REMLOCK_HIGHWATER 250  // Max number of irps holding lock at one time

//
// Device Extension
//

typedef struct _FDO_EXTENSION {
    ULONG           Signature;
    PDEVICE_OBJECT  Fdo;                    // Back pointer to Fdo
    PDEVICE_OBJECT  Pdo;                    // Not Used
    PDEVICE_OBJECT  Ldo;                    // Lower Device Object
    PDEVICE_OBJECT  PhysicalDeviceObject;   // Not Used
    KEVENT          SyncEvent;              // for ForwardIrpSynchronous
} FDO_EXTENSION, *PFDO_EXTENSION;

#define FDO_EXTENSION_SIZE sizeof(FDO_EXTENSION)


//
// Function declarations
//

NTSTATUS    DriverEntry                 ( IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath);
NTSTATUS    QV2KUX_AddDevice            ( IN PDRIVER_OBJECT DriverObject, IN PDEVICE_OBJECT PhysicalDeviceObject);
VOID        QV2KUX_Unload               ( IN PDRIVER_OBJECT DriverObject );
NTSTATUS    QV2KUX_ForwardIrpSynchronous( IN PDEVICE_OBJECT Fdo, IN PIRP Irp);
NTSTATUS    QV2KUX_DispatchPnp          ( IN PDEVICE_OBJECT Fdo, IN PIRP Irp);
NTSTATUS    QV2KUX_DispatchPower        ( IN PDEVICE_OBJECT Fdo, IN PIRP Irp);
NTSTATUS    QV2KUX_StartDevice          ( IN PDEVICE_OBJECT Fdo, IN PIRP Irp);
NTSTATUS    QV2KUX_RemoveDevice         ( IN PDEVICE_OBJECT Fdo, IN PIRP Irp);
NTSTATUS    QV2KUX_SendToNextDriver     ( IN PDEVICE_OBJECT Fdo, IN PIRP Irp);
NTSTATUS    QV2KUX_Internal_IOCTL       ( IN PDEVICE_OBJECT Fdo, IN PIRP Irp);
NTSTATUS    QV2KUX_IrpCompletion        ( IN PDEVICE_OBJECT Fdo, IN PIRP Irp, IN PVOID Context);
VOID        QV2KUX_SyncFilterWithLdo    ( IN PDEVICE_OBJECT Fdo, IN PDEVICE_OBJECT Ldo);

#if DBG

#define DEBUG_BUFFER_LENGTH 256

ULONG QV2KUX_Debug = 0;
UCHAR QV2KUX_DebugBuffer[DEBUG_BUFFER_LENGTH];

VOID        QV2KUX_DebugPrint( ULONG DebugPrintLevel, PCCHAR DebugMessage, ...);

#define DebugPrint(x)   QV2KUX_DebugPrint x

#else

#define DebugPrint(x)

#endif


NTSTATUS    DriverEntry( IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath)
/*++

Routine Description:
    Gg[|Cg

Arguments:
    DriverObject - The disk performance driver object.
    RegistryPath - pointer to a unicode string representing the path,
                   to driver-specific key in the registry.

Return Value:
    STATUS_SUCCESS

--*/
{

    ULONG               ulIndex;
    PDRIVER_DISPATCH  * dispatch;

    // SoCpX
    for (ulIndex = 0, dispatch = DriverObject->MajorFunction;
         ulIndex <= IRP_MJ_MAXIMUM_FUNCTION;
         ulIndex++, dispatch++) {

        *dispatch = QV2KUX_SendToNextDriver;
    }

    // LX
    DriverObject->MajorFunction[IRP_MJ_POWER]                   = QV2KUX_DispatchPower;
    DriverObject->DriverUnload                                  = QV2KUX_Unload;

    //Kv
    DriverObject->MajorFunction[IRP_MJ_PNP]                     = QV2KUX_DispatchPnp;
    DriverObject->DriverExtension->AddDevice                    = QV2KUX_AddDevice;

    // I
    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = QV2KUX_Internal_IOCTL;
    return(STATUS_SUCCESS);

} // end DriverEntry()

#define FILTER_DEVICE_PROPOGATE_FLAGS            0
#define FILTER_DEVICE_PROPOGATE_CHARACTERISTICS (FILE_REMOVABLE_MEDIA |  \
                                                 FILE_READ_ONLY_DEVICE | \
                                                 FILE_FLOPPY_DISKETTE    \
                                                 )

VOID    QV2KUX_SyncFilterWithLdo( IN PDEVICE_OBJECT Fdo, IN PDEVICE_OBJECT Ldo)
{
    ULONG                   propFlags;

    //
    // Propogate all useful flags from target to QV2KUX_. MountMgr will look
    // at the QV2KUX_ object capabilities to figure out if the disk is
    // a removable and perhaps other things.
    //
    propFlags = Ldo->Flags & FILTER_DEVICE_PROPOGATE_FLAGS;
    SET_FLAG(Fdo->Flags, propFlags);

    propFlags = Ldo->Characteristics & FILTER_DEVICE_PROPOGATE_CHARACTERISTICS;
    SET_FLAG(Fdo->Characteristics, propFlags);
}

NTSTATUS    QV2KUX_AddDevice( IN PDRIVER_OBJECT DriverObject, IN PDEVICE_OBJECT PhysicalDeviceObject)
/*++
Routine Description:
    DeviceObjectDeviceExtension
    vOAPDOFDOgp

Arguments:
    DriverObject - Disk performance driver object.
    PhysicalDeviceObject - Physical Device Object from the underlying layered driver

Return Value:
    NTSTATUS
--*/

{
    NTSTATUS                status;
    PDEVICE_OBJECT          Fdo;
    PFDO_EXTENSION       fdoExtension;
    PIRP                    irp;

    // Create a filter device object for this device (partition).
    DebugPrint((2, "QV2KUX_AddDevice: Driver %p Device %p\n", DriverObject, PhysicalDeviceObject));

    status = IoCreateDevice(DriverObject, FDO_EXTENSION_SIZE, NULL, FILE_DEVICE_BUS_EXTENDER, 0, FALSE, &Fdo);

    if (!NT_SUCCESS(status)) {
       DebugPrint((1, "QV2KUX_AddDevice: Cannot create Fdo\n"));
       return status;
    }

    SET_FLAG(Fdo->Flags, DO_DIRECT_IO);

    fdoExtension = Fdo->DeviceExtension;

    RtlZeroMemory(fdoExtension, FDO_EXTENSION_SIZE);
    fdoExtension->Signature = 'QV2K';
    fdoExtension->Fdo = Fdo;
    fdoExtension->PhysicalDeviceObject = PhysicalDeviceObject;

    // hCo
    fdoExtension->Ldo = IoAttachDeviceToDeviceStack(Fdo, PhysicalDeviceObject);

    if (fdoExtension->Ldo == NULL) {
        IoDeleteDevice(Fdo);
        DebugPrint((1, "QV2KUX_AddDevice: Unable to attach %X to target %X\n", Fdo, PhysicalDeviceObject));
        return STATUS_NO_SUCH_DEVICE;
    }

    // ForwardIrpSynchronousgp
    KeInitializeEvent(&fdoExtension->SyncEvent,  NotificationEvent, FALSE);

    // default to DO_POWER_PAGABLE
    SET_FLAG(Fdo->Flags,  DO_POWER_PAGABLE);

    // Clear the DO_DEVICE_INITIALIZING flag
    CLEAR_FLAG(Fdo->Flags, DO_DEVICE_INITIALIZING);

    return STATUS_SUCCESS;

} // end QV2KUX_AddDevice()


NTSTATUS    QV2KUX_DispatchPnp(IN PDEVICE_OBJECT Fdo, IN PIRP Irp)
/*++

Routine Description:
    Dispatch for PNP

Arguments:
    Fdo    - Supplies the device object.
    Irp    - Supplies the I/O request packet.

Return Value:
    NTSTATUS

--*/

{
    PIO_STACK_LOCATION  irpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS            status;
    PFDO_EXTENSION   fdoExtension = Fdo->DeviceExtension;
    BOOLEAN lockHeld;
    BOOLEAN irpCompleted;

    DebugPrint((2, "QV2KUX_DispatchPnp: Device %X Irp %X\n", Fdo, Irp));

    irpCompleted = FALSE;

    switch(irpSp->MinorFunction) {
        case IRP_MN_START_DEVICE:   status = QV2KUX_StartDevice(Fdo, Irp); break;
        case IRP_MN_REMOVE_DEVICE:  status = QV2KUX_RemoveDevice(Fdo, Irp); break;
        default:  status = QV2KUX_SendToNextDriver(Fdo, Irp); irpCompleted = TRUE; break;
    }

    if (! irpCompleted) {
        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    return status;

} // end QV2KUX_DispatchPnp()


NTSTATUS    QV2KUX_IrpCompletion( IN PDEVICE_OBJECT Fdo, IN PIRP Irp, IN PVOID Context)
/*++

Routine Description:

    Forwarded IRP completion routine. Set an event and return
    STATUS_MORE_PROCESSING_REQUIRED. Irp forwarder will wait on this
    event and then re-complete the irp after cleaning up.

Arguments:
    Fdo is the device object of the WMI driver
    Irp is the WMI irp that was just completed
    Context is a PKEVENT that forwarder will wait on

Return Value:

    STATUS_MORE_PORCESSING_REQUIRED

--*/

{
    PKEVENT Event = (PKEVENT) Context;

    UNREFERENCED_PARAMETER(Fdo);
    UNREFERENCED_PARAMETER(Irp);

    KeSetEvent(Event, IO_NO_INCREMENT, FALSE);

    // IrpgACompletionm
    return(STATUS_MORE_PROCESSING_REQUIRED);

} // end QV2KUX_IrpCompletion()


NTSTATUS    QV2KUX_StartDevice( IN PDEVICE_OBJECT Fdo, IN PIRP Irp)
/*++

Routine Description:
    This routine is called when a Pnp Start Irp is received.
    It will schedule a completion routine to initialize and register with WMI.

Arguments:
    Fdo - a pointer to the device object
    Irp - a pointer to the irp

Return Value:
    Status of processing the Start Irp

--*/
{
    PFDO_EXTENSION   fdoExtension = Fdo->DeviceExtension;
    KEVENT              event;
    NTSTATUS            status;

    status = QV2KUX_ForwardIrpSynchronous(Fdo, Irp);
    QV2KUX_SyncFilterWithLdo(Fdo, fdoExtension->Ldo);
    return status;
}


NTSTATUS    QV2KUX_RemoveDevice( IN PDEVICE_OBJECT Fdo, IN PIRP Irp)
/*++

Routine Description:
    This routine is called when the device is to be removed.
    It will de-register itself from WMI first, detach itself from the
    stack before deleting itself.

Arguments:
    Fdo - a pointer to the device object
    Irp - a pointer to the irp

Return Value:
    Status of removing the device

--*/
{
    NTSTATUS            status;
    PFDO_EXTENSION   fdoExtension = Fdo->DeviceExtension;

    status = QV2KUX_ForwardIrpSynchronous(Fdo, Irp);

    IoDetachDevice(fdoExtension->Ldo);
    IoDeleteDevice(Fdo);

    return status;
}


NTSTATUS    QV2KUX_SendToNextDriver( IN PDEVICE_OBJECT Fdo, IN PIRP Irp)
/*++

Routine Description:
    This routine sends the Irp to the next driver in line
    when the Irp is not processed by this driver.

Arguments:
    Fdo
    Irp

Return Value:
    NTSTATUS

--*/
{
    PFDO_EXTENSION   fdoExtension = Fdo->DeviceExtension;

    IoSkipCurrentIrpStackLocation(Irp);
    return IoCallDriver(fdoExtension->Ldo, Irp);

} // end QV2KUX_SendToNextDriver()


NTSTATUS    QV2KUX_DispatchPower( IN PDEVICE_OBJECT Fdo, IN PIRP Irp)
{
    PFDO_EXTENSION fdoExtension = Fdo->DeviceExtension;

    PoStartNextPowerIrp(Irp);
    IoSkipCurrentIrpStackLocation(Irp);

    return PoCallDriver(fdoExtension->Ldo, Irp);

} // end QV2KUX_DispatchPower


NTSTATUS    QV2KUX_ForwardIrpSynchronous( IN PDEVICE_OBJECT Fdo, IN PIRP Irp)
/*++

Routine Description:
    This routine sends the Irp to the next driver in line
    when the Irp needs to be processed by the lower drivers
    prior to being processed by this one.

Arguments:
    Fdo
    Irp

Return Value:
    NTSTATUS

--*/
{
    PFDO_EXTENSION   fdoExtension = Fdo->DeviceExtension;
    NTSTATUS status;

    //CxgNA
    KeClearEvent(&fdoExtension->SyncEvent);
    //IrpStackRs[
    IoCopyCurrentIrpStackLocationToNext(Irp);
    // IrpCompletion
    IoSetCompletionRoutine(Irp, QV2KUX_IrpCompletion, &fdoExtension->SyncEvent, TRUE, TRUE, TRUE);

    // call the next lower device
    status = IoCallDriver(fdoExtension->Ldo, Irp);

    // wait for the actual completion
    if (status == STATUS_PENDING) {
        KeWaitForSingleObject(&fdoExtension->SyncEvent, Executive, KernelMode, FALSE, NULL);
        status = Irp->IoStatus.Status;
    }

    return status;

} // end QV2KUX_ForwardIrpSynchronous()



VOID    QV2KUX_Unload( IN PDRIVER_OBJECT DriverObject)
/*++
Routine Description:
    Free all the allocated resources, etc.

Arguments:
    DriverObject - pointer to a driver object.

Return Value:
    VOID.

--*/
{
    return;
}

NTSTATUS    QV2KUX_Internal_IOCTL(IN PDEVICE_OBJECT Fdo, IN PIRP Irp)
{
    PFDO_EXTENSION  fdoExtension = Fdo->DeviceExtension;

    NTSTATUS            ntStatus;
    PIO_STACK_LOCATION  IrpSp;
    PURB        urb;
    PUCHAR      IoBuffer;
    USHORT      length;
    UCHAR       subclass;

    if (fdoExtension->Signature != 'QV2K') return QV2KUX_SendToNextDriver(Fdo,Irp);

    IrpSp = IoGetCurrentIrpStackLocation(Irp);
    urb = IrpSp->Parameters.Others.Argument1;
    if (!urb) return QV2KUX_SendToNextDriver(Fdo,Irp);
    if (urb->UrbHeader.Function != URB_FUNCTION_GET_DESCRIPTOR_FROM_DEVICE) 
        return QV2KUX_SendToNextDriver(Fdo,Irp);
    // P USB_DEVICE_DESCRIPTOR_TYPE Length = 0x12;
    // Q USB_CONFIGURATION_DESCRIPTOR_TYPE LENGHT = 0x9
    // R USB_CONFIGURATION_DESCRIPTOR_TYPE LENGHT = interface,endpoint descriptor
    if (urb->UrbControlDescriptorRequest.TransferBufferLength <= 0x12)
        return QV2KUX_SendToNextDriver(Fdo,Irp);
    // R
    DebugPrint((0,"URB Get All of Configuration Descriptor \n"));

    ntStatus = QV2KUX_ForwardIrpSynchronous(Fdo,Irp);

    if (NT_SUCCESS(ntStatus)) {
        IoBuffer = (UCHAR *)urb->UrbControlDescriptorRequest.TransferBuffer;
        length = (USHORT)urb->UrbControlDescriptorRequest.TransferBufferLength;
        while(length >= 9) {
            //InterfaceDescriptor
            if (*(IoBuffer+1) == 4) {
                subclass = *(IoBuffer+6);
                DebugPrint((0,"QV2K_IntIoctl: SubCrass = %d \n",subclass));
                if (*(IoBuffer+6) == 6) *(IoBuffer+6) = 5;
            }
            length -= *IoBuffer;
            IoBuffer += *IoBuffer;
        }
    }
    IoCompleteRequest(Irp,IO_NO_INCREMENT);
    return ntStatus;
}

#if DBG

VOID
QV2KUX_DebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )

/*++

Routine Description:
    Debug print for all QV2KUX_

Arguments:
    Debug print level between 0 and 3, with 3 being the most verbose.

Return Value:
    None

--*/

{
    va_list ap;

    va_start(ap, DebugMessage);


    if ((DebugPrintLevel <= (QV2KUX_Debug & 0x0000ffff)) ||
        ((1 << (DebugPrintLevel + 15)) & QV2KUX_Debug)) {

        _vsnprintf(QV2KUX_DebugBuffer, DEBUG_BUFFER_LENGTH, DebugMessage, ap);

        DbgPrint(QV2KUX_DebugBuffer);
    }

    va_end(ap);

}
#endif


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\kernel\scsiscan\class.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:
    class.c

Abstract:
    Contains a subset of routines in classpnp.sys.

Author:
    Ray Patrick (raypat)

Environment:
    kernel mode only

Notes:

Revision History:

--*/
#include <stdio.h>
#include "stddef.h"
#include "wdm.h"
#include "scsi.h"
#include "ntddstor.h"
#include "ntddscsi.h"
#include "scsiscan.h"
#include "private.h"
#include "debug.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, ClassGetDescriptor)
#pragma alloc_text(PAGE, ClassGetInfo)
#endif

NTSTATUS
ClassGetDescriptor(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PSTORAGE_PROPERTY_ID pPropertyId,
    OUT PSTORAGE_DESCRIPTOR_HEADER *pDescriptor
    )
/*++

Routine Description:
    This routine will perform a query for the specified property id and will
    allocate a non-paged buffer to store the data in.  It is the responsibility
    of the caller to ensure that this buffer is freed.

    This routine must be run at IRQL_PASSIVE_LEVEL

Arguments:
    pDeviceObject - the device to query
    pDescriptor   - a location to store a pointer to the buffer we allocate

Return Value:
    Status
    if status is unsuccessful *DeviceInfo will be set to 0

--*/
{
    PIRP                       pIrp;
    PKEVENT                    pEvent = NULL;
    STORAGE_PROPERTY_QUERY     Query;
    ULONG                      Buffer[2];
    PSTORAGE_DESCRIPTOR_HEADER pLocalDescriptor = NULL;
    ULONG                      Length;
    IO_STATUS_BLOCK            StatusBlock;
    NTSTATUS                   Status;
    UCHAR                      Pass;

    //
    // Set the descriptor pointer to NULL and
    // Initialize the event we're going to wait on.
    //

    *pDescriptor = NULL;
    pEvent = MyAllocatePool(NonPagedPool, sizeof(KEVENT));

    if(pEvent == NULL) {
        DebugTrace(MAX_TRACE,("ClassGetDescriptor: Unable to allocate event\n"));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        return Status;
    }
    KeInitializeEvent(pEvent, SynchronizationEvent, FALSE);

    Pass = 0;

    __try {

        //
        // Retrieve the property page
        //

        do {

            RtlZeroMemory(&Query, sizeof(STORAGE_PROPERTY_QUERY));
            Query.PropertyId = *pPropertyId;
            Query.QueryType = PropertyStandardQuery;

            switch( Pass ) {
                case 0:

                    //
                    // On the first pass we just want to get the first few
                    // bytes of the descriptor so we can read it's size
                    //

                    pLocalDescriptor = (PVOID) &Buffer[0];
                    Length = sizeof(ULONG) * 2;
                    break;

                case 1:

                    //
                    // This time we know how much data there is so we can
                    // allocate a buffer of the correct size
                    //

                    Length = ((PSTORAGE_DESCRIPTOR_HEADER) pLocalDescriptor)->Size;
                    pLocalDescriptor = MyAllocatePool(NonPagedPool, Length);
                    if (pLocalDescriptor == NULL) {
                        Status = STATUS_INSUFFICIENT_RESOURCES;
                        DebugTrace(MAX_TRACE,
                                         ("ClassGetDescriptor: unable to get memory for descriptor (%d bytes)\n",
                                          Length));
                        __leave;
                    }
                    break;
            }

            //
            // Build the query irp and wait for it to complete (if necessary)
            //

            pIrp = IoBuildDeviceIoControlRequest(
                IOCTL_STORAGE_QUERY_PROPERTY,
                pDeviceObject,
                &Query,
                sizeof(STORAGE_PROPERTY_QUERY),
                pLocalDescriptor,
                Length,
                FALSE,
                pEvent,
                &StatusBlock);

            if (pIrp == NULL) {
                DebugTrace(MAX_TRACE,("ClassGetDescriptor: unable to allocate irp\n"));
                Status = STATUS_INSUFFICIENT_RESOURCES;
                __leave;
            }

            Status = IoCallDriver(pDeviceObject, pIrp);

            if (Status == STATUS_PENDING) {
                KeWaitForSingleObject(pEvent,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      NULL);

                Status = StatusBlock.Status;
            }

            if (!NT_SUCCESS(Status)) {
                DebugTrace(MAX_TRACE,
                                 ("ClassGetDescriptor: error %#08lx trying to query properties\n",
                                  Status));
                __leave;
            }

        } while (Pass++ != 1);

    } __finally {

        MyFreePool(pEvent);

        if(NT_SUCCESS(Status)){
            *pDescriptor = pLocalDescriptor;
        } else {
            if( (Pass != 0)
             && (NULL != pLocalDescriptor) )
            {
                MyFreePool(pLocalDescriptor);
                pLocalDescriptor = NULL;
            }
        } // if(NT_SUCCESS(Status))
    }
    return Status;
}


BOOLEAN
ClassInterpretSenseInfo(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PSRB pSrb,
    IN UCHAR MajorFunctionCode,
    IN ULONG IoDeviceCode,
    IN ULONG RetryCount,
    OUT NTSTATUS *Status
    )
/*++

Routine Description:
    This routine interprets the data returned from the SCSI
    request sense. It determines the status to return in the
    IRP and whether this request can be retried.

Arguments:
    pDeviceObject - Supplies the device object associated with this request.
    pSrb - Supplies the scsi request block which failed.
    MajorFunctionCode - Supplies the function code to be used for logging.
    IoDeviceCode - Supplies the device code to be used for logging.
    Status - Returns the status for the request.

Return Value:
    BOOLEAN TRUE: Drivers should retry this request.
            FALSE: Drivers should not retry this request.

--*/
{
    PSCSISCAN_DEVICE_EXTENSION      pde;
    PSENSE_DATA                     pSenseBuffer;
    BOOLEAN                         Retry;
    BOOLEAN                         LogError;
    ULONG                           BadSector;
    ULONG                           UniqueId;
    NTSTATUS                        LogStatus;
    ULONG                           ReadSector;
    ULONG                           Index;
    PIO_ERROR_LOG_PACKET            pErrorLogEntry;

    pde = (PSCSISCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;
    pSenseBuffer = pSrb -> SenseInfoBuffer;
    Retry = TRUE;
    LogError = FALSE;
    BadSector = 0;

    //
    // Check that request sense buffer is valid.
    //

    if (pSrb -> SrbStatus & SRB_STATUS_AUTOSENSE_VALID &&
        pSrb -> SenseInfoBufferLength >= offsetof(SENSE_DATA, CommandSpecificInformation)) {
        DebugTrace(MAX_TRACE,("ScsiScannerInterpretSenseInfo: Error code is %x\n",
                                    pSenseBuffer -> ErrorCode));
        DebugTrace(MAX_TRACE,("ScsiScannerInterpretSenseInfo: Sense key is %x\n",
                                    pSenseBuffer -> SenseKey));
        DebugTrace(MAX_TRACE,( "ScsiScannerInterpretSenseInfo: Additional sense code is %x\n",
                                     pSenseBuffer -> AdditionalSenseCode));
        DebugTrace(MAX_TRACE,( "ScsiScannerInterpretSenseInfo: Additional sense code qualifier is %x\n",
                                     pSenseBuffer -> AdditionalSenseCodeQualifier));

        //
        // Zero the additional sense code and additional sense code qualifier
        // if they were not returned by the device.
        //

        ReadSector = pSenseBuffer -> AdditionalSenseLength +
            offsetof(SENSE_DATA, AdditionalSenseLength);

        if (ReadSector > pSrb -> SenseInfoBufferLength) {
            ReadSector = pSrb -> SenseInfoBufferLength;
        }

        if (ReadSector <= offsetof(SENSE_DATA, AdditionalSenseCode)) {
            pSenseBuffer -> AdditionalSenseCode = 0;
        }

        if (ReadSector <= offsetof(SENSE_DATA, AdditionalSenseCodeQualifier)) {
            pSenseBuffer -> AdditionalSenseCodeQualifier = 0;
        }

        switch (pSenseBuffer -> SenseKey & 0xf) {

            case SCSI_SENSE_NOT_READY:
                DebugTrace(MAX_TRACE,("ScsiScannerInterpretSenseInfo: Device not ready\n"));
                *Status = STATUS_DEVICE_NOT_READY;

                switch (pSenseBuffer -> AdditionalSenseCode) {

                    case SCSI_ADSENSE_LUN_NOT_READY:
                        DebugTrace(MAX_TRACE,("ScsiScannerInterpretSenseInfo: Lun not ready\n"));

                        switch (pSenseBuffer -> AdditionalSenseCodeQualifier) {
                            case SCSI_SENSEQ_BECOMING_READY:

                                DebugTrace(MAX_TRACE,( "ScsiScannerInterpretSenseInfo:"
                                    " In process of becoming ready\n"));
                                break;

                            case SCSI_SENSEQ_MANUAL_INTERVENTION_REQUIRED:
                                DebugTrace(MAX_TRACE,( "ScsiScannerInterpretSenseInfo:"
                                    " Manual intervention required\n"));
                                *Status = STATUS_NO_MEDIA_IN_DEVICE;
                                Retry = FALSE;
                                break;

                            case SCSI_SENSEQ_FORMAT_IN_PROGRESS:
                                DebugTrace(MAX_TRACE,( "ScsiScannerInterpretSenseInfo: Format in progress\n"));
                                Retry = FALSE;
                                break;

                            case SCSI_SENSEQ_INIT_COMMAND_REQUIRED:

                            default:
                                DebugTrace(MAX_TRACE,( "ScsiScannerInterpretSenseInfo:"
                                    " Initializing command required\n"));
                                break;

                        } // end switch (pSenseBuffer -> AdditionalSenseCodeQualifier)
                        break;

                    case SCSI_ADSENSE_NO_MEDIA_IN_DEVICE:
                        DebugTrace(MAX_TRACE,(
                            "ScsiScannerInterpretSenseInfo:"
                            " No Media in device.\n"));
                        *Status = STATUS_NO_MEDIA_IN_DEVICE;
                        Retry = FALSE;
                        break;

                } // end switch (pSenseBuffer -> AdditionalSenseCode)
                break;

        case SCSI_SENSE_DATA_PROTECT:
            DebugTrace(MAX_TRACE,("ScsiScannerInterpretSenseInfo: Media write protected\n"));
            *Status = STATUS_MEDIA_WRITE_PROTECTED;
            Retry = FALSE;
            break;

        case SCSI_SENSE_MEDIUM_ERROR:
            DebugTrace(MAX_TRACE,("ScsiScannerInterpretSenseInfo: Bad media\n"));
            *Status = STATUS_DEVICE_DATA_ERROR;
            Retry = FALSE;
            LogError = TRUE;
            UniqueId = 256;
            LogStatus = IO_ERR_BAD_BLOCK;
            break;

        case SCSI_SENSE_HARDWARE_ERROR:
            DebugTrace(MAX_TRACE,("ScsiScannerInterpretSenseInfo: Hardware error\n"));
            *Status = STATUS_IO_DEVICE_ERROR;
            LogError = TRUE;
            UniqueId = 257;
            LogStatus = IO_ERR_CONTROLLER_ERROR;
            break;

        case SCSI_SENSE_ILLEGAL_REQUEST:
            DebugTrace(MAX_TRACE,("ScsiScannerInterpretSenseInfo: Illegal SCSI request\n"));
            *Status = STATUS_INVALID_DEVICE_REQUEST;
            switch (pSenseBuffer -> AdditionalSenseCode) {

                case SCSI_ADSENSE_ILLEGAL_COMMAND:
                    DebugTrace(MAX_TRACE,("ScsiScannerInterpretSenseInfo: Illegal command\n"));
                    Retry = FALSE;
                    break;

                case SCSI_ADSENSE_ILLEGAL_BLOCK:
                    DebugTrace(MAX_TRACE,("ScsiScannerInterpretSenseInfo: Illegal block address\n"));
                    *Status = STATUS_NONEXISTENT_SECTOR;
                    Retry = FALSE;
                    break;

                case SCSI_ADSENSE_INVALID_LUN:
                    DebugTrace(MAX_TRACE,("ScsiScannerInterpretSenseInfo: Invalid LUN\n"));
                    *Status = STATUS_NO_SUCH_DEVICE;
                    Retry = FALSE;
                    break;

                case SCSI_ADSENSE_MUSIC_AREA:
                    DebugTrace(MAX_TRACE,("ScsiScannerInterpretSenseInfo: Music area\n"));
                    Retry = FALSE;
                    break;

                case SCSI_ADSENSE_DATA_AREA:
                    DebugTrace(MAX_TRACE,("ScsiScannerInterpretSenseInfo: Data area\n"));
                    Retry = FALSE;
                    break;

                case SCSI_ADSENSE_VOLUME_OVERFLOW:
                    DebugTrace(MAX_TRACE,("ScsiScannerInterpretSenseInfo: Volume overflow\n"));
                    Retry = FALSE;
                    break;

                case SCSI_ADSENSE_INVALID_CDB:
                    DebugTrace(MAX_TRACE,("ScsiScannerInterpretSenseInfo: Invalid CDB\n"));
                    Retry = FALSE;
                    break;

            } // end switch (pSenseBuffer -> AdditionalSenseCode)
            break;

        case SCSI_SENSE_UNIT_ATTENTION:
            switch (pSenseBuffer -> AdditionalSenseCode) {
                case SCSI_ADSENSE_MEDIUM_CHANGED:
                    DebugTrace(MAX_TRACE,("ScsiScannerInterpretSenseInfo: Media changed\n"));
                    break;

                case SCSI_ADSENSE_BUS_RESET:
                    DebugTrace(MAX_TRACE,("ScsiScannerInterpretSenseInfo: Bus reset\n"));
                    break;

                default:
                    DebugTrace(MAX_TRACE,("ScsiScannerInterpretSenseInfo: Unit attention\n"));
                    break;

            } // end  switch (pSenseBuffer -> AdditionalSenseCode)
            *Status = STATUS_IO_DEVICE_ERROR;
            break;

        case SCSI_SENSE_ABORTED_COMMAND:
            DebugTrace(MAX_TRACE,("ScsiScannerInterpretSenseInfo: Command aborted\n"));
            *Status = STATUS_IO_DEVICE_ERROR;
            break;

       case SCSI_SENSE_RECOVERED_ERROR:
            DebugTrace(MAX_TRACE,("ScsiScannerInterpretSenseInfo: Recovered error\n"));
            *Status = STATUS_SUCCESS;
            Retry = FALSE;
            LogError = TRUE;
            UniqueId = 258;

            switch(pSenseBuffer -> AdditionalSenseCode) {
                case SCSI_ADSENSE_SEEK_ERROR:
                case SCSI_ADSENSE_TRACK_ERROR:
                    LogStatus = IO_ERR_SEEK_ERROR;
                    break;

                case SCSI_ADSENSE_REC_DATA_NOECC:
                case SCSI_ADSENSE_REC_DATA_ECC:
                    LogStatus = IO_RECOVERED_VIA_ECC;
                    break;

                default:
                    LogStatus = IO_ERR_CONTROLLER_ERROR;
                    break;

            } // end switch(pSenseBuffer -> AdditionalSenseCode)

            if (pSenseBuffer -> IncorrectLength) {
                DebugTrace(MAX_TRACE,("ScsiScannerInterpretSenseInfo: Incorrect length detected.\n"));
                *Status = STATUS_INVALID_BLOCK_LENGTH ;
            }
            break;

        case SCSI_SENSE_NO_SENSE:

            //
            // Check other indicators.
            //

            if (pSenseBuffer -> IncorrectLength) {
                DebugTrace(MAX_TRACE,("ScsiScannerInterpretSenseInfo: Incorrect length detected.\n"));
                *Status = STATUS_INVALID_BLOCK_LENGTH ;
                Retry   = FALSE;
            } else {
                DebugTrace(MAX_TRACE,("ScsiScannerInterpretSenseInfo: No specific sense key\n"));
                *Status = STATUS_IO_DEVICE_ERROR;
                Retry   = TRUE;
            }
            break;

        default:
            DebugTrace(MAX_TRACE,("ScsiScannerInterpretSenseInfo: Unrecognized sense code\n"));
            *Status = STATUS_IO_DEVICE_ERROR;
            break;

        } // end switch (pSenseBuffer -> SenseKey & 0xf)

        //
        // Try to determine the bad sector from the inquiry data.
        //

        if ((((PCDB)pSrb -> Cdb) -> CDB10.OperationCode == SCSIOP_READ ||
            ((PCDB)pSrb -> Cdb) -> CDB10.OperationCode == SCSIOP_VERIFY ||
            ((PCDB)pSrb -> Cdb) -> CDB10.OperationCode == SCSIOP_WRITE)) {

            for (Index = 0; Index < 4; Index++) {
                BadSector = (BadSector << 8) | pSenseBuffer -> Information[Index];
            }

            ReadSector = 0;
            for (Index = 0; Index < 4; Index++) {
                ReadSector = (ReadSector << 8) | pSrb -> Cdb[Index+2];
            }

            Index = (((PCDB)pSrb -> Cdb) -> CDB10.TransferBlocksMsb << 8) |
                ((PCDB)pSrb -> Cdb) -> CDB10.TransferBlocksLsb;

            //
            // Make sure the bad sector is within the read sectors.
            //

            if (!(BadSector >= ReadSector && BadSector < ReadSector + Index)) {
                BadSector = ReadSector;
            }
        }

    } else {

        //
        // Request sense buffer not valid. No sense information
        // to pinpoint the error. Return general request fail.
        //

        DebugTrace(MAX_TRACE,("ScsiScannerInterpretSenseInfo: Request sense info not valid. SrbStatus %2x\n",
                    SRB_STATUS(pSrb -> SrbStatus)));
        Retry = TRUE;

        switch (SRB_STATUS(pSrb -> SrbStatus)) {
        case SRB_STATUS_INVALID_LUN:
        case SRB_STATUS_INVALID_TARGET_ID:
        case SRB_STATUS_NO_DEVICE:
        case SRB_STATUS_NO_HBA:
        case SRB_STATUS_INVALID_PATH_ID:
            *Status = STATUS_NO_SUCH_DEVICE;
            Retry = FALSE;
            break;

        case SRB_STATUS_COMMAND_TIMEOUT:
        case SRB_STATUS_ABORTED:
        case SRB_STATUS_TIMEOUT:

            //
            // Update the error count for the device.
            //

            pde -> ErrorCount++;
            *Status = STATUS_IO_TIMEOUT;
            break;

       case SRB_STATUS_SELECTION_TIMEOUT:

           //
           // Avoid reporting too much if device seems to be not connected
           //
           if (pde->LastSrbError != SRB_STATUS_SELECTION_TIMEOUT) {
               LogError = TRUE;
           }

            LogStatus = IO_ERR_NOT_READY;
            UniqueId = 260;
            *Status = STATUS_DEVICE_NOT_CONNECTED;
            Retry = FALSE;
            break;

        case SRB_STATUS_DATA_OVERRUN:
            *Status = STATUS_DATA_OVERRUN;
            Retry = FALSE;
            break;

        case SRB_STATUS_PHASE_SEQUENCE_FAILURE:

            //
            // Update the error count for the device.
            //

            pde -> ErrorCount++;
            *Status = STATUS_IO_DEVICE_ERROR;

            //
            // If there was phase sequence error then limit the number of
            // retries.
            //

            if (RetryCount > 1 ) {
                Retry = FALSE;
            }
            break;

        case SRB_STATUS_REQUEST_FLUSHED:
            *Status = STATUS_IO_DEVICE_ERROR;
            break;

        case SRB_STATUS_INVALID_REQUEST:

            //
            // An invalid request was attempted.
            //

            *Status = STATUS_INVALID_DEVICE_REQUEST;
            Retry = FALSE;
            break;

        case SRB_STATUS_UNEXPECTED_BUS_FREE:
        case SRB_STATUS_PARITY_ERROR:

            //
            // Update the error count for the device.
            //

            pde -> ErrorCount++;

            //
            // Fall through to below.
            //

        case SRB_STATUS_BUS_RESET:
            *Status = STATUS_IO_DEVICE_ERROR;
            break;

        case SRB_STATUS_ERROR:
            *Status = STATUS_IO_DEVICE_ERROR;
            if (pSrb -> ScsiStatus == 0) {

                //
                // This is some strange return code.  Update the error
                // count for the device.
                //

                pde -> ErrorCount++;
            }

            if (pSrb -> ScsiStatus == SCSISTAT_BUSY) {
                *Status = STATUS_DEVICE_NOT_READY;
            }

            if (pSrb -> ScsiStatus == SCSISTAT_RESERVATION_CONFLICT) {
                *Status = STATUS_DEVICE_BUSY;
                Retry = FALSE;
            }
            break;

        default:
            LogError = TRUE;
            LogStatus = IO_ERR_CONTROLLER_ERROR;
            UniqueId = 259;
            *Status = STATUS_IO_DEVICE_ERROR;
            break;

        }

        //
        // If the error count has exceeded the error limit, then disable
        // any tagged queuing, multiple requests per lu queueing
        // and sychronous data transfers.
        //

        if (pde -> ErrorCount == 4) {

            //
            // Clearing the no queue freeze flag prevents the port driver
            // from sending multiple requests per logical unit.
            //

            pde -> SrbFlags &= ~(SRB_FLAGS_QUEUE_ACTION_ENABLE |
                               SRB_FLAGS_NO_QUEUE_FREEZE);

            pde -> SrbFlags |= SRB_FLAGS_DISABLE_SYNCH_TRANSFER;
            DebugTrace(MAX_TRACE,( "ScsiScannerInterpretSenseInfo: Too many errors disabling tagged queuing and synchronous data tranfers.\n"));

        } else if (pde -> ErrorCount == 8) {

            //
            // If a second threshold is reached, disable disconnects.
            //

            //pde -> SrbFlags |= SRB_FLAGS_DISABLE_DISCONNECT;
            DebugTrace(MAX_TRACE,( "ScsiScannerInterpretSenseInfo: Too many errors disabling disconnects.\n"));
        }
    }

    //
    // Log an error if necessary.
    //
    pde->LastSrbError = SRB_STATUS(pSrb -> SrbStatus);

    if (LogError) {
        pErrorLogEntry = (PIO_ERROR_LOG_PACKET)IoAllocateErrorLogEntry(
            pDeviceObject,
            sizeof(IO_ERROR_LOG_PACKET) + 5 * sizeof(ULONG));

        if (NULL == pErrorLogEntry) {

            //
            // Return if no packet could be allocated.
            //

            return Retry;

        }

        if (Retry && RetryCount < MAXIMUM_RETRIES) {
            pErrorLogEntry -> FinalStatus = STATUS_SUCCESS;
        } else {
            pErrorLogEntry -> FinalStatus = *Status;
        }

        //
        // Calculate the device offset if there is a geometry.
        //

        pErrorLogEntry -> ErrorCode = LogStatus;
        pErrorLogEntry -> SequenceNumber = 0;
        pErrorLogEntry -> MajorFunctionCode = MajorFunctionCode;
        pErrorLogEntry -> IoControlCode = IoDeviceCode;
        pErrorLogEntry -> RetryCount = (UCHAR) RetryCount;
        pErrorLogEntry -> UniqueErrorValue = UniqueId;
        pErrorLogEntry -> DumpDataSize = 6 * sizeof(ULONG);
        pErrorLogEntry -> DumpData[0] = pSrb -> PathId;
        pErrorLogEntry -> DumpData[1] = pSrb -> TargetId;
        pErrorLogEntry -> DumpData[2] = pSrb -> Lun;
        pErrorLogEntry -> DumpData[3] = 0;
        pErrorLogEntry -> DumpData[4] = pSrb -> SrbStatus << 8 | pSrb -> ScsiStatus;

        if (pSenseBuffer != NULL) {
            pErrorLogEntry -> DumpData[5] = pSenseBuffer -> SenseKey << 16 |
                                     pSenseBuffer -> AdditionalSenseCode << 8 |
                                     pSenseBuffer -> AdditionalSenseCodeQualifier;

        }
        //
        // Write the error log packet.
        //

        IoWriteErrorLogEntry(pErrorLogEntry);
    }

    return Retry;

} // end ScsiScannerInterpretSenseInfo()



VOID
ClassReleaseQueue(
    IN PDEVICE_OBJECT pDeviceObject
    )

/*++

Routine Description:
    This routine issues an internal device control command
    to the port driver to release a frozen queue. The call
    is issued asynchronously as ClassReleaseQueue will be invoked
    from the IO completion DPC (and will have no context to
    wait for a synchronous call to complete).

Arguments:
    pDeviceObject - The functional device object for the device with the frozen queue.

Return Value:
    None.

--*/
{
    PIO_STACK_LOCATION              pIrpStack;
    PIRP                            pIrp;
    PSCSISCAN_DEVICE_EXTENSION      pde;
    PCOMPLETION_CONTEXT             pContext;
    PSCSI_REQUEST_BLOCK             pSrb;
    KIRQL                           CurrentIrql;


    DebugTrace(MAX_TRACE,("Release Queue \n"));

    //
    // Get our device extension.
    //

    pde = (PSCSISCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;

    //
    // Allocate context from nonpaged pool.
    //

    pContext = MyAllocatePool(NonPagedPool,
                               sizeof(COMPLETION_CONTEXT));
    if(NULL == pContext){
        DebugTrace(MAX_TRACE,("ClassReleaseQueue: ERROR!! Couldn't allocate context memory.\n"));
        goto ClassReleaseQueue_return;
    } // if(NULL == pContext)
    pContext -> Signature = 'pmoC';

    //
    // Save the device object in the context for use by the completion
    // routine.
    //

    pContext->pDeviceObject = pDeviceObject;
    pSrb = &(pContext->Srb);

    //
    // Zero out srb.
    //

    RtlZeroMemory(pSrb, SCSI_REQUEST_BLOCK_SIZE);

    //
    // Write length to SRB.
    //

    pSrb->Length = SCSI_REQUEST_BLOCK_SIZE;

    //
    // specify release queue command.
    //

    pSrb->Function = SRB_FUNCTION_RELEASE_QUEUE;

    //
    // Build the asynchronous request to be sent to the port driver.
    //

    pIrp = IoAllocateIrp(pDeviceObject->StackSize, FALSE);

    if (pIrp != NULL ) {

        IoSetCompletionRoutine(pIrp,
                               (PIO_COMPLETION_ROUTINE)ClassAsynchronousCompletion,
                               pContext,
                               TRUE,
                               TRUE,
                               TRUE);

        pIrpStack = IoGetNextIrpStackLocation(pIrp);

        pIrpStack->MajorFunction = IRP_MJ_SCSI;

        pSrb->OriginalRequest = pIrp;

        //
        // Store the SRB address in next stack for port driver.
        //

        pIrpStack->Parameters.Scsi.Srb = pSrb;

        //
        // Since this routine can cause outstanding requests to be completed, and
        // calling a completion routine at < DISPATCH_LEVEL is dangerous (if they
        // call IoStartNextPacket we will bugcheck) raise up to dispatch level before
        // issuing the request
        //

        CurrentIrql = KeGetCurrentIrql();

        if(CurrentIrql < DISPATCH_LEVEL) {
            KeRaiseIrql(DISPATCH_LEVEL, &CurrentIrql);
            IoCallDriver(pde->pStackDeviceObject, pIrp);
            KeLowerIrql(CurrentIrql);
        } else {
            IoCallDriver(pde->pStackDeviceObject, pIrp);
        }

    }
    else {

        DebugTrace(MAX_TRACE,("ScsiScanner Couldn't allocate IRP \n"));

        //
        // Free context if we are bailing out
        //
        if (pContext) {
            MyFreePool(pContext);
            pContext = NULL;
        }

        // return STATUS_INSUFFICIENT_RESOURCES;
    }

ClassReleaseQueue_return:
    return;

} // end ClassReleaseQueue()



NTSTATUS
ClassAsynchronousCompletion(
    PDEVICE_OBJECT pDeviceObject,
    PIRP pIrp,
    PCOMPLETION_CONTEXT pContext
    )
/*++

Routine Description:
    This routine is called when an asynchronous I/O request
    which was issused by the class driver completes.  Examples of such requests
    are release queue or START UNIT. This routine releases the queue if
    necessary.  It then frees the context and the IRP.

Arguments:
    pDeviceObject - The device object for the logical unit; however since this
                    is the top stack location the value is NULL.
    pIrp          - Supplies a pointer to the Irp to be processed.
    pContext      - Supplies the context to be used to process this request.

Return Value:
    None.

--*/

{
    PSCSI_REQUEST_BLOCK pSrb;

    pSrb = &(pContext->Srb);

    //
    // If this is an execute srb, then check the return status and make sure.
    // the queue is not frozen.
    //

    if (pSrb->Function == SRB_FUNCTION_EXECUTE_SCSI) {

        //
        // Check for a frozen queue.
        //

        if (pSrb->SrbStatus & SRB_STATUS_QUEUE_FROZEN) {

            //
            // Unfreeze the queue getting the device object from the context.
            //

            ClassReleaseQueue(pContext->pDeviceObject);
        }
    }

    //
    // Free the context and the Irp.
    //

    if (pIrp->MdlAddress != NULL) {
        MmUnlockPages(pIrp->MdlAddress);
        IoFreeMdl(pIrp->MdlAddress);
        pIrp->MdlAddress = NULL;
    }

    if (pContext) {
        MyFreePool(pContext);
    }

    IoFreeIrp(pIrp);

    //
    // Indicate the I/O system should stop processing the Irp completion.
    //

    return STATUS_MORE_PROCESSING_REQUIRED;

} // ClassAsynchronousCompletion()



NTSTATUS
ClassGetInfo(
    IN PDEVICE_OBJECT pDeviceObject,
    OUT PSCSISCAN_INFO pTargetInfo
    )
/*++

Routine Description:
    This routine will get target device information such as SCSI ID, LUN, and
    PortNumber. It calls portdriver with IOCTL_SCSI_GET_ADDRESS to retrieve
    required data. Caller has to have allocated the data buffer beforehand.

    This routine must be run at IRQL_PASSIVE_LEVEL

Arguments:
    pDeviceObject - the device to query
    pTargetInfo   - a location to store the data of target SCSI device

Return Value:
    Status

--*/
{
    PIRP                       pIrp = NULL;
    PKEVENT                    pEvent = NULL;
    PSCSI_ADDRESS              pLocalInfo = NULL;

    IO_STATUS_BLOCK            StatusBlock;
    NTSTATUS                   Status ;

    //
    // Set the descriptor pointer to NULL and
    // Initialize the event we're going to wait on.
    //

    pEvent =  NULL;
    pLocalInfo = NULL;

    pEvent = MyAllocatePool(NonPagedPool, sizeof(KEVENT));
    if(pEvent == NULL) {
        DebugTrace(MAX_TRACE,("ClassGetInfo: Unable to allocate event\n"));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    pLocalInfo = MyAllocatePool(NonPagedPool, sizeof(SCSI_ADDRESS));
    if(pLocalInfo == NULL) {
        DebugTrace(MAX_TRACE,("ClassGetInfo: Unable to allocate local buffer\n"));
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto Cleanup;
    }

    KeInitializeEvent(pEvent, SynchronizationEvent, FALSE);

    __try {

        //
        // Build irp and wait for it to complete (if necessary)
        //

        pIrp = IoBuildDeviceIoControlRequest(
                   IOCTL_SCSI_GET_ADDRESS,                // IOCTL code
                   pDeviceObject,                         // DeviceObject to be called
                   NULL,                                  // input buffer
                   0,                                     // size of input buffer
                   pLocalInfo,                            // output buffer
                   sizeof(SCSI_ADDRESS),                  // size of output buffer
                   FALSE,                                 // IRP_MJ_DEVICE_CONTROL
                   pEvent,                                // event is called when completion
                   &StatusBlock);                         // IO status block

        if (pIrp == NULL) {
            DebugTrace(MAX_TRACE,("ClassGetInfo: unable to allocate irp\n"));
            Status = STATUS_INSUFFICIENT_RESOURCES;
            __leave;
        }

        Status = IoCallDriver(pDeviceObject, pIrp);

        if (Status == STATUS_PENDING) {
            KeWaitForSingleObject(pEvent,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);
            Status = StatusBlock.Status;
        }

        if (!NT_SUCCESS(Status)) {
            DebugTrace(MAX_TRACE,
                             ("ClassGetInfo: error %#08lx\n",
                              Status));
            __leave;
        }
    } __finally {
        if(NT_SUCCESS(Status)) {
            pTargetInfo->PortNumber = pLocalInfo->PortNumber;
            pTargetInfo->PathId = pLocalInfo->PathId;
            pTargetInfo->TargetId = pLocalInfo->TargetId;
            pTargetInfo->Lun = pLocalInfo->Lun;
        }

    }

Cleanup:

    //
    // Release resources
    //
    if (pEvent) {
        MyFreePool(pEvent);
        pEvent = NULL;

    }

    if (pLocalInfo) {
        MyFreePool(pLocalInfo);
        pLocalInfo = NULL;
    }

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\kernel\serscan\ioctl.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    rdwr.c

Abstract:

    This module contains the code for a serial imaging devices driver.
    I/O control routine

Author:

    Vlad Sadovsky    vlads              10-April-1998

Environment:

    Kernel mode

Revision History :

    vlads           04/10/1998      Created first draft

--*/

#include "serscan.h"
#include "serlog.h"

#if DBG
extern ULONG SerScanDebugLevel;
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, SerScanDeviceControl)
#endif

NTSTATUS
SerScanDeviceControl(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine is the dispatch for device control requests.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    STATUS_SUCCESS              - Success.
    STATUS_PENDING              - Request pending.
    STATUS_BUFFER_TOO_SMALL     - Buffer too small.
    STATUS_INVALID_PARAMETER    - Invalid io control request.

--*/

{
    NTSTATUS            Status;
    PDEVICE_EXTENSION   Extension;

    PAGED_CODE();

    Extension = DeviceObject->DeviceExtension;

    //
    // Call down to the parent but don't wait...we'll get an IoCompletion callback.
    //
    Status = SerScanCallParent(Extension,
                               Irp,
                               NO_WAIT,
                               SerScanCompleteIrp);

    DebugDump(SERIRPPATH,
              ("SerScan: [Cleanup] After CallParent Status = %x\n",
              Status));

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\kernel\scsiscan\scsiscan.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    scsiscan.c

Abstract:

    The scsi scanner class driver translates IRPs to SRBs with embedded CDBs
    and sends them to its devices through the port driver.

Author:

    Ray Patrick (raypat)

Environment:

    kernel mode only

Notes:

Revision History:

--*/

//
// Include
//

#define INITGUID

#include <stdio.h>
#include "stddef.h"
#include "wdm.h"
#include "scsi.h"
#include "ntddstor.h"
#include "ntddscsi.h"
#include "scsiscan.h"
#include "private.h"
#include "debug.h"

#include <initguid.h>
#include <devguid.h>
#include <wiaintfc.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, DriverEntry)
#pragma alloc_text(PAGE, SSPnp)
#pragma alloc_text(PAGE, SSPnpAddDevice)
#pragma alloc_text(PAGE, SSOpen)
#pragma alloc_text(PAGE, SSClose)
#pragma alloc_text(PAGE, SSReadWrite)
#pragma alloc_text(PAGE, SSDeviceControl)
#pragma alloc_text(PAGE, SSAdjustTransferSize)
#pragma alloc_text(PAGE, SSBuildTransferContext)
#pragma alloc_text(PAGE, SSCreateSymbolicLink)
#pragma alloc_text(PAGE, SSDestroySymbolicLink)
#pragma alloc_text(PAGE, SSUnload)
#endif

DEFINE_GUID(GUID_STI_DEVICE, 0xF6CBF4C0L, 0xCC61, 0x11D0, 0x84, 0xE5, 0x00, 0xA0, 0xC9, 0x27, 0x65, 0x27);

//
// Globals
//

ULONG NextDeviceInstance = 0;

#if DBG
 ULONG SCSISCAN_DebugTraceLevel = MAX_TRACE;
#endif

#define DBG_DEVIOCTL 1

#ifdef _WIN64
BOOLEAN
IoIs32bitProcess(
    IN PIRP Irp
    );
#endif // _WIN64


//
// Function
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    This routine initializes the scanner class driver. The driver
    opens the port driver by name and then receives configuration
    information used to attach to the scanner devices.

Arguments:

    DriverObject

Return Value:

    NT Status

--*/
{

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("DriverEntry: Enter...\n"));

    MyDebugInit(RegistryPath);

    //
    // Set up the device driver entry points.
    //

    DriverObject->MajorFunction[IRP_MJ_READ]            = SSReadWrite;
    DriverObject->MajorFunction[IRP_MJ_WRITE]           = SSReadWrite;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]  = SSDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_CREATE]          = SSOpen;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]           = SSClose;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL]  = SSPnp;
    DriverObject->MajorFunction[IRP_MJ_PNP]             = SSPnp;
    DriverObject->MajorFunction[IRP_MJ_POWER]           = SSPower;
    DriverObject->DriverUnload                          = SSUnload;
    DriverObject->DriverExtension->AddDevice            = SSPnpAddDevice;

    DebugTrace(TRACE_PROC_LEAVE,("DriverEntry: Leaving... Status=STATUS_SUCCESS\n"));
    return STATUS_SUCCESS;

} // end DriverEntry



NTSTATUS
SSPnpAddDevice(
    IN PDRIVER_OBJECT pDriverObject,
    IN PDEVICE_OBJECT pPhysicalDeviceObject
    )
/*++

Routine Description:

    This routine is called to create a new instance of the device.

Arguments:

    pDriverObject - pointer to the driver object for this instance of SS
    pPhysicalDeviceObject - pointer to the device object that represents the scanner
    on the scsi bus.

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    UCHAR                       aName[64];
    ANSI_STRING                 ansiName;
    UNICODE_STRING              uName;
    PDEVICE_OBJECT              pDeviceObject = NULL;
    NTSTATUS                    Status;
    PSCSISCAN_DEVICE_EXTENSION  pde;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("SSPnpAddDevice: Enter...\n"));

    //
    // Create the Functional Device Object (FDO) for this device.
    //

    sprintf(aName,"\\Device\\Scanner%d",NextDeviceInstance);
    RtlInitAnsiString(&ansiName, aName);
    DebugTrace(TRACE_STATUS,("SSPnpAddDevice: Create device object %s\n", aName));
    RtlAnsiStringToUnicodeString(&uName, &ansiName, TRUE);

    //
    // Create device object for this scanner.
    //

    Status = IoCreateDevice(pDriverObject,
                            sizeof(SCSISCAN_DEVICE_EXTENSION),
                            &uName,
                            FILE_DEVICE_SCANNER,
                            0,
                            FALSE,
                            &pDeviceObject);

    RtlFreeUnicodeString(&uName);

    if (!NT_SUCCESS(Status)) {
        DebugTrace(TRACE_ERROR,("SSPnpAddDevice: ERROR!! Can't create device object\n"));
        DEBUG_BREAKPOINT();
        return Status;
    }

    //
    // Indicate that IRPs should include MDLs and it's pawer pagable.
    //

    pDeviceObject->Flags |=  DO_DIRECT_IO;
    pDeviceObject->Flags |=  DO_POWER_PAGABLE;

    //
    // Initialize Device Extention
    //

    pde = (PSCSISCAN_DEVICE_EXTENSION)(pDeviceObject -> DeviceExtension);
    RtlZeroMemory(pde, sizeof(SCSISCAN_DEVICE_EXTENSION));

    //
    // Attach our new FDO to the PDO (Physical Device Object).
    //

    pde -> pStackDeviceObject = IoAttachDeviceToDeviceStack(pDeviceObject,
                                                            pPhysicalDeviceObject);
    if (NULL == pde -> pStackDeviceObject) {
        DebugTrace(MIN_TRACE,("Cannot attach FDO to PDO.\n"));
        DEBUG_BREAKPOINT();
        IoDeleteDevice( pDeviceObject );
        return STATUS_NOT_SUPPORTED;
    }

    //
    // Remember the PDO in our device extension.
    //

    pde -> pPhysicalDeviceObject = pPhysicalDeviceObject;

    //
    // Remember the DeviceInstance number.
    //

    pde -> DeviceInstance = NextDeviceInstance;

    //
    // Reset SRB error status
    //

    pde->LastSrbError = 0L;

    //
    // Disable synchronous transfer for scanner requests.
    // Disable QueueFreeze in case of any error.
    //

    pde -> SrbFlags = SRB_FLAGS_DISABLE_SYNCH_TRANSFER | SRB_FLAGS_NO_QUEUE_FREEZE ;

    //
    // Set timeout value in seconds.
    //

    pde -> TimeOutValue = SCSISCAN_TIMEOUT;

    //
    // Handle exporting interface
    //

    Status = ScsiScanHandleInterface(
        pPhysicalDeviceObject,
        &pde->InterfaceNameString,
        TRUE
        );

    //
    // Each time AddDevice gets called, we advance the global DeviceInstance variable.
    //

    NextDeviceInstance++;

    //
    // Finishing initialize.
    //

    pDeviceObject -> Flags &= ~DO_DEVICE_INITIALIZING;

    DebugTrace(TRACE_PROC_LEAVE,("SSPnpAddDevice: Leaving... Status=STATUS_SUCCESS\n"));
    return STATUS_SUCCESS;

} // end SSPnpAddDevice()


NTSTATUS SSPnp (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
   )
/*++

Routine Description:

    This routine handles all PNP irps.

Arguments:

    pDevciceObject - represents a scsi scanner device
    pIrp - PNP irp

Return Value:

    STATUS_SUCCESS if successful,
    STATUS_UNSUCCESSFUL otherwise

--*/
{
    NTSTATUS                      Status;
    PSCSISCAN_DEVICE_EXTENSION    pde;
    PIO_STACK_LOCATION            pIrpStack;
    STORAGE_PROPERTY_ID           PropertyId;
    KEVENT                        event;
    PDEVICE_CAPABILITIES          pCaps;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("SSPnp: Enter...\n"));

    pde = (PSCSISCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;
    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );

    Status = STATUS_SUCCESS;

    switch (pIrpStack -> MajorFunction) {

        case IRP_MJ_SYSTEM_CONTROL:
            DebugTrace(TRACE_STATUS,("SSPnp: IRP_MJ_SYSTEM_CONTROL\n"));

            //
            // Just passing down IRP to the next layer.
            //

            IoCopyCurrentIrpStackLocationToNext( pIrp );
            Status = IoCallDriver(pde -> pStackDeviceObject, pIrp);
            return Status;
            break;

        case IRP_MJ_PNP:
            DebugTrace(TRACE_STATUS,("SSPnp: IRP_MJ_PNP\n"));
            switch (pIrpStack->MinorFunction) {

                case IRP_MN_QUERY_CAPABILITIES:
                    DebugTrace(TRACE_STATUS,("SSPnp: IRP_MN_QUERY_CAPABILITIES\n"));

                    pCaps = pIrpStack -> Parameters.DeviceCapabilities.Capabilities;

                    //
                    // fill in the structure with non-controversial values
                    //

                    pCaps -> D1Latency = 10;
                    pCaps -> D2Latency = 10;
                    pCaps -> D3Latency = 10;

                    //
                    // Set SurpriseRemoval OK for SBP2 devices.
                    //
                    
                    pCaps->SurpriseRemovalOK = TRUE;
                    pCaps->Removable = TRUE;

                    //
                    // Call down synchronously.
                    //

                    pIrp -> IoStatus.Status = STATUS_SUCCESS;
                    Status = SSCallNextDriverSynch(pde, pIrp);
                    if(!NT_SUCCESS(Status)){
                        DebugTrace(TRACE_ERROR,("SSPnp: ERROR!! Call down failed\n Status=0x%x", Status));
                    }

                    //
                    // Complete IRP.
                    //

                    IoCompleteRequest( pIrp, IO_NO_INCREMENT );
                    return Status;


                case IRP_MN_START_DEVICE:
                    DebugTrace(TRACE_STATUS,("SSPnp: IRP_MN_START_DEVICE\n"));

                    //
                    // Initialize PendingIoEvent.  Set the number of pending i/o requests for this device to 1.
                    // When this number falls to zero, it is okay to remove, or stop the device.
                    //

                    pde -> PendingIoCount = 0;
                    KeInitializeEvent(&pde -> PendingIoEvent, NotificationEvent, FALSE);
                    SSIncrementIoCount(pDeviceObject);

                    //
                    // First, let the port driver start the device. Simply passing down IRP.
                    //

                    Status = SSCallNextDriverSynch(pde, pIrp);
                    if(!NT_SUCCESS(Status)){
                        DebugTrace(TRACE_ERROR,("SSPnp: ERROR!! Call down failed\n Status=0x%x", Status));
                        break;
                    }

                    //
                    // The port driver has started the device.  It is time for
                    // us to do some initialization and create symbolic links
                    // for the device.
                    //

                    //
                    // Call port driver to get adapter capabilities.
                    //

                    PropertyId = StorageAdapterProperty;
                    pde -> pAdapterDescriptor = NULL;
                    Status = ClassGetDescriptor(pde -> pStackDeviceObject,
                                                &PropertyId,
                                                &(pde -> pAdapterDescriptor));
                    if(!NT_SUCCESS(Status)) {
                        DebugTrace(TRACE_ERROR, ("SSPnp: ERROR!! unable to retrieve adapter descriptor.\n"
                            "[%#08lx]\n", Status));
                        DEBUG_BREAKPOINT();
                        if (NULL != pde -> pAdapterDescriptor) {
                            MyFreePool( pde -> pAdapterDescriptor);
                            pde -> pAdapterDescriptor = NULL;
                        }
                        break;
                    }

                    //
                    // Create the symbolic link for this device.
                    //

                    Status = SSCreateSymbolicLink( pde );
                    if (!NT_SUCCESS(Status)) {
                        DebugTrace(TRACE_ERROR, ("SSPnp: ERROR!! Can't create symbolic link.\n"));
                        DEBUG_BREAKPOINT();
                        if (NULL != pde -> pAdapterDescriptor) {
                            MyFreePool( pde -> pAdapterDescriptor);
                            pde -> pAdapterDescriptor = NULL;
                        }
                        break;
                    }

                    //
                    // Indicate device is now ready.
                    //

                    pde -> DeviceLock = 0;
                    pde -> OpenInstanceCount = 0;
                    pde -> AcceptingRequests = TRUE;
                    pIrp -> IoStatus.Status = Status;
                    pIrp -> IoStatus.Information = 0;

                    pde -> LastSrbError = 0L;

                    IoCompleteRequest( pIrp, IO_NO_INCREMENT );
                    return Status;
                    break;

                case IRP_MN_REMOVE_DEVICE:
                    DebugTrace(TRACE_STATUS,("SSPnp: IRP_MN_REMOVE_DEVICE\n"));

                    //
                    // Forward remove message to lower driver.
                    //

                    IoCopyCurrentIrpStackLocationToNext(pIrp);
                    pIrp -> IoStatus.Status = STATUS_SUCCESS;

                    Status = SSCallNextDriverSynch(pde, pIrp);
                    if(!NT_SUCCESS(Status)){
                        DebugTrace(TRACE_ERROR,("SSPnp: ERROR!! Call down failed\n Status=0x%x", Status));
                    }

                    if (pde -> AcceptingRequests) {
                        pde -> AcceptingRequests = FALSE;
                        SSDestroySymbolicLink( pde );
                    }

                    ScsiScanHandleInterface(pde-> pPhysicalDeviceObject,
                                            &pde->InterfaceNameString,
                                            FALSE);

#ifndef _CHICAGO_
                    if (pde->InterfaceNameString.Buffer != NULL) {
                        IoSetDeviceInterfaceState(&pde->InterfaceNameString,FALSE);
                    }
#endif // !_CHICAGO_
                    //
                    // wait for any io requests pending in our driver to
                    // complete before finishing the remove
                    //

                    SSDecrementIoCount(pDeviceObject);
                    KeWaitForSingleObject(&pde -> PendingIoEvent, Suspended, KernelMode,
                                          FALSE,NULL);

                    if (pde -> pAdapterDescriptor) {
                        MyFreePool(pde -> pAdapterDescriptor);
                        pde -> pAdapterDescriptor = NULL;
                    }

                    IoDetachDevice(pde -> pStackDeviceObject);
                    IoDeleteDevice (pDeviceObject);
                    Status = STATUS_SUCCESS;
                    pIrp -> IoStatus.Status = Status;
                    pIrp -> IoStatus.Information = 0;
                    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
                    return Status;
                    break;

            case IRP_MN_STOP_DEVICE:
                    DebugTrace(TRACE_STATUS,("SSPnp: IRP_MN_STOP_DEVICE\n"));

                    //
                    // Indicate device is not ready.
                    //

                    ASSERT(pde -> AcceptingRequests);
                    pde -> AcceptingRequests = FALSE;

                    //
                    // Remove symbolic link.
                    //

                    SSDestroySymbolicLink( pde );

#ifndef _CHICAGO_
                    if (pde->InterfaceNameString.Buffer != NULL) {
                        IoSetDeviceInterfaceState(&pde->InterfaceNameString,FALSE);
                    }
#endif // !_CHICAGO_

                    //
                    // Let the port driver stop the device.
                    //

                    pIrp -> IoStatus.Status = STATUS_SUCCESS;

                    Status = SSCallNextDriverSynch(pde, pIrp);
                    if(!NT_SUCCESS(Status)){
                        DebugTrace(TRACE_ERROR,("SSPnp: ERROR!! Call down failed\n Status=0x%x", Status));
                    }

                    //
                    // wait for any io requests pending in our driver to
                    // complete before finishing the remove
                    //

                    SSDecrementIoCount(pDeviceObject);
                    KeWaitForSingleObject(&pde -> PendingIoEvent, Suspended, KernelMode,
                                          FALSE,NULL);
                    //
                    // Free Adapter Descriptor
                    //

                    if(pde -> pAdapterDescriptor){
                        MyFreePool(pde -> pAdapterDescriptor);
                        pde -> pAdapterDescriptor = NULL;

                    } else {
                        DebugTrace(TRACE_ERROR,("SSPnp: ERROR!! AdapterDescriptor doesn't exist.\n"));
                        DEBUG_BREAKPOINT();
                    }

                    Status = STATUS_SUCCESS;
                    pIrp -> IoStatus.Status = Status;
                    pIrp -> IoStatus.Information = 0;
                    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
                    return Status;
                    break;

            case IRP_MN_QUERY_STOP_DEVICE:
                    DebugTrace(TRACE_STATUS,("SSPnp: IRP_MN_QUERY_STOP_DEVICE\n"));
                    pIrp->IoStatus.Status = STATUS_SUCCESS;
                    break;

            case IRP_MN_QUERY_REMOVE_DEVICE:
                    DebugTrace(TRACE_STATUS,("SSPnp: IRP_MN_QUERY_REMOVE_DEVICE\n"));
                    pIrp->IoStatus.Status = STATUS_SUCCESS;
                    break;

            case IRP_MN_CANCEL_STOP_DEVICE:
                    DebugTrace(TRACE_STATUS,("SSPnp: IRP_MN_CANCEL_STOP_DEVICE\n"));
                    pIrp->IoStatus.Status = STATUS_SUCCESS;
                    break;

            case IRP_MN_CANCEL_REMOVE_DEVICE:
                    DebugTrace(TRACE_STATUS,("SSPnp: IRP_MN_CANCEL_REMOVE_DEVICE\n"));
                    pIrp->IoStatus.Status = STATUS_SUCCESS;
                    break;

            case IRP_MN_SURPRISE_REMOVAL:
                    DebugTrace(TRACE_STATUS,("SSPnp: IRP_MN_SURPRISE_REMOVAL\n"));
                    pIrp->IoStatus.Status = STATUS_SUCCESS;
                    break;

                default:
                    DebugTrace(TRACE_STATUS,("SSPnp: Minor PNP message received, MinFunction = %x\n",
                                                pIrpStack->MinorFunction));
                    break;

            } /* case MinorFunction, MajorFunction == IRP_MJ_PNP_POWER  */

            ASSERT(Status == STATUS_SUCCESS);
            if (!NT_SUCCESS(Status)) {
                pIrp -> IoStatus.Status = Status;
                IoCompleteRequest( pIrp, IO_NO_INCREMENT );

                DebugTrace(TRACE_PROC_LEAVE,("SSPnp: Leaving(w/ Error)... Status=%x\n", Status));
                return Status;
            }

            //
            // Passing down IRP
            //

            IoCopyCurrentIrpStackLocationToNext(pIrp);
            Status = IoCallDriver(pde -> pStackDeviceObject, pIrp);
            DebugTrace(TRACE_PROC_LEAVE,("SSPnp: Leaving... Status=%x\n", Status));
            return Status;
            break; // IRP_MJ_PNP

        default:
            DebugTrace(TRACE_WARNING,("SSPnp: WARNING!! Not handled Major PNP IOCTL.\n"));
            pIrp -> IoStatus.Status = STATUS_INVALID_PARAMETER;
            IoCompleteRequest( pIrp, IO_NO_INCREMENT );
            DebugTrace(TRACE_PROC_LEAVE,("SSPnp: Leaving... Status=STATUS_INVALID_PARAMETER\n", Status));
            return Status;

    } /* case MajorFunction */

} // end SSPnp()


NTSTATUS
SSOpen(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    )
/*++

Routine Description:

    This routine is called to establish a connection to the device
    class driver. It does no more than return STATUS_SUCCESS.

Arguments:
    pDeviceObject - Device object for a device.
    pIrp - Open request packet

Return Value:
    NT Status - STATUS_SUCCESS

--*/
{
    NTSTATUS                    Status;
    PSCSISCAN_DEVICE_EXTENSION  pde;
    PIO_STACK_LOCATION          pIrpStack;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("SSOpen: Enter...\n"));

    pde = (PSCSISCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;
    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );

    //
    // Increment pending IO count
    //

    SSIncrementIoCount( pDeviceObject );

    //
    // Initialize IoStatus
    //

    Status = STATUS_SUCCESS;

    pIrp -> IoStatus.Information = 0;
    pIrp -> IoStatus.Status = Status;

    //
    // Save instance-count to the context in file object.
    //

    InterlockedIncrement(&pde -> OpenInstanceCount);
    (ULONG)(UINT_PTR)(pIrpStack -> FileObject -> FsContext) = pde -> OpenInstanceCount;

    //
    // Check if device is not going away, in which case fail open request.
    //

    if (pde -> AcceptingRequests == FALSE) {
        DebugTrace(TRACE_STATUS,("SSOpen: Device doesn't exist.\n"));
        Status = STATUS_DELETE_PENDING;

        pIrp -> IoStatus.Information = 0;
        pIrp -> IoStatus.Status = Status;
        IoCompleteRequest(pIrp, IO_NO_INCREMENT);

        SSDecrementIoCount(pDeviceObject);

        DebugTrace(TRACE_PROC_LEAVE,("SSOpen: Leaving... Status=STATUS_DELETE_PENDING\n"));
        return Status;
    }

    //
    // Decrement pending IO count
    //

    SSDecrementIoCount(pDeviceObject);

    //
    // Passing down IRP.
    //

    IoSkipCurrentIrpStackLocation( pIrp );
    Status = IoCallDriver(pde -> pStackDeviceObject, pIrp);

    DebugTrace(TRACE_PROC_LEAVE,("SSOpen: Leaving... Status=%x\n", Status));
    return Status;

} // end SSOpen()


NTSTATUS
SSClose(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    )
/*++

Routine Description:

Arguments:
    pDeviceObject - Device object for a device.
    pIrp - Open request packet

Return Value:
    NT Status - STATUS_SUCCESS

--*/
{
    NTSTATUS                    Status;
    PSCSISCAN_DEVICE_EXTENSION  pde;
    PIO_STACK_LOCATION          pIrpStack;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("SSClose: Enter...\n"));

    pde = (PSCSISCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;
    Status = STATUS_SUCCESS;

    //
    // Increment pending IO count
    //

    SSIncrementIoCount( pDeviceObject );

    //
    // Clear instance-count in context
    //

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    pIrpStack -> FileObject -> FsContext = 0;

    //
    // Initialize IoStatus
    //

    pIrp -> IoStatus.Information = 0;
    pIrp -> IoStatus.Status = Status;

    //
    // Decrement pending IO count
    //

    SSDecrementIoCount(pDeviceObject);

    //
    // Passing down IRP
    //

    IoSkipCurrentIrpStackLocation( pIrp );
    Status = IoCallDriver(pde -> pStackDeviceObject, pIrp);

    DebugTrace(TRACE_PROC_LEAVE,("SSClose: Leaving... Status=%x\n", Status));
    return Status;

} // end SSClose()



NTSTATUS
SSDeviceControl(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    )
/*++

Routine Description:
    This function allows a user mode client to send CDBs to the device.

Arguments:
    pDeviceObject - Device object for a device.
    pIrp - Open request packet

Return Value:
    NT Status - STATUS_SUCCESS

--*/
{
    PIO_STACK_LOCATION          pIrpStack;
    PIO_STACK_LOCATION          pNextIrpStack;
    ULONG                       IoControlCode;
    ULONG                       OldTimeout;
    PSCSISCAN_DEVICE_EXTENSION  pde;
    PTRANSFER_CONTEXT           pTransferContext = NULL;
    PMDL                        pMdl = NULL;
    NTSTATUS                    Status;
    PVOID                       Owner;
    PULONG                      pTimeOut;
    PCDB                        pCdb;
    PVOID                       pUserBuffer;

    BOOLEAN                     fLockedSenseBuffer, fLockedSRBStatus;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("SSDeviceControl: Enter...\n"));

    SSIncrementIoCount( pDeviceObject );

    pde = (PSCSISCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;

    //
    // Validate state of the device
    //

    if (pde -> AcceptingRequests == FALSE) {
        DebugTrace(TRACE_WARNING,("SSDeviceControl: WARNING!! Device's been stopped/removed!\n"));
        Status = STATUS_DELETE_PENDING;
        pIrp -> IoStatus.Information = 0;
        goto SSDeviceControl_Complete;
    }

    //
    // Indicate that MDLs are not locked yet
    //

    fLockedSenseBuffer = fLockedSRBStatus = FALSE;

    //
    // Get context pointers
    //

    pIrpStack     = IoGetCurrentIrpStackLocation( pIrp );
    pNextIrpStack = IoGetNextIrpStackLocation( pIrp );
    IoControlCode = pIrpStack->Parameters.DeviceIoControl.IoControlCode;

    //
    // Get owner of device (0 = locked, >0 if someone has it locked)
    //

    Owner = InterlockedCompareExchangePointer(&pde -> DeviceLock,
                                              NULL,
                                              NULL);

    if (Owner != NULL) {
        if (Owner != pIrpStack -> FileObject -> FsContext) {
            DebugTrace(TRACE_WARNING,("SSDeviceControl: WARNING!! Device is already locked\n"));
            Status = STATUS_DEVICE_BUSY;
            pIrp -> IoStatus.Information = 0;
            goto SSDeviceControl_Complete;
        }
    }

    switch (IoControlCode) {

        case IOCTL_SCSISCAN_SET_TIMEOUT:
            DebugTrace(TRACE_STATUS,("SSDeviceControl: SCSISCAN_SET_TIMEOUT\n"));

            //
            // Get pointer of timeout buffer.
            //

            pTimeOut = pIrp -> AssociatedIrp.SystemBuffer;

            //
            // Validate size of the input parameter
            //

            if (pIrpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(pde -> TimeOutValue) ) {
                DebugTrace(TRACE_WARNING,("SSDeviceControl: WARNING!! Buffer too small\n"));
                Status = STATUS_INVALID_PARAMETER;
                goto SSDeviceControl_Complete;
            }

            OldTimeout = *pTimeOut;
            OldTimeout = InterlockedExchange(&pde -> TimeOutValue, *pTimeOut );

            DebugTrace(TRACE_STATUS,("SSDeviceControl: Timeout %d->%d\n",OldTimeout, *pTimeOut));

            pIrp -> IoStatus.Information = 0;

            //
            // If caller wanted to get old timeout value back - give it to him.
            // Ideally we should've require nonNULL value for output buffer, but it had not been speced
            // and now we can't change compatibility.
            //

            if (pIrpStack->Parameters.DeviceIoControl.OutputBufferLength >= sizeof(OldTimeout) ) {
                *pTimeOut = OldTimeout;
                pIrp -> IoStatus.Information = sizeof(OldTimeout) ;
            }

            Status = STATUS_SUCCESS;
            goto SSDeviceControl_Complete;

        case IOCTL_SCSISCAN_LOCKDEVICE:
            DebugTrace(TRACE_STATUS,("SSDeviceControl: IOCTL_SCSISCAN_LOCKDEVICE\n"));

            //
            // Lock device
            //

            Status = STATUS_DEVICE_BUSY;
            if (NULL == InterlockedCompareExchangePointer(&pde -> DeviceLock,
                                                          pIrpStack -> FileObject -> FsContext,
                                                          NULL)) {
                Status = STATUS_SUCCESS;
            }
            goto SSDeviceControl_Complete;

        case IOCTL_SCSISCAN_UNLOCKDEVICE:
            DebugTrace(TRACE_STATUS,("SSDeviceControl: IOCTL_SCSISCAN_UNLOCKDEVICE\n"));

            //
            // Unlock device
            //

            Status = STATUS_DEVICE_BUSY;
            if (pIrpStack -> FileObject -> FsContext ==
                InterlockedCompareExchangePointer(&pde -> DeviceLock,
                                                  NULL,
                                                  pIrpStack -> FileObject -> FsContext)) {
                Status = STATUS_SUCCESS;
            }
            goto SSDeviceControl_Complete;

        case IOCTL_SCSISCAN_CMD:
        {
            SCSISCAN_CMD    LocalScsiscanCmd;
            PSCSISCAN_CMD   pCmd;

            DebugTrace(TRACE_STATUS,("SSDeviceControl: IOCTL_SCSISCAN_CMD\n"));

            //
            // Check input buffer size.
            //
            
#ifdef _WIN64
            if(IoIs32bitProcess(pIrp)){
                PSCSISCAN_CMD_32    pScsiscanCmd32;
                
                if (pIrpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(SCSISCAN_CMD_32) ) {
                    DebugTrace(TRACE_WARNING,("SSDeviceControl: WARNING!! Buffer too small\n"));
                    Status = STATUS_INVALID_PARAMETER;
                    goto SSDeviceControl_Complete;
                }
                
                //
                // Copy parameters from 32bit IOCTL buffer.
                //
                
                pCmd = &LocalScsiscanCmd;
                RtlZeroMemory(pCmd, sizeof(SCSISCAN_CMD));
                pScsiscanCmd32 = pIrp -> AssociatedIrp.SystemBuffer;

                pCmd -> Size            = pScsiscanCmd32 -> Size;
                pCmd -> SrbFlags        = pScsiscanCmd32 -> SrbFlags;
                pCmd -> CdbLength       = pScsiscanCmd32 -> CdbLength;
                pCmd -> SenseLength     = pScsiscanCmd32 -> SenseLength;
                pCmd -> TransferLength  = pScsiscanCmd32 -> TransferLength;
                pCmd -> pSrbStatus      = (PUCHAR)pScsiscanCmd32 -> pSrbStatus;
                pCmd -> pSenseBuffer    = (PUCHAR)pScsiscanCmd32 -> pSenseBuffer;

                RtlCopyMemory(pCmd -> Cdb, pScsiscanCmd32 -> Cdb, 16); // 16 = CDB buffer size.

            }  else { // if(IoIs32bitProcess(pIrp))
#endif // _WIN64

            if (pIrpStack->Parameters.DeviceIoControl.InputBufferLength < sizeof(SCSISCAN_CMD) ) {
                DebugTrace(TRACE_WARNING,("SSDeviceControl: WARNING!! Buffer too small\n"));
                Status = STATUS_INVALID_PARAMETER;
                goto SSDeviceControl_Complete;
            }

            pCmd = pIrp -> AssociatedIrp.SystemBuffer;

#ifdef _WIN64
            } // if(IoIs32bitProcess(pIrp))
#endif // _WIN64

            //
            // Issue SCSI command
            //

            #if DBG_DEVIOCTL
            {
                PCDB    pCdb;

                pCdb = (PCDB)pCmd -> Cdb;
                DebugTrace(TRACE_STATUS,("SSDeviceControl: CDB->ControlCode = %d  \n",pCdb->CDB6GENERIC.OperationCode));
            }
            #endif

            pTransferContext = SSBuildTransferContext(pde,
                                                      pIrp,
                                                      pCmd,
                                                      pIrpStack -> Parameters.DeviceIoControl.InputBufferLength,
                                                      pIrp -> MdlAddress,
                                                      TRUE
                                                      );
            if (NULL == pTransferContext) {
                DebugTrace(TRACE_ERROR,("SSDeviceControl: ERROR!! Can't create transfer context!\n"));
                DEBUG_BREAKPOINT();
                Status = STATUS_INVALID_PARAMETER;
                goto SSDeviceControl_Complete;
            }

            //
            // Fill in transfer length in the CDB.
            //

            if(10 == pCmd -> CdbLength){

                //
                // Currently Scsiscan only supports flagmentation of 10bytes CDB.
                //

                SSSetTransferLengthToCdb((PCDB)pCmd -> Cdb, pTransferContext -> TransferLength);

            } else if (6 != pCmd -> CdbLength){

                //
                // If CdbLength is not 6 or 10 and transfer size exceeds adapter limit, SCSISCAN cannot handle it.
                //

                if(pTransferContext -> TransferLength != pCmd -> TransferLength){
                    DebugTrace(TRACE_WARNING,("SSDeviceControl: WARNING!! TransferLength (CDB !=6 or 10) exceeds limits!\n"));
                    Status = STATUS_INVALID_PARAMETER;
                    goto SSDeviceControl_Complete;
                }
            }

            //
            // Create system address for the user's sense buffer (if any).
            //

            if (pCmd -> SenseLength) {

                pTransferContext -> pSenseMdl = MmCreateMdl(NULL,
                                                            pCmd -> pSenseBuffer,
                                                            pCmd -> SenseLength);

                if (NULL == pTransferContext -> pSenseMdl) {
                    DebugTrace(TRACE_ERROR,("SSDeviceControl: ERROR!! Can't create MDL for sense buffer!\n"));
                    DEBUG_BREAKPOINT();

                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto SSDeviceControl_Error_With_Status;
                }

                //
                // Probe and lock the pages associated with the
                // caller's buffer for write access , using processor mode of the requestor
                // Nb: Probing may cause an exception
                //

                try{

                    MmProbeAndLockPages(pTransferContext -> pSenseMdl,
                                        pIrp -> RequestorMode,
                                        IoModifyAccess
                                        );

                } except(EXCEPTION_EXECUTE_HANDLER) {

                    //
                    // Invalid sense buffer pointer.
                    //

                    DebugTrace(TRACE_WARNING,("SSDeviceControl: WARNING!! Sense Buffer validation failed\n"));
                    Status = GetExceptionCode();

                    pIrp -> IoStatus.Information = 0;
                    goto SSDeviceControl_Error_With_Status;
                }  // except

                //
                // Indicate we succesfully locked sense buffer
                //

                fLockedSenseBuffer = TRUE;

                //
                // Get system address of sense buffer
                //

                pTransferContext -> pSenseMdl -> MdlFlags |= MDL_MAPPING_CAN_FAIL;
                pTransferContext -> pSenseBuffer =
                                     MmGetSystemAddressForMdl(pTransferContext -> pSenseMdl);

                if (NULL == pTransferContext -> pSenseBuffer) {

                    //
                    // Error with MmGetSystemAddressForMdl
                    //

                    DebugTrace(TRACE_ERROR,("SSDeviceControl: ERROR!! Can't get system address for sense buffer!\n"));
                    DEBUG_BREAKPOINT();

                    Status = STATUS_INSUFFICIENT_RESOURCES;
                    goto SSDeviceControl_Error_With_Status;
                }
            }

            //
            // Create system address for the user's srb status byte.
            //

            pMdl = MmCreateMdl(NULL,
                               pCmd -> pSrbStatus,
                               sizeof(UCHAR)
                               );
            if (NULL == pMdl) {
                DebugTrace(TRACE_ERROR,("SSDeviceControl: ERROR!! Can't create MDL for pSrbStatus!\n"));
                DEBUG_BREAKPOINT();

                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto SSDeviceControl_Error_With_Status;
            }

            //
            // Probe and lock the pages associated with the caller's
            // buffer for write access , using processor mode of the requestor
            // Nb: Probing may cause an exception
            //

            try{
                MmProbeAndLockPages(pMdl,
                                    pIrp -> RequestorMode,
                                    IoModifyAccess);

            } except(EXCEPTION_EXECUTE_HANDLER) {

                //
                // Invalid SRB status buffer pointer.
                //

                DebugTrace(TRACE_WARNING,("SSDeviceControl: WARNING!! SRB Status Buffer validation failed\n"));
                Status = GetExceptionCode();

                pIrp -> IoStatus.Information = 0;
                goto SSDeviceControl_Error_With_Status;
            } // except

            //
            // Indicate we successfully locked SRB status
            //

            fLockedSRBStatus = TRUE;

            //
            // Replace pSrbStatus with the address gotten from MmGetSystemAddressForMdl.
            //

            pMdl -> MdlFlags |= MDL_MAPPING_CAN_FAIL;
            pCmd -> pSrbStatus =  MmGetSystemAddressForMdl(pMdl);

            if (NULL == pCmd -> pSrbStatus) {

                //
                // Error with MmGetSystemAddressForMdl
                //

                DebugTrace(TRACE_ERROR,("SSDeviceControl: ERROR!! Can't get system address for pSrbStatus!\n"));
                DEBUG_BREAKPOINT();

                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto SSDeviceControl_Error_With_Status;
            }

            //
            // Save Mdl for pSrbStatus
            //

            pTransferContext -> pSrbStatusMdl = pMdl;

            break;
        } // case IOCTL_SCSISCAN_CMD:

        case IOCTL_SCSISCAN_GET_INFO:
            DebugTrace(TRACE_STATUS,("SSDeviceControl: IOCTL_SCSISCAN_GET_INFO\n"));

            //
            // Get and return SCSI information block for the scanner device
            //

            if (sizeof(SCSISCAN_INFO) != pIrpStack->Parameters.DeviceIoControl.OutputBufferLength) {

                //
                // Incorrect output buffer size
                //

                DebugTrace(TRACE_WARNING,("SSDeviceControl: WARNING!! Output buffer size is wrong!\n"));

                Status = STATUS_INVALID_PARAMETER;
                goto SSDeviceControl_Error_With_Status;
            }

            if (sizeof(SCSISCAN_INFO) > MmGetMdlByteCount(pIrp->MdlAddress)) {

                //
                // buffer size is short
                //

                DebugTrace(TRACE_WARNING,("SSDeviceControl: WARNING!! Output buffer size is wrong!\n"));

                Status = STATUS_INVALID_PARAMETER;
                goto SSDeviceControl_Error_With_Status;
            }

            pIrp->MdlAddress->MdlFlags |= MDL_MAPPING_CAN_FAIL;
            pUserBuffer =  MmGetSystemAddressForMdl(pIrp->MdlAddress);
            if(NULL == pUserBuffer){
                DebugTrace(TRACE_ERROR,("SSDeviceControl: ERROR!! MmGetSystemAddressForMdl failed!\n"));
                Status = STATUS_INSUFFICIENT_RESOURCES;
                goto SSDeviceControl_Complete;
            }

            Status = ClassGetInfo(pde -> pStackDeviceObject, pUserBuffer);
                goto SSDeviceControl_Complete;

        default:

            //
            // Unsupported IOCTL code - pass down.
            //

            DebugTrace(TRACE_STATUS,("SSDeviceControl: Passing down unsupported IOCTL(0x%x)!\n", IoControlCode));

            IoSkipCurrentIrpStackLocation(pIrp);
            Status = IoCallDriver(pde -> pStackDeviceObject, pIrp);
            return Status;
    }

    //
    // Pass request down and mark as pending
    //

    IoMarkIrpPending(pIrp);
    IoSetCompletionRoutine(pIrp, SSIoctlIoComplete, pTransferContext, TRUE, TRUE, FALSE);
    SSSendScannerRequest(pDeviceObject, pIrp, pTransferContext, FALSE);

    DebugTrace(TRACE_PROC_LEAVE,("SSDeviceControl: Leaving... Status=STATUS_PENDING\n"));
    return STATUS_PENDING;

    //
    // Cleanup
    //

SSDeviceControl_Error_With_Status:

    //
    // Clean up if something went wrong when allocating resources
    //

    if (pMdl) {
        if (fLockedSRBStatus) {
            MmUnlockPages(pMdl);
        }

        IoFreeMdl(pMdl);

        if (pTransferContext) {
            pTransferContext -> pSrbStatusMdl = NULL;
        }
    }

    if (pTransferContext) {
        if (pTransferContext -> pSenseMdl) {
            if ( fLockedSenseBuffer ) {
                MmUnlockPages(pTransferContext -> pSenseMdl);
            }

            IoFreeMdl(pTransferContext -> pSenseMdl);

            pTransferContext -> pSenseMdl = NULL;
            pTransferContext -> pSenseBuffer = NULL;
        }
    }


SSDeviceControl_Complete:

    //
    // Everything seems to be OK - complet I/O request
    //

    pIrp -> IoStatus.Status = Status;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    SSDecrementIoCount(pDeviceObject);

    DebugTrace(TRACE_PROC_LEAVE,("SSDeviceControl: Leaving... Status=%x\n",Status));
    return Status;

}   // end SSDeviceControl()



NTSTATUS
SSReadWrite(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp
    )
/*++

Routine Description:

    This is the entry called by the I/O system for scanner IO.

Arguments:

    DeviceObject - the system object for the device.
    Irp - IRP involved.

Return Value:

    NT Status

--*/
{
    NTSTATUS                      Status;
    PIO_STACK_LOCATION            pIrpStack;
    PSCSISCAN_DEVICE_EXTENSION    pde;
    PTRANSFER_CONTEXT             pTransferContext;
    PMDL                          pMdl;
    PSCSISCAN_CMD                 pCmd;
    PCDB                          pCdb;
    PVOID                         Owner;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("SSReadWrite: Enter...\n"));

    pde = (PSCSISCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;
    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    pCmd = NULL;

    //
    // Incremet pending IO count.
    //

    SSIncrementIoCount( pDeviceObject );

    //
    // Validate state of the device
    //

    if (pde -> AcceptingRequests == FALSE) {
        DebugTrace(TRACE_WARNING,("SSReadWrite: WARNING!! Device is already stopped/removed!\n"));

        Status = STATUS_DELETE_PENDING;
        pIrp -> IoStatus.Information = 0;
        goto SSReadWrite_Complete;
    }

#if DBG
    if (pIrpStack -> MajorFunction == IRP_MJ_READ) {
        DebugTrace(TRACE_STATUS,("SSReadWrite: Read request received\n"));
    } else {
        DebugTrace(TRACE_STATUS,("SSReadWrite: Write request received\n"));
    }
#endif

    //
    // Check if device is locked.
    //

    Owner = InterlockedCompareExchangePointer(&pde -> DeviceLock,
                                              pIrpStack -> FileObject -> FsContext,
                                              pIrpStack -> FileObject -> FsContext);
    if (Owner != 0) {
        if (Owner != pIrpStack -> FileObject -> FsContext) {
            DebugTrace(TRACE_WARNING,("SSReadWrite: WARNING!! Device is locked\n"));

            Status = STATUS_DEVICE_BUSY;
            pIrp -> IoStatus.Information = 0;
            goto SSReadWrite_Complete;
        }
    }


    pMdl = pIrp -> MdlAddress;

    //
    // Allocate a SCSISCAN_CMD structure and initialize it.
    //

    pCmd = MyAllocatePool(NonPagedPool, sizeof(SCSISCAN_CMD));
    if (NULL == pCmd) {
        DebugTrace(TRACE_CRITICAL, ("SSReadWrite: ERROR!! cannot allocated SCSISCAN_CMD structure\n"));
        DEBUG_BREAKPOINT();
        pIrp->IoStatus.Information = 0;
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto SSReadWrite_Complete;
    }

    memset(pCmd,0, sizeof(SCSISCAN_CMD));

    //
    // Fill out SCSISCAN_CMD structure.
    //

#if DBG
    pCmd -> Reserved1      = 'dmCS';
#endif
    pCmd -> Size           = sizeof(SCSISCAN_CMD);
    pCmd -> SrbFlags       = SRB_FLAGS_DATA_IN;
    pCmd -> CdbLength      = 6;
    pCmd -> SenseLength    = SENSE_BUFFER_SIZE;
    pCmd -> TransferLength = pIrpStack->Parameters.Read.Length;
    pCmd -> pSenseBuffer   = NULL;

    //
    // Point pSrbStatus to a reserved field in the SCSISCAN_CMD structure.
    // The ReadFile / WriteFile code path never looks at it, but BuildTransferContext
    // will complain if this pointer is NULL.
    //

    pCmd -> pSrbStatus     = &(pCmd -> Reserved2);

    //
    // Set READ command anyways.
    //

    pCdb = (PCDB)pCmd -> Cdb;
    pCdb -> CDB6READWRITE.OperationCode = SCSIOP_READ6;

    //
    // Set WRITE command if WriteFile called this function.
    //

    if (pIrpStack -> MajorFunction == IRP_MJ_WRITE) {
        pCmd -> SrbFlags = SRB_FLAGS_DATA_OUT;
        pCdb -> CDB6READWRITE.OperationCode = SCSIOP_WRITE6;
    }

    //
    // Allocate a sense buffer.
    //

    pCmd -> pSenseBuffer = MyAllocatePool(NonPagedPool, SENSE_BUFFER_SIZE);
    if (NULL == pCmd -> pSenseBuffer) {
        DebugTrace(TRACE_CRITICAL, ("SSReadWrite: ERROR!! Cannot allocate sense buffer\n"));
        DEBUG_BREAKPOINT();
        pIrp->IoStatus.Information = 0;
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto SSReadWrite_Complete;
    }

#if DBG
    *(PULONG)(pCmd ->pSenseBuffer) = 'sneS';
#endif

    //
    // Build a transfer context.
    //

    pTransferContext = SSBuildTransferContext(pde, pIrp, pCmd, sizeof(SCSISCAN_CMD), pMdl, TRUE);
    if (NULL == pTransferContext) {
        DebugTrace(TRACE_ERROR,("SSReadWrite: ERROR!! Can't create transfer context!\n"));
        DEBUG_BREAKPOINT();

        MyFreePool(pCmd -> pSenseBuffer);
        MyFreePool(pCmd);
        pCmd = NULL;

        pIrp -> IoStatus.Information = 0;
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto SSReadWrite_Complete;
    }

    //
    // Fill in transfer length in the CDB.
    //

    pCdb -> PRINT.TransferLength[2] = ((PFOUR_BYTE)&(pTransferContext -> TransferLength)) -> Byte0;
    pCdb -> PRINT.TransferLength[1] = ((PFOUR_BYTE)&(pTransferContext -> TransferLength)) -> Byte1;
    pCdb -> PRINT.TransferLength[0] = ((PFOUR_BYTE)&(pTransferContext -> TransferLength)) -> Byte2;

    //
    // Save retry count in transfer context.
    //

    pTransferContext -> RetryCount = MAXIMUM_RETRIES;

    //
    // Mark IRP with status pending.
    //

    IoMarkIrpPending(pIrp);

    //
    // Set the completion routine and issue scanner request.
    //

    IoSetCompletionRoutine(pIrp, SSReadWriteIoComplete, pTransferContext, TRUE, TRUE, FALSE);
    SSSendScannerRequest(pDeviceObject, pIrp, pTransferContext, FALSE);

    DebugTrace(TRACE_PROC_LEAVE,("SSReadWrite: Leaving... Status=STATUS_PENDING\n"));
    return STATUS_PENDING;


SSReadWrite_Complete:

    //
    // Free allocated command and sense buffers
    //

    if (pCmd ) {
        if (pCmd -> pSenseBuffer) {
            MyFreePool(pCmd -> pSenseBuffer);
        }
        MyFreePool(pCmd);
        pCmd = NULL;
    }

    pIrp->IoStatus.Status = Status;
    IoCompleteRequest(pIrp, IO_NO_INCREMENT);
    SSDecrementIoCount( pDeviceObject );

    DebugTrace(TRACE_PROC_LEAVE,("SSReadWrite: Leaving... Status=%x\n",Status));
    return Status;


} // end SSReadWrite()


PTRANSFER_CONTEXT
SSBuildTransferContext(
    PSCSISCAN_DEVICE_EXTENSION  pde,
    PIRP                        pIrp,
    PSCSISCAN_CMD               pCmd,
    ULONG                       CmdLength,
    PMDL                        pTransferMdl,
    BOOLEAN                     AllowMultipleTransfer
    )
/*++

Routine Description:

Arguments:

Return Value:

    NULL if error

--*/
{
    PMDL                        pSenseMdl;
    PTRANSFER_CONTEXT           pTransferContext;

    PAGED_CODE();

    DebugTrace(TRACE_PROC_ENTER,("SSBuildTransferContext: Enter...\n"));

    //
    // Initialize pointer
    //

    pTransferContext = NULL;
    pSenseMdl        = NULL;

    //
    // Validate the SCSISCAN_CMD structure.
    //

    if ( (0 == pCmd -> CdbLength)               ||
         (pCmd -> CdbLength > sizeof(pCmd -> Cdb)) ) 
    {
        DebugTrace(TRACE_WARNING,("SSBuildTransferContext: WARNING!! Badly formed SCSISCAN_CMD struture!\n"));
        goto BuildTransferContext_Error;
    }

#ifdef _WIN64
    if(IoIs32bitProcess(pIrp)){
        if(pCmd -> Size != sizeof(SCSISCAN_CMD_32)) {
            DebugTrace(TRACE_WARNING,("SSBuildTransferContext: WARNING!! Badly formed SCSISCAN_CMD_32 struture!\n"));
            goto BuildTransferContext_Error;
        }
     } else { // if(IoIs32bitProcess(pIrp))
#endif // _WIN64
    if(pCmd -> Size != sizeof(SCSISCAN_CMD)){
        DebugTrace(TRACE_WARNING,("SSBuildTransferContext: WARNING!! Badly formed SCSISCAN_CMD struture!\n"));
        goto BuildTransferContext_Error;
    }

#ifdef _WIN64
    } // if(IoIs32bitProcess(pIrp))
#endif // _WIN64


    //
    // Verify that pSrbStatus is non-zero.
    //

    if (NULL == pCmd -> pSrbStatus) {
        DebugTrace(TRACE_WARNING,("SSBuildTransferContext: WARNING!! NULL pointer for pSrbStatus!\n"));
        goto BuildTransferContext_Error;
    }

#if DBG
    pCmd -> Reserved1      = 'dmCS';
#endif

    //
    // Verify that if TransferLength is non-zero, a transfer direction has also been specified.
    //

    if (0 != pCmd -> TransferLength) {
        if (0 == (pCmd -> SrbFlags & (SRB_FLAGS_DATA_IN | SRB_FLAGS_DATA_OUT))) {
            DebugTrace(TRACE_WARNING,("SSBuildTransferContext: WARNING!! Transfer length specified w/ no direction!\n"));
            goto BuildTransferContext_Error;
        }
    }

    //
    // Verify that if the direction bits have been set, a transfer length has also be specified.
    //

    if (0 != (pCmd -> SrbFlags & (SRB_FLAGS_DATA_IN | SRB_FLAGS_DATA_OUT))) {
        if (0 == pCmd -> TransferLength) {
            DebugTrace(TRACE_WARNING,("SSBuildTransferContext: WARNING!! Direction bits is set w/ 0 transfer size!\n"));
            goto BuildTransferContext_Error;
        }
    }

    //
    // Verify that if TransferLength is non-zero, then an associated MDL has also been specified.
    // Also, verify that the transfer length does not exceed the transfer buffer size.
    //


    if (0 != pCmd -> TransferLength) {
        if (NULL == pTransferMdl) {
            DebugTrace(TRACE_WARNING,("SSBuildTransferContext: WARNING!! Non-zero transfer length w/ NULL buffer!\n"));
            goto BuildTransferContext_Error;
        }
        if (pCmd -> TransferLength > MmGetMdlByteCount(pTransferMdl)) {
            DebugTrace(TRACE_WARNING,("SSBuildTransferContext: WARNING!! Transfer length exceeds buffer size!\n"));
            goto BuildTransferContext_Error;
        }
    }

    //
    // Verify that if SenseLength is non-zero, then pSenseBuffer is non-zero as well.
    //

    if (pCmd -> SenseLength) {
        if (NULL == pCmd -> pSenseBuffer) {
            DebugTrace(TRACE_WARNING,("SSBuildTransferContext: WARNING!! Non-zero sense length w/ NULL buffer!\n"));
            goto BuildTransferContext_Error;
        }

        if (pCmd -> SrbFlags & SRB_FLAGS_DISABLE_AUTOSENSE) {
            DebugTrace(TRACE_STATUS,("SSBuildTransferContext: Autosense disabled with NON-null sense buffer.\n"));
        }
    }

    //
    // Allocate transfer context
    //

    pTransferContext = MyAllocatePool(NonPagedPool, sizeof(TRANSFER_CONTEXT));
    if (NULL == pTransferContext) {
        DebugTrace(TRACE_CRITICAL,("SSBuildTransferContext: ERROR!! Failed to allocate transfer context\n"));
        DEBUG_BREAKPOINT();
        return NULL;
    }


    memset(pTransferContext, 0, sizeof(TRANSFER_CONTEXT));
#if DBG
    pTransferContext -> Signature = 'refX';
#endif
    pTransferContext -> pCmd = pCmd;

    if (pCmd -> TransferLength) {

#ifdef WINNT
        pTransferContext -> pTransferBuffer = MmGetMdlVirtualAddress(pTransferMdl);
#else
        pTransferContext -> pTransferBuffer = MmGetSystemAddressForMdl(pTransferMdl);
#endif
        if(NULL == pTransferContext -> pTransferBuffer){
            DebugTrace(TRACE_ERROR,("SSBuildTransferContext: ERROR!! Failed to create address for MDL.\n"));
            DEBUG_BREAKPOINT();
            goto BuildTransferContext_Error;
        }

        pTransferContext -> RemainingTransferLength = pCmd -> TransferLength;
        pTransferContext -> TransferLength = pCmd -> TransferLength;

        //
        // Adjust the transfer size to work within the limits of the hardware.  Fail if the transfer is too
        // big and the caller doesn't want the transfer to be split up.
        //

        SSAdjustTransferSize( pde, pTransferContext );

        if (pTransferContext -> RemainingTransferLength !=
            (LONG)pTransferContext -> TransferLength) {
            if (!AllowMultipleTransfer) {
                DebugTrace(TRACE_WARNING,("SSBuildTransferContext: WARNING!! Transfer exceeds hardware limits!\n"));
                goto BuildTransferContext_Error;
            }
        }
    }

    pTransferContext -> pSenseBuffer = pCmd -> pSenseBuffer;

    DebugTrace(TRACE_PROC_LEAVE,("SSBuildTransferContext: Leaving... Return=%x\n",pTransferContext));
    return pTransferContext;


BuildTransferContext_Error:
    if (pTransferContext) {
        MyFreePool( pTransferContext );
    }
    DebugTrace(TRACE_PROC_LEAVE,("SSBuildTransferContext: Leaving... Return=NULL\n"));
    return NULL;
}   // end SSBuildTransferContext()



VOID
SSAdjustTransferSize(
    PSCSISCAN_DEVICE_EXTENSION  pde,
    PTRANSFER_CONTEXT pTransferContext
    )
/*++

Routine Description:
    This is the entry called by the I/O system for scanner IO.

Arguments:

Return Value:

    NT Status

--*/
{
    ULONG MaxTransferLength;
    ULONG nTransferPages;

    PAGED_CODE();

    MaxTransferLength = pde -> pAdapterDescriptor -> MaximumTransferLength;

    //
    // Make sure the transfer size does not exceed the limitations of the underlying hardware.
    // If so, we will break the transfer up into chunks.
    //

    if (pTransferContext -> TransferLength > MaxTransferLength) {
        DebugTrace(TRACE_STATUS,("Request size (0x%x) greater than maximum (0x%x)\n",
                                    pTransferContext -> TransferLength,
                                    MaxTransferLength));
        pTransferContext -> TransferLength = MaxTransferLength;
    }

    //
    // Calculate number of pages in this transfer.
    //

    nTransferPages = ADDRESS_AND_SIZE_TO_SPAN_PAGES(
        pTransferContext -> pTransferBuffer,
        pTransferContext -> TransferLength);

    if (nTransferPages > pde -> pAdapterDescriptor -> MaximumPhysicalPages) {
        DebugTrace(TRACE_STATUS,("Request number of pages (0x%x) greater than maximum (0x%x).\n",
                                    nTransferPages,
                                    pde -> pAdapterDescriptor -> MaximumPhysicalPages));

        //
        // Calculate maximum bytes to transfer that gaurantees that
        // we will not exceed the maximum number of page breaks,
        // assuming that the transfer may not be page alligned.
        //

        pTransferContext -> TransferLength = (pde -> pAdapterDescriptor -> MaximumPhysicalPages - 1) * PAGE_SIZE;
    }
} // end SSAdjustTransferSize()


VOID
SSSetTransferLengthToCdb(
    PCDB  pCdb,
    ULONG TransferLength
    )
/*++

Routine Description:
    Set transfer length to CDB due to its SCSI command.

Arguments:
    pCdb            -   pointer to CDB
    TransferLength  -   size of data to transfer
Return Value:

    none

--*/
{

    switch (pCdb->SEEK.OperationCode) {

        case 0x24:                  // Scanner SetWindow command
        case SCSIOP_READ_CAPACITY:  // Scanner GetWindow command
        case SCSIOP_READ:           // Scanner Read command
        case SCSIOP_WRITE:          // Scanner Send Command
        default:                    // All other commands
        {
            pCdb -> SEEK.Reserved2[2] = ((PFOUR_BYTE)&TransferLength) -> Byte0;
            pCdb -> SEEK.Reserved2[1] = ((PFOUR_BYTE)&TransferLength) -> Byte1;
            pCdb -> SEEK.Reserved2[0] = ((PFOUR_BYTE)&TransferLength) -> Byte2;

            break;
        }

        case 0x34       :           // Scanner GetDataBufferStatus Command
        {
            pCdb -> SEEK.Reserved2[2] = ((PFOUR_BYTE)&TransferLength) -> Byte0;
            pCdb -> SEEK.Reserved2[1] = ((PFOUR_BYTE)&TransferLength) -> Byte1;

            break;
        }

    }

} // end SSSetTransferLengthToCdb()

VOID
SSSendScannerRequest(
    PDEVICE_OBJECT pDeviceObject,
    PIRP pIrp,
    PTRANSFER_CONTEXT pTransferContext,
    BOOLEAN Retry
    )
/*++

Routine Description:

Arguments:

Return Value:

    None.

--*/
{
    PSCSISCAN_DEVICE_EXTENSION      pde;
    PIO_STACK_LOCATION              pIrpStack;
    PIO_STACK_LOCATION              pNextIrpStack;
    PSRB                            pSrb;
    PCDB                            pCdb;
    PSCSISCAN_CMD                   pCmd;

    DebugTrace(TRACE_PROC_ENTER,("SendScannerRequest pirp=0x%p TransferBuffer=0x%p\n", pIrp, pTransferContext->pTransferBuffer));

    pde = (PSCSISCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;
    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    pNextIrpStack = IoGetNextIrpStackLocation( pIrp );
    ASSERT(pTransferContext);
    pSrb = &(pTransferContext -> Srb);
    ASSERT(pSrb);
    pCmd = pTransferContext -> pCmd;
    ASSERT(pCmd);

    //
    // Write length to SRB.
    //

    pSrb -> Length = SCSI_REQUEST_BLOCK_SIZE;

    //
    // Set up IRP Address.
    //

    pSrb -> OriginalRequest = pIrp;

    pSrb -> Function = SRB_FUNCTION_EXECUTE_SCSI;

    pSrb -> DataBuffer = pTransferContext -> pTransferBuffer;

    //
    // Save byte count of transfer in SRB Extension.
    //

    pSrb -> DataTransferLength = pTransferContext -> TransferLength;

    //
    // Initialize the queue actions field.
    //

    pSrb -> QueueAction = SRB_SIMPLE_TAG_REQUEST;

    //
    // Queue sort key is not used.
    //

    pSrb -> QueueSortKey = 0;

    //
    // Indicate auto request sense by specifying buffer and size.
    //

    pSrb -> SenseInfoBuffer = pTransferContext -> pSenseBuffer;
    pSrb -> SenseInfoBufferLength = pCmd -> SenseLength;

    //
    // Set timeout value in seconds.
    //

    pSrb -> TimeOutValue = pde -> TimeOutValue;

    //
    // Zero status fields
    //


    pSrb -> SrbStatus = pSrb -> ScsiStatus = 0;
    pSrb -> NextSrb = 0;

    //
    // Get pointer to CDB in SRB.
    //

    pCdb = (PCDB)(pSrb -> Cdb);

    //
    // Set length of CDB.
    //

    pSrb -> CdbLength = pCmd -> CdbLength;

    //
    // Copy the user's CDB into our private CDB.
    //

    RtlCopyMemory(pCdb, pCmd -> Cdb, pCmd -> CdbLength);

    //
    // Set the srb flags.
    //

    pSrb -> SrbFlags = pCmd -> SrbFlags;

    //
    // Or in the default flags from the device object.
    //

    pSrb -> SrbFlags |= pde -> SrbFlags;

    if (Retry) {
                // Disable synchronous data transfers and
                // disable tagged queuing. This fixes some errors.

                DebugTrace(TRACE_STATUS,("SscsiScan :: Retrying \n"));

                //
                // Original code also added disable disconnect flag to SRB.
                // That action would lock SCSI bus and in a case when paging drive is
                // located on the same bus and scanner is taking long timeouts ( for example
                // when it is mechanically locked) memory manager would hit timeout and
                // bugcheck.
                //
                // pSrb -> SrbFlags |= SRB_FLAGS_DISABLE_DISCONNECT |
                //

                pSrb -> SrbFlags |= SRB_FLAGS_DISABLE_SYNCH_TRANSFER;
                pSrb -> SrbFlags &= ~SRB_FLAGS_QUEUE_ACTION_ENABLE;

                DebugTrace(TRACE_STATUS,("SSSendScannerRequest: Retry branch .Srb flags=(0x%x) \n", pSrb -> SrbFlags));

                pSrb -> QueueTag = SP_UNTAGGED;
    }

    //
    // Set up major SCSI function.
    //

    pNextIrpStack -> MajorFunction = IRP_MJ_SCSI;

    //
    // Save SRB address in next stack for port driver.
    //

    pNextIrpStack -> Parameters.Scsi.Srb = pSrb;

    //
    // Print out SRB fields
    //

    // DebugTrace(MAX_TRACE,("SSSendScannerRequest: SRB ready. Flags=(%#X)Func=(%#x) DataLen=%d \nDataBuffer(16)=[%16s] \n",
     DebugTrace(TRACE_STATUS,("SSSendScannerRequest: SRB ready. Flags=(%#X)Func=(%#x) DataLen=%d \nDataBuffer(16)=[%lx] \n",
                         pSrb -> SrbFlags ,pSrb -> Function,
                         pSrb -> DataTransferLength,
                         pSrb -> DataBuffer));

    IoCallDriver(pde -> pStackDeviceObject, pIrp);

} // end SSSendScannerRequest()


NTSTATUS
SSReadWriteIoComplete(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PTRANSFER_CONTEXT pTransferContext
    )
/*++

Routine Description:
    This routine executes when the port driver has completed a request.
    It looks at the SRB status in the completing SRB and if not success
    it checks for valid request sense buffer information. If valid, the
    info is used to update status with more precise message of type of
    error. This routine deallocates the SRB.

Arguments:
    pDeviceObject - Supplies the device object which represents the logical
        unit.
    pIrp - Supplies the Irp which has completed.

Return Value:
    NT status

--*/
{
    PIO_STACK_LOCATION              pIrpStack;
    PIO_STACK_LOCATION              pNextIrpStack;
    NTSTATUS                        Status;
    BOOLEAN                         Retry;
    PSRB                            pSrb;
    UCHAR                           SrbStatus;
    PCDB                            pCdb;
    PSCSISCAN_CMD                   pCmd;

    DebugTrace(TRACE_PROC_ENTER,("ReadWriteIoComplete: Enter... IRP 0x%p.\n", pIrp));

    ASSERT(NULL != pTransferContext);

    //
    // Initialize local.
    //
    
    Retry           = FALSE;
    pCdb            = NULL;
    pCmd            = NULL;

    pIrpStack       = IoGetCurrentIrpStackLocation(pIrp);
    pNextIrpStack   = IoGetNextIrpStackLocation(pIrp);

    Status = pIrp->IoStatus.Status;
    pSrb = &(pTransferContext -> Srb);
    SrbStatus = SRB_STATUS(pSrb -> SrbStatus);

    if( (SrbStatus != SRB_STATUS_SUCCESS)
     || (STATUS_SUCCESS != Status) )
    {
        DebugTrace(TRACE_ERROR,("ReadWriteIoComplete: ERROR!! Irp error. 0x%p SRB status:0x%p\n", Status, pSrb -> SrbStatus));

        //
        // Release the queue if it is frozen.
        //

        if (pSrb -> SrbStatus & SRB_STATUS_QUEUE_FROZEN) {
            DebugTrace(TRACE_ERROR,("ReadWriteIoComplete: Release queue. IRP 0x%p.\n", pIrp));
           ClassReleaseQueue(pDeviceObject);
        }

        Retry = ClassInterpretSenseInfo(
                                        pDeviceObject,
                                        pSrb,
                                        pNextIrpStack->MajorFunction,
                                        0,
                                        MAXIMUM_RETRIES - ((ULONG)(UINT_PTR)pIrpStack->Parameters.Others.Argument4),
                                        &Status);

        if (Retry && pTransferContext -> RetryCount--) {
            DebugTrace(TRACE_STATUS,("ReadWriteIoComplete: Retry request 0x%p TransferBuffer=0x%p \n",
                                        pIrp,pTransferContext->pTransferBuffer));
            IoSetCompletionRoutine(pIrp, SSReadWriteIoComplete, pTransferContext, TRUE, TRUE, FALSE);
            SSSendScannerRequest(pDeviceObject, pIrp, pTransferContext, TRUE);
            return STATUS_MORE_PROCESSING_REQUIRED;
        }

        //
        // If status is overrun, ignore it to support some bad devices.
        //
        

        if (SRB_STATUS_DATA_OVERRUN == SrbStatus) {
            DebugTrace(TRACE_WARNING,("ReadWriteIoComplete: WARNING!! Data overrun IRP=0x%p. Ignoring...\n", pIrp));
            pTransferContext -> NBytesTransferred += pSrb -> DataTransferLength;
            Status = STATUS_SUCCESS;

        } else {
            DebugTrace(TRACE_STATUS,("ReadWriteIoComplete: Request failed. IRP 0x%p.\n", pIrp));
//            DEBUG_BREAKPOINT();
            pTransferContext -> NBytesTransferred = 0;
            Status = STATUS_IO_DEVICE_ERROR;
        }

    } else {

        pTransferContext -> NBytesTransferred += pSrb -> DataTransferLength;
        pTransferContext -> RemainingTransferLength -= pSrb -> DataTransferLength;
        pTransferContext -> pTransferBuffer += pSrb -> DataTransferLength;
        if (pTransferContext -> RemainingTransferLength > 0) {

            if ((LONG)(pTransferContext -> TransferLength) > pTransferContext -> RemainingTransferLength) {
                pTransferContext -> TransferLength = pTransferContext -> RemainingTransferLength;
                pCmd = pTransferContext -> pCmd;
                pCdb = (PCDB)pCmd -> Cdb;
                pCdb -> PRINT.TransferLength[2] = ((PFOUR_BYTE)&(pTransferContext -> TransferLength)) -> Byte0;
                pCdb -> PRINT.TransferLength[1] = ((PFOUR_BYTE)&(pTransferContext -> TransferLength)) -> Byte1;
                pCdb -> PRINT.TransferLength[0] = ((PFOUR_BYTE)&(pTransferContext -> TransferLength)) -> Byte2;
            }

            IoSetCompletionRoutine(pIrp, SSReadWriteIoComplete, pTransferContext, TRUE, TRUE, FALSE);
            SSSendScannerRequest(pDeviceObject, pIrp, pTransferContext, FALSE);
            return STATUS_MORE_PROCESSING_REQUIRED;
        }

        Status = STATUS_SUCCESS;
    }

    pIrp -> IoStatus.Information = pTransferContext -> NBytesTransferred;

    MyFreePool(pTransferContext -> pCmd -> pSenseBuffer);
    MyFreePool(pTransferContext -> pCmd);
    MyFreePool(pTransferContext);

    pIrp -> IoStatus.Status = Status;

    SSDecrementIoCount( pDeviceObject );

    return Status;

} // end SSReadWriteIoComplete()



NTSTATUS
SSIoctlIoComplete(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PTRANSFER_CONTEXT pTransferContext
    )
/*++

Routine Description:
    This routine executes when an DevIoctl request has completed.

Arguments:
    pDeviceObject - Supplies the device object which represents the logical
        unit.
    pIrp - Supplies the Irp which has completed.
    pTransferContext - pointer to info about the request.

Return Value:
    NT status

--*/
{
    PIO_STACK_LOCATION              pIrpStack;
    NTSTATUS                        Status;
    PSRB                            pSrb;
    PSCSISCAN_CMD                   pCmd;
    PCDB                            pCdb;


    DebugTrace(TRACE_PROC_ENTER,("IoctlIoComplete: Enter... IRP=0x%p\n", pIrp));

    ASSERT(NULL != pTransferContext);

    pIrpStack   = IoGetCurrentIrpStackLocation(pIrp);
    pSrb        = &(pTransferContext -> Srb);
    pCmd        = pTransferContext -> pCmd;

    ASSERT(NULL != pCmd);

    pCdb        = NULL;
    Status = pIrp->IoStatus.Status;

    //
    // Copy the SRB Status back into the user's SCSISCAN_CMD buffer.
    //

    *(pCmd -> pSrbStatus) = pSrb -> SrbStatus;

    //
    // If an error occurred on this transfer, release the frozen queue if necessary.
    //

    if( (SRB_STATUS(pSrb -> SrbStatus) != SRB_STATUS_SUCCESS) 
     || (STATUS_SUCCESS != Status) )
    {
        DebugTrace(TRACE_ERROR,("IoctlIoComplete: ERROR!! Irp error. Status=0x%x SRB status:0x%x\n", Status, pSrb -> SrbStatus));

        if (pSrb -> SrbStatus & SRB_STATUS_QUEUE_FROZEN) {
            DebugTrace(TRACE_ERROR,("IoctlIoComplete: Release queue. IRP  0x%p.\n", pIrp));
           ClassReleaseQueue(pDeviceObject);
        }
    } else {
        pTransferContext -> NBytesTransferred += pSrb -> DataTransferLength;
        pTransferContext -> RemainingTransferLength -= pSrb -> DataTransferLength;
        pTransferContext -> pTransferBuffer += pSrb -> DataTransferLength;
        if (pTransferContext -> RemainingTransferLength > 0) {

            if ((LONG)(pTransferContext -> TransferLength) > pTransferContext -> RemainingTransferLength) {
                pTransferContext -> TransferLength = pTransferContext -> RemainingTransferLength;
                pCmd = pTransferContext -> pCmd;
                pCdb = (PCDB)pCmd -> Cdb;

                //
                // SCSISCAN only supports 10bytes CDB fragmentation.
                //

                ASSERT(pCmd->CdbLength == 10);

                //
                // Fill in transfer length in the CDB.
                //

                SSSetTransferLengthToCdb((PCDB)pCmd -> Cdb, pTransferContext -> TransferLength);

            }

            IoSetCompletionRoutine(pIrp, SSIoctlIoComplete, pTransferContext, TRUE, TRUE, FALSE);
            SSSendScannerRequest(pDeviceObject, pIrp, pTransferContext, FALSE);
            return STATUS_MORE_PROCESSING_REQUIRED;
        }

        Status = STATUS_SUCCESS;
    }

    //
    // Clean up and return.
    //

    if (pTransferContext -> pSrbStatusMdl) {
        MmUnlockPages(pTransferContext -> pSrbStatusMdl);
        IoFreeMdl(pTransferContext -> pSrbStatusMdl);

        //pTransferContext -> pSrbStatusMdl = NULL;
    }

    if (pTransferContext -> pSenseMdl) {
        MmUnlockPages(pTransferContext -> pSenseMdl);
        IoFreeMdl(pTransferContext -> pSenseMdl);

        //pTransferContext -> pSenseMdl = NULL;
    }

    pIrp -> IoStatus.Information = pTransferContext -> NBytesTransferred;
    pIrp -> IoStatus.Status = Status;

    MyFreePool(pTransferContext);

    SSDecrementIoCount( pDeviceObject );

    return Status;

} // end SSIoctlIoComplete()


NTSTATUS
SSCreateSymbolicLink(
    PSCSISCAN_DEVICE_EXTENSION  pde
    )
{

    NTSTATUS                      Status;
    UNICODE_STRING                uName;
    UNICODE_STRING                uName2;
    ANSI_STRING                   ansiName;
    CHAR                          aName[32];
    HANDLE                        hSwKey;

    PAGED_CODE();

    //
    // Create the symbolic link for this device.
    //

    sprintf(aName,"\\Device\\Scanner%d",pde -> DeviceInstance);
    RtlInitAnsiString(&ansiName, aName);
    RtlAnsiStringToUnicodeString(&uName, &ansiName, TRUE);

    sprintf(aName,"\\DosDevices\\Scanner%d",pde -> DeviceInstance);
    RtlInitAnsiString(&ansiName, aName);
    RtlAnsiStringToUnicodeString(&(pde -> SymbolicLinkName), &ansiName, TRUE);

    Status = IoCreateSymbolicLink( &(pde -> SymbolicLinkName), &uName );

    RtlFreeUnicodeString( &uName );

    if (STATUS_SUCCESS != Status ) {
        DebugTrace(MIN_TRACE,("Cannot create symbolic link.\n"));
        DEBUG_BREAKPOINT();
        Status = STATUS_NOT_SUPPORTED;
        return Status;
    }

    //
    // Now, stuff the symbolic link into the CreateFileName key so that STI can find the device.
    //

    IoOpenDeviceRegistryKey( pde -> pPhysicalDeviceObject,
                             PLUGPLAY_REGKEY_DRIVER, KEY_WRITE, &hSwKey);

    RtlInitUnicodeString(&uName,L"CreateFileName");
    sprintf(aName,"\\\\.\\Scanner%d",pde -> DeviceInstance);
    RtlInitAnsiString(&ansiName, aName);
    RtlAnsiStringToUnicodeString(&uName2, &ansiName, TRUE);
    ZwSetValueKey(hSwKey,&uName,0,REG_SZ,uName2.Buffer,uName2.Length);
    RtlFreeUnicodeString( &uName2 );

    return STATUS_SUCCESS;
}


NTSTATUS
SSDestroySymbolicLink(
    PSCSISCAN_DEVICE_EXTENSION  pde
    )
{

    UNICODE_STRING                uName;
    UNICODE_STRING                uName2;
    ANSI_STRING                   ansiName;
    CHAR                          aName[32];
    HANDLE                        hSwKey;

    PAGED_CODE();

    DebugTrace(MIN_TRACE,("DestroySymbolicLink\n"));

    //
    // Delete the symbolic link to this device.
    //

    IoDeleteSymbolicLink( &(pde -> SymbolicLinkName) );

    //
    // Remove the CreateFile name from the s/w key.
    //

    IoOpenDeviceRegistryKey( pde -> pPhysicalDeviceObject,
                             PLUGPLAY_REGKEY_DRIVER, KEY_WRITE, &hSwKey);

    RtlInitUnicodeString(&uName,L"CreateFileName");
    memset(aName, 0, sizeof(aName));
    RtlInitAnsiString(&ansiName, aName);
    RtlAnsiStringToUnicodeString(&uName2, &ansiName, TRUE);
    ZwSetValueKey(hSwKey,&uName,0,REG_SZ,uName2.Buffer,uName2.Length);
    RtlFreeUnicodeString( &uName2 );
    RtlFreeUnicodeString( &(pde -> SymbolicLinkName) );

    ZwClose(hSwKey);

    return STATUS_SUCCESS;

}


VOID
SSIncrementIoCount(
    IN PDEVICE_OBJECT pDeviceObject
    )
/*++

Routine Description:

Arguments:

Return Value:


--*/
{
    PSCSISCAN_DEVICE_EXTENSION  pde;

    pde = (PSCSISCAN_DEVICE_EXTENSION)(pDeviceObject -> DeviceExtension);
    InterlockedIncrement(&pde -> PendingIoCount);
}


LONG
SSDecrementIoCount(
    IN PDEVICE_OBJECT pDeviceObject
    )
/*++

Routine Description:

Arguments:

Return Value:


--*/
{
    PSCSISCAN_DEVICE_EXTENSION  pde;
    LONG                        ioCount;

    pde = (PSCSISCAN_DEVICE_EXTENSION)(pDeviceObject -> DeviceExtension);

    ioCount = InterlockedDecrement(&pde -> PendingIoCount);

    DebugTrace(TRACE_STATUS,("Pending io count = %x\n",ioCount));

    if (0 == ioCount) {
        KeSetEvent(&pde -> PendingIoEvent,
                   1,
                   FALSE);
    }

    return ioCount;
}


NTSTATUS
SSDeferIrpCompletion(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP pIrp,
    IN PVOID Context
    )
/*++

Routine Description:

    This routine is called when the port driver completes an IRP.

Arguments:

    pDeviceObject - Pointer to the device object for the class device.

    pIrp - Irp completed.

    Context - Driver defined context.

Return Value:

    The function value is the final status from the operation.

--*/
{
    PKEVENT pEvent = Context;

    KeSetEvent(pEvent,
               1,
               FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;

}


NTSTATUS
SSPower(
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
    )
/*++

Routine Description:

    Process the Power IRPs sent to the PDO for this device.

Arguments:

    pDeviceObject - pointer to the functional device object (FDO) for this device.
    pIrp          - pointer to an I/O Request Packet

Return Value:

    NT status code

--*/
{
    NTSTATUS                        Status;
    PSCSISCAN_DEVICE_EXTENSION      pde;
    PIO_STACK_LOCATION              pIrpStack;
    BOOLEAN                         hookIt = FALSE;

    PAGED_CODE();

    SSIncrementIoCount( pDeviceObject );

    pde       = (PSCSISCAN_DEVICE_EXTENSION)pDeviceObject -> DeviceExtension;
    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );
    Status    = STATUS_SUCCESS;

    switch (pIrpStack -> MinorFunction) {
        case IRP_MN_SET_POWER:
            DebugTrace(MIN_TRACE,("IRP_MN_SET_POWER\n"));
            PoStartNextPowerIrp(pIrp);
            IoSkipCurrentIrpStackLocation(pIrp);
            Status = PoCallDriver(pde -> pStackDeviceObject, pIrp);
            SSDecrementIoCount(pDeviceObject);
            break; /* IRP_MN_QUERY_POWER */

        case IRP_MN_QUERY_POWER:
            DebugTrace(MIN_TRACE,("IRP_MN_QUERY_POWER\n"));
            PoStartNextPowerIrp(pIrp);
            IoSkipCurrentIrpStackLocation(pIrp);
            Status = PoCallDriver(pde -> pStackDeviceObject, pIrp);
            SSDecrementIoCount(pDeviceObject);
            break; /* IRP_MN_QUERY_POWER */

        default:
            DebugTrace(MIN_TRACE,("Unknown power message (%x)\n",pIrpStack->MinorFunction));
            PoStartNextPowerIrp(pIrp);
            IoSkipCurrentIrpStackLocation(pIrp);
            Status = PoCallDriver(pde -> pStackDeviceObject, pIrp);
            SSDecrementIoCount(pDeviceObject);

    } /* irpStack->MinorFunction */

    return Status;
}


VOID
SSUnload(
    IN PDRIVER_OBJECT pDriverObject
    )
/*++

Routine Description:

    This routine is called when the driver is unloaded.

Arguments:
    pDriverObject - Pointer to the driver object.evice object for the class device.

Return Value:
    none.

--*/
{
    PAGED_CODE();

    DebugTrace(MIN_TRACE,("Driver unloaded.\n"));
}


NTSTATUS
ScsiScanHandleInterface(
    PDEVICE_OBJECT      DeviceObject,
    PUNICODE_STRING     InterfaceName,
    BOOLEAN             Create
    )
/*++

Routine Description:

Arguments:

    DeviceObject    - Supplies the device object.

Return Value:

    None.

--*/
{

    NTSTATUS           Status;


    Status = STATUS_SUCCESS;

#ifndef _CHICAGO_

    if (Create) {

        Status=IoRegisterDeviceInterface(
            DeviceObject,
            &GUID_DEVINTERFACE_IMAGE,
            NULL,
            InterfaceName
            );

        DebugTrace(TRACE_STATUS,("Called IoRegisterDeviceInterface . Returned=0x%X\n",Status));

        if (NT_SUCCESS(Status)) {

            IoSetDeviceInterfaceState(
                InterfaceName,
                TRUE
                );

            DebugTrace(TRACE_STATUS,("Called IoSetDeviceInterfaceState(TRUE) . \n"));


        }

    } else {

        if (InterfaceName->Buffer != NULL) {

            IoSetDeviceInterfaceState(
                InterfaceName,
                FALSE
                );

            DebugTrace(TRACE_STATUS,("Called IoSetDeviceInterfaceState(FALSE) . \n"));

            RtlFreeUnicodeString(
                InterfaceName
                );

            InterfaceName->Buffer = NULL;

        }

    }

#endif // !_CHICAGO_

    return Status;

}

NTSTATUS
SSCallNextDriverSynch(
    IN PSCSISCAN_DEVICE_EXTENSION   pde,
    IN PIRP                         pIrp
)
/*++

Routine Description:

    Calls lower driver and waits for result

Arguments:

    DeviceExtension - pointer to device extension
    Irp - pointer to IRP

Return Value:

    none.

--*/
{
    KEVENT          Event;
    PIO_STACK_LOCATION IrpStack;
    NTSTATUS        Status;

    DebugTrace(TRACE_PROC_ENTER,("SSCallNextDriverSynch: Enter..\n"));

    IrpStack = IoGetCurrentIrpStackLocation(pIrp);

    //
    // Copy IRP stack to the next.
    //

    IoCopyCurrentIrpStackLocationToNext(pIrp);

    //
    // Initialize synchronizing event.
    //

    KeInitializeEvent(&Event,
                      SynchronizationEvent,
                      FALSE);

    //
    // Set completion routine
    //

    IoSetCompletionRoutine(pIrp,
                           SSDeferIrpCompletion,
                           &Event,
                           TRUE,
                           TRUE,
                           TRUE);

    //
    // Call down
    //

    Status = IoCallDriver(pde -> pStackDeviceObject, pIrp);

    if (Status == STATUS_PENDING) {

        //
        // Waiting for the completion.
        //

        DebugTrace(TRACE_STATUS,("SSCallNextDriverSynch: STATUS_PENDING. Wait for event.\n"));
        KeWaitForSingleObject(&Event,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);
        Status = pIrp -> IoStatus.Status;
    }

    //
    // Return
    //

    DebugTrace(TRACE_PROC_LEAVE,("SSCallNextDriverSynch: Leaving.. Status = %x\n", Status));
    return (Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\kernel\scsiscan\sources.inc ===
# ############################################################
#
#Copyright (c) 2000  Microsoft Corporation
#
#Author:
#   byronc, coopp, keisuket, vlads
#
#Date:
#   2-Feb-2000
#
#Module Name:
#    sources.inc
#
#Abstract:
#    This file specifies the target component being built and the list of
#    sources files needed to build that component.  Also specifies optional
#    compiler switches and libraries that are unique for the component being
#    built.
#
#  This directory builds
#     StillImage kernel mode driver
#
# ############################################################

!include $(PROJECT_ROOT)\wia\wiaenv.inc

TARGETNAME=scsiscan
TARGETTYPE=DRIVER
TARGETPATH=$(OBJ_DIR)

SOURCES=..\class.c     \
        ..\scsiscan.c  \
        ..\scsiscan.rc \
        ..\debug.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\kernel\serscan\rdwr.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    rdwr.c

Abstract:

    This module contains the code for a serial imaging devices
    suport class driver.

Author:

    Vlad Sadovsky    vlads              10-April-1998

Environment:

    Kernel mode

Revision History :

    vlads           04/10/1998      Created first draft

--*/

#include "serscan.h"
#include "serlog.h"

#if DBG
extern ULONG SerScanDebugLevel;
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, SerScanReadWrite)
#endif


NTSTATUS
SerScanReadWrite(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine is the dispatch for read and write requests.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    STATUS_SUCCESS              - Success.
    STATUS_PENDING              - Request pending.
    STATUS_INVALID_PARAMETER    - Invalid parameter.

--*/

{
    NTSTATUS            Status;
    PDEVICE_EXTENSION   Extension;

    PAGED_CODE();

    Extension = DeviceObject->DeviceExtension;

    //
    // Call down to the parent but don't wait...we'll get an IoCompletion callback.
    //
    Status = SerScanCallParent(Extension,
                               Irp,
                               NO_WAIT,
                               SerScanCompleteIrp);

    DebugDump(SERIRPPATH,
              ("SerScan: [Read/Write] After CallParent Status = %x\n",
              Status));

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\kernel\serscan\pnppwr.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    pnp.c

Abstract:

    This module contains the code for a serial imaging devices driver
    supporting PnP functionality

Author:

    Vlad Sadovsky    vlads              10-April-1998

Environment:

    Kernel mode

Revision History :

    vlads           04/10/1998      Created first draft

--*/

#include "serscan.h"
#include "serlog.h"

//#include <ntpoapi.h>

extern ULONG SerScanDebugLevel;

extern  const PHYSICAL_ADDRESS PhysicalZero ;

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, SerScanPnp)
#pragma alloc_text(PAGE, SerScanPower)
#endif

NTSTATUS
SerScanPnp (
    IN PDEVICE_OBJECT pDeviceObject,
    IN PIRP           pIrp
   )
/*++

Routine Description:

    This routine handles all PNP IRPs, dispatching them as appropriate .

Arguments:

    pDeviceObject           - represents a device

    pIrp                    - PNP Irp

Return Value:

    STATUS_SUCCESS          - if successful.
    STATUS_UNSUCCESSFUL     - otherwise.

--*/
{
    NTSTATUS                        Status ;
    PDEVICE_EXTENSION               Extension;
    PIO_STACK_LOCATION              pIrpStack;
    PVOID                           pObject;
    ULONG                           NewReferenceCount;
    NTSTATUS                        ReturnStatus;

    pIrpStack = IoGetCurrentIrpStackLocation( pIrp );

    Extension = pDeviceObject->DeviceExtension;

    Status = STATUS_SUCCESS;

    DebugDump(SERINITDEV,("Entering PnP Dispatcher\n"));

    switch (pIrpStack->MinorFunction) {

        case IRP_MN_START_DEVICE:

            //
            // Initialize PendingIoEvent.  Set the number of pending i/o requests for this device to 1.
            // When this number falls to zero, it is okay to remove, or stop the device.
            //

            DebugDump(SERINITDEV,("Entering Start Device \n"));

            KeInitializeEvent(&Extension -> PdoStartEvent, SynchronizationEvent, FALSE);

            IoCopyCurrentIrpStackLocationToNext(pIrp);

            Status = WaitForLowerDriverToCompleteIrp(
                                        Extension->LowerDevice,
                                        pIrp,
                                        &Extension->PdoStartEvent);

            if (!NT_SUCCESS(Status)) {

                pIrp->IoStatus.Status      = Status;
                pIrp->IoStatus.Information = 0;

                IoCompleteRequest(pIrp, IO_NO_INCREMENT);
                return (Status);

            }

            #ifdef CREATE_SYMBOLIC_NAME

            //
            // Now setup the symbolic link for windows.
            //

            Status = IoCreateUnprotectedSymbolicLink(&Extension->SymbolicLinkName, &Extension->ClassName);

            if (NT_SUCCESS(Status)) {

                // We were able to create the symbolic link, so record this
                // value in the extension for cleanup at unload time.

                Extension->CreatedSymbolicLink = TRUE;

                // Write out the result of the symbolic link to the registry.

                Status = RtlWriteRegistryValue(RTL_REGISTRY_DEVICEMAP,
                                               L"Serial Scanners",
                                               Extension->ClassName.Buffer,
                                               REG_SZ,
                                               Extension->SymbolicLinkName.Buffer,
                                               Extension->SymbolicLinkName.Length + sizeof(WCHAR));
                if (!NT_SUCCESS(Status)) {

                    //
                    // It didn't work.  Just go to cleanup.
                    //

                    DebugDump(SERERRORS,
                              ("SerScan: Couldn't create the device map entry\n"
                               "--------  for port %wZ\n",
                               &Extension->ClassName));

                    SerScanLogError(pDeviceObject->DriverObject,
                                    pDeviceObject,
                                    PhysicalZero,
                                    PhysicalZero,
                                    0,
                                    0,
                                    0,
                                    6,
                                    Status,
                                    SER_NO_DEVICE_MAP_CREATED);
                }

            } else {

                //
                // Couldn't create the symbolic link.
                //

                Extension->CreatedSymbolicLink = FALSE;

                ExFreePool(Extension->SymbolicLinkName.Buffer);
                Extension->SymbolicLinkName.Buffer = NULL;

                DebugDump(SERERRORS,
                          ("SerScan: Couldn't create the symbolic link\n"
                           "--------  for port %wZ\n",
                           &Extension->ClassName));

                SerScanLogError(pDeviceObject->DriverObject,
                                pDeviceObject,
                                PhysicalZero,
                                PhysicalZero,
                                0,
                                0,
                                0,
                                5,
                                Status,
                                SER_NO_SYMLINK_CREATED);

            }

            #endif

            ExFreePool(Extension->ClassName.Buffer);
            Extension->ClassName.Buffer = NULL;

            //
            // Ignore status of link registry write  - always succeed
            //

            //
            // Clear InInit flag to indicate device object can be used
            //
            pDeviceObject->Flags &= ~(DO_DEVICE_INITIALIZING);

            pIrp->IoStatus.Status      = Status;
            pIrp->IoStatus.Information = 0;

            IoCompleteRequest(pIrp, IO_NO_INCREMENT);
            return (Status);

            break;

        case IRP_MN_QUERY_REMOVE_DEVICE:
            //
            //  Always pass to lower device in stack after indicating that we don't object
            //
            DebugDump(SERALWAYS,("IRP_MN_QUERY_REMOVE_DEVICE\n"));

            Extension->Removing = TRUE;

            IoCopyCurrentIrpStackLocationToNext( pIrp );
            return (IoCallDriver(Extension->LowerDevice, pIrp));

            break;

        case IRP_MN_CANCEL_REMOVE_DEVICE:
            //
            //  Always pass to lower device in stack , reset indicator as somebody canceled
            //
            DebugDump(SERALWAYS,("IRP_MN_CANCEL_REMOVE_DEVICE\n"));

            Extension->Removing = FALSE;

            //
            // Kill symbolic link
            //
            if (Extension->CreatedSymbolicLink) {
                IoDeleteSymbolicLink(&Extension->SymbolicLinkName);
                Extension->CreatedSymbolicLink = FALSE;
            }

            IoCopyCurrentIrpStackLocationToNext( pIrp );
            return (IoCallDriver(Extension->LowerDevice, pIrp));

            break;


        case IRP_MN_SURPRISE_REMOVAL:
            //
            // Should not ever happen with us, but still process
            //

            DebugDump(SERALWAYS,("IRP_MN_SURPRISE_REMOVAL\n"));

            Extension->Removing = TRUE;

            //
            //  Get rid of the symbolic link
            //
            SerScanHandleSymbolicLink(
                Extension->Pdo,
                &Extension->InterfaceNameString,
                FALSE
                );

            #ifdef USE_EXECUTIVE_RESOURCE
            ExAcquireResourceExclusiveLite(
                &Extension->Resource,
                TRUE
                );
            #else
            ExAcquireFastMutex(&Extension->Mutex);
            #endif

            pObject = InterlockedExchangePointer(&Extension->AttachedFileObject,NULL);
            if (pObject) {
                ObDereferenceObject(pObject);
            }

            pObject = InterlockedExchangePointer(&Extension->AttachedDeviceObject,NULL);
            if (pObject) {
                ObDereferenceObject(pObject);
            }

            #ifdef USE_EXECUTIVE_RESOURCE
            ExReleaseResourceLite(&Extension->Resource);
            #else
            ExReleaseFastMutex(&Extension->Mutex);
            #endif

            IoCopyCurrentIrpStackLocationToNext( pIrp );
            return (IoCallDriver(Extension->LowerDevice, pIrp));


            break;

        case IRP_MN_REMOVE_DEVICE:

            DebugDump(SERALWAYS,("IRP_MN_REMOVE_DEVICE\n"));

            DebugDump(SERINITDEV,("Entering PnP Remove Device\n"));


            //
            // Stop new requests - device is being removed
            //
            Extension->Removing = TRUE;

            //
            //  Get rid of the symbolic link
            //
            SerScanHandleSymbolicLink(
                Extension->Pdo,
                &Extension->InterfaceNameString,
                FALSE
                );


            #ifdef USE_EXECUTIVE_RESOURCE
            ExAcquireResourceExclusiveLite(
                &Extension->Resource,
                TRUE
                );
            #else
            ExAcquireFastMutex(&Extension->Mutex);
            #endif

            pObject = InterlockedExchangePointer(&Extension->AttachedFileObject,NULL);
            if (pObject) {
                ObDereferenceObject(pObject);
            }

            pObject = InterlockedExchangePointer(&Extension->AttachedDeviceObject,NULL);
            if (pObject) {
                ObDereferenceObject(pObject);
            }

            #ifdef USE_EXECUTIVE_RESOURCE
            ExReleaseResourceLite(&Extension->Resource);
            #else
            ExReleaseFastMutex(&Extension->Mutex);
            #endif

            //
            // Send IRP down to lower device
            //
            IoCopyCurrentIrpStackLocationToNext( pIrp );
            ReturnStatus = IoCallDriver(Extension->LowerDevice, pIrp);

            //
            // Decrement ref count
            //
            NewReferenceCount = InterlockedDecrement(&Extension->ReferenceCount);

            if (NewReferenceCount != 0) {
                //
                // Wait for any io requests pending in our driver to
                // complete before finishing the remove
                //
                KeWaitForSingleObject(&Extension -> RemoveEvent,
                                      Suspended,
                                      KernelMode,
                                      FALSE,
                                      NULL);
            }

            // ASSERT(&Extension->ReferenceCount == 0);
            #ifdef USE_EXECUTIVE_RESOURCE
            ExDeleteResourceLite(&Extension->Resource);
            #endif

            DebugDump(SERALWAYS,("IRP_MN_QUERY_REMOVE_DEVICE - Calling IoDeleteDevice - gone\n"));

            IoDetachDevice(Extension->LowerDevice);

            //
            // Free allocated resource.
            //
            
            if(NULL != Extension->ClassName.Buffer){
                ExFreePool(Extension->ClassName.Buffer);
            } // if(NULL != Extension->ClassName.Buffer)

            if(NULL != Extension->SymbolicLinkName.Buffer){
                ExFreePool(Extension->SymbolicLinkName.Buffer);
            } // if(NULL != Extension->SymbolicLinkName.Buffer)

            IoDeleteDevice(pDeviceObject);

            return ReturnStatus;

            break;

        case IRP_MN_STOP_DEVICE:
            //
            // Pass down
            //
            DebugDump(SERALWAYS,("IRP_MN_STOP_DEVICE\n"));

            IoCopyCurrentIrpStackLocationToNext( pIrp );
            return (IoCallDriver(Extension->LowerDevice, pIrp));

            break;

        case IRP_MN_QUERY_STOP_DEVICE:
            //
            // Check open counts
            //
            DebugDump(SERALWAYS,("IRP_MN_QUERY_STOP_DEVICE\n"));

            if (Extension->OpenCount > 0 ) {
                DebugDump(SERALWAYS,("Rejecting QUERY_STOP_DEVICE\n"));

                pIrp->IoStatus.Status = STATUS_UNSUCCESSFUL;

                IoCompleteRequest(pIrp, IO_NO_INCREMENT);

                return STATUS_UNSUCCESSFUL;
            }

            IoCopyCurrentIrpStackLocationToNext( pIrp );
            return (IoCallDriver(Extension->LowerDevice, pIrp));

            break;


        case IRP_MN_CANCEL_STOP_DEVICE:
            //
            // Nothing to do here, but pass to lower
            //
            DebugDump(SERALWAYS,("IRP_MN_CANCEL_STOP_DEVICE\n"));

            IoCopyCurrentIrpStackLocationToNext( pIrp );
            return (IoCallDriver(Extension->LowerDevice, pIrp));

            break;


        case IRP_MN_QUERY_CAPABILITIES:
            {

                ULONG   i;
                KEVENT  WaitEvent;

                //
                // Send this down to the PDO first
                //

                KeInitializeEvent(&WaitEvent, SynchronizationEvent, FALSE);

                IoCopyCurrentIrpStackLocationToNext(pIrp);

                Status=WaitForLowerDriverToCompleteIrp(
                    Extension->LowerDevice,
                    pIrp,
                    &WaitEvent
                    );

                pIrpStack = IoGetCurrentIrpStackLocation(pIrp);

                for (i = PowerSystemUnspecified; i < PowerSystemMaximum;   i++) {

                    Extension->SystemPowerStateMap[i]=PowerDeviceD3;
                }

                for (i = PowerSystemUnspecified; i < PowerSystemHibernate;  i++) {

                    Extension->SystemPowerStateMap[i]=pIrpStack->Parameters.DeviceCapabilities.Capabilities->DeviceState[i];
                }

                Extension->SystemPowerStateMap[PowerSystemWorking]=PowerDeviceD0;

                Extension->SystemWake=pIrpStack->Parameters.DeviceCapabilities.Capabilities->SystemWake;
                Extension->DeviceWake=pIrpStack->Parameters.DeviceCapabilities.Capabilities->DeviceWake;

                IoCompleteRequest(
                    pIrp,
                    IO_NO_INCREMENT
                    );
                return Status;
            }

            break;

        default:

            //
            // Unknown function - pass down
            //
            DebugDump(SERALWAYS,("Passing Pnp Irp down. MnFunc=%x ,  status = %x\n",pIrpStack->MinorFunction, Status));

            IoCopyCurrentIrpStackLocationToNext( pIrp );
            return (IoCallDriver(Extension->LowerDevice, pIrp));

            break;
    }

    //
    // Complete the IRP...
    //

    if (!NT_SUCCESS(Status)) {
        pIrp -> IoStatus.Status = Status;
        pIrp->IoStatus.Information = 0;
        IoCompleteRequest( pIrp, IO_NO_INCREMENT );
    }
    else {

        DebugDump(SERALWAYS,("Passing Pnp Irp down,  status = %x\n", Status));

        IoCopyCurrentIrpStackLocationToNext(pIrp);
        Status = IoCallDriver(Extension->LowerDevice, pIrp);
    }

    return( Status );

}


VOID
DevicePowerCompleteRoutine(
    PDEVICE_OBJECT    DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
{

    return;
}


NTSTATUS
SerScanPower(
        IN PDEVICE_OBJECT pDeviceObject,
        IN PIRP           pIrp
    )
/*++

Routine Description:

    Process the Power IRPs sent to the PDO for this device.

Arguments:

    pDeviceObject - pointer to the functional device object (FDO) for this device.
    pIrp          - pointer to an I/O Request Packet

Return Value:

    NT status code

--*/
{
    NTSTATUS            Status;
    PDEVICE_EXTENSION   Extension = pDeviceObject->DeviceExtension;
    PIO_STACK_LOCATION  pIrpStack = IoGetCurrentIrpStackLocation(pIrp);
    POWER_STATE         PowerState;

    PAGED_CODE();

    Status     = STATUS_SUCCESS;

    switch (pIrpStack->MinorFunction) {

        case IRP_MN_SET_POWER:

            if (pIrpStack->Parameters.Power.Type == SystemPowerState) {
                //
                //  system power state change
                //
                //
                //  request the change in device power state based on systemstate map
                //
                PowerState.DeviceState=Extension->SystemPowerStateMap[pIrpStack->Parameters.Power.State.SystemState];

                PoRequestPowerIrp(
                    Extension->Pdo,
                    IRP_MN_SET_POWER,
                    PowerState,
                    DevicePowerCompleteRoutine,
                    pIrp,
                    NULL
                    );


            }  else {
                //
                //  changing device state
                //
                PoSetPowerState(
                    Extension->Pdo,
                    pIrpStack->Parameters.Power.Type,
                    pIrpStack->Parameters.Power.State
                    );

            }

            break;

        case IRP_MN_QUERY_POWER:

            pIrp->IoStatus.Status = STATUS_SUCCESS;

            break;

        default:

            break;

    }

    PoStartNextPowerIrp(pIrp);

    IoSkipCurrentIrpStackLocation(pIrp);

    Status=PoCallDriver(Extension->LowerDevice, pIrp);

    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\printscan\wia\kernel\serscan\serscan.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    serscan.c

Abstract:

    This module contains the code for a serial imaging devices
    suport class driver.

Author:

    Vlad Sadovsky    vlads              10-April-1998

Environment:

    Kernel mode

Revision History :

    vlads           04/10/1998      Created first draft

--*/

#include "serscan.h"
#include "serlog.h"

#include <initguid.h>

#include <devguid.h>
#include <wiaintfc.h>

#if DBG
ULONG SerScanDebugLevel = -1;
#endif

const PHYSICAL_ADDRESS PhysicalZero = {0};

//
// Keep track of the number of Serial port devices created...
//
ULONG g_NumPorts = 0;

//
// Definition of OpenCloseMutex.
//
extern ULONG OpenCloseReferenceCount = 1;
extern PFAST_MUTEX OpenCloseMutex = NULL;

//
//
#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, SerScanAddDevice)
#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine is called at system initialization time to initialize
    this driver.

Arguments:

    DriverObject    - Supplies the driver object.

    RegistryPath    - Supplies the registry path for this driver.

Return Value:

    STATUS_SUCCESS          - We could initialize at least one device.
    STATUS_NO_SUCH_DEVICE   - We could not in itialize even one device.

--*/

{

    int     i;

    PAGED_CODE();

    #if DBG
    DebugDump(SERINITDEV,("Entering DriverEntry\n"));
    #endif

    //
    // Initialize the Driver Object with driver's entry points
    //
    DriverObject->DriverExtension->AddDevice              = SerScanAddDevice;

    DriverObject->DriverUnload = SerScanUnload;

    #ifdef DEAD_CODE
    for (i=0; i < IRP_MJ_MAXIMUM_FUNCTION; i++) {

        DriverObject->MajorFunction[i]= SerScanPassThrough;
    }
    #endif

    DriverObject->MajorFunction[IRP_MJ_CREATE]            = SerScanCreateOpen;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]             = SerScanClose;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]    = SerScanDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_PNP]               = SerScanPnp;
    DriverObject->MajorFunction[IRP_MJ_POWER]             = SerScanPower;

    //
    // Following are possibly not needed, keep them here to allow
    // easier tracing in when debugging. All of them resort to pass-through
    // behaviour
    //
    #ifdef DEAD_CODE

    DriverObject->MajorFunction[IRP_MJ_CLEANUP]           = SerScanCleanup;
    DriverObject->MajorFunction[IRP_MJ_QUERY_INFORMATION] = SerScanQueryInformationFile;
    DriverObject->MajorFunction[IRP_MJ_SET_INFORMATION]   = SerScanSetInformationFile;

    #endif

    DriverObject->MajorFunction[IRP_MJ_READ]              = SerScanPassThrough;
    DriverObject->MajorFunction[IRP_MJ_WRITE]             = SerScanPassThrough;

    return STATUS_SUCCESS;

}


NTSTATUS
SerScanAddDevice(
    IN PDRIVER_OBJECT pDriverObject,
    IN PDEVICE_OBJECT pPhysicalDeviceObject
    )
/*++

Routine Description:

    This routine is called to create a new instance of the device.
    It creates FDO and attaches it to PDO

Arguments:

    pDriverObject           - pointer to the driver object for this instance of port.

    pPhysicalDeviceObject   - pointer to the device object that represents the port.

Return Value:

    STATUS_SUCCESS          - if successful.
    STATUS_UNSUCCESSFUL     - otherwise.

--*/
{
    UNICODE_STRING      ClassName;
    UNICODE_STRING      LinkName;
    NTSTATUS            Status;
    PDEVICE_EXTENSION   Extension;
    PDEVICE_OBJECT      pDeviceObject;

    PAGED_CODE();


    DebugDump(SERINITDEV,("Entering AddDevice\n"));

    //
    // Get the Class and Link names.
    //

    if (!SerScanMakeNames (g_NumPorts, &ClassName, &LinkName)) {

        SerScanLogError(pDriverObject,
                        NULL,
                        PhysicalZero,
                        PhysicalZero,
                        0,
                        0,
                        0,
                        1,
                        STATUS_SUCCESS,
                        SER_INSUFFICIENT_RESOURCES);

        DebugDump(SERERRORS,("SerScan: Could not form Unicode name strings.\n"));

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Create the device object for this device.
    //

    Status = IoCreateDevice(pDriverObject,
                            sizeof(DEVICE_EXTENSION),
                            &ClassName,
                            FILE_DEVICE_SCANNER,
                            0,
                            TRUE,
                            &pDeviceObject);


    if (!NT_SUCCESS(Status)) {

        ExFreePool(ClassName.Buffer);
        ExFreePool(LinkName.Buffer);

        SerScanLogError(pDriverObject,
                        NULL,
                        PhysicalZero,
                        PhysicalZero,
                        0,
                        0,
                        0,
                        9,
                        STATUS_SUCCESS,
                        SER_INSUFFICIENT_RESOURCES);

        DebugDump(SERERRORS, ("SERPORT:  Could not create a device for %d\n", g_NumPorts));

        return Status;
    }

    //
    // The device object has a pointer to an area of non-paged
    // pool allocated for this device.  This will be the device
    // extension.
    //

    Extension = pDeviceObject->DeviceExtension;

    //
    // Zero all of the memory associated with the device
    // extension.
    //

    RtlZeroMemory(Extension, sizeof(DEVICE_EXTENSION));

    //
    // Get a "back pointer" to the device object.
    //

    Extension->DeviceObject = pDeviceObject;

    Extension->Pdo = pPhysicalDeviceObject;

    Extension->AttachedDeviceObject = NULL;
    Extension->AttachedFileObject = NULL;

    //
    // Setup buffered I/O
    //
    pDeviceObject->Flags |= DO_BUFFERED_IO;

    //
    // Indicate our power code is pageable
    //
    pDeviceObject->Flags |= DO_POWER_PAGABLE;

    //
    // Attach our new Device to our parents stack.
    //
    Extension->LowerDevice = IoAttachDeviceToDeviceStack(
                                  pDeviceObject,
                                  pPhysicalDeviceObject);

    if (NULL == Extension->LowerDevice) {

        ExFreePool(ClassName.Buffer);
        ExFreePool(LinkName.Buffer);

        IoDeleteDevice(pDeviceObject);

        return STATUS_UNSUCCESSFUL;
    }

    Extension->ClassName        = ClassName;
    Extension->SymbolicLinkName = LinkName;

    Status = SerScanHandleSymbolicLink(
        pPhysicalDeviceObject,
        &Extension->InterfaceNameString,
        TRUE
        );

    //
    // We have created the device, so increment the counter
    // that keeps track.
    //
    g_NumPorts++;

    //
    // Initiliaze the rest of device extension
    //
    Extension->ReferenceCount = 1;

    Extension->Removing = FALSE;

    Extension->OpenCount = 0;

    KeInitializeEvent(&Extension->RemoveEvent,
                      NotificationEvent,
                      FALSE
                      );

    // ExInitializeResourceLite(&Extension->Resource);
    ExInitializeFastMutex(&Extension->Mutex);

    //
    // Clear InInit flag to indicate device object can be used
    //
    pDeviceObject->Flags &= ~(DO_DEVICE_INITIALIZING);


    return STATUS_SUCCESS;

}

BOOLEAN
SerScanMakeNames(
    IN  ULONG           SerialPortNumber,
    OUT PUNICODE_STRING ClassName,
    OUT PUNICODE_STRING LinkName
    )

/*++

Routine Description:

    This routine generates the names \Device\SerScanN.

    This routine will allocate pool so that the buffers of
    these unicode strings need to be eventually freed.

Arguments:

    SerialPortNumber  - Supplies the serial port number.

    ClassName           - Returns the class name.

    LinkName            - Returns the link name.

Return Value:

    FALSE   - Failure.
    TRUE    - Success.

--*/
{
    UNICODE_STRING  Prefix;
    UNICODE_STRING  Digits;
    UNICODE_STRING  LinkPrefix;
    UNICODE_STRING  LinkDigits;
    WCHAR           DigitsBuffer[10];
    WCHAR           LinkDigitsBuffer[10];
    UNICODE_STRING  ClassSuffix;
    UNICODE_STRING  LinkSuffix;
    NTSTATUS        Status;

    //
    // Put together local variables for constructing names.
    //

    RtlInitUnicodeString(&Prefix, L"\\Device\\");
    RtlInitUnicodeString(&LinkPrefix, L"\\DosDevices\\");

    //
    // WORKWORK: Change the name to be device specific.
    //
    RtlInitUnicodeString(&ClassSuffix, SERSCAN_NT_SUFFIX);
    RtlInitUnicodeString(&LinkSuffix, SERSCAN_LINK_NAME);

    Digits.Length        = 0;
    Digits.MaximumLength = 20;
    Digits.Buffer        = DigitsBuffer;

    LinkDigits.Length        = 0;
    LinkDigits.MaximumLength = 20;
    LinkDigits.Buffer        = LinkDigitsBuffer;

    Status = RtlIntegerToUnicodeString(SerialPortNumber, 10, &Digits);
    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    Status = RtlIntegerToUnicodeString(SerialPortNumber + 1, 10, &LinkDigits);
    if (!NT_SUCCESS(Status)) {
        return FALSE;
    }

    //
    // Make the class name.
    //

    ClassName->Length = 0;
    ClassName->MaximumLength = Prefix.Length + ClassSuffix.Length +
                               Digits.Length + sizeof(WCHAR);

    ClassName->Buffer = ExAllocatePool(PagedPool, ClassName->MaximumLength);
    if (!ClassName->Buffer) {
        return FALSE;
    }

    RtlZeroMemory(ClassName->Buffer, ClassName->MaximumLength);
    RtlAppendUnicodeStringToString(ClassName, &Prefix);
    RtlAppendUnicodeStringToString(ClassName, &ClassSuffix);
    RtlAppendUnicodeStringToString(ClassName, &Digits);

    //
    // Make the link name.
    //

    LinkName->Length = 0;
    LinkName->MaximumLength = LinkPrefix.Length + LinkSuffix.Length +
                              LinkDigits.Length + sizeof(WCHAR);

    LinkName->Buffer = ExAllocatePool(PagedPool, LinkName->MaximumLength);
    if (!LinkName->Buffer) {
        ExFreePool(ClassName->Buffer);
        return FALSE;
    }

    RtlZeroMemory(LinkName->Buffer, LinkName->MaximumLength);
    RtlAppendUnicodeStringToString(LinkName, &LinkPrefix);
    RtlAppendUnicodeStringToString(LinkName, &LinkSuffix);
    RtlAppendUnicodeStringToString(LinkName, &LinkDigits);

    return TRUE;
}


NTSTATUS
SerScanCleanup(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine is the dispatch for a cleanup requests.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    STATUS_SUCCESS  - Success.

--*/

{
    NTSTATUS            Status;
    PDEVICE_EXTENSION   Extension;

    Extension = DeviceObject->DeviceExtension;

    //
    // Call down to the parent and wait on the Cleanup IRP to complete...
    //
    Status = SerScanCallParent(Extension,
                               Irp,
                               WAIT,
                               NULL);

    DebugDump(SERIRPPATH,
              ("SerScan: [Cleanup] After CallParent Status = %x\n",
              Status));

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;
}

VOID
SerScanCancelRequest(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )

/*++

Routine Description:

    This routine is used to cancel any request in the Serial driver.

Arguments:

    DeviceObject - Pointer to the device object for this device

    Irp - Pointer to the IRP to be canceled.

Return Value:

    None.

--*/

{
    NTSTATUS            Status;
    PDEVICE_EXTENSION   Extension;

    Extension = DeviceObject->DeviceExtension;

    //
    // Call down to the parent and wait on the Cleanup IRP to complete...
    //
    Status = SerScanCallParent(Extension,
                               Irp,
                               WAIT,
                               NULL);

    DebugDump(SERIRPPATH,
              ("SerScan: [Cleanup] After CallParent Status = %x\n",
              Status));

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return;
}


NTSTATUS
SerScanQueryInformationFile(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine is used to query the end of file information on
    the opened Serial port.  Any other file information request
    is retured with an invalid parameter.

    This routine always returns an end of file of 0.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    STATUS_SUCCESS              - Success.
    STATUS_INVALID_PARAMETER    - Invalid file information request.
    STATUS_BUFFER_TOO_SMALL     - Buffer too small.

--*/

{
    NTSTATUS            Status;
    PDEVICE_EXTENSION   Extension;

    Extension = DeviceObject->DeviceExtension;

    Status = SerScanCallParent(Extension,
                               Irp,
                               WAIT,
                               NULL);

    DebugDump(SERIRPPATH,
              ("SerScan: [Cleanup] After CallParent Status = %x\n",
              Status));

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;
}


NTSTATUS
SerScanSetInformationFile(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )

/*++

Routine Description:

    This routine is used to set the end of file information on
    the opened Serial port.  Any other file information request
    is retured with an invalid parameter.

    This routine always ignores the actual end of file since
    the query information code always returns an end of file of 0.

Arguments:

    DeviceObject    - Supplies the device object.

    Irp             - Supplies the I/O request packet.

Return Value:

    STATUS_SUCCESS              - Success.
    STATUS_INVALID_PARAMETER    - Invalid file information request.

--*/

{
    NTSTATUS            Status;
    PDEVICE_EXTENSION   Extension;

    Extension = DeviceObject->DeviceExtension;

    Status = SerScanCallParent(Extension,
                               Irp,
                               WAIT,
                               NULL);

    DebugDump(SERIRPPATH,
              ("SerScan: [Cleanup] After CallParent Status = %x\n",
              Status));

    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return Status;
}

VOID
SerScanUnload(
    IN  PDRIVER_OBJECT  DriverObject
    )

/*++

Routine Description:

    This routine loops through the device list and cleans up after
    each of the devices.

Arguments:

    DriverObject    - Supplies the driver object.

Return Value:

    None.

--*/

{
    PDEVICE_OBJECT      CurrentDevice;
    PDEVICE_OBJECT      NextDevice;
    PDEVICE_EXTENSION   Extension;

    DebugDump(SERUNLOAD,
              ("SerScan: In SerUnload\n"));

    CurrentDevice = DriverObject->DeviceObject;
    while (NULL != CurrentDevice){

        Extension = CurrentDevice->DeviceExtension;


        if(NULL != Extension->SymbolicLinkName.Buffer){
            if (Extension->CreatedSymbolicLink) {
                IoDeleteSymbolicLink(&Extension->SymbolicLinkName);

                RtlDeleteRegistryValue(RTL_REGISTRY_DEVICEMAP,
                                       L"Serial Scanners",
                                       Extension->SymbolicLinkName.Buffer);
            } // if (Extension->CreatedSymbolicLink) 

            ExFreePool(Extension->SymbolicLinkName.Buffer);
            Extension->SymbolicLinkName.Buffer = NULL;
        } // if(NULL != Extension->SymbolicLinkName.Buffer)

        if(NULL != Extension->ClassName.Buffer){
            ExFreePool(Extension->ClassName.Buffer);
            Extension->ClassName.Buffer = NULL;
        } // if(NULL != Extension->ClassName.Buffer)

        NextDevice = CurrentDevice->NextDevice;
        IoDeleteDevice(CurrentDevice);

        CurrentDevice = NextDevice;
    } // while (CurrentDevice = DriverObject->DeviceObject)

}

NTSTATUS
SerScanHandleSymbolicLink(
    PDEVICE_OBJECT      DeviceObject,
    PUNICODE_STRING     InterfaceName,
    BOOLEAN             Create
    )
/*++

Routine Description:

Arguments:

    DriverObject    - Supplies the driver object.

Return Value:

    None.

--*/
{

    NTSTATUS           Status;

    Status = STATUS_SUCCESS;

    if (Create) {

        Status=IoRegisterDeviceInterface(
            DeviceObject,
            &GUID_DEVINTERFACE_IMAGE,
            NULL,
            InterfaceName
            );

        DebugDump(SERINITDEV,("Called IoRegisterDeviceInterface . Returned=0x%X\n",Status));


        if (NT_SUCCESS(Status)) {

            IoSetDeviceInterfaceState(
                InterfaceName,
                TRUE
                );

            DebugDump(SERINITDEV,("Called IoSetDeviceInterfaceState(TRUE) . \n"));

        }

    } else {

        if (InterfaceName->Buffer != NULL) {

            IoSetDeviceInterfaceState(
               