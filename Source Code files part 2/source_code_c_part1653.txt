ription: Builds the IPToGUID map by first getting information on all adapters and
 *              then retrieving the map of IP addresses to adapters.  Using those tables,
 *              this constructs a mapping of IP addresses to adapter GUIDs.
 * Returns: Returns ERROR_SUCCESS if successful.  Returns an error code otherwise.
 * Author: shouse 6.14.00 
 */
DWORD BuildIPToGUIDMap (void) {
    DWORD dwError = ERROR_SUCCESS;
    PMIB_IPADDRTABLE pAddressTable = NULL;
    PIP_ADAPTER_INFO pAdapterTable = NULL;
    DWORD dwAddressSize = 0;
    DWORD dwAdapterSize = 0;
    DWORD dwEntry;

    /* Destroy the IP to GUID map first. */
    if ((dwError = DestroyIPToGUIDMap()) != NO_ERROR) {
	TRACE_ERROR1("DestroyIPToGUIDMap failed: %d\n", dwError);
	return dwError;
    }

    /* Query the necessary length of a buffer to hold the adapter info. */
    if ((dwError = GetAdaptersInfo(pAdapterTable, &dwAdapterSize)) != ERROR_BUFFER_OVERFLOW) {
        TRACE_ERROR1("GetAdaptersInfo failed: %d\n", dwError);
        return dwError;
    }

    /* Allocate a buffer of the indicated size. */
    if (!(pAdapterTable = (PIP_ADAPTER_INFO)HeapAlloc(GetProcessHeap(), 0, dwAdapterSize))) {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        TRACE_ERROR1("HeapAlloc failed: %d\n", dwError);
        return dwError;
    }

    /* Fill the buffer with the adapter info. */
    if ((dwError = GetAdaptersInfo(pAdapterTable, &dwAdapterSize)) != NO_ERROR) {
        TRACE_ERROR1("GetAdaptersInfo failed: %d\n", dwError);
        return dwError;
    }

    /* Query the necessary length of a buffer to hold the IP address table. */
    if ((dwError = GetIpAddrTable(pAddressTable, &dwAddressSize, TRUE)) != ERROR_INSUFFICIENT_BUFFER) {
        TRACE_ERROR1("GetIpAddrTable failed: %d\n", dwError);
        return dwError;
    }

    /* Allocate a buffer of the indicated size. */
    if (!(pAddressTable = (PMIB_IPADDRTABLE)HeapAlloc(GetProcessHeap(), 0, dwAddressSize))) {
        dwError = ERROR_NOT_ENOUGH_MEMORY;
        TRACE_ERROR1("HeapAlloc failed: %d\n", dwError);
        return dwError;
    }

    /* Fill the buffer with the IP address table. */
    if ((dwError = GetIpAddrTable(pAddressTable, &dwAddressSize, TRUE)) != NO_ERROR) {
        TRACE_ERROR1("GetIpAddrTable failed: %d\n", dwError);
        return dwError;
    }

    /* For each entry in the IP address to adapter table, create an entry for our IP address to GUID table. */
    for (dwEntry = 0; dwEntry < pAddressTable->dwNumEntries; dwEntry++) {
        PCHAR pszDeviceName = NULL;
        IPToGUIDEntry * entry = NULL;
        
        /* Only create an entry if the IP address is nonzero and is not the IP loopback address. */
        if ((pAddressTable->table[dwEntry].dwAddr != 0UL) && (pAddressTable->table[dwEntry].dwAddr != IP_LOOPBACK_ADDRESS)) {
            WCHAR szAdapterGUID[CVY_MAX_DEVNAME_LEN];

            /* Retrieve the GUID from the interface index. */
            if (!(pszDeviceName = GetGUIDFromIndex(pAdapterTable, pAddressTable->table[dwEntry].dwIndex))) {
                dwError = ERROR_INCORRECT_ADDRESS;
                TRACE_ERROR1("GetGUIDFromIndex failed: %d\n", dwError);
                return dwError;
            }
            
            /* Allocate a buffer for the IP to GUID entry. */
            if (!(entry = (IPToGUIDEntry *)HeapAlloc(GetProcessHeap(), 0, sizeof(IPToGUIDEntry)))) {
                dwError = ERROR_NOT_ENOUGH_MEMORY;
                TRACE_ERROR1("HeapAlloc failed: %d\n", dwError);
                return dwError;
            }
            
            /* Zero the entry contents. */
            ZeroMemory((VOID *)entry, sizeof(entry));
            
            /* Insert the entry at the head of the linked list indexed by the IP address % HASH. */
            entry->pNext = IPToGUIDMap[pAddressTable->table[dwEntry].dwAddr % IP_TO_GUID_HASH];
            IPToGUIDMap[pAddressTable->table[dwEntry].dwAddr % IP_TO_GUID_HASH] = entry;
            
            /* Fill in the IP address. */
            entry->dwIPAddress = pAddressTable->table[dwEntry].dwAddr;
            
            /* GUIDS in NLB multi-NIC are expected to be prefixed with "\DEVICE\". */
            lstrcpy(entry->szAdapterGUID, L"\\DEVICE\\");

            /* Convert the adapter name ASCII string to a GUID unicode string and place it in the table entry. */
            if (!MultiByteToWideChar(CP_ACP, 0, pszDeviceName, -1, szAdapterGUID, CVY_MAX_DEVNAME_LEN)) {
                dwError = GetLastError();
                TRACE_ERROR1("MultiByteToWideChar failed: %d\n", dwError);
                return dwError;
            }

            /* Cat the GUID onto the "\DEVICE\". */
            lstrcat(entry->szAdapterGUID, szAdapterGUID);
        }
    }
    
    /* Free the buffers used to query the IP stack. */
    if (pAddressTable) HeapFree(GetProcessHeap(), 0, pAddressTable);
    if (pAdapterTable) HeapFree(GetProcessHeap(), 0, pAdapterTable);

    PrintIPToGUIDMap();

    return dwError;
}

/*
 * Function: WlbsConnectionNotificationInit
 * Description: Initialize connection notification by retrieving the device driver
 *              information for later use by IOCTLs and build the IPToGUID map.
 * Returns: Returns ERROR_SUCCESS if successful.  Returns an error code otherwise.
 * Author: shouse 6.15.00 
 */
DWORD WlbsConnectionNotificationInit () {
    DWORD dwError = ERROR_SUCCESS;
    WCHAR szDriver[CVY_STR_SIZE];

    swprintf(szDevice, L"\\\\.\\%ls", CVY_NAME);

    /* Query for the existence of the WLBS driver. */
    if (!QueryDosDevice(szDevice + 4, szDriver, CVY_STR_SIZE)) {
        dwError = GetLastError();
        TRACE_ERROR1("QueryDosDevice failed: %d\n", dwError);
        return dwError;
    }

    /* Build the IP to GUID mapping. */
    if ((dwError = BuildIPToGUIDMap()) != ERROR_SUCCESS) {
        TRACE_ERROR1("BuildIPToGUIDMap failed: %d\n", dwError);
        return dwError;
    }

    /* Create an IP address change event. */
    if (!(hAddrChangeEvent = CreateEvent(NULL, FALSE, FALSE, L"NLB Connection Notification IP Address Change Event"))) {
        dwError = GetLastError();
        TRACE_ERROR1("CreateEvent failed: %d\n", dwError);
        return dwError;
    }

    /* Clear the overlapped structure. */
    ZeroMemory(&AddrChangeOverlapped, sizeof(OVERLAPPED));

    /* Place the event handle in the overlapped structure. */
    AddrChangeOverlapped.hEvent = hAddrChangeEvent;

    /* Tell IP to notify us of any changes to the IP address to interface mapping. */
    dwError = NotifyAddrChange(&hAddrChangeHandle, &AddrChangeOverlapped);

    if ((dwError != NO_ERROR) && (dwError != ERROR_IO_PENDING)) {
        TRACE_ERROR1("NotifyAddrChange failed: %d\n", dwError);
        return dwError;
    }

    return ERROR_SUCCESS;
}

/*
 * Function: ResolveAddressTableChanges
 * Description: Checks for changes in the IP address to adapter mapping and rebuilds the
 *              IPToGUID map if necessary.
 * Returns: Returns ERROR_SUCCESS upon success.  Returns an error code otherwise.
 * Author: shouse 6.20.00
 */
DWORD ResolveAddressTableChanges () {
    DWORD dwError = ERROR_SUCCESS;
    DWORD dwLength = 0;

    /* Check to see if the IP address to adapter table has been modified. */
    if (GetOverlappedResult(hAddrChangeHandle, &AddrChangeOverlapped, &dwLength, FALSE)) {
        TRACE("IP address to adapter table modified... Rebuilding IP to GUID map...\n");
        
        /* If so, rebuild the IP address to GUID mapping. */
        if ((dwError = BuildIPToGUIDMap()) != ERROR_SUCCESS) {
            TRACE_ERROR1("BuildIPToGUIDMap failed: %d\n", dwError);
            return dwError;
        }

        /* Tell IP to notify us of any changes to the IP address to interface mapping. */        
        dwError = NotifyAddrChange(&hAddrChangeHandle, &AddrChangeOverlapped);

        if ((dwError != NO_ERROR) && (dwError != ERROR_IO_PENDING)) {
            TRACE_ERROR1("NotifyAddrChange failed: %d\n", dwError);
            return dwError;
        }
    }

    return ERROR_SUCCESS;
}

/*
 * Function: WlbsConnectionNotify
 * Description: Used to notify the WLBS load module that a connection has been established, reset or closed.
 * Returns: Returns ERROR_SUCCESS if successful.  Returns an error code otherwise.
 * Author: shouse 6.13.00 
 */
DWORD WINAPI WlbsConnectionNotify (DWORD ServerIp, WORD ServerPort, DWORD ClientIp, WORD ClientPort, USHORT Protocol, NLB_CONN_NOTIFICATION_OPERATION Operation, PULONG NLBStatusEx) {
    IOCTL_LOCAL_HDR Header;
    DWORD           dwError = ERROR_SUCCESS;
    PWCHAR          pszAdapterGUID = NULL;
    HANDLE          hDescriptor;
    DWORD           dwLength = 0;

    /* By default, the extended NLB status is success. */
    *NLBStatusEx = NLB_ERROR_SUCCESS;

    /* If not done so already, initialize connection notification support. */
    if (!fInitialized) {
        if ((dwError = WlbsConnectionNotificationInit()) != ERROR_SUCCESS) {
            TRACE_ERROR1("WlbsConnectionNotificationInit failed: %d\n", dwError);
            return dwError;
        }

        fInitialized = TRUE;
    }

    /* Zero the IOCTL input and output buffers. */
    ZeroMemory((VOID *)&Header, sizeof(IOCTL_LOCAL_HDR));

    /* Resolve any changes to the IP address table before we map this IP address. */
    if ((dwError = ResolveAddressTableChanges()) != ERROR_SUCCESS) {
        TRACE_ERROR1("CheckForAddressTableChanges failed: %d\n", dwError);
        return dwError;
    }

    /* Retrieve the GUID corresponding to the adapter on which this IP address is configured. */
    if (!(pszAdapterGUID = GetGUIDFromIP(ServerIp))) {
        dwError = ERROR_INCORRECT_ADDRESS;
        TRACE_ERROR1("GetGUIDFromIP failed: %d\n", dwError);
        return dwError;
    }

    /* Copy the GUID into the IOCTL input buffer. */
    lstrcpy(Header.device_name, pszAdapterGUID);

    /* Copy the function parameters into the IOCTL input buffer. */
    Header.options.notify.flags = 0;
    Header.options.notify.conn.Operation = Operation;
    Header.options.notify.conn.ServerIPAddress = ServerIp;
    Header.options.notify.conn.ServerPort = ServerPort;
    Header.options.notify.conn.ClientIPAddress = ClientIp;
    Header.options.notify.conn.ClientPort = ClientPort;
    Header.options.notify.conn.Protocol = Protocol;

    PrintIPAddress(ServerIp);
    TRACE1(" maps to GUID %ws\n", Header.device_name);
    
    /* Open the device driver. */
    if ((hDescriptor = CreateFile(szDevice, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, 0)) == INVALID_HANDLE_VALUE) {
        dwError = GetLastError();
        *NLBStatusEx = NLB_ERROR_NOT_BOUND;
        TRACE_ERROR1("CreateFile failed: %d\n", dwError);
        return dwError;
    }
    
    /* Use an IOCTL to notify the WLBS driver that a connection has gone up. */
    if (!DeviceIoControl(hDescriptor, IOCTL_CVY_CONNECTION_NOTIFY, &Header, sizeof(IOCTL_LOCAL_HDR), &Header, sizeof(IOCTL_LOCAL_HDR), &dwLength, NULL)) {
        dwError = GetLastError();
        CloseHandle(hDescriptor);
        TRACE_ERROR1("DeviceIoControl failed: %d\n", dwError);
        return dwError;
    }

    /* Make sure the expected number of bytes was returned by the IOCTL. */
    if (dwLength != sizeof(IOCTL_LOCAL_HDR)) {
        dwError = ERROR_GEN_FAILURE;
        CloseHandle(hDescriptor);
        TRACE_ERROR1("DeviceIoControl failed: %d\n", dwError);
        return dwError;
    }

    /*
      Return code can be one of:

      NLB_ERROR_SUCCESS, if the notification is accepted.
      NLB_ERROR_REQUEST_REFUSED, if the notification is rejected
      NLB_ERROR_INVALID_PARAMETER, if the arguments are invalid.
      NLB_ERROR_NOT_FOUND, if NLB was not bound to the specified adapter..
      NLB_ERROR_GENERIC_FAILURE, if a non-specific error occurred.
    */

    /* Pass the return code from the driver back to the caller. */
    *NLBStatusEx = Header.options.notify.conn.ReturnCode;

    /* Close the device driver. */
    CloseHandle(hDescriptor);

    return dwError;
}

/*
 * Function: 
 * Description: 
 * Returns: 
 * Author: shouse 6.13.00 
 */
DWORD WINAPI WlbsConnectionUp (DWORD ServerIp, WORD ServerPort, DWORD ClientIp, WORD ClientPort, USHORT Protocol, PULONG NLBStatusEx) {
    
    return WlbsConnectionNotify(ServerIp, ServerPort, ClientIp, ClientPort, Protocol, NLB_CONN_UP, NLBStatusEx);
}

/*
 * Function: 
 * Description: 
 * Returns: 
 * Author: shouse 6.13.00 
 */
DWORD WINAPI WlbsConnectionDown (DWORD ServerIp, WORD ServerPort, DWORD ClientIp, WORD ClientPort, USHORT Protocol, PULONG NLBStatusEx) {

    return WlbsConnectionNotify(ServerIp, ServerPort, ClientIp, ClientPort, Protocol, NLB_CONN_DOWN, NLBStatusEx);
}

/*
 * Function: 
 * Description: 
 * Returns: 
 * Author: shouse 6.13.00 
 */
DWORD WINAPI WlbsConnectionReset (DWORD ServerIp, WORD ServerPort, DWORD ClientIp, WORD ClientPort, USHORT Protocol, PULONG NLBStatusEx) {

    return WlbsConnectionNotify(ServerIp, ServerPort, ClientIp, ClientPort, Protocol, NLB_CONN_RESET, NLBStatusEx);
}

#else

DWORD WINAPI WlbsConnectionUp (DWORD ServerIp, WORD ServerPort, DWORD ClientIp, WORD ClientPort, USHORT Protocol, PULONG NLBStatusEx) { return ERROR_SUCCESS; }
DWORD WINAPI WlbsConnectionDown (DWORD ServerIp, WORD ServerPort, DWORD ClientIp, WORD ClientPort, USHORT Protocol, PULONG NLBStatusEx) { return ERROR_SUCCESS; }
DWORD WINAPI WlbsConnectionReset (DWORD ServerIp, WORD ServerPort, DWORD ClientIp, WORD ClientPort, USHORT Protocol, PULONG NLBStatusEx) { return ERROR_SUCCESS; }

#endif /* NLB_SESSION_SUPPORT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\componentdef\makefile.inc ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\api\precomp.h ===
#include <windows.h>
#include <winsock2.h>
#include <stdlib.h>
#include <stdio.h>
#include <locale.h>
#include <tchar.h>
#include <setupapi.h>
#include <devguid.h>
#include <objbase.h>
#include <shlwapi.h>

#include <wlbsctrl.h>
#include <wlbsparm.h>
#include <wlbsiocl.h>
#include <wlbsconfig.h>
#include <tracelog.h>
#include <wlbsutil.h>


#include "license.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\api\params.cpp ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    params.cpp

Abstract:

    Windows Load Balancing Service (WLBS)
    API - registry parameters support

Author:

    kyrilf

--*/

#include "precomp.h"
#include "cluster.h"
#include "control.h"
#include "param.h"
#include "debug.h"
#include "params.tmh" // for event tracing

extern HINSTANCE g_hInstCtrl; // Global variable for the dll instance, defined in control.cpp

HKEY WINAPI RegOpenWlbsSetting(const GUID& AdapterGuid, bool fReadOnly)
{
    WCHAR        reg_path [PARAMS_MAX_STRING_SIZE];
    WCHAR szAdapterGuid[128];
    
    StringFromGUID2(AdapterGuid, szAdapterGuid, 
                sizeof(szAdapterGuid)/sizeof(szAdapterGuid[0]) );
            
    swprintf (reg_path, L"SYSTEM\\CurrentControlSet\\Services\\WLBS\\Parameters\\Interface\\%s",
                szAdapterGuid);

    HKEY hKey = NULL;
    RegOpenKeyEx (HKEY_LOCAL_MACHINE, reg_path, 0L,
                           fReadOnly? KEY_READ : KEY_WRITE, & hKey);

    return hKey;
        
}

//+----------------------------------------------------------------------------
//
// Function:  TransformOldPortRulesToNew
//
// Description: Transforms port rules contained in structures without the virtual 
//              ip address into the new ones that do
//
// Arguments: Array of Old Port Rules, Array of New Port Rules, Length of Array 
//
// Returns:   void
//
// History:   KarthicN, Created on 3/19/01
//
//+----------------------------------------------------------------------------
void TransformOldPortRulesToNew(PWLBS_OLD_PORT_RULE  p_old_port_rules,
                                PWLBS_PORT_RULE      p_new_port_rules, 
                                DWORD                num_rules)
{
    if (num_rules == 0) 
        return;
            
    while(num_rules--)
    {
        lstrcpy(p_new_port_rules->virtual_ip_addr, CVY_DEF_ALL_VIP);
        p_new_port_rules->start_port      = p_old_port_rules->start_port;
        p_new_port_rules->end_port        = p_old_port_rules->end_port;
 #ifdef WLBSAPI_INTERNAL_ONLY
        p_new_port_rules->code            = p_old_port_rules->code;
 #else
        p_new_port_rules->Private1        = p_old_port_rules->Private1;
 #endif
        p_new_port_rules->mode            = p_old_port_rules->mode;
        p_new_port_rules->protocol        = p_old_port_rules->protocol;

 #ifdef WLBSAPI_INTERNAL_ONLY
        p_new_port_rules->valid           = p_old_port_rules->valid;
 #else
        p_new_port_rules->Private2        = p_old_port_rules->Private2;
 #endif
        switch (p_new_port_rules->mode) 
        {
        case CVY_MULTI :
             p_new_port_rules->mode_data.multi.equal_load = p_old_port_rules->mode_data.multi.equal_load;
             p_new_port_rules->mode_data.multi.affinity   = p_old_port_rules->mode_data.multi.affinity;
             p_new_port_rules->mode_data.multi.load       = p_old_port_rules->mode_data.multi.load;
             break;
        case CVY_SINGLE :
             p_new_port_rules->mode_data.single.priority  = p_old_port_rules->mode_data.single.priority;
             break;
        default:
             break;
        }
        p_old_port_rules++;
        p_new_port_rules++;
    }

    return;
}

/* Open the bi-directional affinity teaming registry key for a specified adapter. */
HKEY WINAPI RegOpenWlbsBDASettings (const GUID& AdapterGuid, bool fReadOnly) {
    WCHAR reg_path[PARAMS_MAX_STRING_SIZE];
    WCHAR szAdapterGuid[128];
    HKEY  hKey = NULL;
    DWORD dwRet;
    
    StringFromGUID2(AdapterGuid, szAdapterGuid, sizeof(szAdapterGuid)/sizeof(szAdapterGuid[0]));
            
    swprintf(reg_path, L"SYSTEM\\CurrentControlSet\\Services\\WLBS\\Parameters\\Interface\\%ls\\%ls", szAdapterGuid, CVY_NAME_BDA_TEAMING);

    dwRet = RegOpenKeyEx(HKEY_LOCAL_MACHINE, reg_path, 0L, fReadOnly ? KEY_READ : KEY_WRITE, &hKey);

    if (dwRet != ERROR_SUCCESS) {
        LOG_ERROR2("RegOpenWlbsBDASettings for %ls failed with error 0x%08x", szAdapterGuid, dwRet);
        return NULL;
    }

    return hKey;
}

/* Create the bi-directional affinity teaming registry key for a specified adapter. */
HKEY WINAPI RegCreateWlbsBDASettings (const GUID& AdapterGuid) {
    WCHAR reg_path[PARAMS_MAX_STRING_SIZE];
    WCHAR szAdapterGuid[128];
    HKEY  hKey = NULL;
    DWORD dwRet;
    DWORD disp;

    StringFromGUID2(AdapterGuid, szAdapterGuid, sizeof(szAdapterGuid)/sizeof(szAdapterGuid[0]));
            
    swprintf(reg_path, L"SYSTEM\\CurrentControlSet\\Services\\WLBS\\Parameters\\Interface\\%ls\\%ls", szAdapterGuid, CVY_NAME_BDA_TEAMING);
    
    dwRet = RegCreateKeyEx(HKEY_LOCAL_MACHINE, reg_path, 0L, L"", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, &hKey, &disp);

    if (dwRet != ERROR_SUCCESS) {
        LOG_ERROR2("RegCreateWlbsBDASettings for %ls failed with error 0x%08x", szAdapterGuid, dwRet);
        return NULL;
    }

    return hKey;
}

/* Delete the bi-directional affinity teaming registry key for a specified adapter. */
bool WINAPI RegDeleteWlbsBDASettings (const GUID& AdapterGuid) {
    WCHAR reg_path[PARAMS_MAX_STRING_SIZE];
    WCHAR szAdapterGuid[128];
    DWORD dwRet;
    
    StringFromGUID2(AdapterGuid, szAdapterGuid, sizeof(szAdapterGuid)/sizeof(szAdapterGuid[0]));
            
    swprintf(reg_path, L"SYSTEM\\CurrentControlSet\\Services\\WLBS\\Parameters\\Interface\\%ls\\%ls", szAdapterGuid, CVY_NAME_BDA_TEAMING);

    dwRet = RegDeleteKey(HKEY_LOCAL_MACHINE, reg_path);

    if (dwRet != ERROR_SUCCESS) {
        LOG_ERROR2("RegDeleteWlbsBDASettings for %ls failed with error 0x%08x", szAdapterGuid, dwRet);
        return FALSE;
    }

    return TRUE;
}

//+----------------------------------------------------------------------------
//
// Function:  ParamReadReg
//
// Description:  Read cluster settings from registry
//
// Arguments: const GUID& AdapterGuid - IN, Adapter guid
//            PWLBS_REG_PARAMS paramp - OUT Registry parameters
//            bool fUpgradeFromWin2k, whether this is a upgrade from Win2k 
//              or earlier version
//
// Returns:   bool  - true if succeeded
//
// History:   fengsun Created Header    3/9/00
//
//+----------------------------------------------------------------------------
bool WINAPI ParamReadReg(const GUID& AdapterGuid, 
    PWLBS_REG_PARAMS paramp, bool fUpgradeFromWin2k, bool *pfPortRulesInBinaryForm)
{
    HKEY            bda_key = NULL;
    HKEY            key;
    LONG            status;
    DWORD           type;
    DWORD           size;
    ULONG           i, code;
    WLBS_PORT_RULE* rp;
    WCHAR           reg_path [PARAMS_MAX_STRING_SIZE];


    memset (paramp, 0, sizeof (*paramp));


    //
    // For win2k or NT4, only one cluster is supported, there is no per adapter settings 
    //
    if (fUpgradeFromWin2k)
    {
        swprintf (reg_path, L"SYSTEM\\CurrentControlSet\\Services\\WLBS\\Parameters");
        status = RegOpenKeyEx (HKEY_LOCAL_MACHINE, reg_path, 0L,
                           KEY_QUERY_VALUE, & key);

        if (status != ERROR_SUCCESS)
        {
            return false;
        }
    }
    else
    {
        key = RegOpenWlbsSetting(AdapterGuid, true);

        if (key == NULL)
        {
            return false;
        }
    }
    

    swprintf (reg_path, L"%ls", CVY_NAME_INSTALL_DATE);
    size = sizeof (paramp -> install_date);
    status = RegQueryValueEx (key, reg_path, 0L, & type,
                              (LPBYTE) & paramp -> install_date, & size);

    if (status != ERROR_SUCCESS)
        paramp -> install_date = 0;

    swprintf (reg_path, L"%ls", CVY_NAME_VERIFY_DATE);
    size = sizeof (paramp -> i_verify_date);
    status = RegQueryValueEx (key, reg_path, 0L, & type,
                              (LPBYTE) & paramp -> i_verify_date, & size);

    if (status != ERROR_SUCCESS)
        paramp -> i_verify_date = 0;


    swprintf (reg_path, L"%ls", CVY_NAME_VERSION);
    size = sizeof (paramp -> i_parms_ver);
    status = RegQueryValueEx (key, reg_path, 0L, & type,
                              (LPBYTE) & paramp -> i_parms_ver, & size);

    if (status != ERROR_SUCCESS)
        paramp -> i_parms_ver = CVY_DEF_VERSION;

    swprintf (reg_path, L"%ls", CVY_NAME_VIRTUAL_NIC);
    size = sizeof (paramp -> i_virtual_nic_name);
    status = RegQueryValueEx (key, reg_path, 0L, & type,
                              (LPBYTE) paramp -> i_virtual_nic_name, & size);

    if (status != ERROR_SUCCESS)
        paramp -> i_virtual_nic_name [0] = 0;

/*
    swprintf (reg_path, L"%ls", CVY_NAME_CLUSTER_NIC);
    size = sizeof (paramp -> cluster_nic_name);
    status = RegQueryValueEx (key, reg_path, 0L, & type,
                              (LPBYTE) paramp -> cluster_nic_name, & size);

    if (status != ERROR_SUCCESS)
        paramp -> cluster_nic_name [0] = 0;
*/

    swprintf (reg_path, L"%ls", CVY_NAME_HOST_PRIORITY);
    size = sizeof (paramp -> host_priority);
    status = RegQueryValueEx (key, reg_path, 0L, & type,
                              (LPBYTE) & paramp -> host_priority, & size);

    if (status != ERROR_SUCCESS)
        paramp -> host_priority = CVY_DEF_HOST_PRIORITY;


    swprintf (reg_path, L"%ls", CVY_NAME_CLUSTER_MODE);
    size = sizeof (paramp -> cluster_mode);
    status = RegQueryValueEx (key, reg_path, 0L, & type,
                              (LPBYTE) & paramp -> cluster_mode, & size);

    if (status != ERROR_SUCCESS)
        paramp -> cluster_mode = CVY_DEF_CLUSTER_MODE;


    swprintf (reg_path, L"%ls", CVY_NAME_NETWORK_ADDR);
    size = sizeof (paramp -> cl_mac_addr);
    status = RegQueryValueEx (key, reg_path, 0L, & type,
                              (LPBYTE) paramp -> cl_mac_addr, & size);

    if (status != ERROR_SUCCESS)
        swprintf (paramp -> cl_mac_addr, L"%ls", CVY_DEF_NETWORK_ADDR);


    swprintf (reg_path, L"%ls", CVY_NAME_CL_IP_ADDR);
    size = sizeof (paramp -> cl_ip_addr);
    status = RegQueryValueEx (key, reg_path, 0L, & type,
                              (LPBYTE) paramp -> cl_ip_addr, & size);

    if (status != ERROR_SUCCESS)
        swprintf (paramp -> cl_ip_addr, L"%ls", CVY_DEF_CL_IP_ADDR);


    swprintf (reg_path, L"%ls", CVY_NAME_CL_NET_MASK);
    size = sizeof (paramp -> cl_net_mask);
    status = RegQueryValueEx (key, reg_path, 0L, & type,
                              (LPBYTE) paramp -> cl_net_mask, & size);

    if (status != ERROR_SUCCESS)
        swprintf (paramp -> cl_net_mask, L"%ls", CVY_DEF_CL_NET_MASK);


    swprintf (reg_path, L"%ls", CVY_NAME_DED_IP_ADDR);
    size = sizeof (paramp -> ded_ip_addr);
    status = RegQueryValueEx (key, reg_path, 0L, & type,
                              (LPBYTE) paramp -> ded_ip_addr, & size);

    if (status != ERROR_SUCCESS)
        swprintf (paramp -> ded_ip_addr, L"%ls", CVY_DEF_DED_IP_ADDR);


    swprintf (reg_path, L"%ls", CVY_NAME_DED_NET_MASK);
    size = sizeof (paramp -> ded_net_mask);
    status = RegQueryValueEx (key, reg_path, 0L, & type,
                              (LPBYTE) paramp -> ded_net_mask, & size);

    if (status != ERROR_SUCCESS)
        swprintf (paramp -> ded_net_mask, L"%ls", CVY_DEF_DED_NET_MASK);


    swprintf (reg_path, L"%ls", CVY_NAME_DOMAIN_NAME);
    size = sizeof (paramp -> domain_name);
    status = RegQueryValueEx (key, reg_path, 0L, & type,
                              (LPBYTE) paramp -> domain_name, & size);

    if (status != ERROR_SUCCESS)
        swprintf (paramp -> domain_name, L"%ls", CVY_DEF_DOMAIN_NAME);


    swprintf (reg_path, L"%ls", CVY_NAME_ALIVE_PERIOD);
    size = sizeof (paramp -> alive_period);
    status = RegQueryValueEx (key, reg_path, 0L, & type,
                              (LPBYTE) & paramp -> alive_period, & size);

    if (status != ERROR_SUCCESS)
        paramp -> alive_period = CVY_DEF_ALIVE_PERIOD;


    swprintf (reg_path, L"%ls", CVY_NAME_ALIVE_TOLER);
    size = sizeof (paramp -> alive_tolerance);
    status = RegQueryValueEx (key, reg_path, 0L, & type,
                              (LPBYTE) & paramp -> alive_tolerance, & size);

    if (status != ERROR_SUCCESS)
        paramp -> alive_tolerance = CVY_DEF_ALIVE_TOLER;


    swprintf (reg_path, L"%ls", CVY_NAME_NUM_ACTIONS);
    size = sizeof (paramp -> num_actions);
    status = RegQueryValueEx (key, reg_path, 0L, & type,
                              (LPBYTE) & paramp -> num_actions, & size);

    if (status != ERROR_SUCCESS)
        paramp -> num_actions = CVY_DEF_NUM_ACTIONS;


    swprintf (reg_path, L"%ls", CVY_NAME_NUM_PACKETS);
    size = sizeof (paramp -> num_packets);
    status = RegQueryValueEx (key, reg_path, 0L, & type,
                              (LPBYTE) & paramp -> num_packets, & size);

    if (status != ERROR_SUCCESS)
        paramp -> num_packets = CVY_DEF_NUM_PACKETS;


    swprintf (reg_path, L"%ls", CVY_NAME_NUM_SEND_MSGS);
    size = sizeof (paramp -> num_send_msgs);
    status = RegQueryValueEx (key, reg_path, 0L, & type,
                              (LPBYTE) & paramp -> num_send_msgs, & size);

    if (status != ERROR_SUCCESS)
        paramp -> num_send_msgs = CVY_DEF_NUM_SEND_MSGS;


    swprintf (reg_path, L"%ls", CVY_NAME_DSCR_PER_ALLOC);
    size = sizeof (paramp -> dscr_per_alloc);
    status = RegQueryValueEx (key, reg_path, 0L, & type,
                              (LPBYTE) & paramp -> dscr_per_alloc, & size);

    if (status != ERROR_SUCCESS)
        paramp -> dscr_per_alloc = CVY_DEF_DSCR_PER_ALLOC;


    swprintf (reg_path, L"%ls", CVY_NAME_MAX_DSCR_ALLOCS);
    size = sizeof (paramp -> max_dscr_allocs);
    status = RegQueryValueEx (key, reg_path, 0L, & type,
                              (LPBYTE) & paramp -> max_dscr_allocs, & size);

    if (status != ERROR_SUCCESS)
        paramp -> max_dscr_allocs = CVY_DEF_MAX_DSCR_ALLOCS;


    swprintf (reg_path, L"%ls", CVY_NAME_SCALE_CLIENT);
    size = sizeof (paramp -> i_scale_client);
    status = RegQueryValueEx (key, reg_path, 0L, & type,
                              (LPBYTE) & paramp -> i_scale_client, & size);

    if (status != ERROR_SUCCESS)
        paramp -> i_scale_client = CVY_DEF_SCALE_CLIENT;

    swprintf (reg_path, L"%ls", CVY_NAME_CLEANUP_DELAY);
    size = sizeof (paramp -> i_cleanup_delay);
    status = RegQueryValueEx (key, reg_path, 0L, & type,
                              (LPBYTE) & paramp -> i_cleanup_delay, & size);

    if (status != ERROR_SUCCESS)
        paramp -> i_cleanup_delay = CVY_DEF_CLEANUP_DELAY;

    /* V1.1.1 */

    swprintf (reg_path, L"%ls", CVY_NAME_NBT_SUPPORT);
    size = sizeof (paramp -> i_nbt_support);
    status = RegQueryValueEx (key, reg_path, 0L, & type,
                              (LPBYTE) & paramp -> i_nbt_support, & size);

    if (status != ERROR_SUCCESS)
        paramp -> i_nbt_support = CVY_DEF_NBT_SUPPORT;

    /* V1.3b */

    swprintf (reg_path, L"%ls", CVY_NAME_MCAST_SUPPORT);
    size = sizeof (paramp -> mcast_support);
    status = RegQueryValueEx (key, reg_path, 0L, & type,
                              (LPBYTE) & paramp -> mcast_support, & size);

    if (status != ERROR_SUCCESS)
        paramp -> mcast_support = CVY_DEF_MCAST_SUPPORT;


    swprintf (reg_path, L"%ls", CVY_NAME_MCAST_SPOOF);
    size = sizeof (paramp -> i_mcast_spoof);
    status = RegQueryValueEx (key, reg_path, 0L, & type,
                              (LPBYTE) & paramp -> i_mcast_spoof, & size);

    if (status != ERROR_SUCCESS)
        paramp -> i_mcast_spoof = CVY_DEF_MCAST_SPOOF;


    swprintf (reg_path, L"%ls", CVY_NAME_MASK_SRC_MAC);
    size = sizeof (paramp -> mask_src_mac);
    status = RegQueryValueEx (key, reg_path, 0L, & type,
                              (LPBYTE) & paramp -> mask_src_mac, & size);

    if (status != ERROR_SUCCESS)
        paramp -> mask_src_mac = CVY_DEF_MASK_SRC_MAC;


    swprintf (reg_path, L"%ls", CVY_NAME_NETMON_ALIVE);
    size = sizeof (paramp -> i_netmon_alive);
    status = RegQueryValueEx (key, reg_path, 0L, & type,
                              (LPBYTE) & paramp -> i_netmon_alive, & size);

    if (status != ERROR_SUCCESS)
        paramp -> i_netmon_alive = CVY_DEF_NETMON_ALIVE;

    swprintf (reg_path, L"%ls", CVY_NAME_EFFECTIVE_VERSION);
    size = sizeof (paramp -> i_effective_version);
    status = RegQueryValueEx (key, reg_path, 0L, & type,
                              (LPBYTE) & paramp -> i_effective_version, & size);

    if (status != ERROR_SUCCESS)
        paramp -> i_effective_version = CVY_NT40_VERSION_FULL;

    swprintf (reg_path, L"%ls", CVY_NAME_IP_CHG_DELAY);
    size = sizeof (paramp -> i_ip_chg_delay);
    status = RegQueryValueEx (key, reg_path, 0L, & type,
                              (LPBYTE) & paramp -> i_ip_chg_delay, & size);

    if (status != ERROR_SUCCESS)
        paramp -> i_ip_chg_delay = CVY_DEF_IP_CHG_DELAY;


    swprintf (reg_path, L"%ls", CVY_NAME_CONVERT_MAC);
    size = sizeof (paramp -> i_convert_mac);
    status = RegQueryValueEx (key, reg_path, 0L, & type,
                              (LPBYTE) & paramp -> i_convert_mac, & size);

    if (status != ERROR_SUCCESS)
        paramp -> i_convert_mac = CVY_DEF_CONVERT_MAC;


    swprintf (reg_path, L"%ls", CVY_NAME_NUM_RULES);
    size = sizeof (paramp -> i_num_rules);
    status = RegQueryValueEx (key, reg_path, 0L, & type,
                              (LPBYTE) & paramp -> i_num_rules, & size);

    if (status != ERROR_SUCCESS)
        paramp -> i_num_rules = 0;

    WLBS_OLD_PORT_RULE  old_port_rules [WLBS_MAX_RULES];
    HKEY                subkey;
    //
    // Attempt to read port rules from new location/format. If it is an upgrade from Win2k, 
    // it will not be present in the new location.
    //
    if (!fUpgradeFromWin2k 
     && (RegOpenKeyEx (key, CVY_NAME_PORT_RULES, 0L, KEY_QUERY_VALUE, & subkey) == ERROR_SUCCESS))
    {
        DWORD idx = 1, num_rules = paramp -> i_num_rules, correct_rules = 0;
        WLBS_PORT_RULE *port_rule;

        if (pfPortRulesInBinaryForm) 
            *pfPortRulesInBinaryForm = false;

        port_rule = paramp -> i_port_rules;
        while(idx <= num_rules)
        {
            HKEY rule_key;
            wchar_t idx_str[8];
            // Open the per port-rule key "1", "2", "3", ...etc
            if (RegOpenKeyEx (subkey, _itow(idx, idx_str, 10), 0L, KEY_QUERY_VALUE, & rule_key) != ERROR_SUCCESS)
            {
                idx++;
                continue;
            }

            swprintf (reg_path, L"%ls", CVY_NAME_VIP);
            size = sizeof (port_rule -> virtual_ip_addr);
            status = RegQueryValueEx (rule_key, reg_path, 0L, & type, (LPBYTE) &port_rule->virtual_ip_addr, & size);
            if (status != ERROR_SUCCESS)
            {
                idx++;
                continue;
            }

            swprintf (reg_path, L"%ls", CVY_NAME_START_PORT);
            size = sizeof (port_rule ->start_port );
            status = RegQueryValueEx (rule_key, reg_path, 0L, & type, (LPBYTE) &port_rule->start_port, & size);
            if (status != ERROR_SUCCESS)
            {
                idx++;
                continue;
            }

            swprintf (reg_path, L"%ls", CVY_NAME_END_PORT);
            size = sizeof (port_rule ->end_port );
            status = RegQueryValueEx (rule_key, reg_path, 0L, & type, (LPBYTE) &port_rule->end_port, & size);
            if (status != ERROR_SUCCESS)
            {
                idx++;
                continue;
            }

            swprintf (reg_path, L"%ls", CVY_NAME_CODE);
            size = sizeof (port_rule ->code);
            status = RegQueryValueEx (rule_key, reg_path, 0L, & type, (LPBYTE) &port_rule->code, & size);
            if (status != ERROR_SUCCESS)
            {
                idx++;
                continue;
            }

            swprintf (reg_path, L"%ls", CVY_NAME_MODE);
            size = sizeof (port_rule->mode);
            status = RegQueryValueEx (rule_key, reg_path, 0L, & type, (LPBYTE) &port_rule->mode, & size);
            if (status != ERROR_SUCCESS)
            {
                idx++;
                continue;
            }

            swprintf (reg_path, L"%ls", CVY_NAME_PROTOCOL);
            size = sizeof (port_rule->protocol);
            status = RegQueryValueEx (rule_key, reg_path, 0L, & type, (LPBYTE) &port_rule->protocol, & size);
            if (status != ERROR_SUCCESS)
            {
                idx++;
                continue;
            }

            port_rule->valid = true;

            DWORD EqualLoad, Affinity;

            switch (port_rule->mode) 
            {
            case CVY_MULTI :
                 swprintf (reg_path, L"%ls", CVY_NAME_EQUAL_LOAD );
                 size = sizeof (EqualLoad);
                 status = RegQueryValueEx (rule_key, reg_path, 0L, & type, (LPBYTE) &EqualLoad, & size);
                 if (status != ERROR_SUCCESS)
                 {
                     idx++;
                     continue;
                 }
                 else
                 {
                     port_rule->mode_data.multi.equal_load = (WORD) EqualLoad;
                 }

                 swprintf (reg_path, L"%ls", CVY_NAME_AFFINITY );
                 size = sizeof (Affinity);
                 status = RegQueryValueEx (rule_key, reg_path, 0L, & type, (LPBYTE) &Affinity, & size);
                 if (status != ERROR_SUCCESS)
                 {
                     idx++;
                     continue;
                 }
                 else
                 {
                     port_rule->mode_data.multi.affinity = (WORD) Affinity;
                 }

                 swprintf (reg_path, L"%ls", CVY_NAME_LOAD);
                 size = sizeof (port_rule->mode_data.multi.load);
                 status = RegQueryValueEx (rule_key, reg_path, 0L, & type, (LPBYTE) &(port_rule->mode_data.multi.load), & size);
                 if (status != ERROR_SUCCESS)
                 {
                     idx++;
                     continue;
                 }
                 break;

            case CVY_SINGLE :
                 swprintf (reg_path, L"%ls", CVY_NAME_PRIORITY);
                 size = sizeof (port_rule->mode_data.single.priority);
                 status = RegQueryValueEx (rule_key, reg_path, 0L, & type, (LPBYTE) &(port_rule->mode_data.single.priority), & size);
                 if (status != ERROR_SUCCESS)
                 {
                     idx++;
                     continue;
                 }
                 break;

            default:
                 break;
            }

            port_rule++;
            idx++;
            correct_rules++;
        }

        // Discard those rules on which we encountered some error
        if (paramp->i_num_rules != correct_rules) 
        {
            paramp -> i_num_rules = correct_rules;
        }
    }
    else // Port Rules in Binary Format
    {
        if (pfPortRulesInBinaryForm) 
            *pfPortRulesInBinaryForm = true;

        swprintf (reg_path, L"%ls", CVY_NAME_OLD_PORT_RULES);
        size = sizeof (old_port_rules);
        status = RegQueryValueEx (key, reg_path, 0L, & type,
                                  (LPBYTE) old_port_rules, & size);

        if (status != ERROR_SUCCESS  ||
            size % sizeof (WLBS_OLD_PORT_RULE) != 0 ||
            paramp -> i_num_rules != size / sizeof (WLBS_OLD_PORT_RULE))
        {
            ZeroMemory(paramp -> i_port_rules, sizeof(paramp -> i_port_rules));
            paramp -> i_num_rules = 0;
        }
        else // Convert the port rules to new format
        {
            if (paramp -> i_parms_ver > 3) 
            {
                TransformOldPortRulesToNew(old_port_rules, paramp -> i_port_rules, paramp -> i_num_rules);
            }
        }
    }

    swprintf (reg_path, L"%ls", CVY_NAME_LICENSE_KEY);
    size = sizeof (paramp -> i_license_key);
    status = RegQueryValueEx (key, reg_path, 0L, & type,
                              (LPBYTE) paramp -> i_license_key, & size);

    if (status != ERROR_SUCCESS)
        swprintf (paramp -> i_license_key, L"%ls", CVY_DEF_LICENSE_KEY);

    swprintf (reg_path, L"%ls", CVY_NAME_RMT_PASSWORD);
    size = sizeof (paramp -> i_rmt_password);
    status = RegQueryValueEx (key, reg_path, 0L, & type,
                              (LPBYTE) & paramp -> i_rmt_password, & size);

    if (status != ERROR_SUCCESS)
        paramp -> i_rmt_password = CVY_DEF_RMT_PASSWORD;


    swprintf (reg_path, L"%ls", CVY_NAME_RCT_PASSWORD);
    size = sizeof (paramp -> i_rct_password);
    status = RegQueryValueEx (key, reg_path, 0L, & type,
                              (LPBYTE) & paramp -> i_rct_password, & size);

    if (status != ERROR_SUCCESS)
        paramp -> i_rct_password = CVY_DEF_RCT_PASSWORD;


    swprintf (reg_path, L"%ls", CVY_NAME_RCT_PORT);
    size = sizeof (paramp -> rct_port);
    status = RegQueryValueEx (key, reg_path, 0L, & type,
                              (LPBYTE) & paramp -> rct_port, & size);

    if (status != ERROR_SUCCESS)
        paramp -> rct_port = CVY_DEF_RCT_PORT;


    swprintf (reg_path, L"%ls", CVY_NAME_RCT_ENABLED);
    size = sizeof (paramp -> rct_enabled);
    status = RegQueryValueEx (key, reg_path, 0L, & type,
                              (LPBYTE) & paramp -> rct_enabled, & size);

    if (status != ERROR_SUCCESS)
        paramp -> rct_enabled = CVY_DEF_RCT_ENABLED;

    //
    // IGMP support registry entries
    //
    size = sizeof (paramp->fIGMPSupport);
    status = RegQueryValueEx (key, CVY_NAME_IGMP_SUPPORT, 0L, NULL,
                              (LPBYTE) & paramp->fIGMPSupport, &size);

    if (status != ERROR_SUCCESS)
        paramp -> fIGMPSupport = CVY_DEF_IGMP_SUPPORT;
    
    size = sizeof (paramp->szMCastIpAddress);
    status = RegQueryValueEx (key, CVY_NAME_MCAST_IP_ADDR, 0L, NULL,
                              (LPBYTE) & paramp->szMCastIpAddress, &size);

    if (status != ERROR_SUCCESS)
        lstrcpy(paramp -> szMCastIpAddress, CVY_DEF_MCAST_IP_ADDR);
    
    size = sizeof (paramp->fIpToMCastIp);
    status = RegQueryValueEx (key, CVY_NAME_IP_TO_MCASTIP, 0L, NULL,
                              (LPBYTE) & paramp->fIpToMCastIp, &size);

    if (status != ERROR_SUCCESS)
        paramp -> fIpToMCastIp = CVY_DEF_IP_TO_MCASTIP;

    /* Attempt to open the BDA teaming settings.  They may not be there, 
       so if they aren't, move on; otherwise, extract the settings. */
    if ((bda_key = RegOpenWlbsBDASettings(AdapterGuid, true))) {
        GUID TeamGuid;
        HRESULT hr;

        /* If the key exists, we are part of a team. */
        paramp->bda_teaming.active = TRUE;
        
        /* Find out if we are the master of this team. */
        size = sizeof (paramp->bda_teaming.master);
        status = RegQueryValueEx (bda_key, CVY_NAME_BDA_MASTER, 0L, NULL,
                                  (LPBYTE)&paramp->bda_teaming.master, &size);
        
        /* If we can't get that information, default to a slave. */
        if (status != ERROR_SUCCESS)
            paramp->bda_teaming.master = FALSE;

        /* Find out if we are reverse hashing or not. */
        size = sizeof (paramp->bda_teaming.reverse_hash);
        status = RegQueryValueEx (bda_key, CVY_NAME_BDA_REVERSE_HASH, 0L, NULL,
                                  (LPBYTE)&paramp->bda_teaming.reverse_hash, &size);
        
        /* If that fails, then assume normal hashing. */
        if (status != ERROR_SUCCESS)
            paramp->bda_teaming.reverse_hash = FALSE;

        /* Get our team ID - this should be a GUID, be we don't enforce that. */
        size = sizeof (paramp->bda_teaming.team_id);
        status = RegQueryValueEx (bda_key, CVY_NAME_BDA_TEAM_ID, 0L, NULL,
                                  (LPBYTE)&paramp->bda_teaming.team_id, &size);
        
        /* The team is absolutely required - if we can't get it, then don't join the team. */
        if (status != ERROR_SUCCESS)
            paramp->bda_teaming.active = CVY_DEF_BDA_ACTIVE;

        /* Attempt to convert the string to a GUID and check for errors. */
        hr = CLSIDFromString(paramp->bda_teaming.team_id, &TeamGuid);

        /* If the conversion fails, bail out - the team ID must not have been a GUID. */
        if (hr != NOERROR) {
            LOG_ERROR1("ParamReadReg:  Invalid BDA Team ID: %ls", paramp->bda_teaming.team_id);
            paramp->bda_teaming.active = CVY_DEF_BDA_ACTIVE;
        }
  
        RegCloseKey(bda_key);
    }

    /* decode port rules prior to version 3 */

    if (paramp -> i_parms_ver <= 3)
    {
        paramp -> i_parms_ver = CVY_PARAMS_VERSION;

        /* decode the port rules */

        if (! License_data_decode ((PCHAR) old_port_rules, paramp -> i_num_rules * sizeof (WLBS_OLD_PORT_RULE))) 
        {
            ZeroMemory(paramp -> i_port_rules, sizeof(paramp -> i_port_rules));
            paramp -> i_num_rules = 0;
        }
        else
            TransformOldPortRulesToNew(old_port_rules, paramp -> i_port_rules, paramp -> i_num_rules);

    }

    /* upgrade port rules from params V1 to params V2 */

    if (paramp -> i_parms_ver == 1)
    {
        paramp -> i_parms_ver = CVY_PARAMS_VERSION;

        /* keep multicast off by default for old users */

        paramp -> mcast_support = FALSE;

        for (i = 0; i < paramp -> i_num_rules; i ++)
        {
            rp = paramp -> i_port_rules + i;

            code = CVY_RULE_CODE_GET (rp);

            CVY_RULE_CODE_SET (rp);

            if (code != CVY_RULE_CODE_GET (rp))
            {
                rp -> code = code;
                continue;
            }

            if (! rp -> valid)
            {
                continue;
            }

            /* set affinity according to current ScaleSingleClient setting */

            if (rp -> mode == CVY_MULTI)
                rp -> mode_data . multi . affinity = CVY_AFFINITY_SINGLE - (USHORT)paramp -> i_scale_client;

            CVY_RULE_CODE_SET (rp);
        }
    }

    /* upgrade max number of descriptor allocs */

    if (paramp -> i_parms_ver == 2)
    {
        paramp -> i_parms_ver = CVY_PARAMS_VERSION;
        paramp -> max_dscr_allocs = CVY_DEF_MAX_DSCR_ALLOCS;
        paramp -> dscr_per_alloc  = CVY_DEF_DSCR_PER_ALLOC;
    }

    RegCloseKey (key);

    paramp -> i_max_hosts        = CVY_MAX_HOSTS;
    paramp -> i_max_rules        = CVY_MAX_USABLE_RULES;
//    paramp -> i_ft_rules_enabled = TRUE;
//    paramp -> version          = 0;

//  CLEAN_64BIT    CVY_CHECK_MIN (paramp -> i_num_rules, CVY_MIN_NUM_RULES);
    CVY_CHECK_MAX (paramp -> i_num_rules, CVY_MAX_NUM_RULES);
    CVY_CHECK_MIN (paramp -> host_priority, CVY_MIN_HOST_PRIORITY);
    CVY_CHECK_MAX (paramp -> host_priority, CVY_MAX_HOST_PRIORITY);

    return TRUE;

}

//+----------------------------------------------------------------------------
//
// Function:  ParamValidate
//
// Description:  Validates the cluster parameters. Also munges some fields
//               such as IP addresses to make them canonocal.
//
// Arguments:  PWLBS_REG_PARAMS paramp - 
//
// Returns:   bool - TRUE if params are valid, false otherwise
//
// History:   josephj Created 4/25/01 based on code from ParamWriteReg.
//
//+----------------------------------------------------------------------------
bool WINAPI ParamValidate(const PWLBS_REG_PARAMS paramp)
{
    bool fRet = FALSE;
    DWORD   idx;
    IN_ADDR dwIPAddr;
    CHAR *  szIPAddr;
    DWORD   num_rules;
    WLBS_PORT_RULE *port_rule;

    /* verify and if necessary reset the parameters */
    CVY_CHECK_MIN (paramp -> alive_period, CVY_MIN_ALIVE_PERIOD);
    CVY_CHECK_MAX (paramp -> alive_period, CVY_MAX_ALIVE_PERIOD);

    CVY_CHECK_MIN (paramp -> alive_tolerance, CVY_MIN_ALIVE_TOLER);
    CVY_CHECK_MAX (paramp -> alive_tolerance, CVY_MAX_ALIVE_TOLER);

    CVY_CHECK_MIN (paramp -> num_actions, CVY_MIN_NUM_ACTIONS);
    CVY_CHECK_MAX (paramp -> num_actions, CVY_MAX_NUM_ACTIONS);

    CVY_CHECK_MIN (paramp -> num_packets, CVY_MIN_NUM_PACKETS);
    CVY_CHECK_MAX (paramp -> num_packets, CVY_MAX_NUM_PACKETS);

    CVY_CHECK_MIN (paramp -> dscr_per_alloc, CVY_MIN_DSCR_PER_ALLOC);
    CVY_CHECK_MAX (paramp -> dscr_per_alloc, CVY_MAX_DSCR_PER_ALLOC);

    CVY_CHECK_MIN (paramp -> max_dscr_allocs, CVY_MIN_MAX_DSCR_ALLOCS);
    CVY_CHECK_MAX (paramp -> max_dscr_allocs, CVY_MAX_MAX_DSCR_ALLOCS);

// CLEAN_64BIT     CVY_CHECK_MIN (paramp -> i_cleanup_delay, CVY_MIN_CLEANUP_DELAY);
    CVY_CHECK_MAX (paramp -> i_cleanup_delay, CVY_MAX_CLEANUP_DELAY);

// CLEAN_64BIT    CVY_CHECK_MIN (paramp -> i_ip_chg_delay, CVY_MIN_IP_CHG_DELAY);
    CVY_CHECK_MAX (paramp -> i_ip_chg_delay, CVY_MAX_IP_CHG_DELAY);

    CVY_CHECK_MIN (paramp -> num_send_msgs, (paramp -> i_max_hosts + 1) * 2);
    CVY_CHECK_MAX (paramp -> num_send_msgs, (paramp -> i_max_hosts + 1) * 10);

// CLEAN_64BIT    CVY_CHECK_MIN (paramp -> i_num_rules, CVY_MIN_NUM_RULES);
    CVY_CHECK_MAX (paramp -> i_num_rules, CVY_MAX_NUM_RULES);

    CVY_CHECK_MIN (paramp -> host_priority, CVY_MIN_HOST_PRIORITY);
    CVY_CHECK_MAX (paramp -> host_priority, CVY_MAX_HOST_PRIORITY);

// CLEAN_64BIT    CVY_CHECK_MIN (paramp -> cluster_mode, CVY_MIN_CLUSTER_MODE);
    CVY_CHECK_MAX (paramp -> cluster_mode, CVY_MAX_CLUSTER_MODE);

    /* If the cluster IP address is not 0.0.0.0, then make sure the IP address is valid. */
    if (lstrcmpi(paramp->cl_ip_addr, CVY_DEF_CL_IP_ADDR)) {
        /* Check the validity of the IP address. */
        if (!(dwIPAddr.S_un.S_addr = IpAddressFromAbcdWsz(paramp->cl_ip_addr)))
            goto error;
        
        /* Convert the DWORD back to a string.  We do this because 11.11.3 is a valid IP
           address the inet_addr converts to 11.11.0.3 as a DWORD.  Therefore, to keep
           the IP address string (which is used by other parts of NLB, such as the UI)
           consistent, we convert back to a string. */
        if (!(szIPAddr = inet_ntoa(dwIPAddr))) 
            goto error;

        /* Convert the ASCII string to unicode. */
        if (!MultiByteToWideChar(CP_ACP, 0, szIPAddr, -1, paramp->cl_ip_addr, WLBS_MAX_CL_IP_ADDR + 1))
            goto error;
    }

    /* If the cluster netmask is not 0.0.0.0, then make sure the netmask is valid. */
    if (lstrcmpi(paramp->cl_net_mask, CVY_DEF_CL_NET_MASK)) {
        /* Check the validity of the IP address. */
        if (!(dwIPAddr.S_un.S_addr = IpAddressFromAbcdWsz(paramp->cl_net_mask)))
            goto error;
        
        /* Convert the DWORD back to a string.  We do this because 11.11.3 is a valid IP
           address the inet_addr converts to 11.11.0.3 as a DWORD.  Therefore, to keep
           the IP address string (which is used by other parts of NLB, such as the UI)
           consistent, we convert back to a string. */
        if (!(szIPAddr = inet_ntoa(dwIPAddr))) 
            goto error;

        /* Convert the ASCII string to unicode. */
        if (!MultiByteToWideChar(CP_ACP, 0, szIPAddr, -1, paramp->cl_net_mask, WLBS_MAX_CL_NET_MASK + 1))
            goto error;
    }

    /* If the dedicated IP address is not 0.0.0.0, then make sure the IP address is valid. */
    if (lstrcmpi(paramp->ded_ip_addr, CVY_DEF_DED_IP_ADDR)) {
        /* Check the validity of the IP address. */
        if (!(dwIPAddr.S_un.S_addr = IpAddressFromAbcdWsz(paramp->ded_ip_addr)))
            goto error;
        
        /* Convert the DWORD back to a string.  We do this because 11.11.3 is a valid IP
           address the inet_addr converts to 11.11.0.3 as a DWORD.  Therefore, to keep
           the IP address string (which is used by other parts of NLB, such as the UI)
           consistent, we convert back to a string. */
        if (!(szIPAddr = inet_ntoa(dwIPAddr))) 
            goto error;

        /* Convert the ASCII string to unicode. */
        if (!MultiByteToWideChar(CP_ACP, 0, szIPAddr, -1, paramp->ded_ip_addr, WLBS_MAX_DED_IP_ADDR + 1))
            goto error;
    }

    /* If the dedicated netmask is not 0.0.0.0, then make sure the netmask is valid. */
    if (lstrcmpi(paramp->ded_net_mask, CVY_DEF_DED_NET_MASK)) {
        /* Check the validity of the IP address. */
        if (!(dwIPAddr.S_un.S_addr = IpAddressFromAbcdWsz(paramp->ded_net_mask)))
            goto error;
        
        /* Convert the DWORD back to a string.  We do this because 11.11.3 is a valid IP
           address the inet_addr converts to 11.11.0.3 as a DWORD.  Therefore, to keep
           the IP address string (which is used by other parts of NLB, such as the UI)
           consistent, we convert back to a string. */
        if (!(szIPAddr = inet_ntoa(dwIPAddr))) 
            goto error;

        /* Convert the ASCII string to unicode. */
        if (!MultiByteToWideChar(CP_ACP, 0, szIPAddr, -1, paramp->ded_net_mask, WLBS_MAX_DED_NET_MASK + 1))
            goto error;
    }

    /* Verify that the port rule VIP is valid, 
       Also, convert the port rule VIPs that might be in the x.x.x or x.x or x form to x.x.x.x */
    idx = 0;
    num_rules = paramp -> i_num_rules;
    while (idx < num_rules) 
    {
        port_rule = &paramp->i_port_rules[idx];

        /* Check if the port rule is valid and the vip is not "All Vip" */
        if (port_rule->valid && lstrcmpi(port_rule->virtual_ip_addr, CVY_DEF_ALL_VIP)) 
        {
            /* Get IP Address into DWORD form */
            if (!(dwIPAddr.S_un.S_addr = IpAddressFromAbcdWsz(port_rule->virtual_ip_addr)))
                goto error;

            /* Check for validity of IP Address */
            if ((dwIPAddr.S_un.S_un_b.s_b1 < WLBS_IP_FIELD_ZERO_LOW) 
             || (dwIPAddr.S_un.S_un_b.s_b1 > WLBS_IP_FIELD_ZERO_HIGH) 
             || (dwIPAddr.S_un.S_un_b.s_b2 < WLBS_FIELD_LOW) 
             || (dwIPAddr.S_un.S_un_b.s_b2 > WLBS_FIELD_HIGH) 
             || (dwIPAddr.S_un.S_un_b.s_b3 < WLBS_FIELD_LOW) 
             || (dwIPAddr.S_un.S_un_b.s_b3 > WLBS_FIELD_HIGH) 
             || (dwIPAddr.S_un.S_un_b.s_b4 < WLBS_FIELD_LOW) 
             || (dwIPAddr.S_un.S_un_b.s_b4 > WLBS_FIELD_HIGH)) 
                goto error;

            /* Convert the DWORD back to a string.  We do this because 11.11.3 is a valid IP
               address the inet_addr converts to 11.11.0.3 as a DWORD.  Therefore, to keep
               the IP address string (which is used by other parts of NLB, such as the UI)
               consistent, we convert back to a string. */
            if (!(szIPAddr = inet_ntoa(dwIPAddr))) 
                goto error;

            /* Convert the ASCII string to unicode. */
            if (!MultiByteToWideChar(CP_ACP, 0, szIPAddr, -1, port_rule->virtual_ip_addr, WLBS_MAX_CL_IP_ADDR + 1))
                goto error;
        }
        idx++;
    }

    /* If either the cluster IP address or the cluster netmask is not 0.0.0.0,
       then make sure the they are a valid IP address/netmask pair. */
    if (lstrcmpi(paramp->cl_ip_addr, CVY_DEF_CL_IP_ADDR) || lstrcmpi(paramp->cl_net_mask, CVY_DEF_CL_NET_MASK)) {
        /* If they have specified a cluster IP address, but no netmask, then fill it in for them. */
        if (!lstrcmpi(paramp->cl_net_mask, CVY_DEF_CL_NET_MASK))
            ParamsGenerateSubnetMask(paramp->cl_ip_addr, paramp->cl_net_mask);

        /* Check for valid cluster IP address/netmask pairs. */
        if (!IsValidIPAddressSubnetMaskPair(paramp->cl_ip_addr, paramp->cl_net_mask))
            goto error;
        
        /* Check to make sure that the cluster netmask is contiguous. */
        if (!IsContiguousSubnetMask(paramp->cl_net_mask))
            goto error;

        /* Check to make sure that the dedicated IP and cluster IP are not the same. */
        if (!wcscmp(paramp->ded_ip_addr, paramp->cl_ip_addr))
            goto error;
    }

    /* If either the dedicated IP address or the dedicated netmask is not 0.0.0.0,
       then make sure the they are a valid IP address/netmask pair. */
    if (lstrcmpi(paramp->ded_ip_addr, CVY_DEF_DED_IP_ADDR) || lstrcmpi(paramp->ded_net_mask, CVY_DEF_DED_NET_MASK)) {
        /* If they have specified a cluster IP address, but no netmask, then fill it in for them. */
        if (!lstrcmpi(paramp->ded_net_mask, CVY_DEF_DED_NET_MASK))
            ParamsGenerateSubnetMask(paramp->ded_ip_addr, paramp->ded_net_mask);

        /* Check for valid dedicated IP address/netmask pairs. */
        if (!IsValidIPAddressSubnetMaskPair(paramp->ded_ip_addr, paramp->ded_net_mask))
            goto error;
        
        /* Check to make sure that the dedicated netmask is contiguous. */
        if (!IsContiguousSubnetMask(paramp->ded_net_mask))
            goto error;
    }

    /* Check the mac address if the convert_mac flag is not set */
    if ( ! paramp -> i_convert_mac)
    {
        PWCHAR p1, p2;
        WCHAR mac_addr [WLBS_MAX_NETWORK_ADDR + 1];
        DWORD i, j;
        BOOL flag = TRUE;

        _tcscpy (mac_addr, paramp -> cl_mac_addr);

        p2 = p1 = mac_addr;

        for (i = 0 ; i < 6 ; i++)
        {
            if (*p2 == _TEXT('\0'))
            {
                flag = FALSE;
                break;
            }

            j = _tcstoul (p1, &p2, 16);

            if ( j > 255)
            {
                flag = FALSE;
                break;
            }

            if ( ! (*p2 == _TEXT('-') || *p2 == _TEXT(':') || *p2 == _TEXT('\0')) )
            {
                flag = FALSE;
                break;
            }

            if (*p2 == _TEXT('\0') && i < 5)
            {
                flag = FALSE;
                break;
            }

            p1 = p2 + 1;
            p2 = p1;

        }


        if (!flag)
        {
            goto error;
        }
    }

    if (paramp->fIGMPSupport && !paramp->mcast_support)
    {
        //
        // IGMP can not be enabled in unicast mode
        //
        LOG_ERROR("ParamWriteReg IGMP can not be enabled in unicast mode");

        goto error;
    }

    if (paramp->mcast_support && paramp->fIGMPSupport && !paramp->fIpToMCastIp)
    {
        //
        // Multicast mode with IGMP enabled, and user specified an multicast IP address,
        // The multicast IP address should be in the range of (224-239).x.x.x 
        //       but NOT (224-239).0.0.x or (224-239).128.0.x. 
        //

        DWORD dwMCastIp = IpAddressFromAbcdWsz(paramp->szMCastIpAddress);

        if ((dwMCastIp & 0xf0) != 0xe0 ||
            (dwMCastIp & 0x00ffff00) == 0 || 
            (dwMCastIp & 0x00ffff00) == 0x00008000)
        {
            LOG_ERROR1("ParamWriteReg invalid szMCastIpAddressr %ws", 
                paramp->szMCastIpAddress);

            goto error;
        }
    }

    /* Generate the MAC address. */
    ParamsGenerateMAC(paramp->cl_ip_addr, paramp->cl_mac_addr, paramp->szMCastIpAddress, paramp->i_convert_mac, 
                      paramp->mcast_support, paramp->fIGMPSupport, paramp->fIpToMCastIp);

    fRet = TRUE;
    goto end;
    
error:
	fRet = FALSE;
	goto end;

end:
	return fRet;
}

//+----------------------------------------------------------------------------
//
// Function:  ParamWriteReg
//
// Description:  Write cluster settings to registry
//
// Arguments: const GUID& AdapterGuid - 
//            PWLBS_REG_PARAMS paramp - 
//
// Returns:   bool - 
//
// History:   fengsun Created Header    3/9/00
//
//+----------------------------------------------------------------------------
bool WINAPI ParamWriteReg(const GUID& AdapterGuid, PWLBS_REG_PARAMS paramp)
{
    HKEY    bda_key = NULL;
    HKEY    key = NULL;
    DWORD   size;
    LONG    status;
    DWORD   disp, idx;
    DWORD   num_rules;
    WLBS_PORT_RULE *port_rule;

#if 1
	if (!ParamValidate(paramp))
		goto error;

    num_rules = paramp -> i_num_rules;
#else // OBSOLETE_CODE

    IN_ADDR dwIPAddr;
    CHAR *  szIPAddr;

    /* verify and if necessary reset the parameters */
    CVY_CHECK_MIN (paramp -> alive_period, CVY_MIN_ALIVE_PERIOD);
    CVY_CHECK_MAX (paramp -> alive_period, CVY_MAX_ALIVE_PERIOD);

    CVY_CHECK_MIN (paramp -> alive_tolerance, CVY_MIN_ALIVE_TOLER);
    CVY_CHECK_MAX (paramp -> alive_tolerance, CVY_MAX_ALIVE_TOLER);

    CVY_CHECK_MIN (paramp -> num_actions, CVY_MIN_NUM_ACTIONS);
    CVY_CHECK_MAX (paramp -> num_actions, CVY_MAX_NUM_ACTIONS);

    CVY_CHECK_MIN (paramp -> num_packets, CVY_MIN_NUM_PACKETS);
    CVY_CHECK_MAX (paramp -> num_packets, CVY_MAX_NUM_PACKETS);

    CVY_CHECK_MIN (paramp -> dscr_per_alloc, CVY_MIN_DSCR_PER_ALLOC);
    CVY_CHECK_MAX (paramp -> dscr_per_alloc, CVY_MAX_DSCR_PER_ALLOC);

    CVY_CHECK_MIN (paramp -> max_dscr_allocs, CVY_MIN_MAX_DSCR_ALLOCS);
    CVY_CHECK_MAX (paramp -> max_dscr_allocs, CVY_MAX_MAX_DSCR_ALLOCS);

// CLEAN_64BIT     CVY_CHECK_MIN (paramp -> i_cleanup_delay, CVY_MIN_CLEANUP_DELAY);
    CVY_CHECK_MAX (paramp -> i_cleanup_delay, CVY_MAX_CLEANUP_DELAY);

// CLEAN_64BIT    CVY_CHECK_MIN (paramp -> i_ip_chg_delay, CVY_MIN_IP_CHG_DELAY);
    CVY_CHECK_MAX (paramp -> i_ip_chg_delay, CVY_MAX_IP_CHG_DELAY);

    CVY_CHECK_MIN (paramp -> num_send_msgs, (paramp -> i_max_hosts + 1) * 2);
    CVY_CHECK_MAX (paramp -> num_send_msgs, (paramp -> i_max_hosts + 1) * 10);

// CLEAN_64BIT    CVY_CHECK_MIN (paramp -> i_num_rules, CVY_MIN_NUM_RULES);
    CVY_CHECK_MAX (paramp -> i_num_rules, CVY_MAX_NUM_RULES);

    CVY_CHECK_MIN (paramp -> host_priority, CVY_MIN_HOST_PRIORITY);
    CVY_CHECK_MAX (paramp -> host_priority, CVY_MAX_HOST_PRIORITY);

// CLEAN_64BIT    CVY_CHECK_MIN (paramp -> cluster_mode, CVY_MIN_CLUSTER_MODE);
    CVY_CHECK_MAX (paramp -> cluster_mode, CVY_MAX_CLUSTER_MODE);

    /* If the cluster IP address is not 0.0.0.0, then make sure the IP address is valid. */
    if (lstrcmpi(paramp->cl_ip_addr, CVY_DEF_CL_IP_ADDR)) {
        /* Check the validity of the IP address. */
        if (!(dwIPAddr.S_un.S_addr = IpAddressFromAbcdWsz(paramp->cl_ip_addr)))
            goto error;
        
        /* Convert the DWORD back to a string.  We do this because 11.11.3 is a valid IP
           address the inet_addr converts to 11.11.0.3 as a DWORD.  Therefore, to keep
           the IP address string (which is used by other parts of NLB, such as the UI)
           consistent, we convert back to a string. */
        if (!(szIPAddr = inet_ntoa(dwIPAddr))) 
            goto error;

        /* Convert the ASCII string to unicode. */
        if (!MultiByteToWideChar(CP_ACP, 0, szIPAddr, -1, paramp->cl_ip_addr, WLBS_MAX_CL_IP_ADDR + 1))
            goto error;
    }

    /* If the cluster netmask is not 0.0.0.0, then make sure the netmask is valid. */
    if (lstrcmpi(paramp->cl_net_mask, CVY_DEF_CL_NET_MASK)) {
        /* Check the validity of the IP address. */
        if (!(dwIPAddr.S_un.S_addr = IpAddressFromAbcdWsz(paramp->cl_net_mask)))
            goto error;
        
        /* Convert the DWORD back to a string.  We do this because 11.11.3 is a valid IP
           address the inet_addr converts to 11.11.0.3 as a DWORD.  Therefore, to keep
           the IP address string (which is used by other parts of NLB, such as the UI)
           consistent, we convert back to a string. */
        if (!(szIPAddr = inet_ntoa(dwIPAddr))) 
            goto error;

        /* Convert the ASCII string to unicode. */
        if (!MultiByteToWideChar(CP_ACP, 0, szIPAddr, -1, paramp->cl_net_mask, WLBS_MAX_CL_NET_MASK + 1))
            goto error;
    }

    /* If the dedicated IP address is not 0.0.0.0, then make sure the IP address is valid. */
    if (lstrcmpi(paramp->ded_ip_addr, CVY_DEF_DED_IP_ADDR)) {
        /* Check the validity of the IP address. */
        if (!(dwIPAddr.S_un.S_addr = IpAddressFromAbcdWsz(paramp->ded_ip_addr)))
            goto error;
        
        /* Convert the DWORD back to a string.  We do this because 11.11.3 is a valid IP
           address the inet_addr converts to 11.11.0.3 as a DWORD.  Therefore, to keep
           the IP address string (which is used by other parts of NLB, such as the UI)
           consistent, we convert back to a string. */
        if (!(szIPAddr = inet_ntoa(dwIPAddr))) 
            goto error;

        /* Convert the ASCII string to unicode. */
        if (!MultiByteToWideChar(CP_ACP, 0, szIPAddr, -1, paramp->ded_ip_addr, WLBS_MAX_DED_IP_ADDR + 1))
            goto error;
    }

    /* If the dedicated netmask is not 0.0.0.0, then make sure the netmask is valid. */
    if (lstrcmpi(paramp->ded_net_mask, CVY_DEF_DED_NET_MASK)) {
        /* Check the validity of the IP address. */
        if (!(dwIPAddr.S_un.S_addr = IpAddressFromAbcdWsz(paramp->ded_net_mask)))
            goto error;
        
        /* Convert the DWORD back to a string.  We do this because 11.11.3 is a valid IP
           address the inet_addr converts to 11.11.0.3 as a DWORD.  Therefore, to keep
           the IP address string (which is used by other parts of NLB, such as the UI)
           consistent, we convert back to a string. */
        if (!(szIPAddr = inet_ntoa(dwIPAddr))) 
            goto error;

        /* Convert the ASCII string to unicode. */
        if (!MultiByteToWideChar(CP_ACP, 0, szIPAddr, -1, paramp->ded_net_mask, WLBS_MAX_DED_NET_MASK + 1))
            goto error;
    }

    /* Verify that the port rule VIP is valid, 
       Also, convert the port rule VIPs that might be in the x.x.x or x.x or x form to x.x.x.x */
    idx = 0;
    num_rules = paramp -> i_num_rules;
    while (idx < num_rules) 
    {
        port_rule = &paramp->i_port_rules[idx];

        /* Check if the port rule is valid and the vip is not "All Vip" */
        if (port_rule->valid && lstrcmpi(port_rule->virtual_ip_addr, CVY_DEF_ALL_VIP)) 
        {
            /* Get IP Address into DWORD form */
            if (!(dwIPAddr.S_un.S_addr = IpAddressFromAbcdWsz(port_rule->virtual_ip_addr)))
                goto error;

            /* Check for validity of IP Address */
            if ((dwIPAddr.S_un.S_un_b.s_b1 < WLBS_IP_FIELD_ZERO_LOW) 
             || (dwIPAddr.S_un.S_un_b.s_b1 > WLBS_IP_FIELD_ZERO_HIGH) 
             || (dwIPAddr.S_un.S_un_b.s_b2 < WLBS_FIELD_LOW) 
             || (dwIPAddr.S_un.S_un_b.s_b2 > WLBS_FIELD_HIGH) 
             || (dwIPAddr.S_un.S_un_b.s_b3 < WLBS_FIELD_LOW) 
             || (dwIPAddr.S_un.S_un_b.s_b3 > WLBS_FIELD_HIGH) 
             || (dwIPAddr.S_un.S_un_b.s_b4 < WLBS_FIELD_LOW) 
             || (dwIPAddr.S_un.S_un_b.s_b4 > WLBS_FIELD_HIGH)) 
                goto error;

            /* Convert the DWORD back to a string.  We do this because 11.11.3 is a valid IP
               address the inet_addr converts to 11.11.0.3 as a DWORD.  Therefore, to keep
               the IP address string (which is used by other parts of NLB, such as the UI)
               consistent, we convert back to a string. */
            if (!(szIPAddr = inet_ntoa(dwIPAddr))) 
                goto error;

            /* Convert the ASCII string to unicode. */
            if (!MultiByteToWideChar(CP_ACP, 0, szIPAddr, -1, port_rule->virtual_ip_addr, WLBS_MAX_CL_IP_ADDR + 1))
                goto error;
        }
        idx++;
    }

    /* If either the cluster IP address or the cluster netmask is not 0.0.0.0,
       then make sure the they are a valid IP address/netmask pair. */
    if (lstrcmpi(paramp->cl_ip_addr, CVY_DEF_CL_IP_ADDR) || lstrcmpi(paramp->cl_net_mask, CVY_DEF_CL_NET_MASK)) {
        /* If they have specified a cluster IP address, but no netmask, then fill it in for them. */
        if (!lstrcmpi(paramp->cl_net_mask, CVY_DEF_CL_NET_MASK))
            ParamsGenerateSubnetMask(paramp->cl_ip_addr, paramp->cl_net_mask);

        /* Check for valid cluster IP address/netmask pairs. */
        if (!IsValidIPAddressSubnetMaskPair(paramp->cl_ip_addr, paramp->cl_net_mask))
            goto error;
        
        /* Check to make sure that the cluster netmask is contiguous. */
        if (!IsContiguousSubnetMask(paramp->cl_net_mask))
            goto error;

        /* Check to make sure that the dedicated IP and cluster IP are not the same. */
        if (!wcscmp(paramp->ded_ip_addr, paramp->cl_ip_addr))
            goto error;
    }

    /* If either the dedicated IP address or the dedicated netmask is not 0.0.0.0,
       then make sure the they are a valid IP address/netmask pair. */
    if (lstrcmpi(paramp->ded_ip_addr, CVY_DEF_DED_IP_ADDR) || lstrcmpi(paramp->ded_net_mask, CVY_DEF_DED_NET_MASK)) {
        /* If they have specified a cluster IP address, but no netmask, then fill it in for them. */
        if (!lstrcmpi(paramp->ded_net_mask, CVY_DEF_DED_NET_MASK))
            ParamsGenerateSubnetMask(paramp->ded_ip_addr, paramp->ded_net_mask);

        /* Check for valid dedicated IP address/netmask pairs. */
        if (!IsValidIPAddressSubnetMaskPair(paramp->ded_ip_addr, paramp->ded_net_mask))
            goto error;
        
        /* Check to make sure that the dedicated netmask is contiguous. */
        if (!IsContiguousSubnetMask(paramp->ded_net_mask))
            goto error;
    }

    /* Check the mac address if the convert_mac flag is not set */
    if ( ! paramp -> i_convert_mac)
    {
        PWCHAR p1, p2;
        WCHAR mac_addr [WLBS_MAX_NETWORK_ADDR + 1];
        DWORD i, j;
        BOOL flag = TRUE;

        _tcscpy (mac_addr, paramp -> cl_mac_addr);

        p2 = p1 = mac_addr;

        for (i = 0 ; i < 6 ; i++)
        {
            if (*p2 == _TEXT('\0'))
            {
                flag = FALSE;
                break;
            }

            j = _tcstoul (p1, &p2, 16);

            if ( j > 255)
            {
                flag = FALSE;
                break;
            }

            if ( ! (*p2 == _TEXT('-') || *p2 == _TEXT(':') || *p2 == _TEXT('\0')) )
            {
                flag = FALSE;
                break;
            }

            if (*p2 == _TEXT('\0') && i < 5)
            {
                flag = FALSE;
                break;
            }

            p1 = p2 + 1;
            p2 = p1;

        }


        if (!flag)
        {
            goto error;
        }
    }

    if (paramp->fIGMPSupport && !paramp->mcast_support)
    {
        //
        // IGMP can not be enabled in unicast mode
        //
        LOG_ERROR("ParamWriteReg IGMP can not be enabled in unicast mode");

        goto error;
    }

    if (paramp->mcast_support && paramp->fIGMPSupport && !paramp->fIpToMCastIp)
    {
        //
        // Multicast mode with IGMP enabled, and user specified an multicast IP address,
        // The multicast IP address should be in the range of (224-239).x.x.x 
        //       but NOT (224-239).0.0.x or (224-239).128.0.x. 
        //

        DWORD dwMCastIp = IpAddressFromAbcdWsz(paramp->szMCastIpAddress);

        if ((dwMCastIp & 0xf0) != 0xe0 ||
            (dwMCastIp & 0x00ffff00) == 0 || 
            (dwMCastIp & 0x00ffff00) == 0x00008000)
        {
            LOG_ERROR1("ParamWriteReg invalid szMCastIpAddressr %ws", 
                paramp->szMCastIpAddress);

            goto error;
        }
    }
#endif // OBSOLETE_CODE

    /* Generate the MAC address. */
    ParamsGenerateMAC(paramp->cl_ip_addr, paramp->cl_mac_addr, paramp->szMCastIpAddress, paramp->i_convert_mac, 
                      paramp->mcast_support, paramp->fIGMPSupport, paramp->fIpToMCastIp);
    
    WCHAR reg_path [PARAMS_MAX_STRING_SIZE];

    WCHAR szAdapterGuid[128];
    StringFromGUID2(AdapterGuid, szAdapterGuid, 
            sizeof(szAdapterGuid)/sizeof(szAdapterGuid[0]) );
            
    swprintf (reg_path, L"SYSTEM\\CurrentControlSet\\Services\\WLBS\\Parameters\\Interface\\%s",
            szAdapterGuid);
    
    status = RegCreateKeyEx (HKEY_LOCAL_MACHINE, reg_path, 0L, L"",
                             REG_OPTION_NON_VOLATILE,
                             KEY_ALL_ACCESS, NULL, & key, & disp);

    if (status != ERROR_SUCCESS)
        return FALSE;

    swprintf (reg_path, L"%ls", CVY_NAME_INSTALL_DATE);
    size = sizeof (paramp -> install_date);
    status = RegSetValueEx (key, reg_path, 0L, CVY_TYPE_INSTALL_DATE,
                            (LPBYTE) & paramp -> install_date, size);

    if (status != ERROR_SUCCESS)
        goto error;

    swprintf (reg_path, L"%ls", CVY_NAME_VERIFY_DATE);
    size = sizeof (paramp -> i_verify_date);
    status = RegSetValueEx (key, reg_path, 0L, CVY_TYPE_VERIFY_DATE,
                            (LPBYTE) & paramp -> i_verify_date, size);

    if (status != ERROR_SUCCESS)
        goto error;

    swprintf (reg_path, L"%ls", CVY_NAME_VIRTUAL_NIC);
    size = wcslen (paramp -> i_virtual_nic_name) * sizeof (WCHAR);
    status = RegSetValueEx (key, reg_path, 0L, CVY_TYPE_VIRTUAL_NIC,
                            (LPBYTE) & paramp -> i_virtual_nic_name, size);

    if (status != ERROR_SUCCESS)
        goto error;

    swprintf (reg_path, L"%ls", CVY_NAME_HOST_PRIORITY);
    size = sizeof (paramp -> host_priority);
    status = RegSetValueEx (key, reg_path, 0L, CVY_TYPE_HOST_PRIORITY,
                            (LPBYTE) & paramp -> host_priority, size);

    if (status != ERROR_SUCCESS)
        goto error;

    swprintf (reg_path, L"%ls", CVY_NAME_CLUSTER_MODE);
    size = sizeof (paramp -> cluster_mode);
    status = RegSetValueEx (key, reg_path, 0L, CVY_TYPE_CLUSTER_MODE,
                            (LPBYTE) & paramp -> cluster_mode, size);

    if (status != ERROR_SUCCESS)
        goto error;

    swprintf (reg_path, L"%ls", CVY_NAME_NETWORK_ADDR);
    size = wcslen (paramp -> cl_mac_addr) * sizeof (WCHAR);
    status = RegSetValueEx (key, reg_path, 0L, CVY_TYPE_NETWORK_ADDR,
                            (LPBYTE) paramp -> cl_mac_addr, size);

    if (status != ERROR_SUCCESS)
        goto error;

    swprintf (reg_path, L"%ls", CVY_NAME_CL_IP_ADDR);
    size = wcslen (paramp -> cl_ip_addr) * sizeof (WCHAR);
    status = RegSetValueEx (key, reg_path, 0L, CVY_TYPE_CL_IP_ADDR,
                            (LPBYTE) paramp -> cl_ip_addr, size);

    if (status != ERROR_SUCCESS)
        goto error;

    swprintf (reg_path, L"%ls", CVY_NAME_CL_NET_MASK);
    size = wcslen (paramp -> cl_net_mask) * sizeof (WCHAR);
    status = RegSetValueEx (key, reg_path, 0L, CVY_TYPE_CL_NET_MASK,
                            (LPBYTE) paramp -> cl_net_mask, size);

    if (status != ERROR_SUCCESS)
        goto error;

    swprintf (reg_path, L"%ls", CVY_NAME_DED_IP_ADDR);
    size = wcslen (paramp -> ded_ip_addr) * sizeof (WCHAR);
    status = RegSetValueEx (key, reg_path, 0L, CVY_TYPE_DED_IP_ADDR,
                            (LPBYTE) paramp -> ded_ip_addr, size);

    if (status != ERROR_SUCCESS)
        goto error;

    swprintf (reg_path, L"%ls", CVY_NAME_DED_NET_MASK);
    size = wcslen (paramp -> ded_net_mask) * sizeof (WCHAR);
    status = RegSetValueEx (key, reg_path, 0L, CVY_TYPE_DED_NET_MASK,
                            (LPBYTE) paramp -> ded_net_mask, size);

    if (status != ERROR_SUCCESS)
        goto error;

    swprintf (reg_path, L"%ls", CVY_NAME_DOMAIN_NAME);
    size = wcslen (paramp -> domain_name) * sizeof (WCHAR);
    status = RegSetValueEx (key, reg_path, 0L, CVY_TYPE_DOMAIN_NAME,
                            (LPBYTE) paramp -> domain_name, size);

    if (status != ERROR_SUCCESS)
        goto error;

    swprintf (reg_path, L"%ls", CVY_NAME_ALIVE_PERIOD);
    size = sizeof (paramp -> alive_period);
    status = RegSetValueEx (key, reg_path, 0L, CVY_TYPE_ALIVE_PERIOD,
                              (LPBYTE) & paramp -> alive_period, size);

    if (status != ERROR_SUCCESS)
        goto error;

    swprintf (reg_path, L"%ls", CVY_NAME_ALIVE_TOLER);
    size = sizeof (paramp -> alive_tolerance);
    status = RegSetValueEx (key, reg_path, 0L, CVY_TYPE_ALIVE_TOLER,
                            (LPBYTE) & paramp -> alive_tolerance, size);

    if (status != ERROR_SUCCESS)
        goto error;

    swprintf (reg_path, L"%ls", CVY_NAME_NUM_ACTIONS);
    size = sizeof (paramp -> num_actions);
    status = RegSetValueEx (key, reg_path, 0L, CVY_TYPE_NUM_ACTIONS,
                            (LPBYTE) & paramp -> num_actions, size);

    if (status != ERROR_SUCCESS)
        goto error;

    swprintf (reg_path, L"%ls", CVY_NAME_NUM_PACKETS);
    size = sizeof (paramp -> num_packets);
    status = RegSetValueEx (key, reg_path, 0L, CVY_TYPE_NUM_PACKETS,
                            (LPBYTE) & paramp -> num_packets, size);

    if (status != ERROR_SUCCESS)
        goto error;

    swprintf (reg_path, L"%ls", CVY_NAME_NUM_SEND_MSGS);
    size = sizeof (paramp -> num_send_msgs);
    status = RegSetValueEx (key, reg_path, 0L, CVY_TYPE_NUM_SEND_MSGS,
                            (LPBYTE) & paramp -> num_send_msgs, size);

    if (status != ERROR_SUCCESS)
        goto error;

    swprintf (reg_path, L"%ls", CVY_NAME_DSCR_PER_ALLOC);
    size = sizeof (paramp -> dscr_per_alloc);
    status = RegSetValueEx (key, reg_path, 0L, CVY_TYPE_DSCR_PER_ALLOC,
                            (LPBYTE) & paramp -> dscr_per_alloc, size);

    if (status != ERROR_SUCCESS)
        goto error;

    swprintf (reg_path, L"%ls", CVY_NAME_MAX_DSCR_ALLOCS);
    size = sizeof (paramp -> max_dscr_allocs);
    status = RegSetValueEx (key, reg_path, 0L, CVY_TYPE_MAX_DSCR_ALLOCS,
                            (LPBYTE) & paramp -> max_dscr_allocs, size);

    if (status != ERROR_SUCCESS)
        goto error;

    swprintf (reg_path, L"%ls", CVY_NAME_SCALE_CLIENT);
    size = sizeof (paramp -> i_scale_client);
    status = RegSetValueEx (key, reg_path, 0L, CVY_TYPE_SCALE_CLIENT,
                            (LPBYTE) & paramp -> i_scale_client, size);

    if (status != ERROR_SUCCESS)
        goto error;

    swprintf (reg_path, L"%ls", CVY_NAME_CLEANUP_DELAY);
    size = sizeof (paramp -> i_cleanup_delay);
    status = RegSetValueEx (key, reg_path, 0L, CVY_TYPE_CLEANUP_DELAY,
                            (LPBYTE) & paramp -> i_cleanup_delay, size);

    if (status != ERROR_SUCCESS)
        goto error;

    /* V1.1.1 */

    swprintf (reg_path, L"%ls", CVY_NAME_NBT_SUPPORT);
    size = sizeof (paramp -> i_nbt_support);
    status = RegSetValueEx (key, reg_path, 0L, CVY_TYPE_NBT_SUPPORT,
                            (LPBYTE) & paramp -> i_nbt_support, size);

    if (status != ERROR_SUCCESS)
        goto error;

    /* V1.3b */

    swprintf (reg_path, L"%ls", CVY_NAME_MCAST_SUPPORT);
    size = sizeof (paramp -> mcast_support);
    status = RegSetValueEx (key, reg_path, 0L, CVY_TYPE_MCAST_SUPPORT,
                            (LPBYTE) & paramp -> mcast_support, size);

    if (status != ERROR_SUCCESS)
        goto error;

    swprintf (reg_path, L"%ls", CVY_NAME_MCAST_SPOOF);
    size = sizeof (paramp -> i_mcast_spoof);
    status = RegSetValueEx (key, reg_path, 0L, CVY_TYPE_MCAST_SPOOF,
                            (LPBYTE) & paramp -> i_mcast_spoof, size);

    if (status != ERROR_SUCCESS)
        goto error;

    swprintf (reg_path, L"%ls", CVY_NAME_MASK_SRC_MAC);
    size = sizeof (paramp -> mask_src_mac);
    status = RegSetValueEx (key, reg_path, 0L, CVY_TYPE_MASK_SRC_MAC,
                            (LPBYTE) & paramp -> mask_src_mac, size);

    if (status != ERROR_SUCCESS)
        goto error;

    swprintf (reg_path, L"%ls", CVY_NAME_NETMON_ALIVE);
    size = sizeof (paramp -> i_netmon_alive);
    status = RegSetValueEx (key, reg_path, 0L, CVY_TYPE_NETMON_ALIVE,
                            (LPBYTE) & paramp -> i_netmon_alive, size);

    if (status != ERROR_SUCCESS)
        goto error;

    swprintf (reg_path, L"%ls", CVY_NAME_IP_CHG_DELAY);
    size = sizeof (paramp -> i_ip_chg_delay);
    status = RegSetValueEx (key, reg_path, 0L, CVY_TYPE_IP_CHG_DELAY,
                            (LPBYTE) & paramp -> i_ip_chg_delay, size);

    if (status != ERROR_SUCCESS)
        goto error;

    swprintf (reg_path, L"%ls", CVY_NAME_CONVERT_MAC);
    size = sizeof (paramp -> i_convert_mac);
    status = RegSetValueEx (key, reg_path, 0L, CVY_TYPE_CONVERT_MAC,
                            (LPBYTE) & paramp -> i_convert_mac, size);

    if (status != ERROR_SUCCESS)
        goto error;

    swprintf (reg_path, L"%ls", CVY_NAME_NUM_RULES);
    size = sizeof (paramp -> i_num_rules);
    status = RegSetValueEx (key, reg_path, 0L, CVY_TYPE_NUM_RULES,
                            (LPBYTE) & paramp -> i_num_rules, size);

    if (status != ERROR_SUCCESS)
        goto error;

    //
    // sort the rules before writing it to the registry
    // EnumPortRules will take the rules from reg_data and return them in
    // sorted order in the array itself
    //

    WlbsEnumPortRules (paramp, paramp -> i_port_rules, & num_rules);

    ASSERT(paramp -> i_parms_ver == CVY_PARAMS_VERSION);  // version should be upgrated in read
    
    HKEY                subkey;

    swprintf (reg_path, L"%ls", CVY_NAME_PORT_RULES);
    
    // Delete all existing Port Rules
    SHDeleteKey(key, reg_path); // NOT Checking return value cos the key itself may not be present in which case, it will return error

    // Create "PortRules" key
    if (RegCreateKeyEx (key, reg_path, 0L, L"", REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, NULL, & subkey, & disp)
      != ERROR_SUCCESS)
        goto error;

    bool fSpecificVipPortRuleFound = false;

    idx = 1;
    port_rule = paramp -> i_port_rules;
    while(idx <= num_rules)
    {
        // Invalid port rules are placed at the end, So, once an invalid port rule is encountered, we are done
        if (!port_rule->valid) 
            break;

        HKEY rule_key;
        wchar_t idx_str[8];

        // Create the per port-rule key "1", "2", "3", ...etc
        if (RegCreateKeyEx (subkey, _itow(idx, idx_str, 10), 0L, L"", REG_OPTION_NON_VOLATILE, 
                            KEY_ALL_ACCESS, NULL, & rule_key, & disp)
           != ERROR_SUCCESS)
            goto error;

        // Check if there was any specific-vip port rule
        if (!fSpecificVipPortRuleFound && lstrcmpi(port_rule->virtual_ip_addr, CVY_DEF_ALL_VIP))
             fSpecificVipPortRuleFound = true;

        swprintf (reg_path, L"%ls", CVY_NAME_VIP);
        size = sizeof (port_rule -> virtual_ip_addr);
        status = RegSetValueEx (rule_key, reg_path, 0L, CVY_TYPE_VIP, (LPBYTE) & port_rule->virtual_ip_addr, size);
        if (status != ERROR_SUCCESS)
        {
            goto error;
        }

        swprintf (reg_path, L"%ls", CVY_NAME_START_PORT);
        size = sizeof (port_rule ->start_port );
        status = RegSetValueEx (rule_key, reg_path, 0L, CVY_TYPE_START_PORT, (LPBYTE) &port_rule->start_port, size);
        if (status != ERROR_SUCCESS)
        {
            goto error;
        }

        swprintf (reg_path, L"%ls", CVY_NAME_END_PORT);
        size = sizeof (port_rule ->end_port );
        status = RegSetValueEx (rule_key, reg_path, 0L, CVY_TYPE_END_PORT, (LPBYTE) &port_rule->end_port, size);
        if (status != ERROR_SUCCESS)
        {
            goto error;
        }

        swprintf (reg_path, L"%ls", CVY_NAME_CODE);
        size = sizeof (port_rule ->code);
        status = RegSetValueEx (rule_key, reg_path, 0L, CVY_TYPE_CODE, (LPBYTE) &port_rule->code, size);
        if (status != ERROR_SUCCESS)
        {
            goto error;
        }

        swprintf (reg_path, L"%ls", CVY_NAME_MODE);
        size = sizeof (port_rule->mode);
        status = RegSetValueEx (rule_key, reg_path, 0L, CVY_TYPE_MODE, (LPBYTE) &port_rule->mode, size);
        if (status != ERROR_SUCCESS)
        {
            goto error;
        }

        swprintf (reg_path, L"%ls", CVY_NAME_PROTOCOL);
        size = sizeof (port_rule->protocol);
        status = RegSetValueEx (rule_key, reg_path, 0L, CVY_TYPE_PROTOCOL, (LPBYTE) &port_rule->protocol, size);
        if (status != ERROR_SUCCESS)
        {
            goto error;
        }

        DWORD EqualLoad, Affinity;

        switch (port_rule->mode) 
        {
        case CVY_MULTI :
             EqualLoad = port_rule->mode_data.multi.equal_load;
             swprintf (reg_path, L"%ls", CVY_NAME_EQUAL_LOAD );
             size = sizeof (EqualLoad);
             status = RegSetValueEx (rule_key, reg_path, 0L, CVY_TYPE_EQUAL_LOAD, (LPBYTE) &EqualLoad, size);
             if (status != ERROR_SUCCESS)
             {
                 goto error;
             }

             Affinity = port_rule->mode_data.multi.affinity;
             swprintf (reg_path, L"%ls", CVY_NAME_AFFINITY );
             size = sizeof (Affinity);
             status = RegSetValueEx (rule_key, reg_path, 0L, CVY_TYPE_AFFINITY, (LPBYTE) &Affinity, size);
             if (status != ERROR_SUCCESS)
             {
                 goto error;
             }

             swprintf (reg_path, L"%ls", CVY_NAME_LOAD);
             size = sizeof (port_rule->mode_data.multi.load);
             status = RegSetValueEx (rule_key, reg_path, 0L, CVY_TYPE_LOAD, (LPBYTE) &(port_rule->mode_data.multi.load), size);
             if (status != ERROR_SUCCESS)
             {
                 goto error;
             }
             break;

        case CVY_SINGLE :
             swprintf (reg_path, L"%ls", CVY_NAME_PRIORITY);
             size = sizeof (port_rule->mode_data.single.priority);
             status = RegSetValueEx (rule_key, reg_path, 0L, CVY_TYPE_PRIORITY, (LPBYTE) &(port_rule->mode_data.single.priority), size);
             if (status != ERROR_SUCCESS)
             {
                 goto error;
             }
             break;

        default:
             break;
        }

        port_rule++;
        idx++;
    }

    // If there is a specific-vip port rule, write that info on to the registry
    if (fSpecificVipPortRuleFound)
        paramp -> i_effective_version = CVY_VERSION_FULL;
    else
        paramp -> i_effective_version = CVY_NT40_VERSION_FULL;

    swprintf (reg_path, L"%ls", CVY_NAME_EFFECTIVE_VERSION);
    size = sizeof (paramp -> i_effective_version);
    status = RegSetValueEx (key, reg_path, 0L, CVY_TYPE_EFFECTIVE_VERSION,
                            (LPBYTE) & paramp -> i_effective_version, size);

    if (status != ERROR_SUCCESS)
        goto error;

    swprintf (reg_path, L"%ls", CVY_NAME_LICENSE_KEY);
    size = wcslen (paramp -> i_license_key) * sizeof (WCHAR);
    status = RegSetValueEx (key, reg_path, 0L, CVY_TYPE_LICENSE_KEY,
                            (LPBYTE) paramp -> i_license_key, size);

    if (status != ERROR_SUCCESS)
        goto error;

    swprintf (reg_path, L"%ls", CVY_NAME_RMT_PASSWORD);
    size = sizeof (paramp -> i_rmt_password);
    status = RegSetValueEx (key, reg_path, 0L, CVY_TYPE_RMT_PASSWORD,
                            (LPBYTE) & paramp -> i_rmt_password, size);

    if (status != ERROR_SUCCESS)
        goto error;

    swprintf (reg_path, L"%ls", CVY_NAME_RCT_PASSWORD);
    size = sizeof (paramp -> i_rct_password);
    status = RegSetValueEx (key, reg_path, 0L, CVY_TYPE_RCT_PASSWORD,
                            (LPBYTE) & paramp -> i_rct_password, size);

    if (status != ERROR_SUCCESS)
        goto error;

    swprintf (reg_path, L"%ls", CVY_NAME_RCT_PORT);
    size = sizeof (paramp -> rct_port);
    status = RegSetValueEx (key, reg_path, 0L, CVY_TYPE_RCT_PORT,
                            (LPBYTE) & paramp -> rct_port, size);

    if (status != ERROR_SUCCESS)
        goto error;

    swprintf (reg_path, L"%ls", CVY_NAME_RCT_ENABLED);
    size = sizeof (paramp -> rct_enabled);
    status = RegSetValueEx (key, reg_path, 0L, CVY_TYPE_RCT_ENABLED,
                            (LPBYTE) & paramp -> rct_enabled, size);

    if (status != ERROR_SUCCESS)
        goto error;

    //
    // IGMP support registry entries
    //
    status = RegSetValueEx (key, CVY_NAME_IGMP_SUPPORT, 0L, CVY_TYPE_IGMP_SUPPORT,
                            (LPBYTE) & paramp->fIGMPSupport, sizeof (paramp->fIGMPSupport));
    
    if (status != ERROR_SUCCESS)
        goto error;
        
    status = RegSetValueEx (key, CVY_NAME_MCAST_IP_ADDR, 0L, CVY_TYPE_MCAST_IP_ADDR, (LPBYTE) & paramp->szMCastIpAddress, 
                            lstrlen (paramp->szMCastIpAddress)* sizeof(paramp->szMCastIpAddress[0]));

    if (status != ERROR_SUCCESS)
        goto error;
    
    status = RegSetValueEx (key, CVY_NAME_IP_TO_MCASTIP, 0L, CVY_TYPE_IP_TO_MCASTIP,
                            (LPBYTE) & paramp->fIpToMCastIp, sizeof (paramp->fIpToMCastIp));
    
    if (status != ERROR_SUCCESS)
        goto error;

    /* If teaming is active on this adapter, then create a subkey to house the BDA teaming configuration and fill it in. */
    if (paramp->bda_teaming.active) {
        GUID TeamGuid;
        HRESULT hr;

        /* Attempt to create the registry key. */
        if (!(bda_key = RegCreateWlbsBDASettings(AdapterGuid)))
            goto error;

        /* Attempt to convert the string to a GUID and check for errors. */
        hr = CLSIDFromString(paramp->bda_teaming.team_id, &TeamGuid);

        /* If the conversion fails, bail out - the team ID must not have been a GUID. */
        if (hr != NOERROR) {
            LOG_ERROR1("ParamWriteReg:  Invalid BDA Team ID: %ls", paramp->bda_teaming.team_id);
            goto error;
        }

        /* Set the team ID - if it fails, bail out. */
        status = RegSetValueEx(bda_key, CVY_NAME_BDA_TEAM_ID, 0L, CVY_TYPE_BDA_TEAM_ID, (LPBYTE)&paramp->bda_teaming.team_id, 
                               lstrlen(paramp->bda_teaming.team_id) * sizeof(paramp->bda_teaming.team_id[0]));
        
        if (status != ERROR_SUCCESS)
            goto bda_error;

        /* Set the master status - if it fails, bail out. */
        status = RegSetValueEx(bda_key, CVY_NAME_BDA_MASTER, 0L, CVY_TYPE_BDA_MASTER,
                               (LPBYTE)&paramp->bda_teaming.master, sizeof (paramp->bda_teaming.master));

        if (status != ERROR_SUCCESS)
            goto bda_error;

        /* Set the reverse hashing flag - if it fails, bail out. */
        status = RegSetValueEx(bda_key, CVY_NAME_BDA_REVERSE_HASH, 0L, CVY_TYPE_BDA_REVERSE_HASH,
                               (LPBYTE)&paramp->bda_teaming.reverse_hash, sizeof (paramp->bda_teaming.reverse_hash));

        if (status != ERROR_SUCCESS)
            goto bda_error;

        RegCloseKey(bda_key);
    } else {
        /* Delte the registry key and ignore the return value - the key may not even exist. */
        RegDeleteWlbsBDASettings(AdapterGuid);
    }

    //
    // Create an empty string if VirtualNICName does not exist
    //
    swprintf (reg_path, L"%ls", CVY_NAME_VIRTUAL_NIC);
    WCHAR virtual_nic_name[CVY_MAX_CLUSTER_NIC + 1];
    size = sizeof(virtual_nic_name);
    status = RegQueryValueEx (key, CVY_NAME_VIRTUAL_NIC, 0L, NULL,
                              (LPBYTE)virtual_nic_name, & size);

    if (status != ERROR_SUCCESS)
    {
        virtual_nic_name [0] = 0;
        size = wcslen (virtual_nic_name) * sizeof (WCHAR);
        status = RegSetValueEx (key, reg_path, 0L, CVY_TYPE_VIRTUAL_NIC,
                            (LPBYTE) & virtual_nic_name, size);
    }

    /* lastly write the version number */

    swprintf (reg_path, L"%ls", CVY_NAME_VERSION);
    size = sizeof (paramp -> i_parms_ver);
    status = RegSetValueEx (key, reg_path, 0L, CVY_TYPE_VERSION,
                            (LPBYTE) & paramp -> i_parms_ver, size);

    if (status != ERROR_SUCCESS)
        goto error;

    RegCloseKey (key);

    return TRUE;

 error:
    RegCloseKey(key);
    return FALSE;

 bda_error:
    RegCloseKey(bda_key);
    goto error;
} 




//+----------------------------------------------------------------------------
//
// Function:  ParamDeleteReg
//
// Description:  Delete the registry settings
//
// Arguments: IN const WCHAR* pszInterface - 
//
// Returns:   DWORD WINAPI - 
//
// History:   fengsun Created Header    1/22/00
//
//+----------------------------------------------------------------------------
bool WINAPI ParamDeleteReg(const GUID& AdapterGuid, bool fDeleteObsoleteEntries)
{
    WCHAR        reg_path [PARAMS_MAX_STRING_SIZE];
    LONG         status;

    WCHAR szAdapterGuid[128];

    StringFromGUID2(AdapterGuid, szAdapterGuid, 
            sizeof(szAdapterGuid)/sizeof(szAdapterGuid[0]) );

    swprintf (reg_path, L"SYSTEM\\CurrentControlSet\\Services\\WLBS\\Parameters\\Interface\\%s",
            szAdapterGuid);

    if (fDeleteObsoleteEntries) 
    {
        HKEY hkey;

        // Delete Port Rules in Binary format
        status = RegOpenKeyEx (HKEY_LOCAL_MACHINE, reg_path, 0L, KEY_ALL_ACCESS, &hkey);
        if (status == ERROR_SUCCESS)
        {
            RegDeleteValue(hkey, CVY_NAME_OLD_PORT_RULES);
            RegCloseKey(hkey);
        }

        // Delete Win2k entries, Enumerate & delete values
        swprintf (reg_path, L"SYSTEM\\CurrentControlSet\\Services\\WLBS\\Parameters");
        status = RegOpenKeyEx (HKEY_LOCAL_MACHINE, reg_path, 0L, KEY_ALL_ACCESS, &hkey);
        if (status == ERROR_SUCCESS)
        {
           DWORD  Index, ValueNameSize;
           WCHAR  ValueName [PARAMS_MAX_STRING_SIZE];

           Index = 0;
           ValueNameSize = PARAMS_MAX_STRING_SIZE;
           while (RegEnumValue(hkey, Index++, ValueName, &ValueNameSize, NULL, NULL, NULL, NULL) == ERROR_SUCCESS) 
           {
               RegDeleteValue(hkey, ValueName);
           }
           RegCloseKey(hkey);
        }
    }
    else
    {
        DWORD dwRet = RegDeleteKey(HKEY_LOCAL_MACHINE, reg_path);

        if (dwRet != ERROR_SUCCESS)
        {
            LOG_ERROR1("ParamDeleteReg failed at RegDeleteKey for %s", szAdapterGuid);
            return false;
        }
    }

    return true;
} /* end Params_delete */




//+----------------------------------------------------------------------------
//
// Function:  ParamSetDefaults
//
// Description:  Set default settings
//
// Arguments: PWLBS_REG_PARAMS    reg_data - 
//
// Returns:   DWORD - 
//
// History:   fengsun Created Header    3/9/00
//
//+----------------------------------------------------------------------------
DWORD WINAPI ParamSetDefaults(PWLBS_REG_PARAMS    reg_data)
{
    reg_data -> install_date = 0;
    reg_data -> i_verify_date = 0;
//    reg_data -> cluster_nic_name [0] = _TEXT('\0');
    reg_data -> i_parms_ver = CVY_DEF_VERSION;
    reg_data -> i_virtual_nic_name [0] = _TEXT('\0');
    reg_data -> host_priority = CVY_DEF_HOST_PRIORITY;
    reg_data -> cluster_mode = CVY_DEF_CLUSTER_MODE;
    _stprintf (reg_data -> cl_mac_addr, _TEXT("%ls"), CVY_DEF_NETWORK_ADDR);
    _stprintf (reg_data -> cl_ip_addr, _TEXT("%ls"), CVY_DEF_CL_IP_ADDR);
    _stprintf (reg_data -> cl_net_mask, _TEXT("%ls"), CVY_DEF_CL_NET_MASK);
    _stprintf (reg_data -> ded_ip_addr, _TEXT("%ls"), CVY_DEF_DED_IP_ADDR);
    _stprintf (reg_data -> ded_net_mask, _TEXT("%ls"), CVY_DEF_DED_NET_MASK);
    _stprintf (reg_data -> domain_name, _TEXT("%ls"), CVY_DEF_DOMAIN_NAME);
    reg_data -> alive_period = CVY_DEF_ALIVE_PERIOD;
    reg_data -> alive_tolerance = CVY_DEF_ALIVE_TOLER;
    reg_data -> num_actions = CVY_DEF_NUM_ACTIONS;
    reg_data -> num_packets = CVY_DEF_NUM_PACKETS;
    reg_data -> num_send_msgs = CVY_DEF_NUM_SEND_MSGS;
    reg_data -> dscr_per_alloc = CVY_DEF_DSCR_PER_ALLOC;
    reg_data -> max_dscr_allocs = CVY_DEF_MAX_DSCR_ALLOCS;
    reg_data -> i_scale_client = CVY_DEF_SCALE_CLIENT;
    reg_data -> i_cleanup_delay = CVY_DEF_CLEANUP_DELAY;
    reg_data -> i_ip_chg_delay = CVY_DEF_IP_CHG_DELAY;
    reg_data -> i_nbt_support = CVY_DEF_NBT_SUPPORT;
    reg_data -> mcast_support = CVY_DEF_MCAST_SUPPORT;
    reg_data -> i_mcast_spoof = CVY_DEF_MCAST_SPOOF;
    reg_data -> mask_src_mac = CVY_DEF_MASK_SRC_MAC;
    reg_data -> i_netmon_alive = CVY_DEF_NETMON_ALIVE;
    reg_data -> i_effective_version = CVY_NT40_VERSION_FULL;
    reg_data -> i_convert_mac = CVY_DEF_CONVERT_MAC;
    reg_data -> i_num_rules = 0;
    memset (reg_data -> i_port_rules, 0, sizeof (WLBS_PORT_RULE) * WLBS_MAX_RULES);
    _stprintf (reg_data -> i_license_key, _TEXT("%ls"), CVY_DEF_LICENSE_KEY);
    reg_data -> i_rmt_password = CVY_DEF_RMT_PASSWORD;
    reg_data -> i_rct_password = CVY_DEF_RCT_PASSWORD;
    reg_data -> rct_port = CVY_DEF_RCT_PORT;
    reg_data -> rct_enabled = CVY_DEF_RCT_ENABLED;
    reg_data -> i_max_hosts        = CVY_MAX_HOSTS;
    reg_data -> i_max_rules        = CVY_MAX_USABLE_RULES;

    reg_data -> fIGMPSupport = CVY_DEF_IGMP_SUPPORT;
    lstrcpy(reg_data -> szMCastIpAddress, CVY_DEF_MCAST_IP_ADDR);
    reg_data -> fIpToMCastIp = CVY_DEF_IP_TO_MCASTIP;
        
    reg_data->bda_teaming.active = CVY_DEF_BDA_ACTIVE;
    reg_data->bda_teaming.master = CVY_DEF_BDA_MASTER;
    reg_data->bda_teaming.reverse_hash = CVY_DEF_BDA_REVERSE_HASH;
    reg_data->bda_teaming.team_id[0] = CVY_DEF_BDA_TEAM_ID;

        reg_data -> i_num_rules = 1;

        // fill in the first port rule.
        _stprintf (reg_data->i_port_rules[0].virtual_ip_addr, _TEXT("%ls"), CVY_DEF_ALL_VIP);
        reg_data -> i_port_rules [0] . start_port = CVY_DEF_PORT_START;
        reg_data -> i_port_rules [0] . end_port = CVY_DEF_PORT_END;
        reg_data -> i_port_rules [0] . valid = TRUE;
        reg_data -> i_port_rules [0] . mode = CVY_DEF_MODE;
        reg_data -> i_port_rules [0] . mode_data . multi . equal_load = TRUE;
        reg_data -> i_port_rules [0] . mode_data . multi . affinity   = CVY_DEF_AFFINITY;
        reg_data -> i_port_rules [0] . mode_data . multi . load       = CVY_DEF_LOAD;
        reg_data -> i_port_rules [0] . protocol = CVY_DEF_PROTOCOL;
        CVY_RULE_CODE_SET(& reg_data -> i_port_rules [0]);

    return WLBS_OK;
}


EXTERN_C DWORD WINAPI WlbsGetNumPortRules
(
    const PWLBS_REG_PARAMS reg_data
)
{
    if (reg_data == NULL)
        return WLBS_BAD_PARAMS;

    return reg_data -> i_num_rules;

} /* end WlbsGetNumPortRules */

EXTERN_C DWORD WINAPI WlbsGetEffectiveVersion
(
    const PWLBS_REG_PARAMS reg_data
)
{
    if (reg_data == NULL)
        return WLBS_BAD_PARAMS;

    return reg_data -> i_effective_version;

} /* end WlbsGetEffectiveVersion */

EXTERN_C DWORD WINAPI WlbsEnumPortRules
(
    const PWLBS_REG_PARAMS reg_data,
    PWLBS_PORT_RULE  rules,
    PDWORD           num_rules
)
{
    DWORD count_rules, i, index;
    DWORD lowest_vip, lowest_port;
    BOOL array_flags [WLBS_MAX_RULES];
    WLBS_PORT_RULE sorted_rules [WLBS_MAX_RULES];


    if ((reg_data == NULL) || (num_rules == NULL))
        return WLBS_BAD_PARAMS;

    if (*num_rules == 0)
        rules = NULL;
    /* this array is used for keeping track of which rules have already been retrieved */
    /* This is needed since the rules are to be retrieved in the sorted order */

    memset ( array_flags, 0, sizeof(BOOL) * WLBS_MAX_RULES );

    count_rules = 0;

    while ((count_rules < *num_rules) && (count_rules < reg_data -> i_num_rules))
    {
        i = 0;

        /* find the first rule that has not been retrieved */
        while ((! reg_data -> i_port_rules [i] . valid) || array_flags [i])
        {
            i++;
        }

        lowest_vip = htonl(IpAddressFromAbcdWsz(reg_data -> i_port_rules [i] . virtual_ip_addr));
        lowest_port = reg_data -> i_port_rules [i] . start_port;
        index = i;

        /* Compare that rule with the other non-retrieved rules to get the rule with the
           lowest VIP & start_port */

        i++;
        while (i < WLBS_MAX_RULES)
        {
            if (reg_data -> i_port_rules [i] . valid && ( ! array_flags [i] ))
            {
                DWORD current_vip = htonl(IpAddressFromAbcdWsz(reg_data -> i_port_rules [i] . virtual_ip_addr));
                if ((current_vip < lowest_vip) 
                 || ((current_vip == lowest_vip) && (reg_data -> i_port_rules [i] . start_port < lowest_port)))
                {
                    lowest_vip = current_vip;
                    lowest_port = reg_data -> i_port_rules [i] . start_port;
                    index = i;
                }
            }
            i++;
        }
        /*       The array_flags [i] element is set to TRUE if the rule is retrieved */
        array_flags [index] = TRUE;
        sorted_rules [count_rules] = reg_data -> i_port_rules [index];
        count_rules ++;
    }

    /* write the sorted rules back into the return array */
    for (i = 0; i < count_rules; i++)
        rules[i] = sorted_rules[i];

    /* invalidate the remaining rules in the buffer */
    for (i = count_rules; i < *num_rules; i++)
        rules [i] . valid = FALSE;

    if (*num_rules < reg_data -> i_num_rules)
    {
        *num_rules = reg_data -> i_num_rules;
        return WLBS_TRUNCATED;
    }

    *num_rules = reg_data -> i_num_rules;
    return WLBS_OK;

} /* end WlbsEnumPortRules */


EXTERN_C DWORD WINAPI WlbsGetPortRule
(
    const PWLBS_REG_PARAMS reg_data,
    DWORD                  vip,
    DWORD                  pos,
    OUT PWLBS_PORT_RULE    rule
)
{
    int i;


    if ((reg_data == NULL) || (rule == NULL))
        return WLBS_BAD_PARAMS;

    /* need to check whether pos is within the correct range */
    if ( /* CLEAN_64BIT (pos < CVY_MIN_PORT) || */ (pos > CVY_MAX_PORT))
        return WLBS_BAD_PARAMS;

    /* search through the array for the rules */
    for (i = 0; i < WLBS_MAX_RULES; i++)
    {
        /* check only the valid rules */
        if (reg_data -> i_port_rules[i] . valid == TRUE)
        {
            /* check the range of the rule to see if pos fits into it */
            if ((vip == IpAddressFromAbcdWsz(reg_data -> i_port_rules[i] . virtual_ip_addr)) &&
                (pos >= reg_data -> i_port_rules[i] . start_port) &&
                (pos <= reg_data -> i_port_rules[i] . end_port))
            {
                *rule = reg_data -> i_port_rules [i];
                return WLBS_OK;
            }
        }
    }

    /* no rule was found for this port */
    return WLBS_NOT_FOUND;

} /* end WlbsGetPortRule */


EXTERN_C DWORD WINAPI WlbsAddPortRule
(
    PWLBS_REG_PARAMS reg_data,
    const PWLBS_PORT_RULE rule
)
{
    int i;
    DWORD vip;


    if ((reg_data == NULL) || (rule == NULL))
        return WLBS_BAD_PARAMS;

    /* Check if there is space for the new rule */
    if (reg_data -> i_num_rules == WLBS_MAX_RULES)
        return WLBS_MAX_PORT_RULES;

    /* check the rule for valid values */

    /* check for non-zero vip and conflict with dip */
    vip = IpAddressFromAbcdWsz(rule -> virtual_ip_addr);
    if ((vip == 0) || (vip == IpAddressFromAbcdWsz(reg_data->ded_ip_addr))) 
    {
        return WLBS_BAD_PORT_PARAMS;
    }

    /* first check the range of the start and end ports */
    if ((rule -> start_port > rule -> end_port) ||
// CLEAN_64BIT        (rule -> start_port < CVY_MIN_PORT)     ||
        (rule -> end_port   > CVY_MAX_PORT))
    {
        return WLBS_BAD_PORT_PARAMS;
    }

    /* check the protocol range */
    if ((rule -> protocol < CVY_MIN_PROTOCOL) || (rule -> protocol > CVY_MAX_PROTOCOL))
        return WLBS_BAD_PORT_PARAMS;

    /* check filtering mode to see whether it is within range */
    if ((rule -> mode < CVY_MIN_MODE) || (rule -> mode > CVY_MAX_MODE))
        return WLBS_BAD_PORT_PARAMS;

    /* check load weight and affinity if multiple hosts */
    if (rule -> mode == CVY_MULTI)
    {
        if ((rule -> mode_data . multi . affinity < CVY_MIN_AFFINITY) ||
            (rule -> mode_data . multi . affinity > CVY_MAX_AFFINITY))
        {
            return WLBS_BAD_PORT_PARAMS;
        }

        if ((rule -> mode_data . multi . equal_load < CVY_MIN_EQUAL_LOAD) ||
            (rule -> mode_data . multi . equal_load > CVY_MAX_EQUAL_LOAD))
        {
            return WLBS_BAD_PORT_PARAMS;
        }

        if (! rule -> mode_data . multi . equal_load)
        {
            if ((rule -> mode_data . multi . load > CVY_MAX_LOAD))
                //CLEAN_64BIT (rule -> mode_data . multi . load < CVY_MIN_LOAD) ||
            {
                return WLBS_BAD_PORT_PARAMS;
            }
        }
    }

    /* check handling priority range if single host */
    if (rule -> mode == CVY_SINGLE)
    {
        if ((rule -> mode_data . single . priority < CVY_MIN_PRIORITY) ||
            (rule -> mode_data . single . priority > CVY_MAX_PRIORITY))
        {
            return WLBS_BAD_PORT_PARAMS;
        }
    }

    /* go through the rule list and then check for overlapping conditions */
    for (i = 0; i < WLBS_MAX_RULES; i++)
    {
        if (reg_data -> i_port_rules[i] . valid == TRUE)
        {
            if ((IpAddressFromAbcdWsz(reg_data -> i_port_rules[i] . virtual_ip_addr) == vip) 
            && (( (reg_data -> i_port_rules[i] . start_port <= rule -> start_port) &&
                  (reg_data -> i_port_rules[i] . end_port   >= rule -> start_port))      ||
                ( (reg_data -> i_port_rules[i] . start_port >= rule -> start_port)   &&
                  (reg_data -> i_port_rules[i] . start_port <= rule -> end_port))))
            {
                return WLBS_PORT_OVERLAP;
            }
        }
    }


    /* go through the rule list and find out the first empty spot
       and write out the port rule */

    for (i = 0 ; i < WLBS_MAX_RULES ; i++)
    {
        if (reg_data -> i_port_rules[i] . valid == FALSE)
        {
            reg_data -> i_num_rules ++ ;
            reg_data -> i_port_rules [i] = *rule;
            reg_data -> i_port_rules [i] . valid = TRUE;
            CVY_RULE_CODE_SET(& reg_data -> i_port_rules [i]);
            return WLBS_OK;
        }
    }

    return WLBS_MAX_PORT_RULES;

} /* end WlbsAddPortRule */


EXTERN_C DWORD WINAPI WlbsDeletePortRule
(
    PWLBS_REG_PARAMS reg_data,
    DWORD            vip,
    DWORD            port
)
{
    int i;

    if (reg_data == NULL)
        return WLBS_BAD_PARAMS;

    /* check if the port is within the correct range */
    if ( /* CLEAN_64BIT (port < CVY_MIN_PORT) ||*/ (port > CVY_MAX_PORT))
        return WLBS_BAD_PARAMS;

    /* find the rule associated with this port */

    for (i = 0; i < WLBS_MAX_RULES; i++)
    {
        if (reg_data -> i_port_rules[i] . valid)
        {
            if ((vip  == IpAddressFromAbcdWsz(reg_data -> i_port_rules[i] . virtual_ip_addr)) &&
                (port >= reg_data -> i_port_rules[i] . start_port) &&
                (port <= reg_data -> i_port_rules[i] . end_port))
            {
                reg_data -> i_port_rules[i] . valid = FALSE;
                reg_data -> i_num_rules -- ;
                return WLBS_OK;
            }
        }
    }

    return WLBS_NOT_FOUND;

} /* end WlbsDeletePortRule */


EXTERN_C DWORD WINAPI WlbsSetRemotePassword
(
    PWLBS_REG_PARAMS reg_data,
    const WCHAR*           password
)
{
    if (reg_data == NULL)
        return WLBS_BAD_PARAMS;

    if (password != NULL)
    {
        reg_data -> i_rct_password = License_wstring_encode ((WCHAR*)password);
    }
    else
        reg_data -> i_rct_password = CVY_DEF_RCT_PASSWORD;

    return WLBS_OK;

} /* end WlbsSetRemotePassword */

//+----------------------------------------------------------------------------
//
// Function:  RegChangeNetworkAddress
//
// Description:  Change the mac address of the adapter in registry
//
// Arguments: const GUID& AdapterGuid - the adapter guid to look up settings
//            TCHAR mac_address - 
//            BOOL fRemove - true to remove address, false to write address
//
// Returns:   bool - true if succeeded
//
// History:   fengsun Created Header    1/18/00
//
//+----------------------------------------------------------------------------
bool WINAPI RegChangeNetworkAddress(const GUID& AdapterGuid, const WCHAR* mac_address, BOOL fRemove)
{
    HKEY                key = NULL;
    LONG                status;
    DWORD               size;
    DWORD               type;
    TCHAR               net_addr [CVY_MAX_NETWORK_ADDR + 1];
    HDEVINFO            hdi = NULL;
    SP_DEVINFO_DATA     deid;
    TCHAR               tbuf[CVY_STR_SIZE];


    if (fRemove)
    {
        LOG_INFO("RegChangeNetworkAddress remove mac address");
    }
    else
    {
        if (!lstrcmpi(mac_address, CVY_DEF_UNICAST_NETWORK_ADDR)) {
            LOG_INFO1("RegChangeNetworkAddress refusing to change mac address to %ws", mac_address);
            fRemove = TRUE;
        } else {
            LOG_INFO1("RegChangeNetworkAddress to %ws", mac_address);
        }
    }

    /*
        - write NetworkAddress value into the cluster adapter's params key
          if mac address changed, or remove it if switched to multicast mode
    */

    key = RegOpenWlbsSetting(AdapterGuid, true);

    if (key == NULL)
    {
        LOG_ERROR("RegChangeNetworkAddress failed at RegOpenWlbsSetting");
        goto error;
    }

    _stprintf (tbuf, _TEXT("%ls"), CVY_NAME_CLUSTER_NIC);

    TCHAR        driver_name   [CVY_STR_SIZE];      //  the NIC card name for the cluster
    size = sizeof (driver_name);
    status = RegQueryValueEx (key, tbuf, 0L, & type, (LPBYTE) driver_name,
                              & size);

    if (status != ERROR_SUCCESS)
    {
        LOG_ERROR("RegChangeNetworkAddress failed at RegQueryValueEx for ClusterNICName");
        goto error;
    }

    RegCloseKey(key);
    key = NULL;

    hdi = SetupDiCreateDeviceInfoList (&GUID_DEVCLASS_NET, NULL);

    if (hdi == INVALID_HANDLE_VALUE)
    {
        LOG_ERROR("RegChangeNetworkAddress failed at SetupDiCreateDeviceInfoList");
        goto error;
    }

    ZeroMemory(&deid, sizeof(deid));
    deid.cbSize = sizeof(deid);

    if (! SetupDiOpenDeviceInfo (hdi, driver_name, NULL, 0, &deid))
    {
        LOG_ERROR("RegChangeNetworkAddress failed at SetupDiOpenDeviceInfo");
        goto error;
    }

    key = SetupDiOpenDevRegKey (hdi, &deid, DICS_FLAG_GLOBAL, 0,
                                DIREG_DRV, KEY_ALL_ACCESS);

    if (key == INVALID_HANDLE_VALUE)
    {
        LOG_ERROR("RegChangeNetworkAddress failed at SetupDiOpenDevRegKey");
        goto error;
    }

    /* Now the key has been obtained and this can be passed to the RegChangeNetworkAddress call */

    if ((/*global_info.mac_addr_change ||*/ !fRemove)) /* a write is required */
    {
        /* Check if the saved name exists.
         * If it does not, create a new field and save the old address.
         * Write the new address and return
         */

        _stprintf (tbuf, _TEXT("%ls"), CVY_NAME_SAVED_NET_ADDR);
        size = sizeof (TCHAR) * CVY_STR_SIZE;
        status = RegQueryValueEx (key, tbuf, 0L, &type,
                                  (LPBYTE) net_addr, &size);

        if (status != ERROR_SUCCESS) /* there is no saved address. so create a field */
        {
            /* Query the existing mac address in order to save it */
            _stprintf (tbuf, _TEXT("%ls"), CVY_NAME_NET_ADDR);
            size = sizeof (net_addr);
            status = RegQueryValueEx (key, tbuf, 0L, &type,
                                      (LPBYTE) net_addr, &size);

            if (status != ERROR_SUCCESS) /* create an empty saved address */
            {
                net_addr [0] = 0;
                size = 0;
            }

            _stprintf (tbuf, _TEXT("%ls"), CVY_NAME_SAVED_NET_ADDR);
            status = RegSetValueEx (key, tbuf, 0L, CVY_TYPE_NET_ADDR,
                                    (LPBYTE) net_addr, size);

            /* Unable to save the old value */
            if (status != ERROR_SUCCESS)
            {
                LOG_ERROR("RegChangeNetworkAddress failed at RegSetValueEx for WLBSSavedNetworkAddress");
                goto error;
            }
        }

        /* Write the new network address */
        _stprintf (tbuf, _TEXT("%ls"), CVY_NAME_NET_ADDR);
        size = _tcslen (mac_address) * sizeof (TCHAR);
        status = RegSetValueEx (key, tbuf, 0L, CVY_TYPE_NET_ADDR,
                                (LPBYTE)mac_address, size);

        /* Unable to write the new address */
        if (status != ERROR_SUCCESS)
        {
            LOG_ERROR("RegChangeNetworkAddress failed at RegSetValueEx for NetworkAddress");
            goto error;
        }
    }
    else     // remove the address
    {
        /* If the saved field exists,
         * copy this address into the mac address
         * and remove the saved field and return.
         */

        _stprintf (tbuf, _TEXT("%ls"), CVY_NAME_SAVED_NET_ADDR);
        size = sizeof (net_addr);
        status = RegQueryValueEx (key, tbuf, 0L, &type,
                                  (LPBYTE)net_addr, &size);

        if (status == ERROR_SUCCESS)
        {
            /* delete both fields if saved address is empty */
            if ((size == 0) || (_tcsicmp (net_addr, _TEXT("none")) == 0))
            {
                _stprintf (tbuf, _TEXT("%ls"), CVY_NAME_SAVED_NET_ADDR);
                RegDeleteValue (key, tbuf);
                _stprintf (tbuf, _TEXT("%ls"), CVY_NAME_NET_ADDR);
                RegDeleteValue (key, tbuf);
            }
            else /* copy saved address as the network address and delete the saved address field */
            {
                _stprintf (tbuf, _TEXT("%ls"), CVY_NAME_SAVED_NET_ADDR);
                RegDeleteValue (key, tbuf);

                _stprintf (tbuf, _TEXT("%ls"), CVY_NAME_NET_ADDR);
                size = _tcslen (net_addr) * sizeof (TCHAR);
                status = RegSetValueEx (key, tbuf, 0L, CVY_TYPE_NET_ADDR,
                                        (LPBYTE) net_addr, size);

                /* Unable to set the original address */
                if (status != ERROR_SUCCESS)
                {
                    LOG_ERROR("RegChangeNetworkAddress failed at RegSetValueEx for NetworkAddress");
                    goto error;
                }
            }
        }
    }

    RegCloseKey (key);
    key = NULL;


    return true;

error:

    if (key != NULL)
        RegCloseKey(key);

    if (hdi != NULL)
        SetupDiDestroyDeviceInfoList (hdi);

    LOG_ERROR("RegChangeNetworkAddress failed");

    return false;

} 





//+----------------------------------------------------------------------------
//
// Function:  NotifyAdapterAddressChange
//
// Description:  Notify the adapter to reload MAC address 
//              The parameter is different from NotifyAdapterAddressChange.
//              Can not overload, because the function has to be exported
//
// Arguments: const WCHAR* driver_name - 
//
// Returns:   void WINAPI - 
//
// History: fengsun Created 5/20/00
//
//+----------------------------------------------------------------------------
void WINAPI NotifyAdapterAddressChange (const WCHAR * driver_name) {
    
    NotifyAdapterPropertyChange(driver_name, DICS_PROPCHANGE);
}

/*
 * Function: NotifyAdapterPropertyChange
 * Description: Notify a device that a property change event has occurred.
 *              Event should be one of: DICS_PROPCHANGE, DICS_DISABLE, DICS_ENABLE
 * Author: shouse 7.17.00
 */
void WINAPI NotifyAdapterPropertyChange (const WCHAR * driver_name, DWORD eventFlag) {
    HDEVINFO            hdi = NULL;
    SP_DEVINFO_DATA     deid;

    LOG_INFO1("NotifyAdapterPropertyChange eventFlag %d", eventFlag);
    
    hdi = SetupDiCreateDeviceInfoList (&GUID_DEVCLASS_NET, NULL);

    if (hdi == INVALID_HANDLE_VALUE)
    {
        LOG_ERROR("NotifyAdapterPropertyChange failed at SetupDiCreateDeviceInfoList");
        goto error;
    }

    ZeroMemory(&deid, sizeof(deid));
    deid.cbSize = sizeof(deid);

    if (! SetupDiOpenDeviceInfo (hdi, driver_name, NULL, 0, &deid))
    {
        LOG_ERROR("NotifyAdapterPropertyChange failed at SetupDiOpenDeviceInfo");
        goto error;
    }

    SP_PROPCHANGE_PARAMS    pcp;
    SP_DEVINSTALL_PARAMS    deip;

    ZeroMemory(&pcp, sizeof(pcp));

    pcp.ClassInstallHeader.cbSize = sizeof(SP_CLASSINSTALL_HEADER);
    pcp.ClassInstallHeader.InstallFunction = DIF_PROPERTYCHANGE;
    pcp.StateChange = eventFlag;
    pcp.Scope = DICS_FLAG_GLOBAL;
    pcp.HwProfile = 0;

    // Now we set the structure as the device info data's
    // class install params

    if (! SetupDiSetClassInstallParams(hdi, &deid,
                                       (PSP_CLASSINSTALL_HEADER)(&pcp),
                                       sizeof(pcp)))
    {
        LOG_ERROR("NotifyAdapterPropertyChange failed at SetupDiSetClassInstallParams");
        goto error;
    }

    // Now we need to set the "we have a class install params" flag
    // in the device install params

    // initialize out parameter and set its cbSize field

    ZeroMemory(&deip, sizeof(SP_DEVINSTALL_PARAMS));
    deip.cbSize = sizeof(SP_DEVINSTALL_PARAMS);

    // get the header

    if (! SetupDiGetDeviceInstallParams(hdi, &deid, &deip))
    {
        LOG_ERROR("NotifyAdapterPropertyChange failed at SetupDiGetDeviceInstallParams");
        goto error;
    }

    deip.Flags |= DI_CLASSINSTALLPARAMS;

    if (! SetupDiSetDeviceInstallParams(hdi, &deid, &deip))
    {
        LOG_ERROR("NotifyAdapterPropertyChange failed at SetupDiGetDeviceInstallParams");
        goto error;
    }

    // Notify the driver that the state has changed

    LOG_INFO("NotifyAdapterPropertyChange, About to call SetupDiCallClassInstaller");
    if (! SetupDiCallClassInstaller(DIF_PROPERTYCHANGE, hdi, &deid))
    {
        LOG_ERROR("NotifyAdapterPropertyChange failed at SetupDiCallClassInstaller");
        goto error;
    }
    LOG_INFO("NotifyAdapterPropertyChange, Returned from call to SetupDiCallClassInstaller");

    // Set the properties change flag in the device info to
    // let anyone who cares know that their ui might need
    // updating to reflect any change in the device's status
    // We can't let any failures here stop us so we ignore
    // return values

    SetupDiGetDeviceInstallParams(hdi, &deid, &deip);

    deip.Flags |= DI_PROPERTIES_CHANGE;
    SetupDiSetDeviceInstallParams(hdi, &deid, &deip);

    SetupDiDestroyDeviceInfoList (hdi);

    LOG_INFO("NotifyAdapterPropertyChange succeeded here");

error:

    if (hdi != NULL)
        SetupDiDestroyDeviceInfoList (hdi);
}

/*
 * Function: GetDeviceNameFromGUID
 * Description: Given a GUID, return the driver name.
 * Author: shouse 7.17.00
 */
void WINAPI GetDriverNameFromGUID (const GUID & AdapterGuid, OUT WCHAR * driver_name, DWORD size) {
    TCHAR tbuf[CVY_STR_SIZE];
    HKEY key = NULL;
    DWORD type;
    
    if (!(key = RegOpenWlbsSetting(AdapterGuid, true))) return;

    _stprintf (tbuf, _TEXT("%ls"), CVY_NAME_CLUSTER_NIC);

    RegQueryValueEx(key, tbuf, 0L, &type, (LPBYTE)driver_name, &size);
        
    RegCloseKey(key);
}

//+----------------------------------------------------------------------------
//
// Function:  RegReadAdapterIp
//
// Description: Read the adapter IP settings 
//
// Arguments: const GUID& AdapterGuid - 
//            OUT DWORD& dwClusterIp - 
//            OUT DWORD& dwDedicatedIp - 
//
// Returns:   bool - 
//
// History:   fengsun Created Header    3/9/00
//
//+----------------------------------------------------------------------------
bool WINAPI RegReadAdapterIp(const GUID& AdapterGuid,   
        OUT DWORD& dwClusterIp, OUT DWORD& dwDedicatedIp)
{
    HKEY            key;
    LONG            status;
    DWORD           size;

    key = RegOpenWlbsSetting(AdapterGuid, true);

    if (key == NULL)
    {
        return false;
    }

    bool local = false;

    TCHAR nic_name[CVY_STR_SIZE];      // Virtual NIC name
    size = sizeof (nic_name);
    status = RegQueryValueEx (key, CVY_NAME_VIRTUAL_NIC, 0L, NULL,
                              (LPBYTE) nic_name, & size);

    if (status == ERROR_SUCCESS)
    {
        TCHAR szIpAddress[CVY_STR_SIZE];
        size = sizeof (TCHAR) * CVY_STR_SIZE;
        status = RegQueryValueEx (key, CVY_NAME_CL_IP_ADDR, 0L, NULL,
                                      (LPBYTE) szIpAddress, & size);

        if (status == ERROR_SUCCESS)
        {
            dwClusterIp  = IpAddressFromAbcdWsz (szIpAddress);
            local = true;
        }

        status = RegQueryValueEx (key, CVY_NAME_DED_IP_ADDR, 0L, NULL,
                                 (LPBYTE) szIpAddress, & size);

        if (status == ERROR_SUCCESS)
            dwDedicatedIp = IpAddressFromAbcdWsz (szIpAddress);
    }
    RegCloseKey (key);

    return local;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\api\param.h ===
//+----------------------------------------------------------------------------
//
// File:         param.h
//
// Module:       WLBS API
//
// Description: Function here are used by API internally and by notifier object 
//              externally
//
// Copyright (C)  Microsoft Corporation.  All rights reserved.
//
// Author:       fengsun Created    3/9/00
//
//+----------------------------------------------------------------------------

#pragma once

#include "wlbsconfig.h"

#define WLBS_FIELD_LOW 0
#define WLBS_FIELD_HIGH 255
#define WLBS_IP_FIELD_ZERO_LOW 1
#define WLBS_IP_FIELD_ZERO_HIGH 223


bool WINAPI ParamReadReg
(
    const GUID& AdapterGuid,    /* IN  - Adapter GUID */
    PWLBS_REG_PARAMS reg_data,   /* OUT - Registry parameters */
    bool fUpgradeFromWin2k = false,
    bool *pfPortRulesInBinaryForm = NULL
);

bool WINAPI ParamValidate
(
	PWLBS_REG_PARAMS paramp  /* IN OUT - Registry parameters */
);

bool WINAPI ParamWriteReg
(
    const GUID& AdapterGuid,    /* IN  - Adapter GUID */
    PWLBS_REG_PARAMS reg_data   /* IN - Registry parameters */
);

bool WINAPI ParamDeleteReg
(
    const GUID& AdapterGuid,    /* IN  - Adapter GUID */
    bool  fDeleteObsoleteEntries = false
);

DWORD WINAPI ParamSetDefaults(PWLBS_REG_PARAMS    reg_data);

bool WINAPI RegChangeNetworkAddress(const GUID& AdapterGuid, const WCHAR* mac_address, BOOL fRemove);

void WINAPI NotifyAdapterAddressChange (const WCHAR * driver_name);
void WINAPI GetDriverNameFromGUID (const GUID & AdapterGuid, OUT TCHAR * driver_name, DWORD size);
void WINAPI NotifyAdapterPropertyChange (const WCHAR * driver_name, DWORD eventFlag);

DWORD WINAPI NotifyDriverConfigChanges(HANDLE hDeviceWlbs, const GUID& AdapterGuid);

bool WINAPI RegReadAdapterIp(const GUID& AdapterGuid,   
        OUT DWORD& dwClusterIp, OUT DWORD& dwDedicatedIp);

HKEY WINAPI RegOpenWlbsSetting(const GUID& AdapterGuid, bool fReadOnly = false);

DWORD WINAPI IpAddressFromAbcdWsz(IN const WCHAR*  wszIpAddress);
VOID WINAPI AbcdWszFromIpAddress(IN  DWORD  IpAddress, OUT WCHAR*  wszIpAddress);

/* Copied largely from net/config/netcfg/tcpipcfg/ and defined in utils.cpp */
extern BOOL IsValidIPAddressSubnetMaskPair(PCWSTR szIp, PCWSTR szSubnet);
extern BOOL IsContiguousSubnetMask(PCWSTR pszSubnet);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\api\wrapper.cpp ===
#include "precomp.h"

#include <debug.h>
#include "cluster.h"
#include "control.h"
#include "param.h"

CWlbsControl g_WlbsControl;



DWORD WINAPI WlbsInit
(
    PTCHAR          product,
    DWORD           version,
    PVOID           reserved
)
{
    return g_WlbsControl.Initialize();
}


DWORD WINAPI WlbsQuery
(
    DWORD            cluster,
    DWORD            host,
    PWLBS_RESPONSE   response,
    PDWORD           num_hosts,
    PDWORD           host_map,
    PVOID            reserved
)
{
    return g_WlbsControl.WlbsQuery(cluster, host, response,num_hosts, host_map,reserved);
}

DWORD WINAPI WlbsSuspend
(
    DWORD            cluster,
    DWORD            host,
    PWLBS_RESPONSE   response,
    PDWORD           num_hosts
)
{
    return g_WlbsControl.WlbsSuspend(cluster, host, response, num_hosts);
}

DWORD WINAPI WlbsResume
(
    DWORD            cluster,
    DWORD            host,
    PWLBS_RESPONSE   response,
    PDWORD           num_hosts
)
{
    return g_WlbsControl.WlbsResume(cluster, host, response, num_hosts);
}

DWORD WINAPI WlbsStart
(
    DWORD            cluster,
    DWORD            host,
    PWLBS_RESPONSE   response,
    PDWORD           num_hosts
)
{
    return g_WlbsControl.WlbsStart(cluster, host, response, num_hosts);
}

DWORD WINAPI WlbsStop
(
    DWORD            cluster,
    DWORD            host,
    PWLBS_RESPONSE   response,
    PDWORD           num_hosts
)
{
    return g_WlbsControl.WlbsStop(cluster, host, response, num_hosts);
}

DWORD WINAPI WlbsDrainStop
(
    DWORD            cluster,
    DWORD            host,
    PWLBS_RESPONSE   response,
    PDWORD           num_hosts
)
{
    return g_WlbsControl.WlbsDrainStop(cluster, host, response, num_hosts);
}

DWORD WINAPI WlbsEnable
(
    DWORD            cluster,
    DWORD            host,
    PWLBS_RESPONSE   response,
    PDWORD           num_hosts,
    DWORD            vip,
    DWORD            port
)
{
    return g_WlbsControl.WlbsEnable(cluster, host, response, num_hosts, vip, port);
}

DWORD WINAPI WlbsDisable
(
    DWORD            cluster,
    DWORD            host,
    PWLBS_RESPONSE   response,
    PDWORD           num_hosts,
    DWORD            vip,
    DWORD            port
)
{
    return g_WlbsControl.WlbsDisable(cluster, host, response, num_hosts, vip, port);
}

DWORD WINAPI WlbsDrain
(
    DWORD            cluster,
    DWORD            host,
    PWLBS_RESPONSE   response,
    PDWORD           num_hosts,
    DWORD            vip,
    DWORD            port
)
{
    return g_WlbsControl.WlbsDrain(cluster, host, response, num_hosts, vip, port);
}

extern "C" DWORD WINAPI WlbsAdjust
(
    DWORD            cluster,
    DWORD            host,
    PWLBS_RESPONSE   response,
    PDWORD           num_hosts,
    DWORD            port,
    DWORD            value
)
{
    return g_WlbsControl.WlbsAdjust(cluster, host, response, num_hosts, port, value);
}

DWORD WINAPI WlbsResolve
(
    const WCHAR*           address
)
{
    struct hostent *  host;
    char   buf[256];

    if (address == NULL)
        return 0;

    unsigned long addr = IpAddressFromAbcdWsz (address);

    if (addr != INADDR_NONE)
    {
        return addr;
    }

    if (!WideCharToMultiByte(CP_ACP, 0, address, -1, buf, sizeof(buf), NULL, NULL))
        return 0;

    host = gethostbyname (buf);

    if (host == NULL)
        return 0;

    return((struct in_addr *) (host -> h_addr)) -> s_addr;

} /* end WlbsResolve */

#define MAXIPSTRLEN WLBS_MAX_CL_IP_ADDR + 1

BOOL WINAPI WlbsAddressToString
(
    DWORD           address,
    PTCHAR          buf,
    PDWORD          lenp
)
{
    PCHAR temp;
    DWORD len;

    if ( lenp == NULL )
        return FALSE;

    if (*lenp < MAXIPSTRLEN)
        return FALSE;
        
    AbcdWszFromIpAddress(address, buf);
    *lenp=lstrlen(buf);
    
    return TRUE;

} /* end WlbsAddressToString */


BOOL WINAPI WlbsAddressToName
(
    DWORD           address,
    PTCHAR          buf,
    PDWORD          lenp
)
{
    struct hostent * name;
    DWORD len;

    if ( lenp == NULL )
        return FALSE;

    name = gethostbyaddr ((char *) & address, sizeof (DWORD), AF_INET);

    if (name == NULL)
    {
        *lenp = 0;
        return FALSE;
    }

    len = strlen (name -> h_name) + 1;

    /* This is to prevent stprintf from breaking */
    if (*lenp > 0)
    {
        name -> h_name [*lenp - 1] = 0;
#ifdef UNICODE
        wsprintf (buf, L"%S", name -> h_name);
#else
        sprintf (buf, "%s", name -> h_name);
#endif
    }

    if (len > *lenp)
    {
        *lenp = len;
        return FALSE;
    }

    *lenp = len;
    return TRUE;

} /* end WlbsAddressToName */


VOID WINAPI WlbsPortSet
(
    DWORD           cluster,
    WORD            port
)
{
    g_WlbsControl.WlbsPortSet(cluster, port);
}

VOID WINAPI WlbsPasswordSet
(
    DWORD           cluster,
    PTCHAR          password
)
{
    g_WlbsControl.WlbsPasswordSet(cluster, password);
}

VOID WINAPI WlbsCodeSet
(
    DWORD           cluster,
    DWORD           passw
)
{
    g_WlbsControl.WlbsCodeSet(cluster, passw);
}

VOID WINAPI WlbsDestinationSet
(
    DWORD           cluster,
    DWORD           dest
)
{
    g_WlbsControl.WlbsDestinationSet(cluster, dest);
}

VOID WINAPI WlbsTimeoutSet
(
    DWORD           cluster,
    DWORD           milliseconds
)
{
    g_WlbsControl.WlbsTimeoutSet(cluster, milliseconds);
}




//+----------------------------------------------------------------------------
//
// Function:  WlbsReadReg
//
// Description:  
//
// Arguments: WORD           cluster - 
//            PWLBS_REG_PARAMS reg_data
//
// Returns:   DWORD WINAPI - 
//
// History:   fengsun Created Header    3/9/00
//
//+----------------------------------------------------------------------------
DWORD WINAPI WlbsReadReg(
    DWORD           cluster,
    PWLBS_REG_PARAMS reg_data
)
{
    CWlbsCluster* pCluster = g_WlbsControl.GetClusterFromIpOrIndex(cluster);

    if(pCluster == NULL)
    {
        return WLBS_NOT_FOUND;
    }

    return pCluster->ReadConfig(reg_data);
}



//+----------------------------------------------------------------------------
//
// Function:  WlbsWriteReg
//
// Description:  
//
// Arguments: WORD           cluster - 
//            PWLBS_REG_PARAMS reg_data
//
// Returns:   DWORD WINAPI - 
//
// History:   fengsun Created Header    3/9/00
//
//+----------------------------------------------------------------------------
DWORD WINAPI WlbsWriteReg(
    DWORD           cluster,
    const PWLBS_REG_PARAMS reg_data
)
{
    CWlbsCluster* pCluster = g_WlbsControl.GetClusterFromIpOrIndex(cluster);

    if(pCluster == NULL)
    {
        return WLBS_NOT_FOUND;
    }

    return pCluster->WriteConfig(reg_data);
}



//+----------------------------------------------------------------------------
//
// Function:  WlbsCommitChanges
//
// Description:  
//
// Arguments: DWORD cluster - 
//
// Returns:   DWORD WINAPI - 
//
// History:   fengsun Created Header    3/9/00
//
//+----------------------------------------------------------------------------
DWORD WINAPI WlbsCommitChanges(DWORD cluster)
{
    CWlbsCluster* pCluster = g_WlbsControl.GetClusterFromIpOrIndex(cluster);

    if(pCluster == NULL)
    {
        return WLBS_NOT_FOUND;
    }

    return pCluster->CommitChanges(&g_WlbsControl);
}

DWORD WINAPI WlbsSetDefaults
(
    PWLBS_REG_PARAMS    reg_data
)
{
    return ParamSetDefaults(reg_data);
}


BOOL WINAPI WlbsFormatMessage
(
    DWORD,            // error,
    WLBS_COMMAND,     // command,
    BOOL,             // cluster
    PTCHAR          messagep,
    PDWORD          lenp
)
{
    DWORD           len;
    PTSTR           error_str = _TEXT("Not yet implemented");

#if 0
    va_list         arglist;
    DWORD           error;


    va_start(arglist, id);


    if (FormatMessage (FORMAT_MESSAGE_FROM_HMODULE, NULL, id, 0,
                       message, CVY_BUF_SIZE, & arglist) == 0)
    {
        error = GetLastError();

        wprintf(L"Could not print error message due to: ");

        if (FormatMessage (FORMAT_MESSAGE_FROM_SYSTEM, NULL, error, 0,
                           message, CVY_BUF_SIZE, NULL) == 0)
        {
            wprintf(L"%d\n", error);
        }
        else
            wprintf(L"\n %ls\n", message);
    }
    else
    {
        wprintf(L"%ls", message);
    }
#endif



    len = _tcslen(error_str) + 1;

    /* This is to prevent stprintf from breaking */

    if (lenp == NULL)
        return FALSE;

    if (*lenp == 0)
    {
        *lenp = len;
        return FALSE;
    }

    _tcsncpy(messagep, error_str, *lenp);

    if (len > *lenp)
    {
        *lenp = len;
        return FALSE;
    }

    *lenp = len;
    return TRUE;

} /* end WlbsFormatMessage */

DWORD WINAPI WlbsEnumClusters(OUT DWORD* pdwAddresses, OUT DWORD* pdwNum)
{
    return g_WlbsControl.EnumClusters(pdwAddresses, pdwNum);
}



//+----------------------------------------------------------------------------
//
// Function:  WlbsGetAdapterGuid
//
// Description:  
//
// Arguments: IN DWORD cluster - 
//            OUT GUID* pAdapterGuid - 
//
// Returns:   DWORD WINAPI - 
//
// History:   fengsun Created Header    3/10/00
//
//+----------------------------------------------------------------------------
DWORD WINAPI WlbsGetAdapterGuid(IN DWORD cluster, OUT GUID* pAdapterGuid)
{
    ASSERT(pAdapterGuid);

    if (pAdapterGuid == NULL)
    {
        return WLBS_BAD_PARAMS;
    }

    CWlbsCluster* pCluster = g_WlbsControl.GetClusterFromIpOrIndex(cluster);

    if(pCluster == NULL)
    {
        return WLBS_NOT_FOUND;
    }

    *pAdapterGuid = pCluster->GetAdapterGuid();

    return WLBS_OK;
}



//+----------------------------------------------------------------------------
//
// Function:  WlbsNotifyConfigChange
//
// Description:  
//
// Arguments: DWORD cluster - 
//
// Returns:   DWORD WINAPI - 
//
// History: fengsun  Created Header    7/3/00
//
//+----------------------------------------------------------------------------
DWORD WINAPI WlbsNotifyConfigChange(DWORD cluster)
{
    CWlbsCluster* pCluster = g_WlbsControl.GetClusterFromIpOrIndex(cluster);

    if(pCluster == NULL)
    {
        return WLBS_NOT_FOUND;
    }

    DWORD dwStatus = NotifyDriverConfigChanges(g_WlbsControl.GetDriverHandle(), pCluster->GetAdapterGuid());

    return dwStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\api\wlbsapi.c ===
/*
  NETWORK LOAD BALANCING - CONTROL API - TEST UTILITY


  Copyright (C), 1999 by Microsoft Corporation

  PROPRIETARY TRADE SECRET INFORMATION OF MICROSOFT CORPORATION

  The information contained in this file is not to be disclosed or copied in any
  form or distributed to a third party without written permission from Microsoft
  Corporation.

  THE SOFTWARE IS PROVIDED TO YOU "AS-IS" AND WITHOUT WARRANTY OF ANY KIND,
  EXPRESSED, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
  MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.


     $Archive::                                                         $
    $Revision::                                                         $
      $Author::                                                         $
        $Date::                                                         $
     $Modtime::                                                         $
  $Nokeywords::                                                         $
*/

#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <conio.h>
#include <string.h>
#include <winsock.h>
#include <tchar.h>

#include "wlbsctrl.h"
#include "wlbsconfig.h"

#define stricmp strcmp


/* TYPES */


typedef enum
{
    query,
    suspend,
    resume,
    start,
    stop,
    drainstop,
    enable,
    disable,
    drain
}
WLBS_CMD;


/* GLOBALS */

#define BUF_SIZE 80
static CHAR            buf [BUF_SIZE];
static CHAR            buf2 [BUF_SIZE];
static TCHAR           tbuf [BUF_SIZE];
static TCHAR           tbuf2 [BUF_SIZE];
static WLBS_RESPONSE    resp [WLBS_MAX_HOSTS];


/* PROCEDURES */



void generate_port_rules ( PWLBS_PORT_RULE rules, DWORD num_rules, DWORD range );
void delete_all_rules ( PWLBS_REG_PARAMS reg_data );
void test_commit ( PWLBS_REG_PARAMS reg_data, BOOL flag1, BOOL flag2 );
DWORD testnewapi (void);

INT __cdecl _tmain
(
    INT             argc,
    PTCHAR          __targv []
)
{
    DWORD           ret;
    DWORD           status;
    INT             arg_index;
    WLBS_CMD        cmd;
    DWORD           port;
    DWORD           cluster;
    DWORD           host;
    PCHAR           hp;
    PTCHAR          thp;
    DWORD           i;
    DWORD           hosts;
    DWORD           host_map;
    DWORD           buf_size = BUF_SIZE;


    printf ("WLBS Control API V1.0 (c) 1999 by Microsoft Corporation\n");

    /* initialize convoy control routines */

    ret = WlbsInit (_TEXT(WLBS_PRODUCT_NAME), WLBS_API_VER, NULL);

    switch (ret)
    {
    case WLBS_PRESENT:
        printf ("Can execute remote and local commands.\n");
        break;

    case WLBS_REMOTE_ONLY:
        printf ("Can execute local commands.\n");
        break;

    case WLBS_LOCAL_ONLY:
        printf ("Can execute remote commands.\n");
        break;

    default:
        printf ("Error initializing API.\n");
        return 2;
    }


#if 0

    {
        WLBS_REG_PARAMS     params;
        DWORD               status;

        if ((status = WlbsLocalReadReg(& params)) != WLBS_OK)
        {
            printf("WlbsLocalReadReg error %d\n", status);
            return 1;
        }

        printf("WlbsLocalReadReg success\n");

        if (argc > 1)
            _tcsncpy(params.cl_ip_addr, _TEXT("172.31.240.176"), WLBS_MAX_CL_IP_ADDR);
        else
            _tcsncpy(params.cl_ip_addr, _TEXT("172.31.240.175"), WLBS_MAX_CL_IP_ADDR);

        if ((status = WlbsLocalWriteReg(& params)) != WLBS_OK)
        {
            printf("WlbsLocalWriteReg error %d\n", status);
            return 1;
        }

        printf("WlbsLocalWriteReg success\n");

        if ((status = WlbsLocalCommitChanges()) != WLBS_OK)
        {
            printf("WlbsLocalCommitChanges error %d\n", status);
            return 1;
        }

        printf("WlbsLocalCommitChanges success\n");

        return 1;
    }

#endif


    arg_index = 1;

    if (argc < 2)
        goto usage;

    /* parse command line arguments */

    if (_tcsicmp (__targv[arg_index], _TEXT("testnewapi")) == 0)
    {
        testnewapi();
        return 1;
    }
    if (_tcsicmp (__targv [arg_index], _TEXT("suspend")) == 0)
    {
        cmd = suspend;
        arg_index ++;
    }
    else if (_tcsicmp (__targv [arg_index], _TEXT("resume")) == 0)
    {
        cmd = resume;
        arg_index ++;
    }
    else if (_tcsicmp (__targv [arg_index], _TEXT("start")) == 0)
    {
        cmd = start;
        arg_index ++;
    }
    else if (_tcsicmp (__targv [arg_index], _TEXT("stop")) == 0)
    {
        cmd = stop;
        arg_index ++;
    }
    else if (_tcsicmp (__targv [arg_index], _TEXT("drainstop")) == 0)
    {
        cmd = drainstop;
        arg_index ++;
    }
    else if (_tcsicmp (__targv [arg_index], _TEXT("query")) == 0)
    {
        cmd = query;
        arg_index ++;
    }
    else if (_tcsicmp (__targv [arg_index], _TEXT("enable")) == 0)
    {
        arg_index ++;

        if (argc < 3)
            goto usage;

        if (_tcsicmp (__targv [arg_index], _TEXT("all")) == 0)
            port = WLBS_ALL_PORTS;
        else
            port = _ttoi (__targv [arg_index]);

        if (port == 0 && __targv [arg_index][0] != _TEXT('0'))
            goto usage;

        cmd = enable;
        arg_index ++;
    }
    else if (_tcsicmp (__targv [arg_index], _TEXT("disable")) == 0)
    {
        arg_index ++;

        if (argc < 3)
            goto usage;

        if (_tcsicmp (__targv [arg_index], _TEXT("all")) == 0)
            port = WLBS_ALL_PORTS;
        else
            port = _ttoi (__targv [arg_index]);

        if (port == 0 && __targv [arg_index][0] != _TEXT('0'))
            goto usage;

        cmd = disable;
        arg_index ++;
    }
    else if (_tcsicmp (__targv [arg_index], _TEXT("drain")) == 0)
    {
        arg_index ++;

        if (argc < 3)
            goto usage;

        if (_tcsicmp (__targv [arg_index], _TEXT("all")) == 0)
            port = WLBS_ALL_PORTS;
        else
            port = _ttoi (__targv [arg_index]);

        if (port == 0 && __targv [arg_index][0] != _TEXT('0'))
            goto usage;

        cmd = drain;
        arg_index ++;
    }
    else
        goto usage;

    cluster = WLBS_LOCAL_CLUSTER;
    host    = WLBS_LOCAL_HOST;

    /* parse remote command arguments */

    if (arg_index < argc)
    {
        thp = _tcschr (__targv [arg_index], _TEXT(':'));

        /* cluster-wide operation */

        if (thp == NULL)
        {
            cluster = WlbsResolve (__targv [arg_index]);

            if (cluster == 0)
            {
                _tprintf (_TEXT("Bad cluster %s\n"), __targv [arg_index]);
                return 1;
            }

            host = WLBS_ALL_HOSTS;
        }
        else
        {
            * thp = 0;
            thp ++;

            cluster = WlbsResolve (__targv [arg_index]);

            if (cluster == 0)
            {
                _tprintf (_TEXT("Bad cluster %s\n"), __targv [arg_index]);
                return 1;
            }

            if (_tcslen (thp) <= 2 && thp [0] >= _TEXT('0') && thp [0] <= _TEXT('9')
                && ((thp [1] >= _TEXT('0') && thp [1] <= _TEXT('9')) || thp [1] == 0))
            {
                host = _ttoi (thp);
            }
            else
            {
                host = WlbsResolve (thp);

                if (host == 0)
                {
                    _tprintf (_TEXT("Bad host %s\n"), thp);
                    return 1;
                }
            }
        }

        arg_index ++;

        /* parse remote control parameters */

        while (arg_index < argc)
        {
            if (__targv [arg_index] [0] == _TEXT('/') || __targv [arg_index] [0] == _TEXT('-'))
            {
                if (_tcsicmp (__targv [arg_index] + 1, _TEXT("PASSW")) == 0)
                {
                    arg_index ++;

                    if (arg_index >= argc || __targv [arg_index] [0] == _TEXT('/') ||
                        __targv [arg_index] [0] == _TEXT('-'))
                    {
                        printf ("Password: ");

                        for (i = 0; i < BUF_SIZE; i ++)
                        {
                            buf [i] = (CHAR) _getch ();

                            if (buf [i] == 13)
                            {
                                buf [i] = 0;
                                break;
                            }
                        }

                        printf ("\n");

                        if (i == 0)
                            WlbsPasswordSet (cluster, NULL);
                        else
                        {
#ifdef UNICODE
                            _stprintf (tbuf, _TEXT("%S"), buf);
#else
                            _stprintf (tbuf, _TEXT("%s"), buf);
#endif
                            WlbsPasswordSet (cluster, tbuf);
                        }
                    }
                    else
                    {
                        WlbsPasswordSet (cluster, __targv [arg_index]);
                        arg_index ++;
                    }

                }
                else if (_tcsicmp (__targv [arg_index] + 1, _TEXT("PORT")) == 0)
                {
                    arg_index ++;

                    if (arg_index >= argc || __targv [arg_index] [0] == _TEXT('/') ||
                        __targv [arg_index] [0] == _TEXT('-'))
                        goto usage;

                    WlbsPortSet (cluster, (USHORT) _ttoi (__targv [arg_index]));

                    if (port == 0)
                        goto usage;

                    arg_index ++;
                }
                else if (_tcsicmp (__targv [arg_index] + 1, _TEXT("DEST")) == 0)
                {
                    arg_index ++;

                    if (arg_index >= argc || __targv [arg_index] [0] == _TEXT('/') ||
                        __targv [arg_index] [0] == _TEXT('-'))
                        goto usage;

                    WlbsDestinationSet (cluster, WlbsResolve (__targv [arg_index]));
                    arg_index ++;
                }
                else if (_tcsicmp (__targv [arg_index] + 1, _TEXT("TIMEOUT")) == 0)
                {
                    arg_index ++;

                    if (arg_index >= argc || __targv [arg_index] [0] == _TEXT('/') ||
                        __targv [arg_index] [0] == _TEXT('-'))
                        goto usage;

                    WlbsTimeoutSet (cluster, _ttoi (__targv [arg_index]));
                    arg_index ++;
                }
                else
                    goto usage;
            }
            else
                goto usage;
        }
    }

    /* execute command */

    hosts = WLBS_MAX_HOSTS;

    switch (cmd)
    {

    case query:

        status = WlbsQuery (cluster, host, resp, &hosts, &host_map, NULL);

        switch (status)
        {
        case WLBS_INIT_ERROR:

            printf ("WLBS Control API not initialized.\n");
            return 2;

        case WLBS_LOCAL_ONLY:

            printf ("Can only execute local commands.\n");
            return 2;

        case WLBS_REMOTE_ONLY:

            printf ("Can only execute remote commands.\n");
            return 2;

        case WLBS_BAD_PASSW:

            printf ("Bad password specified.\n");
            return 2;

        case WLBS_TIMEOUT:

            printf ("Timed out awaiting response.\n");
            return 2;

        case WLBS_IO_ERROR:

            printf ("Error connecting to WLBS device.\n");
            return 2;

        case WLBS_STOPPED:

            if (host == WLBS_ALL_HOSTS)
                printf ("All cluster hosts are stopped.\n");
            else
                printf ("Cluster host %d is stopped.\n", resp [0] . id);

            break;

        case WLBS_SUSPENDED:

            if (host == WLBS_ALL_HOSTS)
                printf ("All cluster hosts are suspended.\n");
            else
                printf ("Cluster host %d is suspended.\n", resp [0] . id);

            break;

        case WLBS_CONVERGING:

            if (host == WLBS_ALL_HOSTS)
                printf ("Cluster is converging.\n");
            else
                printf ("Cluster host %d is converging.\n", resp [0] . id);

            break;

        case WLBS_DRAINING:

            if (host == WLBS_ALL_HOSTS)
                printf ("Cluster is draining.\n");
            else
                printf ("Cluster host %d is draining.\n", resp [0] . id);

            break;

        case WLBS_CONVERGED:

            printf ("Cluster host %d is converged.\n", resp [0] . id);
            break;

        case WLBS_DEFAULT:

            printf ("Cluster host %d is converged as DEFAULT.\n", resp [0] . id);
            break;

        default:

            if (status >= WSABASEERR)
            {
                printf ("WinSock error %d.\n", status);
                return 2;
            }

            printf ("There are %d active hosts in the cluster.\n", status);
        }

        if (host == WLBS_ALL_HOSTS)
        {
            printf ("Received responses from %d hosts:\n", hosts);

            for (i = 0; i < hosts && i < WLBS_MAX_HOSTS; i ++)
            {
                buf_size = BUF_SIZE;
                WlbsAddressToString (resp [i] . address, tbuf, & buf_size);
                buf_size = BUF_SIZE;
                WlbsAddressToName (resp [i] . address, tbuf2, & buf_size);
                _tprintf (_TEXT("Host %d [%s - %25s]: "), resp [i] . id, tbuf, tbuf2);

                switch (resp [i] . status)
                {
                case WLBS_STOPPED:
                    printf ("stopped\n");
                    break;

                case WLBS_CONVERGING:
                    printf ("converging\n");
                    break;

                case WLBS_DRAINING:
                    printf ("draining\n");
                    break;

                case WLBS_CONVERGED:
                    printf ("converged\n");
                    break;

                case WLBS_SUSPENDED:
                    printf ("suspended\n");
                    break;

                case WLBS_DEFAULT:
                    printf ("converged as DEFAULT\n");
                    break;
                }
            }

        }
        else
        {
            BOOL       first = TRUE;

            printf ("The following hosts are part of the cluster:\n");

            for (i = 0; i < 32; i ++)
            {
                if (host_map & (1 << i))
                {
                    if (! first)
                        printf (", ");
                    else
                        first = FALSE;

                    printf ("%d", i + 1);
                }
            }

            printf ("\n");
        }


        break;

    case suspend:

        status = WlbsSuspend (cluster, host, resp, & hosts);

        switch (status)
        {
        case WLBS_INIT_ERROR:

            printf ("WLBS Control API not initialized.\n");
            return 2;

        case WLBS_LOCAL_ONLY:

            printf ("Can only execute local commands.\n");
            return 2;

        case WLBS_REMOTE_ONLY:

            printf ("Can only execute remote commands.\n");
            return 2;

        case WLBS_BAD_PASSW:

            printf ("Bad password specified.\n");
            return 2;

        case WLBS_TIMEOUT:

            printf ("Timed out awaiting response.\n");
            return 2;

        case WLBS_IO_ERROR:

            printf ("Error connecting to WLBS device.\n");
            return 2;

        case WLBS_OK:

            if (host == WLBS_ALL_HOSTS)
                printf ("All cluster hosts suspended.\n");
            else
                printf ("Cluster mode control suspended.\n");

            break;

        case WLBS_ALREADY:

            printf ("Cluster mode control already suspended.\n");
            break;

        case WLBS_DRAIN_STOP:

            printf ("Cluster mode control suspended; draining preempted.\n");
            break;

        case WLBS_STOPPED:

            printf ("Cluster mode stopped and control suspended.\n");
            break;

        default:

            if (status >= WSABASEERR)
            {
                printf ("WinSock error %d.\n", status);
                return 2;
            }
        }

        if (host == WLBS_ALL_HOSTS)
        {
            printf ("Received responses from %d hosts:\n", hosts);

            for (i = 0; i < hosts && i < WLBS_MAX_HOSTS; i ++)
            {
                buf_size = BUF_SIZE;
                WlbsAddressToString (resp [i] . address, tbuf, & buf_size);
                buf_size = BUF_SIZE;
                WlbsAddressToName (resp [i] . address, tbuf2, & buf_size);
                _tprintf (_TEXT("Host %d [%s - %25s]: "), resp [i] . id, tbuf, tbuf2);

                switch (resp [i] . status)
                {
                case WLBS_OK:
                    printf ("suspended\n");
                    break;

                case WLBS_ALREADY:
                    printf ("already suspended\n");
                    break;

                case WLBS_DRAIN_STOP:
                    printf ("suspended from draining\n");
                    break;

                case WLBS_STOPPED:
                    printf ("stopped and suspended\n");
                    break;
                }
            }

        }

        break;

    case resume:

        status = WlbsResume (cluster, host, resp, & hosts);

        switch (status)
        {
        case WLBS_INIT_ERROR:

            printf ("WLBS Control API not initialized.\n");
            return 2;

        case WLBS_LOCAL_ONLY:

            printf ("Can only execute local commands.\n");
            return 2;

        case WLBS_REMOTE_ONLY:

            printf ("Can only execute remote commands.\n");
            return 2;

        case WLBS_BAD_PASSW:

            printf ("Bad password specified.\n");
            return 2;

        case WLBS_TIMEOUT:

            printf ("Timed out awaiting response.\n");
            return 2;

        case WLBS_IO_ERROR:

            printf ("Error connecting to WLBS device.\n");
            return 2;

        case WLBS_OK:

            if (host == WLBS_ALL_HOSTS)
                printf ("All cluster hosts resumed.\n");
            else
                printf ("Cluster mode control resumed.\n");

            break;

        case WLBS_ALREADY:

            printf ("Cluster mode control already resumed.\n");
            break;

        default:

            if (status >= WSABASEERR)
            {
                printf ("WinSock error %d.\n", status);
                return 2;
            }
        }

        if (host == WLBS_ALL_HOSTS)
        {
            printf ("Received responses from %d hosts:\n", hosts);

            for (i = 0; i < hosts && i < WLBS_MAX_HOSTS; i ++)
            {
                buf_size = BUF_SIZE;
                WlbsAddressToString (resp [i] . address, tbuf, & buf_size);
                buf_size = BUF_SIZE;
                WlbsAddressToName (resp [i] . address, tbuf2, & buf_size);
                _tprintf (_TEXT("Host %d [%s - %25s]: "), resp [i] . id, tbuf, tbuf2);

                switch (resp [i] . status)
                {
                case WLBS_OK:
                    printf ("resumed\n");
                    break;

                case WLBS_ALREADY:
                    printf ("already resumed\n");
                    break;
                }
            }

        }

        break;

    case start:

        status = WlbsStart (cluster, host, resp, & hosts);

        switch (status)
        {
        case WLBS_INIT_ERROR:

            printf ("WLBS Control API not initialized.\n");
            return 2;

        case WLBS_LOCAL_ONLY:

            printf ("Can only execute local commands.\n");
            return 2;

        case WLBS_REMOTE_ONLY:

            printf ("Can only execute remote commands.\n");
            return 2;

        case WLBS_BAD_PASSW:

            printf ("Bad password specified.\n");
            return 2;

        case WLBS_TIMEOUT:

            printf ("Timed out awaiting response.\n");
            return 2;

        case WLBS_IO_ERROR:

            printf ("Error connecting to WLBS device.\n");
            return 2;

        case WLBS_OK:

            if (host == WLBS_ALL_HOSTS)
                printf ("All cluster hosts started.\n");
            else
                printf ("Cluster mode started.\n");

            break;

        case WLBS_BAD_PARAMS:

            if (host == WLBS_ALL_HOSTS)
                printf ("Some host(s) could not start cluster mode due to parameter errors.\n");
            else
                printf ("Could not start cluster mode due to parameter errors.\n");

            break;

        case WLBS_ALREADY:

            printf ("Cluster mode already started.\n");
            break;

        case WLBS_SUSPENDED:

            if (host == WLBS_ALL_HOSTS)
                printf ("All cluster hosts suspended.\n");
            else
                printf ("Cluster mode control suspended.\n");

            break;

        case WLBS_DRAIN_STOP:

            printf ("Cluster mode started; draining preempted.\n");
            break;

        default:

            if (status >= WSABASEERR)
            {
                printf ("WinSock error %d.\n", status);
                return 2;
            }
        }

        if (host == WLBS_ALL_HOSTS)
        {
            printf ("Received responses from %d hosts:\n", hosts);

            for (i = 0; i < hosts && i < WLBS_MAX_HOSTS; i ++)
            {
                buf_size = BUF_SIZE;
                WlbsAddressToString (resp [i] . address, tbuf, & buf_size);
                buf_size = BUF_SIZE;
                WlbsAddressToName (resp [i] . address, tbuf2, & buf_size);
                _tprintf (_TEXT("Host %d [%s - %25s]: "), resp [i] . id, tbuf, tbuf2);

                switch (resp [i] . status)
                {
                case WLBS_OK:
                    printf ("started\n");
                    break;

                case WLBS_ALREADY:
                    printf ("already started\n");
                    break;

                case WLBS_SUSPENDED:
                    printf ("control suspended\n");
                    break;

                case WLBS_DRAIN_STOP:
                    printf ("started from draining\n");
                    break;

                case WLBS_BAD_PARAMS:
                    printf ("bad parameters\n");
                    break;
                }
            }

        }

        break;


    case stop:

        status = WlbsStop (cluster, host, resp, & hosts);

        switch (status)
        {
        case WLBS_INIT_ERROR:

            printf ("WLBS Control API not initialized.\n");
            return 2;

        case WLBS_LOCAL_ONLY:

            printf ("Can only execute local commands.\n");
            return 2;

        case WLBS_REMOTE_ONLY:

            printf ("Can only execute remote commands.\n");
            return 2;

        case WLBS_BAD_PASSW:

            printf ("Bad password specified.\n");
            return 2;

        case WLBS_TIMEOUT:

            printf ("Timed out awaiting response.\n");
            return 2;

        case WLBS_IO_ERROR:

            printf ("Error connecting to WLBS device.\n");
            return 2;

        case WLBS_OK:

            if (host == WLBS_ALL_HOSTS)
                printf ("All cluster hosts stopped.\n");
            else
                printf ("Cluster mode stopped.\n");

            break;

        case WLBS_ALREADY:

            printf ("Cluster mode already stopped.\n");
            break;

        case WLBS_SUSPENDED:

            if (host == WLBS_ALL_HOSTS)
                printf ("All cluster hosts suspended.\n");
            else
                printf ("Cluster mode control suspended.\n");

            break;

        case WLBS_DRAIN_STOP:

            printf ("Cluster mode stopped; draining preempted.\n");
            break;

        default:

            if (status >= WSABASEERR)
            {
                printf ("WinSock error %d.\n", status);
                return 2;
            }
        }

        if (host == WLBS_ALL_HOSTS)
        {
            printf ("Received responses from %d hosts:\n", hosts);

            for (i = 0; i < hosts && i < WLBS_MAX_HOSTS; i ++)
            {
                buf_size = BUF_SIZE;
                WlbsAddressToString (resp [i] . address, tbuf, & buf_size);
                buf_size = BUF_SIZE;
                WlbsAddressToName (resp [i] . address, tbuf2, & buf_size);
                _tprintf (_TEXT("Host %d [%s - %25s]: "), resp [i] . id, tbuf, tbuf2);

                switch (resp [i] . status)
                {
                case WLBS_OK:
                    printf ("stopped\n");
                    break;

                case WLBS_ALREADY:
                    printf ("already stopped\n");
                    break;

                case WLBS_SUSPENDED:
                    printf ("control suspended\n");
                    break;

                case WLBS_DRAIN_STOP:
                    printf ("stopped from draining\n");
                    break;
                }
            }

        }

        break;

    case drainstop:

        status = WlbsDrainStop (cluster, host, resp, & hosts);

        switch (status)
        {
        case WLBS_INIT_ERROR:

            printf ("WLBS Control API not initialized.\n");
            return 2;

        case WLBS_LOCAL_ONLY:

            printf ("Can only execute local commands.\n");
            return 2;

        case WLBS_REMOTE_ONLY:

            printf ("Can only execute remote commands.\n");
            return 2;

        case WLBS_BAD_PASSW:

            printf ("Bad password specified.\n");
            return 2;

        case WLBS_TIMEOUT:

            printf ("Timed out awaiting response.\n");
            return 2;

        case WLBS_IO_ERROR:

            printf ("Error connecting to WLBS device.\n");
            return 2;

        case WLBS_OK:

            if (host == WLBS_ALL_HOSTS)
                printf ("All cluster hosts set to drain.\n");
            else
                printf ("Draining started.\n");

            break;

        case WLBS_STOPPED:

            if (host == WLBS_ALL_HOSTS)
                printf ("Cluster mode stopped on all hosts.\n");
            else
                printf ("Cluster mode stopped.\n");

            break;

        case WLBS_ALREADY:

            printf ("Already draining.\n");
            break;

        case WLBS_SUSPENDED:

            if (host == WLBS_ALL_HOSTS)
                printf ("All cluster hosts suspended.\n");
            else
                printf ("Cluster mode control suspended.\n");

            break;

        default:

            if (status >= WSABASEERR)
            {
                printf ("WinSock error %d.\n", status);
                return 2;
            }
        }

        if (host == WLBS_ALL_HOSTS)
        {
            printf ("Received responses from %d hosts:\n", hosts);

            for (i = 0; i < hosts && i < WLBS_MAX_HOSTS; i ++)
            {
                buf_size = BUF_SIZE;
                WlbsAddressToString (resp [i] . address, tbuf, & buf_size);
                buf_size = BUF_SIZE;
                WlbsAddressToName (resp [i] . address, tbuf2, & buf_size);
                _tprintf (_TEXT("Host %d [%s - %25s]: "), resp [i] . id, tbuf, tbuf2);

                switch (resp [i] . status)
                {
                case WLBS_OK:
                    printf ("draining\n");
                    break;

                case WLBS_ALREADY:
                    printf ("already draining\n");
                    break;

                case WLBS_SUSPENDED:
                    printf ("control suspended\n");
                    break;

                case WLBS_STOPPED:
                    printf ("stopped\n");
                    break;
                }
            }

        }

        break;

    case enable:

        status = WlbsEnable (cluster, host, resp, & hosts, port);

        switch (status)
        {
        case WLBS_INIT_ERROR:

            printf ("WLBS Control API not initialized.\n");
            return 2;

        case WLBS_LOCAL_ONLY:

            printf ("Can only execute local commands.\n");
            return 2;

        case WLBS_REMOTE_ONLY:

            printf ("Can only execute remote commands.\n");
            return 2;

        case WLBS_BAD_PASSW:

            printf ("Bad password specified.\n");
            return 2;

        case WLBS_TIMEOUT:

            printf ("Timed out awaiting response.\n");
            return 2;

        case WLBS_IO_ERROR:

            printf ("Error connecting to WLBS device.\n");
            return 2;

        case WLBS_OK:

            if (host == WLBS_ALL_HOSTS)
                printf ("Port rule(s) enabled on all started hosts.\n");
            else
                printf ("Port rule(s) enabled.\n");

            break;

        case WLBS_NOT_FOUND:

            if (host == WLBS_ALL_HOSTS)
                printf ("Port rule does not exist on some host(s).\n");
            else
                printf ("Port rule does not exist.\n");

            break;

        case WLBS_STOPPED:

            printf ("Cluster mode stopped.\n");
            break;

        case WLBS_ALREADY:

            printf ("Already enabled.\n");
            break;

        case WLBS_SUSPENDED:

            if (host == WLBS_ALL_HOSTS)
                printf ("All cluster hosts suspended.\n");
            else
                printf ("Cluster mode control suspended.\n");

            break;

        case WLBS_DRAINING:

            printf ("Host is draining.\n");
            break;

        default:

            if (status >= WSABASEERR)
            {
                printf ("WinSock error %d.\n", status);
                return 2;
            }
        }

        if (host == WLBS_ALL_HOSTS)
        {
            printf ("Received responses from %d hosts:\n", hosts);

            for (i = 0; i < hosts && i < WLBS_MAX_HOSTS; i ++)
            {
                buf_size = BUF_SIZE;
                WlbsAddressToString (resp [i] . address, tbuf, & buf_size);
                buf_size = BUF_SIZE;
                WlbsAddressToName (resp [i] . address, tbuf2, & buf_size);
                _tprintf (_TEXT("Host %d [%s - %25s]: "), resp [i] . id, tbuf, tbuf2);

                switch (resp [i] . status)
                {
                case WLBS_OK:
                    printf ("enabled\n");
                    break;

                case WLBS_ALREADY:
                    printf ("already enabled\n");
                    break;

                case WLBS_SUSPENDED:
                    printf ("control suspended\n");
                    break;

                case WLBS_STOPPED:
                    printf ("stopped\n");
                    break;

                case WLBS_DRAINING:
                    printf ("draining\n");
                    break;

                case WLBS_NOT_FOUND:
                    printf ("not found\n");
                    break;
                }
            }

        }

        break;

    case disable:

        status = WlbsDisable (cluster, host, resp, & hosts, port);

        switch (status)
        {
        case WLBS_INIT_ERROR:

            printf ("WLBS Control API not initialized.\n");
            return 2;

        case WLBS_LOCAL_ONLY:

            printf ("Can only execute local commands.\n");
            return 2;

        case WLBS_REMOTE_ONLY:

            printf ("Can only execute remote commands.\n");
            return 2;

        case WLBS_BAD_PASSW:

            printf ("Bad password specified.\n");
            return 2;

        case WLBS_TIMEOUT:

            printf ("Timed out awaiting response.\n");
            return 2;

        case WLBS_IO_ERROR:

            printf ("Error connecting to WLBS device.\n");
            return 2;

        case WLBS_OK:

            if (host == WLBS_ALL_HOSTS)
                printf ("Port rule(s) disabled on all started hosts.\n");
            else
                printf ("Port rule(s) disabled.\n");

            break;

        case WLBS_NOT_FOUND:

            if (host == WLBS_ALL_HOSTS)
                printf ("Port rule does not exist on some host(s).\n");
            else
                printf ("Port rule does not exist.\n");

            break;

        case WLBS_STOPPED:

            printf ("Cluster mode stopped.\n");
            break;

        case WLBS_ALREADY:

            printf ("Already disabled.\n");
            break;

        case WLBS_SUSPENDED:

            if (host == WLBS_ALL_HOSTS)
                printf ("All cluster hosts suspended.\n");
            else
                printf ("Cluster mode control suspended.\n");

            break;

        case WLBS_DRAINING:

            printf ("Host is draining.\n");
            break;

        default:

            if (status >= WSABASEERR)
            {
                printf ("WinSock error %d.\n", status);
                return 2;
            }
        }

        if (host == WLBS_ALL_HOSTS)
        {
            printf ("Received responses from %d hosts:\n", hosts);

            for (i = 0; i < hosts && i < WLBS_MAX_HOSTS; i ++)
            {
                buf_size = BUF_SIZE;
                WlbsAddressToString (resp [i] . address, tbuf, & buf_size);
                buf_size = BUF_SIZE;
                WlbsAddressToName (resp [i] . address, tbuf2, & buf_size);
                _tprintf (_TEXT("Host %d [%s - %25s]: "), resp [i] . id, tbuf, tbuf2);

                switch (resp [i] . status)
                {
                case WLBS_OK:
                    printf ("disabled\n");
                    break;

                case WLBS_ALREADY:
                    printf ("already disabled\n");
                    break;

                case WLBS_SUSPENDED:
                    printf ("control suspended\n");
                    break;

                case WLBS_STOPPED:
                    printf ("stopped\n");
                    break;

                case WLBS_DRAINING:
                    printf ("draining\n");
                    break;

                case WLBS_NOT_FOUND:
                    printf ("not found\n");
                    break;
                }
            }

        }

        break;

    case drain:
        status = WlbsDrain (cluster, host, resp, & hosts, port);

        switch (status)
        {
        case WLBS_INIT_ERROR:

            printf ("WLBS Control API not initialized.\n");
            return 2;

        case WLBS_LOCAL_ONLY:

            printf ("Can only execute local commands.\n");
            return 2;

        case WLBS_REMOTE_ONLY:

            printf ("Can only execute remote commands.\n");
            return 2;

        case WLBS_BAD_PASSW:

            printf ("Bad password specified.\n");
            return 2;

        case WLBS_TIMEOUT:

            printf ("Timed out awaiting response.\n");
            return 2;

        case WLBS_IO_ERROR:

            printf ("Error connecting to WLBS device.\n");
            return 2;

        case WLBS_OK:

            if (host == WLBS_ALL_HOSTS)
                printf ("Port rule(s) set to drain on all started hosts.\n");
            else
                printf ("Port rule(s) set to drain.\n");

            break;

        case WLBS_NOT_FOUND:

            if (host == WLBS_ALL_HOSTS)
                printf ("Port rule does not exist on some host(s).\n");
            else
                printf ("Port rule does not exist.\n");

            break;

        case WLBS_STOPPED:

            printf ("Cluster mode stopped.\n");
            break;

        case WLBS_ALREADY:

            printf ("Already disabled.\n");
            break;

        case WLBS_SUSPENDED:

            if (host == WLBS_ALL_HOSTS)
                printf ("All cluster hosts suspended.\n");
            else
                printf ("Cluster mode control suspended.\n");

            break;

        case WLBS_DRAINING:

            printf ("Host is draining.\n");
            break;

        default:

            if (status >= WSABASEERR)
            {
                printf ("WinSock error %d.\n", status);
                return 2;
            }
        }

        if (host == WLBS_ALL_HOSTS)
        {
            printf ("Received responses from %d hosts:\n", hosts);

            for (i = 0; i < hosts && i < WLBS_MAX_HOSTS; i ++)
            {
                buf_size = BUF_SIZE;
                WlbsAddressToString (resp [i] . address, tbuf, & buf_size);
                buf_size = BUF_SIZE;
                WlbsAddressToName (resp [i] . address, tbuf2, & buf_size);
                _tprintf (_TEXT("Host %d [%s - %25s]: "), resp [i] . id, tbuf, tbuf2);

                switch (resp [i] . status)
                {
                case WLBS_OK:
                    printf ("set to drain\n");
                    break;

                case WLBS_ALREADY:
                    printf ("already draining\n");
                    break;

                case WLBS_SUSPENDED:
                    printf ("control suspended\n");
                    break;

                case WLBS_STOPPED:
                    printf ("stopped\n");
                    break;

                case WLBS_DRAINING:
                    printf ("draining\n");
                    break;

                case WLBS_NOT_FOUND:
                    printf ("not found\n");
                    break;
                }
            }

        }

        break;

    default:
        break;
    }

    return 0;

    usage:

    printf ("Usage: %s <command> [<cluster>[:<host>] [/PASSW [<password>]] [/PORT <port>]\n       [/DEST <destination>] [/TIMEOUT <msec>]]\n", __targv [0]);
    printf ("<command>\n");
    printf ("   query                - queries which hosts are currently part of the cluster\n");
    printf ("   suspend              - suspend control over cluster operations\n");
    printf ("   resume               - resume control over cluster operations\n");
    printf ("   start                - starts WLBS cluster operations\n");
    printf ("   stop                 - stops WLBS cluster operations\n");
    printf ("   drainstop            - finishes all existing connections and\n");
    printf ("                          stops WLBS cluster operations\n");
    printf ("   enable  <port> | ALL - enables traffic for <port> rule or ALL ports\n");
    printf ("   disable <port> | ALL - disables ALL traffic for <port> rule or ALL ports\n");
    printf ("   drain   <port> | ALL - disables NEW traffic for <port> rule or ALL ports\n");
    printf ("Remote options:\n");
    printf ("    <cluster>           - cluster name | cluster primary IP address\n");
    printf ("    <host>              - host within the cluster (default - ALL hosts):\n");
    printf ("                          dedicated name | IP address |\n");
    printf ("                          host priority ID (1..32) | 0 for current DEFAULT host\n");
    printf ("    /PASSW <password>   - remote control password (default - NONE)\n");
    printf ("                          blank <password> for console prompt\n");
    printf ("    /PORT <port>        - cluster's remote control UDP port (default - 1717)\n");
    printf ("    /DEST <destination> - alternative destination to send control messages:\n");
    printf ("                          system name | IP address (default - <cluster>)\n");
    printf ("    /TIMEOUT <msecs>    - set timeout for awaiting replies from the cluster\n");
    printf ("                          (default - 10,000)\n");

    return 1;

}




void generate_port_rules ( PWLBS_PORT_RULE rules, DWORD num_rules, DWORD range )
{

    DWORD i;
    static DWORD pri = 1;

    for (i = 0 ; i < num_rules ; i++)
    {
        rules [i] . start_port = i * range;
        rules [i] . end_port = rules [i] . start_port + range - 1;
        rules [i] . mode = WLBS_SINGLE;
        rules [i] . mode = (pri++) % 4 + 1;
        rules [i] . mode = WLBS_MULTI;
        rules [i] . protocol = WLBS_TCP_UDP;

        rules [i] . protocol = (pri++) %4 + 1;
        rules [i] . valid = rand();
        /* The following is just for testing */
        /* rules [i] . end_port = rules [i] . start_port - 1; */

        if (rules [i] . mode == WLBS_SINGLE)
        {
            rules [i] . mode_data . single . priority =  (pri++) % (WLBS_MAX_HOSTS + 6) + 1;
        }

        if (rules [i] . mode == WLBS_MULTI)
        {
            rules [i] . mode_data . multi . affinity = (WORD) ((pri++) % 4);
            rules [i] . mode_data . multi . equal_load = (WORD) ((pri++) % 3);
            rules [i] . mode_data . multi . load = (WORD) ((pri++) % 110);
        }
    }
    return;
}



void delete_all_rules ( PWLBS_REG_PARAMS reg_data )
{
    WLBS_PORT_RULE rules [WLBS_MAX_RULES];
    DWORD num_rules;
    DWORD i;

    num_rules = WlbsGetNumPortRules ( reg_data );
    printf("num_rules is %d\n", num_rules);

    WlbsEnumPortRules ( reg_data, rules, & num_rules );
    printf("num_rules is %d\n", num_rules);

    for (i = 0 ; i < num_rules ; i++)
    {
        if (TRUE)
        {
            printf("Deleting rule %d start %d result %d\n",i,
                   rules [i] . start_port,
                   WlbsDeletePortRule ( reg_data, rules [i] . start_port ) );
        }
    }
    printf("Number of rules in registry is %d\n", WlbsGetNumPortRules ( reg_data ) );
    return;
}


void test_commit ( PWLBS_REG_PARAMS reg_data, BOOL flag1, BOOL flag2 )
{
    /* read from the registry
     * change some values to cause only a reload
     * write and check the return value of commit
     */
    DWORD retval;

    if (flag1)
    {
        retval = WlbsReadReg (WLBS_LOCAL_CLUSTER, reg_data);
        if (retval != WLBS_OK)
        {
            printf("1:Error in reading from the registry\n");
            return;
        }

        /* randomly change some values */
        reg_data -> host_priority = 2;
        reg_data -> alive_period = 1000;
        _stprintf ( reg_data -> domain_name, _TEXT("rkcluster.domain.com"));

        retval = WlbsWriteReg (WLBS_LOCAL_CLUSTER, reg_data);
        if (retval != WLBS_OK)
        {
            printf("1:Error in writing to the registry\n");
            return;
        }

        retval = WlbsCommitChanges (WLBS_LOCAL_CLUSTER);
        if (retval == WLBS_OK)
        {
            printf("1:Successfully reloaded\n");
        }
        else if (retval == WLBS_REBOOT)
        {
            printf("1:Reboot required\n");
        }
        else
        {
            printf("1:retval was neither ok nor reboot\n");
        }
    }
    /* read from the registry
     * change cl_ip_addr or mcast_support or set i_convert_mac to false and set some mac addr
     * write and check the return value of commit
     */

    if (!flag2)
    {
        return;
    }

    retval = WlbsReadReg (WLBS_LOCAL_CLUSTER, reg_data);
    if (retval != WLBS_OK)
    {
        printf("2:Error in reading from the registry\n");
        return;
    }

    {
        /* change the cl_ip_addr */
        _stprintf (reg_data -> cl_ip_addr, _TEXT("10.0.0.200"));

        reg_data -> mcast_support = FALSE;

        reg_data -> i_convert_mac = FALSE;
        _stprintf ( reg_data -> cl_mac_addr, _TEXT("00-bf-ab-cd-ef-13"));

        _tprintf(_TEXT("The original cl net mask is %s\n"), reg_data -> cl_net_mask );
        _tprintf(_TEXT("The original ded net mask is %s\n"), reg_data -> ded_net_mask );
        _stprintf ( reg_data -> cl_net_mask, _TEXT("255.255.255.0"));
        _stprintf ( reg_data -> ded_net_mask , _TEXT("255.255.255.0"));

        _tprintf(_TEXT("The new ip address should be %s\n"), reg_data -> cl_ip_addr);
        _tprintf(_TEXT("The length of the string %d\n"), _tcslen (reg_data -> cl_ip_addr));
    }

    retval = WlbsWriteReg (WLBS_LOCAL_CLUSTER, reg_data);
    if (retval != WLBS_OK)
    {
        printf("2:Error in writing to the registry\n");
        return;
    }

_tprintf (_TEXT("The mac address should be %s"), reg_data -> cl_mac_addr);
    retval = WlbsCommitChanges (WLBS_LOCAL_CLUSTER);
    if (retval == WLBS_OK)
    {
        printf("2:Successfully reloaded\n");
        return;
    }
    else if (retval == WLBS_REBOOT)
    {
        printf("2:Reboot required\n");
        return;
    }
    else if (retval == WLBS_REG_ERROR)
    {
        printf("2:RegError\n");
        return;
    }
    printf("2:The retval from commit was neither ok nor reboot\n");
    return;
}


DWORD testnewapi (void)
{

        WLBS_REG_PARAMS reg_data;
        WLBS_PORT_RULE  rule;
        WLBS_PORT_RULE  rules_list [ 100 ];
        DWORD num_rules = 0;
        DWORD range = 0;
        DWORD status = 0;
        TCHAR * newdomainname = _TEXT("rkcluster.domain.com");
        DWORD i,k;

        DWORD host_map = 0;
        WLBS_RESPONSE response [3];
        DWORD size = 3;
/*
        status = WlbsQuery (WLBS_LOCAL_CLUSTER, 1, response, &size, &host_map, NULL);
        printf("Query status is %d size = %d\n", status, size);
        printf("response is %d %d %x\n", response [0] . id, response [0] . status, response [0] . address);
        printf("response is %d %d %x\n", response [1] . id, response [1] . status, response [1] . address);
        return 0;
  */      
        
        status = WlbsReadReg(WLBS_LOCAL_CLUSTER, &reg_data);

        if (status == WLBS_INIT_ERROR)
        {
            printf ("WlbsReadReg returned an init error\n");
            return 0;
        }

        printf("Printing the TCHAR fields in the reg_data structure\n");
        _tprintf (_TEXT("virtual_nic_name %s\n"), reg_data . i_virtual_nic_name );
        _tprintf (_TEXT("cl_mac_addr      %s\n"), reg_data . cl_mac_addr        );
        _tprintf (_TEXT("cl_ip_addr       %s\n"), reg_data . cl_ip_addr         );
        _tprintf (_TEXT("cl_net_mask      %s\n"), reg_data . cl_net_mask        );
        _tprintf (_TEXT("ded_ip_addr      %s\n"), reg_data . ded_ip_addr        );
        _tprintf (_TEXT("ded_net_mask     %s\n"), reg_data . ded_net_mask       );
        _tprintf (_TEXT("domain_name      %s\n"), reg_data . domain_name        );
        _tprintf (_TEXT("i_license_key    %s\n"), reg_data . i_license_key      );

/*        test_commit ( &reg_data, TRUE, TRUE);
        return 1;
        reg_data . host_priority = 31;
*/
        WlbsSetRemotePassword ( & reg_data, _TEXT(""));

        status = WlbsWriteReg(WLBS_LOCAL_CLUSTER, &reg_data);
        printf("WlbsWriteReg returned %d\n", status);
        return 1;

        memset ((void *) &reg_data, 0, sizeof (WLBS_REG_PARAMS));

        if (WlbsReadReg (WLBS_LOCAL_CLUSTER, &reg_data) == WLBS_INIT_ERROR)
        {
            printf ("WlbsReadReg returned an init error\n");
            return 0;
        }
        _tprintf(_TEXT("Read again from the registry. Domain name %s\n"), reg_data . domain_name );

        printf("The new host priority is %d\n", reg_data . host_priority);

        if (FALSE)
        {
            printf("checking the get num port rules function\n");

            num_rules = WlbsGetNumPortRules ( & reg_data );
            printf("num of rules is %d\n", num_rules );

            printf("checking the get num port rules function\n");
            printf("num of rules is %d\n", WlbsGetNumPortRules ( &reg_data) );

            printf("Writing to the registry %d\n", WlbsWriteReg(WLBS_LOCAL_CLUSTER,  &reg_data) );
            WlbsCommitChanges (WLBS_LOCAL_CLUSTER);

            memset ((void *) &reg_data, 0, sizeof (WLBS_REG_PARAMS));

            if (WlbsReadReg (WLBS_LOCAL_CLUSTER, &reg_data) == WLBS_INIT_ERROR)
            {
                printf ("WlbsReadReg returned an init error\n");
                return 0;
            }

        for (k=0;k<1;k++)
        {
            delete_all_rules ( &reg_data );
            printf("Deleted all the port rules. Num of rules now is %d\n", reg_data . i_num_rules);
            if (TRUE)
            {

                num_rules = 100;
                range = 600;
                generate_port_rules ( rules_list, num_rules, range );
                rules_list [0] . mode = WLBS_SINGLE;
                rules_list [0] . mode_data . single . priority = 5;

                for (i = 0 ; i < num_rules; i++)
                {
                    DWORD status = WlbsAddPortRule (&reg_data, &rules_list [i]);
                    printf("Adding port rule start %d end %d rule # %d result %d\n",
                           rules_list[i] . start_port,
                           rules_list[i] . end_port,
                           i,
                           status);
                }

                printf("Number of rules is %d\n", WlbsGetNumPortRules ( &reg_data ) );
            }

            printf("Writing the changes to the registry\n");
            WlbsWriteReg (WLBS_LOCAL_CLUSTER, &reg_data);
            WlbsCommitChanges (WLBS_LOCAL_CLUSTER);
        }
    }

    for (i=0; i<1; i++)
    {
        memset ( &reg_data, 0, sizeof (reg_data));
        WlbsReadReg (WLBS_LOCAL_CLUSTER, &reg_data);
        reg_data . host_priority = i%32 + 1;
        WlbsWriteReg (WLBS_LOCAL_CLUSTER, &reg_data);
        WlbsCommitChanges (WLBS_LOCAL_CLUSTER);
    }
        test_commit (&reg_data, TRUE, TRUE);
        return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\api\wlbsapitest.c ===
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <conio.h>
#include <string.h>
#include <winsock.h>
#include <tchar.h>
#include <iphlpapi.h>


#include "wlbsctrl.h"
#include "wlbsparm.h"
#include "wlbsiocl.h"

#define BUF_SIZE 256

typedef enum
{
    init,
    query,
    suspend,
    resume,
    wlbsstart,
    stop,
    drainstop,
    enable,
    disable,
    drain,
    resolve,
    addresstostring,
    addresstoname,
    readreg,
    writereg,
    commit,
    getnumportrules,
    enumportrules,
    getportrule,
    addportrule,
    deleteportrule,
    setpassword,
    portset,
    destinationset,
    timeoutset,
    codeset
}
TEST_COMMAND;

PTCHAR ErrStrings [] = {_TEXT("Init"),
    _TEXT("Query"),
    _TEXT("Suspend"),
    _TEXT("Resume"),
    _TEXT("Start"),
    _TEXT("Stop"),
    _TEXT("DrainStop"),
    _TEXT("Enable"),
    _TEXT("Disable"),
    _TEXT("Drain"),
    _TEXT("Resolve"),
    _TEXT("AddressToString"),
    _TEXT("AddressToName"),
    _TEXT("ReadReg"),
    _TEXT("WriteReg"),
    _TEXT("Commit"),
    _TEXT("GetNumPortRules"),
    _TEXT("EnumPortRules"),
    _TEXT("GetPortRule"),
    _TEXT("AddPortRule"),
    _TEXT("SetPassword"),
    _TEXT("PortSet"),
    _TEXT("DestinationSet"),
    _TEXT("TimeoutSet"),
    _TEXT("CodeSet"),
};

typedef struct Err_Struct
{
    struct Err_Struct * next;
    TCHAR comment [BUF_SIZE];
}
Err_Struct, * PErr_Struct;

static global_init = WLBS_INIT_ERROR;
static PErr_Struct headq = NULL, tailq = NULL;
static total_tests  = 0;
static failed_tests = 0;
static TCHAR remote_password [BUF_SIZE];
static TCHAR tbuf [BUF_SIZE];
static TCHAR status_buf [BUF_SIZE];
static BOOL verbose = FALSE;
static remote_cl_ip = 0;
static remote_host_ip = 0;
static BOOL remote_test = FALSE;
static BOOL local_test = FALSE;
static BOOL init_test = FALSE;
static BOOL version_nt4 = FALSE;
static timeout = 1000; /* 1 second by default */

void print_error_messages ();
/* This function adds a error message to the list of error messages.
 * This list will be displayed at the end.
 */
void add_error (PTCHAR errmsg)
{
    PErr_Struct err = (PErr_Struct) malloc (sizeof (Err_Struct));
    
    total_tests ++;
    failed_tests++;
    _tcscpy (err -> comment, errmsg);
    err -> next = NULL;
    
    if (tailq == NULL)
        headq = tailq = err;
    else
    {
        tailq -> next = err;
        tailq = err;
    }

    if (verbose)
        _tprintf (_TEXT("%s\n"), err -> comment);

    return;
}


/* Compares the expected value with the actual returned value and generates an error message
 * which gets appended to the list of error messages
 */
void verify_return_value (PTCHAR string, DWORD expected, DWORD actual)
{

    TCHAR tbuf [BUF_SIZE];


    if (verbose)
        _tprintf( _TEXT("%s %s\n"), status_buf, string);
    else
    {
        putchar (8);
        putchar (8);
        putchar (8);
        putchar (8);
        printf("%4d", total_tests);
    }
    
    if (expected == actual)
    {
        total_tests ++;
        return;
    }

    _stprintf ( tbuf, _TEXT("Test Number %d %s Testing %s Expected %d Returned %d"),
                total_tests, status_buf, string, expected, actual);

    add_error (tbuf);
    return;
}


/* When two return values are possible, such as WLBS_CONVERGED or WLBS_DEFAULT */
void verify_return_value2 (PTCHAR string, DWORD expected1, DWORD expected2, DWORD actual)
{

    if (verbose)
        _tprintf( _TEXT("%s %s\n"), status_buf, string);

    if (expected1 == actual || expected2 == actual)
    {
        total_tests ++;
        return;
    }

    _stprintf ( tbuf, _TEXT("Test Number %d %s Testing %s Expected %d or %d Returned %d"),
                total_tests, status_buf, string, expected1, expected2, actual);

    add_error (tbuf);
    return;
}


void verify_return_value3 (PTCHAR string, DWORD expected1, DWORD expected2, DWORD expected3, DWORD actual)
{

    if (verbose)
        _tprintf( _TEXT("%s %s\n"), status_buf, string);

    if (expected1 == actual || expected2 == actual || expected3 == actual)
    {
        total_tests ++;
        return;
    }

    _stprintf ( tbuf, _TEXT("Test Number %d %s Testing %s Expected %d or %d or %d Returned %d"),
                total_tests, status_buf, string, expected1, expected2, expected3, actual);

    add_error (tbuf);
    return;
}


/* This function calls all the apis without calling init
 * Each of the apis should return WLBS_INIT_ERROR */
void check_init()
{
    TEST_COMMAND cmd;
    WLBS_REG_PARAMS reg_data;
    WLBS_PORT_RULE port_rule;
    WLBS_PORT_RULE port_rules [WLBS_MAX_RULES];
    DWORD num = WLBS_MAX_RULES;
    DWORD status, status1;


    _tcscpy (status_buf, _TEXT("Calling the apis without Initializing"));

    status = WlbsQuery(WLBS_LOCAL_CLUSTER,WLBS_LOCAL_HOST,NULL,NULL,NULL,NULL);
    verify_return_value (_TEXT("Query"), WLBS_INIT_ERROR, status);

    status = WlbsSuspend(WLBS_LOCAL_CLUSTER,WLBS_LOCAL_HOST,NULL,NULL);
    verify_return_value (_TEXT("Suspend"), WLBS_INIT_ERROR, status);

    status = WlbsResume(WLBS_LOCAL_CLUSTER,WLBS_LOCAL_HOST,NULL,NULL);
    verify_return_value (_TEXT("Resume"), WLBS_INIT_ERROR, status);

    status = WlbsStart(WLBS_LOCAL_CLUSTER,WLBS_LOCAL_HOST,NULL,NULL);
    verify_return_value (_TEXT("Start"), WLBS_INIT_ERROR, status);

    status = WlbsStop(WLBS_LOCAL_CLUSTER,WLBS_LOCAL_HOST,NULL,NULL);
    verify_return_value (_TEXT("Stop"), WLBS_INIT_ERROR, status);

    status = WlbsDrainStop(WLBS_LOCAL_CLUSTER,WLBS_LOCAL_HOST,NULL,NULL);
    verify_return_value (_TEXT("DrainStop"), WLBS_INIT_ERROR, status);

    status = WlbsEnable(WLBS_LOCAL_CLUSTER,WLBS_LOCAL_HOST,NULL,NULL,80);
    verify_return_value (_TEXT("Enable"), WLBS_INIT_ERROR, status);

    status = WlbsDisable(WLBS_LOCAL_CLUSTER,WLBS_LOCAL_HOST,NULL,NULL,80);
    verify_return_value (_TEXT("Disable"), WLBS_INIT_ERROR, status);

    status = WlbsDrain(WLBS_LOCAL_CLUSTER,WLBS_LOCAL_HOST,NULL,NULL,80);
    verify_return_value (_TEXT("Drain"), WLBS_INIT_ERROR, status);

    status = WlbsReadReg(WLBS_LOCAL_CLUSTER,WLBS_LOCAL_HOST, &reg_data);
    verify_return_value (_TEXT("ReadReg"), WLBS_INIT_ERROR, status);

    status = WlbsWriteReg(WLBS_LOCAL_CLUSTER,WLBS_LOCAL_HOST, &reg_data);
    verify_return_value (_TEXT("WriteReg"), WLBS_INIT_ERROR, status);

    status = WlbsCommitChanges(WLBS_LOCAL_CLUSTER,WLBS_LOCAL_HOST);
    verify_return_value (_TEXT("CommitChanges"), WLBS_INIT_ERROR, status);

    status = WlbsGetNumPortRules(&reg_data);
    verify_return_value (_TEXT("GetNumPortRules"), WLBS_INIT_ERROR, status);

    status = WlbsEnumPortRules(&reg_data, port_rules, &num);
    verify_return_value (_TEXT("EnumPortRules"), WLBS_INIT_ERROR, status);

    status = WlbsGetPortRule(&reg_data, 80, &port_rule);
    verify_return_value (_TEXT("GetPortRule"), WLBS_INIT_ERROR, status);

    status = WlbsAddPortRule(&reg_data, &port_rule);
    verify_return_value (_TEXT("AddPortRule"), WLBS_INIT_ERROR, status);

    status = WlbsDeletePortRule (&reg_data, 80);
    verify_return_value (_TEXT("DeletePortRule"), WLBS_INIT_ERROR, status);

    /* With an invalid product name, init returns REMOTE_ONLY
     * On subsequent calls, it will return the same value.
     * Hence this test has to be performed in isolation
     */
    if (init_test)
    {
        status = WlbsInit (_TEXT("JunkName"), WLBS_API_VER, NULL);
        verify_return_value2 (_TEXT("Init with junk product name"), WLBS_INIT_ERROR, WLBS_REMOTE_ONLY, status);
        return;
    }

    status = WlbsInit (_TEXT(WLBS_PRODUCT_NAME), WLBS_API_VER, NULL);
    verify_return_value3 (_TEXT("Init"), WLBS_PRESENT, WLBS_REMOTE_ONLY, WLBS_LOCAL_ONLY, status);

    status1 = WlbsInit (_TEXT(WLBS_PRODUCT_NAME), WLBS_API_VER, NULL);
    verify_return_value (_TEXT("Init Again"), status, status1);

    global_init = status;
    return;
}


/* This function brings a particular host to the converged state.
 * This is done by first suspending the host and then resuming 
 * and starting it. Wait till the cluster converges and then return
 */
BOOL GetHostToConvergedState (DWORD cluster, DWORD host)
{
    DWORD status;
    /* suspend the host and then do a resume and start to get it to converged state */

    status = WlbsSuspend (cluster, host, NULL, NULL);
    if (!(status == WLBS_OK || status == WLBS_ALREADY || status == WLBS_STOPPED))
        return FALSE;

    status = WlbsResume (cluster, host, NULL, NULL);
    if (status != WLBS_OK)
        return FALSE;

    status = WlbsStart (cluster, host, NULL, NULL);
    if (status != WLBS_OK)
        return FALSE;

    Sleep(10000); /* Wait for 10 seconds till it converges */

    status = WlbsQuery (cluster, host, NULL, NULL, NULL, NULL);
    if (status == WLBS_CONVERGED || status == WLBS_DEFAULT)
        return TRUE;
    else
        return FALSE;
}


/* This function gets all the hosts on a given cluster to the converged state */
BOOL GetClusterToConvergedState (DWORD cluster)
{
    /* suspend the entire cluster
     * resume the entire cluster
     * start the entire cluster
     * wait for convergence
     * Query should return the number of active hosts
     */
    DWORD status;

    /* Set the timeout so that this process gets speeded up */
    if (cluster == WLBS_LOCAL_CLUSTER)
        WlbsTimeoutSet (WlbsGetLocalClusterAddress (), 2000);
    else
        WlbsTimeoutSet (cluster, 2000);

    status = WlbsSuspend (cluster, WLBS_ALL_HOSTS, NULL, NULL);
    status = WlbsResume  (cluster, WLBS_ALL_HOSTS, NULL, NULL);
    status = WlbsStart   (cluster, WLBS_ALL_HOSTS, NULL, NULL);
    Sleep (10000);
    status = WlbsQuery   (cluster, WLBS_ALL_HOSTS, NULL, NULL, NULL, NULL);

    if (status == WLBS_BAD_PASSW)
        printf("Please ensure that the password on all the machines is the same\n");

    /* Restore it to the default value */
    if (cluster == WLBS_LOCAL_CLUSTER)
        WlbsTimeoutSet (WlbsGetLocalClusterAddress (), 0);
    else
        WlbsTimeoutSet (cluster, 0);

    if ( 1 <= status && status <= WLBS_MAX_HOSTS)
        return TRUE;
    else
        return FALSE;
}


/* This function goes through the response array and verifies that for each host that is converged,
 * the corresponding bit in the hostmap is set.
 * This function is useful only when the response array is from a converged cluster
 */
BOOL verify_hostmap_response (PWLBS_RESPONSE response, DWORD num_response, DWORD host_map)
{
    DWORD i,j;


    /* For each response, if the host is converged or is the default host, then it should
     * figure in the hostmap. Verify this.
     */
    /* This function should be invoked only when the response array is from a converged cluster.
     * or from a single host, when it is converged
     */
    for (i = 0; i < num_response; i++)
    {
        if (response [i] . status == WLBS_CONVERGED || response [i] . status == WLBS_DEFAULT)
        {
            if ( ! ( host_map & (1 << (response [i] . id - 1))) )
                return FALSE;
        }
        else /* That particular bit should not be set */
        {
            if ( host_map & (1 << (response [i] . id - 1)) )
                return FALSE;
        }
    }

    return TRUE;
}


/* Verify that all the responses show the same state. This is used in cluster-wide control tests.
 * If the cluster is reported to be suspended, then all the hosts should show their status
 * to be WLBS_SUSPENDED
 */
void verify_response_status (PWLBS_RESPONSE response, DWORD num_host, DWORD expected_status)
{
    DWORD i;
    TCHAR temp [40];

    for (i = 0 ; i < num_host; i++)
    {
        _stprintf (temp, _TEXT("Verifying response for host %d"), response [i] . id);
        verify_return_value2 ( temp, expected_status, WLBS_ALREADY, response [i] . status);
    }
}


/* This function opens a TCP connection to the cluster ip on the specified port.
 * This function is used to test Drainstop
 */
SOCKET OpenConnection (DWORD cluster, DWORD port)
{

    SOCKET sock = INVALID_SOCKET;
    SOCKADDR_IN caddr, saddr;
    INT ret;

    sock = socket (AF_INET, SOCK_STREAM, 0);

    if (sock == INVALID_SOCKET)
        return sock;

    caddr . sin_family        = AF_INET;
    caddr . sin_port          = htons (0);
    caddr . sin_addr . s_addr = htonl (INADDR_ANY);

    ret = bind (sock, (LPSOCKADDR) & caddr, sizeof (caddr));

    if (ret == SOCKET_ERROR)
    {
        closesocket (sock);
        return INVALID_SOCKET;
    }

    /* setup server's address */

    saddr . sin_family = AF_INET;
    saddr . sin_port   = htons ((USHORT)port);
    saddr . sin_addr . s_addr = cluster;

    ret = connect (sock, (LPSOCKADDR) & saddr, sizeof (saddr));
    if (ret == SOCKET_ERROR)
    {
        closesocket (sock);
        return INVALID_SOCKET;
    }

    return sock;
}


/* This function performs the password testing. The same function can be used for single host
 * or cluster-wide testing.
 */
void password_test (DWORD cluster, DWORD host, PTCHAR password)
{
    DWORD status1;

    /* The input password is the correct password */
    _stprintf (status_buf, _TEXT("Password test for cluster %d host %d"), cluster, host);

    /* If the password is null, then return,since password testing cannot be performed. */
     if (password == NULL)
        return;

     /* If it is an empty string, then again the testing cannot be performed */
    if (_tcslen (password) == 0)
        return;

    WlbsPasswordSet(cluster, _TEXT("JunkPassword"));

    /* All commands should return bad passw */
    status1 = WlbsQuery (cluster, host, NULL, NULL, NULL, NULL);
    verify_return_value (_TEXT("Query"), WLBS_BAD_PASSW, status1);

    status1 = WlbsDrain (cluster, host, NULL, NULL, 80);
    verify_return_value (_TEXT("Drain"), WLBS_BAD_PASSW, status1);

    status1 = WlbsDisable (cluster, host, NULL, NULL, 80);
    verify_return_value (_TEXT("Disable"), WLBS_BAD_PASSW, status1);

    status1 = WlbsEnable (cluster, host, NULL, NULL, 80);
    verify_return_value (_TEXT("Enable"), WLBS_BAD_PASSW, status1);

    status1 = WlbsSuspend (cluster, host, NULL, NULL);
    verify_return_value (_TEXT("Suspend"), WLBS_BAD_PASSW, status1);

    status1 = WlbsResume (cluster, host, NULL, NULL);
    verify_return_value (_TEXT("Resume"), WLBS_BAD_PASSW, status1);

    status1 = WlbsStop (cluster, host, NULL, NULL);
    verify_return_value (_TEXT("Stop"), WLBS_BAD_PASSW, status1);

    status1 = WlbsDrainStop (cluster, host, NULL, NULL);
    verify_return_value (_TEXT("Drainstop"), WLBS_BAD_PASSW, status1);

    status1 = WlbsStart (cluster, host, NULL, NULL);
    verify_return_value (_TEXT("Start"), WLBS_BAD_PASSW, status1);

    WlbsPasswordSet (cluster, password); /* Reset the password for future tests */
    Sleep (10000); /* Wait till the cluster converges */
    return;
}


/* This function verifies the portset api.
 * It sets the port for a given cluster and makes a query on the host
 * The return value should match the expected value, which can be either
 * WLBS_TIMEOUT or some WINSOCK error in case of an invalid port
 * or the status of the host if the port is a valid one
 */
void verify_port (DWORD cluster, DWORD host, DWORD port, DWORD expected)
{
    DWORD status;
    TCHAR temp [BUF_SIZE];

    WlbsPortSet (cluster, (WORD)port);
    status = WlbsQuery (cluster, host, NULL, NULL, NULL, NULL);

    _stprintf (temp, _TEXT("Verifying port set for port %d"), port);
    verify_return_value (temp, expected, status);
    return;
}


/* Get the cluster/host to drainstopped state by establishing a connection and then drainstopping it */
BOOL GetDrainstopState (DWORD cluster, DWORD host, SOCKET * sock, DWORD port)
{
    DWORD status;
    BOOL connected = FALSE;

    /* First, get the cluster or host to the converged state */
    if (host == WLBS_ALL_HOSTS)
    {
        if (!GetClusterToConvergedState (cluster))
            return FALSE;
    }
    else if (!GetHostToConvergedState (cluster, host))
        return FALSE;

    /* Open a TCP connection on the specified port */
    *sock = OpenConnection (cluster, port);
    if (*sock == INVALID_SOCKET)
    {
        add_error(_TEXT("Unable to open a connection to the cluster"));
        return FALSE;
    }

    /* DrainStop the host and then query it. If the status is not draining, something is wrong */
    status = WlbsDrainStop (cluster, host, NULL, NULL);
    verify_return_value (_TEXT("Drainstop with active connection"), WLBS_OK, status);
    Sleep (10000); /* Wait for the cluster to converge */

    status = WlbsQuery (cluster, host, NULL, NULL, NULL, NULL);
    verify_return_value (_TEXT("Query after Drainstop with active connection"), WLBS_DRAINING, status);

    if (status != WLBS_DRAINING)
        return FALSE;

    return TRUE;
}


/* This function deals with the parameter testing of the apis on a single host */
void single_host_parameter_test (DWORD cluster, DWORD host)
{
    DWORD status1, status2;
    DWORD host_map1, host_map2;
    DWORD num_host1, num_host2;
    WLBS_RESPONSE response1, response2, *response;
    DWORD cl_ip, host_ip, host_id;
    TCHAR temp1[40], temp2[40];
    DWORD temp;


    temp = 40;
    if (cluster == WLBS_LOCAL_CLUSTER)
        _stprintf (temp1, _TEXT("local cluster"));
    else
        WlbsAddressToString (cluster, temp1, &temp);

    temp = 40;
    if (cluster == WLBS_LOCAL_HOST)
        _stprintf (temp2, _TEXT("local host"));
    else
        WlbsAddressToString (host, temp2, &temp);

    _stprintf (status_buf, _TEXT("Single Host Parameter Test for cluster:%s host:%s"), temp1, temp2);

    /* First verify that the response structure and the returned value match */
    num_host1 = 1;
    host_map1 = 0;
    status1 = WlbsQuery (cluster, host, &response1, &num_host1, &host_map1, NULL);

    if ( ! verify_hostmap_response (&response1, num_host1, host_map1) )
    {
        _stprintf (tbuf, _TEXT("Querying cluster %d, host %d, returned mismatched hostmap and response"),
                   cluster, host);
        add_error (tbuf);
    }

    if (cluster == WLBS_LOCAL_CLUSTER && host == WLBS_LOCAL_HOST)
    {
        /* On a local host, there can be additional tests. Query the host remotely and verify that
         * both the local and remote queries return the same status, the same id and the same hostmap
         */
        cl_ip = WlbsGetLocalClusterAddress ();
        host_ip = WlbsGetDedicatedAddress ();
        host_id = response1 . id;

        /* Query remotely first using the host ip */
        num_host2 = 1;
        host_map2 = 0;
        status2 = WlbsQuery (cl_ip, host_ip, &response2, &num_host2, &host_map2, NULL);
        verify_return_value (_TEXT("Comparing Local and Remote Query"), status1, status2);

        if (host_map1 != host_map2)
        {
            _stprintf (tbuf, _TEXT("Local host query and remote host query returned different hostmaps %d %d\n"),
                       host_map1, host_map2);
            add_error (tbuf);
        }

        if (response1 . status != response2 . status)
        {
            _stprintf (tbuf, _TEXT("Local host query and remote query returned different statuses in response"));
            add_error (tbuf);
        }

        if (response1 . id != response2 . id)
        {
            _stprintf (tbuf, _TEXT("Local host query and remote query returned different ids in response"));
            add_error (tbuf);
        }

        if (response2 . address != host_ip )
        {
            _stprintf (tbuf, _TEXT("Local host query and remote query returned different IP Addresses"));
            add_error (tbuf);
        }


        /* Now query the host remotely using the host_id as a parameter and verify the returns */
        num_host2 = 1;
        status2 = WlbsQuery (WLBS_LOCAL_CLUSTER, host_id, &response2, &num_host2, &host_map2, NULL);
        verify_return_value (_TEXT("Querying remotely with host id"), status1, status2);

        if (host_map1 != host_map2)
        {
            _stprintf (tbuf, _TEXT("Local host query and remote host query with id returned different hostmaps %d %d\n"),
                       host_map1, host_map2);
            add_error (tbuf);
        }

        if (response1 . status != response2 . status)
        {
            _stprintf (tbuf, _TEXT("Local host query and remote query with id returned different statuses in response"));
            add_error (tbuf);
        }

        if (response1 . id != response2 . id)
        {
            _stprintf (tbuf, _TEXT("Local host query and remote query with id returned different ids in response"));
            add_error (tbuf);
        }

        if (response2 . address != host_ip )
        {
            _stprintf (tbuf, _TEXT("Local host query and remote query returned different IP Addresses"));
            add_error (tbuf);
        }
    }

    status2 = WlbsQuery (cluster, host, NULL, NULL, NULL, NULL);
    verify_return_value (_TEXT("Querying with all parameters NULL"), status1, status2);

    num_host2 = 0;
    status2 = WlbsQuery (cluster, host, NULL, &num_host2, NULL, NULL);
    verify_return_value (_TEXT("Querying with num_host parameter = 0 and host_map = NULL"), status1, status2);

    status2 = WlbsQuery (1234, 0, NULL, NULL, NULL, NULL);
    verify_return_value (_TEXT("Querying non-existent cluster 1234"), WLBS_TIMEOUT, status2);

    status2 = WlbsQuery (cluster, 33, NULL, NULL, NULL, NULL);
    verify_return_value (_TEXT("Querying non-existent host 33"), WLBS_TIMEOUT, status2);

    /* Verify the portset command, only for remote queries
     * since the remote port is not used for local queries
     */
    if (! ( cluster == WLBS_LOCAL_CLUSTER && host == WLBS_LOCAL_HOST ) )
    {
        verify_port (cluster, host, 3000, WLBS_TIMEOUT);
        verify_port (cluster, host, 0, status1);
        verify_port (cluster, host, CVY_DEF_RCT_PORT, status1);
    }

    return;
}


/* This function goes through the state changes of for single host operations */
void single_host_state_changes (DWORD cluster, DWORD host)
{
    DWORD status1, status2;
    WLBS_RESPONSE response [WLBS_MAX_HOSTS];
    DWORD num_host1, num_host2;
    DWORD host_map1, host_map2;
    SOCKET sock = INVALID_SOCKET;
    DWORD temp_address;
    TCHAR temp1[40], temp2[40];
    DWORD temp;

    /* Assume that the host is in the converged state now */

    temp = 40;
    if (cluster == WLBS_LOCAL_CLUSTER)
        _stprintf (temp1, _TEXT("local cluster"));
    else
        WlbsAddressToString (cluster, temp1, &temp);

    temp = 40;
    if (cluster == WLBS_LOCAL_HOST)
        _stprintf (temp2, _TEXT("local host"));
    else
        WlbsAddressToString (host, temp2, &temp);


    _stprintf (status_buf, _TEXT("Single Host State Changes cluster %s host %s"), temp1, temp2);

    /* Call each of the apis and verify that the return values are consistent with the current
     * state of the host. For example, Disable would return different values depending on whether
     * the host was suspended or converged ....
     */
    num_host1 = 1;
    status1 = WlbsQuery (cluster, host, response, &num_host1, &host_map1, NULL);
    verify_return_value2 (_TEXT("Query"), WLBS_CONVERGED, WLBS_DEFAULT, status1);

/* The following tests assume that there is a port rule for port number 80.
 * Otherwise the return code will be WLBS_NOT_FOUND.
 */
    num_host1 = 1;
    status2 = WlbsDisable (cluster, host, response, &num_host1, 80);
    verify_return_value (_TEXT("Disable 80"), WLBS_OK, status2);
    if (status2 == WLBS_NOT_FOUND)
        printf("Please ensure that a port rule exists for port number 80.\n");

    num_host1 = 1;
    status2 = WlbsDisable (cluster, host, response, &num_host1, 80);
    verify_return_value (_TEXT("Disable Again 80"), WLBS_ALREADY, status2);

    /* If a port rule is disabled, drain returns already */
    num_host1 = 1;
    status2 = WlbsDrain (cluster, host, response, &num_host1, 80);
    verify_return_value (_TEXT("Drain 80"), WLBS_ALREADY, status2);

    num_host1 = 1;
    status2 = WlbsEnable (cluster, host, response, &num_host1, 80);
    verify_return_value (_TEXT("Enable 80"), WLBS_OK, status2);

    num_host1 = 1;
    status2 = WlbsEnable (cluster, host, response, &num_host1, 80);
    verify_return_value (_TEXT("Enable Again 80"), WLBS_ALREADY, status2);

    num_host1 = 1;
    status2 = WlbsDisable (cluster, host, response, &num_host1, WLBS_ALL_PORTS);
    verify_return_value (_TEXT("Disable ALL"), WLBS_OK, status2);

    num_host1 = 1;
    status2 = WlbsDisable (cluster, host, response, &num_host1, WLBS_ALL_PORTS);
    verify_return_value (_TEXT("Disable Again ALL"), WLBS_ALREADY, status2);

    num_host1 = 1;
    status2 = WlbsDrain (cluster, host, response, &num_host1, WLBS_ALL_PORTS);
    verify_return_value (_TEXT("Drain ALL"), WLBS_ALREADY, status2);

    num_host1 = 1;
    status2 = WlbsEnable (cluster, host, response, &num_host1, WLBS_ALL_PORTS);
    verify_return_value (_TEXT("Enable ALL"), WLBS_OK, status2);

    num_host1 = 1;
    status2 = WlbsEnable (cluster, host, response, &num_host1, WLBS_ALL_PORTS);
    verify_return_value (_TEXT("Enable Again ALL"), WLBS_ALREADY, status2);

    num_host1 = 1;
    status2 = WlbsSuspend (cluster, host, response, &num_host1);
    verify_return_value (_TEXT("Suspend"), WLBS_STOPPED, status2);

    num_host1 = 1;
    status2 = WlbsQuery (cluster, host, response, &num_host1, &host_map1, NULL);
    verify_return_value (_TEXT("Query after Suspend"), WLBS_SUSPENDED, status2);

    num_host1 = 1;
    status2 = WlbsDrain (cluster, host, response, &num_host1, 80);
    verify_return_value (_TEXT("Drain after Suspend"), WLBS_SUSPENDED, status2);

    num_host1 = 1;
    status2 = WlbsDisable (cluster, host, response, &num_host1, 80);
    verify_return_value (_TEXT("Disable after Suspend"), WLBS_SUSPENDED, status2);

    num_host1 = 1;
    status2 = WlbsEnable (cluster, host, response, &num_host1, 80);
    verify_return_value (_TEXT("Enable after Suspend"), WLBS_SUSPENDED, status2);

    num_host1 = 1;
    status2 = WlbsSuspend (cluster, host, response, &num_host1);
    verify_return_value (_TEXT("Suspend Again"), WLBS_ALREADY, status2);

    num_host1 = 1;
    status2 = WlbsStop (cluster, host, response, &num_host1);
    verify_return_value (_TEXT("Stop after Suspend"), WLBS_SUSPENDED, status2);

    num_host1 = 1;
    status2 = WlbsStart (cluster, host, response, &num_host1);
    verify_return_value (_TEXT("Start after Suspend"), WLBS_SUSPENDED, status2);

    num_host1 = 1;
    status2 = WlbsDrainStop (cluster, host, response, &num_host1);
    verify_return_value (_TEXT("DrainStop after Suspend"), WLBS_SUSPENDED, status2);

    num_host1 = 1;
    status2 = WlbsResume (cluster, host, response, &num_host1);
    verify_return_value (_TEXT("Resume after Suspend"), WLBS_OK, status2);

    num_host1 = 1;
    status2 = WlbsQuery (cluster, host, response, &num_host1, &host_map1, NULL);
    verify_return_value (_TEXT("Query after Resume"), WLBS_STOPPED, status2);

    num_host1 = 1;
    status2 = WlbsDrain (cluster, host, response, &num_host1, 80);
    verify_return_value (_TEXT("Drain when Stopped"), WLBS_STOPPED, status2);

    num_host1 = 1;
    status2 = WlbsDisable (cluster, host, response, &num_host1, 80);
    verify_return_value (_TEXT("Disable when Stopped"), WLBS_STOPPED, status2);

    num_host1 = 1;
    status2 = WlbsEnable (cluster, host, response, &num_host1, 80);
    verify_return_value (_TEXT("Enable when Stopped"), WLBS_STOPPED, status2);

    num_host1 = 1;
    status2 = WlbsResume (cluster, host, response, &num_host1);
    verify_return_value (_TEXT("Resume when Stopped"), WLBS_ALREADY, status2);

    num_host1 = 1;
    status2 = WlbsStop (cluster, host, response, &num_host1);
    verify_return_value (_TEXT("Stop when Stopped"), WLBS_ALREADY, status2);

    num_host1 = 1;
    status2 = WlbsDrainStop (cluster, host, response, &num_host1);
    verify_return_value (_TEXT("DrainStop when Stopped"), WLBS_STOPPED, status2);

    num_host1 = 1;
    status2 = WlbsSuspend (cluster, host, response, &num_host1);
    verify_return_value (_TEXT("Suspend when Stopped"), WLBS_OK, status2);

    num_host1 = 1;
    status2 = WlbsQuery (cluster, host, response, &num_host1, &host_map1, NULL);
    verify_return_value (_TEXT("Query when Suspended"), WLBS_SUSPENDED, status2);

    num_host1 = 1;
    status2 = WlbsResume (cluster, host, response, &num_host1);
    verify_return_value (_TEXT("Resume when Suspended"), WLBS_OK, status2);

    num_host1 = 1;
    status2 = WlbsQuery (cluster, host, response, &num_host1, &host_map1, NULL);
    verify_return_value (_TEXT("Query when Stopped"), WLBS_STOPPED, status2);

    num_host1 = 1;
    status2 = WlbsStart (cluster, host, response, &num_host1);
    verify_return_value (_TEXT("Start when Stopped"), WLBS_OK, status2);

    num_host1 = 1;
    status2 = WlbsQuery (cluster, host, response, &num_host1, &host_map1, NULL);
    verify_return_value3 (_TEXT("Query after Starting"), WLBS_CONVERGING, WLBS_CONVERGED, WLBS_DEFAULT, status2);

    Sleep (10000); /* Wait for the cluster to converge */

    /* Modify the code to keep polling the host till it is converged ###### */

    num_host1 = 1;
    status2 = WlbsQuery (cluster, host, response, &num_host1, &host_map1, NULL);
    verify_return_value2 (_TEXT("Query after Waiting for Convergence"), WLBS_CONVERGED, WLBS_DEFAULT, status2);

    num_host1 = 1;
    status2 = WlbsStart (cluster, host, response, &num_host1);
    verify_return_value (_TEXT("Start when Converged"), WLBS_ALREADY, status2);

    num_host1 = 1;
    status2 = WlbsResume (cluster, host, response, &num_host1);
    verify_return_value (_TEXT("Resume when Converged"), WLBS_ALREADY, status2);

    num_host1 = 1;
    status2 = WlbsStop (cluster, host, response, &num_host1);
    verify_return_value (_TEXT("Stop when Converged"), WLBS_OK, status2);

    num_host1 = 1;
    status2 = WlbsQuery (cluster, host, response, &num_host1, &host_map1, NULL);
    verify_return_value (_TEXT("Query when Stopped"), WLBS_STOPPED, status2);

    num_host1 = 1;
    status2 = WlbsStart (cluster, host, response, &num_host1);
    verify_return_value (_TEXT("Start when Stopped"), WLBS_OK, status2);

    num_host1 = 1;
    status2 = WlbsQuery (cluster, host, response, &num_host1, &host_map1, NULL);
    verify_return_value3 (_TEXT("Query after Starting"), WLBS_CONVERGING, WLBS_CONVERGED, WLBS_DEFAULT, status2);

    Sleep (10000); /* Wait for the cluster to converge */

    num_host1 = 1;
    status2 = WlbsQuery (cluster, host, response, &num_host1, &host_map1, NULL);
    verify_return_value2 (_TEXT("Query after Waiting for Convergence"), WLBS_CONVERGED, WLBS_DEFAULT, status2);

    /* DrainStop is to be tested only on a remote host */
    if ((cluster == WLBS_LOCAL_CLUSTER || cluster == WlbsGetLocalClusterAddress()) &&
        (host == WLBS_LOCAL_HOST || host == WlbsGetDedicatedAddress()) )
        return;


    /* To test drainstop on a particular host, stop the entire cluster. Then start only this particular host.
     * Open a connection to it. Then do a drainstop. Query should return draining. Then close the connection.
     * Query again. The return value should be stopped. This should be done only on a remote host. This test
     * would fail on a local host, since the connection setup does not go through the wlbs driver, but gets
     * routed up the stack.
     */

    num_host1 = WLBS_MAX_HOSTS;
    status2 = WlbsStop (cluster, WLBS_ALL_HOSTS, response, &num_host1);
    verify_return_value (_TEXT("Cluster-wide stop to test drainstop"), WLBS_OK, status2);

    num_host1 = 1;
    status2 = WlbsStart (cluster, host, response, &num_host1);
    verify_return_value (_TEXT("Start on host after Cluster-wide stop"), WLBS_OK, status2);

    Sleep (10000); /* Wait till the host converges */

    num_host1 = 1;
    status2 = WlbsQuery (cluster, host, response, &num_host1, &host_map1, NULL);
    verify_return_value2 (_TEXT("Query after Waiting for Convergence"), WLBS_CONVERGED, WLBS_DEFAULT, status2);


    if (!GetDrainstopState (cluster, host, &sock, 80))
        return;

    num_host1 = 1;
    status2 = WlbsDisable (cluster, host, response, &num_host1, 80);
    verify_return_value (_TEXT("Disable after DrainStop with active connection"), WLBS_ALREADY, status2);

    num_host1 = 1;
    status2 = WlbsDrain (cluster, host, response, &num_host1, 80);
    verify_return_value (_TEXT("Drain after DrainStop with active connection"), WLBS_ALREADY, status2);

    num_host1 = 1;
    status2 = WlbsEnable (cluster, host, response, &num_host1, 80);
    verify_return_value (_TEXT("Enable after DrainStop with active connection"), WLBS_OK, status2);

    num_host1 = 1;
    status2 = WlbsEnable (cluster, host, response, &num_host1, 80);
    verify_return_value (_TEXT("Enable again after DrainStop with active connection"), WLBS_ALREADY, status2);

    num_host1 = 1;
    status2 = WlbsResume (cluster, host, response, &num_host1);
    verify_return_value (_TEXT("Resume after DrainStop with active connection"), WLBS_ALREADY, status2);

    num_host1 = 1;
    status2 = WlbsStop (cluster, host, response, &num_host1);
    verify_return_value (_TEXT("Stop after DrainStop with active connection"), WLBS_DRAIN_STOP, status2);

    closesocket (sock);

    /* Start the host and open a connection again */
    if (!GetDrainstopState (cluster, host, &sock, 80))
        return;

    num_host1 = 1;
    status2 = WlbsStart (cluster, host, response, &num_host1);
    verify_return_value (_TEXT("Start after DrainStop with active connection"), WLBS_DRAIN_STOP, status2);

    closesocket (sock);

    if (!GetDrainstopState (cluster, host, &sock, 80))
        return;

    num_host1 = 1;
    status2 = WlbsSuspend (cluster, host, response, &num_host1);
    verify_return_value (_TEXT("Suspend after DrainStop with active connection"), WLBS_DRAIN_STOP, status2);

    closesocket (sock); /* close the connection */

    if (!GetDrainstopState (cluster, host, &sock, 80))
        return;

    num_host1 = 1;
    status2 = WlbsQuery (cluster, host, response, &num_host1, &host_map1, NULL);
    verify_return_value (_TEXT("Query after DrainStop with active connection"), WLBS_DRAINING, status2);

    closesocket (sock);
    Sleep (10000); /* Wait for it to figure out that all the connections have been terminated */

    num_host1 = 1;
    status2 = WlbsQuery (cluster, host, response, &num_host1, &host_map1, NULL);
    verify_return_value (_TEXT("Query after DrainStop with closed connection"), WLBS_STOPPED, status2);

    /* issue a cluster-wide start to bring back all the hosts to the converged state.*/
    num_host1 = WLBS_MAX_HOSTS;
    status2 = WlbsStart (cluster, WLBS_ALL_HOSTS, response, &num_host1);
    verify_return_value (_TEXT("Cluster-wide start to restore original state"), WLBS_OK, status2);

    Sleep (10000); /* Wait for convergence */
    return;
}


/* This function tests the single host control operations.
 * It performs both the parameter tests as well as the
 * state change tests.
 */
void check_single_host_operations ( )
{
    DWORD local_cluster_ip = 0;
    DWORD local_dedicated_ip = 0;
    DWORD remote_cluster_ip = 0;
    DWORD remote_host = 0;

    if (global_init == WLBS_INIT_ERROR)
    {
        add_error(_TEXT("Cannot perform Control test due to Init Error"));
        return;
    }
    

    if (local_test)
    {
        do {
            if (global_init == WLBS_PRESENT)
            {
                WLBS_REG_PARAMS reg_data;
                DWORD status;

                local_cluster_ip = WlbsGetLocalClusterAddress();
                local_dedicated_ip = WlbsGetDedicatedAddress();

                status = WlbsReadReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, & reg_data);
                WlbsCodeSet (local_cluster_ip, reg_data . i_rct_password);
                /* test the local call path */
                if ( ! GetHostToConvergedState(WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST))
                {
                    printf("Unable to get the local host to converged state\n");
                    break;
                }
                single_host_parameter_test (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST);
                single_host_state_changes (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST);

                /* test the remote call path */
                WlbsCodeSet (local_cluster_ip, reg_data . i_rct_password);
                single_host_parameter_test (local_cluster_ip, local_dedicated_ip);
                single_host_state_changes (local_cluster_ip, local_dedicated_ip);
            }
        } while (FALSE);
    }

    if ( ! remote_test)
        return;

    if (global_init == WLBS_PRESENT || global_init == WLBS_REMOTE_ONLY)
    {
        /* test a remote host on a remote cluster */

        if (remote_cl_ip == 0)
        {
            printf("Remote cluster address is invalid, so Control operations on a remote host are not tested\n");
            return;
        }

        if (remote_host_ip == 0)
        {
            printf("Remote host address is invalid, so Control operations on a remote host are not tested\n");
            return;
        }

        /* Set the password for the remote host and set it so that the operations can be performed */
        WlbsPasswordSet (remote_cl_ip, remote_password);
        WlbsTimeoutSet (remote_cl_ip, timeout);
        if ( ! GetHostToConvergedState(remote_cl_ip, remote_host_ip) )
        {
            printf("Unable to get the remote host to converged state. Not performing state change tests");
            return;
        }

        single_host_state_changes (remote_cl_ip, remote_host_ip);
    }
    else
        printf("Unable to perform the remote tests\n");

    return;
}


/* This function verifies the parameter testing for cluster-wide queries. It checks the response array
 * verifies it with the hostmap
 */
void cluster_parameter_test (DWORD cluster)
{
    DWORD status1, status2;
    DWORD host_map1, host_map2, temp_host_map;
    DWORD num_host1, num_host2;
    WLBS_RESPONSE response1, response2 [WLBS_MAX_HOSTS];
    PWLBS_RESPONSE response = NULL;
    DWORD stopped_host_id = 0;
    DWORD i;

    
    _stprintf (status_buf, _TEXT("Cluster-wide parameter testing for cluster %d"), cluster);

    /* Query with all parameters set to null should return the number of active hosts */
    status1 = WlbsQuery (cluster, WLBS_ALL_HOSTS, NULL, NULL, NULL, NULL);
    
    /* Query with num_hosts set to 0. On return num_hosts should be >= status1 */
    num_host1 = 0;
    status2 = WlbsQuery (cluster, WLBS_ALL_HOSTS, NULL, &num_host1, &host_map1, NULL);
    if (num_host1 < status1)
    {
        _stprintf (tbuf, _TEXT("Cluster-wide query returned %d active and %d total hosts"), status1, num_host1);
        add_error (tbuf);
        return;
    }

    /* Response array = #hosts + 1. Check that the boundaries are not overwritten. */
    response = (PWLBS_RESPONSE) malloc (sizeof (WLBS_RESPONSE) * (num_host1 + 1));
    memset (response, 0, (sizeof (WLBS_RESPONSE) * (num_host1 + 1)));
    memset (&response1, 0, sizeof (WLBS_RESPONSE));
    num_host2 = num_host1 - 1;

    status2 = WlbsQuery (cluster, WLBS_ALL_HOSTS, &response [1], &num_host2, &host_map2, NULL);
    if (memcmp (&response1, &response[0], sizeof (WLBS_RESPONSE)) ||
        memcmp (&response1, &response[num_host1], sizeof (WLBS_RESPONSE)) )
    {
        add_error(_TEXT("Response Array boundaries are over-written"));
    }

    free (response);
    response = NULL;

    /* Query again with the full response buffer */
    /* Verify that the hostmap and response array are in sync */
    num_host1 = WLBS_MAX_HOSTS;

    status2 = WlbsQuery (cluster, WLBS_ALL_HOSTS, response2, &num_host1, &host_map1, NULL);
    if (! verify_hostmap_response (response2, num_host1, host_map1) )
        add_error (_TEXT("Hostmap and Response do not match for the cluster wide query"));

    /* The following test is to verify the correctness of the hostmap parameter
     * Save the host_map returned in the previous query.
     * Stop a converged host.
     * Query again and get the new host_map.
     * */
    for (i = 0 ; i < num_host1; i++)
    {
        if (response2 [i] . status == WLBS_CONVERGED || response2 [i] . status == WLBS_DEFAULT)
        {
            stopped_host_id = response2 [i] . id;
            break;
        }
    }

    status1  = WlbsStop (cluster, stopped_host_id, NULL, NULL);

    Sleep (10000); /* Wait for the cluster to converge */

    /* Query the cluster again */
    num_host1 = WLBS_MAX_HOSTS;
    status1 = WlbsQuery (cluster, WLBS_ALL_HOSTS, response2, &num_host1, &host_map1, NULL);
    if (status2 == 1) /* This is to take care of single host clusters */
        verify_return_value (_TEXT("Querying cluster after stopping 1 host"), WLBS_STOPPED, status1);
    else
        verify_return_value (_TEXT("Querying cluster after stopping 1 host"), status2 - 1, status1);


    if (status2 > 1) /* The following verification can be done only if there are 2 or more hosts in the cluster */
    {
        /* Verify that the corresponding bit in the host_map is not set */
        if (! verify_hostmap_response (response2, num_host1, host_map1) )
            add_error (_TEXT("Hostmap and Response do not match for the cluster wide query"));

        if (host_map1 & (1 << (stopped_host_id - 1)) )
        {
            _stprintf (tbuf, _TEXT("Stopping host %d did not change the host_map"), stopped_host_id);
            add_error (tbuf);
        }
    }

    /* start the host again */
    status1 = WlbsStart (cluster, stopped_host_id, NULL, NULL);

    /* wait for it to converge */
    Sleep (10000);
    
    status1 = WlbsQuery (cluster, WLBS_ALL_HOSTS, NULL, NULL, NULL, NULL);
    if (! (status1 >= 1 && status1 <= WLBS_MAX_HOSTS) )
        printf("Unable to get the cluster to the converged state after Cluster parameter testing\n");

    /* Test portset */
    verify_port (cluster, WLBS_ALL_HOSTS, 3000, WLBS_TIMEOUT);
    verify_port (cluster, WLBS_ALL_HOSTS, 0, status1);
    verify_port (cluster, WLBS_ALL_HOSTS, CVY_DEF_RCT_PORT, status1);

    return;
}


void verify_timeout (DWORD cluster, DWORD timeout)
{
    DWORD time1, time2, time_diff;
    DWORD status;

    WlbsTimeoutSet (cluster, timeout);
    if (timeout == 0) /* set it to the default value */
        timeout = IOCTL_REMOTE_RECV_DELAY * IOCTL_REMOTE_SEND_RETRIES * IOCTL_REMOTE_RECV_RETRIES;

    time1 = GetTickCount ();
    status = WlbsQuery (cluster, WLBS_ALL_HOSTS, NULL, NULL, NULL, NULL);
    time2 = GetTickCount ();

    time_diff = time2 - time1;

    if (abs (time_diff - timeout) > 1000) /* Keep a margin of 1 sec */
    {
        _stprintf ( tbuf, _TEXT("Expected timeout %d, Actual timeout %d"), timeout, time_diff);
        add_error (tbuf);
    }

    return;
}


/* This function takes the entire cluster through the different state changes.
 * Some special cases are when one particular host is suspended
 * or when one particular host is in the drainstop state.
 * In such cases, WLBS_SUSPENDED or WLBS_DRAINING or WLBS_DRAIN_STOP are returned.
 * These return values are also verified.
 * After these special cases, the entire cluster is taken through the state changes.
 * In these tests, the response array is checked to verify that the statuses of each
 * host is in synch with the value returned by the control operation.
 */
void cluster_state_changes (DWORD cluster)
{
    DWORD status1, status2;
    WLBS_REG_PARAMS reg_data;
    BOOL password_flag = TRUE;
    WLBS_RESPONSE response [WLBS_MAX_HOSTS];
    DWORD num_host, host_map;
    DWORD suspended_host_id;
    DWORD temp_address;
    SOCKET sock = INVALID_SOCKET;


    _stprintf (status_buf, _TEXT("Checking cluster state changes for cluster %d"), cluster);

    /* Password check on the local cluster only */
    if (cluster == WLBS_LOCAL_CLUSTER)
    {
        DWORD password;
        DWORD cluster = WlbsGetLocalClusterAddress ();


        status1 = WlbsReadReg(WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, & reg_data);
        password = reg_data . i_rct_password;
        status1 = WlbsSetRemotePassword (&reg_data, _TEXT("NewPassword"));
        status1 = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, & reg_data);
        status1 = WlbsCommitChanges (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST);
        Sleep (10000);

        if (status1 != WLBS_OK)
        {
            password_flag = FALSE;
            add_error (_TEXT("Unable to change the password on the local machine."));
        }

        if (password_flag)
            password_test (WLBS_LOCAL_CLUSTER, WLBS_ALL_HOSTS, _TEXT("NewPassword"));

        status1 = WlbsReadReg(WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, & reg_data);
        reg_data . i_rct_password = password;
        status1 = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, & reg_data);
        status1 = WlbsCommitChanges (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST);
        WlbsCodeSet (cluster, password);
        Sleep (10000); /* Wait till the cluster converges */
    }
    /* Password check on the remote cluster by getting the password beforehand */
    else
    {
        password_test (cluster, WLBS_ALL_HOSTS, remote_password);

        /* Reset the password to the original state */
        WlbsPasswordSet (cluster, remote_password);
    }

    /* Bring any one host to the suspended state. On every command, the response should be WLBS_SUSPENDED */
    _stprintf (status_buf, _TEXT("Cluster-wide commands with one suspended host"));

    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsQuery (cluster, WLBS_ALL_HOSTS, response, &num_host, &host_map, NULL);

    suspended_host_id = response [0] . id;
    status1 = WlbsSuspend (cluster, suspended_host_id, NULL, NULL);
    Sleep (10000); /* Wait for the cluster to converge. */

    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsStop (cluster, WLBS_ALL_HOSTS, response, &num_host);
    verify_return_value (_TEXT("Stop after suspending 1 host"), WLBS_SUSPENDED, status1);

    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsDrainStop (cluster, WLBS_ALL_HOSTS, response, &num_host);
    verify_return_value (_TEXT("Stop after suspending 1 host"), WLBS_SUSPENDED, status1);

    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsStart (cluster, WLBS_ALL_HOSTS, response, &num_host);
    verify_return_value (_TEXT("Start after suspending 1 host"), WLBS_SUSPENDED, status1);

    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsDrain (cluster, WLBS_ALL_HOSTS, response, &num_host, 80);
    verify_return_value (_TEXT("Drain after suspending 1 host"), WLBS_SUSPENDED, status1);

    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsDisable (cluster, WLBS_ALL_HOSTS, response, &num_host, 80);
    verify_return_value (_TEXT("Disable after suspending 1 host"), WLBS_SUSPENDED, status1);

    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsEnable (cluster, WLBS_ALL_HOSTS, response, &num_host, 80);
    verify_return_value (_TEXT("Enable after suspending 1 host"), WLBS_SUSPENDED, status1);

    /* Now get the cluster to the converged state and test the state changes */
    if ( !GetClusterToConvergedState (cluster))
    {
        add_error (_TEXT("Unable to get the cluster to the converged state"));
        return;
    }

    _stprintf ( status_buf, _TEXT("Cluster-wide commands"));

    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsSuspend (cluster, WLBS_ALL_HOSTS, response, &num_host);
    verify_return_value (_TEXT("Cluster-wide Suspend"), WLBS_OK, status1);

    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsQuery (cluster, WLBS_ALL_HOSTS, response, &num_host, &host_map, NULL);
    verify_return_value (_TEXT("Query after Cluster-wide Suspend"), WLBS_SUSPENDED, status1);
    verify_response_status (response, num_host, WLBS_SUSPENDED);

    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsResume (cluster, WLBS_ALL_HOSTS, response, &num_host);
    verify_return_value (_TEXT("Cluster-wide Resume after Suspend"), WLBS_OK, status1);

    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsQuery (cluster, WLBS_ALL_HOSTS, response, &num_host, &host_map, NULL);
    verify_return_value (_TEXT("Cluster-wide Query after Resume"), WLBS_STOPPED, status1);
    verify_response_status (response, num_host, WLBS_STOPPED);

    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsStart (cluster, WLBS_ALL_HOSTS, response, &num_host);
    verify_return_value (_TEXT("Cluster-wide Start after Resume"), WLBS_OK, status1);

    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsQuery (cluster, WLBS_ALL_HOSTS, response, &num_host, &host_map, NULL);
    if (! (status1 == WLBS_CONVERGING || ( 1 <= status1 && status1 <= WLBS_MAX_HOSTS)) )
    {
        add_error (_TEXT("Error in query after cluster-wide start"));
    }

    Sleep (10000); /* Wait for the cluster to converge */

    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsQuery (cluster, WLBS_ALL_HOSTS, response, &num_host, &host_map, NULL);
    if ( ! ( 1 <= status1 && status1 <= WLBS_MAX_HOSTS) )
        printf("Unable to get the cluster to converged state after Starting\n");

    /* Test for invalid port numbers */
    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsDrain (cluster, WLBS_ALL_HOSTS, response, &num_host, CVY_MAX_PORT + 1);
    verify_return_value (_TEXT("Drain on invalid port"), WLBS_NOT_FOUND, status1);

    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsDisable (cluster, WLBS_ALL_HOSTS, response, &num_host, CVY_MAX_PORT + 1);
    verify_return_value (_TEXT("Disable on invalid port"), WLBS_NOT_FOUND, status1);

    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsEnable (cluster, WLBS_ALL_HOSTS, response, &num_host, CVY_MAX_PORT + 1);
    verify_return_value (_TEXT("Enable on invalid port"), WLBS_NOT_FOUND, status1);

    Sleep (10000); /* Wait for the cluster to converge */

    /* Test for invalid port numbers */
    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsDrain (cluster, WLBS_ALL_HOSTS, response, &num_host, WLBS_ALL_PORTS);
    verify_return_value (_TEXT("Drain on all port"), WLBS_OK, status1);

    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsDisable (cluster, WLBS_ALL_HOSTS, response, &num_host, WLBS_ALL_PORTS);
    verify_return_value (_TEXT("Disable on all port"), WLBS_OK, status1);

    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsEnable (cluster, WLBS_ALL_HOSTS, response, &num_host, WLBS_ALL_PORTS);
    verify_return_value (_TEXT("Enable on all port"), WLBS_OK, status1);

    Sleep (10000);

    /* Test timeout */
    if (cluster == WLBS_LOCAL_CLUSTER)
        temp_address = WlbsGetLocalClusterAddress ();
    else
        temp_address = cluster;

    verify_timeout (temp_address, 5000);
    verify_timeout (temp_address, 1000);
    verify_timeout (temp_address, 0);

    WlbsTimeoutSet (temp_address, timeout); /* Set the value specified by the user */


    if (cluster == WLBS_LOCAL_CLUSTER)
        return; /* DrainStop is not checked, since the connection will not be visible to the wlbs driver */


    if (!GetDrainstopState (cluster, WLBS_ALL_HOSTS, &sock, 80))
        return;

    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsQuery (cluster, WLBS_ALL_HOSTS, response, &num_host, &host_map, NULL);
    verify_return_value (_TEXT("Query after DrainStop with active connection"), WLBS_DRAINING, status1);

    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsDisable (cluster, WLBS_ALL_HOSTS, response, &num_host, 80);
    verify_return_value (_TEXT("Disable after DrainStop with active connection"), WLBS_OK, status1);

    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsDrain (cluster, WLBS_ALL_HOSTS, response, &num_host, 80);
    verify_return_value (_TEXT("Drain after DrainStop with active connection"), WLBS_OK, status1);

    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsEnable (cluster, WLBS_ALL_HOSTS, response, &num_host, 80);
    verify_return_value (_TEXT("Enable after DrainStop with active connection"), WLBS_OK, status1);

    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsEnable (cluster, WLBS_ALL_HOSTS, response, &num_host, 80);
    verify_return_value (_TEXT("Enable again after DrainStop with active connection"), WLBS_OK, status1);

    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsStop (cluster, WLBS_ALL_HOSTS, response, &num_host);
    verify_return_value (_TEXT("Stop after DrainStop with active connection"), WLBS_OK, status1);

    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsQuery (cluster, WLBS_ALL_HOSTS, response, &num_host, &host_map, NULL);
    verify_return_value (_TEXT("Query after Stop on DrainStop with active connection"), WLBS_STOPPED, status1);

    closesocket (sock);

    if (!GetDrainstopState (cluster, WLBS_ALL_HOSTS, &sock, 80))
        return;

    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsStart (cluster, WLBS_ALL_HOSTS, response, &num_host);
    verify_return_value (_TEXT("Start after DrainStop with active connection"), WLBS_OK, status1);

    Sleep (10000);
    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsQuery (cluster, WLBS_ALL_HOSTS, response, &num_host, &host_map, NULL);
    if (!(1 <= status1 && status1 <= WLBS_MAX_HOSTS))
        return;

    closesocket (sock);

    if (!GetDrainstopState (cluster, WLBS_ALL_HOSTS, &sock, 80))
        return;

    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsSuspend (cluster, WLBS_ALL_HOSTS, response, &num_host);
    verify_return_value (_TEXT("Suspend after DrainStop with active connection"), WLBS_OK, status1);

    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsQuery (cluster, WLBS_ALL_HOSTS, response, &num_host, &host_map, NULL);
    verify_return_value (_TEXT("Suspend after DrainStop with active connection"), WLBS_SUSPENDED, status1);

    closesocket (sock);

    if (!GetDrainstopState (cluster, WLBS_ALL_HOSTS, &sock, 80))
        return;

    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsResume (cluster, WLBS_ALL_HOSTS, response, &num_host);
    verify_return_value (_TEXT("Resume on DrainStop with active connection"), WLBS_OK, status1);

    closesocket (sock); /* close the connection */

    Sleep (10000); /* Wait for the host to figure out that all the connections have terminated */
    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsQuery (cluster, WLBS_ALL_HOSTS, response, &num_host, &host_map, NULL);
    verify_return_value (_TEXT("Query after DrainStop with closed connection"), WLBS_STOPPED, status1);

    /* issue a cluster-wide start to bring back all the hosts to the converged state.*/
    num_host = WLBS_MAX_HOSTS;
    status1 = WlbsStart (cluster, WLBS_ALL_HOSTS, response, &num_host);
    verify_return_value (_TEXT("Cluster-wide start to restore original state"), WLBS_OK, status1);

    Sleep (10000); /* Wait for the cluster to converge */
    return;
}


void check_cluster_operations ( )
{
    DWORD cluster = 0;

    if (local_test)
    {
        if (global_init = WLBS_PRESENT)
        {
            WLBS_REG_PARAMS reg_data;
            DWORD status;

            status = WlbsReadReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, &reg_data);
            if (status != WLBS_OK)
            {
                printf("Unable to read from the registry to set the password\nAborting cluster checks\n");
                return;
            }

            WlbsCodeSet (WlbsGetLocalClusterAddress (), reg_data . i_rct_password );
            WlbsTimeoutSet (WlbsGetLocalClusterAddress (), timeout);
            if (GetClusterToConvergedState (WLBS_LOCAL_CLUSTER))
            {
                cluster_parameter_test (WLBS_LOCAL_CLUSTER);
                cluster_state_changes (WLBS_LOCAL_CLUSTER);
            }
            else
            {
                add_error (_TEXT("Unable to get the local cluster to the converged state"));
            }
        }
    }

    if (!remote_test)
        return;

    WlbsPasswordSet (remote_cl_ip, remote_password);
    WlbsTimeoutSet (remote_cl_ip, timeout);
    if ( GetClusterToConvergedState (remote_cl_ip))
    {
        cluster_parameter_test (remote_cl_ip);
        cluster_state_changes (remote_cl_ip);
    }
    else
        add_error (_TEXT("Unable to get the remote cluster to the converged state"));

    return;
}


/* This function is used to find the first place where the 2 structures differ */
DWORD find_mem_change (PWLBS_REG_PARAMS data1, PWLBS_REG_PARAMS data2, DWORD size)
{
    DWORD i;

    printf("size of dword %d\n", sizeof (DWORD));
    for (i = 4; i < size ; i += 4)
    {
        if (memcmp (data1, data2, i))
            return i;
    }
    return 0;
}


void check_rules_in_structure (PWLBS_REG_PARAMS reg_data)
{
    DWORD i;

    printf("the number of rules is %d\n", reg_data -> i_num_rules);
    for (i = 0 ; i < WLBS_MAX_RULES; i++)
    {
        if (reg_data -> i_port_rules [i] . i_valid)
        {
            printf("\tFound valid port rule %d with start port %d ep %d\n", i,
                   reg_data -> i_port_rules [i] . start_port,
                   reg_data -> i_port_rules [i] . end_port);
        }
    }
    return;
}


/* This function tests the reads and writes to the registry */
void check_registry_rw ()
{
    WLBS_REG_PARAMS saved;
    WLBS_REG_PARAMS newdata;
    WLBS_REG_PARAMS temp;
    DWORD status;


    if (global_init == WLBS_REMOTE_ONLY || global_init == WLBS_INIT_ERROR)
    {
        add_error (_TEXT("Cannot check registry rw since wlbs is not installed"));
        return;
    }

    /* parameter testing */
    _stprintf (status_buf, _TEXT("Parameter Test for ReadReg and WriteReg"));
    status = WlbsReadReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, NULL);
    verify_return_value (_TEXT("ReadReg with null regdata"), WLBS_BAD_PARAMS, status);
    
    status = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, NULL);
    verify_return_value (_TEXT("WriteReg with null regdata"), WLBS_BAD_PARAMS, status);

    status = WlbsReadReg (12, WLBS_LOCAL_HOST, & saved);
    verify_return_value (_TEXT("ReadReg on remote cluster"), WLBS_LOCAL_ONLY, status);

    status = WlbsWriteReg (12, WLBS_LOCAL_HOST, & saved);
    verify_return_value (_TEXT("WriteReg on remote cluster"), WLBS_LOCAL_ONLY, status);

    status = WlbsReadReg (WLBS_LOCAL_CLUSTER, 10, & saved);
    verify_return_value (_TEXT("ReadReg on remote host"), WLBS_LOCAL_ONLY, status);

    status = WlbsWriteReg (WLBS_LOCAL_CLUSTER, 10, & saved);
    verify_return_value (_TEXT("WriteReg on remote host"), WLBS_LOCAL_ONLY, status);

    /* now test the actual working of read and write reg */

    _stprintf (status_buf, _TEXT("Testing ReadReg and WriteReg for correctness"));
    
    status = WlbsReadReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, & saved);
    verify_return_value (_TEXT("ReadReg"), WLBS_OK, status);

    /* The following memset is to avoid any spurious differences */
    memset (&newdata, 0, sizeof (WLBS_REG_PARAMS));

    /* Fill in the structure with valid values */
    newdata . alive_period = saved . alive_period + 1;
    newdata . alive_tolerance = saved . alive_tolerance + 1;
    _tcscpy (newdata . cl_ip_addr, _TEXT("111.222.111.222"));
    _tcscpy (newdata . cl_mac_addr, _TEXT("11-22-33-44-55-66"));
    _tcscpy (newdata . cl_net_mask, _TEXT("255.255.255.0"));
    newdata . cluster_mode = FALSE;
    _tcscpy (newdata . ded_ip_addr, _TEXT("111.222.111.233"));
    _tcscpy (newdata . ded_net_mask, _TEXT("255.255.255.0"));
    _tcscpy (newdata . domain_name, _TEXT("TESTDOMAINNAME"));
    newdata . dscr_per_alloc = 1024;
    newdata . host_priority = saved . host_priority + 1;
    newdata . i_cleanup_delay = 3600;
    _tcscpy (newdata . i_cluster_nic_name, saved . i_cluster_nic_name); /* This is for read-only */
    newdata . i_convert_mac = FALSE;
    newdata . i_expiration = 0;
    newdata . i_ft_rules_enabled = TRUE;
    newdata . i_ip_chg_delay = saved . i_ip_chg_delay + 1;
    _tcscpy (newdata . i_license_key, _TEXT("JUNKLICENSEKEY"));
    newdata . i_max_hosts = LICENSE_MAX_HOSTS;
    newdata . i_max_rules = LICENSE_RULES;
    newdata . i_mcast_spoof = FALSE;
    newdata . i_num_rules = 0;
    newdata . i_parms_ver = saved . i_parms_ver;
    memset ( newdata . i_port_rules, 0, sizeof (WLBS_PORT_RULE) * WLBS_MAX_RULES);
    newdata . i_rct_password = 23445;
    newdata . i_rmt_password = 98765;
    newdata . i_scale_client = 10;
    newdata . i_verify_date  = 0;
    newdata . i_version = 0;
    _tcscpy (newdata . i_virtual_nic_name, _TEXT("TEMP_VIRTUAL_NIC_NAME"));
    newdata . install_date = 50000;
    newdata . mask_src_mac = FALSE;
    newdata . max_dscr_allocs = 1024;
    newdata . mcast_support = FALSE;
    newdata . i_nbt_support = FALSE;
    newdata . num_actions = saved . num_actions + 1;
    newdata . num_packets = saved . num_packets + 1;
    newdata . num_send_msgs = saved . num_send_msgs + 1;
    newdata . rct_enabled = FALSE;
    newdata . rct_port = 2000;


    status = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, & newdata);
    verify_return_value (_TEXT("WriteReg"), WLBS_OK, status);

    memset (&temp, 0, sizeof (WLBS_REG_PARAMS));

    status = WlbsReadReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, & temp);
    verify_return_value (_TEXT("ReadReg after a write"), WLBS_OK, status);

    memset ( temp . i_port_rules, 0, sizeof (WLBS_PORT_RULE) * WLBS_MAX_RULES);
    if (memcmp(&temp, &newdata, sizeof (WLBS_REG_PARAMS)))
    {
        _stprintf (tbuf, _TEXT("1:The data written and the data read back differ in the location %d\n"),
                   find_mem_change (&newdata, &temp, sizeof (WLBS_REG_PARAMS)) );
        add_error (tbuf);
    }

    /* restore the original status of the registry */
    status = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, & saved);
    verify_return_value (_TEXT("WriteReg to restore original state"), WLBS_OK, status);

    status = WlbsReadReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, & newdata);
    verify_return_value (_TEXT("ReadReg"), WLBS_OK, status);

    newdata . i_convert_mac = FALSE;
    newdata . mcast_support = FALSE;
    _tcscpy (newdata . cl_mac_addr, _TEXT("11-22-33-44-55-66"));

    status = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, & newdata);
    verify_return_value (_TEXT("WriteReg with convertmac = false; mcast = false"), WLBS_OK, status);

    status = WlbsReadReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, & temp);
    verify_return_value (_TEXT("ReadReg with convertmac = false; mcast = false"), WLBS_OK, status);

    if (memcmp (&temp, &newdata, sizeof (WLBS_REG_PARAMS)) )
    {
        _stprintf (tbuf, _TEXT("2:The data written and the data read back differ in the location %d\n"),
                   find_mem_change (&newdata, &temp, sizeof (WLBS_REG_PARAMS)) );
        add_error (tbuf);
    }

    newdata . i_convert_mac = TRUE;
    newdata . mcast_support = FALSE;

    status = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, & newdata);
    verify_return_value (_TEXT("WriteReg with convertmac = true; mcast = false"), WLBS_OK, status);

    status = WlbsReadReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, & temp);
    if ( _tcsnicmp(_TEXT("02-bf"), temp . cl_mac_addr, _tcslen(_TEXT("02-bf")) ) )
    {
        _stprintf (tbuf, _TEXT("Error in converting mac address in the unicast mode"));
        add_error (tbuf);
    }

    newdata . mcast_support = TRUE;
    status = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, & newdata);
    verify_return_value (_TEXT("WriteReg with convertmac = true; mcast = true"), WLBS_OK, status);

    status = WlbsReadReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, & temp);

    if ( _tcsnicmp (_TEXT("03-bf"), temp . cl_mac_addr, _tcslen(_TEXT("03-bf")) ))
    {
        _stprintf (tbuf, _TEXT("Error in converting mac address in the multicast mode"));
        add_error (tbuf);
    }

    /* These tests are to verify that parameter checking in WlbsWriteReg is o.k. */

    newdata . host_priority = CVY_MIN_PRIORITY - 1;
    status = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, &newdata);
    verify_return_value (_TEXT("WriteReg with host priority = 0"), WLBS_BAD_PARAMS, status);

    newdata . host_priority = CVY_MAX_PRIORITY + 1;
    status = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, &newdata);
    verify_return_value (_TEXT("WriteReg with host priority = 33"), WLBS_BAD_PARAMS, status);
    newdata . host_priority = saved . host_priority;

    newdata . rct_port = CVY_MIN_RCT_PORT - 1;
    status = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, &newdata);
    verify_return_value (_TEXT("WriteReg with RCT port = 0"), WLBS_BAD_PARAMS, status);

    newdata . rct_port = CVY_MAX_RCT_PORT + 1;
    status = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, &newdata);
    verify_return_value (_TEXT("WriteReg with RCT port = 65536"), WLBS_BAD_PARAMS, status);
    newdata . rct_port = saved . rct_port;

    newdata . i_num_rules = CVY_MAX_NUM_RULES + 1;
    status = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, &newdata);
    verify_return_value (_TEXT("WriteReg with num_rules = 33"), WLBS_BAD_PARAMS, status);
    newdata . i_num_rules = saved . i_num_rules;

    newdata . i_convert_mac = FALSE;
    _tcscpy (newdata . ded_ip_addr, _TEXT("0.0.0.0"));
    _tcscpy (newdata . cl_ip_addr, _TEXT("0.0.0.0"));
    _tcscpy (newdata . ded_net_mask, _TEXT("0.0.0.0"));
    _tcscpy (newdata . cl_net_mask, _TEXT("0.0.0.0"));
    _tcscpy (newdata . cl_mac_addr, _TEXT("00-11-22-33-44-AA"));
    status = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, &newdata);
    verify_return_value (_TEXT("WriteReg with all ip addresses = 0"), WLBS_OK, status);

    _tcscpy (newdata . cl_mac_addr, _TEXT("0g-11-hh-jj-kk-ll"));
    status = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, &newdata);
    verify_return_value (_TEXT("WriteReg with cl mac addr = 0g-11-hh-jj-kk-ll"), WLBS_BAD_PARAMS, status);
    _tcscpy (newdata . cl_mac_addr, _TEXT("00-11-22-33-44-AA"));

    _tcscpy (newdata . cl_mac_addr, _TEXT("00-11-22-33-44-5G"));
    status = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, &newdata);
    verify_return_value (_TEXT("WriteReg with cl mac addr = 00-11-22-33-44-5G"), WLBS_BAD_PARAMS, status);
    _tcscpy (newdata . cl_mac_addr, _TEXT("00-11-22-33-44-AA"));

    _tcscpy (newdata . ded_net_mask, _TEXT("333.222.222.222"));
    status = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, &newdata);
    verify_return_value (_TEXT("WriteReg with ded ip mask = 333.222.222.222"), WLBS_BAD_PARAMS, status);
    _tcscpy (newdata . ded_net_mask, _TEXT("0.0.0.0"));

    _tcscpy (newdata . ded_ip_addr, _TEXT("333.222.222.222"));
    status = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, &newdata);
    verify_return_value (_TEXT("WriteReg with ded ip addr = 333.222.222.222"), WLBS_BAD_PARAMS, status);
    _tcscpy (newdata . ded_ip_addr, _TEXT("0.0.0.0"));

    _tcscpy (newdata . cl_net_mask, _TEXT("333.222.222.222"));
    status = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, &newdata);
    verify_return_value (_TEXT("WriteReg with cl ip mask = 333.222.222.222"), WLBS_BAD_PARAMS, status);
    _tcscpy (newdata . cl_net_mask, _TEXT("0.0.0.0"));

    _tcscpy (newdata . cl_ip_addr, _TEXT("333.222.222.222"));
    status = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, &newdata);
    verify_return_value (_TEXT("WriteReg with cl ip addr = 333.222.222.222"), WLBS_BAD_PARAMS, status);
    _tcscpy (newdata . cl_ip_addr, _TEXT("0.0.0.0"));


    /* Restore the initial state */
    status = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, & saved);
    status = WlbsCommitChanges (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST);
    return;
}


/* This function verifies the commit functionality.
 * It writes a new priority to the registry and commits it.
 * A local query is made. The host id is checked to see that the commit has
 * indeed forced the driver to load the new host id.
 * This may cause the cluster (in case of multiple hosts) to go into convergence
 * if the id is duplicated .....
 */

void verify_host_id_changes (PWLBS_REG_PARAMS reg_data, DWORD old_priority, DWORD new_priority)
{
    DWORD status;
    DWORD num_host, host_map;
    WLBS_RESPONSE response;


    reg_data -> host_priority = new_priority;
    status = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, reg_data);
    status = WlbsCommitChanges (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST);
    verify_return_value (_TEXT("Commit after changing host priority"), WLBS_OK, status);
    num_host = 1;
    status = WlbsQuery (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, &response, &num_host, &host_map, NULL);

    /* Hope that Query does not return any winsock error ... */
    verify_return_value (_TEXT("Verifying the host priority after commit"),
                         new_priority,
                         response . id);

    return;
}


/* This function changes only the cluster and dedicated ip addresses and verifies them */
void verify_ip_address_changes (PWLBS_REG_PARAMS reg_data, PTCHAR cl_ip_addr, PTCHAR ded_ip_addr)
{
    DWORD status;

    _tcscpy ( reg_data -> cl_ip_addr,  cl_ip_addr);
    _tcscpy ( reg_data -> ded_ip_addr, ded_ip_addr);
    reg_data -> i_convert_mac = FALSE; /* So that the mac address does not change */

    status = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, reg_data);
    status = WlbsCommitChanges (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST);
    /* Both nt4 and nt5 should return WLBS_OK.
     * Reboot should not be returned since the mac address is not changed.
     */
    verify_return_value (_TEXT("Commit after changing ip addresses"), WLBS_OK, status);

    verify_return_value (_TEXT("Verify Changed Cluster IP Address"),
                         WlbsResolve (cl_ip_addr),
                         WlbsGetLocalClusterAddress());

    verify_return_value (_TEXT("Verify Changed Cluster IP Address"),
                         WlbsResolve (ded_ip_addr),
                         WlbsGetDedicatedAddress());

    return;
}


/* This function verifies that the mac address is as specified in the registry structure.
 * It uses IP helper functions to get the mac address from the adapters.
 * It firsts lists all the adapters and verifies that the address on one of those
 * matches that in the registry.
 * This function will not work on NT4 machines since NT4 does not support some
 * IP helper functions.
 */
void verify_mac_address (PWLBS_REG_PARAMS reg_data)
{
    IP_ADAPTER_INFO *padapter_info = NULL, *temp_adapter_info = NULL;
    ULONG size;
    DWORD status;
    BOOL found = FALSE;
    CHAR AddressFromReg [CVY_MAX_NETWORK_ADDR + 1];
    CHAR AddressFromIPHelper [CVY_MAX_NETWORK_ADDR + 1];
    DWORD i;
    DWORD num_interfaces = 0;


    Sleep (30000); /* Wait for the driver to finish reloading and then check */

#ifdef UNICODE
    sprintf (AddressFromReg, "%ls", reg_data -> cl_mac_addr);
#else
    sprintf (AddressFromReg, "%s",  reg_data -> cl_mac_addr);
#endif

    status = GetNumberOfInterfaces (&num_interfaces);
    if (status != NO_ERROR)
    {
        printf("Unable to find any network interfaces on the local computer\nAborting the test\n");
        return;
    }

    size = sizeof (IP_ADAPTER_INFO) * num_interfaces;
    padapter_info = (IP_ADAPTER_INFO *) malloc (size);
    if (padapter_info == NULL)
        return;

    for (i = 0 ; i < num_interfaces; i++)
        padapter_info [i] . Next = NULL;

    status = GetAdaptersInfo (padapter_info, & size);
    if (status != ERROR_SUCCESS)
    {
        printf("Unable to Get Adapter Info. Cannot verify mac address.\n");
        switch (status)
        {
        case ERROR_BUFFER_OVERFLOW : printf ("Required buffer size is %d\n", size);
            break;

        case ERROR_INVALID_PARAMETER : printf ("Invalid parameter\n");
            break;

        case ERROR_NO_DATA : printf ("No Adapter Information\n");
            break;

        case ERROR_NOT_SUPPORTED : printf ("Error not supported");
            break;

        default:
            break;
        }
        return;
    }

    temp_adapter_info = padapter_info;
    while (padapter_info)
    {
        sprintf (AddressFromIPHelper, "%02x-%02x-%02x-%02x-%02x-%02x",
                 padapter_info -> Address [0],
                 padapter_info -> Address [1],
                 padapter_info -> Address [2],
                 padapter_info -> Address [3],
                 padapter_info -> Address [4],
                 padapter_info -> Address [5]);

        if (_stricmp (AddressFromIPHelper, AddressFromReg) == 0)
        {
            found = TRUE;
            break;
        }
        padapter_info = padapter_info -> Next;
    }

    /* Free the allocated memory */
    while (temp_adapter_info)
    {
        padapter_info = temp_adapter_info;
        temp_adapter_info = temp_adapter_info -> Next;
        free (padapter_info);
    }

    if (!found && !reg_data -> mcast_support)
    {
        add_error (_TEXT("In unicast mode, the registry mac address does not match the adapter mac address\n"));
        return;
    }

    if (found && reg_data -> mcast_support)
    {
        add_error (_TEXT("In multicast mode, the registry mac address was written to the NIC"));
        return;
    }
    /* If mac address is generated by converting the ip address,
     * then verify that the conversion takes place
     */
    if (reg_data -> i_convert_mac)
    {
        if (!reg_data -> mcast_support)
            if (_strnicmp (AddressFromIPHelper, "02-bf", strlen ("02-bf")) )
                add_error (_TEXT("Generation of MAC address in unicast mode failed"));
    }

    return;
}



/* This function checks the working of commit api. */
void check_commit (DWORD entry_point)
{

    WLBS_REG_PARAMS saved, newdata, temp_data;
    DWORD status;
    WLBS_RESPONSE response;
    DWORD num_host, host_map;
    DWORD old_priority, new_priority;


    _stprintf (status_buf, _TEXT("Checking Commit"));
    if (global_init == WLBS_REMOTE_ONLY || global_init == WLBS_INIT_ERROR)
    {
        _stprintf (tbuf, _TEXT("%s Unable to Perform Commit checks"), status_buf);
        add_error(tbuf);
        return;
    }

    /* Save the original configuration */
    status = WlbsReadReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, &saved);
    if (status != WLBS_OK)
    {
        _stprintf(tbuf, _TEXT("%s Unable to save the original configuration. Aborting the tests\n"), status_buf);
        add_error (tbuf);
        return;
    }

    status = WlbsReadReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, &newdata);

    /* This is because commit returns reboot in nt4 on a commit when the mac address changes. */
    if (version_nt4)
    {
        if (entry_point == 1)
        {
            _tprintf(_TEXT("Use ipconfig to ensure that the mac address is %s\n"), newdata . cl_mac_addr);
            goto mac_addr_change1;
        }
        else if (entry_point == 2)
        {
            _tprintf(_TEXT("Use ipconfig to ensure that the mac address is %s\n"), newdata . cl_mac_addr);
            goto mac_addr_change2;
        }
        else if (entry_point == 3)
        {
            _tprintf(_TEXT("Use ipconfig to ensure that the mac address is the manufacturer specified one.\n"));
            goto mac_addr_change3;
        }
        else if (entry_point == 4)
        {
            _tprintf(_TEXT("Use ipconfig to ensure that the mac address is the manufacturer specified one.\n"));
            _tprintf(_TEXT("Please note that the cluster IP address has been changed by this test.\nPlease reset the cluster settings\n"));
            return;
        }
    }

    /* Write without any changes */
    status = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, &newdata);
    status = WlbsCommitChanges (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST);
    verify_return_value (_TEXT("Commit without any changes"), WLBS_OK, status);

    /* Change only the host priority and verify that query returns the correct priority */
    old_priority = newdata . host_priority;
    new_priority = newdata . host_priority + 1; /* Could cause the cluster to stop operations */
    if (new_priority > CVY_MAX_HOST_PRIORITY)
        new_priority = 1;

    verify_host_id_changes ( &newdata, old_priority, new_priority);

    /* Change back to the original value and verify */
    verify_host_id_changes ( &newdata, new_priority, old_priority);

    /* Verify changes in the ip addresses */
    verify_ip_address_changes ( &newdata, _TEXT("111.111.111.111"), _TEXT("222.222.222.222"));

    /* Restore the original addresses and verify */
    verify_ip_address_changes ( &newdata, saved . cl_ip_addr, saved . ded_ip_addr);

    /* Now verify mac address changes */
    newdata . i_convert_mac = FALSE;
    newdata . mcast_support = FALSE;
    _stprintf (newdata . cl_mac_addr, _TEXT("00-12-34-56-78-9a"));
    status = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, &newdata);
    status = WlbsCommitChanges (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST);

    if (!version_nt4)
    {
        verify_return_value (_TEXT("Changing mac address 1"), WLBS_OK, status);
        status = WlbsReadReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, &temp_data);
        verify_mac_address (&temp_data);
    }
    else
    {
        verify_return_value (_TEXT("Changing mac address 1"), WLBS_REBOOT, status);
        printf("\n");
        print_error_messages ();
        printf("Total number of tests: %d Failed Tests: %d\n", total_tests, failed_tests);
        printf("Please reboot the machine and start the test as \n wlbsapitest reboot 1");
        exit (1);
    }

mac_addr_change1:
    /* When convert mac is true and mcast support is false */
    newdata . i_convert_mac = TRUE;
    newdata . mcast_support = FALSE;
    _stprintf (newdata . cl_mac_addr, _TEXT("00-12-34-56-78-9a"));
    status = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, &newdata);
    status = WlbsCommitChanges (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST);

    if (!version_nt4)
    {
        verify_return_value (_TEXT("Changing mac address 2"), WLBS_OK, status);
        status = WlbsReadReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, &temp_data);
        verify_mac_address (&temp_data);
    }
    else
    {
        verify_return_value (_TEXT("Changing mac address 2"), WLBS_REBOOT, status);
        printf("\n");
        print_error_messages ();
        printf("Total number of tests: %d Failed Tests: %d\n", total_tests, failed_tests);
        printf("Please reboot the machine and start the test as \n wlbsapitest reboot 2");
        exit (1);
    }

mac_addr_change2:
    /* When convertmac is true and mcast_support is also true */
    newdata . i_convert_mac = TRUE;
    newdata . mcast_support = TRUE;
    status = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, &newdata);
    status = WlbsCommitChanges (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST);

    if (!version_nt4)
    {
        verify_return_value (_TEXT("Changing mac address 3"), WLBS_OK, status);
        status = WlbsReadReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, &temp_data);
        verify_mac_address (&temp_data);
    }
    else
    {

        verify_return_value (_TEXT("Changing mac address 3"), WLBS_REBOOT, status);
        printf("\n");
        print_error_messages ();
        printf("Total number of tests: %d Failed Tests: %d\n", total_tests, failed_tests);
        printf("Please reboot the machine and start the test as \n wlbsapitest reboot 3");
        exit (1);
    }

mac_addr_change3:

    /* Add a test to change the cluster ip address in multicast mode with convertmac set to true
     * and verify that ipconfig does not display this multicast mac address.
     */

    _tcscpy (newdata . cl_ip_addr, _TEXT("111.222.111.222"));
    status = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, &newdata);
    status = WlbsCommitChanges (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST);

    if (!version_nt4)
    {
        verify_return_value (_TEXT("Changing mac address 4"), WLBS_OK, status);
        status = WlbsReadReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, &temp_data);
        verify_mac_address (&temp_data);
    }
    else
    {

        verify_return_value (_TEXT("Changing mac address 4"), WLBS_REBOOT, status);
        printf("\n");
        print_error_messages ();
        printf("Total number of tests: %d Failed Tests: %d\n", total_tests, failed_tests);
        printf("Please reboot the machine and start the test as \n wlbsapitest reboot 4");
        exit (1);
    }



    /* restore the original state */
    if (entry_point == 0)
    {
        status = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, &saved);
        status = WlbsCommitChanges (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST);
    }

    return;
}


/* This function performs the parameter tests for the port rule APIs.
 * This includes passing NULL parameters, invalid parameters ...
 */
void port_rule_parameter_test (PWLBS_REG_PARAMS reg_data)
{
    DWORD status;
    PWLBS_PORT_RULE rules;
    WLBS_PORT_RULE rule1, rule2;
    DWORD num_rules1, num_rules2;

    _stprintf (status_buf, _TEXT("Port Rule APIs Parameter Test"));

    status = WlbsGetNumPortRules (NULL);
    verify_return_value (_TEXT("GetNumPortRules"), WLBS_BAD_PARAMS, status);

    status = WlbsEnumPortRules (NULL, NULL, NULL);
    verify_return_value (_TEXT("EnumPortRules"), WLBS_BAD_PARAMS, status);

    status = WlbsEnumPortRules (reg_data, NULL, NULL);
    verify_return_value (_TEXT("EnumPortRules"), WLBS_BAD_PARAMS, status);

    /* find the number of rules through both EnumPortRules as well as through GetNumPortRules
     * Verify that both return the same number of rules
     */
    num_rules1 = 0;
    status = WlbsEnumPortRules (reg_data, NULL, &num_rules1);
    verify_return_value (_TEXT("EnumPortRules"), WLBS_TRUNCATED, status);
    num_rules2 = WlbsGetNumPortRules (reg_data);
    verify_return_value (_TEXT("EnumPortRules and GetNumPortRules"), num_rules2, num_rules1);

    status = WlbsGetPortRule (NULL, 80, NULL);
    verify_return_value (_TEXT("GetPortRule with regdata null"), WLBS_BAD_PARAMS, status);

    status = WlbsGetPortRule (reg_data, 80, NULL);
    verify_return_value (_TEXT("GetPortRule with port_rule null"), WLBS_BAD_PARAMS, status);

    status = WlbsGetPortRule (reg_data, CVY_MAX_PORT + 1, &rule1);
    verify_return_value (_TEXT("GetPortRule with invalid port"), WLBS_BAD_PARAMS, status);

    status = WlbsAddPortRule (NULL, NULL);
    verify_return_value (_TEXT("AddPortRule with regdata null"), WLBS_BAD_PARAMS, status);
    
    status = WlbsAddPortRule (reg_data, NULL);
    verify_return_value (_TEXT("AddPortRule with port_rule null"), WLBS_BAD_PARAMS, status);

    status = WlbsDeletePortRule (NULL, 80);
    verify_return_value (_TEXT("DeletePortRule with regdata null"), WLBS_BAD_PARAMS, status);

    status = WlbsDeletePortRule (reg_data, CVY_MAX_PORT + 1);
    verify_return_value (_TEXT("DeletePortRule with invalid port number"), WLBS_BAD_PARAMS, status);

    return;
}


/* This function deletes all the existing port rules in the reg_params structure.
 * This helps in starting off from a known state.
 */
void delete_all_rules ( PWLBS_REG_PARAMS reg_data )
{
    WLBS_PORT_RULE rules [WLBS_MAX_RULES];
    DWORD num_rules;
    DWORD i;

    num_rules = WLBS_MAX_RULES;
    WlbsEnumPortRules ( reg_data, rules, & num_rules );

    for (i = 0 ; i < num_rules ; i++)
        WlbsDeletePortRule ( reg_data, rules [i] . start_port );

    return;
}


/* This function generates num_rules number of valid and non-ovelapping port rules
 * and returns it in the rules array
 */
void generate_valid_rules ( PWLBS_PORT_RULE rules, DWORD num_rules, DWORD range )
{

    DWORD i;
    static DWORD pri = 0;

    for (i = 0 ; i < num_rules ; i++)
    {
        rules [i] . start_port = i * range;
        rules [i] . end_port = rules [i] . start_port + range - 1;
        rules [i] . mode = (pri++) % CVY_MAX_MODE + 1;
        rules [i] . protocol = (pri++) % CVY_MAX_PROTOCOL + 1;
        

        if (rules [i] . mode == WLBS_SINGLE)
            rules [i] . mode_data . single . priority =  (pri++) % (WLBS_MAX_HOSTS) + 1;

        if (rules [i] . mode == WLBS_MULTI)
        {
            rules [i] . mode_data . multi . affinity = (WORD) ((pri++) % (CVY_MAX_AFFINITY + 1));
            rules [i] . mode_data . multi . equal_load = (WORD) ((pri++) % 2);
            rules [i] . mode_data . multi . load = (WORD) ((pri++) % (CVY_MAX_LOAD + 1));
        }
    }
    return;
}


/* Verify that the rules returned by Enum are in sorted order */
BOOL verify_enum_port_rules (PWLBS_PORT_RULE rules, DWORD num_rules)
{
    DWORD i;

    if (num_rules == 0)
        return TRUE;

    for (i = 0 ; i < num_rules - 1; i++)
    {
        if (rules [i] . start_port >= rules [i + 1] . start_port)
            return FALSE;
    }

    return TRUE;
}


/* Check that add and delete apis work fine. Verify this through calls to GetNum, Enum, GetPort */
void check_add_delete_port_rules (PWLBS_REG_PARAMS reg_data,
                                  PWLBS_PORT_RULE rule_list,
                                  DWORD num_rules,
                                  DWORD range)
{
    DWORD status;
    DWORD num_rules1, num_rules2;
    WLBS_PORT_RULE rule, rules [WLBS_MAX_RULES];
    DWORD i, j, port;

    /* First check the addportrule functionality.
     * After adding each rule, check that GetNumPortRules returns the correct value.
     * Verify that EnumPortRules also returns the correct number of rules
     */
    for (i = 0 ; i < WLBS_MAX_RULES ; i++)
    {
        j = (i * range) % num_rules;
        status = WlbsAddPortRule (reg_data, &rule_list [j] );
        verify_return_value (_TEXT("AddPortRule"), WLBS_OK, status);

        num_rules1 = WlbsGetNumPortRules (reg_data);
        verify_return_value (_TEXT("GetNumPortRules"), i+1, num_rules1);

        num_rules2 = WLBS_MAX_RULES;
        status = WlbsEnumPortRules (reg_data, rules, &num_rules2);
        verify_return_value (_TEXT("EnumPortRules"), WLBS_OK, status);
        verify_return_value (_TEXT("EnumPortRules and GetNum"), num_rules1, num_rules2);

        if (!verify_enum_port_rules (rules, num_rules2))
        {
            add_error (_TEXT("Error in Verifying EnumPortRules. Aborting tests"));
            return;
        }

        /* Verify that GetPortRule returns the correct port rule that was added 
         * Do a GetPortRule on the start port, the end port as well as on any port
         * number in between.
         */
        if (j%3 == 0)
            port = rule_list [j] . start_port;
        else if (j%3 == 1)
            port = rule_list [j] . end_port;
        else
            port = (rule_list [j] . start_port + rule_list [j] . end_port)/2;
    
        status = WlbsGetPortRule (reg_data, port, & rule);
        verify_return_value (_TEXT("GetPortRule"), WLBS_OK, status);

        /* These two fields are set when the rule is added */
        rule_list [j] . i_valid = rule . i_valid;
        rule_list [j] . i_code  = rule . i_code;

        if (memcmp (&rule, &rule_list [j], sizeof (WLBS_PORT_RULE)) )
            add_error (_TEXT("Port rule that was added is changed when retrieved"));
    }

    /* Now there is no space for any further rules.
     * Try to add the remaining rules.
     * WlbsAddPortRule should return WLBS_MAX_PORT_RULES each time.
     * Also, get port rule should return WLBS_NOT_FOUND
     */
    for (i = WLBS_MAX_RULES; i < num_rules; i++)
    {
        j = (i * range) % num_rules;
        
        status = WlbsAddPortRule (reg_data, & rule_list [j]);
        verify_return_value (_TEXT("AddPortRule more than 32 rules"), WLBS_MAX_PORT_RULES, status);

        port = rule_list [j] . start_port;
        status = WlbsGetPortRule (reg_data, port, &rule);
        verify_return_value (_TEXT("GetPortRule non-existent rule"), WLBS_NOT_FOUND, status);

        verify_return_value (_TEXT("GetNumPortRules when max rules"), WLBS_MAX_RULES,
                             WlbsGetNumPortRules(reg_data));
    }

    /* Test delete functionality.
     * Pass the start port, end port or any intermediate port number as input.
     * Verify that the port rule has indeed been deleted by checking GetNumPortRules,
     * EnumPortRules as well GetPortRule
     */
    for (i = 0 ; i < WLBS_MAX_RULES; i ++)
    {
        j = (i * range) % num_rules;

        if (j%3 == 0)
            port = rule_list [j] . start_port;
        else if (j%3 == 1)
            port = rule_list [j] . end_port;
        else
            port = (rule_list [j] . start_port + rule_list [j] . end_port) / 2;

        status = WlbsDeletePortRule (reg_data, port);
        verify_return_value (_TEXT("DeletePortRule"), WLBS_OK, status);

        num_rules1 = WlbsGetNumPortRules (reg_data);
        verify_return_value (_TEXT("GetNumPortRules after deleting"), WLBS_MAX_RULES - i - 1, num_rules1);

        num_rules2 = WLBS_MAX_RULES;
        status = WlbsEnumPortRules (reg_data, rules, &num_rules2);
        verify_return_value (_TEXT("EnumPortRules after deleting"), WLBS_OK, status);
        verify_return_value (_TEXT("EnumPortRules and GetNum after deleting"), num_rules1, num_rules2);

        if (!verify_enum_port_rules (rules, num_rules2))
        {
            add_error (_TEXT("Error in Verifying EnumPortRules. Aborting tests"));
            return;
        }

        status = WlbsGetPortRule (reg_data, port, & rule);
        verify_return_value (_TEXT("GetPortRule after deleting"), WLBS_NOT_FOUND, status);
    }

    /* Try to delete the remaining rules. WLBS_NOT_FOUND should be returned in all cases.
     * Also, GetNumPortRules should return 0 always */
    for (i = WLBS_MAX_RULES; i < num_rules; i++)
    {
        j = (i * range) % num_rules;
        status = WlbsDeletePortRule (reg_data, rule_list [j] . start_port);
        verify_return_value (_TEXT("DeletePortRule on empty rule list"), WLBS_NOT_FOUND, status);
        verify_return_value (_TEXT("GetNumPortRules on empty rule list"), 0,
                             WlbsGetNumPortRules(reg_data));
    }

    return;
}


void port_rule_functional_test (PWLBS_REG_PARAMS reg_data)
{
#define MAX_RULES 50

    WLBS_PORT_RULE rule1, rule2, rule_list1 [MAX_RULES], rule_list2 [WLBS_MAX_RULES];
    DWORD status1, status2;
    DWORD num_rules1, num_rules2;

    /* Delete all the existing rules. Add invalid rules and check that the error is detected.
     * Add new rules in both sorted and unsorted order and then do an enum to verify that
     * the rules get sorted. Verify that GetNumPortRules returns the correct value each time.
     * Delete the rules in random order and also in sorted order. Verify that the rule is
     * indeed deleted. Also, verify that enum returns all the rules in sorted order.
     */
    delete_all_rules (reg_data);
    generate_valid_rules (rule_list1, MAX_RULES, 500);

    rule1 = rule_list1 [0];
    /* First, try adding invalid rules. The return value should be WLBS_BAD_PORT_PARAMS */
    /* The invalid cases are listed in the apitest.c file */

    /* start port > end port */
    rule1 . start_port = rule1 . end_port + 1;
    status1 = WlbsAddPortRule (reg_data, &rule1);
    verify_return_value (_TEXT("AddPortRule sp > ep"), WLBS_BAD_PORT_PARAMS, status1);

    /* invalid start port */
    rule1 . start_port = CVY_MAX_PORT + 1;
    rule1 . end_port = rule1 . start_port;
    status1 = WlbsAddPortRule (reg_data, &rule1);
    verify_return_value (_TEXT("AddPortRule sp > MAX_PORT"), WLBS_BAD_PORT_PARAMS, status1);

    /* invalid end port */
    rule1 . start_port = 80;
    rule1 . end_port = CVY_MAX_PORT + 1;
    status1 = WlbsAddPortRule (reg_data, &rule1);
    verify_return_value (_TEXT("AddPortRule sp = 80 ep > MAX_PORT"), WLBS_BAD_PORT_PARAMS, status1);

    /* invalid protocol */
    rule1 = rule_list1 [0];
    rule1 . protocol = CVY_MIN_PROTOCOL - 1;
    status1 = WlbsAddPortRule (reg_data, &rule1);
    verify_return_value (_TEXT("AddPortRule InvalidProtocol"), WLBS_BAD_PORT_PARAMS, status1);

    rule1 . protocol = CVY_MAX_PROTOCOL + 1;
    status1 = WlbsAddPortRule (reg_data, &rule1);
    verify_return_value (_TEXT("AddPortRule InvalidProtocol"), WLBS_BAD_PORT_PARAMS, status1);

    rule1 . protocol = CVY_MAX_PROTOCOL;
    /* invalid mode */
    rule1 . mode = CVY_MIN_MODE - 1;
    status1 = WlbsAddPortRule (reg_data, &rule1);
    verify_return_value (_TEXT("AddPortRule InvalidMode"), WLBS_BAD_PORT_PARAMS, status1);

    rule1 . mode = CVY_MAX_MODE + 1;
    status1 = WlbsAddPortRule (reg_data, &rule1);
    verify_return_value (_TEXT("AddPortRule InvalidMode"), WLBS_BAD_PORT_PARAMS, status1);

    /* invalid priority */
    rule1 . mode = CVY_SINGLE;
    rule1 . mode_data . single . priority = CVY_MIN_PRIORITY - 1;
    status1 = WlbsAddPortRule (reg_data, &rule1);
    verify_return_value (_TEXT("AddPortRule InvalidPriority"), WLBS_BAD_PORT_PARAMS, status1);

    rule1 . mode_data . single . priority = CVY_MAX_PRIORITY + 1;
    status1 = WlbsAddPortRule (reg_data, &rule1);
    verify_return_value (_TEXT("AddPortRule InvalidPriority"), WLBS_BAD_PORT_PARAMS, status1);

    /* invalid affinity */
    rule1 . mode = CVY_MULTI;
    rule1 . mode_data . multi . affinity = CVY_MAX_AFFINITY + 1;
    status1 = WlbsAddPortRule (reg_data, &rule1);
    verify_return_value (_TEXT("AddPortRule InvalidAffinity"), WLBS_BAD_PORT_PARAMS, status1);

    /* invalid equal load */
    rule1 . mode_data . multi . affinity = CVY_MAX_AFFINITY;
    rule1 . mode_data . multi . equal_load = CVY_MAX_EQUAL_LOAD + 1;
    status1 = WlbsAddPortRule (reg_data, &rule1);
    verify_return_value (_TEXT("AddPortRule InvalidEqualLoad"), WLBS_BAD_PORT_PARAMS, status1);

    /* invalid load */
    rule1 . mode_data . multi . equal_load = CVY_MIN_EQUAL_LOAD;
    rule1 . mode_data . multi . load = CVY_MAX_LOAD + 1;
    status1 = WlbsAddPortRule (reg_data, &rule1);
    verify_return_value (_TEXT("AddPortRule InvalidLoad"), WLBS_BAD_PORT_PARAMS, status1);

    /* add a valid rule and then test for overlapping rules
     * Test the different cases where overlapping can occur
     */
    rule1 = rule_list1 [1];
    status1 = WlbsAddPortRule (reg_data, &rule1);
    verify_return_value (_TEXT("AddPortRule ValidRule"), WLBS_OK, status1);

    rule2 = rule1;
    status1 = WlbsAddPortRule (reg_data, &rule2);
    verify_return_value (_TEXT("AddPortRule Overlap. same start and end ports"), WLBS_PORT_OVERLAP, status1);

    rule2 . start_port = rule1 . start_port + 1;
    rule2 . end_port   = rule2 . end_port - 1;
    status1 = WlbsAddPortRule (reg_data, &rule2);
    verify_return_value (_TEXT("AddPortRule Overlap 2 "), WLBS_PORT_OVERLAP, status1);

    rule2 . start_port = rule1 . start_port - 1;
    rule2 . end_port   = rule2 . end_port + 1;
    status1 = WlbsAddPortRule (reg_data, &rule2);
    verify_return_value (_TEXT("AddPortRule Overlap 3 "), WLBS_PORT_OVERLAP, status1);

    /* The following two tests would fail if the start port and the end port both are the same */
    rule2 . start_port = rule1 . start_port - 1;
    rule2 . end_port   = rule2 . end_port - 1;
    status1 = WlbsAddPortRule (reg_data, &rule2);
    verify_return_value (_TEXT("AddPortRule Overlap 4 "), WLBS_PORT_OVERLAP, status1);

    rule2 . start_port = rule1 . start_port + 1;
    rule2 . end_port   = rule2 . end_port + 1;
    status1 = WlbsAddPortRule (reg_data, &rule2);
    verify_return_value (_TEXT("AddPortRule Overlap 5 "), WLBS_PORT_OVERLAP, status1);

    status1 = WlbsDeletePortRule (reg_data, rule1 . start_port);
    verify_return_value (_TEXT("DeletePortRule"), WLBS_OK, status1);

    /* First test the APIs by inserting and deleting the rules in sorted order */
    check_add_delete_port_rules (reg_data, rule_list1, MAX_RULES, 1);
    /* Then test the APIs by inserting and deleting the rules in pseudo - unsorted order */
    check_add_delete_port_rules (reg_data, rule_list1, MAX_RULES, 7);

    return;
#undef MAX_RULES
}


void check_port_rule_apis ()
{

    WLBS_REG_PARAMS saved, reg_data;
    DWORD status;

    if (global_init == WLBS_REMOTE_ONLY || global_init == WLBS_INIT_ERROR)
    {
        add_error (_TEXT("WLBS is not installed on this host. Port rule apis cannot be tested"));
        return;
    }

    /* Save the existing configuration */
    status = WlbsReadReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, &saved);
    status = WlbsReadReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, &reg_data);

    port_rule_parameter_test (&reg_data);
    port_rule_functional_test (&reg_data);

    status = WlbsWriteReg (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, &saved);

    return;
}


void print_error_messages ()
{
    PErr_Struct temp;
    DWORD i = 0;

    while (headq)
    {
        temp = headq;
        i++;
        _tprintf (_TEXT("Error %d %s\n"), i, temp -> comment);
        headq = headq -> next;
        free(temp);
    }

    return;
}


#define INTERNET_ADDRESS "111.111.11.11"

/* This function tests WlbsResolve, WlbsAddressToString and WlbsAddressToName */
void check_winsock_wrappers ()
{
    DWORD lenp;
    DWORD address;
    TCHAR buf1[5], buf2[20], buf3[100], buf4[100];
    CHAR cbuf[100], cbuf2[20];
    int len = 1000;
    struct hostent * host;

    _stprintf (status_buf, _TEXT("Verifying Winsock Wrappers"));
    verify_return_value (_TEXT("WlbsResolve on invalid name"), WlbsResolve(_TEXT("junkname")), 0);
    gethostname (cbuf, len); /* Assume that this function does not fail */
#ifdef UNICODE
    swprintf (buf4, _TEXT("%S"), cbuf);
#else
    sprintf (buf4, "%s", cbuf);
#endif

    host = gethostbyname (cbuf);
    if (host == NULL)
    {
        add_error(_TEXT("gethostbyname failed, aborting winsock wrapper test\n"));
        return;

    }

    verify_return_value (_TEXT("WlbsResolve on null name"), WlbsResolve(NULL),0);

    address = ((struct in_addr *) (host -> h_addr)) -> s_addr;
    verify_return_value (_TEXT("WlbsResolve on local machine name"), WlbsResolve(buf4),
                         address);

    verify_return_value (_TEXT("WlbsResolve on valid dotted notation"),
                         WlbsResolve(_TEXT("111.111.111.111")),
                         inet_addr ("111.111.111.111"));

    verify_return_value (_TEXT("WlbsResolve on invalid dotted notation"),
                         WlbsResolve(_TEXT("333.111.111.111")), 0);


    lenp = 0;
    verify_return_value (_TEXT("WlbsAddressToString on null buffer"),
                         WlbsAddressToString (address , NULL, &lenp),
                         FALSE );
    verify_return_value (_TEXT("WlbsAddressToString required buffer length"),
                         strlen (inet_ntoa (* ((struct in_addr *) &address)) ) + 1, lenp);

    lenp = 5;
    verify_return_value (_TEXT("WlbsAddressToString on insufficient buffer"),
                         WlbsAddressToString (address , buf1, &lenp),
                         FALSE );
    verify_return_value (_TEXT("WlbsAddressToString required buffer length"),
                         strlen (inet_ntoa (* ((struct in_addr *) &address)) ) + 1, lenp);

    lenp = 20;
    verify_return_value (_TEXT("WlbsAddressToString on sufficient buffer"),
                         WlbsAddressToString (address , buf2, &lenp),
                         TRUE );
    verify_return_value (_TEXT("WlbsAddressToString required buffer length"),
                         strlen (inet_ntoa (* ((struct in_addr *) &address)) ) + 1, lenp);

#ifdef UNICODE
    sprintf (cbuf2, "%ls", buf2);
#else
    sprintf (cbuf2, "%s", buf2);
#endif

    if (_stricmp (cbuf2, inet_ntoa (* ((struct in_addr *) &address))) )
    {
        _stprintf (tbuf,
                   _TEXT("WlbsAddressToString return was different from the value supplied. Expected %S Got %S"),
                   cbuf2, inet_ntoa (* ((struct in_addr *) &address)) );

        add_error (tbuf);
    }

    /* WlbsAddressToName */
    lenp = 0;
    verify_return_value (_TEXT("WlbsAddressToName on null buffer"),
                         FALSE,
                         WlbsAddressToName (address, NULL, &lenp));
    verify_return_value (_TEXT("WlbsAddressToName required buffer length"),
                         strlen ((gethostbyaddr ((char *) & address, sizeof (DWORD), AF_INET)) -> h_name) + 1,
                         lenp);

    lenp = 5;
    verify_return_value (_TEXT("WlbsAddressToName on insufficient buffer"),
                         FALSE,
                         WlbsAddressToName (address , buf1, &lenp));
    verify_return_value (_TEXT("WlbsAddressToName required buffer length"),
                         strlen ((gethostbyaddr ((char *) & address, sizeof (DWORD), AF_INET)) -> h_name) + 1,
                         lenp);

    lenp = 100;
    verify_return_value (_TEXT("WlbsAddressToName on sufficient buffer"),
                         TRUE,
                         WlbsAddressToName (address , buf3, &lenp));
    verify_return_value (_TEXT("WlbsAddressToName required buffer length"),
                         strlen ((gethostbyaddr ((char *) & address, sizeof (DWORD), AF_INET)) -> h_name) + 1,
                         lenp);

    sprintf (cbuf, "%s", (gethostbyaddr ((char *) & address, sizeof (DWORD), AF_INET)) -> h_name);
#ifdef UNICODE
    swprintf (buf4, L"%S", cbuf);
#else
    sprintf (buf4, "%s", cbuf);
#endif
    if (_tcsicmp (buf3, buf4) )
    {
        _stprintf (tbuf,
                  _TEXT("WlbsAddressToName return was different from the value supplied. Expected %s Got %s"),
                  buf4, buf3);

        add_error (tbuf);
    }

    return;
}



void print_usage ()
{
    printf("Usage  : wlbsapitest [local] [remote cl_ip host_ip] [init] [verbose] [reboot 1|2|3] [timeout t]\n");
    printf("local  : for local cluster/host tests\n");
    printf("remote : for remote cluster/host tests\n");
    printf("init   : for testing a WlbsInit special case\n");
    printf("verbose: for printing the tests as they are carried out\n");
    printf("reboot : for testing commit on nt4 machines. Contact kumar for further info.\n");
    printf("timeout: for specifying the timeout value for cluster-wide queries. Specify it in milliseconds\n");
    return;
}


INT __cdecl _tmain
(
    INT             argc,
    PTCHAR          __targv []
)
{
    DWORD i;
    INT arg_count;
    OSVERSIONINFO   osiv;
    DWORD entry_point = 0;

    if (argc == 1)
    {
        print_usage();
        return 1;
    }

    /* Now parse the command line */
    arg_count = 1;

    while (arg_count < argc)
    {
        do {

            if ( ! _tcsicmp (__targv [arg_count], _TEXT("local")) )
                {
                local_test = TRUE;
                arg_count++;
                break;
            }

            if ( ! _tcsicmp (__targv [arg_count], _TEXT("remote")) )
                {
                if ( (argc - arg_count) <= 2)
                {
                    print_usage ();
                    return 1;
                }

                remote_cl_ip = WlbsResolve (__targv [arg_count + 1]);
                remote_host_ip = WlbsResolve (__targv [arg_count + 2]);
                remote_test = TRUE;
                arg_count += 3;
                break;
            }

            if ( ! _tcsicmp (__targv [arg_count], _TEXT("verbose")) )
            {
                verbose = TRUE;
                arg_count ++;
                break;
            }

            if ( ! _tcsicmp (__targv [arg_count], _TEXT("init")) )
            {
                init_test = TRUE;
                arg_count ++;
                break;
            }

            if ( ! _tcsicmp (__targv [arg_count], _TEXT("timeout")) )
            {
                if (argc - arg_count <= 1)
                {
                    print_usage ();
                    return 1;
                }
                timeout = _ttoi ( __targv [arg_count + 1] );
                arg_count += 2;
                break;
            }

            if ( ! _tcsicmp (__targv [arg_count], _TEXT("reboot")) )
            {
                if (argc - arg_count <= 1)
                {
                    print_usage ();
                    return 1;
                }
                entry_point = _ttoi ( __targv [arg_count + 1] );
                arg_count += 2;
                if (entry_point > 3)
                {
                    print_usage ();
                    return 1;
                }
                break;
            }

            print_usage ();
            return 1;

        } while ( 0 );
    }


    if (remote_test)
    {
        printf("Please enter the password for the remote host/cluster : ");
        _tscanf (_TEXT("%s"), remote_password);
    }

    if (!verbose)
        printf("Test Number: 0000");

    /* Get the version info on the OS (nt4 or higher) and store the info. */
    memset (&osiv, 0, sizeof (OSVERSIONINFO));
    osiv . dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
    if (GetVersionEx(&osiv) == 0)
        printf("error in getting the os version\n");
    version_nt4 = (osiv . dwPlatformId == VER_PLATFORM_WIN32_NT) &&
                  (osiv . dwMajorVersion == 4);

    check_init();
    if (init_test)
    {
        printf("\n");
        print_error_messages();
        printf("Total number of tests: %d Failed Tests: %d\n", total_tests, failed_tests);
        return 1;
    }

    if (version_nt4)
        if (entry_point != 0)
        {
            check_commit (entry_point);
            return 1;
        }

    check_single_host_operations();
    check_cluster_operations();


    if (!local_test)
    {
        printf("\n");
        print_error_messages();
        printf("Total number of tests: %d Failed Tests: %d\n", total_tests, failed_tests);
        return 1;
    }

    check_port_rule_apis();
    check_registry_rw();
    check_commit(0);
    check_winsock_wrappers();
    printf("\n");
    print_error_messages();
    printf("Total number of tests: %d Failed Tests: %d\n", total_tests, failed_tests);
    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\control\makefile.inc ===
$(TARGETPATH)\nlbs.cmd: nlbs.cmd
	copy nlbs.cmd $(TARGETPATH)
	$(BINPLACE_CMD)

log_msgs.h log_msgs.rc msg00001.bin: log_msgs.mc
    mc -v -U log_msgs.mc
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\control\nlb\control.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 2001
//
//  File:       control.cpp
//
//  Contents:   Command line wrapper for nlb.exe
//
//  Notes:      
//
//  Author:     chrisdar
//
//  Created:    6 Apr 2001
//
//  Change History:
//
//+---------------------------------------------------------------------------

#include <windows.h>
#include <wchar.h>
#include <process.h>
#include <stdio.h>

int __cdecl wmain (int argc, PWCHAR argv[]) {
    // Set up the path+exe to be executed
    // Note: system32 is the correct directory, even for i64 machines!
    const wchar_t* pwszPath = L"%systemroot%\\system32\\wlbs.exe";
    const DWORD dwPathLen = wcslen(pwszPath);
    
    // Get space needed to hold the command line arguments
    DWORD dwArgSpace = 0;
    int i = 0;
    for (i=1; i<argc; i++)
    {
        dwArgSpace += wcslen(argv[i]);
    }

    // Allocate memory for the path+exe+arguments+1 (for NULL termination)
    // Params are separated by space and 'argc - 1' spaces are needed.
    // +1 for a NULL terminator ==> add 'argc' to length
    wchar_t* pwszCommand = new wchar_t[dwPathLen + dwArgSpace + argc];
    if (NULL == pwszCommand)
    {
        printf("Memory allocation failure...exiting\n");
        return -1;
    }

    // Build up the command line with spaces as token separators
    wcscpy(pwszCommand, pwszPath);
    for (i=1; i<argc; i++)
    {
        wcscat(pwszCommand, L" ");
        wcscat(pwszCommand, argv[i]);
    }

    // Execute the command for the user
    if (-1 == _wsystem(pwszCommand))
    {
        // Prints a text equivalent of errno for the system call
        _wperror(L"Command execution failed: ");
        return -1;
    }
  
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\driver\load.h ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    load.h

Abstract:

    Windows Load Balancing Service (WLBS)
    Driver - load balancing mechanism

Author:

    bbain

--*/


#ifndef _Load_h_
#define _Load_h_


#ifndef KERNEL_MODE

#define SPINLOCK                THREADLOCK
#define IRQLEVEL                ULONG
#define LOCK_INIT(lp)           Lock_init(lp)
#define LOCK_ENTER(lp, pirql)   {if (Lock_enter((lp), INFINITE) != 1)  \
                                    UNIV_PRINT(("Lock enter error")); }
#define LOCK_EXIT(lp, irql)     {if (Lock_exit(lp) != 1)  \
                                    UNIV_PRINT(("Lock exit error")); }

#else

#include <ntddk.h>
#define LINK                    LIST_ENTRY
#define QUEUE                   LIST_ENTRY
#define Link_init(lp)           InitializeListHead (lp)
#define Link_unlink(lp)         {RemoveEntryList (lp) ; InitializeListHead (lp);}
#define Queue_init(qp)          InitializeListHead (qp)
// tmp #define Queue_enq(qp, lp)       InsertTailList (qp, lp)
#define Queue_enq(qp, lp)       if (IsListEmpty(lp)) {InsertTailList(qp, lp);} else DbgBreakPoint()
#define Queue_front(qp)         (IsListEmpty(qp) ? NULL : (qp) -> Flink)
#define Queue_deq(qp)           Queue_front(qp);\
                                if (! IsListEmpty (qp)) { \
                                    PLIST_ENTRY _lp = RemoveHeadList (qp); \
                                    InitializeListHead(_lp); }
#define Queue_next(qp, lp)      ((IsListEmpty (qp) || (lp) -> Flink == (qp)) ? \
                                 NULL : (lp) -> Flink)

#define SPINLOCK                KSPIN_LOCK
#define IRQLEVEL                KIRQL

#if 0   /* 1.03: Removed kernel mode locking in this module */
#define LOCK_INIT(lp)           KeInitializeSpinLock (lp)
#define LOCK_ENTER(lp, pirql)   KeAcquireSpinLock (lp, pirql)
#define LOCK_EXIT(lp, irql)     KeReleaseSpinLock (lp, irql)
#endif

#define LOCK_INIT(lp)
#define LOCK_ENTER(lp, pirql)
#define LOCK_EXIT(lp, irql)

#endif


#include "wlbsparm.h"
#include "params.h"
#include "wlbsiocl.h"

/* CONSTANTS */

/* This is the hardcoded second paramter to Map() when map function limiting is needed. */
#define MAP_FN_PARAMETER 0x00000000

#define CVY_LOADCODE	0xc0deba1c	/* type checking code for load structure (bbain 8/19/99) */
#define CVY_ENTRCODE	0xc0debaa5	/* type checking code for conn. entry (bbain 8/19/99) */
#define CVY_DESCCODE	0xc0deba5a	/* type checking code for conn. descr. (bbain 8/19/99) */
#define CVY_BINCODE 	0xc0debabc	/* type checking code for bin structure (bbain 8/19/99) */

#define CVY_MAXBINS     60      /* # load balancing bins; must conform to MAP_T def. V2.06 */
#define CVY_MAX_CHASH   4096    /* max. hash entries for connection hashing V1.1.4 */
#define CVY_INIT_QCONN  1024    /* initial # free connection descriptors V1.1.4 */

#define CVY_EQUAL_LOAD  50      /* load percentage used for equal load balance */

/* TCP connection status */

#define CVY_CONN_UP     1       /* connection may be coming up */
#define CVY_CONN_DOWN   2       /* connection may be going down */
#define CVY_CONN_RESET  3       /* connection is getting reset */ /* ###### added for keynote - ramkrish */

/* broadcast host states */

#define HST_NORMAL  1       /* normal operations */
#define HST_STABLE  2       /* stable convergence detected */
#define HST_CVG     3       /* converging to new load balance */

/* Bitmap for teaming, which is of the form:

   -------------------------------------
   |XXXXXXXX|PPPPPPPP|PPPPPPPP|NNNNNHMA|
   -------------------------------------

   X: Reserved
   P: XOR of the least significant 16 bits of each participant
   N: Number of participants
   H: Hashing (Reverse=1, Normal=0)
   M: Master (Yes=1, No=0)
   A: Teaming active (Yes=1, No=0)
*/
#define CVY_BDA_TEAMING_CODE_ACTIVE_OFFSET      0
#define CVY_BDA_TEAMING_CODE_MASTER_OFFSET      1
#define CVY_BDA_TEAMING_CODE_HASHING_OFFSET     2
#define CVY_BDA_TEAMING_CODE_NUM_MEMBERS_OFFSET 3
#define CVY_BDA_TEAMING_CODE_MEMBERS_OFFSET     8

#define CVY_BDA_TEAMING_CODE_ACTIVE_MASK        0x00000001
#define CVY_BDA_TEAMING_CODE_MASTER_MASK        0x00000002
#define CVY_BDA_TEAMING_CODE_HASHING_MASK       0x00000004
#define CVY_BDA_TEAMING_CODE_NUM_MEMBERS_MASK   0x000000f8
#define CVY_BDA_TEAMING_CODE_MEMBERS_MASK       0x00ffff00

#define CVY_BDA_TEAMING_CODE_CREATE(code,active,master,hashing,num,members)                                       \
        (code) |= ((active)  << CVY_BDA_TEAMING_CODE_ACTIVE_OFFSET)      & CVY_BDA_TEAMING_CODE_ACTIVE_MASK;      \
        (code) |= ((master)  << CVY_BDA_TEAMING_CODE_MASTER_OFFSET)      & CVY_BDA_TEAMING_CODE_MASTER_MASK;      \
        (code) |= ((hashing) << CVY_BDA_TEAMING_CODE_HASHING_OFFSET)     & CVY_BDA_TEAMING_CODE_HASHING_MASK;     \
        (code) |= ((num)     << CVY_BDA_TEAMING_CODE_NUM_MEMBERS_OFFSET) & CVY_BDA_TEAMING_CODE_NUM_MEMBERS_MASK; \
        (code) |= ((members) << CVY_BDA_TEAMING_CODE_MEMBERS_OFFSET)     & CVY_BDA_TEAMING_CODE_MEMBERS_MASK;

#define CVY_BDA_TEAMING_CODE_RETRIEVE(code,active,master,hashing,num,members)                                \
        active  = (code & CVY_BDA_TEAMING_CODE_ACTIVE_MASK)      >> CVY_BDA_TEAMING_CODE_ACTIVE_OFFSET;      \
        master  = (code & CVY_BDA_TEAMING_CODE_MASTER_MASK)      >> CVY_BDA_TEAMING_CODE_MASTER_OFFSET;      \
        hashing = (code & CVY_BDA_TEAMING_CODE_HASHING_MASK)     >> CVY_BDA_TEAMING_CODE_HASHING_OFFSET;     \
        num     = (code & CVY_BDA_TEAMING_CODE_NUM_MEMBERS_MASK) >> CVY_BDA_TEAMING_CODE_NUM_MEMBERS_OFFSET; \
        members = (code & CVY_BDA_TEAMING_CODE_MEMBERS_MASK)     >> CVY_BDA_TEAMING_CODE_MEMBERS_OFFSET;

/* DATA STRUCTURES */


/* type for a bin map (V2.04) */

typedef ULONGLONG   MAP_T, * PMAP_T;

/* state for all bins within a port group */

/* 64-bit -- ramkrish added pad */
typedef struct {
    ULONG       index;                      /* index in array of bin states */
    ULONG       code;                       /* type checking code (bbain 8/17/99) */
    MAP_T       targ_map;                   /* new target load map for local host */
    MAP_T       all_idle_map;               /* map of bins idle in all other hosts */
    MAP_T       cmap;                       /* cache of cur_map for this host (v2.1) */
    MAP_T       new_map[CVY_MAX_HOSTS];     /* new map for hosts while converging */
    MAP_T       cur_map[CVY_MAX_HOSTS];     /* current ownership mask per host */
    MAP_T       chk_map[CVY_MAX_HOSTS];     /* map of cur & rdy bins for all hosts */
                                            /* used as a check for coverage */
    MAP_T       idle_map[CVY_MAX_HOSTS];    /* map of idle bins per host */
    BOOLEAN     initialized;                /* TRUE => port group has been initialized (v2.06) */
    BOOLEAN     compatible;                 /* TRUE => detected that rule codes do not match */
    BOOLEAN     equal_bal;                  /* TRUE => all hosts balance evenly */
    USHORT      affinity;                   /* TRUE => client affinity for this port */
    USHORT      pad64;                      /* 64-bit -- ramkrish */
    ULONG       mode;                       /* processing mode */
    ULONG       prot;                       /* protocol */
    ULONG       tot_load;                   /* total load percentages for all hosts */
    ULONG       orig_load_amt;              /* original load amt. for this host */
    ULONG       load_amt[CVY_MAX_HOSTS];    /* multi:  load percentages per host
                                               single: host priorities (1..CVY_MAXHOSTS)
                                               equal:  100
                                               dead:   0 */
    MAP_T       snd_bins;                   /* local bins to send when ready */
    MAP_T       rcv_bins;                   /* remote bins to receive when ready */
    MAP_T       rdy_bins;                   /* snd bins that are ready to send
                                               or have been sent but not acknowledged */
    MAP_T       idle_bins;                  /* bins with no connections active */
    LONG        tconn;                      /* total # active local connections (v2.06) */
    LONG        nconn[CVY_MAXBINS];         /* # active local connections per bin */
    QUEUE       connq;                      /* queue of active connections on all bins */
} BIN_STATE, * PBIN_STATE;


//#pragma pack(4)

/* ping message */
/* 64-bit -- ramkrish change pragma pack to 1 */
#pragma pack(1)

typedef struct {
    USHORT      host_id;                    /* my host id */
    USHORT      master_id;                  /* current master host id */
    USHORT      state;                      /* my host's state */
    USHORT      nrules;                     /* # active rules */
    ULONG       hcode;                      /* unique host code */
    ULONG       pkt_count;                  /* count of packets handled since cvg'd (1.32B) */
    ULONG       teaming;                    /* BDA teaming configuraiton information. */
    ULONG       reserved2;
    ULONG       rcode[CVY_MAX_RULES];       /* rule code */
    MAP_T       cur_map[CVY_MAX_RULES];     /* my current load map for each port group */
    MAP_T       new_map[CVY_MAX_RULES];     /* my new load map for each port group */
                                            /* if converging */
    MAP_T       idle_map[CVY_MAX_RULES];    /* map of idle bins for each port group */
    MAP_T       rdy_bins[CVY_MAX_RULES];    /* my rdy to send bins for each port group */
    ULONG       load_amt[CVY_MAX_RULES];    /* my load amount for each port group */
    ULONG       pg_rsvd1[CVY_MAX_RULES];    /* reserved */
} PING_MSG, * PPING_MSG;

#pragma pack()


/* unique connection entry */

/* 64-bit -- ramkrish structure is aligned for 64-bit */

typedef struct {
    LINK        blink;          /* link into bin queue and dirty queue */
    LINK        rlink;          /* link into the recovery queue V2.1.5 */
    ULONG       code;           /* type checking code (bbain 8/17/99) */
    BOOLEAN     alloc;          /* TRUE => this entry was allocated
                                   (vs. in hash table) */
    BOOLEAN     dirty;          /* TRUE => this entry is associated with an obsolete
                                   connection and will be cleaned up after a timeout
                                   period to allow TCP/IP to purge its state (v1.32B) */
    UCHAR       bin;            /* entry's bin number */
    BOOLEAN     used;           /* TRUE => used for tracking connection */
    ULONG       fin_count;      /* ###### for keynote - ramkrish to keep track of the fins */
    ULONG       client_ipaddr,
                svr_ipaddr;
    USHORT      svr_port,
                client_port;
#if defined (NLB_SESSION_SUPPORT)
    USHORT      protocol;       /* The protocol type for this descriptor - we no
                                   long use descriptors only for TCP connections. */
#endif
} CONN_ENTRY, * PCONN_ENTRY;


/* connection descriptor */

/* 64-bit -- ramkrish */

typedef struct {
    LINK        link;           /* link into free queue or hash table queue */
    ULONG       code;           /* type checking code (bbain 8/17/99) */
    ULONG       pad64;          /* 64-bit -- ramkrish */
    CONN_ENTRY  entry;
} CONN_DESCR, * PCONN_DESCR;


/* load module's context */

/* 64-bit -- ramkrish */
typedef struct {
    ULONG       ref_count;                  /* The reference count on this load module. */
    ULONG       my_host_id;                 /* local host id and priority MINUS one */
    ULONG       code;                       /* type checking code (bbain 8/17/99) */
    /* 64-bit -- ramkrish */
    PING_MSG    send_msg;                   /* current message to send */
    ULONG       pad64_1;                    /* 64-bit */
#ifndef KERNEL_MODE     /* 1.03: Removed kernel mode locking in this module */
    SPINLOCK    lock;                       /* lock for mutual exclusion */
#endif

    ULONG       def_timeout,                /* default timeout in msec. */
                cur_timeout,                /* current timeout in msec. (v1.32B) */
                cln_timeout,                /* cleanup timeout in msec. (v1.32B) */
                cur_time;                   /* current time waiting for cleanup (v1.32B) */
    ULONG       host_map,                   /* map of currently active hosts */
                ping_map,                   /* map of currently pinged hosts */
                min_missed_pings,           /* # missed pings to trigger host dead */
                pkt_count;                  /* count of packets handled since cvg'd (1.32B) */
    ULONG       last_hmap;                  /* host map after last convergence (bbain RTM RC1 6/23/99) */
    ULONG       nmissed_pings[CVY_MAX_HOSTS];
                                            /* missed ping count for each host */
    BOOLEAN     initialized;                /* TRUE => this module has been initialized */
    BOOLEAN     active;                     /* TRUE => this module is active */
    BOOLEAN     consistent;                 /* TRUE => this host has seen consistent
                                               information from other hosts */

    BOOLEAN     bad_team_config;            /* TRUE => inconsistent BDA teaming configuration detected. */

    BOOLEAN     dup_hosts;                  /* TRUE => duplicate host id's seen */
    BOOLEAN     dup_sspri;                  /* TRUE => duplicate single server
                                               priorities seen */
    BOOLEAN     bad_map;                    /* TRUE => bad new map detected */
    BOOLEAN     overlap_maps;               /* TRUE => overlapping maps detected */
    BOOLEAN     err_rcving_bins;            /* TRUE => error receiving bins detected */
    BOOLEAN     err_orphans;                /* TRUE => orphan bins detected */
    BOOLEAN     bad_num_rules;              /* TRUE => different number of rules seen */
    BOOLEAN     alloc_inhibited;            /* TRUE => inhibited malloc of conn's. */
    BOOLEAN     alloc_failed;               /* TRUE => malloc failed */
    BOOLEAN     bad_defrule;                /* TRUE => invalid default rule detected */

    BOOLEAN     scale_client;               /* TRUE => scale client requests;
                                               FALSE => hash all client requests to one
                                               server host */
    BOOLEAN     cln_waiting;                /* TRUE => waiting for cleanup (v1.32B) */
    BOOLEAN     pad64_2;                    /* 64-bit -- ramkrish */
    BOOLEAN     dirty_bin[CVY_MAXBINS];     /* TRUE => bin has dirty connections (v1.32B) */
    ULONG       pad64_3;                    /* 64-bit -- ramkrish */
    ULONG       stable_map;                 /* map of stable hosts */
    ULONG       min_stable_ct;              /* min needed # of timeouts with stable
                                               condition */
    ULONG       my_stable_ct;               /* count of timeouts locally stable */
    ULONG       all_stable_ct;              /* count of timeouts with all stable
                                               condition */
    ULONG       dscr_per_alloc;             /* # conn. descriptors per allocation */
    ULONG       max_dscr_allocs;            /* max # descriptor allocations */
    ULONG       nqalloc;                    /* # conn. descriptor allocations */
    LONG        nconn;                      /* # active conns across all port rules (v2.1) */
    PCONN_DESCR qalloc_list[CVY_MAX_MAX_DSCR_ALLOCS];
                                            /* list of descriptor free queue allocations (bbain 2/25/99) */
//    LONG        nconn;                      /* # active conns across all port rules (v2.1) */ // 64-bit -- ramkrish
//    PING_MSG    send_msg;                   /* current message to send */
    BIN_STATE   pg_state[CVY_MAX_RULES];    /* bin state for all active rules */
    CONN_ENTRY  hashed_conn[CVY_MAX_CHASH]; /* hashed connection entries */
    QUEUE       connq[CVY_MAX_CHASH];       /* queues for overloaded hashed conn's. */
    QUEUE       conn_freeq;                 /* queue of free descriptors */
    QUEUE       conn_dirtyq;                /* queue of dirty connection entries (v1.32B) */
    CONN_DESCR  conn_descr[CVY_INIT_QCONN]; /* initial set of free descriptors */
    QUEUE       conn_rcvryq;                /* connection recover queue V2.1.5 */
    PCVY_PARAMS params;                     /* pointer to the global parameters */
} LOAD_CTXT, * PLOAD_CTXT;


/* FUNCTIONS */


/* Load Module Functions */

#if defined (NLB_SESSION_SUPPORT)
#define CVY_CONN_MATCH(ep, sa, sp, ca, cp, prot)  ((ep)->used &&                          \
                                                   (ep)->client_ipaddr == (ca) &&         \
                                                   (ep)->client_port == ((USHORT)(cp)) && \
                                                   (ep)->svr_ipaddr == (sa) &&            \
                                                   (ep)->svr_port == ((USHORT)(sp)) &&    \
                                                   (ep)->protocol == ((USHORT)(prot)))
#else
#define CVY_CONN_MATCH(ep, sa, sp, ca, cp, prot)        ((ep)->used &&                          \
                                                   (ep)->client_ipaddr == (ca) &&         \
                                                   (ep)->client_port == ((USHORT)(cp)) && \
                                                   (ep)->svr_ipaddr == (sa) &&            \
                                                   (ep)->svr_port == ((USHORT)(sp)))
#endif

/*
  Determine if a connection entry matches supplied parameters
*/

#if defined (NLB_SESSION_SUPPORT)
#define CVY_CONN_SET(ep, sa, sp, ca, cp, prot) {                                    \
                                                 (ep)->svr_ipaddr = (sa);           \
                                                 (ep)->svr_port = (USHORT)(sp);     \
                                                 (ep)->client_ipaddr = (ca);        \
                                                 (ep)->client_port = (USHORT)(cp);  \
                                                 (ep)->protocol = (USHORT)(prot);   \
                                                 (ep)->used = TRUE;                 \
                                               }
#else
#define CVY_CONN_SET(ep, sa, sp, ca, cp, prot) {                                    \
                                                 (ep)->svr_ipaddr = (sa);           \
                                                 (ep)->svr_port = (USHORT)(sp);     \
                                                 (ep)->client_ipaddr = (ca);        \
                                                 (ep)->client_port = (USHORT)(cp);  \
                                                 (ep)->used = TRUE;                 \
                                               }
#endif

/*
  Sets up a connection entry for the supplied parameters
*/


#define CVY_CONN_IN_USE(ep) ((ep)->used)
/*
  Checks if connection entry is in use
*/

#define CVY_CONN_CLEAR(ep) { (ep)->used = FALSE; }
/*
  Clears a connection entry
*/


extern void Load_start(
    PLOAD_CTXT      lp);
/*
  Start load module

  function:
    Starts load module after previously initialized or stopped.
*/


extern void Load_stop(
    PLOAD_CTXT      lp);
/*
  Stop load module

  function:
    Stops load module after previously initialized or started.
*/


extern void Load_init(
    PLOAD_CTXT      lp,
    PCVY_PARAMS     params);
/*
  Initialize load module

  function:
    Initializes the load module for the first time.
*/


extern void Load_cleanup(    /* (bbain 2/25/99) */
	PLOAD_CTXT      lp);
/*
  Cleanup load module

  function:
    Cleans up the load module by releasing dynamically allocated memory.
*/


extern void Load_msg_rcv(
    PLOAD_CTXT      lp,
    PPING_MSG       pmsg);          /* ptr. to ping message */
/*
  Receive a ping message
*/


extern PPING_MSG Load_snd_msg_get(
    PLOAD_CTXT      lp);
/*
  Get local ping message to send

  returns PPING_MSG:
      <ptr. to ping message to send>
*/


extern BOOLEAN Load_timeout(
    PLOAD_CTXT      lp,
    PULONG          new_timeout,
    PBOOLEAN        pconverging,    /* ptr. to boolean with TRUE => cluster converging (v2.1) */
    PULONG          pnconn);        /* ptr. to # active conns across all port rules (v2.1) */
/*
  Handle timeout

  returns BOOLEAN:
    TRUE  => host is attached to the network
    FALSE => host lost network connection
*/


extern BOOLEAN Load_packet_check(
    PLOAD_CTXT      lp,
    ULONG           svr_ipaddr,
    ULONG           svr_port,
    ULONG           client_ipaddr,
    ULONG           client_port,
    USHORT          protocol,
    BOOLEAN         limit_map_fn);
/*
  Check whether to accept incoming TCP/UDP packet

  returns BOOLEAN:
    TRUE    => accept packet and pass on to TCP/IP
    FALSE   => filter packet
*/


extern BOOLEAN Load_conn_advise(
    PLOAD_CTXT      lp,
    ULONG           svr_ipaddr,
    ULONG           svr_port,
    ULONG           client_ipaddr,
    ULONG           client_port,
    USHORT          protocol,
    ULONG           conn_status,
    BOOLEAN         limit_map_fn);
/*
  Advise load module on possible change in TCP connection status

  returns BOOLEAN:
    TRUE    => accept packet and pass on to TCP/IP if an input packet
    FALSE   => filter packet
*/


extern ULONG Load_port_change(
    PLOAD_CTXT      lp,
    ULONG           ipaddr,
    ULONG           port,
    ULONG           cmd,        /* enable, disable, set value */
    ULONG           value);
/*
  Enable or disable traffic handling for a rule containing specified port

  returns ULONG:
    IOCTL_CVY_OK        => port handling changed
    IOCTL_CVY_NOT_FOUND => rule for this port was found
    IOCTL_CVY_ALREADY   => port handling was previously completed
*/


extern ULONG Load_hosts_query(
    PLOAD_CTXT      lp,
    BOOLEAN         internal,
    PULONG          host_map);
/*
  Log and return current host map

  returns ULONG:
    <one of IOCTL_CVY_...state defined in params.h>
*/

/*
 * Function: 
 * Description: 
 * Parameters: 
 * Returns: 
 * Author: shouse, 3.29.01
 * Notes: 
 */
extern BOOLEAN Load_create_dscr(PLOAD_CTXT lp, ULONG svr_ipaddr, ULONG svr_port, ULONG client_ipaddr, ULONG client_port, USHORT protocol, BOOLEAN limit_map_fn);

/*
 * Function: 
 * Description: 
 * Parameters: 
 * Returns: 
 * Author: shouse, 3.29.01
 * Notes: 
 */
extern ULONG Load_add_reference (IN PLOAD_CTXT pLoad);

/*
 * Function: 
 * Description: 
 * Parameters: 
 * Returns: 
 * Author: shouse, 3.29.01
 * Notes: 
 */
extern ULONG Load_release_reference (IN PLOAD_CTXT pLoad);

/*
 * Function: 
 * Description: 
 * Parameters: 
 * Returns: 
 * Author: shouse, 3.29.01
 * Notes: 
 */
extern ULONG Load_get_reference_count (IN PLOAD_CTXT pLoad);

/*
 * Function: 
 * Description: 
 * Parameters: 
 * Returns: 
 * Author: shouse, 5.18.01
 * Notes: 
 */
extern VOID Load_query_packet_filter (
    PIOCTL_QUERY_STATE_PACKET_FILTER pQuery,
    PLOAD_CTXT    lp,
    ULONG         svr_ipaddr,
    ULONG         svr_port,
    ULONG         client_ipaddr,
    ULONG         client_port,
    USHORT        protocol,
    BOOLEAN       limit_map_fn);

#if defined (NLB_SESSION_SUPPORT)
#define  NLB_IPSEC_SESSION_SUPPORT_ENABLED() 1
#define  NLB_PPTP_SESSION_SUPPORT_ENABLED() 1
#else
#define  NLB_IPSEC_SESSION_SUPPORT_ENABLED() 0
#define  NLB_PPTP_SESSION_SUPPORT_ENABLED() 0
#endif // NLB_SESSION_SUPPORT

#define NLB_SESSION_SUPPORT_ENABLED()                   \
            (NLB_PPTP_SESSION_SUPPORT_ENABLED()         \
             || NLB_IPSEC_SESSION_SUPPORT_ENABLED())

#endif /* _Load_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\control\control.cpp ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

	control.cpp

Abstract:

	Windows Load Balancing Service (WLBS)
    Command-line utility

Author:

    kyrilf
    ramkrish (Post Win2K)

--*/

#include <windows.h>
#include <stdio.h>
#include <conio.h>
#include <stdlib.h>
#include <process.h>
#include <time.h>
#include <locale.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <tchar.h>
#include <shlwapi.h>

#define WLBSAPI_INTERNAL_ONLY
#define BACKWARD_COMPATIBILITY
#define CVY_MAX_ADAPTERS    16

#include "wlbsutil.h"
#include "wlbsctrl.h"
#include "wlbsconfig.h"
#include "wlbsparm.h"
#include "wlbsiocl.h"

#define CLIENT
#include "log_msgs.h"

/* CONSTANTS */
#define CVY_OK               1
#define CVY_ERROR_USAGE     -1
#define CVY_ERROR_REGISTRY  -2
#define CVY_ERROR_SYSTEM    -3
#define CVY_ERROR_USER      -4
#define CVY_BUF_SIZE        4096
#define CVY_MAX_EVENTS      10
#define CVY_MAX_INSERTS     10
#define CVY_ALL_CLUSTERS    0xffffffff
#define CVY_ALL_HOSTS       0xffffffff
#define CVY_LOCAL_CLUSTER   0
#define CVY_LOCAL_HOST      WLBS_LOCAL_HOST

#define TL_ERROR ((DWORD)0x00010000)
#define TL_WARN ((DWORD)0x00020000)
#define TL_INFO ((DWORD)0x00040000)

typedef enum {
    mcastipaddress,
    iptomcastip,
    masksrcmac,
    iptomacenable
} WLBS_REG_KEYS;

typedef enum {
    query,
    suspend,
    resume,
    __start,
    stop,
    drainstop,
    enable,
    disable,
    drain,
    reload,
    display,
    ip2mac,
    help,
    registry,
    invalid
} WLBS_COMMANDS;

typedef enum {
    TRACE_ALL,
    TRACE_FILE, 
    TRACE_CONSOLE,
    TRACE_DEBUGGER
} TraceOutput;

static HANDLE file_hdl = NULL;
static HANDLE ConsoleHdl;
static BYTE buffer [CVY_BUF_SIZE];
static WCHAR message [CVY_BUF_SIZE];
static WCHAR ConsoleBuf [CVY_BUF_SIZE];
static WCHAR wbuf [CVY_STR_SIZE];
static WCHAR psw_buf [CVY_STR_SIZE];

VOID WConsole(const wchar_t *fmt, ...)
{
   va_list  arglist;   
   DWORD    res1, res2;
   DWORD    TotalLen;
   
   // Form a string out of the arguments
   va_start(arglist, fmt);
   wvnsprintf(ConsoleBuf, CVY_BUF_SIZE, fmt, arglist);
   va_end(arglist);

   // Attempt WriteConsole, if it fails, do a wprintf
   TotalLen = lstrlenW(ConsoleBuf);
   if (!WriteConsole(ConsoleHdl, ConsoleBuf, lstrlenW(ConsoleBuf), &res1, &res2))
   {
       wprintf(ConsoleBuf);
   }
   return;
}

VOID Message_print (DWORD id, ...) {
    va_list arglist;
    DWORD error;
    
    va_start(arglist, id);
    
    if (FormatMessage(FORMAT_MESSAGE_FROM_HMODULE, NULL, id, 0, message, CVY_BUF_SIZE, & arglist) == 0) {
        error = GetLastError();
        
        //
        // Can't localize this because we've got a failure trying
        // to display a localized message..
        //
        WConsole(L"Could not print error message due to: ");
        
        if (FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, error, 0, message, CVY_BUF_SIZE, NULL) == 0)
            WConsole(L"%d\n", error);
        else
            WConsole(L"\n %ls\n", message);
    } else
        WConsole(L"%ls", message);
}

VOID Error_print (BOOL sock) {
    DWORD error;

    if (sock) {
        error = WSAGetLastError();

        switch (error) {
            case WSAENETUNREACH:
                Message_print(IDS_CTR_WS_NUNREACH);
                break;
            case WSAETIMEDOUT:
                Message_print(IDS_CTR_WS_TIMEOUT);
                break;
            case WSAHOST_NOT_FOUND:
                Message_print(IDS_CTR_WS_NOAUTH);
                break;
            case WSATRY_AGAIN:
                Message_print(IDS_CTR_WS_NODNS);
                break;
            case WSAENETDOWN:
                Message_print(IDS_CTR_WS_NETFAIL);
                break;
            case WSAEHOSTUNREACH:
                Message_print(IDS_CTR_WS_HUNREACH);
                break;
            case WSAENETRESET:
                Message_print(IDS_CTR_WS_RESET);
                break;
            default:
                Message_print(IDS_CTR_ER_CODE, error);
                break;
        }
    } else {
        error = GetLastError();
        
        if (FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, error, 0, message, CVY_BUF_SIZE, NULL) == 0)
            Message_print(IDS_CTR_ER_CODE, error);
        else
            WConsole(L"%ls\n", message);
    }

}

INT Report (WLBS_COMMANDS command, BOOLEAN condensed, ULONG ret_code, ULONG param1, ULONG param2,
            ULONG query_state, ULONG host_id, ULONG host_map) {
    ULONG i;
    BOOL first;

    switch (command) {
        case reload:
            if (ret_code == WLBS_BAD_PARAMS) {
                Message_print(IDS_CTR_BAD_PARAMS);
                return CVY_ERROR_USER;
            } else
                Message_print(IDS_CTR_RELOADED);

            break;
        case resume:
            if (condensed)
                if (ret_code == WLBS_ALREADY)
                    Message_print(IDS_CTR_RESUMED_C_A);
                else
                    Message_print(IDS_CTR_RESUMED_C);
            else
                if (ret_code == WLBS_ALREADY)
                    Message_print(IDS_CTR_RESUMED_A);
                else
                    Message_print(IDS_CTR_RESUMED);

            break;
        case suspend:
            if (condensed)
                if (ret_code == WLBS_ALREADY)
                    Message_print(IDS_CTR_SUSPENDED_C_A);
                else {
                    if (ret_code == WLBS_STOPPED)
                        Message_print(IDS_CTR_FROM_START_C);
                    
                    Message_print(IDS_CTR_SUSPENDED_C);
                }
            else
                if (ret_code == WLBS_ALREADY)
                    Message_print(IDS_CTR_SUSPENDED_A);
                else {
                    if (ret_code == WLBS_STOPPED)
                        Message_print(IDS_CTR_FROM_START);

                    Message_print(IDS_CTR_SUSPENDED);
                }

            break;
        case __start:
            if (ret_code == WLBS_SUSPENDED) {
                if (condensed)
                    Message_print(IDS_CTR_SUSPENDED_C);
                else
                    Message_print(IDS_CTR_SUSPENDED);

                return CVY_ERROR_USER;
            } else if (ret_code == WLBS_BAD_PARAMS) {
                if (condensed)
                    Message_print(IDS_CTR_BAD_PARAMS_C);
                else
                    Message_print(IDS_CTR_BAD_PARAMS);

                return CVY_ERROR_USER;
            } else {
                if (condensed)
                    if (ret_code == WLBS_ALREADY)
                        Message_print(IDS_CTR_STARTED_C_A);
                    else {
                        if (ret_code == WLBS_DRAIN_STOP)
                            Message_print(IDS_CTR_FROM_DRAIN_C);

                        Message_print(IDS_CTR_STARTED_C);
                    }
                else
                    if (ret_code == WLBS_ALREADY)
                        Message_print(IDS_CTR_STARTED_A);
                    else {
                        if (ret_code == WLBS_DRAIN_STOP)
                            Message_print(IDS_CTR_FROM_DRAIN);

                        Message_print(IDS_CTR_STARTED);
                    }
            }

            break;
        case stop:
            if (ret_code == WLBS_SUSPENDED) {
                if (condensed)
                    Message_print(IDS_CTR_SUSPENDED_C);
                else
                    Message_print(IDS_CTR_SUSPENDED);

                return CVY_ERROR_USER;
            }else {
                if (condensed)
                    if (ret_code == WLBS_ALREADY)
                        Message_print(IDS_CTR_STOPPED_C_A);
                    else
                        Message_print(IDS_CTR_STOPPED_C);
                else
                    if (ret_code == WLBS_ALREADY)
                        Message_print(IDS_CTR_STOPPED_A);
                    else
                        Message_print(IDS_CTR_STOPPED);
            }

            break;
        case drainstop:
            if (ret_code == WLBS_SUSPENDED) {
                if (condensed)
                    Message_print(IDS_CTR_SUSPENDED_C);
                else
                    Message_print(IDS_CTR_SUSPENDED);

                return CVY_ERROR_USER;
            } else {
                if (condensed)
                    if (ret_code == WLBS_STOPPED)
                        Message_print(IDS_CTR_STOPPED_C);
                    else if (ret_code == WLBS_ALREADY)
                        Message_print(IDS_CTR_DRAINED_C_A);
                    else
                        Message_print(IDS_CTR_DRAINED_C);
                else
                    if (ret_code == WLBS_STOPPED)
                        Message_print(IDS_CTR_STOPPED);
                    else if (ret_code == WLBS_ALREADY)
                        Message_print(IDS_CTR_DRAINED_A);
                    else
                        Message_print(IDS_CTR_DRAINED);
            }

            break;
        case enable:
        case disable:
        case drain:
            if (ret_code == WLBS_SUSPENDED) {
                if (condensed)
                    Message_print(IDS_CTR_SUSPENDED_C);
                else
                    Message_print(IDS_CTR_SUSPENDED);

                return CVY_ERROR_USER;
            } else if (ret_code == WLBS_STOPPED) {
                if (condensed)
                    Message_print(IDS_CTR_RLS_ST_C);
                else
                    Message_print(IDS_CTR_RLS_ST);

                return CVY_ERROR_USER;
            } else if (ret_code == WLBS_NOT_FOUND) {
                if (param2 == IOCTL_ALL_PORTS)
                {
                    if (param1 == IOCTL_ALL_VIPS) {
                        if (condensed)
                            Message_print(IDS_CTR_RLS_NORULES_C);
                        else
                            Message_print(IDS_CTR_RLS_NORULES);
                    }
                    else if (param1 == IpAddressFromAbcdWsz(CVY_DEF_ALL_VIP)) 
                    {
                        if (condensed)
                            Message_print(IDS_CTR_RLS_NO_ALL_VIP_RULES_C);
                        else
                            Message_print(IDS_CTR_RLS_NO_ALL_VIP_RULES);
                    }
                    else
                    {
                        WCHAR szIpAddress[WLBS_MAX_CL_IP_ADDR+1];
                        AbcdWszFromIpAddress(param1, szIpAddress);
                        if (condensed)
                            Message_print(IDS_CTR_RLS_NO_SPECIFIC_VIP_RULES_C, szIpAddress);
                        else
                            Message_print(IDS_CTR_RLS_NO_SPECIFIC_VIP_RULES, szIpAddress);
                    }
                }
                else
                {
                    if (param1 == IOCTL_ALL_VIPS) {
                        if (condensed)
                            Message_print(IDS_CTR_RLS_NONE_C, param2);
                        else
                            Message_print(IDS_CTR_RLS_NONE, param2);
                    }
                    else if (param1 == IpAddressFromAbcdWsz(CVY_DEF_ALL_VIP)) 
                    {
                        if (condensed)
                            Message_print(IDS_CTR_RLS_NO_ALL_VIP_RULE_FOR_PORT_C, param2);
                        else
                            Message_print(IDS_CTR_RLS_NO_ALL_VIP_RULE_FOR_PORT, param2);
                    }
                    else
                    {
                        WCHAR szIpAddress[WLBS_MAX_CL_IP_ADDR+1];
                        AbcdWszFromIpAddress(param1, szIpAddress);
                        if (condensed)
                            Message_print(IDS_CTR_RLS_NO_SPECIFIC_VIP_RULE_FOR_PORT_C, szIpAddress, param2);
                        else
                            Message_print(IDS_CTR_RLS_NO_SPECIFIC_VIP_RULE_FOR_PORT, szIpAddress, param2);
                    }
                }

                return CVY_ERROR_USER;
            } else {
                switch (command) 
                {
                    case enable:
                         if (condensed)
                             if (ret_code == WLBS_ALREADY)
                                Message_print(IDS_CTR_RLS_EN_C_A);
                             else
                                 Message_print(IDS_CTR_RLS_EN_C);
                         else
                             if (ret_code == WLBS_ALREADY)
                                 Message_print(IDS_CTR_RLS_EN_A);
                             else
                                 Message_print(IDS_CTR_RLS_EN);
                         break;
                    case disable:
                         if (condensed)
                             if (ret_code == WLBS_ALREADY)
                                 Message_print(IDS_CTR_RLS_DS_C_A);
                             else
                                 Message_print(IDS_CTR_RLS_DS_C);
                         else
                             if (ret_code == WLBS_ALREADY)
                                 Message_print(IDS_CTR_RLS_DS_A);
                             else
                                 Message_print(IDS_CTR_RLS_DS);
                         break;
                    case drain :
                         if (condensed)
                             if (ret_code == WLBS_ALREADY)
                                 Message_print(IDS_CTR_RLS_DR_C_A);
                             else
                                 Message_print(IDS_CTR_RLS_DR_C);
                         else
                             if (ret_code == WLBS_ALREADY)
                                 Message_print(IDS_CTR_RLS_DR_A);
                             else
                                 Message_print(IDS_CTR_RLS_DR);
                         break;
                }
            }

            break;
        case query:
            switch (query_state) {
                case WLBS_SUSPENDED:
                    if (condensed)
                        Message_print(IDS_CTR_CVG_SP_C);
                    else
                        Message_print(IDS_CTR_CVG_SP, host_id);

                    return CVY_OK;
                case WLBS_STOPPED:
                    if (condensed)
                        Message_print(IDS_CTR_CVG_UN_C);
                    else
                        Message_print(IDS_CTR_CVG_UN, host_id);

                    return CVY_OK;
                case WLBS_DISCONNECTED:
                    if (condensed)
                        Message_print(IDS_CTR_MEDIA_DISC_C);
                    else
                        Message_print(IDS_CTR_MEDIA_DISC, host_id);

                    return CVY_OK;
                case WLBS_DRAINING:
                    if (condensed)
                        Message_print(IDS_CTR_CVG_DR_C);
                    else
                        Message_print(IDS_CTR_CVG_DR, host_id);

                    break;
                case WLBS_CONVERGING:
                    if (condensed)
                        Message_print(IDS_CTR_CVG_PR_C);
                    else
                        Message_print(IDS_CTR_CVG_PR, host_id);

                    break;
                case WLBS_CONVERGED:
                    if (condensed)
                        Message_print(IDS_CTR_CVG_SL_C);
                    else
                        Message_print(IDS_CTR_CVG_SL, host_id);

                    break;
                case WLBS_DEFAULT:
                    if (condensed)
                        Message_print(IDS_CTR_CVG_MS_C);
                    else
                        Message_print(IDS_CTR_CVG_MS, host_id);

                    break;
                default:
                    if (condensed)
                        Message_print(IDS_CTR_CVG_ER_C);
                    else
                        Message_print(IDS_CTR_CVG_ER, query_state);

                    return CVY_ERROR_SYSTEM;
            }

            if (!condensed) {
                first = TRUE;

                for (i = 0; i < 32; i ++) {
                    if (host_map & (1 << i)) {
                        if (!first)
                            WConsole (L", ");
                        else
                            first = FALSE;

                        WConsole(L"%d", i + 1);
                    }
                }

                WConsole (L"\n");
            }

            break;
        default:
            Message_print(IDS_CTR_IO_ER, command);
            break;
    }

    return CVY_OK;

}

INT Display (DWORD cluster) {
    HANDLE hdl;
    HINSTANCE lib;
    DWORD flag;
    EVENTLOGRECORD * recp = (EVENTLOGRECORD *)buffer;
    DWORD actual, needed, records, index = 0, got = 0;
    DWORD j, i, code;
    PWCHAR strp;
    PWCHAR prot;
    WCHAR aff;
    time_t curr_time;
    PWLBS_PORT_RULE rp, rulep;
    BYTE * inserts[CVY_MAX_INSERTS];
    WLBS_REG_PARAMS params;
    DWORD status;

    status = WlbsReadReg(cluster, &params);

    if (status != WLBS_OK) {
        Message_print (IDS_CTR_REMOTE);
        return CVY_ERROR_USER;
    }

    Message_print(IDS_CTR_DSP_CONFIGURATION);

    time (& curr_time);

    WConsole(L"%-25.25ls = %ls", L"Current time", _wctime (& curr_time));
    WConsole(L"%-25.25ls = %d\n", CVY_NAME_VERSION, params.i_parms_ver);
    WConsole(L"%-25.25ls = %ls\n", CVY_NAME_VIRTUAL_NIC, params.i_virtual_nic_name);
    WConsole(L"%-25.25ls = %d\n", CVY_NAME_ALIVE_PERIOD, params.alive_period);
    WConsole(L"%-25.25ls = %d\n", CVY_NAME_ALIVE_TOLER, params.alive_tolerance);
    WConsole(L"%-25.25ls = %d\n", CVY_NAME_NUM_ACTIONS, params.num_actions);
    WConsole(L"%-25.25ls = %d\n", CVY_NAME_NUM_PACKETS, params.num_packets);
    WConsole(L"%-25.25ls = %d\n", CVY_NAME_NUM_SEND_MSGS, params.num_send_msgs);
    WConsole(L"%-25.25ls = %ls\n", CVY_NAME_NETWORK_ADDR, params.cl_mac_addr);
    WConsole(L"%-25.25ls = %ls\n", CVY_NAME_DOMAIN_NAME, params.domain_name);
    WConsole(L"%-25.25ls = %ls\n", CVY_NAME_CL_IP_ADDR, params.cl_ip_addr);
    WConsole(L"%-25.25ls = %ls\n", CVY_NAME_CL_NET_MASK, params.cl_net_mask);
    WConsole(L"%-25.25ls = %ls\n", CVY_NAME_DED_IP_ADDR, params.ded_ip_addr);
    WConsole(L"%-25.25ls = %ls\n", CVY_NAME_DED_NET_MASK, params.ded_net_mask);
    WConsole(L"%-25.25ls = %d\n", CVY_NAME_HOST_PRIORITY, params.host_priority);
    WConsole(L"%-25.25ls = %ls\n", CVY_NAME_CLUSTER_MODE, params.cluster_mode ? L"ENABLED" : L"DISABLED");
    WConsole(L"%-25.25ls = %d\n", CVY_NAME_DSCR_PER_ALLOC, params.dscr_per_alloc);
    WConsole(L"%-25.25ls = %d\n", CVY_NAME_MAX_DSCR_ALLOCS, params.max_dscr_allocs);
    WConsole(L"%-25.25ls = %d\n", CVY_NAME_SCALE_CLIENT, params.i_scale_client);
    WConsole(L"%-25.25ls = %d\n", CVY_NAME_NBT_SUPPORT, params.i_nbt_support);
    WConsole(L"%-25.25ls = %d\n", CVY_NAME_MCAST_SUPPORT, params.mcast_support);
    WConsole(L"%-25.25ls = %d\n", CVY_NAME_MCAST_SPOOF, params.i_mcast_spoof);
    WConsole(L"%-25.25ls = %d\n", CVY_NAME_MASK_SRC_MAC, params.mask_src_mac);
    WConsole(L"%-25.25ls = %ls\n", CVY_NAME_IGMP_SUPPORT, params.fIGMPSupport ? L"ENABLED" : L"DISABLED");
    WConsole(L"%-25.25ls = %ls\n", CVY_NAME_IP_TO_MCASTIP, params.fIpToMCastIp ? L"ENABLED" : L"DISABLED");
    WConsole(L"%-25.25ls = %ls\n", CVY_NAME_MCAST_IP_ADDR, params.szMCastIpAddress);
    WConsole(L"%-25.25ls = %d\n", CVY_NAME_NETMON_ALIVE, params.i_netmon_alive);
    if (params.i_effective_version == CVY_NT40_VERSION_FULL)
        WConsole(L"%-25.25ls = %ls\n", CVY_NAME_EFFECTIVE_VERSION, CVY_NT40_VERSION);
    else
        WConsole(L"%-25.25ls = %ls\n", CVY_NAME_EFFECTIVE_VERSION, CVY_VERSION);
    WConsole(L"%-25.25ls = %d\n", CVY_NAME_IP_CHG_DELAY, params.i_ip_chg_delay);
    WConsole(L"%-25.25ls = %d\n", CVY_NAME_CONVERT_MAC, params.i_convert_mac);
    WConsole(L"%-25.25ls = %d\n", CVY_NAME_CLEANUP_DELAY, params.i_cleanup_delay);
    WConsole(L"%-25.25ls = %d\n", CVY_NAME_RCT_ENABLED, params.rct_enabled);
    WConsole(L"%-25.25ls = %d\n", CVY_NAME_RCT_PORT, params.rct_port);
    WConsole(L"%-25.25ls = 0x%X\n", CVY_NAME_RCT_PASSWORD, params.i_rct_password);
    WConsole(L"%-25.25ls = 0x%X\n", CVY_NAME_RMT_PASSWORD, params.i_rmt_password);
    WConsole(L"%-25.25ls = %ls\n", CVY_NAME_CUR_VERSION, CVY_VERSION);
    WConsole(L"%-25.25ls = 0x%X\n", CVY_NAME_INSTALL_DATE, params.install_date);
    WConsole(L"%-25.25ls = 0x%X\n", CVY_NAME_VERIFY_DATE, params.i_verify_date);
    WConsole(L"%-25.25ls = %d\n", CVY_NAME_NUM_RULES, params.i_num_rules);
    WConsole(L"%-25.25ls = %ls\n", CVY_NAME_BDA_TEAMING, params.bda_teaming.active ? L"ENABLED" : L"DISABLED");
    WConsole(L"%-25.25ls = %ls\n", CVY_NAME_BDA_TEAM_ID, params.bda_teaming.team_id);
    WConsole(L"%-25.25ls = %ls\n", CVY_NAME_BDA_MASTER, params.bda_teaming.master ? L"ENABLED" : L"DISABLED");
    WConsole(L"%-25.25ls = %ls\n", CVY_NAME_BDA_REVERSE_HASH, params.bda_teaming.reverse_hash ? L"ENABLED" : L"DISABLED");

    WConsole(L"%-25.25ls \n", CVY_NAME_PORT_RULES);

    WConsole(L"Virtual IP addr Start\tEnd\tProt\tMode\t\tPri\tLoad\tAffinity\n");

    for (i = 0; i < params.i_num_rules; i ++) {
        rp = params.i_port_rules + i;

        code = CVY_RULE_CODE_GET(rp);

        CVY_RULE_CODE_SET(rp);

        if (code != CVY_RULE_CODE_GET(rp)) {
            WConsole(L"bad rule code 0x%08x vs 0x%08x\n", code, CVY_RULE_CODE_GET(rp));
            rp->code = code;
            continue;
        }

        if (!rp->valid) {
            WConsole(L"rule is not valid\n");
            continue;
        }

        if (rp->start_port > rp->end_port) {
            WConsole(L"bad port range %d-%d\n", rp->start_port, rp->end_port);
            continue;
        }

        for (j = 0; j < i; j ++) {
            rulep = params.i_port_rules + j;
            if ((IpAddressFromAbcdWsz(rulep->virtual_ip_addr) == IpAddressFromAbcdWsz(rp->virtual_ip_addr)) 
             && ((rulep->start_port < rp->start_port && rulep->end_port >= rp->start_port) ||
                 (rulep->start_port >= rp->start_port && rulep->start_port <= rp->end_port))) {
                WConsole(L"port ranges for rules %d (%d-%d) and %d (%d-%d) overlap\n", i, rp->start_port, rp->end_port, j, rulep->start_port, rulep->end_port);
                continue;
            }
        }

        if (rp->start_port > CVY_MAX_PORT) {
            WConsole(L"bad start port %d\n", rp->start_port);
            continue;
        }

        if (rp->end_port > CVY_MAX_PORT) {
            WConsole(L"bad end port %d\n", rp->end_port);
            continue;
        }

        if (rp->protocol < CVY_MIN_PROTOCOL || rp->protocol > CVY_MAX_PROTOCOL) {
            WConsole(L"bad protocol %d\n", rp->protocol);
            continue;
        }

        if (rp->mode < CVY_MIN_MODE || rp->mode > CVY_MAX_MODE) {
            WConsole(L"bad mode %d\n", rp->mode);
            continue;
        }

        switch (rp->protocol) {
            case CVY_TCP:
                prot = L"TCP";
                break;
            case CVY_UDP:
                prot = L"UDP";
                break;
            default:
                prot = L"Both";
                break;
        }

        if (!lstrcmpi(rp->virtual_ip_addr, CVY_DEF_ALL_VIP))            
            WConsole(L"%15ls\t%5d\t%5d\t%ls\t", L"ALL", rp->start_port, rp->end_port, prot);
        else
            WConsole(L"%15ls\t%5d\t%5d\t%ls\t", rp->virtual_ip_addr, rp->start_port, rp->end_port, prot);

        switch (rp->mode) {
            case CVY_SINGLE:
                WConsole(L"%-10.10ls\t%2d", L"Single", rp->mode_data.single.priority);
                break;
            case CVY_MULTI:
                if (rp->mode_data.multi.affinity == CVY_AFFINITY_NONE)
                    aff = L'N';
                else if (rp->mode_data.multi.affinity == CVY_AFFINITY_SINGLE)
                    aff = L'S';
                else
                    aff = L'C';

                if (rp->mode_data.multi.equal_load)
                    WConsole(L"%-10.10ls\t\tEqual\t%lc", L"Multiple", aff);
                else {
                    if (rp->mode_data.multi.load > CVY_MAX_LOAD) {
                        WConsole(L"bad load %d\n", rp->mode_data.multi.load);
                        continue;
                    }

                    WConsole(L"%-10.10ls\t\t%3d\t%lc", L"Multiple", rp->mode_data.multi.load, aff);
                }

                break;
            default:
                WConsole(L"%-10.10ls", L"Disabled");
                break;
        }

        WConsole(L"\n");
    }

    WConsole(L"\n");

    Message_print(IDS_CTR_DSP_EVENTLOG);

    hdl = OpenEventLog (NULL, L"System");

    if (hdl == NULL) {
        WConsole(L"Could not open event log due to:\n");
        Error_print (FALSE);
        return CVY_ERROR_SYSTEM;
    }

    if (!GetNumberOfEventLogRecords(hdl, &records)) {
        WConsole(L"Could not get number of records in event log due to:\n");
        Error_print (FALSE);
        CloseEventLog (hdl);
        return CVY_ERROR_SYSTEM;
    }

    if (!GetOldestEventLogRecord (hdl, & index)) {
        WConsole(L"Could not get the index of the latest event log record due to:\n");
        Error_print (FALSE);
        CloseEventLog (hdl);
        return CVY_ERROR_SYSTEM;
    }

    swprintf(message + GetSystemDirectory (message, CVY_BUF_SIZE), L"\\drivers\\%ls.sys", CVY_NAME);

    lib = LoadLibrary(message);

    if (lib == NULL) {
        WConsole(L"Could not load driver image file due to:\n");
        Error_print (FALSE);
        CloseEventLog (hdl);
        return CVY_ERROR_SYSTEM;
    }

    index += records - 1;

    flag = EVENTLOG_SEEK_READ | EVENTLOG_BACKWARDS_READ;

    while (got < CVY_MAX_EVENTS && ReadEventLog(hdl, flag, index, recp, CVY_BUF_SIZE, &actual, &needed)) {
        while (got < CVY_MAX_EVENTS && actual > 0) {
            if (wcscmp ((PWSTR)(((PBYTE) recp) + sizeof(EVENTLOGRECORD)), CVY_NAME) == 0) {
                WConsole(L"#%02d ID: 0x%08X Type: %d Category: %d ", index--, recp->EventID, recp->EventType, recp->EventCategory);
                        
                time_t TimeGenerated = recp->TimeGenerated;
                
                WConsole(L"Time: %ls", _wctime(&TimeGenerated));

                strp = (PWCHAR)((LPBYTE)recp + recp->StringOffset);

                for (i = 0; i < CVY_MAX_INSERTS; i ++) {
                    if (i < recp->NumStrings) {
                        inserts[i] = (BYTE*)strp;
                        strp += wcslen (strp) + 1;
                    } else
                        inserts[i] = 0;
                }

                if (FormatMessage(FORMAT_MESSAGE_FROM_HMODULE | FORMAT_MESSAGE_ARGUMENT_ARRAY, lib,
                                  recp->EventID, 0, (PWCHAR)message, CVY_BUF_SIZE, (va_list *)inserts) == 0) {
                    WConsole(L"Could not load message string due to:\n");
                    Error_print(FALSE);
                } else
                    WConsole(L"%ls", message);

                for (i = 0; i < recp->DataLength / sizeof(DWORD); i ++) {
                    if (i != 0 && i % 8 == 0)
                        WConsole(L"\n");
                    
                    WConsole(L"%08X ", *(UNALIGNED DWORD*)((PBYTE)recp + recp->DataOffset + i * sizeof(DWORD)));
                }

                WConsole(L"\n\n");
                got++;
            }

            actual -= recp->Length;
            recp = (EVENTLOGRECORD *)((LPBYTE)recp + recp->Length);
            index--;
        }

        recp = (EVENTLOGRECORD *)buffer;
        flag = EVENTLOG_SEQUENTIAL_READ | EVENTLOG_BACKWARDS_READ;
    }

    FreeLibrary(lib);
    CloseEventLog(hdl);

    Message_print(IDS_CTR_DSP_IPCONFIG);

    fflush(stdout);

    _wsystem(L"ipconfig /all");

    Message_print(IDS_CTR_DSP_STATE);

    return CVY_OK;

}

/* This function parses the remaining arguments to determine whether the command
 * is for all clusters, or a remote cluster or for a single local cluster. */
BOOLEAN Parse (INT argc, PWCHAR argv [], PINT arg_index, PDWORD ptarget_cl, PDWORD ptarget_host) {
    PWCHAR phost;

#ifdef BACKWARD_COMPATIBILITY
    *ptarget_cl = CVY_ALL_CLUSTERS;
    *ptarget_host = CVY_LOCAL_HOST;

    if (*arg_index >= argc)
        return TRUE;
#endif
    
    /* At this point, argv[arg_index] == cluster_ip and/or argv[arg_index+1] == /local or /passw or /port */

    //
    // Special check for /PASSW without a cluster ID, because this is
    // a common error
    //
    if (   _wcsicmp (argv [*arg_index], L"/passw") == 0
        || _wcsicmp (argv [*arg_index], L"-passw") == 0)
    {
		Message_print (IDS_CTR_PSSW_WITHOUT_CLUSTER);
                return FALSE;

    }

    phost = wcschr(argv[* arg_index], L':');

    /* if there is no host part - operation applies to all hosts */
    if (phost == NULL) {
        *ptarget_host = CVY_ALL_HOSTS;
    } else {
        /* split target name so targ points to cluster name and host to host name */
        *phost = 0;
        phost ++;

        if (wcslen(phost) <= 2 && phost[0] >= L'0' && phost[0] <= L'9' && ((phost[1] >= L'0' && phost[1] <= L'9') || phost[1] == 0))
            *ptarget_host = _wtoi(phost);
        else {
            *ptarget_host = WlbsResolve(phost);

            if (*ptarget_host == 0) {
		Message_print(IDS_CTR_BAD_HOST_NAME_IP);
                return FALSE;
	    }
        }
    }

    // Retrieve the Cluster IP Address or "ALL"
    if (_wcsicmp (argv[*arg_index], L"all") == 0)
    {
        // If there is a host part, then, cluster ip can not be "ALL"
        if (*ptarget_host != CVY_ALL_HOSTS) 
        {
            Message_print(IDS_CTR_BAD_CLUSTER_NAME_IP);
            return FALSE;
        }
        *ptarget_cl = CVY_ALL_CLUSTERS;
    }
    else
    {
        *ptarget_cl = WlbsResolve(argv[*arg_index]);
        if (*ptarget_cl == 0) {
            Message_print(IDS_CTR_BAD_CLUSTER_NAME_IP);
            return FALSE;
        }
    }

    (*arg_index)++;

    // If there is no host part, then, there better be the LOCAL or GLOBAL flag
    if (*ptarget_host == CVY_ALL_HOSTS) 
    {
        if (*arg_index == argc)
        {
#ifdef BACKWARD_COMPATIBILITY
            return TRUE;
#else
            Message_print(IDS_CTR_CLUSTER_WITHOUT_LOCAL_GLOBAL_FLAG);
            return FALSE;
#endif
        }

        if (_wcsicmp (argv[*arg_index], L"local") == 0) 
        {
            *ptarget_host = CVY_LOCAL_HOST;
            (*arg_index)++;
        } 
#ifdef BACKWARD_COMPATIBILITY
        else if ((argv[*arg_index][0] == L'/') || (argv[*arg_index][0] == L'-')) 
        {
            if (_wcsicmp(argv[*arg_index] + 1, L"local") == 0) 
            {
                *ptarget_host = CVY_LOCAL_HOST;
                (*arg_index)++;
            }
        }
#endif
        else if (_wcsicmp (argv[*arg_index], L"global") == 0)
        {
            // Already set to CVY_ALL_HOSTS
            (*arg_index)++;
        }
        else
        {
            Message_print(IDS_CTR_CLUSTER_WITHOUT_LOCAL_GLOBAL_FLAG);
            return FALSE;
        }
    }

    if (*arg_index == argc)
        return TRUE;

    if ((argv[*arg_index][0] == L'/') || (argv[*arg_index][0] == L'-')) {
#ifdef BACKWARD_COMPATIBILITY
        if (_wcsicmp(argv[*arg_index] + 1, L"local") == 0) {
            (*arg_index)++;
            *ptarget_host = CVY_LOCAL_HOST;
            return TRUE;
        } else 
#endif
        if ((_wcsicmp(argv[*arg_index] + 1, L"port")  == 0) || (_wcsicmp(argv[*arg_index] + 1, L"passw") == 0))
            return TRUE;
        else
            return FALSE;
    } else
        return FALSE;

}

VOID Process (WLBS_COMMANDS command, DWORD target_cl, DWORD target_host, ULONG param1,
              ULONG param2, ULONG dest_port, DWORD dest_addr, PWCHAR dest_password) {
    DWORD num_hosts = WLBS_MAX_HOSTS;
    DWORD len = WLBS_MAX_CL_IP_ADDR + 1;
    DWORD host_map;
    WLBS_RESPONSE response[WLBS_MAX_HOSTS];
    DWORD status;
    DWORD i;
    WLBS_REG_PARAMS reg_data;

    WlbsPasswordSet(target_cl, dest_password);
    WlbsPortSet(target_cl, (USHORT)dest_port);

    switch (command) {
    case query:
        status = WlbsQuery(target_cl, target_host, response, &num_hosts, &host_map, NULL);
        break;
    case __start:
        status = WlbsStart(target_cl, target_host, response, &num_hosts);
        break;
    case stop:
        status = WlbsStop(target_cl, target_host, response, &num_hosts);
        break;
    case suspend:
        status = WlbsSuspend(target_cl, target_host, response, &num_hosts);
        break;
    case resume:
        status = WlbsResume(target_cl, target_host, response, &num_hosts);
        break;
    case drainstop:
        status = WlbsDrainStop(target_cl, target_host, response, &num_hosts);
        break;
    case enable:
        status = WlbsEnable(target_cl, target_host, response, &num_hosts, param1, param2);
        break;
    case disable:
        status = WlbsDisable(target_cl, target_host, response, &num_hosts, param1, param2);
        break;
    case drain:
        status = WlbsDrain(target_cl, target_host, response, &num_hosts,  param1, param2);
        break;
    case reload:
        status = WlbsNotifyConfigChange(target_cl);

        if (status == WLBS_LOCAL_ONLY) {
            Message_print(IDS_CTR_REMOTE);
            return;
        }

        if (status == WLBS_REG_ERROR || status == WLBS_BAD_PARAMS) {
            Message_print(IDS_CTR_BAD_PARAMS);
            return;
        }

        if (status == WLBS_OK) {
            Message_print(IDS_CTR_RELOADED);
            return;
        }

        break;
    case display:
        Display(target_cl);
        Process(query, target_cl, target_host, param1, param2, dest_port, dest_addr, dest_password);
        return;
    case registry:
        if ((status = WlbsReadReg(target_cl, &reg_data)) != WLBS_OK) {
            Message_print(IDS_CTR_REG_READ);
            return;
        }

        switch (param1) {
        case mcastipaddress:
            reg_data.fIpToMCastIp = FALSE;
            WlbsAddressToString(param2, reg_data.szMCastIpAddress, &len);
            break;
        case iptomcastip:
            reg_data.fIpToMCastIp = param2;
            break;
        case iptomacenable:
            reg_data.i_convert_mac = param2;
            break;
        case masksrcmac:
            reg_data.mask_src_mac = param2;
            break;
        }

        if ((status = WlbsWriteReg(target_cl, &reg_data)) != WLBS_OK) {
            Message_print(IDS_CTR_REG_WRITE);
            return;
        }

        switch (param1) {
        case mcastipaddress:
        {
            TCHAR igmpaddr[WLBS_MAX_CL_IP_ADDR + 1];
            DWORD len = WLBS_MAX_CL_IP_ADDR + 1;

            WlbsAddressToString (param2, igmpaddr, &len);

            Message_print(IDS_CTR_REG_MCASTIPADDRESS, igmpaddr);
            break;
        }
        case iptomcastip:
            Message_print((param2) ? IDS_CTR_REG_IPTOMCASTIP_ON : IDS_CTR_REG_IPTOMCASTIP_OFF);
            break;
        case masksrcmac:
            Message_print((param2) ? IDS_CTR_REG_MASKSRCMAC_ON : IDS_CTR_REG_MASKSRCMAC_OFF);
            break;
        case iptomacenable:
            Message_print((param2) ? IDS_CTR_REG_IPTOMACENABLE_ON : IDS_CTR_REG_IPTOMACENABLE_OFF);
            break;
        }

        return;
    default:
        return;
    }

    if (status == WLBS_INIT_ERROR) {
        Message_print(IDS_CTR_INIT);
        return;
    }

    if (status == WLBS_LOCAL_ONLY) {
        Message_print(IDS_CTR_WSOCK);
        return;
    }

    if (status == WLBS_REMOTE_ONLY) {
        Message_print(IDS_CTR_NO_CVY, CVY_NAME);
        return;
    }

    if (status >= WSABASEERR) {
        Message_print(IDS_CTR_WSOCK);
        Error_print(TRUE);
        return;
    }

    if (status == WLBS_TIMEOUT) {
        Message_print(IDS_CTR_NO_RSP3);

        if (command != query)
            Message_print(IDS_CTR_NO_RSP4, CVY_NAME);

        return;
    }

    if (target_host == CVY_LOCAL_HOST) {
        Report(command, FALSE, status, param1, param2, response[0].status, response[0].id, host_map);
        return;
    }

    /* Call Report for each host's response */
    for (i = 0; i < num_hosts; i++) {
        if (response[i].address == 0)
            Message_print(IDS_CTR_HOST_NO_DED, response [i] . id);
        else {
            DWORD len = CVY_STR_SIZE;
#if defined (SBH)
            Message_print(IDS_CTR_HOST, response[i].id, response[i].hostname);
#else
            WlbsAddressToString(response[i].address, wbuf, &len);
            Message_print(IDS_CTR_HOST, response[i].id, wbuf);
#endif
        }

        if (response[i].status == WLBS_BAD_PASSW) {
            if (target_host != CVY_ALL_HOSTS) {
                WConsole(L"\n");
                Message_print(IDS_CTR_BAD_PASSW);
            } else {
                Message_print(IDS_CTR_BAD_PASSW_C);
                WConsole(L"\n");
            }

            continue;
        }

        Report(command, TRUE, response[i].status, param1, param2, response[i].status, response[i].id, host_map);
    }

    return;

}

BOOL
ParsePort(
    PWCHAR          arg,
    PULONG          pvip,
    PULONG          pport
    )
/*
    arg is expected to optionally contain a virtual IP address or a 
    "all", signifying the "all vip" port rule and mandatorilay contain 
    "all", signifying all ports, or a port number in the range of 0-65535.

    Return: TRUE if valid parse, in which case *pvip & *pport contains the parsed
    value. FALSE if invalid parse, in  which case *pvip & *pport are undefined.
*/
{
    BOOL fRet = TRUE;
    WCHAR vip_str[WLBS_MAX_CL_IP_ADDR+1];
    WCHAR *temp_str;
    ULONG port, viplen;

    // Check if a vip or the "ALL" string was passed
    if ((temp_str = wcspbrk(arg,L":")) != NULL)
    {
        viplen = (ULONG)(temp_str - arg);
        wcsncpy(vip_str, arg, viplen);
        vip_str[viplen] = L'\0';
        *pvip = IpAddressFromAbcdWsz(vip_str);

        // A vip was not passed, Check if the "All" string was passed
        if (*pvip == INADDR_NONE) 
        {
            if (_wcsicmp (vip_str, L"all") == 0)
            {
                *pvip = IpAddressFromAbcdWsz(CVY_DEF_ALL_VIP);
            }
            else
            {
                return FALSE;
            }
        }

        arg = temp_str + 1;
    }
    else // Neither a vip nor the "All" string was passed, so this applies to every vip
    {
        *pvip = IOCTL_ALL_VIPS;
    }

    if (_wcsicmp (arg, L"all") == 0)
    {
        port = IOCTL_ALL_PORTS;
    }
    else
    {
        port = _wtoi (arg);

        if (   wcspbrk(arg, L".:") != NULL
            || (port == 0 && arg[0] != L'0')
            || port > 65535
            )
        fRet = FALSE;
    }

    *pport = port;

    return fRet;
}

/* 
 * Function: Process_tracing
 * Description: This function processing the tracing command.
 * Author: shouse 12.12.00
 *
 */
DWORD Process_tracing (DWORD tracing, TraceOutput output, DWORD flags) {
    HKEY hTracingKey;
    const WCHAR szTracingKey[] = L"Software\\Microsoft\\Tracing\\wlbs";
    const WCHAR szDebuggerTracingEnableValue[] = L"EnableDebuggerTracing";
    const WCHAR szDebuggerTracingMaskValue[] = L"DebuggerTracingMask";
    const WCHAR szFileTracingEnableValue[] = L"EnableFileTracing";
    const WCHAR szFileTracingMaskValue[] = L"FileTracingMask";
    const WCHAR szConsoleTracingEnableValue[] = L"EnableConsoleTracing";
    const WCHAR szConsoleTracingMaskValue[] = L"ConsoleTracingMask";
    DWORD status = ERROR_SUCCESS;

    if ((status = RegOpenKeyEx(HKEY_LOCAL_MACHINE, szTracingKey, 0, KEY_ALL_ACCESS, &hTracingKey)) == ERROR_SUCCESS) {
        DWORD size = sizeof (DWORD);

        switch (output) {
        case TRACE_FILE:
            if ((status = RegSetValueEx(hTracingKey, szFileTracingEnableValue, 0, REG_DWORD, (LPBYTE)&tracing, size)) != ERROR_SUCCESS)
                break;
            
            if (tracing)
                if ((status = RegSetValueEx(hTracingKey, szFileTracingMaskValue, 0, REG_DWORD, (LPBYTE)&flags, size)) != ERROR_SUCCESS)
                    break;

            break;
        case TRACE_CONSOLE:
            if ((status = RegSetValueEx(hTracingKey, szConsoleTracingEnableValue, 0, REG_DWORD, (LPBYTE)&tracing, size)) != ERROR_SUCCESS)
                break;
            
            if (tracing)
                if ((status = RegSetValueEx(hTracingKey, szConsoleTracingMaskValue, 0, REG_DWORD, (LPBYTE)&flags, size)) != ERROR_SUCCESS)
                    break;

            break;
        case TRACE_DEBUGGER:
            if ((status = RegSetValueEx(hTracingKey, szDebuggerTracingEnableValue, 0, REG_DWORD, (LPBYTE)&tracing, size)) != ERROR_SUCCESS)
                break;
            
            if (tracing)
                if ((status = RegSetValueEx(hTracingKey, szDebuggerTracingMaskValue, 0, REG_DWORD, (LPBYTE)&flags, size)) != ERROR_SUCCESS)
                    break;

            break;
        case TRACE_ALL:
            if ((status = RegSetValueEx(hTracingKey, szFileTracingEnableValue, 0, REG_DWORD, (LPBYTE)&tracing, size)) != ERROR_SUCCESS)
                break;
            
            if (tracing)
                if ((status = RegSetValueEx(hTracingKey, szFileTracingMaskValue, 0, REG_DWORD, (LPBYTE)&flags, size)) != ERROR_SUCCESS)
                    break;

            if ((status = RegSetValueEx(hTracingKey, szConsoleTracingEnableValue, 0, REG_DWORD, (LPBYTE)&tracing, size)) != ERROR_SUCCESS)
                break;
            
            if (tracing)
                if ((status = RegSetValueEx(hTracingKey, szConsoleTracingMaskValue, 0, REG_DWORD, (LPBYTE)&flags, size)) != ERROR_SUCCESS)
                    break;

            if ((status = RegSetValueEx(hTracingKey, szDebuggerTracingEnableValue, 0, REG_DWORD, (LPBYTE)&tracing, size)) != ERROR_SUCCESS)
                break;
            
            if (tracing)
                if ((status = RegSetValueEx(hTracingKey, szDebuggerTracingMaskValue, 0, REG_DWORD, (LPBYTE)&flags, size)) != ERROR_SUCCESS)
                    break;

            break;
        }

        RegCloseKey(hTracingKey);
    }

    if (status == ERROR_SUCCESS) {
        switch (output) {
        case TRACE_FILE:
            if (tracing)
                Message_print(IDS_CTR_TRACE_FILE_ON);
            else 
                Message_print(IDS_CTR_TRACE_FILE_OFF);

            break;
        case TRACE_CONSOLE:
            if (tracing)
                Message_print(IDS_CTR_TRACE_CONSOLE_ON);
            else
                Message_print(IDS_CTR_TRACE_CONSOLE_OFF);
            
            break;
        case TRACE_DEBUGGER:
            if (tracing)
                Message_print(IDS_CTR_TRACE_DEBUGGER_ON);
            else
                Message_print(IDS_CTR_TRACE_DEBUGGER_OFF);
            
            break;
        case TRACE_ALL:
            if (tracing)
                Message_print(IDS_CTR_TRACE_ALL_ON);
            else
                Message_print(IDS_CTR_TRACE_ALL_OFF);

            break;
        }

        if (tracing) {
            switch (flags) {
            case TL_ERROR:
                Message_print(IDS_CTR_TRACE_E);
                break;
            case TL_WARN:
                Message_print(IDS_CTR_TRACE_W);
                break;
            case TL_INFO:
                Message_print(IDS_CTR_TRACE_I);
                break;
            case TL_ERROR|TL_INFO:
                Message_print(IDS_CTR_TRACE_EI);
                break;
            case TL_ERROR|TL_WARN:
                Message_print(IDS_CTR_TRACE_EW);
                break;
            case TL_WARN|TL_INFO:
                Message_print(IDS_CTR_TRACE_WI);
                break;
            case TL_ERROR|TL_WARN|TL_INFO:
                Message_print(IDS_CTR_TRACE_EWI);
                break;
            }
        }
    }

    return status;
}

/* 
 * Function: Parse_tracing
 * Description: This function parses the WLBS tracing control arguments.
 * Author: shouse 12.12.00
 *
 */
BOOLEAN Parse_tracing (INT argc, PWCHAR argv [], PINT arg_index, PDWORD flags) {

    if (argc < 4) return TRUE;
    
    for (; (*arg_index) < argc; (*arg_index)++) {
        if ((_wcsicmp(argv[*arg_index] + 1, L"error") == 0)) {
            if (*(argv[*arg_index]) == '+')
                *flags |= TL_ERROR;
            else if (*(argv[*arg_index]) == '-')
                *flags &= ~TL_ERROR;
            else
                return FALSE;
        } else if ((_wcsicmp(argv[*arg_index] + 1, L"warning") == 0)) {
            if (*(argv[*arg_index]) == '+')
                *flags |= TL_WARN;
            else if (*(argv[*arg_index]) == '-')
                *flags &= ~TL_WARN;
            else
                return FALSE;
        } else if ((_wcsicmp(argv[*arg_index] + 1, L"info") == 0)) {
            if (*(argv[*arg_index]) == '+')
                *flags |= TL_INFO;
            else if (*(argv[*arg_index]) == '-')
                *flags &= ~TL_INFO;
            else
                return FALSE;
        } else
            return FALSE;
    }
    
    return TRUE;
}

extern "C"
{

int __cdecl wmain (int argc, PWCHAR argv[]) {
    INT arg_index;
    ULONG i, ip;
    PUCHAR bp;
    LONG status;
    DWORD target_cl;
    DWORD target_host;
    WLBS_COMMANDS command = invalid;
    ULONG param1;
    ULONG param2;
    ULONG dest_port;
    PWCHAR dest_password;
    DWORD dest_addr;

    _wsetlocale(LC_ALL, L".OCP");

    if ((ConsoleHdl = GetStdHandle(STD_OUTPUT_HANDLE)) == INVALID_HANDLE_VALUE)
    {
        wprintf(L"GetStdHandle failed, Unable to write to Console !!!\n");
        return CVY_ERROR_SYSTEM;
    }

    Message_print(IDS_CTR_NAME, CVY_NAME);

    if (argc < 2 || argc > 10) {
usage:
        Message_print(IDS_CTR_USAGE, CVY_NAME);
        Message_print(IDS_CTR_USAGE2);
        return CVY_ERROR_USAGE;
    }

    status = WlbsInit(NULL, WLBS_API_VER, NULL);

    if (status == WLBS_INIT_ERROR) {
        Message_print(IDS_CTR_WSOCK);
        Error_print(TRUE);
        return CVY_ERROR_SYSTEM;
    }

#if defined (SBH)
    /* 100 BEGIN hack. */
    
    IOCTL_QUERY_STATE buf;

    buf.Operation = NLB_QUERY_PACKET_FILTER;
    buf.Filter.ServerIPAddress = WlbsResolve(L"12.12.4.2");
    buf.Filter.ClientIPAddress = WlbsResolve(L"11.11.1.1");
    buf.Filter.ServerPort = 80;
    buf.Filter.ClientPort = 17348;
    buf.Filter.Protocol = 6;

    DWORD myretval = WlbsQueryState(WlbsResolve(L"12.12.4.2"), CVY_ALL_HOSTS, &buf);

    return CVY_OK;;

    /* 110 END hack. */
#endif

    arg_index = 1;

    /* parse command */
    if (_wcsicmp(argv [arg_index], L"ip2mac") == 0) {
        command = ip2mac;
        arg_index++;

        if (argc < 3)
            goto usage;

        ip = WlbsResolve(argv[arg_index]);

        bp = (PUCHAR)(&ip);
        Message_print(IDS_CTR_IP, inet_ntoa(*((struct in_addr *)&ip)));
        Message_print(IDS_CTR_MCAST, bp[0], bp[1], bp[2], bp[3]);
        Message_print(IDS_CTR_UCAST, bp[0], bp[1], bp[2], bp[3]);

        return CVY_OK;
    } else if (_wcsicmp(argv[arg_index], L"help") == 0) {
        command = help;
        swprintf(wbuf, L"%ls.chm", CVY_NAME);

        if (_wspawnlp(P_NOWAIT, L"hh.exe", L"hh.exe", wbuf, NULL) == -1) {
            Message_print(IDS_CTR_HELP);
            return CVY_ERROR_SYSTEM;
        }

        return CVY_OK;
    } else if (_wcsicmp(argv[arg_index], L"suspend") == 0) {
        command = suspend;
        arg_index++;
#ifndef BACKWARD_COMPATIBILITY
        if (argc < 3) 
            goto usage;
#endif
        if (!Parse(argc, argv, &arg_index, &target_cl, &target_host))
            goto usage;
    } else if (_wcsicmp(argv[arg_index], L"resume") == 0) {
        command = resume;
        arg_index++;
#ifndef BACKWARD_COMPATIBILITY
        if (argc < 3) 
            goto usage;
#endif
        if (!Parse(argc, argv, &arg_index, &target_cl, &target_host))
            goto usage;
    } else if (_wcsicmp(argv[arg_index], L"start") == 0) {
        command = __start;
        arg_index++;
#ifndef BACKWARD_COMPATIBILITY
        if (argc < 3) 
            goto usage;
#endif
        if (!Parse(argc, argv, &arg_index, &target_cl, &target_host))
            goto usage;
    } else if (_wcsicmp(argv[arg_index], L"stop") == 0) {
        command = stop;
        arg_index++;
#ifndef BACKWARD_COMPATIBILITY
        if (argc < 3) 
            goto usage;
#endif
        if (!Parse(argc, argv, &arg_index, &target_cl, &target_host))
            goto usage;
    } else if (_wcsicmp(argv[arg_index], L"drainstop") == 0) {
        command = drainstop;
        arg_index++;
#ifndef BACKWARD_COMPATIBILITY
        if (argc < 3) 
            goto usage;
#endif
        if (!Parse(argc, argv, &arg_index, &target_cl, &target_host))
            goto usage;
    } else if (_wcsicmp(argv[arg_index], L"query") == 0) {
        command = query;
        arg_index++;
#ifndef BACKWARD_COMPATIBILITY
        if (argc < 3) 
            goto usage;
#endif
        if (!Parse(argc, argv, &arg_index, &target_cl, &target_host))
            goto usage;
    } else if (_wcsicmp(argv[arg_index], L"enable") == 0) {
        command = enable;
        arg_index++;

#ifdef BACKWARD_COMPATIBILITY
        if (argc < 3)
#else
        if (argc < 4)
#endif
            goto usage;

        if (!ParsePort(argv[arg_index], &param1, &param2))
            goto usage;

        arg_index++;

        if (!Parse(argc, argv, &arg_index, &target_cl, &target_host))
            goto usage;
    } else if (_wcsicmp(argv[arg_index], L"disable") == 0) {
        command = disable;
        arg_index++;

#ifdef BACKWARD_COMPATIBILITY
        if (argc < 3)
#else
        if (argc < 4)
#endif
            goto usage;

        if (!ParsePort(argv[arg_index], &param1, &param2))
            goto usage;

        arg_index++;

        if (!Parse(argc, argv, &arg_index, &target_cl, &target_host))
            goto usage;
    } else if (_wcsicmp(argv[arg_index], L"drain") == 0) {
        command = drain;
        arg_index++;

#ifdef BACKWARD_COMPATIBILITY
        if (argc < 3)
#else
        if (argc < 4)
#endif
            goto usage;

        if (!ParsePort(argv[arg_index], &param1, &param2))
            goto usage;

        arg_index++;

        if (!Parse(argc, argv, &arg_index, &target_cl, &target_host))
            goto usage;
    }

    /* local only commands */
    else if (_wcsicmp(argv[arg_index], L"display") == 0) {
        command = display;
        arg_index++;
        target_host = CVY_LOCAL_HOST;

        // Verify that the cluster ip or "All" string is passed and there are no more arguments
        if ((arg_index == argc) || (arg_index + 1 < argc))
#ifdef BACKWARD_COMPATIBILITY
            if (arg_index == argc)
                target_cl = CVY_ALL_CLUSTERS;
            else 
                goto usage;
#else
            goto usage;
#endif
        else {
            // Retrieve the Cluster IP Address or "ALL"
            if (_wcsicmp (argv[arg_index], L"all") == 0)
            {
                target_cl   = CVY_ALL_CLUSTERS;
            }
            else
            {
                target_cl = WlbsResolve(argv [arg_index]);

                if (target_cl == 0)
                    goto usage;
            }
            arg_index++;
        }

    } else if (_wcsicmp(argv[arg_index], L"reload") == 0) {
        command = reload;
        arg_index++;
        target_host = CVY_LOCAL_HOST;

        // Verify that the cluster ip or "All" string is passed and there are no more arguments
        if ((arg_index == argc) || (arg_index + 1 < argc))
#ifdef BACKWARD_COMPATIBILITY
            if (arg_index == argc)
                target_cl = CVY_ALL_CLUSTERS;
            else 
                goto usage;
#else
            goto usage;
#endif
        else {
            // Retrieve the Cluster IP Address or "ALL"
            if (_wcsicmp (argv[arg_index], L"all") == 0)
            {
                target_cl   = CVY_ALL_CLUSTERS;
            }
            else
            {
                target_cl = WlbsResolve(argv [arg_index]);

                if (target_cl == 0)
                    goto usage;
            }
            arg_index++;
        }
    }
    else if (_wcsicmp(argv[arg_index], L"registry") == 0)
    {
        command = registry;
        target_host = CVY_LOCAL_HOST;
        arg_index++;

        if (argc < 4) goto reg_usage;

        if (_wcsicmp(argv[arg_index], L"mcastipaddress") == 0) {
            arg_index++;

            param1 = mcastipaddress;

            if (!(param2 = WlbsResolve(argv[arg_index])))
                goto reg_usage;

            /* The multicast IP address should be in the range of (224-239).x.x.x, but NOT (224-239).0.0.x or (224-239).128.0.x. */
            if ((param2 & 0xf0) != 0xe0 || (param2 & 0x00ffff00) == 0 || (param2 & 0x00ffff00) == 0x00008000) {
                Message_print (IDS_CTR_REG_INVAL_MCASTIPADDRESS);
                goto reg_usage;
            }

        } else if (_wcsicmp(argv[arg_index], L"iptomcastip") == 0) {
            arg_index++;

            param1 = iptomcastip;

            if (_wcsicmp(argv[arg_index], L"on") == 0)
                param2 = 1;
            else if (_wcsicmp(argv[arg_index], L"off") == 0)
                param2 = 0;
            else 
                goto reg_usage;
            
        } else if (_wcsicmp(argv[arg_index], L"masksrcmac") == 0) {
            arg_index++;

            param1 = masksrcmac;

            if (_wcsicmp(argv[arg_index], L"on") == 0)
                param2 = 1;
            else if (_wcsicmp(argv[arg_index], L"off") == 0)
                param2 = 0;
            else 
                goto reg_usage;

        } else if (_wcsicmp(argv[arg_index], L"iptomacenable") == 0) {
            arg_index++;

            param1 = iptomacenable;

            if (_wcsicmp(argv[arg_index], L"on") == 0)
                param2 = 1;
            else if (_wcsicmp(argv[arg_index], L"off") == 0)
                param2 = 0;
            else 
                goto reg_usage;

        } else {
            Message_print(IDS_CTR_REG_KEY, argv[arg_index]);
            goto reg_usage;
        }

        arg_index++;
        
        if (arg_index == argc) {
            target_cl = CVY_ALL_CLUSTERS;
        } else if (arg_index + 1 < argc)
            goto reg_usage;
        else {
            if (!(target_cl = WlbsResolve(argv[arg_index])))
                goto reg_usage;

            arg_index++;
        }

        if (argc != arg_index)
            goto reg_usage;
    }
    else if (_wcsicmp(argv[arg_index], L"tracing") == 0)
    {
        TraceOutput output;
        DWORD flags = TL_ERROR;
        DWORD tracing = 0;

        arg_index++;

        if (argc < 3) goto trace_usage;        
        
        if (_wcsicmp(argv[arg_index], L"file") == 0)
            output = TRACE_FILE;
        else if (_wcsicmp(argv[arg_index], L"console") == 0)
            output = TRACE_CONSOLE;
        else if (_wcsicmp(argv[arg_index], L"debugger") == 0)
            output = TRACE_DEBUGGER;
        else if (_wcsicmp(argv[arg_index], L"on") == 0) {
            output = TRACE_ALL;
            arg_index--;
        } else if (_wcsicmp(argv[arg_index], L"off") == 0) {
            output = TRACE_ALL;
            arg_index--;
        } else 
            goto trace_usage;

        arg_index++;

        if (_wcsicmp(argv[arg_index], L"on") == 0)
            tracing = 1;
        else if (_wcsicmp(argv[arg_index], L"off") == 0)
            tracing = 0;
        else 
            goto trace_usage;

        arg_index++;

        if (tracing && !Parse_tracing(argc, argv, &arg_index, &flags))
            goto trace_usage;

        if (Process_tracing(tracing, output, flags) != ERROR_SUCCESS)
            Message_print(IDS_CTR_TRACE_FAILED);

        return CVY_OK;
    }
    else
        goto usage;
    
    /* The remote control parameters need to be parsed. */
    dest_password = NULL;
    dest_addr = 0;
    dest_port = 0;

    while (arg_index < argc) {
        if (argv[arg_index][0] == L'/' || argv[arg_index][0] == L'-') {
            if (_wcsicmp(argv[arg_index] + 1, L"PASSW") == 0) {
                arg_index++;

                if (arg_index >= argc || argv[arg_index][0] == L'/' || argv[arg_index][0] == L'-') {
                    HANDLE hConsole;
                    DWORD dwMode;      // console mode
                    DWORD dwInputMode; // stdin input mode

                    Message_print(IDS_CTR_PASSW);

                    hConsole = GetStdHandle(STD_INPUT_HANDLE);
                    dwInputMode = GetFileType(hConsole);

                    //
                    // prompt for password, making sure password isn't echoed
                    // if the stdin is redirected, don't bother querying/changing console mode
                    //
                    if (dwInputMode == FILE_TYPE_CHAR) {
                        if (!GetConsoleMode(hConsole, &dwMode)) {
                            Error_print(FALSE);
                            return CVY_ERROR_SYSTEM;
                        }

                        if (!SetConsoleMode(hConsole, dwMode &= ~ENABLE_ECHO_INPUT)) {
                            Error_print(FALSE);
                            return CVY_ERROR_SYSTEM;
                        }
                    }

                    for (i = 0; i < CVY_STR_SIZE; i++) {
                        //
                        // read a character, copying to the buffer
                        // break out of loop on CR and EOF
                        //
                        if ((psw_buf[i] = fgetwc(stdin)) == WEOF)
                            break;

                        if (psw_buf[i] == L'\n')
                            break;
                    }

                    // NULL terminate the password
                    psw_buf[i] = L'\0';

                    // restore previous console mode
                    if (dwInputMode == FILE_TYPE_CHAR)
                        SetConsoleMode(hConsole, dwMode);

                    WConsole(L"\n");

                    if (i == 0)
                        dest_password = NULL;
                    else
                        dest_password = psw_buf;
                } else {
                    dest_password = argv[arg_index];
                    arg_index ++;
                }
            } else if (_wcsicmp(argv[arg_index] + 1, L"PORT") == 0) {
                arg_index++;

                if (arg_index >= argc || argv[arg_index][0] == L'/' || argv[arg_index][0] == L'-')
                    goto usage;

                dest_port = (USHORT)_wtoi(argv[arg_index]);

                if (dest_port == 0)
                    goto usage;

                arg_index++;
            } else if (_wcsicmp(argv[arg_index] + 1, L"DEST") == 0) {
                arg_index++;

                if (arg_index >= argc || argv[arg_index][0] == L'/' || argv[arg_index][0] == L'-')
                    goto usage;

                dest_addr = WlbsResolve(argv [arg_index]);

                if (dest_addr == 0)
                    goto usage;

                arg_index++;
            } else
                goto usage;
        } else
            goto usage;
    }

    if (target_cl != CVY_ALL_CLUSTERS) {
        Process(command, target_cl, target_host, param1, param2, dest_port, dest_addr, dest_password);
        return CVY_OK;
    }

    /* Enumerate all the clusters and call process for each one of them */
    else {
        DWORD clusters[CVY_MAX_ADAPTERS];
        DWORD i, len;

        len = CVY_MAX_ADAPTERS;

        WlbsEnumClusters(clusters, &len);

        if (!len) {
            Message_print(IDS_CTR_NO_CVY, CVY_NAME);
            return CVY_OK;
        }

        for (i = 0 ; i < len; i++) {
            WCHAR wbuf[CVY_STR_SIZE];
            DWORD buflen = CVY_STR_SIZE;

            WlbsAddressToString(clusters[i], wbuf, &buflen);

            Message_print(IDS_CTR_CLUSTER_ID, wbuf);

            Process(command, clusters[i], target_host, param1, param2, dest_port, dest_addr, dest_password);

            if (i < len - 1)
                WConsole (L"\n");
        }

        return CVY_OK;
    }

reg_usage:
        Message_print(IDS_CTR_REG_USAGE, CVY_NAME);
        return CVY_ERROR_USAGE;

trace_usage:
        Message_print(IDS_CTR_TRACE_USAGE, CVY_NAME);
        return CVY_ERROR_USAGE;
}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\driver\load.c ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

	load.c

Abstract:

	Windows Load Balancing Service (WLBS)
    Driver - load balancing algorithm

Author:

    bbain

ToDo:
    Kernel mode queue mgt
    Fail safe mode (single server for everything)
--*/

#ifdef KERNEL_MODE

#include <ntddk.h>

#include "log.h"
#include "univ.h"
#include "main.h" // added for multiple nic

static ULONG log_module_id = LOG_MODULE_LOAD;

#else

#include <stdlib.h>
#include <windows.h>
#endif

#include <stdio.h>
#include "wlbsparm.h"
#include "params.h"
#include "wlbsiocl.h"
#include "wlbsip.h"
#include "load.h"

//
// For WPP Event Tracing
//
#include "trace.h"  // for event tracing
#include "load.tmh" // for event tracing
#ifndef KERNEL_MODE

#define UNIV_PRINT(s)                   { printf s ; printf ("\n"); }
#define Univ_ulong_to_str(x, y, z)      (y)

#define LOG_MSG(c,s)
#define LOG_MSG1(c,s,d1)
#define LOG_MSG2(c,s,d1,d2)
#define LOG_MSG3(c,s,d1,d2,d3)
#define LOG_MSG4(c,s,d1,d2,d3,d4)

#else

#define malloc(s)   ExAllocatePoolWithTag (NonPagedPool, s, UNIV_POOL_TAG)
#define free(s)     ExFreePool (s)

#endif


//extern CVY_PARAMS   univ_params;
//#define univ_params  ( * (lp -> params))

void Bin_state_print(PBIN_STATE bp, ULONG my_host_id);
void Load_conn_kill(PLOAD_CTXT lp, PBIN_STATE bp);       /* v1.32B */


// static WCHAR        buf [256];      /* string buffer (V1.1.2) */


/* CONSTANTS */


#if 0   /* v2.06 */
#define BIN_ALL_ONES    ((MAP_T)-1)                     /* bin map state for 64 ones (v2.04) */
#endif
#define BIN_ALL_ONES    ((MAP_T)(0xFFFFFFFFFFFFFFF))    /* bin map state for 60 ones (v2.04) */


/* FUNCTIONS */


/* Byte offset of a field in a structure of the specified type: */

#define CVY_FIELD_OFFSET(type, field)    ((LONG_PTR)&(((type *)0)->field))

/*
 * Address of the base of the structure given its type, field name, and the
 * address of a field or field offset within the structure:
 */

#define STRUCT_PTR(address, type, field) ((type *)( \
                                          (PCHAR)(address) - \
                                          (PCHAR)CVY_FIELD_OFFSET(type, field)))

/*
 * Function: Load_teaming_consistency_notify
 * Description: This function is called to notify a team in which this adapter
 *              might be participating whether the teaming configuration in the
 *              heartbeats is consistent or not.  Inconsistent configuration
 *              results in the entire team being marked inactive - meaning that
 *              no adapter in the team will handle any traffic, except to the DIP.
 * Parameters: member - a pointer to the team membership information for this adapter.
 *             consistent - a boolean indicating the polarity of teaming consistency.
 * Returns: Nothing.
 * Author: shouse, 3.29.01
 * Notes: In order to check to see whether or not this adapter is part of a team,
 *        we need to look into the team member information for this adapter.  This
 *        access should be locked, but for performance reasons, we will only lock
 *        and check for sure if we "think" we're part of a team.  Worst case is that
 *        we are in the process of joining a team and we missed this check - no 
 *        matter, we'll notify them when/if we see this again. 
 */
VOID Load_teaming_consistency_notify (IN PBDA_MEMBER member, IN BOOL consistent) {

    /* Make sure that the membership information points to something. */
    ASSERT(member);

    /* We can check without locking to keep the common case minimally expensive.  If we do think
       we're part of a team, then we'll grab the lock and make sure.  If our first indication is 
       that we're not part of a team, then just bail out and if we actually are part of a team, 
       we'll be through here again later to notify our team if necessary. */
    if (!member->active) return;

    NdisAcquireSpinLock(&univ_bda_teaming_lock);
        
    /* If we are an active member of a BDA team, then notify our team of our state. */
    if (member->active) {
        /* Assert that the team actually points to something. */
        ASSERT(member->bda_team);
        
        /* Assert that the member ID is valid. */
        ASSERT(member->member_id <= CVY_BDA_MAXIMUM_MEMBER_ID);
        
        if (consistent) {
            UNIV_PRINT(("Load_teaming_consistency_notify:  Consistent configuration detected."));

            /* Mark this member as consistent. */
            member->bda_team->consistency_map |= (1 << member->member_id);
        } else {
            UNIV_PRINT(("Load_teaming_consistency_notify:  Inconsistent configuration detected."));

            /* Mark this member as inconsistent. */
            member->bda_team->consistency_map &= ~(1 << member->member_id);
            
            /* Inactivate the team. */
            member->bda_team->active = FALSE;
        }
    }

    NdisReleaseSpinLock(&univ_bda_teaming_lock);
}

/*
 * Function: Load_teaming_consistency_check
 * Description: This function is used to check our teaming configuration against the
 *              teaming configuration received in a remote heartbeat.  It does little 
 *              more than check the equality of two DWORDS, however, if this is our
 *              first notification of bad configuration, it prints a few debug state-
 *              ments as well.
 * Parameters: bAlreadyKnown - a boolean indication of whether or not we have already detected bad configuration.
 *                             If the misconfiguration is already known, no additional logging is done.
 *             member - a pointer to the team member structure for this adapter.
 *             myConfig - a DWORD containing the teaming "code" for me.
 *             theirCofnig - a DWORD containing the teaming "code" received in the heartbeat from them.
 * Returns: BOOLEAN (as ULONG) - TRUE means the configuration is consistent, FALSE indicates that it is not.
 * Author: shouse, 3.29.01
 * Notes:  In order to check to see whether or not this adapter is part of a team,
 *         we need to look into the team member information for this adapter.  This
 *         access should be locked, but for performance reasons, we will only lock
 *         and check for sure if we "think" we're part of a team.  Worst case is that
 *         we are in the process of joining a team and we missed this check - no 
 *         matter, we'll check again on the next heartbeat.
 */
ULONG Load_teaming_consistency_check (IN BOOLEAN bAlreadyKnown, IN PBDA_MEMBER member, IN ULONG myConfig, IN ULONG theirConfig) {

    /* We can check without locking to keep the common case minimally expensive.  If we do think
       we're part of a team, then we'll grab the lock and make sure.  If our first indication is 
       that we're not part of a team, then just bail out and if we actually are part of a team, 
       we'll be through here again later to check the consistency. */
    if (!member->active) return TRUE;

    NdisAcquireSpinLock(&univ_bda_teaming_lock);

    /* If we are part of a BDA team, check the BDA teaming configuration consistency. */
    if (member->active) {

        NdisReleaseSpinLock(&univ_bda_teaming_lock);
        
        /* If the bi-directional affinity teaming configurations don't match, do something about it. */
        if (myConfig != theirConfig) {
            if (!bAlreadyKnown) {
                UNIV_PRINT(("Bad teaming configuration detected: Mine=0x%08x, Theirs=0x%08x", myConfig, theirConfig));
                
                /* Report whether or not the teaming active flags are consistent. */
                if ((myConfig & CVY_BDA_TEAMING_CODE_ACTIVE_MASK) != (theirConfig & CVY_BDA_TEAMING_CODE_ACTIVE_MASK)) {
                    UNIV_PRINT(("Teaming active flags do not match: Mine=%d, Theirs=%d", 
                                (myConfig & CVY_BDA_TEAMING_CODE_ACTIVE_MASK) >> CVY_BDA_TEAMING_CODE_ACTIVE_OFFSET,
                                (theirConfig & CVY_BDA_TEAMING_CODE_ACTIVE_MASK) >> CVY_BDA_TEAMING_CODE_ACTIVE_OFFSET));
                }
                
                /* Report whether or not the master flags are consistent. */
                if ((myConfig & CVY_BDA_TEAMING_CODE_MASTER_MASK) != (theirConfig & CVY_BDA_TEAMING_CODE_MASTER_MASK)) {
                    UNIV_PRINT(("Master/slave settings do not match: Mine=%d, Theirs=%d",
                                (myConfig & CVY_BDA_TEAMING_CODE_MASTER_MASK) >> CVY_BDA_TEAMING_CODE_MASTER_OFFSET,
                                (theirConfig & CVY_BDA_TEAMING_CODE_MASTER_MASK) >> CVY_BDA_TEAMING_CODE_MASTER_OFFSET));
                }
                
                /* Report whether or not the reverse hashing flags are consistent. */
                if ((myConfig & CVY_BDA_TEAMING_CODE_HASHING_MASK) != (theirConfig & CVY_BDA_TEAMING_CODE_HASHING_MASK)) {
                    UNIV_PRINT(("Reverse hashing flags do not match: Mine=%d, Theirs=%d",
                                (myConfig & CVY_BDA_TEAMING_CODE_HASHING_MASK) >> CVY_BDA_TEAMING_CODE_HASHING_OFFSET,
                                (theirConfig & CVY_BDA_TEAMING_CODE_HASHING_MASK) >> CVY_BDA_TEAMING_CODE_HASHING_OFFSET));
                }
                
                /* Report whether or not the number of team members is consistent. */
                if ((myConfig & CVY_BDA_TEAMING_CODE_NUM_MEMBERS_MASK) != (theirConfig & CVY_BDA_TEAMING_CODE_NUM_MEMBERS_MASK)) {
                    UNIV_PRINT(("Numbers of team members do not match: Mine=%d, Theirs=%d",
                                (myConfig & CVY_BDA_TEAMING_CODE_NUM_MEMBERS_MASK) >> CVY_BDA_TEAMING_CODE_NUM_MEMBERS_OFFSET,
                                (theirConfig & CVY_BDA_TEAMING_CODE_NUM_MEMBERS_MASK) >> CVY_BDA_TEAMING_CODE_NUM_MEMBERS_OFFSET));
                }
                
                /* Report whether or not the team membership lists are consistent. */
                if ((myConfig & CVY_BDA_TEAMING_CODE_MEMBERS_MASK) != (theirConfig & CVY_BDA_TEAMING_CODE_MEMBERS_MASK)) {
                    UNIV_PRINT(("Participating members lists do not match: Mine=0x%04x, Theirs=0x%04x",
                                (myConfig & CVY_BDA_TEAMING_CODE_MEMBERS_MASK) >> CVY_BDA_TEAMING_CODE_MEMBERS_OFFSET,
                                (theirConfig & CVY_BDA_TEAMING_CODE_MEMBERS_MASK) >> CVY_BDA_TEAMING_CODE_MEMBERS_OFFSET));
                }
            }
            
            return FALSE;
        }

        return TRUE;
    }

    NdisReleaseSpinLock(&univ_bda_teaming_lock);

    return TRUE;
}

/*
 * Function: Load_teaming_code_create
 * Description: This function pieces together the ULONG code that represents the configuration 
 *              of bi-directional affinity teaming on this adapter.  If the adapter is not part
 *              of a team, then the code is zero.
 * Parameters: code - a pointer to a ULONG that will receive the 32-bit code word.
 *             member - a pointer to the team member structure for this adapter.
 * Returns: Nothing.
 * Author: shouse, 3.29.01
 * Notes:  In order to check to see whether or not this adapter is part of a team,
 *         we need to look into the team member information for this adapter.  This
 *         access should be locked, but for performance reasons, we will only lock
 *         and check for sure if we "think" we're part of a team.  Worst case is that
 *         we are in the process of joining a team and we missed this check - no 
 *         matter, we'll be through here the next time er send a heartbeat anyway.
 */
VOID Load_teaming_code_create (OUT PULONG code, IN PBDA_MEMBER member) {

    /* Assert that the code actually points to something. */
    ASSERT(code);

    /* Assert that the membership information actually points to something. */
    ASSERT(member);

    /* Reset the code. */
    *code = 0;

    /* We can check without locking to keep the common case minimally expensive.  If we do think
       we're part of a team, then we'll grab the lock and make sure.  If our first indication is 
       that we're not part of a team, then just bail out and if we actually are part of a team, 
       we'll be through here again later to generate the code next time we send a heartbeat. */
    if (!member->active) return;

    NdisAcquireSpinLock(&univ_bda_teaming_lock);

    /* If we are in a team, fill in the team configuration information. */
    if (member->active) {
        /* Assert that the team actually points to something. */
        ASSERT(member->bda_team);

        /* Add configuration information for teaming at each timeout. */
        CVY_BDA_TEAMING_CODE_CREATE(*code,
                                    member->active,
                                    member->master,
                                    member->reverse_hash,
                                    member->bda_team->membership_count,
                                    member->bda_team->membership_fingerprint);
    }
    
    NdisReleaseSpinLock(&univ_bda_teaming_lock);
}

/*
 * Function: Load_add_reference
 * Description: This function adds a reference to the load module of a given adapter.
 * Parameters: pLoad - a pointer to the load module to reference.
 * Returns: ULONG - The incremented value.
 * Author: shouse, 3.29.01
 * Notes: 
 */
ULONG Load_add_reference (IN PLOAD_CTXT pLoad) {

    /* Assert that the load pointer actually points to something. */
    ASSERT(pLoad);

    /* Increment the reference count. */
    return NdisInterlockedIncrement(&pLoad->ref_count);
}

/*
 * Function: Load_release_reference
 * Description: This function releases a reference on the load module of a given adapter.
 * Parameters: pLoad - a pointer to the load module to dereference.
 * Returns: ULONG - The decremented value.
 * Author: shouse, 3.29.01
 * Notes: 
 */
ULONG Load_release_reference (IN PLOAD_CTXT pLoad) {

    /* Assert that the load pointer actually points to something. */
    ASSERT(pLoad);

    /* Decrement the reference count. */
    return NdisInterlockedDecrement(&pLoad->ref_count);
}

/*
 * Function: Load_get_reference_count
 * Description: This function returns the current reference count on a given adapter.
 * Parameters: pLoad - a pointer to the load module to check.
 * Returns: ULONG - The current reference count.
 * Author: shouse, 3.29.01
 * Notes: 
 */
ULONG Load_get_reference_count (IN PLOAD_CTXT pLoad) {

    /* Assert that the load pointer actually points to something. */
    ASSERT(pLoad);

    /* Return the reference count. */
    return pLoad->ref_count;
}

/* Hash routine is based on a public-domain Tiny Encryption Algorithm (TEA) by
   David Wheeler and Roger Needham at the Computer Laboratory of Cambridge
   University. For reference, please consult
   http://vader.brad.ac.uk/tea/tea.shtml */

ULONG Map (
    ULONG               v1,
    ULONG               v2)         /* v2.06: removed range parameter */
{
    ULONG               y = v1,
                        z = v2,
                        sum = 0;

    const ULONG a = 0x67; //key [0];
    const ULONG b = 0xdf; //key [1];
    const ULONG c = 0x40; //key [2];
    const ULONG d = 0xd3; //key [3];

    const ULONG delta = 0x9E3779B9;

    //
    // Unroll the loop to improve performance
    //
    sum += delta;
    y += (z << 4) + a ^ z + sum ^ (z >> 5) + b;
    z += (y << 4) + c ^ y + sum ^ (y >> 5) + d;

    sum += delta;
    y += (z << 4) + a ^ z + sum ^ (z >> 5) + b;
    z += (y << 4) + c ^ y + sum ^ (y >> 5) + d;

    sum += delta;
    y += (z << 4) + a ^ z + sum ^ (z >> 5) + b;
    z += (y << 4) + c ^ y + sum ^ (y >> 5) + d;

    sum += delta;
    y += (z << 4) + a ^ z + sum ^ (z >> 5) + b;
    z += (y << 4) + c ^ y + sum ^ (y >> 5) + d;

    sum += delta;
    y += (z << 4) + a ^ z + sum ^ (z >> 5) + b;
    z += (y << 4) + c ^ y + sum ^ (y >> 5) + d;

    sum += delta;
    y += (z << 4) + a ^ z + sum ^ (z >> 5) + b;
    z += (y << 4) + c ^ y + sum ^ (y >> 5) + d;

    sum += delta;
    y += (z << 4) + a ^ z + sum ^ (z >> 5) + b;
    z += (y << 4) + c ^ y + sum ^ (y >> 5) + d;

    sum += delta;
    y += (z << 4) + a ^ z + sum ^ (z >> 5) + b;
    z += (y << 4) + c ^ y + sum ^ (y >> 5) + d;

    return y ^ z;
} /* end Map */


BOOLEAN Bin_targ_map_get(
    PLOAD_CTXT      lp,
    PBIN_STATE      binp,           /* ptr. to bin state */
    ULONG           my_host_id,
    PMAP_T          pmap)           /* ptr. to target map */
/*
  Get target map for this host

  returns BOOLEAN:
    TRUE    => valid target map is returned via pmap
    FALSE   => error occurred; no target map returned
*/
{
    ULONG       remsz,          /* remainder size */
                loadsz,         /* size of a load partition */
                first_bit;      /* first bit position of load partition */
    MAP_T       targ_map;       /* bit map of load bins for this host */
    ULONG       tot_load = 0;   /* total of load perecentages */
    ULONG *     pload_list;     /* ptr. to list of load balance perecntages */
    WCHAR       num [20];
    PMAIN_CTXT  ctxtp = CONTAINING_RECORD (lp, MAIN_CTXT, load);


    pload_list = binp->load_amt;

    if (binp->mode == CVY_SINGLE)
    {
        ULONG       max_pri;        /* highest priority */
        ULONG       i;

        first_bit  = 0;

        /* compute max priority */

        max_pri = CVY_MAX_HOSTS + 1;

        for (i=0; i<CVY_MAX_HOSTS; i++)
        {
            tot_load += pload_list[i];      /* v2.1 */

            if (pload_list[i] != 0) 
            {
                //
                // If another host has the same priority as this host, do not converge
                //
                if (i!= my_host_id && pload_list[i] == pload_list[my_host_id])
                {
                    if (!(lp->dup_sspri))
                    {
                        UNIV_PRINT(("Host %d: duplicate single svr priorities detected", my_host_id));
                        Univ_ulong_to_str (pload_list[my_host_id], num, 10);
                        LOG_MSG(MSG_ERROR_SINGLE_DUP, num);

                        lp->dup_sspri = TRUE;
                    }

                    /* 1.03: return error, which inhibits convergence; note that
                       rule will be automatically reinstated when duplicate server
                       priorities are eliminated */

                    return FALSE;
                }

                if ( pload_list[i] <= max_pri )
                {
                    max_pri = pload_list[i];
                }
            }
        }

        binp->tot_load = tot_load;      /* v2.1 */

        /* now determine if we are the highest priority host */

        if (pload_list[my_host_id] == max_pri)
        {
            loadsz   = CVY_MAXBINS;
            targ_map = BIN_ALL_ONES;    /* v2.05 */
        }
        else
        {
            loadsz   = 0;
            targ_map = 0;               /* v2.05 */
        }
    }

    else    /* load balanced */
    {
        ULONG       i, j;
        ULONG       partsz[CVY_MAX_HOSTS+1];
                                    /* new partition size per host */
        ULONG       cur_partsz[CVY_MAX_HOSTS+1];
                                    /* current partition size per host (v2.05) */
        ULONG       cur_host[CVY_MAXBINS];
                                    /* current host for each bin (v2.05) */
        ULONG       tot_partsz;     /* sum of partition sizes */
        ULONG       donor;          /* current donor host  (v2.05) */
        ULONG       cur_nbins;      /* current # bins (v2.05) */

        /* setup current partition sizes and bin to host mapping from current map (v2.05) */

        cur_nbins = 0;

        for (j=0; j<CVY_MAXBINS; j++)
            cur_host[j] = CVY_MAX_HOSTS;    /* all bins are initially orphans */

        for (i=0; i<CVY_MAX_HOSTS; i++)
        {
            ULONG   count = 0L;
            MAP_T   cmap  = binp->cur_map[i];

            tot_load += pload_list[i];  /* folded into this loop v2.1 */

            for (j=0; j<CVY_MAXBINS && cmap != ((MAP_T)0); j++)
            {
                /* if host i has bin j and it's not a duplicate, set up the mapping */

                if ((cmap & ((MAP_T)0x1)) != ((MAP_T)0) && cur_host[j] == CVY_MAX_HOSTS)
                {
                    count++;
                    cur_host[j] = i;
                }
                cmap >>= 1;
            }

            cur_partsz[i]  = count;
            cur_nbins     += count;
        }

        if (cur_nbins > CVY_MAXBINS)
        {
            UNIV_PRINT(("Bin_targ_map_get: error - too many bins found"));
            LOG_MSG(MSG_ERROR_INTERNAL, MSG_NONE);

            cur_nbins = CVY_MAXBINS;
        }

        /* if there are orphan bins, give them to pseudo-host CVY_MAX_HOSTS for now (v2.05) */

        if (cur_nbins < CVY_MAXBINS)
            cur_partsz[CVY_MAX_HOSTS] = CVY_MAXBINS - cur_nbins;
        else
            cur_partsz[CVY_MAX_HOSTS] = 0;

        /* compute total load */

        binp->tot_load = tot_load;      /* v2.06 */

        /* now compute tentative partition sizes and remainder after initially
           dividing up partitions among hosts */

        tot_partsz = 0;
        first_bit  = 0;

        for (i=0; i<CVY_MAX_HOSTS; i++)
        {
            if (tot_load > 0)
                partsz[i] = CVY_MAXBINS * pload_list[i] / tot_load;
            else
                partsz[i] = 0;

            tot_partsz += partsz[i];
        }

        remsz = CVY_MAXBINS - tot_partsz;

        /* check for zero total load */

        if (tot_partsz == 0)
        {
            * pmap = 0;
            return TRUE;
        }

        /* first dole out remainder bits to hosts that currently have bins (this
           minimizes the number of bins that have to move) v2.05 */

        if (remsz > 0)
        {
            for (i=0; i<CVY_MAX_HOSTS && remsz > 0; i++)
                if (cur_partsz[i] > 0 && pload_list[i] > 0)
                {
                    partsz[i]++;
                    remsz--;
                }
        }

        /* now dole out remainder bits to hosts that currently have no bins (to maintain
           the target load balance) v2.05 */

        if (remsz > 0)
        {
            for (i=0; i<CVY_MAX_HOSTS && remsz > 0; i++)
                if (cur_partsz[i] == 0 && pload_list[i] > 0)
                {
                    partsz[i]++;
                    remsz--;
                }
        }

        /* now dole out remainder bits among non-zero partitions round robin */

        i = 0;
        while (remsz > 0)
        {
            if (pload_list[i] > 0)
            {
                partsz[i]++;
                remsz--;
            }

            i++;
            if (i == CVY_MAX_HOSTS)
                i = 0;
        }

        /* reallocate bins to target hosts to match new partition sizes (v2.05) */

        donor = 0;
        partsz[CVY_MAX_HOSTS] = 0;      /* pseudo-host needs no bins */

        for (i=0; i<CVY_MAX_HOSTS; i++)
        {
            ULONG       rcvrsz;         /* current receiver's target partition */
            ULONG       donorsz;        /* current donor's target partition size */

            /* find and give this host some bins */

            rcvrsz = partsz[i];

            while (rcvrsz > cur_partsz[i])
            {
                /* find a host with too many bins */

                for (; donor < CVY_MAX_HOSTS; donor++)
                    if (partsz[donor] < cur_partsz[donor])
                        break;

                /* if donor is pseudo-host and it's out of bins, give it more bins
                   to keep algorithm from looping; this should never happen */

                if (donor >= CVY_MAX_HOSTS && cur_partsz[donor] == 0)
                {
                    UNIV_PRINT(("Bin_targ_map_get: error - no donor bins"));
                    LOG_MSG(MSG_ERROR_INTERNAL, MSG_NONE);
                    cur_partsz[donor] = CVY_MAXBINS;
                }

                /* now find the donor's bins and give them to the target host */

                donorsz = partsz[donor];        /* donor's target bin count */

                for (j=0; j<CVY_MAXBINS; j++)
                {
                    if (cur_host[j] == donor)
                    {
                        cur_host[j] = i;
                        cur_partsz[donor]--;
                        cur_partsz[i]++;

                        /* if this donor has no more to give, go find the next donor;
                           if this receiver needs no more, go on to next receiver */

                        if (donorsz == cur_partsz[donor] || rcvrsz == cur_partsz[i])
                            break;
                    }
                }

                /* if no bin was found, log a fatal error and exit */

                if (j == CVY_MAXBINS)
                {
                    UNIV_PRINT(("Bin_targ_map_get: error - no bin found"));
                    LOG_MSG(MSG_ERROR_INTERNAL, MSG_NONE);
                    break;
                }
            }
        }

        /* finally, compute bit mask for this host (v2.05) */

        targ_map = 0;

        for (j=0; j<CVY_MAXBINS; j++)
        {
            if (cur_host[j] == CVY_MAX_HOSTS)
            {
                UNIV_PRINT(("Bin_targ_map_get: error - incomplete mapping"));
                LOG_MSG(MSG_ERROR_INTERNAL, MSG_NONE);
                cur_host[j] = 0;
            }

            if (cur_host[j] == my_host_id)
                targ_map |= ((MAP_T)1) << j;
        }
    }

    * pmap = targ_map;

    return TRUE;

}  /* end Bin_targ_map_get */


BOOLEAN Bin_map_check(
    ULONG       tot_load,       /* total load percentage (v2.06) */
    PMAP_T      pbin_map)       /* bin map for all hosts */
{
    MAP_T       tot_map,        /* total map for all hosts */
                ovr_map,        /* overlap map between hosts */
                exp_tot_map;    /* expected total map */
    ULONG       i;


    /* compute expected total map (2.04) */

    if (tot_load == 0)              /* v2.06 */
        return TRUE;
    else
        exp_tot_map = BIN_ALL_ONES;

    /* compute total map and overlap map */

    tot_map = ovr_map = 0;

    for (i=0; i<CVY_MAX_HOSTS; i++)
    {
        ovr_map |= (pbin_map[i] & tot_map);
        tot_map |= pbin_map[i];
    }

    if (tot_map == exp_tot_map && ovr_map == 0)
        return TRUE;
    else
        return FALSE;

}  /* end Bin_map_check */


BOOLEAN Bin_map_covering(
    ULONG       tot_load,       /* total load percentage (v2.06) */
    PMAP_T      pbin_map)       /* bin map for all hosts */
{
    MAP_T       tot_map,        /* total map for all hosts */
                exp_tot_map;    /* expected total map */
    ULONG       i;


    /* compute expected total map (v2.04) */

    if (tot_load == 0)              /* v2.06 */
        return TRUE;
    else
        exp_tot_map = BIN_ALL_ONES;

    /* compute total map and overlap map */

    tot_map = 0;

    for (i=0; i<CVY_MAX_HOSTS; i++)
    {
        tot_map |= pbin_map[i];
    }

    if (tot_map == exp_tot_map)
        return TRUE;
    else
        return FALSE;

}  /* end Bin_map_covering */


void Bin_state_init(
    PLOAD_CTXT      lp,
    PBIN_STATE      binp,           /* ptr. to bin state */
    ULONG           index,          /* index of bin state */
    ULONG           my_host_id,
    ULONG           mode,
    ULONG           prot,
    BOOLEAN         equal_bal,      /* TRUE => balance equally across hosts */
    USHORT          affinity,
    ULONG           load_amt)       /* this host's load percentage if unequal */
/*
  Initialize bin state for a port group
*/
{
    ULONG       i;          /* loop variable */
    PMAIN_CTXT  ctxtp = CONTAINING_RECORD (lp, MAIN_CTXT, load);


    if ((equal_bal && mode == CVY_SINGLE) ||
        (mode == CVY_SINGLE && load_amt > CVY_MAX_HOSTS) ||
        index >= CVY_MAXBINS)
    {
        UNIV_ASSERT(FALSE);  // This should never happen
    }

    binp->code       = CVY_BINCODE;  /* (bbain 8/19/99) */
    binp->equal_bal  = equal_bal;
    binp->affinity   = affinity;
    binp->index      = index;
    binp->compatible = TRUE;
    binp->mode       = mode;
    binp->prot       = prot;

    /* initialize target and new load maps */

    binp->targ_map     = 0;
    binp->all_idle_map = BIN_ALL_ONES;
    binp->cmap         = 0;         /* v2.1 */

    for (i=0; i<CVY_MAX_HOSTS; i++)
    {
        binp->new_map[i]  = 0;
        binp->cur_map[i]  = 0;
        binp->chk_map[i]  = 0;
        binp->idle_map[i] = BIN_ALL_ONES;
    }

    /* initialize load percentages for all hosts */

    if (equal_bal)
    {
        load_amt = CVY_EQUAL_LOAD;
    }

    binp->tot_load = load_amt;

    for (i=0; i<CVY_MAX_HOSTS; i++)
    {
        if (i == my_host_id)
        {
            binp->orig_load_amt =
            binp->load_amt[i]   = load_amt;
        }
        else
            binp->load_amt[i] = 0;
    }

    /* initialize requesting state to no requests active and all bins local or none */

    binp->snd_bins  = 0;
    binp->rcv_bins  = 0;
    binp->rdy_bins  = 0;
    binp->idle_bins = BIN_ALL_ONES;     /* we are initially idle */

    /* perform first initialization only once (v2.06) */

    if (!(binp->initialized))
    {
        binp->tconn = 0;

        for (i=0; i<CVY_MAXBINS; i++)
        {
            binp->nconn[i] = 0;
        }

        Queue_init(&(binp->connq));
        binp->initialized = TRUE;
    }

}  /* end Bin_state_init */


BOOLEAN Bin_converge(
    PLOAD_CTXT      lp,
    PBIN_STATE      binp,           /* ptr. to bin state */
    ULONG           my_host_id)
/*
   Explicitly attempt to converge new port group state

  returns BOOL:
    TRUE  => all hosts have consistent new state for converging
    FALSE => parameter error or inconsistent convergence state
*/
{
    MAP_T           orphan_map;     /* map of orphans that this host will now own */
    ULONG           i;


    /* determine new target load map; 1.03: return in error if no map generated */

    if (!Bin_targ_map_get(lp, binp, my_host_id, &(binp->targ_map)))
        return FALSE;

    /* compute map of all currently orphan bins; note that all duplicates are
       considered to be orphans */

    orphan_map = 0;
    for (i=0; i<CVY_MAX_HOSTS; i++)
        orphan_map |= binp->cur_map[i];

    orphan_map = ~orphan_map;

    /* update our new map to include all current bins and orphans that are in the
       target set */

    binp->new_map[my_host_id] = binp->cmap |                        /* v2.1 */
                                (binp->targ_map & orphan_map);      /* 1.03 */

    /* check that new load maps are consistent and covering */

     return Bin_map_check(binp->tot_load, binp->new_map);   /* v2.06 */

}  /* end Bin_converge */


void Bin_converge_commit(
    PLOAD_CTXT      lp,
    PBIN_STATE      binp,           /* ptr. to bin state */
    ULONG           my_host_id)
/*
  Commit to new port group state
*/
{
    ULONG       i;
    PMAIN_CTXT  ctxtp = CONTAINING_RECORD (lp, MAIN_CTXT, load);

    /* check that new load maps are consistent and covering */

    if (!(Bin_map_check(binp->tot_load, binp->new_map)))    /* v2.06 */
    {
        if (!(lp->bad_map))
        {
            UNIV_PRINT(("Bin_converge_commit: bad new map"));
            LOG_MSG1(MSG_ERROR_INTERNAL, MSG_NONE, (ULONG_PTR)binp->new_map);

            lp->bad_map = TRUE;
        }
    }

    /* commit to new current maps */

    for (i=0; i<CVY_MAX_HOSTS; i++)
    {
        binp->chk_map[i] =
        binp->cur_map[i] = binp->new_map[i];
    }

    /* setup new send/rcv bins, and new ready to ship bins; note that ready to
       ship bins are cleared from the current map */

    binp->rdy_bins  = binp->cur_map[my_host_id]  & ~(binp->targ_map);       /* 1.03 */

    binp->cur_map[my_host_id] &= ~(binp->rdy_bins);

    binp->rcv_bins = binp->targ_map & ~(binp->cur_map[my_host_id]);

    binp->cmap     = binp->cur_map[my_host_id];                             /* v2.1 */

#if 0
    /* simulation output generator (2.05) */
    {
        ULONG lcount = 0L;
        ULONG ncount = 0L;
        MAP_T bins  = binp->rdy_bins;

        for (i=0; i<CVY_MAXBINS && bins != 0; i++, bins >>= 1)
            if ((bins & ((MAP_T)0x1)) != ((MAP_T)0))
                lcount++;

        bins = binp->targ_map;

        for (i=0; i<CVY_MAXBINS && bins != 0; i++, bins >>= 1)
            if ((bins & ((MAP_T)0x1)) != ((MAP_T)0))
                ncount++;

        printf("Connverge at host %d pg %d: losing %d, will have %d bins\n", my_host_id, binp->index,
               lcount, ncount);
    }
#endif

}  /* end Bin_converge_commit */


BOOLEAN Bin_host_update(
    PLOAD_CTXT      lp,
    PBIN_STATE      binp,           /* ptr. to bin state */
    ULONG           my_host_id,     /* my host's id MINUS one */
    BOOLEAN         converging,     /* TRUE => we are converging now */
    BOOLEAN         rem_converging, /* TRUE => remote host is converging */
    ULONG           rem_host,       /* remote host's id MINUS one */
    MAP_T           cur_map,        /* remote host's current map or 0 if host died */
    MAP_T           new_map,        /* remote host's new map if converging */
    MAP_T           idle_map,       /* remote host's idle map */
    MAP_T           rdy_bins,       /* bins that host is ready to send; ignored
                                       if converging to prevent bin transfers */
    ULONG           pkt_count,      /* remote host's packet count */
    ULONG           load_amt)       /* remote host's load percentage */
/*
  Update hosts's state for a port group

  returns BOOL:
    TRUE  => if not converging, normal return
             otherwise, all hosts have consistent state for converging
    FALSE => parameter error or inconsistent convergence state

  function:
    Updates hosts's state for a port group and attempts to converge new states if
    in convergence mode.  Called when a ping message is received or when a host
    is considered to have died.  Handles case of newly discovered hosts.  Can be
    called multiple times with the same information.
*/
{
    ULONG       i;
    PMAIN_CTXT  ctxtp = CONTAINING_RECORD (lp, MAIN_CTXT, load);

    if (rem_host >= CVY_MAX_HOSTS || rem_host == my_host_id)
    {
        UNIV_PRINT(("Bin_host_update: parameter error"));
        LOG_MSG2(MSG_ERROR_INTERNAL, MSG_NONE, rem_host+1, my_host_id+1);
        return FALSE;
    }

	UNIV_ASSERT(binp->code == CVY_BINCODE);	/* (bbain 8/19/99) */

#if 0   /* v2.06 */
    /* update current load balance information */

    if (binp->equal_bal && load_amt > 0)
    {
        load_amt = CVY_EQUAL_LOAD;
    }
#endif

    /* change load percentage if load changed */

    if (load_amt != binp->load_amt[rem_host])
    {
#if 0   /* v2.06 */
        binp->tot_load          += (load_amt - binp->load_amt[rem_host]);
#endif
        binp->load_amt[rem_host] = load_amt;
    }


    /* check for non-overlapping maps */

    if ((binp->cmap & cur_map) != 0)        /* v2.1 */
    {
        /* if we have received fewer packets than the other host or have a higher host id,
           remove duplicates from current map; this uses a heuristic that a newly joining
           host that was subnetted probably did not receive packets; we are trying to avoid
           having two hosts answer to the same client while minimizing disruption of service
           (v1.32B) */

        if (lp->send_msg.pkt_count < pkt_count ||
            (lp->send_msg.pkt_count == pkt_count && rem_host < my_host_id))
        {
            MAP_T   dup_map;

            dup_map = binp->cmap & cur_map;     /* v2.1 */

            binp->cur_map[my_host_id] &= ~dup_map;
            binp->cmap                 = binp->cur_map[my_host_id];     /* v2.1 */

            Load_conn_kill(lp, binp);
        }

        if (!converging && !rem_converging)
        {
            if (!(lp->overlap_maps))
            {
                UNIV_PRINT(("Host %d: two hosts with overlapping maps detected %d.", my_host_id, binp->index));
                LOG_MSG2(MSG_WARN_OVERLAP, MSG_NONE, my_host_id+1, binp->index);

                lp->overlap_maps = TRUE;
            }

            /* force convergence if in normal operations */

            return FALSE;
        }
    }

    /* now update remote host's current map */

    binp->cur_map[rem_host] = cur_map;

    /* update idle map and calculate new global idle map if it's changed */

    if (binp->idle_map[rem_host] != idle_map)
    {
        MAP_T   saved_map    = binp->all_idle_map;
        MAP_T   new_idle_map = BIN_ALL_ONES;
        MAP_T   tmp_map;

        binp->idle_map[rem_host] = idle_map;

        /* compute new idle map for all other hosts */

        for (i=0; i<CVY_MAX_HOSTS; i++)
            if (i != my_host_id)
                new_idle_map &= binp->idle_map[i];

        binp->all_idle_map = new_idle_map;

        /* see which locally owned bins have gone idle in all other hosts */

        tmp_map = new_idle_map & (~saved_map) & binp->cmap;     /* v2.1 */

        if (tmp_map != 0)
        {
            UNIV_PRINT(("Host %d pg %d: detected new all idle %08x for local bins",
                         my_host_id, binp->index, tmp_map));
        }

        tmp_map = saved_map & (~new_idle_map) & binp->cmap;     /* v2.1 */

        if (tmp_map != 0)
        {
            UNIV_PRINT(("Host %d pg %d: detected new non-idle %08x for local bins",
                         my_host_id, binp->index, tmp_map));
        }
    }
    /* 1.03: eliminated else clause */

    /* if we are not converging AND other host not converging, exchange bins;
       convergence must now be complete for both hosts */

    if (!converging)
    {
        if (!rem_converging) {      /* 1.03: reorganized code to exchange bins only when both
                                       hosts are not converging to avoid using stale bins */

            MAP_T       new_bins;           /* incoming bins from the remote host */

            /* check to see if remote host has received some bins from us */

            binp->rdy_bins &= (~cur_map);

            /* check to see if we can receive some bins */

            new_bins = binp->rcv_bins & rdy_bins;

            if (new_bins != 0)
            {
                if ((binp->cmap & new_bins) != 0)       /* v2.1 */
                {
                    if (!(lp->err_rcving_bins))
                    {
                        UNIV_PRINT(("Bin_host_update: receiving bins already own"));
                        LOG_MSG2(MSG_ERROR_INTERNAL, MSG_NONE, binp->cur_map[my_host_id], new_bins);

                        lp->err_rcving_bins = TRUE;
                    }
                }

                binp->cur_map[my_host_id]  |=  new_bins;
                binp->rcv_bins             &= ~new_bins;

                binp->cmap                  = binp->cur_map[my_host_id];    /* v2.1 */

                UNIV_PRINT(("====== host %d pg %d: received %08x ; cur now %08x",
                             my_host_id, binp->index, new_bins, binp->cur_map[my_host_id]));
            }

            /* do consistency check that all bins are covered */

            binp->chk_map[rem_host]   = cur_map | rdy_bins;
            binp->chk_map[my_host_id] = binp->cmap | binp->rdy_bins;        /* v2.1 */

            if (!Bin_map_covering(binp->tot_load, binp->chk_map))   /* v2.06 */
            {
                if (!(lp->err_orphans))
                {
#if 0
                    UNIV_PRINT(("Host %d: orphan bins detected", my_host_id));
                    LOG_MSG1(MSG_ERROR_INTERNAL, MSG_NONE, my_host_id+1);
#endif
                    lp->err_orphans = TRUE;
                }
            }
        }

        return TRUE;
    }

    /* otherwise, store proposed new load map and try to converge current host data */

    else
    {
        binp->chk_map[rem_host] =
        binp->new_map[rem_host] = new_map;

        return Bin_converge(lp, binp, my_host_id);
    }

}  /* end Bin_host_update */


void Bin_state_print(
    PBIN_STATE      binp,           /* ptr. to bin state */
    ULONG           my_host_id)
{
#if 0
    ULONG   i;
#endif

    UNIV_PRINT(("hst %d binp %x: maps: targ %x cur %x new %x; eq %d mode %d amt %d tot %d; bins: snd %x rcv %x rdy %x",
                 my_host_id, binp, binp->targ_map, binp->cur_map[my_host_id], binp->new_map[my_host_id],
                 binp->equal_bal, binp->mode, binp->load_amt[my_host_id],
                 binp->tot_load, binp->snd_bins, binp->rcv_bins, binp->rdy_bins));

#if 0
    for (i=0; i<CVY_MAX_HOSTS; i++)
    {
        UNIV_PRINT(("host %d: cur map %x new %x load_amt %d", i+1, binp->cur_map[i],
                     binp->new_map[i], binp->load_amt[i]));
    }

    for (i=0; i<CVY_MAXBINS; i++)
    {
        UNIV_PRINT(("bin %d: req_host %d bin_state %d nconn %d", i, binp->req_host[i],
                     binp->bin_state[i], binp->nconn[i]));
    }
#endif

}  /* end Bin_state_print */


void Load_conn_kill(
    PLOAD_CTXT      lp,
    PBIN_STATE      bp)
/*
  Kill all connections in a port group (v1.32B)
*/
{
    PCONN_ENTRY ep;         /* ptr. to connection entry */
    PCONN_DESCR dp;         /* ptr. to connection descriptor */
    QUEUE *     qp;         /* ptr. to bin's connection queue */
    QUEUE *     dqp;        /* ptr. to dirty queue */
    QUEUE *     fqp;        /* ptr. to free queue */
    LONG        count[CVY_MAXBINS];
                            /* count of cleaned up connections per bin for checking */
    ULONG       i;
    BOOLEAN     err_bin;    /* bin id error detected */
    BOOLEAN     err_count;  /* connection count error detected */
    PMAIN_CTXT  ctxtp = CONTAINING_RECORD (lp, MAIN_CTXT, load);

    err_bin   =
    err_count = FALSE;

    qp  = &(bp->connq);
    dqp = &(lp->conn_dirtyq);
    fqp = &(lp->conn_freeq);

    for (i=0; i<CVY_MAXBINS; i++)
        count[i] = 0;

#ifdef TRACE_DIRTY
    DbgPrint ("marking connections as dirty");
#endif

    /* remove connections from bin queue and either make dirty or cleanup  */

    ep = (PCONN_ENTRY)Queue_deq(qp);
	
    while (ep != NULL)
    {
		UNIV_ASSERT (ep->code == CVY_ENTRCODE);	/* (bbain 8/19/99) */

        if (ep->bin >= CVY_MAXBINS)
        {
            if (!err_bin)
            {
                UNIV_PRINT(("Load_conn_kill: bad bin id"));
                LOG_MSG2(MSG_ERROR_INTERNAL, MSG_NONE, ep->bin, CVY_MAXBINS);

                err_bin = TRUE;
            }
        }
        else
        {
            count[ep->bin]++;
        }

        /* make connection and bin dirty if we don't have a zero timeout period so that they
           will not be handled by TCP/IP anymore; this avoids allowing TCP/IP's now stale
           connection state from handling packets for newer connections should traffic be
           directed to this host in the future */

        if (lp->cln_timeout > 0)
        {
            ep->dirty = TRUE;
            Queue_enq(dqp, &(ep->blink));

            lp->dirty_bin[ep->bin] = TRUE;
            lp->cln_waiting        = TRUE;
        }

        /* otherwise, just cleanup the connection */

        else
        {
            CVY_CONN_CLEAR(ep);     /* v2.06 */

            Link_unlink(&(ep->rlink));      /* V2.1.5 */

            /* if entry is not in the hash table, free the descriptor */

            if (ep->alloc)
            {
                dp = STRUCT_PTR(ep, CONN_DESCR, entry);
				UNIV_ASSERT (dp->code == CVY_DESCCODE);	/* (bbain 8/19/99) */

                Link_unlink(&(dp->link));
                Queue_enq(fqp, &(dp->link));
            }
        }

        ep = (PCONN_ENTRY)Queue_deq(qp);
    }

    /* now make bins idle */

    for (i=0; i<CVY_MAXBINS; i++)
    {
        if (bp->nconn[i] != count[i])
        {
            if (!err_count)
            {
                UNIV_PRINT(("Load_conn_kill: bad connection count %d %d bin %d", bp->nconn[i], (LONG)count[i], i));

/* KXF 2.1.1 - removed after tripped up at MSFT a few times */
#if 0
                LOG_MSG3(MSG_ERROR_INTERNAL, MSG_NONE, bp->nconn[i], (LONG)count[i], i);
#endif

                err_count = TRUE;
            }
        }

        bp->nconn[i] = 0;
    }

    lp->nconn -= bp->tconn;         /* v2.1 */
    if (lp->nconn < 0)
        lp->nconn = 0;
    bp->tconn = 0;                  /* v2.06 */

    bp->idle_bins = BIN_ALL_ONES;

    /* if we at least one connection is dirty, restart cleanup timeout period */

    if (lp->cln_waiting)
    {
#ifdef TRACE_DIRTY
        DbgPrint ("setting cleanup timeout");
#endif
        lp->cur_time = 0;
    }
    else
    {
#ifdef TRACE_DIRTY
        DbgPrint ("no dirty connections found");
#endif
    }

}  /* end Load_conn_kill */


void Load_conn_cleanup(
    PLOAD_CTXT      lp)
/*
  Clean up all dirty connections (v1.32B)
*/
{
    PCONN_ENTRY ep;         /* ptr. to connection entry */
    PCONN_DESCR dp;         /* ptr. to connection descriptor */
    QUEUE *     fqp;        /* ptr. to free queue */
    QUEUE *     dqp;        /* ptr. to dirty queue */
    BOOLEAN     err_bin;    /* bin id error detected */
    ULONG       i;
    PMAIN_CTXT  ctxtp = CONTAINING_RECORD (lp, MAIN_CTXT, load);

    err_bin = FALSE;

    dqp = &(lp->conn_dirtyq);
    fqp = &(lp->conn_freeq);

#ifdef TRACE_DIRTY
     DbgPrint ("cleaning up dirty connections");
#endif

    /* dequeue and clean up all connections on dirty connection queue */

    ep = (PCONN_ENTRY)Queue_deq(dqp);

    while (ep != NULL)
    {
		UNIV_ASSERT (ep->code == CVY_ENTRCODE);	/* (bbain 8/19/99) */

        if (ep->bin >= CVY_MAXBINS)
        {
            if (!err_bin)
            {
                UNIV_PRINT(("Load_conn_cleanup: bad bin id"));
                LOG_MSG2(MSG_ERROR_INTERNAL, MSG_NONE, ep->bin, CVY_MAXBINS);

                err_bin = TRUE;
            }
        }

        CVY_CONN_CLEAR(ep);

        ep->dirty = FALSE;

        Link_unlink(&(ep->rlink));          /* V2.1.5 */

        /* if entry is not in the hash table, free the descriptor */

        if (ep->alloc)
        {
            dp = STRUCT_PTR(ep, CONN_DESCR, entry);
			UNIV_ASSERT (dp->code == CVY_DESCCODE);	/* (bbain 8/19/99) */

            Link_unlink(&(dp->link));
            Queue_enq(fqp, &(dp->link));
        }

        ep = (PCONN_ENTRY)Queue_deq(dqp);
    }

    /* clear all dirty bin flags */

    for (i=0; i<CVY_MAXBINS; i++)
        lp->dirty_bin[i] = FALSE;

}  /* end Load_conn_cleanup */


void Load_stop(
    PLOAD_CTXT      lp)
{
    ULONG       i;
    IRQLEVEL    irql;
    PMAIN_CTXT  ctxtp = CONTAINING_RECORD (lp, MAIN_CTXT, load);

	UNIV_ASSERT(lp->code == CVY_LOADCODE);	/* (bbain 8/19/99) */
	
    if (!(lp->active))
        return;

    LOCK_ENTER(&(lp->lock), &irql);

    /* make connections for all rules dirty so they will not be handled */

    for (i=0; i<lp->send_msg.nrules; i++)
    {
        PBIN_STATE  bp;     /* ptr. to bin state */

        bp = &(lp->pg_state[i]);
		UNIV_ASSERT(bp->code == CVY_BINCODE);	/* (bbain 8/21/99) */

        Load_conn_kill(lp, bp);  /* (v1.32B) */

        /* advertise that we are not handling any load in case a ping is sent out */

        lp->send_msg.cur_map[i]  = 0;
        lp->send_msg.new_map[i]  = 0;
        lp->send_msg.idle_map[i] = BIN_ALL_ONES;
        lp->send_msg.rdy_bins[i] = 0;
        lp->send_msg.load_amt[i] = 0;
    }

    lp->send_msg.state     = HST_CVG;       /* force convergence (v2.1) */

    /* go inactive until restarted */

    lp->active = FALSE;
    lp->nconn  = 0;         /* v2.1 */

    LOCK_EXIT(&(lp->lock), irql);

}  /* end Load_stop */


void Load_start(            /* (v1.32B) */
    PLOAD_CTXT      lp)
{
    ULONG       i;
    BOOLEAN     ret;
    PMAIN_CTXT  ctxtp = CONTAINING_RECORD (lp, MAIN_CTXT, load);
    WCHAR me[20];

    if (!(lp->initialized))
        Load_init(lp, & ctxtp -> params);

    UNIV_ASSERT(lp->code == CVY_LOADCODE);	/* (bbain 8/19/99) */

    if (lp->active)
        return;

    lp->my_host_id =(* (lp->params)).host_priority - 1;

    lp->ping_map   =
    lp->host_map   = 1 << lp->my_host_id;

    lp->last_hmap  = 0;		/* bbain RTM RC1 6/23/99 */

    for (i=0; i<CVY_MAX_HOSTS; i++)
    {
        lp->nmissed_pings[i] = 0;
    }

    lp->min_missed_pings = (* (lp->params)).alive_tolerance;
    lp->cln_timeout      = (* (lp->params)).cleanup_delay;
    lp->def_timeout      = (* (lp->params)).alive_period;
    lp->stable_map       = 0;
    lp->consistent       = TRUE;

    /* Intiialize the bad teaming configuration detected flag. */
    lp->bad_team_config  = FALSE;

    lp->dup_hosts        = FALSE;
    lp->dup_sspri        = FALSE;
    lp->bad_map          = FALSE;
    lp->overlap_maps     = FALSE;
    lp->err_rcving_bins  = FALSE;
    lp->err_orphans      = FALSE;
    lp->bad_num_rules    = FALSE;
    lp->alloc_inhibited  = FALSE;
    lp->alloc_failed     = FALSE;
    lp->bad_defrule      = FALSE;

    lp->scale_client     = (BOOLEAN)(* (lp->params)).scale_client;
    lp->my_stable_ct     = 0;
    lp->all_stable_ct    = 0;
    lp->min_stable_ct    = lp->min_missed_pings;

    lp->dscr_per_alloc   = (* (lp->params)).dscr_per_alloc;
    lp->max_dscr_allocs  = (* (lp->params)).max_dscr_allocs;

    lp->pkt_count        = 0;       /* 1.32B */

    /* initialize port group bin states; add a default rule at the end */

    if ((* (lp->params)).num_rules >= (CVY_MAX_RULES - 1))
    {
        UNIV_PRINT(("Load_start: too many rules; using max possible."));
        lp->send_msg.nrules = (USHORT)CVY_MAX_RULES;
    }
    else
        lp->send_msg.nrules = (USHORT)((* (lp->params)).num_rules) + 1;

    for (i=0; i<lp->send_msg.nrules; i++)
    {
        PBIN_STATE  bp;     /* ptr. to bin state */
        PCVY_RULE   rp;     /* ptr. to rules array */

        bp = &(lp->pg_state[i]);
        rp = &((* (lp->params)).port_rules[i]);

        if (i == (((ULONG)lp->send_msg.nrules) - 1))

            /* initialize bin state for default rule to single server with
                host priority */

            Bin_state_init(lp, bp, i, lp->my_host_id, CVY_SINGLE, CVY_TCP_UDP,
                           FALSE, (USHORT)0, (* (lp->params)).host_priority);

        else if (rp->mode == CVY_SINGLE)
            Bin_state_init(lp, bp, i, lp->my_host_id, rp->mode, rp->protocol,
                           FALSE, (USHORT)0, rp->mode_data.single.priority);
        else if (rp->mode == CVY_MULTI)
            Bin_state_init(lp, bp, i, lp->my_host_id, rp->mode, rp->protocol,
                           (BOOLEAN)(rp->mode_data.multi.equal_load),
                           rp->mode_data.multi.affinity,
                           (rp->mode_data.multi.equal_load ?
                            CVY_EQUAL_LOAD : rp->mode_data.multi.load));

        /* handle CVY_NEVER mode as multi-server. the check for
           those modes is done before attempting to hash to the bin in
           Load_packet_check and Load_conn_advise so bin distribution plays
           no role in the behavior, but simply allows the rule to be valid
           across all of the operational servers */

        else
            Bin_state_init(lp, bp, i, lp->my_host_id, rp->mode, rp->protocol,
                           TRUE, (USHORT)0, CVY_EQUAL_LOAD);

        ret = Bin_converge(lp, bp, lp->my_host_id);
        if (!ret)
        {
            UNIV_PRINT(("Load_start: initial convergence inconsistent"));
            LOG_MSG(MSG_ERROR_INTERNAL, MSG_NONE);
        }

        /* export current port group state to send msg */

        if (i == (((ULONG)(lp->send_msg.nrules)) - 1))
            lp->send_msg.rcode[i]= 0;
        else
            lp->send_msg.rcode[i]= rp->code;

        lp->send_msg.cur_map[i]   = bp->cmap;                       /* v2.1 */
        lp->send_msg.new_map[i]   = bp->new_map[lp->my_host_id];
        lp->send_msg.idle_map[i]  = bp->idle_bins;
        lp->send_msg.rdy_bins[i]  = bp->rdy_bins;
        lp->send_msg.load_amt[i]  = bp->load_amt[lp->my_host_id];
        /* ###### for keynote - ramkrish */
        lp->send_msg.pg_rsvd1[i]  = (ULONG)bp->all_idle_map;
    }

    /* initialize send msg */

    lp->send_msg.host_id   = (USHORT)(lp->my_host_id);
    lp->send_msg.master_id = (USHORT)(lp->my_host_id);
    lp->send_msg.hcode     = lp->params->install_date;
    lp->send_msg.pkt_count = lp->pkt_count;         /* 1.32B */

    Univ_ulong_to_str (lp->my_host_id+1, me, 10);

    /* Tracking convergence - Starting convergence because this host is joining the cluster. */
    LOG_MSGS(MSG_INFO_CONVERGING_NEW_MEMBER, me, me);
    TRACE_CONVERGENCE("Initiating convergence on host %d.  Reason: Host %d is joining the cluster.", lp->my_host_id+1, lp->my_host_id+1);

    /* Tracking convergence - Starting convergence. */
    lp->send_msg.state     = HST_CVG;

    /* activate module */

    lp->active      = TRUE;

}  /* end Load_start */


void Load_init(
   PLOAD_CTXT       lp,
   PCVY_PARAMS      params)
{
    ULONG       i;
    PMAIN_CTXT  ctxtp = CONTAINING_RECORD (lp, MAIN_CTXT, load);

    TRACE_INFO("-> Load_init: lp=0x%p, param=0x%p", lp, params);

    LOCK_INIT(&(lp->lock));

    if (!(lp->initialized))
    {
        lp->code = CVY_LOADCODE;	/* (bbain 8/19/99) */

        /* initialize hashed connection descriptors and queues */

        for (i=0; i<CVY_MAX_CHASH; i++)
        {
            PCONN_ENTRY     ep;

            ep = &(lp->hashed_conn[i]);

            ep->code = CVY_ENTRCODE;    /* (bbain 8/19/99) */
            ep->alloc = FALSE;
            ep->dirty = FALSE;          /* v1.32B */

            CVY_CONN_CLEAR(ep);
            Link_init(&(ep->blink));
            Link_init(&(ep->rlink));    /* V2.1.5 */

            Queue_init(&(lp->connq[i]));
        }

        /* initialize connection free and dirty queues; free descriptors */

        Queue_init(&(lp->conn_freeq));
        Queue_init(&(lp->conn_dirtyq));                     /* v1.32B */
        Queue_init(&(lp->conn_rcvryq));                     /* V2.1.5 */

        for (i=0; i<CVY_INIT_QCONN; i++)
        {
            lp->conn_descr[i].code = CVY_DESCCODE;			/* (bbain 8/19/99) */
            Link_init(&(lp->conn_descr[i].link));
            lp->conn_descr[i].entry.code = CVY_ENTRCODE;	/* (bbain 8/21/99) */
            lp->conn_descr[i].entry.alloc = TRUE;
            lp->conn_descr[i].entry.dirty = FALSE;          /* v1.32B */

            CVY_CONN_CLEAR(&(lp->conn_descr[i].entry));
            Link_init(&(lp->conn_descr[i].entry.blink));
            Link_init(&(lp->conn_descr[i].entry.rlink));    /* V2.1.5 */

            Queue_enq(&(lp->conn_freeq), &(lp->conn_descr[i].link));
        }

        /* (v1.32B) */

        for (i=0; i<CVY_MAXBINS; i++)
            lp->dirty_bin[i] = FALSE;

        lp->cln_waiting      = FALSE;
        lp->def_timeout      =
        lp->cur_timeout      = params -> alive_period;
        lp->nqalloc          = 0;
        lp->nconn            = 0;       /* v2.1 */
        lp->active           = FALSE;
        lp->initialized      = TRUE;

        /* clear list of descriptor queue allocations (bbain 2/25/99) */

        for (i=0; i<CVY_MAX_MAX_DSCR_ALLOCS; i++)
            lp->qalloc_list[i] = (PCONN_DESCR)NULL;

        lp -> params = params;
    }
    else
    {
        UNIV_ASSERT(lp->code == CVY_LOADCODE);	/* (bbain 8/19/99) */
    }

    /* Initialize the reference count on this load module. */
    lp->ref_count = 0;


    /* don't start module (v1.32B) */
    TRACE_INFO("<- Load_init");

}  /* end Load_init */


void Load_cleanup(            /* (bbain 2/25/99) */
    PLOAD_CTXT      lp)
{
    ULONG       i;
    PMAIN_CTXT  ctxtp = CONTAINING_RECORD (lp, MAIN_CTXT, load);

    UNIV_ASSERT(lp->code == CVY_LOADCODE);	/* (bbain 8/19/99) */

    /* free all descriptor queue allocations */

    if (lp->nqalloc > CVY_MAX_MAX_DSCR_ALLOCS)
        lp->nqalloc = CVY_MAX_MAX_DSCR_ALLOCS;

    for (i=0; i<lp->nqalloc; i++)
        if (lp->qalloc_list[i] != (PCONN_DESCR)NULL)
            free((PVOID)(lp->qalloc_list[i]));

}  /* end Load_cleanup */


void Load_convergence_start(
    PLOAD_CTXT      lp)
{
    PMAIN_CTXT  ctxtp = CONTAINING_RECORD (lp, MAIN_CTXT, load);
    lp->consistent    = TRUE;       /* 1.03 */

    /* setup initial convergence state */

    lp->send_msg.state = HST_CVG;

    lp->stable_map    = 0;
    lp->my_stable_ct  = 0;
    lp->all_stable_ct = 0;

    lp->send_msg.master_id = (USHORT)(lp->my_host_id);

}  /* end Load_convergence_start */


void Load_msg_rcv(
    PLOAD_CTXT      lp,
    PPING_MSG       pmsg)           /* ptr. to ping message */
{
    ULONG       i;
    BOOLEAN     consistent;
    ULONG       my_host;
    ULONG       rem_host;
    ULONG       saved_map;      /* saved host map */
    PPING_MSG   sendp;          /* ptr. to my send message */
    IRQLEVEL    irql;
    WCHAR       me[20];
    WCHAR       them[20];
    ULONG       map;
    PMAIN_CTXT  ctxtp = CONTAINING_RECORD (lp, MAIN_CTXT, load);

    /* Used for tracking convergence and event logging. */
    BOOLEAN     bInconsistentMaster = FALSE;
    BOOLEAN     bInconsistentTeaming = FALSE;
    BOOLEAN     bInconsistentPortRules = FALSE;

    UNIV_ASSERT(lp->code == CVY_LOADCODE);

    TRACE_HB("Recv HB from host %d",  (ULONG) pmsg->host_id + 1);

    if (!(lp->active))
        return;

    my_host  = lp->my_host_id;
    rem_host = (ULONG) pmsg->host_id;

    Univ_ulong_to_str (my_host+1, me, 10);
    Univ_ulong_to_str (rem_host+1, them, 10);

    sendp    = &(lp->send_msg);

    if (rem_host >= CVY_MAX_HOSTS)
        return;

    LOCK_ENTER(&(lp->lock), &irql);

    /* filter out packets broadcast by this host */

    if(rem_host == my_host)
    {
        /* if this packet was really from another host, we have duplicate host ids */

        if (sendp->hcode != pmsg->hcode)
        {
            if (!(lp->dup_hosts))
            {
                UNIV_PRINT(("Duplicate host ids detected."));

                LOG_MSG(MSG_ERROR_HOST_ID, me);

                lp->dup_hosts = TRUE;
            }

            /* Tracking convergence - Starting convergence because duplicate host IDs were detected in the cluster. */
            if (sendp->state == HST_NORMAL) {
                LOG_MSGS(MSG_INFO_CONVERGING_DUPLICATE_HOST_ID, me, them);
                TRACE_CONVERGENCE("Initiating convergence on host %d.  Reason: Host %d is configured with the same host ID.", my_host+1, rem_host+1);
            }

            /* Tracking convergence - Starting convergence. */
            Load_convergence_start(lp);
        }

        /* just update ping and host maps for us */
        lp->ping_map |= (1 << my_host);
        lp->host_map |= (1 << my_host);

        LOCK_EXIT(&(lp->lock), irql);
        return;
    }

    if (sendp->nrules != pmsg->nrules)
    {
        if (!(lp->bad_num_rules))
        {
            UNIV_PRINT(("Host %d: Hosts have diff # rules.", my_host));

            LOG_MSG2(MSG_ERROR_RULES_MISMATCH, them, sendp->nrules, pmsg->nrules);

            lp->bad_num_rules = TRUE;
        }

        /* Tracking convergence - Starting convergence because the number of port rules on this host and the remote host do not match. */
        if (sendp->state == HST_NORMAL) {
            LOG_MSGS(MSG_INFO_CONVERGING_NUM_RULES, me, them);            
            TRACE_CONVERGENCE("Initiating convergence on host %d.  Reason: Host %d is configured with a conflicting number of port rules.", my_host+1, rem_host+1);
        }

        /* Tracking convergence - Starting convergence. */
        Load_convergence_start(lp);

        /* just update ping and host maps for remote host (bbain 2/17/99) */

        lp->ping_map |= (1 << rem_host);
        lp->host_map |= (1 << rem_host);

        LOCK_EXIT(&(lp->lock), irql);
        return;
    }

    /* update mastership and see if consistent */

    if (rem_host < sendp->master_id)
        sendp->master_id = (USHORT)rem_host;

    consistent = sendp->master_id == pmsg->master_id;       /* 1.03 */

    /* For the purposes of logging the reason for convergence, note this inconsistency. */
    if (!consistent) bInconsistentMaster = TRUE;

    /* update ping and host maps to include remote host */

    lp->ping_map  |= (1 << rem_host);

    saved_map      = lp->host_map;
    lp->host_map  |= (1 << rem_host);

    /* handle host convergence */

    if (sendp->state != HST_NORMAL)
    {
        /* if master, update stable map for remote host */

        if (sendp->master_id == my_host)
        {
            if (pmsg->state == HST_STABLE)
            {
                lp->stable_map |= (1 << rem_host);
            }
            else
            {
                lp->stable_map    &= ~(1 << rem_host);
                lp->all_stable_ct  = 0;
            }
        }

        /* otherwise, update state if have global stable convergence  and the current
           master has signalled completion by returning to the normal state; note
           that we must do this prior to updating port group states  */

        else if (rem_host == sendp->master_id && pmsg->state == HST_NORMAL)
        {
            if (sendp->state == HST_STABLE)
            {
                sendp->state = HST_NORMAL;

                /* Notify our BDA team that this cluster is consistently configured.  
                   If we are not part of a BDA team, this call is essentially a no-op. */
                Load_teaming_consistency_notify(&ctxtp->bda_teaming, TRUE);

                /* Reset the bad teaming configuration detected flag if we are converged. */
                lp->bad_team_config = FALSE;

                lp->dup_hosts       = FALSE;
                lp->dup_sspri       = FALSE;
                lp->bad_map         = FALSE;
                lp->overlap_maps    = FALSE;
                lp->err_rcving_bins = FALSE;
                lp->err_orphans     = FALSE;
                lp->bad_num_rules   = FALSE;
                lp->pkt_count       = 0;      /* v1.32B */

                for (i=0; i<sendp->nrules; i++)
                {
                    PBIN_STATE      bp;

                    bp = &(lp->pg_state[i]);

                    bp->compatible = TRUE;      /* 1.03 */

                    Bin_converge_commit(lp, bp, my_host);

                    UNIV_PRINT(("Host %d pg %d: new cur map %x idle %x all %x",
                                my_host, i, bp->cur_map[my_host], bp->idle_bins,
                                bp->all_idle_map));

#if 0   /* 1.03: only update ping message in Load_timeout to avoid locking send */

                    /* export current port group state */

                    sendp->cur_map[i]   = bp->cmap;                 /* v2.1 */
                    sendp->new_map[i]   = bp->new_map[my_host];
                    sendp->idle_map[i]  = bp->idle_bins;
                    sendp->rdy_bins[i]  = bp->rdy_bins;
                    sendp->load_amt[i]  = bp->load_amt[my_host];
#endif
                }

#if 0
                sendp->pkt_count = lp->pkt_count;           /* 1.32B */
#endif

                UNIV_PRINT(("Host %d: converged as slave", my_host));
                /* log convergence completion if host map changed (bbain RTM RC1 6/23/99) */
                Load_hosts_query (lp, TRUE, & map);
                lp->last_hmap = lp->host_map;
            }
            else
            {
                /* Tracking convergence - Starting convergence because the DEFAULT host prematurely ended convergence.  In this case, we 
                   are guaranteed to already be in the HST_CVG state, and because this message can be misleading in some circumstances, 
                   we do not log an event.  For instance, due to timing issues, when a host joins a cluster he can receive a HST_NORMAL 
                   heartbeat from the DEFAULT host while it is still in the HST_CVG state simply because that heartbeat left the DEFAULT 
                   host before it received our first heartbeat, which initiated convergence. */
                TRACE_CONVERGENCE("Initiating convergence on host %d.  Reason: Host %d, the DEFAULT host, prematurely terminated convergence.", my_host+1, rem_host+1);

                /* Tracking convergence - Starting convergence. */
                Load_convergence_start(lp);
            }
        }
    }

    /* Compare the teaming configuration of this host with the remote host.  If the
       two are inconsitent and we are part of a team, we will initiate convergence. */
    if (!Load_teaming_consistency_check(lp->bad_team_config, &ctxtp->bda_teaming, sendp->teaming, pmsg->teaming)) {
        /* Only log an event if the teaming configuration was, but is now not, consistent. */
        if (!lp->bad_team_config) {
            /* Note that we saw this. */
            lp->bad_team_config = TRUE;
            
            /* Log the event. */
            LOG_MSG(MSG_ERROR_BDA_BAD_TEAM_CONFIG, them);
        }

        /* Notify the team that this cluster is NOT consistently configured. */
        Load_teaming_consistency_notify(&ctxtp->bda_teaming, FALSE);

        /* Mark the heartbeats inconsistent to force and retain convergence. */
        consistent = FALSE;

        /* For the purposes of logging the reason for convergence, note this inconsistency. */
        bInconsistentTeaming = TRUE;
    }

    /* update port group state */

    for (i=0; i<sendp->nrules; i++)
    {
        BOOLEAN     ret;
        PBIN_STATE  bp;

        bp = &lp->pg_state[i];

        /* if rule codes don't match, print message and handle incompatibility (1.03: note
           that we previously marked rule invalid, which would stop processing) */

        if (sendp->rcode[i] != pmsg->rcode[i])
        {
            /* 1.03: if rule was peviously compatible, print message */

            if (bp->compatible)
            {
                PCVY_RULE rp;

                UNIV_PRINT(("Host %d pg %d: rule codes do not match.", lp->my_host_id, i));

				/* bbain 8/27/99 */
                LOG_MSG4(MSG_ERROR_RULES_MISMATCH, them, rem_host, i, sendp->rcode[i], pmsg->rcode[i]);

                /* Get the port rule information for this rule. */
                rp = &lp->params->port_rules[i];

                /* Check to see if this is an issue with a win2k host in a cluster utilizing virtual clusters. */
                if ((rp->virtual_ip_addr != CVY_ALL_VIP_NUMERIC_VALUE) && ((sendp->rcode[i] ^ ~rp->virtual_ip_addr) == pmsg->rcode[i])) {
                    UNIV_PRINT((" ** A Windows 2000 or NT4 host MAY be participating in a cluster utilizing virtual cluster support."));
                    LOG_MSG(MSG_WARN_VIRTUAL_CLUSTERS, MSG_NONE);
                }

                bp->compatible = FALSE;
            }

            /* 1.03: mark rule inconsistent to force and continue convergence */

            consistent = FALSE;

            /* For the purposes of logging the reason for convergence, note this inconsistency. */
            bInconsistentPortRules = TRUE;

            /* don't update bin state */

            continue;
        }

        ret = Bin_host_update(lp, bp, my_host, (BOOLEAN)(sendp->state != HST_NORMAL),
                              (BOOLEAN)(pmsg->state != HST_NORMAL),
                              rem_host, pmsg->cur_map[i], pmsg->new_map[i],
                              pmsg->idle_map[i], pmsg->rdy_bins[i],
                              pmsg->pkt_count, pmsg->load_amt[i]);

#if 0   /* 1.03: only update ping message in Load_timeout to avoid locking send */

        /* export current port group state */

        sendp->cur_map[i]  = bp->cmap;                  /* v2.1 */
        sendp->new_map[i]  = bp->new_map[my_host];
        sendp->idle_map[i] = bp->idle_bins;
        sendp->rdy_bins[i] = bp->rdy_bins;
        sendp->load_amt[i] = bp->load_amt[my_host];
#endif

        if (!ret)
            consistent = FALSE;
    }

    /* update our consistency state */

    lp->consistent = consistent;

    /* if we are in normal operation and we discover a new host or a host goes into
       convergence or we discover an inconsistency, go into convergence */

    if (sendp->state == HST_NORMAL)
    {
        if (lp->host_map != saved_map || pmsg->state == HST_CVG || !consistent)
        {
            /* If a host has joined the cluster, or if inconsistent teaming configuration or port 
               rules were detected, then we need to log an event.  However, we segregate the 
               inconsistent master host flag because it is set by the initiating host in MANY
               occasions, so we want to log the most specific reason(s) for convergence if 
               possible and only report the inconsistent master detection only if nothing more
               specific can be deduced. */
            if (lp->host_map != saved_map || bInconsistentTeaming || bInconsistentPortRules) {

                /* If the host maps are different, then we know that the host from which we received 
                   this packet is joining the cluster because the ONLY operation on the host map in 
                   this function is to ADD a remote host to our map.  Otherwise, if the map has not
                   changed, then an inconsistent configuration got us into the branch. */
                if (lp->host_map != saved_map) {
                    /* Tracking convergence - Starting convergence because another host is joining the cluster. */
                    LOG_MSGS(MSG_INFO_CONVERGING_NEW_MEMBER, me, them);
                    TRACE_CONVERGENCE("Initiating convergence on host %d.  Reason: Host %d is joining the cluster.", my_host+1, rem_host+1);
                } else if (bInconsistentTeaming || bInconsistentPortRules) {
                    /* Tracking convergence - Starting convergence because inconsistent configuration was detected. */
                    LOG_MSGS(MSG_INFO_CONVERGING_BAD_CONFIG, me, them);
                    TRACE_CONVERGENCE("Initiating convergence on host %d.  Reason: Host %d has conflicting configuration.", my_host+1, rem_host+1);
                } 

            /* If we have nothing better to report, report convergence for an unspecific reason. */
            } else if (bInconsistentMaster || pmsg->state == HST_CVG) {
                /* Tracking convergence - Starting convergence for unknown reasons. */
                LOG_MSGS(MSG_INFO_CONVERGING_UNKNOWN, me, them);
                TRACE_CONVERGENCE("Initiating convergence on host %d.  Reason: Host %d is converging for an unknown reason.", my_host+1, rem_host+1);
            }

            /* Tracking convergence - Starting convergence. */
            Load_convergence_start(lp);
        }
    }

    /* otherwise, if we are in convergence and we see an inconsistency, just restart
       our local convergence */

    else
    {
        /* update our consistency state; if we didn't see consistent information,
           restart this host's convergence */

        if (!consistent)
        {
            /* Tracking convergence - Starting convergence because inconsistent configuration was detected.  
               This keeps hosts in a state of convergence when hosts are inconsistently configured.  However,
               since the cluster is already in a state of convergece (HST_CVG or HST_STABLE), don't log an
               event, which may confuse a user. */
            TRACE_CONVERGENCE("Initiating convergence on host %d.   Reason: Host %d has conflicting configuration.", my_host+1, rem_host+1);

            /* Tracking convergence - Starting convergence. */
            sendp->state = HST_CVG;
            lp->my_stable_ct = 0;
            lp->stable_map &= ~(1 << my_host);
            lp->all_stable_ct = 0;
        }
    }

    LOCK_EXIT(&(lp->lock), irql);

}  /* end Load_msg_rcv */


PPING_MSG Load_snd_msg_get(
    PLOAD_CTXT      lp)
{
    return &(lp->send_msg);

}  /* end Load_snd_msg_get */


BOOLEAN Load_timeout(
    PLOAD_CTXT      lp,
    PULONG          new_timeout,
    PBOOLEAN        pconverging,
    PULONG          pnconn)
/*
  Note: we only update ping message in this function since we know that upper level code
  sends out ping messages after calling this routine.  We cannot be sure that Load_msg_rcv
  is sequentialized with sending a message, (1.03)

  Upper level code locks this routine wrt Load_msg_rcv, Load_packet_check, and
  Load_conn_advise.  (1.03)
*/
{
    ULONG       missed_pings;
    ULONG       my_host;
    ULONG       i;
    PPING_MSG   sendp;          /* ptr. to my send message */
    IRQLEVEL    irql;
    ULONG       map;            /* returned host map from query */
    PMAIN_CTXT  ctxtp = CONTAINING_RECORD (lp, MAIN_CTXT, load);

    UNIV_ASSERT(lp->code == CVY_LOADCODE);       /* (bbain 8/19/99) */

    LOCK_ENTER(&(lp->lock), &irql);

    /* check for cleanup timeout (v1.32B) */

    if (lp->cln_waiting)
    {
        lp->cur_time += lp->cur_timeout;

        if (lp->cur_time >= lp->cln_timeout)
        {
            Load_conn_cleanup(lp);

            lp->cln_waiting = FALSE;
        }
    }

    /* return if not active */

    if (!(lp->active))
    {
        if (new_timeout != NULL)
            * new_timeout = lp->cur_timeout = lp->def_timeout;
        if (pnconn != NULL)         /* v2.1 */
            * pnconn = lp->nconn;
        if (pconverging != NULL)
            * pconverging = FALSE;

        LOCK_EXIT(&(lp->lock), irql);
        return FALSE;
    }

    my_host = lp->my_host_id;
    sendp   = &(lp->send_msg);

    /* compute which hosts missed pings and reset ping map */

    missed_pings = lp->host_map & (~lp->ping_map);

#ifdef NO_CLEANUP
    lp->ping_map = 1 << my_host;
#else
    lp->ping_map = 0;
#endif

    /* check whether any host is dead, including ourselves */

    for (i=0; i<CVY_MAX_HOSTS; i++)
    {
        /* if we have a missed ping for this host, increment count */

        if ((missed_pings & 0x1) == 1)
        {
            lp->nmissed_pings[i]++;

            /* if we missed too many pings, declare host dead and force convergence */

            if (lp->nmissed_pings[i] == lp->min_missed_pings)
            {
                ULONG       j;
                BOOLEAN     ret;
                WCHAR       me[20];
                WCHAR       them[20];

                if (i == my_host)
                {
                    UNIV_PRINT(("Host %d: missed too many pings; this host declared offline", i));

                    /* reset our packet count since we are likely not to be receiving
                       packets from others now; this will make us less favored to
                       handle duplicate bins later (v1.32B) */

                    lp->pkt_count = 0;
                }

                lp->host_map &= ~(1<<i);

                for (j=0; j<sendp->nrules; j++)
                {
                    PBIN_STATE      bp;

                    bp = &(lp->pg_state[j]);
					UNIV_ASSERT(bp->code == CVY_BINCODE);	/* (bbain 8/19/99) */

                    if (i == my_host)
                    {
                        ULONG       k;

                        /* cleanup connections and restore maps to clean state */

                        Load_conn_kill(lp, bp);

                        bp->targ_map     = 0;
                        bp->all_idle_map = BIN_ALL_ONES;
                        bp->cmap         = 0;               /* v2.1 */
                        bp->compatible   = TRUE;            /* v1.03 */

                        for (k=0; k<CVY_MAX_HOSTS; k++)
                        {
                            bp->new_map[k]  = 0;
                            bp->cur_map[k]  = 0;
                            bp->chk_map[k]  = 0;
                            bp->idle_map[k] = BIN_ALL_ONES;

                            if (k != i)
                                bp->load_amt[k] = 0;
                        }

                        bp->snd_bins   =
                        bp->rcv_bins   =
                        bp->rdy_bins   = 0;
                        bp->idle_bins  = BIN_ALL_ONES;

                        /* compute initial new map for convergence as only host in cluster
                           (v 1.3.2B) */

                        ret = Bin_converge(lp, bp, lp->my_host_id);
                        if (!ret)
                        {
                            UNIV_PRINT(("Load_timeout: initial convergence inconsistent"));
                            LOG_MSG(MSG_ERROR_INTERNAL, MSG_NONE);
                        }
                    }
                    else
                    {
                        ret = Bin_host_update(lp, bp, my_host, TRUE, TRUE,
                                          i, 0, 0, BIN_ALL_ONES, 0, 0, 0);
                    }
                }

                lp->nmissed_pings[i] = 0;

                /* If a host has dropped out of the cluster, then log an event.  However, we don't 
                   log an event when we drop out because the only way for us to drop out of our own
                   cluster is if we are stopping anyway, or if we have lost network connectivity. 
                   Logging such events may be misleading, so we won't bother. */
                if (i != my_host) {
                    Univ_ulong_to_str (my_host+1, me, 10);
                    Univ_ulong_to_str (i+1, them, 10);                   
                    
                    /* Tracking convergence - Starting convergence because a member has fallen out of the cluster. */
                    LOG_MSGS(MSG_INFO_CONVERGING_MEMBER_LOST, me, them);
                    TRACE_CONVERGENCE("Initiating convergence on host %d.  Reason: Host %d is leaving the cluster.", my_host+1, i+1);
                }
                
                /* Tracking convergence - Starting convergence. */
                Load_convergence_start(lp);
            }
        }

        /* otherwise reset missed ping count */

        else
            lp->nmissed_pings[i] = 0;

        missed_pings >>= 1;
    }

    /* handle convergence */

    if (sendp->state != HST_NORMAL)
    {
        /* check whether we have been consistent and have received our own pings
           for a sufficient period to move to a stable state and announce it to
           other hosts */

        if (sendp->state == HST_CVG)
        {
            if (lp->consistent && ((lp->host_map & (1 << my_host)) != 0))
            {
                lp->my_stable_ct++;
                if (lp->my_stable_ct >= lp->min_stable_ct)
                {
                    sendp->state = HST_STABLE;
                    lp->stable_map |= (1 << my_host);
                }
            }
            else
                lp->my_stable_ct = lp->all_stable_ct = 0;	/* wlb B3RC1 */
        }

        /* otherwise, see if we are the master and everybody's been stable for
           a sufficient period for us to terminate convergence */

        else if (sendp->state == HST_STABLE &&
                 my_host == sendp->master_id &&
                 lp->stable_map == lp->host_map)
        {
            lp->all_stable_ct++;
            if (lp->all_stable_ct >= lp->min_stable_ct)
            {
                sendp->state = HST_NORMAL;

                /* Notify our BDA team that this cluster is consistently configured.  
                   If we are not part of  BDA team, this call is essentially a no-op. */
                Load_teaming_consistency_notify(&ctxtp->bda_teaming, TRUE);

                /* Reset the bad teaming configuration detected flag if we are converged. */
                lp->bad_team_config = FALSE;

                lp->dup_hosts       = FALSE;
                lp->dup_sspri       = FALSE;
                lp->bad_map         = FALSE;
                lp->overlap_maps    = FALSE;
                lp->err_rcving_bins = FALSE;
                lp->err_orphans     = FALSE;
                lp->bad_num_rules   = FALSE;
                lp->pkt_count       = 0;      /* v1.32B */

                for (i=0; i<sendp->nrules; i++)
                {
                    PBIN_STATE      bp;
                    BOOLEAN         ret;

                    bp = &(lp->pg_state[i]);

                    bp->compatible = TRUE;      /* 1.03 */

                    /* explicitly converge to new map in case we're the only host (v2.06) */

                    ret = Bin_converge(lp, bp, lp->my_host_id);
                    if (!ret)
                    {
                        UNIV_PRINT(("Load_timeout: final convergence inconsistent"));
                        LOG_MSG(MSG_ERROR_INTERNAL, MSG_NONE);
                    }

                    Bin_converge_commit(lp, bp, my_host);

                    UNIV_PRINT(("Host %d pg %d: new cur map %x idle %x all %x",
                                 my_host, i, bp->cur_map[my_host], bp->idle_bins,
                                 bp->all_idle_map));
                }

                UNIV_PRINT(("+++ Host %d: converged as master +++", my_host));
                /* log convergence completion if host map changed (bbain RTM RC1 6/23/99) */
                Load_hosts_query (lp, TRUE, & map);
                lp->last_hmap = lp->host_map;
            }
        }
    }

    /* 1.03: update ping message */

    for (i=0; i<sendp->nrules; i++)
    {
        PBIN_STATE      bp;

        bp = &(lp->pg_state[i]);

        /* export current port group state to ping message */

        sendp->cur_map[i]   = bp->cmap;                 /* v2.1 */
        sendp->new_map[i]   = bp->new_map[my_host];
        sendp->idle_map[i]  = bp->idle_bins;
        sendp->rdy_bins[i]  = bp->rdy_bins;
        sendp->load_amt[i]  = bp->load_amt[my_host];
        /* ###### for keynote - ramkrish */
        sendp->pg_rsvd1[i]  = (ULONG)bp->all_idle_map;
    }

    sendp->pkt_count        = lp->pkt_count;            /* 1.32B */

    /* Add configuration information for teaming at each timeout. */
    Load_teaming_code_create(&lp->send_msg.teaming, &ctxtp->bda_teaming);

    /* request fast timeout if converging */

    if (new_timeout != NULL)        /* 1.03 */
    {
        if (sendp->state != HST_NORMAL)
            * new_timeout = lp->cur_timeout = lp->def_timeout / 2;
        else
            * new_timeout = lp->cur_timeout = lp->def_timeout;
    }

    if (pnconn != NULL)             /* v2.1 */
        * pnconn = lp->nconn;
    if (pconverging != NULL)
        * pconverging = (sendp->state != HST_NORMAL);

    LOCK_EXIT(&(lp->lock), irql);

    return ((lp->host_map) != 0);

}  /* end Load_timeout */


PBIN_STATE Load_pg_lookup(
    PLOAD_CTXT      lp,
    ULONG           svr_ipaddr,
    ULONG           svr_port,
    BOOLEAN         is_tcp)
{
    PCVY_RULE       rp;     /* ptr. to rules array */
    PBIN_STATE      bp;     /* ptr. to bin state */
    ULONG           i;
    ULONG           nurules;    /* # user defined rules */
    PMAIN_CTXT  ctxtp = CONTAINING_RECORD (lp, MAIN_CTXT, load);

    UNIV_ASSERT(lp->code == CVY_LOADCODE);	/* (bbain 8/19/99) */

    rp      = (* (lp->params)).port_rules;
    nurules = (* (lp->params)).num_rules;

    /* check for invalid port value (bbain RC1 6/14/99) */

    UNIV_ASSERT(svr_port <= CVY_MAX_PORT); 

    /* find server port rule */

    for (i=0; i<nurules; i++)
    {
        /* For virtual clusters: If the server IP address matches the VIP for the port rule,
           or if the VIP for the port rule is "ALL VIPs", and if the port lies in the range
           for this rule, and if the protocol matches, this is the rule.  Notice that this
           give priority to rules for specific VIPs over those for "ALL VIPs", which means
           that this code RELIES on the port rules being sorted by VIP/port where the "ALL
           VIP" ports rules are at the end of the port rule list. */
        if ((svr_ipaddr == rp->virtual_ip_addr || CVY_ALL_VIP_NUMERIC_VALUE == rp->virtual_ip_addr) &&
            (svr_port >= rp->start_port && svr_port <= rp->end_port) &&
            ((is_tcp && rp->protocol != CVY_UDP) || (!is_tcp && rp->protocol != CVY_TCP)))
            break;
        else
            rp++;
    }

    /* use default rule if port not found or rule is invalid */

    bp = &(lp->pg_state[i]);
    UNIV_ASSERT(bp->code == CVY_BINCODE);	/* (bbain 8/19/99) */

    return bp;

}  /* end Load_pg_lookup */


BOOLEAN Load_packet_check(
    PLOAD_CTXT      lp,
    ULONG           svr_ipaddr,
    ULONG           svr_port,
    ULONG           client_ipaddr,
    ULONG           client_port,
    USHORT          protocol,
    BOOLEAN         limit_map_fn)
{
    PBIN_STATE      bp;     /* ptr. to bin state */
    ULONG           id;     /* hash index for the connection */
    ULONG           bin;    /* bin index */
    QUEUE *         qp;     /* ptr. to connection queue */
    IRQLEVEL        irql;
    PMAIN_CTXT      ctxtp = CONTAINING_RECORD (lp, MAIN_CTXT, load);
    BOOLEAN         is_tcp_pkt = (protocol == TCPIP_PROTOCOL_TCP);
    BOOLEAN         is_session_pkt;

    is_session_pkt = is_tcp_pkt;
	
    if (NLB_IPSEC_SESSION_SUPPORT_ENABLED() && (protocol == TCPIP_PROTOCOL_IPSEC1))
    {
        is_session_pkt = TRUE;
    }

    UNIV_ASSERT(lp->code == CVY_LOADCODE);	/* (bbain 8/19/99) */

    if (! lp -> active)
        return FALSE;

    lp->pkt_count++;    /* increment count of pkts handled (v1.32B) */

    bp = Load_pg_lookup(lp, svr_ipaddr, svr_port, is_tcp_pkt);

    /* V2.2 make sure that Load_pg_lookup properly handled protocol specific rules */

    UNIV_ASSERT ((is_tcp_pkt && bp->prot != CVY_UDP) || (!is_tcp_pkt && bp->prot != CVY_TCP));

    /* handle CVY_NEVER mode immediately */

    if (bp->mode == CVY_NEVER)
        return FALSE;

    /* lookup connection entry in hash table */
    if (limit_map_fn) {
        if (bp->affinity == CVY_AFFINITY_NONE)
            id = Map(client_ipaddr, MAP_FN_PARAMETER);
        else if (bp->affinity == CVY_AFFINITY_SINGLE)
            id = Map(client_ipaddr, MAP_FN_PARAMETER);
        else
            id = Map(client_ipaddr & TCPIP_CLASSC_MASK, MAP_FN_PARAMETER);
    } else {
        if (bp->affinity == CVY_AFFINITY_NONE)
            id = Map(client_ipaddr, ((svr_port << 16) + client_port));
        else if (bp->affinity == CVY_AFFINITY_SINGLE)
            id = Map(client_ipaddr, svr_ipaddr);
        else
            id = Map(client_ipaddr & TCPIP_CLASSC_MASK, svr_ipaddr);
    }

    /* now hash client address to bin id */
    bin = id % CVY_MAXBINS;

    LOCK_ENTER(&(lp->lock), &irql);

    /* check bin for residency and all other hosts now idle on their bins; in this
       case and if we do not have dirty connections, we must be able to handle the packet */
    if (((bp->cmap & (((MAP_T) 1) << bin)) != 0) &&                 /* v2.1 */
        (!is_session_pkt || (((bp->all_idle_map & (((MAP_T) 1) << bin)) != 0) && (!(lp->cln_waiting)))))   /* v1.32B */
    {
        /* note that we may have missed a connection, but it could also be a stale
           packet so we can't start tracking the connection now */

#ifdef TRACE_LOAD
        DbgPrint("Host %d: check 1 accepts pkt; rule %d bin %d nconn %d %s port %d\n",
                     lp->my_host_id, bp->index, bin, bp->nconn[bin], is_tcp_pkt ? "TCP" : "UDP", svr_port);
#endif
        LOCK_EXIT(&(lp->lock), irql);
        return TRUE;
    }
    /* otherwise, if we have an active connection for this bin or if we have dirty
       connections for this bin and the bin is resident, check for a match */

    else if (bp->nconn[bin] > 0 || (lp->cln_waiting && lp->dirty_bin[bin] && ((bp->cmap & (((MAP_T) 1) << bin)) != 0)))
    {
        PCONN_ENTRY     ep;     /* ptr. to connection entry */
        PCONN_DESCR     dp;     /* ptr. to connection descriptor */
    
        /* now hash client address to conn. hash table index */
        id  = id % CVY_MAX_CHASH;

        ep = &(lp->hashed_conn[id]);
        qp = &(lp->connq[id]);
        
        
        /* look for a connection match */
        if (CVY_CONN_MATCH(ep, svr_ipaddr, svr_port, client_ipaddr, client_port, protocol))
        {
            /* if connection was dirty, just block the packet since TCP/IP may have stale
               connection state for a previous connection from another host (v1.32B) */

            if (ep->dirty)
            {
                LOCK_EXIT(&(lp->lock), irql);
#ifdef TRACE_DIRTY
                DbgPrint ("blocking dirty connection from %d to %d\n", client_port, svr_port);
#endif
                return FALSE;
            }

#ifdef TRACE_LOAD
            DbgPrint("Host %d: check 2 accepts pkt; rule %d bin %d nconn %d %s port %d\n",
                         lp->my_host_id, bp->index, bin, bp->nconn[bin], is_tcp_pkt ? "TCP" : "UDP", svr_port);
#endif
            LOCK_EXIT(&(lp->lock), irql);
            return TRUE;
        }
        else
        {
            for (dp = (PCONN_DESCR)Queue_front(qp); dp != NULL;
                 dp = (PCONN_DESCR)Queue_next(qp, &(dp->link)))
            {
                if (CVY_CONN_MATCH(&(dp->entry), svr_ipaddr, svr_port, client_ipaddr, client_port, protocol))
                {
                    /* if connection was dirty, just block the packet since TCP/IP may have
                       stale connection state for a previous connection from another host
                       (v1.32B) */

                    if (dp->entry.dirty)
                    {
                        LOCK_EXIT(&(lp->lock), irql);
#ifdef TRACE_DIRTY
                        DbgPrint ("blocking dirty connection from %d to %d\n", client_port, svr_port);
#endif
                        return FALSE;
                    }

#ifdef TRACE_LOAD
                    DbgPrint("Host %d: check 3 accepts pkt; rule %d bin %d nconn %d %s port %d\n",
                                 lp->my_host_id, bp->index, bin, bp->nconn[bin], is_tcp_pkt ? "TCP" : "UDP", svr_port);
#endif
                    LOCK_EXIT(&(lp->lock), irql);
                    return TRUE;
                }
            }
        }
    }

    LOCK_EXIT(&(lp->lock), irql);
    return FALSE;

}  /* end Load_packet_check */


BOOLEAN Load_conn_advise(
    PLOAD_CTXT      lp,
    ULONG           svr_ipaddr,
    ULONG           svr_port,
    ULONG           client_ipaddr,
    ULONG           client_port,
    USHORT          protocol,
    ULONG           conn_status,
    BOOLEAN         limit_map_fn)
{
    BOOLEAN     match,      /* TRUE => we have a record of this connection */
                hit;        /* TRUE => we have a hash entry hit */
    ULONG       id;         /* hash index for the connection */
    ULONG       bin;        /* bin index */
    PBIN_STATE  bp;         /* ptr. to bin state */
    PCONN_ENTRY ep;         /* ptr. to connection entry */
    PCONN_DESCR dp;         /* ptr. to connection descriptor */
    QUEUE *     qp;         /* ptr. to connection queue */
    IRQLEVEL    irql;
    PMAIN_CTXT  ctxtp = CONTAINING_RECORD (lp, MAIN_CTXT, load);
    BOOLEAN     is_tcp_pkt = (protocol == TCPIP_PROTOCOL_TCP);

    UNIV_ASSERT(lp->code == CVY_LOADCODE);	/* (bbain 8/19/99) */
 
    if (!lp -> active)
        return FALSE;

    lp->pkt_count++;    /* increment count of pkts handled (v1.32B) */

    /* increment bin count */

    bp = Load_pg_lookup(lp, svr_ipaddr, svr_port, is_tcp_pkt);

    /* handle CVY_NEVER immediately */

    if (bp->mode == CVY_NEVER)
        return FALSE;

    /* This function is no longer for TCP only. */
    if (!NLB_SESSION_SUPPORT_ENABLED())
    {
        /* This should never happen with session support disabled anyway - Load_pg_lookup() will
           NEVER return a UDP only rule when the is_tcp_pkt is TRUE, so this isn't necessary. */
        if (bp->prot == CVY_UDP)
            return TRUE;
    }

    /* lookup connection entry in hash table */
    if (limit_map_fn) {
        if (bp->affinity == CVY_AFFINITY_NONE)
            id = Map(client_ipaddr, MAP_FN_PARAMETER);
        else if (bp->affinity == CVY_AFFINITY_SINGLE)
            id = Map(client_ipaddr, MAP_FN_PARAMETER);
        else
            id = Map(client_ipaddr & TCPIP_CLASSC_MASK, MAP_FN_PARAMETER);
    } else {
        if (bp->affinity == CVY_AFFINITY_NONE)
            id = Map(client_ipaddr, ((svr_port << 16) + client_port));
        else if (bp->affinity == CVY_AFFINITY_SINGLE)
            id = Map(client_ipaddr, svr_ipaddr);
        else
            id = Map(client_ipaddr & TCPIP_CLASSC_MASK, svr_ipaddr);
    }

    /* now hash client address to bin id and conn. hash table index */

    bin = id % CVY_MAXBINS;
    id  = id % CVY_MAX_CHASH;

    /* if this connection is not in our current map and it is not a connection
       down notification for a non-idle bin, just filter it out */

    if ((bp->cmap & (((MAP_T) 1) << bin)) == 0 &&                   /* v2.1 */
        (!((conn_status == CVY_CONN_DOWN || conn_status == CVY_CONN_RESET) && bp->nconn[bin] > 0)))
        return FALSE;

    ep = &(lp->hashed_conn[id]);
    UNIV_ASSERT (ep->code == CVY_ENTRCODE);	/* (bbain 8/21/99) */
    qp = &(lp->connq[id]);

    match = hit = FALSE;

    LOCK_ENTER(&(lp->lock), &irql);

    if (CVY_CONN_MATCH(ep, svr_ipaddr, svr_port, client_ipaddr, client_port, protocol))
    {
        hit   =
        match = TRUE;
    }
    else
    {
        for (dp = (PCONN_DESCR)Queue_front(qp); dp != NULL;
             dp = (PCONN_DESCR)Queue_next(qp, &(dp->link)))
        {
            if (CVY_CONN_MATCH(&(dp->entry), svr_ipaddr, svr_port, client_ipaddr, client_port, protocol))
            {
                match = TRUE;

                UNIV_ASSERT (dp->code == CVY_DESCCODE);	/* (bbain 8/19/99) */
                ep = &(dp->entry);						/* v 2.06 */
                UNIV_ASSERT (ep->code == CVY_ENTRCODE);	/* (bbain 8/21/99) */

                /* release connection descriptor if taking down connection */

                if (conn_status == CVY_CONN_DOWN || conn_status == CVY_CONN_RESET)
                {
                    /* if connection was dirty, just block the packet since TCP/IP may have
                       stale connection state for a previous connection from another host
                       (v1.32B) */

                    if (ep->dirty)
                    {
                        LOCK_EXIT(&(lp->lock), irql);
#ifdef TRACE_DIRTY
                        DbgPrint ("blocking dirty FIN from %d to %d\n", client_port, svr_port);
#endif
                        return FALSE;
                    }

                    /* ###### fin count added for keynote - ramkrish. */
                    /* if first fin, then only increment the count and return TRUE */
                    if (conn_status == CVY_CONN_DOWN && ep->fin_count == 0 && is_tcp_pkt)
                    {
                        ep->fin_count++;
                        LOCK_EXIT(&(lp->lock), irql);
                        return TRUE;
                    }

                    Link_unlink(&(dp->entry.blink));
                    Link_unlink(&(dp->entry.rlink));  /* V2.1.5 */

                    Link_unlink(&(dp->link));
                    Queue_enq(&(lp->conn_freeq), &(dp->link));
                }

                break;
            }
        }
    }

    /* if we see a new connection, handle it */

    if (conn_status == CVY_CONN_UP)
    {
        /* if we don't have a connection match, setup a new connection entry */

        if (!match)
        {
            /* if hash entry table is not available, setup and enqueue a new entry */

            if (CVY_CONN_IN_USE(ep))
            {
                dp = (PCONN_DESCR)Queue_deq(&(lp->conn_freeq));

                if (dp == NULL)
                {
                    /* allocate new queue descriptors if allowed */

                    if (lp->nqalloc < lp->max_dscr_allocs)
                    {
                        UNIV_PRINT(("Load_conn_advise: %d/%d allocating %d descriptors", lp->nqalloc, lp->max_dscr_allocs, lp->dscr_per_alloc));

                        lp->qalloc_list[lp->nqalloc] =    /* (bbain 2/25/99) */
                            dp = (PCONN_DESCR)malloc((lp->dscr_per_alloc) * sizeof(CONN_DESCR));
                        if (dp != NULL)
                        {
                            ULONG           i;
                            PCONN_DESCR     tp;
                            QUEUE *         fqp;

                            lp->nqalloc++;

                            /* initialize and link up descriptors; save first descriptor
                               for our use */

							dp->code = CVY_DESCCODE;			/* (bbain 8/19/99) */
							Link_init(&(dp->link));
							ep = &(dp->entry);					/* (bbain 8/21/99) */
							ep->code  = CVY_ENTRCODE;			/* (bbain 8/19/99) */
                            ep->alloc = TRUE;
                            ep->dirty = FALSE;					/* v1.32B */

                            CVY_CONN_CLEAR(&(dp->entry));
                            Link_init(&(dp->entry.blink));
                            Link_init(&(dp->entry.rlink));      /* V2.1.5 */

                            tp  = dp + 1;
                            fqp = &(lp->conn_freeq);

                            for (i=1; i<lp->dscr_per_alloc; i++)
                            {
								tp->code = CVY_DESCCODE;		/* (bbain 8/19/99) */
								Link_init(&(tp->link));
								tp->entry.code  = CVY_ENTRCODE;	/* (bbain 8/19/99) */
								tp->entry.alloc = TRUE;
                                tp->entry.dirty = FALSE;        /* v1.32B */

                                CVY_CONN_CLEAR(&(tp->entry));
                                Link_init(&(tp->entry.blink));
                                Link_init(&(tp->entry.rlink));  /* V2.1.5 */

                                Queue_enq(fqp, &(tp->link));

                                tp++;
                            }
                        }
                        else
                        {
                            if (!(lp->alloc_failed))
                            {
                                UNIV_PRINT(("Load_conn_advise: error allocating conn descrs"));
                                LOG_MSG(MSG_ERROR_MEMORY, MSG_NONE);

                                lp->alloc_failed = TRUE;
                            }

                            LOCK_EXIT(&(lp->lock), irql);
                            return TRUE;
                        }
                    }
                    else
                    {
                        /* V2.1.5 - if reached allocation limit - start taking
                           connection descriptors from the recover queue since
                           they are likely to be stale and very old */

                        PBIN_STATE      rbp;
                        LINK *          rlp;

#ifdef TRACE_RCVRY
                        DbgPrint ("Host %d: taking connection from recovery queue\n", lp->my_host_id);
#endif

                        rlp = (LINK *)Queue_deq(&(lp->conn_rcvryq));

                        UNIV_ASSERT (rlp != NULL);

                        /* this should not happen at all but protect anyway */

                        if (rlp == NULL)
                        {
                            if (!(lp->alloc_inhibited))
                            {
                                UNIV_PRINT(("Host %d: cannot allocate conn descriptors.", lp->my_host_id));
                                LOG_MSG(MSG_WARN_DESCRIPTORS, CVY_NAME_MAX_DSCR_ALLOCS);

                                lp->alloc_inhibited = TRUE;
                            }

                            LOCK_EXIT(&(lp->lock), irql);
                            return TRUE;
                        }

                        ep = STRUCT_PTR(rlp, CONN_ENTRY, rlink);
						UNIV_ASSERT (ep->code == CVY_ENTRCODE);	/* (bbain 8/19/99) */

                        /* fixed for nt4/sp5 */

                        if (ep->alloc)
                        {
                            /* unlink allocated descriptors from the hash table
                               queue if necessary and set dp so that code below
                               will put it back in the right hash queue */

                            dp = STRUCT_PTR(ep, CONN_DESCR, entry);
							UNIV_ASSERT (dp->code == CVY_DESCCODE);	/* (bbain 8/19/99) */
							
                            Link_unlink(&(dp->link));
                        }
                        else
                        {
							dp = NULL;								/* (bbain 8/21/99) */
                        }

                        /* dirty connections are not counted */

                        if (! ep->dirty)
                        {
                            /* find out which port group we are on so we can clean
                            up its counters */

                            rbp = Load_pg_lookup(lp, ep->svr_ipaddr, ep->svr_port, is_tcp_pkt);

                            /* correct bad (negative) bin count */

                            if (lp->nconn <= 0)
                                lp->nconn = 0;
                            else
                                lp->nconn--;

                            if (rbp->nconn[ep->bin] <= 0)
                                rbp->nconn[ep->bin] = 0;
                            else
                            {
                                rbp->nconn[ep->bin]--;
                            }

							if (rbp->tconn <= 0)
								rbp->tconn = 0;
							else
								rbp->tconn--;

                            if (rbp->nconn[ep->bin] == 0)
                            {
                                rbp->idle_bins |= (((MAP_T) 1) << ep->bin);
                            }
                        }

                        Link_unlink(&(ep->blink));
                        CVY_CONN_CLEAR(ep);
                        ep->dirty = FALSE;
                    }
                }
				/* else dp is not NULL, so setup entry pointer */
				else
				{
					ep = &(dp->entry);
					UNIV_ASSERT (ep->code == CVY_ENTRCODE);	/* (bbain 8/21/99) */
				}					

                /* enqueue descriptor in hash table unless it's already a hash table entry
				   (V2.1.5 recovered connection might be in hash table, so make
                   sure we do not end up queueing it) */

                if (dp != NULL)
                {
					UNIV_ASSERT (dp->code == CVY_DESCCODE);	/* (bbain 8/19/99) */

                    /* enqueue new queue descriptor and setup entry pointer */

                    Queue_enq(qp, &(dp->link));
                }
            }

            /* setup new entry */

			UNIV_ASSERT (ep->code == CVY_ENTRCODE);	/* (bbain 8/21/99) */

            CVY_CONN_SET(ep, svr_ipaddr, svr_port, client_ipaddr, client_port, protocol);
            ep->bin = (UCHAR)bin;

            /* ###### fin count added for keynote - ramkrish */
            /* initialize the fin count to 0 for a new connection */
            ep->fin_count = 0;
                        
            /* enqueue entry into port group queue */

            Queue_enq(&(bp->connq), &(ep->blink));

            /* V2.1.5 add entry to the tail of connection recovery queue */

            Queue_enq(&(lp->conn_rcvryq), &(ep->rlink));

            /* increment # connections and mark bin not idle if necessary */

            lp->nconn++;            /* v2.1 */
            bp->tconn++;
            bp->nconn[bin]++;
            if (bp->nconn[bin] == 1)
                bp->idle_bins &= ~(((MAP_T) 1) << bin);

#ifdef TRACE_LOAD
            DbgPrint("Host %d: advise starts conn; rule %d bin %d nconn %d\n",
                         lp->my_host_id, bp->index, bin, bp->nconn[bin]);
#endif
        }
        /* otherwise, we have a match; clean up conn entry if dirty since we have a
           new connection, although TCP/IP will likely reject it if it has stale state
           from another connection (v1.32B) */

        else
        {
            if (ep->dirty)
            {
#ifdef TRACE_DIRTY
                DbgPrint ("converting dirty SYN from %d to %d\n", client_port, svr_port);
#endif
				UNIV_ASSERT (ep->code == CVY_ENTRCODE);	/* (bbain 8/21/99) */

                ep->dirty = FALSE;

                /* ###### initialize fin count for this new connection added for keynote - ramkrish */
                /* ###### since we are reusing a dirty connection desc for a new conn., it needs to be reset */
                ep->fin_count = 0;

                UNIV_ASSERT (ep->bin == (USHORT)bin);

                /* unlink and enqueue entry into port group queue */

                Link_unlink(&(ep->blink));
                Queue_enq(&(bp->connq), &(ep->blink));

                /* increment # connections and mark bin not idle if necessary */

                lp->nconn++;            /* v2.1 */
                bp->tconn++;
                bp->nconn[bin]++;
                if (bp->nconn[bin] == 1)
                    bp->idle_bins &= ~(((MAP_T) 1) << bin);
            }
        }
    }

    /* otherwise, if a known connection is going down, remove our connection entry */

    /* ###### check for reset addded for keynote - ramkrish */
    else if ((conn_status == CVY_CONN_DOWN || conn_status == CVY_CONN_RESET) && match)
    {
        /* if connection was dirty, just block the packet since TCP/IP may have stale
           connection state for a previous connection from another host (v1.32B) */

        if (ep->dirty)
        {
            LOCK_EXIT(&(lp->lock), irql);
#ifdef TRACE_DIRTY
            DbgPrint ("blocking dirty FIN from %d to %d\n", client_port, svr_port);
#endif
            return FALSE;
        }

        /* ###### fin count added for keynote - ramkrish */
        /* if this is the first fin, then simply increment the fincount and return */
        if (conn_status == CVY_CONN_DOWN && ep->fin_count == 0 && is_tcp_pkt)
        {
            ep->fin_count++;
            LOCK_EXIT(&(lp->lock), irql);
            return TRUE;
        }

        /* clear hash table entry if we had a hit; enqueued entry was already freed */

        if (hit)
        {
            CVY_CONN_CLEAR(ep);

            /* ###### clear fin count for keynote - ramkrish */
            ep->fin_count = 0;

            Link_unlink(&(ep->rlink));      /* V2.1.5 */
            Link_unlink(&(ep->blink));
        }

        /* decrement # connections and mark bin idle if necessary */

#if 0
        if (bp->nconn[bin] <= 0)
            DbgPrint("WLBS: Load_conn_advise: count was zero %d %d\n", bin, bp->nconn[bin]);
#endif

        UNIV_ASSERT(bp->nconn[bin] > 0 && bp->tconn > 0 && lp->nconn > 0);

        if (lp->nconn <= 0)         /* v2.1 */
            lp->nconn = 0;
        else
            lp->nconn--;

        if (bp->nconn[bin] <= 0)    /* correct bad (negative) bin count */
            bp->nconn[bin] = 0;
        else
            bp->nconn[bin]--;

        if (bp->tconn <= 0)
            bp->tconn = 0;
        else
            bp->tconn--;

        if (bp->nconn[bin] == 0)
        {
            bp->idle_bins |= (((MAP_T) 1) << bin);
        }

#ifdef TRACE_LOAD
        DbgPrint("Host %d: advise removes conn; rule %d bin %d nconn %d\n",
                     lp->my_host_id, bp->index, bin, bp->nconn[bin]);
#endif
    }
    else
    {
        LOCK_EXIT(&(lp->lock), irql);
        return FALSE;
    }

    LOCK_EXIT(&(lp->lock), irql);
    return TRUE;

}  /* end Load_conn_advise */

/* 
 * Function: Load_create_dscr
 * Desctription:
 * Parameters:
 * Returns:
 * Author: shouse, 5.18.01
 * Notes:
 */
BOOLEAN Load_create_dscr(
    PLOAD_CTXT      lp,
    ULONG           svr_ipaddr,
    ULONG           svr_port,
    ULONG           client_ipaddr,
    ULONG           client_port,
    USHORT          protocol,
    BOOLEAN         limit_map_fn)
{
    BOOLEAN     match = FALSE; /* TRUE => we have a record of this connection. */
    ULONG       id;            /* Hash index for the connection. */
    ULONG       bin;           /* Bin index. */
    PBIN_STATE  bp;            /* Pointer to bin state. */
    PCONN_ENTRY ep;            /* Pointer to connection entry. */
    PCONN_DESCR dp;            /* Pointer to connection descriptor. */
    QUEUE *     qp;            /* Pointer to connection queue. */
    PMAIN_CTXT  ctxtp = CONTAINING_RECORD(lp, MAIN_CTXT, load);
    BOOLEAN     is_tcp_pkt = (protocol == TCPIP_PROTOCOL_TCP);

    UNIV_ASSERT(lp->code == CVY_LOADCODE);
 
    if (!lp->active)
        return FALSE;

    /* Increment count of packets handled. */
    lp->pkt_count++;

    /* Find the port rule for this connection. */
    bp = Load_pg_lookup(lp, svr_ipaddr, svr_port, is_tcp_pkt);

    /* Hash. */
    if (limit_map_fn) {
        if (bp->affinity == CVY_AFFINITY_NONE)
            id = Map(client_ipaddr, MAP_FN_PARAMETER);
        else if (bp->affinity == CVY_AFFINITY_SINGLE)
            id = Map(client_ipaddr, MAP_FN_PARAMETER);
        else
            id = Map(client_ipaddr & TCPIP_CLASSC_MASK, MAP_FN_PARAMETER);
    } else {
        if (bp->affinity == CVY_AFFINITY_NONE)
            id = Map(client_ipaddr, ((svr_port << 16) + client_port));
        else if (bp->affinity == CVY_AFFINITY_SINGLE)
            id = Map(client_ipaddr, svr_ipaddr);
        else
            id = Map(client_ipaddr & TCPIP_CLASSC_MASK, svr_ipaddr);
    }

    /* Hash client address to bin id and connection hash table index. */
    bin = id % CVY_MAXBINS;
    id  = id % CVY_MAX_CHASH;

    /* Get a pointer to the connection entry for this hash ID. */
    ep = &(lp->hashed_conn[id]);

    UNIV_ASSERT (ep->code == CVY_ENTRCODE);

    /* Get a pointer to the conneciton queue. */
    qp = &(lp->connq[id]);

    if (CVY_CONN_MATCH(ep, svr_ipaddr, svr_port, client_ipaddr, client_port, protocol)) 
    {
        /* Note that we found a match for this tuple. */
        match = TRUE;
    } else {
        for (dp = (PCONN_DESCR)Queue_front(qp); dp != NULL; dp = (PCONN_DESCR)Queue_next(qp, &(dp->link))) {
            if (CVY_CONN_MATCH(&(dp->entry), svr_ipaddr, svr_port, client_ipaddr, client_port, protocol)) 
            {
                /* Note that we found a match for this tuple. */
                match = TRUE;
                
                UNIV_ASSERT (dp->code == CVY_DESCCODE);

                /* Get a pointer to the connection entry. */
                ep = &(dp->entry);			

                UNIV_ASSERT (ep->code == CVY_ENTRCODE);

                break;
            }
        }
    }

    /* If we don't have a connection match, setup a new connection entry. */
    if (!match) {
        /* If hash entry table is not available, setup and enqueue a new entry. */
        if (CVY_CONN_IN_USE(ep)) {
            /* Get a pointer to a free descriptor. */
            dp = (PCONN_DESCR)Queue_deq(&(lp->conn_freeq));

            if (dp == NULL) {
                /* Allocate new queue descriptors if allowed. */
                if (lp->nqalloc < lp->max_dscr_allocs) {
                    UNIV_PRINT(("Load_create_dscr: %d/%d allocating %d descriptors", lp->nqalloc, lp->max_dscr_allocs, lp->dscr_per_alloc));

                    dp = lp->qalloc_list[lp->nqalloc] = (PCONN_DESCR)malloc((lp->dscr_per_alloc) * sizeof(CONN_DESCR));

                    if (dp != NULL) {
                        ULONG       i;
                        PCONN_DESCR tp;
                        QUEUE *     fqp;

                        /* Increment the counter for number of allocations. */
                        lp->nqalloc++;

                        /* Initialize and link up descriptors; save first descriptor for our use. */
                        dp->code = CVY_DESCCODE;
                        Link_init(&(dp->link));

                        /* Initialize the connection entry. */
                        ep = &(dp->entry);	
                        ep->code  = CVY_ENTRCODE;
                        ep->alloc = TRUE;
                        ep->dirty = FALSE;		

                        /* Mark this entry unused. */
                        CVY_CONN_CLEAR(&(dp->entry));

                        Link_init(&(dp->entry.blink));
                        Link_init(&(dp->entry.rlink));

                        tp = dp + 1;
                        fqp = &(lp->conn_freeq);

                        /* Initialize all descriptors and tack them on the free queue. */
                        for (i = 1; i < lp->dscr_per_alloc; i++, tp++) {
                            /* Initialize the descriptor. */
                            tp->code = CVY_DESCCODE;
                            Link_init(&(tp->link));

                            /* Initialize the connection entry. */
                            tp->entry.code  = CVY_ENTRCODE;
                            tp->entry.alloc = TRUE;
                            tp->entry.dirty = FALSE;

                            /* Mark this entry unused. */
                            CVY_CONN_CLEAR(&(tp->entry));

                            Link_init(&(tp->entry.blink));
                            Link_init(&(tp->entry.rlink));

                            /* Queue the descriptor onto the free queue. */
                            Queue_enq(fqp, &(tp->link));
                        }
                    } else {
                        /* Allocation failed, log a message and bail out. */
                        if (!(lp->alloc_failed)) {
                            UNIV_PRINT(("Load_conn_advise: error allocating conn descrs"));
                            LOG_MSG(MSG_ERROR_MEMORY, MSG_NONE);
                            lp->alloc_failed = TRUE;
                        }

                        return FALSE;
                    }
                } else {
                    /* If we have reached the allocation limit, start taking connection descriptors 
                       from the recover queue since they are likely to be stale and very old. */
                    PBIN_STATE rbp;
                    LINK *     rlp;

#ifdef TRACE_RCVRY
                    DbgPrint ("Host %d: taking connection from recovery queue\n", lp->my_host_id);
#endif

                    /* Dequeue a descriptor from the recovery queue. */
                    rlp = (LINK *)Queue_deq(&(lp->conn_rcvryq));

                    UNIV_ASSERT (rlp != NULL);

                    /* This should not happen at all but protect anyway. */
                    if (rlp == NULL) {
                        /* Unable to get a descriptor, log a message and bail out. */
                        if (!(lp->alloc_inhibited)) {
                            UNIV_PRINT(("Host %d: cannot allocate conn descriptors.", lp->my_host_id));
                            LOG_MSG(MSG_WARN_DESCRIPTORS, CVY_NAME_MAX_DSCR_ALLOCS);
                            lp->alloc_inhibited = TRUE;
                        }

                        return FALSE;
                    }

                    /* Grab a pointer to the connection entry. */
                    ep = STRUCT_PTR(rlp, CONN_ENTRY, rlink);

                    UNIV_ASSERT (ep->code == CVY_ENTRCODE);

                    if (ep->alloc) {
                        /* Unlink allocated descriptors from the hash table queue if necessary 
                           and set dp so that code below will put it back in the right hash queue. */
                        dp = STRUCT_PTR(ep, CONN_DESCR, entry);

                        UNIV_ASSERT (dp->code == CVY_DESCCODE);
							
                        Link_unlink(&(dp->link));
                    } else {
                        dp = NULL;
                    }

                    /* Dirty connections are not counted, so we don't need to update these counters. */
                    if (! ep->dirty) {
                        /* Find out which port group we are on so we can clean up its counters. */
                        rbp = Load_pg_lookup(lp, ep->svr_ipaddr, ep->svr_port, is_tcp_pkt);

                        if (lp->nconn <= 0)
                            lp->nconn = 0;
                        else
                            lp->nconn--;

                        if (rbp->nconn[ep->bin] <= 0)
                            rbp->nconn[ep->bin] = 0;
                        else
                            rbp->nconn[ep->bin]--;

                        if (rbp->tconn <= 0)
                            rbp->tconn = 0;
                        else
                            rbp->tconn--;

                        if (rbp->nconn[ep->bin] == 0)
                            rbp->idle_bins |= (((MAP_T) 1) << ep->bin);
                    }

                    Link_unlink(&(ep->blink));

                    /* Mark the descriptor as unused. */
                    CVY_CONN_CLEAR(ep);

                    /* Makr the descriptor as clean. */
                    ep->dirty = FALSE;
                }
            } else {
		/* There was a free descriptor, so setup the connection entry pointer. */
                ep = &(dp->entry);

                UNIV_ASSERT (ep->code == CVY_ENTRCODE);
            }					

            /* Enqueue descriptor in hash table unless it's already a hash table entry (a recovered 
               connection might be in hash table, so make sure we do not end up queueing it) */
            if (dp != NULL) {
                UNIV_ASSERT (dp->code == CVY_DESCCODE);

                Queue_enq(qp, &(dp->link));
            }
        }

        UNIV_ASSERT (ep->code == CVY_ENTRCODE);

        /* Setup a new entry. */
        CVY_CONN_SET(ep, svr_ipaddr, svr_port, client_ipaddr, client_port, protocol);
        ep->bin = (UCHAR)bin;

        /* Initialize the fin count to 0 for a new connection. */
        ep->fin_count = 0;
                        
        /* Enqueue entry into port group queue. */
        Queue_enq(&(bp->connq), &(ep->blink));

        /* Add entry to the tail of connection recovery queue. */
        Queue_enq(&(lp->conn_rcvryq), &(ep->rlink));

        /* Increment number of connections and mark bin not idle if necessary. */
        lp->nconn++;
        bp->tconn++;
        bp->nconn[bin]++;

        if (bp->nconn[bin] == 1) bp->idle_bins &= ~(((MAP_T) 1) << bin);

#ifdef TRACE_LOAD
        DbgPrint("Host %d: advise starts conn; rule %d bin %d nconn %d\n",
                 lp->my_host_id, bp->index, bin, bp->nconn[bin]);
#endif
    } else {
        /* We have a match.  Clean up connection entry if it's dirty since we have a new connection, 
           although TCP/IP will likely reject it if it has stale state from another connection. */
        if (ep->dirty) {
#ifdef TRACE_DIRTY
            DbgPrint ("converting dirty SYN from %d to %d\n", client_port, svr_port);
#endif
            UNIV_ASSERT (ep->code == CVY_ENTRCODE);
            
            ep->dirty = FALSE;
            ep->fin_count = 0;

            UNIV_ASSERT (ep->bin == (USHORT)bin);

            /* Unlink and enqueue entry into port group queue. */
            Link_unlink(&(ep->blink));
            Queue_enq(&(bp->connq), &(ep->blink));

            /* Increment # connections and mark bin not idle if necessary. */
            lp->nconn++;
            bp->tconn++;
            bp->nconn[bin]++;

            if (bp->nconn[bin] == 1) bp->idle_bins &= ~(((MAP_T) 1) << bin);
        }
    }

    return TRUE;
}

ULONG Load_port_change(
    PLOAD_CTXT      lp,
    ULONG           ipaddr,
    ULONG           port,
    ULONG           cmd,
    ULONG           value)
{
    PCVY_RULE       rp;      /* Pointer to configured port rules. */
    PBIN_STATE      bp;      /* Pointer to load module port rule state. */
    ULONG           nrules;  /* Number of rules. */ 
    ULONG           i;
    ULONG           ret = IOCTL_CVY_NOT_FOUND;
    PMAIN_CTXT  ctxtp = CONTAINING_RECORD(lp, MAIN_CTXT, load);

    UNIV_ASSERT(lp->code == CVY_LOADCODE);

    if (! lp->active) 
        return IOCTL_CVY_NOT_FOUND;

    rp = (* (lp->params)).port_rules;

    /* If we are draining whole cluster, include DEFAULT rule; Otherwise, just
       include the user-defined rules (the DEFAULT rule is the last rule). */

    if (cmd == IOCTL_CVY_CLUSTER_DRAIN || cmd == IOCTL_CVY_CLUSTER_PLUG)
        nrules = (* (lp->params)).num_rules + 1;
    else
        nrules = (* (lp->params)).num_rules;

    for (i=0; i<nrules; i++, rp++)
    {
        /* If the virtual IP address is IOCTL_ALL_VIPS (0x00000000), then we are applying this 
           change to all port rules for port X, regardless of VIP.  If the virtual IP address is 
           to be applied to a particular VIP, then we apply only to port rules whose VIP matches.  
           Similarly, if the change is to apply to an "ALL VIP" rule, then we also apply when the 
           VIP matches because the caller uses CVY_ALL_VIP_NUMERIC_VALUE (0xffffffff) as the 
           virtual IP address, which is the same value stored in the port rule state. */
        if ((ipaddr == IOCTL_ALL_VIPS || ipaddr == rp->virtual_ip_addr) && 
            (port == IOCTL_ALL_PORTS || (port >= rp->start_port && port <= rp->end_port)))
        {
            bp = &(lp->pg_state[i]);
            
            UNIV_ASSERT(bp->code == CVY_BINCODE);	/* (bbain 8/19/99) */

            /* If enabling a port rule, set the load amount to original value;
               If disabling a port rule, set the load amount to zero; 
               Otherwise, set the load amount it to the specified amount. */
            if (cmd == IOCTL_CVY_PORT_ON || cmd == IOCTL_CVY_CLUSTER_PLUG)
            {
                if (bp->load_amt[lp->my_host_id] == bp->orig_load_amt)
                {
                    /* If we are the first port rule to match, then set the
                       return value to "Already"; Otherwise, we don't want to
                       overwrite some other port rule's return value of "OK"
                       in the case of ALL_VIPS or ALL_PORTS. */
                    if (ret == IOCTL_CVY_NOT_FOUND) ret = IOCTL_CVY_ALREADY;

                    continue;
                }

                /* Restore the original load amount. */
                bp->load_amt[lp->my_host_id] = bp->orig_load_amt;
                ret = IOCTL_CVY_OK;
            }
            else if (cmd == IOCTL_CVY_PORT_OFF)
            {

                if (bp->load_amt[lp->my_host_id] == 0)
                {
                    /* If we are the first port rule to match, then set the
                       return value to "Already"; Otherwise, we don't want to
                       overwrite some other port rule's return value of "OK"
                       in the case of ALL_VIPS or ALL_PORTS. */
                    if (ret == IOCTL_CVY_NOT_FOUND) ret = IOCTL_CVY_ALREADY;

                    continue;
                }

                bp->load_amt[lp->my_host_id] = 0;

                /* Immediately stop handling all traffic on the port group. */
                bp->cmap                    = 0;
                bp->cur_map[lp->my_host_id] = 0;
                Load_conn_kill(lp, bp);
                ret = IOCTL_CVY_OK;
            }
            else if (cmd == IOCTL_CVY_PORT_DRAIN || cmd == IOCTL_CVY_CLUSTER_DRAIN)
            {
                if (bp->load_amt[lp->my_host_id] == 0)
                {
                    /* If we are the first port rule to match, then set the
                       return value to "Already"; Otherwise, we don't want to
                       overwrite some other port rule's return value of "OK"
                       in the case of ALL_VIPS or ALL_PORTS. */
                    if (ret == IOCTL_CVY_NOT_FOUND) ret = IOCTL_CVY_ALREADY;

                    continue;
                }

                /* Set load weight to zero, but continue to handle existing connections. */
                bp->load_amt[lp->my_host_id] = 0;
                ret = IOCTL_CVY_OK;
            }
            else
            {
                UNIV_ASSERT(cmd == IOCTL_CVY_PORT_SET);

                if (bp->load_amt[lp->my_host_id] == value)
                {
                    /* If we are the first port rule to match, then set the
                       return value to "Already"; Otherwise, we don't want to
                       overwrite some other port rule's return value of "OK"
                       in the case of ALL_VIPS or ALL_PORTS. */
                    if (ret == IOCTL_CVY_NOT_FOUND) ret = IOCTL_CVY_ALREADY;

                    continue;
                }

                /* Set the load weight for this port rule. */
                bp->orig_load_amt = value;
                bp->load_amt[lp->my_host_id] = value;
                ret = IOCTL_CVY_OK;
            }

            if (port != IOCTL_ALL_PORTS && ipaddr != IOCTL_ALL_VIPS) break;
        }
    }

    /* If the cluster isn't already converging, then initiate convergence if the load weight of a port rule has been modified. */
    if (lp->send_msg.state != HST_CVG && ret == IOCTL_CVY_OK) {
        WCHAR me[20];
        
        Univ_ulong_to_str (lp->my_host_id+1, me, 10);

        /* Tracking convergence - Starting convergence because our port rule configuration has changed. */
        LOG_MSGS(MSG_INFO_CONVERGING_NEW_RULES, me, me);
        TRACE_CONVERGENCE("Initiating convergence on host %d.  Reason: Host %d has changed its port rule configuration.", lp->my_host_id+1, lp->my_host_id+1);

        /* Tracking convergence. */
        Load_convergence_start(lp);
    }

    return ret;

} /* end Load_port_change */


ULONG Load_hosts_query(
    PLOAD_CTXT      lp,
    BOOLEAN         internal,
    PULONG          host_map)
{
    WCHAR           buf1 [256];
    WCHAR           buf2 [256];
    PWCHAR          ptr1 = buf1;
    PWCHAR          ptr2 = buf2;
    WCHAR           num [20];       /* v2.1 */
    WCHAR           msk [33];
    ULONG           i, j, k;
    PMAIN_CTXT      ctxtp = CONTAINING_RECORD (lp, MAIN_CTXT, load);

    UNIV_ASSERT(lp->code == CVY_LOADCODE);	/* (bbain 8/19/99) */

    buf1 [0] = 0;
    buf2 [0] = 0;
    msk [0]  = 0;
    num [0]  = 0;

	for (i = 0, j = 0; i < 16; i++)
	{
		if (lp -> host_map & (1 << i))
		{
			ptr1 = Univ_ulong_to_str (i + 1, ptr1, 10);

			* ptr1 = L',';
			ptr1 ++;
			j ++;

			msk [i] = L'1';
		}
		else
			msk [i] = L'0';
	}

	for (i = 16, k = 0; i < 32; i++)
	{
		if (lp -> host_map & (1 << i))
		{
			ptr2 = Univ_ulong_to_str (i + 1, ptr2, 10);

			* ptr2 = L',';
			ptr2 ++;
			k ++;

			msk [i] = L'1';
		}
		else
			msk [i] = L'0';
	}

	if (k)
	{
		ptr2 --;
//		* ptr2 = L'.';
//		ptr2 ++;
	}
	else if (j)
	{
		ptr1 --;
//		* ptr1 = L'.';
//		ptr1 ++;
	}

	* ptr1 = 0;
	* ptr2 = 0;

    * host_map = lp->host_map;

    Univ_ulong_to_str ((* (lp->params)) . host_priority, num, 10); /* v2.1 */

    if (lp->send_msg.state != HST_NORMAL)
    {
        UNIV_PRINT (("current host map is %08x and converging", lp->host_map));
        if (internal)   /* 1.03 */
        {
			LOG_MSGS3 (MSG_INFO_CONVERGING, num, buf1, buf2);
        }
        return IOCTL_CVY_CONVERGING;
    }

    /* if this host has the bins for the deafult rule, it is the default host (v2.1) */

    else if (lp->pg_state[(* (lp->params)).num_rules].cmap != 0)
    {
        UNIV_PRINT (("current host map is %08x and converged as DEFAULT", lp->host_map));
        if (internal)   /* 1.03 */
        {
            LOG_MSGS3(MSG_INFO_MASTER, num, buf1, buf2);
        }
        return IOCTL_CVY_MASTER;
    }
    else
    {
        UNIV_PRINT (("current host map is %08x and converged (NON-DEFAULT)", lp->host_map));
        if (internal)   /* 1.03 */
        {
            LOG_MSGS3(MSG_INFO_SLAVE, num, buf1, buf2);
        }
        return IOCTL_CVY_SLAVE;
    }

} /* end Load_hosts_query */

/* 
 * Function: Load_query_packet_filter
 * Desctription:
 * Parameters:
 * Returns:
 * Author: shouse, 5.18.01
 * Notes:
 */
VOID Load_query_packet_filter (
    PIOCTL_QUERY_STATE_PACKET_FILTER pQuery,
    PLOAD_CTXT    lp,
    ULONG         svr_ipaddr,
    ULONG         svr_port,
    ULONG         client_ipaddr,
    ULONG         client_port,
    USHORT        protocol,
    BOOLEAN       limit_map_fn)
{
    PBIN_STATE    bp;
    ULONG         id;
    ULONG         bin;
    QUEUE *       qp;

    /* This variable is used for port rule lookup and since the port rules only cover
       UDP and TCP, we categorize as TCP and non-TCP, meaning that any protocol that's 
       not TCP will be treated like UDP for the sake of port rule lookup. */
    BOOLEAN       is_tcp_pkt = (protocol == TCPIP_PROTOCOL_TCP);

    /* Further, some protocols are treated with "session" semantics, while others are
       not.  For TCP, this "session" is currently a single TCP connection, which is 
       tracked from SYN to FIN using a connection descriptor.  IPSec "sessions" are
       also tracked using descriptors, so even though its treated like UDP for port
       rule lookup, its treated with the session semantics resembling TCP.  Therefore,
       by default the determination of a session packet is initially the same as the
       determination of a TCP packet. */       
    BOOLEAN       is_session_pkt = is_tcp_pkt;

    /* If we have enabled IPSec session tracking, then if the protocol is IPSec, this 
       packet should also be treated as part of an existing session. */
    if (NLB_IPSEC_SESSION_SUPPORT_ENABLED() && (protocol == TCPIP_PROTOCOL_IPSEC1)) is_session_pkt = TRUE;

    UNIV_ASSERT(lp->code == CVY_LOADCODE);

    /* If the load module has been "turned off", then we drop the packet. */
    if (!lp->active) {
        pQuery->Results.Accept = NLB_REJECT_LOAD_MODULE_INACTIVE;
        return;
    }

    /* Find the port rule for this server IP address / port pair. */
    bp = Load_pg_lookup(lp, svr_ipaddr, svr_port, is_tcp_pkt);

    UNIV_ASSERT ((is_tcp_pkt && bp->prot != CVY_UDP) || (!is_tcp_pkt && bp->prot != CVY_TCP));

    /* If the matching port rule is configured as "disabled", which means to drop any
       packets that match the rule, then we drop the packet. */
    if (bp->mode == CVY_NEVER) {
        pQuery->Results.Accept = NLB_REJECT_PORT_RULE_DISABLED;
        return;
    }

    /* Apply the NLB hashing algorithm on the client identification.  If for reasons
       such as BDA teaming, we have chosen to limit the map function, we hard code the
       second parameter, rather than use some of the server identification in an 
       effort to make the processing of this packet agnostic to the server identity. 
       The hashing parameters also, of course, depend on the configured afffinity 
       settings for the retrieved port rule. */
    if (limit_map_fn) {
        if (bp->affinity == CVY_AFFINITY_NONE)
            id = Map(client_ipaddr, MAP_FN_PARAMETER);
        else if (bp->affinity == CVY_AFFINITY_SINGLE)
            id = Map(client_ipaddr, MAP_FN_PARAMETER);
        else
            id = Map(client_ipaddr & TCPIP_CLASSC_MASK, MAP_FN_PARAMETER);
    } else {
        if (bp->affinity == CVY_AFFINITY_NONE)
            id = Map(client_ipaddr, ((svr_port << 16) + client_port));
        else if (bp->affinity == CVY_AFFINITY_SINGLE)
            id = Map(client_ipaddr, svr_ipaddr);
        else
            id = Map(client_ipaddr & TCPIP_CLASSC_MASK, svr_ipaddr);
    }

    /* Find the applicable "bucket" by a modulo operation on the number of bins, 60. */
    bin = id % CVY_MAXBINS;

    /* At this point, we can begin providing the requestee some actual information about 
       the state of the load module to better inform them as to why the decision we return
       them was actually made.  Here will provide some appropriate information about the
       port rule we are operating on, including the "bucket" ID, the current "bucket" 
       ownership map and the number of connections active on this "bucket". */
    pQuery->Results.HashInfo.Valid = TRUE;
    pQuery->Results.HashInfo.Bin = bin;
    pQuery->Results.HashInfo.CurrentMap = bp->cmap;
    pQuery->Results.HashInfo.AllIdleMap = bp->all_idle_map;
    pQuery->Results.HashInfo.ActiveConnections = bp->nconn[bin];

    /* check bin for residency and all other hosts now idle on their bins; in this
       case and if we do not have dirty connections, we must be able to handle the packet */

    /* If we currently own the "bucket" to which this connection maps and either NLB provides
       no session support for this protocol, or all other hosts have no exisitng connections
       on this "bucket" and we have no dirty connections, then we can safely take the packet
       with no regard to the connection (session) descriptors. */
    if (((bp->cmap & (((MAP_T) 1) << bin)) != 0) && (!is_session_pkt || (((bp->all_idle_map & (((MAP_T) 1) << bin)) != 0) && (!(lp->cln_waiting))))) {
        pQuery->Results.Accept = NLB_ACCEPT_UNCONDITIONAL_OWNERSHIP;
        return;

    /* Otherwise, if there are active connections on this "bucket" or if we own the 
       "bucket" and there are dirty connections on it, then we'll walk our descriptor
       lists to determine whether or not we should take the packet or not. */
    } else if (bp->nconn[bin] > 0 || (lp->cln_waiting && lp->dirty_bin[bin] && ((bp->cmap & (((MAP_T) 1) << bin)) != 0))) {
        PCONN_ENTRY ep;
        PCONN_DESCR dp;

        /* Calculate our index into the descriptor hash table by a modulo operation on the 
           length of the static descriptor array, 4096. */
        id  = id % CVY_MAX_CHASH;

        /* Grab a pointer to the descriptor in our spot in the hash table. */
        ep = &(lp->hashed_conn[id]);

        /* Grab a pointer to our assigned queue of descriptors - our second level hashing. */
        qp = &(lp->connq[id]);
        
        /* First look for a match in the first-level hashing array. */
        if (CVY_CONN_MATCH(ep, svr_ipaddr, svr_port, client_ipaddr, client_port, protocol)) {
            /* If we find a match in the static hash table, fill in some descriptor
               information for the user, including whether or not the descriptor was
               allocated or static (static is this case) and the observed FIN count. */
            pQuery->Results.DescriptorInfo.Valid = TRUE;
            pQuery->Results.DescriptorInfo.Alloc = ep->alloc;
            pQuery->Results.DescriptorInfo.Dirty = ep->dirty;
            pQuery->Results.DescriptorInfo.FinCount = ep->fin_count;
            
            /* If the connection is dirty, we do not take the packet because TCP may
               have stale information for this descriptor. */
            if (ep->dirty) {
                pQuery->Results.Accept = NLB_REJECT_CONNECTION_DIRTY;
                return;
            }

            /* If the connection is not dirty, we'll take the packet, as it belongs
               to an existing connection that we are servicing on this host. */
            pQuery->Results.Accept = NLB_ACCEPT_FOUND_MATCHING_DESCRIPTOR;
            return;

        /* Otherwise, we have to walk the second-level hashing linked list of connection
           (session) descriptors looking for a match. */
        } else {
            /* Walk the queue until we reach the end or find what we're looking for. */
            for (dp = (PCONN_DESCR)Queue_front(qp); dp != NULL; dp = (PCONN_DESCR)Queue_next(qp, &(dp->link))) {
                if (CVY_CONN_MATCH(&(dp->entry), svr_ipaddr, svr_port, client_ipaddr, client_port, protocol)) {
                    /* If we find a match in the static hash table, fill in some descriptor
                       information for the user, including whether or not the descriptor was
                       allocated or static (allocated is this case) and the observed FIN count. */
                    pQuery->Results.DescriptorInfo.Valid = TRUE;
                    pQuery->Results.DescriptorInfo.Alloc = dp->entry.alloc;
                    pQuery->Results.DescriptorInfo.Dirty = dp->entry.dirty;
                    pQuery->Results.DescriptorInfo.FinCount = dp->entry.fin_count;

                    /* If the connection is dirty, we do not take the packet because TCP may
                       have stale information for this descriptor. */
                    if (dp->entry.dirty) {
                        pQuery->Results.Accept = NLB_REJECT_CONNECTION_DIRTY;
                        return;
                    }

                    /* If the connection is not dirty, we'll take the packet, as it belongs
                       to an existing connection that we are servicing on this host. */
                    pQuery->Results.Accept = NLB_ACCEPT_FOUND_MATCHING_DESCRIPTOR;
                    return;
                }
            }
        }
    }

    /* If we get all the way down here, then we aren't going to accept the packet
       because we do not own the "bucket" to which the packet maps and we have no
       existing connection (session) state to allow us to service the packet. */
    pQuery->Results.Accept = NLB_REJECT_OWNED_ELSEWHERE;
    return;
}

#if defined (SBH)

/* 
 * Function: Load_packet_filter
 * Desctription:
 * Parameters:
 * Returns:
 * Author: shouse, 5.18.01
 * Notes:
 */
BOOLEAN Load_packet_filter (
    PLOAD_CTXT      lp,
    ULONG           svr_ipaddr,
    ULONG           svr_port,
    ULONG           client_ipaddr,
    ULONG           client_port,
    USHORT          protocol,
    ULONG           conn_status,
    BOOLEAN         limit_map_fn)
{

    BIN_LOOKUP();

    HASH();

    switch (conn_status) {
    case CVY_CONN_CREATE:
        CREATE_DSCR();
        break;
    case CVY_CONN_UP:
        CREATE_DSCR();
        break;
    case CVY_CONN_DOWN:
    case CVY_CONN_RESET:
        REMOVE_DSCR();
        break;
    case CVY_CONN_DATA:
        // protocol dependent.
        CHECK_HASH();
        SEARCH_QUEUE();
        break;
    }
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\driver\init.c ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

	init.c

Abstract:

	Windows Load Balancing Service (WLBS)
        Driver - initialization implementation

Author:

    kyrilf

--*/

#define NDIS51_MINIPORT         1
#define NDIS_MINIPORT_DRIVER    1
#define NDIS50                  1
#define NDIS51                  1

#include <stdio.h>
#include <string.h>
#include <ndis.h>

#include "main.h"
#include "init.h"
#include "prot.h"
#include "nic.h"
#include "univ.h"
#include "wlbsparm.h"
#include "log.h"
#include "trace.h" // For wmi event tracing

static ULONG log_module_id = LOG_MODULE_INIT;

/* Added for NDIS51. */
extern VOID Nic_pnpevent_notify (
    NDIS_HANDLE           adapter_handle,
    NDIS_DEVICE_PNP_EVENT pnp_event,
    PVOID                 info_buf,
    ULONG                 info_len);

/* Mark code that is used only during initialization. */
#pragma alloc_text (INIT, DriverEntry)

NDIS_STATUS DriverEntry (
    PVOID                         driver_obj,
    PVOID                         registry_path)
{
    NDIS_PROTOCOL_CHARACTERISTICS prot_char;
    NDIS_MINIPORT_CHARACTERISTICS nic_char;
    NDIS_STRING                   prot_name = UNIV_NDIS_PROTOCOL_NAME;
    NTSTATUS                      status;
    PUNICODE_STRING               reg_path = (PUNICODE_STRING) registry_path;
    WCHAR                         params [] = L"\\Parameters\\Interface\\";
    ULONG                         i;

    /* Register Convoy protocol with NDIS. */
    UNIV_PRINT (("DriverEntry: Loading the driver %x", driver_obj));

    univ_driver_ptr = driver_obj;

    /* Initialize the array of bindings. */
    univ_adapters_count = 0;

    for (i = 0 ; i < CVY_MAX_ADAPTERS; i++)
    {
        univ_adapters [i] . code            = MAIN_ADAPTER_CODE;
        univ_adapters [i] . announced       = FALSE;
        univ_adapters [i] . inited          = FALSE;
        univ_adapters [i] . bound           = FALSE;
        univ_adapters [i] . used            = FALSE;
        univ_adapters [i] . ctxtp           = NULL;
        univ_adapters [i] . device_name_len = 0;
        univ_adapters [i] . device_name     = NULL;
    }

    /* create UNICODE name for the protocol */

    univ_reg_path_len = reg_path -> Length + wcslen (params) * sizeof (WCHAR) + sizeof (WCHAR);

    status = NdisAllocateMemoryWithTag (& univ_reg_path, univ_reg_path_len, UNIV_POOL_TAG);

    if (status != NDIS_STATUS_SUCCESS)
    {
        UNIV_PRINT (("Error allocating memory %x", status));
        __LOG_MSG1 (MSG_ERROR_MEMORY, MSG_NONE, status);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    RtlZeroMemory (univ_reg_path, reg_path -> Length + wcslen (params) * sizeof (WCHAR) + sizeof (WCHAR));

    RtlCopyMemory (univ_reg_path, reg_path -> Buffer, reg_path -> Length);

    RtlCopyMemory (((PCHAR) univ_reg_path) + reg_path -> Length, params, wcslen (params) * sizeof (WCHAR));

    /* Initialize miniport wrapper. */
    NdisMInitializeWrapper (& univ_wrapper_handle, driver_obj, registry_path, NULL);

    /* Initialize miniport characteristics. */
    RtlZeroMemory (& nic_char, sizeof (nic_char));

    nic_char . MajorNdisVersion         = UNIV_NDIS_MAJOR_VERSION;
    nic_char . MinorNdisVersion         = UNIV_NDIS_MINOR_VERSION;
    nic_char . HaltHandler              = Nic_halt;
    nic_char . InitializeHandler        = Nic_init;
    nic_char . QueryInformationHandler  = Nic_info_query;
    nic_char . SetInformationHandler    = Nic_info_set;
    nic_char . ResetHandler             = Nic_reset;
    nic_char . ReturnPacketHandler      = Nic_return;
    nic_char . SendPacketsHandler       = Nic_packets_send;
    nic_char . TransferDataHandler      = Nic_transfer;

    /* For NDIS51, define 3 new handlers. These handlers do nothing for now, but stuff will be added later. */
    nic_char . CancelSendPacketsHandler = Nic_cancel_send_packets;
    nic_char . PnPEventNotifyHandler    = Nic_pnpevent_notify;
    nic_char . AdapterShutdownHandler   = Nic_adapter_shutdown;

    UNIV_PRINT (("DriverEntry: Registering miniport"));

    status = NdisIMRegisterLayeredMiniport (univ_wrapper_handle, & nic_char, sizeof (nic_char), & univ_driver_handle);

    if (status != NDIS_STATUS_SUCCESS)
    {
        UNIV_PRINT (("error registering layered miniport with NDIS %x", status));
        __LOG_MSG1 (MSG_ERROR_REGISTERING, MSG_NONE, status);
        NdisTerminateWrapper (univ_wrapper_handle, NULL);
        NdisFreeMemory(univ_reg_path, univ_reg_path_len, 0);
        goto error;
    }

    /* Initialize protocol characteristics. */
    RtlZeroMemory (& prot_char, sizeof (prot_char));

    /* This value needs to be 0, otherwise error registering protocol */
    prot_char . MinorNdisVersion            = 0;                         
    
    prot_char . MajorNdisVersion            = UNIV_NDIS_MAJOR_VERSION;
    prot_char . BindAdapterHandler          = Prot_bind;
    prot_char . UnbindAdapterHandler        = Prot_unbind;
    prot_char . OpenAdapterCompleteHandler  = Prot_open_complete;
    prot_char . CloseAdapterCompleteHandler = Prot_close_complete;
    prot_char . StatusHandler               = Prot_status;
    prot_char . StatusCompleteHandler       = Prot_status_complete;
    prot_char . ResetCompleteHandler        = Prot_reset_complete;
    prot_char . RequestCompleteHandler      = Prot_request_complete;
    prot_char . SendCompleteHandler         = Prot_send_complete;
    prot_char . TransferDataCompleteHandler = Prot_transfer_complete;
    prot_char . ReceiveHandler              = Prot_recv_indicate;
    prot_char . ReceiveCompleteHandler      = Prot_recv_complete;
    prot_char . ReceivePacketHandler        = Prot_packet_recv;
    prot_char . PnPEventHandler             = Prot_PNP_handle;
    prot_char . Name                        = prot_name;

    UNIV_PRINT (("DriverEntry: Registering protocol"));

    NdisRegisterProtocol(& status, & univ_prot_handle, & prot_char, sizeof (prot_char));

    if (status != NDIS_STATUS_SUCCESS)
    {
        UNIV_PRINT (("error registering protocol with NDIS %x", status));
        __LOG_MSG1 (MSG_ERROR_REGISTERING, MSG_NONE, status);
        NdisTerminateWrapper (univ_wrapper_handle, NULL);
        NdisFreeMemory(univ_reg_path, univ_reg_path_len, 0);
        goto error;
    }

    NdisIMAssociateMiniport (univ_driver_handle, univ_prot_handle);

    NdisMRegisterUnloadHandler (univ_wrapper_handle, Init_unload);

    NdisAllocateSpinLock (& univ_bind_lock);

    /* Allocate the global spin lock to protect the list of bi-directional affinity teams. */
    NdisAllocateSpinLock(&univ_bda_teaming_lock);

    UNIV_PRINT (("DriverEntry: completed OK"));

    //
    // Initialize WMI event tracing
    //
    Trace_Initialize( driver_obj, registry_path );

    return NDIS_STATUS_SUCCESS;

error:

    return status;

} /* end DriverEntry */


VOID Init_unload (
    PVOID       driver_obj)
{
    NDIS_STATUS status;
    ULONG       i;

    UNIV_PRINT (("Init_unload: Unloading the driver %x", driver_obj));

    /* If we failed to deallocate the context during unbind (both halt and unbind
       were not called for example) - do it now before unloading the driver. */
    for (i = 0 ; i < CVY_MAX_ADAPTERS; i++)
    {
        NdisAcquireSpinLock(& univ_bind_lock);

        if (univ_adapters [i] . inited && univ_adapters [i] . ctxtp != NULL)
        {
            univ_adapters [i] . used      = FALSE;
            univ_adapters [i] . inited    = FALSE;
            univ_adapters [i] . announced = FALSE;
            univ_adapters [i] . bound     = FALSE;

            NdisReleaseSpinLock(& univ_bind_lock);

            Main_cleanup (univ_adapters [i] . ctxtp);

            NdisFreeMemory (univ_adapters [i] . ctxtp, sizeof (MAIN_CTXT), 0);

            univ_adapters [i] . ctxtp = NULL;

            NdisFreeMemory (univ_adapters [i] . device_name, univ_adapters [i] . device_name_len, 0);

            univ_adapters [i] . device_name     = NULL;
            univ_adapters [i] . device_name_len = 0;
        }
        else 
        {
            NdisReleaseSpinLock(& univ_bind_lock);
        }
    }

    /* Free the global spin lock to protect the list of bi-directional affinity teams. */
    NdisFreeSpinLock(&univ_bda_teaming_lock);

    NdisFreeSpinLock (& univ_bind_lock);

    if (univ_prot_handle == NULL)
        status = NDIS_STATUS_FAILURE;
    else
        NdisDeregisterProtocol (& status, univ_prot_handle);

    UNIV_PRINT (("Init_unload: Deregistered protocol %x", univ_prot_handle, status));

    //
    // Deinitialize WMI event tracing
    //
    Trace_Deinitialize();

    NdisFreeMemory(univ_reg_path, univ_reg_path_len, 0);

    UNIV_PRINT (("Init_unload: Completed OK"));

} /* end Init_unload */

ULONG NLBMiniportCount = 0;

enum _DEVICE_STATE {
    PS_DEVICE_STATE_READY = 0,	// ready for create/delete
    PS_DEVICE_STATE_CREATING,	// create operation in progress
    PS_DEVICE_STATE_DELETING	// delete operation in progress
} NLBControlDeviceState = PS_DEVICE_STATE_READY;

/*
 * Function:
 * Purpose: This function is called by MiniportInitialize and registers the IOCTL interface for WLBS.
 *          The device is registered only for the first miniport instantiation.
 * Author: shouse, 3.1.01 - Copied largely from the sample IM driver net\ndis\samples\im\
 */
NDIS_STATUS Init_register_device (VOID) {
    NDIS_STATUS	     Status = NDIS_STATUS_SUCCESS;
    UNICODE_STRING   DeviceName;
    UNICODE_STRING   DeviceLinkUnicodeString;
    PDRIVER_DISPATCH DispatchTable[IRP_MJ_MAXIMUM_FUNCTION];
    UINT	     i;
    
    UNIV_PRINT(("Init_register_device: Entering, NLBMiniportCount=%u", NLBMiniportCount));
    
    NdisAcquireSpinLock(&univ_bind_lock);
    
    ++NLBMiniportCount;
    
    if (1 == NLBMiniportCount)
    {
        ASSERT(NLBControlDeviceState != PS_DEVICE_STATE_CREATING);
        
        UNIV_PRINT((" ** Registering IOCTL interface"));

        /* Another thread could be running PtDeregisterDevice on behalf 
           of another miniport instance. If so, wait for it to exit. */
        while (NLBControlDeviceState != PS_DEVICE_STATE_READY)
        {
            NdisReleaseSpinLock(&univ_bind_lock);
            NdisMSleep(1);
            NdisAcquireSpinLock(&univ_bind_lock);
        }
        
        NLBControlDeviceState = PS_DEVICE_STATE_CREATING;
        
        NdisReleaseSpinLock(&univ_bind_lock);
        
        for (i = 0; i < IRP_MJ_MAXIMUM_FUNCTION; i++)
            DispatchTable[i] = Main_dispatch;
        
        NdisInitUnicodeString(&DeviceName, CVY_DEVICE_NAME);
        NdisInitUnicodeString(&DeviceLinkUnicodeString, CVY_DOSDEVICE_NAME);
        
        /* Create a device object and register our dispatch handlers. */
        Status = NdisMRegisterDevice(univ_wrapper_handle, &DeviceName, &DeviceLinkUnicodeString,
            &DispatchTable[0], &univ_device_object, &univ_device_handle);
        
        if (Status != NDIS_STATUS_SUCCESS || univ_device_handle == NULL)
        {
            UNIV_PRINT((" ** Error registering device with NDIS %x", Status));

            __LOG_MSG1(MSG_ERROR_REGISTERING, MSG_NONE, Status);

            univ_device_handle = NULL;
        }

        NdisAcquireSpinLock(&univ_bind_lock);
        
        NLBControlDeviceState = PS_DEVICE_STATE_READY;
    }
    
    NdisReleaseSpinLock(&univ_bind_lock);
    
    UNIV_PRINT(("Init_register_device: Exiting, Status=%x", Status));
    
    return (Status);
}

/*
 * Function:
 * Purpose: This function is called by MiniportHalt and deregisters the IOCTL interface for WLBS.
 *          The device is deregistered only wnen the last miniport halts.
 * Author: shouse, 3.1.01 - Copied largely from the sample IM driver net\ndis\samples\im\
 */
NDIS_STATUS Init_deregister_device (VOID) {
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    
    UNIV_PRINT(("Init_deregister_device: Entering, NLBMiniportCount=%u", NLBMiniportCount));
    
    NdisAcquireSpinLock(&univ_bind_lock);
    
    ASSERT(NLBMiniportCount > 0);
    
    --NLBMiniportCount;
    
    if (0 == NLBMiniportCount)
    {
        /* All miniport instances have been halted. Deregister the control device. */
        
        ASSERT(NLBControlDeviceState == PS_DEVICE_STATE_READY);
        
        UNIV_PRINT((" ** Deleting IOCTL interface"));

        /* Block PtRegisterDevice() while we release the control
           device lock and deregister the device. */
        NLBControlDeviceState = PS_DEVICE_STATE_DELETING;
        
        NdisReleaseSpinLock(&univ_bind_lock);
        
        if (univ_device_handle != NULL)
        {
            Status = NdisMDeregisterDevice(univ_device_handle);
            univ_device_handle = NULL;
        }
        
        NdisAcquireSpinLock(&univ_bind_lock);

        NLBControlDeviceState = PS_DEVICE_STATE_READY;
    }

    NdisReleaseSpinLock(&univ_bind_lock);
    
    UNIV_PRINT(("Init_deregister_Device: Exiting, Status=%x", Status));

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\driver\init.h ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    init.h

Abstract:

    Windows Load Balancing Service (WLBS)
    Driver - initialization

Author:

    kyrilf

--*/


#ifndef _Init_h_
#define _Init_h_

#include <ndis.h>


/* PROCEDURES */


extern NDIS_STATUS DriverEntry (
    PVOID               driver_obj,         /* driver object */
    PVOID               registry_path);     /* system registry path to our
                                               driver */
/*
  Driver's main entry routine

  returns NDIS_STATUS:

  function:
*/


extern VOID Init_unload (
    PVOID               driver_obj);
/*
  Driver's unload routine

  returns NDIS_STATUS:

  function:
*/

/*
 * Function:
 * Purpose: This function is called by MiniportInitialize and registers the IOCTL interface for WLBS.
 *          The device is registered only for the first miniport instantiation.
 * Author: shouse, 3.1.01
 */
NDIS_STATUS Init_register_device (VOID);

/*
 * Function:
 * Purpose: This function is called by MiniportHalt and deregisters the IOCTL interface for WLBS.
 *          The device is deregistered only wnen the last miniport halts.
 * Author: shouse, 3.1.01
 */
NDIS_STATUS Init_deregister_device (VOID);

#endif /* end _Init_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\driver\log.c ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

	log.c

Abstract:

	Windows Load Balancing Service (WLBS)
    Driver - event logging support

Author:

    kyrilf

--*/


#include <ntddk.h>

#include "log.h"
#include "univ.h"


/* PROCEDURES */


BOOLEAN Log_event (
    NTSTATUS             code,
    PWSTR                msg1,
    PWSTR                msg2,
    PWSTR                msg3,
    PWSTR                msg4,
    ULONG                loc,
    ULONG                d1,
    ULONG                d2,
    ULONG                d3,
    ULONG                d4)
{
    PIO_ERROR_LOG_PACKET ErrorLogEntry;
    UNICODE_STRING       ErrorStr[4];
    PWCHAR               InsertStr;
    ULONG                EntrySize;
    ULONG                BytesLeft;
    ULONG                i;

    RtlInitUnicodeString(&ErrorStr[0], msg1);
    RtlInitUnicodeString(&ErrorStr[1], msg2);
    RtlInitUnicodeString(&ErrorStr[2], msg3);
    RtlInitUnicodeString(&ErrorStr[3], msg4);

    /* Remember the insertion string should be NUL terminated. So we allocate the 
       extra space of WCHAR. The first parameter to IoAllocateErrorLogEntry can 
       be either the driver object or the device object. If it is given a device 
       object, the name of the device (used in IoCreateDevice) will show up in the 
       place of %1 in the message. See the message file (.mc) for more details. */
    EntrySize = sizeof(IO_ERROR_LOG_PACKET) + LOG_NUMBER_DUMP_DATA_ENTRIES * sizeof (ULONG) +
	ErrorStr[0].Length + ErrorStr[1].Length + ErrorStr[2].Length + ErrorStr[3].Length + 4 * sizeof(WCHAR);

    /* Truncate the size if necessary. */
    if (EntrySize > ERROR_LOG_MAXIMUM_SIZE) {
        if (ERROR_LOG_MAXIMUM_SIZE > (sizeof(IO_ERROR_LOG_PACKET) + LOG_NUMBER_DUMP_DATA_ENTRIES * sizeof (ULONG))) {
            UNIV_PRINT (("Log_event: log entry size too large, truncating: size=%u, max=%u", EntrySize, ERROR_LOG_MAXIMUM_SIZE));
            EntrySize = ERROR_LOG_MAXIMUM_SIZE;
        } else {
            UNIV_PRINT (("Log_event: log entry size too large, exiting: size=%u, max=%u", EntrySize, ERROR_LOG_MAXIMUM_SIZE));
            return FALSE;
        }
    }    

    ErrorLogEntry = IoAllocateErrorLogEntry(univ_driver_ptr, (UCHAR)(EntrySize));

    if (ErrorLogEntry == NULL) {
#if DBG
        /* Convert Unicode string to AnsiCode; %ls can only be used in PASSIVE_LEVEL. */
        CHAR AnsiString[64];

        for (i = 0; (i < sizeof(AnsiString) - 1) && (i < ErrorStr[0].Length); i++)
            AnsiString[i] = (CHAR)msg1[i];

        AnsiString[i] = '\0';
        
        UNIV_PRINT (("Log_event: error allocating log entry %s", AnsiString));
#endif        
        return FALSE;
    }

    ErrorLogEntry -> ErrorCode         = code;
    ErrorLogEntry -> SequenceNumber    = 0;
    ErrorLogEntry -> MajorFunctionCode = 0;
    ErrorLogEntry -> RetryCount        = 0;
    ErrorLogEntry -> UniqueErrorValue  = 0;
    ErrorLogEntry -> FinalStatus       = STATUS_SUCCESS;
    ErrorLogEntry -> DumpDataSize      = (LOG_NUMBER_DUMP_DATA_ENTRIES + 1) * sizeof (ULONG);
    ErrorLogEntry -> StringOffset      = sizeof (IO_ERROR_LOG_PACKET) + LOG_NUMBER_DUMP_DATA_ENTRIES * sizeof (ULONG);
    ErrorLogEntry -> NumberOfStrings   = 0;

    /* load the NUMBER_DUMP_DATA_ENTRIES plus location id here */
    ErrorLogEntry -> DumpData [0]      = loc;
    ErrorLogEntry -> DumpData [1]      = d1;
    ErrorLogEntry -> DumpData [2]      = d2;
    ErrorLogEntry -> DumpData [3]      = d3;
    ErrorLogEntry -> DumpData [4]      = d4;

    /* Calculate the number of bytes available in the string storage area. */
    BytesLeft = EntrySize - ErrorLogEntry->StringOffset;

    /* Set a pointer to the beginning of the string storage area. */
    InsertStr = (PWCHAR)((PCHAR)ErrorLogEntry + ErrorLogEntry->StringOffset);

    /* Loop through all strings and put in as many as we can. */
    for (i = 0; i < 4, BytesLeft > 0; i++) {
        /* Find out how much of this string we can fit into the buffer - save room for the NUL character. */
        ULONG Length = (ErrorStr[i].Length <= (BytesLeft - sizeof(WCHAR))) ? ErrorStr[i].Length : BytesLeft - sizeof(WCHAR);

        /* Copy the number of characters that will fit. */
        RtlMoveMemory(InsertStr, ErrorStr[i].Buffer, Length);

        /* Put the NUL character at the end. */
        *(PWCHAR)((PCHAR)InsertStr + Length) = L'\0';

        /* Increment the number of strings successfully fit in the buffer. */
        ErrorLogEntry->NumberOfStrings++;

        /* Move the string pointer past the string. */
        InsertStr = (PWCHAR)((PCHAR)InsertStr + Length + sizeof(WCHAR));

        /* Calculate the number of bytes left now. */
        BytesLeft -= (Length + sizeof(WCHAR));
    }

    IoWriteErrorLogEntry(ErrorLogEntry);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\driver\log.h ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    log.h

Abstract:

    Windows Load Balancing Service (WLBS)
    Driver - event logging support

Author:

    kyrilf

--*/


#ifndef _Log_h_
#define _Log_h_

#include <ndis.h>

#include "log_msgs.h"


/* CONSTANTS */
#define LOG_NUMBER_DUMP_DATA_ENTRIES    4

/* module IDs */
#define LOG_MODULE_INIT                 1
#define LOG_MODULE_UNLOAD               2
#define LOG_MODULE_NIC                  3
#define LOG_MODULE_PROT                 4
#define LOG_MODULE_MAIN                 5
#define LOG_MODULE_LOAD                 6
#define LOG_MODULE_UTIL                 7
#define LOG_MODULE_PARAMS               8
#define LOG_MODULE_TCPIP                9

#define MSG_NONE                        L""

/* MACROS */

// Summary of logging function:
// Log_event (MSG_NAME from log_msgs.mc, "WLBS..." (hardcoded string %2), message 1 (%3), message 2 (%4), message 3 (%5), 
//            module location (hardcoded first dump data entry), dump data 1, dump data 2, dump data 3, dump data 4);

#define __LOG_MSG(code,msg1)            Log_event (code,      CVY_NAME,           msg1, MSG_NONE, MSG_NONE, __LINE__ | (log_module_id << 16), 0,           0,           0,           0)
#define __LOG_MSG1(code,msg1,d1)        Log_event (code,      CVY_NAME,           msg1, MSG_NONE, MSG_NONE, __LINE__ | (log_module_id << 16), (ULONG)(d1), 0,           0,           0)
#define __LOG_MSG2(code,msg1,d1,d2)     Log_event (code,      CVY_NAME,           msg1, MSG_NONE, MSG_NONE, __LINE__ | (log_module_id << 16), (ULONG)(d1), (ULONG)(d2), 0,           0)

#define LOG_MSG(code,msg1)              Log_event (code,      ctxtp->log_msg_str, msg1, MSG_NONE, MSG_NONE, __LINE__ | (log_module_id << 16), 0,           0,           0,           0)
#define LOG_MSGS(code,msg1,msg2)        Log_event (code,      ctxtp->log_msg_str, msg1, msg2,     MSG_NONE, __LINE__ | (log_module_id << 16), 0,           0,           0,           0)
#define LOG_MSGS3(code,msg1,msg2,msg3)  Log_event (code,      ctxtp->log_msg_str, msg1, msg2,     msg3,     __LINE__ | (log_module_id << 16), 0,           0,           0,           0)

#define LOG_MSG1(code,msg1,d1)          Log_event (code,      ctxtp->log_msg_str, msg1, MSG_NONE, MSG_NONE, __LINE__ | (log_module_id << 16), (ULONG)(d1), 0,           0,           0)
#define LOG_MSG2(code,msg1,d1,d2)       Log_event (code,      ctxtp->log_msg_str, msg1, MSG_NONE, MSG_NONE, __LINE__ | (log_module_id << 16), (ULONG)(d1), (ULONG)(d2), 0,           0)
#define LOG_MSG3(code,msg1,d1,d2,d3)    Log_event (code,      ctxtp->log_msg_str, msg1, MSG_NONE, MSG_NONE, __LINE__ | (log_module_id << 16), (ULONG)(d1), (ULONG)(d2), (ULONG)(d3), 0)
#define LOG_MSG4(code,msg1,d1,d2,d3,d4) Log_event (code,      ctxtp->log_msg_str, msg1, MSG_NONE, MSG_NONE, __LINE__ | (log_module_id << 16), (ULONG)(d1), (ULONG)(d2), (ULONG)(d3), (ULONG)(d4))

#define LOG_INFO(msg1)                  Log_event (MSG_INFO,  ctxtp->log_msg_str, msg1, MSG_NONE, MSG_NONE, __LINE__ | (log_module_id << 16), 0,           0,           0,           0)
#define LOG_INFO4(msg1,d1,d2,d3,d4)     Log_event (MSG_INFO,  ctxtp->log_msg_str, msg1, MSG_NONE, MSG_NONE, __LINE__ | (log_module_id << 16), (ULONG)(d1), (ULONG)(d2), (ULONG)(d3), (ULONG)(d4))

#define LOG_WARN(msg1)                  Log_event (MSG_WARN,  ctxtp->log_msg_str, msg1, MSG_NONE, MSG_NONE, __LINE__ | (log_module_id << 16), 0,           0,           0,           0)
#define LOG_WARN4(msg1,d1,d2,d3,d4)     Log_event (MSG_WARN,  ctxtp->log_msg_str, msg1, MSG_NONE, MSG_NONE, __LINE__ | (log_module_id << 16), (ULONG)(d1), (ULONG)(d2), (ULONG)(d3), (ULONG)(d4))

#define LOG_ERROR(msg1)                 Log_event (MSG_ERROR, ctxtp->log_msg_str, msg1, MSG_NONE, MSG_NONE, __LINE__ | (log_module_id << 16), 0,           0,           0,           0)
#define LOG_ERROR4(msg1,d1,d2,d3,d4)    Log_event (MSG_ERROR, ctxtp->log_msg_str, msg1, MSG_NONE, MSG_NONE, __LINE__ | (log_module_id << 16), (ULONG)(d1), (ULONG)(d2), (ULONG)(d3), (ULONG)(d4))

/* PROCEDURES */
extern BOOLEAN Log_event (
    NTSTATUS            code,           /* status code */
    PWSTR               str1,           /* message string */
    PWSTR               str2,           /* message string */
    PWSTR               str3,           /* message string */
    PWSTR               str4,           /* message string */
    ULONG               loc,            /* message location identifier */
    ULONG               d1,             /* dump data to enter into the log */
    ULONG               d2,
    ULONG               d3,
    ULONG               d4);
/*
  Log system event

  returns NTSTATUS:

  function:
*/


#endif /* _Log_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\driver\nic.c ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    nic.c

Abstract:

    Windows Load Balancing Service (WLBS)
    Driver - upper-level (NIC) layer of intermediate miniport

Author:

    kyrilf

--*/


#define NDIS_MINIPORT_DRIVER    1
//#define NDIS50_MINIPORT         1
#define NDIS51_MINIPORT         1

#include <ndis.h>

#include "nic.h"
#include "prot.h"
#include "main.h"
#include "util.h"
#include "wlbsparm.h"
#include "univ.h"
#include "log.h"
#include "init.h"

/* define this routine here since the necessary portion of ndis.h was not
   imported due to NDIS_... flags */

extern NTKERNELAPI VOID KeBugCheckEx (ULONG code, ULONG_PTR p1, ULONG_PTR p2, ULONG_PTR p3, ULONG_PTR p4);

NTHALAPI KIRQL KeGetCurrentIrql();

/* GLOBALS */

static ULONG log_module_id = LOG_MODULE_NIC;


/* PROCEDURES */


/* miniport handlers */

NDIS_STATUS Nic_init (      /* PASSIVE_IRQL */
    PNDIS_STATUS        open_status,
    PUINT               medium_index,
    PNDIS_MEDIUM        medium_array,
    UINT                medium_size,
    NDIS_HANDLE         adapter_handle,
    NDIS_HANDLE         wrapper_handle)
{
    PMAIN_CTXT          ctxtp;
    UINT                i;
    NDIS_STATUS         status;
    PMAIN_ADAPTER       adapterp;


    /* verify that we have the context setup (Prot_bind was called) */

    UNIV_PRINT (("Nic_init: called %x", adapter_handle));

#if 0
    if (univ_ctxt_handle == NULL)
    {
        UNIV_PRINT (("no current context"));
        LOG_MSG (MSG_ERROR_INTERNAL, MSG_NONE);
        return NDIS_STATUS_ADAPTER_NOT_FOUND;
    }
#endif
    ctxtp = (PMAIN_CTXT) NdisIMGetDeviceContext (adapter_handle);

    if (ctxtp == NULL)
        return NDIS_STATUS_ADAPTER_NOT_FOUND;

    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    adapterp = & (univ_adapters [ctxtp -> adapter_id]);
    UNIV_ASSERT (adapterp -> ctxtp == ctxtp);

    /* return supported mediums */

    for (i = 0; i < medium_size; i ++)
    {
        if (medium_array [i] == ctxtp -> medium)
        {
            * medium_index = i;
            break;
        }
    }

    if (i >= medium_size)
    {
        UNIV_PRINT (("unsupported media requested %d, %d, %x", i, medium_size, ctxtp -> medium));
        LOG_MSG3 (MSG_ERROR_MEDIA, MSG_NONE, i, medium_size, ctxtp -> medium);
        return NDIS_STATUS_UNSUPPORTED_MEDIA;
    }

    ctxtp -> prot_handle = adapter_handle;

    NdisMSetAttributesEx (adapter_handle, ctxtp, 0,
                          NDIS_ATTRIBUTE_INTERMEDIATE_DRIVER |   /* V1.1.2 */  /* v2.07 */
                          NDIS_ATTRIBUTE_DESERIALIZE |
                          NDIS_ATTRIBUTE_IGNORE_PACKET_TIMEOUT |
                          NDIS_ATTRIBUTE_IGNORE_REQUEST_TIMEOUT |
                          NDIS_ATTRIBUTE_NO_HALT_ON_SUSPEND, 0);

	/* Setting up the default value for the Device State Flag as PM capable
	   initialize the PM Variable, (for both NIC and the PROT)
       Device is ON by default. */

	ctxtp->prot_pnp_state = NdisDeviceStateD0;
	ctxtp->nic_pnp_state  = NdisDeviceStateD0;

    /* create and initialize periodic timer for heartbeats */

    status = NdisAllocateMemoryWithTag (& ctxtp -> timer,
                                        sizeof (NDIS_MINIPORT_TIMER),
                                        UNIV_POOL_TAG);

    if (status != NDIS_STATUS_SUCCESS)
    {
        UNIV_PRINT (("error allocating timer %d %x", sizeof (NDIS_MINIPORT_TIMER), status));
        LOG_MSG2 (MSG_ERROR_MEMORY, MSG_NONE, sizeof (NDIS_MINIPORT_TIMER), status);
        return NDIS_STATUS_RESOURCES;
    }

    NdisMInitializeTimer ((PNDIS_MINIPORT_TIMER) ctxtp -> timer,
                          ctxtp -> prot_handle, Nic_timer, ctxtp);

    ctxtp -> curr_tout = ctxtp -> params . alive_period;

    NdisMSetPeriodicTimer ((PNDIS_MINIPORT_TIMER) ctxtp -> timer, ctxtp -> curr_tout);

    /* shouse, 3.1.01 - Create the IOCTL interface.  This was previously done in Driver_Entry, which 
       caused uninstall/install problems due to open handles existing after HALTing the miniport. 
       DO NOT call this function with the univ_bind_lock acquired. */
    Init_register_device();

    NdisAcquireSpinLock(& univ_bind_lock);
    UNIV_ASSERT (adapterp -> code == MAIN_ADAPTER_CODE);
    adapterp -> announced = TRUE;
    NdisReleaseSpinLock(& univ_bind_lock);

    return NDIS_STATUS_SUCCESS;

} /* end Nic_init */


VOID Nic_halt ( /* PASSIVE_IRQL */
    NDIS_HANDLE         adapter_handle)
{
    PMAIN_CTXT          ctxtp = (PMAIN_CTXT) adapter_handle;
    BOOLEAN             done;
    NDIS_STATUS         status;
    PMAIN_ADAPTER       adapterp;


    UNIV_PRINT (("Nic_halt: called"));

    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    UNIV_PRINT ((" nic_halt: adapter id is 0x%x", ctxtp -> adapter_id));
    adapterp = & (univ_adapters [ctxtp -> adapter_id]);
    UNIV_ASSERT (adapterp -> code == MAIN_ADAPTER_CODE);
    UNIV_ASSERT (adapterp -> ctxtp == ctxtp);

    NdisAcquireSpinLock(& univ_bind_lock);

    if (! adapterp -> announced)
    {
        NdisReleaseSpinLock(& univ_bind_lock);
        return;
    }

    adapterp -> announced = FALSE;
    NdisReleaseSpinLock(& univ_bind_lock);

    /* shouse, 3.1.01 - Destroy the IOCTL interface.  This was previously done in Init_Unload, which 
       caused uninstall/install problems due to open handles existing after HALTing the miniport.
       DO NOT call this function with the univ_bind_lock acquired. */
    Init_deregister_device();

    /* release resources */

    NdisMCancelTimer ((PNDIS_MINIPORT_TIMER) ctxtp -> timer, & done);
    NdisFreeMemory (ctxtp -> timer, sizeof (NDIS_MINIPORT_TIMER), 0);

//    ctxtp->prot_handle = NULL;
    /* This is commented out to resolve a timing issue.
     * During unbind, a packet could go through but the flags
     * announced and bound are reset and prot_handle is set to NULL
     * So, this should be set after CloseAdapter.
     */

    status = Prot_close (adapterp);

    /* ctxtp might be gone at this point! */

    UNIV_PRINT (("Nic_halt: exiting %x", status));

} /* end Nic_halt */


//#define TRACE_OID
NDIS_STATUS Nic_info_query (
    NDIS_HANDLE         adapter_handle,
    NDIS_OID            oid,
    PVOID               info_buf,
    ULONG               info_len,
    PULONG              written,
    PULONG              needed)
{
    PMAIN_CTXT          ctxtp = (PMAIN_CTXT) adapter_handle;
    NDIS_STATUS         status;
    PMAIN_ACTION        actp;
    PNDIS_REQUEST       request;
    ULONG               size;
    PMAIN_ADAPTER       adapterp;


    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

#if defined(TRACE_OID)
    DbgPrint("Nic_info_query: called for %x, %x %d\n", oid, info_buf, info_len);
#endif

    adapterp = & (univ_adapters [ctxtp -> adapter_id]);
    UNIV_ASSERT (adapterp -> code == MAIN_ADAPTER_CODE);
    UNIV_ASSERT (adapterp -> ctxtp == ctxtp);

    if (! adapterp -> inited)
        return NDIS_STATUS_FAILURE;

    if (oid == OID_PNP_QUERY_POWER)
    {
#if defined(TRACE_OID)
        DbgPrint("Nic_info_query: OID_PNP_QUERY_POWER\n");
#endif
        return NDIS_STATUS_SUCCESS;
    }

    if (ctxtp -> reset_state != MAIN_RESET_NONE ||
        ctxtp->nic_pnp_state > NdisDeviceStateD0 ||
        ctxtp->standby_state)
        return NDIS_STATUS_FAILURE;

    /* this would break if passing it through to the lower NIC due to what seems
       to be a bug in NDIS */

    /* V2.0.6 add performance counters */


    switch (oid)
    {
        case OID_GEN_SUPPORTED_LIST:

#if defined(TRACE_OID)
            DbgPrint("Nic_info_query: OID_GEN_SUPPORTED_LIST\n");
#endif
            break;
#if 0
            size = UNIV_NUM_OIDS * sizeof (ULONG);

            if (size > info_len)
            {
                * needed = size;
                return NDIS_STATUS_INVALID_LENGTH;
            }

            NdisMoveMemory (info_buf, univ_oids, size);
            * written = size;
            return NDIS_STATUS_SUCCESS;
#endif

        case OID_GEN_XMIT_OK:

            if (info_len < sizeof (ULONG))
            {
                * needed = sizeof (ULONG);
                return NDIS_STATUS_INVALID_LENGTH;
            }

            * ((PULONG) info_buf) = ctxtp -> cntr_xmit_ok;
            * written = sizeof (ULONG);

#if defined(TRACE_OID)
            DbgPrint("Nic_info_query: OID_GEN_XMIT_OK %d\n", *(PULONG) info_buf);
#endif
            return NDIS_STATUS_SUCCESS;

        case OID_GEN_RCV_OK:

            if (info_len < sizeof (ULONG))
            {
                * needed = sizeof (ULONG);
                return NDIS_STATUS_INVALID_LENGTH;
            }

            * ((PULONG) info_buf) = ctxtp -> cntr_recv_ok;
            * written = sizeof (ULONG);

#if defined(TRACE_OID)
            DbgPrint("Nic_info_query: OID_GEN_RCV_OK %d\n", *(PULONG) info_buf);
#endif
            return NDIS_STATUS_SUCCESS;

        case OID_GEN_XMIT_ERROR:

            if (info_len < sizeof (ULONG))
            {
                * needed = sizeof (ULONG);
                return NDIS_STATUS_INVALID_LENGTH;
            }

            * ((PULONG) info_buf) = ctxtp -> cntr_xmit_err;
            * written = sizeof (ULONG);

#if defined(TRACE_OID)
            DbgPrint("Nic_info_query: OID_GEN_XMIT_ERROR %d\n", *(PULONG) info_buf);
#endif
            return NDIS_STATUS_SUCCESS;

        case OID_GEN_RCV_ERROR:

            if (info_len < sizeof (ULONG))
            {
                * needed = sizeof (ULONG);
                return NDIS_STATUS_INVALID_LENGTH;
            }

            * ((PULONG) info_buf) = ctxtp -> cntr_recv_err;
            * written = sizeof (ULONG);

#if defined(TRACE_OID)
            DbgPrint("Nic_info_query: OID_GEN_RCV_ERROR %d\n", *(PULONG) info_buf);
#endif
            return NDIS_STATUS_SUCCESS;

        case OID_GEN_RCV_NO_BUFFER:

            if (info_len < sizeof (ULONG))
            {
                * needed = sizeof (ULONG);
                return NDIS_STATUS_INVALID_LENGTH;
            }

            * ((PULONG) info_buf) = ctxtp -> cntr_recv_no_buf;
            * written = sizeof (ULONG);

#if defined(TRACE_OID)
            DbgPrint("Nic_info_query: OID_GEN_RCV_NO_BUFFER %d\n", *(PULONG) info_buf);
#endif
            return NDIS_STATUS_SUCCESS;

        case OID_GEN_DIRECTED_BYTES_XMIT:

            if (info_len < sizeof (ULONGLONG))
            {
                * needed = sizeof (ULONGLONG);
                return NDIS_STATUS_INVALID_LENGTH;
            }

            * ((PULONGLONG) info_buf) = ctxtp -> cntr_xmit_bytes_dir;
            * written = sizeof (ULONGLONG);

#if defined(TRACE_OID)
            DbgPrint("Nic_info_query: OID_GEN_DIRECTED_BYTES_XMIT %.0f\n", *(PULONGLONG) info_buf);
#endif
            return NDIS_STATUS_SUCCESS;

        case OID_GEN_DIRECTED_FRAMES_XMIT:

            if (info_len < sizeof (ULONG))
            {
                * needed = sizeof (ULONG);
                return NDIS_STATUS_INVALID_LENGTH;
            }

            * ((PULONG) info_buf) = ctxtp -> cntr_xmit_frames_dir;
            * written = sizeof (ULONG);

#if defined(TRACE_OID)
            DbgPrint("Nic_info_query: OID_GEN_DIRECTED_FRAMES_XMIT %d\n", *(PULONG) info_buf);
#endif
            return NDIS_STATUS_SUCCESS;

        case OID_GEN_MULTICAST_BYTES_XMIT:

            if (info_len < sizeof (ULONGLONG))
            {
                * needed = sizeof (ULONGLONG);
                return NDIS_STATUS_INVALID_LENGTH;
            }

            * ((PULONGLONG) info_buf) = ctxtp -> cntr_xmit_bytes_mcast;
            * written = sizeof (ULONGLONG);

#if defined(TRACE_OID)
            DbgPrint("Nic_info_query: OID_GEN_MULTICAST_BYTES_XMIT %.0f\n", *(PULONGLONG) info_buf);
#endif
            return NDIS_STATUS_SUCCESS;

        case OID_GEN_MULTICAST_FRAMES_XMIT:

            if (info_len < sizeof (ULONG))
            {
                * needed = sizeof (ULONG);
                return NDIS_STATUS_INVALID_LENGTH;
            }

            * ((PULONG) info_buf) = ctxtp -> cntr_xmit_frames_mcast;
            * written = sizeof (ULONG);

#if defined(TRACE_OID)
            DbgPrint("Nic_info_query: OID_GEN_MULTICAST_FRAMES_XMIT %d\n", *(PULONG) info_buf);
#endif
            return NDIS_STATUS_SUCCESS;

        case OID_GEN_BROADCAST_BYTES_XMIT:

            if (info_len < sizeof (ULONGLONG))
            {
                * needed = sizeof (ULONGLONG);
                return NDIS_STATUS_INVALID_LENGTH;
            }

            * ((PULONGLONG) info_buf) = ctxtp -> cntr_xmit_bytes_bcast;
            * written = sizeof (ULONGLONG);

#if defined(TRACE_OID)
            DbgPrint("Nic_info_query: OID_GEN_BROADCAST_BYTES_XMIT %.0f\n", *(PULONGLONG) info_buf);
#endif
            return NDIS_STATUS_SUCCESS;

        case OID_GEN_BROADCAST_FRAMES_XMIT:

            if (info_len < sizeof (ULONG))
            {
                * needed = sizeof (ULONG);
                return NDIS_STATUS_INVALID_LENGTH;
            }

            * ((PULONG) info_buf) = ctxtp -> cntr_xmit_frames_bcast;
            * written = sizeof (ULONG);

#if defined(TRACE_OID)
            DbgPrint("Nic_info_query: OID_GEN_BROADCAST_FRAMES_XMIT %d\n", *(PULONG) info_buf);
#endif
            return NDIS_STATUS_SUCCESS;

        case OID_GEN_DIRECTED_BYTES_RCV:

            if (info_len < sizeof (ULONGLONG))
            {
                * needed = sizeof (ULONGLONG);
                return NDIS_STATUS_INVALID_LENGTH;
            }

            * ((PULONGLONG) info_buf) = ctxtp -> cntr_recv_bytes_dir;
            * written = sizeof (ULONGLONG);

#if defined(TRACE_OID)
            DbgPrint("Nic_info_query: OID_GEN_DIRECTED_BYTES_RCV %.0f\n", *(PULONGLONG) info_buf);
#endif
            return NDIS_STATUS_SUCCESS;

        case OID_GEN_DIRECTED_FRAMES_RCV:

            if (info_len < sizeof (ULONG))
            {
                * needed = sizeof (ULONG);
                return NDIS_STATUS_INVALID_LENGTH;
            }

            * ((PULONG) info_buf) = ctxtp -> cntr_recv_frames_dir;
            * written = sizeof (ULONG);

#if defined(TRACE_OID)
            DbgPrint("Nic_info_query: OID_GEN_DIRECTED_FRAMES_RCV %d\n", *(PULONG) info_buf);
#endif
            return NDIS_STATUS_SUCCESS;

        case OID_GEN_MULTICAST_BYTES_RCV:

            if (info_len < sizeof (ULONGLONG))
            {
                * needed = sizeof (ULONGLONG);
                return NDIS_STATUS_INVALID_LENGTH;
            }

            * ((PULONGLONG) info_buf) = ctxtp -> cntr_recv_bytes_mcast;
            * written = sizeof (ULONGLONG);

#if defined(TRACE_OID)
            DbgPrint("Nic_info_query: OID_GEN_MULTICAST_BYTES_RCV %.0f\n", *(PULONGLONG) info_buf);
#endif
            return NDIS_STATUS_SUCCESS;

        case OID_GEN_MULTICAST_FRAMES_RCV:

            if (info_len < sizeof (ULONG))
            {
                * needed = sizeof (ULONG);
                return NDIS_STATUS_INVALID_LENGTH;
            }

            * ((PULONG) info_buf) = ctxtp -> cntr_recv_frames_mcast;
            * written = sizeof (ULONG);

#if defined(TRACE_OID)
            DbgPrint("Nic_info_query: OID_GEN_MULTICAST_FRAMES_RCV %d\n", *(PULONG) info_buf);
#endif
            return NDIS_STATUS_SUCCESS;

        case OID_GEN_BROADCAST_BYTES_RCV:

            if (info_len < sizeof (ULONGLONG))
            {
                * needed = sizeof (ULONGLONG);
                return NDIS_STATUS_INVALID_LENGTH;
            }

            * ((PULONGLONG) info_buf) = ctxtp -> cntr_recv_bytes_bcast;
            * written = sizeof (ULONGLONG);

#if defined(TRACE_OID)
            DbgPrint("Nic_info_query: OID_GEN_DIRECTED_BROADCAST_RCV %.0f\n", *(PULONGLONG) info_buf);
#endif
            return NDIS_STATUS_SUCCESS;

        case OID_GEN_BROADCAST_FRAMES_RCV:

            if (info_len < sizeof (ULONG))
            {
                * needed = sizeof (ULONG);
                return NDIS_STATUS_INVALID_LENGTH;
            }

            * ((PULONG) info_buf) = ctxtp -> cntr_recv_frames_bcast;
            * written = sizeof (ULONG);

#if defined(TRACE_OID)
            DbgPrint("Nic_info_query: OID_GEN_BROADCAST_FRAMES_RCV %d\n", *(PULONG) info_buf);
#endif
            return NDIS_STATUS_SUCCESS;

        case OID_GEN_RCV_CRC_ERROR:

            if (info_len < sizeof (ULONG))
            {
                * needed = sizeof (ULONG);
                return NDIS_STATUS_INVALID_LENGTH;
            }

            * ((PULONG) info_buf) = ctxtp -> cntr_recv_crc_err;
            * written = sizeof (ULONG);

#if defined(TRACE_OID)
            DbgPrint("Nic_info_query: OID_GEN_RCV_CRC_ERROR %d\n", *(PULONG) info_buf);
#endif
            return NDIS_STATUS_SUCCESS;

        case OID_GEN_TRANSMIT_QUEUE_LENGTH:

            if (info_len < sizeof (ULONG))
            {
                * needed = sizeof (ULONG);
                return NDIS_STATUS_INVALID_LENGTH;
            }

            * ((PULONG) info_buf) = ctxtp -> cntr_xmit_queue_len;
            * written = sizeof (ULONG);

#if defined(TRACE_OID)
            DbgPrint("Nic_info_query: OID_GEN_TRANSMIT_QUEUE_LENGTH %d\n", *(PULONG) info_buf);
#endif
            return NDIS_STATUS_SUCCESS;

        default:
            break;
    }

    actp = Main_action_get (ctxtp);

    if (actp == NULL)
    {
        UNIV_PRINT (("error allocating action"));
        return NDIS_STATUS_FAILURE;
    }

    request = & actp -> op . request . req;

    request -> RequestType = NdisRequestQueryInformation;

    request -> DATA . QUERY_INFORMATION . Oid                     = oid;
    request -> DATA . QUERY_INFORMATION . InformationBuffer       = info_buf;
    request -> DATA . QUERY_INFORMATION . InformationBufferLength = info_len;

    actp -> op . request . xferred = written;
    actp -> op . request . needed  = needed;

    /* pass request down */

    status = Prot_request (ctxtp, actp, TRUE);

    if (status != NDIS_STATUS_PENDING)
    {
        * written = request -> DATA . QUERY_INFORMATION . BytesWritten;
        * needed  = request -> DATA . QUERY_INFORMATION . BytesNeeded;

#if defined(TRACE_OID)
        DbgPrint("Nic_info_query: done %x, %d %d, %x\n", status, * written, * needed, * ((PULONG) (request -> DATA . QUERY_INFORMATION . InformationBuffer)));
#endif

        /* override return values of some oids */

        if (oid == OID_GEN_MAXIMUM_SEND_PACKETS && info_len >= sizeof (ULONG))
        {
            * ((PULONG) info_buf) = CVY_MAX_SEND_PACKETS;
            * written = sizeof (ULONG);
            status = NDIS_STATUS_SUCCESS;
        }
        else if (oid == OID_GEN_MAC_OPTIONS && status == NDIS_STATUS_SUCCESS)
        {
            * ((PULONG) info_buf) |= NDIS_MAC_OPTION_TRANSFERS_NOT_PEND |
                                     NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA;
            * ((PULONG) info_buf) &= ~NDIS_MAC_OPTION_NO_LOOPBACK;
        }
        else if (oid == OID_PNP_CAPABILITIES && status == NDIS_STATUS_SUCCESS)
        {
            PNDIS_PNP_CAPABILITIES          pnp_capabilities;
            PNDIS_PM_WAKE_UP_CAPABILITIES   pm_struct;

            if (info_len >= sizeof (NDIS_PNP_CAPABILITIES))
            {
                pnp_capabilities = (PNDIS_PNP_CAPABILITIES) info_buf;
                pm_struct = & pnp_capabilities -> WakeUpCapabilities;

                pm_struct -> MinMagicPacketWakeUp = NdisDeviceStateUnspecified;
                pm_struct -> MinPatternWakeUp     = NdisDeviceStateUnspecified;
                pm_struct -> MinLinkChangeWakeUp  = NdisDeviceStateUnspecified;

                ctxtp -> prot_pnp_state = NdisDeviceStateD0;
                ctxtp -> nic_pnp_state  = NdisDeviceStateD0;

                * written = sizeof (NDIS_PNP_CAPABILITIES);
                * needed = 0;
                status = NDIS_STATUS_SUCCESS;
            }
            else
            {
                * needed = sizeof (NDIS_PNP_CAPABILITIES);
                status = NDIS_STATUS_RESOURCES;
            }
        }

        Main_action_put (ctxtp, actp);
    }

    return status;

} /* end Nic_info_query */


NDIS_STATUS Nic_info_set (
    NDIS_HANDLE         adapter_handle,
    NDIS_OID            oid,
    PVOID               info_buf,
    ULONG               info_len,
    PULONG              read,
    PULONG              needed)
{
    PMAIN_CTXT          ctxtp = (PMAIN_CTXT) adapter_handle;
    NDIS_STATUS         status;
    PMAIN_ACTION        actp;
    PNDIS_REQUEST       request;
    PMAIN_ADAPTER       adapterp;


    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    adapterp = & (univ_adapters [ctxtp -> adapter_id]);
    UNIV_ASSERT (adapterp -> code == MAIN_ADAPTER_CODE);
    UNIV_ASSERT (adapterp -> ctxtp == ctxtp);

#if defined(TRACE_OID)
    DbgPrint("Nic_info_set: called for %x, %x %d\n", oid, info_buf, info_len);
#endif

    if (! adapterp -> inited)
        return NDIS_STATUS_FAILURE;

    /* the Set Power should not be sent to the miniport below the Passthru,
       but is handled internally */

    if (oid == OID_PNP_SET_POWER)
    {
        NDIS_DEVICE_POWER_STATE new_pnp_state;

#if defined(TRACE_OID)
        DbgPrint("Nic_info_set: OID_PNP_SET_POWER\n");
#endif


        if (info_len >= sizeof (NDIS_DEVICE_POWER_STATE))
        {
            new_pnp_state = (* (PNDIS_DEVICE_POWER_STATE) info_buf);

            /* If WLBS is transitioning from an Off to On state, it must wait
               for all underlying miniports to be turned On */

            if (ctxtp->nic_pnp_state > NdisDeviceStateD0 &&
                new_pnp_state != NdisDeviceStateD0)
            {
                // If the miniport is in a non-D0 state, the miniport can only
                // receive a Set Power to D0

                return NDIS_STATUS_FAILURE;
            }

       		//
    		// Is the miniport transitioning from an On (D0) state to an Low Power State (>D0)
    		// If so, then set the standby_state Flag - (Block all incoming requests)
    		//
    		if (ctxtp->nic_pnp_state == NdisDeviceStateD0 &&
                new_pnp_state > NdisDeviceStateD0)
    		{
    			ctxtp->standby_state = TRUE;
    		}

    		//
    		// If the miniport is transitioning from a low power state to ON (D0), then clear the standby_state flag
    		// All incoming requests will be pended until the physical miniport turns ON.
    		//
    		if (ctxtp->nic_pnp_state > NdisDeviceStateD0 &&
                new_pnp_state == NdisDeviceStateD0)
    		{
    			ctxtp->standby_state = FALSE;
    		}

            ctxtp->nic_pnp_state = new_pnp_state;

            * read   = sizeof (NDIS_DEVICE_POWER_STATE);
            * needed = 0;

            return NDIS_STATUS_SUCCESS;
        }
        else
        {
            * read   = 0;
            * needed = sizeof (NDIS_DEVICE_POWER_STATE);

            return NDIS_STATUS_INVALID_LENGTH;
        }
    }

    if (ctxtp -> reset_state != MAIN_RESET_NONE ||
        ctxtp->nic_pnp_state > NdisDeviceStateD0 ||
        ctxtp->standby_state)
        return NDIS_STATUS_FAILURE;

    actp = Main_action_get (ctxtp);

    if (actp == NULL)
    {
        UNIV_PRINT (("error allocating action"));
        return NDIS_STATUS_FAILURE;
    }

    request = & actp -> op . request . req;

    request -> RequestType = NdisRequestSetInformation;

    request -> DATA . SET_INFORMATION . Oid = oid;

    /* V1.3.0b Multicast support.  If protocol is setting multicast list, make sure we always 
       add our multicast address on at the end.  If the cluster IP address 0.0.0.0, then we don't
       want to add the multicast MAC address to the NIC  - we retain the current MAC address. */
    if (oid == OID_802_3_MULTICAST_LIST && ctxtp -> params . mcast_support && ctxtp -> params . cl_ip_addr != 0)
    {
        ULONG       size, i, len;
        PUCHAR      ptr;


        UNIV_PRINT (("Nic_info_set: OID_802_3_MULTICAST_LIST"));

        /* search and see if our multicast address is alrady in the list */

        len = CVY_MAC_ADDR_LEN (ctxtp -> medium);

        for (i = 0; i < info_len; i += len)
        {
            if (CVY_MAC_ADDR_COMP (ctxtp -> medium, (PUCHAR) info_buf + i, & ctxtp -> cl_mac_addr))
            {
                UNIV_PRINT (("Nic_info_set: cluster MAC matched - no need to add it"));
                CVY_MAC_ADDR_PRINT (ctxtp -> medium, "", & ctxtp -> cl_mac_addr);
                break;
            }
            else
                CVY_MAC_ADDR_PRINT (ctxtp -> medium, "", (PUCHAR) info_buf + i);

        }

        /* if cluster mac not found, add it to the list */

        if (i >= info_len)
        {
            UNIV_PRINT (("Nic_info_set: cluster MAC not found - adding it"));
            CVY_MAC_ADDR_PRINT (ctxtp -> medium, "", & ctxtp -> cl_mac_addr);

            size = info_len + len;
        }
        else
        {
            size = info_len;
        }

        status = NdisAllocateMemoryWithTag (& ptr, size, UNIV_POOL_TAG);

        if (status != NDIS_STATUS_SUCCESS)
        {
            UNIV_PRINT (("error allocating space %d %x", size, status));
            LOG_MSG2 (MSG_ERROR_MEMORY, MSG_NONE, size, status);
            Main_action_put (ctxtp, actp);
            return NDIS_STATUS_FAILURE;
        }

        /* V1.3.1b */

        if (i >= info_len)
        {
            CVY_MAC_ADDR_COPY (ctxtp -> medium, ptr, & ctxtp -> cl_mac_addr);
            NdisMoveMemory (ptr + len, info_buf, info_len);
        }
        else
        {
            NdisMoveMemory (ptr, info_buf, info_len);
        }

        request -> DATA . SET_INFORMATION . InformationBuffer       = ptr;
        request -> DATA . SET_INFORMATION . InformationBufferLength = size;
    }
    else
    {
        request -> DATA . SET_INFORMATION . InformationBuffer       = info_buf;
        request -> DATA . SET_INFORMATION . InformationBufferLength = info_len;
    }

    actp -> op . request . xferred = read;
    actp -> op . request . needed  = needed;

    status = Prot_request (ctxtp, actp, TRUE);

    if (status != NDIS_STATUS_PENDING)
    {
        /* V1.3.0b multicast support - clean up array used for storing list
           of multicast addresses */

        * read   = request -> DATA . SET_INFORMATION . BytesRead;
        * needed = request -> DATA . SET_INFORMATION . BytesNeeded;

        if (request -> DATA . SET_INFORMATION . Oid == OID_802_3_MULTICAST_LIST && ctxtp -> params . mcast_support && ctxtp -> params . cl_ip_addr != 0)
        {
            NdisFreeMemory (request -> DATA . SET_INFORMATION . InformationBuffer,
                            request -> DATA . SET_INFORMATION . InformationBufferLength, 0);
            * read -= CVY_MAC_ADDR_LEN (ctxtp -> medium);
        }

#if defined(TRACE_OID)
        DbgPrint("Nic_info_set: done %x, %d %d\n", status, * read, * needed);
#endif

        Main_action_put (ctxtp, actp);
    }

    return status;

} /* end Nic_info_set */


NDIS_STATUS Nic_reset (
    PBOOLEAN            addr_reset,
    NDIS_HANDLE         adapter_handle)
{
    PMAIN_CTXT          ctxtp = (PMAIN_CTXT) adapter_handle;
    NDIS_STATUS         status;
    PMAIN_ADAPTER       adapterp;


    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    adapterp = & (univ_adapters [ctxtp -> adapter_id]);
    UNIV_ASSERT (adapterp -> code == MAIN_ADAPTER_CODE);

    if (! adapterp -> inited)
        return NDIS_STATUS_FAILURE;

    UNIV_PRINT (("Nic_reset: called"));

    /* since no information needs to be passed to Prot_reset,
       action is not allocated. Prot_reset_complete will get
       one and pass it to Nic_reset_complete */

    status = Prot_reset (ctxtp);

    if (status != NDIS_STATUS_SUCCESS && status != NDIS_STATUS_PENDING)
        UNIV_PRINT (("error resetting adapter %x", status));

    return status;

} /* end Nic_reset */


VOID Nic_cancel_send_packets (
    NDIS_HANDLE         adapter_handle,
    PVOID               cancel_id)
{
    PMAIN_CTXT          ctxtp = (PMAIN_CTXT) adapter_handle;
    PMAIN_ADAPTER       adapterp;


    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    adapterp = & (univ_adapters [ctxtp -> adapter_id]);
    UNIV_ASSERT (adapterp -> code == MAIN_ADAPTER_CODE);

    /* Since no internal queues are maintained,
     * can simply pass the cancel call to the miniport
     */
    Prot_cancel_send_packets (ctxtp, cancel_id);

    return;
} /* Nic_cancel_send_packets */


VOID Nic_pnpevent_notify (
    NDIS_HANDLE              adapter_handle,
    NDIS_DEVICE_PNP_EVENT    pnp_event,
    PVOID                    info_buf,
    ULONG                    info_len)
{
    PMAIN_CTXT          ctxtp = (PMAIN_CTXT) adapter_handle;


    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    return;
} /* Nic_pnpevent_notify */


VOID Nic_adapter_shutdown (
    NDIS_HANDLE         adapter_handle)
{
    PMAIN_CTXT          ctxtp = (PMAIN_CTXT) adapter_handle;


    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    return;
} /* Nic_adapter_shutdown */


/* helpers for protocol layer */


NDIS_STATUS Nic_announce (
    PMAIN_CTXT          ctxtp)
{
    NDIS_STATUS         status;
    NDIS_STRING         nic_name;


    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    /* create the name to expose to TCP/IP protocol and call NDIS to force
       TCP/IP to bind to us */

    NdisInitUnicodeString (& nic_name, ctxtp -> virtual_nic_name);

    UNIV_PRINT (("exposing %ls, %ls", nic_name . Buffer, ctxtp -> virtual_nic_name));

    status = NdisIMInitializeDeviceInstanceEx (univ_driver_handle, & nic_name, (NDIS_HANDLE) ctxtp);

    if (status != NDIS_STATUS_SUCCESS)
    {
        UNIV_PRINT (("error announcing driver %x", status));
        LOG_MSG1 (MSG_ERROR_ANNOUNCE, nic_name . Buffer, status);
    }

    return status;

} /* end Nic_announce */


NDIS_STATUS Nic_unannounce (
    PMAIN_CTXT          ctxtp)
{
    NDIS_STATUS         status;
    NDIS_STRING         nic_name;
    PMAIN_ADAPTER       adapterp;


    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    adapterp = & (univ_adapters [ctxtp -> adapter_id]);
    UNIV_ASSERT (adapterp -> code == MAIN_ADAPTER_CODE);
    UNIV_ASSERT (adapterp -> ctxtp == ctxtp);
UNIV_PRINT(("Nic_unannounce called"));
    NdisAcquireSpinLock(& univ_bind_lock);

    if (! adapterp -> announced || ctxtp -> prot_handle == NULL)
    {
        adapterp -> announced = FALSE;
        ctxtp->prot_handle = NULL;
        NdisReleaseSpinLock(& univ_bind_lock);

        NdisInitUnicodeString (& nic_name, ctxtp -> virtual_nic_name);

        UNIV_PRINT (("cancelling %ls, %ls", nic_name . Buffer, ctxtp -> virtual_nic_name));

        status = NdisIMCancelInitializeDeviceInstance (univ_driver_handle, & nic_name);

        if (status != NDIS_STATUS_SUCCESS)
        {
            UNIV_PRINT (("error cancelling driver %x", status));
            LOG_MSG1 (MSG_ERROR_ANNOUNCE, nic_name . Buffer, status);
        }

        return NDIS_STATUS_SUCCESS;
    }

    NdisReleaseSpinLock(& univ_bind_lock);

UNIV_PRINT(("calling DeinitializeDeviceInstance"));
    status = NdisIMDeInitializeDeviceInstance (ctxtp -> prot_handle);

    return status;

} /* end Nic_unannounce */

#if 0
ULONG   Nic_sync_queue (
    PMAIN_CTXT          ctxtp,
    UNIV_SYNC_CALLB     callb,
    PVOID               callb_ctxtp,
    ULONG               queue)
{
    NDIS_STATUS         status;
    NDIS_HANDLE         switch_handle;
    ULONG               switched;
    ULONG               i;
    PMAIN_ACTION        actp = (PMAIN_ACTION) callb_ctxtp;


    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    if (ctxtp -> prot_handle == NULL)
        return FALSE;

    (* callb) (ctxtp -> prot_handle, callb_ctxtp);
    return TRUE;

    /* generic wrapper for all up-calls that require us flipping to miniport
       mode */

    /* V1.1.2 attempt to switch to miniport mode now. if succeeded - call
       the necessary handler and flip back */

    /* V2.1.7b NT5 - if we bind to the NIC before actually being bound to
       TCP/IP, then do not pass anything up. */

    if (ctxtp -> prot_handle == NULL)
        return FALSE;

    switched = NdisIMSwitchToMiniport (ctxtp -> prot_handle, & switch_handle);

    if (switched)
    {
        (* callb) (ctxtp -> prot_handle, callb_ctxtp);
        NdisIMRevertBack (ctxtp -> prot_handle, switch_handle);
        return TRUE;
    }

    /* 1.2.1 if queuing is not desired - get out */

    if (! queue && ! switched)
        return FALSE;

    /* attempt to queue the callback for later time */

    i = 0;

    while (i < CVY_MAX_CALLB_QUEUE_RETRIES)
    {
        status = NdisIMQueueMiniportCallback (ctxtp -> prot_handle, callb,
                                              callb_ctxtp);

        if (status == NDIS_STATUS_SUCCESS || status == NDIS_STATUS_PENDING)
            break;

        UNIV_PRINT (("error queueing miniport callback %x", status));
        i ++;
    }

    /* V1.1.2 make sure we log the message if we could not flip */

    if (i < CVY_MAX_CALLB_QUEUE_RETRIES)
        return TRUE;

    if (! ctxtp -> sync_warned)
    {
        LOG_MSG1 (MSG_ERROR_MEMORY, MSG_NONE, status);
        ctxtp -> sync_warned = TRUE;
    }

    /* cannot queue for retry if we were passed context instead of an action */

    if (callb_ctxtp == ctxtp)
        return FALSE;

    /* insert action onto a recovery queue for attempted completion later, in
       the context of Nic_timer */

    UNIV_ASSERT (actp -> code == MAIN_ACTION_CODE);

    actp->callb = callb;

    NdisAcquireSpinLock (& ctxtp -> sync_lock);
    InsertTailList (& ctxtp -> sync_list [ctxtp -> cur_sync_list], & actp -> link);
    ctxtp -> num_sync_queued ++;
    NdisReleaseSpinLock (& ctxtp -> sync_lock);

    return FALSE;

} /* end Nic_sync_queue */
#endif

/* routines that can be used with Nic_sync */


VOID Nic_request_complete (
    NDIS_HANDLE         handle,
    PVOID               cookie)
{
    PMAIN_ACTION        actp    = (PMAIN_ACTION) cookie;
    PMAIN_CTXT          ctxtp   = actp -> ctxtp;
    NDIS_STATUS         status  = actp -> status;
    PNDIS_REQUEST       request = & actp -> op . request . req;
    PULONG              ptr;
    ULONG               oid;


    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    if (status != NDIS_STATUS_SUCCESS)
        UNIV_PRINT (("error requesting adapter %x", status));

    if (request -> RequestType == NdisRequestSetInformation)
    {
        UNIV_ASSERT (request -> DATA . SET_INFORMATION . Oid != OID_PNP_SET_POWER);

        * actp -> op . request . xferred =
                            request -> DATA . SET_INFORMATION . BytesRead;
        * actp -> op . request . needed  =
                            request -> DATA . SET_INFORMATION . BytesNeeded;

#if defined(TRACE_OID)
        DbgPrint("Nic_request_complete: set done %x, %d %d\n", status, * actp -> op . request . xferred, * actp -> op . request . needed);
#endif

        /* V1.3.0b multicast support - free multicast list array */

        if (request -> DATA . SET_INFORMATION . Oid == OID_802_3_MULTICAST_LIST && ctxtp -> params . mcast_support && ctxtp -> params . cl_ip_addr != 0)
        {
            NdisFreeMemory (request -> DATA . SET_INFORMATION . InformationBuffer,
                            request -> DATA . SET_INFORMATION . InformationBufferLength, 0);
            * actp -> op . request . xferred -= CVY_MAC_ADDR_LEN (ctxtp -> medium);
        }

        NdisMSetInformationComplete (ctxtp -> prot_handle, status);
    }
    else if (request -> RequestType == NdisRequestQueryInformation)
    {
        * actp -> op . request . xferred =
                        request -> DATA . QUERY_INFORMATION . BytesWritten;
        * actp -> op . request . needed  =
                        request -> DATA . QUERY_INFORMATION . BytesNeeded;

#if defined(TRACE_OID)
        DbgPrint("Nic_request_complete: query done %x, %d %d\n", status, * actp -> op . request . xferred, * actp -> op . request . needed);
#endif

        oid = request -> DATA . QUERY_INFORMATION . Oid;
        ptr = ((PULONG) request -> DATA . QUERY_INFORMATION . InformationBuffer);

        /* override certain oid values with our own */

        if (oid == OID_GEN_MAXIMUM_SEND_PACKETS &&
            request -> DATA . QUERY_INFORMATION . InformationBufferLength >=
            sizeof (ULONG))
        {
            * ptr = CVY_MAX_SEND_PACKETS;
            * actp -> op . request . xferred = sizeof (ULONG);
            status = NDIS_STATUS_SUCCESS;
        }
        else if (oid == OID_GEN_MAC_OPTIONS && status == NDIS_STATUS_SUCCESS)
        {
            * ptr |= NDIS_MAC_OPTION_TRANSFERS_NOT_PEND |
                     NDIS_MAC_OPTION_COPY_LOOKAHEAD_DATA;
            * ptr &= ~NDIS_MAC_OPTION_NO_LOOPBACK;
        }
        else if (oid == OID_PNP_CAPABILITIES && status == NDIS_STATUS_SUCCESS)
        {
            PNDIS_PNP_CAPABILITIES          pnp_capabilities;
            PNDIS_PM_WAKE_UP_CAPABILITIES   pm_struct;

            if (request -> DATA . QUERY_INFORMATION . InformationBufferLength >=
                sizeof (NDIS_PNP_CAPABILITIES))
            {
                pnp_capabilities = (PNDIS_PNP_CAPABILITIES) ptr;
                pm_struct = & pnp_capabilities -> WakeUpCapabilities;

                pm_struct -> MinMagicPacketWakeUp = NdisDeviceStateUnspecified;
                pm_struct -> MinPatternWakeUp     = NdisDeviceStateUnspecified;
                pm_struct -> MinLinkChangeWakeUp  = NdisDeviceStateUnspecified;

                ctxtp -> prot_pnp_state = NdisDeviceStateD0;
                ctxtp -> nic_pnp_state  = NdisDeviceStateD0;

                * actp -> op . request . xferred = sizeof (NDIS_PNP_CAPABILITIES);
                * actp -> op . request . needed  = 0;
                status = NDIS_STATUS_SUCCESS;
            }
            else
            {
                * actp -> op . request . needed = sizeof (NDIS_PNP_CAPABILITIES);
                status = NDIS_STATUS_RESOURCES;
            }
        }

        NdisMQueryInformationComplete (ctxtp -> prot_handle, status);
    }
    else
        UNIV_PRINT (("strange request completion %x\n", request -> RequestType));

    Main_action_put (ctxtp, actp);

} /* end Nic_request_complete */


VOID Nic_reset_complete (
    PMAIN_CTXT          ctxtp,
    NDIS_STATUS         status)
{
//    PMAIN_ACTION        actp   = (PMAIN_ACTION) cookie;
//    PMAIN_CTXT          ctxtp  = actp -> ctxtp;
//    NDIS_STATUS         status = actp -> status;


    if (status != NDIS_STATUS_SUCCESS)
        UNIV_PRINT (("error resetting adapter %x", status));

    NdisMResetComplete (ctxtp -> prot_handle, status, TRUE);
//    Main_action_put (ctxtp, actp);

} /* end Nic_reset_complete */


VOID Nic_send_complete (
    PMAIN_CTXT          ctxtp,
    NDIS_STATUS         status,
    PNDIS_PACKET        packet)
{
//    PMAIN_ACTION        actp   = (PMAIN_ACTION) cookie;
//    PMAIN_CTXT          ctxtp  = actp -> ctxtp;
//    NDIS_STATUS         status = actp -> status;
//    PNDIS_PACKET        packet = actp -> op . send . packet;


    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    if (status != NDIS_STATUS_SUCCESS)
        UNIV_PRINT (("error sending to adapter %x", status));

//    ctxtp -> sends_completed ++;
    NdisMSendComplete (ctxtp -> prot_handle, packet, status);
//    Main_action_put (ctxtp, actp);

} /* end Nic_send_complete */


VOID Nic_recv_complete (    /* PASSIVE_IRQL */
    PMAIN_CTXT          ctxtp)
{


    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    if (ctxtp -> medium == NdisMedium802_3)
    {
        NdisMEthIndicateReceiveComplete (ctxtp -> prot_handle);
    }

} /* end Nic_recv_complete */


VOID Nic_send_resources_signal (
    PMAIN_CTXT          ctxtp)
{
//    PMAIN_CTXT          ctxtp  = (PMAIN_CTXT) cookie;

    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    UNIV_PRINT (("signalling send resources available"));
    NdisMSendResourcesAvailable (ctxtp -> prot_handle);

} /* end Nic_send_resources_signal */


NDIS_STATUS Nic_PNP_handle (
    PMAIN_CTXT          ctxtp,
    PNET_PNP_EVENT      pnp_event)
{
    NDIS_STATUS         status;


    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    if (ctxtp -> prot_handle != NULL)
    {
        status = NdisIMNotifyPnPEvent (ctxtp -> prot_handle, pnp_event);
    }
    else
    {
        status = NDIS_STATUS_SUCCESS;
    }

    UNIV_PRINT (("NdisIMNotifyPnPEvent: status 0x%x", status));

    return status;
}


VOID Nic_status (
    PMAIN_CTXT          ctxtp,
    NDIS_STATUS         status,
    PVOID               buf,
    UINT                len)
{
//    PMAIN_ACTION        actp   = (PMAIN_ACTION) cookie;
//    PMAIN_CTXT          ctxtp  = actp -> ctxtp;
//    NDIS_STATUS         status = actp -> status;


    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    UNIV_PRINT (("status indicated %x", status));

    NdisMIndicateStatus (ctxtp -> prot_handle, status, buf, len);

//    Main_action_put (ctxtp, actp);

} /* end Nic_status */


VOID Nic_status_complete (
    PMAIN_CTXT          ctxtp)
{
//    PMAIN_ACTION        actp   = (PMAIN_ACTION) cookie;
//    PMAIN_CTXT          ctxtp  = actp -> ctxtp;


    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    NdisMIndicateStatusComplete (ctxtp -> prot_handle);

//    Main_action_put (ctxtp, actp);

} /* end Nic_status_complete */



VOID Nic_packets_send (
    NDIS_HANDLE         adapter_handle,
    PPNDIS_PACKET       packets,
    UINT                num_packets)
{
    PMAIN_CTXT          ctxtp = (PMAIN_CTXT) adapter_handle;
    NDIS_STATUS         status;
    PMAIN_ADAPTER       adapterp;

    /* V1.1.4 */

    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    adapterp = & (univ_adapters [ctxtp -> adapter_id]);
    UNIV_ASSERT (adapterp -> code == MAIN_ADAPTER_CODE);
    UNIV_ASSERT (adapterp -> ctxtp == ctxtp);

    if (! adapterp -> inited)
    {
//        ctxtp -> uninited_return += num_packets;
        return;
    }

//    ctxtp -> sends_in ++;

    Prot_packets_send (ctxtp, packets, num_packets);

} /* end Nic_packets_send */


VOID Nic_return (
    NDIS_HANDLE         adapter_handle,
    PNDIS_PACKET        packet)
{
    PMAIN_CTXT          ctxtp = (PMAIN_CTXT) adapter_handle;
    PMAIN_ADAPTER       adapterp;


    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    adapterp = & (univ_adapters [ctxtp -> adapter_id]);
    UNIV_ASSERT (adapterp -> code == MAIN_ADAPTER_CODE);
    UNIV_ASSERT (adapterp -> ctxtp == ctxtp);
#if 0 /* The adapter context is not required for Nic_return. Main_cleanup will wait
       * for all the packets to be returned before cleaning up the packet pools.
       */
    if (! adapterp -> inited)
        return;
#endif

    Prot_return (ctxtp, packet);

} /* end Nic_return */


/* would be called by Prot_packet_recv */

VOID Nic_recv_packet (
    PMAIN_CTXT          ctxtp,
    PNDIS_PACKET        packet)
{
    NDIS_STATUS         status;


    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    status = NDIS_GET_PACKET_STATUS (packet);
    NdisMIndicateReceivePacket (ctxtp -> prot_handle, & packet, 1);

    if (status == NDIS_STATUS_RESOURCES)
        Prot_return (ctxtp, packet);

} /* end Nic_recv_packet */


VOID Nic_timer (
    PVOID                   dpc,
    PVOID                   cp,
    PVOID                   arg1,
    PVOID                   arg2)
{
    PMAIN_CTXT              ctxtp = cp;
    ULONG                   tout;
    PLIST_ENTRY             entryp;
    PMAIN_ACTION            actp;
    ULONG                   wrk_list;
    ULONG                   empty;
    PMAIN_ADAPTER           adapterp;


    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    adapterp = & (univ_adapters [ctxtp -> adapter_id]);
    UNIV_ASSERT (adapterp -> code == MAIN_ADAPTER_CODE);
    UNIV_ASSERT (adapterp -> ctxtp == ctxtp);

    if (! adapterp -> inited)
        return;
#if 0
    wrk_list = ctxtp -> cur_sync_list;
    NdisAcquireSpinLock (& ctxtp -> sync_lock);
    ctxtp -> cur_sync_list = (ctxtp -> cur_sync_list ? 0 : 1);
    empty = IsListEmpty (& ctxtp -> sync_list [wrk_list]);
    NdisReleaseSpinLock (& ctxtp -> sync_lock);

    /* attempt to process queued-up actions for completion */

    while (! empty)
    {
        NdisAcquireSpinLock (& ctxtp -> sync_lock);
        entryp = RemoveHeadList (& ctxtp -> sync_list [wrk_list]);

        /* if list empty - nothing to do */

        if (entryp == & ctxtp -> sync_list [wrk_list])
        {
            NdisReleaseSpinLock (& ctxtp -> sync_lock);
            break;
        }

        ctxtp->num_sync_queued --;
        NdisReleaseSpinLock (& ctxtp -> sync_lock);

        actp = CONTAINING_RECORD (entryp, MAIN_ACTION, link);
        UNIV_ASSERT (actp -> code == MAIN_ACTION_CODE);

        /* attempt to complete the action again. if it fails again, Nic_sync_queue
           will queue the action on to the current sync list for retry later. */

        Nic_sync_queue(ctxtp, actp->callb, actp, TRUE);
    }
#endif
    /* figure out next delay */

    tout = ctxtp -> curr_tout;

    /* handle the heartbeat */

    Main_ping (ctxtp, & tout);

    /* set new delay value if it was changed */

    if (tout != ctxtp -> curr_tout)
    {
        ctxtp -> curr_tout = tout;
        NdisMSetPeriodicTimer ((PNDIS_MINIPORT_TIMER) ctxtp -> timer, tout);
    }

} /* end Nic_timer */


VOID Nic_sleep (
    ULONG                   msecs)
{
    NdisMSleep(msecs);

} /* end Nic_sleep */


/* Added from old code for NT 5.1 - ramkrish */
VOID Nic_recv_indicate (
    PMAIN_CTXT          ctxtp,
    NDIS_HANDLE         recv_handle,
    PVOID               head_buf,
    UINT                head_len,
    PVOID               look_buf,
    UINT                look_len,
    UINT                packet_len)
{
//    PMAIN_ACTION        actp   = (PMAIN_ACTION) cookie;
//    PMAIN_CTXT          ctxtp  = actp -> ctxtp;


    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    /* V1.1.2 do not accept frames if the card below is resetting */

    if (ctxtp -> reset_state != MAIN_RESET_NONE)
        return;

    if (ctxtp -> medium == NdisMedium802_3)
    {
        NdisMEthIndicateReceive (ctxtp -> prot_handle,
                                 recv_handle,
                                 head_buf,
                                 head_len,
                                 look_buf,
                                 look_len,
                                 packet_len);
    }

//    Main_action_put (ctxtp, actp);

} /* end Nic_recv_indicate */


NDIS_STATUS Nic_transfer (
    PNDIS_PACKET        packet,
    PUINT               xferred,
    NDIS_HANDLE         adapter_handle,
    NDIS_HANDLE         receive_handle,
    UINT                offset,
    UINT                len)
{
    PMAIN_CTXT          ctxtp = (PMAIN_CTXT) adapter_handle;
    NDIS_STATUS         status;


    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    status = Prot_transfer (ctxtp, receive_handle, packet, offset, len, xferred);

    if (status != NDIS_STATUS_PENDING && status != NDIS_STATUS_SUCCESS)
        UNIV_PRINT (("error transferring from adapter %x", status));

    return status;

} /* end Nic_transfer */


VOID Nic_transfer_complete (
    PMAIN_CTXT          ctxtp,
    NDIS_STATUS         status,
    PNDIS_PACKET        packet,
    UINT                xferred)
{
//    PMAIN_ACTION        actp   = (PMAIN_ACTION) cookie;
//    PMAIN_CTXT          ctxtp  = actp -> ctxtp;
//    NDIS_STATUS         status = actp -> status;


    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    if (status != NDIS_STATUS_SUCCESS)
        UNIV_PRINT (("error transferring from adapter %x", status));

    NdisMTransferDataComplete (ctxtp -> prot_handle, packet, status, xferred);

//    Main_action_put (ctxtp, actp);

} /* end Nic_transfer_complete */


/* old code */

#if 0
NDIS_STATUS Nic_send (
    NDIS_HANDLE         adapter_handle,
    PNDIS_PACKET        packet,
    UINT                flags)
{
    PMAIN_CTXT          ctxtp = (PMAIN_CTXT) adapter_handle;
    NDIS_STATUS         status;


    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    status = Prot_send (ctxtp, packet, flags);

    if (status != NDIS_STATUS_PENDING && status != NDIS_STATUS_SUCCESS)
        UNIV_PRINT (("error sending to adapter %x", status));

    return status;

} /* end Nic_send */
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\driver\params.c ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    params.c

Abstract:

    Windows Load Balancing Service (WLBS)
    Driver - registry parameter support

Author:

    kyrilf

--*/

#include <ntddk.h>
#include <string.h>

#include "wlbsparm.h"
#include "params.h"
#include "univ.h"
#include "log.h"
#include "main.h"

/* To create registry path strings for the new port rule structure in the registry. */
extern int swprintf(wchar_t * buffer, const wchar_t * format,...);

/* CONSTANTS */


#define PARAMS_INFO_BUF_SIZE    ((CVY_MAX_PARAM_STR + 1) * sizeof (WCHAR) + \
                                  CVY_MAX_RULES * sizeof (CVY_RULE) + \
                                  sizeof (KEY_VALUE_PARTIAL_INFORMATION) + 4)

/* The maximum length of a registry path string, in characters (WCHAR). */
#define CVY_MAX_REG_PATH        512

/* GLOBALS */


static ULONG log_module_id = LOG_MODULE_PARAMS;


static UCHAR            infop [PARAMS_INFO_BUF_SIZE];


/* PROCEDURES */

/* return codes from Params_verify call */
/* in user mode returns object ID of the dialog control that needs to be fixed */

#define CVY_VERIFY_OK           0
#define CVY_VERIFY_EXIT         1

ULONG Params_verify (
    PVOID           nlbctxt,
    PCVY_PARAMS     paramp,
    BOOL            complain)
{
    ULONG           j, i, code;
    PCVY_RULE       rp, rulep;
    PSTR            prot;
    PCHAR           aff;
    ULONG           ret;
    ANSI_STRING     domain, key, ip;
    PMAIN_CTXT      ctxtp = (PMAIN_CTXT)nlbctxt;

    /* ensure sane values for all parameters */

    CVY_CHECK_MIN (paramp -> alive_period, CVY_MIN_ALIVE_PERIOD);
    CVY_CHECK_MAX (paramp -> alive_period, CVY_MAX_ALIVE_PERIOD);

    CVY_CHECK_MIN (paramp -> alive_tolerance, CVY_MIN_ALIVE_TOLER);
    CVY_CHECK_MAX (paramp -> alive_tolerance, CVY_MAX_ALIVE_TOLER);

    CVY_CHECK_MIN (paramp -> num_actions, CVY_MIN_NUM_ACTIONS);
    CVY_CHECK_MAX (paramp -> num_actions, CVY_MAX_NUM_ACTIONS);

    CVY_CHECK_MIN (paramp -> num_packets, CVY_MIN_NUM_PACKETS);
    CVY_CHECK_MAX (paramp -> num_packets, CVY_MAX_NUM_PACKETS);

    CVY_CHECK_MIN (paramp -> dscr_per_alloc, CVY_MIN_DSCR_PER_ALLOC);
    CVY_CHECK_MAX (paramp -> dscr_per_alloc, CVY_MAX_DSCR_PER_ALLOC);

    CVY_CHECK_MIN (paramp -> max_dscr_allocs, CVY_MIN_MAX_DSCR_ALLOCS);
    CVY_CHECK_MAX (paramp -> max_dscr_allocs, CVY_MAX_MAX_DSCR_ALLOCS);

    CVY_CHECK_MAX (paramp -> cleanup_delay, CVY_MAX_CLEANUP_DELAY);

    CVY_CHECK_MAX (paramp -> ip_chg_delay, CVY_MAX_IP_CHG_DELAY);

    CVY_CHECK_MIN (paramp -> num_send_msgs, (CVY_MAX_HOSTS + 1) * 2);
    CVY_CHECK_MAX (paramp -> num_send_msgs, (CVY_MAX_HOSTS + 1) * 10);

    /* verify that parameters are correct */

    if (paramp -> parms_ver != CVY_PARAMS_VERSION)
    {
        UNIV_PRINT (("bad parameters version %d, expected %d", paramp -> parms_ver, CVY_PARAMS_VERSION));
        LOG_MSG (MSG_WARN_VERSION, MSG_NONE);
        return CVY_VERIFY_EXIT;
    }

    if (paramp -> rct_port < CVY_MIN_RCT_PORT ||
        paramp -> rct_port > CVY_MAX_RCT_PORT)
    {
        UNIV_PRINT (("bad value for parameter %s, %d <= %d <= %d", CVY_NAME_NUM_RULES, CVY_MIN_CLEANUP_DELAY, paramp -> cleanup_delay, CVY_MAX_CLEANUP_DELAY));
        return CVY_VERIFY_EXIT;
    }

    if (paramp -> host_priority < CVY_MIN_HOST_PRIORITY ||
        paramp -> host_priority > CVY_MAX_HOSTS)
    {
        UNIV_PRINT (("bad value for parameter %s, %d <= %d <= %d", CVY_NAME_HOST_PRIORITY, CVY_MIN_HOST_PRIORITY, paramp -> host_priority, CVY_MAX_HOSTS));
        return CVY_VERIFY_EXIT;
    }

    if (paramp -> num_rules > CVY_MAX_NUM_RULES)
    {
        UNIV_PRINT (("bad value for parameter %s, %d <= %d <= %d", CVY_NAME_NUM_RULES, CVY_MIN_NUM_RULES, paramp -> num_rules, CVY_MAX_NUM_RULES));
        return CVY_VERIFY_EXIT;
    }

    if (paramp -> num_rules > CVY_MAX_USABLE_RULES)
    {
        UNIV_PRINT (("bad value for parameter %s, %d <= %d <= %d", CVY_NAME_NUM_RULES, CVY_MIN_NUM_RULES, paramp -> num_rules, CVY_MAX_USABLE_RULES));
        LOG_MSG2 (MSG_WARN_TOO_MANY_RULES, MSG_NONE, paramp -> num_rules, CVY_MAX_USABLE_RULES);
        paramp -> num_rules = CVY_MAX_USABLE_RULES;
    }

    CVY_CHECK_MAX (paramp -> num_rules, CVY_MAX_NUM_RULES);

    CVY_CHECK_MIN (paramp -> host_priority, CVY_MIN_HOST_PRIORITY);
    CVY_CHECK_MAX (paramp -> host_priority, CVY_MAX_HOST_PRIORITY);

#ifdef TRACE_PARAMS
    DbgPrint ("Parameter: %-25ls = %d\n",  CVY_NAME_HOST_PRIORITY, paramp -> host_priority);
    DbgPrint ("Parameter: %-25ls = %ls\n", CVY_NAME_DED_IP_ADDR,   paramp -> ded_ip_addr);
    DbgPrint ("Parameter: %-25ls = %ls\n", CVY_NAME_DED_NET_MASK,  paramp -> ded_net_mask);
    DbgPrint ("Parameter: %-25ls = %ls\n", CVY_NAME_NETWORK_ADDR,  paramp -> cl_mac_addr);
    DbgPrint ("Parameter: %-25ls = %ls\n", CVY_NAME_CL_IP_ADDR,    paramp -> cl_ip_addr);
    DbgPrint ("Parameter: %-25ls = %ls\n", CVY_NAME_CL_NET_MASK,   paramp -> cl_net_mask);
    DbgPrint ("Parameter: %-25ls = %ls\n", CVY_NAME_DOMAIN_NAME,   paramp -> domain_name);
    DbgPrint ("Parameter: %-25ls = %ls\n", CVY_NAME_MCAST_IP_ADDR, paramp -> cl_igmp_addr);
    DbgPrint ("Parameter: %-25ls = %d\n",  CVY_NAME_ALIVE_PERIOD,  paramp -> alive_period);
    DbgPrint ("Parameter: %-25ls = %d\n",  CVY_NAME_ALIVE_TOLER,   paramp -> alive_tolerance);
    DbgPrint ("Parameter: %-25ls = %d\n",  CVY_NAME_NUM_ACTIONS,   paramp -> num_actions);
    DbgPrint ("Parameter: %-25ls = %d\n",  CVY_NAME_NUM_PACKETS,   paramp -> num_packets);
    DbgPrint ("Parameter: %-25ls = %d\n",  CVY_NAME_NUM_SEND_MSGS, paramp -> num_send_msgs);
    DbgPrint ("Parameter: %-25ls = %x\n",  CVY_NAME_INSTALL_DATE,  paramp -> install_date);
    DbgPrint ("Parameter: %-25ls = %x\n",  CVY_NAME_RMT_PASSWORD,  paramp -> rmt_password);
    DbgPrint ("Parameter: %-25ls = %x\n",  CVY_NAME_RCT_PASSWORD,  paramp -> rct_password);
    DbgPrint ("Parameter: %-25ls = %d\n",  CVY_NAME_RCT_PORT,      paramp -> rct_port);
    DbgPrint ("Parameter: %-25ls = %d\n",  CVY_NAME_RCT_ENABLED,   paramp -> rct_enabled);
    DbgPrint ("Parameter: %-25ls = %d\n",  CVY_NAME_NUM_RULES,     paramp -> num_rules);
    DbgPrint ("Parameter: %-25ls = %d\n",  CVY_NAME_DSCR_PER_ALLOC,paramp -> dscr_per_alloc);
    DbgPrint ("Parameter: %-25ls = %d\n",  CVY_NAME_MAX_DSCR_ALLOCS, paramp -> max_dscr_allocs);
    DbgPrint ("Parameter: %-25ls = %d\n",  CVY_NAME_SCALE_CLIENT,  paramp -> scale_client);
    DbgPrint ("Parameter: %-25ls = %d\n",  CVY_NAME_CLEANUP_DELAY, paramp -> cleanup_delay);
    DbgPrint ("Parameter: %-25ls = %d\n",  CVY_NAME_NBT_SUPPORT,   paramp -> nbt_support);
    DbgPrint ("Parameter: %-25ls = %d\n",  CVY_NAME_MCAST_SUPPORT, paramp -> mcast_support);
    DbgPrint ("Parameter: %-25ls = %d\n",  CVY_NAME_MCAST_SPOOF,   paramp -> mcast_spoof);
    DbgPrint ("Parameter: %-25ls = %d\n",  CVY_NAME_IGMP_SUPPORT, paramp -> igmp_support);
    DbgPrint ("Parameter: %-25ls = %d\n",  CVY_NAME_MASK_SRC_MAC,  paramp -> mask_src_mac);
    DbgPrint ("Parameter: %-25ls = %d\n",  CVY_NAME_NETMON_ALIVE,  paramp -> netmon_alive);
    DbgPrint ("Parameter: %-25ls = %d\n",  CVY_NAME_IP_CHG_DELAY,  paramp -> ip_chg_delay);
    DbgPrint ("Parameter: %-25ls = %d\n",  CVY_NAME_CONVERT_MAC,   paramp -> convert_mac);

    DbgPrint ("\n");
    DbgPrint ("Bi-directional affinity teaming:\n");
    DbgPrint ("Active:       %ls\n", (paramp->bda_teaming.active) ? L"Yes" : L"No");
    DbgPrint ("Team ID:      %ls\n", (paramp->bda_teaming.team_id));
    DbgPrint ("Master:       %ls\n", (paramp->bda_teaming.master) ? L"Yes" : L"No");
    DbgPrint ("Reverse hash: %ls\n", (paramp->bda_teaming.reverse_hash) ? L"Yes" : L"No");
    DbgPrint ("\n");

    /* If teaming is active, check some required configuration. */
    if (paramp->bda_teaming.active) {
        /* If there is no team ID, bail out.  User-level stuff should ensure 
           that it is a GUID.  We'll just check for an empty string here. */
        if (paramp->bda_teaming.team_id[0] == L'\0') {
            DbgPrint("BDA Teaming: Invalid Team ID (Empty)\n");
            LOG_MSG (MSG_ERROR_BDA_PARAMS_TEAM_ID, MSG_NONE);
            paramp->bda_teaming.active = FALSE;
            return CVY_VERIFY_EXIT;
        }

        /* If there is more than one port rule, bail out.  None is fine. */
        if (paramp->num_rules > 1) {
            DbgPrint("BDA Teaming: Invalid number of port rules specified (%d)\n", paramp->num_rules);
            LOG_MSG (MSG_ERROR_BDA_PARAMS_PORT_RULES, MSG_NONE);
            paramp->bda_teaming.active = FALSE;
            return CVY_VERIFY_EXIT;
        }

        /* Since we are asserting that there are only 0 or 1 rules, we know that the only rule we need 
           to check (if there even is a rule), is at the beginning of the array, so we can simply set 
           a pointer to the beginning of the port rules array in the params structure. */
        rp = paramp->port_rules;

        /* If there is one rule and its multiple host filtering, the affinity must be single
           or class C.  If its not (that is, if its set to no affinity), bail out. */
        if ((paramp->num_rules == 1) && (rp->mode == CVY_MULTI)  && (rp->mode_data.multi.affinity == CVY_AFFINITY_NONE)) {
            DbgPrint("BDA Teaming: Invalid affinity for multiple host filtering (None)\n");
            LOG_MSG (MSG_ERROR_BDA_PARAMS_PORT_RULES, MSG_NONE);
            paramp->bda_teaming.active = FALSE;
            return CVY_VERIFY_EXIT;
        }
    }

    DbgPrint ("Rules:\n");

    for (i = 0; i < paramp -> num_rules * sizeof (CVY_RULE) / sizeof (ULONG); i ++)
    {
        if (i != 0 && i % 9 == 0)
            DbgPrint ("\n");

        DbgPrint ("%08X ", * ((PULONG) paramp -> port_rules + i));
    }

    DbgPrint ("\n   VIP   Start  End  Prot   Mode   Pri Load Affinity\n");
#endif

    for (i = 0; i < paramp -> num_rules; i ++)
    {
        rp = paramp -> port_rules + i;

        code = CVY_DRIVER_RULE_CODE_GET (rp);

        CVY_DRIVER_RULE_CODE_SET (rp);

        if (code != CVY_DRIVER_RULE_CODE_GET (rp))
        {
            UNIV_PRINT (("bad rule code: %x vs %x", code, rp -> code));
            return CVY_VERIFY_EXIT;
        }

        if (rp -> start_port > CVY_MAX_PORT)
        {
            UNIV_PRINT (("bad value for rule parameter %s, %d <= %d <= %d", "StartPort", CVY_MIN_PORT, rp -> start_port, CVY_MAX_PORT));
            return CVY_VERIFY_EXIT;
        }

        if (rp -> end_port > CVY_MAX_PORT)
        {
            UNIV_PRINT (("bad value for rule parameter %s, %d <= %d <= %d", "EndPort", CVY_MIN_PORT, rp -> end_port, CVY_MAX_PORT));
            return CVY_VERIFY_EXIT;
        }

        if (rp -> protocol < CVY_MIN_PROTOCOL ||
            rp -> protocol > CVY_MAX_PROTOCOL)
        {
            UNIV_PRINT (("bad value for rule parameter %s, %d <= %d <= %d", "Protocol", CVY_MIN_PROTOCOL, rp -> protocol, CVY_MAX_PROTOCOL));
            return CVY_VERIFY_EXIT;
        }

        if (rp -> mode < CVY_MIN_MODE ||
            rp -> mode > CVY_MAX_MODE)
        {
            UNIV_PRINT (("bad value for parameter %s, %d <= %d <= %d", "Mode", CVY_MIN_MODE, rp -> mode, CVY_MAX_MODE));
            return CVY_VERIFY_EXIT;
        }

#ifdef TRACE_PARAMS
        switch (rp -> protocol)
        {
            case CVY_TCP:
                prot = "TCP";
                break;

            case CVY_UDP:
                prot = "UDP";
                break;

            default:
                prot = "Both";
                break;
        }

        DbgPrint ("%08x %5d %5d %4s ", rp -> virtual_ip_addr, rp -> start_port, rp -> end_port, prot);
#endif

        switch (rp -> mode)
        {
            case CVY_SINGLE:

                if (rp -> mode_data . single . priority < CVY_MIN_PRIORITY ||
                    rp -> mode_data . single . priority > CVY_MAX_PRIORITY)
                {
                    UNIV_PRINT (("bad value for parameter %s, %d <= %d <= %d", "Priority", CVY_MIN_PRIORITY, rp -> mode_data . single . priority, CVY_MAX_PRIORITY));
                    return CVY_VERIFY_EXIT;
                }

#ifdef TRACE_PARAMS
                DbgPrint ("%8s %3d\n", "Single", rp -> mode_data . single . priority);
#endif
                break;

            case CVY_MULTI:

                if (rp -> mode_data . multi . affinity < CVY_MIN_AFFINITY ||
                    rp -> mode_data . multi . affinity > CVY_MAX_AFFINITY)
                {
                    UNIV_PRINT (("bad value for parameter %s, %d <= %d <= %d", "Affinity", CVY_MIN_AFFINITY, rp -> mode_data.multi.affinity, CVY_MAX_AFFINITY));
                    return CVY_VERIFY_EXIT;
                }

                if (rp -> mode_data . multi . affinity == CVY_AFFINITY_NONE)
                    aff = "None";
                else if (rp -> mode_data . multi . affinity == CVY_AFFINITY_SINGLE)
                    aff = "Single";
                else
                    aff = "Class C";

                if (rp -> mode_data . multi . equal_load)
                {
#ifdef TRACE_PARAMS
                    DbgPrint ("%8s %3s %4s %s\n", "Multiple", "", "Eql", aff);
#endif
                }
                else
                {
                    if (rp -> mode_data . multi . load > CVY_MAX_LOAD)
                    {
                        UNIV_PRINT (("bad value for parameter %s, %d <= %d <= %d", "Load", CVY_MIN_LOAD, rp -> mode_data . multi . load, CVY_MAX_LOAD));
                        return CVY_VERIFY_EXIT;
                    }

#ifdef TRACE_PARAMS
                    DbgPrint ("%8s %3s %4d %s\n", "Multiple", "", rp -> mode_data . multi . load, aff);
#endif
                }

                break;

            default:

#ifdef TRACE_PARAMS
                DbgPrint ("%8s\n", "Disabled");
#endif
                break;
        }

        if (rp -> start_port > rp -> end_port)
        {
            UNIV_PRINT (("Bad port range %d - %d", rp -> start_port, rp -> end_port));
            return CVY_VERIFY_EXIT;
        }

        for (j = 0; j < i; j ++)
        {
            rulep = paramp -> port_rules + j;

            if ((rulep -> virtual_ip_addr == rp -> virtual_ip_addr) &&
                ((rulep -> start_port < rp -> start_port && rulep -> end_port >= rp -> start_port) ||
                 (rulep -> start_port >= rp -> start_port && rulep -> start_port <= rp -> end_port)))
            {
                UNIV_PRINT (("Requested port range in rule %d VIP: %08x (%d - %d) overlaps with the range in an existing rule %d VIP: %08x (%d - %d)", 
                             i, rp -> virtual_ip_addr, rp -> start_port, rp -> end_port, j, rulep -> virtual_ip_addr, rulep -> start_port, rulep -> end_port));
                return CVY_VERIFY_EXIT;
            }
        }
    }

    rulep = &(paramp->port_rules[0]);

    /* in optimized mode - if we have no rules, or a single rule that will
       not look at anything or only source IP address (the only exception to this
       is multiple handling mode with no affinity that also uses source port
       for its decision making) then we can just rely on normal mechanism to
       handle every fragmented packet - since algorithm will not attempt to
       look past the IP header.

       for multiple rules, or single rule with no affinity, apply algorithm only
       to the first packet that has UDP/TCP header and then let fragmented
       packets up on all of the systems. TCP will then do the right thing and
       throw away the fragments on all of the systems other than the one that
       handled the first fragment. */

/* ###### ramkrish. Setting the optimized frags flag in ctxtp is probably a hack,
   but let it be until a better solution can be thought of. */

    if (paramp->num_rules == 0 || (paramp->num_rules == 1 &&
        rulep->start_port == CVY_MIN_PORT &&
        rulep->end_port == CVY_MAX_PORT &&
        ! (rulep->mode == CVY_MULTI &&
           rulep->mode_data.multi.affinity == CVY_AFFINITY_NONE)))
    {
        ctxtp -> optimized_frags = TRUE;
#ifdef TRACE_PARAMS
        DbgPrint("IP fragmentation mode - OPTIMIZED\n");
#endif
    }
    else
    {
        ctxtp -> optimized_frags = FALSE;
#ifdef TRACE_PARAMS
        DbgPrint("IP fragmentation mode - UNOPTIMIZED\n");
#endif
    }

    return CVY_VERIFY_OK;

} /* end Params_verify */

static NTSTATUS Params_query_registry (
    PVOID               nlbctxt,
    PCVY_PARAMS         paramp,
    HANDLE              hdl,
    PWCHAR              name,
    PVOID               datap,
    ULONG               len)
{
    UNICODE_STRING      str;
    ULONG               actual;
    NTSTATUS            status;
    PUCHAR              buffer;
    PKEY_VALUE_PARTIAL_INFORMATION   valp = (PKEY_VALUE_PARTIAL_INFORMATION) infop;
    PMAIN_CTXT          ctxtp = (PMAIN_CTXT)nlbctxt;


    RtlInitUnicodeString (& str, name);

    status = ZwQueryValueKey (hdl, & str, KeyValuePartialInformation, infop,
                              PARAMS_INFO_BUF_SIZE, & actual);

    if (status != STATUS_SUCCESS)
    {
        UNIV_PRINT (("error %x querying value %ls", status, name));
        return status;
    }

    if (valp -> Type == REG_DWORD)
    {
        if (valp -> DataLength != sizeof (ULONG))
        {
            UNIV_PRINT (("bad DWORD length %d", valp -> DataLength));
            return STATUS_OBJECT_NAME_NOT_FOUND;
        }

        * ((PULONG) datap) = * ((PULONG) valp -> Data);
    }
    else if (valp -> Type == REG_BINARY)
    {
        /* since we know that only port rules are of binary type - check
           the size here */

        if (valp -> DataLength > len)
        {
            UNIV_PRINT (("bad BINARY length %d", valp -> DataLength));
            LOG_MSG3 (MSG_ERROR_INTERNAL, MSG_NONE, valp -> DataLength, sizeof (CVY_RULE), CVY_MAX_RULES - 1);
            return STATUS_OBJECT_NAME_NOT_FOUND;
        }

        RtlCopyMemory (datap, valp -> Data, valp -> DataLength);
    }
    else
    {
        if (valp -> DataLength == 0)
        {
            /* simulate an empty string */

            valp -> DataLength = 2;
            valp -> Data [0] = 0;
            valp -> Data [1] = 0;
        }

        if (valp -> DataLength > len)
        {
            UNIV_PRINT (("string too big for %ls %d %d\n", name, valp -> DataLength, len));
        }

        RtlCopyMemory (datap, valp -> Data,
                       valp -> DataLength <= len ?
                       valp -> DataLength : len);
    }

    return status;

} /* end Params_query_registry */

LONG Params_read_portrules (PVOID nlbctxt, PWCHAR reg_path, PCVY_PARAMS paramp) {
    ULONG             dwTemp;
    ULONG             pr_index;
    ULONG             pr_reg_path_length;
    WCHAR             pr_reg_path[CVY_MAX_REG_PATH];
    WCHAR             pr_number[8];
    UNICODE_STRING    pr_path;
    OBJECT_ATTRIBUTES pr_obj;
    HANDLE            pr_hdl = NULL;
    NTSTATUS          status = STATUS_SUCCESS;
    NTSTATUS          final_status = STATUS_SUCCESS;
    PMAIN_CTXT        ctxtp = (PMAIN_CTXT)nlbctxt;

    /* Make sure that we have AT LEAST 12 WCHARs left for the port rule path information (\ + PortRules + \ + NUL). */
    ASSERT(wcslen(reg_path) < (CVY_MAX_REG_PATH - wcslen(CVY_NAME_PORT_RULES) - 3));

    /* Create the "static" portion of the registry, which is "...\Services\WLBS\Interface\<GUID>\PortRules\". */
    wcscpy(pr_reg_path, (PWSTR)reg_path);
    wcscat(pr_reg_path, L"\\");
    wcscat(pr_reg_path, CVY_NAME_PORT_RULES);
    wcscat(pr_reg_path, L"\\");
    
    /* Get the length of this string - this is the placeholder where we will sprintf in the rule numbers each time. */
    pr_reg_path_length = wcslen(pr_reg_path);
    
    /* Make sure that we have AT LEAST 3 WCHARs left for the port rule number and the NUL character (XX + NUL). */
    ASSERT(pr_reg_path_length < (CVY_MAX_REG_PATH - 3));

    /* Loop through each port rule in the port rules tree. */
    for (pr_index = 0; pr_index < paramp->num_rules; pr_index++) {
        /* Sprintf the port rule number (+1) into the registry path key after the "PortRules\". */
        swprintf(pr_number, L"%d", pr_index + 1);
        wcscpy(pr_reg_path + pr_reg_path_length, (PWSTR)pr_number);
        
        UNIV_PRINT(("Port rule registry path: %ls", pr_reg_path));
        
        RtlInitUnicodeString(&pr_path, pr_reg_path);
        InitializeObjectAttributes(&pr_obj, &pr_path, 0, NULL, NULL);
        
        /* Open the key - upon failure, bail out below. */
        status = ZwOpenKey(&pr_hdl, KEY_READ, &pr_obj);
         
        /* If we can't open this key, note FAILURE and continue to the next rule. */
        if (status != STATUS_SUCCESS) {
            final_status = status;
            continue;
        }

        /* Read the rule (error checking) code for the port rule. */
        status = Params_query_registry(nlbctxt, paramp, pr_hdl, CVY_NAME_CODE, &paramp->port_rules[pr_index].code, sizeof(paramp->port_rules[pr_index].code));
            
        if (status != STATUS_SUCCESS)
            final_status = status;

        {
            WCHAR szTemp[CVY_MAX_VIRTUAL_IP_ADDR + 1];
            PWCHAR pTemp = szTemp;
            ULONG dwOctets[4];
            ULONG cIndex;

            /* Read the virtual IP address to which this rule applies. */
            status = Params_query_registry(nlbctxt, paramp, pr_hdl, CVY_NAME_VIP, szTemp, sizeof(szTemp));
            
            if (status != STATUS_SUCCESS) {
                final_status = status;
            } else {
                for (cIndex = 0; cIndex < 4; cIndex++, pTemp++) {
                    if (!Univ_str_to_ulong(dwOctets + cIndex, pTemp, &pTemp, 3, 10) || (cIndex < 3 && *pTemp != L'.')) {
                        UNIV_PRINT (("bad virtual IP address"));
                        final_status = STATUS_INVALID_PARAMETER;
                        break;
                    }
                }
            }
            
            IP_SET_ADDR(&paramp->port_rules[pr_index].virtual_ip_addr, dwOctets[0], dwOctets[1], dwOctets[2], dwOctets[3]);
        }

        /* Read the start port. */
        status = Params_query_registry(nlbctxt, paramp, pr_hdl, CVY_NAME_START_PORT, &paramp->port_rules[pr_index].start_port, sizeof(paramp->port_rules[pr_index].start_port));
            
        if (status != STATUS_SUCCESS)
            final_status = status;

        /* Read the end port. */
        status = Params_query_registry(nlbctxt, paramp, pr_hdl, CVY_NAME_END_PORT, &paramp->port_rules[pr_index].end_port, sizeof(paramp->port_rules[pr_index].end_port));
            
        if (status != STATUS_SUCCESS)
            final_status = status;

        /* Read the protocol(s) to which this rule applies. */
        status = Params_query_registry(nlbctxt, paramp, pr_hdl, CVY_NAME_PROTOCOL, &paramp->port_rules[pr_index].protocol, sizeof(paramp->port_rules[pr_index].protocol));
            
        if (status != STATUS_SUCCESS)
            final_status = status;

        /* Read the filtering mode - single host, multiple host or disabled. */
        status = Params_query_registry(nlbctxt, paramp, pr_hdl, CVY_NAME_MODE, &paramp->port_rules[pr_index].mode, sizeof(paramp->port_rules[pr_index].mode));
            
        if (status != STATUS_SUCCESS)
            final_status = status;

        /* Based on the mode, get the rest of the parameters. */
        switch (paramp->port_rules[pr_index].mode) {
        case CVY_SINGLE:
            /* Read the single host filtering priority. */
            status = Params_query_registry(nlbctxt, paramp, pr_hdl, CVY_NAME_PRIORITY, &paramp->port_rules[pr_index].mode_data.single.priority, sizeof(paramp->port_rules[pr_index].mode_data.single.priority));
                
            if (status != STATUS_SUCCESS)
                final_status = status;

            break;
        case CVY_MULTI:
            /* Read the equal load flag for the multiple host filtering rule.  Because this parameter is a DWORD in the registry and
               a USHORT in our parameters structure, we read it into a temporary variable and then copy to our parameters upon success. */ 
            status = Params_query_registry(nlbctxt, paramp, pr_hdl, CVY_NAME_EQUAL_LOAD, &dwTemp, sizeof(dwTemp));
                
            if (status != STATUS_SUCCESS)
                final_status = status;
            else 
                paramp->port_rules[pr_index].mode_data.multi.equal_load = (USHORT)dwTemp;

            /* Read the explicit load distribution for multiple host filtering. */
            status = Params_query_registry(nlbctxt, paramp, pr_hdl, CVY_NAME_LOAD, &paramp->port_rules[pr_index].mode_data.multi.load, sizeof(paramp->port_rules[pr_index].mode_data.multi.load));
                
            if (status != STATUS_SUCCESS)
                final_status = status;

            /* Read the affinity setting for multiple host filtering. Because this parameter is a DWORD in the registry and
               a USHORT in our parameters structure, we read it into a temporary variable and then copy to our parameters upon success. */ 
            status = Params_query_registry(nlbctxt, paramp, pr_hdl, CVY_NAME_AFFINITY, &dwTemp, sizeof(dwTemp));
                
            if (status != STATUS_SUCCESS)
                final_status = status;
            else 
                paramp->port_rules[pr_index].mode_data.multi.affinity = (USHORT)dwTemp;

            break;
        }            

        /* Close the key for this rule. */
        status = ZwClose (pr_hdl);
            
        if (status != STATUS_SUCCESS)
            final_status = status;
            
    }

    return final_status;
}

LONG Params_read_teaming (PVOID nlbctxt, PWCHAR reg_path, PCVY_PARAMS paramp) {
    WCHAR             bda_reg_path[CVY_MAX_REG_PATH];
    UNICODE_STRING    bda_path;
    OBJECT_ATTRIBUTES bda_obj;
    HANDLE            bda_hdl = NULL;
    NTSTATUS          status = STATUS_SUCCESS;
    NTSTATUS          final_status = STATUS_SUCCESS;
    PMAIN_CTXT        ctxtp = (PMAIN_CTXT)nlbctxt;

    /* Make sure that we have AT LEAST 12 WCHARs left for the BDA teaming path information (\ + BDATeaming + NUL). */
    ASSERT(wcslen(reg_path) < (CVY_MAX_REG_PATH - wcslen(CVY_NAME_BDA_TEAMING) - 2));

    /* Create the registry path, which is "...\Services\WLBS\Interface\<GUID>\BDATeaming\". */
    wcscpy(bda_reg_path, (PWSTR)reg_path);
    wcscat(bda_reg_path, L"\\");
    wcscat(bda_reg_path, CVY_NAME_BDA_TEAMING);
    
    UNIV_PRINT(("BDA teaming registry path: %ls", bda_reg_path));
        
    RtlInitUnicodeString(&bda_path, bda_reg_path);
    InitializeObjectAttributes(&bda_obj, &bda_path, 0, NULL, NULL);
    
    /* Open the key - failure is acceptable and means that this adapter is not part of a BDA team. */
    status = ZwOpenKey(&bda_hdl, KEY_READ, &bda_obj);
    
    /* If we can't open this key, return here. */
    if (status != STATUS_SUCCESS) {
        /* If we couldn't find the key, that's fine - it might not exist. */
        if (status == STATUS_OBJECT_NAME_NOT_FOUND)
            return STATUS_SUCCESS;
        /* Otherwise, there was a legitimate error. */
        else
            return status;
    }

    /* If we were able to open the registry key, then this adapter is part of a BDA team. */
    paramp->bda_teaming.active = TRUE;

    /* Read the team ID from the registry - this is a GUID. */
    status = Params_query_registry (nlbctxt, paramp, bda_hdl, CVY_NAME_BDA_TEAM_ID, &paramp->bda_teaming.team_id, sizeof(paramp->bda_teaming.team_id));

    if (status != STATUS_SUCCESS)
        final_status = status;

    /* Get the boolean indication of whether or not this adapter is the master for the team. */
    status = Params_query_registry (nlbctxt, paramp, bda_hdl, CVY_NAME_BDA_MASTER, &paramp->bda_teaming.master, sizeof(paramp->bda_teaming.master));

    if (status != STATUS_SUCCESS)
        final_status = status;

    /* Get the boolean indication of forward (conventional) or reverse hashing. */
    status = Params_query_registry (nlbctxt, paramp, bda_hdl, CVY_NAME_BDA_REVERSE_HASH, &paramp->bda_teaming.reverse_hash, sizeof(paramp->bda_teaming.reverse_hash));

    if (status != STATUS_SUCCESS)
        final_status = status;
    
    /* Close the key for BDA teaming. */
    status = ZwClose(bda_hdl);
    
    if (status != STATUS_SUCCESS)
        final_status = status;

    return final_status;
}

LONG Params_read_hostname (PVOID nlbctxt, PCVY_PARAMS paramp) {
    WCHAR             domain[CVY_MAX_HOST_NAME + 1]; 
    WCHAR             hostname[CVY_MAX_HOST_NAME + 1]; 
    WCHAR             host_reg_path[CVY_MAX_REG_PATH];
    UNICODE_STRING    host_path;
    OBJECT_ATTRIBUTES host_obj;
    HANDLE            host_hdl = NULL;
    NTSTATUS          status = STATUS_SUCCESS;
    PMAIN_CTXT        ctxtp = (PMAIN_CTXT)nlbctxt;

    /* Erase the hostname.domain first. */
    wcscpy(paramp->hostname, L"");

    /* Create the registry path to the TCP/IP parameters. */
    wcscpy(host_reg_path, L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters");
    
    UNIV_PRINT(("TCP/IP parameters registry path: %ls", host_reg_path));

    RtlInitUnicodeString(&host_path, host_reg_path);
    InitializeObjectAttributes(&host_obj, &host_path, 0, NULL, NULL);
    
    /* Open the key - failure is acceptable. */
    status = ZwOpenKey(&host_hdl, KEY_READ, &host_obj);
    
    /* If we can't open this key, return here. */
    if (status != STATUS_SUCCESS)
        return STATUS_SUCCESS;

    /* Get the hostname from the registry.  Failure is acceptable. */
    status = Params_query_registry (nlbctxt, paramp, host_hdl, L"Hostname", hostname, sizeof(hostname));

    if (status != STATUS_SUCCESS)
        return STATUS_SUCCESS;

    /* Read the domain from the registry.  Failture is acceptable. */
    status = Params_query_registry (nlbctxt, paramp, host_hdl, L"Domain", domain, sizeof(domain));

    if (status != STATUS_SUCCESS)
        return STATUS_SUCCESS;

    /* If the domain.hostname is too large to fit in the buffer, then we return here. */
    if ((wcslen(domain) + wcslen(hostname) + 1) > CVY_MAX_HOST_NAME) {
        /* However, if we at least have room for the hostname, use it. */
        if (wcslen(hostname) <= CVY_MAX_HOST_NAME)
            wcscpy(paramp->hostname, hostname);
        
        return STATUS_SUCCESS;
    }        

    /* If we succesfully retrieved the domain and hostname, and we have enough room
       in our buffer, create the fully qualified hostname as HOST.DOMAIN. */
    wcscpy(paramp->hostname, hostname);
    wcscat(paramp->hostname, L".");
    wcscat(paramp->hostname, domain);

    return STATUS_SUCCESS;
}

LONG Params_init (
    PVOID           nlbctxt,
    PVOID           rp,
    PVOID           adapter_guid,
    PCVY_PARAMS     paramp)
{
    NTSTATUS                    status;
    WCHAR                       reg_path [CVY_MAX_REG_PATH];
    UNICODE_STRING              path;
    OBJECT_ATTRIBUTES           obj;
    HANDLE                      hdl = NULL;
    NTSTATUS                    final_status = STATUS_SUCCESS;
    PMAIN_CTXT                  ctxtp = (PMAIN_CTXT)nlbctxt;

    RtlZeroMemory (paramp, sizeof (CVY_PARAMS));

    paramp -> cl_mac_addr      [0] = 0;
    paramp -> cl_ip_addr       [0] = 0;
    paramp -> cl_net_mask      [0] = 0;
    paramp -> ded_ip_addr      [0] = 0;
    paramp -> ded_net_mask     [0] = 0;
    paramp -> cl_igmp_addr     [0] = 0;
    paramp -> domain_name      [0] = 0;

    /* Setup defaults that we HAVE to have. */
    paramp->num_actions   = CVY_DEF_NUM_ACTIONS;
    paramp->num_packets   = CVY_DEF_NUM_PACKETS;
    paramp->num_send_msgs = CVY_DEF_NUM_SEND_MSGS;
    paramp->alive_period  = CVY_DEF_ALIVE_PERIOD;

    /* Make sure that the registry path fits in out buffer. */
    ASSERT(wcslen((PWSTR) rp) + wcslen((PWSTR) adapter_guid) + 1 <= CVY_MAX_REG_PATH);

    wcscpy (reg_path, (PWSTR) rp);
    wcscat (reg_path, (PWSTR) adapter_guid);
    RtlInitUnicodeString (& path, reg_path);

    InitializeObjectAttributes (& obj, & path, 0, NULL, NULL);

    status = ZwOpenKey (& hdl, KEY_READ, & obj);

    if (status != STATUS_SUCCESS)
        goto error;

    status = Params_query_registry (nlbctxt, paramp, hdl, CVY_NAME_VERSION, & paramp -> parms_ver, sizeof (paramp -> parms_ver));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, paramp, hdl, CVY_NAME_EFFECTIVE_VERSION, & paramp -> effective_ver, sizeof (paramp -> effective_ver));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, paramp, hdl, CVY_NAME_HOST_PRIORITY, & paramp -> host_priority, sizeof (paramp -> host_priority));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, paramp, hdl, CVY_NAME_NETWORK_ADDR, & paramp -> cl_mac_addr, sizeof (paramp -> cl_mac_addr));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, paramp, hdl, CVY_NAME_CL_IP_ADDR, & paramp -> cl_ip_addr, sizeof (paramp -> cl_ip_addr));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, paramp, hdl, CVY_NAME_MCAST_IP_ADDR, & paramp -> cl_igmp_addr, sizeof (paramp -> cl_igmp_addr));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, paramp, hdl, CVY_NAME_CL_NET_MASK, & paramp -> cl_net_mask, sizeof (paramp -> cl_net_mask));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, paramp, hdl, CVY_NAME_ALIVE_PERIOD, & paramp -> alive_period, sizeof (paramp -> alive_period));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, paramp, hdl, CVY_NAME_ALIVE_TOLER, & paramp -> alive_tolerance, sizeof (paramp -> alive_tolerance));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, paramp, hdl, CVY_NAME_DOMAIN_NAME, & paramp -> domain_name, sizeof (paramp -> domain_name));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, paramp, hdl, CVY_NAME_RMT_PASSWORD, & paramp -> rmt_password, sizeof (paramp -> rmt_password));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, paramp, hdl, CVY_NAME_RCT_PASSWORD, & paramp -> rct_password, sizeof (paramp -> rct_password));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, paramp, hdl, CVY_NAME_RCT_PORT, & paramp -> rct_port, sizeof (paramp -> rct_port));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, paramp, hdl, CVY_NAME_RCT_ENABLED, & paramp -> rct_enabled, sizeof (paramp -> rct_enabled));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, paramp, hdl, CVY_NAME_NUM_ACTIONS, & paramp -> num_actions, sizeof (paramp -> num_actions));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, paramp, hdl, CVY_NAME_NUM_PACKETS, & paramp -> num_packets, sizeof (paramp -> num_packets));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, paramp, hdl, CVY_NAME_NUM_SEND_MSGS, & paramp -> num_send_msgs, sizeof (paramp -> num_send_msgs));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, paramp, hdl, CVY_NAME_INSTALL_DATE, & paramp -> install_date, sizeof (paramp -> install_date));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, paramp, hdl, CVY_NAME_CLUSTER_MODE, & paramp -> cluster_mode, sizeof (paramp -> cluster_mode));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, paramp, hdl, CVY_NAME_DED_IP_ADDR, & paramp -> ded_ip_addr, sizeof (paramp -> ded_ip_addr));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, paramp, hdl, CVY_NAME_DED_NET_MASK, & paramp -> ded_net_mask, sizeof (paramp -> ded_net_mask));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, paramp, hdl, CVY_NAME_DSCR_PER_ALLOC, & paramp -> dscr_per_alloc, sizeof (paramp -> dscr_per_alloc));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, paramp, hdl, CVY_NAME_MAX_DSCR_ALLOCS, & paramp -> max_dscr_allocs, sizeof (paramp -> max_dscr_allocs));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, paramp, hdl, CVY_NAME_SCALE_CLIENT, & paramp -> scale_client, sizeof (paramp -> scale_client));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, paramp, hdl, CVY_NAME_CLEANUP_DELAY, & paramp -> cleanup_delay, sizeof (paramp -> cleanup_delay));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, paramp, hdl, CVY_NAME_NBT_SUPPORT, & paramp -> nbt_support, sizeof (paramp -> nbt_support));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, paramp, hdl, CVY_NAME_MCAST_SUPPORT, & paramp -> mcast_support, sizeof (paramp -> mcast_support));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, paramp, hdl, CVY_NAME_MCAST_SPOOF, & paramp -> mcast_spoof, sizeof (paramp -> mcast_spoof));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, paramp, hdl, CVY_NAME_IGMP_SUPPORT, & paramp -> igmp_support, sizeof (paramp -> igmp_support));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, paramp, hdl, CVY_NAME_MASK_SRC_MAC, & paramp -> mask_src_mac, sizeof (paramp -> mask_src_mac));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, paramp, hdl, CVY_NAME_NETMON_ALIVE, & paramp -> netmon_alive, sizeof (paramp -> netmon_alive));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, paramp, hdl, CVY_NAME_IP_CHG_DELAY, & paramp -> ip_chg_delay, sizeof (paramp -> ip_chg_delay));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, paramp, hdl, CVY_NAME_CONVERT_MAC, & paramp -> convert_mac, sizeof (paramp -> convert_mac));

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = Params_query_registry (nlbctxt, paramp, hdl, CVY_NAME_NUM_RULES, & paramp -> num_rules, sizeof (paramp -> num_rules));
    
    /* Get the port rules only if we were able to successfully grab the number of port rules, which is necessary
       in order to generate the registry keys for the new port rule format for virtual cluster support. */
    if (status != STATUS_SUCCESS) {
        final_status = status;        
    } else {
        /* First try to open the port rules in their old format. */
        status = Params_query_registry (nlbctxt, paramp, hdl, CVY_NAME_OLD_PORT_RULES, & paramp -> port_rules, sizeof (paramp -> port_rules));

        if (status == STATUS_SUCCESS) {
            /* If we were succussful in reading the rules from the old settings, then FAIL - this shouldn't happen. */
            final_status = STATUS_INVALID_PARAMETER;

            UNIV_PRINT(("Error: Found port rules in old binary format"));
        } else {
            /* Look up the port rules, which we are now expecting to be in tact in the new location. */
            status = Params_read_portrules(nlbctxt, reg_path, paramp);
            
            if (status != STATUS_SUCCESS)
                final_status = status;
        }
    }

    /* Look up the BDA teaming parameters, if they exist. */
    status = Params_read_teaming(nlbctxt, reg_path, paramp);
    
    if (status != STATUS_SUCCESS)
        final_status = status;

    /* Attempt to retrieve the hostname from the TCP/IP registry settings. */
    status = Params_read_hostname(nlbctxt, paramp);

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = ZwClose (hdl);

    if (status != STATUS_SUCCESS)
        final_status = status;

    status = final_status;

 error:

    if (status != STATUS_SUCCESS)
    {
        UNIV_PRINT (("error querying registry %x", status));
        LOG_MSG1 (MSG_ERROR_REGISTRY, path . Buffer, status);
    }

    /* Verify registry parameter settings. */
    if (Params_verify (nlbctxt, paramp, TRUE) != CVY_VERIFY_OK)
    {
        UNIV_PRINT (("bad parameter value(s)"));
        LOG_MSG (MSG_ERROR_REGISTRY, MSG_NONE);
        return STATUS_UNSUCCESSFUL;
    }

    return status;

} /* end Params_init */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\driver\params.h ===
#pragma once


#define CVY_MAX_CALLB_QUEUE_RETRIES    100       /* maximum number of times to
                                                   attempt queueing miniport
                                                   callback in Nic_sync_queue */

#define CVY_MAX_ALLOCS                 50       /* maximum number of allocations
                                                   we can perform for packets
                                                   and actions */

#define CVY_MAX_SEND_PACKETS           50      /*  maximum number of packets
                                                   Prot_packets_send can send
                                                   down at one time */

#define CVY_MAX_PENDING_PACKETS        100     /*  maximum number of packets that
                                                   can be queued in a deserialized
                                                   wlbs driver */

/* Structure to hold the bi-directional affinity registry settings. */
typedef struct _CVY_BDA {
    WCHAR       team_id[CVY_MAX_BDA_TEAM_ID + 1];  /* The team ID - user-level support should enforce that it is a GUID. */
    ULONG       active;                            /* Is this adapter part of a BDA team? */
    ULONG       master;                            /* Boolean indication of master status (Slave=0). */
    ULONG       reverse_hash;                      /* Sets direction of hashing - forward (normal) or reverse. */
} CVY_BDA, PCVY_BDA;

/* port group rule - keep it 64bit in size for encryption */

typedef struct
{
    ULONG       start_port,         /* starting port number */
                end_port;           /* ending port number */
    ULONG       virtual_ip_addr;    /* Virtual clusters - the VIP to which the rule applies.
                                       All VIPs is represented by 0xffffffff. */
    ULONG       code;               /* unique rule code */
    ULONG       mode;               /* filtering mode */
    ULONG       protocol;           /* CVY_TCP, CVY_UDP or CVY_TCP_UDP */
    ULONG       valid;              /* for rule management in user mode */
    union
    {
        struct
        {
            ULONG       priority;   /* mastership priority: 1->N or 0 for
                                       not-specified */
        }           single;         /* data for single server mode */
        struct
        {
            USHORT      equal_load; /* TRUE => even load distribution */
            USHORT      affinity;   /* TRUE - map all client connections to one server */
            ULONG       load;       /* percentage of load to handle locally */
        }           multi;          /* data for multi-server mode */
    }           mode_data;          /* data for appropriate port group mode */
}
CVY_RULE, * PCVY_RULE;

/* host parameters */

typedef struct
{

    /* obtained from the registry */

    ULONG       parms_ver;          /* parameter structure version */
    ULONG       effective_ver;      /* what WLBS version we are effectively operating in. */

    ULONG       host_priority;      /* host's priority for single-server mastership */
    ULONG       alive_period;       /* period for sending "I am alive" messages
                                       in milliseconds */
    ULONG       alive_tolerance;    /* how many "I am alive" messages can be
                                       missed from other servers before assuming
                                       that the host is dead */
    ULONG       num_actions;        /* number of actions to allocate */
    ULONG       num_packets;        /* number of packets to allocate */
    ULONG       num_send_msgs;      /* number of send packets to allocate */
    ULONG       install_date;       /* install time stamp */
    ULONG       rmt_password;       /* remote maintenance password */
    ULONG       rct_password;       /* remote control password */
    ULONG       rct_port;           /* remote control UDP port */
    ULONG       rct_enabled;        /* TRUE - remote control enabled */
    ULONG       num_rules;          /* # active port group rules */
    ULONG       cleanup_delay;      /* dirty connection cleanup delay in
                                       milliseconds, 0 - delay */
    ULONG       cluster_mode;       /* TRUE - enabled on startup */
    ULONG       dscr_per_alloc;     /* number of connection tracking
                                       descriptor per allocation */
    ULONG       max_dscr_allocs;    /* maximum number of connection tracking
                                       descriptor allocations */
    ULONG       scale_client;       /* TRUE - load balance connections from a
                                       given client across cluster servers */
    ULONG       nbt_support;        /* TRUE - NBT cluster name support enabled */
    ULONG       mcast_support;      /* TRUE - enable multicast MAC address support
                                       for switched V1.3.0b */
    ULONG       mcast_spoof;        /* TRUE - if mcast_support is TRUE - enable
                                       TCP/IP spoofing so that remote hosts can
                                       resolve cluster IP address to multicast
                                       address via ARPs V1.3.0b */
    ULONG       igmp_support;       /* TRUE - if IGMP support is enabled */
    ULONG       mask_src_mac;       /* TRUE - spoof source MAC when sending
                                       frames in unicast mode to prevent
                                       switches from getting confused V 2.0.6 */
    ULONG       netmon_alive;       /* TRUE - pass heartbeat frames to the
                                       protocols */
    ULONG       convert_mac;        /* TRUE - automatically match MAC address
                                       to primary cluster IP address */
    ULONG       ip_chg_delay;       /* delay in milliseconds to block outgoing
                                       ARPs while IP address change is in
                                       process */

    CVY_BDA     bda_teaming;        /* the bi-directional affinity teaming config. */

    /* strings */

    WCHAR       cl_mac_addr [CVY_MAX_NETWORK_ADDR + 1];
                                    /* cluster MAC address */
    WCHAR       cl_ip_addr [CVY_MAX_CL_IP_ADDR + 1];
                                    /* cluster IP address */
    WCHAR       cl_net_mask [CVY_MAX_CL_NET_MASK + 1];
                                    /* netmask for cluster IP address or "" for none */
    WCHAR       ded_ip_addr [CVY_MAX_DED_IP_ADDR + 1];
                                    /* dedicated IP address or "" for none */
    WCHAR       ded_net_mask [CVY_MAX_DED_NET_MASK + 1];
                                    /* netmask for dedicated IP address or "" for none */
    WCHAR       domain_name [CVY_MAX_DOMAIN_NAME + 1];
                                    /* client's domain name */
    WCHAR       cl_igmp_addr [CVY_MAX_CL_IGMP_ADDR + 1];
                                    /* dedicated IP address or "" for none */
    CVY_RULE    port_rules[CVY_MAX_RULES - 1];
                                    /* port rules (account for internal default) */
    WCHAR       hostname[CVY_MAX_HOST_NAME + 1]; 
                                    /* hostname.domain for this host if available. */
}
CVY_PARAMS, * PCVY_PARAMS;

#define CVY_DRIVER_RULE_CODE_GET(rulep) ((rulep) -> code)

#define CVY_DRIVER_RULE_CODE_SET(rulep) ((rulep) -> code =                          \
                                         ((ULONG) (((rulep) -> start_port) <<  0) | \
                                          (ULONG) (((rulep) -> end_port)   << 12) | \
                                          (ULONG) (((rulep) -> protocol)   << 24) | \
                                          (ULONG) (((rulep) -> mode)       << 28) | \
                                          (ULONG) (((rulep) -> mode == CVY_MULTI ? (rulep) -> mode_data . multi . affinity : 0) << 30)) \
                                         ^ ~((rulep) -> virtual_ip_addr))

extern LONG Params_init (
    PVOID           nlbctxt,
    PVOID           reg_path,
    PVOID           adapter_guid, /* GUID of the adapter for multiple nics*/
    PCVY_PARAMS     paramp);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\driver\main.h ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    main.h

Abstract:

    Windows Load Balancing Service (WLBS)
    Driver - packet handing

Author:

    kyrilf

--*/


#ifndef _Main_h_
#define _Main_h_

#define NDIS_MINIPORT_DRIVER    1
//#define NDIS50_MINIPORT         1
#define NDIS50                  1
#define NDIS51_MINIPORT         1
#define NDIS51                  1

#include <ndis.h>

#include "univ.h"
#include "load.h"
#include "util.h"
#include "wlbsip.h"
#include "wlbsparm.h"
#include "params.h"
#include "wlbsiocl.h"

/* Turn off mixed-mode clusters, which allows clusters in different 
   cluster modes (unicast, multicast, IGMP) to converge separately. */
#undef NLB_MIXED_MODE_CLUSTERS

/* CONSTANTS */


/* type codes for main datastructures */

#define MAIN_CTXT_CODE              0xc0dedead
#define MAIN_ACTION_CODE            0xc0deac10
#define MAIN_BUFFER_CODE            0xc0deb4fe
#define MAIN_ADAPTER_CODE           0xc0deadbe

/* protocol specific constants */

#define MAIN_FRAME_SIG              0x886f          /* new and approved 802.3 ping frame signature */
#define MAIN_FRAME_SIG_OLD          0xbf01          /* old convoy 802.3 ping frame signature */
#define MAIN_FRAME_CODE             0xc0de01bf      /* ping frame code */
#define MAIN_IP_SIG                 0x0800          /* IP code for IGMP messages */

/* reset states */

#define MAIN_RESET_NONE             0
#define MAIN_RESET_START            1
#define MAIN_RESET_START_DONE       2
#define MAIN_RESET_END              3

/* post-filtering operation types */

#define MAIN_FILTER_OP_NONE         0       /* not operation */
#define MAIN_FILTER_OP_NBT          1       /* netbios spoofing */
#define MAIN_FILTER_OP_CTRL         2       /* remote control packets */

/* packet type */

#define MAIN_PACKET_TYPE_NONE       0       /* invalid number */
#define MAIN_PACKET_TYPE_PING       1       /* ping packet */
#define MAIN_PACKET_TYPE_INDICATE   2       /* recv_indicate packet */
#define MAIN_PACKET_TYPE_PASS       3       /* pass-through packet */
#define MAIN_PACKET_TYPE_CTRL       4       /* remote control packet */
#define MAIN_PACKET_TYPE_TRANSFER   6       /* protocol layer initiated transfer packet */
#define MAIN_PACKET_TYPE_IGMP       7       /* igmp message packet */

/* frame type */

#define MAIN_FRAME_UNKNOWN          0
#define MAIN_FRAME_DIRECTED         1
#define MAIN_FRAME_MULTICAST        2
#define MAIN_FRAME_BROADCAST        3

/* adapter constants */
#define MAIN_ADAPTER_NOT_FOUND      -1

/* TYPES */


/* actions are used for passing parameter info between Nic and Prot modules,
   and ensure that if miniport syncronization requires queueing we do not
   loose parameters and context */
#pragma pack(1) /* 64-bit -- ramkrish */
typedef struct
{
    LIST_ENTRY          link;
    PVOID               ctxtp;              /* pointer to main context */
    ULONG               code;               /* type-checking code */
//    UNIV_SYNC_CALLB     callb;              /* callback in case have to re-try */
    NDIS_STATUS         status;             /* general status */

    /* per-operation type data */

    union
    {
        struct
        {
            PULONG              xferred;
            PULONG              needed;
            ULONG               external;
            ULONG               pad64;      /* 64-bit -- ramkrish */
            NDIS_REQUEST        req;
        }
                            request;
#if 0
        struct
        {
            PNDIS_PACKET        packet;
        }
                            send;
        struct
        {
            PNDIS_PACKET        packet;
        }
                            recv;
        struct
        {
            NDIS_HANDLE         recv_handle;
            PVOID               head_buf;
            UINT                head_len;
            PVOID               look_buf;
            UINT                look_len;
            UINT                packet_len;
        }
                            indicate;
        struct
        {
            PNDIS_PACKET        packet;
            UINT                xferred;
        }
                            transfer;
        struct
        {
            PVOID               buf;
            UINT                len;
        }
                            status;
#endif
        struct
        {
            PNDIS_PACKET        packet;
        }
                            ctrl;
    }
                        op;
}
MAIN_ACTION, * PMAIN_ACTION;
#pragma pack()

/* V2.0.6 per-packet protocol reserved information. this structure has to be at
   most 16 bytes in length */

#pragma pack(1)
/* 64-bit changes -- ramkrish */
typedef struct
{
    PVOID               miscp;      /* dscrp for ping frame,
                                       bufp for recv_indicate frame,
                                       external packet for pass through frames */
    USHORT              type;       /* packet type */
    USHORT              group;      /* if the frame direct, multicast or
                                       broadcast */
    LONG                data;       /* used for keeping expected xfer len on
                                       recv_indicate until transfer_complete
                                       occurs and for doing locking on
                                       send/receive paths */
    ULONG               len;        /* packet length for stats */
}
MAIN_PROTOCOL_RESERVED, * PMAIN_PROTOCOL_RESERVED;

#pragma pack()


/* per receive buffer wrapper structure */

typedef struct
{
    LIST_ENTRY          link;
    ULONG               code;       /* type-checking code */
    ULONG               pad64;      /* 64-bit -- ramkrish */
    PNDIS_BUFFER        full_bufp;  /* describes enture buffer */
    PNDIS_BUFFER        frame_bufp; /* describes payload only */
    PUCHAR              framep;     /* pointer to payload */
    UCHAR               data [1];   /* beginning of buffer */
}
MAIN_BUFFER, * PMAIN_BUFFER;

/* convoy ping message header */

#pragma pack(1)

typedef struct
{
    ULONG                   code;               /* distinguishes Convoy frames */
    ULONG                   version;            /* software version */
    ULONG                   host;               /* source host id */
    ULONG                   cl_ip_addr;         /* cluster IP address */
    ULONG                   ded_ip_addr;        /* dedicated IP address V2.0.6 */
}
MAIN_FRAME_HDR, * PMAIN_FRAME_HDR;

#pragma pack()


/* per ping message wrapper structure */


typedef struct
{
    LIST_ENTRY              link;
    CVY_MEDIA_HDR           media_hdr;          /* filled-out media header */
    MAIN_FRAME_HDR          frame_hdr;          /* frame header */
    PING_MSG                msg;                /* ping msg V1.1.4 */
    ULONG                   recv_len;           /* used on receive path */
    PNDIS_BUFFER            media_hdr_bufp;     /* describes media header */
    PNDIS_BUFFER            frame_hdr_bufp;     /* describes frame header */
    PNDIS_BUFFER            send_data_bufp;     /* describes payload source for
                                                   outgoing frames */
    PNDIS_BUFFER            recv_data_bufp;     /* describes payload destination
                                                   for incoming frames */
}
MAIN_FRAME_DSCR, * PMAIN_FRAME_DSCR;


#pragma pack(1)
typedef struct
{
    UCHAR                   igmp_vertype;          /* Version and Type */
    UCHAR                   igmp_unused;           /* Unused */
    USHORT                  igmp_xsum;             /* Checksum */
    ULONG                   igmp_address;          /* Multicast Group Address */
}
MAIN_IGMP_DATA, * PMAIN_IGMP_DATA;


typedef struct
{
    UCHAR                   iph_verlen;             /* Version and length */
    UCHAR                   iph_tos;                /* Type of service */
    USHORT                  iph_length;             /* Total length of datagram */
    USHORT                  iph_id;                 /* Identification */
    USHORT                  iph_offset;             /* Flags and fragment offset */
    UCHAR                   iph_ttl;                /* Time to live */
    UCHAR                   iph_protocol;           /* Protocol */
    USHORT                  iph_xsum;               /* Header checksum */
    ULONG                   iph_src;                /* Source address */
    ULONG                   iph_dest;               /* Destination address */
}
MAIN_IP_HEADER, * PMAIN_IP_HEADER;


typedef struct
{
    MAIN_IP_HEADER          ip_data;
    MAIN_IGMP_DATA          igmp_data;
}
MAIN_IGMP_FRAME, * PMAIN_IGMP_FRAME;
#pragma pack()

#define CVY_BDA_MAXIMUM_MEMBER_ID (CVY_MAX_ADAPTERS - 1)
#define CVY_BDA_INVALID_MEMBER_ID CVY_MAX_ADAPTERS

/* This structure holds the configuration of a BDA team.  Each 
   member holds a pointer to this structure, which its uses to 
   update state and acquire references to and utilize the master 
   load context for packet handling. */
typedef struct _BDA_TEAM {
    struct _BDA_TEAM * prev;                             /* Pointer to the previous team in this doubly-linked list. */
    struct _BDA_TEAM * next;                             /* Pointer to the next team in this doubly-linked list. */
    PLOAD_CTXT         load;                             /* Pointer to the "shared" load module for this team. This
                                                            is the load module of the master.  If there is no master
                                                            in the team, this pointer is NULL. */ 
    PNDIS_SPIN_LOCK    load_lock;                        /* Pointer to the load lock for the "shared" load module. */
    ULONG              active;                           /* Is this team active.  Teams become inactive under two 
                                                            conditions; (1) inconsistent teaming detected via heart-
                                                            beats or (2) the team has no master. */
    ULONG              membership_count;                 /* This is the number of members in the team.  This acts as
                                                            a reference count on the team state. */
    ULONG              membership_fingerprint;           /* This is an XOR of the least significant 16 bits of each
                                                            member's primary cluster IP address.  This is used as a 
                                                            sort of signature on the team membership. */
    ULONG              membership_map;                   /* This is a bit map of the team membership.  Each member is
                                                            assigned a member ID, which is its index in this bit map. */
    ULONG              consistency_map;                  /* This is a bit map of the member consistency.  Each mamber
                                                            is assigned a member ID, which is its index in this bit map.
                                                            When a member detects bad configuration via its heartbeats,
                                                            it resets its bit in this map. */  
    WCHAR              team_id[CVY_MAX_BDA_TEAM_ID + 1]; /* This is the team ID - a GUID - which is used to match 
                                                            adapters to the correct team. */
} BDA_TEAM, * PBDA_TEAM;

/* This structure holds the teaming configuration for a single
   adapter and is a member of the MAIN_CTXT structure. */
typedef struct _BDA_MEMBER {
    ULONG              active;                           /* Is this adapter part of a BDA team. */
    ULONG              master;                           /* Is this adapter the master of its team. */
    ULONG              reverse_hash;                     /* Is this adapter using reverse hashing (reverse source and 
                                                            destination IP addresses and ports before hashing). */
    ULONG              member_id;                        /* The member ID - a unique (per-team) ID between 0 and 15. 
                                                            Used as the index in several team bit arrays. */
    PBDA_TEAM          bda_team;                         /* Pointer to a BDA_TEAM structure, which contains the 
                                                            ocnfiguration and state of my team. */
} BDA_MEMBER, * PBDA_MEMBER;

/* main context type */

typedef struct
{
    ULONG               code;                   /* type checking code */
    NDIS_STATUS         completion_status;      /* request completion status */
    NDIS_EVENT          completion_event;       /* request completion trigger */
    NDIS_HANDLE         bind_handle;            /* bind context handle */
    NDIS_HANDLE         unbind_handle;          /* unbind context handle */
    NDIS_HANDLE         mac_handle;             /* underlying adapter handle */
    NDIS_HANDLE         prot_handle;            /* overlying protocol handle */
    NDIS_MEDIUM         medium;                 /* adapter medium */
    ULONG               curr_tout;              /* current heartbeat period */
    ULONG               igmp_sent;              /* time elapsed since the last
						   igmp message was sent */
    ULONG               packets_exhausted;      /* out of send packets */
    ULONG               mac_options;            /* adapter options V1.3.1b */
    ULONG               media_connected;        /* media plugged in V1.3.2b */

    ULONG               max_frame_size;         /* MTU of the medium V1.3.2b */
    ULONG               max_mcast_list_size;

    BDA_MEMBER          bda_teaming;            /* BDA membership information. */

    PVOID               timer;                  /* points to Nic module allocated
                                                   ping time V1.2.3b */
    ULONG               num_packets;            /* number of packets per alloc */
    ULONG               num_actions;            /* number of actions per alloc */
    ULONG               num_send_msgs;          /* number of heartbeats to alloc */

    /* states */

    ULONG               reset_state;            /* current reset state V1.1.2 */
    ULONG               recv_indicated;         /* first receive trigger after
                                                   reset V1.1.2 */
    ULONG               draining;               /* draining mode */
    ULONG               stopping;               /* draining->stop mode */
    ULONG               suspended;              /* cluster control suspended */
    ULONG               convoy_enabled;         /* cluster mode active */

    /* PnP */

    NDIS_DEVICE_POWER_STATE  prot_pnp_state;    /* PNP state */
    NDIS_DEVICE_POWER_STATE  nic_pnp_state;     /* PNP state */
    PMAIN_ACTION        out_request;            /* outstanding request */
    ULONG               requests_pending;       /* set or query requests pending */
    ULONG               standby_state;          /* entering standby state */

    /* IP and MAC addresses */

    ULONG               ded_ip_addr;            /* dedicated IP */
    ULONG               ded_net_mask;           /* dedicated mask */
    ULONG               ded_bcast_addr;         /* dedicated broadcast IP */
    ULONG               cl_ip_addr;             /* cluster IP */
    ULONG               cl_net_mask;            /* cluster mask */
    ULONG               cl_bcast_addr;          /* cluster broadcast IP */
    ULONG               cl_igmp_addr;           /* IGMP address for join messages */
    CVY_MAC_ADR         ded_mac_addr;           /* dedicated MAC V1.3.0b */
    CVY_MAC_ADR         cl_mac_addr;            /* cluster MAC V1.3.0b */

#if defined (NLB_MIXED_MODE_CLUSTERS)
    /* Added for migrating a cluster between different modes */
    CVY_MAC_ADR         unic_mac_addr;          /* unicast mac address */
    CVY_MAC_ADR         mult_mac_addr;          /* multicast mac address */
    CVY_MAC_ADR         igmp_mac_addr;          /* igmp mac address */

    BOOL                mac_addr_warned;        /* warn if the mac address is different */
#endif /* NLB_MIXED_MODE_CLUSTERS */

    /* event logging - prevent event log from filling with error messages */

    ULONG               actions_warned;
    ULONG               packets_warned;
    ULONG               bad_host_warned;
    ULONG               sync_warned;
    ULONG               send_msgs_warned;
    ULONG               dup_ded_ip_warned;      /* duplicate dedicated IP address */

    /* actions */

    LIST_ENTRY          sync_list[2];           /* list of actions for
                                                   Nic_sync_queue retry calls */
    NDIS_SPIN_LOCK      sync_lock;              /* corresponding lock */
    ULONG               cur_sync_list;          /* list for enqueueing new items */
    ULONG               num_sync_queued;        /* number of pending syncs */
    LIST_ENTRY          act_list;               /* list of allocated actions */
    NDIS_SPIN_LOCK      act_lock;               /* corresponding lock */
    PMAIN_ACTION        act_buf [CVY_MAX_ALLOCS];
                                                /* array of allocated sets of
                                                   actions */
    ULONG               num_action_allocs;      /* number of allocated action
                                                   sets */
    ULONG               act_size;

    /* #ps# -- ramkrish */
    NPAGED_LOOKASIDE_LIST resp_list;            /* list for main protocol field
                                                   to be allocated for ps */

    /* packets */

    NDIS_SPIN_LOCK      send_lock;              /* send packet lock */
    NDIS_HANDLE         send_pool_handle [CVY_MAX_ALLOCS];
                                                /* array of allocated sets of
                                                   send packet pools V1.1.2 */
    ULONG               num_send_packet_allocs; /* number of allocated send
                                                   packet pools */
    ULONG               cur_send_packet_pool;   /* current send pool to draw
                                                   packets from V1.3.2b */
    ULONG               num_sends_alloced;      /* number of send packets allocated */
    ULONG               num_sends_out;          /* number of send packets out */
    ULONG               send_allocing;          /* TRUE if some thread is allocing a send packet pool */
    NDIS_SPIN_LOCK      recv_lock;              /* receive packet lock */
    NDIS_HANDLE         recv_pool_handle [CVY_MAX_ALLOCS];
                                                /* array of allocated sets of
                                                   recv packet pools V1.1.2 */
    ULONG               num_recv_packet_allocs; /* number of allocated recv
                                                   packet pools */
    ULONG               cur_recv_packet_pool;   /* current recv pool to draw
                                                   packets from V1.3.2b */
    ULONG               num_recvs_alloced;      /* number of recv packets allocated */
    ULONG               num_recvs_out;          /* number of recv packets out */
    ULONG               recv_allocing;          /* TRUE if some thread is allocing a recv packet pool */

    /* buffers */

    NDIS_HANDLE         buf_pool_handle [CVY_MAX_ALLOCS];
                                                /* array of buffer descriptor
                                                   sets V1.3.2b */
    PUCHAR              buf_array [CVY_MAX_ALLOCS];
                                                /* array of buffer pools V1.3.2b */
    ULONG               buf_size;               /* buffer + descriptor size
                                                   V1.3.2b */
    ULONG               buf_mac_hdr_len;        /* length of full media header
                                                   V1.3.2b */
    LIST_ENTRY          buf_list;               /* list of buffers V1.3.2b */
    NDIS_SPIN_LOCK      buf_lock;               /* corresponding lock V1.3.2b */
    ULONG               num_buf_allocs;         /* number of allocated buffer
                                                   pools V1.3.2b */
    ULONG               num_bufs_alloced;       /* number of buffers allocated */
    ULONG               num_bufs_out;           /* number of buffers out */

    /* heartbeats */

    CVY_MEDIA_HDR       media_hdr;              /* filled-out media master header
                                                   for heartbeat messages */
    CVY_MEDIA_HDR       media_hdr_igmp;         /* filled-out media master header
                                                   for igmp messages. Need a separate one
						   since the EtherType will be different */
    MAIN_IGMP_FRAME     igmp_frame;             /* IGMP message */

    ULONG               etype_old;              /* ethernet type was set to
                                                   convoy compatibility value */
    LIST_ENTRY          frame_list;             /* list of heartbeat frames */
    NDIS_SPIN_LOCK      frame_lock;             /* corresponding lock */
    PMAIN_FRAME_DSCR    frame_dscrp;            /* heartbeat frame descriptors */
    NDIS_HANDLE         frame_pool_handle;      /* packet pool for heartbeats */
    NDIS_HANDLE         frame_buf_pool_handle;  /* buffer pool for heartbeats */

    /* remote control */

    LIST_ENTRY          rct_list;               /* list of pending requests */
    NDIS_SPIN_LOCK      rct_lock;               /* corresponding lock */
    ULONG               rct_last_addr;          /* source of last request */
    ULONG               rct_last_id;            /* last request epoch */

    /* V2.0.6 performance counters */

    ULONG               cntr_xmit_ok;
    ULONG               cntr_recv_ok;
    ULONG               cntr_xmit_err;
    ULONG               cntr_recv_err;
    ULONG               cntr_recv_no_buf;
    ULONGLONG           cntr_xmit_bytes_dir;
    ULONG               cntr_xmit_frames_dir;
    ULONGLONG           cntr_xmit_bytes_mcast;
    ULONG               cntr_xmit_frames_mcast;
    ULONGLONG           cntr_xmit_bytes_bcast;
    ULONG               cntr_xmit_frames_bcast;
    ULONGLONG           cntr_recv_bytes_dir;
    ULONG               cntr_recv_frames_dir;
    ULONGLONG           cntr_recv_bytes_mcast;
    ULONG               cntr_recv_frames_mcast;
    ULONGLONG           cntr_recv_bytes_bcast;
    ULONG               cntr_recv_frames_bcast;
    ULONG               cntr_recv_crc_err;
    ULONG               cntr_xmit_queue_len;

    /* sub-module contexts */

    TCPIP_CTXT          tcpip;                  /* TCP/IP handling context V1.1.1 */
    NDIS_SPIN_LOCK      load_lock;              /* load context lock */
    LOAD_CTXT           load;                   /* load processing context */
    PPING_MSG           load_msgp;              /* load ping message to send
                                                   out as heartbeat */

    /* Parameter contexts */ // ###### ramkrish
    CVY_PARAMS          params;
    ULONG               params_valid;
    ULONG               optimized_frags;

    // Name of the nic.  Used by Nic_announce and Nic_unannounce
    WCHAR       virtual_nic_name [CVY_MAX_VIRTUAL_NIC + 1];


#if 0
    NDIS_SPIN_LOCK      pending_lock;           /* for accessing pending packets */
    PNDIS_PACKET        pending_array [CVY_MAX_PENDING_PACKETS]; /* array of pending packets */
    ULONG               pending_count;          /* number of pending packets */
    ULONG               pending_first;          /* first pending packet */
    ULONG               pending_last;           /* last pending packet */
    ULONG               pending_access;         /* true if accessing the pending list */

    /* for tracking send filtering */
    ULONG               sends_in;
    ULONG               sends_filtered;
    ULONG               sends_completed;
    ULONG               arps_filtered;
    ULONG               mac_modified;
    ULONG               arps_count;
    ULONG               uninited_return;
#endif

    ULONG               adapter_id;

    WCHAR               log_msg_str [80];           /* This was added for log messages for nulti nic support */
}
MAIN_CTXT, * PMAIN_CTXT;


/* adapter context */ // ###### ramkrish
typedef struct
{
    ULONG               code;                   /* type checking code */
    USHORT              used;                   /* whether this element is in use or not */
    USHORT              inited;                 /* context has been initialized */
    USHORT              bound;                  /* convoy has been bound to the stack */
    USHORT              announced;              /* tcpip has been bound to convoy */
    PMAIN_CTXT          ctxtp;                  /* pointer to the context that is used */
//    NDIS_STRING         device_name;            /* stores the name of the adapter that we are binding to */
    ULONG               device_name_len;        /* length of the string allocated for the device name */
    PWSTR               device_name;            /* name of the device to which this context is bound */
}
MAIN_ADAPTER, * PMAIN_ADAPTER;


/* MACROS */


/* compute offset to protocol reserved space in the packet */

/* Set/retrieve the pointer to our private buffer, which we store in the 
   MiniportReserved field of an NDIS packet. */
#define MAIN_MINIPORT_FIELD(p) (*(PMAIN_PROTOCOL_RESERVED *) ((p) -> MiniportReserved))

#define MAIN_PROTOCOL_FIELD(p) ((PMAIN_PROTOCOL_RESERVED) ((p) -> ProtocolReserved))
#define MAIN_IMRESERVED_FIELD(p) ((PMAIN_PROTOCOL_RESERVED) ((p) -> IMReserved [0]))

/* If the current packet stack exists, then get the IMReserved pointer and return it if
   it is non-NULL - this is where we have stored / are storing our private data.   If it 
   NULL, or if the current packet stack is NULL, then we are either using ProtocolReserved
   or MiniportReserved, depending on whether this is in the send or receive path.  We 
   also make sure that there is a non-NULL pointer in MiniportReserved before returning
   it because CTRL packets, although they are allocated on the receive path, use Protocol
   Reserved. */
#define MAIN_RESP_FIELD(pkt, left, ps, rsp, send)   \
(ps) = NdisIMGetCurrentPacketStack((pkt), &(left)); \
if ((ps))                                           \
{                                                   \
    if (MAIN_IMRESERVED_FIELD((ps)))                \
        (rsp) = MAIN_IMRESERVED_FIELD((ps));        \
    else if ((send))                                \
        (rsp) = MAIN_PROTOCOL_FIELD((pkt));         \
    else if (MAIN_MINIPORT_FIELD((pkt)))            \
        (rsp) = MAIN_MINIPORT_FIELD((pkt));         \
    else                                            \
        (rsp) = MAIN_PROTOCOL_FIELD((pkt));         \
}                                                   \
else                                                \
{                                                   \
    if ((send))                                     \
        (rsp) = MAIN_PROTOCOL_FIELD((pkt));         \
    else if (MAIN_MINIPORT_FIELD((pkt)))            \
        (rsp) = MAIN_MINIPORT_FIELD((pkt));         \
    else                                            \
        (rsp) = MAIN_PROTOCOL_FIELD((pkt));         \
}

#define MAIN_PNP_DEV_ON(c)		((c)->nic_pnp_state == NdisDeviceStateD0 && (c)->prot_pnp_state == NdisDeviceStateD0 )


/* Global variables that are exported */
extern MAIN_ADAPTER            univ_adapters [CVY_MAX_ADAPTERS]; // ###### ramkrish
extern ULONG                   univ_adapters_count;

/* PROCEDURES */


extern NDIS_STATUS Main_init (
    PMAIN_CTXT          ctxtp);
/*
  Initialize context

  returns NDIS_STATUS:

  function:
*/


extern VOID Main_cleanup (
    PMAIN_CTXT          ctxtp);
/*
  Cleanup context

  returns VOID:

  function:
*/


extern ULONG   Main_arp_handle (
    PMAIN_CTXT          ctxtp,
    PARP_HDR            arp_hdrp,
    ULONG               len,            /* v2.0.6 */
    ULONG               send);
/*
  Process ARP packets

  returns ULONG  :
    TRUE  => accept
    FALSE => drop

  function:
*/


BOOLEAN   Main_ip_recv_filter(
    PMAIN_CTXT          ctxtp,
    const PIP_HDR       ip_hdrp,
    const PUCHAR        hdrp,
    ULONG               len,       
    IN OUT PULONG       pOperation);


BOOLEAN   Main_ip_send_filter(
    PMAIN_CTXT          ctxtp,
    const PIP_HDR       ip_hdrp,
    const PUCHAR        hdrp,
    ULONG               len,       
    IN OUT PULONG       pOperation);


extern ULONG   Main_recv_ping (
    PMAIN_CTXT          ctxtp,
    PMAIN_FRAME_HDR     cvy_hdrp);
/*
  Process heartbeat packets

  returns ULONG  :
    TRUE  => accept
    FALSE => drop

  function:
*/


extern PNDIS_PACKET Main_send (
    PMAIN_CTXT          ctxtp,
    PNDIS_PACKET        packetp,
    PULONG              exhausted);
/*
  Process outgoing packets

  returns PNDIS_PACKET:

  function:
*/


extern PNDIS_PACKET Main_recv (
    PMAIN_CTXT          ctxtp,
    PNDIS_PACKET        packetp);
/*
  Process incoming packets

  returns PNDIS_PACKET:

  function:
*/


extern PNDIS_PACKET Main_recv_indicate (
    PMAIN_CTXT          ctxtp,
    NDIS_HANDLE         handle,
    PUCHAR              look_buf,
    UINT                look_len,
    UINT                packet_len,
    PUCHAR              head_buf,
    UINT                head_len,
    PBOOLEAN            accept); /* For NT 5.1 - ramkrish */
/*
  Process incoming data indications

  returns PNDIS_PACKET:

  function:
*/


extern ULONG   Main_actions_alloc (
    PMAIN_CTXT              ctxtp);
/*
  Allocate additional actions

  returns ULONG  :
    TRUE  => success
    FALSE => failure

  function:
*/


extern ULONG   Main_bufs_alloc (
    PMAIN_CTXT              ctxtp);
/*
  Allocate additional buffers

  returns ULONG  :
    TRUE  => success
    FALSE => failure

  function:
*/


extern PNDIS_PACKET Main_frame_get (
    PMAIN_CTXT              ctxtp,
    ULONG                   send,
    PULONG                  len,
    USHORT                  frame_type);
/*
  Get a fresh heartbeat/igmp frame from the list

  returns PNDIS_PACKET:

  function:
*/


extern VOID Main_frame_put (
    PMAIN_CTXT              ctxtp,
    PNDIS_PACKET            packet,
    PMAIN_FRAME_DSCR        dscrp);
/*
  Return heartbeat frame to the list

  returns VOID:

  function:
*/


extern PMAIN_ACTION Main_action_get (
    PMAIN_CTXT              ctxtp);
/*
  Get a fresh action from the list

  returns PMAIN_ACTION:

  function:
*/


extern VOID Main_action_put (
    PMAIN_CTXT              ctxtp,
    PMAIN_ACTION            reqp);
/*
  Return action to the list

  returns VOID:

  function:
*/


extern VOID Main_action_slow_put (
    PMAIN_CTXT              ctxtp,
    PMAIN_ACTION            reqp);
/*
  Return action to the list using slow (non-DPC) locking

  returns VOID:

  function:
*/


extern PNDIS_PACKET Main_packet_alloc (
    PMAIN_CTXT              ctxtp,
    ULONG                   send,
    PULONG                  low);
/*
  Allocate a fresh packet from the pool

  returns PNDIS_PACKET:

  function:
*/


extern PNDIS_PACKET Main_packet_get (
    PMAIN_CTXT              ctxtp,
    PNDIS_PACKET            packet,
    ULONG                   send,
    USHORT                  group,
    ULONG                   len);
/*
  Get a fresh packet

  returns PNDIS_PACKET:

  function:
*/


extern PNDIS_PACKET Main_packet_put (
    PMAIN_CTXT              ctxtp,
    PNDIS_PACKET            packet,
    ULONG                   send,
    NDIS_STATUS             status);
/*
  Return packet to the pool

  returns PNDIS_PACKET:
    <linked packet>

  function:
*/



extern VOID Main_send_done (
    PVOID                   ctxtp,
    PNDIS_PACKET            packetp,
    NDIS_STATUS             status);
/*
  Heartbeat send completion routine

  returns VOID:

  function:
*/


extern VOID Main_xfer_done (
    PVOID                   ctxtp,
    PNDIS_PACKET            packetp,
    NDIS_STATUS             status,
    ULONG                   xferred);
/*
  Heartbeat data transfer completion routine

  returns VOID:

  function:
*/


extern VOID Main_ping (
    PMAIN_CTXT              ctxtp,
    PULONG                  tout);
/*
  Handle ping timeout

  returns VOID:

  function:
*/


extern PUCHAR Main_frame_parse (
    PMAIN_CTXT          ctxtp,
    PNDIS_PACKET        packetp,
    PUCHAR *            startp,     /* destination for the MAC header */
    ULONG               off,        /* offset from beginning of data - 0 means
                                       right after IP header */
    PUCHAR *            locp,       /* destination for the TCP/UDP/other header */
    PULONG              lenp,       /* length without media header */
    PUSHORT             sig,        /* signature from the MAC header */
    PUSHORT             group,      /* directed, multicast or broadcast */
    ULONG               send);
/*
  Parse packet extracting real pointers to specified offsets

  returns PUCHAR:
    <pointer to specified offset>

  function:
*/


extern PUCHAR Main_frame_find (
    PMAIN_CTXT          ctxtp,
    PUCHAR              head_buf,
    PUCHAR              look_buf,
    UINT                look_len,
    PUSHORT             sig);
/*
  Parse lookahead buffer finding pointer to payload offset

  returns PUCHAR:
    <pointer to payload>

  function:
*/


extern ULONG   Main_ip_addr_init (
    PMAIN_CTXT          ctxtp);
/*
  Convert IP strings in dotted notation to ulongs

  returns ULONG  :
    TRUE  => success
    FALSE => failure

  function:
*/


extern ULONG   Main_mac_addr_init (
    PMAIN_CTXT          ctxtp);
/*
  Convert MAC string in dashed notation to array of bytes

  returns ULONG  :
    TRUE  => success
    FALSE => failure

  function:
*/


extern ULONG   Main_igmp_init (
    PMAIN_CTXT          ctxtp,
    BOOLEAN             join);
/*
  Initialize the Ethernet frame and IP Packet to send out IGMP joins or leaves
  
  returns ULONG  :
    TRUE  => success
    FALSE => failure

  function:
*/

NDIS_STATUS Main_dispatch(
    PVOID                   DeviceObject,
    PVOID                   Irp);
/*
  Handle all requests
  
  returns NDIS_STATUS:
  
  function:
*/


extern NDIS_STATUS Main_ioctl (
    PVOID                   device, 
    PVOID                   irp_irp);
/*
  Handle IOCTL request

  returns NDIS_STATUS:

  function:
*/


extern NDIS_STATUS Main_ctrl (
    PMAIN_CTXT              ctxtp,
    ULONG                   io_ctrl_code,
    PIOCTL_CVY_BUF          bufp,
    PIOCTL_OPTIONS          optionsp);
/*
  Handle cluster operation control requests (local or remote)

  returns NDIS_STATUS:

  function:
*/


extern VOID Main_ctrl_recv (
    PMAIN_CTXT              ctxtp,
    PNDIS_PACKET            packet);
/*
  Handle remote control requests

  returns VOID:

  function:
*/


// ###### ramkrish
// code added for multiple nic support for looking up the array of elements

extern INT Main_adapter_alloc (
    PWSTR                   device_name);
/*
  Returns the first available adapter element.
  This function is called at bind time, when context is to be allocated for a
  new binding

  returns INT:
    -1                   : falied to allocate a new context for this binding
    0 - CVY_MAX_ADAPTERS : success

  function:
*/


extern INT Main_adapter_get (
    PWSTR                   device_name);
/*
  Look up an adapter that is bound to this device.

  returns:
    -1                   : adapter not found
    0 - CVY_MAX_ADAPTERS : success

  function:
*/


extern INT Main_adapter_put (
    PMAIN_ADAPTER           adapterp);
/*
  Look up an adapter that is bound to this device.

  returns:
    -1                   : adapter not found
    0 - CVY_MAX_ADAPTERS : success

  function:
*/


extern INT Main_adapter_selfbind (
    PWSTR                   device_name);
/*
  Finds if a ProtocolBind call is being made to ourself

  returns;
    -1                   : adapter not found
    0 - CVY_MAX_ADAPTERS : success

  function:
*/

#if defined (NLB_SESSION_SUPPORT)
/* shouse 4.30.01 - IOCTL implementation for connection UP/DOWN notifications. */
extern NDIS_STATUS Conn_notify_ctrl (PMAIN_CTXT ctxtp, ULONG fOptions, PIOCTL_CONN_NOTIFICATION pConn);
#endif

/* shouse 5.19.01 - IOCTL implementation for driver state queries. */
extern NDIS_STATUS Query_state_ctrl (PMAIN_CTXT ctxtp, ULONG fOptions, PIOCTL_QUERY_STATE pQuery);

#endif /* _Main_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\driver\main.c ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    main.c

Abstract:

    Windows Load Balancing Service (WLBS)
    Driver - packet handling

Author:

    kyrilf

--*/

#include <ndis.h>

#include "main.h"
#include "prot.h"
#include "nic.h"
#include "univ.h"
#include "wlbsip.h"
#include "util.h"
#include "load.h"
#include "wlbsparm.h"
#include "params.h"
#include "log.h"
#include "trace.h"

EXPORT
VOID
NdisIMCopySendPerPacketInfo(
	IN PNDIS_PACKET DstPacket,
	IN PNDIS_PACKET SrcPacket
	);

EXPORT
VOID
NdisIMCopySendCompletePerPacketInfo(
	IN PNDIS_PACKET DstPacket,
	PNDIS_PACKET SrcPacket
	);


//
// Internal functions
//
BOOLEAN Main_ApplyChangeWithoutReStart(PMAIN_CTXT ctxtp,
                                       CVY_PARAMS* pOldParams, 
                                       const CVY_PARAMS* pCurParam);
#if defined (SBH)
NDIS_STATUS Main_QueryPerf (
    PMAIN_CTXT              ctxtp,
    PCVY_DRIVER_PERF          pPerf);
#endif
    
/* GLOBALS */

MAIN_ADAPTER            univ_adapters [CVY_MAX_ADAPTERS]; // ###### ramkrish
ULONG                   univ_adapters_count = 0;

/* need this to bootstrap Main_ioctl since it will run without any context */

static PVOID                ioctrl_ctxtp;

static ULONG log_module_id = LOG_MODULE_MAIN;

/* The head of the BDA team list. */
PBDA_TEAM univ_bda_teaming_list = NULL;

/* PROCEDURES */

/*
 * Function: Main_alloc_team
 * Description: This function allocates and initializes a BDA_TEAM structure.
 * Parameters: ctxtp - a pointer to the MAIN_CTXT structure for this adapter
 * Returns: PBDA_TEAM - a pointer to a new BDA_TEAM structure if successful, NULL if not.
 * Author: shouse, 3.29.01
 * Notes: 
 */
PBDA_TEAM Main_alloc_team (IN PMAIN_CTXT ctxtp, IN PWSTR team_id) {
    PUCHAR      ptr;
    PBDA_TEAM   team;
    NDIS_STATUS status;

    UNIV_PRINT(("Main_alloc_team:  Entering..."));

    /* Allocate a BDA_TEAM structure. */
    status = NdisAllocateMemoryWithTag(&ptr, sizeof(BDA_TEAM), UNIV_POOL_TAG);
    
    if (status != NDIS_STATUS_SUCCESS) {
        UNIV_PRINT(("Main_alloc_team:  Unable to allocate a team.  Exiting..."));
        LOG_MSG2(MSG_ERROR_MEMORY, MSG_NONE, sizeof(BDA_TEAM), status);
        return NULL;
    }

    /* Make sure that ptr actually points to something. */
    ASSERT(ptr);

    /* Zero the memory out. */
    NdisZeroMemory(ptr, sizeof(BDA_TEAM));

    /* Cast the new memory to a team pointer. */
    team = (PBDA_TEAM)ptr;

    /* Set the default field values.  This is redundant (since 
       we just called NdisZeroMemory), but whatever. */
    team->prev = NULL;
    team->next = NULL;
    team->load = NULL;
    team->load_lock = NULL;
    team->active = FALSE;
    team->membership_count = 0;
    team->membership_fingerprint = 0;
    team->membership_map = 0;
    team->consistency_map = 0;

    /* Copy the team ID into the team structure. */
    NdisMoveMemory(team->team_id, team_id, CVY_MAX_BDA_TEAM_ID * sizeof(WCHAR));

    UNIV_PRINT(("Main_alloc_team:  Exiting..."));

    return team;
}

/*
 * Function: Main_free_team
 * Description: This function frees the memory used by a BDA_TEAM.
 * Parameters: team - a pointer to the team to be freed.
 * Returns: Nothing.
 * Author: shouse, 3.29.01
 * Notes: 
 */
VOID Main_free_team (IN PBDA_TEAM team) {
 
    UNIV_PRINT(("Main_free_team:  Entering..."));

    /* Make sure that team actually points to something. */
    ASSERT(team);

    /* Free the memory that the team structure is using. */
    NdisFreeMemory((PUCHAR)team, sizeof(BDA_TEAM), 0);
    
    UNIV_PRINT(("Main_free_team:  Exiting..."));
}

/*
 * Function: Main_find_team
 * Description: This function searches the linked list of teams looking for
 *              a given team ID.  If team with the same ID is found, a pointer
 *              to that team is returned, otherwise NULL is returned to indicate
 *              that no such team exists.
 * Parameters: ctxtp - a pointer to the MAIN_CTXT structure for this team.
 *             team_id - a unicode string containing the team ID, which must be a GUID.
 * Returns: PBDA_TEAM - a pointer to the team if found, NULL otherwise.
 * Author: shouse, 3.29.01
 * Notes: This function should be called with the global teaming lock already acquired!!!
 */
PBDA_TEAM Main_find_team (IN PMAIN_CTXT ctxtp, IN PWSTR team_id) {
    NDIS_STRING existing_team;
    NDIS_STRING new_team;
    PBDA_TEAM   team;
    
    UNIV_PRINT(("Main_find_team:  Entering..."));

    /* Loop through all teams in the linked list.  If we find a matching
       team ID, return a pointer to the team; otherwise, return NULL. */
    for (team = univ_bda_teaming_list; team; team = team->next) {
        /* If we have a match, return a pointer to the team. */
        if (NdisEqualMemory((PVOID)team->team_id, (PVOID)team_id, sizeof(WCHAR) * CVY_MAX_BDA_TEAM_ID)) {
            UNIV_PRINT(("Main_find_team:  Team found.  Exiting..."));
            return team;
        }
    }

    UNIV_PRINT(("Main_find_team:  Team not found.  Exiting..."));

    return NULL;
}

/*
 * Function: Main_teaming_get_member_id
 * Description: This function assigns a team member a unique, zero-indexed integer ID, 
 *              which is used by the member as in index in a consistency bit map.  Each 
 *              member sets their bit in the consistecy bit map, based on heartbeat 
 *              observations, that is used by the master of the team to determine whether
 *              or not the team should be in an active state.
 * Parameters: team - a pointer to the team which the adapter is joining.
 *             id - out parameter to hold the new ID.
 * Returns: BOOLEAN - always TRUE now, but there may be a need to return failure in the future.
 * Author: shouse, 3.29.01
 * Notes: This function should be called with the team lock already acquired!!!
 */
BOOLEAN Main_teaming_get_member_id (IN PBDA_TEAM team, OUT PULONG id) {
    ULONG index;
    ULONG map;

    UNIV_PRINT(("Main_teaming_get_member_id:  Entering..."));

    /* Make sure that team actually points to something. */
    ASSERT(team);

    /* Make sure that ID actually points to something. */
    ASSERT(id);

    /* Loop through the membership map looking for the first reset bit.  Because members
       can come and go, this bit will not always be in the (num_membes)th position.  For 
       example, it is perfectly plausible for the membership_map to look like (binary)
       0000 0000 0000 0000 0000 0100 1110 0111, in which case the ID returned by this 
       function would be three. */
    for (index = 0, map = team->membership_map; 
         index <= CVY_BDA_MAXIMUM_MEMBER_ID, map; 
         index++, map >>= 1)
        if (!(map & 0x00000001)) break;

    /* We assert that the index must be less than the maximum number of adapters 
       (CVY_BDA_MAXIMUM_MEMBER_ID = CVY_MAX_ADAPTERS - 1). */
    ASSERT(index <= CVY_BDA_MAXIMUM_MEMBER_ID);

    /* Set the member ID. */
    *id = index;

    /* Set our bit in the membership map. */
    team->membership_map |= (1 << *id);

    /* Set our bit in the consistency map.  By default, we assume that this member
       is consistent and heartbeats on this adapter can deternmine otherwise. */
    team->consistency_map |= (1 << *id);

    UNIV_PRINT(("Main_teaming_get_member_id:  Exiting..."));

    /* We may have reason to fail this call in the future, but for now, we always succeed. */
    return TRUE;
}

/*
 * Function: Main_teaming_put_member_id
 * Description: This function is called when a member leaves its team, at which
 *              time its ID is put back into the ID pool.
 * Parameters: team - a pointer to the team which this adapter is leaving.
 *             id - the ID, which this function will reset before returning.
 * Returns: BOOLEAN - always TRUE now, but there may be a need to return failure in the future.
 * Author: shouse, 3.29.01
 * Notes: This function should be called with the team lock already acquired!!!
 */
BOOLEAN Main_teaming_put_member_id (IN PBDA_TEAM team, IN OUT PULONG id) {

    UNIV_PRINT(("Main_teaming_put_member_id:  Entering..."));

    /* Make sure that team actually points to something. */
    ASSERT(team);

    /* Make sure that ID actually points to something. */
    ASSERT(id);

    /* Reet our bit in the membership map.  This effectively prevents 
       us from influencing the active state of the team. */
    team->membership_map &= ~(1 << *id);

    /* Reet our bit in the consistency map. */
    team->consistency_map &= ~(1 << *id);

    /* Set the member ID back to an invalid value. */
    *id = CVY_BDA_INVALID_MEMBER_ID;

    UNIV_PRINT(("Main_teaming_put_member_id:  Exiting..."));

    /* We may have reason to fail this call in the future, but for now, we always succeed. */
    return TRUE;
}

/*
 * Function: Main_queue_team
 * Description: This fuction queues a team onto the global doubly-linked list of BDA teams
 *              (univ_bda_teaming_list).  Insertions always occur at the front of the list.
 * Parameters: team - a pointer to the team to queue onto the list.
 * Returns: Nothing.
 * Author: shouse, 3.29.01
 * Notes: This function should be called with the global teaming lock already acquired!!!
 */
VOID Main_queue_team (IN PBDA_TEAM team) {

    UNIV_PRINT(("Main_queue_team:  Entering..."));

    /* Make sure that team actually points to something. */
    ASSERT(team);

    /* Insert at the head of the list by setting next to the current 
       head and pointing the global head pointer to the new team. */
    team->prev = NULL;
    team->next = univ_bda_teaming_list;
    univ_bda_teaming_list = team;

    /* If we are not the only team in the list, then we have to 
       set my successor's previous pointer to point to me. */
    if (team->next) team->next->prev = team;
    
    UNIV_PRINT(("Main_queue_team:  Exiting..."));
}

/*
 * Function: Main_dequeue_team
 * Description: This function removes a given team from the global doubly-linked 
 *              list of teams (univ_bda_teaming_list).
 * Parameters: team - a pointer to the team to remove from the list.
 * Returns: Nothing.
 * Author: shouse, 3.29.01
 * Notes: This function should be called with the global teaming lock already acquired!!!
 */
VOID Main_dequeue_team (IN PBDA_TEAM team) {

    UNIV_PRINT(("Main_dequeue_team:  Entering..."));

    /* Make sure that team actually points to something. */
    ASSERT(team);

    /* Special case when we are the first team in the list, in which case, we
       have no previous pointer and the head of the list needs to be reset. */
    if (!team->prev) {
        /* Point the global head of the list to the next team in the list, 
           which CAN be NULL, meaning that the list is now empty. */
        univ_bda_teaming_list = team->next;
        
        /* If there was a team after me in the list, who is now the new 
           head of the list, set its previous pointer to NULL. */
        if (team->next) team->next->prev = NULL;
    } else {
        /* Point the previous node's next pointer to my successor in the
           list, which CAN be NULL if I was the last team in the list. */
        team->prev->next = team->next;

        /* If there is a team after me in the list, point its previous 
           pointer to my predecessor. */
        if (team->next) team->next->prev = team->prev;
    }

    UNIV_PRINT(("Main_dequeue_team:  Exiting..."));
}

/*
 * Function: Main_get_team
 * Description: This function returns a team for the given team ID.  If the team already
 *              exists in the global teaming list, it is returned.  Otherwise, a new team
 *              is allocated, initialized and returned.  Before a team is returned, however,
 *              it is properly referenced by incrementing the reference count (membership_count),
 *              assigning a team member ID to the requestor and fingerprinting the team with
 *              the member's primary cluster IP address.
 * Parameters: ctxtp - a pointer to the MAIN_CTXT structure for this adapter.
 *             team_id - a unicode string (GUID) uniquely identifying the team to retrieve.
 * Returns: PBDA_TEAM - a pointer to the requested team.  NULL if it does not exists and
 *          a new team cannot be allocated, or if the team ID is invalid (empty).
 * Author: shouse, 3.29.01
 * Notes: This function should be called with the global teaming lock already acquired!!!
 */
PBDA_TEAM Main_get_team (IN PMAIN_CTXT ctxtp, IN PWSTR team_id) {
    PBDA_TEAM team;

    UNIV_PRINT(("Main_get_team:  Entering..."));

    /* Make sure that team_id actually points to something. */
    if (!team_id || team_id[0] == L'\0') {
        UNIV_PRINT(("Main_get_team:  Invalid parameter.  Exiting..."));
        return NULL;
    }

    /* Try to find a previous instance of this team in the global list.
       If we can't find it in the list, then allocate a new team. */
    if (!(team = Main_find_team(ctxtp, ctxtp->params.bda_teaming.team_id))) {
        /* Allocate and initialize a new team. */
        if (!(team = Main_alloc_team(ctxtp, ctxtp->params.bda_teaming.team_id))) {
            UNIV_PRINT(("Main_get_team:  Error attempting to allocate memory for a team.  Exiting..."));
            return NULL;
        }
     
        /* If a new team was allocated, insert it into the list. */
        Main_queue_team(team);
    }

    /* Increment the reference count on this team.  This reference count prevents
       a team from being destroyed while somebody is still using it. */
    team->membership_count++;

    /* Get a team member ID, which is my index into the consistency bit map. */
    Main_teaming_get_member_id(team, &ctxtp->bda_teaming.member_id);

    /* The fingerprint field is a cumulative XOR of all primary cluster IPs in the team.  We
       only use the two least significant bytes of the cluster IP, which, because the 
       cluster IP address is stored in host order, are the two most significant bytes. */    
    team->membership_fingerprint ^= ((ctxtp->cl_ip_addr >> 16) & 0x0000ffff);

    UNIV_PRINT(("Main_get_team:  Exiting..."));

    return team;
}

/*
 * Function: Main_put_team
 * Description: This function releases a reference on a team and frees the team if
 *              no references remain.  Dereferencing includes decrementing the 
 *              membership_count, releasing this member's ID and removing our
 *              fingerprint from the team.
 * Parameters: ctxtp - a pointer to the MAIN_CTXT structure for this adapter.
 *             team - a pointer to the team to dereference.
 * Returns: Nothing.
 * Author: shouse, 3.29.01
 * Notes: This function should be called with the global teaming lock already acquired!!!
 */
VOID Main_put_team (IN PMAIN_CTXT ctxtp, IN PBDA_TEAM team) {
    
    UNIV_PRINT(("Main_put_team:  Entering..."));

    /* Make sure that team actually points to something. */
    ASSERT(team);

    /* The fingerprint field is a cumulative XOR of all primary cluster IPs in the team.  
       We only use the two least significant bytes of the cluster IP, which, because the 
       cluster IP address is stored in host order, are the two most significant bytes. 
       Because a fingerprint is an XOR, the act of removing our fingerprint is the same
       as it was to add it - we simply XOR our primary cluster IP address to remove it. 
       ((NUM1 ^ NUM2) ^ NUM2) equals NUM1. */    
    team->membership_fingerprint ^= ((ctxtp->cl_ip_addr >> 16) & 0x0000ffff);

    /* Release our team member ID back into the free pool. */
    Main_teaming_put_member_id(team, &ctxtp->bda_teaming.member_id);

    /* Decrement the number of adapters in this team and remove and free the team 
       if this is the last reference on the team. */
    if (!--team->membership_count) {
        /* Remove the team from the list. */
        Main_dequeue_team(team);

        /* Free the memory used by the team. */
        Main_free_team(team);
    }

    UNIV_PRINT(("Main_put_team:  Exiting..."));
}

/*
 * Function: Main_teaming_check_consistency
 * Description: This function is called by all adapters during Main_ping, wherein
 *              the master of every team should check its team for consitency and
 *              mark the team active if it is consistent.  Teams are marked incon-
 *              sistent and inactive by the load module or when the master of an 
 *              existing team is removed.  Because on the master performs the con-
 *              sistency check in this function, a team without a master can NEVER
 *              be marked active.
 * Parameters: ctxtp - a pointer to the adapter's MAIN_CTXT structure.
 * Returns: Nothing
 * Author: shouse, 3.29.01
 * Notes: This function acquires the global teaming lock.
 */
VOID Main_teaming_check_consistency (IN PMAIN_CTXT ctxtp) {
    PBDA_TEAM team;

    /* We check whether or not we are teaming without grabbing the global teaming
       lock in an effort to minimize the common case - teaming is a special mode
       of operation that is only really useful in a clustered firewall scenario.
       So, if we aren't teaming, just bail out here; if we really aren't teaming,
       or are in the process of leaving a team, then no worries; if however, we were
       teaming or in the process of joining a team, then we'll just catch this
       the next time through.  If we do think we're teaming, then we'll go ahead
       and grab the global lock to make sure. */
    if (!ctxtp->bda_teaming.active) return;

    NdisAcquireSpinLock(&univ_bda_teaming_lock);

    /* If we actually aren't part of a team, bail out - nothing to do. */
    if (!ctxtp->bda_teaming.active) {
        NdisReleaseSpinLock(&univ_bda_teaming_lock);
        return;
    }

    /* If we aren't the master of our team, bail out - nothing to do.  
       Only the master can change the state of a team to active. */
    if (!ctxtp->bda_teaming.master) {
        NdisReleaseSpinLock(&univ_bda_teaming_lock);
        return;
    }

    /* Extract a pointer to my team. */
    team = ctxtp->bda_teaming.bda_team;

    /* Make sure that the team exists. */
    ASSERT(team);

    /* If all members of my team are consistent, then activate the team. */
    if (team->membership_map == team->consistency_map) {
        if (!team->active) {
            LOG_MSG(MSG_INFO_BDA_TEAM_REACTIVATED, MSG_NONE);
            team->active = TRUE;
        }
    }

    NdisReleaseSpinLock(&univ_bda_teaming_lock);
}

/*
 * Function: Main_teaming_ip_addr_change
 * Description: This function is called from Main_ip_addr_init when the primary
 *              cluster IP address of an adapter changes (potentially).  We need
 *              to recognize this to properly re-fingerprint the team.
 * Parameters: ctxtp - a pointer to the MAIN_CTXT structure for this adapter.
 *             old_ip - the old cluster IP addres (as a DWORD).
 *             new_ip - the new cluster IP address (as a DWORD).
 * Returns: Nothing.
 * Author: shouse, 3.29.01
 * Notes: This function acquires the global teaming lock.
 */
VOID Main_teaming_ip_addr_change (IN PMAIN_CTXT ctxtp, IN ULONG old_ip, IN ULONG new_ip) {
    PBDA_TEAM team;

    UNIV_PRINT(("Main_teaming_ip_addr_change:  Entering..."));

    NdisAcquireSpinLock(&univ_bda_teaming_lock);

    /* If we aren't part of a team, bail out - nothing to do.  Because this function is only
       called during a re-configuration, we won't worry about optimizing and not grabbing the 
       lock as is done in some of the hot paths. */
    if (!ctxtp->bda_teaming.active) {
        UNIV_PRINT(("Main_teaming_ip_addr_change:  This adapter is not part of a team.  Exiting..."));
        NdisReleaseSpinLock(&univ_bda_teaming_lock);
        return;
    }

    /* Grab a pointer to the team. */
    team = ctxtp->bda_teaming.bda_team;

    /* Make sure that team actually points to something. */
    ASSERT(team);

    /* Remove the old cluster IP address by undoing the XOR.  We only use the two
       least significant bytes of the cluster IP, which, because the cluster IP 
       address is stored in host order, are the two most significant bytes. */
    team->membership_fingerprint ^= ((old_ip >> 16) & 0x0000ffff);

    /* XOR with the new cluster IP address. We only use the two least
       significant bytes of the cluster IP, which, because the cluster IP 
       address is stored in host order, are the two most significant bytes. */
    team->membership_fingerprint ^= ((new_ip >> 16) & 0x0000ffff);

    NdisReleaseSpinLock(&univ_bda_teaming_lock);

    UNIV_PRINT(("Main_teaming_ip_addr_change:  Exiting..."));
}

/*
 * Function: Main_teaming_cleanup
 * Description: This function is called from Main_cleanup (or Main_teaming_init) to
 *              cleanup any teaming configuration that may exist on an adapter.  To
 *              do so, we cleanup our membership state and dereference the team. If
 *              we are the master for the team, however, we have to wait until there
 *              are no more references on our load module before allowing the operation
 *              to complete, because this might be called in the unbind path, in 
 *              which case, our load module would be going away.
 * Parameters: ctxtp - a pointer to the MAIN_CTXT structure for this adapter.
 * Returns: Nothing.
 * Author: shouse, 3.29.01
 * Notes: This function acquires the global teaming lock.
 */
VOID Main_teaming_cleanup (IN PMAIN_CTXT ctxtp) {
    PBDA_TEAM team;
    
    UNIV_PRINT(("Main_teaming_cleanup:  Entering..."));

    NdisAcquireSpinLock(&univ_bda_teaming_lock);

    /* If we aren't part of a team, bail out - nothing to do. */
    if (!ctxtp->bda_teaming.active) {
        UNIV_PRINT(("Main_teaming_cleanup:  This adapter is not part of a team.  Exiting..."));
        NdisReleaseSpinLock(&univ_bda_teaming_lock);
        return;
    }

    /* Inactivate teaming on this adapter.  This will cause other entities like the 
       load module and send/receive paths to stop thinking in teaming mode. */
    ctxtp->bda_teaming.active = FALSE;    

    /* Grab a pointer to the team. */
    team = ctxtp->bda_teaming.bda_team;

    /* Make sure that team actually points to something. */
    ASSERT(team);

    /* If we are the master for this team, make sure that all references to our load
       module have been released and then remove our load information from the team. */
    if (ctxtp->bda_teaming.master) {
        /* Mark the team as inactive - a team cannot function without a master.  Members
           of an inactive team will NOT accept packets and therefore will not reference
           our load module further while we wait for the reference count to go to zero. */
        team->active = FALSE;
        
        NdisReleaseSpinLock(&univ_bda_teaming_lock);

        /* No need to worry - the team pointer cannot go away even though we don't have 
           the lock acquired; we have a reference on the team until we call Main_put_team. */
        while (Load_get_reference_count(team->load)) {
            UNIV_PRINT(("Main_teaming_cleanup:  Sleeping...\n"));

            /* Sleep while there are references on our load module. */
            Nic_sleep(10);
        }

        NdisAcquireSpinLock(&univ_bda_teaming_lock);   

        /* Remove the pointer to my load module.  We wait until now to prevent another 
           adapter from joining the team claiming to be the master until we are done
           waiting for references on our load module to go away. */
        team->load = NULL;
        team->load_lock = NULL;

        /* If we have just left a team without a master, log an event to notify
           the user that a team cannot function without a designated master. */
        LOG_MSG(MSG_INFO_BDA_MASTER_LEAVE, MSG_NONE);
    }

    /* Reset the teaming context (member_id is set and reset by Main_get(put)_team). */
    ctxtp->bda_teaming.reverse_hash = 0;
    ctxtp->bda_teaming.master = 0;
        
    /* Remove the pointer to the team structure. */
    ctxtp->bda_teaming.bda_team = NULL;

    /* Decrements the reference count and frees the team if necessary. */
    Main_put_team(ctxtp, team);

    NdisReleaseSpinLock(&univ_bda_teaming_lock);

    UNIV_PRINT(("Main_teaming_cleanup:  Exiting..."));

    return;
}

/*
 * Function: Main_teaming_init
 * Description: This function is called by either Main_init or Main_ctrl to re-initialize
 *              the teaming confguration on this adapter.  If the new teaming configuration,
 *              which is stored in ctxtp->params is the same as the current configuration, 
 *              then we don't need to bother.  Otherwise, if we are already part of a team,
 *              we begin by cleaning up that state, which may unnecssary in some cases, but
 *              it makes things simpler and more straight-forward, so we'll live with it.  
 * Parameters: ctxtp - a pointer to the MAIN_CTXT structure for this adapter. 
 * Returns: BOOLEAN - TRUE if successful, FALSE if unsuccessful.
 * Author: shouse, 3.29.01
 * Notes: This function acquires the global teaming lock.
 */
BOOLEAN Main_teaming_init (IN PMAIN_CTXT ctxtp) {
    PBDA_TEAM team;
    
    UNIV_PRINT(("Main_teaming_init:  Entering..."));

    NdisAcquireSpinLock(&univ_bda_teaming_lock);

    /* If the parameters are invalid, do nothing. */
    if (!ctxtp->params_valid) {
        UNIV_PRINT(("Main_teaming_init:  Parameters are invalid.  Exiting..."));
        NdisReleaseSpinLock(&univ_bda_teaming_lock);
        return TRUE;
    }

    /* Check to see if the state of teaming has changed.  If we were actively teaming 
       before and we are still part of a team, then we may be able to get out of here
       without disturbing anything, if the rest of the configuration hasn't changed. */
    if (ctxtp->bda_teaming.active == ctxtp->params.bda_teaming.active) { 
        if (ctxtp->bda_teaming.active) {
            /* Make sure that I have a pointer to my team. */
            ASSERT(ctxtp->bda_teaming.bda_team);

            /* If all other teaming parameters are unchanged, then we can bail out 
               because no  part of the teaming configuration changed. */
            if ((ctxtp->bda_teaming.master == ctxtp->params.bda_teaming.master) &&
                (ctxtp->bda_teaming.reverse_hash == ctxtp->params.bda_teaming.reverse_hash) &&
                NdisEqualMemory((PVOID)ctxtp->bda_teaming.bda_team->team_id, (PVOID)ctxtp->params.bda_teaming.team_id, sizeof(WCHAR) * CVY_MAX_BDA_TEAM_ID)) {
                NdisReleaseSpinLock(&univ_bda_teaming_lock);
                return TRUE;
            }
        } else {
            /* If I wasn't teaming before, and I'm not teaming now, there's nothing for me to do. */
            NdisReleaseSpinLock(&univ_bda_teaming_lock);
            return TRUE;
        }
    }

    /* If this adapter is already in a team, cleanup first.  At this point, we know that 
       some part of the teaming configuration has changed, so we'll cleanup our old state
       if we need to and then re-build it with the new parameters if necessary. */
    if (ctxtp->bda_teaming.active) {
        UNIV_PRINT(("Main_teaming_init:  This adapter is already part of a team."));

        NdisReleaseSpinLock(&univ_bda_teaming_lock);

        /* Cleanup our old teaming state first. */
        Main_teaming_cleanup(ctxtp);

        NdisAcquireSpinLock(&univ_bda_teaming_lock);
    } 

    /* If, according to the new configuration, this adapter is not part of a team, do nothing. */
    if (!ctxtp->params.bda_teaming.active) {
        UNIV_PRINT(("Main_teaming_init:  This adapter is not part of a team.  Exiting..."));
        ctxtp->bda_teaming.member_id = CVY_BDA_INVALID_MEMBER_ID;
        NdisReleaseSpinLock(&univ_bda_teaming_lock);
        return TRUE;
    }

    /* Try to find a previous instance of this team.  If the team does not
       exist, Main_get_team will allocate, intialize and reference a new team. */
    if (!(team = Main_get_team(ctxtp, ctxtp->params.bda_teaming.team_id))) {
        UNIV_PRINT(("Main_teaming_init:  Error attempting to allocate memory for a team.  Exiting..."));
        NdisReleaseSpinLock(&univ_bda_teaming_lock);
        return FALSE;
    }

    /* If we are supposed to be the master for this team, we need to make sure that the
       team doesn't already have a master, and if so, setup the shared load context. */
    if (ctxtp->params.bda_teaming.master) {
        /* If we are supposed to be the master for this team, check for an existing master. */
        if (team->load) {
            /* If the load pointer is set, then this team already has a master. */
            UNIV_PRINT(("Main_teaming_init:  This team already has a master.  Exiting..."));

            LOG_MSG(MSG_INFO_BDA_MULTIPLE_MASTERS, MSG_NONE);

            /* Release our reference on this team. */
            Main_put_team(ctxtp, team);

            NdisReleaseSpinLock(&univ_bda_teaming_lock);

            return FALSE;            
        } else {
            /* Otherwise, we are it.  Set the global load state pointers
               to our load module and load lock. */
            team->load = &ctxtp->load;
            team->load_lock = &ctxtp->load_lock;

            /* If all members of my team are consistent, then activate the team. */
            if (team->membership_map == team->consistency_map) team->active = TRUE;

            /* Log the fact that a master has now been assigned to this team. */
            LOG_MSG(MSG_INFO_BDA_MASTER_JOIN, MSG_NONE);
        }
    }

    /* If we have just joined a team without a master, log an event to notify
       the user that a team cannot function without a designated master. */
    if (!team->load) {
        LOG_MSG(MSG_INFO_BDA_NO_MASTER, MSG_NONE);
    }

    /* Store a pointer to the team in the adapter's teaming context. */
    ctxtp->bda_teaming.bda_team = team;

    /* Copy the teaming configuration from the parameters into the teaming context. */
    ctxtp->bda_teaming.master = ctxtp->params.bda_teaming.master;
    ctxtp->bda_teaming.reverse_hash = ctxtp->params.bda_teaming.reverse_hash;
    ctxtp->bda_teaming.active = TRUE;

    NdisReleaseSpinLock(&univ_bda_teaming_lock);

    UNIV_PRINT(("Main_teaming_init:  Exiting..."));

    return TRUE;
}

/*
 * Function: Main_teaming_acquire_load
 * Description: This function determines which load module a particular adapter should be unsing,
 *              sets the appropriate pointers, and references the appropriate load module.  If an
 *              adapter is not part of a BDA team, then it should always be using its own load
 *              module - in that case, this function does nothing.  If the adapter is part of a 
 *              team, but the team in inactive, we return FALSE to indicate that the adapter should
 *              not accept this packet - inactive teams drop all traffic except traffic to the DIP.  
 *              If the adapter is part of an active team, then we set the load and lock pointers to
 *              point to the team's master load state and appropriately set the reverse hashing
 *              indication based on the parameter setting for this adapter.  In this scenario, which
 *              creates a cross-adapter load reference, we reference the master's load module so
 *              that it doesn't go away while we are using a pointer to it. 
 * Parameters: member - a pointer to the teaming member information for this adapter.
 *             ppLoad - an out pointer to a pointer to a load module set appropriately upon exit.
 *             ppLock - an out pointer to a pointer to a load lock set appropriately upon exit.
 *             pbTeaming - an out pointer to a boolean that we set if this adapter is teaming.
 *             pbReverse - an out pointer to a boolean that we set if this adapter is teaming.
 * Returns: BOOLEAN - an indication of whether or not this packet is refused (TRUE = drop it).
 * Author: shouse, 3.29.01
 * Notes: This function acquires the global teaming lock.
 */
BOOLEAN Main_teaming_acquire_load (IN PBDA_MEMBER member, OUT PLOAD_CTXT * ppLoad, OUT PNDIS_SPIN_LOCK * ppLock, OUT BOOLEAN * pbTeaming, OUT ULONG * pbReverse) {
    
    NdisAcquireSpinLock(&univ_bda_teaming_lock);
    
    /* Assert that the team membership information actually points to something. */
    ASSERT(member);

    /* Assert that the load pointer and the pointer to the load pointer actually point to something. */
    ASSERT(ppLoad && *ppLoad);

    /* Assert that the lock pointer and the pointer to the lock pointer actually point to something. */
    ASSERT(ppLock && *ppLock);

    /* Assert that the reverse hashing pointer actually points to something. */
    ASSERT(pbReverse);

    /* Assert that the teaming pointer actually points to something. */
    ASSERT(pbTeaming);

    /* If we are an active BDA team participant, check the team state to see whether we
       should accept this packet and fill in the load module/configuration parameters. */
    if (member->active) {
        PBDA_TEAM team = member->bda_team;
        
        /* Assert that the team actually points to something. */
        ASSERT(team);
        
        /* If the team is inactive, we will not handle this packet. */
        if (!team->active) {
            NdisReleaseSpinLock(&univ_bda_teaming_lock);
            return TRUE;
        }
        
        /* Otherwise, tell the caller to use the team's load lock and module. */
        *ppLoad = team->load;
        *ppLock = team->load_lock;
        
        /* Fill in the reverse-hashing flag and tell the caller that it is indeed teaming. */
        *pbReverse = member->reverse_hash;
        *pbTeaming = TRUE;        

        /* In the case of cross-adapter load module reference, add a reference to 
           the load module we are going to use to keep it from disappering on us. */
        Load_add_reference(*ppLoad);
    }
    
    NdisReleaseSpinLock(&univ_bda_teaming_lock);

    return FALSE;
}

/*
 * Function: Main_teaming_release_load
 * Description: This function releases a reference to a load module if necessary.  If we did not
 *              acquire this load module pointer in teaming mode, then this is unnessary.  Other-
 *              wise, we need to decrement the count, now that we are done using the pointer.
 * Parameters: pLoad - a pointer to the load module to dereference.
 *             pLock - a pointer to the load lock corresponding to the load module pointer (unused).
 *             bTeaming - a boolean indication of whether or not we acquired this pointer in teaming mode.
 * Returns: Nothing.
 * Author: shouse, 3.29.01
 * Notes: 
 */
VOID Main_teaming_release_load (IN PLOAD_CTXT pLoad, IN PNDIS_SPIN_LOCK pLock, IN BOOLEAN bTeaming) {
    
    /* Assert that the load pointer actually points to something. */
    ASSERT(pLoad);

    /* Assert that the lock pointer actually points to something. */
    ASSERT(pLock);

    /* If this load module was referenced, remove the reference. */
    if (bTeaming) Load_release_reference(pLoad);
}

/*
 * Function: Main_packet_check
 * Description: This function is, for all intents and purposed, a teaming-aware wrapper
 *              around Load_packet_check.  It determines which load module to utilize,
 *              based on the BDA teaming configuration on this adapter.  Adapters that
 *              are not part of a team continue to use their own load modules (Which is
 *              BY FAR, the most common case).  Adapters that are part of a team will
 *              use the load context of the adapter configured as the team's master as
 *              long as the team is in an active state.  In such as case, because of 
 *              the cross-adapter referencing of load modules, the reference count on
 *              the master's load module is incremented to keep it from "going away"
 *              while another team member is using it.  When a team is marke inactive,
 *              which is the result of a misconfigured team either on this host or 
 *              another host in the cluster, the adapter handles NO traffic that would
 *              require the use of a load module.  Other traffic, such as traffic to 
 *              the DIP, or RAW IP traffic, is allowed to pass.
 * Parameters: ctxtp - a pointer to the MAIN_CTXT structure for this adapter.
 *             svr_addr - the server IP address (source IP on send, destination IP on recv).
 *             svr_port - the server port (source port on send, destination port on recv).
 *             clt_addr - the client IP address (detination IP on send, source IP on recv).
 *             clt_port - the client port (destination port on send, source port on recv).
 *             protocol - the protocol for this packet. 
 *             pbRefused - an out parameter to indicate whether BDA teaming has refused service.
 *             bFilterTeamingOnly - TRUE indicates that this packet should be filtered only if BDA teaming.
 * Returns: BOOLEAN - indication of whether or not to accept the packet.
 * Author: shouse, 3.29.01
 * Notes: 
 */
__inline BOOLEAN Main_packet_check (PMAIN_CTXT ctxtp, 
                                    ULONG      svr_addr, 
                                    ULONG      svr_port, 
                                    ULONG      clt_addr, 
                                    ULONG      clt_port, 
                                    USHORT     protocol, 
                                    BOOLEAN *  pbRefused, 
                                    BOOLEAN    bFilterTeamingOnly) 
{
    /* For BDA teaming, initialize load pointer, lock pointer, reverse hashing flag and teaming flag
       assuming that we are not teaming.  Main_teaming_acquire_load will change them appropriately. */
    PLOAD_CTXT      pLoad = &ctxtp->load;
    PNDIS_SPIN_LOCK pLock = &ctxtp->load_lock;
    ULONG           bReverse = FALSE;
    BOOLEAN         bTeaming = FALSE;
    BOOLEAN         acpt = TRUE;

    /* We check whether or not we are teaming without grabbing the global teaming
       lock in an effort to minimize the common case - teaming is a special mode
       of operation that is only really useful in a clustered firewall scenario.
       So, if we don't think we're teaming, don't bother to check for sure, just
       use our own load module and go with it - in the worst case, we handle a
       packet we perhaps shouldn't have while we were joining a team or changing
       our current team configuration. */
    if (ctxtp->bda_teaming.active) {
        /* Check the teaming configuration and add a reference to the load module before consulting the load 
           module.  If the return value is TRUE, then the load module was NOT referenced, so we can bail out. */
        *pbRefused = Main_teaming_acquire_load(&ctxtp->bda_teaming, &pLoad, &pLock, &bTeaming, &bReverse);
    
        /* If teaming has suggested that we not allow this packet to pass, dump it. */
        if (*pbRefused) return FALSE;
    }
    
    if (!bTeaming && bFilterTeamingOnly) {
        /* If we are only supposed to filter this packet if we are in a BDA team,
           then if we are not, we can just return TRUE now to indicate that it is
           OK to allow the packet to pass. */
        return TRUE;
    }

    NdisAcquireSpinLock(pLock);
    
    /* If this adapter is reverse hashing, then simply flip the source and 
       destination IP addresses and ports when sending them to the load module. */
    if (bReverse)
        acpt = Load_packet_check(pLoad, clt_addr, clt_port, svr_addr, svr_port, protocol, bTeaming);
    else
        acpt = Load_packet_check(pLoad, svr_addr, svr_port, clt_addr, clt_port, protocol, bTeaming);
    
    NdisReleaseSpinLock(pLock);  
    
    /* Release the reference on the load module if necessary.  If we aren't teaming, even in 
       the case we skipped calling Main_teaming_Acquire_load_module above bTeaming is FALSE, 
       so there is no need to call this function to release a reference. */
    if (bTeaming) Main_teaming_release_load(pLoad, pLock, bTeaming);

    return acpt;
}

/*
 * Function: Main_conn_advise
 * Description: This function is, for all intents and purposed, a teaming-aware wrapper
 *              around Load_conn_advise.  It determines which load module to utilize,
 *              based on the BDA teaming configuration on this adapter.  Adapters that
 *              are not part of a team continue to use their own load modules (Which is
 *              BY FAR, the most common case).  Adapters that are part of a team will
 *              use the load context of the adapter configured as the team's master as
 *              long as the team is in an active state.  In such as case, because of 
 *              the cross-adapter referencing of load modules, the reference count on
 *              the master's load module is incremented to keep it from "going away"
 *              while another team member is using it.  When a team is marke inactive,
 *              which is the result of a misconfigured team either on this host or 
 *              another host in the cluster, the adapter handles NO traffic that would
 *              require the use of a load module.  Other traffic, such as traffic to 
 *              the DIP, or RAW IP traffic, is allowed to pass. 
 * Parameters: ctxtp - a pointer to the MAIN_CTXT structure for this adapter.
 *             svr_addr - the server IP address (source IP on send, destination IP on recv).
 *             svr_port - the server port (source port on send, destination port on recv).
 *             clt_addr - the client IP address (detination IP on send, source IP on recv).
 *             clt_port - the client port (destination port on send, source port on recv).
 *             protocol - the protocol for this packet. 
 *             conn_status - the TCP flag in this packet - SYN (UP), FIN (DOWN) or RST (RESET).
 *             pbRefused - an out parameter to indicate whether BDA teaming has refused service.
 *             bFilterTeamingOnly - TRUE indicates that this packet should be filtered only if BDA teaming.
 * Returns: BOOLEAN - indication of whether or not to accept the packet.
 * Author: shouse, 3.29.01
 * Notes: 
 */
__inline BOOLEAN Main_conn_advise (PMAIN_CTXT ctxtp, 
                                   ULONG      svr_addr, 
                                   ULONG      svr_port, 
                                   ULONG      clt_addr, 
                                   ULONG      clt_port,
                                   USHORT     protocol, 
                                   ULONG      conn_status, 
                                   BOOLEAN *  pbRefused, 
                                   BOOLEAN    bFilterTeamingOnly) 
{
    /* For BDA teaming, initialize load pointer, lock pointer, reverse hashing flag and teaming flag
       assuming that we are not teaming.  Main_teaming_acquire_load will change them appropriately. */
    PLOAD_CTXT      pLoad = &ctxtp->load;
    PNDIS_SPIN_LOCK pLock = &ctxtp->load_lock;
    ULONG           bReverse = FALSE;
    BOOLEAN         bTeaming = FALSE;
    BOOLEAN         acpt = TRUE;

    /* We check whether or not we are teaming without grabbing the global teaming
       lock in an effort to minimize the common case - teaming is a special mode
       of operation that is only really useful in a clustered firewall scenario.
       So, if we don't think we're teaming, don't bother to check for sure, just
       use our own load module and go with it - in the worst case, we handle a
       packet we perhaps shouldn't have while we were joining a team or changing
       our current team configuration. */
    if (ctxtp->bda_teaming.active) {
        /* Check the teaming configuration and add a reference to the load module before consulting the load 
           module.  If the return value is TRUE, then the load module was NOT referenced, so we can bail out. */
        *pbRefused = Main_teaming_acquire_load(&ctxtp->bda_teaming, &pLoad, &pLock, &bTeaming, &bReverse);
        
        /* If teaming has suggested that we not allow this packet to pass, dump it. */
        if (*pbRefused) return FALSE;
    }
    
    if (!bTeaming && bFilterTeamingOnly) {
        /* If we are only supposed to filter this packet if we are in a BDA team,
           then if we are not, we can just return TRUE now to indicate that it is
           OK to allow the packet to pass. */
        return TRUE;
    }

    NdisAcquireSpinLock(pLock);
    
    /* If this adapter is reverse hashing, then simply flip the source and 
       destination IP addresses and ports when sending them to the load module. */
    if (bReverse)
        acpt = Load_conn_advise(pLoad, clt_addr, clt_port, svr_addr, svr_port, protocol, conn_status, bTeaming);
    else
        acpt = Load_conn_advise(pLoad, svr_addr, svr_port, clt_addr, clt_port, protocol, conn_status, bTeaming);
    
    NdisReleaseSpinLock(pLock);  
    
    /* Release the reference on the load module if necessary.  If we aren't teaming, even in 
       the case we skipped calling Main_teaming_Acquire_load_module above, bTeaming is FALSE, 
       so there is no need to call this function to release a reference. */
    if (bTeaming) Main_teaming_release_load(pLoad, pLock, bTeaming);

    return acpt;
}

/*
 * Function: Main_create_dscr
 * Description: This function is, for all intents and purposed, a teaming-aware wrapper
 *              around Loas_create_dscr.  It determines which load module to utilize,
 *              based on the BDA teaming configuration on this adapter.  Adapters that
 *              are not part of a team continue to use their own load modules (Which is
 *              BY FAR, the most common case).  Adapters that are part of a team will
 *              use the load context of the adapter configured as the team's master as
 *              long as the team is in an active state.  In such as case, because of 
 *              the cross-adapter referencing of load modules, the reference count on
 *              the master's load module is incremented to keep it from "going away"
 *              while another team member is using it.  When a team is marke inactive,
 *              which is the result of a misconfigured team either on this host or 
 *              another host in the cluster, the adapter handles NO traffic that would
 *              require the use of a load module.  Other traffic, such as traffic to 
 *              the DIP, or RAW IP traffic, is allowed to pass.  This function creates
 *              a connection descriptor in the load module without consulting load-
 *              balancing state - it is simply a direction, on an outgoing TCP SYN, for
 *              the load module to create state.  Under the restrictions placed on port
 *              rules in bi-directional affinity teaming, if we create this descriptor
 *              on the outbound path, we can guarantee that connections originating on
 *              this NLB host ALWAYS return to this host, even if convergence has
 *              occurred.
 * Parameters: ctxtp - a pointer to the MAIN_CTXT structure for this adapter.
 *             svr_addr - the server IP address (source IP on send, destination IP on recv).
 *             svr_port - the server port (source port on send, destination port on recv).
 *             clt_addr - the client IP address (detination IP on send, source IP on recv).
 *             clt_port - the client port (destination port on send, source port on recv).
 *             protocol - the protocol for this packet. 
 *             pbRefused - an out parameter to indicate whether BDA teaming has refused service.
 *             bFilterTeamingOnly - TRUE indicates that this packet should be filtered only if BDA teaming.
 * Returns: BOOLEAN - indication of whether or not to accept the packet (based on the success of descriptor creation).
 * Author: shouse, 3.29.01
 * Notes: 
 */
__inline BOOLEAN Main_create_dscr (PMAIN_CTXT ctxtp, 
                                   ULONG      svr_addr, 
                                   ULONG      svr_port, 
                                   ULONG      clt_addr,
                                   ULONG      clt_port, 
                                   USHORT     protocol,
                                   BOOLEAN *  pbRefused, 
                                   BOOLEAN    bFilterTeamingOnly) 
{
    /* For BDA teaming, initialize load pointer, lock pointer, reverse hashing flag and teaming flag
       assuming that we are not teaming.  Main_teaming_acquire_load will change them appropriately. */
    PLOAD_CTXT      pLoad = &ctxtp->load;
    PNDIS_SPIN_LOCK pLock = &ctxtp->load_lock;
    ULONG           bReverse = FALSE;
    BOOLEAN         bTeaming = FALSE;
    BOOLEAN         acpt = TRUE;

    /* We check whether or not we are teaming without grabbing the global teaming
       lock in an effort to minimize the common case - teaming is a special mode
       of operation that is only really useful in a clustered firewall scenario.
       So, if we don't think we're teaming, don't bother to check for sure, just
       use our own load module and go with it - in the worst case, we handle a
       packet we perhaps shouldn't have while we were joining a team or changing
       our current team configuration. */
    if (ctxtp->bda_teaming.active) {
        /* Check the teaming configuration and add a reference to the load module before consulting the load module.  
           If the return value is TRUE, then the load module was NOT referenced, so we can bail out. */
        *pbRefused = Main_teaming_acquire_load(&ctxtp->bda_teaming, &pLoad, &pLock, &bTeaming, &bReverse);
        
        /* If teaming has suggested that we not allow this packet to pass, dump it. */
        if (*pbRefused) return FALSE;
    }    

    if (!bTeaming && bFilterTeamingOnly) {
        /* If we are only supposed to filter this packet if we are in a BDA team,
           then if we are not, we can just return TRUE now to indicate that it is
           OK to allow the packet to pass. */
        return TRUE;
    }

    /* If we are in a BDA team, then we want to create a descriptor for an outgoing SYN. */
    NdisAcquireSpinLock(pLock);
    
    /* If this adapter is reverse hashing, then simply flip the source and 
       destination IP addresses and ports when sending them to the load module. */
    if (bReverse)
        acpt = Load_create_dscr(pLoad, clt_addr, clt_port, svr_addr, svr_port, protocol, bTeaming);
    else
        acpt = Load_create_dscr(pLoad, svr_addr, svr_port, clt_addr, clt_port, protocol, bTeaming);
    
    NdisReleaseSpinLock(pLock);  
    
    /* Release the reference on the load module if necessary.  If we aren't teaming, even in 
       the case we skipped calling Main_teaming_Acquire_load_module above, bTeaming is FALSE, 
       so there is no need to call this function to release a reference. */
    if (bTeaming) Main_teaming_release_load(pLoad, pLock, bTeaming);

    return acpt;
}

/* 
 * Function: Main_query_packet_filter
 * Desctription:
 * Parameters:
 * Returns:
 * Author: shouse, 5.18.01
 * Notes:
 */
VOID Main_query_packet_filter (PMAIN_CTXT ctxtp, PIOCTL_QUERY_STATE_PACKET_FILTER pQuery)
{
    /* For BDA teaming, initialize load pointer, lock pointer, reverse hashing flag and teaming flag
       assuming that we are not teaming.  Main_teaming_acquire_load will change them appropriately. */
    PLOAD_CTXT      pLoad = &ctxtp->load;
    PNDIS_SPIN_LOCK pLock = &ctxtp->load_lock;
    ULONG           bReverse = FALSE;
    BOOLEAN         bTeaming = FALSE;
    BOOLEAN         bRefused = FALSE;
    BOOLEAN         acpt = TRUE;
    
    /* NOTE: This entire operation assumes RECEIVE path semantics - most outgoing traffic
       is not filtered by NLB anyway, so there isn't much need to query send filtering. */

    /* First check for remote control packets, which are always UDP and are always allowed to pass. */
    if (pQuery->Protocol == TCPIP_PROTOCOL_UDP) {
        /* If the client UDP port is the remote control port, then this is a remote control 
           response from another NLB cluster host.  These are always allowed to pass. */
        if (pQuery->ClientPort == ctxtp->params.rct_port || pQuery->ClientPort == CVY_DEF_RCT_PORT_OLD) {
            pQuery->Results.Accept = NLB_ACCEPT_REMOTE_CONTROL_RESPONSE;
            return; 
        /* Otherwise, if the server UDP port is the remote control port, then this is an incoming
           remote control request from another NLB cluster host.  These are always allowed to pass. */
        } else if (pQuery->ServerPort == ctxtp->params.rct_port || pQuery->ServerPort == CVY_DEF_RCT_PORT_OLD) {
            pQuery->Results.Accept = NLB_ACCEPT_REMOTE_CONTROL_REQUEST;
            return;            
        }
    }

    /* Check for traffic destined for the dedicated IP address of this host, or to the cluster
       or dedicated broadcast IP addresses.  These packets are always allowed to pass. */
    if (pQuery->ServerIPAddress == ctxtp->ded_ip_addr || pQuery->ServerIPAddress == ctxtp->ded_bcast_addr || pQuery->ServerIPAddress == ctxtp->cl_bcast_addr) {
        pQuery->Results.Accept = NLB_ACCEPT_DIP_OR_BROADCAST;
        return;
    }
    
    /* Check for passthru packets.  When the cluster IP address has not been specified, the
       cluster moves into passthru mode, in which it passes up ALL packets received. */
    if (ctxtp->cl_ip_addr == 0) {
        pQuery->Results.Accept = NLB_ACCEPT_PASSTHRU_MODE;
        return;
    }
    
    /* If the cluster is not operational, which can happen, for example as a result of a wlbs.exe
       command such as "wlbs stop", or as a result of bad parameter settings, then drop all traffic 
       that does not meet the above conditions. */
    if (!ctxtp->convoy_enabled) {
        pQuery->Results.Accept = NLB_REJECT_CLUSTER_STOPPED;
        return;
    }
    
    /* We check whether or not we are teaming without grabbing the global teaming
       lock in an effort to minimize the common case - teaming is a special mode
       of operation that is only really useful in a clustered firewall scenario.
       So, if we don't think we're teaming, don't bother to check for sure, just
       use our own load module and go with it - in the worst case, we handle a
       packet we perhaps shouldn't have while we were joining a team or changing
       our current team configuration. */
    if (ctxtp->bda_teaming.active) {
        /* Check the teaming configuration and add a reference to the load module before consulting the load 
           module.  If the return value is TRUE, then the load module was NOT referenced, so we can bail out. */
        bRefused = Main_teaming_acquire_load(&ctxtp->bda_teaming, &pLoad, &pLock, &bTeaming, &bReverse);
        
        /* If teaming has suggested that we not allow this packet to pass, the cluster will
           drop it.  This occurs when teams are inconsistently configured, or when a team is
           without a master, in which case there is no load context to consult anyway. */
        if (bRefused) {
            pQuery->Results.Accept = NLB_REJECT_BDA_TEAMING_REFUSED;
            return;
        }
    }

    NdisAcquireSpinLock(pLock);
    
    /* If this adapter is reverse hashing, then simply flip the source and destination IP addresses 
       and ports when sending them to the load module.  This function will run the NLB hashing 
       algorithm using the provided IP tuple and protocol information and fill in the query buffer
       with appropriate hashing and connection descriptor information. */
    if (bReverse)
        Load_query_packet_filter(pQuery, pLoad, pQuery->ClientIPAddress, pQuery->ClientPort, pQuery->ServerIPAddress, pQuery->ServerPort, pQuery->Protocol, bTeaming);
    else
        Load_query_packet_filter(pQuery, pLoad, pQuery->ServerIPAddress, pQuery->ServerPort, pQuery->ClientIPAddress, pQuery->ClientPort, pQuery->Protocol, bTeaming);

    NdisReleaseSpinLock(pLock);  
    
    /* Release the reference on the load module if necessary.  If we aren't teaming, even in 
       the case we skipped calling Main_teaming_Acquire_load_module above, bTeaming is FALSE, 
       so there is no need to call this function to release a reference. */
    if (bTeaming) Main_teaming_release_load(pLoad, pLock, bTeaming);
}

ULONG   Main_ip_addr_init (
    PMAIN_CTXT          ctxtp)
{
    ULONG               byte [4];
    ULONG               i;
    PWCHAR              tmp;
    ULONG               old_ip_addr;


    /* initialize dedicated IP address from the register string */

    tmp = ctxtp -> params . ded_ip_addr;
    ctxtp -> ded_ip_addr  = 0;

    /* do not initialize if one was not specified */

    if (tmp [0] == 0)
        goto ded_netmask;

    for (i = 0; i < 4; i ++)
    {
        if (! Univ_str_to_ulong (byte + i, tmp, & tmp, 3, 10) ||
            (i < 3 && * tmp != L'.'))
        {
            UNIV_PRINT (("bad dedicated IP address"));
            LOG_MSG (MSG_WARN_DED_IP_ADDR, ctxtp -> params . ded_ip_addr);
            ctxtp -> ded_net_mask = 0;
            goto ded_netmask;
        }

        tmp ++;
    }

    IP_SET_ADDR (& ctxtp -> ded_ip_addr, byte [0], byte [1], byte [2], byte [3]);

    UNIV_PRINT  (("Dedicated IP address: %d.%d.%d.%d = %x", byte [0], byte [1], byte [2], byte [3], ctxtp -> ded_ip_addr));

ded_netmask:

    /* initialize dedicated net mask from the register string */

    tmp = ctxtp -> params . ded_net_mask;
    ctxtp -> ded_net_mask = 0;

    /* do not initialize if one was not specified */

    if (tmp [0] == 0)
        goto cluster;

    for (i = 0; i < 4; i ++)
    {
        if (! Univ_str_to_ulong (byte + i, tmp, & tmp, 3, 10) ||
            (i < 3 && * tmp != L'.'))
        {
            UNIV_PRINT (("bad dedicated net mask address"));
            LOG_MSG (MSG_WARN_DED_NET_MASK, ctxtp -> params . ded_net_mask);
            ctxtp -> ded_ip_addr = 0;
            goto cluster;
        }

        tmp ++;
    }

    IP_SET_ADDR (& ctxtp -> ded_net_mask, byte [0], byte [1], byte [2], byte [3]);

    UNIV_PRINT  (("Dedicated net mask: %d.%d.%d.%d = %x", byte [0], byte [1], byte [2], byte [3], ctxtp -> ded_net_mask));

cluster:

    /* initialize cluster IP address from the register string */

    tmp = ctxtp -> params . cl_ip_addr;

    /* Save the previous cluster IP address to notify bi-directional affinity teaming. */
    old_ip_addr = ctxtp -> cl_ip_addr;

    ctxtp -> cl_ip_addr = 0;

    for (i = 0; i < 4; i ++)
    {
        if (! Univ_str_to_ulong (byte + i, tmp, & tmp, 3, 10) ||
            (i < 3 && * tmp != L'.'))
        {
            UNIV_PRINT (("bad cluster IP address"));
            LOG_MSG (MSG_ERROR_CL_IP_ADDR, ctxtp -> params . cl_ip_addr);
            ctxtp -> cl_net_mask = 0;
            return FALSE;
        }

        tmp ++;
    }

    IP_SET_ADDR (& ctxtp -> cl_ip_addr, byte [0], byte [1], byte [2], byte [3]);

    UNIV_PRINT  (("Cluster IP address: %d.%d.%d.%d = %x", byte [0], byte [1], byte [2], byte [3], ctxtp -> cl_ip_addr));

    /* Notify BDA teaming config that a cluster IP address might have changed. */
    Main_teaming_ip_addr_change(ctxtp, old_ip_addr, ctxtp->cl_ip_addr);

    /* initialize cluster net mask from the register string */

    tmp = ctxtp -> params . cl_net_mask;
    ctxtp -> cl_net_mask = 0;

    /* do not initialize if one was not specified */

    for (i = 0; i < 4; i ++)
    {
        if (! Univ_str_to_ulong (byte + i, tmp, & tmp, 3, 10) ||
            (i < 3 && * tmp != L'.'))
        {
            UNIV_PRINT (("bad cluster net mask address"));
            LOG_MSG (MSG_ERROR_CL_NET_MASK, ctxtp -> params . cl_net_mask);
            return FALSE;
        }

        tmp ++;
    }

    IP_SET_ADDR (& ctxtp -> cl_net_mask, byte [0], byte [1], byte [2], byte [3]);

    UNIV_PRINT  (("Cluster net mask: %d.%d.%d.%d = %x", byte [0], byte [1], byte [2], byte [3], ctxtp -> cl_net_mask));

    if (ctxtp -> params . mcast_support && ctxtp -> params . igmp_support)
    {
	/* Initialize the multicast IP address for IGMP support */

	tmp = ctxtp -> params . cl_igmp_addr;
	ctxtp -> cl_igmp_addr = 0;

	/* do not initialize if one was not specified */

	for (i = 0; i < 4; i ++)
	{
	    if (! Univ_str_to_ulong (byte + i, tmp, & tmp, 3, 10) ||
		(i < 3 && * tmp != L'.'))
            {
		UNIV_PRINT (("bad cluster net mask address"));
//		LOG_MSG (MSG_ERROR_CL_NET_MASK, ctxtp -> params . cl_igmp_addr); // is this required since it is checked in the APIs?
		return FALSE;
	    }

	    tmp ++;
	}

	IP_SET_ADDR (& ctxtp -> cl_igmp_addr, byte [0], byte [1], byte [2], byte [3]);

	UNIV_PRINT  (("Cluster IGMP Address: %d.%d.%d.%d = %x", byte [0], byte [1], byte [2], byte [3], ctxtp -> cl_igmp_addr));
    }

    if ((ctxtp -> ded_ip_addr != 0 && ctxtp -> ded_net_mask == 0) ||
        (ctxtp -> ded_ip_addr == 0 && ctxtp -> ded_net_mask != 0))
    {
        UNIV_PRINT (("need to specify both dedicated IP address AND network mask"));
        LOG_MSG (MSG_WARN_DED_MISMATCH, MSG_NONE);
        ctxtp -> ded_ip_addr = 0;
        ctxtp -> ded_net_mask = 0;
    }

    IP_SET_BCAST (& ctxtp -> cl_bcast_addr, ctxtp -> cl_ip_addr, ctxtp -> cl_net_mask);
    UNIV_PRINT  (("Cluster broadcast address: %d.%d.%d.%d = %x", ctxtp -> cl_bcast_addr & 0xff, (ctxtp -> cl_bcast_addr >> 8) & 0xff, (ctxtp -> cl_bcast_addr >> 16) & 0xff, (ctxtp -> cl_bcast_addr >> 24) & 0xff, ctxtp -> cl_bcast_addr));

    if (ctxtp -> ded_ip_addr != 0)
    {
        IP_SET_BCAST (& ctxtp -> ded_bcast_addr, ctxtp -> ded_ip_addr, ctxtp -> ded_net_mask);
        UNIV_PRINT  (("Dedicated broadcast address: %d.%d.%d.%d = %x", ctxtp -> ded_bcast_addr & 0xff, (ctxtp -> ded_bcast_addr >> 8) & 0xff, (ctxtp -> ded_bcast_addr >> 16) & 0xff, (ctxtp -> ded_bcast_addr >> 24) & 0xff, ctxtp -> ded_bcast_addr));
    }
    else
        ctxtp -> ded_bcast_addr = 0;

    if (ctxtp -> cl_ip_addr == 0)
    {
        UNIV_PRINT (("Cluster IP address = 0. Cluster host stopped"));
        return FALSE;
    }

    return TRUE;

} /* end Main_ip_addr_init */


ULONG   Main_mac_addr_init (
    PMAIN_CTXT          ctxtp)
{
    ULONG               i, b, len;
    PUCHAR              ap;
    PWCHAR              tmp;
    PUCHAR              srcp, dstp;
    ULONG               non_zero = 0;
    CVY_MAC_ADR         old_mac_addr;

    /* remember old mac address so we can yank it out of the multicast list */

    old_mac_addr = ctxtp->cl_mac_addr;

    /* at the time this routine is called by Prot_bind - ded_mad_addr is
       already set */

    tmp = ctxtp -> params . cl_mac_addr;
    len = CVY_MAC_ADDR_LEN (ctxtp -> medium);

    ap = (PUCHAR) & ctxtp -> cl_mac_addr;

    for (i = 0; i < len; i ++)
    {
        /* setup destination broadcast and source cluster addresses */

        if (! Univ_str_to_ulong (& b, tmp, & tmp, 2, 16) ||
            (i < len - 1 && * tmp != L'-' && * tmp != L':'))
        {
            UNIV_PRINT (("bad cluster network address"));
            LOG_MSG (MSG_ERROR_NET_ADDR, ctxtp -> params . cl_mac_addr);

            /* WLBS 2.3 prevent from failing if no MAC address - just use the
               dedicated one as cluster */

            NdisMoveMemory (& ctxtp -> cl_mac_addr, & ctxtp -> ded_mac_addr, len);
            non_zero = 1;
            break;
        }

        tmp ++;
        ap [i] = (UCHAR) b;

        /* WLBS 2.3 sum up bytes for future non-zero check */

        non_zero += b;
    }

    /* WLBS 2.3 - use dedicated address as cluster address if specified address
       is zero - this could be due to parameter errors */

    if (non_zero == 0)
        NdisMoveMemory (& ctxtp -> cl_mac_addr, & ctxtp -> ded_mac_addr, len);

    /* enforce group flag to proper value */

    if (ctxtp -> params . mcast_support)
        ap [0] |= ETHERNET_GROUP_FLAG;
    else
        ap [0] &= ~ETHERNET_GROUP_FLAG;

    if (ctxtp -> medium == NdisMedium802_3)
    {
        dstp = ctxtp -> media_hdr . ethernet . dst . data;
        srcp = ctxtp -> media_hdr . ethernet . src . data;
        len = ETHERNET_ADDRESS_FIELD_SIZE;

        CVY_ETHERNET_ETYPE_SET (& ctxtp -> media_hdr . ethernet, MAIN_FRAME_SIG);
    }

    ctxtp -> etype_old = FALSE;

    /* V1.3.1b - load multicast address as destination instead of broadcast */

    for (i = 0; i < len; i ++)
    {
        if (ctxtp -> params . mcast_support)
            dstp [i] = ap [i];
        else
            dstp [i] = 0xff;

        srcp [i] = ((PUCHAR) & ctxtp -> ded_mac_addr) [i];

    }

    if (! ctxtp -> params . mcast_support)
    {
        /* V2.0.6 - override source MAC address to prevent switch confusion */

        if (ctxtp -> params . mask_src_mac)
        {
            CVY_MAC_ADDR_LAA_SET (ctxtp -> medium, srcp);

            * ((PUCHAR) (srcp + 1)) = (UCHAR) ctxtp -> params . host_priority;
            * ((PULONG) (srcp + 2)) = ctxtp -> cl_ip_addr;
        }

        /* make source address look difference than our dedicated to prevent
           Compaq drivers from optimizing their reception out */

        else
            CVY_MAC_ADDR_LAA_TOGGLE (ctxtp -> medium, srcp);
    }

#if defined (NLB_MIXED_MODE_CLUSTERS)
    PUCHAR              s,d;

    len = CVY_MAC_ADDR_LEN (ctxtp -> medium);
    /* derive the unicast mac address */
    s = (PUCHAR) (& (ctxtp -> unic_mac_addr));
    s[0]  = 0x02;
    s[1]  = 0xbf;
    s[2]  = (UCHAR) (ctxtp -> cl_ip_addr & 0xff);
    s[3]  = (UCHAR) ((ctxtp -> cl_ip_addr & 0xff00) >> 8);
    s[4]  = (UCHAR) ((ctxtp -> cl_ip_addr & 0xff0000) >> 16);
    s[5]  = (UCHAR) ((ctxtp -> cl_ip_addr & 0xff000000) >> 24);

    /* derive the multicast mac address */
    NdisMoveMemory ( & ctxtp -> mult_mac_addr, & ctxtp -> unic_mac_addr, len);
    d = (PUCHAR) (& (ctxtp -> mult_mac_addr));
    d[0]  = 0x03;

    /* derive the igmp mac address */
    NdisMoveMemory ( & ctxtp -> igmp_mac_addr, & ctxtp -> unic_mac_addr, len);
    d = (PUCHAR) (& (ctxtp -> igmp_mac_addr));
    d[0]  = 0x01;
    d[1]  = 0x00;
    d[2]  = 0x5e;
    d[3]  = 0x7f;

    CVY_MAC_ADDR_PRINT (ctxtp -> medium, "Unicast mac address: ", (PUCHAR) & ctxtp -> unic_mac_addr);
    CVY_MAC_ADDR_PRINT (ctxtp -> medium, "Multicast mac address: ", (PUCHAR) & ctxtp -> mult_mac_addr);
    CVY_MAC_ADDR_PRINT (ctxtp -> medium, "IGMP mac address: ", (PUCHAR) & ctxtp -> igmp_mac_addr);
#endif /* NLB_MIXED_MODE_CLUSTERS */

    CVY_MAC_ADDR_PRINT (ctxtp -> medium, "Cluster network address: ", ap);
    CVY_MAC_ADDR_PRINT (ctxtp -> medium, "Dedicated network address: ", srcp);

    /* Load cluster address as multicast one to the NIC.  If the cluster IP address 0.0.0.0, then we
       don't want to add the multicast MAC address to the NIC - we retain the current MAC address. */
    if (ctxtp -> params . mcast_support && ctxtp -> params . cl_ip_addr != 0)
    {
        ULONG               xferred;
        ULONG               needed;
        PNDIS_REQUEST       request;
        MAIN_ACTION         act;
        PUCHAR              ptr;
        NDIS_STATUS         status;
        ULONG               size, i, len;


        len = CVY_MAC_ADDR_LEN (ctxtp->medium);
        size = ctxtp->max_mcast_list_size * len;

        status = NdisAllocateMemoryWithTag (& ptr, size, UNIV_POOL_TAG);

        if (status != NDIS_STATUS_SUCCESS)
        {
            UNIV_PRINT (("error allocating space %d %x", size, status));
            LOG_MSG2 (MSG_ERROR_MEMORY, MSG_NONE, size, status);
            return FALSE;
        }

        act . code  = MAIN_ACTION_CODE;
        act . ctxtp = ctxtp;
        request = & act . op . request . req;
        act . op . request . xferred = & xferred;
        act . op . request . needed  = & needed;

        /* get current mcast list */

        request -> RequestType = NdisRequestQueryInformation;

        if (ctxtp -> medium == NdisMedium802_3)
            request -> DATA . QUERY_INFORMATION . Oid = OID_802_3_MULTICAST_LIST;

        request -> DATA . QUERY_INFORMATION . InformationBufferLength = size;
        request -> DATA . QUERY_INFORMATION . InformationBuffer = ptr;

        status = Prot_request (ctxtp, & act, FALSE);

        if (status != NDIS_STATUS_SUCCESS)
        {
            UNIV_PRINT (("error %x querying multicast address list %d %d", status, xferred, needed));
            NdisFreeMemory (ptr, size, 0);
            return FALSE;
        }

        for (i = 0; i < xferred; i += len)
        {
            if (CVY_MAC_ADDR_COMP (ctxtp -> medium, (PUCHAR) ptr + i, & old_mac_addr))
            {
                UNIV_PRINT (("old cluster MAC matched"));
                CVY_MAC_ADDR_PRINT (ctxtp -> medium, "", & old_mac_addr);
                UNIV_PRINT (("copying new MAC into %dth entry in the multicast list", i));
                CVY_MAC_ADDR_PRINT (ctxtp -> medium, "", & ctxtp->cl_mac_addr);

                CVY_MAC_ADDR_COPY (ctxtp->medium, (PUCHAR) ptr + i, & ctxtp->cl_mac_addr);

                break;
            }
            else
                CVY_MAC_ADDR_PRINT (ctxtp -> medium, "", & ctxtp -> cl_mac_addr);
        }

        /* add MAC if not present */

        if (i >= xferred)
        {
            UNIV_PRINT (("adding new MAC"));
            CVY_MAC_ADDR_PRINT (ctxtp -> medium, "", & ctxtp->cl_mac_addr);

            if (xferred + len > size)
            {
                UNIV_PRINT (("no room for cluster mac %d", ctxtp->max_mcast_list_size));
                LOG_MSG1 (MSG_ERROR_MCAST_LIST_SIZE, L"", ctxtp->max_mcast_list_size);
                NdisFreeMemory (ptr, size, 0);
                return FALSE;
            }

            UNIV_PRINT (("copying new MAC into %dth entry in the multicast list", i));
            CVY_MAC_ADDR_PRINT (ctxtp -> medium, "", & ctxtp->cl_mac_addr);

            CVY_MAC_ADDR_COPY (ctxtp->medium, (PUCHAR) ptr + xferred, & ctxtp->cl_mac_addr);

            xferred += len;
        }

        request -> RequestType = NdisRequestSetInformation;

        if (ctxtp -> medium == NdisMedium802_3)
            request -> DATA . SET_INFORMATION . Oid = OID_802_3_MULTICAST_LIST;

        request -> DATA . SET_INFORMATION . InformationBufferLength = xferred;
        request -> DATA . SET_INFORMATION . InformationBuffer = ptr;

        status = Prot_request (ctxtp, & act, FALSE);

        if (status != NDIS_STATUS_SUCCESS)
        {
            UNIV_PRINT (("error %x setting multicast address %d %d", status, xferred, needed));
            NdisFreeMemory (ptr, size, 0);
            return FALSE;
        }

        NdisFreeMemory (ptr, size, 0);
    }

    return TRUE;

} /* end Main_mac_addr_init */


/* Initialize the Ethernet Header and IP packet for sending out IGMP joins/leaves */
ULONG Main_igmp_init (
    PMAIN_CTXT          ctxtp,
    BOOLEAN             join)
{
    PUCHAR              ptr;
    ULONG               checksum;
    PMAIN_IGMP_DATA     igmpd = & (ctxtp -> igmp_frame . igmp_data);
    PMAIN_IP_HEADER     iph  = & (ctxtp -> igmp_frame . ip_data);
    PUCHAR              srcp, dstp;
    UINT                i;


    if ((!ctxtp -> params . mcast_support) || (!ctxtp -> params . igmp_support))
	return FALSE;

    /* Fill in the igmp data */
    igmpd -> igmp_vertype = 0x12; /* Needs to be changed for join/leave */
    igmpd -> igmp_unused  = 0x00;
    igmpd -> igmp_xsum    = 0x0000;
    igmpd -> igmp_address = ctxtp -> cl_igmp_addr;

    /* Compute the IGMP checksum */
    ptr = (PUCHAR) igmpd;
    checksum = 0;

    for (i = 0; i < sizeof (MAIN_IGMP_DATA) / 2; i ++, ptr += 2)
        checksum += (ULONG) ((ptr [0] << 8) | ptr [1]);

    checksum = (checksum >> 16) + (checksum & 0xffff);
    checksum += (checksum >> 16);
    checksum  = (~ checksum);

    ptr = (PUCHAR) (& igmpd -> igmp_xsum);
    ptr [0] = (CHAR) ((checksum >> 8) & 0xff);
    ptr [1] = (CHAR) (checksum & 0xff);

    /* Fill in the IP Header */
    iph -> iph_verlen   = 0x45;
    iph -> iph_tos      = 0;
    iph -> iph_length   = 0x1c00;
    iph -> iph_id       = 0xabcd; /* Need to find the significance of this later */
    iph -> iph_offset   = 0;
    iph -> iph_ttl      = 0x1;
    iph -> iph_protocol = 0x2;
    iph -> iph_xsum     = 0x0;
    iph -> iph_src      = ctxtp -> cl_ip_addr;
    iph -> iph_dest     = ctxtp -> cl_igmp_addr;

    /* Compute the checksum for the IP header */
    checksum = Tcpip_chksum (& ctxtp -> tcpip, (PIP_HDR) iph, NULL, TCPIP_PROTOCOL_IP);
    IP_SET_CHKSUM ((PIP_HDR) iph, (USHORT) checksum);

    /* Fill in the ethernet header */
    if (ctxtp -> medium == NdisMedium802_3)
    {
        dstp = ctxtp -> media_hdr_igmp . ethernet . dst . data;
        srcp = ctxtp -> media_hdr_igmp . ethernet . src . data;

        CVY_ETHERNET_ETYPE_SET (& ctxtp -> media_hdr_igmp . ethernet, MAIN_IP_SIG);
    }

    CVY_MAC_ADDR_COPY (ctxtp -> medium, dstp, & ctxtp -> cl_mac_addr);
    CVY_MAC_ADDR_COPY (ctxtp -> medium, srcp, & ctxtp -> ded_mac_addr);

    return TRUE;

} /* end Main_igmp_init */


NDIS_STATUS Main_init (
    PMAIN_CTXT          ctxtp)
{
    ULONG               i, size;
    NDIS_STATUS         status;
    PMAIN_FRAME_DSCR    dscrp;

    /* hook the IRP_MJ_DEVICE_CONTROL entry point in order to catch user-mode
       requests to the driver. this is probably a hack, since there has to
       be an IOCTL to NDIS-installed handler that will cause our
       QueryInformationHandler to be called. could not find it in the
       documentation though */

    ioctrl_ctxtp = ctxtp;

#if 0
    univ_ioctl_hdlr = ((PDRIVER_OBJECT) univ_driver_ptr) -> MajorFunction [IRP_MJ_DEVICE_CONTROL];
    ((PDRIVER_OBJECT) univ_driver_ptr) -> MajorFunction [IRP_MJ_DEVICE_CONTROL] = Main_ioctl;
#endif

    /* V2.0.6 */

//    UNIV_ASSERT_VAL (sizeof (MAIN_PROTOCOL_RESERVED) <= 16, sizeof (MAIN_PROTOCOL_RESERVED));

    /* V1.3.2b */

    if (sizeof (PING_MSG) + sizeof (MAIN_FRAME_HDR) > ctxtp -> max_frame_size)
    {
        UNIV_PRINT (("ping message will not fit in the media frame %d > %d", sizeof (PING_MSG) + sizeof (MAIN_FRAME_HDR), ctxtp -> max_frame_size));
        LOG_MSG2 (MSG_ERROR_INTERNAL, MSG_NONE, sizeof (PING_MSG) + sizeof (MAIN_FRAME_HDR), ctxtp -> max_frame_size);
        goto error;
    }

    /* V2.0.6 initialize IP addresses - might be used in the Main_mac_addr_init
       so have to do it here */

    if (! Main_ip_addr_init (ctxtp))
    {
        ctxtp -> convoy_enabled = FALSE;
        ctxtp -> params_valid   = FALSE;
        UNIV_PRINT (("error initializing IP addresses"));
    }

    /* V1.3.1b parse cluster MAC address from parameters */

    if (! Main_mac_addr_init (ctxtp))
    {
        ctxtp -> convoy_enabled = FALSE;
        ctxtp -> params_valid   = FALSE;
        UNIV_PRINT (("error initializing cluster MAC address"));
    }

    /* Initialize IGMP message if in igmp mode */

    if (ctxtp -> params . mcast_support && ctxtp -> params . igmp_support)
    {
	if (! Main_igmp_init (ctxtp, TRUE))
	{
	    ctxtp -> convoy_enabled = FALSE;
	    ctxtp -> params_valid   = FALSE;
	    UNIV_PRINT (("error initializing IGMP message"));
	}

	UNIV_PRINT (("IGMP message initialized"));
    }

    /* can extract the send message pointer even if load is not inited yet V1.1.4 */

    ctxtp -> load_msgp = Load_snd_msg_get (& ctxtp -> load);

    /* initalize lists and locks */

    NdisInitializeListHead (& ctxtp -> sync_list[0]);
    NdisInitializeListHead (& ctxtp -> sync_list[1]);
    NdisInitializeListHead (& ctxtp -> act_list);
    NdisInitializeListHead (& ctxtp -> buf_list);
    NdisInitializeListHead (& ctxtp -> frame_list);
    NdisInitializeListHead (& ctxtp -> rct_list);

    NdisAllocateSpinLock (& ctxtp -> sync_lock);
    NdisAllocateSpinLock (& ctxtp -> act_lock);
    NdisAllocateSpinLock (& ctxtp -> buf_lock);
    NdisAllocateSpinLock (& ctxtp -> recv_lock);
    NdisAllocateSpinLock (& ctxtp -> send_lock);
    NdisAllocateSpinLock (& ctxtp -> frame_lock);
    NdisAllocateSpinLock (& ctxtp -> rct_lock);
    NdisAllocateSpinLock (& ctxtp -> load_lock);

    /* #ps# */
    NdisInitializeNPagedLookasideList (& ctxtp -> resp_list, NULL, NULL, 0,
                                       sizeof (MAIN_PROTOCOL_RESERVED),
                                       UNIV_POOL_TAG, 0);

    /* capture boot-time parameters */

    ctxtp -> num_packets   = ctxtp -> params . num_packets;
    ctxtp -> num_actions   = ctxtp -> params . num_actions;
    ctxtp -> num_send_msgs = ctxtp -> params . num_send_msgs;

#if 0
    /* ###### for tracking pending packets - ramkrish */
    NdisAllocateSpinLock (& ctxtp -> pending_lock);
    ctxtp -> pending_count  = 0;
    ctxtp -> pending_first  = 0;
    ctxtp -> pending_last   = 0;
    ctxtp -> pending_access = 0;

    /* ###### for tracking send filtering - ramkrish */
    ctxtp -> sends_in        = 0;
    ctxtp -> sends_completed = 0;
    ctxtp -> sends_filtered  = 0;
    ctxtp -> arps_filtered   = 0;
    ctxtp -> mac_modified    = 0;
    ctxtp -> arps_count      = 0;
    ctxtp -> uninited_return = 0;
#endif

    /* V1.1.1 - initalize other contexts */

    if (! Tcpip_init (& ctxtp -> tcpip, & ctxtp -> params))
    {
        UNIV_PRINT (("error initializing tcpip layer"));
        goto error;
    }

    UNIV_PRINT (("Initialized tcpip"));
    Load_init (& ctxtp -> load, & ctxtp -> params);
    UNIV_PRINT (("Initialized load"));

    /* don't try to init addresses if already encountered error - strings
       could be bad ! */

    if (ctxtp -> params_valid && ctxtp -> params . cluster_mode && ctxtp -> convoy_enabled)
    {
        UNIV_PRINT (("Main_init: calling load_start"));
        Load_start (& ctxtp -> load);
    }

    /* allocate actions */

    size = sizeof (MAIN_ACTION);
#ifdef _WIN64 // 64-bit -- ramkrish
    ctxtp -> act_size = (size & 0x7) ? (size + 8 - (size & 0x7) ) : size;
#else
    ctxtp -> act_size = size;
#endif

    if (! Main_actions_alloc (ctxtp))
        goto error;

    /* V1.3.2b - allocate buffers */

    ctxtp -> buf_mac_hdr_len = CVY_MAC_HDR_LEN (ctxtp -> medium);
    ctxtp -> buf_size = sizeof (MAIN_BUFFER) + ctxtp -> buf_mac_hdr_len +
                        ctxtp -> max_frame_size - 1;

    /* 64-bit -- ramkrish */
    UNIV_PRINT (("ctxtp -> buf_size = %d", ctxtp -> buf_size));
    size = ctxtp -> buf_size;
#ifdef _WIN64
    ctxtp -> buf_size = (size & 0x7) ? (size + 8 - (size & 0x7)) : size;
    UNIV_PRINT (("ctxtp -> buf_size = %d", ctxtp -> buf_size));
#else
    ctxtp -> buf_size = size;
#endif

    if (! Main_bufs_alloc (ctxtp))
        goto error;

    size = ctxtp -> num_packets;

    /* V1.1.2 - allocate packet pools */

    NdisAllocatePacketPool (& status, & (ctxtp -> send_pool_handle [0]),
                            ctxtp -> num_packets,
                            sizeof (MAIN_PROTOCOL_RESERVED));

    if (status != NDIS_STATUS_SUCCESS)
    {
        UNIV_PRINT (("error allocating send packet pool %d %x", size, status));
        LOG_MSG2 (MSG_ERROR_MEMORY, MSG_NONE, size, status);
        goto error;
    }

    ctxtp -> num_send_packet_allocs = 1;
    ctxtp -> cur_send_packet_pool   = 0;
    ctxtp -> num_sends_alloced = ctxtp->num_packets;

    NdisAllocatePacketPool (& status, & (ctxtp -> recv_pool_handle [0]),
                            ctxtp -> num_packets,
                            sizeof (MAIN_PROTOCOL_RESERVED));

    if (status != NDIS_STATUS_SUCCESS)
    {
        UNIV_PRINT (("error allocating recv packet pool %d %x", size, status));
        LOG_MSG2 (MSG_ERROR_MEMORY, MSG_NONE, size, status);
        goto error;
    }

    ctxtp -> num_recv_packet_allocs = 1;
    ctxtp -> cur_recv_packet_pool   = 0;
    ctxtp -> num_recvs_alloced = ctxtp->num_packets;

    /* allocate support for heartbeat ping messages */

    size = sizeof (MAIN_FRAME_DSCR) * ctxtp -> num_send_msgs;

    status = NdisAllocateMemoryWithTag (& ctxtp -> frame_dscrp, size,
                                        UNIV_POOL_TAG);

    if (status != NDIS_STATUS_SUCCESS)
    {
        UNIV_PRINT (("error allocating frame descriptors %d %x", size, status));
        LOG_MSG2 (MSG_ERROR_MEMORY, MSG_NONE, size, status);
        goto error;
    }

    size = ctxtp -> num_send_msgs;

    NdisAllocatePacketPool (& status, & ctxtp -> frame_pool_handle,
                            ctxtp -> num_send_msgs,
                            sizeof (MAIN_PROTOCOL_RESERVED));

    if (status != NDIS_STATUS_SUCCESS)
    {
        UNIV_PRINT (("error allocating ping packet pool %d %x", size, status));
        LOG_MSG2 (MSG_ERROR_MEMORY, MSG_NONE, size, status);
        goto error;
    }

    size = 5 * ctxtp -> num_send_msgs;

    NdisAllocateBufferPool (& status, & ctxtp -> frame_buf_pool_handle,
                            5 * ctxtp -> num_send_msgs);

    if (status != NDIS_STATUS_SUCCESS)
    {
        UNIV_PRINT (("error allocating ping buffer pool %d %x", size, status));
        LOG_MSG2 (MSG_ERROR_MEMORY, MSG_NONE, size, status);
        goto error;
    }

    for (i = 0; i < ctxtp -> num_send_msgs; i ++)
    {
        dscrp = & (ctxtp -> frame_dscrp [i]);

        if (ctxtp -> medium == NdisMedium802_3)
        {
            /* this buffer describes Ethernet MAC header */

            size = sizeof (CVY_ETHERNET_HDR);

            NdisAllocateBuffer (& status, & dscrp -> media_hdr_bufp,
                                ctxtp -> frame_buf_pool_handle,
                                & dscrp -> media_hdr . ethernet,
                                sizeof (CVY_ETHERNET_HDR));

            if (status != NDIS_STATUS_SUCCESS)
            {
                UNIV_PRINT (("error allocating ethernet header buffer %d %x", i, status));
                LOG_MSG3 (MSG_ERROR_MEMORY, MSG_NONE, i, size, status);
                goto error;
            }

            dscrp -> recv_len = 0;
        }

        dscrp -> recv_len += sizeof (MAIN_FRAME_HDR) + sizeof (PING_MSG);

        /* this buffer describes frame headers */

        size = sizeof (MAIN_FRAME_HDR);

        NdisAllocateBuffer (& status, & dscrp -> frame_hdr_bufp,
                            ctxtp -> frame_buf_pool_handle,
                            & dscrp -> frame_hdr,
                            sizeof (MAIN_FRAME_HDR));

        if (status != NDIS_STATUS_SUCCESS)
        {
            UNIV_PRINT (("error allocating frame header buffer %d %x", i, status));
            LOG_MSG3 (MSG_ERROR_MEMORY, MSG_NONE, i, size, status);
            return FALSE;
        }

        /* this buffer describes receive ping message buffer V1.1.4 */

        size = sizeof (PING_MSG);

        NdisAllocateBuffer (& status, & dscrp -> recv_data_bufp,
                            ctxtp -> frame_buf_pool_handle,
                            & dscrp -> msg,
                            sizeof (PING_MSG));

        if (status != NDIS_STATUS_SUCCESS)
        {
            UNIV_PRINT (("error allocating recv msg buffer %d %x", i, status));
            LOG_MSG3 (MSG_ERROR_MEMORY, MSG_NONE, i, size, status);
            return FALSE;
        }

        /* this buffer describes send ping message buffer V1.1.4 */
#if 0
        size = sizeof (PING_MSG);

        NdisAllocateBuffer (& status, & dscrp -> send_data_bufp,
                            ctxtp -> frame_buf_pool_handle,
                            ctxtp -> load_msgp,
                            sizeof (PING_MSG));

        if (status != NDIS_STATUS_SUCCESS)
        {
            UNIV_PRINT (("error allocating send msg buffer %d %x", i, status));
            LOG_MSG3 (MSG_ERROR_MEMORY, MSG_NONE, i, size, status);
            return FALSE;
        }
#endif
	dscrp -> send_data_bufp = NULL; /* Allocate this in Main_frame_get */

        NdisInterlockedInsertTailList (& ctxtp -> frame_list,
                                       & dscrp -> link,
                                       & ctxtp -> frame_lock);
    }

    /* Initialize the bi-directional affinity teaming if it has been configured. */
    if (!Main_teaming_init(ctxtp))
    {
        ctxtp -> convoy_enabled = FALSE;
        ctxtp -> params_valid   = FALSE;
        UNIV_PRINT (("error initializing bi-directional affinity teaming"));
    }

    UNIV_PRINT (("Initialized bi-directional affinity teaming"));        

    return NDIS_STATUS_SUCCESS;

error:

    Main_cleanup (ctxtp);

    return NDIS_STATUS_FAILURE;

} /* end Main_init */


VOID Main_cleanup (
    PMAIN_CTXT          ctxtp)
{
    ULONG               i, j;
    PMAIN_BUFFER        bp;


    /* V1.1.4 */

    /* #ps# */
    /* While using packet stacking, ensure that all packets are returned
     * before clearing up the context
     */

#if 0 // no longer needed, since Ndis will take care of this for us
    while (1)
    {
        NDIS_STATUS status;
        ULONG       count;

        status = NdisQueryPendingIOCount (ctxtp -> mac_handle, & count);
        if (status != NDIS_STATUS_SUCCESS || count == 0)
            break;

        Nic_sleep (10);
    }
#endif

    NdisDeleteNPagedLookasideList (& ctxtp -> resp_list);

    for (i = 0; i < CVY_MAX_ALLOCS; i ++)
    {
        if (ctxtp -> send_pool_handle [i] != NULL)
        {
            while (1)
            {
                if (NdisPacketPoolUsage (ctxtp -> send_pool_handle [i]) == 0)
                    break;

                Nic_sleep (10); /* wait for 10 milliseconds for the packets to be returned */
            }

            NdisFreePacketPool (ctxtp -> send_pool_handle [i]);
            ctxtp -> send_pool_handle [i] = NULL;
        }

        if (ctxtp -> recv_pool_handle [i] != NULL)
        {
            while (1)
            {
                if (NdisPacketPoolUsage (ctxtp -> recv_pool_handle [i]) == 0)
                    break;

                Nic_sleep (10); /* wait for 10 milliseconds for the packets to be returned */
            }

            NdisFreePacketPool (ctxtp -> recv_pool_handle [i]);
            ctxtp -> recv_pool_handle [i] = NULL;
        }

        if (ctxtp -> act_buf [i] != NULL)
            NdisFreeMemory (ctxtp -> act_buf [i],
                            ctxtp -> num_actions * ctxtp -> act_size, 0);

        /* V1.3.2b */

        if (ctxtp -> buf_array [i] != NULL)
        {
            for (j = 0; j < ctxtp -> num_packets; j ++)
            {
                bp = (PMAIN_BUFFER) (ctxtp -> buf_array [i] + j * ctxtp -> buf_size);

                if (bp -> full_bufp != NULL)
                {
                    NdisAdjustBufferLength (bp -> full_bufp,
                                            ctxtp -> buf_mac_hdr_len +
                                            ctxtp -> max_frame_size);
                    NdisFreeBuffer (bp -> full_bufp);
                }

                if (bp -> frame_bufp != NULL)
                {
                    NdisAdjustBufferLength (bp -> frame_bufp,
                                            ctxtp -> max_frame_size);
                    NdisFreeBuffer (bp -> frame_bufp);
                }
            }

            NdisFreeMemory (ctxtp -> buf_array [i],
                            ctxtp -> num_packets * ctxtp -> buf_size, 0);
        }

        if (ctxtp -> buf_pool_handle [i] != NULL)
            NdisFreeBufferPool (ctxtp -> buf_pool_handle [i]);
    }

    if (ctxtp -> frame_dscrp != NULL)
    {
        for (i = 0; i < ctxtp -> num_send_msgs; i ++)
        {
            if (ctxtp -> frame_dscrp [i] . media_hdr_bufp != NULL)
                NdisFreeBuffer (ctxtp -> frame_dscrp [i] . media_hdr_bufp);

            if (ctxtp -> frame_dscrp [i] . frame_hdr_bufp != NULL)
                NdisFreeBuffer (ctxtp -> frame_dscrp [i] . frame_hdr_bufp);

            if (ctxtp -> frame_dscrp [i] . send_data_bufp != NULL)
                NdisFreeBuffer (ctxtp -> frame_dscrp [i] . send_data_bufp);

            if (ctxtp -> frame_dscrp [i] . recv_data_bufp != NULL)
                NdisFreeBuffer (ctxtp -> frame_dscrp [i] . recv_data_bufp);
        }

        NdisFreeMemory (ctxtp -> frame_dscrp, sizeof (MAIN_FRAME_DSCR) *
                        ctxtp -> num_send_msgs, 0);
    }

    if (ctxtp -> frame_buf_pool_handle != NULL)
        NdisFreeBufferPool (ctxtp -> frame_buf_pool_handle);

    /* This packet pool is being used only for the heartbeat messages,
     * so prefer not to check the packet pool usage.
     */
    if (ctxtp -> frame_pool_handle != NULL)
        NdisFreePacketPool (ctxtp -> frame_pool_handle);

    NdisFreeSpinLock (& ctxtp -> sync_lock);
    NdisFreeSpinLock (& ctxtp -> act_lock);
    NdisFreeSpinLock (& ctxtp -> buf_lock);     /* V1.3.2b */
    NdisFreeSpinLock (& ctxtp -> recv_lock);
    NdisFreeSpinLock (& ctxtp -> send_lock);
    NdisFreeSpinLock (& ctxtp -> frame_lock);
    NdisFreeSpinLock (& ctxtp -> rct_lock);

    /* Cleanup BDA teaming state. Note: this function will sleep under certain circumstances. */
    Main_teaming_cleanup(ctxtp);

    if (ctxtp -> convoy_enabled)
        Load_stop (& ctxtp -> load);

    Load_cleanup (& ctxtp -> load);

    NdisFreeSpinLock (& ctxtp -> load_lock);

    return;
} /* end Main_cleanup */


ULONG   Main_arp_handle (
    PMAIN_CTXT          ctxtp,
    PARP_HDR            arp_hdrp,
    ULONG               len,       /* v2.0.6 */
    ULONG               send)
{
    PUCHAR              macp;

    /* V1.3.0b multicast support - ARP spoofing. use either this one or
       code in Nic_request_complete that makes TCP/IP believe that station
       current MAC address is the multicast one */

    /* V1.3.1b */

    if (len < sizeof(ARP_HDR))  /* v2.0.6 */
        return FALSE;

#if defined(TRACE_ARP)
    DbgPrint ("(ARP) %s\n", send ? "send" : "recv");
    DbgPrint ("    MAC type      = %x\n",  ARP_GET_MAC_TYPE (arp_hdrp));
    DbgPrint ("    prot type     = %x\n",  ARP_GET_PROT_TYPE (arp_hdrp));
    DbgPrint ("    MAC length    = %d\n",  ARP_GET_MAC_LEN (arp_hdrp));
    DbgPrint ("    prot length   = %d\n",  ARP_GET_PROT_LEN (arp_hdrp));
    DbgPrint ("    message type  = %d\n",  ARP_GET_MSG_TYPE (arp_hdrp));
    DbgPrint ("    src MAC addr  = %02x-%02x-%02x-%02x-%02x-%02x\n",
                                           ARP_GET_SRC_MAC (arp_hdrp, 0),
                                           ARP_GET_SRC_MAC (arp_hdrp, 1),
                                           ARP_GET_SRC_MAC (arp_hdrp, 2),
                                           ARP_GET_SRC_MAC (arp_hdrp, 3),
                                           ARP_GET_SRC_MAC (arp_hdrp, 4),
                                           ARP_GET_SRC_MAC (arp_hdrp, 5));
    DbgPrint ("    src prot addr = %d.%d.%d.%d\n",
                                           ARP_GET_SRC_PROT (arp_hdrp, 0),
                                           ARP_GET_SRC_PROT (arp_hdrp, 1),
                                           ARP_GET_SRC_PROT (arp_hdrp, 2),
                                           ARP_GET_SRC_PROT (arp_hdrp, 3));
    DbgPrint ("    dst MAC addr  = %02x-%02x-%02x-%02x-%02x-%02x\n",
                                           ARP_GET_DST_MAC (arp_hdrp, 0),
                                           ARP_GET_DST_MAC (arp_hdrp, 1),
                                           ARP_GET_DST_MAC (arp_hdrp, 2),
                                           ARP_GET_DST_MAC (arp_hdrp, 3),
                                           ARP_GET_DST_MAC (arp_hdrp, 4),
                                           ARP_GET_DST_MAC (arp_hdrp, 5));
    DbgPrint ("    dst prot addr = %d.%d.%d.%d\n",
                                           ARP_GET_DST_PROT (arp_hdrp, 0),
                                           ARP_GET_DST_PROT (arp_hdrp, 1),
                                           ARP_GET_DST_PROT (arp_hdrp, 2),
                                           ARP_GET_DST_PROT (arp_hdrp, 3));
#endif

    /* block sending out ARPs while we are changing IPs */

    if (send && univ_changing_ip > 0)
    {
        /* if source IP is the one we are switching to - stop blocking ARPs */

        if (ARP_GET_SRC_PROT_64(arp_hdrp) == ctxtp->cl_ip_addr) /* 64-bit -- ramkrish */
        {
            NdisAcquireSpinLock (& ctxtp -> load_lock);
            univ_changing_ip = 0;
            NdisReleaseSpinLock (& ctxtp -> load_lock);

            UNIV_PRINT (("IP address changed - stop blocking"));
        }
        else if (ARP_GET_SRC_PROT_64(arp_hdrp) != ctxtp -> ded_ip_addr) /* 64-bit -- ramkrish */
        {
#if defined(TRACE_ARP)
            DbgPrint ("blocked due to IP switching\n");
#endif
//            ctxtp -> arps_filtered ++;
            return FALSE;
        }
    }

    if (ctxtp -> params . mcast_spoof &&
        ctxtp -> params . mcast_support &&
        ARP_GET_PROT_TYPE (arp_hdrp) == ARP_PROT_TYPE_IP &&
        ARP_GET_PROT_LEN  (arp_hdrp) == ARP_PROT_LEN_IP)
    {
        if (send)
        {
            /* if this is a cluster IP address and our dedicated MAC -
               replace dedicated MAC with cluster MAC */

            if (ARP_GET_SRC_PROT_64 (arp_hdrp) != ctxtp -> ded_ip_addr) /* 64-bit -- ramkrish */
            {
                macp = ARP_GET_SRC_MAC_PTR (arp_hdrp);

                if (CVY_MAC_ADDR_COMP (ctxtp -> medium, macp, & ctxtp -> ded_mac_addr))
                    CVY_MAC_ADDR_COPY (ctxtp -> medium, macp, & ctxtp -> cl_mac_addr);
            }

#if defined (NLB_MIXED_MODE_CLUSTERS)
	    return TRUE;
#endif /* NLB_MIXED_MODE_CLUSTERS */

        }
#if 0
        else
        {
            /* if this is a cluster IP address and our cluster MAC -
               replace cluster MAC with dedicated MAC */

            if (ARP_GET_SRC_PROT_64 (arp_hdrp) != ctxtp -> ded_ip_addr) /* 64-bit -- ramkrish */
            {
                macp = ARP_GET_SRC_MAC_PTR (arp_hdrp);

                if (CVY_MAC_ADDR_COMP (ctxtp -> medium, macp, & ctxtp -> cl_mac_addr))
                    CVY_MAC_ADDR_COPY (ctxtp -> medium, macp, & ctxtp -> ded_mac_addr);
            }

            if (ARP_GET_DST_PROT_64 (arp_hdrp) != ctxtp -> ded_ip_addr) /* 64-bit -- ramkrish */
            {
                macp = ARP_GET_DST_MAC_PTR (arp_hdrp);

                if (CVY_MAC_ADDR_COMP (ctxtp -> medium, macp, & ctxtp -> cl_mac_addr))
                    CVY_MAC_ADDR_COPY (ctxtp -> medium, macp, & ctxtp -> ded_mac_addr);
            }
        }
#endif
    }

#if defined (NLB_MIXED_MODE_CLUSTERS)
    // code for migrating between cluster modes
    if (!send)
    {
	if (ARP_GET_SRC_PROT_64 (arp_hdrp) != ctxtp -> ded_ip_addr)
	{
	    macp = ARP_GET_SRC_MAC_PTR (arp_hdrp);

	    if (CVY_MAC_ADDR_COMP (ctxtp -> medium, macp, & ctxtp -> cl_mac_addr))
	    {
		if (ctxtp -> params . mcast_support) /* only change for multicast support */
		{
		    CVY_MAC_ADDR_COPY (ctxtp -> medium, macp, & ctxtp -> ded_mac_addr);
		}
	    }
	    else /* some machine could be in another mode. Avoid the IP address conflict, but warn the user */
	    {
		if (CVY_MAC_ADDR_COMP (ctxtp -> medium, macp, & ctxtp -> unic_mac_addr) ||
		    CVY_MAC_ADDR_COMP (ctxtp -> medium, macp, & ctxtp -> mult_mac_addr) ||
		    CVY_MAC_ADDR_COMP (ctxtp -> medium, macp, & ctxtp -> igmp_mac_addr))
		{
		    UNIV_PRINT (("Detected a host with a different mode"));
		    if (! ctxtp -> mac_addr_warned)
		    {
			ctxtp -> mac_addr_warned = TRUE;
			LOG_MSG(MSG_WARN_DIFFERENT_MODE, MSG_NONE);
		    }

		    if (ctxtp -> params . mcast_support)
			CVY_MAC_ADDR_COPY (ctxtp -> medium, macp, & ctxtp -> ded_mac_addr);
		    else
			CVY_MAC_ADDR_COPY (ctxtp -> medium, macp, & ctxtp -> cl_mac_addr);
		}
		else
		{
		    ; /* This will be a genuine IP address conflict */
		}
	    }
	}

	if (ARP_GET_DST_PROT_64 (arp_hdrp) != ctxtp -> ded_ip_addr)
	{
	    macp = ARP_GET_DST_MAC_PTR (arp_hdrp);

	    if (CVY_MAC_ADDR_COMP (ctxtp -> medium, macp, & ctxtp -> cl_mac_addr))
	    {
		if (ctxtp -> params . mcast_support) /* only change for multicast support */
                {
		    CVY_MAC_ADDR_COPY (ctxtp -> medium, macp, & ctxtp -> ded_mac_addr);
		}
	    }
	    else /* some machine could be in another mode. Avoid the IP address conflict, but warn the user */
	    {
		if (CVY_MAC_ADDR_COMP (ctxtp -> medium, macp, & ctxtp -> unic_mac_addr) ||
		    CVY_MAC_ADDR_COMP (ctxtp -> medium, macp, & ctxtp -> mult_mac_addr) ||
		    CVY_MAC_ADDR_COMP (ctxtp -> medium, macp, & ctxtp -> igmp_mac_addr))
                {
		    UNIV_PRINT (("Detected a host with a different mode"));
		    if (! ctxtp -> mac_addr_warned)
		    {
			ctxtp -> mac_addr_warned = TRUE;
			LOG_MSG(MSG_WARN_DIFFERENT_MODE, MSG_NONE);
		    }

		    if (ctxtp -> params . mcast_support)
			CVY_MAC_ADDR_COPY (ctxtp -> medium, macp, & ctxtp -> ded_mac_addr);
		    else
			CVY_MAC_ADDR_COPY (ctxtp -> medium, macp, & ctxtp -> cl_mac_addr);
		}
		else
		{
		    ; /* This will be a genuine IP address conflict */
		}
	    }
	}
    }
#endif /* NLB_MIXED_MODE_CLUSTERS */

#if defined(TRACE_ARP)
    DbgPrint ("---- spoofed to -----\n");
    DbgPrint ("    src MAC addr  = %02x-%02x-%02x-%02x-%02x-%02x\n",
                                           ARP_GET_SRC_MAC (arp_hdrp, 0),
                                           ARP_GET_SRC_MAC (arp_hdrp, 1),
                                           ARP_GET_SRC_MAC (arp_hdrp, 2),
                                           ARP_GET_SRC_MAC (arp_hdrp, 3),
                                           ARP_GET_SRC_MAC (arp_hdrp, 4),
                                           ARP_GET_SRC_MAC (arp_hdrp, 5));
    DbgPrint ("    src prot addr = %d.%d.%d.%d\n",
                                           ARP_GET_SRC_PROT (arp_hdrp, 0),
                                           ARP_GET_SRC_PROT (arp_hdrp, 1),
                                           ARP_GET_SRC_PROT (arp_hdrp, 2),
                                           ARP_GET_SRC_PROT (arp_hdrp, 3));
    DbgPrint ("    dst MAC addr  = %02x-%02x-%02x-%02x-%02x-%02x\n",
                                           ARP_GET_DST_MAC (arp_hdrp, 0),
                                           ARP_GET_DST_MAC (arp_hdrp, 1),
                                           ARP_GET_DST_MAC (arp_hdrp, 2),
                                           ARP_GET_DST_MAC (arp_hdrp, 3),
                                           ARP_GET_DST_MAC (arp_hdrp, 4),
                                           ARP_GET_DST_MAC (arp_hdrp, 5));
    DbgPrint ("    dst prot addr = %d.%d.%d.%d\n",
                                           ARP_GET_DST_PROT (arp_hdrp, 0),
                                           ARP_GET_DST_PROT (arp_hdrp, 1),
                                           ARP_GET_DST_PROT (arp_hdrp, 2),
                                           ARP_GET_DST_PROT (arp_hdrp, 3));
#endif

    return TRUE;

} /* end Main_arp_handle */

#if defined (NLB_SESSION_SUPPORT)
/*
 * Function: Main_parse_ipsec
 * Description: This function parses UDP packets received on port 500, which are IPSec
 *              control packets.  This function attempts to recognize the start of an 
 *              IPSec session - its virtual 'SYN' packet.  IPSec sessions begin with an
 *              IKE key exchange which is an IKE Main Mode Security Association.  This 
 *              function parses the IKE header and payload to identify the Main Mode
 *              SAs, which NLB will treat like TCP SYNs - all other UDP 500 and IPSec 
 *              traffic is treated like TCP data packets.  The problem is that NLB 
 *              cannot necessarily tell the difference between a new Main Mode SA and
 *              a re-key of an existing Main Mode SA.  Therefore, if the client does not
 *              support intitial contact notification, then every Main Mode SA will be
 *              considered a new session, which means that sessions can potentially 
 *              break depending on how often Main Mode SAs are negotiated.  However, if
 *              the client does support initial contact notification, then the only Main 
 *              Mode SAs that will be reported as such are the initial ones (when no state 
 *              currently exists between the client and the server), which allows NLB to 
 *              distinguish the two types of Main Mode SAs, which should allow NLB to 
 *              reliably keep IPSec sessions "sticky".  Note that there is no TCP FIN
 *              equivalent, so the descriptor for these sessions will be around forever,
 *              or until the load module is reset, or a new initial Main Mode SA arrives
 *              with the same address tuple, at which time the descriptor is removed and
 *              the correct host accepts the session and creates a new descriptor.  IPSec
 *              can however, if desired, notify NLB through the connection notification
 *              APIs, telling NLB that the session has gone down, allowing NLB to clean 
 *              out the descriptor for the session.  This is not necessarily critical, 
 *              but would be useful in the case where a host with stale information 
 *              rejoins the cluster, which could cause two hosts to pass up packets for
 *              the same session - IPSec will toss them out, unless its a Main Mode SA.
 *              Its also useful in the case where IPSec has refused a connection, in
 *              which case there is no reason for NLB to keep the descriptors around.
 * Parameters: pIKEPacket - a pointer to the IKE packet buffer (this is beyond the UDP header).
 *             cUDPDataLenght - the length of the corresponding buffer.
 * Returns: BOOLEAN - TRUE if the packet is a new IPSec session, FALSE if it is not.
 * Author: Created by shouse, 4.28.01
 */
BOOLEAN Main_parse_ipsec (PUCHAR pIKEPacket, ULONG cUDPDataLength) {
    /* Pointer to the IKE header. */
    PIPSEC_ISAKMP_HDR  pISAKMPHeader = (PIPSEC_ISAKMP_HDR)pIKEPacket;
    /* Pointer to the subsequent generic payloads in the IKE packet. */
    PIPSEC_GENERIC_HDR pGenericHeader;                   

    /* The responder cookie - should be zero for a new MM SA. */
    UCHAR              MainModeRCookie[IPSEC_ISAKMP_HEADER_RCOOKIE_LENGTH] = IPSEC_ISAKMP_MAIN_MODE_RCOOKIE;    
    /* The initiator cookie - should be non-zero if this is really an IKE packet. */
    UCHAR              EncapsulatedIPSecICookie[IPSEC_ISAKMP_HEADER_ICOOKIE_LENGTH] = IPSEC_ISAKMP_ENCAPSULATED_IPSEC_ICOOKIE;    
    /* The Microsoft client vendor ID - used to determine whether or not the client supports initial contact notification. */
    UCHAR              VIDMicrosoftClient[IPSEC_VENDOR_HEADER_VENDOR_ID_LENGTH] = IPSEC_VENDOR_ID_MICROSOFT;      

    /* Whether or not we've determined the client to be compatible. */                                                                                                                      
    BOOLEAN            bInitialContactEnabled = FALSE;
    /* Whether or not this is indeed an initial contact. */
    BOOLEAN            bInitialContact = FALSE;

    /* The length of the IKE packet. */            
    ULONG              cISAKMPPacketLength;
    /* The next payload code in the IKE payload chain. */  
    UCHAR              NextPayload;        

    UNIV_PRINT(("Sniffing IKE header %p\n", pISAKMPHeader));

    /* The UDP data should be at least as long as the initiator cookie.  If the packet is 
       UDP encapsulated IPSec, then the I cookie will be 0 to indicate such. */
    if (cUDPDataLength < IPSEC_ISAKMP_HEADER_ICOOKIE_LENGTH) {
        UNIV_PRINT(("Malformed UDP data: UDP data length = %u\n", cUDPDataLength));
        return FALSE;
    }

    /* Need to check the init cookie, which will distinguish clients behind a NAT, 
       which also send their IPSec (ESP) traffic to UDP port 500.  If the I cookie
       is zero, then this is NOT an IKE packet, so we return FALSE. */
    if (NdisEqualMemory((PVOID)IPSEC_ISAKMP_GET_ICOOKIE_POINTER(pISAKMPHeader), (PVOID)&EncapsulatedIPSecICookie[0], sizeof(UCHAR) * IPSEC_ISAKMP_HEADER_ICOOKIE_LENGTH)) {
        UNIV_PRINT(("This packet is UDP encapsulated IPSec traffic, not an IKE packet\n"));
        return FALSE;
    }

    /* At this point, this packet should be IKE, so the UDP data should be at least 
       as long as an ISAKMP header. */
    if (cUDPDataLength < IPSEC_ISAKMP_HEADER_LENGTH) {
        UNIV_PRINT(("Malformed ISAKMP header: UDP data length = %u\n", cUDPDataLength));
        return FALSE;
    }

    /* Get the total length of the IKE packet from the ISAKMP header. */
    cISAKMPPacketLength = IPSEC_ISAKMP_GET_PACKET_LENGTH(pISAKMPHeader);

    /* The IKE packet should be at least as long as an ISAKMP header (a whole lot longer, actually). */
    if (cISAKMPPacketLength < IPSEC_ISAKMP_HEADER_LENGTH) {
        UNIV_PRINT(("Malformed ISAKMP header: ISAKMP Packet length = %u\n", cISAKMPPacketLength));
        return FALSE;
    }

    /* Sanity check - the UDP data length and IKE packet length SHOULD be the same. */
    if (cUDPDataLength != cISAKMPPacketLength) {
        UNIV_PRINT(("Expected equal packet lenghts: UDP data length = %u, ISAKMP packet length = %u\n", cUDPDataLength, cISAKMPPacketLength));
        return FALSE;
    }

    /* Get the first payload type out of the ISAKMP header. */
    NextPayload = IPSEC_ISAKMP_GET_NEXT_PAYLOAD(pISAKMPHeader);

    /* IKE security associations are identified by a payload type byte in the header.
       Check that first - this does not ensure that this is what we are looking for 
       because this check will not exclude, for instance, main mode re-keys. */
    if (NextPayload != IPSEC_ISAKMP_SA) {
        UNIV_PRINT(("Not a Main Mode Security Association\n"));
        return FALSE;
    } 

    /* Now check the resp cookie.  If the cookie is all zeros, this is a new main mode 
       SA.  However, we are only really interested in initial contact main mode SAs 
       (the first SA for a particular client), so we need to look a bit further. */
    if (!NdisEqualMemory((PVOID)IPSEC_ISAKMP_GET_RCOOKIE_POINTER(pISAKMPHeader), (PVOID)&MainModeRCookie[0], sizeof(UCHAR) * IPSEC_ISAKMP_HEADER_RCOOKIE_LENGTH)) {
        UNIV_PRINT(("Not a new Main Mode Security Association\n"));
        return FALSE;
    }

    /* Calculate a pointer to the fist generic payload, which is directly after the ISAKMP header. */
    pGenericHeader = (PIPSEC_GENERIC_HDR)((PUCHAR)pISAKMPHeader + IPSEC_ISAKMP_HEADER_LENGTH);

    /* We are looping through the generic payloads looking for the vendor ID and/or notify information. */
    while ((PUCHAR)pGenericHeader <= ((PUCHAR)pISAKMPHeader + cISAKMPPacketLength - IPSEC_GENERIC_HEADER_LENGTH)) {
        /* Extract the payload length from the generic header. */
        USHORT cPayloadLength = IPSEC_GENERIC_GET_PAYLOAD_LENGTH(pGenericHeader);

        /* Not all clients are going to support this (in fact, only the Microsoft client
           will support it, so we need to first see what the vendor ID of the client is.
           if it is a Microsoft client that supports the initial contact vendor ID, then
           we'll look for the initial contact, which provides better stickiness for IPSec
           connections.  If either the client is non-MS, or if it is not a version that
           supports initial contact, then we can revert to the "second-best" solution, 
           which is to provide stickiness _between_ Main Mode SAs.  This means that if a
           client re-keys their Main Mode session, they _may_ be rebalanced to another
           server.  This is still better than the old UDP implementation, but the only
           way to provide full session support for IPSec (without the distributed session
           table nightmare) is to be able to distinguish initial Main Mode SAs from sub-
           sequent Main Mode SAs (re-keys). */
        if (NextPayload == IPSEC_ISAKMP_VENDOR_ID) {
            PIPSEC_VENDOR_HDR pVendorHeader = (PIPSEC_VENDOR_HDR)pGenericHeader;

            /* Make sure that the vendor ID payload is at least as long as a vendor ID. */
            if (cPayloadLength < (IPSEC_GENERIC_HEADER_LENGTH + IPSEC_VENDOR_HEADER_VENDOR_ID_LENGTH)) {
                UNIV_PRINT(("Malformed vendor ID header: Payload length = %d\n", cPayloadLength));
                break;
            }

            /* Look for the Microsoft client vendor ID.  If it is the right version, then we know that 
               the client is going to appropriately set the initial contact information, allowing NLB
               to provide the best possible support for session stickiness. */
            if (NdisEqualMemory((PVOID)IPSEC_VENDOR_ID_GET_ID_POINTER(pVendorHeader), (PVOID)&VIDMicrosoftClient[0], sizeof(UCHAR) * IPSEC_VENDOR_HEADER_VENDOR_ID_LENGTH)) {
                /* Make sure that their is a version number attached to the Microsoft Vendor ID.  Not 
                   all vendor IDs have versions attached, but the Microsoft vendor ID should. */
                if (cPayloadLength < (IPSEC_GENERIC_HEADER_LENGTH + IPSEC_VENDOR_ID_PAYLOAD_LENGTH)) {
                    UNIV_PRINT(("Unable to determine MS client version: Payload length = %d\n", cPayloadLength));
                    break;
                }

                if (IPSEC_VENDOR_ID_GET_VERSION(pVendorHeader) >= IPSEC_VENDOR_ID_MICROSOFT_MIN_VERSION) {
                    /* Microsoft clients whose version is greater than or equal to 4 will support
                       initial contact.  Non-MS clients, or old MS clients will not, so they 
                       receive decent, but not guaranteed sitckines, based solely on MM SAs. */
                    bInitialContactEnabled = TRUE;
                }
            }
        } else if (NextPayload == IPSEC_ISAKMP_NOTIFY) {
            PIPSEC_NOTIFY_HDR pNotifyHeader = (PIPSEC_NOTIFY_HDR)pGenericHeader;

            /* Make sure that the notify payload is the correct length. */
            if (cPayloadLength < (IPSEC_GENERIC_HEADER_LENGTH + IPSEC_NOTIFY_PAYLOAD_LENGTH)) {
                UNIV_PRINT(("Malformed notify header: Payload length = %d\n", cPayloadLength));
                break;
            }

            if (IPSEC_NOTIFY_GET_NOTIFY_MESSAGE(pNotifyHeader) == IPSEC_NOTIFY_INITIAL_CONTACT) {
                /* This is an initial contact notification from the client, which means that this is
                   the first time that the client has contacted this server; more precisely, the client
                   currently has no state associated with this peer.  NLB will "re-balance" on initial 
                   contact notifications, but not other Main Mode key exchanges as long as it can 
                   determine that the client will comply with initial contact notification. */
                bInitialContact = TRUE;
            }
        }

        /* Get the next payload type out of the generic header. */
        NextPayload = IPSEC_GENERIC_GET_NEXT_PAYLOAD(pGenericHeader);
        
        /* Calculate a pointer to the next generic payload. */
        pGenericHeader = (PIPSEC_GENERIC_HDR)((PUCHAR)pGenericHeader + cPayloadLength);
    }

    /* If the vendor ID did not indicate that this client supports initial contact notification,
       then return TRUE, and we go with the less-than-optimal solution of treating Main Mode
       SAs as the connection boundaries, which potentially breaks sessions on MM SA re-keys. */
    if (!bInitialContactEnabled) {
        UNIV_PRINT(("This client does not support initial contact notifications.\n")); 
        return TRUE;
    }

    /* If this was a Main Mode SA from a client that supports initial contact, but did not
       specify the initial contact vendor ID, then this is a re-key for an existing session. */
    if (!bInitialContact) {
        UNIV_PRINT(("Not an initial contact Main Mode Security Association\n"));
        return FALSE;
    }

    /* Otherwise, this IS a Main Mode SA initial contact, which the IPSec 'SYN'. */
    UNIV_PRINT(("Found an initial contact Main Mode Security Association\n"));

    return TRUE;
}
#else  /* !NLB_SESSION_SUPPORT */
BOOLEAN Main_parse_ipsec (PUCHAR pIKEPacket, ULONG cUDPDataLength) {

    return FALSE;
}
#endif /* NLB_SESSION_SUPPORT */

//+----------------------------------------------------------------------------
//
// Function:   Main_ip_send_filter 
//
// Description:  Filter outgoing IP packets
//
// Arguments: MAIN_CTXT      ctxtp - 
//            const PIP_HDR   ip_hdrp - 
//            const PUCHAR    hdrp - 
//            ULONG           len - 
//            IN OUT PULONG   pOperation - 
//                  IN: has to be MAIN_FILTER_OP_NONE
//                  OUT: MAIN_FILTER_OP_NONE or MAIN_FILTER_OP_CTRL
//
// Returns:   BOOLEAN  - TRUE if to allow the packet to go through
//                     FALSE if to drop the packet
//
// History:   kyrilf initial code
//            fengsun Created seperate function 11/14/00
//
//+----------------------------------------------------------------------------
BOOLEAN   Main_ip_send_filter (
    PMAIN_CTXT      ctxtp,
    const PIP_HDR   ip_hdrp,
    const PUCHAR    hdrp,
    ULONG           len,      
    IN OUT PULONG   pOperation)
{
    PUDP_HDR            udp_hdrp = NULL;
    PTCP_HDR            tcp_hdrp = NULL;
    BOOLEAN             acpt = TRUE;       // Whether or not to accept the packet.
    ULONG               svr_port;          // Port for this host.
    ULONG               svr_addr;          // IP address for this host.
    ULONG               clt_port;          // Port for destination client.
    ULONG               clt_addr;          // IP address for destination client.
    ULONG               flags;             // TCP flags.
    ULONG               hlen; 
    ULONG               Protocol;          // Protocol derived from IP header.
    BOOLEAN             bRefused = FALSE;  // TRUE -> BDA has refused handling this packet.

    hlen = sizeof (ULONG) * IP_GET_HLEN (ip_hdrp);
    
    if (len < hlen)
        return FALSE;
    
#if defined(TRACE_IP)
    DbgPrint ("(IP) send \n");
    DbgPrint ("    version       = %d\n",     IP_GET_VERS (ip_hdrp));
    DbgPrint ("    header length = %d\n",     IP_GET_HLEN (ip_hdrp));
    DbgPrint ("    service type  = 0x%x\n",   IP_GET_SRVC (ip_hdrp));
    DbgPrint ("    packet length = %d\n",     IP_GET_PLEN (ip_hdrp));
    DbgPrint ("    frag ident    = %d\n",     IP_GET_FRAG_ID (ip_hdrp));
    DbgPrint ("    frag flags    = 0x%x\n",   IP_GET_FRAG_FLGS (ip_hdrp));
    DbgPrint ("    frag offset   = %d\n",     IP_GET_FRAG_OFF (ip_hdrp));
    DbgPrint ("    time to live  = %d\n",     IP_GET_TTL (ip_hdrp));
    DbgPrint ("    checksum      = 0x04%x\n", IP_GET_CHKSUM (ip_hdrp));
    DbgPrint ("    protocol      = %d ",      IP_GET_PROT (ip_hdrp));
#endif

    UNIV_ASSERT(*pOperation == MAIN_FILTER_OP_NONE);  

    if (IP_GET_FRAG_OFF(ip_hdrp) != 0)
    {
#if defined(TRACE_FRAGS)
        if ((IP_GET_FRAG_FLGS(ip_hdrp) & 0x1) == 0)
            DbgPrint("Fragmented datagram id %d flgs %x off %d received from %d.%d.%d.%d\n",
                     IP_GET_FRAG_ID(ip_hdrp),
                     IP_GET_FRAG_FLGS(ip_hdrp),
                     IP_GET_FRAG_OFF(ip_hdrp),
                     IP_GET_SRC_ADDR (ip_hdrp, 0),
                     IP_GET_SRC_ADDR (ip_hdrp, 1),
                     IP_GET_SRC_ADDR (ip_hdrp, 2),
                     IP_GET_SRC_ADDR (ip_hdrp, 3));
#endif
        /* Always let fragmented packets go out. */
        return TRUE;
    }

    /* Server address is the source IP and client address is the destination IP. */
    svr_addr = IP_GET_SRC_ADDR_64 (ip_hdrp);
    clt_addr = IP_GET_DST_ADDR_64 (ip_hdrp);

    /* Get the IP protocol form the IP header. */
    Protocol = IP_GET_PROT(ip_hdrp);

    /* Packets directed to the dedicated IP address are always passed through.  If the 
       cluster IP address hasn't been set (parameter error), then fall into a pass-
       through mode and pass all traffic up to the upper-layer protocols. */
    if (svr_addr == ctxtp -> ded_ip_addr || ctxtp -> cl_ip_addr == 0)
    {
        if (Protocol != TCPIP_PROTOCOL_UDP)
        {
            /* For UDP protocol, remote control packet has to be handled seperately, so don't accept it yet. */
            return TRUE;
        }
    }

    switch (IP_GET_PROT (ip_hdrp))
    {
    case TCPIP_PROTOCOL_TCP:
#if defined(TRACE_IP) || defined(TRACE_TCP)
        DbgPrint ("(TCP) send \n");
#endif
        
        tcp_hdrp = (PTCP_HDR) hdrp;
        
        hlen += sizeof (ULONG) * TCP_GET_HLEN (tcp_hdrp);  /* v2.0.6 */
        
        if (len < hlen)
            return FALSE;
        
#if defined(TRACE_TCP)
        DbgPrint ("    source port   = %d\n",  TCP_GET_SRC_PORT (tcp_hdrp));
        DbgPrint ("    dest port     = %d\n",  TCP_GET_DST_PORT (tcp_hdrp));
        DbgPrint ("    seq no.       = %d\n",  TCP_GET_SEQ_NO (tcp_hdrp));
        DbgPrint ("    ack no.       = %d\n",  TCP_GET_ACK_NO (tcp_hdrp));
        DbgPrint ("    flags         = %d\n",  TCP_GET_FLAGS (tcp_hdrp));
#endif
        
        svr_port = TCP_GET_SRC_PORT (tcp_hdrp);
        clt_port = TCP_GET_DST_PORT (tcp_hdrp);
        
        /* For PPTP support, because we cannot extract a source port number from the subsequent GRE packets
           in order to match them to an existing PPTP TCP descriptor, we will hardcode the source port number
           here and then do the same for GRE packets.  This way, we can treat GRE packets like TCP data packets
           on this TCP connection.  Note that this breaks when clients are behind a NAT because a single client
           IP address will have many connections to port 1723, each with a different source port.  In that case,
           we break because we are not reference counting SYNs v. FINs - i.e., the first PPTP connection to go
           down would destroy the TCP descriptor for (Client IP, 0, Server IP, 1723).  There are two solutions;
           (1) reference count re-used descriptors (so we require 2 FINs per SYN, not just 2 period), or (2)
           have PPTP use our notification APIs to give us something that we can look for in the GRE packets, 
           such as a call ID, to identify the GRE packet as belonging to a known session. */
        if (svr_port == PPTP_CTRL_PORT)
        {
            if (ctxtp -> convoy_enabled)
            {
                if (NLB_PPTP_SESSION_SUPPORT_ENABLED()) // JosephJ: added 0 && because I'm disabling PPTP session support for now...
                {
                    clt_port = 0;
                }
                else
                {
                    acpt = Main_packet_check(ctxtp, svr_addr, svr_port, clt_addr, clt_port, TCPIP_PROTOCOL_UDP, &bRefused, FALSE);
                    
                    /* If teaming has suggested that we not allow this packet to pass, dump it. */
                    if (bRefused) acpt = FALSE;

                    break;
                }
            }
            else
            {
                acpt = FALSE;

                break;
            }            
        }
        
        UNIV_ASSERT(IP_GET_FRAG_OFF(ip_hdrp) == 0);
        
        /* Apply filtering algorithm. process connection boundaries different from regular packets. */
        
        /* Get the TCP flags to find out the packet type. */
        flags = TCP_GET_FLAGS (tcp_hdrp);
        
        if (flags & TCP_FLAG_SYN)
        {
#if defined(TRACE_CNCT)
            DbgPrint ("outgoing SYN %x from %d.%d.%d.%d:%d\n",
                      TCP_GET_FLAGS (tcp_hdrp),
                      IP_GET_SRC_ADDR (ip_hdrp, 0),
                      IP_GET_SRC_ADDR (ip_hdrp, 1),
                      IP_GET_SRC_ADDR (ip_hdrp, 2),
                      IP_GET_SRC_ADDR (ip_hdrp, 3),
                      TCP_GET_SRC_PORT (tcp_hdrp));
#endif
            
            /* In the case of an outgoing SYN, we always want to allow the packet to pass, 
               unless the operation was refused (in the case on an inactive BDA team), so
               we ignore the return value, which is the response from the load module, and
               check only refused to determine whether or not to drop the packet.  If this 
               adapter is part of a BDA team, this function will create a descriptor for 
               this TCP connection on the way out to make sure that it will come back to 
               this host, even if a convergence and bucket redistribution occurs before the
               SYNACK is returned from the destination. */
            if (ctxtp -> convoy_enabled) 
            {
                Main_create_dscr(ctxtp, svr_addr, svr_port, clt_addr, clt_port, TCPIP_PROTOCOL_TCP, &bRefused, TRUE);
            
                /* If teaming has suggested that we not allow this packet to pass, dump it. */
                if (bRefused) acpt = FALSE;
            }
        } 
        else if (flags & TCP_FLAG_FIN)
        {
#if defined(TRACE_CNCT)
            DbgPrint ("outgoing FIN %x from %d.%d.%d.%d:%d\n",
                      TCP_GET_FLAGS (tcp_hdrp),
                      IP_GET_SRC_ADDR (ip_hdrp, 0),
                      IP_GET_SRC_ADDR (ip_hdrp, 1),
                      IP_GET_SRC_ADDR (ip_hdrp, 2),
                      IP_GET_SRC_ADDR (ip_hdrp, 3),
                      TCP_GET_SRC_PORT (tcp_hdrp));
#endif

            /* In the case of an outgoing FIN, we always want to allow the packet to pass, 
               unless the operation was refused (in the case on an inactive BDA team), so
               we ignore the return value, which is the response from the load module, and
               check only refused to determine whether or not to drop the packet. */
            Main_conn_advise(ctxtp, svr_addr, svr_port, clt_addr, clt_port, TCPIP_PROTOCOL_TCP, CVY_CONN_DOWN, &bRefused, FALSE);

            /* If teaming has suggested that we not allow this packet to pass, dump it. */
            if (bRefused) acpt = FALSE;
        }
        else if (flags & TCP_FLAG_RST)
        {
#if defined(TRACE_CNCT)
            DbgPrint ("outgoing RST %x from %d.%d.%d.%d:%d\n",
                      TCP_GET_FLAGS (tcp_hdrp),
                      IP_GET_SRC_ADDR (ip_hdrp, 0),
                      IP_GET_SRC_ADDR (ip_hdrp, 1),
                      IP_GET_SRC_ADDR (ip_hdrp, 2),
                      IP_GET_SRC_ADDR (ip_hdrp, 3),
                      TCP_GET_SRC_PORT (tcp_hdrp));
#endif

            /* In the case of an outgoing RST, we always want to allow the packet to pass, 
               unless the operation was refused (in the case on an inactive BDA team), so
               we ignore the return value, which is the response from the load module, and
               check only refused to determine whether or not to drop the packet. */
            Main_conn_advise(ctxtp, svr_addr, svr_port, clt_addr, clt_port, TCPIP_PROTOCOL_TCP, CVY_CONN_RESET, &bRefused, FALSE);

            /* If teaming has suggested that we not allow this packet to pass, dump it. */
            if (bRefused) acpt = FALSE;
        }

        break;

    case TCPIP_PROTOCOL_UDP:
#if defined(TRACE_IP) || defined(TRACE_UDP)
        DbgPrint ("(UDP) send\n");
#endif
        udp_hdrp = (PUDP_HDR) hdrp;
            
        hlen += sizeof (UDP_HDR);

        if (len < hlen)
            return FALSE;

#if defined(TRACE_UDP)
        DbgPrint ("    source port   = %d\n",  UDP_GET_SRC_PORT (udp_hdrp));
        DbgPrint ("    dest port     = %d\n",  UDP_GET_DST_PORT (udp_hdrp));
        DbgPrint ("    length        = %d\n",  UDP_GET_LEN (udp_hdrp));
#endif

        svr_port = UDP_GET_SRC_PORT (udp_hdrp);
        clt_port = UDP_GET_DST_PORT (udp_hdrp);
            
        /* IP broadcast UDPs generated by wlbs.exe.  Note that we cannot look past UDP header on send and thus check the code. */
        if ((clt_port == ctxtp -> params . rct_port || clt_port == CVY_DEF_RCT_PORT_OLD) && clt_addr == TCPIP_BCAST_ADDR) {
            /* This flag is used by Main_send to enable loop back so that we can respond to a query originated on this host. */
            *pOperation = MAIN_FILTER_OP_CTRL;  
        }

        /* Always allow outgoing UDP packets to go through. */
        UNIV_ASSERT(acpt == TRUE);

        break;

    case TCPIP_PROTOCOL_GRE:
#if defined(TRACE_IP) || defined(TRACE_GRE)
        DbgPrint ("(GRE) send\n");
#endif

        if (ctxtp -> convoy_enabled)
        {
            if (!NLB_PPTP_SESSION_SUPPORT_ENABLED())
            {
                acpt = Main_packet_check(ctxtp, svr_addr, PPTP_CTRL_PORT, clt_addr, 0, TCPIP_PROTOCOL_UDP, &bRefused, FALSE);
                
                /* If teaming has suggested that we not allow this packet to pass, dump it. */
                if (bRefused) acpt = FALSE;
            }

            /* Otherwise, PPTP packets are treated like TCP data, which are always allowed to pass. */
        }
        else 
        {
            acpt = FALSE;
        }

#if defined(TRACE_IP) || defined(TRACE_GRE)
        DbgPrint ("accepted %d\n", acpt);
#endif
        break;
    case TCPIP_PROTOCOL_IPSEC1:
    case TCPIP_PROTOCOL_IPSEC2:
#if defined(TRACE_IP) || defined(TRACE_IPSEC)
        DbgPrint ("(IPSEC %d) send \n", IP_GET_PROT (ip_hdrp));
#endif
        if (ctxtp -> convoy_enabled)
        {
            if (!NLB_IPSEC_SESSION_SUPPORT_ENABLED())
            {
                acpt = Main_packet_check(ctxtp, svr_addr, IPSEC_CTRL_PORT, clt_addr, 0, TCPIP_PROTOCOL_UDP, &bRefused, FALSE);
                
                /* If teaming has suggested that we not allow this packet to pass, dump it. */
                if (bRefused) acpt = FALSE;
            }

            /* Otherwise, IPSec packets are treated kind of like TCP data, which are always allowed to pass. */
        }
        else
        {
            acpt = FALSE;
        }

#if defined(TRACE_IP) || defined(TRACE_IPSEC)
        DbgPrint ("accepted %d\n", acpt);
#endif
        break;
    case TCPIP_PROTOCOL_ICMP:
#if defined(TRACE_IP)
        DbgPrint ("(ICMP)\n");
#endif
        /* Allow all outgoing ICMP to pass; incoming ICMP may be filtered, however. */
        break;
    default:
        /* Allow other protocols to go out on all hosts. */
#if defined(TRACE_IP)
        DbgPrint ("(unknown)\n");
#endif
        break;
    }

#if defined(TRACE_IP) || defined(TRACE_TCP) || defined(TRACE_UDP)
    DbgPrint ("    src address   = %d.%d.%d.%d\n",
              IP_GET_SRC_ADDR (ip_hdrp, 0),
              IP_GET_SRC_ADDR (ip_hdrp, 1),
              IP_GET_SRC_ADDR (ip_hdrp, 2),
              IP_GET_SRC_ADDR (ip_hdrp, 3));
    DbgPrint ("    dst address   = %d.%d.%d.%d\n",
              IP_GET_DST_ADDR (ip_hdrp, 0),
              IP_GET_DST_ADDR (ip_hdrp, 1),
              IP_GET_DST_ADDR (ip_hdrp, 2),
              IP_GET_DST_ADDR (ip_hdrp, 3));

    DbgPrint ("\n");
#endif

    return acpt;
} 

//+----------------------------------------------------------------------------
//
// Function:   Main_ip_recv_filter 
//
// Description:  Filter incoming IP packets
//
// Arguments: MAIN_CTXT      ctxtp - 
//            const PIP_HDR   ip_hdrp - 
//            const PUCHAR    hdrp - 
//            ULONG           len - 
//            IN OUT PULONG   pOperation - 
//                  IN: has to be MAIN_FILTER_OP_NONE
//                  OUT: MAIN_FILTER_OP_NONE 
//                       MAIN_FILTER_OP_CTRL 
//                       MAIN_FILTER_OP_NBT
//
// Returns:   BOOLEAN  - TRUE if to allow the packet to go through
//                     FALSE if to drop the packet
//
// History:   kyrilf initial code
//            fengsun Created seperate function 11/14/00
//
//+----------------------------------------------------------------------------
BOOLEAN   Main_ip_recv_filter(
    PMAIN_CTXT          ctxtp,
    const PIP_HDR       ip_hdrp,
    const PUCHAR        hdrp,
    ULONG               len,       
    IN OUT PULONG       pOperation)
{
    PUDP_HDR            udp_hdrp = NULL;
    PTCP_HDR            tcp_hdrp = NULL;
    BOOLEAN             acpt = TRUE;         // Whether or not to accept the packet.
    ULONG               svr_port;            // Port for this host.
    ULONG               svr_addr;            // IP address for this host.
    ULONG               clt_port;            // Port for destination client.
    ULONG               clt_addr;            // IP address for destination client.
    ULONG               flags;               // TCP flags.
    ULONG               hlen;
    BOOLEAN             fragmented = FALSE;
    ULONG               Protocol;            // Protocol derived from IP header.
    BOOLEAN             bRefused = FALSE;    // TRUE -> BDA has refused handling this packet.

    hlen = sizeof (ULONG) * IP_GET_HLEN (ip_hdrp);

    if (len < hlen)
        return FALSE;

#if defined(TRACE_IP)
    DbgPrint ("(IP) recv\n");
    DbgPrint ("    version       = %d\n",     IP_GET_VERS (ip_hdrp));
    DbgPrint ("    header length = %d\n",     IP_GET_HLEN (ip_hdrp));
    DbgPrint ("    service type  = 0x%x\n",   IP_GET_SRVC (ip_hdrp));
    DbgPrint ("    packet length = %d\n",     IP_GET_PLEN (ip_hdrp));
    DbgPrint ("    frag ident    = %d\n",     IP_GET_FRAG_ID (ip_hdrp));
    DbgPrint ("    frag flags    = 0x%x\n",   IP_GET_FRAG_FLGS (ip_hdrp));
    DbgPrint ("    frag offset   = %d\n",     IP_GET_FRAG_OFF (ip_hdrp));
    DbgPrint ("    time to live  = %d\n",     IP_GET_TTL (ip_hdrp));
    DbgPrint ("    checksum      = 0x04%x\n", IP_GET_CHKSUM (ip_hdrp));
    DbgPrint ("    protocol      = %d ",      IP_GET_PROT (ip_hdrp));
#endif

    UNIV_ASSERT(*pOperation == MAIN_FILTER_OP_NONE);  

    /* Server address is the destination IP and client address is the source IP. */
    svr_addr = IP_GET_DST_ADDR_64(ip_hdrp);
    clt_addr = IP_GET_SRC_ADDR_64(ip_hdrp);

    /* Get the protocol ID from the IP header. */
    Protocol = IP_GET_PROT(ip_hdrp);

    /* Packets directed to the dedicated IP address are always passed through.  If the 
       cluster IP address hasn't been set (parameter error), then fall into a pass-
       through mode and pass all traffic up to the upper-layer protocols. */
    if (svr_addr == ctxtp -> ded_ip_addr || ctxtp -> cl_ip_addr == 0 ||
        svr_addr == ctxtp -> ded_bcast_addr || svr_addr == ctxtp -> cl_bcast_addr)
    {
        if (Protocol != TCPIP_PROTOCOL_UDP)
        {
            /* For UDP protocol, remote control packet has to be handled seperately, so don't accept it yet. */
            return TRUE;
        }
    }

    /* If the load module is stopped, drop most packets. */
    if (! ctxtp -> convoy_enabled)
    {
        /* Drop TCP, GRE and IPSEC immediately.  Non-remote-control UDP will also
           be dropped, but other protocols will be allowed to pass. */
        if (Protocol == TCPIP_PROTOCOL_TCP || Protocol == TCPIP_PROTOCOL_GRE ||
            Protocol == TCPIP_PROTOCOL_IPSEC1 || Protocol == TCPIP_PROTOCOL_IPSEC2)
        {
            /* For UDP protocol, remote control packet has to be handled seperately, so don't accept it yet. */
            return FALSE; 
        }
    }

#if defined(TRACE_FRAGS)
    if ((IP_GET_FRAG_FLGS(ip_hdrp) & 0x1) != 0)
    {
        DbgPrint("Fragmented datagram id %d flgs %x off %d received from %d.%d.%d.%d\n",
                 IP_GET_FRAG_ID(ip_hdrp),
                 IP_GET_FRAG_FLGS(ip_hdrp),
                 IP_GET_FRAG_OFF(ip_hdrp),
                 IP_GET_SRC_ADDR (ip_hdrp, 0),
                 IP_GET_SRC_ADDR (ip_hdrp, 1),
                 IP_GET_SRC_ADDR (ip_hdrp, 2),
                 IP_GET_SRC_ADDR (ip_hdrp, 3));
    }
#endif

    if (IP_GET_FRAG_OFF(ip_hdrp) != 0)
    {
#if defined(TRACE_FRAGS)
        if ((IP_GET_FRAG_FLGS(ip_hdrp) & 0x1) == 0)
            DbgPrint("Fragmented datagram id %d flgs %x off %d received from %d.%d.%d.%d\n",
                     IP_GET_FRAG_ID(ip_hdrp),
                     IP_GET_FRAG_FLGS(ip_hdrp),
                     IP_GET_FRAG_OFF(ip_hdrp),
                     IP_GET_SRC_ADDR (ip_hdrp, 0),
                     IP_GET_SRC_ADDR (ip_hdrp, 1),
                     IP_GET_SRC_ADDR (ip_hdrp, 2),
                     IP_GET_SRC_ADDR (ip_hdrp, 3));
#endif
        /* In optimized-fragment mode; If we have no rules, or a single rule that will
           not look at anything or only source IP address (the only exception to this
           is multiple handling mode with no affinity that also uses source port for
           its decision making), then we can just rely on normal mechanism to handle
           every fragmented packet, since the algorithm will not attempt to look past 
           the IP header.

           For multiple rules, or single rule with no affinity, apply algorithm only
           to the first packet that has UDP/TCP header and then let fragmented packets
           up on all of the systems.  TCP will then do the right thing and throw away
           the fragments on all of the systems other than the one that handled the first 
           fragment.

           If port rules will not let us handle IP fragments reliably, let TCP filter 
           them out based on sequence numbers. */

        if (! ctxtp -> optimized_frags)
            return TRUE;
        
        fragmented = TRUE;
    }
    
    switch (Protocol)
    {
    case TCPIP_PROTOCOL_TCP:
#if defined(TRACE_IP) || defined(TRACE_TCP)
        DbgPrint ("(TCP) recv\n");
#endif

        tcp_hdrp = (PTCP_HDR) hdrp;
        
        if (! fragmented)
        {
            hlen += sizeof (ULONG) * TCP_GET_HLEN (tcp_hdrp);
            
            if (len < hlen)
                return FALSE;
            
#if defined(TRACE_TCP)
            DbgPrint ("    source port   = %d\n",  TCP_GET_SRC_PORT (tcp_hdrp));
            DbgPrint ("    dest port     = %d\n",  TCP_GET_DST_PORT (tcp_hdrp));
            DbgPrint ("    seq no.       = %d\n",  TCP_GET_SEQ_NO (tcp_hdrp));
            DbgPrint ("    ack no.       = %d\n",  TCP_GET_ACK_NO (tcp_hdrp));
            DbgPrint ("    flags         = %d\n",  TCP_GET_FLAGS (tcp_hdrp));
#endif

            clt_port = TCP_GET_SRC_PORT (tcp_hdrp);
            svr_port = TCP_GET_DST_PORT (tcp_hdrp);

            /* For PPTP support, because we cannot extract a source port number from the subsequent GRE packets
               in order to match them to an existing PPTP TCP descriptor, we will hardcode the source port number
               here and then do the same for GRE packets.  This way, we can treat GRE packets like TCP data packets
               on this TCP connection.  Note that this breaks when clients are behind a NAT because a single client
               IP address will have many connections to port 1723, each with a different source port.  In that case,
               we break because we are not reference counting SYNs v. FINs - i.e., the first PPTP connection to go
               down would destroy the TCP descriptor for (Client IP, 0, Server IP, 1723).  There are two solutions;
               (1) reference count re-used descriptors (so we require 2 FINs per SYN, not just 2 period), or (2)
               have PPTP use our notification APIs to give us something that we can look for in the GRE packets, 
               such as a call ID, to identify the GRE packet as belonging to a known session. */
            if (svr_port == PPTP_CTRL_PORT)
            {
                if (NLB_PPTP_SESSION_SUPPORT_ENABLED())
                {
                    clt_port = 0;
                }
                else
                {
                    UNIV_ASSERT(ctxtp -> convoy_enabled);
                    
                    acpt = Main_packet_check(ctxtp, svr_addr, svr_port, clt_addr, clt_port, TCPIP_PROTOCOL_UDP, &bRefused, FALSE);
	            
                    /* If teaming has suggested that we not allow this packet to pass, dump it. */
                    if (bRefused) acpt = FALSE;
                    
                    break;
                }
            }

            flags = TCP_GET_FLAGS (tcp_hdrp);
        }
        else
        {
            clt_port = 0;
            svr_port = 0;
            flags = 0;
        }

        /* Apply filtering algorithm.  Process connection boundaries different from regular packets. */

        if (flags & TCP_FLAG_SYN)
        {
#if defined(TRACE_CNCT)
            DbgPrint ("incoming SYN %x from %d.%d.%d.%d:%d\n",
                      TCP_GET_FLAGS (tcp_hdrp),
                      IP_GET_SRC_ADDR (ip_hdrp, 0),
                      IP_GET_SRC_ADDR (ip_hdrp, 1),
                      IP_GET_SRC_ADDR (ip_hdrp, 2),
                      IP_GET_SRC_ADDR (ip_hdrp, 3),
                      TCP_GET_SRC_PORT (tcp_hdrp));
#endif
            acpt = Main_conn_advise(ctxtp, svr_addr, svr_port, clt_addr, clt_port, TCPIP_PROTOCOL_TCP, CVY_CONN_UP, &bRefused, FALSE);

            /* If teaming has suggested that we not allow this packet to pass, dump it. */
            if (bRefused) acpt = FALSE;
        }
        else if (flags & TCP_FLAG_FIN)
        {
#if defined(TRACE_CNCT)
            DbgPrint ("incoming FIN %x from %d.%d.%d.%d:%d\n",
                      TCP_GET_FLAGS (tcp_hdrp),
                      IP_GET_SRC_ADDR (ip_hdrp, 0),
                      IP_GET_SRC_ADDR (ip_hdrp, 1),
                      IP_GET_SRC_ADDR (ip_hdrp, 2),
                      IP_GET_SRC_ADDR (ip_hdrp, 3),
                      TCP_GET_SRC_PORT (tcp_hdrp));
#endif
            acpt = Main_conn_advise(ctxtp, svr_addr, svr_port, clt_addr, clt_port, TCPIP_PROTOCOL_TCP, CVY_CONN_DOWN, &bRefused, FALSE);

            /* If teaming has suggested that we not allow this packet to pass, dump it. */
            if (bRefused) acpt = FALSE;
        }
        else if (flags & TCP_FLAG_RST)
        {
#if defined(TRACE_CNCT)
            DbgPrint ("incoming RST %x from %d.%d.%d.%d:%d\n",
                      TCP_GET_FLAGS (tcp_hdrp),
                      IP_GET_SRC_ADDR (ip_hdrp, 0),
                      IP_GET_SRC_ADDR (ip_hdrp, 1),
                      IP_GET_SRC_ADDR (ip_hdrp, 2),
                      IP_GET_SRC_ADDR (ip_hdrp, 3),
                      TCP_GET_SRC_PORT (tcp_hdrp));
#endif
            acpt = Main_conn_advise(ctxtp, svr_addr, svr_port, clt_addr, clt_port, TCPIP_PROTOCOL_TCP, CVY_CONN_RESET, &bRefused, FALSE);

            /* If teaming has suggested that we not allow this packet to pass, dump it. */
            if (bRefused) acpt = FALSE;
        }
        else
        {
            UNIV_ASSERT(! (flags & (TCP_FLAG_SYN | TCP_FLAG_FIN | TCP_FLAG_RST)));

            acpt = Main_packet_check(ctxtp, svr_addr, svr_port, clt_addr, clt_port, TCPIP_PROTOCOL_TCP, &bRefused, FALSE);

            /* If teaming has suggested that we not allow this packet to pass, dump it. */
            if (bRefused) acpt = FALSE;

            /* Post-process NBT traffic on receive. */
            if (svr_port == NBT_SESSION_PORT && ctxtp -> params . nbt_support && acpt)
                * pOperation = MAIN_FILTER_OP_NBT;
        }

        break;

    case TCPIP_PROTOCOL_UDP:
#if defined(TRACE_IP) || defined(TRACE_UDP)
        DbgPrint ("(UDP) recv \n");
#endif
        udp_hdrp = (PUDP_HDR) hdrp;

        hlen += sizeof (UDP_HDR);

        if (! fragmented)
        {
            if (len < hlen)
                return FALSE;

#if defined(TRACE_UDP)
            DbgPrint ("    source port   = %d\n",  UDP_GET_SRC_PORT (udp_hdrp));
            DbgPrint ("    dest port     = %d\n",  UDP_GET_DST_PORT (udp_hdrp));
            DbgPrint ("    length        = %d\n",  UDP_GET_LEN (udp_hdrp));
#endif
        }

        if (! fragmented)
        {
            clt_port = UDP_GET_SRC_PORT (udp_hdrp);
            svr_port = UDP_GET_DST_PORT (udp_hdrp);
        }
        else
        {
            clt_port = 0;
            svr_port = 0;
        }

        if (! fragmented)
        {
            if (clt_port == ctxtp -> params . rct_port || clt_port == CVY_DEF_RCT_PORT_OLD)
            {
                /* Allow incoming remote control response to go through on all hosts. */
                PIOCTL_REMOTE_HDR rct_hdrp = (PIOCTL_REMOTE_HDR) UDP_GET_DGRAM_PTR(udp_hdrp);

                if (rct_hdrp -> code == IOCTL_REMOTE_CODE) break;
            }

            /* Let remote control request go through regardless whether remote control is 
               enabled.  Remote query could be processed even if remote control is disabled.
               The request will be queued up and handled on receive complete. */
            if (svr_port == ctxtp -> params . rct_port || svr_port == CVY_DEF_RCT_PORT_OLD)
            {
                PIOCTL_REMOTE_HDR rct_hdrp = (PIOCTL_REMOTE_HDR) UDP_GET_DGRAM_PTR(udp_hdrp);

                /* Make sure this is our remote message. note that we are assuming that RCT
                   header imediatelly folows the UDP header.  This is only TRUE on receive. */
                if (rct_hdrp -> code == IOCTL_REMOTE_CODE)
                {
                    /* Consume receives and handle them during the receive complete event. */
#if defined(TRACE_RCT)
                    DbgPrint ("(RCT) received on port %d from %d.%d.%d.%d:%d\n",
                              svr_port,
                              IP_GET_SRC_ADDR (ip_hdrp, 0),
                              IP_GET_SRC_ADDR (ip_hdrp, 1),
                              IP_GET_SRC_ADDR (ip_hdrp, 2),
                              IP_GET_SRC_ADDR (ip_hdrp, 3),
                              clt_port);
#endif
                    *pOperation = MAIN_FILTER_OP_CTRL;
                    break;
                }
            }
        }

        /* Packets directed to the dedicated IP address are always passed through.  If the 
           cluster IP address hasn't been set (parameter error), then fall into a pass-
           through mode and pass all traffic up to the upper-layer protocols. */
        if (svr_addr == ctxtp -> ded_ip_addr || ctxtp -> cl_ip_addr == 0 ||
            svr_addr == ctxtp -> ded_bcast_addr || svr_addr == ctxtp -> cl_bcast_addr)
            break;

        /* Apply filtering algorithm. */
        if (ctxtp -> convoy_enabled)
        {
            /* UDP packets that arrive on port 500 are IPSec control packets. */
            if (NLB_IPSEC_SESSION_SUPPORT_ENABLED() && svr_port == IPSEC_CTRL_PORT)
            {
                /* First, parse the IKE payload to find out whether or not 
                   this is an initial contact IKE Main Mode SA. */
                BOOLEAN bIsIKEInitialContact = Main_parse_ipsec((PUCHAR)udp_hdrp + sizeof(UDP_HDR), len - hlen);
                
                /* If this is an intial contact, treat this as a TCP SYN.  Otherwise, treat it like a TCP data packet. */
                if (bIsIKEInitialContact) {
                    /* Because there may not be an explicit connection down notififcation from IPSec, we first need to clean out any 
                       descriptor that might already exist for this tuple.  If we still own the bucket, we'll just end up re-creating 
                       it, but if we do not, then somebody else will, so we have to clean out the descriptor to keep us from handling
                       another host's traffic.  Since this is just as likely to fail as succeed, and we don't really care either way,
                       ignore the return value. */
                    Main_conn_advise(ctxtp, svr_addr, svr_port, clt_addr, clt_port, TCPIP_PROTOCOL_IPSEC1, CVY_CONN_RESET, &bRefused, FALSE);
                        
                    /* If we own the bucket for this tuple, we'll create a descriptor and accept the packet.  If the client is not behind a 
                       NAT, then the source port will be IPSEC_CTRL_PORT (500).  If the client is behind a NAT, the source port will be 
                       arbitrary, but will persist for the entire IPSec session, so we can use it to distinguish clients behind a NAT.  In
                       such a scenario, all IPSec data (non-control traffic) is encapsulated in UDP packets, so the packet check will be 
                       performed in the else case of this branch.  In a non-NAT case, the data is in IPSec1/2 protocol packets, which will
                       be handled analagously in another case of this protocol switch statement. */
                    acpt = Main_conn_advise(ctxtp, svr_addr, svr_port, clt_addr, clt_port, TCPIP_PROTOCOL_IPSEC1, CVY_CONN_UP, &bRefused, FALSE);
                } else {
                    /* If this is part of an existing IPSec session, then we have to have a descriptor in order to accpet it.  This will 
                       keep all IPSec traffic during the key exchange sticky, plus the data exchange if the client is behind a NAT. */
                    acpt = Main_packet_check(ctxtp, svr_addr, svr_port, clt_addr, clt_port, TCPIP_PROTOCOL_IPSEC1, &bRefused, FALSE);
                }
                
                if (bRefused) acpt = FALSE;
            } else {
                acpt = Main_packet_check(ctxtp, svr_addr, svr_port, clt_addr, clt_port, TCPIP_PROTOCOL_UDP, &bRefused, FALSE);
                
                /* If teaming has suggested that we not allow this packet to pass, dump it. */
                if (bRefused) acpt = FALSE;
            }
        }
        else
        {
            acpt = FALSE;
        }

        break;

    case TCPIP_PROTOCOL_GRE:
#if defined(TRACE_IP) || defined(TRACE_GRE)
        DbgPrint ("(GRE) recv");
#endif
        
        if (NLB_PPTP_SESSION_SUPPORT_ENABLED())
        {
            /* For PPTP support, because we cannot extract a source port number from the subsequent GRE packets
               in order to match them to an existing PPTP TCP descriptor, we will hardcode the source port number
               here and then do the same for GRE packets.  This way, we can treat GRE packets like TCP data packets
               on this TCP connection.  Note that this breaks when clients are behind a NAT because a single client
               IP address will have many connections to port 1723, each with a different source port.  In that case,
               we break because we are not reference counting SYNs v. FINs - i.e., the first PPTP connection to go
               down would destroy the TCP descriptor for (Client IP, 0, Server IP, 1723).  There are two solutions;
               (1) reference count re-used descriptors (so we require 2 FINs per SYN, not just 2 period), or (2)
               have PPTP use our notification APIs to give us something that we can look for in the GRE packets, 
               such as a call ID, to identify the GRE packet as belonging to a known session. */
            acpt = Main_packet_check(ctxtp, svr_addr, PPTP_CTRL_PORT, clt_addr, 0, TCPIP_PROTOCOL_TCP, &bRefused, FALSE);
        }
        else
        {
            acpt = Main_packet_check(ctxtp, svr_addr, PPTP_CTRL_PORT, clt_addr, 0, TCPIP_PROTOCOL_UDP, &bRefused, FALSE);
        }
        
        /* If teaming has suggested that we not allow this packet to pass, dump it. */
        if (bRefused) acpt = FALSE;

#if defined(TRACE_IP) || defined(TRACE_GRE)
        DbgPrint ("accepted %d\n", acpt);
#endif
        break;

    case TCPIP_PROTOCOL_IPSEC1:
    case TCPIP_PROTOCOL_IPSEC2:
#if defined(TRACE_IP) || defined(TRACE_IPSEC)
        DbgPrint ("(IPSEC %d) recv \n", IP_GET_PROT (ip_hdrp));
#endif
        if (NLB_IPSEC_SESSION_SUPPORT_ENABLED()) 
        {
            /* NLB_SESSION_SUPPORT: If this is part of an existing IPSec session, then we have to have a descriptor in order to accpet it.  Because 
               this can only happen in the case where the client is NOT behind a NAT, we can safely hardcode the client port
               to IPSEC_CTRL_PORT (500).  In NAT scenarios, the data traffic is UDP encapsulated, not IPSec protocol type 
               traffic, and is distinguished by source port. */
            acpt = Main_packet_check(ctxtp, svr_addr, IPSEC_CTRL_PORT, clt_addr, IPSEC_CTRL_PORT, TCPIP_PROTOCOL_IPSEC1, &bRefused, FALSE);
        }
        else
        {
            acpt = Main_packet_check(ctxtp, svr_addr, IPSEC_CTRL_PORT, clt_addr, 0, TCPIP_PROTOCOL_UDP, &bRefused, FALSE);
        }

        /* If teaming has suggested that we not allow this packet to pass, dump it. */
        if (bRefused) acpt = FALSE;

#if defined(TRACE_IP) || defined(TRACE_IPSEC)
        DbgPrint ("accepted %d\n", acpt);
#endif
        break;
    case TCPIP_PROTOCOL_ICMP:
        /* In BDA teaming mode, we don't want all hosts to send up ICMP traffic, just one, due
           to multiplicitive effects in a clustered router configuration.  Hardcode the ports,
           since ICMP has no notion of port numbers. */
        acpt = Main_packet_check(ctxtp, svr_addr, 0, clt_addr, 0, TCPIP_PROTOCOL_UDP, &bRefused, TRUE);

        /* If teaming has suggested that we not allow this packet to pass, dump it. */
        if (bRefused) acpt = FALSE;

        break;
    default:
        //
        //  Allow other protocols to go through on all hosts
        //
#if defined(TRACE_IP)
        DbgPrint ("(unknown)\n");
#endif
        break;
    }

#if defined(TRACE_IP) || defined(TRACE_TCP) || defined(TRACE_UDP)
    DbgPrint ("    src address   = %d.%d.%d.%d\n",
              IP_GET_SRC_ADDR (ip_hdrp, 0),
              IP_GET_SRC_ADDR (ip_hdrp, 1),
              IP_GET_SRC_ADDR (ip_hdrp, 2),
              IP_GET_SRC_ADDR (ip_hdrp, 3));
    DbgPrint ("    dst address   = %d.%d.%d.%d\n",
              IP_GET_DST_ADDR (ip_hdrp, 0),
              IP_GET_DST_ADDR (ip_hdrp, 1),
              IP_GET_DST_ADDR (ip_hdrp, 2),
              IP_GET_DST_ADDR (ip_hdrp, 3));

    DbgPrint ("\n");
#endif

    return acpt;
} 



ULONG   Main_recv_ping (
    PMAIN_CTXT          ctxtp,
    PMAIN_FRAME_HDR     cvy_hdrp)
{
#if defined(TRACE_CVY)
    DbgPrint ("(CVY %d)\n", cvy_hdrp -> host);
#endif

    /* V1.3.2b - do not need to protect here since we are not making the
       decision to call Load_ routines */

    if (! ctxtp -> convoy_enabled)
        return FALSE;

    /* only accept messages from our cluster */

    if (cvy_hdrp->cl_ip_addr == 0 ||
        cvy_hdrp->cl_ip_addr != ctxtp -> cl_ip_addr)
        return FALSE;

    /* sanity check host id */

    if (cvy_hdrp -> host == 0 || cvy_hdrp -> host > CVY_MAX_HOSTS)
    {
        UNIV_PRINT (("bad host id %d", cvy_hdrp -> host));

        if (! ctxtp -> bad_host_warned)
        {
            LOG_MSG1 (MSG_ERROR_HOST_ID, MSG_NONE, cvy_hdrp -> host);
            ctxtp -> bad_host_warned = TRUE;
        }

        return FALSE;
    }

    if ((cvy_hdrp -> host != ctxtp -> params . host_priority) &&
        (cvy_hdrp -> ded_ip_addr == ctxtp -> ded_ip_addr) &&
        (ctxtp -> ded_ip_addr != 0))
    {
        UNIV_PRINT (("duplicate dedicated IP address 0x%x", ctxtp -> ded_ip_addr));

        if (! ctxtp -> dup_ded_ip_warned)
        {
            LOG_MSG (MSG_ERROR_DUP_DED_IP_ADDR, ctxtp -> params . ded_ip_addr);
            ctxtp -> dup_ded_ip_warned = TRUE;
        }
    } 

    /* might want to take appropriate actions for a message from a host
       running different version number of software */

    if (cvy_hdrp -> version != CVY_VERSION_FULL)
    {
        ;
    }

    return TRUE;

} /* end Main_recv_ping */


PNDIS_PACKET Main_send (
    PMAIN_CTXT          ctxtp,
    PNDIS_PACKET        packetp,
    PULONG              exhausted)
{
    PUCHAR              hdrp, mac_hdrp;
    ULONG               plen;
    USHORT              sig;
    PUCHAR              tcp_hdrp;
    PNDIS_PACKET        newp;
    ULONG               op = MAIN_FILTER_OP_NONE;
    USHORT              group;


    * exhausted = FALSE;

    /* extract payload, IP and MAC pointers */

    hdrp = Main_frame_parse (ctxtp, packetp, & mac_hdrp, 0, & tcp_hdrp, & plen,
                             & sig, & group, TRUE);

    if (hdrp == NULL)
        return NULL;

    /* process IP frames */

    if (sig == TCPIP_IP_SIG)  /* v2.0.6 */
    {
        if (tcp_hdrp == NULL ||
            ! Main_ip_send_filter (ctxtp, (PIP_HDR) hdrp, tcp_hdrp, plen, & op))
            return NULL;
    }

    /* process ARP frames */

    else if (sig == TCPIP_ARP_SIG)
    {
//        ctxtp -> arps_count ++;
        if (! Main_arp_handle (ctxtp, (PARP_HDR) hdrp, plen, TRUE))  /* v2.0.6 */
            return NULL;
    }

    /* if still sending out - get a new packet */

    newp = Main_packet_get (ctxtp, packetp, TRUE, group, plen);

    * exhausted = (newp == NULL);

    /* in unicast mode, if this is a remote control packet, make sure it will
       loopback to us. */

    if (newp != NULL && op == MAIN_FILTER_OP_CTRL)
        NdisClearPacketFlags(newp, NDIS_FLAGS_DONT_LOOPBACK);

    return newp;

} /* end Main_send */


PNDIS_PACKET Main_recv (
    PMAIN_CTXT          ctxtp,
    PNDIS_PACKET        packetp)
{
    PMAIN_FRAME_HDR     cvy_hdrp;
    PUCHAR              hdrp, mac_hdrp;
    ULONG               len, dlen, plen;
    USHORT              sig = 0;
    PUCHAR              tcp_hdrp;
    PNDIS_PACKET        newp;
    PMAIN_BUFFER        bp;
    PMAIN_PROTOCOL_RESERVED resp;
    PNDIS_PACKET_OOB_DATA   oobp;
    ULONG               size, xferred;
    PLIST_ENTRY         entryp;
    ULONG               op = MAIN_FILTER_OP_NONE;
    PNBT_HDR            nbt_hdrp;
    USHORT              group;
    ULONG               packet_lowmark;

    /* extract payload, IP and MAC pointers */

    hdrp = Main_frame_parse (ctxtp, packetp, & mac_hdrp, 0, & tcp_hdrp, & len,
                             & sig, & group, FALSE);

    if (hdrp == NULL)
        return NULL;

    plen = len;

    cvy_hdrp = (PMAIN_FRAME_HDR) hdrp;

    /* process IP frames */

    if (sig == TCPIP_IP_SIG)  /* v2.0.6 */
    {
        if (tcp_hdrp == NULL ||
            ! Main_ip_recv_filter (ctxtp, (PIP_HDR) hdrp, tcp_hdrp, plen, & op))
            return NULL;
    }

    /* process ARP frames */

    else if (sig == TCPIP_ARP_SIG)
    {
        if (! Main_arp_handle (ctxtp, (PARP_HDR) hdrp, plen, FALSE))  /* v2.0.6 */
            return NULL;
    }

    /* process heartbeat frames */

    else if ((sig == MAIN_FRAME_SIG || sig == MAIN_FRAME_SIG_OLD) &&
             cvy_hdrp -> code == MAIN_FRAME_CODE)
    {
        /* make sure it looks acceptable */

        if (len >= sizeof (MAIN_FRAME_HDR) && Main_recv_ping (ctxtp, cvy_hdrp))
        {

#if defined (NLB_MIXED_MODE_CLUSTERS)
	    // code for migrating between cluster modes
	    /* reject the packet if the mac address is not ours to allow unicast and multicast clusters to exist */
	    {
		ULONG    doff = CVY_MAC_DST_OFF (ctxtp -> medium);


		if (ctxtp -> params . mcast_support &&
		    (! CVY_MAC_ADDR_COMP (ctxtp -> medium, mac_hdrp + doff, & ctxtp -> ded_mac_addr)))
		{
		    return NULL;
		}
	    }
#endif /* NLB_MIXED_MODE_CLUSTERS */

            /* V2.2 switch into backward compatibility mode if a convoy hearbeat
               is detected */

            if (sig == MAIN_FRAME_SIG_OLD && ! ctxtp -> etype_old)
            {
                if (ctxtp -> medium == NdisMedium802_3)
                {
                    CVY_ETHERNET_ETYPE_SET (& ctxtp -> media_hdr . ethernet, MAIN_FRAME_SIG_OLD);
                }

                ctxtp -> etype_old = TRUE;
            }

            if (len >= (sizeof (MAIN_FRAME_HDR) + sizeof (PING_MSG)))
            {
                /* recompute pointer to the ping message */

                Main_frame_parse (ctxtp, packetp, & mac_hdrp, sizeof (MAIN_FRAME_HDR),
                                  & hdrp, & len, & sig, & group, FALSE);

                /* have load deal with contents */

                NdisAcquireSpinLock (& ctxtp -> load_lock);
                if (ctxtp -> convoy_enabled && hdrp != NULL) /* V1.3.2b, V2.0.6 */
                    Load_msg_rcv (& ctxtp -> load, (PPING_MSG) hdrp);
                NdisReleaseSpinLock (& ctxtp -> load_lock);
            }
            else
            {
                UNIV_PRINT (("PING message size mismatch %d vs %d", len, sizeof (MAIN_FRAME_HDR) + sizeof (PING_MSG)));
            }
        }

        if (! ctxtp -> params . netmon_alive)
            return NULL;
    }

    /* post-process NBT traffic */

    if (op == MAIN_FILTER_OP_NBT)
    {
        dlen = TCP_GET_DGRAM_LEN ((PIP_HDR) hdrp, (PTCP_HDR) tcp_hdrp);

        /* have to re-parse packet to find offset to NBT header */

        hdrp = Main_frame_parse (ctxtp, packetp, & mac_hdrp, len - dlen,
                                 (PUCHAR * ) & nbt_hdrp, & len, & sig, & group,
                                 FALSE);

        /* V2.1 let TCP module mask machine name if necessary */

        if (hdrp != NULL && nbt_hdrp != NULL &&
            plen >= (((PUCHAR) nbt_hdrp) - ((PUCHAR) hdrp) + dlen))
        {
            Tcpip_nbt_handle (& ctxtp -> tcpip, (PIP_HDR) hdrp, (PTCP_HDR) tcp_hdrp,
                              dlen, nbt_hdrp);
        }
    }

    /* get a new packet */

    if (op != MAIN_FILTER_OP_CTRL)
    {
        newp = Main_packet_get (ctxtp, packetp, FALSE, group, plen);

        if (newp == NULL)
            ctxtp -> cntr_recv_no_buf ++; /* V2.0.6 */
    }

    /* copy incoming remote control packet into our own, so we re-use it later
       to send back reply */

    else
    {
        /* V1.3.2b */

        newp = Main_packet_alloc (ctxtp, FALSE, & packet_lowmark);

        if (newp == NULL)
        {
            ctxtp -> cntr_recv_no_buf ++; /* V2.0.6 */
            return NULL;
        }

        /* get a buffer */

        while (1)
        {
            NdisAcquireSpinLock (& ctxtp -> buf_lock);
            entryp = RemoveHeadList (& ctxtp -> buf_list);

            if (entryp != & ctxtp -> buf_list)
            {
                ctxtp->num_bufs_out++;
                NdisReleaseSpinLock (& ctxtp -> buf_lock);
                break;
            }

            NdisReleaseSpinLock (& ctxtp -> buf_lock);

            UNIV_PRINT (("OUT OF BUFFERS!!!"));

            if (! Main_bufs_alloc (ctxtp))
            {
                NdisFreePacket (newp);
                ctxtp -> cntr_recv_no_buf ++; /* V2.0.6 */
                return NULL;
            }
        }

        bp = CONTAINING_RECORD (entryp, MAIN_BUFFER, link);
        UNIV_ASSERT (bp -> code == MAIN_BUFFER_CODE);

        size = ctxtp -> buf_mac_hdr_len + len;

        NdisAdjustBufferLength (bp -> full_bufp, size);
        NdisChainBufferAtFront (newp, bp -> full_bufp);

        /* copy actual data */

        NdisCopyFromPacketToPacket (newp, 0, size, packetp, 0, & xferred);

        /* copy OOB info */

        oobp = NDIS_OOB_DATA_FROM_PACKET (newp);
        oobp -> HeaderSize               = ctxtp -> buf_mac_hdr_len;
        oobp -> MediaSpecificInformation = NULL;
        oobp -> SizeMediaSpecificInfo    = 0;
        oobp -> TimeSent                 = 0;
        oobp -> TimeReceived             = 0;

        /* shouse - Because packets marked as CTRL never pass above NLB in the 
           network stack, we can always use the ProtocolReserved field. */
        resp = MAIN_PROTOCOL_FIELD (newp);
        
        if (packet_lowmark)
            NDIS_SET_PACKET_STATUS (newp, NDIS_STATUS_RESOURCES);

        /* set protocol reserved fields */

        resp -> type   = MAIN_PACKET_TYPE_CTRL;
        resp -> miscp  = bp;
        resp -> data   = 0;

        /* V2.0.6 */

        resp -> group  = group;
        resp -> len    = plen; /* 64-bit -- ramkrish */

        /* Because this is a remote control packet, MiniportReserved
           should not contain a pointer to a private protocol buffer. */
        ASSERT(!MAIN_MINIPORT_FIELD(newp));
    }

    return newp;

} /* end Main_recv */


PNDIS_PACKET Main_recv_indicate (
    PMAIN_CTXT          ctxtp,
    NDIS_HANDLE         handle,
    PUCHAR              look_buf,
    UINT                look_len,
    UINT                packet_len,
    PUCHAR              head_buf,
    UINT                head_len,
    PBOOLEAN            accept)
{
    PIP_HDR             ip_hdrp;
    PUCHAR              tcp_hdrp;
    USHORT              sig = 0;
    PMAIN_FRAME_HDR     cvy_hdrp;
    PUCHAR              hdrp;
    PNDIS_PACKET        newp;
    PMAIN_PROTOCOL_RESERVED resp = NULL;
    PLIST_ENTRY         entryp;
    PMAIN_BUFFER        bp;
    NDIS_STATUS         status;
    ULONG               op = MAIN_FILTER_OP_NONE;
    ULONG               len, xferred, off, dlen;
    PNBT_HDR            nbt_hdrp;
    ULONG               plen;
    USHORT              group;
    ULONG               packet_lowmark;
    UINT                offset;


    /* find pointer to payload */

    *accept = FALSE;
    hdrp = Main_frame_find (ctxtp, head_buf, look_buf, look_len, & sig);

    if (hdrp == NULL)
        return NULL;

    cvy_hdrp = (PMAIN_FRAME_HDR) hdrp;

    /* V2.0.6 find out actual payload length (minus LLC/SNAP) */

    plen = (ULONG)(packet_len - (hdrp - look_buf));

    /* process IP frames */

    if (sig == TCPIP_IP_SIG)
    {
        ip_hdrp = (PIP_HDR) hdrp;

        tcp_hdrp = hdrp + sizeof (ULONG) * IP_GET_HLEN (ip_hdrp);

        if (! Main_ip_recv_filter (ctxtp, ip_hdrp, tcp_hdrp, plen, & op))
            return NULL;
    }

    /* process heartbeat frames */

    else if ((sig == MAIN_FRAME_SIG || sig == MAIN_FRAME_SIG_OLD) &&
             cvy_hdrp -> code == MAIN_FRAME_CODE)
    {
        /* make sure frame looks acceptable */

        if (plen >= (sizeof (MAIN_FRAME_HDR) + sizeof (PING_MSG)))
        {
            /* V2.2 switch into backward compatibility mode if a convoy hearbeat
               is detected */

            if (sig == MAIN_FRAME_SIG_OLD && ! ctxtp -> etype_old)
            {
                if (ctxtp -> medium == NdisMedium802_3)
                {
                    CVY_ETHERNET_ETYPE_SET (& ctxtp -> media_hdr . ethernet, MAIN_FRAME_SIG_OLD);
                }

                ctxtp -> etype_old = TRUE;
            }

            if (Main_recv_ping (ctxtp, cvy_hdrp))
            {
#if defined (NLB_MIXED_MODE_CLUSTERS)
		// code for migrating between cluster modes
		/* reject the packet if the mac address is broadcast to allow unicast and multicast clusters to exist */
		{
		    ULONG    doff = CVY_MAC_DST_OFF (ctxtp -> medium);


		    if (ctxtp -> params . mcast_support &&
			(! CVY_MAC_ADDR_COMP (ctxtp -> medium, head_buf + doff, & ctxtp -> cl_mac_addr)))
		    {
			return NULL;
		    }
		}
#endif /* NLB_MIXED_MODE_CLUSTERS */

                /* V1.3.2b - if entire frame is in lookahead - let load deal with
                   it now */

#ifndef _WIN64 /* 64-bit -- ramkrish */
/* The data in the buffer may not be aligned. so copy the data into our own structure */
                if (look_len == packet_len)
                {
                    NdisAcquireSpinLock (& ctxtp -> load_lock);
                    if (ctxtp -> convoy_enabled)
                        Load_msg_rcv (& ctxtp -> load, (PPING_MSG) (cvy_hdrp + 1));
                    NdisReleaseSpinLock (& ctxtp -> load_lock);
                }

                /* get a fresh frame descriptor and perform data transfer */

                else
#endif         /* 64-bit -- ramkrish */
                {
                    newp = Main_frame_get (ctxtp, FALSE, & len, MAIN_PACKET_TYPE_PING);

                    if (newp == NULL)
                    {
                        UNIV_PRINT (("error getting frame packet"));
                        return NULL;
                    }

                    NdisTransferData (& status, ctxtp -> mac_handle, handle, 0,
                                        len, newp, & xferred);

                    if (status != NDIS_STATUS_PENDING)
                        Main_xfer_done (ctxtp, newp, status, xferred);
                }
            }
        }
        else
        {
            UNIV_PRINT (("PING message size mismatch %d vs %d", packet_len - (hdrp - look_buf), sizeof (MAIN_FRAME_HDR) + sizeof (PING_MSG)));
        }

        if (! ctxtp -> params . netmon_alive)
            return NULL;
    }

    /* If statement added for NT 5.1 - ramkrish */
    * accept = TRUE;

    /* If the packet is being accepted and indicated to the protocol layer,
     * then modify the destination mac address in multicast mode.
     */
    if (sig == TCPIP_IP_SIG && op == MAIN_FILTER_OP_NONE)
    {
        offset = CVY_MAC_DST_OFF(ctxtp -> medium);

        if (ctxtp -> params . mcast_support &&
            CVY_MAC_ADDR_COMP(ctxtp -> medium, head_buf + offset, & ctxtp -> cl_mac_addr) )
        {
                CVY_MAC_ADDR_COPY(ctxtp -> medium, head_buf + offset, & ctxtp -> ded_mac_addr);
        }

        return NULL;
    }

    /* The ARPs and NBT packets need to be modified */
    /* V1.3.2b - get fresh packet */

    /* shouse - On indicated receives, we need to use the MiniportReserved field to store
       our private data.  If allocation fails, bail out and dump the packet.  CTRL packets
       can continue to use ProtocolReserved because they never go up the stack. */
    if (op != MAIN_FILTER_OP_CTRL) {
        resp = (PMAIN_PROTOCOL_RESERVED) NdisAllocateFromNPagedLookasideList (& ctxtp -> resp_list);
    
        if (!resp) {
            * accept = FALSE; /* ###### no resources for the packet, so drop it */
            return NULL;
        }
    }

    newp = Main_packet_alloc (ctxtp, FALSE, & packet_lowmark);

    if (newp == NULL)
    {
        * accept = FALSE; /* ###### cannot allocate packet, so drop it */
        ctxtp -> cntr_recv_no_buf ++; /* V2.0.6 */

        /* shouse - If we can't allocate a packet, put the private buffer back on the list. */
        if (resp) NdisFreeToNPagedLookasideList (& ctxtp -> resp_list, resp);

        return NULL;
    }

    /* get fresh buffer */

    while (1)
    {

        NdisAcquireSpinLock (& ctxtp -> buf_lock);
        entryp = RemoveHeadList (& ctxtp -> buf_list);

        if (entryp != & ctxtp -> buf_list)
        {
            ctxtp->num_bufs_out++;
            NdisReleaseSpinLock (& ctxtp -> buf_lock);
            break;
        }

        NdisReleaseSpinLock (& ctxtp -> buf_lock);

        UNIV_PRINT (("OUT OF BUFFERS!!!"));

        if (! Main_bufs_alloc (ctxtp))
        {
            NdisFreePacket (newp);
            ctxtp -> cntr_recv_no_buf ++; /* V2.0.6 */
            * accept = FALSE; /* ###### no resources for the packet, so drop it */

            /* shouse - If buffer allocation fails, put the resp buffer back on the list. */
            if (resp) NdisFreeToNPagedLookasideList (& ctxtp -> resp_list, resp);

            return NULL;
        }
    }

    bp = CONTAINING_RECORD (entryp, MAIN_BUFFER, link);
    UNIV_ASSERT (bp -> code == MAIN_BUFFER_CODE);

    UNIV_ASSERT_VAL2 (head_len == ctxtp -> buf_mac_hdr_len, head_len, ctxtp -> buf_mac_hdr_len);

    /* copy media header into the buffer */

    NdisMoveMemory (bp -> data, head_buf, head_len);

    /* V1.3.0b multicast support V1.3.1b */

    off = CVY_MAC_DST_OFF (ctxtp -> medium);

    /* V2.0.6 figure out frame type for statistics */

    if (! CVY_MAC_ADDR_MCAST (ctxtp -> medium, head_buf + off))
        group = MAIN_FRAME_DIRECTED;
    else
    {
        if (CVY_MAC_ADDR_BCAST (ctxtp -> medium, head_buf + off))
            group = MAIN_FRAME_BROADCAST;
        else
            group = MAIN_FRAME_MULTICAST;
    }

    /* mask cluster MAC address so not to confuse the protocol */

    if (ctxtp -> params . mcast_support)
    {
        if (CVY_MAC_ADDR_COMP (ctxtp -> medium, bp -> data + off, & ctxtp -> cl_mac_addr))
            CVY_MAC_ADDR_COPY (ctxtp -> medium, bp -> data + off, & ctxtp -> ded_mac_addr);
    }

    NdisAdjustBufferLength (bp -> full_bufp, head_len + packet_len);

    /* only bother to transfer lookahead buffer if entire packet fits into
        it - for some reason doing NdisTransferData with offset does not
        work on some cards (ex. Intel 10 ISA) */

    UNIV_ASSERT_VAL2 (packet_len <= ctxtp -> max_frame_size, packet_len, ctxtp -> max_frame_size);

    if (look_len < packet_len)
    {
        NdisAdjustBufferLength (bp -> frame_bufp, packet_len);
        NdisChainBufferAtFront (newp, bp -> frame_bufp);
    }
    else
    {
        UNIV_ASSERT_VAL2 (look_len <= ctxtp -> max_frame_size, look_len, ctxtp -> max_frame_size);
        UNIV_ASSERT_VAL2 (bp -> framep == bp -> data + ctxtp -> buf_mac_hdr_len, (LONG_PTR) bp -> framep, (LONG_PTR) bp -> data);
        NdisMoveMemory (bp -> framep, look_buf, look_len);
        NdisChainBufferAtFront (newp, bp -> full_bufp);
    }

    /* after lookahead has been copied - do data modification. note that we
       are assuming that frames that require modification fit in the lookahead
       buffer */

    if (sig == TCPIP_ARP_SIG)
    {
        UNIV_ASSERT_VAL2 (look_len == packet_len, look_len, packet_len);

        /* recompute the offset from the beginning of frame */

        hdrp = Main_frame_find (ctxtp, bp -> data, bp -> framep, look_len, & sig);

        if (hdrp != NULL)
            (void) Main_arp_handle (ctxtp, (PARP_HDR) hdrp, plen, FALSE);  /* v2.0.6 */
    }

    if (op == MAIN_FILTER_OP_NBT)
    {
        UNIV_ASSERT_VAL2 (look_len == packet_len, look_len, packet_len);

        /* recompute the offset from the beginning of frame */

        hdrp = Main_frame_find (ctxtp, bp -> data, bp -> framep, look_len, & sig);

        if (hdrp != NULL)
        {
            ip_hdrp = (PIP_HDR) hdrp;
            tcp_hdrp = hdrp + sizeof (ULONG) * IP_GET_HLEN (ip_hdrp);

            dlen = TCP_GET_DGRAM_LEN (ip_hdrp, (PTCP_HDR) tcp_hdrp);
            nbt_hdrp = (PNBT_HDR) TCP_GET_DGRAM_PTR ((PTCP_HDR) tcp_hdrp);

            if (plen >= (((PUCHAR) nbt_hdrp) - ((PUCHAR) ip_hdrp) + dlen))  /* v2.0.6 */
                Tcpip_nbt_handle (& ctxtp -> tcpip, (PIP_HDR) hdrp, (PTCP_HDR) tcp_hdrp,
                                  dlen, nbt_hdrp);
        }
    }

    NDIS_SET_PACKET_HEADER_SIZE(newp, head_len);

    /* setup protocol reserved fields */

    /* shouse - For non-CTRL packets, Use MiniportReserved to store a pointer to our 
       private data.  CTRL continues to use ProtocolReserved. */
    if (op != MAIN_FILTER_OP_CTRL) {
        MAIN_MINIPORT_FIELD (newp) = resp;
        resp -> type = MAIN_PACKET_TYPE_INDICATE;
    } else {
        resp = MAIN_PROTOCOL_FIELD (newp);
        resp -> type = MAIN_PACKET_TYPE_CTRL;
    }

    resp -> miscp  = bp;
    resp -> data   = (LONG) (look_len < packet_len ? packet_len : 0); /* 64-bit -- ramkrish */

    /* V2.0.6 */

    resp -> len   = plen; /* 64-bit -- ramkrish */
    resp -> group = group;

    /* if we have less than a half of allocation block number of buffers left -
       allocate more until either alloc fails or we get above the watermark.
       if alloc fails - mark packet so that it is not retained by the protocol
       and is returned back to us. */

    while (ctxtp->num_bufs_alloced - ctxtp->num_bufs_out < ctxtp->num_packets / 2)
    {
        if (!Main_bufs_alloc(ctxtp))
        {
            NDIS_SET_PACKET_STATUS (newp, NDIS_STATUS_RESOURCES);
            return newp;
        }
    }

    if (packet_lowmark)
        NDIS_SET_PACKET_STATUS (newp, NDIS_STATUS_RESOURCES);
    else
        NDIS_SET_PACKET_STATUS (newp, NDIS_STATUS_SUCCESS);
    
    if (op == MAIN_FILTER_OP_CTRL) {
        /* Because this is a remote control packet, MiniportReserved
           should not contain a pointer to a private protocol buffer. */
        ASSERT(!MAIN_MINIPORT_FIELD(newp));
    }

    return newp;

} /* end Main_recv_indicate */


ULONG   Main_actions_alloc (
    PMAIN_CTXT              ctxtp)
{
    PMAIN_ACTION            actp;
    ULONG                   size, index, i;
    NDIS_STATUS             status;


    NdisAcquireSpinLock (& ctxtp -> act_lock);

    if (ctxtp -> num_action_allocs >= CVY_MAX_ALLOCS)
    {
        if (! ctxtp -> actions_warned)
        {
            LOG_MSG1 (MSG_WARN_RESOURCES, CVY_NAME_NUM_ACTIONS, ctxtp -> num_actions);
            ctxtp -> actions_warned = TRUE;
        }

        NdisReleaseSpinLock (& ctxtp -> act_lock);
        return FALSE;
    }

    index = ctxtp -> num_action_allocs;
    NdisReleaseSpinLock (& ctxtp -> act_lock);

    size = ctxtp -> num_actions * ctxtp -> act_size; /* 64-bit -- ramkrish */

    status = NdisAllocateMemoryWithTag (& (ctxtp -> act_buf [index]), size,
                                        UNIV_POOL_TAG);

    if (status != NDIS_STATUS_SUCCESS)
    {
        UNIV_PRINT (("error allocating actions %d %x", size, status));
        LOG_MSG2 (MSG_ERROR_MEMORY, MSG_NONE, size, status);
        return FALSE;
    }

    NdisAcquireSpinLock (& ctxtp -> act_lock);
    ctxtp -> num_action_allocs ++;
    NdisReleaseSpinLock (& ctxtp -> act_lock);

    for (i = 0; i < ctxtp -> num_actions; i++)
    {
        /* ensure that actp is aligned along 8-byte boundaries */
        actp = (PMAIN_ACTION) ( (PUCHAR) (ctxtp -> act_buf [index]) + i * ctxtp -> act_size);
        actp -> code  = MAIN_ACTION_CODE;
        actp -> ctxtp = ctxtp;

        NdisInterlockedInsertTailList (& ctxtp -> act_list,
                                       & actp -> link,
                                       & ctxtp -> act_lock);
    }

#if 0 /* 64-bit -- ramkrish */
    for (i = 0, actp = ctxtp -> act_buf [index];
         i < ctxtp -> num_actions;
         i ++, actp ++)
    {
        actp -> code  = MAIN_ACTION_CODE;
        actp -> ctxtp = ctxtp;

        NdisInterlockedInsertTailList (& ctxtp -> act_list,
                                       & actp -> link,
                                       & ctxtp -> act_lock);
    }
#endif

    return TRUE;

} /* end Main_actions_alloc */


PMAIN_ACTION Main_action_get (
    PMAIN_CTXT              ctxtp)
{
    PLIST_ENTRY             entryp;
    PMAIN_ACTION            actp;


    while (1)
    {
        NdisAcquireSpinLock (& ctxtp -> act_lock);
        entryp = RemoveHeadList (& ctxtp -> act_list);
        NdisReleaseSpinLock (& ctxtp -> act_lock);

        if (entryp != & ctxtp -> act_list)
            break;

        UNIV_PRINT (("OUT OF ACTIONS!!!"));

        if (! Main_actions_alloc (ctxtp))
            return NULL;
    }

    actp = CONTAINING_RECORD (entryp, MAIN_ACTION, link);
    UNIV_ASSERT (actp -> code == MAIN_ACTION_CODE);

    return actp;

} /* end Main_action_get */


VOID Main_action_put (
    PMAIN_CTXT              ctxtp,
    PMAIN_ACTION            actp)
{
    UNIV_ASSERT (actp -> code == MAIN_ACTION_CODE);


    NdisAcquireSpinLock (& ctxtp -> act_lock);
    InsertTailList (& ctxtp -> act_list, & actp -> link);
    NdisReleaseSpinLock (& ctxtp -> act_lock);

} /* end Main_action_put */


VOID Main_action_slow_put (
    PMAIN_CTXT              ctxtp,
    PMAIN_ACTION            actp)
{
    UNIV_ASSERT (actp -> code == MAIN_ACTION_CODE);


    NdisAcquireSpinLock (& ctxtp -> act_lock);
    InsertTailList (& ctxtp -> act_list, & actp -> link);
    NdisReleaseSpinLock (& ctxtp -> act_lock);

} /* end Main_action_slow_put */


ULONG   Main_bufs_alloc (
    PMAIN_CTXT              ctxtp)
{
    PMAIN_BUFFER        bp;
    NDIS_STATUS         status;
    ULONG               i, size, index;


    NdisAcquireSpinLock (& ctxtp -> buf_lock);

    if (ctxtp -> num_buf_allocs >= CVY_MAX_ALLOCS)
    {
        if (! ctxtp -> packets_warned)
        {
            LOG_MSG1 (MSG_WARN_RESOURCES, CVY_NAME_NUM_PACKETS, ctxtp -> num_packets);
            ctxtp -> packets_warned = TRUE;
        }

        NdisReleaseSpinLock (& ctxtp -> buf_lock);
        return FALSE;
    }

    index = ctxtp -> num_buf_allocs;
    NdisReleaseSpinLock (& ctxtp -> buf_lock);

    /* get twice as many buffer descriptors (one for entire buffer and one
       just for the payload portion) */

    size = 2 * ctxtp -> num_packets;

    NdisAllocateBufferPool (& status, & (ctxtp -> buf_pool_handle [index]),
                            2 * ctxtp -> num_packets);

    if (status != NDIS_STATUS_SUCCESS)
    {
        UNIV_PRINT (("error allocating buffer pool %d %x", size, status));
        LOG_MSG2 (MSG_ERROR_MEMORY, MSG_NONE, size, status);
        return FALSE;
    }

    /* allocate memory for the payload */

    size = ctxtp -> num_packets * ctxtp -> buf_size;

    status = NdisAllocateMemoryWithTag (& (ctxtp -> buf_array [index]), size,
                                        UNIV_POOL_TAG);

    if (status != NDIS_STATUS_SUCCESS)
    {
        UNIV_PRINT (("error allocating buffer space %d %x", size, status));
        LOG_MSG2 (MSG_ERROR_MEMORY, MSG_NONE, size, status);
        goto error;
    }

    NdisZeroMemory (ctxtp -> buf_array [index], size);

    for (i = 0; i < ctxtp -> num_packets; i ++)
    {
        bp = (PMAIN_BUFFER) (ctxtp -> buf_array [index] + i * ctxtp -> buf_size);

        bp -> code = MAIN_BUFFER_CODE;

        /* setup buffer descriptors to describe entire buffer and just the
           payload */

        size = ctxtp -> buf_mac_hdr_len + ctxtp -> max_frame_size;

        NdisAllocateBuffer (& status, & bp -> full_bufp,
                            ctxtp -> buf_pool_handle [index],
                            bp -> data, size);

        if (status != NDIS_STATUS_SUCCESS)
        {
            UNIV_PRINT (("error allocating header buffer %d %x", i, status));
            LOG_MSG3 (MSG_ERROR_MEMORY, MSG_NONE, i, size, status);
            goto error;
        }

        bp -> framep = bp -> data + ctxtp -> buf_mac_hdr_len;
        size = ctxtp -> max_frame_size;

        NdisAllocateBuffer (& status, & bp -> frame_bufp,
                            ctxtp -> buf_pool_handle [index],
                            bp -> framep, size);

        if (status != NDIS_STATUS_SUCCESS)
        {
            UNIV_PRINT (("error allocating frame buffer %d %x", i, status));
            LOG_MSG3 (MSG_ERROR_MEMORY, MSG_NONE, i, size, status);
            goto error;
        }

        NdisInterlockedInsertTailList (& ctxtp -> buf_list,
                                       & bp -> link,
                                       & ctxtp -> buf_lock);
    }

    NdisAcquireSpinLock (& ctxtp -> buf_lock);
    ctxtp -> num_buf_allocs ++;
    ctxtp->num_bufs_alloced += ctxtp->num_packets;
    NdisReleaseSpinLock (& ctxtp -> buf_lock);

    return TRUE;

error:

    if (ctxtp -> buf_array [index] != NULL)
    {
        for (i = 0; i < ctxtp -> num_packets; i ++)
        {
            bp = (PMAIN_BUFFER) (ctxtp -> buf_array [index] + i * ctxtp -> buf_size);

            if (bp -> full_bufp != NULL)
            {
                NdisAdjustBufferLength (bp -> full_bufp,
                                        ctxtp -> buf_mac_hdr_len +
                                        ctxtp -> max_frame_size);
                NdisFreeBuffer (bp -> full_bufp);
            }

            if (bp -> frame_bufp != NULL)
            {
                NdisAdjustBufferLength (bp -> frame_bufp,
                                        ctxtp -> max_frame_size);
                NdisFreeBuffer (bp -> frame_bufp);
            }
        }

        NdisFreeMemory (ctxtp -> buf_array [index],
                        ctxtp -> num_packets * ctxtp -> buf_size, 0);
    }

    if (ctxtp -> buf_pool_handle [index] != NULL)
        NdisFreeBufferPool (ctxtp -> buf_pool_handle [index]);

    return FALSE;

} /* end Main_bufs_alloc */


PNDIS_PACKET Main_frame_get (
    PMAIN_CTXT          ctxtp,
    ULONG               send,
    PULONG              lenp,
    USHORT              frame_type)
{
    PLIST_ENTRY         entryp;
    PMAIN_FRAME_DSCR    dscrp;
    NDIS_STATUS         status;
    PMAIN_PROTOCOL_RESERVED resp;
    PNDIS_PACKET        packet;
    PNDIS_PACKET_STACK  pktstk;
    BOOLEAN             stack_left;


    NdisAllocatePacket (& status, & packet, ctxtp -> frame_pool_handle);

    if (status != NDIS_STATUS_SUCCESS)
    {
        UNIV_PRINT (("OUT OF PING PACKETS!!!"));

#if 0 /* V1.3.2b */
        if (! ctxtp -> send_msgs_warned)
        {
            LOG_MSG1 (MSG_WARN_RESOURCES, CVY_NAME_NUM_SEND_MSGS, ctxtp -> num_send_msgs);
            ctxtp -> send_msgs_warned = TRUE;
        }
#endif

        return NULL;
    }

    /* #ps# -- ramkrish */
    pktstk = NdisIMGetCurrentPacketStack (packet, & stack_left);
    if (pktstk)
    {
        MAIN_IMRESERVED_FIELD(pktstk) = NULL;
    }

    /* Make sure that the MiniportReserved field is initially NULL. */
    MAIN_MINIPORT_FIELD(packet) = NULL;

    NdisAcquireSpinLock (& ctxtp -> frame_lock);
    entryp = RemoveHeadList (& ctxtp -> frame_list);
    NdisReleaseSpinLock (& ctxtp -> frame_lock);

    if (entryp == & ctxtp -> frame_list)
    {
        UNIV_PRINT (("OUT OF PING MESSAGES!!!"));

#if 0 /* V1.3.2b */
        if (! ctxtp -> send_msgs_warned)
        {
            LOG_MSG1 (MSG_WARN_RESOURCES, CVY_NAME_NUM_SEND_MSGS, ctxtp -> num_send_msgs);
            ctxtp -> send_msgs_warned = TRUE;
        }
#endif

        NdisFreePacket (packet);
        return NULL;
    }

    dscrp = CONTAINING_RECORD (entryp, MAIN_FRAME_DSCR, link);

    /* if sending heartbeat - fill out the header. in both cases - chain
       the necessary buffer descriptors to the packet */

    if (send)
    {
	PVOID         address = NULL;
	ULONG         size = 0;


	UNIV_ASSERT_VAL (frame_type == MAIN_PACKET_TYPE_PING ||
			 frame_type == MAIN_PACKET_TYPE_IGMP,
			 frame_type);

        /* V2.0.6, V2.2 moved here */

	/* Differentiate between igmp and heartbeat messages and allocate buffers */
	if (frame_type == MAIN_PACKET_TYPE_PING)
	{
	    size = sizeof (PING_MSG);
	    address = (PVOID)(ctxtp -> load_msgp);
	}
	else if (frame_type == MAIN_PACKET_TYPE_IGMP)
	{
	    size = sizeof (MAIN_IGMP_FRAME);
	    address = (PVOID) (& ctxtp -> igmp_frame);
	}
	else
	{
	    UNIV_PRINT (("Invalid frame type passed to Main_frame_get 0x%x", frame_type));
	    UNIV_ASSERT(0);
	}

	/* Allocate the buffer for sending the data */
	NdisAllocateBuffer (& status, & dscrp -> send_data_bufp,
			    ctxtp -> frame_buf_pool_handle,
			    address, size);

	if (status != NDIS_STATUS_SUCCESS)
	{
	    UNIV_PRINT (("Failed to allocate buffer for 0x%x", frame_type));

	    dscrp -> send_data_bufp = NULL;

	    NdisAcquireSpinLock (& ctxtp -> frame_lock);
	    InsertTailList (& ctxtp -> frame_list, & dscrp -> link);
	    NdisReleaseSpinLock (& ctxtp -> frame_lock);

	    NdisFreePacket (packet);
	    return NULL;
	}

        /* since packet length is always the same, and so are destination
           and source addresses - can use generic media header */

	if (frame_type == MAIN_PACKET_TYPE_PING)
	{
	    dscrp -> media_hdr               = ctxtp -> media_hdr;

	    dscrp -> frame_hdr . code        = MAIN_FRAME_CODE;
	    dscrp -> frame_hdr . version     = CVY_VERSION_FULL;
	    dscrp -> frame_hdr . host        = (UCHAR) ctxtp -> params . host_priority;
	    dscrp -> frame_hdr . cl_ip_addr  = ctxtp -> cl_ip_addr;
	    dscrp -> frame_hdr . ded_ip_addr = ctxtp -> ded_ip_addr;

	    NdisChainBufferAtFront (packet, dscrp -> send_data_bufp); /* V1.1.4 */
	    NdisChainBufferAtFront (packet, dscrp -> frame_hdr_bufp);

	}
	else if (frame_type == MAIN_PACKET_TYPE_IGMP)
	{
	    dscrp -> media_hdr               = ctxtp -> media_hdr_igmp;
	    NdisChainBufferAtFront (packet, dscrp -> send_data_bufp); /* V1.1.4 */
	}
	else
	{
	    UNIV_PRINT (("Invalid frame type passed to Main_frame_get 0x%x", frame_type));
	    UNIV_ASSERT(0);
	}

        NdisChainBufferAtFront (packet, dscrp -> media_hdr_bufp);
    }
    else
    {
        NdisChainBufferAtFront (packet, dscrp -> recv_data_bufp); /* V1.1.4 */
        NdisChainBufferAtFront (packet, dscrp -> frame_hdr_bufp);
    }

    /* fill out protocol reserved fields */

    /* shouse - Again, since these packets are hidden from upper layers, we should
       be OK using the protocol reserved field regardless of send/receive. */

    resp = MAIN_PROTOCOL_FIELD (packet);
    resp -> type   = frame_type;
    resp -> miscp  = dscrp;
    resp -> data   = 0;
    resp -> len    = 0;
    resp -> group  = 0;

    * lenp = dscrp -> recv_len;

    return packet;

} /* end Main_frame_get */


VOID Main_frame_put (
    PMAIN_CTXT          ctxtp,
    PNDIS_PACKET        packet,
    PMAIN_FRAME_DSCR    dscrp)
{
    PNDIS_BUFFER        bufp;

    /* shouse - Again, since these packets are hidden from upper layers, we should
       be OK using the protocol reserved field regardless of send/receive. */

    PMAIN_PROTOCOL_RESERVED resp = MAIN_PROTOCOL_FIELD (packet);


    UNIV_ASSERT_VAL (resp -> type == MAIN_PACKET_TYPE_PING ||
		     resp -> type == MAIN_PACKET_TYPE_IGMP, resp -> type);

    /* strip buffers from the packet buffer chain */

    do
    {
        NdisUnchainBufferAtFront (packet, & bufp);
    }
    while (bufp != NULL);

    /* recyle the packet */

    NdisReinitializePacket (packet);

    NdisFreePacket (packet);

    /* If the send buffer is not null, free this buffer */

    if (dscrp -> send_data_bufp != NULL)
    {
	NdisFreeBuffer (dscrp -> send_data_bufp);
	dscrp -> send_data_bufp = NULL;
    }
    /* put frame descriptor back on the free list */

    NdisAcquireSpinLock (& ctxtp -> frame_lock);
    InsertTailList (& ctxtp -> frame_list, & dscrp -> link);
    NdisReleaseSpinLock (& ctxtp -> frame_lock);

} /* end Main_frame_return */


PNDIS_PACKET Main_packet_alloc (
    PMAIN_CTXT              ctxtp,
    ULONG                   send,
    PULONG                  low)
{
    PNDIS_PACKET            newp = NULL;
    PNDIS_HANDLE            poolh;
    ULONG                   i, max, size, start;
    NDIS_STATUS             status;
    PNDIS_PACKET_STACK      pktstk;
    BOOLEAN                 stack_left;


    /* !!! assume that recv and send paths are not re-entrant, otherwise need
       to lock this. make sure that NdisAllocatePacket... routines are not
       called holding a spin lock */

    /* V1.1.2 */
    *low = FALSE;

    if (send)
    {
        poolh = ctxtp -> send_pool_handle;

        NdisAcquireSpinLock (& ctxtp -> send_lock);
        max   = ctxtp -> num_send_packet_allocs;
        start = ctxtp -> cur_send_packet_pool;
        ctxtp -> cur_send_packet_pool = (start + 1) % max;
        NdisReleaseSpinLock (& ctxtp -> send_lock);
    }
    else
    {
        poolh = ctxtp -> recv_pool_handle;

        NdisAcquireSpinLock (& ctxtp -> recv_lock);
        max   = ctxtp -> num_recv_packet_allocs;
        start = ctxtp -> cur_recv_packet_pool;
        ctxtp -> cur_recv_packet_pool = (start + 1) % max;
        NdisReleaseSpinLock (& ctxtp -> recv_lock);
    }

    /* Try to allocate a packet from the existing packet pools */
    i = start;

    do
    {
        NdisAllocatePacket (& status, & newp, poolh [i]);

        if (status == NDIS_STATUS_SUCCESS)
        {
            /* #ps# -- ramkrish */
            pktstk = NdisIMGetCurrentPacketStack (newp, & stack_left);

            if (pktstk)
            {
                MAIN_IMRESERVED_FIELD (pktstk) = NULL;
            }

            /* Make sure that the MiniportReserved field is initially NULL. */
            MAIN_MINIPORT_FIELD(newp) = NULL;

            if (send)
            {
                NdisAcquireSpinLock (& ctxtp -> send_lock);

                /* Because the decrement is interlocked, so should the increment. */
                NdisInterlockedIncrement(& ctxtp -> num_sends_out);

                if ((ctxtp -> num_sends_alloced - ctxtp -> num_sends_out)
                    < (ctxtp -> num_packets / 2))
                {
                    NdisReleaseSpinLock (& ctxtp -> send_lock);
                    break;
                }
                NdisReleaseSpinLock (& ctxtp -> send_lock);
            }
            else
            {
                NdisAcquireSpinLock (& ctxtp -> recv_lock);

                /* Because the decrement is interlocked, so should the increment. */
                NdisInterlockedIncrement(& ctxtp -> num_recvs_out);

                if ((ctxtp -> num_recvs_alloced - ctxtp -> num_recvs_out)
                    < (ctxtp -> num_packets / 2))
                {
                    NdisReleaseSpinLock (& ctxtp -> recv_lock);
                    break;
                }
                NdisReleaseSpinLock (& ctxtp -> recv_lock);
            }

            return newp;
        }

        /* pick the next pool to improve number of tries until we get something */

        i = (i + 1) % max;

    } while (i != start);

    /* At this point, the high level mark has been reached, so allocate a new packet pool */

    if (send)
    {
        NdisAcquireSpinLock (& ctxtp -> send_lock);

        if (ctxtp -> num_send_packet_allocs >= CVY_MAX_ALLOCS)
        {
            * low = TRUE;
            NdisReleaseSpinLock (& ctxtp -> send_lock);
            return newp;
        }

        if (ctxtp -> send_allocing)
        {
            * low = TRUE; /* do not know whether the allocation by another thread will succeed or not */
            NdisReleaseSpinLock (& ctxtp -> send_lock);
            return newp;
        }
        else
        {
            max = ctxtp -> num_send_packet_allocs;
            ctxtp -> send_allocing = TRUE;
            NdisReleaseSpinLock (& ctxtp -> send_lock);
        }
    }
    else
    {
        NdisAcquireSpinLock (& ctxtp -> recv_lock);

        if (ctxtp -> num_recv_packet_allocs >= CVY_MAX_ALLOCS)
        {
            * low = TRUE;
            NdisReleaseSpinLock (& ctxtp -> recv_lock);
            return newp;
        }

        if (ctxtp -> recv_allocing)
        {
            * low = TRUE; /* do not know whether the allocation by another thread will succeed or not */
            NdisReleaseSpinLock (& ctxtp -> recv_lock);
            return newp;
        }
        else
        {
            max = ctxtp -> num_recv_packet_allocs;
            ctxtp -> recv_allocing = TRUE;
            NdisReleaseSpinLock (& ctxtp -> recv_lock);
        }
    }

    /* Due to the send_allocing and recv_allocing flag, at most 1 send or recv thread will be in this portion at any time */
    size = ctxtp -> num_packets;

    NdisAllocatePacketPool (& status, & (poolh [max]),
                            ctxtp -> num_packets,
                            sizeof (MAIN_PROTOCOL_RESERVED));

    if (status != NDIS_STATUS_SUCCESS)
    {
        if (send)
        {
            UNIV_PRINT (("error allocating send packet pool %d %x", size, status));
        }
        else
        {
            UNIV_PRINT (("error allocating recv packet pool %d %x", size, status));
        }

        LOG_MSG2 (MSG_ERROR_MEMORY, MSG_NONE, size, status);
        * low = TRUE;
    }
    else
    {
        if (send)
        {
            NdisAcquireSpinLock (& ctxtp -> send_lock);
            ctxtp -> num_send_packet_allocs ++;
            ctxtp -> num_sends_alloced += ctxtp -> num_packets;
            ctxtp -> send_allocing = FALSE;
            NdisReleaseSpinLock (& ctxtp -> send_lock);
        }
        else
        {
            NdisAcquireSpinLock (& ctxtp -> recv_lock);
            ctxtp -> num_recv_packet_allocs ++;
            ctxtp -> num_recvs_alloced += ctxtp -> num_packets;
            ctxtp -> recv_allocing = FALSE;
            NdisReleaseSpinLock (& ctxtp -> recv_lock);
        }

        * low = FALSE;
    }

    return newp;
} /* Main_packet_alloc */


/* V1.3.2b */
#if 0
PNDIS_PACKET Main_packet_alloc (
    PMAIN_CTXT              ctxtp,
    ULONG                   send)
{
    PNDIS_PACKET            newp;
    PNDIS_HANDLE            poolh;
    ULONG                   i, max, size, start;
    NDIS_STATUS             status;


    /* !!! assume that recv and send paths are not re-entrant, otherwise need
       to lock this. make sure that NdisAllocatePacket... routines are not
       called holding a spin lock */

    /* V1.1.2 */

    if (send)
    {
        poolh = ctxtp -> send_pool_handle;

        NdisAcquireSpinLock (& ctxtp -> send_lock);
        max   = ctxtp -> num_send_packet_allocs;
        start = ctxtp -> cur_send_packet_pool;
        ctxtp -> cur_send_packet_pool = (start + 1) % max;
        NdisReleaseSpinLock (& ctxtp -> send_lock);
    }
    else
    {
        poolh = ctxtp -> recv_pool_handle;

        NdisAcquireSpinLock (& ctxtp -> recv_lock);
        max   = ctxtp -> num_recv_packet_allocs;
        start = ctxtp -> cur_recv_packet_pool;
        ctxtp -> cur_recv_packet_pool = (start + 1) % max;
        NdisReleaseSpinLock (& ctxtp -> recv_lock);
    }

    i = start;

    while (1)
    {
        NdisAllocatePacket (& status, & newp, poolh [i]);

        if (status == NDIS_STATUS_SUCCESS)
        {
            if (send)
                NdisInterlockedIncrement(& ctxtp -> num_sends_out);
            else
                NdisInterlockedIncrement(& ctxtp -> num_recvs_out);

            return newp;
        }

        /* pick the next pool to improve number of tries until we get something */

        i = (i + 1) % max;

        if (i != start)
            continue;

        if (send)
        {
            UNIV_PRINT (("OUT OF SEND PACKETS!!!"));
        }
        else
        {
            UNIV_PRINT (("OUT OF RECV PACKETS!!!"));
        }

        /* allocate another packet pool if we can */

        if (max >= CVY_MAX_ALLOCS)
        {
            if (! ctxtp -> packets_warned)
            {
                LOG_MSG1 (MSG_WARN_RESOURCES, CVY_NAME_NUM_PACKETS, ctxtp -> num_packets);
                ctxtp -> packets_warned = TRUE;
            }

            break;
        }

        size = ctxtp -> num_packets;

        NdisAllocatePacketPool (& status, & (poolh [max]),
                                ctxtp -> num_packets,
                                sizeof (MAIN_PROTOCOL_RESERVED));

        if (status != NDIS_STATUS_SUCCESS)
        {
            UNIV_PRINT (("error allocating recv packet pool %d %x", size, status));
            LOG_MSG2 (MSG_ERROR_MEMORY, MSG_NONE, size, status);
            break;
        }

        if (send)
        {
            NdisAcquireSpinLock (& ctxtp -> send_lock);
            ctxtp -> num_send_packet_allocs ++;
            ctxtp -> cur_send_packet_pool = max;
            ctxtp -> num_sends_alloced += ctxtp->num_packets;
            NdisReleaseSpinLock (& ctxtp -> send_lock);
        }
        else
        {
            NdisAcquireSpinLock (& ctxtp -> recv_lock);
            ctxtp -> num_recv_packet_allocs ++;
            ctxtp -> cur_recv_packet_pool = max;
            ctxtp -> num_recvs_alloced += ctxtp->num_packets;
            NdisReleaseSpinLock (& ctxtp -> recv_lock);
        }

        i = max;
        max ++;
    }

    return NULL;

} /* end Main_packet_alloc */
#endif

PNDIS_PACKET Main_packet_get (
    PMAIN_CTXT              ctxtp,
    PNDIS_PACKET            packet,
    ULONG                   send,
    USHORT                  group,
    ULONG                   len)
{
    PNDIS_PACKET            newp;
//    PNDIS_PACKET_OOB_DATA   new_oobp, old_oobp;
    PMAIN_PROTOCOL_RESERVED resp = NULL;
    ULONG                   packet_lowmark;
    PNDIS_PACKET_STACK      pktstk = NULL;
    BOOLEAN                 stack_left;


    /* #ps# */
    pktstk = NdisIMGetCurrentPacketStack (packet, & stack_left);

    if (stack_left)
    {
        resp = (PMAIN_PROTOCOL_RESERVED) NdisAllocateFromNPagedLookasideList (& ctxtp -> resp_list);

        MAIN_IMRESERVED_FIELD (pktstk) = resp;

        if (resp)
        {
            resp -> type   = MAIN_PACKET_TYPE_PASS;
            resp -> miscp  = packet;
            resp -> data   = 0;

            /* V2.0.6 */

            resp -> group  = group;
            resp -> len    = len; /* 64-bit -- ramkrish */

            return packet;
        }
    }
        
    /* get a packet */

    /* shouse - If this is a receive, then we are using MiniportReserved and must allocate a 
       buffer to hold our private data.  If it fails, bail out and dump the packet. */
    if (!send) {
        resp = (PMAIN_PROTOCOL_RESERVED) NdisAllocateFromNPagedLookasideList (& ctxtp -> resp_list);

        if (!resp) return NULL;
    }

    newp = Main_packet_alloc (ctxtp, send, & packet_lowmark);

    if (newp == NULL) {
        /* shouse - If packet allocation fails, put the resp buffer back on the list if this is a receive. */
        if (resp) NdisFreeToNPagedLookasideList (& ctxtp -> resp_list, resp);

        return NULL;
    }

    pktstk = NdisIMGetCurrentPacketStack (newp, & stack_left);     /* #ps# */

    if (pktstk)
    {
        MAIN_IMRESERVED_FIELD(pktstk) = NULL;
    }

    /* Make sure that the MiniportReserved field is initially NULL. */
    MAIN_MINIPORT_FIELD(newp) = NULL;

    /* make new packet resemble the outside one */

    if (send)
    {
        PVOID			        media_info = NULL;
        ULONG			        media_info_size = 0;


        newp->Private.Head = packet->Private.Head;
        newp->Private.Tail = packet->Private.Tail;

        NdisGetPacketFlags(newp) = NdisGetPacketFlags(packet);

        NdisSetPacketFlags(newp, NDIS_FLAGS_DONT_LOOPBACK);

        // Copy the OOB Offset from the original packet to the new
        // packet.

        NdisMoveMemory(NDIS_OOB_DATA_FROM_PACKET(newp),
                       NDIS_OOB_DATA_FROM_PACKET(packet),
                       sizeof(NDIS_PACKET_OOB_DATA));

        // Copy the per packet info into the new packet

        NdisIMCopySendPerPacketInfo(newp, packet);

        // Copy the Media specific information

        NDIS_GET_PACKET_MEDIA_SPECIFIC_INFO(packet, & media_info, & media_info_size);

        if (media_info != NULL || media_info_size != 0)
        {
            NDIS_SET_PACKET_MEDIA_SPECIFIC_INFO(newp, media_info, media_info_size);
        }
    }
    else
    {
        newp->Private.Head = packet->Private.Head;
        newp->Private.Tail = packet->Private.Tail;

        // Get the original packet(it could be the same packet as one received or a different one
        // based on # of layered MPs) and set it on the indicated packet so the OOB stuff is visible
        // correctly at the top.

        NDIS_SET_ORIGINAL_PACKET(newp, NDIS_GET_ORIGINAL_PACKET(packet));
        NDIS_SET_PACKET_HEADER_SIZE(newp, NDIS_GET_PACKET_HEADER_SIZE(packet));
        NdisGetPacketFlags(newp) = NdisGetPacketFlags(packet);

        if (packet_lowmark)
            NDIS_SET_PACKET_STATUS(newp, NDIS_STATUS_RESOURCES);
        else
            NDIS_SET_PACKET_STATUS(newp, NDIS_GET_PACKET_STATUS(packet));
        }

#if 0
    newp -> Private . PhysicalCount   = packet -> Private . PhysicalCount;
    newp -> Private . TotalLength     = packet -> Private . TotalLength;
    newp -> Private . Head            = packet -> Private . Head;
    newp -> Private . Tail            = packet -> Private . Tail;
    newp -> Private . Count           = packet -> Private . Count;
    newp -> Private . Flags           = packet -> Private . Flags;
    newp -> Private . ValidCounts     = packet -> Private . ValidCounts;
    newp -> Private . NdisPacketFlags = packet -> Private . NdisPacketFlags;

    old_oobp = NDIS_OOB_DATA_FROM_PACKET (packet);
    new_oobp = NDIS_OOB_DATA_FROM_PACKET (newp);

    * new_oobp = * old_oobp;
#endif

    /* fill out protocol reserved field */

    /* shouse - Sends should use ProtocolReserved and receives should use MiniportReserved.  Buffer
       space for MiniportReserved is allocated further up in this function. */
    if (send) { 
        resp = MAIN_PROTOCOL_FIELD (newp);
    } else { 
        MAIN_MINIPORT_FIELD (newp) = resp;
    }

    resp -> type   = MAIN_PACKET_TYPE_PASS;
    resp -> miscp  = packet;
    resp -> data   = 0;

    /* V2.0.6 */

    resp -> group  = group;
    resp -> len    = len; /* 64-bit -- ramkrish */

    return newp;

} /* end Main_packet_get*/


PNDIS_PACKET Main_packet_put (
    PMAIN_CTXT              ctxtp,
    PNDIS_PACKET            packet,
    ULONG                   send,
    NDIS_STATUS             status)
{
    PNDIS_PACKET            oldp = NULL;
    PNDIS_PACKET_STACK      pktstk;
    BOOLEAN                 stack_left;
    PMAIN_PROTOCOL_RESERVED resp; /* #ps# */
//    PMAIN_PROTOCOL_RESERVED resp = MAIN_PROTOCOL_FIELD (packet);
    PMAIN_BUFFER            bp;
    PNDIS_BUFFER            bufp;


    /* #ps# */
    MAIN_RESP_FIELD(packet, stack_left, pktstk, resp, send);

    UNIV_ASSERT(resp);

    /* Because CTRL packets are actually allocated on the receive path,
       we need to change the send flag to false to get the logic right. */
    if (resp->type == MAIN_PACKET_TYPE_CTRL) {
        ASSERT(send);
        send = FALSE;
    }

    /* V2.0.6 update statistics */

    if (send)
    {
        if (status == NDIS_STATUS_SUCCESS)
        {
            ctxtp -> cntr_xmit_ok ++;

            switch (resp -> group)
            {
                case MAIN_FRAME_DIRECTED:
                    ctxtp -> cntr_xmit_frames_dir ++;
                    ctxtp -> cntr_xmit_bytes_dir += (ULONGLONG) (resp -> len);
                    break;

                case MAIN_FRAME_MULTICAST:
                    ctxtp -> cntr_xmit_frames_mcast ++;
                    ctxtp -> cntr_xmit_bytes_mcast += (ULONGLONG) (resp -> len);
                    break;

                case MAIN_FRAME_BROADCAST:
                    ctxtp -> cntr_xmit_frames_bcast ++;
                    ctxtp -> cntr_xmit_bytes_bcast += (ULONGLONG) (resp -> len);
                    break;

                default:
                    break;
            }
        }
        else
            ctxtp -> cntr_xmit_err ++;
    }
    else
    {
        if (status == NDIS_STATUS_SUCCESS)
        {
            ctxtp -> cntr_recv_ok ++;

            switch (resp -> group)
            {
                case MAIN_FRAME_DIRECTED:
                    ctxtp -> cntr_recv_frames_dir ++;
                    ctxtp -> cntr_recv_bytes_dir += (ULONGLONG) (resp -> len);
                    break;

                case MAIN_FRAME_MULTICAST:
                    ctxtp -> cntr_recv_frames_mcast ++;
                    ctxtp -> cntr_recv_bytes_mcast += (ULONGLONG) (resp -> len);
                    break;

                case MAIN_FRAME_BROADCAST:
                    ctxtp -> cntr_recv_frames_bcast ++;
                    ctxtp -> cntr_recv_bytes_bcast += (ULONGLONG) (resp -> len);
                    break;

                default:
                    break;
            }
        }
        else
            ctxtp -> cntr_recv_err ++;
    }

    /* V1.3.2b - if this is our buffer packet - get rid of the buffer */

    if (resp -> type == MAIN_PACKET_TYPE_INDICATE ||
        resp -> type == MAIN_PACKET_TYPE_CTRL)
    {
        /* strip buffers from the packet buffer chain */

        NdisUnchainBufferAtFront (packet, & bufp);

        bp = (PMAIN_BUFFER) resp -> miscp;
        UNIV_ASSERT (bp -> code == MAIN_BUFFER_CODE);

        NdisAcquireSpinLock (& ctxtp -> buf_lock);
        ctxtp -> num_bufs_out--;
        InsertTailList (& ctxtp -> buf_list, & bp -> link);
        NdisReleaseSpinLock (& ctxtp -> buf_lock);

        /* Indicated packets use MiniportReserved, while CTRL packets use ProtocolReserved,
           so indicated packets need to free the resp buffer back to the list. */
        if (resp -> type == MAIN_PACKET_TYPE_INDICATE) {
            resp -> type = MAIN_PACKET_TYPE_NONE;
            NdisFreeToNPagedLookasideList (& ctxtp -> resp_list, resp);
        }
    }
    else
    {
        UNIV_ASSERT_VAL (resp -> type == MAIN_PACKET_TYPE_PASS ||
                         resp -> type == MAIN_PACKET_TYPE_TRANSFER,
                         resp -> type);

        oldp = (PNDIS_PACKET) resp -> miscp;

        /* If the old packet is the same as this packet, then we were using
           NDIS packet stacking to hold our private data.  In this case, we
           ALWAYS need to free the resp buffer back to our list. */
        if (oldp == packet)
        {
            resp -> type = MAIN_PACKET_TYPE_NONE;
            NdisFreeToNPagedLookasideList (& ctxtp -> resp_list, resp);
            return packet;
        }

#if defined (SBH)
        /* It used to be that if a new packet was allocated, we always used 
           protocol reseved, so there was never a need to free our private
           buffer (it was part of the packet itself).  However, now in the 
           case where packet != oldp (we allocated a new packet) we may have
           to free the private data buffer.  If we allocate a packet on the
           send path, we play the part of protocol and use the protocol
           reserved field, which is the former behavior.  However, if we 
           allocate a packet on the receive path, we pull a resp buffer off
           of our lookaside list and store a pointer in the miniport reserved
           field of the packet.  Therefore, if this is the completion of a 
           receive, free the private buffer. */
        if (!send)
            NdisFreeToNPagedLookasideList (& ctxtp -> resp_list, resp);
#endif
        // Copy the per packet info into the new packet

        if (send)
            NdisIMCopySendCompletePerPacketInfo(oldp, packet);

        resp -> type = MAIN_PACKET_TYPE_NONE;
    }

    /* These conters ONLY count outstanding allocated packets - for resource tracking. */
    if (send)
        NdisInterlockedDecrement(& ctxtp -> num_sends_out);
    else
        NdisInterlockedDecrement(& ctxtp -> num_recvs_out);

    NdisReinitializePacket (packet);
    NdisFreePacket (packet);

    return oldp;

} /* end Main_packet_put */


#ifdef PERIODIC_RESET
static ULONG countdown = 0;
ULONG   resetting = FALSE;
#endif

VOID Main_ping (
    PMAIN_CTXT              ctxtp,
    PULONG                  toutp)
{
    ULONG                   len, conns;
    BOOLEAN                 alive, converging;
    PNDIS_PACKET            packet;
    NDIS_STATUS             status;
    BOOLEAN                 send_heartbeat = TRUE;


#ifdef PERIODIC_RESET   /* enable this to simulate periodic resets */

    if (countdown++ == 15)
    {
        NDIS_STATUS     status;

        resetting = TRUE;

        NdisReset (& status, ctxtp -> mac_handle);

        if (status == NDIS_STATUS_SUCCESS)
            resetting = FALSE;

        countdown = 0;
    }

#endif

    /* If unbind handler has been called, return here */
    if (ctxtp -> unbind_handle)
	return;

    /* The master adapter must check the consistency of its team's configuration
       and appropriately activate/de-activate the team once per timeout. */
    Main_teaming_check_consistency(ctxtp);

    /* count down time left for blocking ARPs */

    NdisAcquireSpinLock (& ctxtp -> load_lock);  /* V1.0.3 */

    if (*toutp > univ_changing_ip)
        univ_changing_ip = 0;
    else
        univ_changing_ip -= *toutp;

    alive = Load_timeout (& ctxtp -> load, toutp, & converging, & conns);

    /* moving release to the end of the function locks up one of the testbeds.
       guessing because of some reentrancy problem with NdisSend that is being
       called by ctxtp_frame_send */

    if (! ctxtp -> convoy_enabled && ! ctxtp -> stopping)
    {
        UNIV_ASSERT (! ctxtp -> draining);
        NdisReleaseSpinLock (& ctxtp -> load_lock);  /* V1.0.3 */
	send_heartbeat   = FALSE;
//	return;
    }

    /* V2.1 if draining and no more connections - stop cluster mode */

    if (send_heartbeat)
    {
	if (ctxtp -> draining && conns == 0 && ! converging)
        {
	    IOCTL_CVY_BUF       buf;

	    ctxtp -> draining = FALSE;
	    NdisReleaseSpinLock (& ctxtp -> load_lock);

	    Main_ctrl (ctxtp, (ULONG) IOCTL_CVY_CLUSTER_OFF, & buf, NULL);
	}
	else
	    NdisReleaseSpinLock (& ctxtp -> load_lock);  /* V1.0.3 */

	/* V2.1 clear stopping flag here since we are going to send out the frame
	   that will initiate convergence */

	ctxtp -> stopping = FALSE;
    }

    /* V1.3.2b */

    if (! ctxtp -> media_connected || ! MAIN_PNP_DEV_ON(ctxtp))
        return;

    /* V1.1.2 do not send pings if the card below is resetting */

    if (ctxtp -> reset_state != MAIN_RESET_NONE)
        return;

    if (send_heartbeat)
    {
	packet = Main_frame_get (ctxtp, TRUE, & len, MAIN_PACKET_TYPE_PING);

	if (packet == NULL)
        {
	    UNIV_PRINT (("error getting frame packet"));
	    return;
	}

	NdisSend (& status, ctxtp -> mac_handle, packet);

	if (status != NDIS_STATUS_PENDING)
	    Main_send_done (ctxtp, packet, status);
    }

    /* Check to see if igmp message needs to be sent out.  If the cluster IP address is 0.0.0.0, we 
       don't want to join the multicast IGMP group.  Likewise, in multicast or unicast mode. */
    if (ctxtp -> params . mcast_support && ctxtp -> params . igmp_support && ctxtp -> params . cl_ip_addr != 0)
    {
	ctxtp -> igmp_sent += ctxtp -> curr_tout;

	if (ctxtp -> igmp_sent < CVY_DEF_IGMP_INTERVAL)
	    return;

	ctxtp -> igmp_sent = 0;
	packet = Main_frame_get (ctxtp, TRUE, & len, MAIN_PACKET_TYPE_IGMP);

	if (packet == NULL)
        {
	    UNIV_PRINT (("error getting igmp packet"));
	    return;
	}

	NdisSend (& status, ctxtp -> mac_handle, packet);

	if (status != NDIS_STATUS_PENDING)
	    Main_send_done (ctxtp, packet, status);
    }

} /* Main_ping */


VOID Main_send_done (
    PVOID                   cp,
    PNDIS_PACKET            packetp,
    NDIS_STATUS             status)
{
    PMAIN_CTXT              ctxtp = (PMAIN_CTXT) cp;
    PMAIN_FRAME_DSCR        dscrp;

    /* shouse - This function is only called for ping and IGMP messages, so
       we can continue to allow it to access the protocol reserved field. */
    PMAIN_PROTOCOL_RESERVED resp = MAIN_PROTOCOL_FIELD (packetp);

    UNIV_ASSERT_VAL (resp -> type == MAIN_PACKET_TYPE_PING ||
		     resp -> type == MAIN_PACKET_TYPE_IGMP, resp -> type);

    /* attempt to see if this packet is part of our frame descriptor */

    dscrp = (PMAIN_FRAME_DSCR) resp -> miscp;

    if (status != NDIS_STATUS_SUCCESS)
        UNIV_PRINT (("error sending %x error 0x%x", resp -> type, status));

    Main_frame_put (ctxtp, packetp, dscrp);

} /* end Main_send_done */


VOID Main_xfer_done (
    PVOID                   cp,
    PNDIS_PACKET            packetp,
    NDIS_STATUS             status,
    ULONG                   xferred)
{
    PMAIN_CTXT              ctxtp = (PMAIN_CTXT) cp;
    PMAIN_FRAME_DSCR         dscrp;

    /* shouse - This function is only called for ping messages, so we can 
       continue to allow it to access the protocol reserved field. */
    PMAIN_PROTOCOL_RESERVED resp = MAIN_PROTOCOL_FIELD (packetp);

    UNIV_ASSERT_VAL (resp -> type == MAIN_PACKET_TYPE_PING, resp -> type);

    dscrp = (PMAIN_FRAME_DSCR) resp -> miscp;

    if (status != NDIS_STATUS_SUCCESS)
    {
        UNIV_PRINT (("error transferring %x", status));
    }
    else if (xferred != dscrp -> recv_len)
    {
        UNIV_PRINT (("only xferred %d out of %d bytes", xferred, sizeof (MAIN_FRAME_HDR)));
    }
    else
    {
        /* let load deal with received heartbeat */

        NdisAcquireSpinLock (& ctxtp -> load_lock);   /* V1.0.3 */
        if (ctxtp -> convoy_enabled)    /* V1.3.2b */
            Load_msg_rcv (& ctxtp -> load, & dscrp -> msg);     /* V1.1.4 */
        NdisReleaseSpinLock (& ctxtp -> load_lock);     /* V1.0.3 */
    }

    Main_frame_put (ctxtp, packetp, dscrp);

} /* end Main_xfer_done */


PUCHAR Main_frame_parse (
    PMAIN_CTXT          ctxtp,
    PNDIS_PACKET        packetp,
    PUCHAR *            startp,     /* destination for the MAC header */
    ULONG               off,        /* offset from beginning of data - 0 means
                                       right after IP header */
    PUCHAR *            locp,       /* destination for the TCP/UDP/other header */
    PULONG              lenp,       /* length without media header */
    PUSHORT             sigp,        /* signature from the MAC header */
    PUSHORT             group,      /* directed, multicast or broadcast */
    ULONG               send)
/*
  Parse packet extracting real pointers to specified offsets

  returns PUCHAR:
    <pointer to specified offset>
*/
{
    PNDIS_BUFFER        bufp;
    PUCHAR              memp, retp;
    UINT                len, total_len;
    ULONG               curr_len = 0, hdr_len, offset;


    /* get basic frame info */

    NdisGetFirstBufferFromPacket (packetp, & bufp, & memp, & len, & total_len);

    if (bufp == NULL)
        return NULL;

//    NdisQueryBuffer (bufp, & memp, & len);

    * startp = memp;

    offset = CVY_MAC_DST_OFF (ctxtp -> medium);

    /* V2.0.6 - figure out frame type for stats */

    if (! CVY_MAC_ADDR_MCAST (ctxtp -> medium, memp + offset))
        * group = MAIN_FRAME_DIRECTED;
    else
    {
        if (CVY_MAC_ADDR_BCAST (ctxtp -> medium, memp + offset))
            * group = MAIN_FRAME_BROADCAST;
        else
            * group = MAIN_FRAME_MULTICAST;
    }

    /* V1.3.0b multicast support V1.3.1b - on receive mask the cluster MAC
       so that protocol does not get confused */

    if (ctxtp -> params . mcast_support)
    {
        if (! send &&
            CVY_MAC_ADDR_COMP (ctxtp -> medium, memp + offset, & ctxtp -> cl_mac_addr))
            CVY_MAC_ADDR_COPY (ctxtp -> medium, memp + offset, & ctxtp -> ded_mac_addr);
    }

    /* V2.0.6 source MAC address shadowing to prevent switches from learning */

    else if (send && ctxtp -> params . mask_src_mac)
    {
        offset = CVY_MAC_SRC_OFF (ctxtp -> medium);

        if (CVY_MAC_ADDR_COMP (ctxtp -> medium, memp + offset, & ctxtp -> cl_mac_addr))
        {
            CVY_MAC_ADDR_COPY (ctxtp -> medium, memp + offset, & ctxtp -> ded_mac_addr);

            //
            // Change to the unique mac.  
            // Note, this can be done during initialization to improve performance
            //
            CVY_MAC_ADDR_LAA_SET (ctxtp -> medium, memp + offset);
            * ((PUCHAR) (memp + offset + 1)) = (UCHAR) ctxtp -> params . host_priority;
/*          // 64-bit -- ramkrish
            * ((PULONG) (memp + offset + 2)) = ctxtp -> cl_ip_addr;
*/
//            ctxtp -> mac_modified ++;
        }
    }

    /* get header length and signature from the frame depending on the medium */

    if (ctxtp -> medium == NdisMedium802_3)
    {
        hdr_len = sizeof (CVY_ETHERNET_HDR);

        * sigp = CVY_ETHERNET_ETYPE_GET (memp);
    }

    if (total_len < hdr_len)
    {
        return NULL;
    }

    /* get payload length */

    * lenp = total_len - hdr_len;

    /* traverse buffers until we find payload offset and remember the pointer */

    while (1)
    {
        if (curr_len + len > hdr_len)
        {
            retp = memp + (hdr_len - curr_len);
            break;
        }

        curr_len += len;

        NdisGetNextBuffer (bufp, & bufp);

        if (bufp == NULL)
            return NULL;

        NdisQueryBuffer (bufp, & memp, & len);
    }

    /* by default assume next offset is after IP header */

    if (off == 0)
        off = sizeof (ULONG) * IP_GET_HLEN ((PIP_HDR) retp);

    hdr_len += off;

    /* traverse buffers until we find next offset and remember the pointer */

    while (1)
    {
        if (curr_len + len > hdr_len)
        {
            * locp = memp + (hdr_len - curr_len);
            break;
        }

        curr_len += len;

        NdisGetNextBuffer (bufp, & bufp);

        if (bufp == NULL)
        {
            * locp = NULL;
            break;
        }

        NdisQueryBuffer (bufp, & memp, & len);
    }

    return retp;

} /* end Main_frame_parse */


PUCHAR Main_frame_find (
    PMAIN_CTXT          ctxtp,
    PUCHAR              head_buf,
    PUCHAR              look_buf,
    UINT                look_len,
    PUSHORT             sigp)
{
    /* get payload location and signature from the frame depending on the medium */

    if (ctxtp -> medium == NdisMedium802_3)
    {
        * sigp = CVY_ETHERNET_ETYPE_GET (head_buf);
        return look_buf;
    }

    return look_buf;

} /* end Main_frame_find */

NDIS_STATUS Main_dispatch (
    PVOID                   DeviceObject, 
    PVOID                   Irp) 
{
    PIRP                    pIrp = Irp;
    PIO_STACK_LOCATION      irpStack;
    NDIS_STATUS	            status = NDIS_STATUS_SUCCESS;
    
    UNIV_PRINT(("Main_dispatch: Device=%p, Irp=%p \n", DeviceObject, Irp));

    irpStack = IoGetCurrentIrpStackLocation(pIrp);
    
    switch (irpStack->MajorFunction) {
    case IRP_MJ_DEVICE_CONTROL:
        status = Main_ioctl(DeviceObject, Irp);
        break;        
    default:
        break;
    }
    
    pIrp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    
    return status;
} 

NDIS_STATUS Main_ioctl (
    PVOID                   device, 
    PVOID                   irp_irp) 
{
    PIRP                    irp = irp_irp;
    PIO_STACK_LOCATION      irp_sp;
    ULONG                   ilen, olen, info = 0;
    NDIS_STATUS             status = NDIS_STATUS_SUCCESS;
    ULONG                   io_ctrl_code;
    PMAIN_CTXT              ctxtp = ioctrl_ctxtp;
    PIOCTL_LOCAL_HDR        bufp;
    ULONG                   adapter_index;

    irp_sp = IoGetCurrentIrpStackLocation (irp);
    io_ctrl_code = irp_sp -> Parameters . DeviceIoControl . IoControlCode;

    ilen = irp_sp -> Parameters . DeviceIoControl . InputBufferLength;
    olen = irp_sp -> Parameters . DeviceIoControl . OutputBufferLength;
    bufp = irp -> AssociatedIrp . SystemBuffer;

    switch (io_ctrl_code)
    {
    case IOCTL_CVY_CLUSTER_ON:
    case IOCTL_CVY_CLUSTER_OFF:
    case IOCTL_CVY_PORT_ON:
    case IOCTL_CVY_PORT_OFF:
    case IOCTL_CVY_QUERY:
    case IOCTL_CVY_RELOAD:
    case IOCTL_CVY_PORT_SET:
    case IOCTL_CVY_PORT_DRAIN:
    case IOCTL_CVY_CLUSTER_DRAIN:
    case IOCTL_CVY_CLUSTER_SUSPEND:
    case IOCTL_CVY_CLUSTER_RESUME:
        /* Picking univ_ctxt_hanlde here is not kosher, since we should 
           get the callback cookie out of callb_ctxtp from ctxtp context. 
           Since we do not have it - do what we can now - cheat :) */
        
        if (ilen != sizeof (IOCTL_LOCAL_HDR) || olen != sizeof (IOCTL_LOCAL_HDR) || bufp == NULL)
        {
            UNIV_PRINT(("Buffer is missing or not the expected (%d) size: %d, %d", sizeof(IOCTL_LOCAL_HDR), ilen, olen));
            status = STATUS_INVALID_PARAMETER;
            break;
        }
        
        adapter_index = Main_adapter_get (bufp -> device_name);
        
        if (adapter_index == MAIN_ADAPTER_NOT_FOUND)
        {
            UNIV_PRINT(("Unknown adapter: %ls", bufp -> device_name));
            status = STATUS_INVALID_PARAMETER;
            break;
        }
        
        UNIV_PRINT(("Ioctl %d for adapter %ls", io_ctrl_code, bufp -> device_name));
        
        ctxtp = univ_adapters [adapter_index] . ctxtp;
        
        irp -> IoStatus . Information = sizeof (IOCTL_LOCAL_HDR);
        
        /* Process the IOCTL.  All necessary information except the VIP is in the IOCTL_CVY_BUF.  For
           backward compatiblilty reasons, we need to store the virtual IP address in the local buffer. */
        status = Main_ctrl (ctxtp, io_ctrl_code, & (bufp -> ctrl), & (bufp -> options));
        
        break;
    case IOCTL_CVY_QUERY_STATE:
        /* Check the lengths of the input and output buffers specified by the user-space application. */
        if (ilen != sizeof (IOCTL_LOCAL_HDR) || olen != sizeof (IOCTL_LOCAL_HDR) || !bufp) {
            UNIV_PRINT(("Buffer is missing or not the expected (%d) size: input=%d, output=%d", sizeof(IOCTL_LOCAL_HDR), ilen, olen));
            status = STATUS_INVALID_PARAMETER;
            break;
        }
        
        /* Map from the GUID to the adapter index. */
        if ((adapter_index = Main_adapter_get(bufp->device_name)) == MAIN_ADAPTER_NOT_FOUND) {
            UNIV_PRINT(("Unknown adapter: %ls", bufp->device_name));
            status = STATUS_INVALID_PARAMETER;
            break;
        }

        UNIV_PRINT(("Ioctl for adapter %ls", bufp->device_name));

        /* Fill in the number of bytes written.  This IOCTL always writes the same number of bytes that it 
           reads.  That is, the input and output buffers should be identical structures. */
        irp->IoStatus.Information = sizeof(IOCTL_LOCAL_HDR);
        
        /* Retrieve the context pointer from the global arrary of adapters. */
        ctxtp = univ_adapters[adapter_index].ctxtp;
        
        /* Call the query state IOCTL handler. */
        status = Query_state_ctrl(ctxtp, bufp->options.state.flags, &bufp->options.state.query);
        
        break;
#if defined (NLB_SESSION_SUPPORT)
    case IOCTL_CVY_CONNECTION_NOTIFY:
        /* Check the lengths of the input and output buffers specified by the user-space application. */
        if (ilen != sizeof (IOCTL_LOCAL_HDR) || olen != sizeof (IOCTL_LOCAL_HDR) || !bufp) {
            UNIV_PRINT(("Buffer is missing or not the expected (%d) size: input=%d, output=%d", sizeof(IOCTL_LOCAL_HDR), ilen, olen));
            status = STATUS_INVALID_PARAMETER;
            break;
        }
        
        /* Map from the GUID to the adapter index. */
        if ((adapter_index = Main_adapter_get(bufp->device_name)) == MAIN_ADAPTER_NOT_FOUND) {
            UNIV_PRINT(("Unknown adapter: %ls", bufp->device_name));
            status = STATUS_INVALID_PARAMETER;
            break;
        }

        UNIV_PRINT(("Ioctl for adapter %ls", bufp->device_name));

        /* Fill in the number of bytes written.  This IOCTL always writes the same number of bytes that it 
           reads.  That is, the input and output buffers should be identical structures. */
        irp->IoStatus.Information = sizeof(IOCTL_LOCAL_HDR);
        
        /* Retrieve the context pointer from the global arrary of adapters. */
        ctxtp = univ_adapters[adapter_index].ctxtp;
        
        /* Call the connection notification IOCTL handler. */
        status = Conn_notify_ctrl(ctxtp, bufp->options.notify.flags, &bufp->options.notify.conn);
        
        break;
#endif
#if defined (SBH)
    case IOCTL_CVY_QUERY_PERF:
        irp -> IoStatus . Information = 0;
        
        if (ilen != sizeof (IOCTL_LOCAL_HDR) || olen != sizeof (CVY_DRIVER_PERF) || bufp == NULL)
        {
            UNIV_PRINT(("Buffer is missing or not the expected (%d) size: %d, %d", sizeof(IOCTL_LOCAL_HDR), ilen, olen));
            status = STATUS_INVALID_PARAMETER;
            break;
        }
        
        adapter_index = Main_adapter_get (bufp -> device_name);
        
        if (adapter_index == MAIN_ADAPTER_NOT_FOUND)
        {
            UNIV_PRINT(("Unknown adapter: %ls", bufp -> device_name));
            status = STATUS_INVALID_PARAMETER;
            break;
        }
        
        UNIV_PRINT(("Ioctl perf for adapter %ls", bufp -> device_name));
        
        ctxtp = univ_adapters [adapter_index] . ctxtp;
        
        status = Main_QueryPerf(ctxtp, (PCVY_DRIVER_PERF)bufp);
        
        if (status == NDIS_STATUS_SUCCESS)
        {
            irp -> IoStatus . Information = sizeof (CVY_DRIVER_PERF);
        }
        
        break;
#endif /* SBH */
    default:
        UNIV_PRINT(("Unknown Ioctl code: %x", io_ctrl_code));
        break;
    }
    
    return status;
    
} /* end Main_ioctl */

/* 
 * Function: Query_state_ctrl
 * Description: 
 * Parameters: 
 * Returns: 
 * Author: shouse 5.18.01
 */
NDIS_STATUS Query_state_ctrl (PMAIN_CTXT ctxtp, ULONG fOptions, PIOCTL_QUERY_STATE pQuery) {
    PMAIN_ADAPTER pAdapter = &(univ_adapters[ctxtp->adapter_id]);

    NdisAcquireSpinLock(&univ_bind_lock);

    /* If the adapter isn't initialized yet, refuse the request. */
    if (!pAdapter->inited) {
        NdisReleaseSpinLock(&univ_bind_lock);
        pQuery->ReturnCode = NLB_QUERY_STATE_FAILURE;
        return NDIS_STATUS_SUCCESS;
    }

    NdisReleaseSpinLock(&univ_bind_lock);

    switch (pQuery->Operation) {
    case NLB_QUERY_REG_PARAMS:
    case NLB_QUERY_PORT_RULE_STATE:
    case NLB_QUERY_BDA_TEAM_STATE:
    case NLB_QUERY_PACKET_STATISTICS:
        UNIV_PRINT (("Unimplemented operation: %d", pQuery->Operation));

        pQuery->ReturnCode = NLB_QUERY_STATE_FAILURE;        

        break;

    /* Given a IP tuple (client IP, client port, server IP, server port) and a protocol, 
       determine whether or not this host would accept the packet and why or why not. It
       is important that this is performed completely unobtrusively and has no side-effects
       on the actual operation of NLB and the load module. */
    case NLB_QUERY_PACKET_FILTER:
        /* Being by Zero'ing out the results portion of the buffer. */
        NdisZeroMemory(&pQuery->Filter.Results, sizeof(pQuery->Filter.Results));

        /* Query NLB for packet filter information for this IP tuple and protocol.  Main_query_packet_filter
           checks the NDIS driver information for filtering issues such as DIP traffic, BDA teaming and 
           NLB driver state (on/off due to wlbs.exe commands and parameter errors).  If necessary, it then
           consults the load module to perform the actual port rule lookup and determine packet acceptance. */
        Main_query_packet_filter(ctxtp, &pQuery->Filter);
        
        /* This should always result in success, whether the packet is accepted or not. */
        pQuery->ReturnCode = NLB_QUERY_STATE_SUCCESS;

        break;
    default:
        UNIV_PRINT (("Unknown operation: %d", pQuery->Operation));

        pQuery->ReturnCode = NLB_QUERY_STATE_FAILURE;

        break;
    }
    
    return NDIS_STATUS_SUCCESS;
}


#if defined (NLB_SESSION_SUPPORT)
/* 
 * Function: Conn_notify_ctrl
 * Description: 
 * Parameters: 
 * Returns: 
 * Author: shouse 4.30.01
 */
NDIS_STATUS Conn_notify_ctrl (PMAIN_CTXT ctxtp, ULONG fOptions, PIOCTL_CONN_NOTIFICATION pConn) {
    PMAIN_ADAPTER pAdapter = &(univ_adapters[ctxtp->adapter_id]);
    BOOLEAN bRefused = FALSE;
    BOOLEAN bRet = TRUE;

    NdisAcquireSpinLock(&univ_bind_lock);

    /* If the adapter isn't initialized yet, refuse the request. */
    if (!pAdapter->inited) {
        NdisReleaseSpinLock(&univ_bind_lock);
        pConn->ReturnCode = NLB_ERROR_GENERIC_FAILURE;
        return NDIS_STATUS_SUCCESS;
    }

    NdisReleaseSpinLock(&univ_bind_lock);

    /* Make sure that the parameters from the input buffer are valid. */
    if ((pConn->Protocol != TCPIP_PROTOCOL_IPSEC1) || (pConn->ServerPort > CVY_MAX_PORT) || 
        (pConn->ClientPort > CVY_MAX_PORT) || (!pConn->ServerIPAddress) || (!pConn->ClientIPAddress)) {
        /* Use the return code in the IOCTL buffer to relay a parameter error and return success. */
        pConn->ReturnCode = NLB_ERROR_INVALID_PARAMETER;
        return NDIS_STATUS_SUCCESS;
    }

    switch (pConn->Operation) {
    case NLB_CONN_UP:
        /* Notify the load module of the upcoming connection. */
        bRet = Main_create_dscr(ctxtp, pConn->ServerIPAddress, pConn->ServerPort, pConn->ClientIPAddress, pConn->ClientPort, pConn->Protocol, &bRefused, FALSE);

        /* If the packet was refused by BDA or rejected by the load module, return refusal error, otherwise, it succeeded. */
        if (bRefused || !bRet) 
            pConn->ReturnCode = NLB_ERROR_REQUEST_REFUSED;
        else 
            pConn->ReturnCode = NLB_ERROR_SUCCESS;

        break;
    case NLB_CONN_DOWN:
    case NLB_CONN_RESET:
        /* Notify the load module that a connection is being torn down. */
        bRet = Main_conn_advise(ctxtp, pConn->ServerIPAddress, pConn->ServerPort, pConn->ClientIPAddress, pConn->ClientPort, pConn->Protocol, CVY_CONN_DOWN, &bRefused, FALSE);

        /* If the packet was refused by BDA or rejected by the load module, return refusal error, otherwise, it succeeded. */
        if (bRefused || !bRet) 
            pConn->ReturnCode = NLB_ERROR_REQUEST_REFUSED;
        else
            pConn->ReturnCode = NLB_ERROR_SUCCESS;

        break;
    default:
        UNIV_PRINT (("Unknown operation: %d", pConn->Operation));

        /* This should never, ever happen, but if it does, signal a generic NLB error and fail. */
        pConn->ReturnCode = NLB_ERROR_GENERIC_FAILURE;
        break;
    }

    return NDIS_STATUS_SUCCESS;
}
#endif

NDIS_STATUS Main_ctrl (
    PMAIN_CTXT              ctxtp,
    ULONG                   io_ctrl_code,
    PIOCTL_CVY_BUF          bufp,
    /* Note: optionsp CAN be NULL, so you must check it first. */
    PIOCTL_OPTIONS          optionsp) 
{
    WCHAR                   num [20];
    ULONG                   mode;
    ULONG                   old_ip;
    PMAIN_ADAPTER           adapterp = & (univ_adapters [ctxtp -> adapter_id]);


    NdisAcquireSpinLock(& univ_bind_lock);
    if (! adapterp -> inited)
    {
        NdisReleaseSpinLock(& univ_bind_lock);
        UNIV_PRINT (("unbound from all NICs"));
        return NDIS_STATUS_FAILURE;
    }

    NdisReleaseSpinLock(& univ_bind_lock);

    /* make sure data is written into bufp AFTER taking everything we need
       out of it !!! */

    switch (io_ctrl_code)
    {
        case IOCTL_CVY_RELOAD:
        {
            CVY_PARAMS old_params;
            CVY_PARAMS new_params;

            if (KeGetCurrentIrql () > PASSIVE_LEVEL)
            {
                UNIV_PRINT (("!!! IRQL IS TOO HIGH %d\n", KeGetCurrentIrql ()));
                return NDIS_STATUS_FAILURE;
            }

            /* Take a snapshot of the old parameter set for later comparison. */
            RtlCopyMemory(&old_params, &ctxtp -> params, sizeof(ctxtp -> params));

            /* Spin locks can not be acquired when we are calling Params_init
               since it will be doing registry access operations that depend on
               running at PASSIVEL_IRQL_LEVEL.  Therefore, we gather the new
               parameters into a temporary structure and copy them in the NLB
               context protected by a spin lock. */
            if (Params_init(ctxtp, univ_reg_path, adapterp->device_name + 8, &new_params) != NDIS_STATUS_SUCCESS) 
            {
                UNIV_PRINT (("error retrieving registry parameters"));
                bufp->ret_code = IOCTL_CVY_BAD_PARAMS;
                break;
            }
            
            NdisAcquireSpinLock (& ctxtp -> load_lock);   /* V1.0.3, V1.3.2b */

            /* At this point, we have verified that the new parameters are valid,
               so copy them into the permanent parameters structure. */
            RtlCopyMemory(&ctxtp->params, &new_params, sizeof(ctxtp->params));
            ctxtp->params_valid = TRUE;

            Univ_ulong_to_str (ctxtp -> params . host_priority, num, 10);

            if (ctxtp -> convoy_enabled && 
                Main_ApplyChangeWithoutReStart(ctxtp, &old_params, &ctxtp -> params)) 
            {
                //
                // Changes is applied with no need to restart
                //
                NdisReleaseSpinLock (& ctxtp -> load_lock); 
                bufp -> ret_code = IOCTL_CVY_OK;
                break;
            }

            mode = ctxtp -> convoy_enabled;

            bufp -> ret_code = IOCTL_CVY_OK;

            if (ctxtp -> convoy_enabled)
            {
                ctxtp -> convoy_enabled = FALSE;
                Load_stop (& ctxtp -> load);

                if (ctxtp -> draining)
                {
                    ctxtp -> draining = FALSE;
                    NdisReleaseSpinLock (& ctxtp -> load_lock);     /* V1.0.3 */

                    UNIV_PRINT (("connection draining interrupted"));
                    LOG_MSG (MSG_INFO_DRAINING_STOPPED, MSG_NONE);

                    bufp -> ret_code = IOCTL_CVY_DRAINING_STOPPED;
                }
                else
                    NdisReleaseSpinLock (& ctxtp -> load_lock);     /* V1.0.3 */

                UNIV_PRINT (("cluster mode stopped"));
                LOG_MSG (MSG_INFO_STOPPED, MSG_NONE);
            }
            else
                NdisReleaseSpinLock (& ctxtp -> load_lock);     /* V1.0.3 */


            old_ip = ctxtp->cl_ip_addr;

            if (! Main_ip_addr_init (ctxtp) || ! Main_mac_addr_init (ctxtp) || ! Main_teaming_init(ctxtp))
            {
                ctxtp -> params_valid = FALSE;
                UNIV_PRINT (("parameter error"));
                LOG_MSG (MSG_ERROR_DISABLED, MSG_NONE);
                bufp -> ret_code  = IOCTL_CVY_BAD_PARAMS;
                break;
            }

	    if (ctxtp -> params . mcast_support && ctxtp -> params . igmp_support)
		Main_igmp_init (ctxtp, TRUE);

            if (old_ip != ctxtp->cl_ip_addr)
            {
                NdisAcquireSpinLock (& ctxtp -> load_lock);
                univ_changing_ip = ctxtp -> params.ip_chg_delay;
                NdisReleaseSpinLock (& ctxtp -> load_lock);

                UNIV_PRINT (("changing IP address with delay %d", univ_changing_ip));
            }

            LOG_MSG (MSG_INFO_RELOADED, MSG_NONE);

            if (mode)
            {
                NdisAcquireSpinLock (& ctxtp -> load_lock);   /* V1.0.3, V1.3.2b */

                Load_start (& ctxtp -> load);
                ctxtp -> convoy_enabled = TRUE;

                NdisReleaseSpinLock (& ctxtp -> load_lock);     /* V1.0.3, V1.3.2b */

                UNIV_PRINT (("cluster mode started"));
                LOG_MSG (MSG_INFO_STARTED, num);
            }

            ctxtp -> bad_host_warned = FALSE;

            UNIV_PRINT (("parameters reloaded"));

            break;
        }
        

        case IOCTL_CVY_CLUSTER_RESUME:

            NdisAcquireSpinLock (& ctxtp -> load_lock);   /* V1.0.3, V1.3.2b */

            if (! ctxtp -> suspended)
            {
                NdisReleaseSpinLock (& ctxtp -> load_lock);     /* V1.0.3, V1.3.2b */
                UNIV_PRINT (("cluster mode already resumed"));
                bufp -> ret_code = IOCTL_CVY_ALREADY;
                break;
            }

            UNIV_ASSERT (! ctxtp -> convoy_enabled);
            UNIV_ASSERT (! ctxtp -> draining);

            ctxtp -> suspended = FALSE;
            NdisReleaseSpinLock (& ctxtp -> load_lock);     /* V1.0.3, V1.3.2b */

            UNIV_PRINT (("cluster mode resumed"));
            LOG_MSG (MSG_INFO_RESUMED, MSG_NONE);

            bufp -> ret_code = IOCTL_CVY_OK;
            break;

        case IOCTL_CVY_CLUSTER_ON:

            Univ_ulong_to_str (ctxtp -> params . host_priority, num, 10);

            NdisAcquireSpinLock (& ctxtp -> load_lock);   /* V1.0.3, V1.3.2b */

            if (ctxtp -> suspended)
            {
                UNIV_ASSERT (! ctxtp -> convoy_enabled);
                UNIV_ASSERT (! ctxtp -> draining);

                NdisReleaseSpinLock (& ctxtp -> load_lock);
                UNIV_PRINT (("cluster mode is suspended"));
                bufp -> ret_code = IOCTL_CVY_SUSPENDED;
                break;
            }

            /* V2.1 */

            if (ctxtp -> draining)
            {
                UNIV_ASSERT (ctxtp -> convoy_enabled);

                UNIV_PRINT(("START: Calling Load_port_change -> VIP=%08x, port=%d, load=%d\n", 
                            IOCTL_ALL_VIPS, IOCTL_ALL_PORTS, 0));

                bufp -> ret_code = Load_port_change (& ctxtp -> load,
                                                     IOCTL_ALL_VIPS,
                                                     IOCTL_ALL_PORTS,
                                                     (ULONG) IOCTL_CVY_CLUSTER_PLUG,
                                                     0);

                ctxtp -> draining = FALSE;

                NdisReleaseSpinLock (& ctxtp -> load_lock);     /* V1.0.3, V1.3.2b */

                UNIV_PRINT (("connection draining interrupted"));
                LOG_MSG (MSG_INFO_DRAINING_STOPPED, MSG_NONE);

                UNIV_PRINT (("cluster mode started"));
                LOG_MSG (MSG_INFO_STARTED, num);

                bufp -> ret_code = IOCTL_CVY_DRAINING_STOPPED;
                break;
            }

            if (ctxtp -> convoy_enabled)
            {
                NdisReleaseSpinLock (& ctxtp -> load_lock);     /* V1.0.3, V1.3.2b */
                UNIV_PRINT (("cluster mode already started"));
                bufp -> ret_code = IOCTL_CVY_ALREADY;
                break;
            }

            if (! ctxtp -> params_valid)
            {
                NdisReleaseSpinLock (& ctxtp -> load_lock);     /* V1.0.3, V1.3.2b */
                UNIV_PRINT (("parameter error"));
                LOG_MSG (MSG_ERROR_DISABLED, MSG_NONE);
                bufp -> ret_code  = IOCTL_CVY_BAD_PARAMS;
                break;
            }

            Load_start (& ctxtp -> load);
            ctxtp -> convoy_enabled = TRUE;
            NdisReleaseSpinLock (& ctxtp -> load_lock);     /* V1.0.3, V1.3.2b */

            ctxtp -> bad_host_warned = FALSE;

            UNIV_PRINT (("cluster mode started"));
            LOG_MSG (MSG_INFO_STARTED, num);

            bufp -> ret_code = IOCTL_CVY_OK;
            break;

        case IOCTL_CVY_CLUSTER_SUSPEND:

            NdisAcquireSpinLock (& ctxtp -> load_lock);   /* V1.0.3, V1.3.2b */

            if (ctxtp -> suspended)
            {
                NdisReleaseSpinLock (& ctxtp -> load_lock);     /* V1.0.3, V1.3.2b */
                UNIV_PRINT (("cluster mode already suspended"));
                bufp -> ret_code = IOCTL_CVY_ALREADY;
                break;
            }

            ctxtp -> suspended = TRUE;

            if (ctxtp -> convoy_enabled)
            {
                ctxtp -> convoy_enabled = FALSE;
                ctxtp -> stopping = TRUE;
                Load_stop (& ctxtp -> load);

                /* V2.1 */

                if (ctxtp -> draining)
                {
                    ctxtp -> draining = FALSE;

                    NdisReleaseSpinLock (& ctxtp -> load_lock);
                    UNIV_PRINT (("connection draining interrupted"));
                    LOG_MSG (MSG_INFO_DRAINING_STOPPED, MSG_NONE);

                    bufp -> ret_code = IOCTL_CVY_DRAINING_STOPPED;
                }
                else
                {
                    NdisReleaseSpinLock (& ctxtp -> load_lock);
                    bufp -> ret_code = IOCTL_CVY_STOPPED;
                }

                UNIV_PRINT (("cluster mode stopped"));
                LOG_MSG (MSG_INFO_STOPPED, MSG_NONE);
            }
            else
            {
                NdisReleaseSpinLock (& ctxtp -> load_lock);
                bufp -> ret_code = IOCTL_CVY_OK;
            }

            UNIV_PRINT (("cluster mode suspended"));
            LOG_MSG (MSG_INFO_SUSPENDED, MSG_NONE);

            break;

        case IOCTL_CVY_CLUSTER_OFF:

            NdisAcquireSpinLock (& ctxtp -> load_lock);   /* V1.0.3, V1.3.2b */

            if (ctxtp -> suspended)
            {
                UNIV_ASSERT (! ctxtp -> convoy_enabled);
                UNIV_ASSERT (! ctxtp -> draining);

                NdisReleaseSpinLock (& ctxtp -> load_lock);
                UNIV_PRINT (("cluster mode is suspended"));
                bufp -> ret_code = IOCTL_CVY_SUSPENDED;
                break;
            }

            if (! ctxtp -> convoy_enabled)
            {
                NdisReleaseSpinLock (& ctxtp -> load_lock);     /* V1.0.3, V1.3.2b */
                UNIV_PRINT (("cluster mode already stopped"));
                bufp -> ret_code = IOCTL_CVY_ALREADY;
                break;
            }

            ctxtp -> convoy_enabled = FALSE;
            ctxtp -> stopping = TRUE;
            Load_stop (& ctxtp -> load);

            /* V2.1 */

            if (ctxtp -> draining)
            {
                ctxtp -> draining = FALSE;
                NdisReleaseSpinLock (& ctxtp -> load_lock);     /* V1.0.3 */

                UNIV_PRINT (("connection draining interrupted"));
                LOG_MSG (MSG_INFO_DRAINING_STOPPED, MSG_NONE);

                bufp -> ret_code = IOCTL_CVY_DRAINING_STOPPED;
            }
            else
            {
                NdisReleaseSpinLock (& ctxtp -> load_lock);     /* V1.0.3 */
                bufp -> ret_code = IOCTL_CVY_OK;
            }

            UNIV_PRINT (("cluster mode stopped"));
            LOG_MSG (MSG_INFO_STOPPED, MSG_NONE);

            break;

        /* V2.1 */

        case IOCTL_CVY_CLUSTER_DRAIN:

            NdisAcquireSpinLock (& ctxtp -> load_lock);  /* V1.0.3 */

            if (ctxtp -> suspended)
            {
                UNIV_ASSERT (! ctxtp -> convoy_enabled);
                UNIV_ASSERT (! ctxtp -> draining);

                NdisReleaseSpinLock (& ctxtp -> load_lock);
                UNIV_PRINT (("cluster mode is suspended"));
                bufp -> ret_code = IOCTL_CVY_SUSPENDED;
                break;
            }

            if (! ctxtp -> convoy_enabled)
            {
                UNIV_ASSERT (! ctxtp -> draining);
                NdisReleaseSpinLock (& ctxtp -> load_lock);  /* V1.0.3 */
                UNIV_PRINT (("cannot drain connections while cluster is stopped"));
                bufp -> ret_code = IOCTL_CVY_STOPPED;
                break;
            }

            if (ctxtp -> draining)
            {
                NdisReleaseSpinLock (& ctxtp -> load_lock);     /* V1.0.3, V1.3.2b */
                UNIV_PRINT (("already draining"));
                bufp -> ret_code = IOCTL_CVY_ALREADY;
                break;
            }

            ctxtp -> draining = TRUE;

            UNIV_PRINT(("DRAIN: Calling Load_port_change -> VIP=%08x, port=%d, load=%d\n", 
                        IOCTL_ALL_VIPS, IOCTL_ALL_PORTS, 0));

            bufp -> ret_code = Load_port_change (& ctxtp -> load,
                                                 IOCTL_ALL_VIPS,
                                                 IOCTL_ALL_PORTS,
                                                 io_ctrl_code,
                                                 0);

            NdisReleaseSpinLock (& ctxtp -> load_lock);  /* V1.0.3 */

            if (bufp -> ret_code == IOCTL_CVY_OK)
            {
                UNIV_PRINT (("connection draining started"));
                LOG_MSG (MSG_INFO_CLUSTER_DRAINED, MSG_NONE);
            }

            break;

        case IOCTL_CVY_PORT_ON:
        case IOCTL_CVY_PORT_SET:

            Univ_ulong_to_str (bufp -> data . port . num, num, 10);

            NdisAcquireSpinLock (& ctxtp -> load_lock);  /* V1.0.3 */

            if (ctxtp -> suspended)
            {
                UNIV_ASSERT (! ctxtp -> convoy_enabled);
                UNIV_ASSERT (! ctxtp -> draining);

                NdisReleaseSpinLock (& ctxtp -> load_lock);
                UNIV_PRINT (("cluster mode is suspended"));
                bufp -> ret_code = IOCTL_CVY_SUSPENDED;
                break;
            }

            if (! ctxtp -> convoy_enabled)
            {
                NdisReleaseSpinLock (& ctxtp -> load_lock);  /* V1.0.3 */
                UNIV_PRINT (("cannot enable/disable port while cluster is stopped"));
                LOG_MSG (MSG_WARN_CLUSTER_STOPPED, MSG_NONE);
                bufp -> ret_code = IOCTL_CVY_STOPPED;
                break;
            }

            UNIV_PRINT(("ENABLE: Calling Load_port_change -> VIP=%08x, port=%d, load=%d\n", 
                        (optionsp) ? optionsp->port.virtual_ip_addr : IOCTL_ALL_VIPS, bufp->data.port.num, bufp->data.port.load));

            bufp -> ret_code = Load_port_change (& ctxtp -> load,
                                                 (optionsp) ? optionsp->port.virtual_ip_addr : IOCTL_ALL_VIPS,
                                                 bufp->data.port.num,
                                                 io_ctrl_code,
                                                 bufp->data.port.load);

            NdisReleaseSpinLock (& ctxtp -> load_lock);  /* V1.0.3 */

            if (bufp -> ret_code == IOCTL_CVY_NOT_FOUND)
            {
                UNIV_PRINT (("port %d not found in any of the valid port rules", bufp -> data . port . num));
                LOG_MSG (MSG_WARN_PORT_NOT_FOUND, num);
            }
            else if (bufp -> ret_code == IOCTL_CVY_OK)
            {
                if (io_ctrl_code == IOCTL_CVY_PORT_ON)
                {
                    if (bufp -> data . port . num == IOCTL_ALL_PORTS)
                    {
                        UNIV_PRINT (("all port rules enabled"));
                        LOG_MSG (MSG_INFO_PORT_ENABLED_ALL, MSG_NONE);
                    }
                    else
                    {
                        UNIV_PRINT (("rule for port %d enabled", bufp -> data . port . num));
                        LOG_MSG (MSG_INFO_PORT_ENABLED, num);
                    }
                }
                else
                {
                    if (bufp -> data . port . num == IOCTL_ALL_PORTS)
                    {
                        UNIV_PRINT (("all port rules adjusted"));
                        LOG_MSG (MSG_INFO_PORT_ADJUSTED_ALL, MSG_NONE);
                    }
                    else
                    {
                        UNIV_PRINT (("rule for port %d adjusted to %d", bufp -> data . port . num, bufp -> data . port . load));
                        LOG_MSG (MSG_INFO_PORT_ADJUSTED, num);
                    }
                }
            }
            else
            {
                UNIV_PRINT (("port %d already enabled", bufp -> data . port . num));
            }

            break;

        case IOCTL_CVY_PORT_OFF:
        case IOCTL_CVY_PORT_DRAIN:

            Univ_ulong_to_str (bufp -> data . port . num, num, 10);

            NdisAcquireSpinLock (& ctxtp -> load_lock);   /* V1.0.3 */

            if (ctxtp -> suspended)
            {
                UNIV_ASSERT (! ctxtp -> convoy_enabled);
                UNIV_ASSERT (! ctxtp -> draining);

                NdisReleaseSpinLock (& ctxtp -> load_lock);
                UNIV_PRINT (("cluster mode is suspended"));
                bufp -> ret_code = IOCTL_CVY_SUSPENDED;
                break;
            }

            if (! ctxtp -> convoy_enabled)
            {
                NdisReleaseSpinLock (& ctxtp -> load_lock);  /* V1.0.3 */
                UNIV_PRINT (("cannot enable/disable port while cluster is stopped"));
                LOG_MSG (MSG_WARN_CLUSTER_STOPPED, MSG_NONE);
                bufp -> ret_code = IOCTL_CVY_STOPPED;
                break;
            }

            UNIV_PRINT(("DISABLE: Calling Load_port_change -> VIP=%08x, port=%d, load=%d\n", 
                        (optionsp) ? optionsp->port.virtual_ip_addr : IOCTL_ALL_VIPS, bufp->data.port.num, bufp->data.port.load));

            bufp -> ret_code = Load_port_change (& ctxtp -> load,
                                                 (optionsp) ? optionsp->port.virtual_ip_addr : IOCTL_ALL_VIPS,
                                                 bufp->data.port.num,
                                                 io_ctrl_code,
                                                 bufp->data.port.load);

            NdisReleaseSpinLock (& ctxtp -> load_lock); /* V1.0.3 */

            if (bufp -> ret_code == IOCTL_CVY_NOT_FOUND)
            {
                UNIV_PRINT (("port %d not found in any of the valid port rules", bufp -> data . port . num));
                LOG_MSG (MSG_WARN_PORT_NOT_FOUND, num);
            }
            else if (bufp -> ret_code == IOCTL_CVY_OK)
            {
                if (io_ctrl_code == IOCTL_CVY_PORT_OFF)
                {
                    if (bufp -> data . port . num == IOCTL_ALL_PORTS)
                    {
                        UNIV_PRINT (("all port rules disabled"));
                        LOG_MSG (MSG_INFO_PORT_DISABLED_ALL, MSG_NONE);
                    }
                    else
                    {
                        UNIV_PRINT (("rule for port %d disabled", bufp -> data . port . num));
                        LOG_MSG (MSG_INFO_PORT_DISABLED, num);
                    }
                }
                else
                {
                    if (bufp -> data . port . num == IOCTL_ALL_PORTS)
                    {
                        UNIV_PRINT (("all port rules drained"));
                        LOG_MSG (MSG_INFO_PORT_DRAINED_ALL, MSG_NONE);
                    }
                    else
                    {
                        UNIV_PRINT (("rule for port %d drained", bufp -> data . port . num));
                        LOG_MSG (MSG_INFO_PORT_DRAINED, num);
                    }
                }
            }
            else
            {
                UNIV_PRINT (("port %d already disabled", bufp -> data . port . num));
            }

            break;

        case IOCTL_CVY_QUERY:

            NdisAcquireSpinLock (& ctxtp -> load_lock);  /* V1.0.3 */

            if (ctxtp -> suspended)
            {
                UNIV_PRINT (("cannot query status - this host is suspended"));
                bufp -> data . query . state = IOCTL_CVY_SUSPENDED;
            }
            else if (! ctxtp -> convoy_enabled)
            {
                UNIV_PRINT (("cannot query status - this host is not part of the cluster"));
                bufp -> data . query . state = IOCTL_CVY_STOPPED;
            }
            else if (!ctxtp -> media_connected || !MAIN_PNP_DEV_ON(ctxtp))
            {
                UNIV_PRINT (("cannot query status - this host is not connected to the network"));
                bufp -> data . query . state = IOCTL_CVY_DISCONNECTED;
            }
            else
            {
                ULONG     tmp_host_map; /* 64-bit -- ramkrish */

                bufp -> data . query . state = (USHORT) Load_hosts_query (& ctxtp -> load, FALSE,
                                                                          & tmp_host_map);
                bufp -> data . query . host_map = tmp_host_map;

                /* V2.1 */

                if (ctxtp -> draining &&
                    bufp -> data . query . state != IOCTL_CVY_CONVERGING)
                    bufp -> data . query . state = IOCTL_CVY_DRAINING;
            }

            bufp -> data . query . host_id = (USHORT) ctxtp -> params . host_priority;

            NdisReleaseSpinLock (& ctxtp -> load_lock);  /* V1.0.3 */

            /* If the user-level application has requested the hostname, return it. */
            if (optionsp && (optionsp->query.flags & IOCTL_OPTIONS_QUERY_HOSTNAME))
                NdisMoveMemory(optionsp->query.hostname, ctxtp->params.hostname, CVY_MAX_HOST_NAME + 1);

            break;

        default:
            UNIV_PRINT (("bad IOCTL %x", io_ctrl_code));
            return NDIS_STATUS_FAILURE;
    }

    return NDIS_STATUS_SUCCESS;

} /* end Main_ctrl */




//+----------------------------------------------------------------------------
//
// Function:  Main_ctrl_recv
//
// Description:  Process remote control request packet
//
// Arguments: MAIN_CTXT          ctxtp - 
//            PNDIS_PACKET        packet - 
//
// Returns:   Nothing
//
// History:   kyrilf initial code
//            fengsun Created Header    11/15/00
//
//+----------------------------------------------------------------------------
VOID Main_ctrl_recv (
    PMAIN_CTXT          ctxtp,
    PNDIS_PACKET        packet)
{
    NDIS_STATUS         status = NDIS_STATUS_SUCCESS;
    PIP_HDR             ip_hdrp;
    PUCHAR              mac_hdrp;
    PUDP_HDR            udp_hdrp;
    ULONG               len;
    USHORT              sig;
    ULONG               soff, doff;
    CVY_MAC_ADR         tmp_mac;
    PIOCTL_REMOTE_HDR   rct_hdrp;
    ULONG               state, host_map;
    USHORT              checksum, group;
    ULONG               i;
    ULONG               tmp_src_addr, tmp_dst_addr;   /* 64-bit -- ramkrish */
    USHORT              tmp_src_port, tmp_dst_port;   /* 64-bit -- ramkrish */
    BOOLEAN             IgnorePassword = FALSE;   // whether to ignore remote control password

    UNIV_PRINT (("Main_ctrl_recv: processing"));

    ip_hdrp = (PIP_HDR) Main_frame_parse (ctxtp, packet, & mac_hdrp, 0,
                                          (PUCHAR *) & udp_hdrp, & len, & sig,
                                          & group, FALSE);

    if (ip_hdrp == NULL || udp_hdrp == NULL)  /* v2.0.6 */
        goto quit;

    /* v2.0.6 */

    if (len < NLB_MIN_RCTL_PACKET_LEN(ip_hdrp))
    {
        UNIV_PRINT(("remote control packet not expected length: got %d bytes, expected at least %d bytes\n", len, NLB_MIN_RCTL_PACKET_LEN(ip_hdrp)));
        goto quit;
    }

    checksum = Tcpip_chksum (& ctxtp -> tcpip, ip_hdrp, NULL, TCPIP_PROTOCOL_IP);

    if (IP_GET_CHKSUM (ip_hdrp) != checksum)
    {
        UNIV_PRINT (("bad PP checksum %x vs %x\n", IP_GET_CHKSUM (ip_hdrp), checksum))
        goto quit;
    }

    checksum = Tcpip_chksum (& ctxtp -> tcpip, ip_hdrp, (PUCHAR) udp_hdrp, TCPIP_PROTOCOL_UDP);

    if (UDP_GET_CHKSUM (udp_hdrp) != checksum)
    {
        UNIV_PRINT (("bad UDP checksum %x vs %x\n", UDP_GET_CHKSUM (udp_hdrp), checksum))
        goto quit;
    }

    rct_hdrp = (PIOCTL_REMOTE_HDR) UDP_GET_DGRAM_PTR (udp_hdrp);

    /* double-check the code */

    if (rct_hdrp -> code != IOCTL_REMOTE_CODE)
    {
        UNIV_PRINT (("bad RCT code %x\n", rct_hdrp -> code));
        goto quit;
    }

    /* might want to take appropriate actions for a message from a host
       running different version number of software */

    if (rct_hdrp -> version != CVY_VERSION_FULL)
    {
        UNIV_PRINT (("version mismatch %x vs %x", rct_hdrp -> version, CVY_VERSION_FULL));
    }

    /* see if this message is destined for this cluster */

    if (rct_hdrp -> cluster != ctxtp -> cl_ip_addr)
    {
        UNIV_PRINT (("message for cluster %08X rejected on cluster %08X", rct_hdrp -> cluster, ctxtp -> cl_ip_addr));
        goto quit;
    }

    /* 64-bit -- ramkrish */

    tmp_src_addr = IP_GET_SRC_ADDR_64(ip_hdrp);
    tmp_dst_addr = IP_GET_DST_ADDR_64(ip_hdrp);

    /* do not trust src addr in header, since winsock does not resolve
       multihomed addresses properly */

    rct_hdrp -> addr = tmp_src_addr;

    /* If remote control is disabled, we drop the requests. */
    if (!ctxtp->params.rct_enabled) {
        /* If remote control is disabled, still allows query originated from a machine in 
           the same cluster.  This way, an application running on one host can get a list 
           of all hosts (include stopped host) even if remote control is disabled. */
        if (rct_hdrp->ioctrl != IOCTL_CVY_QUERY)
            goto quit;

        /* This in only supported using the XP remote control packet format. */
        if (rct_hdrp->version != CVY_VERSION_FULL)
            goto quit;

        /* Make sure that the packet length is what we expect, or we may fault. */
        if (len < NLB_WINXP_RCTL_PACKET_LEN(ip_hdrp))
            goto quit;

        /* Check to see if the request originated on a member of the cluster for
           which the query is destined.  The user-level software on the initiator
           checks its own NLB configuration and sets this bit if it is a member
           of the target cluster. */
        if (!(rct_hdrp->options.query.flags & IOCTL_OPTIONS_QUERY_CLUSTER_MEMBER))
            goto quit;

        /* Ignore the password in such an instance. */
        IgnorePassword = TRUE;
    }

    /* query load to see if we are the master, etc. */

    if (! ctxtp -> convoy_enabled)
        state = IOCTL_CVY_STOPPED;
    else
        state = Load_hosts_query (& ctxtp -> load, FALSE, & host_map);

    /* check if this message is destined to us */

    //
    // The host id in the remote control packet could be
    //      IOCTL_MASTER_HOST (0) for master host
    //      IOCTL_ALL_HOSTS (FFFFFFFF) for all hosts
    //      Host ID, for one host
    //      Dedicated IP, for one host
    //      Cluster IP, for all hosts in the cluster
    //
    
    if (rct_hdrp -> host == IOCTL_MASTER_HOST)
    {
        if (state != IOCTL_CVY_MASTER)
        {
            UNIV_PRINT (("RCT request for MASTER host rejected"));
            goto quit;
        }
    }
    else if (rct_hdrp -> host != IOCTL_ALL_HOSTS)
    {
        if (rct_hdrp -> host > CVY_MAX_HOSTS)
        {
            if (! ((ctxtp -> ded_ip_addr != 0 &&
                    rct_hdrp -> host == ctxtp -> ded_ip_addr) ||
                    rct_hdrp -> host == ctxtp -> cl_ip_addr))
            {
                UNIV_PRINT (("RCT request for host IP %x rejected", rct_hdrp -> host));
                goto quit;
            }
        }
        else
        {
            if (! (rct_hdrp -> host == ctxtp -> params . host_priority ||
                   rct_hdrp -> host == 0))
            {
                UNIV_PRINT (("RCT request for host ID %d rejected", rct_hdrp -> host));
                goto quit;
            }
        }
    }



    /* if this is VR remote maintenance password */

    if (rct_hdrp -> password == IOCTL_REMOTE_VR_CODE)
    {
        /* if user disabled this function - drop the packet */

        if (ctxtp -> params . rmt_password == 0)
        {
            UNIV_PRINT (("VR remote password rejected"));
            goto quit;
        }
        else
        {
            UNIV_PRINT (("VR remote password accepted"));
        }
    }


    //
    // This is a new remote control request, with a different source IP 
    //  or newer ID.
    // Log an event if the password does not match or if the command is not query
    //
    if (! (rct_hdrp -> addr == ctxtp -> rct_last_addr &&
           rct_hdrp -> id   <= ctxtp -> rct_last_id))
    {
        WCHAR               buf [256];  
        PWCHAR              ptr = buf;

        //
        // Generate string "SourceIp:SourcePort"
        //
        for (i = 0; i < 4; i ++)
        {
            ptr = Univ_ulong_to_str (IP_GET_SRC_ADDR (ip_hdrp, i), ptr, 10);

            * ptr = L'.';
            ptr ++;
        }

        ptr --;
        * ptr = L':';
        ptr ++;

        ptr = Univ_ulong_to_str (UDP_GET_SRC_PORT (udp_hdrp), ptr, 10);
        * ptr = 0;

        if (!IgnorePassword &&
            ctxtp -> params . rct_password != 0 &&
            rct_hdrp -> password != ctxtp -> params . rct_password)
        {
            LOG_MSG (MSG_WARN_RCT_HACK, buf);

            UNIV_PRINT (("RCT hack attempt on port %d from %d.%d.%d.%d:%d",
                                                UDP_GET_DST_PORT (udp_hdrp),
                                                IP_GET_SRC_ADDR (ip_hdrp, 0),
                                                IP_GET_SRC_ADDR (ip_hdrp, 1),
                                                IP_GET_SRC_ADDR (ip_hdrp, 2),
                                                IP_GET_SRC_ADDR (ip_hdrp, 3),
                                                UDP_GET_SRC_PORT (udp_hdrp)));
        }

        /* only log error commands and commands that affect cluster state */

        else if (rct_hdrp -> ioctrl != IOCTL_CVY_QUERY)
        {
            PWSTR           cmd;

            switch (rct_hdrp -> ioctrl)
            {
                case IOCTL_CVY_CLUSTER_ON:
                    cmd = L"START";
                    break;

                case IOCTL_CVY_CLUSTER_OFF:
                    cmd = L"STOP";
                    break;

                case IOCTL_CVY_CLUSTER_DRAIN:
                    cmd = L"DRAINSTOP";
                    break;

                case IOCTL_CVY_PORT_ON:
                    cmd = L"ENABLE";
                    break;

                case IOCTL_CVY_PORT_SET:
                    cmd = L"ADJUST";
                    break;

                case IOCTL_CVY_PORT_OFF:
                    cmd = L"DISABLE";
                    break;

                case IOCTL_CVY_PORT_DRAIN:
                    cmd = L"DRAIN";
                    break;

                case IOCTL_CVY_QUERY:
                    cmd = L"QUERY";
                    break;

                case IOCTL_CVY_CLUSTER_SUSPEND:
                    cmd = L"SUSPEND";
                    break;

                case IOCTL_CVY_CLUSTER_RESUME:
                    cmd = L"RESUME";
                    break;

                default:
                    cmd = L"UNKNOWN";
                    break;
            }


            LOG_MSGS (MSG_INFO_RCT_RCVD, cmd, buf);

            UNIV_PRINT (("RCT command %x port %d from %d.%d.%d.%d:%d",
                                                rct_hdrp -> ioctrl,
                                                UDP_GET_DST_PORT (udp_hdrp),
                                                IP_GET_SRC_ADDR (ip_hdrp, 0),
                                                IP_GET_SRC_ADDR (ip_hdrp, 1),
                                                IP_GET_SRC_ADDR (ip_hdrp, 2),
                                                IP_GET_SRC_ADDR (ip_hdrp, 3),
                                                UDP_GET_SRC_PORT (udp_hdrp)));
        }
    }

    ctxtp -> rct_last_addr = rct_hdrp -> addr;
    ctxtp -> rct_last_id   = rct_hdrp -> id;

    /* make sure remote control password matches ours */

    if (!IgnorePassword &&
        ctxtp -> params . rct_password != 0 &&
        rct_hdrp -> password != ctxtp -> params . rct_password)
    {
        rct_hdrp -> ctrl . ret_code = IOCTL_CVY_BAD_PASSWORD;
        goto send;
    }

    if (rct_hdrp->version == CVY_NT40_VERSION_FULL) {
        /* Make sure that the packet length is what we expect, or we may fault. */
        if (len < NLB_NT40_RCTL_PACKET_LEN(ip_hdrp)) {
            UNIV_PRINT(("NT 4.0 remote control packet not expected length: got %d bytes, expected %d bytes\n", len, NLB_NT40_RCTL_PACKET_LEN(ip_hdrp)));
            goto quit;
        }

        /* If this remote control packet came from an NT 4.0 host, check our current effective version
           and drop it if we are operating in a Whistler-specific mode (virtual clusters, BDA, etc.). */
        if (ctxtp->params.effective_ver == CVY_VERSION_FULL &&
            (rct_hdrp->ioctrl == IOCTL_CVY_PORT_ON          ||
             rct_hdrp->ioctrl == IOCTL_CVY_PORT_OFF         ||
             rct_hdrp->ioctrl == IOCTL_CVY_PORT_SET         ||
             rct_hdrp->ioctrl == IOCTL_CVY_PORT_DRAIN))
            goto quit;
        /* Otherwise, perform the operation.  Since this request came from a win2K/NT4 host, then hardcode 
           the VIP, which should be ignored by Main_ctrl since we aren't using Virtual clusters. */
        else
            status = Main_ctrl(ctxtp, rct_hdrp->ioctrl, &rct_hdrp->ctrl, NULL);
    } else if (rct_hdrp->version == CVY_WIN2K_VERSION_FULL) {
        /* Make sure that the packet length is what we expect, or we may fault. */
        if (len < NLB_WIN2K_RCTL_PACKET_LEN(ip_hdrp)) {
            UNIV_PRINT(("Windows 2000 remote control packet not expected length: got %d bytes, expected %d bytes\n", len, NLB_WIN2K_RCTL_PACKET_LEN(ip_hdrp)));
            goto quit;
        }

        /* If this remote control packet came from an Win2k host, check our current effective version
           and drop it if we are operating in a Whistler-specific mode (virtual clusters, BDA, etc.). */
        if (ctxtp->params.effective_ver == CVY_VERSION_FULL &&
            (rct_hdrp->ioctrl == IOCTL_CVY_PORT_ON          ||
             rct_hdrp->ioctrl == IOCTL_CVY_PORT_OFF         ||
             rct_hdrp->ioctrl == IOCTL_CVY_PORT_SET         ||
             rct_hdrp->ioctrl == IOCTL_CVY_PORT_DRAIN))           
            goto quit;
        /* Otherwise, perform the operation.  Since this request came from a win2K/NT4 host, then hardcode 
           the VIP, which should be ignored by Main_ctrl since we aren't using Virtual clusters. */
        else
            status = Main_ctrl(ctxtp, rct_hdrp->ioctrl, &rct_hdrp->ctrl, NULL);
    } else {
        /* Make sure that the packet length is what we expect, or we may fault. */
        if (len < NLB_WINXP_RCTL_PACKET_LEN(ip_hdrp)) {
            UNIV_PRINT(("Windows XP remote control packet not expected length: got %d bytes, expected %d bytes\n", len, NLB_WINXP_RCTL_PACKET_LEN(ip_hdrp)));
            goto quit;
        }

        /* Perform the operation.  The virtual IP address is stored in the remote control 
           buffer, not in the IOCTL buffer for reasons of backward compatibility. */
        status = Main_ctrl(ctxtp, rct_hdrp->ioctrl, &rct_hdrp->ctrl, &rct_hdrp->options);
    }

    /* if did not succeed - just drop the packet - client will timeout and
       resend the request */

    if (status != NDIS_STATUS_SUCCESS)
        goto quit;

send:

    rct_hdrp -> version = CVY_VERSION_FULL;
    rct_hdrp -> host    = ctxtp -> params . host_priority;
    rct_hdrp -> addr    = ctxtp -> ded_ip_addr;

    /* flip source and destination MAC, IP addresses and UDP ports to prepare
       for sending this message back */

    soff = CVY_MAC_SRC_OFF (ctxtp -> medium);
    doff = CVY_MAC_DST_OFF (ctxtp -> medium);

    /* V2.0.6 recoded for clarity */

    if (ctxtp -> params . mcast_support)
    {
        if (CVY_MAC_ADDR_BCAST (ctxtp -> medium, mac_hdrp + doff))
            CVY_MAC_ADDR_COPY (ctxtp -> medium, & tmp_mac, & ctxtp -> ded_mac_addr);
        else
            CVY_MAC_ADDR_COPY (ctxtp -> medium, & tmp_mac, mac_hdrp + doff);

        CVY_MAC_ADDR_COPY (ctxtp -> medium, mac_hdrp + doff, mac_hdrp + soff);
        CVY_MAC_ADDR_COPY (ctxtp -> medium, mac_hdrp + soff, & tmp_mac);
    }
    else
    {
        if (! CVY_MAC_ADDR_BCAST (ctxtp -> medium, mac_hdrp + doff))
        {
            CVY_MAC_ADDR_COPY (ctxtp -> medium, & tmp_mac, mac_hdrp + doff);
            CVY_MAC_ADDR_COPY (ctxtp -> medium, mac_hdrp + doff, mac_hdrp + soff);
        }
        else
            CVY_MAC_ADDR_COPY (ctxtp -> medium, & tmp_mac, & ctxtp -> ded_mac_addr);

        /* V2.0.6 spoof source mac to prevent switches from getting confused */

        if (ctxtp -> params . mask_src_mac &&
            CVY_MAC_ADDR_COMP (ctxtp -> medium, & tmp_mac, & ctxtp -> cl_mac_addr))
        {
            CVY_MAC_ADDR_LAA_SET (ctxtp -> medium, mac_hdrp + soff);

            * ((PUCHAR) (mac_hdrp + soff + 1)) = (UCHAR) ctxtp -> params . host_priority;
            * ((PULONG) (mac_hdrp + soff + 2)) = ctxtp -> cl_ip_addr;
        }
        else
            CVY_MAC_ADDR_COPY (ctxtp -> medium, mac_hdrp + soff, & tmp_mac);
    }


    /* 64-bit -- ramkrish */
    if (tmp_dst_addr == TCPIP_BCAST_ADDR)
    {
        tmp_dst_addr = ctxtp -> cl_ip_addr;

        if (ctxtp -> params . mcast_support)
            IP_SET_DST_ADDR_64 (ip_hdrp, tmp_src_addr);  /* 64-bit -- ramkrish */
    }
    else
        IP_SET_DST_ADDR_64 (ip_hdrp, tmp_src_addr); /* 64-bit -- ramkrish */

    IP_SET_SRC_ADDR_64 (ip_hdrp, tmp_dst_addr);

    checksum = Tcpip_chksum (& ctxtp -> tcpip, ip_hdrp, NULL, TCPIP_PROTOCOL_IP);
    IP_SET_CHKSUM (ip_hdrp, checksum);

    /* 64-bit -- ramkrish */
    tmp_src_port = (USHORT) UDP_GET_SRC_PORT (udp_hdrp);
    tmp_dst_port = (USHORT) UDP_GET_DST_PORT (udp_hdrp);

    UDP_SET_SRC_PORT_64 (udp_hdrp, tmp_dst_port);
    UDP_SET_DST_PORT_64 (udp_hdrp, tmp_src_port);

    checksum = Tcpip_chksum (& ctxtp -> tcpip, ip_hdrp, (PUCHAR) udp_hdrp, TCPIP_PROTOCOL_UDP);
    UDP_SET_CHKSUM (udp_hdrp, checksum);

#if defined(TRACE_RCT)
            DbgPrint ("(RCT) sending reply to %d.%d.%d.%d:%d [%02x-%02x-%02x-%02x-%02x-%02x]\n",
                                                IP_GET_DST_ADDR (ip_hdrp, 0),
                                                IP_GET_DST_ADDR (ip_hdrp, 1),
                                                IP_GET_DST_ADDR (ip_hdrp, 2),
                                                IP_GET_DST_ADDR (ip_hdrp, 3),
                                                UDP_GET_DST_PORT (udp_hdrp),
                                                * (mac_hdrp + doff + 0),
                                                * (mac_hdrp + doff + 1),
                                                * (mac_hdrp + doff + 2),
                                                * (mac_hdrp + doff + 3),
                                                * (mac_hdrp + doff + 4),
                                                * (mac_hdrp + doff + 5));
            DbgPrint ("                  from %d.%d.%d.%d:%d [%02x-%02x-%02x-%02x-%02x-%02x]\n",
                                                IP_GET_SRC_ADDR (ip_hdrp, 0),
                                                IP_GET_SRC_ADDR (ip_hdrp, 1),
                                                IP_GET_SRC_ADDR (ip_hdrp, 2),
                                                IP_GET_SRC_ADDR (ip_hdrp, 3),
                                                UDP_GET_SRC_PORT (udp_hdrp),
                                                * (mac_hdrp + soff + 0),
                                                * (mac_hdrp + soff + 1),
                                                * (mac_hdrp + soff + 2),
                                                * (mac_hdrp + soff + 3),
                                                * (mac_hdrp + soff + 4),
                                                * (mac_hdrp + soff + 5));

#endif

    /* send back response */

    NdisSend (& status, ctxtp -> mac_handle, packet);

quit:

    /* note that we have to put packet back 'unoptimized' way since we are
       running at PASSIVE IRQL from RecvComplete */

    if (status != NDIS_STATUS_PENDING)
    {
        UNIV_PRINT (("Main_ctrl_recv: packet not pending\n"));
        Main_packet_put (ctxtp, packet, TRUE, status);
    }

} /* end Main_ctrl_recv */


// ###### code added for multiple nic support - ramkrish
INT Main_adapter_alloc (
    PWSTR               device_name)
{
    INT                 i;


    UNIV_PRINT (("Main_adapter_alloc: for %ls", device_name));

    NdisAcquireSpinLock (& univ_bind_lock);

    if (univ_adapters_count == CVY_MAX_ADAPTERS)
    {
        NdisReleaseSpinLock (& univ_bind_lock);
        return MAIN_ADAPTER_NOT_FOUND;
    }

    NdisReleaseSpinLock (& univ_bind_lock);

    for (i = 0 ; i < CVY_MAX_ADAPTERS; i++)
    {
        NdisAcquireSpinLock (& univ_bind_lock);
        if (univ_adapters [i] . used == FALSE)
        {
            univ_adapters [i] . used = TRUE;
            univ_adapters_count ++;
            NdisReleaseSpinLock (& univ_bind_lock);
            break;
        }
        NdisReleaseSpinLock (& univ_bind_lock);
    }

    if (i >= CVY_MAX_ADAPTERS)
        return MAIN_ADAPTER_NOT_FOUND;

    NdisAcquireSpinLock (& univ_bind_lock);

    univ_adapters [i] . bound = FALSE;
    univ_adapters [i] . inited = FALSE;
    univ_adapters [i] . announced = FALSE;

    NdisReleaseSpinLock (& univ_bind_lock);

    return i;
} /* end Main_adapter_alloc */


INT Main_adapter_get (
    PWSTR               device_name)
{
    INT i;
    NDIS_STRING         new_device_name, cur_device_name;


    if (device_name == NULL)
        return MAIN_ADAPTER_NOT_FOUND;

    NdisInitUnicodeString (& new_device_name, device_name);

    for (i = 0 ; i < CVY_MAX_ADAPTERS; i++)
    {
        if (univ_adapters [i] . used &&
            univ_adapters [i] . bound &&
            univ_adapters [i] . inited &&
            univ_adapters [i] . device_name_len)
        {
            NdisInitUnicodeString (& cur_device_name, univ_adapters [i] . device_name);
            if (NdisEqualUnicodeString (& new_device_name, & cur_device_name, TRUE))
                return i;
        }
    }

    return MAIN_ADAPTER_NOT_FOUND; /* adapter not found */
} /* end Main_adapter_get */


INT Main_adapter_put (
    PMAIN_ADAPTER       adapterp)
{
    INT adapter_id;
    INT i;


    UNIV_ASSERT (adapterp -> code == MAIN_ADAPTER_CODE);

    for (i = 0 ; i < CVY_MAX_ADAPTERS; i++)
    {
        if (adapterp == univ_adapters + i)
        {
            adapter_id = i;
            UNIV_PRINT (("Main_adapter_put: for adapter id 0x%x\n", adapter_id));
            break;
        }
    }

    if (!adapterp -> used)
        return adapter_id;

    UNIV_ASSERT (univ_adapters_count > 0);
    NdisAcquireSpinLock (& univ_bind_lock);

    univ_adapters [adapter_id] . bound           = FALSE;
    univ_adapters [adapter_id] . inited          = FALSE;
    univ_adapters [adapter_id] . announced       = FALSE;
    univ_adapters [adapter_id] . device_name_len = 0;
    univ_adapters [adapter_id] . device_name     = NULL;
    univ_adapters [adapter_id] . ctxtp           = NULL;

    univ_adapters [adapter_id] . used = FALSE;
    univ_adapters_count --;

    NdisReleaseSpinLock (& univ_bind_lock);

    return adapter_id;
} /* end Main_adapter_put*/


INT Main_adapter_selfbind (
    PWSTR               device_name)
{
    INT                 i;
    NDIS_STRING         new_device_name, cur_device_name;


    UNIV_PRINT (("Main_adapter_selfbind: %ls", device_name));
    if (device_name == NULL)
        return MAIN_ADAPTER_NOT_FOUND;

    NdisInitUnicodeString (& new_device_name, device_name);
    for (i = 0 ; i < CVY_MAX_ADAPTERS; i++)
    {
        if (univ_adapters [i] . used &&
            univ_adapters [i] . bound &&
            univ_adapters [i] . inited)
        {
            NdisInitUnicodeString (& cur_device_name, univ_adapters [i] . ctxtp -> virtual_nic_name);
            UNIV_PRINT (("Main_adapter_selfbind: comparing %ls %ls",
                         new_device_name . Buffer,
                         cur_device_name . Buffer));
            if (NdisEqualUnicodeString (&new_device_name, &cur_device_name, TRUE))
                return i;
        }
    }

    return MAIN_ADAPTER_NOT_FOUND;
} /* end Main_adapter_selfbind */

//+----------------------------------------------------------------------------
//
// Function:  Main_ApplyChangeWithoutReStart
//
// Description:  Apply setting changes without re-start.
//              ctxtp -> load_lock should be hold before calling this function
//
// Arguments: PMAIN_CTXT ctxtp -
//            CVY_PARAMS* pOldParams - the old parameters
//            const CVY_PARAMS* pCurParam - new parameters
//
// Returns:   BOOLEAN  - TRUE if the change is applied without re-start
//                       otherwise, no changes is applied
//
// History:   fengsun Created Header    9/28/00
//
//+----------------------------------------------------------------------------
BOOLEAN Main_ApplyChangeWithoutReStart(PMAIN_CTXT ctxtp,
                                       CVY_PARAMS* pOldParams, 
                                       const CVY_PARAMS* pCurParam) 
{
    CVY_RULE    OldRules[CVY_MAX_RULES - 1];
    ULONG i;

    if (pOldParams->num_rules != pCurParam->num_rules)
    {
        //
        // Different number of rules
        //
        return FALSE;
    }

    UNIV_ASSERT(sizeof(OldRules) == sizeof(pOldParams->port_rules));

    //
    // Save the old rules and copy the new rule weight over old settings
    //
    RtlCopyMemory(&OldRules, pOldParams->port_rules, sizeof(OldRules));

    for (i=0; i<pCurParam->num_rules; i++)
    {
        if (pCurParam->port_rules[i].mode == CVY_MULTI)
        {
            pOldParams->port_rules[i].mode_data.multi.equal_load = 
                                    pCurParam->port_rules[i].mode_data.multi.equal_load;

            pOldParams->port_rules[i].mode_data.multi.load = 
                                    pCurParam->port_rules[i].mode_data.multi.load;
        }
    }

    if(RtlCompareMemory(pOldParams, pCurParam, sizeof(CVY_PARAMS)) != sizeof(CVY_PARAMS))
    {
        //
        // There are other changes besides port rule weight
        //
        return FALSE;
    }



    //
    //  The only change is the weight.  Now change the weight
    //
    for (i=0; i<pCurParam->num_rules; i++)
    {
        ULONG NewWeight;

        switch (OldRules[i].mode)
        {
        case CVY_MULTI:
            if (OldRules[i].mode_data.multi.equal_load && pCurParam->port_rules[i].mode_data.multi.equal_load)
            {
                continue;  // no weight change
            }

            if (!OldRules[i].mode_data.multi.equal_load && 
                !pCurParam->port_rules[i].mode_data.multi.equal_load &&
                OldRules[i].mode_data.multi.load == pCurParam->port_rules[i].mode_data.multi.load)
            {
                continue; // no weight change
            }

            if (pCurParam->port_rules[i].mode_data.multi.equal_load)
            {
                NewWeight = CVY_EQUAL_LOAD;
            }
            else
            {
                NewWeight = pCurParam->port_rules[i].mode_data.multi.load;
            }

            //
            // Change the weight of the port.  Return code ignored
            //

            UNIV_PRINT(("RELOAD: Calling Load_port_change -> VIP=%08x, port=%d, load=%d\n", 
                        OldRules[i].virtual_ip_addr, OldRules[i].start_port, NewWeight));
                       
            Load_port_change (& ctxtp -> load,
                                 OldRules[i].virtual_ip_addr,
                                 OldRules[i].start_port,
                                 IOCTL_CVY_PORT_SET,
                                 NewWeight);

            break;

        case CVY_SINGLE:
        case CVY_NEVER:
        default:
            break;
        }
    }

    LOG_MSG(MSG_INFO_CONFIGURE_CHANGE_CONVERGING, MSG_NONE);

    return TRUE;
}

#if defined (SBH)
//+----------------------------------------------------------------------------
//
// Function:  Main_QueryPerf
//
// Description:  Query the perfomrance related state from the driver
//
// Arguments: MAIN_CTXT  ctxtp - 
//            PCVY_DRIVER_PERF  pPerf - 
//
// Returns:   NDIS_STATUS - 
//
// History:   fengsun Created Header    11/13/00
//
//+----------------------------------------------------------------------------
NDIS_STATUS Main_QueryPerf(
    PMAIN_CTXT              ctxtp,
    OUT PCVY_DRIVER_PERF          pPerf)
{
    ULONG i;
    ULONG Status;
    
    //
    // Call WlbsQuery
    //
    IOCTL_CVY_BUF QueryBuf;

    /* This IOCTL will actually ignore the VIP argument, but set it to a reasonable value anyway. */
    Status = Main_ctrl(ctxtp, IOCTL_CVY_QUERY, &QueryBuf, NULL);

    if (Status != NDIS_STATUS_SUCCESS)
    {
        return Status;
    }

    pPerf->QueryState = QueryBuf.data.query.state;
    pPerf->HostId = QueryBuf.data.query.host_id;
    pPerf->HostMap = QueryBuf.data.query.host_map;

    NdisAcquireSpinLock(&ctxtp -> load_lock);

    //
    // Ethernet header
    //
    UNIV_ASSERT(sizeof(pPerf->EthernetDstAddr) == ETHERNET_ADDRESS_FIELD_SIZE);
    UNIV_ASSERT(sizeof(pPerf->EthernetSrcAddr) == ETHERNET_ADDRESS_FIELD_SIZE);
    RtlCopyMemory (&pPerf->EthernetDstAddr, &ctxtp->media_hdr.ethernet.dst,
                    sizeof(pPerf->EthernetDstAddr));
    RtlCopyMemory (&pPerf->EthernetSrcAddr, &ctxtp->media_hdr.ethernet.src, 
                    sizeof(pPerf->EthernetSrcAddr));

    //
    // Heatbeart
    //
    pPerf->HeartbeatVersion = ctxtp->frame_dscrp->frame_hdr.version;   
    pPerf->ClusterIp = ctxtp->frame_dscrp->frame_hdr.cl_ip_addr;
    pPerf->DedicatedIp = ctxtp->frame_dscrp->frame_hdr.ded_ip_addr;
    pPerf->master_id = ctxtp->load_msgp->master_id;
    pPerf->state = ctxtp->load_msgp->state;                      
    pPerf->nrules = ctxtp->load_msgp->nrules;                     
    pPerf->UniqueCode = ctxtp->load_msgp->hcode;                      
    pPerf->pkt_count = ctxtp->load_msgp->pkt_count;                  
    pPerf->teaming = ctxtp->load_msgp->teaming;
    pPerf->reserved2 = ctxtp->load_msgp->reserved2;

    UNIV_ASSERT(sizeof(pPerf->rcode) == sizeof(ctxtp->load_msgp->rcode));
    RtlCopyMemory(pPerf->rcode, ctxtp->load_msgp->rcode, sizeof(pPerf->rcode));

    UNIV_ASSERT(sizeof(pPerf->cur_map) == sizeof(ctxtp->load_msgp->cur_map));
    RtlCopyMemory(pPerf->cur_map, ctxtp->load_msgp->cur_map, sizeof(pPerf->cur_map));

    UNIV_ASSERT(sizeof(pPerf->new_map) == sizeof(ctxtp->load_msgp->new_map));
    RtlCopyMemory(pPerf->new_map, ctxtp->load_msgp->new_map, sizeof(pPerf->new_map));

    UNIV_ASSERT(sizeof(pPerf->idle_map) == sizeof(ctxtp->load_msgp->idle_map));
    RtlCopyMemory(pPerf->idle_map, ctxtp->load_msgp->idle_map, sizeof(pPerf->idle_map));

    UNIV_ASSERT(sizeof(pPerf->rdy_bins) == sizeof(ctxtp->load_msgp->rdy_bins));
    RtlCopyMemory(pPerf->rdy_bins, ctxtp->load_msgp->rdy_bins, sizeof(pPerf->rdy_bins));

    UNIV_ASSERT(sizeof(pPerf->load_amt) == sizeof(ctxtp->load_msgp->load_amt));
    RtlCopyMemory(pPerf->load_amt, ctxtp->load_msgp->load_amt, sizeof(pPerf->load_amt));

    UNIV_ASSERT(sizeof(pPerf->pg_rsvd1) == sizeof(ctxtp->load_msgp->pg_rsvd1));
    RtlCopyMemory(pPerf->pg_rsvd1, ctxtp->load_msgp->pg_rsvd1, sizeof(pPerf->pg_rsvd1));
    
    //
    // Load module
    //
    pPerf->Convergence = 0;
    pPerf->nDescAllocated = ctxtp->load.nqalloc * ctxtp->load.dscr_per_alloc+
        CVY_MAX_CHASH+CVY_INIT_QCONN;
    pPerf->nDescInUse = ctxtp->load.nconn;
    pPerf->PacketCount = ctxtp->load.pkt_count;
    pPerf->DirtyClientWaiting = ctxtp->load.cln_waiting;

    UNIV_ASSERT(sizeof(pPerf->CurrentMap[i]) == 
            sizeof(ctxtp->load.pg_state[0].cur_map));
            
    for (i=0; i<ctxtp->load_msgp->nrules; i++)
    {
        pPerf->AllIdleMap[i] = ctxtp->load.pg_state[i].all_idle_map;
        RtlCopyMemory(pPerf->CurrentMap[i], ctxtp->load.pg_state[i].cur_map,
            sizeof(pPerf->CurrentMap[i]));
    }

    NdisReleaseSpinLock (&ctxtp -> load_lock);   

    return NDIS_STATUS_SUCCESS;
}
#endif /* SBH */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\driver\nic.h ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    nic.h

Abstract:

    Windows Load Balancing Service (WLBS)
    Driver - upper-level (NIC) layer of intermediate miniport

Author:

    kyrilf

--*/


#ifndef _Nic_h_
#define _Nic_h_

#include <ndis.h>

#include "main.h"


/* PROCEDURES */


/* miniport handlers */

extern NDIS_STATUS Nic_init (
    PNDIS_STATUS        open_status,
    PUINT               medium_index,
    PNDIS_MEDIUM        medium_array,
    UINT                medium_size,
    NDIS_HANDLE         adapter_handle,
    NDIS_HANDLE         wrapper_handle);
/*
  Responds to protocol open request

  returns NDIS_STATUS:

  function:
*/


extern VOID Nic_halt (
    NDIS_HANDLE         adapter_handle);
/*
  Responds to protocol halt request

  returns VOID:

  function:
*/


extern NDIS_STATUS Nic_info_query (
    NDIS_HANDLE         adapter_handle,
    NDIS_OID            Oid,
    PVOID               info_buf,
    ULONG               info_len,
    PULONG              written,
    PULONG              needed);
/*
  Responds to protocol OID query request

  returns NDIS_STATUS:

  function:
*/


extern NDIS_STATUS Nic_info_set (
    NDIS_HANDLE         adapter_handle,
    NDIS_OID            oid,
    PVOID               info_buf,
    ULONG               info_len,
    PULONG              read,
    PULONG              needed);
/*
  Responds to protocol OID set request

  returns NDIS_STATUS:

  function:
*/


extern NDIS_STATUS Nic_reset (
    PBOOLEAN            addr_reset,
    NDIS_HANDLE         adapter_handle);
/*
  Responds to protocol reset request

  returns NDIS_STATUS:

  function:
*/


extern VOID Nic_packets_send (
    NDIS_HANDLE         adapter_handle,
    PNDIS_PACKET *      packets,
    UINT                num_packets);
/*
  Responds to protocol send packets request

  returns VOID:

  function:
*/


extern VOID Nic_return (
    NDIS_HANDLE         adapter_handle,
    PNDIS_PACKET        packet);
/*
  Responds to protocol return packet request

  returns NDIS_STATUS:

  function:
*/


/* These 3 functions have been added for NDIS51 support. */

extern VOID Nic_cancel_send_packets (
    NDIS_HANDLE         adapter_handle,
    PVOID               cancel_id);
/*
  Responds to CancelSendPackets request

  returns None:

  function:
*/

#if 0
extern VOID Nic_pnpevent_notify (
    NDIS_HANDLE              adapter_handle,
    NDIS_DEVICE_PNP_EVENT    pnp_event,
    PVOID                    info_buf,
    ULONG                    info_len);

/*
  Responds to PnPEventNotify request

  returns None:

  function:
*/
#endif

extern VOID Nic_adapter_shutdown (
    NDIS_HANDLE         adapter_handle);
/*
  Responds to AdapterShutdown request

  returns None:

  function:
*/


/* helpers for protocol layer */

extern NDIS_STATUS Nic_announce (
    PMAIN_CTXT          ctxtp);
/*
  Announces us to the protocol layer during binding to the lower adapter

  returns NDIS_STATUS:

  function:
*/


extern NDIS_STATUS Nic_unannounce (
    PMAIN_CTXT          ctxtp);
/*
  Unannounces us from the protocol layer during unbinding from the lower adapter

  returns NDIS_STATUS:

  function:
*/

#if 0
extern ULONG   Nic_sync_queue (
    PMAIN_CTXT          ctxtp,
    UNIV_SYNC_CALLB     callb,
    PVOID               callb_ctxtp,
    ULONG               queue);

/*
  Perform synchronization by switching to miniport mode or queueing callback

  returns ULONG  :
    TRUE  => succeeded
    FALSE => failed

  function:
*/

#endif
extern VOID Nic_timer (
    PVOID                   dpc,
    PVOID                   ctxtp,
    PVOID                   arg1,
    PVOID                   arg2);
/*
  Heartbeat timer handler

  returns VOID:

  function:
*/


extern VOID Nic_sleep (
    ULONG                   msecs);
/*
  Sleep helper

  returns VOID:

  function:
*/



/* routines that can be used with Nic_sync */

extern VOID Nic_reset_complete (
    PMAIN_CTXT          ctxtp,
    NDIS_STATUS         status);
/*
  Propagate reset completion to protocol

  returns VOID:

  function:
*/


extern VOID Nic_request_complete (
    NDIS_HANDLE         handle,
    PVOID               actp);
/*
  Propagate request completion to protocol

  returns VOID:

  function:
*/


extern VOID Nic_send_complete (
    PMAIN_CTXT          ctxtp,
    NDIS_STATUS         status,
    PNDIS_PACKET        packet);
/*
  Propagate packet send completion to protocol

  returns VOID:

  function:
*/


extern VOID Nic_recv_complete (
    PMAIN_CTXT          ctxtp);
/*
  Propagate post-receive completion to protocol

  returns VOID:

  function:
*/


extern NDIS_STATUS Nic_PNP_handle (
    PMAIN_CTXT          ctxtp,
    PNET_PNP_EVENT      pnp_event);
/*
  Propagate PNP Events to protocol
  
  returns NDIS_STATUS:

  function:
*/


extern VOID Nic_status (
    PMAIN_CTXT          ctxtp,
    NDIS_STATUS         status,
    PVOID               buf,
    UINT                len);
/*
  Propagate status indication to protocol

  returns VOID:

  function:
*/


extern VOID Nic_status_complete (
    PMAIN_CTXT          ctxtp);
/*
  Propagate status indication completion to protocol

  returns VOID:

  function:
*/


extern VOID Nic_send_resources_signal (
    PMAIN_CTXT          ctxtp);
/*
  Send resource availability message to protocol

  returns VOID:

  function:
*/


extern VOID Nic_recv_packet (
    PMAIN_CTXT          ctxtp,
    PNDIS_PACKET        packet);
/*
  Propagate received packet to protocol

  returns VOID:

  function:
*/

/* Added from old code for NT 5.1 - ramkrish */
extern VOID Nic_recv_indicate (
    PMAIN_CTXT          ctxtp,
    NDIS_HANDLE         recv_handle,
    PVOID               head_buf,
    UINT                head_len,
    PVOID               look_buf,
    UINT                look_len,
    UINT                packet_len);
/*
  Propagates receive indication to protocol

  returns VOID:

  function:
*/


extern NDIS_STATUS Nic_transfer (
    PNDIS_PACKET        packet,
    PUINT               xferred,
    NDIS_HANDLE         adapter_handle,
    NDIS_HANDLE         receive_handle,
    UINT                offset,
    UINT                len);
/*
  Responds to protocol data transfer request

  returns NDIS_STATUS:

  function:
*/



extern VOID Nic_transfer_complete (
    PMAIN_CTXT          ctxtp,
    NDIS_STATUS         status,
    PNDIS_PACKET        packet,
    UINT                xferred);

/*
  Propagates data transfer completion to protocol

  returns VOID:

  function:
*/


/* old code */

#if 0
extern NDIS_STATUS Nic_send (
    NDIS_HANDLE         adapter_handle,
    PNDIS_PACKET        packet,
    UINT                flags);
/*
  Responds to protocol packet send request

  returns NDIS_STATUS:

  function:
*/

#endif

#endif /* _Nic_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\driver\tcpip.c ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    tcpip.c

Abstract:

    Windows Load Balancing Service (WLBS)
    Driver - IP/TCP/UDP support

Author:

    kyrilf

--*/

#include <ndis.h>

#include "wlbsip.h"
#include "univ.h"
#include "wlbsparm.h"
#include "params.h"
#include "log.h"


/* GLOBALS */


static ULONG log_module_id = LOG_MODULE_TCPIP;

/* constant encoded shadow computer name that will replace our cluster name */

static UCHAR nbt_encoded_shadow_name [NBT_ENCODED_NAME_LEN] =
                                                        NBT_ENCODED_NAME_SHADOW;


/* PROCEDURES */


BOOLEAN Tcpip_init (
    PTCPIP_CTXT         ctxtp,
    PVOID               parameters)
{
    ULONG               i, j;
    PCVY_PARAMS         params = (PCVY_PARAMS) parameters;


    /* extract cluster computer name from full internet name */

    j = 0;

    while (params -> domain_name [j] != 0)
    {
        if (params -> domain_name [j] == L'.' ||
            params -> domain_name [j] == 0)
            break;

        j ++;
    }

    /* build encoded cluster computer name for checking against arriving NBT
       session requests */

    for (i = 0; i < NBT_NAME_LEN; i ++)
    {
        if (i >= j)
        {
            ctxtp -> nbt_encoded_cluster_name [2 * i]     =
                     NBT_ENCODE_FIRST (' ');
            ctxtp -> nbt_encoded_cluster_name [2 * i + 1] =
                     NBT_ENCODE_SECOND (' ');
        }
        else
        {
            ctxtp -> nbt_encoded_cluster_name [2 * i]     =
                     NBT_ENCODE_FIRST (toupper ((UCHAR) (params -> domain_name [i])));
            ctxtp -> nbt_encoded_cluster_name [2 * i + 1] =
                     NBT_ENCODE_SECOND (toupper ((UCHAR) (params -> domain_name [i])));
        }
    }

    return TRUE;

} /* Tcpip_init */


VOID Tcpip_nbt_handle (
    PTCPIP_CTXT             ctxtp,
    PIP_HDR                 ip_hdrp,
    PTCP_HDR                tcp_hdrp,
    ULONG                   len,
    PNBT_HDR                nbt_hdrp)
{
    PUCHAR                  called_name;
    ULONG                   i;


    /* if this is an NBT session request packet, check to see if it's calling
       the cluster machine name, which should be replaced with the shadow name */

    if (len >= sizeof (NBT_HDR) &&
        NBT_GET_PKT_TYPE (nbt_hdrp) == NBT_SESSION_REQUEST)
    {
        /* pass the field length byte - assume all names are
           NBT_ENCODED_NAME_LEN bytes long */

        called_name = NBT_GET_CALLED_NAME (nbt_hdrp) + 1;

        /* match called name to cluster name */

        for (i = 0; i < NBT_ENCODED_NAME_LEN; i ++)
        {
            if (called_name [i] != ctxtp -> nbt_encoded_cluster_name [i])
                break;
        }

        /* replace cluster computer name with the shadom name */

        if (i >= NBT_ENCODED_NAME_LEN)
        {
            USHORT      checksum;


            for (i = 0; i < NBT_ENCODED_NAME_LEN; i ++)
                called_name [i] = nbt_encoded_shadow_name [i];

            /* re-compute checksum */

            checksum = Tcpip_chksum (ctxtp, ip_hdrp, (PUCHAR) tcp_hdrp,
                                     TCPIP_PROTOCOL_TCP);
            TCP_SET_CHKSUM (tcp_hdrp, checksum);
        }
    }

} /* end Tcpip_nbt_handle */


USHORT Tcpip_chksum (
    PTCPIP_CTXT         ctxtp,
    PIP_HDR             ip_hdrp,
    PUCHAR              prot_hdrp,
    ULONG               prot)
{
    ULONG               checksum = 0, i, len;
    PUCHAR              ptr;
    USHORT              original, tmp;


    /* preserve original checksum */

    if (prot == TCPIP_PROTOCOL_TCP)
    {
        original = TCP_GET_CHKSUM ((PTCP_HDR) prot_hdrp);
        TCP_SET_CHKSUM ((PTCP_HDR) prot_hdrp, 0);
    }
    else if (prot == TCPIP_PROTOCOL_UDP)
    {
        original = UDP_GET_CHKSUM ((PUDP_HDR) prot_hdrp);
        UDP_SET_CHKSUM ((PUDP_HDR) prot_hdrp, 0);
    }
    else
    {
        original = IP_GET_CHKSUM (ip_hdrp);
        IP_SET_CHKSUM (ip_hdrp, 0);
    }

    /* computer appropriate checksum for specified protocol */

    if (prot != TCPIP_PROTOCOL_IP)
    {
        /* checksum in computed over the source IP address, destination IP address,
           protocol (6 for TCP), TCP segment length value and entire TCP segment
           (setting checksum field within TCP header to 0). code is taken from
           page 185 of "Internetworking with TCP/IP: Volume II" by
           Comer/Stevens, 1991 */

        ptr = (PUCHAR) IP_GET_SRC_ADDR_PTR (ip_hdrp);

        /* 2*IP_ADDR_LEN bytes = IP_ADDR_LEN shorts */

        for (i = 0; i < IP_ADDR_LEN; i ++, ptr += 2)
            checksum += (ULONG) ((ptr [0] << 8) | ptr [1]);
    }

    if (prot == TCPIP_PROTOCOL_TCP)
    {
        len = IP_GET_PLEN (ip_hdrp) - IP_GET_HLEN (ip_hdrp) * sizeof (ULONG);
        checksum += TCPIP_PROTOCOL_TCP + len;
        ptr = prot_hdrp;
    }
    else if (prot == TCPIP_PROTOCOL_UDP)
    {
        len = IP_GET_PLEN (ip_hdrp) - IP_GET_HLEN (ip_hdrp) * sizeof (ULONG);
        checksum += TCPIP_PROTOCOL_UDP + UDP_GET_LEN ((PUDP_HDR) prot_hdrp);
        ptr = prot_hdrp;
    }
    else
    {
        len = IP_GET_HLEN (ip_hdrp) * sizeof (ULONG);
        ptr = (PUCHAR) ip_hdrp;
        prot_hdrp = (PUCHAR) ip_hdrp;
    }

    for (i = 0; i < len / 2; i ++, ptr += 2)
        checksum += (ULONG) ((ptr [0] << 8) | ptr [1]);

    if (len % 2)
        checksum += (ULONG) (prot_hdrp [len - 1] << 8);

    checksum = (checksum >> 16) + (checksum & 0xffff);
    checksum += (checksum >> 16);

    /* restore original checksum */

    if (prot == TCPIP_PROTOCOL_TCP)
    {
        TCP_SET_CHKSUM ((PTCP_HDR) prot_hdrp, original);
    }
    else if (prot == TCPIP_PROTOCOL_UDP)
    {
        UDP_SET_CHKSUM ((PUDP_HDR) prot_hdrp, original);
    }
    else
    {
        IP_SET_CHKSUM (ip_hdrp, original);
    }

    return (USHORT) (~checksum & 0xffff);

} /* end Tcpip_chksum */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\driver\trace.h ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    trace.h

Abstract:

    Windows Load Balancing Service (WLBS)
    Driver - Support for Windows Event Tracing

    Since currently NDIS and WPP event tracing don't mix well, WPP event
    tracing is accessed through a separate C file, trace.c, which doesn't
    include ndis.h.

    To keep the low foot print of Event Tracing, the following specialized
    macros should be used for tracing, as well as specialized tracing
    routines written for each thing traced.

Author:

    josephj

--*/


#ifndef _trace_h_
#define _trace_h_

VOID
Trace_Initialize(
    PVOID                         driver_obj,
    PVOID                         registry_path
    );

VOID
Trace_Deinitialize(VOID);

#endif // _trace_h_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\driver\prot.c ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    prot.c

Abstract:

    Windows Load Balancing Service (WLBS)
    Driver - lower-level (protocol) layer of intermediate miniport

Author:

    kyrilf

--*/

#define NDIS50                  1
#define NDIS51                  1

#include <ndis.h>

#include "prot.h"
#include "nic.h"
#include "main.h"
#include "util.h"
#include "univ.h"
#include "log.h"


/* GLOBALS */

NTHALAPI KIRQL KeGetCurrentIrql();

static ULONG log_module_id = LOG_MODULE_PROT;


/* PROCEDURES */


VOID Prot_bind (        /* PASSIVE_IRQL */
    PNDIS_STATUS        statusp,
    NDIS_HANDLE         bind_handle,
    PNDIS_STRING        device_name,
    PVOID               reg_path,
    PVOID               reserved)
{
    NDIS_STATUS         status;
    NDIS_STATUS         error_status;
    PMAIN_CTXT          ctxtp;
    ULONG               ret;
    UINT                medium_index;
    ULONG               i;
    ULONG               peek_size;
    ULONG               tmp;
    ULONG               xferred;
    ULONG               needed;
    ULONG               result;
    PNDIS_REQUEST       request;
    MAIN_ACTION         act;
    INT                 adapter_index; // ###### ramkrish for multiple nic support
    PMAIN_ADAPTER       adapterp = NULL;

    /* WLBS 2.3 */

    NDIS_HANDLE         ctxt_handle;
    NDIS_HANDLE         config_handle;
    PNDIS_CONFIGURATION_PARAMETER   param;
    NDIS_STRING         device_str = NDIS_STRING_CONST ("UpperBindings");

//DbgBreakPoint();
    /* make sure we are not attempting to bind to ourselves */

    UNIV_PRINT (("Prot_bind: binding to %ls", device_name -> Buffer));

//#if 0
    adapter_index = Main_adapter_get (device_name -> Buffer);
    if (adapter_index != MAIN_ADAPTER_NOT_FOUND)
    {
        UNIV_PRINT (("Already bound to this device 0x%x", adapter_index));
        *statusp = NDIS_STATUS_FAILURE;
        return;
    }

    adapter_index = Main_adapter_selfbind (device_name -> Buffer);
    if (adapter_index != MAIN_ADAPTER_NOT_FOUND)
    {
        UNIV_PRINT (("Attempting to bind to ourselves 0x%x", adapter_index));
        *statusp = NDIS_STATUS_FAILURE;
        return;
    }

    adapter_index = Main_adapter_alloc (device_name -> Buffer);
    if (adapter_index == MAIN_ADAPTER_NOT_FOUND)
    {
        UNIV_PRINT (("Unable to allocate ctxt for adapter 0x%x", univ_adapters_count));
        *statusp = NDIS_STATUS_FAILURE;
        return;
    }
//#endif

//    adapter_index = 0;


    adapterp = &(univ_adapters [adapter_index]);
//    adapterp -> used = TRUE;
    UNIV_ASSERT (adapterp -> code == MAIN_ADAPTER_CODE);

    NdisAcquireSpinLock(& univ_bind_lock);
    adapterp -> bound = TRUE;
    NdisReleaseSpinLock(& univ_bind_lock);

    UNIV_PRINT (("Prot_bind: devicename: length %d max length %d",
                 device_name -> Length, device_name -> MaximumLength));
    /* copy the device name to be used for future reference */
//#if 0
    tmp = device_name -> MaximumLength * sizeof (WCHAR);
    status = NdisAllocateMemoryWithTag (& (adapterp -> device_name),
                                        device_name -> MaximumLength,
                                        UNIV_POOL_TAG);

    if (status != NDIS_STATUS_SUCCESS)
    {
        NdisAcquireSpinLock(& univ_bind_lock);
        adapterp -> bound = FALSE;
        NdisReleaseSpinLock(& univ_bind_lock);

        Main_adapter_put (adapterp);
        UNIV_PRINT (("error allocating memory %d %x", tmp, status));
        __LOG_MSG2 (MSG_ERROR_MEMORY, MSG_NONE, tmp, status);
        * statusp = status;
        return;
    }

    NdisMoveMemory (adapterp -> device_name,
                    device_name -> Buffer,
                    device_name -> Length);
    adapterp -> device_name_len = device_name -> MaximumLength;
    adapterp -> device_name [(device_name -> Length)/sizeof (WCHAR)] = UNICODE_NULL;
//#endif
    /* if we failed to deallocate the context during unbind (both halt and unbind
       were not called for example) - do it now before allocating a new context */

    /* SBH - I think the comment below is bogus... Let's find out. */
    ASSERT (adapterp->ctxtp == NULL);

#if 0 // This code has been commented out since inited is guaranteed to be reset at this point
    if (adapterp -> inited && adapterp -> ctxtp != NULL)
    {
        adapterp -> inited = FALSE;
        NdisReleaseSpinLock(& univ_bind_lock);

        Main_cleanup (adapterp -> ctxtp);
        NdisFreeMemory (adapterp -> ctxtp, sizeof (MAIN_CTXT), 0);
        adapterp -> ctxtp = NULL;

        if (adapterp -> device_name_len)
        {
            NdisFreeMemory (adapterp -> device_name, adapterp -> device_name_len, 0);
            adapterp -> device_name     = NULL;
            adapterp -> device_name_len = 0;
        }
    }
    else
        NdisReleaseSpinLock(& univ_bind_lock);
#endif
    /* allocate device context */

    status = NdisAllocateMemoryWithTag (& (adapterp -> ctxtp), sizeof (MAIN_CTXT),
                                        UNIV_POOL_TAG);

    if (status != NDIS_STATUS_SUCCESS)
    {
        UNIV_PRINT (("error allocating memory %d %x", sizeof (MAIN_CTXT), status));
        __LOG_MSG2 (MSG_ERROR_MEMORY, MSG_NONE, sizeof (MAIN_CTXT), status);
	__LOG_MSG (MSG_ERROR_BIND_FAIL, adapterp -> device_name);
        * statusp = status;

        if (adapterp -> device_name_len)
        {
            NdisFreeMemory (adapterp -> device_name, adapterp -> device_name_len, 0);
            adapterp -> device_name     = NULL;
            adapterp -> device_name_len = 0;
        }

        NdisAcquireSpinLock(& univ_bind_lock);
        adapterp -> bound = FALSE;
        NdisReleaseSpinLock(& univ_bind_lock);

        Main_adapter_put (adapterp);
        return;
    }

    /* initialize context */
    ctxtp = adapterp -> ctxtp;

    NdisZeroMemory (ctxtp, sizeof (MAIN_CTXT));

    NdisAcquireSpinLock (& univ_bind_lock);

    ctxtp -> code = MAIN_CTXT_CODE;
    ctxtp -> bind_handle = bind_handle;
    ctxtp -> adapter_id = adapter_index;

    NdisReleaseSpinLock (& univ_bind_lock);

    NdisInitializeEvent (& ctxtp -> completion_event);

    NdisResetEvent (& ctxtp -> completion_event);

    /* bind to specified adapter */

    ctxt_handle = (NDIS_HANDLE) ctxtp;
    NdisOpenAdapter (& status, & error_status, & ctxtp -> mac_handle,
                     & medium_index, univ_medium_array, UNIV_NUM_MEDIUMS,
                     univ_prot_handle, ctxtp, device_name, 0, NULL);


    /* if pending - wait for Prot_open_complete to set the completion event */

    if (status == NDIS_STATUS_PENDING)
    {
        ret = NdisWaitEvent (& ctxtp -> completion_event, UNIV_WAIT_TIME);

        if (! ret)
        {
            UNIV_PRINT (("error waiting for event"));
            __LOG_MSG1 (MSG_ERROR_INTERNAL, MSG_NONE, status);
            * statusp = status;

            NdisFreeMemory (ctxtp, sizeof (MAIN_CTXT), 0);
            if (adapterp -> device_name_len)
            {
                NdisFreeMemory (adapterp -> device_name, adapterp -> device_name_len, 0);
                adapterp -> device_name     = NULL;
                adapterp -> device_name_len = 0;
            }

            NdisAcquireSpinLock(& univ_bind_lock);
            adapterp -> bound = FALSE;
            NdisReleaseSpinLock(& univ_bind_lock);
            Main_adapter_put (adapterp);
            return;
        }

        status = ctxtp -> completion_status;
    }

    /* check binding status */

    if (status != NDIS_STATUS_SUCCESS)
    {
        UNIV_PRINT (("error openning adapter %x", status));
        __LOG_MSG1 (MSG_ERROR_OPEN, device_name -> Buffer, status);

        /* If the failure was because the medium was not supported, log this. */
        if (status == NDIS_STATUS_UNSUPPORTED_MEDIA) {
            UNIV_PRINT (("unsupported medium"));
            __LOG_MSG (MSG_ERROR_MEDIA, MSG_NONE);
        }

        * statusp = status;

        NdisFreeMemory (ctxtp, sizeof (MAIN_CTXT), 0);

        if (adapterp -> device_name_len)
        {
            NdisFreeMemory (adapterp -> device_name, adapterp -> device_name_len, 0);
            adapterp -> device_name     = NULL;
            adapterp -> device_name_len = 0;
        }

        NdisAcquireSpinLock(& univ_bind_lock);
        adapterp -> bound = FALSE;
        NdisReleaseSpinLock(& univ_bind_lock);

        Main_adapter_put (adapterp);
        return;
    }

    ctxtp -> medium    = univ_medium_array [medium_index];

    /* V1.3.1b make sure that underlying adapter is of the supported medium */

    if (ctxtp -> medium != NdisMedium802_3)
    {
        /* This should never happen because this error should be caught earlier
           by NdisOpenAdapter, but we'll put another check here just in case. */
        UNIV_PRINT (("unsupported medium %d", ctxtp -> medium));
        __LOG_MSG1 (MSG_ERROR_MEDIA, MSG_NONE, ctxtp -> medium);
        goto error;
    }

    /* Copy "WLBS Cluster " into the log string.  We'll add the cluster IP address later.  This
       is because in some failure paths, we try to print this out in an event log, but its empty,
       so the event log looks incomplete.  True, it will not necessarily have the cluster IP 
       address, but it will have something. */
    wcscpy(ctxtp->log_msg_str, CVY_NAME_MULTI_NIC);

    /* V1.3.0b extract current MAC address from the NIC - note that main is not
       inited yet so we have to create a local action */

    act . code  = MAIN_ACTION_CODE;
    act . ctxtp = ctxtp;
    request = & act . op . request . req;
    act . op . request . xferred = & xferred;
    act . op . request . needed  = & needed;

    request -> RequestType = NdisRequestQueryInformation;

    if (ctxtp -> medium == NdisMedium802_3)
        request -> DATA . QUERY_INFORMATION . Oid = OID_802_3_CURRENT_ADDRESS;

    request -> DATA . QUERY_INFORMATION . InformationBuffer       = & ctxtp -> ded_mac_addr;
    request -> DATA . QUERY_INFORMATION . InformationBufferLength = sizeof (CVY_MAC_ADR);

    status = Prot_request (ctxtp, & act, FALSE);

    if (status != NDIS_STATUS_SUCCESS)
    {
        UNIV_PRINT (("error %x requesting station address %d %d", status, xferred, needed));
        goto error;
    }

    /* V1.3.1b get MAC options */

    request -> RequestType = NdisRequestQueryInformation;

    request -> DATA . QUERY_INFORMATION . Oid = OID_GEN_MAC_OPTIONS;

    request -> DATA . QUERY_INFORMATION . InformationBuffer       = & result;
    request -> DATA . QUERY_INFORMATION . InformationBufferLength = sizeof (ULONG);

    status = Prot_request (ctxtp, & act, FALSE);

    if (status != NDIS_STATUS_SUCCESS)
    {
        UNIV_PRINT (("error %x requesting MAC options %d %d", status, xferred, needed));
        goto error;
    }
    
    UNIV_PRINT(("Prot_request query  mac options completed"));
    ctxtp -> mac_options = result;

    /* Make sure the 802.3 adapter supports dynamically changing the MAC address of the NIC. */
    if (!(ctxtp -> mac_options & NDIS_MAC_OPTION_SUPPORTS_MAC_ADDRESS_OVERWRITE)) {
        UNIV_PRINT (("unsupported network adapter MAC options %x", ctxtp -> mac_options));
        __LOG_MSG (MSG_ERROR_DYNAMIC_MAC, MSG_NONE);
        goto error;
    }

    status = Params_init (ctxtp, univ_reg_path, adapterp -> device_name + 8, & (ctxtp -> params));

    /* Now, cat the cluster IP address onto the log message string to complete it. */
    wcscat(ctxtp->log_msg_str, ctxtp->params.cl_ip_addr);

    if (status != NDIS_STATUS_SUCCESS)
    {
        UNIV_PRINT (("error retrieving registry parameters %x", status));
        ctxtp -> convoy_enabled = ctxtp -> params_valid = FALSE;
    }
    else
    {
        ctxtp -> convoy_enabled = ctxtp -> params_valid = TRUE;
    }

    /* V1.3.2b check if media is connected. some cards do not register
       disconnection - so use this as a hint. */

    request -> RequestType = NdisRequestQueryInformation;

    request -> DATA . QUERY_INFORMATION . Oid = OID_GEN_MEDIA_CONNECT_STATUS;

    request -> DATA . QUERY_INFORMATION . InformationBuffer       = & result;
    request -> DATA . QUERY_INFORMATION . InformationBufferLength = sizeof (ULONG);

    status = Prot_request (ctxtp, & act, FALSE);

    if (status != NDIS_STATUS_SUCCESS)
    {
        UNIV_PRINT (("error %x requesting media connection status %d %d", status, xferred, needed));
        ctxtp -> media_connected = TRUE;
    }
    else
    {
        ctxtp -> media_connected = (result == NdisMediaStateConnected);
        UNIV_PRINT (("Media state - %s", result == NdisMediaStateConnected ? "CONNECTED" : "DISCONNECTED"));
        UNIV_PRINT(("Prot_request query media connect status completed"));
    }

    /* V1.3.2b figure out MTU of the medium */

    request -> RequestType = NdisRequestQueryInformation;

    request -> DATA . QUERY_INFORMATION . Oid = OID_GEN_MAXIMUM_TOTAL_SIZE;

    request -> DATA . QUERY_INFORMATION . InformationBuffer       = & result;
    request -> DATA . QUERY_INFORMATION . InformationBufferLength = sizeof (ULONG);

    status = Prot_request (ctxtp, & act, FALSE);

    if (status != NDIS_STATUS_SUCCESS)
    {
        UNIV_PRINT (("error %x requesting max frame size %d %d", status, xferred, needed));
        ctxtp -> max_frame_size = CVY_MAX_FRAME_SIZE;
    }
    else
    {
        ctxtp -> max_frame_size = result;
        UNIV_PRINT(("Prot_request query oid gen max size completed"));
    }

    /* figure out maximum multicast list size */

    request -> RequestType = NdisRequestQueryInformation;

    if (ctxtp -> medium == NdisMedium802_3)
        request -> DATA . QUERY_INFORMATION . Oid = OID_802_3_MAXIMUM_LIST_SIZE;

    request -> DATA . QUERY_INFORMATION . InformationBufferLength = sizeof (ULONG);
    request -> DATA . QUERY_INFORMATION . InformationBuffer = & ctxtp->max_mcast_list_size;

    status = Prot_request (ctxtp, & act, FALSE);

    if (status != NDIS_STATUS_SUCCESS)
    {
        UNIV_PRINT (("error %x setting multicast address %d %d", status, xferred, needed));
        goto error;
    }
    UNIV_PRINT(("Prot_request query oid gen max list size completed"));

    /* initialize main context now */

    status = Main_init (ctxtp);

    if (status != NDIS_STATUS_SUCCESS)
    {
        UNIV_PRINT (("error initializing main module %x", status));
        goto error;
    }

    NdisAcquireSpinLock(& univ_bind_lock);
    adapterp -> inited = TRUE;
    NdisReleaseSpinLock(& univ_bind_lock);

    /* WLBS 2.3 start off by opening the config section and reading our instance
       which we want to export for this binding */

    NdisOpenProtocolConfiguration (& status, & config_handle, reg_path);

    if (status != NDIS_STATUS_SUCCESS)
    {
        UNIV_PRINT (("error openning protocol configuration %x", status));
        goto error;
    }

    NdisReadConfiguration (& status, & param, config_handle, & device_str,
                           NdisParameterString);

    if (status != NDIS_STATUS_SUCCESS)
    {
        UNIV_PRINT (("error reading binding configuration %x", status));
        goto error;
    }

    /* free up whatever params allocated and get a new string to fit the
       device name */

    if (param -> ParameterData . StringData . Length >=
        sizeof (ctxtp -> virtual_nic_name) - sizeof (WCHAR))
    {
        UNIV_PRINT (("nic name string too big %d %d\n", param -> ParameterData . StringData . Length, sizeof (ctxtp -> virtual_nic_name) - sizeof (WCHAR)));
    }

    NdisMoveMemory (ctxtp -> virtual_nic_name,
                    param -> ParameterData . StringData . Buffer,
                    param -> ParameterData . StringData . Length <
                    sizeof (ctxtp -> virtual_nic_name) - sizeof (WCHAR) ?
                    param -> ParameterData . StringData . Length :
                    sizeof (ctxtp -> virtual_nic_name) - sizeof (WCHAR));

    * (PWSTR) ((PCHAR) ctxtp -> virtual_nic_name +
               param -> ParameterData . StringData . Length) = L'\0' ;

    UNIV_PRINT (("read binding name %ls\n", ctxtp -> virtual_nic_name));

#if 0
    {
        WCHAR    reg_path [512];


        wcscpy (reg_path, univ_reg_path);
        wcscat (reg_path, adapterp -> device_name + 8);

        UNIV_PRINT (("Prot_bind: write binding name to %ls", reg_path));
        status = RtlWriteRegistryValue (RTL_REGISTRY_SERVICES, reg_path,
                                        CVY_NAME_VIRTUAL_NIC, REG_SZ,
                                        ctxtp -> params . virtual_nic_name,
                                        param -> ParameterData . StringData . Length + 2);

        if (status != STATUS_SUCCESS)
        {
            UNIV_PRINT (("error writing virtual NIC name %x", status));
        }
    }
#endif

    /* we should be all inited at this point! during announcement, Nic_init
       will be called and it will start ping timer */

    /* announce ourselves to the protocol above */
    UNIV_PRINT(("calling nic_announce"));
    status = Nic_announce (ctxtp);

    if (status != NDIS_STATUS_SUCCESS)
    {
        UNIV_PRINT (("error announcing driver %x", status));
        goto error;
    }

    UNIV_PRINT (("Prot_bind: bound to %ls with %x", device_name -> Buffer, ctxtp -> mac_handle));

    /* at this point TCP/IP should have bound to us after we announced ourselves
       to it and we are all done binding to NDIS below - all set! */

    if (! ctxtp -> convoy_enabled)
        LOG_MSG (MSG_ERROR_DISABLED, MSG_NONE);
    else
    {
        ctxtp -> convoy_enabled = ctxtp -> params . cluster_mode;

        if (ctxtp -> convoy_enabled)
        {
            WCHAR                   num [20];

            Univ_ulong_to_str (ctxtp -> params . host_priority, num, 10);
            LOG_MSG (MSG_INFO_STARTED, num);
        }
        else
            LOG_MSG (MSG_INFO_STOPPED, MSG_NONE);
    }

    UNIV_PRINT (("Prot_bind: returning 0x%x", status));
    * statusp = status;
    return;

error:

    * statusp = status;

    Prot_unbind (& status, ctxtp, ctxtp);

    return;

} /* end Prot_bind */


VOID Prot_unbind (      /* PASSIVE_IRQL */
    PNDIS_STATUS        statusp,
    NDIS_HANDLE         adapter_handle,
    NDIS_HANDLE         unbind_handle)
{
    PMAIN_CTXT          ctxtp = (PMAIN_CTXT) adapter_handle;
    NDIS_STATUS         status = NDIS_STATUS_SUCCESS;
    PMAIN_ACTION        actp;
    PMAIN_ADAPTER       adapterp;
    INT                 adapter_index;


    UNIV_PRINT (("Prot_unbind: called %x", ctxtp));
    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    adapter_index = ctxtp -> adapter_id;

    adapterp = & (univ_adapters [adapter_index]);
    UNIV_ASSERT (adapterp -> code = MAIN_ADAPTER_CODE);
    UNIV_ASSERT (adapterp -> ctxtp == ctxtp);

    ctxtp -> unbind_handle = unbind_handle;

    if (ctxtp->out_request != NULL)
    {
        actp = ctxtp->out_request;
        ctxtp->out_request = NULL;

        Prot_request_complete(ctxtp, & actp->op.request.req, NDIS_STATUS_FAILURE);
    }

    /* unannounce the nic now if it was announced before */
    status = Nic_unannounce (ctxtp);
    UNIV_PRINT (("Prot_unbind: unaunnounced %x", status));

    /* if still bound (Prot_close was not called from Nic_halt) then close now */

    status = Prot_close (adapterp);
    UNIV_PRINT (("Prot_unbind: closed %x", status));


    /* ctxtp might be gone at this point! */
#if 0
    if (adapterp -> device_name_len)
    {
        NdisFreeMemory (adapterp -> device_name, adapterp -> device_name_len, 0);
        adapterp -> device_name     = NULL;
        adapterp -> device_name_len = 0;
    }
#endif

    Main_adapter_put (adapterp);

    * statusp = status;
    UNIV_PRINT (("Prot_unbind: returning with status 0x%x", status));
    return;

} /* end Prot_unbind */


VOID Prot_open_complete (       /* PASSIVE_IRQL */
    NDIS_HANDLE         adapter_handle,
    NDIS_STATUS         open_status,
    NDIS_STATUS         error_status)
{
    PMAIN_CTXT          ctxtp = (PMAIN_CTXT) adapter_handle;


    UNIV_PRINT (("Prot_open_complete: called %x", ctxtp));

    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    ctxtp -> completion_status = open_status;
    NdisSetEvent (& ctxtp -> completion_event);

} /* end Prot_open_complete */


VOID Prot_close_complete (      /* PASSIVE_IRQL */
    NDIS_HANDLE         adapter_handle,
    NDIS_STATUS         status)
{
    PMAIN_CTXT          ctxtp = (PMAIN_CTXT) adapter_handle;


    UNIV_PRINT (("Prot_close_complete: called %x %x", ctxtp, status));

    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    ctxtp -> completion_status = status;
    NdisSetEvent (& ctxtp -> completion_event);

} /* end Prot_close_complete */


VOID Prot_request_complete (
    NDIS_HANDLE         adapter_handle,
    PNDIS_REQUEST       request,
    NDIS_STATUS         status)
{
    PMAIN_CTXT          ctxtp = (PMAIN_CTXT) adapter_handle;
    PMAIN_ACTION        actp;


    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    actp = CONTAINING_RECORD (request, MAIN_ACTION, op . request . req);
    UNIV_ASSERT (actp -> code == MAIN_ACTION_CODE);

    /* if request came from above - pass completion up */

    ctxtp->requests_pending = FALSE;

    if (actp -> op . request . external)
    {
        actp -> status = status;
        Nic_request_complete (ctxtp -> prot_handle, actp);
//        Nic_sync_queue (ctxtp, Nic_request_complete, actp, TRUE);
    }

    /* handle internal request completion */

    else
    {
        if (request -> RequestType == NdisRequestSetInformation)
        {
            * actp -> op . request . xferred =
                                request -> DATA . SET_INFORMATION . BytesRead;
            * actp -> op . request . needed  =
                                request -> DATA . SET_INFORMATION . BytesNeeded;
        }
        else
        {
            * actp -> op . request . xferred =
                            request -> DATA . QUERY_INFORMATION . BytesWritten;
            * actp -> op . request . needed  =
                            request -> DATA . QUERY_INFORMATION . BytesNeeded;
        }

        ctxtp -> completion_status = status;
        NdisSetEvent (& ctxtp -> completion_event);
    }

} /* end Prot_request_complete */


#ifdef PERIODIC_RESET
extern ULONG   resetting;
#endif

VOID Prot_reset_complete (
    NDIS_HANDLE         adapter_handle,
    NDIS_STATUS         status)
{
    PMAIN_CTXT          ctxtp = (PMAIN_CTXT) adapter_handle;
//    PMAIN_ACTION        actp;
    PMAIN_ADAPTER       adapterp;


    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    adapterp = & (univ_adapters [ctxtp -> adapter_id]);
    UNIV_ASSERT (adapterp -> code == MAIN_ADAPTER_CODE);
    UNIV_ASSERT (adapterp -> ctxtp == ctxtp);

    if (! adapterp -> inited)
        return;

#ifdef PERIODIC_RESET
    if (resetting)
    {
        resetting = FALSE;
        return;
    }
#endif
/*
    actp = Main_action_get (ctxtp);

    if (actp == NULL)
    {
        UNIV_PRINT (("error allocating action"));
        return;
    }

    actp -> status = status;
*/
    Nic_reset_complete (ctxtp, status);
//    Nic_sync_queue (ctxtp, Nic_reset_complete, actp, TRUE);

} /* end Prot_reset_complete */


VOID Prot_send_complete (
    NDIS_HANDLE         adapter_handle,
    PNDIS_PACKET        packet,
    NDIS_STATUS         status)
{
    PMAIN_CTXT          ctxtp = (PMAIN_CTXT) adapter_handle;
    PNDIS_PACKET        oldp;
    PNDIS_PACKET_STACK  pktstk;
    BOOLEAN             stack_left;
    PMAIN_PROTOCOL_RESERVED resp;
    LONG                lock_value;
    PMAIN_ADAPTER       adapterp;
    BOOLEAN             set = FALSE;


    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    adapterp = & (univ_adapters [ctxtp -> adapter_id]);
    UNIV_ASSERT (adapterp -> code == MAIN_ADAPTER_CODE);
    UNIV_ASSERT (adapterp -> ctxtp == ctxtp);

    if (! adapterp -> inited)
        return;

    MAIN_RESP_FIELD(packet, stack_left, pktstk, resp, TRUE);

    if (resp -> type == MAIN_PACKET_TYPE_PING ||
	resp -> type == MAIN_PACKET_TYPE_IGMP)
    {
        Main_send_done (ctxtp, packet, status);
        return;
    }

    if (resp -> type == MAIN_PACKET_TYPE_CTRL)
    {
        UNIV_PRINT (("Prot_send_complete: control packet send complete\n"));
        Main_packet_put (ctxtp, packet, TRUE, status);
        return;
    }

    UNIV_ASSERT_VAL (resp -> type == MAIN_PACKET_TYPE_PASS, resp -> type);

#if 0 /* this code is only needed for Prot_send - see comments in Prot_send */

    /* atomically signal Prot_send that a send complete arrived in case it is
       still in progress; see Prot_send and associated problem */

    lock_value = InterlockedDecrement (& resp -> data);
    UNIV_ASSERT_VAL (lock_value == 0 || lock_value == 1, lock_value);

    /* if lock value is 1 then Prot_send is still running and we will supply it with
       a return status so that it can complete synchronously; otherwise, Prot_send
       has completed and we must provide an asynchronous completion to the protocol */

    if (lock_value == 1)
    {
        resp -> len = status;
        return;
    }
#endif

    oldp = Main_packet_put (ctxtp, packet, TRUE, status);
/* ######
    actp = Main_action_get (ctxtp);

    if (actp == NULL)
    {
        UNIV_PRINT (("error allocating action"));
*/
        /* make sure that we always signal resource availability even if
           we cannot get an action to post a Nic_send_complete. do it
           through Nic_send_resources_signal instead */
/* ######
        if (ctxtp -> packets_exhausted)
        {
            ctxtp -> packets_exhausted = FALSE;
            Nic_sync_queue (ctxtp, Nic_send_resources_signal, ctxtp, TRUE);
        }

        return;
    }
*/
    if (ctxtp -> packets_exhausted)
    {
        ctxtp -> packets_exhausted = FALSE;

        /* optimized out since Nic_send_complete will perform the same action
           as the Nic_send_resources_signal */

        /* Nic_sync_queue (ctxtp, Nic_send_resources_signal, ctxtp, TRUE); */
    }
/* ######
    actp -> status = status;
    actp -> op . send . packet = oldp;
*/
    Nic_send_complete (ctxtp, status, oldp);

//    Nic_sync_queue (ctxtp, Nic_send_complete, actp, TRUE);

} /* end Prot_send_complete */


NDIS_STATUS Prot_recv_indicate (
    NDIS_HANDLE         adapter_handle,
    NDIS_HANDLE         recv_handle,
    PVOID               head_buf,
    UINT                head_len,
    PVOID               look_buf,
    UINT                look_len,
    UINT                packet_len)
{
    PMAIN_CTXT          ctxtp = (PMAIN_CTXT) adapter_handle;
//    PMAIN_ACTION        actp;
    NDIS_STATUS         status;
    PNDIS_PACKET        packet, newp;
    ULONG               xferred;
    BOOLEAN             accept = FALSE;
    PMAIN_ADAPTER       adapterp;
    PNDIS_PACKET_STACK  pktstk;
    BOOLEAN             stack_left;
    PMAIN_PROTOCOL_RESERVED resp;
    LONG                lock_value;


    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    adapterp = & (univ_adapters [ctxtp -> adapter_id]);
    UNIV_ASSERT (adapterp -> code == MAIN_ADAPTER_CODE);
    UNIV_ASSERT (adapterp -> ctxtp == ctxtp);

// ###### ramkrish check: check whether the driver has been announced to tcpip before processing any packets
    if (! adapterp -> inited || ! adapterp -> announced)
        return NDIS_STATUS_NOT_ACCEPTED;

    /* fix netflex driver bug that reports bogus packet length to us */

    UNIV_ASSERT_VAL2(packet_len <= ctxtp -> max_frame_size && look_len <= ctxtp -> max_frame_size, packet_len, look_len);

    CVY_CHECK_MAX(look_len, ctxtp->max_frame_size);
    CVY_CHECK_MAX(packet_len, ctxtp->max_frame_size);

    /* V1.1.2 do not accept frames if the card below is resetting */

    if (ctxtp -> reset_state != MAIN_RESET_NONE)
        return NDIS_STATUS_NOT_ACCEPTED;

    ctxtp -> recv_indicated = TRUE;

    /* V1.3.2b - see if we need to handle this packet */

    packet = Main_recv_indicate (ctxtp, recv_handle, look_buf, look_len,
                                 packet_len, head_buf, head_len, &accept);

    if (! accept) /* NT 5.1 - ramkrish */
    {
        ctxtp -> recv_indicated = FALSE;
        return NDIS_STATUS_NOT_ACCEPTED;
    }

    /* transfer the rest of the data if required. note that we have to xfer
       entire packet due to bugs on some card drives that do not handle
       partial xfers */

    if (packet != NULL) /* NT 5.1 - ramkrish */
    {
        if (look_len < packet_len)
        {
            NdisTransferData (& status, ctxtp -> mac_handle, recv_handle,
                              0, packet_len, packet, & xferred);
        }
        else
        {
            xferred = 0;
            status  = NDIS_STATUS_SUCCESS;
        }

        if (status != NDIS_STATUS_PENDING)
            Prot_transfer_complete (adapter_handle, packet, status, xferred);
    }
    else /* propagate indicates to the protocol - NT 5.1 - ramkrish */
    {
	do
	{
	    /* If a packet was indicated, then indicate the packet up to the protocols */
	    packet = NdisGetReceivedPacket (ctxtp -> mac_handle, recv_handle);


	    if (packet != NULL) /* Then allocate a new packet and then pass it up as a packet recv,
				   but marked with status resources. */
	    {
		newp = Main_packet_get (ctxtp, packet, FALSE, 0, 0);

		if (newp != NULL)
		{
		    MAIN_RESP_FIELD(packet, stack_left, pktstk, resp, FALSE);

		    resp -> data = 2; /* This is to ensure that Prot_return does not return this packet */

		    status  = NDIS_GET_PACKET_STATUS(packet);
		    NDIS_SET_PACKET_STATUS (newp, NDIS_STATUS_RESOURCES);

		    Nic_recv_packet (ctxtp, newp);

		    Main_packet_put (ctxtp, newp, FALSE, NDIS_GET_PACKET_STATUS (newp));
		    NDIS_SET_PACKET_STATUS (packet, status);
		    break;
		}
	    }

	    /* Fall through if no packet was indicated or no packet could be allocated or no packet stack */

	    Nic_recv_indicate (ctxtp, recv_handle,  head_buf, head_len, look_buf,
			       look_len, packet_len);

	} while (FALSE);
    }

    return NDIS_STATUS_SUCCESS;

#if 0 /* old code */

    actp = Main_action_get (ctxtp);

    if (actp == NULL)
    {
        UNIV_PRINT (("error allocating action"));
        return NDIS_STATUS_NOT_ACgCEPTED;
    }

    actp -> op . indicate . recv_handle = recv_handle;
    actp -> op . indicate . head_buf    = head_buf;
    actp -> op . indicate . head_len    = head_len;
    actp -> op . indicate . look_buf    = look_buf;
    actp -> op . indicate . look_len    = look_len;
    actp -> op . indicate . packet_len  = packet_len;

    if (! Nic_sync_queue (ctxtp, Nic_recv_indicate, actp, FALSE)) /* 1.2.1 */
    {
        if (((PUCHAR) head_buf) [0] & 0x1)
        {
            UNIV_PRINT (("error delivering loopback to higher level protocol due to syncing problem"));
        }
        else
        {
            UNIV_PRINT (("error delivering receive indicate to higher level protocol due to syncing problem"));
        }

        Main_action_put (ctxtp, actp);
        return NDIS_STATUS_NOT_ACCEPTED;
    }

    /* Main_action_put will be called in Nic_recv_indicate */

    return NDIS_STATUS_SUCCESS;

#endif

} /* end Prot_recv_indicate */


VOID Prot_recv_complete (       /* PASSIVE_IRQL */
    NDIS_HANDLE         adapter_handle)
{
    PMAIN_CTXT          ctxtp = (PMAIN_CTXT) adapter_handle;
    PLIST_ENTRY         entryp;
    PMAIN_ADAPTER       adapterp;


    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    adapterp = & (univ_adapters [ctxtp -> adapter_id]);
    UNIV_ASSERT (adapterp -> code == MAIN_ADAPTER_CODE);
    UNIV_ASSERT (adapterp -> ctxtp == ctxtp);

    if (! adapterp -> inited)
        return;

    if (! adapterp -> announced)
        return;

    /* process control queue if there is any work on it */

    while (1)
    {
        PMAIN_ACTION        actp;


        entryp = NdisInterlockedRemoveHeadList (& ctxtp -> rct_list,
                                                & ctxtp -> rct_lock);

        if (entryp == NULL)
            break;

        actp = CONTAINING_RECORD (entryp, MAIN_ACTION, link);
        UNIV_ASSERT (actp -> code == MAIN_ACTION_CODE);

        /* handle remote control request now */
        Main_ctrl_recv (ctxtp, actp -> op . ctrl . packet);

        /* note un-optimized call since running at PASSIVE IRQL */
        Main_action_put (ctxtp, actp);
    }

    Nic_recv_complete (ctxtp);

//    Nic_sync_queue (ctxtp, Nic_recv_complete, ctxtp, TRUE);

} /* end Prot_recv_complete */


VOID Prot_transfer_complete (
    NDIS_HANDLE         adapter_handle,
    PNDIS_PACKET        packet,
    NDIS_STATUS         status,
    UINT                xferred)
{
    PMAIN_CTXT          ctxtp = (PMAIN_CTXT) adapter_handle;
    PNDIS_PACKET        oldp;
    PNDIS_PACKET_STACK  pktstk;
    BOOLEAN             stack_left;
    PMAIN_PROTOCOL_RESERVED resp;
    LONG                lock_value;
    PNDIS_BUFFER        bufp;
    PMAIN_ADAPTER       adapterp;


    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    adapterp = & (univ_adapters [ctxtp -> adapter_id]);
    UNIV_ASSERT (adapterp -> code == MAIN_ADAPTER_CODE);
    UNIV_ASSERT (adapterp -> ctxtp == ctxtp);

    if (! adapterp -> inited)
        return;

    MAIN_RESP_FIELD (packet, stack_left, pktstk, resp, FALSE); /* #ps# */

    if (resp -> type == MAIN_PACKET_TYPE_PING)
    {
        Main_xfer_done (ctxtp, packet, status, xferred);
        return;
    }

    UNIV_ASSERT_VAL (resp -> type == MAIN_PACKET_TYPE_INDICATE ||
                     resp -> type == MAIN_PACKET_TYPE_CTRL ||
                     resp -> type == MAIN_PACKET_TYPE_TRANSFER,
                     resp -> type);

    /* V2.0.6 */

    /* Added code for NT 5.1 - ramkrish */
    if (resp -> type == MAIN_PACKET_TYPE_TRANSFER)
    {
        if (status == NDIS_STATUS_SUCCESS)
        {
            PUCHAR hdrp, mac_hdrp, tcp_hdrp;
            ULONG  len;
            USHORT sig, group;

            /* Parse the buffers and obtain the length and group information.
             * This is used to update the counters.
             */
            hdrp = Main_frame_parse (ctxtp, packet, & mac_hdrp, 0, & tcp_hdrp, & len,
                                     & sig, & group, FALSE);
            if (hdrp)
            {
                resp -> len   = len; /* 64-bit -- ramkrish */
                resp -> group = group;
            }
        }
        oldp = Main_packet_put (ctxtp, packet, FALSE, status);
        Nic_transfer_complete (ctxtp, status, packet, xferred);
        return;
    }

    if (status != NDIS_STATUS_SUCCESS)
    {
        UNIV_PRINT (("error transferring %x", status));
        Main_packet_put (ctxtp, packet, FALSE, status);
        return;
    }

    /* V1.3.2b */

    if ((UINT) resp -> data != xferred)
    {
        UNIV_PRINT (("did not xfer enough data %d %d\n", resp -> data, xferred));
        Main_packet_put (ctxtp, packet, FALSE, NDIS_STATUS_FAILURE);
        return;
    }

    /* if some data was transferred - then replace partial buffer with full
       frame buffer. we had a partial buffer describing just the data portion,
       without media header for NdisTransferData call. protocols can't handle
       multiple linked buffers on receive, so we need to have one big one
       describing both media header and payload */

    if (xferred > 0)
    {
        NdisUnchainBufferAtFront (packet, & bufp);
        bufp = ((PMAIN_BUFFER) resp -> miscp) -> full_bufp;
        NdisChainBufferAtFront (packet, bufp);
    }

    /* put control packets on control queue */

    if (resp -> type == MAIN_PACKET_TYPE_CTRL)
    {
        PMAIN_ACTION        actp;


        actp = Main_action_get (ctxtp);

        if (actp == NULL)
        {
            UNIV_PRINT (("error allocating action"));
            Main_packet_put (ctxtp, packet, TRUE, NDIS_STATUS_FAILURE);
            return;
        }

        actp -> op . ctrl . packet = packet;

        NdisAcquireSpinLock (& ctxtp -> rct_lock);
        InsertTailList (& ctxtp -> rct_list, & actp -> link);
        NdisReleaseSpinLock (& ctxtp -> rct_lock);

        return;
    }

    /* pass packet up. note signalling to decide who will dispose of the
       packet */

    resp -> data = 2;

//    actp -> op . recv . packet = packet;

    Nic_recv_packet (ctxtp, packet);
//    Nic_sync_queue (ctxtp, Nic_recv_packet, actp, TRUE);

    lock_value = InterlockedDecrement (& resp -> data);
    UNIV_ASSERT_VAL (lock_value == 0 || lock_value == 1, lock_value);

    if (lock_value == 0)
        Main_packet_put (ctxtp, packet, FALSE, NDIS_STATUS_SUCCESS);

#if 0 /* old code */

    oldp = Main_packet_put (ctxtp, packet, FALSE, status);

    actp = Main_action_get (ctxtp);

    if (actp == NULL)
    {
        UNIV_PRINT (("error allocating action"));
        return;
    }

    actp -> status = status;

    actp -> op . transfer . packet  = oldp;
    actp -> op . transfer . xferred = xferred;

    Nic_sync_queue (ctxtp, Nic_transfer_complete, actp, TRUE);

#endif

} /* end Prot_transfer_complete */


NDIS_STATUS Prot_PNP_handle (
    NDIS_HANDLE         adapter_handle,
    PNET_PNP_EVENT      pnp_event)
{
    PMAIN_CTXT          ctxtp = (PMAIN_CTXT) adapter_handle;
    PNDIS_DEVICE_POWER_STATE  device_state;
    NDIS_STATUS         status = NDIS_STATUS_SUCCESS;
    IOCTL_CVY_BUF       ioctl_buf;
    PMAIN_ACTION        actp;


    /* can happen when first initializing */

    switch (pnp_event -> NetEvent)
    {
        case NetEventSetPower:

            if (adapter_handle == NULL)
                return NDIS_STATUS_SUCCESS;

            UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

            device_state = (PNDIS_DEVICE_POWER_STATE) (pnp_event -> Buffer);
            UNIV_PRINT (("Nic_PNP_handle: NetEventSetPower %x", * device_state));

	    // If the specified device state is D0, then handle it first,
	    // else notify the protocols first and then handle it.

	    if (*device_state != NdisDeviceStateD0)
	    {
		status = Nic_PNP_handle (ctxtp, pnp_event);
	    }

	    //
	    // Is the protocol transitioning from an On (D0) state to an Low Power State (>D0)
	    // If so, then set the standby_state Flag - (Block all incoming requests)
	    //
	    if (ctxtp->prot_pnp_state == NdisDeviceStateD0 &&
		*device_state > NdisDeviceStateD0)
            {
		ctxtp->standby_state = TRUE;
	    }

	    //
	    // If the protocol is transitioning from a low power state to ON (D0), then clear the standby_state flag
	    // All incoming requests will be pended until the physical miniport turns ON.
	    //
	    if (ctxtp->prot_pnp_state > NdisDeviceStateD0 &&
		*device_state == NdisDeviceStateD0)
	    {
		ctxtp->standby_state = FALSE;
	    }

	    ctxtp -> prot_pnp_state = *device_state;

	    /* if we are being sent to standby, block outstanding requests and
		   sends */

	    if (*device_state > NdisDeviceStateD0)
            {
               /* sleep till outstanding sends complete */

               while (1)
               {
                   ULONG        i;


                   /* #ps# -- ramkrish */
                   while (1)
                   {
                       NDIS_STATUS status;
                       ULONG       count;

                       status = NdisQueryPendingIOCount (ctxtp -> mac_handle, & count);
                       if (status != NDIS_STATUS_SUCCESS || count == 0)
                           break;

                       Nic_sleep (10);
                   }

                   for (i = 0; i < ctxtp->num_send_packet_allocs; i++)
                   {
                       if (NdisPacketPoolUsage(ctxtp->send_pool_handle[i]) != 0)
                           break;
                   }

                   if (i >= ctxtp->num_send_packet_allocs)
                       break;

                   Nic_sleep(10);
               }

               /* sleep till outstanding requests complete */

               while (ctxtp->requests_pending)
               {
                   Nic_sleep(10);
               }


            }
            else
            {
                if (ctxtp->out_request != NULL)
                {
		    NDIS_STATUS      status;


                    actp = ctxtp->out_request;
                    ctxtp->out_request = NULL;

                    status = Prot_request(ctxtp, actp, actp->op.request.external);

                    if (status != NDIS_STATUS_PENDING)
                        Prot_request_complete(ctxtp, & actp->op.request.req, status);


                }
            }

	    if (*device_state == NdisDeviceStateD0)
	    {
		status = Nic_PNP_handle (ctxtp, pnp_event);
	    }

            break;

        case NetEventReconfigure:

            UNIV_PRINT (("Nic_PNP_handle: NetEventReconfigure"));

            if (adapter_handle == NULL) // This happens if the device is being enabled through the device manager.
            {
                UNIV_PRINT (("Prot_PNP_handle: Enumerate protocol bindings"));
                NdisReEnumerateProtocolBindings (univ_prot_handle);
                return NDIS_STATUS_SUCCESS;
            }
            /* gets called when something changes in our setup from notify
               object */

            UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

            /* This IOCTL will actually ignore the VIP argument, but set it to a reasonable value anyway. */
            Main_ctrl (ctxtp, IOCTL_CVY_RELOAD, & ioctl_buf, IOCTL_ALL_VIPS);

	    status = Nic_PNP_handle (ctxtp, pnp_event);

            UNIV_PRINT (("Nic_PNP_handle: NetEventReconfigure done %d %x", ioctl_buf . ret_code, status));
            break;

        case NetEventQueryPower:
            UNIV_PRINT (("Nic_PNP_handle: NetEventQueryPower"));
            if (adapter_handle == NULL)
                return NDIS_STATUS_SUCCESS;

            UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

	    status = Nic_PNP_handle (ctxtp, pnp_event);
            break;

        case NetEventQueryRemoveDevice:
            UNIV_PRINT (("Nic_PNP_handle: NetEventQueryRemoveDevice"));
            if (adapter_handle == NULL)
                return NDIS_STATUS_SUCCESS;

            UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

	    status = Nic_PNP_handle (ctxtp, pnp_event);
            break;

        case NetEventCancelRemoveDevice:
            UNIV_PRINT (("Nic_PNP_handle: NetEventCancelRemoveDevice"));
            if (adapter_handle == NULL)
                return NDIS_STATUS_SUCCESS;

            UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

	    status = Nic_PNP_handle (ctxtp, pnp_event);
            break;

        case NetEventBindList:
            UNIV_PRINT (("Nic_PNP_handle: NetEventBindList"));
            if (adapter_handle == NULL)
                return NDIS_STATUS_SUCCESS;

            UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

	    status = Nic_PNP_handle (ctxtp, pnp_event);
            break;

        case NetEventBindsComplete:
            UNIV_PRINT (("Nic_PNP_handle: NetEventBindComplete"));
            if (adapter_handle == NULL)
                return NDIS_STATUS_SUCCESS;

            UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

	    status = Nic_PNP_handle (ctxtp, pnp_event);
            break;

        default:
            UNIV_PRINT (("Nic_PNP_handle: new event"));
            if (adapter_handle == NULL)
                return NDIS_STATUS_SUCCESS;

            UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

	    status = Nic_PNP_handle (ctxtp, pnp_event);
            break;
    }

    return status; /* Always return NDIS_STATUS_SUCCESS or
		      the return value of NdisIMNotifyPnPEvent */

} /* end Nic_PNP_handle */


VOID Prot_status (
    NDIS_HANDLE         adapter_handle,
    NDIS_STATUS         status,
    PVOID               stat_buf,
    UINT                stat_len)
{
    PMAIN_CTXT          ctxtp = (PMAIN_CTXT) adapter_handle;
//    PMAIN_ACTION        actp;
    KIRQL               irql;
    PMAIN_ADAPTER       adapterp;


    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    adapterp = & (univ_adapters [ctxtp -> adapter_id]);
    UNIV_ASSERT (adapterp -> code == MAIN_ADAPTER_CODE);
    UNIV_ASSERT (adapterp -> ctxtp == ctxtp);

    UNIV_PRINT(("Prot_status called for adapter %d for notification %d: inited=%d, announced=%d", ctxtp -> adapter_id, status, adapterp->inited, adapterp->announced));

    if (! adapterp -> inited || ! adapterp -> announced)
        return;

    UNIV_PRINT (("STATUS %x", status));

    switch (status)
    {
        case NDIS_STATUS_WAN_LINE_UP:
            UNIV_PRINT (("NDIS_STATUS_WAN_LINE_UP"));
            break;

        case NDIS_STATUS_WAN_LINE_DOWN:
            UNIV_PRINT (("NDIS_STATUS_WAN_LINE_DOWN"));
            break;

        case NDIS_STATUS_MEDIA_CONNECT:
            UNIV_PRINT (("NDIS_STATUS_MEDIA_CONNECT"));

            /* V1.3.2b */
            ctxtp -> media_connected = TRUE;
            break;

        case NDIS_STATUS_MEDIA_DISCONNECT:
            UNIV_PRINT (("NDIS_STATUS_MEDIA_DISCONNECT"));

            /* V1.3.2b */
            ctxtp -> media_connected = FALSE;
            break;

        case NDIS_STATUS_HARDWARE_LINE_UP:
            UNIV_PRINT (("NDIS_STATUS_HARDWARE_LINE_UP"));
            break;

        case NDIS_STATUS_HARDWARE_LINE_DOWN:
            UNIV_PRINT (("NDIS_STATUS_HARDWARE_LINE_DOWN"));
            break;

        case NDIS_STATUS_INTERFACE_UP:
            UNIV_PRINT (("NDIS_STATUS_INTERFACE_UP"));
            break;

        case NDIS_STATUS_INTERFACE_DOWN:
            UNIV_PRINT (("NDIS_STATUS_INTERFACE_DOWN"));
            break;

        /* V1.1.2 */

        case NDIS_STATUS_RESET_START:
            UNIV_PRINT (("NDIS_STATUS_RESET_START"));
            ctxtp -> reset_state = MAIN_RESET_START;
            ctxtp -> recv_indicated = FALSE;
            break;

        case NDIS_STATUS_RESET_END:
            UNIV_PRINT (("NDIS_STATUS_RESET_END"));
            // apparently alteon adapter does not call status complete function,
            // so need to transition to none state here in order to prevent hangs
            //ctxtp -> reset_state = MAIN_RESET_END;
            ctxtp -> reset_state = MAIN_RESET_NONE;
            break;

        default:
            break;
    }

    if (! MAIN_PNP_DEV_ON(ctxtp))
        return;
/* ######
    actp = Main_action_get (ctxtp);

    if (actp == NULL)
    {
        UNIV_PRINT (("error allocating action"));
        return;
    }

    actp -> status = status;

    actp -> op . status . buf = stat_buf;
    actp -> op . status . len = stat_len;
*/
    Nic_status (ctxtp, status, stat_buf, stat_len);
//    Nic_sync_queue (ctxtp, Nic_status, actp, TRUE);

} /* end Prot_status */


VOID Prot_status_complete (
    NDIS_HANDLE         adapter_handle)
{
    PMAIN_CTXT          ctxtp = (PMAIN_CTXT) adapter_handle;
//    PMAIN_ACTION        actp;
    PMAIN_ADAPTER       adapterp;


    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    adapterp = & (univ_adapters [ctxtp -> adapter_id]);
    UNIV_ASSERT (adapterp -> code == MAIN_ADAPTER_CODE);
    UNIV_ASSERT (adapterp -> ctxtp == ctxtp);

    if (! adapterp -> inited)
        return;

    /* V1.1.2 */

    if (ctxtp -> reset_state == MAIN_RESET_END)
    {
        ctxtp -> reset_state = MAIN_RESET_NONE;
        UNIV_PRINT (("NDIS_STATUS_RESET_END completed"));
    }
    else if (ctxtp -> reset_state == MAIN_RESET_START)
    {
        ctxtp -> reset_state = MAIN_RESET_START_DONE;
        UNIV_PRINT (("NDIS_STATUS_RESET_START completed"));
    }

    if (! MAIN_PNP_DEV_ON(ctxtp))
        return;
/* ######
    actp = Main_action_get (ctxtp);

    if (actp == NULL)
    {
        UNIV_PRINT (("error allocating action"));
        return;
    }
*/
    Nic_status_complete (ctxtp);
//    Nic_sync_queue (ctxtp, Nic_status_complete, actp, TRUE);

} /* end Prot_status_complete */


/* helpers for nic layer */


NDIS_STATUS Prot_close (       /* PASSIVE_IRQL */
    PMAIN_ADAPTER       adapterp
)
{
    NDIS_STATUS         status;
    ULONG               ret;
    PMAIN_CTXT          ctxtp;


    UNIV_PRINT (("Prot_close: called"));
    UNIV_ASSERT (adapterp -> code == MAIN_ADAPTER_CODE);
//    UNIV_ASSERT (adapterp -> ctxtp == ctxtp);

    ctxtp = adapterp -> ctxtp;

    /* close binding */

    NdisAcquireSpinLock(& univ_bind_lock);

    if ( ! adapterp -> bound || ctxtp->mac_handle == NULL)
    {
        /* cleanup only on the second time we are entering Prot_close, which
           is called by both Nic_halt and Prot_unbind. the last one to be
           called will cleanup the context since they both use it. if both
           do not get called, then it will be cleaned up by Prot_bind before
           allocating a new one of Init_unload before unloading the driver. */

        if (adapterp -> inited)
        {
            UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

            adapterp -> inited    = FALSE;

            NdisReleaseSpinLock(& univ_bind_lock);

            Main_cleanup (ctxtp);
            NdisFreeMemory (ctxtp, sizeof (MAIN_CTXT), 0);

            adapterp -> ctxtp = NULL;

            if (adapterp -> device_name_len)
            {
                NdisFreeMemory (adapterp -> device_name, adapterp -> device_name_len, 0);
                adapterp -> device_name = NULL;
                adapterp -> device_name_len = 0;
            }

        }
        else
            NdisReleaseSpinLock(& univ_bind_lock);

        Main_adapter_put (adapterp);
        return NDIS_STATUS_SUCCESS;
    }

    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    adapterp -> bound = FALSE;
    ctxtp -> convoy_enabled = FALSE;

    NdisReleaseSpinLock(& univ_bind_lock);

    LOG_MSG (MSG_INFO_STOPPED, MSG_NONE);

    NdisResetEvent (& ctxtp -> completion_event);

    NdisCloseAdapter (& status, ctxtp -> mac_handle);

    /* if pending - wait for Prot_close_complete to set the completion event */

    if (status == NDIS_STATUS_PENDING)
    {
        ret = NdisWaitEvent (& ctxtp -> completion_event, UNIV_WAIT_TIME);

        if (! ret)
        {
            UNIV_PRINT (("error waiting for event"));
            LOG_MSG1 (MSG_ERROR_INTERNAL, MSG_NONE, status);
            return NDIS_STATUS_FAILURE;
        }

        status = ctxtp -> completion_status;
    }

    /* At this point,wait for all pending recvs to be completed and then return */

    ctxtp -> mac_handle  = NULL;
    ctxtp -> prot_handle = NULL;

    /* check binding status */

    if (status != NDIS_STATUS_SUCCESS)
    {
        UNIV_PRINT (("error closing adapter %x", status));
        LOG_MSG1 (MSG_ERROR_INTERNAL, MSG_NONE, status);
    }

    /* if nic level is not announced anymore - safe to remove context now */

    NdisAcquireSpinLock(& univ_bind_lock);

    if (! adapterp -> announced || ctxtp -> prot_handle == NULL)
    {
        if (adapterp -> inited)
        {
            adapterp -> inited = FALSE;
            NdisReleaseSpinLock(& univ_bind_lock);

            Main_cleanup (ctxtp);
            NdisFreeMemory (ctxtp, sizeof (MAIN_CTXT), 0);

            adapterp -> ctxtp = NULL;

            if (adapterp -> device_name_len)
            {
                NdisFreeMemory (adapterp -> device_name, adapterp -> device_name_len, 0);
                adapterp -> device_name = NULL;
                adapterp -> device_name_len = 0;
            }
        }
        else
            NdisReleaseSpinLock(& univ_bind_lock);

        Main_adapter_put (adapterp);
    }
    else
        NdisReleaseSpinLock(& univ_bind_lock);

    UNIV_PRINT (("Prot_close: exiting"));

    return status;

} /* end Prot_close */


NDIS_STATUS Prot_request (
    PMAIN_CTXT          ctxtp,
    PMAIN_ACTION        actp,
    ULONG               external)
{
    NDIS_STATUS         status;
    PNDIS_REQUEST       request = & actp -> op . request . req;
    ULONG               ret;


    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    /* V1.1.2 do not accept requests if the card below is resetting */

    actp -> op . request . external = external;

    if (ctxtp -> unbind_handle) // Prot_unbind was called
        return NDIS_STATUS_FAILURE;

    // if the Protocol device state is OFF, then the IM driver cannot send the
    // request below and must pend it

    if (ctxtp->prot_pnp_state > NdisDeviceStateD0)
    {
        UNIV_ASSERT (ctxtp->out_request == NULL);
        ctxtp->out_request = actp;
        return NDIS_STATUS_PENDING;
    }

    NdisResetEvent (& ctxtp -> completion_event);

    ctxtp->requests_pending = TRUE;
    NdisRequest (& status, ctxtp -> mac_handle, request);

    /* if pending - wait for Prot_request_complete to set the completion event */

    if (status != NDIS_STATUS_PENDING)
    {
        ctxtp->requests_pending = FALSE;
    }
    else if (! external)
    {
        ret = NdisWaitEvent (& ctxtp -> completion_event, UNIV_WAIT_TIME);

        if (! ret)
        {
            UNIV_PRINT (("error waiting for event"));
            LOG_MSG1 (MSG_ERROR_INTERNAL, MSG_NONE, status);
            status = NDIS_STATUS_FAILURE;
            return status;
        }

        status = ctxtp -> completion_status;
    }

    return status;

} /* end Prot_request */


NDIS_STATUS Prot_reset (
    PMAIN_CTXT          ctxtp)
{
    NDIS_STATUS         status;


    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    NdisReset (& status, ctxtp -> mac_handle);

    return status;

} /* end Prot_reset */


VOID Prot_packets_send (
    PMAIN_CTXT          ctxtp,
    PPNDIS_PACKET       packets,
    UINT                num_packets)
{
    PNDIS_PACKET        array [CVY_MAX_SEND_PACKETS];
    PNDIS_PACKET        filtered_array [CVY_MAX_SEND_PACKETS];
    UINT                count = 0, filtered_count = 0, i;
    NDIS_STATUS         status;
    PNDIS_PACKET        newp;
    LONG                lock_value;
    PMAIN_ACTION        actp;
    ULONG               exhausted;
    PNDIS_PACKET_STACK  pktstk;
    BOOLEAN             stack_left;


    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    /* V1.1.2 do not accept frames if the card below is resetting */

    if (ctxtp -> reset_state != MAIN_RESET_NONE ||
        ! MAIN_PNP_DEV_ON(ctxtp))
    {
        ctxtp -> cntr_xmit_err ++;
        status = NDIS_STATUS_FAILURE;
        goto fail;
    }

    /* ###### modified for a deserialized driver - ramkrish */
    for (count = i = 0;
         count < (num_packets > CVY_MAX_SEND_PACKETS ?
                  CVY_MAX_SEND_PACKETS : num_packets);
         count ++)
    {
        newp = Main_send (ctxtp, packets [count], & exhausted);

        if (newp == NULL)
        {
            /* if we ran out of packets - get out of the loop */

            if (exhausted)
            {
                UNIV_PRINT (("error xlating packet"));
                ctxtp -> packets_exhausted = TRUE;
                break;
            }

            /* if packet was filtered out - set status to success to calm
               TCP/IP down and go on to the next one */

            else
            {
                /* ###### filtered_... added for NT 5.1 deserialization - ramkrish */
//                ctxtp -> sends_filtered ++;
                filtered_array [filtered_count] = packets [count];
                filtered_count++;
                NDIS_SET_PACKET_STATUS (packets [count], NDIS_STATUS_SUCCESS);
                continue;
            }
        }

//        resp = MAIN_PROTOCOL_FIELD (newp); /* #ps# */

#if 0 /* do not need this since corresponding code was commented out in Prot_send_complete */

        /* initalize value to 1 to force Prot_send_complete to deal with the
           packet */

        resp -> data = 1;
#endif

        /* mark packet as pending send */

        NDIS_SET_PACKET_STATUS (packets [count], NDIS_STATUS_PENDING);
        array [i] = newp;
        i ++;
    }

    if (i > 0)
        NdisSendPackets (ctxtp -> mac_handle, array, i);

    /* ###### added for indicating the filtered packets in deserialization - ramkrish */
    for (i = 0; i < filtered_count; i++)
        Nic_send_complete (ctxtp, NDIS_STATUS_SUCCESS, filtered_array [i]);

fail:
    /* ###### the remaining packets cannot be handled, no space in the pending queue too */
    for (i = count; i < num_packets; i++)
    {
        NDIS_SET_PACKET_STATUS (packets [i], NDIS_STATUS_FAILURE);
        Nic_send_complete (ctxtp, NDIS_STATUS_FAILURE, packets [i]);
    }

#if 0 /* old code used in serialized driver - ramkrish */
    status = NDIS_STATUS_RESOURCES;

    /* the following code has to be removed and the other packets have to be put in a queue */
fail:

    /* fill status field on all un-handled packets */

    for (i = count; i < num_packets; i ++)
        NDIS_SET_PACKET_STATUS (packets [i], status);

#endif
} /* end Prot_packets_send */


INT Prot_packet_recv (
    NDIS_HANDLE         adapter_handle,
    PNDIS_PACKET        packet)
{
    PMAIN_CTXT          ctxtp = (PMAIN_CTXT) adapter_handle;
    PNDIS_PACKET        newp;
    NDIS_STATUS         status;
    PMAIN_PROTOCOL_RESERVED resp;
    LONG                lock_value;
    PNDIS_PACKET_STACK  pktstk;
    BOOLEAN             stack_left;
    PMAIN_ADAPTER       adapterp;


    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    adapterp = & (univ_adapters [ctxtp -> adapter_id]);
    UNIV_ASSERT (adapterp -> code == MAIN_ADAPTER_CODE);
    UNIV_ASSERT (adapterp -> ctxtp == ctxtp);

// ###### ramkrish check: check whether the driver has been announced to tcpip before processing any packets
    if (! adapterp -> inited || ! adapterp -> announced)
        return 0;

    /* V1.1.4 do not accept frames if the card below is resetting */

    if (ctxtp -> reset_state != MAIN_RESET_NONE)
        return 0;

    /* figure out if we need to handle this packet */

    newp = Main_recv (ctxtp, packet);

    if (newp == NULL)
        return 0;

//    resp = MAIN_PROTOCOL_FIELD (newp);

    MAIN_RESP_FIELD (newp, stack_left, pktstk, resp, FALSE); /* #ps# */

    /* put control packets on control queue */

    if (resp -> type == MAIN_PACKET_TYPE_CTRL)
    {
        PMAIN_ACTION        actp;


        actp = Main_action_get (ctxtp);

        if (actp == NULL)
        {
            UNIV_PRINT (("error allocating action"));
            Main_packet_put (ctxtp, newp, TRUE, NDIS_STATUS_FAILURE);
            return 0;
        }

        actp -> op . ctrl . packet = newp;

        NdisAcquireSpinLock (& ctxtp -> rct_lock);
        InsertTailList (& ctxtp -> rct_list, & actp -> link);
        NdisReleaseSpinLock (& ctxtp -> rct_lock);

        /* packet has been copied into our buffers - can return 0 */

        return 0;
    }

    UNIV_ASSERT_VAL (resp -> type == MAIN_PACKET_TYPE_PASS, resp -> type);

    /* pass packet up. note signaling to figure out who will be disposing of
       the packet */
    resp -> data = 2;

/* ######
    actp -> op . recv . packet = newp;
*/
    Nic_recv_packet (ctxtp, newp);
//    Nic_sync_queue (ctxtp, Nic_recv_packet, actp, TRUE);

    lock_value = InterlockedDecrement (& resp -> data);
    UNIV_ASSERT_VAL (lock_value == 0 || lock_value == 1, lock_value);

    if (lock_value == 0)
    {
        Main_packet_put (ctxtp, newp, FALSE, NDIS_STATUS_SUCCESS);
        return 0;
    }

    return 1;

} /* end Prot_packet_recv */


VOID Prot_return (
    PMAIN_CTXT          ctxtp,
    PNDIS_PACKET        packet)
{
    PNDIS_PACKET        oldp;
    PMAIN_PROTOCOL_RESERVED resp;
    LONG                lock_value;
    ULONG               type;
    PNDIS_PACKET_STACK  pktstk;
    BOOLEAN             stack_left;


    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

//    resp = MAIN_PROTOCOL_FIELD (packet);

    MAIN_RESP_FIELD (packet, stack_left, pktstk, resp, FALSE); /* #ps# */

    /* check to see if we need to be disposing of this packet */

    lock_value = InterlockedDecrement (& resp -> data);
    UNIV_ASSERT_VAL (lock_value == 0 || lock_value == 1, lock_value);

    if (lock_value == 1)
        return;

    /* resp will become invalid after the call to Main_packet_put. save type
       for assertion below */

    type = resp -> type;

    oldp = Main_packet_put (ctxtp, packet, FALSE, NDIS_STATUS_SUCCESS);

    /* if oldp is NULL - this is our internal packet from recv_indicate path */

    if (oldp != NULL)
    {
        UNIV_ASSERT_VAL (type == MAIN_PACKET_TYPE_PASS, type);
        NdisReturnPackets (& oldp, 1);
    }

} /* end Prot_return */


/* ###### Added from old code for NT 5.1 - ramkrish */

NDIS_STATUS Prot_transfer (
    PMAIN_CTXT          ctxtp,
    NDIS_HANDLE         recv_handle,
    PNDIS_PACKET        packet,
    UINT                offset,
    UINT                len,
    PUINT               xferred)
{
    NDIS_STATUS         status;
    PNDIS_PACKET        newp;
    PMAIN_PROTOCOL_RESERVED resp;
    PNDIS_PACKET_STACK  pktstk;
    BOOLEAN             stack_left;


    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    /* V1.1.2 do not accept frames if the card below is resetting */

    if (ctxtp -> reset_state != MAIN_RESET_NONE)
        return NDIS_STATUS_FAILURE;

    /* we are trying to prevent transfer requests from stale receive indicates
       that have been made to the protocol layer prior to the reset operation.
       we do not know what is the old inbound frame state and cannot expect
       to be able to carry out any transfers. */

    if (! ctxtp -> recv_indicated)
    {
        UNIV_PRINT (("*** ERROR - STALE RECV AFTER RESET ***"));
        return NDIS_STATUS_FAILURE;
    }

    newp = Main_packet_get (ctxtp, packet, FALSE, 0, 0);

    if (newp == NULL)
    {
        UNIV_PRINT (("error xlating packet"));
        return NDIS_STATUS_RESOURCES;
    }

    /* ###### for NT 5.1 - ramkrish */
//    resp = MAIN_PROTOCOL_FIELD (newp); /* #ps# */

    MAIN_RESP_FIELD (newp, stack_left, pktstk, resp, FALSE);

    resp -> type = MAIN_PACKET_TYPE_TRANSFER;

    NdisTransferData (& status, ctxtp -> mac_handle, recv_handle, offset, len,
                      newp, xferred);   /* V1.1.2 */

    if (status != NDIS_STATUS_PENDING)
    {
        if (status == NDIS_STATUS_SUCCESS)
        {
            PUCHAR hdrp, mac_hdrp, tcp_hdrp;
            ULONG  len;
            USHORT sig, group;

            /* Parse the buffers and obtain the length and group information.
             * This is used to update the counters.
             */
            hdrp = Main_frame_parse (ctxtp, newp, & mac_hdrp, 0, & tcp_hdrp, & len,
                                     & sig, & group, FALSE);
            if (hdrp)
            {
                resp -> len   = len;
                resp -> group = group;
            }
        }
        Main_packet_put (ctxtp, newp, FALSE, status);
    }

    return status;

} /* end Prot_transfer */


VOID Prot_cancel_send_packets (
    PMAIN_CTXT        ctxtp,
    PVOID             cancel_id)
{
    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);


    NdisCancelSendPackets (ctxtp -> mac_handle, cancel_id);

    return;
} /* Prot_cancel_send_packets */


#if 0

/*
    This code relies on using the len field in MAIN_PROTOCOL_RESERVED to hold
    the status value passed from Main_send_complete. Uncommenting it in this
    state will break! Note that setting and interlock decrementing of data
    field is commented out in Prot_packets_send and Prot_send_complete.
*/

NDIS_STATUS Prot_send (
    PMAIN_CTXT          ctxtp,
    PNDIS_PACKET        packet,
    UINT                flags)
{
    NDIS_STATUS         status;
    PNDIS_PACKET        newp;
    PMAIN_PROTOCOL_RESERVED resp;
    LONG                lock_value;
    ULONG               exhausted;


    UNIV_ASSERT (ctxtp -> code == MAIN_CTXT_CODE);

    /* V1.1.2 do not accept frames if the card below is resetting */

    if (ctxtp -> reset_state != MAIN_RESET_NONE)
        return NDIS_STATUS_FAILURE;

    newp = Main_send (ctxtp, packet, & exhausted);

    if (newp == NULL)
    {
        if (exhausted)
        {
            UNIV_PRINT (("error xlating packet"));
            ctxtp -> packets_exhausted = TRUE;
            return NDIS_STATUS_RESOURCES;
        }
        else
            return NDIS_STATUS_SUCCESS;
    }

    NdisSetPacketFlags (newp, flags);

    resp = MAIN_PROTOCOL_FIELD (newp);

    /* initialize lock value to 2 so that can distinguish whether or not send
       complete occurred during send to NDIS; see below */

    resp -> data = 2;

    NdisSend (& status, ctxtp -> mac_handle, newp);

    /* atomically decrement and check lock value; Prot_send_complete also
       does this */

    lock_value = InterlockedDecrement (& resp -> data);
    UNIV_ASSERT_VAL (lock_value == 0 || lock_value == 1, lock_value);

    /* if lock value is 1 then Prot_send_complete has not completed and it will later
       call Nic_send_complete and cleanup; otherwise, if lock value is 0,
       Prot_send_complete has run and supplied us with a status to return
       synchronously;

       this handles an apparent bug in which send complete is signalled during the
       send operation but the send returns a pending status anyway */

    if (lock_value == 0)
        status = resp -> len;

    if (status != NDIS_STATUS_PENDING)
    {
        Main_packet_put (ctxtp, newp, TRUE, status);

        if (ctxtp -> packets_exhausted)
        {
            ctxtp -> packets_exhausted = FALSE;
            Nic_sync_queue (ctxtp, Nic_send_resources_signal, ctxtp, TRUE);
        }
    }

    return status;

} /* end Prot_send */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\driver\trace.c ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

	trace.c

Abstract:

	Windows Load Balancing Service (WLBS)
    Driver - support for WMI event tracing

History:

    4/01/01 JosephJ Created

--*/

#define  NLB_TRACING_ENABLED 1

#include <ntddk.h>
#include <wmistr.h>
#include <wlbsparm.h>
#include "trace.h"
#include "trace.tmh"


UINT            Trace_Skip_Initialization = 0;
PDRIVER_OBJECT  Trace_Saved_Driver_Object = NULL;

VOID
Trace_Initialize(
    PVOID                         driver_obj,
    PVOID                         registry_path
    )
{
    if (!Trace_Skip_Initialization)
    {
        PDRIVER_OBJECT DriverObject =  (PDRIVER_OBJECT) driver_obj;
        PUNICODE_STRING RegistryPath  = (PUNICODE_STRING) registry_path;
    
        Trace_Saved_Driver_Object = DriverObject;

        WPP_INIT_TRACING(DriverObject, RegistryPath);
    }
}

VOID
Trace_Deinitialize(VOID)
{
    if (Trace_Saved_Driver_Object != NULL)
    {
        WPP_CLEANUP(Trace_Saved_Driver_Object);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\driver\prot.h ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    prot.h

Abstract:

    Windows Load Balancing Service (WLBS)
    Driver - lower-level (protocol) layer of intermediate miniport

Author:

    kyrilf

--*/


#ifndef _Prot_h_
#define _Prot_h_

#include <ndis.h>

#include "main.h"
#include "util.h"


/* PROCEDURES */


/* required NDIS protocol handlers */

extern VOID Prot_bind (
    PNDIS_STATUS        statusp,
    NDIS_HANDLE         bind_handle,
    PNDIS_STRING        device_name,
    PVOID               reg_path,
    PVOID               reserved);
/*
  Bind to underlying adapter

  returns VOID:

  function:
*/


extern VOID Prot_unbind (
    PNDIS_STATUS        statusp,
    NDIS_HANDLE         bind_handle,
    NDIS_HANDLE         unbind_handle);
/*
  Unbind from underlying adapter

  returns VOID:

  function:
*/


extern VOID Prot_close_complete (
    NDIS_HANDLE         bind_handle,
    NDIS_STATUS         statusp);
/*
  Completion handler for NdisCloseAdapter call

  returns VOID:

  function:
*/


extern VOID Prot_open_complete (
    NDIS_HANDLE         bind_handle,
    NDIS_STATUS         statusp,
    NDIS_STATUS         errorp);
/*
  Completion handler for NdisOpenAdapter call

  returns VOID:

  function:
*/


extern NDIS_STATUS Prot_recv_indicate (
    NDIS_HANDLE         bind_handle,
    NDIS_HANDLE         recv_handle,
    PVOID               head_buf,
    UINT                head_len,
    PVOID               look_buf,
    UINT                look_len,
    UINT                packet_len);
/*
  Process lookahead of a new packet

  returns NDIS_STATUS:

  function:
*/


extern VOID Prot_recv_complete (
    NDIS_HANDLE         bind_handle);
/*
  Handle post-receive operations when timing is relaxed

  returns VOID:

  function:
*/


extern INT Prot_packet_recv (
    NDIS_HANDLE         bind_handle,
    PNDIS_PACKET        packet);
/*
  Receive entire new packet

  returns INT:
    <number of clients using the packet>

  function:
*/


extern VOID Prot_request_complete (
    NDIS_HANDLE         bind_handle,
    PNDIS_REQUEST       request,
    NDIS_STATUS         status);
/*
  Completion handler for NdisRequest call

  returns VOID:

  function:
*/


extern VOID Prot_reset_complete (
    NDIS_HANDLE         bind_handle,
    NDIS_STATUS         status);
/*
  Completion handler for NdisReset call

  returns VOID:

  function:
*/


extern VOID Prot_send_complete (
    NDIS_HANDLE         bind_handle,
    PNDIS_PACKET        packet,
    NDIS_STATUS         status);
/*
  Completion handler for NdiSendPackets or NdisSend calls

  returns VOID:

  function:
*/


extern NDIS_STATUS Prot_PNP_handle (
    NDIS_HANDLE             ctxtp,
    PNET_PNP_EVENT          pnp_event);
/*
  PNP handler

  returns NDIS_STATUS:

  function:
*/


extern VOID Prot_status (
    NDIS_HANDLE         bind_handle,
    NDIS_STATUS         get_status,
    PVOID               stat_buf,
    UINT                stat_len);
/*
  Status indication from adapter handler

  returns VOID:

  function:
*/


extern VOID Prot_status_complete (
    NDIS_HANDLE         bind_handle);
/*
  Status indication from adapter completion handler

  returns VOID:

  function:
*/


extern VOID Prot_transfer_complete (
    NDIS_HANDLE         bind_handle,
    PNDIS_PACKET        packet,
    NDIS_STATUS         status,
    UINT                xferred);
/*
  Completion handler for NdiTransferDate calls

  returns VOID:

  function:
*/


/* helpers for nic layer */


extern NDIS_STATUS Prot_close (
    PMAIN_ADAPTER       adapterp);
/*
  Close underlying connection and free context

  returns NDIS_STATUS:

  function:
*/


extern NDIS_STATUS Prot_request (
    PMAIN_CTXT          ctxtp,
    PMAIN_ACTION        actp,
    ULONG               slave);
/*
  NdisRequest wrapper

  returns NDIS_STATUS:

  function:
*/


extern NDIS_STATUS Prot_reset (
    PMAIN_CTXT          ctxtp);
/*
  NdisRequest wrapper

  returns NDIS_STATUS:

  function:
*/


extern VOID Prot_packets_send (
    PMAIN_CTXT          ctxtp,
    PPNDIS_PACKET       packets,
    UINT                num);
/*
  NdisSendPackets wrapper

  returns NDIS_STATUS:

  function:
*/


extern VOID Prot_return (
    PMAIN_CTXT          ctxtp,
    PNDIS_PACKET        packet);
/*
  NdisReturnPackets wrapper

  returns NDIS_STATUS:

  function:
*/

/* Added from old code for NT 5.1 - ramkrish */
extern NDIS_STATUS Prot_transfer (
    PMAIN_CTXT          ctxtp,
    NDIS_HANDLE         recv_handle,
    PNDIS_PACKET        packet,
    UINT                offset,
    UINT                len,
    PUINT               xferred);
/*
  NdisTransferData wrapper

  returns NDIS_STATUS:

  function:
*/


/* This helper function added for using NDIS51 flag */
extern VOID Prot_cancel_send_packets (
    PMAIN_CTXT          ctxtp,
    PVOID               cancel_id);
/*
  NdisCancelSendPackets wrapper

  returns:

  function:
*/


#if 0 /* old code */

extern NDIS_STATUS Prot_send (
    PMAIN_CTXT          ctxtp,
    PNDIS_PACKET        packet,
    UINT                flags);
/*
  NdisSend wrapper

  returns NDIS_STATUS:

  function:
*/

#endif

#endif /* _Prot_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\driver\util.h ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    util.h

Abstract:

    Windows Load Balancing Service (WLBS)
    Driver - media support definitions

Author:

    kyrilf

--*/


#ifndef _Util_h_
#define _Util_h_

#include <ndis.h>
#include <xfilter.h>

#include "wlbsparm.h"


/* CONSTANTS */


/* media-specific constants */

#define ETHERNET_DESTINATION_FIELD_OFFSET   0
#define ETHERNET_SOURCE_FIELD_OFFSET        6
#define ETHERNET_LENGTH_FIELD_OFFSET        12
#define ETHERNET_LENGTH_FIELD_SIZE          2
#define ETHERNET_ADDRESS_FIELD_SIZE         6
#define ETHERNET_HEADER_SIZE                14

/* flags are in byte 0 of ethernet address */

#define ETHERNET_GROUP_FLAG                 0x1
#define ETHERNET_LAA_FLAG                   0x2

/* max frame size we expect to generate */

#define CVY_MAX_FRAME_SIZE                  1500


/* TYPES */


#pragma pack(1)

/* ethernet media header type */

typedef struct
{
    UCHAR            data [ETHERNET_ADDRESS_FIELD_SIZE];
}
CVY_ETHERNET_ADR, * PCVY_ETHERNET_ADR;

typedef struct
{
    UCHAR            data [ETHERNET_LENGTH_FIELD_SIZE];
}
CVY_ETHERNET_LEN, * PCVY_ETHERNET_LEN;

typedef struct
{
    CVY_ETHERNET_ADR        dst;
    CVY_ETHERNET_ADR        src;
    CVY_ETHERNET_LEN        len;
}
CVY_ETHERNET_HDR, * PCVY_ETHERNET_HDR;

typedef union
{
    CVY_ETHERNET_HDR   ethernet;
}
CVY_MEDIA_HDR, * PCVY_MEDIA_HDR;

typedef union
{
    CVY_ETHERNET_ADR   ethernet;
}
CVY_MAC_ADR, * PCVY_MAC_ADR;

/* V1.3.1b medium independent MAC address manipulation routines - note that these 
   are optimized for speed and assume that all mediums have the same size addresses.
   NOTE: The seemingly silly format of these macros is simply to leave fenceposts
   for the future additions of other supported mediums. */
#define CVY_MAC_SRC_OFF(m)             ((m) == NdisMedium802_3 ? ETHERNET_SOURCE_FIELD_OFFSET : ETHERNET_SOURCE_FIELD_OFFSET)
#define CVY_MAC_DST_OFF(m)             ((m) == NdisMedium802_3 ? ETHERNET_DESTINATION_FIELD_OFFSET : ETHERNET_DESTINATION_FIELD_OFFSET)
#define CVY_MAC_HDR_LEN(m)             ((m) == NdisMedium802_3 ? sizeof (CVY_ETHERNET_HDR) : sizeof (CVY_ETHERNET_HDR))
#define CVY_MAC_ADDR_LEN(m)            ((m) == NdisMedium802_3 ? ETHERNET_ADDRESS_FIELD_SIZE : ETHERNET_ADDRESS_FIELD_SIZE)

#define CVY_MAC_ADDR_BCAST(m,a)        (((PUCHAR)(a))[0] == 0xff)
#define CVY_MAC_ADDR_MCAST(m,a)        (((PUCHAR)(a))[0] & 0x1)
#define CVY_MAC_ADDR_GROUP_SET(m,a)    ((((PUCHAR)(a))[0]) |= 0x1)
#define CVY_MAC_ADDR_GROUP_TOGGLE(m,a) ((((PUCHAR)(a))[0]) ^= 0x1)
#define CVY_MAC_ADDR_LAA_SET(m,a)      ((((PUCHAR)(a))[0]) |= 0x2)
#define CVY_MAC_ADDR_LAA_TOGGLE(m,a)   ((((PUCHAR)(a))[0]) ^= 0x2)
#define CVY_MAC_ADDR_COMP(m,a,b)       ((* (ULONG UNALIGNED *)(a) == * (ULONG UNALIGNED *)(b)) && \
                                        (* (USHORT UNALIGNED *)((PUCHAR)(a) + sizeof (ULONG)) ==    \
                                         * (USHORT UNALIGNED *)((PUCHAR)(b) + sizeof (ULONG))))
#define CVY_MAC_ADDR_COPY(m,d,s)       ((* (ULONG UNALIGNED *)(d) = * (ULONG UNALIGNED *)(s)), \
                                        (* (USHORT UNALIGNED *)((PUCHAR)(d) + sizeof (ULONG)) = \
                                         * (USHORT UNALIGNED *)((PUCHAR)(s) + sizeof (ULONG))))
#if DBG
#define CVY_MAC_ADDR_PRINT(m,s,a)      DbgPrint ("%s %02X-%02X-%02X-%02X-%02X-%02X\n", s, ((PUCHAR)(a))[0], ((PUCHAR)(a))[1], ((PUCHAR)(a))[2], ((PUCHAR)(a))[3], ((PUCHAR)(a))[4], ((PUCHAR)(a))[5])
#else
#define CVY_MAC_ADDR_PRINT(m,s,a)
#endif

/* Medium type field manipulation routines */
#define CVY_ETHERNET_ETYPE_SET(p,l)    ((PUCHAR) (p)) [ETHERNET_LENGTH_FIELD_OFFSET] = (UCHAR) ((l) >> 8); \
                                       ((PUCHAR) (p)) [ETHERNET_LENGTH_FIELD_OFFSET + 1] = (UCHAR) (l)
#define CVY_ETHERNET_ETYPE_GET(p)      (((USHORT) ((PUCHAR) (p)) [ETHERNET_LENGTH_FIELD_OFFSET]) << 8) | \
                                       ((USHORT) ((PUCHAR) (p)) [ETHERNET_LENGTH_FIELD_OFFSET + 1])

#pragma pack()

#endif /* _Util_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\driver\univ.c ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    univ.c

Abstract:

    Windows Load Balancing Service (WLBS)
    Driver - global variables

Author:

    kyrilf

--*/


#include <stdlib.h>
#include <ndis.h>

#include "univ.h"
#include "wlbsparm.h"


/* GLOBALS */

/* The global teaming list spin lock. */
NDIS_SPIN_LOCK          univ_bda_teaming_lock;

// UNIV_ADAPTER            univ_adapters [CVY_MAX_ADAPTERS]; // ###### ramkrish
WCHAR                   empty_str [] = L"";
UNIV_IOCTL_HDLR         univ_ioctl_hdlr = NULL;
PVOID                   univ_driver_ptr = NULL;
NDIS_HANDLE             univ_driver_handle = NULL;
NDIS_HANDLE             univ_wrapper_handle = NULL;
NDIS_HANDLE             univ_prot_handle = NULL;
NDIS_HANDLE             univ_ctxt_handle = NULL;
// ###### ramkrish ULONG                   univ_convoy_enabled;
// ###### ramkrish ULONG                   univ_bound = FALSE;
// ###### ramkrish ULONG                   univ_announced = FALSE;
NDIS_SPIN_LOCK          univ_bind_lock;
ULONG                   univ_changing_ip = 0;

// ###### ramkrish ULONG                   univ_inited = FALSE;
NDIS_HANDLE             univ_device_handle = NULL;
PDEVICE_OBJECT          univ_device_object = NULL;

NDIS_PHYSICAL_ADDRESS   univ_max_addr = NDIS_PHYSICAL_ADDRESS_CONST (-1,-1);
NDIS_MEDIUM             univ_medium_array [UNIV_NUM_MEDIUMS] = UNIV_MEDIUMS;
// ###### ramkrish ULONG                   univ_params_valid = FALSE;
// ###### ramkrish CVY_PARAMS              univ_params;
PWCHAR                  univ_reg_path = NULL;
ULONG                   univ_reg_path_len = 0;
// ###### ramkrish ULONG                   univ_optimized_frags = FALSE;
NDIS_OID                univ_oids [UNIV_NUM_OIDS] =
                                       { OID_GEN_SUPPORTED_LIST,
                                         OID_GEN_HARDWARE_STATUS,
                                         OID_GEN_MEDIA_SUPPORTED,
                                         OID_GEN_MEDIA_IN_USE,
                                         OID_GEN_MAXIMUM_LOOKAHEAD,
                                         OID_GEN_MAXIMUM_FRAME_SIZE,
                                         OID_GEN_LINK_SPEED,
                                         OID_GEN_TRANSMIT_BUFFER_SPACE,
                                         OID_GEN_RECEIVE_BUFFER_SPACE,
                                         OID_GEN_TRANSMIT_BLOCK_SIZE,
                                         OID_GEN_RECEIVE_BLOCK_SIZE,
                                         OID_GEN_VENDOR_ID,
                                         OID_GEN_VENDOR_DESCRIPTION,
                                         OID_GEN_CURRENT_PACKET_FILTER,
                                         OID_GEN_CURRENT_LOOKAHEAD,
                                         OID_GEN_DRIVER_VERSION,
                                         OID_GEN_MAXIMUM_TOTAL_SIZE,
                                         OID_GEN_PROTOCOL_OPTIONS,
                                         OID_GEN_MAC_OPTIONS,
                                         OID_GEN_MEDIA_CONNECT_STATUS,
                                         OID_GEN_MAXIMUM_SEND_PACKETS,
                                         OID_GEN_VENDOR_DRIVER_VERSION,
                                         OID_GEN_XMIT_OK,
                                         OID_GEN_RCV_OK,
                                         OID_GEN_XMIT_ERROR,
                                         OID_GEN_RCV_ERROR,
                                         OID_GEN_RCV_NO_BUFFER,
                                         OID_GEN_DIRECTED_BYTES_XMIT,
                                         OID_GEN_DIRECTED_FRAMES_XMIT,
                                         OID_GEN_MULTICAST_BYTES_XMIT,
                                         OID_GEN_MULTICAST_FRAMES_XMIT,
                                         OID_GEN_BROADCAST_BYTES_XMIT,
                                         OID_GEN_BROADCAST_FRAMES_XMIT,
                                         OID_GEN_DIRECTED_BYTES_RCV,
                                         OID_GEN_DIRECTED_FRAMES_RCV,
                                         OID_GEN_MULTICAST_BYTES_RCV,
                                         OID_GEN_MULTICAST_FRAMES_RCV,
                                         OID_GEN_BROADCAST_BYTES_RCV,
                                         OID_GEN_BROADCAST_FRAMES_RCV,
                                         OID_GEN_RCV_CRC_ERROR,
                                         OID_GEN_TRANSMIT_QUEUE_LENGTH,
                                         OID_802_3_PERMANENT_ADDRESS,
                                         OID_802_3_CURRENT_ADDRESS,
                                         OID_802_3_MULTICAST_LIST,
                                         OID_802_3_MAXIMUM_LIST_SIZE,
                                         OID_802_3_MAC_OPTIONS,
                                         OID_802_3_RCV_ERROR_ALIGNMENT,
                                         OID_802_3_XMIT_ONE_COLLISION,
                                         OID_802_3_XMIT_MORE_COLLISIONS,
                                         OID_802_3_XMIT_DEFERRED,
                                         OID_802_3_XMIT_MAX_COLLISIONS,
                                         OID_802_3_RCV_OVERRUN,
                                         OID_802_3_XMIT_UNDERRUN,
                                         OID_802_3_XMIT_HEARTBEAT_FAILURE,
                                         OID_802_3_XMIT_TIMES_CRS_LOST,
                                         OID_802_3_XMIT_LATE_COLLISIONS };


/* PROCEDURES */


VOID Univ_ndis_string_alloc (
    PNDIS_STRING            string,
    PCHAR                   src)
{
    PWCHAR                  tmp;


    /* allocate enough space for the string */

    string -> Length = strlen (src) * sizeof (WCHAR);
    string -> MaximumLength = string -> Length + sizeof (WCHAR);

    NdisAllocateMemoryWithTag (& (string -> Buffer), string -> MaximumLength,
                               UNIV_POOL_TAG);

    if (string -> Buffer == NULL)
    {
        string -> Length = 0;
        string -> MaximumLength = 0;
        return;
    }

    /* copy characters */

    tmp = string -> Buffer;

    while (* src != '\0')
    {
        * tmp = (WCHAR) (* src);
        src ++;
        tmp ++;
    }

    * tmp = UNICODE_NULL;

} /* end Univ_ndis_string_free */


VOID Univ_ndis_string_free (
    PNDIS_STRING            string)
{
    if (string -> Buffer == NULL)
        return;

    /* free memory */

    NdisFreeMemory (string -> Buffer, string -> MaximumLength, 0);
    string -> Length = 0;
    string -> MaximumLength = 0;

} /* end Univ_ndis_string_free */


VOID Univ_ansi_string_alloc (
    PANSI_STRING            string,
    PWCHAR                  src)
{
    PCHAR                   tmp;
    PWCHAR                  wtmp;
    USHORT                  len;


    /* compute length of the string in characters */

    wtmp = src;
    len = 0;

    while (* wtmp != UNICODE_NULL)
    {
        len ++;
        wtmp ++;
    }

    /* allocate enough space for the string */

    string -> Length = len;
    string -> MaximumLength = len + sizeof (CHAR);

    NdisAllocateMemoryWithTag (& (string -> Buffer), string -> MaximumLength,
                               UNIV_POOL_TAG);

    if (string -> Buffer == NULL)
    {
        string -> Length = 0;
        string -> MaximumLength = 0;
        return;
    }

    /* copy characters */

    tmp = string -> Buffer;

    while (* src != '\0')
    {
        * tmp = (CHAR) (* src);
        src ++;
        tmp ++;
    }

    * tmp = 0;

} /* end Univ_ansi_string_free */


VOID Univ_ansi_string_free (
    PANSI_STRING        string)
{
    if (string == NULL)
        return;

    /* free memory */

    NdisFreeMemory (string -> Buffer, string -> MaximumLength, 0);
    string -> Length = 0;
    string -> MaximumLength = 0;

} /* end Univ_ansi_string_free */


ULONG   Univ_str_to_ulong (
    PULONG          retp,
    PWCHAR          start_ptr,
    PWCHAR *        end_ptr,
    ULONG           width,
    ULONG           base)
{
    PWCHAR          ptr;
    WCHAR           c;
    ULONG           number = 0;
    ULONG           val, pos = 0;


    /* check base */

    if (base != 2 && base != 8 && base != 10 && base != 16)
    {
        if (end_ptr != NULL)
            * end_ptr = start_ptr;

        return FALSE;
    }

    /* skip space */

    ptr = start_ptr;
    number = 0;

    while (* ptr == 0x20)
        ptr ++;

    /* extract digits and build the number */

    while (pos < width)
    {
        c = * ptr;

        if (0x30 <= c && c <= 0x39)
            val = c - 0x30;
        else if (0x41 <= c && c <= 0x46)
            val = c - 0x41 + 0xa;
        else if (0x61 <= c && c <= 0x66)
            val = c - 0x61 + 0xa;
        else
            break;

        if (val >= base)
            break;

        number = number * base + val;

        ptr ++;
        pos ++;
    }

    /* makre sure we extracted something */

    if (pos == 0)
    {
        ptr = start_ptr;
        * retp = 0;
        return FALSE;
    }

    /* return resulting number */

    if (end_ptr != NULL)
        * end_ptr = ptr;

    * retp = number;
    return TRUE;

} /* end Univ_str_to_ulong */


PWCHAR Univ_ulong_to_str (
    ULONG           val,
    PWCHAR          buf,
    ULONG           base)
{
    ULONG           dig;
    PWCHAR          p, sav;
    WCHAR           tmp;


    /* check base */

    if (base != 2 && base != 8 && base != 10 && base != 16)
    {
        buf [0] = 0;
        return buf;
    }

    /* extract digits from the number and output to string */

    p = buf;

    do
    {
        /* get next digit */

        dig = (ULONG) (val % base);
        val /= base;

        /* convert to ascii and store */

        if (dig > 9)
            * p = (CHAR) (dig - 10 + L'a');
        else
            * p = (CHAR) (dig + L'0');

        p ++;
    }
    while (val > 0);

    * p = 0;
    sav = p;

    /* swap the characters, since operation above creates inverted string */

    p --;

    do
    {
        tmp = * p;
        * p = * buf;
        * buf = tmp;
        p --; buf ++;
    }
    while (buf < p);       /* repeat until halfway */

    return sav;

} /* end Univ_ulong_to_str */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\inc\tracelog.h ===
#pragma once

#ifdef __cplusplus
extern "C" {
#endif


#include <windows.h>
#include <winbase.h>
#include <rtutils.h>

#define TL_ERROR ((DWORD)0x00010000 | TRACE_USE_MASK)
#define TL_WARN  ((DWORD)0x00020000 | TRACE_USE_MASK)
#define TL_INFO  ((DWORD)0x00040000 | TRACE_USE_MASK)
//    #define TL_TRACE ((DWORD)0x00080000 | TRACE_USE_MASK)
//    #define TL_EVENT ((DWORD)0x00100000 | TRACE_USE_MASK)

BOOL  TRACELogRegister(LPCTSTR szName);
void  TRACELogDeRegister();
void  TRACELogPrint(IN DWORD dwDbgLevel, IN LPCSTR DbgMessage, IN ...);


#define LOG_ERROR(pszFmt)                    TRACELogPrint(TL_ERROR, pszFmt)
#define LOG_ERROR1(pszFmt, arg1)             TRACELogPrint(TL_ERROR, pszFmt, arg1)
#define LOG_ERROR2(pszFmt, arg1, arg2)       TRACELogPrint(TL_ERROR, pszFmt, arg1, arg2)
#define LOG_ERROR3(pszFmt, arg1, arg2, arg3) TRACELogPrint(TL_ERROR, pszFmt, arg1, arg2, arg3)

#define LOG_WARN(pszFmt)                    TRACELogPrint(TL_WARN, pszFmt)
#define LOG_WARN1(pszFmt, arg1)             TRACELogPrint(TL_WARN, pszFmt, arg1)
#define LOG_WARN2(pszFmt, arg1, arg2)       TRACELogPrint(TL_WARN, pszFmt, arg1, arg2)
#define LOG_WARN3(pszFmt, arg1, arg2, arg3) TRACELogPrint(TL_WARN, pszFmt, arg1, arg2, arg3)

#define LOG_INFO(pszFmt)                    TRACELogPrint(TL_INFO, pszFmt)
#define LOG_INFO1(pszFmt, arg1)             TRACELogPrint(TL_INFO, pszFmt, arg1)
#define LOG_INFO2(pszFmt, arg1, arg2)       TRACELogPrint(TL_INFO, pszFmt, arg1, arg2)
#define LOG_INFO3(pszFmt, arg1, arg2, arg3) TRACELogPrint(TL_INFO, pszFmt, arg1, arg2, arg3)


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\inc\debug.h ===
#ifndef DEBUG_H
#define DEBUG_H

#ifdef __cplusplus
extern "C" {
#endif

#include <windows.h>


//
// Macros for debugging support.
//
// ASSERT(exp)   Popup a dialogbox, if exp is FALSE
// ASSERTMSG(exp, msg)  Similar to ASSERT.  Except the msg is displayed instead of the expression
//
// Use TRACE(x) for output, where x is a list of printf()-style parameters.  
//     TRACEn() is TRACE with n printf arguments
//     For example, TRACE2("This shows how to print stuff, like a string %s, and a number %u.","string",5);
//
// USE VERIFY for expressions executed for both debug and release version
//

#undef ASSERT
#undef ASSERTMSG

/*
//
// Used by atl
//
#ifdef _ATL_NO_DEBUG_CRT
#define _ASSERTE ASSERT
#define _ASSERT ASSERT
#endif
*/

//
// Trace out the function name
//
#ifdef ENABLE_PROFILE
#define PROFILE(pszFunctionName) TRACE(pszFunctionName)
#else
#define PROFILE(pszFunctionName) ((void)0)
#endif

//
// Define TRACE here. 
//

#define TRACE_INFO  TRACE
#define TRACE_INFO1 TRACE1
#define TRACE_INFO2 TRACE2
#define TRACE_INFO3 TRACE3

#define TRACE_ERROR  TRACE
#define TRACE_ERROR1 TRACE1
#define TRACE_ERROR2 TRACE2
#define TRACE_ERROR3 TRACE3

#ifdef DBG
#define DEBUG
#endif

#if	( defined(DEBUG) || defined(_DEBUG) )

extern "C" void TraceMessageA(const CHAR *pszFmt, ...) ;

#define TRACE(pszFmt)                    TraceMessageA(pszFmt)
#define TRACE1(pszFmt, arg1)             TraceMessageA(pszFmt, arg1)
#define TRACE2(pszFmt, arg1, arg2)       TraceMessageA(pszFmt, arg1, arg2)
#define TRACE3(pszFmt, arg1, arg2, arg3) TraceMessageA(pszFmt, arg1, arg2, arg3)

#else

#define TRACE(pszFmt)       ((void)0)             
#define TRACE1(pszFmt, arg1)    ((void)0)             
#define TRACE2(pszFmt, arg1, arg2)  ((void)0)       
#define TRACE3(pszFmt, arg1, arg2, arg3)    ((void)0)

#endif  

#if	( defined(DEBUG) || defined(_DEBUG))

#ifdef UNICODE
#define AssertMessage AssertMessageW
#else
#define AssertMessage AssertMessageA
#endif

void AssertMessage(const TCHAR *pszFile, unsigned nLine, const TCHAR *pszMsg);

#define ASSERT(x)		(void)((x) || (AssertMessage(TEXT(__FILE__),__LINE__,TEXT(#x)),0))
#define ASSERTMSG(exp, msg)   (void)((exp) || (AssertMessage(TEXT(__FILE__),__LINE__,msg),0))

#define VERIFY(x)		    ASSERT(x)

// {ASSERT(pObj);pObj->AssertValid();} 
#define ASSERT_VALID(pObj) ((ASSERT(pObj),1) && ((pObj)->AssertValid(),1))

#else // DEBUG

#define ASSERT_VALID(pObj) 
#define ASSERT(x)           ((void)0)
#define ASSERTMSG(exp, msg) ((void)0)
#define VERIFY(x)           (x)       
#endif

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\inc\wlbsiocl.h ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

	wlbsiocl.h

Abstract:

	Windows Load Balancing Service (WLBS)
    IOCTL and remote control specifications

Author:

    kyrilf

Environment:


Revision History:


--*/

#ifndef _Wlbsiocl_h_
#define _Wlbsiocl_h_

#ifdef KERNEL_MODE

#include <ndis.h>
#include <ntddndis.h>
#include <devioctl.h>
typedef BOOLEAN BOOL;

#else

#include <windows.h>
#include <winioctl.h>

#endif

#include "wlbsparm.h"

/* these are not strictly parameters, but this is a good place to put them, since this file is shared among user and kernel modes */

/* Microsoft says that this value should be in the range 32768-65536 */
#define CVY_DEVICE_TYPE                 0xc0c0

#define IOCTL_CVY_CLUSTER_ON            CTL_CODE(CVY_DEVICE_TYPE, 1, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_CVY_CLUSTER_OFF           CTL_CODE(CVY_DEVICE_TYPE, 2, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_CVY_PORT_ON               CTL_CODE(CVY_DEVICE_TYPE, 3, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_CVY_PORT_OFF              CTL_CODE(CVY_DEVICE_TYPE, 4, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_CVY_QUERY                 CTL_CODE(CVY_DEVICE_TYPE, 5, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_CVY_RELOAD                CTL_CODE(CVY_DEVICE_TYPE, 6, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_CVY_PORT_SET              CTL_CODE(CVY_DEVICE_TYPE, 7, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_CVY_PORT_DRAIN            CTL_CODE(CVY_DEVICE_TYPE, 8, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_CVY_CLUSTER_DRAIN         CTL_CODE(CVY_DEVICE_TYPE, 9, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_CVY_CLUSTER_PLUG          CTL_CODE(CVY_DEVICE_TYPE, 10, METHOD_BUFFERED, FILE_ANY_ACCESS) /* Internal only - passed from main.c to load.c when a start interrupts a drain. */
#define IOCTL_CVY_CLUSTER_SUSPEND       CTL_CODE(CVY_DEVICE_TYPE, 11, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_CVY_CLUSTER_RESUME        CTL_CODE(CVY_DEVICE_TYPE, 12, METHOD_BUFFERED, FILE_ANY_ACCESS)
#define IOCTL_CVY_QUERY_STATE           CTL_CODE(CVY_DEVICE_TYPE, 13, METHOD_BUFFERED, FILE_ANY_ACCESS)
#if defined (NLB_SESSION_SUPPORT)
#define IOCTL_CVY_CONNECTION_NOTIFY     CTL_CODE(CVY_DEVICE_TYPE, 14, METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif
#if defined (SBH)
#define IOCTL_CVY_QUERY_PERF            CTL_CODE(CVY_DEVICE_TYPE, 15, METHOD_BUFFERED, FILE_ANY_ACCESS)
#endif

#define IOCTL_CVY_OK                    0
#define IOCTL_CVY_ALREADY               1
#define IOCTL_CVY_BAD_PARAMS            2
#define IOCTL_CVY_NOT_FOUND             3
#define IOCTL_CVY_STOPPED               4
#define IOCTL_CVY_CONVERGING            5
#define IOCTL_CVY_SLAVE                 6
#define IOCTL_CVY_MASTER                7
#define IOCTL_CVY_BAD_PASSWORD          8
#define IOCTL_CVY_DRAINING              9
#define IOCTL_CVY_DRAINING_STOPPED      10
#define IOCTL_CVY_SUSPENDED             11
#define IOCTL_CVY_DISCONNECTED          12

#define IOCTL_REMOTE_CODE               0xb055c0de
#define IOCTL_REMOTE_VR_PASSWORD        L"b055c0de"
#define IOCTL_REMOTE_VR_CODE            0x9CD8906E
#define IOCTL_REMOTE_SEND_RETRIES       5
#define IOCTL_REMOTE_RECV_DELAY         100
#define IOCTL_REMOTE_RECV_RETRIES       20

#define IOCTL_MASTER_HOST               0           /* MASTER_HOST host id */
#define IOCTL_ALL_HOSTS                 0xffffffff  /* ALL_HOSTS host id */
#define IOCTL_ALL_PORTS                 0xffffffff  /* Apply to all port rules. */
#define IOCTL_ALL_VIPS                  0x00000000  /* For virtual clusters, this is the ALL VIP specification for disable/enable/drain 
                                                       (including both specific VIP and "ALL VIP" port rules). */

#define CVY_MAX_DEVNAME_LEN             48          /* The actual length of \device\guid is 46, but 48 was chosen for word alignment. */

/* These flags indicate which options are being used/specified and/or additional information for the remote protocol. */

/* For queries. */
#define IOCTL_OPTIONS_QUERY_CLUSTER_MEMBER   0x00000001 /* The initiator is part of the cluster it is querying. */
#define IOCTL_OPTIONS_QUERY_HOSTNAME         0x00000002 /* Return the hostname when a remote query is performed. */

/* For port rule operations. */
#define IOCTL_OPTIONS_PORTS_VIP_SPECIFIED    0x00000001 /* A VIP has been specified to check against. */

/* For state queries. */

#if defined (SBH)
//
// For IOCTL_CVY_QUERY_PERF
//
typedef struct 
{
    USHORT QueryState;   // same as IOCTL_CVY_BUF::data.query.state
    USHORT HostId;
    ULONG  HostMap;
    
    //
    // Heartbeat including ethernet header
    //

    UCHAR       EthernetDstAddr[6];
    UCHAR       EthernetSrcAddr[6];

    ULONG       HeartbeatVersion;   
    ULONG       ClusterIp;         
    ULONG       DedicatedIp;
    
    USHORT      master_id;  
    USHORT      state;                      /* my host's state */
    USHORT      nrules;                     /* # active rules */
    ULONG       UniqueCode;                 /* unique host code */
    ULONG       pkt_count;                  // Count of packets handled since cvg'd 
                                            // Updated only during convergence
    ULONG       teaming;                    /* Includes BDA teaming configuration. */
    ULONG       reserved2;
    ULONG       rcode[CVY_MAX_RULES];       /* rule code */
    ULONGLONG   cur_map[CVY_MAX_RULES];     /* my current load map for each port group */
    ULONGLONG   new_map[CVY_MAX_RULES];     /* my new load map for each port group */
                                            /* if converging */
    ULONGLONG   idle_map[CVY_MAX_RULES];    /* map of idle bins for each port group */
    ULONGLONG   rdy_bins[CVY_MAX_RULES];    /* my rdy to send bins for each port group */
    ULONG       load_amt[CVY_MAX_RULES];    /* my load amount for each port group */
    ULONG       pg_rsvd1[CVY_MAX_RULES];    /* reserved */

    //
    // Load module
    //
    ULONG       Convergence;
    ULONG       nDescAllocated;
    ULONG       nDescInUse;
    ULONG       PacketCount;
    ULONGLONG   AllIdleMap[CVY_MAX_RULES];
    ULONGLONG   CurrentMap[CVY_MAX_RULES][CVY_MAX_HOSTS];
    ULONG       DirtyClientWaiting;
}CVY_DRIVER_PERF, *PCVY_DRIVER_PERF;
#endif /* SBH */

#pragma pack(1)

typedef enum {
    NLB_CONN_UP = 0,
    NLB_CONN_DOWN,
    NLB_CONN_RESET
} NLB_CONN_NOTIFICATION_OPERATION;

#if defined (NLB_SESSION_SUPPORT)

#define NLB_ERROR_SUCCESS           0x00000000
#define NLB_ERROR_GENERIC_FAILURE   0x00000001
#define NLB_ERROR_INVALID_PARAMETER 0x00000002
#define NLB_ERROR_REQUEST_REFUSED   0x00000003
#define NLB_ERROR_NOT_BOUND         0x00000004
#define NLB_ERROR_NOT_FOUND         0x00000005

/* IOCTL input buffer for connection notification from user space. */
typedef struct {
    ULONG                           ReturnCode;     /* The status of the operation upon return. */
    ULONG                           Version;        /* The version number for checking between user and kernel space. */
    NLB_CONN_NOTIFICATION_OPERATION Operation;      /* The operation to perform - UP/DOWN/RESET. */    

    ULONG  ClientIPAddress;                         /* The IP address of the client in network byte order. */
    ULONG  ServerIPAddress;                         /* The IP address of the server in network byte order. */
    USHORT ClientPort;                              /* The client port number. */
    USHORT ServerPort;                              /* The server port number. */
    USHORT Protocol;                                /* The protocol of the packet in question. */
    USHORT Reserved;                                /* For byte alignment - reserved for later. */
} IOCTL_CONN_NOTIFICATION, * PIOCTL_CONN_NOTIFICATION;
#endif

#define NLB_QUERY_STATE_SUCCESS 1500
#define NLB_QUERY_STATE_FAILURE 1501

/* These are the supported state query operations. */
typedef enum {
    NLB_QUERY_REG_PARAMS = 0,                       /* Retrieve the registry parameters from the driver state. */
    NLB_QUERY_PORT_RULE_STATE,                      /* Retrieve the current port rule state. */
    NLB_QUERY_BDA_TEAM_STATE,                       /* Retrieve the current BDA teaming state. */
    NLB_QUERY_PACKET_STATISTICS,                    /* Retrieve the current packet handling statistics. */
    NLB_QUERY_PACKET_FILTER                         /* Retrieve packet filtering information. */
} NLB_QUERY_STATE_OPERATION;

/* These are the possible responses from the load packet filter
   state query, which returns accept/reject status for a given
   IP tuple and protocol, based on the current driver state. */
typedef enum {
    NLB_REJECT_LOAD_MODULE_INACTIVE = 0,            /* Packet rejected because the load module is inactive. */
    NLB_REJECT_CLUSTER_STOPPED,                     /* Packet rejected because NLB is stopped on this adapter. */
    NLB_REJECT_PORT_RULE_DISABLED,                  /* Packet rejected because the applicable port rule's filtering mode is disabled. */
    NLB_REJECT_CONNECTION_DIRTY,                    /* Packet rejected because the connection was marked dirty.  */
    NLB_REJECT_OWNED_ELSEWHERE,                     /* Packet rejected because the packet is owned by another host.  */
    NLB_REJECT_BDA_TEAMING_REFUSED,                 /* Packet rejected because BDA teaming refused to process it. */
    NLB_ACCEPT_UNCONDITIONAL_OWNERSHIP,             /* Packet accepted because this host owns it unconditionally (optimized mode). */
    NLB_ACCEPT_FOUND_MATCHING_DESCRIPTOR,           /* Packet accepted because we found a matching connection descriptor. */
    NLB_ACCEPT_PASSTHRU_MODE,                       /* Packet accepted because the cluster is in passthru mode. */
    NLB_ACCEPT_DIP_OR_BROADCAST,                    /* Packet accepted because its was sent to a bypassed address. */
    NLB_ACCEPT_REMOTE_CONTROL_REQUEST,              /* Packet accepted because it is an NLB remote control packet. */
    NLB_ACCEPT_REMOTE_CONTROL_RESPONSE              /* Packet accepted because it is an NLB remote control packet. */
} NLB_QUERY_PACKET_FILTER_RESPONSE;

/* This structure is used to query packet filtering information from the driver
   about a particular connection.  Given a IP tuple (client IP, client port, 
   server IP, server port) and a protocol, determine whether or not this host 
   would accept the packet and why or why not. It is important that this is 
   performed completely unobtrusively and has no side-effects on the actual 
   operation of NLB and the load module. */
typedef struct {
    ULONG  ClientIPAddress;                         /* The IP address of the client in network byte order. */
    ULONG  ServerIPAddress;                         /* The IP address of the server in network byte order. */
    USHORT ClientPort;                              /* The client port number. */
    USHORT ServerPort;                              /* The server port number. */
    USHORT Protocol;                                /* The protocol of the packet in question. */
    USHORT Reserved;                                /* For byte alignment - reserved for later. */
    
    struct {
        NLB_QUERY_PACKET_FILTER_RESPONSE Accept;    /* The response - reason for accepting or rejecting the packet. */
        
        struct {
            USHORT        Valid;                    /* Whether or not the driver has filled in the descriptor information. */
            USHORT        Reserved;                 /* For byte alignment - reserved for later. */
            USHORT        Alloc;                    /* Whether this descriptor is from the hash table or queue. */
            USHORT        Dirty;                    /* Whether this connection is dirty or not. */
            ULONG         FinCount;                 /* The number of FINs seen on this connection - TCP only. */
        } DescriptorInfo;

        struct {
            USHORT        Valid;                    /* Whether or not the driver has filled in the hashing information. */
            USHORT        Reserved;                 /* For byte alignment - reserved for later. */
            ULONG         Bin;                      /* The "bucket" which this tuple mapped to - from 0 to 59. */
            ULONG         ActiveConnections;        /* The number of active connections on this "bucket". */
            ULONGLONG     CurrentMap;               /* The current "bucket" map for the applicable port rule. */
            ULONGLONG     AllIdleMap;               /* The all idle "bucket" map for the applicable port rule. */
        } HashInfo;
    } Results;
} IOCTL_QUERY_STATE_PACKET_FILTER, * PIOCTL_QUERY_STATE_PACKET_FILTER;

/* This structure is used by all query state IOCTLS to retrieve the specified
   state information from the driver, including load module state, port rule
   state, packet statistics and BDA teaming. */
typedef struct {
    ULONG                               ReturnCode; /* The status of the operation upon return. */
    ULONG                               Version;    /* The version number for checking between user and kernel space. */
    NLB_QUERY_STATE_OPERATION           Operation;  /* The operation to perform. */
    
    union {
        IOCTL_QUERY_STATE_PACKET_FILTER Filter;     /* The input/output buffer for packet filter queries. */
    };
} IOCTL_QUERY_STATE, * PIOCTL_QUERY_STATE;

/* This structure is used by most of the existing IOCTL and remote control operations,
   including queries, cluster control and port rule control. */
typedef union
{
    ULONG          ret_code;
    union {
        struct {
            USHORT state;
            USHORT host_id;
            ULONG  host_map;
        } query;
        struct {
            ULONG  load;
            ULONG  num;
        } port;
    } data;
} IOCTL_CVY_BUF, * PIOCTL_CVY_BUF;

/* This structure is used by IOCTL and remote control operations to provide extended 
   functionality beyond the legacy remote control protocol, which MUST remain backward 
   compatible with NT 4.0 and Windows 2000. */
typedef union {
    UCHAR reserved[256];                            /* Bite the bullet and reserve 256 bytes to allow for future expansion. */

    union {
        struct
        {
            ULONG flags;                            /* These flags indicate which options fields have been specified. */
            WCHAR hostname[CVY_MAX_HOST_NAME + 1];  /* Host name filled in by NLB on remote control reply. */
        } query;
        struct
        {
            ULONG flags;                            /* These flags indicate which options fields have been specified. */
            ULONG virtual_ip_addr;                  /* For virtual clusters, the VIP, which can be 0x00000000, 0xffffffff or a specific VIP. */
        } port;
        struct
        {
            ULONG flags;                            /* These flags indicate which options fields have been specified. */
            IOCTL_QUERY_STATE query;                /* This is the input/output buffer for querying driver state. */
        } state;
#if defined (NLB_SESSION_SUPPORT)
        struct
        {
            ULONG flags;                            /* These flags indicate which options fields have been specified. */
            IOCTL_CONN_NOTIFICATION conn;           /* The input/output buffer for connection notifications from upper-layer protocols. */
        } notify;
#endif
    };
} IOCTL_OPTIONS, * PIOCTL_OPTIONS;

typedef struct {
    WCHAR         device_name[CVY_MAX_DEVNAME_LEN]; /* Identifies the adapter. */
    IOCTL_CVY_BUF ctrl;                             /* The IOCTL information. */
    IOCTL_OPTIONS options;                          /* Optionally specified parameters. */
} IOCTL_LOCAL_HDR, * PIOCTL_LOCAL_HDR;

/* These macros define the remote control packets lengths based on Windows and NLB versions,
   so that error checking can be done upon the reception of a remote control packet. */
#define NLB_MIN_RCTL_PACKET_LEN(ip_hdrp)   ((sizeof(ULONG) * IP_GET_HLEN(ip_hdrp)) + sizeof(UDP_HDR) + sizeof(IOCTL_REMOTE_HDR) - sizeof(IOCTL_OPTIONS))
#define NLB_NT40_RCTL_PACKET_LEN(ip_hdrp)  ((sizeof(ULONG) * IP_GET_HLEN(ip_hdrp)) + sizeof(UDP_HDR) + sizeof(IOCTL_REMOTE_HDR) - sizeof(IOCTL_OPTIONS))
#define NLB_WIN2K_RCTL_PACKET_LEN(ip_hdrp) ((sizeof(ULONG) * IP_GET_HLEN(ip_hdrp)) + sizeof(UDP_HDR) + sizeof(IOCTL_REMOTE_HDR) - sizeof(IOCTL_OPTIONS))
#define NLB_WINXP_RCTL_PACKET_LEN(ip_hdrp) ((sizeof(ULONG) * IP_GET_HLEN(ip_hdrp)) + sizeof(UDP_HDR) + sizeof(IOCTL_REMOTE_HDR))
#define NLB_MAX_RCTL_PACKET_LEN(ip_hdrp)   ((sizeof(ULONG) * IP_GET_HLEN(ip_hdrp)) + sizeof(UDP_HDR) + sizeof(IOCTL_REMOTE_HDR))

/* This structure is the UDP data for NLB remote control messages. */
typedef struct {
    ULONG         code;                             /* Distinguishes remote packets. */
    ULONG         version;                          /* Software version. */
    ULONG         host;                             /* Destination host (0 or cluster IP address for master). */
    ULONG         cluster;                          /* Primary cluster IP address. */
    ULONG         addr;                             /* Dedicated IP address on the way back, client IP address on the way in. */
    ULONG         id;                               /* Message ID. */
    ULONG         ioctrl;                           /* IOCTRL code. */
    IOCTL_CVY_BUF ctrl;                             /* Control buffer. */
    ULONG         password;                         /* Encoded password. */
    IOCTL_OPTIONS options;                          /* Optionally specified parameters. */
} IOCTL_REMOTE_HDR, * PIOCTL_REMOTE_HDR;

#pragma pack()

#endif /* _Wlbsiocl_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\driver\univ.h ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    univ.h

Abstract:

    Windows Load Balancing Service (WLBS)
    Driver - global definitions

Author:

    kyrilf

--*/

#ifndef _Univ_h_
#define _Univ_h_

#include <ndis.h>

#include "wlbsparm.h"


/* CONSTANTS */


/* debugging constants and macros */

#undef ASSERT
#define ASSERT(v)


#if DBG

#define UNIV_TODO(s)                DbgPrint ("Convoy ToDo (%s, %d) - %s\n", __FILE__, __LINE__, s)
#define UNIV_PRINT(msg)             { DbgPrint ("Convoy [%d @ %s] ", \
                                               __LINE__, __FILE__); \
                                      DbgPrint msg; DbgPrint ("\n"); }

#define UNIV_DBG_ASSERT(c,m,d1,d2)  if (!(c)) { DbgPrint ("Convoy (%s) [%X, %X] failed [%d @ %s] ", \
                                               #c, d1, d2, __LINE__, __FILE__); \
                                     DbgPrint m; DbgPrint ("\n"); }


#define CVY_ASSERT_CODE             0xbfc0a55e

#define UNIV_ASSERT(c)              if (!(c)) \
                                        KeBugCheckEx (CVY_ASSERT_CODE, \
                                                  log_module_id, __LINE__, \
                                                  0, 0);

#define UNIV_ASSERT_VAL(c,v)        if (!(c)) \
                                        KeBugCheckEx (CVY_ASSERT_CODE, \
                                                  log_module_id, __LINE__, \
                                                  v, 0);
#define UNIV_ASSERT_VAL2(c,v1,v2)   if (!(c)) \
                                        KeBugCheckEx (CVY_ASSERT_CODE, \
                                                  log_module_id, __LINE__, \
                                                  v1, v2);

/* TRACE_... defines below toggle emmition of particular types of debug
   output */

/* enabled trace types */

#define TRACE_PARAMS        /* registry parameter initialization (params.c) */
#define TRACE_RCT           /* remote control request processing (main.c) */
#define TRACE_RCVRY         /* packet filtering (load.c) */
#define TRACE_FRAGS         /* IP packet fragmentation (main.c) */

/* disabled trace types */

#if 0

#define TRACE_GRE           /* GRE packet processing (main.c) */
#define TRACE_IPSEC         /* IPSEC packet processing (main.c) */
#define TRACE_TCP           /* TCP packet processing (main.c) */
#define TRACE_UDP           /* UDP packet processing (main.c) */
#define TRACE_ARP           /* ARP packet processing (main.c) */
#define TRACE_OID           /* OID info/set requests (nic.c) */
#define TRACE_DIRTY         /* dirty connection processing (load.c) */
#define TRACE_IP            /* IP packet processing (main.c) */
#define TRACE_CVY           /* Convoy packet processing (main.c) */

#define TRACE_CNCT          /* TCP connection boundaries (main.c) */
#define TRACE_LOAD          /* packet filtering (load.c) */

#define PERIODIC_RESET      /* reset underlying NIC periodically for testing
                               see main.c, prot.c for usage */
#define NO_CLEANUP          /* do not cleanup host map (load.c) */

#endif

#else /* DBG */

#define UNIV_TODO(s)
#define UNIV_PRINT(msg)
#define UNIV_DBG_ASSERT(c,m,d1,d2)
#define UNIV_ASSERT(c)
#define UNIV_ASSERT_VAL(c,v)
#define UNIV_ASSERT_VAL2(c,v1,v2)

#endif /* DBG */

#define UNIV_POOL_TAG               'SBLW'

/* constants for some NDIS routines */

#define UNIV_WAIT_TIME              0
#define UNIV_NDIS_MAJOR_VERSION_OLD 4
#define UNIV_NDIS_MAJOR_VERSION     5 /* #ps# */
#define UNIV_NDIS_MINOR_VERSION     1 /* NT 5.1 */

/* Convoy protocol name to be reported to NDIS during binding */

#define UNIV_NDIS_PROTOCOL_NAME     NDIS_STRING_CONST ("WLBS")

/* supported medium types */

#define UNIV_NUM_MEDIUMS            1
#define UNIV_MEDIUMS                { NdisMedium802_3 }

/* number of supported OIDs (some are supported by Convoy directly and some
   are passed down to the underlying drivers) */

#define UNIV_NUM_OIDS               56


/* TYPES */

/* some procedure types */

typedef VOID (* UNIV_SYNC_CALLB) (NDIS_HANDLE, PVOID);
typedef NDIS_STATUS (* UNIV_IOCTL_HDLR) (PVOID, PVOID);


/* GLOBALS */

/* The global teaming list spin lock. */
extern NDIS_SPIN_LOCK      univ_bda_teaming_lock;

// extern UNIV_ADAPTER        univ_adapters [CVY_MAX_ADAPTERS]; /* list of adapters */
extern UNIV_IOCTL_HDLR     univ_ioctl_hdlr;     /* preserved NDIS IOCTL handler */
extern PVOID               univ_driver_ptr;     /* driver pointer passed during
                                                   initialization */
extern NDIS_HANDLE         univ_driver_handle;  /* driver handle */
extern NDIS_HANDLE         univ_wrapper_handle; /* NDIS wrapper handle */
extern NDIS_HANDLE         univ_prot_handle;    /* NDIS protocol handle */
extern NDIS_HANDLE         univ_ctxt_handle;    /* Convoy context handle */
// ###### ramkrish extern ULONG               univ_convoy_enabled; /* clustering mode enabled */
extern PWSTR               univ_reg_path;       /* registry path name passed
                                                   during initialization */
extern ULONG               univ_reg_path_len;
// ###### ramkrish extern ULONG               univ_bound;          /* Convoy has been bound into
//                                                   the network stack */
// ###### ramkrish extern ULONG               univ_announced;      /* TCP/IP has been bound to
//                                                   Convoy */
extern NDIS_SPIN_LOCK      univ_bind_lock;      /* protects access to univ_bound
                                                    and univ_announced */
extern ULONG               univ_changing_ip;    /* IP address change in process */
// ###### ramkrish extern ULONG               univ_inited;         /* context initialized */
extern NDIS_PHYSICAL_ADDRESS univ_max_addr;     /* maximum physical address
                                                   constant to be passed to
                                                   NDIS memory allocation calls */
extern NDIS_MEDIUM         univ_medium_array [];/* supported medium types */
// ###### ramkrish extern CVY_PARAMS          univ_params;         /* registry parameters */
// ###### ramkrish extern ULONG               univ_params_valid;   /* paramter structure contains
//                                                   valid data */
// ###### ramkrish extern ULONG               univ_optimized_frags;/* port rules allow for optimized
//                                                   handling of IP fragments */
extern NDIS_OID            univ_oids [];        /* list of supported OIDs */
extern WCHAR               empty_str [];
extern NDIS_HANDLE         univ_device_handle;
extern PDEVICE_OBJECT      univ_device_object;


/* PROCEDURES */


extern VOID Univ_ndis_string_alloc (
    PNDIS_STRING            string,
    PCHAR                   src);
/*
  Allocates NDIS string and copies contents of character string to it

  returns VOID:

  function:
*/


extern VOID Univ_ndis_string_free (
    PNDIS_STRING            string);
/*
  Frees memory previously allocated for the NDIS string

  returns VOID:

  function:
*/


extern VOID Univ_ansi_string_alloc (
    PANSI_STRING            string,
    PWCHAR                  src);
/*
  Allocates NDIS string and copies contents of character string to it

  returns VOID:

  function:
*/


extern VOID Univ_ansi_string_free (
    PANSI_STRING            string);
/*
  Frees memory previously allocated for the NDIS string

  returns VOID:

  function:
*/


extern ULONG   Univ_str_to_ulong (
    PULONG                  retp,
    PWCHAR                  start_ptr,
    PWCHAR *                end_ptr,
    ULONG                   width,
    ULONG                   base);
/*
  Converts string representaion of a number to a ULONG value

  returns ULONG  :
    TRUE  => success
    FALSE => failure

  function:
*/


extern PWCHAR Univ_ulong_to_str (
    ULONG                   val,
    PWCHAR                  buf,
    ULONG                   base);
/*
  Converts ULONG value to a string representation in specified base

  returns PWCHAR:
    <pointer to the symbol in the string following the converted number>

  function:
*/


#endif /* _Univ_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\inc\wlbsutil.h ===
DWORD WINAPI IpAddressFromAbcdWsz(IN const WCHAR*  wszIpAddress);
VOID
WINAPI AbcdWszFromIpAddress(
    IN  DWORD  IpAddress,    
    OUT WCHAR*  wszIpAddress);
VOID GetIPAddressOctets (PCWSTR pszIpAddress, DWORD ardw[4]);
BOOL IsValidIPAddressSubnetMaskPair (PCWSTR szIp, PCWSTR szSubnet);


BOOL IsContiguousSubnetMask (PCWSTR pszSubnet);

BOOL ParamsGenerateSubnetMask (PWSTR ip, PWSTR sub);
void ParamsGenerateMAC (const WCHAR * szClusterIP, 
                               OUT WCHAR * szClusterMAC, 
                               OUT WCHAR * szMulticastIP, 
                               BOOL fConvertMAC, 
                               BOOL fMulticast, 
                               BOOL fIGMP, 
                               BOOL fUseClusterIP);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\inc\wlbsip.h ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

	wlbsip.h

Abstract:

	Windows Load Balancing Service (WLBS)
    IP/TCP/UDP support

Author:

    kyrilf

Environment:


Revision History:


--*/

#ifndef _Tcpip_h_
#define _Tcpip_h_

#ifdef KERNEL_MODE
#include <ndis.h>
#endif


#pragma pack(1)

/* type structures for basic protocols */

typedef struct
{
    UCHAR               byte [20];
}
IP_HDR, * PIP_HDR;

typedef struct
{
    UCHAR               byte [24];
}
TCP_HDR, * PTCP_HDR;

typedef struct
{
    UCHAR               byte [8];
}
UDP_HDR, * PUDP_HDR;

typedef struct
{
    UCHAR               byte [28];
}
ARP_HDR, * PARP_HDR;

#define TCPIP_BCAST_ADDR        0xffffffff  /* IP broadcast address */
#define TCPIP_CLASSC_MASK       0x00ffffff  /* IP address Class C mask */

/* protocol type signatures carried in the length field of Ethernet frame */

#define TCPIP_IP_SIG            0x0800      /* IP protocol */
#define TCPIP_ARP_SIG           0x0806      /* ARP/RARP protocol */

/* supported IP version */

#define TCPIP_VERSION           4           /* current IP version */

/* protocol types as encoded in IP header */

#define TCPIP_PROTOCOL_IP       0           /* Internet protocol id */
#define TCPIP_PROTOCOL_ICMP     1           /* Internet control message protocol id */
#define TCPIP_PROTOCOL_IGMP     2           /* Internet gateway message protocol id */
#define TCPIP_PROTOCOL_GGP      3           /* Gateway-gateway protocol id */
#define TCPIP_PROTOCOL_TCP      6           /* Transmission control protocol id */
#define TCPIP_PROTOCOL_EGP      8           /* Exterior gateway protocol id */
#define TCPIP_PROTOCOL_PUP      12          /* PARC universal packet protocol id */
#define TCPIP_PROTOCOL_UDP      17          /* user datagram protocol id */
#define TCPIP_PROTOCOL_HMP      20          /* Host monitoring protocol id */
#define TCPIP_PROTOCOL_XNS_IDP  22          /* Xerox NS IDP protocol id */
#define TCPIP_PROTOCOL_RDP      27          /* Reliable datagram protocol id */
#define TCPIP_PROTOCOL_RVD      66          /* MIT remote virtual disk protocol id */
#define TCPIP_PROTOCOL_RAW_IP   255         /* raw IP protocol id */
#define TCPIP_PROTOCOL_GRE      47          /* PPTP's GRE stream */
#define TCPIP_PROTOCOL_IPSEC1   50          /* IPSEC's data stream */
#define TCPIP_PROTOCOL_IPSEC2   51          /* IPSEC's data stream */

#define IP_ADDR_LEN             4           /* in bytes */

#if defined (NLB_SESSION_SUPPORT)

/* Stolen from net\ipsec\oakley\ikedef.h and net\ipsec\oakley\isakmp.h. */
#if defined (SBH)
#define COOKIE_LEN 8

typedef struct isakmp_hdr_ {
    unsigned char init_cookie[COOKIE_LEN];
    unsigned char resp_cookie[COOKIE_LEN];
    unsigned char next_payload;
#ifdef ISAKMP_i386
    unsigned char minver:4,
        majver:4;
#else
    unsigned char majver:4,
        minver:4;
#endif
    unsigned char exch;
    unsigned char flags;
    unsigned long mess_id;
    unsigned long len;
} isakmp_hdr;

typedef struct generic_payload_ {
    unsigned char next_payload;
    unsigned char reserved;
    unsigned short payload_len;
} generic_payload;

typedef struct vendor_payload_ {
    unsigned char next_payload;
    unsigned char reserved;
    unsigned short payload_len;
    unsigned char vendor_id[1];
} generic_payload;

typedef struct notify_payload_ {
    unsigned char next_payload;
    unsigned char reserved;
    unsigned short payload_len;
    unsigned long doi;
    unsigned char protocol_id;
    unsigned char spi_size;
    unsigned short notify_message;
}
#endif

/* IPSec/IKE header macros. */
#define IPSEC_ISAKMP_SA                                1
#define IPSEC_ISAKMP_VENDOR_ID                         13
#define IPSEC_ISAKMP_NOTIFY                            11

#define IPSEC_ISAKMP_MAIN_MODE_RCOOKIE                 {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
#define IPSEC_ISAKMP_ENCAPSULATED_IPSEC_ICOOKIE        {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}

#define IPSEC_ISAKMP_HEADER_LENGTH                     28
#define IPSEC_ISAKMP_HEADER_ICOOKIE_OFFSET             0
#define IPSEC_ISAKMP_HEADER_ICOOKIE_LENGTH             8
#define IPSEC_ISAKMP_HEADER_RCOOKIE_OFFSET             8
#define IPSEC_ISAKMP_HEADER_RCOOKIE_LENGTH             8
#define IPSEC_ISAKMP_HEADER_NEXT_PAYLOAD_OFFSET        16
#define IPSEC_ISAKMP_HEADER_PACKET_LENGTH_OFFSET       24

typedef struct {
    UCHAR byte[IPSEC_ISAKMP_HEADER_LENGTH];
} IPSEC_ISAKMP_HDR, * PIPSEC_ISAKMP_HDR;

#define IPSEC_ISAKMP_GET_ICOOKIE_POINTER(isakmp_hdrp)  ((PUCHAR)isakmp_hdrp + IPSEC_ISAKMP_HEADER_ICOOKIE_OFFSET)
#define IPSEC_ISAKMP_GET_RCOOKIE_POINTER(isakmp_hdrp)  ((PUCHAR)isakmp_hdrp + IPSEC_ISAKMP_HEADER_RCOOKIE_OFFSET)
#define IPSEC_ISAKMP_GET_NEXT_PAYLOAD(isakmp_hdrp)     ((UCHAR)((isakmp_hdrp)->byte[IPSEC_ISAKMP_HEADER_NEXT_PAYLOAD_OFFSET]))
#define IPSEC_ISAKMP_GET_PACKET_LENGTH(isakmp_hdrp)    ((ULONG)(((isakmp_hdrp)->byte[IPSEC_ISAKMP_HEADER_PACKET_LENGTH_OFFSET]     << 24) | \
                                                                ((isakmp_hdrp)->byte[IPSEC_ISAKMP_HEADER_PACKET_LENGTH_OFFSET + 1] << 16) | \
                                                                ((isakmp_hdrp)->byte[IPSEC_ISAKMP_HEADER_PACKET_LENGTH_OFFSET + 2] << 8)  | \
                                                                ((isakmp_hdrp)->byte[IPSEC_ISAKMP_HEADER_PACKET_LENGTH_OFFSET + 3] << 0)))

#define IPSEC_GENERIC_HEADER_LENGTH                    4
#define IPSEC_GENERIC_HEADER_NEXT_PAYLOAD_OFFSET       0
#define IPSEC_GENERIC_HEADER_PAYLOAD_LENGTH_OFFSET     2

typedef struct {
    UCHAR byte[IPSEC_GENERIC_HEADER_LENGTH];
} IPSEC_GENERIC_HDR, * PIPSEC_GENERIC_HDR;

#define IPSEC_GENERIC_GET_NEXT_PAYLOAD(generic_hdrp)   ((UCHAR)((generic_hdrp)->byte[IPSEC_GENERIC_HEADER_NEXT_PAYLOAD_OFFSET]))
#define IPSEC_GENERIC_GET_PAYLOAD_LENGTH(generic_hdrp) ((USHORT)(((generic_hdrp)->byte[IPSEC_GENERIC_HEADER_PAYLOAD_LENGTH_OFFSET]     << 8) | \
                                                                 ((generic_hdrp)->byte[IPSEC_GENERIC_HEADER_PAYLOAD_LENGTH_OFFSET + 1] << 0)))

#define IPSEC_VENDOR_ID_MICROSOFT                      {0x1E, 0x2B, 0x51, 0x69, 0x05, 0x99, 0x1C, 0x7D, 0x7C, 0x96, 0xFC, 0xBF, 0xB5, 0x87, 0xE4, 0x61}
#define IPSEC_VENDOR_ID_MICROSOFT_MIN_VERSION          0x00000004

#define IPSEC_VENDOR_ID_PAYLOAD_LENGTH                 20
#define IPSEC_VENDOR_HEADER_VENDOR_ID_OFFSET           4
#define IPSEC_VENDOR_HEADER_VENDOR_ID_LENGTH           16
#define IPSEC_VENDOR_HEADER_VENDOR_VERSION_OFFSET      20
#define IPSEC_VENDOR_HEADER_VENDOR_VERSION_LENGTH      4

typedef struct {
    UCHAR byte[IPSEC_GENERIC_HEADER_LENGTH + IPSEC_VENDOR_ID_PAYLOAD_LENGTH];
} IPSEC_VENDOR_HDR, * PIPSEC_VENDOR_HDR;

#define IPSEC_VENDOR_ID_GET_ID_POINTER(vendor_hdrp)    ((PUCHAR)vendor_hdrp + IPSEC_VENDOR_HEADER_VENDOR_ID_OFFSET)
#define IPSEC_VENDOR_ID_GET_VERSION(vendor_hdrp)       ((ULONG)(((vendor_hdrp)->byte[IPSEC_VENDOR_HEADER_VENDOR_VERSION_OFFSET]     << 24) | \
                                                                ((vendor_hdrp)->byte[IPSEC_VENDOR_HEADER_VENDOR_VERSION_OFFSET + 1] << 16) | \
                                                                ((vendor_hdrp)->byte[IPSEC_VENDOR_HEADER_VENDOR_VERSION_OFFSET + 2] << 8)  | \
                                                                ((vendor_hdrp)->byte[IPSEC_VENDOR_HEADER_VENDOR_VERSION_OFFSET + 3] << 0)))

#define IPSEC_NOTIFY_INITIAL_CONTACT                   24578

#define IPSEC_NOTIFY_PAYLOAD_LENGTH                    8
#define IPSEC_NOTIFY_HEADER_NOTIFY_MESSAGE_OFFSET      10

typedef struct {
    UCHAR byte[IPSEC_GENERIC_HEADER_LENGTH + IPSEC_NOTIFY_PAYLOAD_LENGTH];
} IPSEC_NOTIFY_HDR, * PIPSEC_NOTIFY_HDR;

#define IPSEC_NOTIFY_GET_NOTIFY_MESSAGE(notify_hdrp)   ((USHORT)(((notify_hdrp)->byte[IPSEC_NOTIFY_HEADER_NOTIFY_MESSAGE_OFFSET]     << 8) | \
                                                                 ((notify_hdrp)->byte[IPSEC_NOTIFY_HEADER_NOTIFY_MESSAGE_OFFSET + 1] << 0)))
#endif

/* ARP header macros - note address locations assume 6 byte MAC (Ethernet)
   and 4 byte protocol (IP) sizes */

/* type of hardware address */
#define ARP_GET_MAC_TYPE(p)     (((ULONG) ((p) -> byte[0]) << 8) | (ULONG) ((p) -> byte[1]))

/* higher layer addressing protocol */
#define ARP_GET_PROT_TYPE(p)    (((ULONG) ((p) -> byte[2]) << 8) | (ULONG) ((p) -> byte[3]))

/* length of hardware address */
#define ARP_GET_MAC_LEN(p)      ((ULONG) ((p) -> byte[4]))

/* length of higher layer address */
#define ARP_GET_PROT_LEN(p)     ((ULONG) ((p) -> byte[5]))

/* type of message */
#define ARP_GET_MSG_TYPE(p)     (((ULONG) ((p) -> byte[6]) << 8) | (ULONG) ((p) -> byte[7]))

/* source hardware address */
#define ARP_GET_SRC_MAC_PTR(p)  (&((p) -> byte[8]))
#define ARP_GET_SRC_MAC(p,n)    ((ULONG) ((p) -> byte[8 + (n)]))

/* source higher layer address */
#define ARP_GET_SRC_PROT(p,n)   ((ULONG) ((p) -> byte[14 + (n)]))
#define ARP_GET_SRC_FPROT(p)    (* ((PULONG) &((p) -> byte[14])))
/* 64-bit -- ramkrish */
#define ARP_GET_SRC_PROT_64(p)  ((ULONG) (((p) -> byte[14] << 0)   | ((p) -> byte[15] << 8) | \
                                          ((p) -> byte[16] << 16)  | ((p) -> byte[17] << 24)))


/* destination hardware address */
#define ARP_GET_DST_MAC_PTR(p)  (&((p) -> byte[18]))
#define ARP_GET_DST_MAC(p,n)    ((ULONG) ((p) -> byte[18 + (n)]))

/* destination higher layer address */
#define ARP_GET_DST_PROT(p,n)   ((ULONG) ((p) -> byte[24 + (n)]))
#define ARP_GET_DST_FPROT(p)    (* ((PULONG) &((p) -> byte[24])))
/* 64-bit -- ramkrish */
#define ARP_GET_DST_PROT_64(p)  ((ULONG) (((p) -> byte[18] << 0)   | ((p) -> byte[19] << 8) | \
                                          ((p) -> byte[20] << 16)  | ((p) -> byte[21] << 24)))


#define ARP_MAC_TYPE_ETH        0x0001
#define ARP_PROT_TYPE_IP        0x0800
#define ARP_MAC_LEN_ETH         6
#define ARP_PROT_LEN_IP         4
#define ARP_MSG_TYPE_REQ        0x1
#define ARP_MSG_TYPE_RSP        0x2


/* IP datagram header macros */


/* IP version number */
#define IP_GET_VERS(p)          ((ULONG) ((((p) -> byte[0]) >> 4) & 0xf))

/* header length in 32-bit words */
#define IP_GET_HLEN(p)          ((ULONG) (((p) -> byte[0]) & 0xf))

/* service type */
#define IP_GET_SRVC(p)          ((ULONG) ((p) -> byte[1]))

/* total datagram packet length in bytes */
#define IP_GET_PLEN(p)          (((ULONG) ((p) -> byte[2]) << 8) | (ULONG) ((p) -> byte[3]))

/* fragmentation identification - this one seems to have bytes swaped within
   the short word ??? */
#define IP_GET_FRAG_ID(p)       (((ULONG) ((p) -> byte[5]) << 8) | (ULONG) ((p) -> byte[4]))

/* fragmentation flags */
#define IP_GET_FRAG_FLGS(p)     ((ULONG) ((((p) -> byte[6]) >> 5) & 0x7))

/* fragmentation offset */
#define IP_GET_FRAG_OFF(p)      (((ULONG) ((p) -> byte[6] & 0x1f) << 8) | (ULONG) ((p) -> byte[7]))

/* Time To Live in seconds */
#define IP_GET_TTL(p)           ((ULONG) ((p) -> byte[8]))

/* higher level protocol id */
#define IP_GET_PROT(p)          ((ULONG) ((p) -> byte[9]))

/* header checksum - this one seems to have bytes swaped within
   the short word ??? */
#define IP_GET_CHKSUM(p)        (((USHORT) ((p) -> byte[10]) << 8) | (USHORT) ((p) -> byte[11]))
#define IP_SET_CHKSUM(p,c)      (((p) -> byte[10] = (c) >> 8), ((p) -> byte[11] = (c) & 0xff))

/* source IP address */
#define IP_GET_SRC_ADDR(p,n)    ((ULONG) ((p) -> byte[12 + (n)]))
#define IP_GET_SRC_ADDR_PTR(p)  (&((p) -> byte[12]))
#define IP_GET_SRC_FADDR(p)     (* ((PULONG) &((p) -> byte[12]))) /* 64-bit -- ramkrish */


#ifdef _WIN64 
    #define IP_GET_SRC_ADDR_64(p)   ((ULONG) (((p) -> byte[12] << 0) | ((p) -> byte[13] << 8) | \
                                          ((p) -> byte[14] << 16)  | ((p) -> byte[15] << 24)))
#else                                          
    //  This is faster than the one above.  This function is called in critical receiving path
    #define IP_GET_SRC_ADDR_64(p)     (* ((PULONG) &((p) -> byte[12])))
#endif

/* destination IP address */
#define IP_GET_DST_ADDR(p,n)    ((ULONG) ((p) -> byte[16 + (n)]))

#ifdef _WIN64 
    #define IP_GET_DST_ADDR_64(p)   ((ULONG) (((p) -> byte[16] << 0)   | ((p) -> byte[17] << 8) | \
                                          ((p) -> byte[18] << 16)  | ((p) -> byte[19] << 24)))
#else                                          
    //  This is faster than the one above.  This function is called in critical receiving path
    #define IP_GET_DST_ADDR_64(p)     (* ((PULONG) &((p) -> byte[16])))
#endif


/* 64-bit -- ramkrish */

#define IP_SET_SRC_ADDR_64(p,c)    { \
                                     PUCHAR tmp = (PUCHAR) (&(c)); \
                                     (p) -> byte[12] = tmp[0]; (p) -> byte[13] = tmp[1]; \
                                     (p) -> byte[14] = tmp[2]; (p) -> byte[15] = tmp[3]; \
                                   }

#define IP_SET_DST_ADDR_64(p,c)    { \
                                     PUCHAR tmp = (PUCHAR) (&(c)); \
                                     (p) -> byte[16] = tmp[0]; (p) -> byte[17] = tmp[1]; \
                                     (p) -> byte[18] = tmp[2]; (p) -> byte[19] = tmp[3]; \
                                   }

/* create IP address from 4 bytes */
#define IP_SET_ADDR(p,b0,b1,b2,b3) (* (p) = (((b0) << 0) | ((b1) << 8) | ((b2) << 16) | ((b3) << 24)))

/* compute broadcast address from IP address and netmask */
#define IP_SET_BCAST(p,a,m)     (* (p) = ((a) & (m)) | (~(m)))


/* TCP header macros */


/* pointer to TCP header from IP header pointer */
#define TCP_PTR(p)              ((PTCP_HDR)(((ULONG *)(p)) + ((ULONG)IP_GET_HLEN(p))))

/* source port */
#define TCP_GET_SRC_PORT(p)     (((ULONG) ((p) -> byte[0]) << 8) | (ULONG) ((p) -> byte[1]))
#define TCP_GET_SRC_PORT_PTR(p) (& ((p) -> byte[0])) /* 64-bit -- ramkrish */

/* destination port */
#define TCP_GET_DST_PORT(p)     (((ULONG) ((p) -> byte[2]) << 8) | (ULONG) ((p) -> byte[3]))
#define TCP_GET_DST_PORT_PTR(p) (& ((p) -> byte[2]))  /* 64-bit -- ramkrish */

/* sequence number */
#define TCP_GET_SEQ_NO(p)       (((ULONG) ((p) -> byte[4]) << 24) | ((ULONG) ((p) -> byte[5]) << 16) | \
                                 ((ULONG) ((p) -> byte[6]) << 8)  |  (ULONG) ((p) -> byte[7]))

/* acknowledgement number */
#define TCP_GET_ACK_NO(p)       (((ULONG) ((p) -> byte[8])  << 24) | ((ULONG) ((p) -> byte[9]) << 16) | \
                                 ((ULONG) ((p) -> byte[10]) << 8)  |  (ULONG) ((p) -> byte[11]))

/* flags */
#define TCP_GET_FLAGS(p)        (((ULONG) ((p) -> byte[13])) & 0x3f)

/* header length in 32-bit words */
#define TCP_GET_HLEN(p)         ((ULONG) (((p) -> byte[12]) >> 4))

/* datagram length */
#define TCP_GET_DGRAM_LEN(i,t)  (IP_GET_PLEN (i) - ((IP_GET_HLEN (i) + TCP_GET_HLEN (t)) * sizeof (ULONG)))

/* pointer to datagram */
#define TCP_GET_DGRAM_PTR(p)    ((PUCHAR)(((ULONG *)(p)) + ((ULONG) TCP_GET_HLEN(p))))

/* checksum field */
#define TCP_GET_CHKSUM(p)       ((((USHORT)((p) -> byte[16])) << 8) | (USHORT)((p) -> byte[17]))
#define TCP_SET_CHKSUM(p,c)     (((p) -> byte[16] = (c) >> 8), ((p) -> byte[17] = (c) & 0xff))

#define TCP_FLAG_URG            0x20
#define TCP_FLAG_ACK            0x10
#define TCP_FLAG_PSH            0x8
#define TCP_FLAG_RST            0x4
#define TCP_FLAG_SYN            0x2
#define TCP_FLAG_FIN            0x1


/* UDP header macros */


/* pointer to TCP header from IP header pointer */
#define UDP_PTR(p)              ((PUDP_HDR)(((ULONG *)(p)) + ((ULONG)IP_GET_HLEN(p))))

/* source port */
#define UDP_GET_SRC_PORT(p)     (((ULONG) ((p) -> byte[0]) << 8) | (ULONG) ((p) -> byte[1]))
#define UDP_GET_SRC_PORT_PTR(p) (& ((p) -> byte[0]))
#define UDP_GET_SRC_FPORT(p)    (* ((PUSHORT) &((p) -> byte[0])))

/* 64-bit -- ramkrish */
#define UDP_SET_SRC_PORT_64(p,v) (((p) -> byte[0] = v >> 8), ((p) -> byte[1] = v & 0xff))

/* destination port */
#define UDP_GET_DST_PORT(p)     (((ULONG) ((p) -> byte[2]) << 8) | (ULONG) ((p) -> byte[3]))
#define UDP_GET_DST_PORT_PTR(p) (& ((p) -> byte[2]))
#define UDP_GET_DST_FPORT(p)    (* ((PUSHORT) &((p) -> byte[2])))

/* 64-bit -- ramkrish */
#define UDP_SET_DST_PORT_64(p,v) (((p) -> byte[2] = v >> 8), ((p) -> byte[3] = v & 0xff))

/* packet length */
#define UDP_GET_LEN(p)          (((ULONG) ((p) -> byte[4]) << 8) | (ULONG) ((p) -> byte[5]))

/* packet length */
#define UDP_GET_CHKSUM(p)       (((USHORT) ((p) -> byte[6]) << 8) | (USHORT) ((p) -> byte[7]))
#define UDP_SET_CHKSUM(p,c)     (((p) -> byte[6] = (c) >> 8), ((p) -> byte[7] = (c) & 0xff))

/* pointer to datagram */
#define UDP_GET_DGRAM_PTR(p)    ((PUCHAR)(p) + sizeof (UDP_HDR))


/* V1.11 NetBIOS name cluster name support */


#define NBT_NAME_LEN            16
#define NBT_ENCODED_NAME_LEN    (2 * NBT_NAME_LEN) /* multiplier HAS to be 2 */

#define NBT_ENCODED_NAME_BASE   'A'

#define NBT_NAME_SHADOW         "*SMBSERVER      "

#define NBT_ENCODED_NAME_SHADOW \
{ \
    'C', 'K', 'F', 'D', 'E', 'N', 'E', 'C', 'F', 'D', 'E', 'F', 'F', 'C', 'F', 'G', \
    'E', 'F', 'F', 'C', 'C', 'A', 'C', 'A', 'C', 'A', 'C', 'A', 'C', 'A', 'C', 'A'  \
}

#define NBT_ENCODE_FIRST(c)     (((c) >> 4)  + NBT_ENCODED_NAME_BASE)
#define NBT_ENCODE_SECOND(c)    (((c) & 0xf) + NBT_ENCODED_NAME_BASE)

#define NBT_SESSION_PORT        139
#define NBT_SESSION_REQUEST     0x81        /* packet type */

typedef struct
{
    UCHAR               byte[72];  /* only the session request packet */
}
NBT_HDR, * PNBT_HDR;

/* pointer to NBT header from TCP header */
#define NBT_PTR(p)              ((PNBT_HDR)(((ULONG *)(p)) + ((ULONG) TCP_GET_HLEN(p))))

/* packet type */
#define NBT_GET_PKT_TYPE(p)     ((ULONG) ((p) -> byte[0]))

/* packet length */
#define NBT_GET_PKT_LEN(p)      ((ULONG) ((p) -> byte[3]))

/* called name */
#define NBT_GET_CALLED_NAME(p)  ((PUCHAR) & ((p) -> byte[4]))       /* server's name */

/* calling name */
#define NBT_GET_CALLING_NAME(p) ((PUCHAR) & ((p) -> byte[36]))      /* client's name */


/* PPTP/IPSEC support */

#define PPTP_CTRL_PORT          1723
#define IPSEC_CTRL_PORT         500

#pragma pack()


/* TCPIP module context */


typedef struct
{
    UCHAR               nbt_encoded_cluster_name [NBT_ENCODED_NAME_LEN]; /* V1.2 */
}
TCPIP_CTXT, * PTCPIP_CTXT;


/* PROCEDURES */


extern BOOLEAN Tcpip_init (
    PTCPIP_CTXT     ctxtp,
    PVOID           params);
/*
  Initialize module

  returns BOOLEAN:
    TRUE  => success
    FALSE => failure

  function:
*/


extern VOID Tcpip_nbt_handle (
    PTCPIP_CTXT     ctxtp,
    PIP_HDR         ip_hdrp,
    PTCP_HDR        tcp_hdrp,
    ULONG           len,
    PNBT_HDR        nbt_hdrp);
/*
  Process NBT header and mask cluster name with shadow name

  returns VOID:

  function:
*/


extern USHORT Tcpip_chksum (
    PTCPIP_CTXT     ctxtp,
    PIP_HDR         ip_hdrp,
    PUCHAR          prot_hdrp,
    ULONG           prot);
/*
  Produce IP, TCP or UDL checksums for specified protocol header

  returns USHORT:
    <checksum>

  function:
*/


#endif /* _Tcpip_h_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\installpack\pch.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       P C H . H
//
//  Contents:   Pre-compiled header file
//
//  Notes:
//
//  Author:     kumarp 28-September-98
//
//----------------------------------------------------------------------------

#pragma once

// Turns off "string too long - truncated to 255 characters in the debug
// information, debugger cannot evaluate symbol."
//
#pragma warning (disable: 4786)

#include <windows.h>
#include <netcfgx.h>
#include <netcfgn.h>

#include <setupapi.h>
#include <devguid.h>
#include <tchar.h>
#include <stdio.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\installpack\implinc.cpp ===
#include "pch.h"
#pragma hdrstop
#include "idls_i.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\installpack\tracelog.h ===
#pragma once

#ifdef __cplusplus
extern "C" {
#endif


#include <windows.h>
#include <winbase.h>
#include <rtutils.h>

#define TL_ERROR ((DWORD)0x00010000 | TRACE_USE_MASK)
#define TL_WARN  ((DWORD)0x00020000 | TRACE_USE_MASK)
#define TL_INFO  ((DWORD)0x00040000 | TRACE_USE_MASK)
//    #define TL_TRACE ((DWORD)0x00080000 | TRACE_USE_MASK)
//    #define TL_EVENT ((DWORD)0x00100000 | TRACE_USE_MASK)

BOOL  TRACELogRegister(LPCTSTR szName);
void  TRACELogDeRegister();
void  TRACELogPrint(IN DWORD dwDbgLevel, IN LPCSTR DbgMessage, IN ...);


#define LOG_ERROR(pszFmt)                    TRACELogPrint(TL_ERROR, pszFmt)
#define LOG_ERROR1(pszFmt, arg1)             TRACELogPrint(TL_ERROR, pszFmt, arg1)
#define LOG_ERROR2(pszFmt, arg1, arg2)       TRACELogPrint(TL_ERROR, pszFmt, arg1, arg2)
#define LOG_ERROR3(pszFmt, arg1, arg2, arg3) TRACELogPrint(TL_ERROR, pszFmt, arg1, arg2, arg3)

#define LOG_WARN(pszFmt)                    TRACELogPrint(TL_WARN, pszFmt)
#define LOG_WARN1(pszFmt, arg1)             TRACELogPrint(TL_WARN, pszFmt, arg1)
#define LOG_WARN2(pszFmt, arg1, arg2)       TRACELogPrint(TL_WARN, pszFmt, arg1, arg2)
#define LOG_WARN3(pszFmt, arg1, arg2, arg3) TRACELogPrint(TL_WARN, pszFmt, arg1, arg2, arg3)

#define LOG_INFO(pszFmt)                    TRACELogPrint(TL_INFO, pszFmt)
#define LOG_INFO1(pszFmt, arg1)             TRACELogPrint(TL_INFO, pszFmt, arg1)
#define LOG_INFO2(pszFmt, arg1, arg2)       TRACELogPrint(TL_INFO, pszFmt, arg1, arg2)
#define LOG_INFO3(pszFmt, arg1, arg2, arg3) TRACELogPrint(TL_INFO, pszFmt, arg1, arg2, arg3)


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\installpack\error.h ===
/*
 * File: error.h
 * Description: This file contains the definitions of the NLB install pack
 *              HRESULT error codes.
 * Author: shouse 12.5.00
 */

#define FACILITY_NLB           35

#define NLB_E_INVALID_OS        1
#define NLB_E_ALREADY_INSTALLED 2
#define NLB_E_FILES_MISSING     3
#define NLB_E_INF_FAILURE       4
#define NLB_E_REGISTER_DLL      5
#define NLB_E_COMPILE_MOF       6
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\installpack\snetcfg.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       S N E T C F G . H
//
//  Contents:   Sample code that demonstrates how to:
//              - find out if a component is installed
//              - install a net component
//              - install an OEM net component
//              - uninstall a net component
//              - enumerate net components
//              - enumerate net adapters using Setup API
//              - enumerate binding paths of a component
//
//  Notes:
//
//  Author:     kumarp 26-March-98
//
//----------------------------------------------------------------------------

#pragma once

enum NetClass
{
    NC_NetAdapter=0,
    NC_NetProtocol,
    NC_NetService,
    NC_NetClient,
    NC_Unknown
};

HRESULT FindIfComponentInstalled(IN PCWSTR szComponentId);

HRESULT HrInstallNetComponent(IN PCWSTR szComponentId,
                              IN enum NetClass nc,
                              IN PCWSTR szSrcDir);

HRESULT HrUninstallNetComponent(IN PCWSTR szComponentId);


HRESULT HrShowNetAdapters();
HRESULT HrShowNetComponents();
HRESULT HrShowBindingPathsOfComponent(IN PCWSTR szComponentId);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\installpack\tracelog.cpp ===
#include <stdio.h>
#include <stdarg.h>
#include "tracelog.h"

static DWORD  sg_dwTraceID = INVALID_TRACEID;
static char    sg_szTraceName[100];   // Used for OutputDebugString

#ifdef DBG
DWORD   sg_dwTracingToDebugger = 1;  // Enable OutputDebugString for debug version by default
#else
DWORD   sg_dwTracingToDebugger = 0;  
#endif

DWORD   sg_dwDebuggerMask      = 0;


inline const char *TraceLevel(DWORD dwDbgLevel)
{
    switch(dwDbgLevel)
    {
        case TL_ERROR: return "ERROR";
        case TL_WARN:  return "WARN ";
        case TL_INFO:  return "INFO ";
        default:       return " ??? ";
    }
}

BOOL TRACELogRegister(LPCTSTR szName)
{
    HKEY       hTracingKey;

    char       szTracingKey[100];
    const char szDebuggerTracingEnableValue[] = "EnableDebuggerTracing";
    const char szTracingMaskValue[]   = "FileTracingMask";

    sg_dwTracingToDebugger = 0;

    sg_dwTraceID = TraceRegister(szName);
    TraceDeregister(sg_dwTraceID);

#ifdef UNICODE
    wsprintfA(szTracingKey, "Software\\Microsoft\\Tracing\\%ls", szName);
#else
    wsprintfA(szTracingKey, "Software\\Microsoft\\Tracing\\%s", szName);
#endif

    if ( ERROR_SUCCESS == RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                                        szTracingKey,
                                        0,
                                        KEY_READ|KEY_SET_VALUE,
                                        &hTracingKey) )
    {
        DWORD      dwDataSize = sizeof (DWORD);
        DWORD      dwDataType;

#ifdef DBG
        //
        //  Always Enable file tracing for debug version
        //
        DWORD dwEnableFileTracing = 1;
        RegSetValueExA(hTracingKey,
                         "EnableFileTracing",
                         0,
                         REG_DWORD,
                         (LPBYTE) &dwEnableFileTracing,
                         sizeof (DWORD));
#endif

        dwDataSize = sizeof (DWORD);
        RegQueryValueExA(hTracingKey,
                         szDebuggerTracingEnableValue,
                         0,
                         &dwDataType,
                         (LPBYTE) &sg_dwTracingToDebugger,
                         &dwDataSize);

        dwDataSize = sizeof (DWORD);
        RegQueryValueExA(hTracingKey,
                         szTracingMaskValue,
                         0,
                         &dwDataType,
                         (LPBYTE) &sg_dwDebuggerMask,
                         &dwDataSize);

        RegCloseKey (hTracingKey);
    }

#ifdef UNICODE
    wsprintfA(sg_szTraceName, "%ls", szName);
#else
    wsprintfA(sg_szTraceName, "%s", szName);
#endif

    sg_dwTraceID = TraceRegister(szName);
    return (sg_dwTraceID != INVALID_TRACEID);
}


void TRACELogDeRegister()
{
    sg_dwTracingToDebugger = 0;

    if (sg_dwTraceID != INVALID_TRACEID)
    {
        TraceDeregister(sg_dwTraceID);
        sg_dwTraceID = INVALID_TRACEID;
    }
}


void TRACELogPrint(IN DWORD dwDbgLevel, IN LPCSTR lpszFormat, IN ...)
{
    #define MAXDEBUGSTRINGLENGTH 1024
    char    szTraceBuf[MAXDEBUGSTRINGLENGTH + 1];
    va_list arglist;

    if ( ( sg_dwTracingToDebugger > 0 ) &&
         ( dwDbgLevel & sg_dwDebuggerMask ) )
    {

        // retrieve local time
        SYSTEMTIME SystemTime;
        GetLocalTime(&SystemTime);

        wsprintfA(szTraceBuf,
                  "%s:[%02u:%02u:%02u.%03u:] [%s] ",
                  sg_szTraceName,
                  SystemTime.wHour,
                  SystemTime.wMinute,
                  SystemTime.wSecond,
                  SystemTime.wMilliseconds,
                  TraceLevel(dwDbgLevel));

        va_list ap;
        va_start(ap, lpszFormat);

        _vsnprintf(&szTraceBuf[lstrlenA(szTraceBuf)], 
            MAXDEBUGSTRINGLENGTH - lstrlenA(szTraceBuf), 
            lpszFormat, 
            ap
            );

        lstrcatA (szTraceBuf, "\n");

        OutputDebugStringA (szTraceBuf);

        va_end(ap);
		
    }
    
	if (sg_dwTraceID != INVALID_TRACEID && ( dwDbgLevel & sg_dwDebuggerMask ))
    {
		wsprintfA(szTraceBuf, "[%s] %s", TraceLevel(dwDbgLevel), lpszFormat);

		va_start(arglist, lpszFormat);
		TraceVprintfExA(sg_dwTraceID, dwDbgLevel | TRACE_USE_MSEC, szTraceBuf, arglist);
		va_end(arglist);
	}

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\installpack\install.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       M A I N . C P P
//
//  Contents:   Code to provide a simple cmdline interface to
//              the sample code functions
//
//  Notes:      The code in this file is not required to access any
//              netcfg functionality. It merely provides a simple cmdline
//              interface to the sample code functions provided in
//              file snetcfg.cpp.
//
//  Author:     kumarp    28-September-98
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "snetcfg.h"
#include "error.h"
#include <wbemcli.h>
#include <winnls.h>
#include "tracelog.h"

BOOL g_fVerbose = FALSE;

BOOL WlbsCheckSystemVersion ();
BOOL WlbsCheckFiles ();
HRESULT WlbsRegisterDlls ();
HRESULT WlbsCompileMof ();

// ----------------------------------------------------------------------
//
// Function:  wmain
//
// Purpose:   The main function
//
// Arguments: standard main args
//
// Returns:   0 on success, non-zero otherwise
//
// Author:    kumarp 25-December-97
//
// Notes:
//
EXTERN_C int __cdecl wmain (int argc, WCHAR * argv[]) {
    HRESULT hr = S_OK;
    WCHAR ch;
    enum NetClass nc = NC_Unknown;
    WCHAR szFileFullPath[MAX_PATH+1];
    WCHAR szFileFullPathDest[MAX_PATH+1];
    PWCHAR pwc;
    PWSTR szFileComponent;

    TRACELogRegister(L"wlbs");

    LOG_INFO("Checking Windows version information.");

    if (!WlbsCheckSystemVersion()) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_NLB, NLB_E_INVALID_OS);
        LOG_ERROR("The NLB install pack can only be used on Windows 2000 Server Service Pack 1 or higher.");
        goto error;
    }

    LOG_INFO("Checking for previous NLB installations.");

    hr = FindIfComponentInstalled(_TEXT("ms_wlbs"));

    if (hr == S_OK) {
        /* AppCenter request on 1.9.01 to revert to S_FALSE in this case due to RTM proximity. */
        /* hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_NLB, NLB_E_ALREADY_INSTALLED); */
        hr = S_FALSE;
        LOG_ERROR("Network Load Balancing Service is already installed.");
        goto error;
    }

    if (FAILED(hr)) {
        LOG_ERROR("Warning: Error querying for Network Load Balancing Service. There may be errors in this installtion.");
    }

    LOG_INFO("Checking for necessary files.");

    if (!WlbsCheckFiles()) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_NLB, NLB_E_FILES_MISSING);
        LOG_ERROR1("Please install the NLB hotfix before running %ls", argv[0]);
        goto error;
    }

    GetModuleFileName(NULL, szFileFullPath, MAX_PATH + 1);

    pwc = wcsrchr(szFileFullPath, L'\\');
    * (pwc + 1) = L'\0';
    wcscat(szFileFullPath, L"netwlbs.inf");

    LOG_INFO("Checking language version.");

    switch (GetSystemDefaultLangID()) {
    case 0x0409: case 0x0809: case 0x0c09: case 0x1009: case 0x1409: case 0x1809: case 0x1c09:
    case 0x2009: case 0x2409: case 0x2809: case 0x2c09:
        LOG_INFO1("English version detected 0x%x.", GetSystemDefaultLangID());
        wcscat (szFileFullPath, L".eng");
        break;
    case 0x0411:
        LOG_INFO1("Japanese version detected 0x%x.", GetSystemDefaultLangID());
        wcscat (szFileFullPath, L".jpn");
        break;
    case 0x0407: case 0x0807: case 0x0c07: case 0x1007: case 0x1407:
        LOG_INFO1("German version detected 0x%x.", GetSystemDefaultLangID());
        wcscat (szFileFullPath, L".ger");
        break;
    case 0x040c: case 0x080c: case 0x0c0c: case 0x100c: case 0x140c:
        LOG_INFO1("French version detected 0x%x.", GetSystemDefaultLangID());
        wcscat (szFileFullPath, L".fr");
        break;
    default:
        LOG_INFO1("Unsupported Language.Please contact PSS for a new %ls.", argv[0]);
        wcscat (szFileFullPath, L".eng");
        break;
    }

    /* First copy the .inf file. */
    GetWindowsDirectory(szFileFullPathDest, MAX_PATH + 1);
    wcscat(szFileFullPathDest, L"\\INF\\netwlbs.inf");

    LOG_INFO("Copying the NLB .inf file.");

    if (!CopyFile(szFileFullPath, szFileFullPathDest, FALSE)) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_NLB, NLB_E_INF_FAILURE);
        LOG_ERROR2("Warning: Unable to copy the inf file %ls %ls.", szFileFullPath, szFileFullPathDest);
        goto error;
    }

    /* Now install the service. */
    hr = HrInstallNetComponent(L"ms_wlbs", NC_NetService, szFileFullPathDest);

    if (!SUCCEEDED(hr)) {
        LOG_ERROR("Error installing Network Load Balancing.");
        goto error;
    } else {
        LOG_INFO("Installation of Network Load Balancing done.");
    }

    /* Change working directory to %TEMP%. Needed because of a IMofCopiler::CompileFile error on Win2K. */
    WCHAR * szTempDir = _wgetenv(L"TEMP");
    _wchdir(szTempDir);

    LOG_INFO("Registering NLB Dlls.");

    /* Register the provider .dll here. */
    hr = WlbsRegisterDlls();

    if (!SUCCEEDED(hr)) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_NLB, NLB_E_REGISTER_DLL);
        LOG_ERROR("Error registering NLB Dlls.");
        goto error;
    }

    LOG_INFO("Compiling the NLB MOF.");

    /* Compile wlbsprov.mof here */
    hr = WlbsCompileMof();

    if (!SUCCEEDED(hr)) {
        hr = MAKE_HRESULT(SEVERITY_ERROR, FACILITY_NLB, NLB_E_COMPILE_MOF);
        LOG_ERROR("Error compiling the NLB MOF.");
        goto error;
    } 

    LOG_INFO("WLBS Setup successful.");

    return hr;

error:
    LOG_ERROR1("WLBS Setup failed 0x%x", hr);

    return hr;
}

/* This checks whether the system on which NLB is being installed is a W2K Server or not. */
BOOL WlbsCheckSystemVersion () {
    OSVERSIONINFOEX osinfo;

    osinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

    if (!GetVersionEx((LPOSVERSIONINFO)&osinfo)) return FALSE;
    
    /* For install, we return TRUE only if its Windows 2000 Server. */
    if ((osinfo.dwMajorVersion == 5) && 
        (osinfo.dwMinorVersion == 0) && 
        (osinfo.wProductType == VER_NT_SERVER) && 
        !(osinfo.wSuiteMask & VER_SUITE_ENTERPRISE) &&
        !(osinfo.wSuiteMask & VER_SUITE_DATACENTER))
        return TRUE;
    
    return FALSE;
}

BOOL WlbsCheckFiles () {
    WCHAR * FileList [] = {
        L"\\system32\\drivers\\wlbs.sys",
        L"\\system32\\wlbs.exe",
        L"\\help\\wlbs.chm",
        L"\\help\\wlbs.hlp",
        L"\\system32\\wlbsctrl.dll",
        L"\\system32\\wbem\\wlbsprov.dll",
        L"\\system32\\wbem\\wlbsprov.mof",
        L"\\system32\\wbem\\wlbsprov.mfl",
        L"\\inf\\netwlbsm.inf",
        NULL
    };

    WCHAR wszPath [MAX_PATH + 1];
    PWCHAR pwc;
    INT i = 0;
    BOOL first = FALSE;
    WIN32_FIND_DATA FileFind;
    HANDLE hdl;

    while (FileList [i] != NULL) {
	GetWindowsDirectory(wszPath, MAX_PATH + 1);
        wcscat(wszPath, FileList [i]);

        hdl = FindFirstFile(wszPath, & FileFind);

        if (hdl == INVALID_HANDLE_VALUE) {
            if (!first) {
                first = TRUE;
                LOG_ERROR("Error: The following files were not found:");
            }

            LOG_ERROR1("%\tls",wszPath);
        }

        if (hdl != INVALID_HANDLE_VALUE)
            FindClose(hdl);

        i++;
    }

    return !first;
}

HRESULT WlbsRegisterDlls () {
    WCHAR * DllList [] = { 
        L"\\wbem\\wlbsprov.dll",
        NULL
    };
    
    INT i = 0;
    WCHAR pszDllPath [MAX_PATH + 1];
    HINSTANCE hLib;
    CHAR * pszDllEntryPoint = "DllRegisterServer";
    HRESULT (STDAPICALLTYPE * lpDllEntryPoint)(void);
    HRESULT hr = S_OK;

    if (!GetSystemDirectory(pszDllPath, MAX_PATH + 1)) {
        hr = E_UNEXPECTED;
        LOG_ERROR("GetSystemDirectoryFailed.");
        return hr;
    }

    wcscat(pszDllPath, DllList [0]);

    if (FAILED(hr = OleInitialize(NULL))) {
        LOG_ERROR("OleInitialize Failed.");
        return hr;
    }

    hLib = LoadLibrary(pszDllPath);

    if (hLib == NULL) {
        hr = E_UNEXPECTED;
        LOG_ERROR("LoadLibrary for wlbsprov.dll Failed.");
        goto CleanOle;
    }

    (FARPROC &)lpDllEntryPoint = GetProcAddress(hLib, pszDllEntryPoint);

    if (lpDllEntryPoint == NULL) {
        hr = E_UNEXPECTED;
        LOG_ERROR("DllRegisterServer was not found.");
        goto CleanLib;
    }

    if (FAILED(hr = (*lpDllEntryPoint)())) {
        LOG_ERROR("DllRegisterServer failed.");
        goto CleanLib;
    }

    LOG_INFO("Dll Registration Succeeded.");

CleanLib:
    FreeLibrary(hLib);

CleanOle:
    OleUninitialize();

    return hr;
}

HRESULT WlbsCompileMof () {
      WCHAR * MofList [] = {
          L"\\wbem\\wlbsprov.mof",
          NULL
      };

      IMofCompiler * pMofComp = NULL;
      WBEM_COMPILE_STATUS_INFO Info;
      HRESULT hr = S_OK;
      WCHAR pszMofPath [MAX_PATH + 1];

      if (!GetSystemDirectory(pszMofPath, MAX_PATH + 1)) {
          hr = E_UNEXPECTED;
          LOG_ERROR("GetSystemDirectoryFailed.");
          return hr;
      }

      wcscat(pszMofPath, MofList [0]);

      hr = CoInitialize(NULL);

      if (FAILED(hr)) {
          LOG_ERROR("CoInitialize failed.");
          return hr;
      }

      hr = CoCreateInstance(CLSID_MofCompiler, NULL, CLSCTX_INPROC_SERVER, IID_IMofCompiler, (LPVOID *)&pMofComp);

      if (FAILED(hr)) {
          LOG_ERROR("CoCreateInstance Failed.");

          switch (hr) {
          case REGDB_E_CLASSNOTREG:
              LOG_ERROR("Not registered.");
              break;
          case CLASS_E_NOAGGREGATION:
              LOG_ERROR("No aggregration.");
              break;
          default:
              LOG_ERROR1("Error ox%x.", hr);
              break;
          }

          CoUninitialize();

          return hr;
      }

      hr = pMofComp->CompileFile(pszMofPath, NULL, NULL, NULL, NULL, 0, 0, 0, &Info);

      if (hr != WBEM_S_NO_ERROR)
          LOG_ERROR("Compile Failed.");

      pMofComp->Release();

      CoUninitialize();

      return Info.hRes;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\installpack\snetcfg.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       S N E T C F G . C P P
//
//  Contents:   Sample code that demonstrates how to:
//              - find out if a component is installed
//              - install a net component
//              - install an OEM net component
//              - uninstall a net component
//              - enumerate net components
//              - enumerate net adapters using Setup API
//              - enumerate binding paths of a component
//
//  Notes:
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop
#include "snetcfg.h"


//----------------------------------------------------------------------------
// Globals
//
static const GUID* c_aguidClass[] =
{
    &GUID_DEVCLASS_NET,
    &GUID_DEVCLASS_NETTRANS,
    &GUID_DEVCLASS_NETSERVICE,
    &GUID_DEVCLASS_NETCLIENT
};

//----------------------------------------------------------------------------
// Prototypes of helper functions
//
HRESULT HrInstallNetComponent(IN INetCfg* pnc, IN PCWSTR szComponentId,
                              IN const GUID* pguidClass);
HRESULT HrUninstallNetComponent(IN INetCfg* pnc, IN PCWSTR szComponentId);
HRESULT HrGetINetCfg(IN BOOL fGetWriteLock, INetCfg** ppnc);
HRESULT HrReleaseINetCfg(BOOL fHasWriteLock, INetCfg* pnc);
void ShowMessage(IN PCWSTR szMsg, ...);
void ShowHrMessage(IN HRESULT hr);
inline ULONG ReleaseObj(IUnknown* punk)
{
    return (punk) ? punk->Release () : 0;
}


//+---------------------------------------------------------------------------
//
// Function:  HrIsComponentInstalled
//
// Purpose:   Find out if a component is installed
//
// Arguments:
//    szComponentId [in]  id of component to search
//
// Returns:   S_OK    if installed,
//            S_FALSE if not installed,
//            otherwise an error code
//
// Author:    kumarp 11-February-99
//
// Notes:
//
HRESULT HrIsComponentInstalled(IN PCWSTR szComponentId)
{
    HRESULT hr=S_OK;
    INetCfg* pnc;
    INetCfgComponent* pncc;

    hr = HrGetINetCfg(FALSE, &pnc);
    if (S_OK == hr)
    {
        hr = pnc->FindComponent(szComponentId, &pncc);
        if (S_OK == hr)
        {
            ReleaseObj(pncc);
        }
        (void) HrReleaseINetCfg(FALSE, pnc);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  FindIfComponentInstalled
//
// Purpose:   Find out if a component is installed
//
// Arguments:
//    szComponentId [in]  id of component to locate
//
// Returns:   None
//
// Author:    kumarp 11-February-99
//
// Notes:
//
HRESULT FindIfComponentInstalled(IN PCWSTR szComponentId)
{
    HRESULT hr=S_OK;

    hr = HrIsComponentInstalled(szComponentId);
    if (S_OK == hr)
    {
        _tprintf(L"'%s' is installed\n", szComponentId);
    }
    else if (S_FALSE == hr)
    {
        _tprintf(L"'%s' is not installed\n", szComponentId);
    }
    else
    {
        _tprintf(L"Could not find if '%s' is installed. error code: 0x%x\n",
                 szComponentId, hr);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrInstallNetComponent
//
// Purpose:   Install the specified net component
//
// Arguments:
//    szComponentId [in]  component to install
//    nc            [in]  class of the component
//    szInfFullPath [in]  full path to primary INF file
//                        required if the primary INF and other
//                        associated files are not pre-copied to
//                        the right destination dirs.
//                        Not required when installing MS components
//                        since the files are pre-copied by
//                        Windows NT Setup.
//
// Returns:   S_OK or NETCFG_S_REBOOT on success, otherwise an error code
//
// Notes:
//
HRESULT HrInstallNetComponent(IN PCWSTR szComponentId,
                              IN enum NetClass nc,
                              IN PCWSTR szInfFullPath)
{
    HRESULT hr=S_OK;
    INetCfg* pnc;

    // cannot install net adapters this way. they have to be
    // enumerated/detected and installed by PnP

    if ((nc == NC_NetProtocol) ||
        (nc == NC_NetService) ||
        (nc == NC_NetClient))
    {
        ShowMessage(L"Trying to install '%s'...", szComponentId);

        // if full path to INF has been specified, the INF
        // needs to be copied using Setup API to ensure that any other files
        // that the primary INF copies will be correctly found by Setup API
        //
        if (szInfFullPath && wcslen(szInfFullPath))
        {
            WCHAR szInfNameAfterCopy[MAX_PATH+1];
            if (SetupCopyOEMInf(
                    szInfFullPath,
                    NULL,               // other files are in the
                                        // same dir. as primary INF
                    SPOST_PATH,         // first param. contains path to INF
                    0,                  // default copy style
                    szInfNameAfterCopy, // receives the name of the INF
                                        // after it is copied to %windir%\inf
                    MAX_PATH,           // max buf. size for the above
                    NULL,               // receives required size if non-null
                    NULL))              // optionally retrieves filename
                                        // component of szInfNameAfterCopy
            {
                ShowMessage(L"...%s was copied to %s",
                            szInfFullPath,
                            szInfNameAfterCopy);
            }
            else
            {
                DWORD dwError = GetLastError();
                hr = HRESULT_FROM_WIN32(dwError);
            }
        }

        if (S_OK == hr)
        {
            // get INetCfg interface
            hr = HrGetINetCfg(TRUE, &pnc);

            if (SUCCEEDED(hr))
            {
                // install szComponentId
                hr = HrInstallNetComponent(pnc, szComponentId,
                                           c_aguidClass[nc]);
                if (SUCCEEDED(hr))
                {
                    // Apply the changes
                    hr = pnc->Apply();
                }

                // release INetCfg
                (void) HrReleaseINetCfg(TRUE, pnc);
            }
        }
        // show success/failure message
        ShowHrMessage(hr);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrInstallNetComponent
//
// Purpose:   Install the specified net component
//
// Arguments:
//    pnc           [in]  pointer to INetCfg object
//    szComponentId [in]  component to install
//    pguidClass    [in]  class guid of the component
//
// Returns:   S_OK or NETCFG_S_REBOOT on success, otherwise an error code
//
// Notes:
//
HRESULT HrInstallNetComponent(IN INetCfg* pnc,
                              IN PCWSTR szComponentId,
                              IN const GUID* pguidClass)
{
    HRESULT hr=S_OK;
    OBO_TOKEN OboToken;
    INetCfgClassSetup* pncClassSetup;
    INetCfgComponent* pncc;

    // OBO_TOKEN specifies the entity on whose behalf this
    // component is being installed

    // set it to OBO_USER so that szComponentId will be installed
    // On-Behalf-Of "user"
    ZeroMemory (&OboToken, sizeof(OboToken));
    OboToken.Type = OBO_USER;

    hr = pnc->QueryNetCfgClass (pguidClass, IID_INetCfgClassSetup,
                                (void**)&pncClassSetup);
    if (SUCCEEDED(hr))
    {
        hr = pncClassSetup->Install(szComponentId,
                                    &OboToken,
                                    NSF_POSTSYSINSTALL,
                                    0,       // <upgrade-from-build-num>
                                    NULL,    // answerfile name
                                    NULL,    // answerfile section name
                                    &pncc);
        if (S_OK == hr)
        {
            // we dont want to use pncc (INetCfgComponent), release it
            ReleaseObj(pncc);
        }

        ReleaseObj(pncClassSetup);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrUninstallNetComponent
//
// Purpose:   Initialize INetCfg and uninstall a component
//
// Arguments:
//    szComponentId [in]  InfId of component to uninstall (e.g. MS_TCPIP)
//
// Returns:   S_OK or NETCFG_S_REBOOT on success, otherwise an error code
//
// Notes:
//
HRESULT HrUninstallNetComponent(IN PCWSTR szComponentId)
{
    HRESULT hr=S_OK;
    INetCfg* pnc;

    ShowMessage(L"Trying to uninstall '%s'...", szComponentId);

    // get INetCfg interface
    hr = HrGetINetCfg(TRUE, &pnc);

    if (SUCCEEDED(hr))
    {
        // uninstall szComponentId
        hr = HrUninstallNetComponent(pnc, szComponentId);

        if (S_OK == hr)
        {
            // Apply the changes
            hr = pnc->Apply();
        }
        else if (S_FALSE == hr)
        {
            ShowMessage(L"...'%s' is not installed", szComponentId);
        }

        // release INetCfg
        (void) HrReleaseINetCfg(TRUE, pnc);
    }

    // show success/failure message
    ShowHrMessage(hr);

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrUninstallNetComponent
//
// Purpose:   Uninstall the specified component.
//
// Arguments:
//    pnc           [in]  pointer to INetCfg object
//    szComponentId [in]  component to uninstall
//
// Returns:   S_OK or NETCFG_S_REBOOT on success, otherwise an error code
//
// Notes:
//
HRESULT HrUninstallNetComponent(IN INetCfg* pnc, IN PCWSTR szComponentId)
{
    HRESULT hr=S_OK;
    OBO_TOKEN OboToken;
    INetCfgComponent* pncc;
    GUID guidClass;
    INetCfgClass* pncClass;
    INetCfgClassSetup* pncClassSetup;

    // OBO_TOKEN specifies the entity on whose behalf this
    // component is being uninstalld

    // set it to OBO_USER so that szComponentId will be uninstalld
    // On-Behalf-Of "user"
    ZeroMemory (&OboToken, sizeof(OboToken));
    OboToken.Type = OBO_USER;

    // see if the component is really installed
    hr = pnc->FindComponent(szComponentId, &pncc);

    if (S_OK == hr)
    {
        // yes, it is installed. obtain INetCfgClassSetup and DeInstall

        hr = pncc->GetClassGuid(&guidClass);

        if (S_OK == hr)
        {
            hr = pnc->QueryNetCfgClass(&guidClass, IID_INetCfgClass,
                                       (void**)&pncClass);
            if (SUCCEEDED(hr))
            {
                hr = pncClass->QueryInterface(IID_INetCfgClassSetup,
                                              (void**)&pncClassSetup);
                    if (SUCCEEDED(hr))
                    {
                        hr = pncClassSetup->DeInstall (pncc, &OboToken, NULL);

                        ReleaseObj (pncClassSetup);
                    }
                ReleaseObj(pncClass);
            }
        }
        ReleaseObj(pncc);
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
// Function:  HrShowNetAdapters
//
// Purpose:   Display all installed net class devices using Setup API
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
HRESULT HrShowNetAdapters()
{
#define MAX_COMP_INSTID 4096
#define MAX_COMP_DESC   4096

    HRESULT hr=S_OK;
    HDEVINFO hdi;
    DWORD dwIndex=0;
    SP_DEVINFO_DATA deid;
    BOOL fSuccess=FALSE;
    DWORD   cchRequiredSize;
    WCHAR szCompInstanceId[MAX_COMP_INSTID];
    WCHAR szCompDescription[MAX_COMP_DESC];
    DWORD dwRegType;
    BOOL fFound=FALSE;

    // get a list of all devices of class 'GUID_DEVCLASS_NET'
    hdi = SetupDiGetClassDevs(&GUID_DEVCLASS_NET, NULL, NULL, DIGCF_PRESENT);

    if (INVALID_HANDLE_VALUE != hdi)
    {
        // enumerate over each device
        while (deid.cbSize = sizeof(SP_DEVINFO_DATA),
               SetupDiEnumDeviceInfo(hdi, dwIndex, &deid))
        {
            dwIndex++;

            // the right thing to do here would be to call this function
            // to get the size required to hold the instance ID and then
            // to call it second time with a buffer large enough for that size.
            // However, that would tend to obscure the control flow in
            // the sample code. Lets keep things simple by keeping the
            // buffer large enough.

            // get the device instance ID
            fSuccess = SetupDiGetDeviceInstanceId(hdi, &deid,
                                                  szCompInstanceId,
                                                  MAX_COMP_INSTID, NULL);
            if (fSuccess)
            {
                // get the description for this instance
                fSuccess =
                    SetupDiGetDeviceRegistryProperty(hdi, &deid,
                                                     SPDRP_DEVICEDESC,
                                                     &dwRegType,
                                                     (BYTE*) szCompDescription,
                                                     MAX_COMP_DESC,
                                                     NULL);
                if (fSuccess)
                {
                    if (!fFound)
                    {
                        fFound = TRUE;
                        _tprintf(L"Instance ID\tDescription\n");
                        _tprintf(L"-----------\t-----------\n");
                    }
                    _tprintf(L"%s\t%s\n",
                             szCompInstanceId, szCompDescription);
                }
            }
        }

        // release the device info list
        SetupDiDestroyDeviceInfoList(hdi);
    }

    if (!fSuccess)
    {
        DWORD dwError = GetLastError();
        hr = HRESULT_FROM_WIN32(dwError);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrShowNetComponents
//
// Purpose:   Display the list of installed components of the
//            specified class.
//
// Arguments:
//    pnc        [in]  pointer to INetCfg object
//    pguidClass [in]  pointer to class GUID
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
HRESULT HrShowNetComponents(IN INetCfg* pnc,
                            IN const GUID* pguidClass)
{
    HRESULT hr=S_OK;
    PWSTR szInfId;
    PWSTR szDisplayName;
    DWORD dwcc;
    INetCfgComponent* pncc;
    INetCfgClass* pncclass;
    IEnumNetCfgComponent* pencc;
    ULONG celtFetched;

    hr = pnc->QueryNetCfgClass(pguidClass, IID_INetCfgClass,
                               (void**)&pncclass);
    if (SUCCEEDED(hr))
    {
        // get IEnumNetCfgComponent so that we can enumerate
        hr = pncclass->EnumComponents(&pencc);

        ReleaseObj(pncclass);

        while (SUCCEEDED(hr) &&
               (S_OK == (hr = pencc->Next(1, &pncc, &celtFetched))))
        {
            if (pguidClass == &GUID_DEVCLASS_NET)
            {
                // we are interested only in physical netcards
                //
                hr = pncc->GetCharacteristics(&dwcc);

                if (FAILED(hr) || !(dwcc & NCF_PHYSICAL))
                {
                    hr = S_OK;
                    ReleaseObj(pncc);
                    continue;
                }
            }

            hr = pncc->GetId(&szInfId);

            if (S_OK == hr)
            {
                hr = pncc->GetDisplayName(&szDisplayName);
                if (SUCCEEDED(hr))
                {
                    _tprintf(L"%-26s %s\n", szInfId, szDisplayName);

                    CoTaskMemFree(szDisplayName);
                }
                CoTaskMemFree(szInfId);
            }
            // we dont want to stop enumeration just because 1 component
            // failed either GetId or GetDisplayName, therefore reset hr to S_OK
            hr = S_OK;

            ReleaseObj(pncc);
        }
        ReleaseObj(pencc);
    }


    if (S_FALSE == hr)
    {
        hr = S_OK;
    }

    return hr;
}


//+---------------------------------------------------------------------------
//
// Function:  HrShowNetComponents
//
// Purpose:   Display installed net components.
//
// Arguments: None
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
HRESULT HrShowNetComponents()
{
    HRESULT hr=S_OK;
    PCWSTR szClassName;

    static const PCWSTR c_aszClassNames[] =
    {
        L"Network Adapters",
        L"Network Protocols",
        L"Network Services",
        L"Network Clients"
    };

    INetCfg* pnc;

    // get INetCfg interface
    hr = HrGetINetCfg(FALSE, &pnc);

    if (SUCCEEDED(hr))
    {
        for (int i=0; i<4; i++)
        {
            _tprintf(L"\n%s\n-----------------\n", c_aszClassNames[i]);

            (void) HrShowNetComponents(pnc, c_aguidClass[i]);
        }

        // release INetCfg
        hr = HrReleaseINetCfg(FALSE, pnc);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrGetNextBindingInterface
//
// Purpose:   Enumerate over binding interfaces that constitute
//            the given binding path
//
// Arguments:
//    pncbp  [in]  pointer to INetCfgBindingPath object
//    ppncbi [out] pointer to pointer to INetCfgBindingInterface object
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
HRESULT HrGetNextBindingInterface(IN  INetCfgBindingPath* pncbp,
                                  OUT INetCfgBindingInterface** ppncbi)
{
    HRESULT hr=S_OK;
    INetCfgBindingInterface* pncbi=NULL;

    static IEnumNetCfgBindingInterface* pencbi=NULL;

    *ppncbi = NULL;

    // if this is the first call in the enumeration, obtain
    // the IEnumNetCfgBindingInterface interface
    //
    if (!pencbi)
    {
        hr = pncbp->EnumBindingInterfaces(&pencbi);
    }

    if (S_OK == hr)
    {
        ULONG celtFetched;

        // get next binding interface
        hr = pencbi->Next(1, &pncbi, &celtFetched);
    }

    // on the last call (hr == S_FALSE) or on error, release resources

    if (S_OK == hr)
    {
        *ppncbi = pncbi;
    }
    else
    {
        ReleaseObj(pencbi);
        pencbi = NULL;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrGetNextBindingPath
//
// Purpose:   Enumerate over binding paths that start with
//            the specified component
//
// Arguments:
//    pncc              [in]  pointer to INetCfgComponent object
//    dwBindingPathType [in]  type of binding path to retrieve
//    ppncbp            [out] pointer to INetCfgBindingPath interface
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
HRESULT HrGetNextBindingPath(IN  INetCfgComponent* pncc,
                             IN  DWORD  dwBindingPathType,
                             OUT INetCfgBindingPath** ppncbp)
{
    HRESULT hr=S_OK;
    INetCfgBindingPath* pncbp=NULL;

    static IEnumNetCfgBindingPath* pebp=NULL;

    *ppncbp = NULL;

    // if this is the first call in the enumeration, obtain
    // the IEnumNetCfgBindingPath interface
    if (!pebp)
    {
        INetCfgComponentBindings* pnccb=NULL;

        hr = pncc->QueryInterface(IID_INetCfgComponentBindings,
                                  (void**) &pnccb);
        if (S_OK == hr)
        {
            hr = pnccb->EnumBindingPaths(dwBindingPathType, &pebp);
            ReleaseObj(pnccb);
        }
    }

    if (S_OK == hr)
    {
        ULONG celtFetched;

        // get next binding path
        hr = pebp->Next(1, &pncbp, &celtFetched);
    }

    // on the last call (hr == S_FALSE) or on error, release resources

    if (S_OK == hr)
    {
        *ppncbp = pncbp;
    }
    else
    {
        ReleaseObj(pebp);
        pebp = NULL;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrShowBindingPath
//
// Purpose:   Display components of a binding path in the format:
//            foo -> bar -> adapter
//
// Arguments:
//    pncbp [in]  pointer to INetCfgBindingPath object
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
HRESULT HrShowBindingPath(IN INetCfgBindingPath* pncbp)
{
    HRESULT hr=S_OK;
    INetCfgBindingInterface* pncbi;
    INetCfgComponent* pncc = NULL;
    BOOL fFirstInterface=TRUE;
    PWSTR szComponentId;

    while (SUCCEEDED(hr) &&
           (S_OK == (hr = HrGetNextBindingInterface(pncbp, &pncbi))))
    {
        // for the first (top) interface we need to get the upper as well as
        // the lower component. for other interfaces we need to get
        // only the lower component.

        if (fFirstInterface)
        {
            fFirstInterface = FALSE;
            hr = pncbi->GetUpperComponent(&pncc);
            if (SUCCEEDED(hr))
            {
                // get id so that we can display it
                //
                // for readability of the output, we have used the GetId
                // function. For non net class components, this
                // does not pose a problem. In case of net class components,
                // there may be more than one net adapters of the same type
                // in which case, GetId will return the same string. This will
                // make it impossible to distinguish between two binding
                // paths that end in two distinct identical cards. In such case,
                // it may be better to use the GetInstanceGuid function because
                // it will return unique GUID for each instance of an adapter.
                //
                hr = pncc->GetId(&szComponentId);
                ReleaseObj(pncc);
                if (SUCCEEDED(hr))
                {
                    _tprintf(szComponentId);
                    CoTaskMemFree(szComponentId);
                }
            }
        }

        if (SUCCEEDED(hr))
        {
            hr = pncbi->GetLowerComponent(&pncc);
            if (SUCCEEDED(hr))
            {
                hr = pncc->GetId(&szComponentId);
                if (SUCCEEDED(hr))
                {
                    _tprintf(L" -> %s", szComponentId);
                    CoTaskMemFree(szComponentId);
                }
                ReleaseObj(pncc);
            }
        }
        ReleaseObj(pncbi);
    }

    _tprintf(L"\n");

    if (hr == S_FALSE)
    {
        hr = S_OK;
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrShowBindingPathsBelowComponent
//
// Purpose:   Display all binding paths that start with
//            the specified component
//
// Arguments:
//    szComponentId [in]  id of given component (e.g. MS_TCPIP)
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
HRESULT HrShowBindingPathsOfComponent(IN PCWSTR szComponentId)
{
    HRESULT hr=S_OK;
    INetCfg* pnc=NULL;
    INetCfgComponent* pncc=NULL;
    INetCfgBindingPath* pncbp=NULL;

    // get INetCfg interface
    hr = HrGetINetCfg(FALSE, &pnc);

    if (SUCCEEDED(hr))
    {
        // get INetCfgComponent for szComponentId
        hr = pnc->FindComponent(szComponentId, &pncc);
        if (S_OK == hr)
        {
            _tprintf(L"Binding paths starting with '%s'\n\n",
                     szComponentId);

            while (S_OK == (hr = HrGetNextBindingPath(pncc, EBP_BELOW,
                                                      &pncbp)))
            {
                // display the binding path
                hr = HrShowBindingPath(pncbp);
                ReleaseObj(pncbp);
            }

            _tprintf(L"Binding paths ending with '%s'\n\n",
                     szComponentId);

            while (S_OK == (hr = HrGetNextBindingPath(pncc, EBP_ABOVE,
                                                      &pncbp)))
            {
                // display the binding path
                hr = HrShowBindingPath(pncbp);
                ReleaseObj(pncbp);
            }

            ReleaseObj(pncc);
        }
        // release INetCfg
        hr = HrReleaseINetCfg(FALSE, pnc);
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrGetINetCfg
//
// Purpose:   Initialize COM, create and initialize INetCfg.
//            Obtain write lock if indicated.
//
// Arguments:
//    fGetWriteLock [in]  whether to get write lock
//    ppnc          [in]  pointer to pointer to INetCfg object
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
HRESULT HrGetINetCfg(IN BOOL fGetWriteLock,
                     INetCfg** ppnc)
{
    HRESULT hr=S_OK;

    // Initialize the output parameters.
    *ppnc = NULL;

    // initialize COM
    hr = CoInitializeEx(NULL,
                        COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED );

    if (SUCCEEDED(hr))
    {
        // Create the object implementing INetCfg.
        //
        INetCfg* pnc;
        hr = CoCreateInstance(CLSID_CNetCfg, NULL, CLSCTX_INPROC_SERVER,
                              IID_INetCfg, (void**)&pnc);
        if (SUCCEEDED(hr))
        {
            INetCfgLock * pncLock = NULL;
            if (fGetWriteLock)
            {
                // Get the locking interface
                hr = pnc->QueryInterface(IID_INetCfgLock,
                                         (LPVOID *)&pncLock);
                if (SUCCEEDED(hr))
                {
                    // Attempt to lock the INetCfg for read/write
                    static const ULONG c_cmsTimeout = 15000;
                    static const WCHAR c_szSampleNetcfgApp[] =
                        L"Sample Netcfg Application (netcfg.exe)";
                    PWSTR szLockedBy;

                    hr = pncLock->AcquireWriteLock(c_cmsTimeout,
                                                   c_szSampleNetcfgApp,
                                                   &szLockedBy);
                    if (S_FALSE == hr)
                    {
                        hr = NETCFG_E_NO_WRITE_LOCK;
                        _tprintf(L"Could not lock INetcfg, it is already locked by '%s'", szLockedBy);
                    }
                }
            }

            if (SUCCEEDED(hr))
            {
                // Initialize the INetCfg object.
                //
                hr = pnc->Initialize(NULL);
                if (SUCCEEDED(hr))
                {
                    *ppnc = pnc;
                    pnc->AddRef();
                }
                else
                {
                    // initialize failed, if obtained lock, release it
                    if (pncLock)
                    {
                        pncLock->ReleaseWriteLock();
                    }
                }
            }
            ReleaseObj(pncLock);
            ReleaseObj(pnc);
        }

        if (FAILED(hr))
        {
            CoUninitialize();
        }
    }

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  HrReleaseINetCfg
//
// Purpose:   Uninitialize INetCfg, release write lock (if present)
//            and uninitialize COM.
//
// Arguments:
//    fHasWriteLock [in]  whether write lock needs to be released.
//    pnc           [in]  pointer to INetCfg object
//
// Returns:   S_OK on success, otherwise an error code
//
// Notes:
//
HRESULT HrReleaseINetCfg(BOOL fHasWriteLock, INetCfg* pnc)
{
    HRESULT hr = S_OK;

    // uninitialize INetCfg
    hr = pnc->Uninitialize();

    // if write lock is present, unlock it
    if (SUCCEEDED(hr) && fHasWriteLock)
    {
        INetCfgLock* pncLock;

        // Get the locking interface
        hr = pnc->QueryInterface(IID_INetCfgLock,
                                 (LPVOID *)&pncLock);
        if (SUCCEEDED(hr))
        {
            hr = pncLock->ReleaseWriteLock();
            ReleaseObj(pncLock);
        }
    }

    ReleaseObj(pnc);

    CoUninitialize();

    return hr;
}

//+---------------------------------------------------------------------------
//
// Function:  ShowMessage
//
// Purpose:   Helper function to display a message in verbose mode.
//            If not in verbose mode, do nothing.
//
// Arguments:
//    szMsg [in]  message to display
//
// Returns:   None
//
// Notes:
//
void ShowMessage(IN PCWSTR szMsg, ...)
{
    extern BOOL g_fVerbose;

    if (g_fVerbose)
    {
        va_list arglist;

        va_start(arglist, szMsg);
        _vtprintf(szMsg, arglist);
        _tprintf(L"\n");
        fflush(stdout);
        va_end(arglist);
    }
}

//+---------------------------------------------------------------------------
//
// Function:  ShowHrMessage
//
// Purpose:   Helper function to display the status of the last action
//            as indicated by the given HRESULT
//
// Arguments:
//    hr [in]  status code
//
// Returns:   None
//
// Notes:
//
void ShowHrMessage(IN HRESULT hr)
{
    if (SUCCEEDED(hr))
    {
        ShowMessage(L"...done");
        if (NETCFG_S_REBOOT == hr)
        {
            ShowMessage(L"*** You need to reboot your computer for this change to take effect ***");
        }
    }
    else
    {
        ShowMessage(L"..failed. Error code: 0x%lx", hr);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbkd\nlbkd.c ===
/*
 * File: nlbkd.c
 * Description: This file contains the implementation of the NLB KD
 *              debugging extensions.  Use '!load nlbkd.dll' to load
 *              the extensions and '!nlbkd.help' to see the supported
 *              extensions.
 * Author: Created by shouse, 1.4.01
 */

#include "nlbkd.h"
#include "utils.h"
#include "print.h"

WINDBG_EXTENSION_APIS ExtensionApis;
EXT_API_VERSION ApiVersion = { 1, 0, EXT_API_VERSION_NUMBER64, 0 };

#define NL      1
#define NONL    0

USHORT SavedMajorVersion;
USHORT SavedMinorVersion;
BOOL ChkTarget;

/*
 * Function: WinDbgExtensionDllInit
 * Description: Initializes the KD extension DLL.
 * Author: Created by shouse, 1.4.01 - copied largely from ndiskd.dll
 */
VOID WinDbgExtensionDllInit (PWINDBG_EXTENSION_APIS64 lpExtensionApis, USHORT MajorVersion, USHORT MinorVersion) {

    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    ChkTarget = (SavedMajorVersion == 0x0c) ? TRUE : FALSE;
}

/*
 * Function: CheckVersion
 * Description: Checks the extension DLL version against the target version.
 * Author: Created by shouse, 1.4.01 - copied largely from ndiskd.dll
 */
VOID CheckVersion (VOID) {

    /* For now, do nothing. */
    return;

#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}

/*
 * Function: ExtensionApiVersion
 * Description: Returns the API version information. 
 * Author: Created by shouse, 1.4.01 - copied largely from ndiskd.dll
 */
LPEXT_API_VERSION ExtensionApiVersion (VOID) {

    return &ApiVersion;
}

/*
 * Function: help
 * Description: Prints the usage of the NLB KD debugger extensions.
 * Author: Created by shouse, 1.4.01
 */
DECLARE_API (help) {
    dprintf("Network Load Balancing debugger extensions:\n");
    
    dprintf("   version                                  print nlbkd version\n");
    dprintf("   nlbadapters [Verbosity]                  show all NLB adapter blocks\n");
    dprintf("   nlbadapter  <Adapter Block> [Verbosity]  dump an NLB adapter block\n");
    dprintf("   nlbctxt     <Context Block> [Verbosity]  dump an NLB context block\n");
    dprintf("   nlbload     <Load Block> [Verbosity]     dump an NLB load block\n");
    dprintf("   nlbparams   <Params Block> [Verbosity]   dump an NLB parameters block\n");
    dprintf("   nlbresp     <Packet> [Direction]         dump the NLB private data for the specified packet\n");
    dprintf("   nlbconnq    <Queue> [MaxEntries]         dump the contents of a connection descriptor queue\n");
    dprintf("   nlbhash     <Packet>                     determine whether or not NLB will accept this packet\n");
    dprintf("   nlbpkt      <Packet>                     dump an NLB-specific packet whose type is determined\n");
    dprintf("                                              automagically (heartbeat, IGMP, or remote-control)\n");
    dprintf("   nlbmap      <Load Block> <Client IP> <Client Port> <Server IP> <Server Port> [Protocol] [Packet Type]\n");
    dprintf("                                            query map function and retrieve any existing state for this tuple\n");
    dprintf("   nlbteams                                 dump the linked list of NLB BDA teams\n");
    dprintf("\n");
    dprintf("  [Verbosity] is an optional integer from 0 to 2 that determines the level of detail displayed.\n");
    dprintf("  [Direction] is an optional integer that specifies the direction of the packet (RCV=0, SND=1).\n");
    dprintf("  [Protocol] is an optional protocol specification, which can be TCP or UDP.\n");
    dprintf("  [Packet Type] is an optional TCP packet type specification, which can be SYN, DATA, FIN or RST.\n");
    dprintf("\n");
    dprintf("  IP addresses can be in dotted notation or network byte order DWORDs.\n");
}

/*
 * Function: version
 * Description: Prints the NLB KD debugger extension version information.
 * Author: Created by shouse, 1.4.01 - copied largely from ndiskd.dll
 */
DECLARE_API (version) {
#if DBG
    PCSTR kind = "Checked";
#else
    PCSTR kind = "Free";
#endif

    dprintf("%s NLB Extension DLL for Build %d debugging %s kernel for Build %d\n", kind,
            VER_PRODUCTBUILD, SavedMajorVersion == 0x0c ? "Checked" : "Free", SavedMinorVersion);
}

/*
 * Function: nlbadapters
 * Description: Prints all NLB adapter strucutres in use.  Verbosity is always LOW.
 * Author: Created by shouse, 1.5.01
 */
DECLARE_API (nlbadapters) {
    ULONG dwVerbosity = VERBOSITY_LOW;
    CHAR szArgList[10][MAX_PATH];
    CHAR szArgBuffer[MAX_PATH];
    ULONG64 pNumAdapters;
    DWORD dwAdapterSize;
    ULONG dwNumAdapters;
    ULONG64 pAdapter;
    ULONG dwIndex;
    INT index = 0;
    CHAR * str;
    CHAR * p;

    if (args && (*args)) {   
        /* Copy the argument list into a temporary buffer. */
        strcpy(szArgBuffer, args);

        /* Peel out all of the tokenized strings. */
        for (p = mystrtok(szArgBuffer, " \t," ); p && *p; p = mystrtok(NULL, " \t,"))
            strcpy(&szArgList[index++][0], p);
        
        /* If a verbosity was specified, get it. */
        if (index == 1) dwVerbosity = atoi(&szArgList[0][0]);
        
        /* If too many arguments were given, or the verbosity was out of range, complain. */
        if ((index > 1) || (dwVerbosity > VERBOSITY_HIGH)) {
            PrintUsage(USAGE_ADAPTERS);
            return;
        }
    }

    /* Get the address of the global variable containing the number of NLB adapters in use. */
    pNumAdapters = GetExpression(UNIV_ADAPTERS_COUNT);

    if (!pNumAdapters) {
        ErrorCheckSymbols(UNIV_ADAPTERS_COUNT);
        return;
    }

    /* Get the number of adapters from the address. */
    dwNumAdapters = GetUlongFromAddress(pNumAdapters);

    dprintf("Network Load Balancing is currently bound to %u adapter(s).\n", dwNumAdapters);

    /* Get the base address of the global array of NLB adapter structures. */
    pAdapter = GetExpression(UNIV_ADAPTERS);

    if (!pAdapter) {
        ErrorCheckSymbols(UNIV_ADAPTERS);
        return;
    }

    /* Find out the size of a MAIN_ADAPTER structure. */
    dwAdapterSize = GetTypeSize(MAIN_ADAPTER);

    /* Loop through all adapters in use and print some information about them. */
    for (dwIndex = 0; dwIndex < CVY_MAX_ADAPTERS; dwIndex++) {
        ULONG dwValue;

        /* Retrieve the used/unused state of the adapter. */
        GetFieldValue(pAdapter, MAIN_ADAPTER, MAIN_ADAPTER_FIELD_USED, dwValue);
        
        /* If the adapter is in use, or the user specified HIGH verbosity, print the adapter. */
        if (dwValue || (dwVerbosity == VERBOSITY_HIGH)) {
            /* Print the adapter index. */
            dprintf("\n[%u] ", dwIndex);
            
            /* Print the adapter contents.  If verbosity is high, change it to 
               medium - we don't want to recurse into context from here. */
            PrintAdapter(pAdapter, (dwVerbosity == VERBOSITY_HIGH) ? VERBOSITY_MEDIUM : dwVerbosity);
        }

        /* Advance the pointer to the next index in the array of structures. */
        pAdapter += dwAdapterSize;
    }
}

/*
 * Function: nlbadapter
 * Description: Prints NLB adapter information.  Takes an adapter pointer and an
 *              optional verbosity as arguments.  Default verbosity is MEDIUM. 
 * Author: Created by shouse, 1.5.01
 */
DECLARE_API (nlbadapter) {
    ULONG dwVerbosity = VERBOSITY_LOW;
    CHAR szArgList[10][MAX_PATH];
    CHAR szArgBuffer[MAX_PATH];
    ULONG64 pAdapter;
    INT index = 0;
    CHAR * str;
    CHAR * p;
   
    /* Make sure at least one argument, the adapter pointer, is there. */
    if (!args || !(*args)) {
        PrintUsage(USAGE_ADAPTER);
        return;
    }

    /* Get the address of the NLB adapter block from the command line. */
    pAdapter = (ULONG64)GetExpression(args);

    /* Copy the argument list into a temporary buffer. */
    strcpy(szArgBuffer, args);

    /* Peel out all of the tokenized strings. */
    for (p = mystrtok(szArgBuffer, " \t," ); p && *p; p = mystrtok(NULL, " \t,"))
        strcpy(&szArgList[index++][0], p);

    /* If a verbosity was specified, get it. */
    if (index == 2) dwVerbosity = atoi(&szArgList[1][0]);

    /* If too many arguments were given, or the verbosity was out of range, complain. */
    if ((index > 2) || (dwVerbosity > VERBOSITY_HIGH)) {
        PrintUsage(USAGE_ADAPTER);
        return;
    }

    /* Print the adapter contents. */
    PrintAdapter(pAdapter, dwVerbosity);
}

/*
 * Function: nlbctxt 
 * Description: Prints NLB context information.  Takes a context pointer and an
 *              optional verbosity as arguments.  Default verbosity is LOW.
 * Author: Created by shouse, 1.21.01
 */
DECLARE_API (nlbctxt) {
    ULONG dwVerbosity = VERBOSITY_LOW;
    CHAR szArgList[10][MAX_PATH];
    CHAR szArgBuffer[MAX_PATH];
    ULONG64 pContext;
    INT index = 0;
    CHAR * str;
    CHAR * p;
   
    /* Make sure at least one argument, the context pointer, is there. */
    if (!args || !(*args)) {
        PrintUsage(USAGE_CONTEXT);
        return;
    }

    /* Get the address of the NLB context block from the command line. */
    pContext = (ULONG64)GetExpression(args);

    /* Copy the argument list into a temporary buffer. */
    strcpy(szArgBuffer, args);

    /* Peel out all of the tokenized strings. */
    for (p = mystrtok(szArgBuffer, " \t," ); p && *p; p = mystrtok(NULL, " \t,"))
        strcpy(&szArgList[index++][0], p);

    /* If a verbosity was specified, get it. */
    if (index == 2) dwVerbosity = atoi(&szArgList[1][0]);

    /* If too many arguments were given, or the verbosity was out of range, complain. */
    if ((index > 2) || (dwVerbosity > VERBOSITY_HIGH)) {
        PrintUsage(USAGE_CONTEXT);
        return;
    }

    /* Print the context contents. */
    PrintContext(pContext, dwVerbosity);
}

/*
 * Function: nlbload
 * Description: Prints NLB load information.  Takes a load pointer and an optional
 *              verbosity as arguments.  Default verbosity is LOW. 
 * Author: Created by shouse, 2.1.01
 */
DECLARE_API (nlbload) {
    ULONG dwVerbosity = VERBOSITY_LOW;
    CHAR szArgList[10][MAX_PATH];
    CHAR szArgBuffer[MAX_PATH];
    ULONG64 pLoad;
    INT index = 0;
    CHAR * str;
    CHAR * p;
   
    /* Make sure at least one argument, the load pointer, is there. */
    if (!args || !(*args)) {
        PrintUsage(USAGE_LOAD);
        return;
    }

    /* Get the address of the NLB load block from the command line. */
    pLoad = (ULONG64)GetExpression(args);

    /* Copy the argument list into a temporary buffer. */
    strcpy(szArgBuffer, args);

    /* Peel out all of the tokenized strings. */
    for (p = mystrtok(szArgBuffer, " \t," ); p && *p; p = mystrtok(NULL, " \t,"))
        strcpy(&szArgList[index++][0], p);

    /* If a verbosity was specified, get it. */
    if (index == 2) dwVerbosity = atoi(&szArgList[1][0]);

    /* If too many arguments were given, or the verbosity was out of range, complain. */
    if ((index > 2) || (dwVerbosity > VERBOSITY_HIGH)) {
        PrintUsage(USAGE_LOAD);
        return;
    }

    /* Print the load contents. */
    PrintLoad(pLoad, dwVerbosity);
}

/*
 * Function: nlbparams
 * Description: Prints NLB parameter information.  Takes a parameter pointer and an
 *              optional verbosity as arguments.  Default verbosity is LOW.
 * Author: Created by shouse, 1.21.01
 */
DECLARE_API (nlbparams) {
    ULONG dwVerbosity = VERBOSITY_LOW;
    CHAR szArgList[10][MAX_PATH];
    CHAR szArgBuffer[MAX_PATH];
    ULONG64 pParams;
    INT index = 0;
    CHAR * str;
    CHAR * p;
   
    /* Make sure at least one argument, the params pointer, is there. */
    if (!args || !(*args)) {
        PrintUsage(USAGE_PARAMS);
        return;
    }

    /* Get the address of the NLB params block from the command line. */
    pParams = (ULONG64)GetExpression(args);

    /* Copy the argument list into a temporary buffer. */
    strcpy(szArgBuffer, args);

    /* Peel out all of the tokenized strings. */
    for (p = mystrtok(szArgBuffer, " \t," ); p && *p; p = mystrtok(NULL, " \t,"))
        strcpy(&szArgList[index++][0], p);

    /* If a verbosity was specified, get it. */
    if (index == 2) dwVerbosity = atoi(&szArgList[1][0]);

    /* If too many arguments were given, or the verbosity was out of range, complain. */
    if ((index > 2) || (dwVerbosity > VERBOSITY_HIGH)) {
        PrintUsage(USAGE_PARAMS);
        return;
    }

    /* Print the parameter contents. */
    PrintParams(pParams, dwVerbosity);
}

/*
 * Function: nlbresp
 * Description: Prints out the NLB private packet data for a given packet.  Takes a
 *              packet pointer and an optional direction as arguments.  If not specified, 
 *              the packet is presumed to be on the receive path.
 * Author: Created by shouse, 1.31.01
 */
DECLARE_API (nlbresp) {
    ULONG dwDirection = DIRECTION_RECEIVE;
    CHAR szArgList[10][MAX_PATH];
    CHAR szArgBuffer[MAX_PATH];
    ULONG64 pPacket;
    INT index = 0;
    CHAR * str;
    CHAR * p;
   
    /* Make sure at least one argument, the packet pointer, is there. */
    if (!args || !(*args)) {
        PrintUsage(USAGE_RESP);
        return;
    }

    /* Get the address of the NDIS packet from the command line. */
    pPacket = (ULONG64)GetExpression(args);

    /* Copy the argument list into a temporary buffer. */
    strcpy(szArgBuffer, args);

    /* Peel out all of the tokenized strings. */
    for (p = mystrtok(szArgBuffer, " \t," ); p && *p; p = mystrtok(NULL, " \t,"))
        strcpy(&szArgList[index++][0], p);

    /* If a direction was specified, get it. */
    if (index == 2) dwDirection = atoi(&szArgList[1][0]);

    /* If too many arguments were given, or the direction was out of range, complain. */
    if ((index > 2) || (dwDirection > DIRECTION_SEND)) {
        PrintUsage(USAGE_RESP);
        return;
    }

    /* Print the NLB private data buffer contents. */
    PrintResp(pPacket, dwDirection);
}

/*
 * Function: nlbadapters
 * Description: Prints all NLB adapter strucutres in use.  Verbosity is always LOW.
 * Author: Created by shouse, 1.5.01
 */
DECLARE_API (nlbteams) {
    ULONG64 pTeam;
    ULONG64 pAddr;
    ULONG dwNumTeams = 0;
    ULONG dwValue;

    /* Get the base address of the global linked list of BDA teams. */
    pAddr = GetExpression(UNIV_BDA_TEAMS);

    if (!pAddr) {
        ErrorCheckSymbols(UNIV_BDA_TEAMS);
        return;
    }

    /* Get the pointer to the first team. */
    pTeam = GetPointerFromAddress(pAddr);

    dprintf("NLB bi-directional affinity teams:\n");

    /* Loop through all teams in the list and print them out. */
    while (pTeam) {
        /* Increment the number of teams found - only used if none are found. */
        dwNumTeams++;

        dprintf("\n");

        /* Print out the team. */
        PrintBDATeam(pTeam);
        
       /* Get the offset of the params pointer. */
        if (GetFieldOffset(BDA_TEAM, BDA_TEAM_FIELD_NEXT, &dwValue))
            dprintf("Can't get offset of %s in %s\n", BDA_TEAM_FIELD_NEXT, BDA_TEAM);
        else {
            pAddr = pTeam + dwValue;
            
            /* Retrieve the pointer. */
            pTeam = GetPointerFromAddress(pAddr);
        }
    }

    if (!dwNumTeams) dprintf("\nNone.\n");
}

/*
 * Function: nlbconnq
 * Description: This function prints out all connection descriptors in a given
 *              queue of descriptors.
 * Author: Created by shouse, 4.15.01
 */
DECLARE_API (nlbconnq) {
    ULONG dwMaxEntries = 0xffffffff;
    CHAR szArgList[10][MAX_PATH];
    CHAR szArgBuffer[MAX_PATH];
    ULONG64 pQueue;
    INT index = 0;
    CHAR * str;
    CHAR * p;
   
    /* Make sure at least one argument, the queue pointer, is there. */
    if (!args || !(*args)) {
        PrintUsage(USAGE_CONNQ);
        return;
    }

    /* Get the address of the queue from the command line. */
    pQueue = (ULONG64)GetExpression(args);

    /* Copy the argument list into a temporary buffer. */
    strcpy(szArgBuffer, args);

    /* Peel out all of the tokenized strings. */
    for (p = mystrtok(szArgBuffer, " \t," ); p && *p; p = mystrtok(NULL, " \t,"))
        strcpy(&szArgList[index++][0], p);

    /* If a maximum number of entries to print was specified, get it. */
    if (index == 2) dwMaxEntries = atoi(&szArgList[1][0]);

    /* If too many arguments were given,complain. */
    if (index > 2) {
        PrintUsage(USAGE_RESP);
        return;
    }

    /* Print the NLB private data buffer contents. */
    PrintQueue(pQueue, dwMaxEntries);
}

/*
 * Function: nlbmap
 * Description: This function will perform the NLB hashing algorithm to determine
 *              whether a given packet - identified by a (Src IP, Src port, Dst IP,
 *              Dst port) tuple would be handled by this host or another host.
 *              Further, if the connection is a known TCP connection, the associated
 *              descriptor and state information are displayed.
 * Author: 
 */
DECLARE_API (nlbmap) {
    CHAR szArgList[10][MAX_PATH];
    CHAR szArgBuffer[MAX_PATH];
    TCP_PACKET_TYPE ePktType = SYN;
    ULONG64 pLoad;
    ULONG dwClientIPAddress;
    ULONG dwClientPort;
    ULONG dwServerIPAddress;
    ULONG dwServerPort;
    BOOLEAN bIsTCP = TRUE;
    INT index = 0;
    CHAR * str;
    CHAR * p;
   
    /* Make sure that the load pointer is there. */
    if (!args || !(*args)) {
        PrintUsage(USAGE_MAP);
        return;
    }

    /* Get the address of the load module from the command line. */
    pLoad = (ULONG64)GetExpression(args);

    /* Copy the argument list into a temporary buffer. */
    strcpy(szArgBuffer, args);

    /* Peel out all of the tokenized strings. */
    for (p = mystrtok(szArgBuffer, " \t," ); p && *p; p = mystrtok(NULL, " \t,"))
        strcpy(&szArgList[index++][0], p);

    /* If too many arguments were given, complain. */
    if ((index > 7) || (index < 5)) {
        PrintUsage(USAGE_MAP);
        return;
    }

    /* If we find a '.' in the IP address, then we need to convert it using inet_addr.  
       If there is no '.', then we assume its already a DWORD in network byte order. */
    if (strchr(szArgList[1], '.'))
        dwClientIPAddress = inet_addr(szArgList[1]);
    else
        dwClientIPAddress = atoi(&szArgList[1][0]);

    dwClientPort = atoi(&szArgList[2][0]);

    /* Make sure the port is between 0 and 65535. */
    if (dwClientPort > CVY_MAX_PORT) {
        dprintf("Invalid port: %s\n", dwClientPort);
        return;
    }

    /* If we find a '.' in the IP address, then we need to convert it using inet_addr.  
       If there is no '.', then we assume its already a DWORD in network byte order. */
    if (strchr(szArgList[1], '.'))
        dwServerIPAddress = inet_addr(szArgList[3]);
    else
        dwServerIPAddress = atoi(&szArgList[3][0]);

    dwServerPort = atoi(&szArgList[4][0]);

    /* Make sure the port is between 0 and 65535. */
    if (dwServerPort > CVY_MAX_PORT) {
        dprintf("Invalid port: %s\n", dwServerPort);
        return;
    }

    /* If a sixth argument has been specified, it is the protocol, which should be either TCP or UDP. */
    if (index >= 6) {
        if (!_stricmp(szArgList[5], "TCP")) {
            bIsTCP = TRUE;
        } else if (!_stricmp(szArgList[5], "UDP")) {
            bIsTCP = FALSE;
        } else {
            dprintf("Invalid protocol: %s\n", szArgList[5]);
            return;
        }
    }

    /* If an seventh argument has been specified, it is TCP packet type, which should be SYN, DATA, FIN or RST. */
    if (index >= 7) {
        if (!bIsTCP) {
            dprintf("UDP connections do not have packet types\n");
            return;
        }

        if (!_stricmp(szArgList[6], "SYN")) {
            ePktType = SYN;
        } else if (!_stricmp(szArgList[6], "DATA")) {
            ePktType = DATA;
        } else if (!_stricmp(szArgList[6], "FIN")) {
            ePktType = FIN;
        } else if (!_stricmp(szArgList[6], "RST")) {
            ePktType = RST;
        } else {
            dprintf("Invalid TCP packet type: %s\n", szArgList[6]);
            return;
        }
    }

    /* Hash on this tuple and print the results. */
    PrintMap(pLoad, dwClientIPAddress, dwClientPort, dwServerIPAddress, dwServerPort, bIsTCP, ePktType);
}

/*
 * Function: nlbhash
 * Description: 
 * Author: Created by shouse, 4.15.01
 */
DECLARE_API (nlbhash) {

    dprintf("This extension has not yet been implemented.\n");
}

/*
 * Function: nlbpkt
 * Description: Prints out the contents of an NLB-specific packet.  Takes a packet
 *              pointer as an argument.
 * Author: Created by shouse, 2.1.01
 */
DECLARE_API (nlbpkt) {

    dprintf("This extension should take a packet pointer and parse the packet to\n");
    dprintf("  determine whether it is an NLB heartbeat, remote control or IGMP join.\n");
    dprintf("  If the packet is one of those NLB-specific types, it will dump the\n");
    dprintf("  contents of the packet.  Otherwise, it prints just basic packet info,\n");
    dprintf("  such as source and destination IP addresses and port numbers.\n");

    dprintf("\n");

    dprintf("This extension has not yet been implemented.\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbkd\nlbkd.h ===
/*
 * File: nlbkd.h
 * Description: This file contains definitions and function prototypes
 *              for the NLB KD extensions, nlbkd.dll.
 * History: Created by shouse, 1.4.01
 */

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntverp.h>
#include <windef.h>
#include <winbase.h>
#include <ntosp.h>
#include <wdmguid.h>
#include <wmistr.h>
#include <winsock2.h>
#include <wdbgexts.h>
#include <stdlib.h>
#include <ndis.h>

/* Define the different types of TCP packets. */
typedef enum _TCP_PACKET_TYPE {
    SYN = 0,
    DATA,
    FIN,
    RST
} TCP_PACKET_TYPE;

/* Define the levels of verbosity. */
#define VERBOSITY_LOW                             0
#define VERBOSITY_MEDIUM                          1
#define VERBOSITY_HIGH                            2

/* Define the packet directions. */
#define DIRECTION_RECEIVE                         0
#define DIRECTION_SEND                            1

/* Define the IDs for usage informations. */
#define USAGE_ADAPTERS                            0
#define USAGE_ADAPTER                             1
#define USAGE_CONTEXT                             2
#define USAGE_PARAMS                              3
#define USAGE_LOAD                                4
#define USAGE_RESP                                5
#define USAGE_CONNQ                               6
#define USAGE_MAP                                 7

/* Copy some common NLB defines from various sources. */
#define CVY_MAX_ADAPTERS                          16
#define CVY_MAX_HOSTS                             32
#define CVY_MAX_RULES                             33
#define CVY_MAX_BINS                              60
#define CVY_MAX_VIRTUAL_NIC                       256
#define CVY_MAX_CL_IP_ADDR                        17
#define CVY_MAX_CL_NET_MASK                       17
#define CVY_MAX_DED_IP_ADDR                       17
#define CVY_MAX_DED_NET_MASK                      17
#define CVY_MAX_CL_IGMP_ADDR                      17
#define CVY_MAX_NETWORK_ADDR                      17
#define CVY_MAX_DOMAIN_NAME                       100
#define CVY_MAX_BDA_TEAM_ID                       40
#define CVY_BDA_INVALID_MEMBER_ID                 CVY_MAX_ADAPTERS
#define CVY_MAX_PORT                              65535
#define CVY_TCP                                   1
#define CVY_UDP                                   2
#define CVY_TCP_UDP                               3
#define CVY_SINGLE                                1
#define CVY_MULTI                                 2
#define CVY_NEVER                                 3
#define CVY_AFFINITY_NONE                         0
#define CVY_AFFINITY_SINGLE                       1
#define CVY_AFFINITY_CLASSC                       2
#define HST_NORMAL                                1
#define HST_STABLE                                2
#define HST_CVG                                   3
#define MAIN_PACKET_TYPE_NONE                     0
#define MAIN_PACKET_TYPE_PING                     1
#define MAIN_PACKET_TYPE_INDICATE                 2
#define MAIN_PACKET_TYPE_PASS                     3
#define MAIN_PACKET_TYPE_CTRL                     4
#define MAIN_PACKET_TYPE_TRANSFER                 6
#define MAIN_PACKET_TYPE_IGMP                     7
#define MAIN_FRAME_UNKNOWN                        0
#define MAIN_FRAME_DIRECTED                       1
#define MAIN_FRAME_MULTICAST                      2
#define MAIN_FRAME_BROADCAST                      3
#define CVY_ALL_VIP                               0xffffffff

/* Copy the code check IDs from various sources. */
#define MAIN_ADAPTER_CODE                         0xc0deadbe
#define MAIN_CTXT_CODE                            0xc0dedead
#define LOAD_CTXT_CODE                            0xc0deba1c
#define BIN_STATE_CODE                            0xc0debabc

/* Some NDIS defines and global variables we need. */
#define NDIS_PACKET_STACK_SIZE                    "ndis!ndisPacketStackSize"
#define STACK_INDEX                               "ndis!STACK_INDEX"
#define NDIS_PACKET_STACK                         "ndis!NDIS_PACKET_STACK"
#define NDIS_PACKET_STACK_FIELD_IMRESERVED        "IMReserved"
#define NDIS_PACKET_WRAPPER                       "ndis!NDIS_PACKET_WRAPPER"
#define NDIS_PACKET_WRAPPER_FIELD_STACK_INDEX     "StackIndex.Index"
#define NDIS_PACKET                               "ndis!NDIS_PACKET"
#define NDIS_PACKET_FIELD_MPRESERVED              "MiniportReserved"
#define NDIS_PACKET_FIELD_PROTRESERVED            "ProtocolReserved" 

/* Global NLB variables that we're accessing. */
#define UNIV_ADAPTERS_COUNT                       "wlbs!univ_adapters_count"
#define UNIV_ADAPTERS                             "wlbs!univ_adapters"
#define UNIV_BDA_TEAMS                            "wlbs!univ_bda_teaming_list"

/* Members of MAIN_PROTOCOL_RESERVED. */
#define MAIN_PROTOCOL_RESERVED                    "wlbs!MAIN_PROTOCOL_RESERVED"
#define MAIN_PROTOCOL_RESERVED_FIELD_MISCP        "miscp"
#define MAIN_PROTOCOL_RESERVED_FIELD_TYPE         "type"
#define MAIN_PROTOCOL_RESERVED_FIELD_GROUP        "group"
#define MAIN_PROTOCOL_RESERVED_FIELD_DATA         "data"
#define MAIN_PROTOCOL_RESERVED_FIELD_LENGTH       "len"

/* Members of MAIN_ADAPTER. */
#define MAIN_ADAPTER                              "wlbs!MAIN_ADAPTER"
#define MAIN_ADAPTER_FIELD_CODE                   "code"
#define MAIN_ADAPTER_FIELD_USED                   "used"
#define MAIN_ADAPTER_FIELD_INITED                 "inited"
#define MAIN_ADAPTER_FIELD_BOUND                  "bound"
#define MAIN_ADAPTER_FIELD_ANNOUNCED              "announced"
#define MAIN_ADAPTER_FIELD_CONTEXT                "ctxtp"
#define MAIN_ADAPTER_FIELD_NAME_LENGTH            "device_name_len"
#define MAIN_ADAPTER_FIELD_NAME                   "device_name"

/* Members of MAIN_CTXT. */
#define MAIN_CTXT                                 "wlbs!MAIN_CTXT"
#define MAIN_CTXT_FIELD_CODE                      "code"
#define MAIN_CTXT_FIELD_ADAPTER_ID                "adapter_id"
#define MAIN_CTXT_FIELD_VIRTUAL_NIC               "virtual_nic_name"
#define MAIN_CTXT_FIELD_CL_IP_ADDR                "cl_ip_addr"
#define MAIN_CTXT_FIELD_CL_NET_MASK               "cl_net_mask"
#define MAIN_CTXT_FIELD_CL_BROADCAST              "cl_bcast_addr"
#define MAIN_CTXT_FIELD_CL_MAC_ADDR               "cl_mac_addr"
#define MAIN_CTXT_FIELD_DED_IP_ADDR               "ded_ip_addr"
#define MAIN_CTXT_FIELD_DED_NET_MASK              "ded_net_mask"
#define MAIN_CTXT_FIELD_DED_BROADCAST             "ded_bcast_addr"
#define MAIN_CTXT_FIELD_DED_MAC_ADDR              "ded_mac_addr"
#define MAIN_CTXT_FIELD_IGMP_MCAST_IP             "cl_igmp_addr"

#if defined (SBH)
#define MAIN_CTXT_FIELD_UNICAST_MAC_ADDR          "unic_mac_addr"
#define MAIN_CTXT_FIELD_MULTICAST_MAC_ADDR        "mult_mac_addr"
#define MAIN_CTXT_FIELD_IGMP_MAC_ADDR             "igmp_mac_addr"
#endif /* SBH */

#define MAIN_CTXT_FIELD_MEDIUM                    "medium"
#define MAIN_CTXT_FIELD_MEDIA_CONNECT             "media_connected"
#define MAIN_CTXT_FIELD_MAC_OPTIONS               "mac_options"
#define MAIN_CTXT_FIELD_FRAME_SIZE                "max_frame_size"
#define MAIN_CTXT_FIELD_MCAST_LIST_SIZE           "max_mcast_list_size"
#define MAIN_CTXT_FIELD_PARAMS                    "params"
#define MAIN_CTXT_FIELD_PARAMS_VALID              "params_valid"
#define MAIN_CTXT_FIELD_LOAD                      "load"
#define MAIN_CTXT_FIELD_ENABLED                   "convoy_enabled"
#define MAIN_CTXT_FIELD_DRAINING                  "draining"
#define MAIN_CTXT_FIELD_SUSPENDED                 "suspended"
#define MAIN_CTXT_FIELD_STOPPING                  "stopping"
#define MAIN_CTXT_FIELD_EXHAUSTED                 "packets_exhausted"
#define MAIN_CTXT_FIELD_PING_TIMEOUT              "curr_tout"
#define MAIN_CTXT_FIELD_IGMP_TIMEOUT              "igmp_sent"
#define MAIN_CTXT_FIELD_BIND_HANDLE               "bind_handle"
#define MAIN_CTXT_FIELD_UNBIND_HANDLE             "unbind_handle"
#define MAIN_CTXT_FIELD_MAC_HANDLE                "mac_handle"
#define MAIN_CTXT_FIELD_PROT_HANDLE               "prot_handle"
#define MAIN_CTXT_FIELD_CNTR_RECV_NO_BUF          "cntr_recv_no_buf"
#define MAIN_CTXT_FIELD_CNTR_XMIT_OK              "cntr_xmit_ok"
#define MAIN_CTXT_FIELD_CNTR_RECV_OK              "cntr_recv_ok"
#define MAIN_CTXT_FIELD_CNTR_XMIT_ERROR           "cntr_xmit_err"
#define MAIN_CTXT_FIELD_CNTR_RECV_ERROR           "cntr_recv_err"
#define MAIN_CTXT_FIELD_CNTR_XMIT_FRAMES_DIR      "cntr_xmit_frames_dir"
#define MAIN_CTXT_FIELD_CNTR_XMIT_BYTES_DIR       "cntr_xmit_bytes_dir"
#define MAIN_CTXT_FIELD_CNTR_XMIT_FRAMES_MCAST    "cntr_xmit_frames_mcast"
#define MAIN_CTXT_FIELD_CNTR_XMIT_BYTES_MCAST     "cntr_xmit_bytes_mcast"
#define MAIN_CTXT_FIELD_CNTR_XMIT_FRAMES_BCAST    "cntr_xmit_frames_bcast"
#define MAIN_CTXT_FIELD_CNTR_XMIT_BYTES_BCAST     "cntr_xmit_bytes_bcast"
#define MAIN_CTXT_FIELD_CNTR_RECV_FRAMES_DIR      "cntr_recv_frames_dir"
#define MAIN_CTXT_FIELD_CNTR_RECV_BYTES_DIR       "cntr_recv_bytes_dir"
#define MAIN_CTXT_FIELD_CNTR_RECV_FRAMES_MCAST    "cntr_recv_frames_mcast"
#define MAIN_CTXT_FIELD_CNTR_RECV_BYTES_MCAST     "cntr_recv_bytes_mcast"
#define MAIN_CTXT_FIELD_CNTR_RECV_FRAMES_BCAST    "cntr_recv_frames_bcast"
#define MAIN_CTXT_FIELD_CNTR_RECV_BYTES_BCAST     "cntr_recv_bytes_bcast"
#define MAIN_CTXT_FIELD_RESP                      "resp_list"
#define MAIN_CTXT_FIELD_SEND_POOLS_ALLOCATED      "num_send_packet_allocs"
#define MAIN_CTXT_FIELD_SEND_PACKETS_ALLOCATED    "num_sends_alloced"
#define MAIN_CTXT_FIELD_SEND_POOL_CURRENT         "cur_send_packet_pool"
#define MAIN_CTXT_FIELD_SEND_OUTSTANDING          "num_sends_out"
#define MAIN_CTXT_FIELD_RECV_POOLS_ALLOCATED      "num_recv_packet_allocs"
#define MAIN_CTXT_FIELD_RECV_PACKETS_ALLOCATED    "num_recvs_alloced"
#define MAIN_CTXT_FIELD_RECV_POOL_CURRENT         "cur_recv_packet_pool"
#define MAIN_CTXT_FIELD_RECV_OUTSTANDING          "num_recvs_out"
#define MAIN_CTXT_FIELD_BUF_POOLS_ALLOCATED       "num_buf_allocs"
#define MAIN_CTXT_FIELD_BUFS_ALLOCATED            "num_bufs_alloced"
#define MAIN_CTXT_FIELD_BUFS_OUTSTANDING          "num_bufs_out"
#define MAIN_CTXT_FIELD_CNTR_PING_NO_BUF          "cntr_recv_no_buf" /* Not right. */
#define MAIN_CTXT_FIELD_PING_PACKETS_ALLOCATED    "num_send_msgs"
#define MAIN_CTXT_FIELD_PING_OUTSTANDING          "num_recvs_out" /* Not right. */
#define MAIN_CTXT_FIELD_BDA_TEAMING               "bda_teaming"

/* Lookaside list members we access. */
#define GENERAL_LOOKASIDE                         "_GENERAL_LOOKASIDE"
#define GENERAL_LOOKASIDE_FIELD_SIZE              "Size"
#define GENERAL_LOOKASIDE_FIELD_ALLOCATES         "TotalAllocates"
#define GENERAL_LOOKASIDE_FIELD_FREES             "TotalFrees"

/* BDA participant members. */
#define BDA_MEMBER                                "wlbs!_BDA_MEMBER"
#define BDA_MEMBER_FIELD_ACTIVE                   "active"
#define BDA_MEMBER_FIELD_MEMBER_ID                "member_id"
#define BDA_MEMBER_FIELD_MASTER                   "master"
#define BDA_MEMBER_FIELD_REVERSE_HASH             "reverse_hash"
#define BDA_MEMBER_FIELD_TEAM                     "bda_team"

/* BDA team members. */
#define BDA_TEAM                                  "wlbs!_BDA_TEAM"
#define BDA_TEAM_FIELD_ACTIVE                     "active"
#define BDA_TEAM_FIELD_PREV                       "prev"
#define BDA_TEAM_FIELD_NEXT                       "next"
#define BDA_TEAM_FIELD_LOAD                       "load"
#define BDA_TEAM_FIELD_LOAD_LOCK                  "load_lock"
#define BDA_TEAM_FIELD_MEMBERSHIP_COUNT           "membership_count"
#define BDA_TEAM_FIELD_MEMBERSHIP_FINGERPRINT     "membership_fingerprint"
#define BDA_TEAM_FIELD_MEMBERSHIP_MAP             "membership_map"
#define BDA_TEAM_FIELD_CONSISTENCY_MAP            "consistency_map"
#define BDA_TEAM_FIELD_TEAM_ID                    "team_id"

/* Members of CVY_PARAMS. */
#define CVY_PARAMS                                "wlbs!CVY_PARAMS"
#define CVY_PARAMS_FIELD_VERSION                  "parms_ver"
#define CVY_PARAMS_FIELD_HOST_PRIORITY            "host_priority"
#define CVY_PARAMS_FIELD_MULTICAST_SUPPORT        "mcast_support"
#define CVY_PARAMS_FIELD_IGMP_SUPPORT             "igmp_support"
#define CVY_PARAMS_FIELD_INITIAL_STATE            "cluster_mode"
#define CVY_PARAMS_FIELD_REMOTE_CONTROL_ENABLED   "rct_enabled"
#define CVY_PARAMS_FIELD_REMOTE_CONTROL_PORT      "rct_port"
#define CVY_PARAMS_FIELD_REMOTE_CONTROL_PASSWD    "rct_password"
#define CVY_PARAMS_FIELD_CL_IP_ADDR               "cl_ip_addr"
#define CVY_PARAMS_FIELD_CL_NET_MASK              "cl_net_mask"
#define CVY_PARAMS_FIELD_CL_MAC_ADDR              "cl_mac_addr"
#define CVY_PARAMS_FIELD_CL_IGMP_ADDR             "cl_igmp_addr"
#define CVY_PARAMS_FIELD_CL_NAME                  "domain_name"
#define CVY_PARAMS_FIELD_DED_IP_ADDR              "ded_ip_addr"
#define CVY_PARAMS_FIELD_DED_NET_MASK             "ded_net_mask"
#define CVY_PARAMS_FIELD_NUM_RULES                "num_rules"
#define CVY_PARAMS_FIELD_PORT_RULES               "port_rules"
#define CVY_PARAMS_FIELD_ALIVE_PERIOD             "alive_period"
#define CVY_PARAMS_FIELD_ALIVE_TOLERANCE          "alive_tolerance"
#define CVY_PARAMS_FIELD_NUM_ACTIONS              "num_actions"
#define CVY_PARAMS_FIELD_NUM_PACKETS              "num_packets"
#define CVY_PARAMS_FIELD_NUM_PINGS                "num_send_msgs"
#define CVY_PARAMS_FIELD_NUM_DESCR                "dscr_per_alloc"
#define CVY_PARAMS_FIELD_MAX_DESCR                "max_dscr_allocs"
#define CVY_PARAMS_FIELD_NBT_SUPPORT              "nbt_support"
#define CVY_PARAMS_FIELD_MCAST_SPOOF              "mcast_spoof"
#define CVY_PARAMS_FIELD_NETMON_PING              "netmon_alive"
#define CVY_PARAMS_FIELD_MASK_SRC_MAC             "mask_src_mac"
#define CVY_PARAMS_FIELD_CONVERT_MAC              "convert_mac"
#define CVY_PARAMS_FIELD_IP_CHANGE_DELAY          "ip_chg_delay"
#define CVY_PARAMS_FIELD_CLEANUP_DELAY            "cleanup_delay"
#define CVY_PARAMS_FIELD_BDA_TEAMING              "bda_teaming"

/* Members of BDA teaming. */
#define CVY_BDA                                   "wlbs!_CVY_BDA"
#define CVY_BDA_FIELD_ACTIVE                      "active"
#define CVY_BDA_FIELD_MASTER                      "master"
#define CVY_BDA_FIELD_REVERSE_HASH                "reverse_hash"
#define CVY_BDA_FIELD_TEAM_ID                     "team_id"

/* Members of CVY_RULE. */
#define CVY_RULE                                  "wlbs!CVY_RULE"
#define CVY_RULE_FIELD_VIP                        "virtual_ip_addr"
#define CVY_RULE_FIELD_START_PORT                 "start_port"
#define CVY_RULE_FIELD_END_PORT                   "end_port"
#define CVY_RULE_FIELD_PROTOCOL                   "protocol"
#define CVY_RULE_FIELD_MODE                       "mode"
#define CVY_RULE_FIELD_PRIORITY                   "mode_data.single.priority"
#define CVY_RULE_FIELD_EQUAL_LOAD                 "mode_data.multi.equal_load"
#define CVY_RULE_FIELD_LOAD_WEIGHT                "mode_data.multi.load"
#define CVY_RULE_FIELD_AFFINITY                   "mode_data.multi.affinity"

/* Members of LOAD_CTXT. */
#define LOAD_CTXT                                 "wlbs!LOAD_CTXT"
#define LOAD_CTXT_FIELD_CODE                      "code"
#define LOAD_CTXT_FIELD_HOST_ID                   "my_host_id"
#define LOAD_CTXT_FIELD_REF_COUNT                 "ref_count"
#define LOAD_CTXT_FIELD_INIT                      "initialized"
#define LOAD_CTXT_FIELD_ACTIVE                    "active"
#define LOAD_CTXT_FIELD_PACKET_COUNT              "pkt_count"
#define LOAD_CTXT_FIELD_CONNECTIONS               "nconn"
#define LOAD_CTXT_FIELD_CONSISTENT                "consistent"
#define LOAD_CTXT_FIELD_DUP_HOST_ID               "dup_hosts"
#define LOAD_CTXT_FIELD_DUP_PRIORITY              "dup_sspri"
#define LOAD_CTXT_FIELD_BAD_TEAM_CONFIG           "bad_team_config"
#define LOAD_CTXT_FIELD_BAD_NUM_RULES             "bad_num_rules"
#define LOAD_CTXT_FIELD_BAD_NEW_MAP               "bad_map"
#define LOAD_CTXT_FIELD_OVERLAPPING_MAP           "overlap_maps"
#define LOAD_CTXT_FIELD_RECEIVING_BINS            "err_rcving_bins"
#define LOAD_CTXT_FIELD_ORPHANED_BINS             "err_orphans"
#define LOAD_CTXT_FIELD_HOST_MAP                  "host_map"
#define LOAD_CTXT_FIELD_PING_MAP                  "ping_map"
#define LOAD_CTXT_FIELD_LAST_MAP                  "last_hmap"
#define LOAD_CTXT_FIELD_STABLE_MAP                "stable_map"
#define LOAD_CTXT_FIELD_MIN_STABLE                "min_stable_ct"
#define LOAD_CTXT_FIELD_LOCAL_STABLE              "my_stable_ct"
#define LOAD_CTXT_FIELD_ALL_STABLE                "all_stable_ct"
#define LOAD_CTXT_FIELD_DEFAULT_TIMEOUT           "def_timeout"
#define LOAD_CTXT_FIELD_CURRENT_TIMEOUT           "cur_timeout"
#define LOAD_CTXT_FIELD_PING_TOLERANCE            "min_missed_pings"
#define LOAD_CTXT_FIELD_PING_MISSED               "nmissed_pings"
#define LOAD_CTXT_FIELD_CLEANUP_WAITING           "cln_waiting"
#define LOAD_CTXT_FIELD_CLEANUP_TIMEOUT           "cln_timeout"
#define LOAD_CTXT_FIELD_CLEANUP_CURRENT           "cur_time"
#define LOAD_CTXT_FIELD_DESCRIPTORS_PER_ALLOC     "dscr_per_alloc"
#define LOAD_CTXT_FIELD_MAX_DESCRIPTOR_ALLOCS     "max_dscr_allocs"
#define LOAD_CTXT_FIELD_NUM_DESCRIPTOR_ALLOCS     "nqalloc"
#define LOAD_CTXT_FIELD_INHIBITED_ALLOC           "alloc_inhibited"
#define LOAD_CTXT_FIELD_FAILED_ALLOC              "alloc_failed"
#define LOAD_CTXT_FIELD_DIRTY_BINS                "dirty_bin"
#define LOAD_CTXT_FIELD_PING                      "send_msg"
#define LOAD_CTXT_FIELD_PORT_RULE_STATE           "pg_state"
#define LOAD_CTXT_FIELD_PARAMS                    "params"

/* Members of PING_MSG. */
#define PING_MSG                                  "wlbs!PING_MSG"
#define PING_MSG_FIELD_HOST_ID                    "host_id"
#define PING_MSG_FIELD_DEFAULT_HOST_ID            "master_id"
#define PING_MSG_FIELD_STATE                      "state"
#define PING_MSG_FIELD_NUM_RULES                  "nrules"
#define PING_MSG_FIELD_HOST_CODE                  "hcode"
#define PING_MSG_FIELD_TEAMING_CODE               "teaming"
#define PING_MSG_FIELD_PACKET_COUNT               "pkt_count"
#define PING_MSG_FIELD_RULE_CODE                  "rcode"
#define PING_MSG_FIELD_CURRENT_MAP                "cur_map"
#define PING_MSG_FIELD_NEW_MAP                    "new_map"
#define PING_MSG_FIELD_IDLE_MAP                   "idle_map"
#define PING_MSG_FIELD_READY_BINS                 "rdy_bins"
#define PING_MSG_FIELD_LOAD_AMOUNT                "load_amt"

/* Members of BIN_STATE. */
#define BIN_STATE                                 "wlbs!BIN_STATE"
#define BIN_STATE_FIELD_CODE                      "code"
#define BIN_STATE_FIELD_INDEX                     "index"
#define BIN_STATE_FIELD_INITIALIZED               "initialized"
#define BIN_STATE_FIELD_COMPATIBLE                "compatible"
#define BIN_STATE_FIELD_EQUAL                     "equal_bal"
#define BIN_STATE_FIELD_MODE                      "mode"
#define BIN_STATE_FIELD_AFFINITY                  "affinity"
#define BIN_STATE_FIELD_PROTOCOL                  "prot"
#define BIN_STATE_FIELD_ORIGINAL_LOAD             "orig_load_amt"
#define BIN_STATE_FIELD_CURRENT_LOAD              "load_amt"
#define BIN_STATE_FIELD_TOTAL_LOAD                "tot_load"
#define BIN_STATE_FIELD_TOTAL_CONNECTIONS         "tconn"
#define BIN_STATE_FIELD_CURRENT_MAP               "cmap"
#define BIN_STATE_FIELD_ALL_IDLE_MAP              "all_idle_map"
#define BIN_STATE_FIELD_IDLE_BINS                 "idle_bins"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\installpack\uninstall.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997.
//
//  File:       M A I N . C P P
//
//  Contents:   Code to provide a simple cmdline interface to
//              the sample code functions
//
//  Notes:      The code in this file is not required to access any
//              netcfg functionality. It merely provides a simple cmdline
//              interface to the sample code functions provided in
//              file snetcfg.cpp.
//
//  Author:     kumarp    28-September-98
//
//----------------------------------------------------------------------------

#include "pch.h"
#pragma hdrstop

#include "snetcfg.h"
#include <wbemcli.h>
#include <winnls.h>
#include "tracelog.h"

BOOL g_fVerbose=FALSE;

BOOL WlbsCheckSystemVersion ();
BOOL WlbsCheckFiles ();
HRESULT WlbsRegisterDlls ();
HRESULT WlbsCompileMof ();

// ----------------------------------------------------------------------
//
// Function:  wmain
//
// Purpose:   The main function
//
// Arguments: standard main args
//
// Returns:   0 on success, non-zero otherwise
//
// Author:    kumarp 25-December-97
//
// Notes:
//
EXTERN_C int __cdecl wmain (int argc, WCHAR * argv[]) {
    HRESULT hr=S_FALSE;
    WCHAR szFileFullPath[MAX_PATH+1];
    WCHAR szFileFullPathDest[MAX_PATH+1];

    if (!WlbsCheckSystemVersion()) {
	LOG_ERROR("The NLB install pack can only be used on Windows 2000 Server Service Pack 1 or higher.");
	return S_OK;
    }

    /* Check to see if the service is already installed. */
    hr = FindIfComponentInstalled(_TEXT("ms_wlbs"));

    if (hr == S_OK) {
	LOG_INFO("Network Load Balancing Service is installed.  Proceeding with uninstall...");
    } else {
	LOG_ERROR("Network Load Balancing Service is not installed.");
        return S_OK;
    }

    /* Now uninstall the service. */
    hr = HrUninstallNetComponent(L"ms_wlbs");

    if (!SUCCEEDED(hr))
	LOG_ERROR("Error uninstalling Network Load Balancing.");
    else
	LOG_INFO("Uninstallation of Network Load Balancing succeeded.");

    /* Remove the .inf and the .pnf files. */
    GetWindowsDirectory(szFileFullPathDest, MAX_PATH + 1);
    wcscat(szFileFullPathDest, L"\\INF\\netwlbs.inf");
    DeleteFile(szFileFullPathDest);

    GetWindowsDirectory(szFileFullPathDest, MAX_PATH + 1);
    wcscat(szFileFullPathDest, L"\\INF\\netwlbs.pnf");
    DeleteFile(szFileFullPathDest);

    return hr;
}

/* This checks whether the system on which NLB is being installed is a W2K Server or not. */
BOOL WlbsCheckSystemVersion () {
    OSVERSIONINFOEX osinfo;

    osinfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

    if (!GetVersionEx((LPOSVERSIONINFO)&osinfo)) return FALSE;

    /* For uninstalls, we return TRUE only if its Windows 2000 Server. */
    if ((osinfo.dwMajorVersion == 5) && 
        (osinfo.dwMinorVersion == 0) && 
        (osinfo.wProductType == VER_NT_SERVER) && 
        !(osinfo.wSuiteMask & VER_SUITE_ENTERPRISE) &&
        !(osinfo.wSuiteMask & VER_SUITE_DATACENTER))
        return TRUE;

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbkd\print.c ===
/*
 * File: print.c
 * Description: This file contains the implementation of the print
 *              utilities for the NLB KD extensions.
 * Author: Created by shouse, 1.4.01
 */

#include "nlbkd.h"
#include "utils.h"
#include "print.h"

/*
 * Function: PrintUsage
 * Description: Prints usage information for the specified context.
 * Author: Created by shouse, 1.5.01
 */
void PrintUsage (ULONG dwContext) {

    /* Display the appropriate help. */
    switch (dwContext) {
    case USAGE_ADAPTERS:
        dprintf("Usage: nlbadapters [verbosity]\n");
        dprintf("  [verbosity]:   0 (LOW)     Prints minimal detail for adapters in use (default)\n");
        dprintf("                 1 (MEDIUM)  Prints adapter state for adapters in use\n");
        dprintf("                 2 (HIGH)    Prints adapter state for ALL NLB adapter blocks\n");
        break;
    case USAGE_ADAPTER:
        dprintf("Usage: nlbadapter <pointer to adapter block> [verbosity]\n");
        dprintf("  [verbosity]:   0 (LOW)     Prints minimal detail for the specified adapter\n");
        dprintf("                 1 (MEDIUM)  Prints adapter state for the specified adapter (default)\n");
        dprintf("                 2 (HIGH)    Recurses into NLB context with LOW verbosity\n");
        break;
    case USAGE_CONTEXT:
        dprintf("Usage: nlbctxt <pointer to context block> [verbosity]\n");
        dprintf("  [verbosity]:   0 (LOW)     Prints fundamental NLB configuration and state (default)\n");
        dprintf("                 1 (MEDIUM)  Prints resource state and packet statistics\n");
        dprintf("                 2 (HIGH)    Recurses into parameters and load with LOW verbosity\n");
        break;
    case USAGE_PARAMS:
        dprintf("Usage: nlbparams <pointer to params block> [verbosity]\n");
        dprintf("  [verbosity]:   0 (LOW)     Prints fundamental NLB configuration parameters (default)\n");
        dprintf("                 1 (MEDIUM)  Prints all configured port rules\n");
        dprintf("                 2 (HIGH)    Prints extra miscellaneous configuration\n");
        break;
    case USAGE_LOAD:
        dprintf("Usage: nlbload <pointer to load block> [verbosity]\n");
        dprintf("  [verbosity]:   0 (LOW)     Prints fundamental load state and configuration\n");
        dprintf("                 1 (MEDIUM)  Prints the state of all port rules and bins\n");
        dprintf("                 2 (HIGH)    Prints the NLB heartbeat information\n");
        break;
    case USAGE_RESP:
        dprintf("Usage: nlbresp <pointer to packet> [direction]\n");
        dprintf("  [direction]:   0 (RECEIVE) Packet is on the receive path (default)\n");
        dprintf("                 1 (SEND)    Packet is on the send path\n");
        break;
    case USAGE_CONNQ:
        dprintf("Usage: nlbconnq <pointer to queue> [max entries]\n");
        dprintf("  [max entries]: Maximum number of entries to print (default is ALL)\n");
        break;
    case USAGE_MAP:
        dprintf("Usage: nlbmap <pointer to load block> <client IP> <client port> <server IP> <server port> [protocol] [packet type]\n");
        dprintf("  [protocol]:    TCP or UDP (default is TCP)\n");
        dprintf("  [packet type]: For TCP connections, one of SYN, DATA, FIN or RST (default is SYN)\n");
        dprintf("\n");
        dprintf("  IP Address can be in dotted notation or network byte order DWORDs\n");
        break;
    default:
        dprintf("No usage information available.\n");
        break;
    }
}

/*
 * Function: PrintAdapter
 * Description: Prints the contents of the MAIN_ADAPTER structure at the specified verbosity.
 *              LOW (0) prints only the adapter address and device name.
 *              MEDIUM (1) additionally prints the status flags (init, bound, annouce, etc.).
 *              HIGH (2) recurses into the context structure and prints it at MEDIUM verbosity.
 * Author: Created by shouse, 1.5.01
 */
void PrintAdapter (ULONG64 pAdapter, ULONG dwVerbosity) {
    WCHAR szString[256];
    ULONG dwValue;
    ULONG64 pAddr;

    /* Make sure the address is non-NULL. */
    if (!pAdapter) {
        dprintf("Error: NLB adapter block is NULL.\n");
        return;
    }
    
    dprintf("NLB Adapter Block 0x%p\n", pAdapter);

    /* Get the MAIN_ADAPTER_CODE from the structure to make sure that this address
       indeed points to a valid NLB adapter block. */
    GetFieldValue(pAdapter, MAIN_ADAPTER, MAIN_ADAPTER_FIELD_CODE, dwValue);
    
    if (dwValue != MAIN_ADAPTER_CODE) {
        dprintf("  Error: Invalid NLB adapter block.  Wrong code found (0x%08x).\n", dwValue);
        return;
    }
    
    /* Retrieve the used/unused state of the adapter. */
    GetFieldValue(pAdapter, MAIN_ADAPTER, MAIN_ADAPTER_FIELD_USED, dwValue);
    
    if (!dwValue) 
        dprintf("  This adapter is unused.\n");
    else {
        /* Get the pointer to and length of the device to which NLB is bound. */
        GetFieldValue(pAdapter, MAIN_ADAPTER, MAIN_ADAPTER_FIELD_NAME_LENGTH, dwValue);
        GetFieldValue(pAdapter, MAIN_ADAPTER, MAIN_ADAPTER_FIELD_NAME, pAddr);
        
        /* Retrieve the contexts of the string and store it in a buffer. */
        GetString(pAddr, szString, dwValue);
        
        dprintf("  Physical device name:               %ls\n", szString);
    }

    /* If we're printing at low verbosity, bail out here. */
    if (dwVerbosity == VERBOSITY_LOW) return;

    /* Determine whether or not the adapter has been initialized. */
    GetFieldValue(pAdapter, MAIN_ADAPTER, MAIN_ADAPTER_FIELD_INITED, dwValue);
    
    dprintf("  Context state initialized:          %s\n", (dwValue) ? "Yes" : "No");
    
    /* Determine whether or not NLB has been bound to the stack yet. */
    GetFieldValue(pAdapter, MAIN_ADAPTER, MAIN_ADAPTER_FIELD_BOUND, dwValue);
    
    dprintf("  NLB bound to adapter:               %s\n", (dwValue) ? "Yes" : "No");
    
    /* Determine whether or not TCP/IP has been bound to the NLB virtual adapter or not. */
    GetFieldValue(pAdapter, MAIN_ADAPTER, MAIN_ADAPTER_FIELD_ANNOUNCED, dwValue);
    
    dprintf("  NLB miniport announced:             %s\n", (dwValue) ? "Yes" : "No");
    
    /* Get the offset of the NLB context pointer. */
    if (GetFieldOffset(MAIN_ADAPTER, MAIN_ADAPTER_FIELD_CONTEXT, &dwValue))
        dprintf("Can't get offset of %s in %s\n", MAIN_ADAPTER_FIELD_CONTEXT, MAIN_ADAPTER);
    else {
        pAddr = pAdapter + dwValue;

        /* Retrieve the pointer. */
        pAddr = GetPointerFromAddress(pAddr);
        
        dprintf(" %sNLB context:                        0x%p\n", 
                (pAddr && (dwVerbosity == VERBOSITY_HIGH)) ? "-" : (pAddr) ? "+" : " ", pAddr);    
    }

    /* If we're printing at medium verbosity, bail out here. */
    if (dwVerbosity == VERBOSITY_MEDIUM) return;

    /* Print the context information (always with LOW verbosity during recursion. */
    if (pAddr) {
        dprintf("\n");
        PrintContext(pAddr, VERBOSITY_LOW);
    }
}

/*
 * Function: PrintContext
 * Description: Prints the contents of the MAIN_CTXT structure at the specified verbosity.
 *              LOW (0) prints fundamental NLB configuration and state.
 *              MEDIUM (1) additionally prints the resource state (pools, allocations, etc).
 *              HIGH (2) further prints other miscelaneous information.
 * Author: Created by shouse, 1.5.01
 */
void PrintContext (ULONG64 pContext, ULONG dwVerbosity) {
    WCHAR szNICName[CVY_MAX_VIRTUAL_NIC];
    ULONGLONG dwwValue;
    IN_ADDR dwIPAddr;
    CHAR * szString;
    UCHAR szMAC[6];
    ULONG64 pAddr;
    ULONG dwValue;

    /* Make sure the address is non-NULL. */
    if (!pContext) {
        dprintf("Error: NLB context block is NULL.\n");
        return;
    }

    dprintf("NLB Context Block 0x%p\n", pContext);

    /* Get the MAIN_CTXT_CODE from the structure to make sure that this address
       indeed points to a valid NLB context block. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_CODE, dwValue);
    
    if (dwValue != MAIN_CTXT_CODE) {
        dprintf("  Error: Invalid NLB context block.  Wrong code found (0x%08x).\n", dwValue);
        return;
    } 

    /* Get the offset of the NLB virtual NIC name. */
    if (GetFieldOffset(MAIN_CTXT, MAIN_CTXT_FIELD_VIRTUAL_NIC, &dwValue))
        dprintf("Can't get offset of %s in %s\n", MAIN_CTXT_FIELD_VIRTUAL_NIC, MAIN_CTXT);
    else {
        pAddr = pContext + dwValue;
    
        /* Retrieve the contexts of the string and store it in a buffer. */
        GetString(pAddr, szNICName, CVY_MAX_VIRTUAL_NIC);
        
        dprintf("  NLB virtual NIC name:               %ls\n", szNICName);
    }

    /* Get the convoy enabled status. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_ENABLED, dwValue);

    dprintf("  NLB enabled:                        %s ", (dwValue) ? "Yes" : "No");

    /* Get the draining status. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_DRAINING, dwValue);

    if (dwValue) dprintf("(Draining) ");

    /* Get the suspended status. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_SUSPENDED, dwValue);

    if (dwValue) dprintf("(Suspended) ");

    /* Get the stopping status. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_STOPPING, dwValue);

    if (dwValue) dprintf("(Stopping) ");

    dprintf("\n");

    /* Get the adapter index. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_ADAPTER_ID, dwValue);

    dprintf("  NLB adapter ID:                     %u\n", dwValue);

    dprintf("\n");

    /* Get the adapter medium. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_MEDIUM, dwValue);

    dprintf("  Network medium:                     %s\n", (dwValue == NdisMedium802_3) ? "802.3" : "FDDI");

    /* Get the media connect status. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_MEDIA_CONNECT, dwValue);

    dprintf("  Network connect status:             %s\n", (dwValue) ? "Connected" : "Disconnected");

    /* Get the media connect status. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_FRAME_SIZE, dwValue);

    dprintf("  Frame size (MTU):                   %u\n", dwValue);

    /* Get the media connect status. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_MCAST_LIST_SIZE, dwValue);

    dprintf("  Multicast MAC list size:            %u\n", dwValue);

    /* Determine dynamic MAC address support. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_MAC_OPTIONS, dwValue);

    dprintf("  Dynamic MAC address support:        %s\n", 
            (dwValue & NDIS_MAC_OPTION_SUPPORTS_MAC_ADDRESS_OVERWRITE) ? "Yes" : "No");

    dprintf("\n");

    dprintf("  NDIS handles\n");

    /* Get the NDIS bind handle. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_BIND_HANDLE, pAddr);

    dprintf("      Bind handle:                    0x%p\n", pAddr);

    /* Get the NDIS unbind handle. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_UNBIND_HANDLE, pAddr);

    dprintf("      Unbind handle:                  0x%p\n", pAddr);

    /* Get the NDIS MAC handle. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_MAC_HANDLE, pAddr);

    dprintf("      MAC handle:                     0x%p\n", pAddr);

    /* Get the NDIS protocol handle. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_PROT_HANDLE, pAddr);

    dprintf("      Protocol handle:                0x%p\n", pAddr);

    dprintf("\n");

    dprintf("  Cluster IP settings\n");

    /* Get the cluster IP address, which is a DWORD, and convert it to a string. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_CL_IP_ADDR, dwValue);

    dwIPAddr.S_un.S_addr = dwValue;
    szString = inet_ntoa(dwIPAddr);

    dprintf("      IP address:                     %s\n", szString);

    /* Get the cluster net mask, which is a DWORD, and convert it to a string. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_CL_NET_MASK, dwValue);

    dwIPAddr.S_un.S_addr = dwValue;
    szString = inet_ntoa(dwIPAddr);

    dprintf("      Netmask:                        %s\n", szString);

    /* Get the offset of the cluster MAC address and retrieve the MAC from that address. */
    if (GetFieldOffset(MAIN_CTXT, MAIN_CTXT_FIELD_CL_MAC_ADDR, &dwValue))
        dprintf("Can't get offset of %s in %s\n", MAIN_CTXT_FIELD_CL_MAC_ADDR, MAIN_CTXT);
    else {
        pAddr = pContext + dwValue;

        GetMAC(pAddr, szMAC, 6);

        dprintf("      MAC address:                    %02X-%02X-%02X-%02X-%02X-%02X\n", 
                ((PUCHAR)(szMAC))[0], ((PUCHAR)(szMAC))[1], ((PUCHAR)(szMAC))[2], 
                ((PUCHAR)(szMAC))[3], ((PUCHAR)(szMAC))[4], ((PUCHAR)(szMAC))[5]);
    }

    /* Get the cluster broadcast address, which is a DWORD, and convert it to a string. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_CL_BROADCAST, dwValue);

    dwIPAddr.S_un.S_addr = dwValue;
    szString = inet_ntoa(dwIPAddr);

    dprintf("      Broadcast address:              %s\n", szString);

    /* Get the IGMP multicast IP address, which is a DWORD, and convert it to a string. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_IGMP_MCAST_IP, dwValue);

    dwIPAddr.S_un.S_addr = dwValue;
    szString = inet_ntoa(dwIPAddr);

    dprintf("      IGMP multicast IP address:      %s\n", szString);

    dprintf("\n");

    dprintf("  Dedicated IP settings\n");

    /* Get the dedicated IP address, which is a DWORD, and convert it to a string. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_DED_IP_ADDR, dwValue);

    dwIPAddr.S_un.S_addr = dwValue;
    szString = inet_ntoa(dwIPAddr);

    dprintf("      IP address:                     %s\n", szString);

    /* Get the dedicated net mask, which is a DWORD, and convert it to a string. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_DED_NET_MASK, dwValue);

    dwIPAddr.S_un.S_addr = dwValue;
    szString = inet_ntoa(dwIPAddr);

    dprintf("      Netmask:                        %s\n", szString);

    /* Get the dedicated broadcast address, which is a DWORD, and convert it to a string. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_DED_BROADCAST, dwValue);

    dwIPAddr.S_un.S_addr = dwValue;
    szString = inet_ntoa(dwIPAddr);

    dprintf("      Broadcast address:              %s\n", szString);

    /* Get the offset of the dedicated MAC address and retrieve the MAC from that address. */
    if (GetFieldOffset(MAIN_CTXT, MAIN_CTXT_FIELD_DED_MAC_ADDR, &dwValue))
        dprintf("Can't get offset of %s in %s\n", MAIN_CTXT_FIELD_DED_MAC_ADDR, MAIN_CTXT);
    else {
        pAddr = pContext + dwValue;

        GetMAC(pAddr, szMAC, 6);

        dprintf("      MAC address:                    %02X-%02X-%02X-%02X-%02X-%02X\n", 
                ((PUCHAR)(szMAC))[0], ((PUCHAR)(szMAC))[1], ((PUCHAR)(szMAC))[2], 
                ((PUCHAR)(szMAC))[3], ((PUCHAR)(szMAC))[4], ((PUCHAR)(szMAC))[5]);
    }

    dprintf("\n");

#if defined (SBH)
    dprintf("  Cluster MAC addresses\n");

    /* Get the offset of the unicast MAC address and retrieve the MAC from that address. */
    if (GetFieldOffset(MAIN_CTXT, MAIN_CTXT_FIELD_UNICAST_MAC_ADDR, &dwValue))
        dprintf("Can't get offset of %s in %s\n", MAIN_CTXT_FIELD_UNICAST_MAC_ADDR, MAIN_CTXT);
    else {
        pAddr = pContext + dwValue;

        GetMAC(pAddr, szMAC, 6);

        dprintf("      Unicast:                        %02X-%02X-%02X-%02X-%02X-%02X\n", 
                ((PUCHAR)(szMAC))[0], ((PUCHAR)(szMAC))[1], ((PUCHAR)(szMAC))[2], 
                ((PUCHAR)(szMAC))[3], ((PUCHAR)(szMAC))[4], ((PUCHAR)(szMAC))[5]);
    }

    /* Get the offset of the multicast MAC address and retrieve the MAC from that address. */
    if (GetFieldOffset(MAIN_CTXT, MAIN_CTXT_FIELD_MULTICAST_MAC_ADDR, &dwValue))
        dprintf("Can't get offset of %s in %s\n", MAIN_CTXT_FIELD_MULTICAST_MAC_ADDR, MAIN_CTXT);
    else {
        pAddr = pContext + dwValue;

        GetMAC(pAddr, szMAC, 6);

        dprintf("      Multicast:                      %02X-%02X-%02X-%02X-%02X-%02X\n", 
                ((PUCHAR)(szMAC))[0], ((PUCHAR)(szMAC))[1], ((PUCHAR)(szMAC))[2], 
                ((PUCHAR)(szMAC))[3], ((PUCHAR)(szMAC))[4], ((PUCHAR)(szMAC))[5]);
    }

    /* Get the offset of the IGMP MAC address and retrieve the MAC from that address. */
    if (GetFieldOffset(MAIN_CTXT, MAIN_CTXT_FIELD_IGMP_MAC_ADDR, &dwValue))
        dprintf("Can't get offset of %s in %s\n", MAIN_CTXT_FIELD_IGMP_MAC_ADDR, MAIN_CTXT);
    else {
        pAddr = pContext + dwValue;

        GetMAC(pAddr, szMAC, 6);

        dprintf("      IGMP:                           %02X-%02X-%02X-%02X-%02X-%02X\n", 
                ((PUCHAR)(szMAC))[0], ((PUCHAR)(szMAC))[1], ((PUCHAR)(szMAC))[2], 
                ((PUCHAR)(szMAC))[3], ((PUCHAR)(szMAC))[4], ((PUCHAR)(szMAC))[5]);
    }

    dprintf("\n");
#endif /* SBH */

    /* Get the offset of the BDA teaming information for this context. */
    if (GetFieldOffset(MAIN_CTXT, MAIN_CTXT_FIELD_BDA_TEAMING, &dwValue))
        dprintf("Can't get offset of %s in %s\n", MAIN_CTXT_FIELD_BDA_TEAMING, MAIN_CTXT);
    else {
        pAddr = pContext + dwValue;

        /* Print the bi-directional affinity teaming state. */
        PrintBDAMember(pAddr);
    }

    dprintf("\n");

    /* Get the current heartbeat period. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_PING_TIMEOUT, dwValue);

    dprintf("  Current heartbeat period:           %u millisecond(s)\n", dwValue);

    /* Get the current IGMP join counter. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_IGMP_TIMEOUT, dwValue);

    dprintf("  Time since last IGMP join:          %.1f second(s)\n", (float)(dwValue/1000.0));

    /* If we're printing at low verbosity, go to the end and print the load and params pointers. */
    if (dwVerbosity == VERBOSITY_LOW) goto end;

    dprintf("\n");

    dprintf("  Send packet pools\n");

    /* Get the state of the send packet pool. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_EXHAUSTED, dwValue);

    dprintf("      Pool exhausted:                 %s\n", (dwValue) ? "Yes" : "No");    

    /* Get the number of send packet pools allocated. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_SEND_POOLS_ALLOCATED, dwValue);

    dprintf("      Pools allocated:                %u\n", dwValue);    

    /* Get the number of send packets allocated. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_SEND_PACKETS_ALLOCATED, dwValue);

    dprintf("      Packets allocated:              %u\n", dwValue);

    /* Get the current send packet pool. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_SEND_POOL_CURRENT, dwValue);

    dprintf("      Current pool:                   %u\n", dwValue);    

    /* Get the number of pending send packets (outstanding). */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_SEND_OUTSTANDING, dwValue);

    dprintf("      Packets outstanding:            %u\n", dwValue);    

    dprintf("\n");

    dprintf("  Receive packet pools\n");

    /* Get the receive "out of resoures" counter. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_CNTR_RECV_NO_BUF, dwValue);

    dprintf("      Allocation failures:            %u\n", dwValue);

    /* Get the number of receive packet pools allocated. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_RECV_POOLS_ALLOCATED, dwValue);

    dprintf("      Pools allocated:                %u\n", dwValue);    

    /* Get the number of receive packets allocated. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_RECV_PACKETS_ALLOCATED, dwValue);

    dprintf("      Packets allocated:              %u\n", dwValue);

    /* Get the current receive packet pool. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_RECV_POOL_CURRENT, dwValue);

    dprintf("      Current pool:                   %u\n", dwValue);    

    /* Get the number of pending receive packets (outstanding). */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_RECV_OUTSTANDING, dwValue);

    dprintf("      Packets outstanding:            %u\n", dwValue);    

    dprintf("\n");

    dprintf("  Ping/IGMP packet pool (not accurate yet)\n");

    /* Get the receive "out of resoures" counter. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_CNTR_PING_NO_BUF, dwValue);

    dprintf("      Allocation failures:            %u\n", dwValue);

    /* Get the number of ping/igmp packets allocated. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_PING_PACKETS_ALLOCATED, dwValue);

    dprintf("      Packets allocated:              %u\n", dwValue);

    /* Get the number of pending ping/igmp packets (outstanding). */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_PING_OUTSTANDING, dwValue);

    dprintf("      Packets outstanding:            %u\n", dwValue);    

    dprintf("\n");

    dprintf("  Receive buffer pools\n");

    /* Get the number of receive buffer pools allocated. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_BUF_POOLS_ALLOCATED, dwValue);

    dprintf("      Pools allocated:                %u\n", dwValue);    

    /* Get the number of receive buffers allocated. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_BUFS_ALLOCATED, dwValue);

    dprintf("      Buffers allocated:              %u\n", dwValue);

    /* Get the number of pending receive buffers (outstanding). */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_BUFS_OUTSTANDING, dwValue);

    dprintf("      Buffers outstanding:            %u\n", dwValue);    

    dprintf("\n");

    dprintf("  NLB Main Protocol Reserved buffers\n");

    /* Get the address of the resp lookaside list, then use it to get the size of 
       the list and the total number of allocations and frees. */
    GetFieldOffset(MAIN_CTXT, MAIN_CTXT_FIELD_RESP, &dwValue);
    
    pAddr = pContext + dwValue;

    GetFieldValue(pAddr, GENERAL_LOOKASIDE, GENERAL_LOOKASIDE_FIELD_ALLOCATES, dwValue);

    dprintf("      Total allocations:              %u\n", dwValue);    

    GetFieldValue(pAddr, GENERAL_LOOKASIDE, GENERAL_LOOKASIDE_FIELD_FREES, dwValue);

    dprintf("      Total frees:                    %u\n", dwValue);    

    GetFieldValue(pAddr, GENERAL_LOOKASIDE, GENERAL_LOOKASIDE_FIELD_SIZE, dwValue);

    dprintf("      Current lookaside list size:    %u\n", dwValue);    

    dprintf("\n");

    dprintf("                                         Sent      Received\n");
    dprintf("  Statistics                          ----------  ----------\n");

    /* Get the number of successful sends. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_CNTR_XMIT_OK, dwValue);

    dprintf("      Successful:                     %10u", dwValue);

    /* Get the number of successful receives. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_CNTR_RECV_OK, dwValue);

    dprintf("  %10u\n", dwValue);

    /* Get the number of unsuccessful sends. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_CNTR_XMIT_ERROR, dwValue);

    dprintf("      Unsuccessful:                   %10u", dwValue);

    /* Get the number of unsuccessful receives. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_CNTR_RECV_ERROR, dwValue);

    dprintf("  %10u\n", dwValue);

    /* Get the number of directed frames transmitted. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_CNTR_XMIT_FRAMES_DIR, dwValue);

    dprintf("      Directed packets:               %10u", dwValue);
    /* Get the number of directed frames received. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_CNTR_RECV_FRAMES_DIR, dwValue);

    dprintf("  %10u\n", dwValue);

    /* Get the number of directed bytes transmitted. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_CNTR_XMIT_BYTES_DIR, dwwValue);

    dprintf("      Directed bytes:                 %10u", dwwValue);

    /* Get the number of directed bytes received. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_CNTR_RECV_BYTES_DIR, dwwValue);

    dprintf("  %10u\n", dwValue);

    /* Get the number of multicast frames transmitted. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_CNTR_XMIT_FRAMES_MCAST, dwValue);

    dprintf("      Multicast packets:              %10u", dwValue);

    /* Get the number of multicast frames received. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_CNTR_RECV_FRAMES_MCAST, dwValue);

    dprintf("  %10u\n", dwValue);

    /* Get the number of multicast bytes transmitted. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_CNTR_XMIT_BYTES_MCAST, dwwValue);

    dprintf("      Multicast bytes:                %10u", dwwValue);

    /* Get the number of multicast bytes received. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_CNTR_RECV_BYTES_MCAST, dwwValue);

    dprintf("  %10u\n", dwValue);

    /* Get the number of broadcast frames transmitted. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_CNTR_XMIT_FRAMES_BCAST, dwValue);

    dprintf("      Broadcast packets:              %10u", dwValue);

    /* Get the number of broadcast frames received. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_CNTR_RECV_FRAMES_BCAST, dwValue);

    dprintf("  %10u\n", dwValue);

    /* Get the number of broadcast bytes transmitted. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_CNTR_XMIT_BYTES_BCAST, dwwValue);

    dprintf("      Broadcast bytes:                %10u", dwwValue);

    /* Get the number of broadcast bytes received. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_CNTR_RECV_BYTES_BCAST, dwwValue);

    dprintf("  %10u\n", dwValue);

 end:

    dprintf("\n");

    /* Get the pointer to the NLB load. */
    GetFieldOffset(MAIN_CTXT, MAIN_CTXT_FIELD_LOAD, &dwValue);
    
    pAddr = pContext + dwValue;

    dprintf(" %sNLB load:                           0x%p\n",    
            (pAddr && (dwVerbosity == VERBOSITY_HIGH)) ? "-" : (pAddr) ? "+" : " ", pAddr);    

    /* Print the load information if verbosity is high. */
    if (pAddr && (dwVerbosity == VERBOSITY_HIGH)) {
        dprintf("\n");
        PrintLoad(pAddr, VERBOSITY_LOW);
        dprintf("\n");
    }

    /* Get the pointer to the NLB parameters. */
    GetFieldOffset(MAIN_CTXT, MAIN_CTXT_FIELD_PARAMS, &dwValue);
    
    pAddr = pContext + dwValue;

    dprintf(" %sNLB parameters:                     0x%p ",
            (pAddr && (dwVerbosity == VERBOSITY_HIGH)) ? "-" : (pAddr) ? "+" : " ", pAddr);    

    /* Get the validity of the NLB parameter block. */
    GetFieldValue(pContext, MAIN_CTXT, MAIN_CTXT_FIELD_PARAMS_VALID, dwValue);

    dprintf("(%s)\n", (dwValue) ? "Valid" : "Invalid");

    /* Print the parameter information if verbosity is high. */
    if (pAddr && (dwVerbosity == VERBOSITY_HIGH)) {
        dprintf("\n");
        PrintParams(pAddr, VERBOSITY_LOW);
    }
}

/*
 * Function: PrintParams
 * Description: Prints the contents of the CVY_PARAMS structure at the specified verbosity.
 *              LOW (0) prints fundamental configuration parameters.
 *              MEDIUM (1) prints all configured port rules.
 *              HIGH (2) prints other miscellaneous configuration.
 * Author: Created by shouse, 1.21.01
 */
void PrintParams (ULONG64 pParams, ULONG dwVerbosity) {
    WCHAR szString[256];
    ULONG64 pAddr;
    ULONG dwValue;

    /* Make sure the address is non-NULL. */
    if (!pParams) {
        dprintf("Error: NLB parameter block is NULL.\n");
        return;
    }

    /* Get the parameter version number. */
    GetFieldValue(pParams, CVY_PARAMS, CVY_PARAMS_FIELD_VERSION, dwValue);

    dprintf("NLB Parameters Block 0x%p (Version %d)\n", pParams, dwValue);

    /* Get the host priority. */
    GetFieldValue(pParams, CVY_PARAMS, CVY_PARAMS_FIELD_HOST_PRIORITY, dwValue);

    dprintf("  Host priority:                      %u\n", dwValue);

    /* Get the initial cluster state flag. */
    GetFieldValue(pParams, CVY_PARAMS, CVY_PARAMS_FIELD_INITIAL_STATE, dwValue);

    dprintf("  Initial cluster state:              %s\n", (dwValue) ? "Active" : "Inactive");

    dprintf("\n");

    /* Get the multicast support flag. */
    GetFieldValue(pParams, CVY_PARAMS, CVY_PARAMS_FIELD_MULTICAST_SUPPORT, dwValue);

    dprintf("  Multicast support enabled:          %s\n", (dwValue) ? "Yes" : "No");

    /* Get the IGMP support flag. */
    GetFieldValue(pParams, CVY_PARAMS, CVY_PARAMS_FIELD_IGMP_SUPPORT, dwValue);

    dprintf("  IGMP multicast support enabled:     %s\n", (dwValue) ? "Yes" : "No");

    dprintf("\n");

    dprintf("  Remote control settings\n");

    /* Get the remote control support flag. */
    GetFieldValue(pParams, CVY_PARAMS, CVY_PARAMS_FIELD_REMOTE_CONTROL_ENABLED, dwValue);

    dprintf("      Enabled:                        %s\n", (dwValue) ? "Yes" : "No");

    /* Get the remote control port. */
    GetFieldValue(pParams, CVY_PARAMS, CVY_PARAMS_FIELD_REMOTE_CONTROL_PORT, dwValue);

    dprintf("      Port number:                    %u\n", dwValue);

    /* Get the host priority. */
    GetFieldValue(pParams, CVY_PARAMS, CVY_PARAMS_FIELD_REMOTE_CONTROL_PASSWD, dwValue);

    dprintf("      Password:                       0x%08x\n", dwValue);

    dprintf("\n");

    dprintf("  Cluster IP settings\n");

    /* Get the offset of the cluster IP address and retrieve the string from that address. */
    if (GetFieldOffset(CVY_PARAMS, CVY_PARAMS_FIELD_CL_IP_ADDR, &dwValue))
        dprintf("Can't get offset of %s in %s\n", CVY_PARAMS_FIELD_CL_IP_ADDR, CVY_PARAMS);
    else {
        pAddr = pParams + dwValue;

        /* Retrieve the contexts of the string and store it in a buffer. */
        GetString(pAddr, szString, CVY_MAX_CL_IP_ADDR + 1);

        dprintf("      IP address:                     %ls\n", szString);
    }

    /* Get the offset of the cluster netmask and retrieve the string from that address. */
    if (GetFieldOffset(CVY_PARAMS, CVY_PARAMS_FIELD_CL_NET_MASK, &dwValue))
        dprintf("Can't get offset of %s in %s\n", CVY_PARAMS_FIELD_CL_NET_MASK, CVY_PARAMS);
    else {
        pAddr = pParams + dwValue;

        /* Retrieve the contexts of the string and store it in a buffer. */
        GetString(pAddr, szString, CVY_MAX_CL_NET_MASK + 1);

        dprintf("      Netmask:                        %ls\n", szString);
    }

    /* Get the offset of the cluster MAC address and retrieve the MAC from that address. */
    if (GetFieldOffset(CVY_PARAMS, CVY_PARAMS_FIELD_CL_MAC_ADDR, &dwValue))
        dprintf("Can't get offset of %s in %s\n", CVY_PARAMS_FIELD_CL_MAC_ADDR, CVY_PARAMS);
    else {
        pAddr = pParams + dwValue;

        /* Retrieve the contexts of the string and store it in a buffer. */
        GetString(pAddr, szString, CVY_MAX_NETWORK_ADDR + 1);

        dprintf("      MAC address:                    %ls\n", szString);
    }

    /* Get the offset of the cluster IGMP multicast address and retrieve the string from that address. */
    if (GetFieldOffset(CVY_PARAMS, CVY_PARAMS_FIELD_CL_IGMP_ADDR, &dwValue))
        dprintf("Can't get offset of %s in %s\n", CVY_PARAMS_FIELD_CL_IGMP_ADDR, CVY_PARAMS);
    else {
        pAddr = pParams + dwValue;

        /* Retrieve the contexts of the string and store it in a buffer. */
        GetString(pAddr, szString, CVY_MAX_CL_IGMP_ADDR + 1);

        dprintf("      IGMP multicast IP address:      %ls\n", szString);
    }

    /* Get the offset of the cluster name and retrieve the string from that address. */
    if (GetFieldOffset(CVY_PARAMS, CVY_PARAMS_FIELD_CL_NAME, &dwValue))
        dprintf("Can't get offset of %s in %s\n", CVY_PARAMS_FIELD_CL_NAME, CVY_PARAMS);
    else {
        pAddr = pParams + dwValue;

        /* Retrieve the contexts of the string and store it in a buffer. */
        GetString(pAddr, szString, CVY_MAX_DOMAIN_NAME + 1);

        dprintf("      Domain name:                    %ls\n", szString);
    }

    dprintf("\n");

    dprintf("  Dedicated IP settings\n");

    /* Get the offset of the dedicated IP address and retrieve the string from that address. */
    if (GetFieldOffset(CVY_PARAMS, CVY_PARAMS_FIELD_DED_IP_ADDR, &dwValue))
        dprintf("Can't get offset of %s in %s\n", CVY_PARAMS_FIELD_DED_IP_ADDR, CVY_PARAMS);
    else {
        pAddr = pParams + dwValue;

        /* Retrieve the contexts of the string and store it in a buffer. */
        GetString(pAddr, szString, CVY_MAX_DED_IP_ADDR + 1);

        dprintf("      IP address:                     %ls\n", szString);
    }

    /* Get the offset of the dedicated netmask and retrieve the string from that address. */
    if (GetFieldOffset(CVY_PARAMS, CVY_PARAMS_FIELD_DED_NET_MASK, &dwValue))
        dprintf("Can't get offset of %s in %s\n", CVY_PARAMS_FIELD_DED_NET_MASK, CVY_PARAMS);
    else {
        pAddr = pParams + dwValue;

        /* Retrieve the contexts of the string and store it in a buffer. */
        GetString(pAddr, szString, CVY_MAX_DED_NET_MASK + 1);

        dprintf("      Netmask:                        %ls\n", szString);
    }

    dprintf("\n");
    
    /* Get the offset of the BDA teaming parameters structure. */
    if (GetFieldOffset(CVY_PARAMS, CVY_PARAMS_FIELD_BDA_TEAMING, &dwValue))
        dprintf("Can't get offset of %s in %s\n", CVY_PARAMS_FIELD_BDA_TEAMING, CVY_PARAMS);
    else {
        ULONG64 pBDA = pParams + dwValue;

        /* Find out whether or not teaming is active on this adapter. */
        GetFieldValue(pBDA, CVY_BDA, CVY_BDA_FIELD_ACTIVE, dwValue);
        
        dprintf("  Bi-directional affinity teaming:    %s\n", (dwValue) ? "Active" : "Inactive");

        /* Get the offset of the team ID and retrieve the string from that address. */
        if (GetFieldOffset(CVY_BDA, CVY_BDA_FIELD_TEAM_ID, &dwValue))
            dprintf("Can't get offset of %s in %s\n", CVY_BDA_FIELD_TEAM_ID, CVY_BDA);
        else {
            pAddr = pBDA + dwValue;
            
            /* Retrieve the contexts of the string and store it in a buffer. */
            GetString(pAddr, szString, CVY_MAX_BDA_TEAM_ID + 1);
            
            dprintf("      Team ID:                        %ls\n", szString);
        }

        /* Get the master flag. */
        GetFieldValue(pBDA, CVY_BDA, CVY_BDA_FIELD_MASTER, dwValue);
        
        dprintf("      Master:                         %s\n", (dwValue) ? "Yes" : "No");

        /* Get the reverse hashing flag. */
        GetFieldValue(pBDA, CVY_BDA, CVY_BDA_FIELD_REVERSE_HASH, dwValue);
        
        dprintf("      Reverse hashing:                %s\n", (dwValue) ? "Yes" : "No");
    }

    /* If we're printing at low verbosity, bail out here. */
    if (dwVerbosity == VERBOSITY_LOW) return;

    dprintf("\n");

    /* Get the offset of the port rules and pass it to PrintPortRules. */
    if (GetFieldOffset(CVY_PARAMS, CVY_PARAMS_FIELD_PORT_RULES, &dwValue))
        dprintf("Can't get offset of %s in %s\n", CVY_PARAMS_FIELD_PORT_RULES, CVY_PARAMS);
    else {
        pAddr = pParams + dwValue;
        
        /* Get the number of port rules. */
        GetFieldValue(pParams, CVY_PARAMS, CVY_PARAMS_FIELD_NUM_RULES, dwValue);

        PrintPortRules(dwValue, pAddr);
    }

    /* If we're printing at medium verbosity, bail out here. */
    if (dwVerbosity == VERBOSITY_MEDIUM) return;

    dprintf("\n");

    /* Get the heartbeat period. */
    GetFieldValue(pParams, CVY_PARAMS, CVY_PARAMS_FIELD_ALIVE_PERIOD, dwValue);

    dprintf("  Heartbeat period:                   %u millisecond(s)\n", dwValue);

    /* Get the heartbeat loss tolerance. */
    GetFieldValue(pParams, CVY_PARAMS, CVY_PARAMS_FIELD_ALIVE_TOLERANCE, dwValue);

    dprintf("  Heartbeat loss tolerance:           %u\n", dwValue);

    dprintf("\n");

    /* Get the number of remote control actions to allocate. */
    GetFieldValue(pParams, CVY_PARAMS, CVY_PARAMS_FIELD_NUM_ACTIONS, dwValue);

    dprintf("  Number of actions to allocate:      %u\n", dwValue);

    /* Get the number of packets to allocate. */
    GetFieldValue(pParams, CVY_PARAMS, CVY_PARAMS_FIELD_NUM_PACKETS, dwValue);

    dprintf("  Number of packets to allocate:      %u\n", dwValue);

    /* Get the number of heartbeats to allocate. */
    GetFieldValue(pParams, CVY_PARAMS, CVY_PARAMS_FIELD_NUM_PINGS, dwValue);

    dprintf("  Number of heartbeats to allocate:   %u\n", dwValue);

    /* Get the number of descriptors per allocation. */
    GetFieldValue(pParams, CVY_PARAMS, CVY_PARAMS_FIELD_NUM_DESCR, dwValue);

    dprintf("  Descriptors per allocation:         %u\n", dwValue);

    /* Get the maximum number of descriptor allocations. */
    GetFieldValue(pParams, CVY_PARAMS, CVY_PARAMS_FIELD_MAX_DESCR, dwValue);

    dprintf("  Maximum Descriptors allocations:    %u\n", dwValue);

    dprintf("\n");

    /* Get the NetBT support flag. */
    GetFieldValue(pParams, CVY_PARAMS, CVY_PARAMS_FIELD_NBT_SUPPORT, dwValue);

    dprintf("  NetBT support enabled:              %s\n", (dwValue) ? "Yes" : "No");

    /* Get the multicast spoof flag. */
    GetFieldValue(pParams, CVY_PARAMS, CVY_PARAMS_FIELD_MCAST_SPOOF, dwValue);

    dprintf("  Multicast spoofing enabled:         %s\n", (dwValue) ? "Yes" : "No");
    
    /* Get the netmon passthru flag. */
    GetFieldValue(pParams, CVY_PARAMS, CVY_PARAMS_FIELD_NETMON_PING, dwValue);

    dprintf("  Netmon heartbeat passthru enabled:  %s\n", (dwValue) ? "Yes" : "No");

    /* Get the mask source MAC flag. */
    GetFieldValue(pParams, CVY_PARAMS, CVY_PARAMS_FIELD_MASK_SRC_MAC, dwValue);

    dprintf("  Mask source MAC enabled:            %s\n", (dwValue) ? "Yes" : "No");

    /* Get the convert MAC flag. */
    GetFieldValue(pParams, CVY_PARAMS, CVY_PARAMS_FIELD_CONVERT_MAC, dwValue);

    dprintf("  IP to MAC conversion enabled:       %s\n", (dwValue) ? "Yes" : "No");

    dprintf("\n");

    /* Get the IP change delay value. */
    GetFieldValue(pParams, CVY_PARAMS, CVY_PARAMS_FIELD_IP_CHANGE_DELAY, dwValue);

    dprintf("  IP change delay:                    %u millisecond(s)\n", dwValue);

    /* Get the dirty descriptor cleanup delay value. */
    GetFieldValue(pParams, CVY_PARAMS, CVY_PARAMS_FIELD_CLEANUP_DELAY, dwValue);

    dprintf("  Dirty connection cleanup delay:     %u millisecond(s)\n", dwValue);
}

/*
 * Function: PrintPortRules
 * Description: Prints the NLB port rules.
 * Author: Created by shouse, 1.21.01
 */
void PrintPortRules (ULONG dwNumRules, ULONG64 pRules) {
    ULONG dwRuleSize;
    ULONG dwIndex;
    ULONG64 pAddr;

    /* Make sure the address is non-NULL. */
    if (!pRules) {
        dprintf("Error: NLB port rule block is NULL.\n");
        return;
    }

    dprintf("  Configured port rules (%u)\n", dwNumRules);

    /* If no port rules are present, print a notification. */
    if (!dwNumRules) {
        dprintf("      There are no port rules configured on this cluster.\n");
        return;
    } 

    /* Print the column headers. */
    dprintf("         Virtual IP   Start   End   Protocol    Mode    Priority   Load Weight  Affinity\n");
    dprintf("      --------------- -----  -----  --------  --------  --------   -----------  --------\n");

    /* Find out the size of a CVY_RULE structure. */
    dwRuleSize = GetTypeSize(CVY_RULE);

    /* Loop through all port rules and print the configuration. Note: The print statements
       are full of seemingly non-sensicle format strings, but trust me, they're right. */
    for (dwIndex = 0; dwIndex < dwNumRules; dwIndex++) {
        IN_ADDR dwIPAddr;
        CHAR * szString;
        ULONG dwValue;
        USHORT wValue;

        /* Get the VIP.  Convert from a DWORD to a string. */
        GetFieldValue(pRules, CVY_RULE, CVY_RULE_FIELD_VIP, dwValue);

        if (dwValue != CVY_ALL_VIP) {
            dwIPAddr.S_un.S_addr = dwValue;
            szString = inet_ntoa(dwIPAddr);
            
            dprintf("      %-15s", szString);
        } else
            dprintf("      %-15s", "ALL VIPs");

        /* Get the start port. */
        GetFieldValue(pRules, CVY_RULE, CVY_RULE_FIELD_START_PORT, dwValue);

        dprintf(" %5u", dwValue);

        /* Get the end port. */
        GetFieldValue(pRules, CVY_RULE, CVY_RULE_FIELD_END_PORT, dwValue);

        dprintf("  %5u", dwValue);

        /* Figure out the protocol. */
        GetFieldValue(pRules, CVY_RULE, CVY_RULE_FIELD_PROTOCOL, dwValue);

        switch (dwValue) {
            case CVY_TCP:
                dprintf("     %s  ", "TCP");
                break;
            case CVY_UDP:
                dprintf("     %s  ", "UDP");
                break;
            case CVY_TCP_UDP:
                dprintf("    %s  ", "Both");
                break;
            default:
                dprintf("   %s", "Unknown");
                break;
        }

        /* Find the rule mode. */
        GetFieldValue(pRules, CVY_RULE, CVY_RULE_FIELD_MODE, dwValue);

        switch (dwValue) {
        case CVY_SINGLE: 
            /* Print mode and priority. */
            dprintf("   %s ", "Single");

            /* Get the handling priority. */
            GetFieldValue(pRules, CVY_RULE, CVY_RULE_FIELD_PRIORITY, dwValue);
            
            dprintf("     %2u   ", dwValue);
            break;
        case CVY_MULTI: 
            /* Print mode, weight and affinity. */
            dprintf("  %s", "Multiple");

            dprintf("  %8s", "");
            
            /* Get the equal load flag. */
            GetFieldValue(pRules, CVY_RULE, CVY_RULE_FIELD_EQUAL_LOAD, wValue);

            if (wValue) {
                dprintf("      %5s   ", "Equal");
            } else {
                /* If distribution is unequal, get the load weight. */
                GetFieldValue(pRules, CVY_RULE, CVY_RULE_FIELD_LOAD_WEIGHT, dwValue);

                dprintf("       %3u    ", dwValue);
            }

            /* Get the affinity for this rule. */
            GetFieldValue(pRules, CVY_RULE, CVY_RULE_FIELD_AFFINITY, wValue);

            switch (wValue) {
            case CVY_AFFINITY_NONE:
                dprintf("    %s", "None");
                break;
            case CVY_AFFINITY_SINGLE:
                dprintf("   %s", "Single");
                break;
            case CVY_AFFINITY_CLASSC:
                dprintf("   %s", "Class C");
                break;
            default:
                dprintf("   %s", "Unknown");
                break;
            }

            break;
        case CVY_NEVER: 
            /* Print the mode. */
            dprintf("  %s", "Disabled");
            break;
        default:

            break;
        }

        dprintf("\n");

        /* Advance the pointer to the next index in the array of structures. */
        pRules += dwRuleSize;
    }
}

/*
 * Function: PrintLoad
 * Description: Prints the contents of the CVY_LOAD structure at the specified verbosity.
 *              LOW (0) 
 *              MEDIUM (1) 
 *              HIGH (2) 
 * Author: Created by shouse, 1.21.01
 */
void PrintLoad (ULONG64 pLoad, ULONG dwVerbosity) {
    WCHAR szString[256];
    ULONG dwMissedPings[CVY_MAX_HOSTS];
    BOOL dwDirtyBins[CVY_MAX_BINS];
    ULONG64 pAddr;
    ULONG dwValue;
    ULONG dwHostID;
    BOOL bValue;

    /* Make sure the address is non-NULL. */
    if (!pLoad) {
        dprintf("Error: NLB load block is NULL.\n");
        return;
    }

    dprintf("NLB Load Block 0x%p\n", pLoad);

    /* Get the LOAD_CTXT_CODE from the structure to make sure that this address
       indeed points to a valid NLB load block. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_CODE, dwValue);
    
    if (dwValue != LOAD_CTXT_CODE) {
        dprintf("  Error: Invalid NLB load block.  Wrong code found (0x%08x).\n", dwValue);
        return;
    } 

    /* Get my host ID. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_HOST_ID, dwHostID);

    /* Determine whether or not the load context has been initialized. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_REF_COUNT, dwValue);

    dprintf("  Reference count:                    %u\n", dwValue);

    /* Determine whether or not the load context has been initialized. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_INIT, bValue);

    dprintf("  Load initialized:                   %s\n", (bValue) ? "Yes" : "No");

    /* Determine whether or not the load context is active. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_ACTIVE, bValue);

    dprintf("  Load active:                        %s\n", (bValue) ? "Yes" : "No");

    /* Get the number of total packets handled since last convergence. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_PACKET_COUNT, dwValue);

    dprintf("  Packets handled since convergence:  %u\n", dwValue);

    /* Get the number of currently active connections. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_CONNECTIONS, dwValue);

    dprintf("  Current active connections:         %u\n", dwValue);

    dprintf("\n");

    /* Find out the level of consistency from incoming heartbeats. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_CONSISTENT, bValue);

    dprintf("  Consistent heartbeats detected:     %s\n", (bValue) ? "Yes" : "No");

    /* Have we seen duplicate host IDs? */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_DUP_HOST_ID, bValue);

    dprintf("      Duplicate host IDs:             %s\n", (bValue) ? "Yes" : "No");

    /* Have we seen duplicate handling priorities? */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_DUP_PRIORITY, bValue);

    dprintf("      Duplicate handling priorities:  %s\n", (bValue) ? "Yes" : "No");

    /* Have we seen inconsistent BDA teaming configuration? */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_BAD_TEAM_CONFIG, bValue);

    dprintf("      Inconsistent BDA teaming:       %s\n", (bValue) ? "Yes" : "No");

    /* Have we seen a different number of port rules? */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_BAD_NUM_RULES, bValue);

    dprintf("      Different number of port rules: %s\n", (bValue) ? "Yes" : "No");

    /* Is the new host map bad? */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_BAD_NEW_MAP, bValue);

    dprintf("      Invalid new host map:           %s\n", (bValue) ? "Yes" : "No");

    /* Do the maps overlap? */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_OVERLAPPING_MAP, bValue);

    dprintf("      Overlapping maps:               %s\n", (bValue) ? "Yes" : "No");

    /* Was there an error in updating bins? */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_RECEIVING_BINS, bValue);

    dprintf("      Received bins already owned:    %s\n", (bValue) ? "Yes" : "No");

    /* Were there orphaned bins after an update? */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_ORPHANED_BINS, bValue);

    dprintf("      Orphaned bins:                  %s\n", (bValue) ? "Yes" : "No");

    dprintf("\n");

    /* Get the current host map. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_HOST_MAP, dwValue);

    dprintf("  Current host map:                   0x%08x ", dwValue);

    /* If there are hosts in the map, print them. */
    if (dwValue) {
        dprintf("(");
        PrintHostList(dwValue);
        dprintf(")");
    }

    dprintf("\n");

    /* Get the current map of pinged hosts. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_PING_MAP, dwValue);

    dprintf("  Ping'd host map:                    0x%08x ", dwValue);

    /* If there are hosts in the map, print them. */
    if (dwValue) {
        dprintf("(");
        PrintHostList(dwValue);
        dprintf(")");
    }

    dprintf("\n");

    /* Get the map from the last convergence. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_LAST_MAP, dwValue);

    dprintf("  Host map after last convergence:    0x%08x ", dwValue);

    /* If there are hosts in the map, print them. */
    if (dwValue) {
        dprintf("(");
        PrintHostList(dwValue);
        dprintf(")");
    }

    dprintf("\n");

    dprintf("\n");
    
    /* Get the stable host map. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_STABLE_MAP, dwValue);

    dprintf("  Stable host map:                    0x%08x ", dwValue);

    /* If there are hosts in the map, print them. */
    if (dwValue) {
        dprintf("(");
        PrintHostList(dwValue);
        dprintf(")");
    }

    dprintf("\n");

    /* Get the minimum number of timeouts with stable condition. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_MIN_STABLE, dwValue);

    dprintf("  Stable timeouts necessary:          %u\n", dwValue);

    /* Get the number of local stable timeouts. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_LOCAL_STABLE, dwValue);

    dprintf("  Local stable timeouts:              %u\n", dwValue);

    /* Get the number of global stable timeouts. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_ALL_STABLE, dwValue);

    dprintf("  Global stable timeouts:             %u\n", dwValue);

    dprintf("\n");

    /* Get the default timeout period. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_DEFAULT_TIMEOUT, dwValue);

    dprintf("  Default timeout interval:           %u millisecond(s)\n", dwValue);

    /* Get the current timeout period. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_CURRENT_TIMEOUT, dwValue);

    dprintf("  Current timeout interval:           %u millisecond(s)\n", dwValue);

    /* Get the ping miss tolerance. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_PING_TOLERANCE, dwValue);

    dprintf("  Missed ping tolerance:              %u\n", dwValue);

    /* Get the missed ping array. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_PING_MISSED, dwMissedPings);

    dprintf("  Missed pings:                       ");

    PrintMissedPings(dwMissedPings);

    dprintf("\n");

    /* Are we waiting for a cleanup? */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_CLEANUP_WAITING, bValue);

    dprintf("  Cleanup waiting:                    %s\n", (bValue) ? "Yes" : "No");

    /* Get the cleanup timeout. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_CLEANUP_TIMEOUT, dwValue);

    dprintf("  Cleanup timeout:                    %.1f second(s)\n", (float)(dwValue/1000.0));

    /* Get the current cleanup wait time. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_CLEANUP_CURRENT, dwValue);

    dprintf("  Current cleanup wait time:          %.1f second(s)\n", (float)(dwValue/1000.0));

    dprintf("\n");

    /* Get the number of descriptors per allocation. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_DESCRIPTORS_PER_ALLOC, dwValue);

    dprintf("  Descriptors per allocation:         %u\n", dwValue);

    /* Get the maximum number of allocations allowed. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_MAX_DESCRIPTOR_ALLOCS, dwValue);

    dprintf("  Maximum descriptor allocations:     %u\n", dwValue);

    /* Get the number of allocations thusfar. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_NUM_DESCRIPTOR_ALLOCS, dwValue);

    dprintf("  Number of descriptor allocations:   %u\n", dwValue);

    /* Get the inhibited allocations flag. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_INHIBITED_ALLOC, bValue);

    dprintf("  Allocations inhibited:              %s\n", (bValue) ? "Yes" : "No");

    /* Get the failed allocations flag. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_FAILED_ALLOC, bValue);

    dprintf("  Allocations failed:                 %s\n", (bValue) ? "Yes" : "No");

    /* If wer're printing at low verbosity, bail out here. */
    if (dwVerbosity == VERBOSITY_LOW) return;

    dprintf("\n");

    /* Get the dirty bin array. */
    GetFieldValue(pLoad, LOAD_CTXT, LOAD_CTXT_FIELD_DIRTY_BINS, dwDirtyBins);

    dprintf("  Dirty bins:                         ");

    /* Print the bins which have dirty connections. */
    PrintDirtyBins(dwDirtyBins);

    dprintf("\n");

    /* Get the offset of the port rule state structures and use PrintPortRuleState to print them. */
    if (GetFieldOffset(LOAD_CTXT, LOAD_CTXT_FIELD_PORT_RULE_STATE, &dwValue))
        dprintf("Can't get offset of %s in %s\n", LOAD_CTXT_FIELD_PORT_RULE_STATE, LOAD_CTXT);
    else {
        ULONG dwPortRuleStateSize;
        ULONG dwNumRules;
        ULONG dwIndex;
        ULONG dwTemp;

        /* Get the offset of the params pointer. */
        if (GetFieldOffset(LOAD_CTXT, LOAD_CTXT_FIELD_PARAMS, &dwTemp))
            dprintf("Can't get offset of %s in %s\n", LOAD_CTXT_FIELD_PARAMS, LOAD_CTXT);
        else {
            pAddr = pLoad + dwTemp;
            
            /* Retrieve the pointer. */
            pAddr = GetPointerFromAddress(pAddr);

            /* Get the number of port rules from the params block. */
            GetFieldValue(pAddr, CVY_PARAMS, CVY_PARAMS_FIELD_NUM_RULES, dwNumRules);
            
            /* Set the address of the port rule state array. */
            pAddr = pLoad + dwValue;
            
            /* Find out the size of a BIN_STATE structure. */
            dwPortRuleStateSize = GetTypeSize(BIN_STATE);
            
            /* NOTE: its "less than or equal" as opposed to "less than" because we need to include 
               the DEFAULT port rule, which is always at index "num rules" (i.e. the last rule). */
            for (dwIndex = 0; dwIndex <= dwNumRules; dwIndex++) {
                /* Print the state information for the port rule. */
                PrintPortRuleState(pAddr, dwHostID, (dwIndex == dwNumRules) ? TRUE : FALSE);
                
                if (dwIndex < dwNumRules) dprintf("\n");
                
                /* Advance the pointer to the next port rule. */
                pAddr += dwPortRuleStateSize;
            }
        }
    }

    /* If wer're printing at medium verbosity, bail out here. */
    if (dwVerbosity == VERBOSITY_MEDIUM) return;

    dprintf("\n");

    dprintf("  Heartbeat message\n");

    /* Get the offset of the heartbeat structure and use PrintHeartbeat to print it. */
    if (GetFieldOffset(LOAD_CTXT, LOAD_CTXT_FIELD_PING, &dwValue))
        dprintf("Can't get offset of %s in %s\n", LOAD_CTXT_FIELD_PING, LOAD_CTXT);
    else {
        pAddr = pLoad + dwValue;
     
        /* Print the NLB heartbeat contents. */
        PrintHeartbeat(pAddr);
    }
}

/*
 * Function: PrintResp
 * Description: Prints the NLB private data associated with the given packet.
 * Author: Created by shouse, 1.31.01
 */
void PrintResp (ULONG64 pPacket, ULONG dwDirection) {
    ULONG64 pPacketStack;
    ULONG bStackLeft;
    ULONG64 pProtReserved = 0;
    ULONG64 pIMReserved = 0;
    ULONG64 pMPReserved = 0;
    ULONG64 pResp;
    ULONG64 pAddr;
    ULONG dwValue;
    USHORT wValue;

    /* Make sure the address is non-NULL. */
    if (!pPacket) {
        dprintf("Error: Packet is NULL.\n");
        return;
    }

    /* Print a warning concerning the importance of knowing whether its a send or receive. */
    dprintf("Assuming packet 0x%p is on the %s packet path.  If this is\n", pPacket, 
            (dwDirection == DIRECTION_RECEIVE) ? "RECEIVE" : "SEND");
    dprintf("  incorrect, the information displayed below MAY be incorrect.\n");

    dprintf("\n");

    /* Get the current NDIS packet stack. */
    pPacketStack = PrintCurrentPacketStack(pPacket, &bStackLeft);

    dprintf("\n");

    if (pPacketStack) {
        /* Get the offset of the IMReserved field in the packet stack. */
        if (GetFieldOffset(NDIS_PACKET_STACK, NDIS_PACKET_STACK_FIELD_IMRESERVED, &dwValue))
            dprintf("Can't get offset of %s in %s\n", NDIS_PACKET_STACK_FIELD_IMRESERVED, NDIS_PACKET_STACK);
        else {
            pAddr = pPacketStack + dwValue;
            
            /* Get the resp pointer from the IMReserved field. */
            pIMReserved = GetPointerFromAddress(pAddr);
        }
    }
    
    /* Get the offset of the MiniportReserved field in the packet. */
    if (GetFieldOffset(NDIS_PACKET, NDIS_PACKET_FIELD_MPRESERVED, &dwValue))
        dprintf("Can't get offset of %s in %s\n", NDIS_PACKET_FIELD_MPRESERVED, NDIS_PACKET);
    else {
        pAddr = pPacket + dwValue;
        
        /* Get the resp pointer from the MPReserved field. */
        pMPReserved = GetPointerFromAddress(pAddr);
    }
    
    /* Get the offset of the ProtocolReserved field in the packet. */
    if (GetFieldOffset(NDIS_PACKET, NDIS_PACKET_FIELD_PROTRESERVED, &dwValue))
        dprintf("Can't get offset of %s in %s\n", NDIS_PACKET_FIELD_PROTRESERVED, NDIS_PACKET);
    else {
        pProtReserved = pPacket + dwValue;
    }

    /* Mimic #define MAIN_RESP_FIELD(pkt, left, ps, rsp, send) (from wlbs\driver\main.h). */
    if (pPacketStack) {
        if (pIMReserved) 
            pResp = pIMReserved;
        else if (dwDirection == DIRECTION_SEND) 
            pResp = pProtReserved;
        else if (pMPReserved) 
            pResp = pMPReserved;
        else 
            pResp = pProtReserved;
    } else {
        if (dwDirection == DIRECTION_SEND) 
            pResp = pProtReserved;
        else if (pMPReserved) 
            pResp = pMPReserved;
        else 
            pResp = pProtReserved;
    }

    dprintf("NLB Main Protocol Reserved Block 0x%p\n");
    
    /* Get the offset of the miscellaneous pointer. */
    if (GetFieldOffset(MAIN_PROTOCOL_RESERVED, MAIN_PROTOCOL_RESERVED_FIELD_MISCP, &dwValue))
        dprintf("Can't get offset of %s in %s\n", MAIN_PROTOCOL_RESERVED_FIELD_MISCP, MAIN_PROTOCOL_RESERVED);
    else {
        pAddr = pResp + dwValue;
        
        /* Retrieve the pointer. */
        pAddr = GetPointerFromAddress(pAddr);

        dprintf("  Miscellaneous pointer:              0x%p\n", pAddr);
    }

    /* Retrieve the packet type from the NLB private data. */
    GetFieldValue(pResp, MAIN_PROTOCOL_RESERVED, MAIN_PROTOCOL_RESERVED_FIELD_TYPE, wValue);
    
    switch (wValue) {
    case MAIN_PACKET_TYPE_NONE:
        dprintf("  Packet type:                        %u (None)\n", wValue);
        break;
    case MAIN_PACKET_TYPE_PING:
        dprintf("  Packet type:                        %u (Heartbeat)\n", wValue);
        break;
    case MAIN_PACKET_TYPE_INDICATE:
        dprintf("  Packet type:                        %u (Indicate)\n", wValue);
        break;
    case MAIN_PACKET_TYPE_PASS:
        dprintf("  Packet type:                        %u (Passthrough)\n", wValue);
        break;
    case MAIN_PACKET_TYPE_CTRL:
        dprintf("  Packet type:                        %u (Remote Control)\n", wValue);
        break;
    case MAIN_PACKET_TYPE_TRANSFER:
        dprintf("  Packet type:                        %u (Transfer)\n", wValue);
        break;
    case MAIN_PACKET_TYPE_IGMP:
        dprintf("  Packet type:                        %u (IGMP)\n", wValue);
        break;
    default:
        dprintf("  Packet type:                        %u (Invalid)\n", wValue);
        break;
    }

    /* Retrieve the group from the NLB private data. */
    GetFieldValue(pResp, MAIN_PROTOCOL_RESERVED, MAIN_PROTOCOL_RESERVED_FIELD_GROUP, wValue);
    
    switch (wValue) {
    case MAIN_FRAME_UNKNOWN:
        dprintf("  Packet type:                        %u (Unknown)\n", wValue);
        break;
    case MAIN_FRAME_DIRECTED:
        dprintf("  Packet type:                        %u (Directed)\n", wValue);
        break;
    case MAIN_FRAME_MULTICAST:
        dprintf("  Packet type:                        %u (Multicast)\n", wValue);
        break;
    case MAIN_FRAME_BROADCAST:
        dprintf("  Packet type:                        %u (Broadcast)\n", wValue);
        break;
    default:
        dprintf("  Packet type:                        %u (Invalid)\n", wValue);
        break;
    }

    /* Retrieve the data field from the NLB private data. */
    GetFieldValue(pResp, MAIN_PROTOCOL_RESERVED, MAIN_PROTOCOL_RESERVED_FIELD_DATA, dwValue);
    
    dprintf("  Data:                               %u\n", dwValue);

    /* Retrieve the length field from the NLB private data. */
    GetFieldValue(pResp, MAIN_PROTOCOL_RESERVED, MAIN_PROTOCOL_RESERVED_FIELD_LENGTH, dwValue);
    
    dprintf("  Length:                             %u\n", dwValue);
}

/*
 * Function: PrintCurrentPacketStack
 * Description: Retrieves the current packet stack for the specified packet.  Note: this
 *              is heavily dependent on the current NDIS packet stacking mechanics - any
 *              changes to NDIS packet stacking could easily (will) break this.  This 
 *              entire function mimics NdisIMGetCurrentPacketStack().
 * Author: Created by shouse, 1.31.01
 */
ULONG64 PrintCurrentPacketStack (ULONG64 pPacket, ULONG * bStackLeft) {
    ULONG64 pNumPacketStacks;
    ULONG64 pPacketWrapper;
    ULONG64 pPacketStack;
    ULONG dwNumPacketStacks;
    ULONG dwStackIndexSize;
    ULONG dwPacketStackSize;
    ULONG dwCurrentIndex;

    /* Make sure the address is non-NULL. */
    if (!pPacket) {
        dprintf("Error: Packet is NULL.\n");
        *bStackLeft = 0;
        return 0;
    }

    /* Get the address of the global variable containing the number of packet stacks. */
    pNumPacketStacks = GetExpression(NDIS_PACKET_STACK_SIZE);

    if (!pNumPacketStacks) {
        ErrorCheckSymbols(NDIS_PACKET_STACK_SIZE);
        *bStackLeft = 0;
        return 0;
    }

    /* Get the number of packet stacks from the address. */
    dwNumPacketStacks = GetUlongFromAddress(pNumPacketStacks);

    /* Find out the size of a STACK_INDEX structure. */
    dwStackIndexSize = GetTypeSize(STACK_INDEX);

    /* Find out the size of a NDIS_PACKET_STACK structure. */
    dwPacketStackSize = GetTypeSize(NDIS_PACKET_STACK);

    /* This is the calculation we're doing (from ndis\sys\wrapper.h):
       #define SIZE_PACKET_STACKS (sizeof(STACK_INDEX) + (sizeof(NDIS_PACKET_STACK) * ndisPacketStackSize)) */
    pPacketStack = pPacket - (dwStackIndexSize + (dwPacketStackSize * dwNumPacketStacks));

    /* The wrapper is the packet address minus the size of the stack index.  
       See ndis\sys\wrapper.h.  We need this to get the current stack index. */
    pPacketWrapper = pPacket - dwStackIndexSize;

    dprintf("NDIS Packet Stack: 0x%p\n", pPacketStack);

    /* Retrieve the current stack index. */
    GetFieldValue(pPacketWrapper, NDIS_PACKET_WRAPPER, NDIS_PACKET_WRAPPER_FIELD_STACK_INDEX, dwCurrentIndex);

    dprintf("  Current stack index:                %d\n", dwCurrentIndex);

    if (dwCurrentIndex < dwNumPacketStacks) {
        /* If the current index is less than the number of stacks, then point the stack to 
           the right address and determine whether or not there is stack room left. */
        pPacketStack += dwCurrentIndex * dwPacketStackSize;
        *bStackLeft = (dwNumPacketStacks - dwCurrentIndex - 1) > 0;
    } else {
       /* If not, then we're out of stack space. */
        pPacketStack = 0;
        *bStackLeft = 0;
    }

    dprintf("  Current packet stack:               0x%p\n", pPacketStack);
    dprintf("  Stack remaining:                    %s\n", (*bStackLeft) ? "Yes" : "No");

    return pPacketStack;
}

/*
 * Function: PrintHostList
 * Description: Prints a list of hosts in a host map.
 * Author: Created by shouse, 2.1.01
 */
void PrintHostList (ULONG dwHostMap) {
    BOOL bFirst = TRUE;
    ULONG dwHostNum = 1;
    
    /* As long as there are hosts still in the map, print them. */
    while (dwHostMap) {
        /* If the least significant bit is set, print the host number. */
        if (dwHostMap & 0x00000001) {
            /* If this is the first host printed, just print the number. */
            if (bFirst) {
                dprintf("%u", dwHostNum);
                bFirst = FALSE;
            } else
                /* Otherwise, we need to print a comma first. */
                dprintf(", %u", dwHostNum);
        }
        
        /* Increment the host number and shift the map to the right one bit. */
        dwHostNum++;
        dwHostMap >>= 1;
    }
}

/*
 * Function: PrintMissedPings
 * Description: Prints a list hosts from which we are missing pings.
 * Author: Created by shouse, 2.1.01
 */
void PrintMissedPings (ULONG dwMissedPings[]) {
    BOOL bMissing = FALSE;
    ULONG dwIndex;

    /* Loop through the entire array of missed pings. */
    for (dwIndex = 0; dwIndex < CVY_MAX_HOSTS; dwIndex++) {
        /* If we're missing pings from this host, print the number missed and 
           the host priority, which is the index (host ID) plus one. */
        if (dwMissedPings[dwIndex]) {
            dprintf("\n      Missing %u pings from Host %u", dwMissedPings[dwIndex], dwIndex + 1);
            
            /* Not the fact that we found at least one host with missing pings. */
            bMissing = TRUE;
        }
    }

    /* If we're missing no pings, print "None". */
    if (!bMissing) dprintf("None");

    dprintf("\n");
}

/*
 * Function: PrintDirtyBins
 * Description: Prints a list of bins with dirty connections.
 * Author: Created by shouse, 2.1.01
 */
void PrintDirtyBins (BOOL dwDirtyBins[]) {
    BOOL bFirst = TRUE;
    ULONG dwIndex;

    /* Loop through the entire array of dirty bins. */
    for (dwIndex = 0; dwIndex < CVY_MAX_BINS; dwIndex++) {
        if (dwDirtyBins[dwIndex]) {
            /* If this is the first bin printed, just print the number. */
            if (bFirst) {
                dprintf("%u", dwIndex);
                bFirst = FALSE;
            } else
                /* Otherwise, we need to print a comma first. */
                dprintf(", %u", dwIndex);
        }
    }

    /* If there are no dirty bins, print "None". */
    if (bFirst) dprintf("None");

    dprintf("\n");
}

/*
 * Function: PrintHeartbeat
 * Description: Prints the contents of the NLB heartbeat structure.
 * Author: Created by shouse, 2.1.01
 */
void PrintHeartbeat (ULONG64 pHeartbeat) {
    ULONG dwValue;
    USHORT wValue;
    ULONG dwIndex;
    ULONG dwRuleCode[CVY_MAX_RULES];
    ULONGLONG ddwCurrentMap[CVY_MAX_RULES];
    ULONGLONG ddwNewMap[CVY_MAX_RULES];
    ULONGLONG ddwIdleMap[CVY_MAX_RULES];
    ULONGLONG ddwReadyBins[CVY_MAX_RULES];
    ULONG dwLoadAmount[CVY_MAX_RULES];
    
    /* Make sure the address is non-NULL. */
    if (!pHeartbeat) {
        dprintf("Error: Heartbeat is NULL.\n");
        return;
    }

    /* Get the default host ID. */
    GetFieldValue(pHeartbeat, PING_MSG, PING_MSG_FIELD_DEFAULT_HOST_ID, wValue);
    
    dprintf("      DEFAULT host ID:                %u (%u)\n", wValue, wValue + 1);

    /* Get my host ID. */
    GetFieldValue(pHeartbeat, PING_MSG, PING_MSG_FIELD_HOST_ID, wValue);
    
    dprintf("      My host ID:                     %u (%u)\n", wValue, wValue + 1);

    /* Get my host code. */
    GetFieldValue(pHeartbeat, PING_MSG, PING_MSG_FIELD_HOST_CODE, dwValue);
    
    dprintf("      Unique host code:               0x%08x\n", dwValue);
    
    /* Get the host state. */
    GetFieldValue(pHeartbeat, PING_MSG, PING_MSG_FIELD_STATE, wValue);
    
    dprintf("      Host state:                     ");

    switch (wValue) {
    case HST_CVG:
        dprintf("Converging\n");
        break;
    case HST_STABLE:
        dprintf("Stable\n");
        break;
    case HST_NORMAL:
        dprintf("Normal\n");
        break;
    default:
        dprintf("Unknown\n");
        break;
    }

    /* Get the teaming configuration code. */
    GetFieldValue(pHeartbeat, PING_MSG, PING_MSG_FIELD_TEAMING_CODE, dwValue);
    
    dprintf("      BDA teaming configuration:      0x%08x\n", dwValue);

    /* Get the packet count. */
    GetFieldValue(pHeartbeat, PING_MSG, PING_MSG_FIELD_PACKET_COUNT, dwValue);
    
    dprintf("      Packets handled:                %u\n", dwValue);

    /* Get the number of port rules. */
    GetFieldValue(pHeartbeat, PING_MSG, PING_MSG_FIELD_NUM_RULES, wValue);
    
    dprintf("      Number of port rules:           %u\n", wValue);

    /* Get the rule codes. */
    GetFieldValue(pHeartbeat, PING_MSG, PING_MSG_FIELD_RULE_CODE, dwRuleCode);

    /* Get the current bin map. */
    GetFieldValue(pHeartbeat, PING_MSG, PING_MSG_FIELD_CURRENT_MAP, ddwCurrentMap);

    /* Get the new bin map. */
    GetFieldValue(pHeartbeat, PING_MSG, PING_MSG_FIELD_NEW_MAP, ddwNewMap);

    /* Get the idle bin map. */
    GetFieldValue(pHeartbeat, PING_MSG, PING_MSG_FIELD_IDLE_MAP, ddwIdleMap);

    /* Get the ready bins map. */
    GetFieldValue(pHeartbeat, PING_MSG, PING_MSG_FIELD_READY_BINS, ddwReadyBins);

    /* Get the load amount for each rule. */
    GetFieldValue(pHeartbeat, PING_MSG, PING_MSG_FIELD_LOAD_AMOUNT, dwLoadAmount);
    
    /* Loop through all port rules and spit out some information. */
    for (dwIndex = 0; dwIndex < wValue; dwIndex++) {
        /* Decode the rule.  See CVY_RULE_CODE_SET() in net\inc\wlbsparams.h. */
        ULONG dwStartPort = dwRuleCode[dwIndex] & 0x00000fff;
        ULONG dwEndPort = (dwRuleCode[dwIndex] & 0x00fff000) >> 12;
        ULONG dwProtocol = (dwRuleCode[dwIndex] & 0x0f000000) >> 24;
        ULONG dwMode = (dwRuleCode[dwIndex] & 0x30000000) >> 28;
        ULONG dwAffinity = (dwRuleCode[dwIndex] & 0xc0000000) >> 30;

        dprintf("      Port rule %u\n", dwIndex + 1);
           
        /* Print out the bin maps and load weight. */
        dprintf("          Rule code:                  0x%08x ", dwRuleCode[dwIndex]);
        
        /* If this is the last port rule, then its the default port rule. */
        if (dwIndex == (wValue - 1))
            dprintf("(DEFAULT port rule)\n");
        else {
#if 0 /* Because rule codes are overlapped logical ORs, we can't necessarily get back the
         information that was put in, so we won't spit it out until we can guarantee that. */

            /* Print out the port range - keep in mind that 16 bit port ranges are 
               encoded in 12 bit numbers, so this may not be 100% accurate. */
            dprintf("(%u - %u, ", dwStartPort, dwEndPort);
            
            /* Print the protocol. */
            switch (dwProtocol) {
            case CVY_TCP:
                dprintf("TCP, ");
                break;
            case CVY_UDP:
                dprintf("UDP, ");
                break;
            case CVY_TCP_UDP:
                dprintf("TCP/UDP, ");
                break;
            default:
                dprintf("Unknown protocol, ");
                break;
            }
            
            /* Print the filtering mode. */
            switch (dwMode) {
            case CVY_SINGLE:
                dprintf("Single host)\n");
                break;
            case CVY_MULTI:
                dprintf("Multiple host, ");
                
                /* If this rule uses multiple host, then we also print the affinity. */
                switch (dwAffinity) {
                case CVY_AFFINITY_NONE:
                    dprintf("No affinity)\n");
                    break;
                case CVY_AFFINITY_SINGLE:
                    dprintf("Single affinity)\n");
                    break;
                case CVY_AFFINITY_CLASSC:
                    dprintf("Class C affinity)\n");
                    break;
                default:
                    dprintf("Unknown affinity)\n");
                    break;
                }
                
                break;
            case CVY_NEVER:
                dprintf("Disabled)\n");
                break;
            default:
                dprintf("Unknown filtering mode)\n");
                break;
            }
#else
            dprintf("\n");
#endif
            /* Print the load weight. */
            dprintf("          Load weight:                %u\n", dwLoadAmount[dwIndex]);        
        }

        /* Print the bin maps for all rules, default or not. */
        dprintf("          Current map:                0x%015I64x\n", ddwCurrentMap[dwIndex]);        
        dprintf("          New map:                    0x%015I64x\n", ddwNewMap[dwIndex]);        
        dprintf("          Idle map:                   0x%015I64x\n", ddwIdleMap[dwIndex]);        
        dprintf("          Ready bins:                 0x%015I64x\n", ddwReadyBins[dwIndex]);        
    }
}

/*
 * Function: PrintPortRuleState
 * Description: Prints the state information for the port rule.
 * Author: Created by shouse, 2.5.01
 */
void PrintPortRuleState (ULONG64 pPortRule, ULONG dwHostID, BOOL bDefault) {
    ULONG dwValue;
    ULONG dwMode;
    USHORT wValue;
    BOOL bValue;
    ULONGLONG ddwValue;

    /* Make sure the address is non-NULL. */
    if (!pPortRule) {
        dprintf("Error: Port rule is NULL.\n");
        return;
    }

    /* Get the BIN_STATE_CODE from the structure to make sure that this address
       indeed points to a valid NLB port rule state block. */
    GetFieldValue(pPortRule, BIN_STATE, BIN_STATE_FIELD_CODE, dwValue);
    
    if (dwValue != BIN_STATE_CODE) {
        dprintf("  Error: Invalid NLB port rule state block.  Wrong code found (0x%08x).\n", dwValue);
        return;
    } 

    /* Get the index of the rule - the "rule number". */
    GetFieldValue(pPortRule, BIN_STATE, BIN_STATE_FIELD_INDEX, dwValue);

    dprintf("  Port rule %u\n", dwValue + 1);

    /* Is the port rule state initialized? */
    GetFieldValue(pPortRule, BIN_STATE, BIN_STATE_FIELD_INITIALIZED, bValue);

    dprintf("      State initialized:              %s\n", (bValue) ? "Yes" : "No");

    /* Are the codes compatible? */
    GetFieldValue(pPortRule, BIN_STATE, BIN_STATE_FIELD_COMPATIBLE, bValue);

    dprintf("      Compatibility detected:         %s\n", (bValue) ? "Yes" : "No");

    /* Is the port rule state initialized? */
    GetFieldValue(pPortRule, BIN_STATE, BIN_STATE_FIELD_EQUAL, bValue);

    dprintf("      Equal load balancing:           %s\n", (bValue) ? "Yes" : "No");

    /* Get the filtering mode for this port rule. */
    GetFieldValue(pPortRule, BIN_STATE, BIN_STATE_FIELD_MODE, dwMode);

    dprintf("      Filtering mode:                 "); 

    /* If this is the DEFAULT port rule, then jump to the bottom. */
    if (bDefault) {
        dprintf("DEFAULT\n");
        goto end;
    }

    switch (dwMode) {
    case CVY_SINGLE:
        dprintf("Single host\n");
        break;
    case CVY_MULTI:
        dprintf("Multiple host\n");
        break;
    case CVY_NEVER:
        dprintf("Disabled\n");
        break;
    default:
        dprintf("Unknown\n");
        break;
    }

    if (dwMode == CVY_MULTI) {
        /* Get the affinity for this port rule. */
        GetFieldValue(pPortRule, BIN_STATE, BIN_STATE_FIELD_AFFINITY, wValue);
        
        dprintf("      Affinity:                       ");
        
        switch (wValue) {
        case CVY_AFFINITY_NONE:
            dprintf("None\n");
            break;
        case CVY_AFFINITY_SINGLE:
            dprintf("Single\n");
            break;
        case CVY_AFFINITY_CLASSC:
            dprintf("Class C\n");
            break;
        default:
            dprintf("Unknown\n");
            break;
        }
    }
    
    /* Get the protocol(s) for this port rule. */
    GetFieldValue(pPortRule, BIN_STATE, BIN_STATE_FIELD_PROTOCOL, dwValue);

    dprintf("      Protocol(s):                    ");

    /* Print the protocol. */
    switch (dwValue) {
    case CVY_TCP:
        dprintf("TCP\n");
        break;
    case CVY_UDP:
        dprintf("UDP\n");
        break;
    case CVY_TCP_UDP:
        dprintf("TCP/UDP\n");
        break;
    default:
        dprintf("Unknown\n");
        break;
    }

    /* In multiple host filtering, print the load information.  For single host 
       filtering, print the host priority information. */
    if (dwMode == CVY_MULTI) {
        ULONG dwCurrentLoad[CVY_MAX_HOSTS];

        /* Get the original load for this rule on this host. */
        GetFieldValue(pPortRule, BIN_STATE, BIN_STATE_FIELD_ORIGINAL_LOAD, dwValue);
        
        dprintf("      Configured load weight:         %u\n", dwValue);    
        
        /* Get the original load for this rule on this host. */
        GetFieldValue(pPortRule, BIN_STATE, BIN_STATE_FIELD_CURRENT_LOAD, dwCurrentLoad);
        
        dprintf("      Current load weight:            %u/", dwCurrentLoad[dwHostID]);    
        
        /* Get the total load for this rule on all hosts. */
        GetFieldValue(pPortRule, BIN_STATE, BIN_STATE_FIELD_TOTAL_LOAD, dwValue);

        dprintf("%u\n", dwValue);    
    } else if (dwMode == CVY_SINGLE) {
        /* Get the host priority. */
        GetFieldValue(pPortRule, BIN_STATE, BIN_STATE_FIELD_ORIGINAL_LOAD, dwValue);
        
        dprintf("      Host priority:                  %u\n", dwValue);    
    }

 end:

    /* Get the total number of active connections. */
    GetFieldValue(pPortRule, BIN_STATE, BIN_STATE_FIELD_TOTAL_CONNECTIONS, dwValue);
    
    dprintf("      Total active connections:       %u\n", dwValue);    

    /* Get the current map. */
    GetFieldValue(pPortRule, BIN_STATE, BIN_STATE_FIELD_CURRENT_MAP, ddwValue);
    
    dprintf("      Current map:                    0x%015I64x\n", ddwValue);

    /* Get the all idle map. */
    GetFieldValue(pPortRule, BIN_STATE, BIN_STATE_FIELD_ALL_IDLE_MAP, ddwValue);
    
    dprintf("      All idle map:                   0x%015I64x\n", ddwValue);

    /* Get the idle bins map. */
    GetFieldValue(pPortRule, BIN_STATE, BIN_STATE_FIELD_IDLE_BINS, ddwValue);
    
    dprintf("      My idle map:                    0x%015I64x\n", ddwValue);
}

/*
 * Function: PrintBDAMember
 * Description: Prints the BDA teaming configuration and state of a member.
 * Author: Created by shouse, 4.8.01
 */
void PrintBDAMember (ULONG64 pMember) {
    ULONG64 pAddr;
    ULONG dwValue;

    /* Make sure the address is non-NULL. */
    if (!pMember) {
        dprintf("Error: Member is NULL.\n");
        return;
    }

    /* Find out whether or not teaming is active on this adapter. */
    GetFieldValue(pMember, BDA_MEMBER, BDA_MEMBER_FIELD_ACTIVE, dwValue);
    
    dprintf("  Bi-directional affinity teaming:    %s\n", (dwValue) ? "Active" : "Inactive");
    
    /* Get the team-assigned member ID. */
    GetFieldValue(pMember, BDA_MEMBER, BDA_MEMBER_FIELD_MEMBER_ID, dwValue);
    
    if (dwValue == CVY_BDA_INVALID_MEMBER_ID) 
        dprintf("      Member ID:                      %s\n", "Invalid");
    else 
        dprintf("      Member ID:                      %u\n", dwValue);

    /* Get the master status flag. */
    GetFieldValue(pMember, BDA_MEMBER, BDA_MEMBER_FIELD_MASTER, dwValue);
    
    dprintf("      Master:                         %s\n", (dwValue) ? "Yes" : "No");
    
    /* Get the reverse hashing flag. */
    GetFieldValue(pMember, BDA_MEMBER, BDA_MEMBER_FIELD_REVERSE_HASH, dwValue);
    
    dprintf("      Reverse hashing:                %s\n", (dwValue) ? "Yes" : "No");

    /* Get the pointer to the BDA team. */
    GetFieldValue(pMember, BDA_MEMBER, BDA_MEMBER_FIELD_TEAM, pAddr);

    dprintf("     %sBDA team:                       0x%p\n", (pAddr) ? "-" : "+", pAddr);    
    
    /* If this adapter is part of a team, print out the team configuration and state. */
    if (pAddr) {
        dprintf("\n");
        PrintBDATeam(pAddr);
    }
}

/*
 * Function: PrintBDAMember
 * Description: Prints the BDA teaming configuration and state of a member.
 * Author: Created by shouse, 4.8.01
 */
void PrintBDATeam (ULONG64 pTeam) {
    WCHAR szString[256];
    ULONG64 pAddr;
    ULONG dwValue;

    /* Make sure the address is non-NULL. */
    if (!pTeam) {
        dprintf("Error: Team is NULL.\n");
        return;
    }

    dprintf("  BDA Team 0x%p\n", pTeam);

    /* Find out whether or not the team is active. */
    GetFieldValue(pTeam, BDA_TEAM, BDA_TEAM_FIELD_ACTIVE, dwValue);

    dprintf("      Active:                         %s\n", (dwValue) ? "Yes" : "No");

    /* Get the offset of the team ID and retrieve the string from that address. */
    if (GetFieldOffset(BDA_TEAM, BDA_TEAM_FIELD_TEAM_ID, &dwValue))
        dprintf("Can't get offset of %s in %s\n", BDA_TEAM_FIELD_TEAM_ID, BDA_TEAM);
    else {
        pAddr = pTeam + dwValue;
        
        /* Retrieve the contexts of the string and store it in a buffer. */
        GetString(pAddr, szString, CVY_MAX_BDA_TEAM_ID + 1);
        
        dprintf("      Team ID:                        %ls\n", szString);
    }

    /* Get the current membership count. */
    GetFieldValue(pTeam, BDA_TEAM, BDA_TEAM_FIELD_MEMBERSHIP_COUNT, dwValue);

    dprintf("      Number of members:              %u\n", dwValue);

    /* Get the current membership list. */
    GetFieldValue(pTeam, BDA_TEAM, BDA_TEAM_FIELD_MEMBERSHIP_FINGERPRINT, dwValue);

    dprintf("      Membership fingerprint:         0x%08x\n", dwValue);
    
    /* Get the current membership map. */
    GetFieldValue(pTeam, BDA_TEAM, BDA_TEAM_FIELD_MEMBERSHIP_MAP, dwValue);

    dprintf("      Members:                        0x%08x ", dwValue);

    /* If there are members in the map, print them. */
    if (dwValue) {
        dprintf("(");
        PrintBDAMemberList(dwValue);
        dprintf(")");
    }

    dprintf("\n");

    /* Get the current consistency map. */
    GetFieldValue(pTeam, BDA_TEAM, BDA_TEAM_FIELD_CONSISTENCY_MAP, dwValue);

    dprintf("      Consistent members:             0x%08x ", dwValue);

    /* If there are members in the map, print them. */
    if (dwValue) {
        dprintf("(");
        PrintBDAMemberList(dwValue);
        dprintf(")");
    }

    dprintf("\n");

    /* Get the offset of the load module pointer. */
    if (GetFieldOffset(BDA_TEAM, BDA_TEAM_FIELD_LOAD, &dwValue))
        dprintf("Can't get offset of %s in %s\n", BDA_TEAM_FIELD_LOAD, BDA_TEAM);
    else {
        pAddr = pTeam + dwValue;

        /* Retrieve the pointer. */
        pAddr = GetPointerFromAddress(pAddr);

        dprintf("      Load:                           0x%p\n", pAddr);    
    }

    /* Get the offset of the load lock pointer. */
    if (GetFieldOffset(BDA_TEAM, BDA_TEAM_FIELD_LOAD_LOCK, &dwValue))
        dprintf("Can't get offset of %s in %s\n", BDA_TEAM_FIELD_LOAD_LOCK, BDA_TEAM);
    else {
        pAddr = pTeam + dwValue;

        /* Retrieve the pointer. */
        pAddr = GetPointerFromAddress(pAddr);

        dprintf("      Load lock:                      0x%p\n", pAddr);
    }

    /* Get the offset of the previous pointer. */
    if (GetFieldOffset(BDA_TEAM, BDA_TEAM_FIELD_PREV, &dwValue))
        dprintf("Can't get offset of %s in %s\n", BDA_TEAM_FIELD_PREV, BDA_TEAM);
    else {
        pAddr = pTeam + dwValue;

        /* Retrieve the pointer. */
        pAddr = GetPointerFromAddress(pAddr);

        dprintf("      Previous BDA Team:              0x%p\n", pAddr);    
    }

    /* Get the offset of the next pointer. */
    if (GetFieldOffset(BDA_TEAM, BDA_TEAM_FIELD_NEXT, &dwValue))
        dprintf("Can't get offset of %s in %s\n", BDA_TEAM_FIELD_NEXT, BDA_TEAM);
    else {
        pAddr = pTeam + dwValue;

        /* Retrieve the pointer. */
        pAddr = GetPointerFromAddress(pAddr);

        dprintf("      Next BDA Team:                  0x%p\n", pAddr);
    }    
}

/*
 * Function: PrintBDAMemberList
 * Description: Prints a list of members in a BDA membership or consistency map. 
 * Author: Created by shouse, 4.8.01
 */
void PrintBDAMemberList (ULONG dwMemberMap) {
    BOOL bFirst = TRUE;
    ULONG dwMemberNum = 0;
    
    /* As long as there are hosts still in the map, print them. */
    while (dwMemberMap) {
        /* If the least significant bit is set, print the host number. */
        if (dwMemberMap & 0x00000001) {
            /* If this is the first host printed, just print the number. */
            if (bFirst) {
                dprintf("%u", dwMemberNum);
                bFirst = FALSE;
            } else
                /* Otherwise, we need to print a comma first. */
                dprintf(", %u", dwMemberNum);
        }
        
        /* Increment the host number and shift the map to the right one bit. */
        dwMemberNum++;
        dwMemberMap >>= 1;
    }
}

/*
 * Function: PrintQueue
 * Description: Prints MaxEntries entries in a connection descriptor queue.
 * Author: Created by shouse, 4.15.01
 */
void PrintQueue (ULONG64 pQueue, ULONG dwMaxEntries) {


}

/*
 * Function: PrintMap
 * Description: Searches the given load module to determine who should accept this packet.  If
 *              state for this packet already exists, it is printed. 
 * Author: Created by shouse, 4.15.01
 */
void PrintMap (ULONG64 pLoad, ULONG dwClientIPAddress, ULONG dwClientPort, ULONG dwServerIPAddress, ULONG dwServerPort, BOOLEAN bIsTCP, TCP_PACKET_TYPE ePktType) {
    WCHAR szString[256];
    ULONG64 pAddr;
    ULONG dwValue;

    /* Make sure the load address is non-NULL. */
    if (!pLoad) {
        dprintf("Error: Load is NULL.\n");
        return;
    }

    dprintf("Looking for connection tuple (0x%08x, %u, 0x%08x, %u, %s", dwClientIPAddress, dwClientPort, dwServerIPAddress, dwServerPort, (bIsTCP) ? "TCP" : "UDP");
    
    if (bIsTCP)
        dprintf(" %s)\n", TCPPacketTypeToString(ePktType));
    else
        dprintf(")\n");
    
    dprintf("Map returned: %u\n", Map(dwClientIPAddress, dwServerIPAddress));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbkd\print.h ===
/*
 * File: print.h
 * Description: This file contains function prototypes for the print
 *              utilities for the NLB KD extensions.
 * History: Created by shouse, 1.4.01
 */

/* Prints usage information for the specified context. */
void PrintUsage (ULONG dwContext);

/* Prints the contents of the MAIN_ADAPTER structure at the specified verbosity. */
void PrintAdapter (ULONG64 pAdapter, ULONG dwVerbosity);

/* Prints the contents of the MAIN_CTXT structure at the specified verbosity. */
void PrintContext (ULONG64 pContext, ULONG dwVerbosity);

/* Prints the contents of the CVY_PARAMS structure at the specified verbosity. */
void PrintParams (ULONG64 pParams, ULONG dwVerbosity);

/* Prints the NLB port rules. */
void PrintPortRules (ULONG dwNumRules, ULONG64 pRules);

/* Prints the contents of the CVY_LOAD structure at the specified verbosity. */
void PrintLoad (ULONG64 pLoad, ULONG dwVerbosity);

/* Prints the NLB private data associated with the given packet. */
void PrintResp (ULONG64 pPacket, ULONG dwDirection);

/* Prints a list of hosts in a host map. */
void PrintHostList (ULONG dwHostMap);

/* Prints a list hosts from which we are missing pings. */
void PrintMissedPings (ULONG dwMissedPings[]);

/* Prints a list of bins with dirty connections. */
void PrintDirtyBins (BOOL dwDirtyBins[]);

/* Prints the contents of the NLB heartbeat structure. */
void PrintHeartbeat (ULONG64 pHeartbeat);

/* Prints the state information for the port rule. */
void PrintPortRuleState (ULONG64 pPortRule, ULONG dwHostID, BOOL bDefault);

/* Retrieves the current packet stack for the specified packet. */
ULONG64 PrintCurrentPacketStack (ULONG64 pPacket, ULONG * bStackLeft);

/* Prints the BDA member configuration and state. */
void PrintBDAMember (ULONG64 pMember);

/* Prints the BDA team configuration and state. */
void PrintBDATeam (ULONG64 pMember);

/* Prints a list of members in a BDA membership or consistency map. */
void PrintBDAMemberList (ULONG dwMemberMap);

/* Prints MaxEntries entries in a connection descriptor queue. */
void PrintQueue (ULONG64 pQueue, ULONG dwMaxEntries);

/* Searches the given load module to determine who should accept this packet.  If state for this packet already exists, it is printed. */
void PrintMap (ULONG64 pLoad, ULONG dwClientIPAddress, ULONG dwClientPort, ULONG dwServerIPAddress, ULONG dwServerPort, BOOLEAN bIsTCP, TCP_PACKET_TYPE ePktType);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\exe\aboutdialog.cpp ===
#include "AboutDialog.h"

AboutDialog::AboutDialog(CWnd* parent )
        :
        CDialog( IDD, parent )
{}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\exe\aboutdialog.h ===
#ifndef ABOUTDIALOG_H
#define ABOUTDIALOG_H

#include "stdafx.h"

#include "resource.h"

class AboutDialog : public CDialog
{
public:
    enum
    {
        IDD = IDD_ABOUT,
    };

    AboutDialog(CWnd* parent = NULL);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbkd\utils.h ===
/*
 * File: utils.h
 * Description: This file contains function prototypes for the utility
 *              functions for the NLB KD extensions.
 * History: Created by shouse, 1.4.01
 */

/* Prints an error message when the symbols are bad. */
VOID ErrorCheckSymbols (CHAR * symbol);

/* Tokenizes a string via a configurable list of tokens. */
char * mystrtok (char * string, char * control);

/* Returns a ULONG residing at a given memory location. */
ULONG GetUlongFromAddress (ULONG64 Location);

/* Returns a memory address residing at a given memory location. */
ULONG64 GetPointerFromAddress (ULONG64 Location);

/* Reads data from a memory location into a buffer. */
BOOL GetData (IN LPVOID ptr, IN ULONG64 dwAddress, IN ULONG size, IN PCSTR type);

/* Copies a string from memory into a buffer. */
BOOL GetString (IN ULONG64 dwAddress, IN LPWSTR buf, IN ULONG MaxChars);

/* Copies an ethernet MAC address from memory into a buffer. */
BOOL GetMAC (IN ULONG64 dwAddress, IN UCHAR * buf, IN ULONG NumChars);

/* Returns a string corresponding to the enumerated TCP packet type. */
CHAR * TCPPacketTypeToString (TCP_PACKET_TYPE ePktType);

/* This IS the NLB hashing function. */
ULONG Map (ULONG v1, ULONG v2);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\exe\application.h ===
#ifndef APPLICATION_H
#define APPLICATION_H

#include "stdafx.h"

class Application : public CWinApp
{
public:
    virtual BOOL InitInstance();

    afx_msg void OnAppAbout();

    DECLARE_MESSAGE_MAP()
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbkd\utils.c ===
/*
 * File: utils.c
 * Description: This file contains the implementation of some utility
 *              functions for the NLB KD extensions.
 * Author: Created by shouse, 1.4.01
 */

#include "nlbkd.h"
#include "utils.h"
#include "print.h"

/*
 * Function: ErrorCheckSymbols
 * Description: Prints an error message when the symbols are bad.
 * Author: Created by shouse, 1.4.01 - copied largely from ndiskd.dll
 */
VOID ErrorCheckSymbols (CHAR * symbol) {

    dprintf("NLBKD: Error: Could not access %s - check symbols for wlbs.sys\n", symbol);
}

/*
 * Function: mystrtok
 * Description: Tokenizes a string via a configurable list of tokens.
 * Author: Created by shouse, 1.4.01 - copied largely from ndiskd.dll
 */
char * mystrtok (char * string, char * control) {
    static unsigned char * str;
    CHAR * p;
    CHAR * s;

    if (string) str = string;

    if (!str || (*str == '\0')) return NULL;

    for (; *str; str++) {
        for (s = control; *s; s++)
            if (*str == *s) break;
        
        if (*s == '\0') break;
    }

    if (*str == '\0') {
        str = NULL;
        return NULL;
    }

    for (p = str + 1; *p; p++) {
        for (s = control; *s; s++) {
            if(*p == *s) {
                s = str;
                *p = '\0';
                str = p + 1;
                return s;
            }
        }
    }

    s = str;
    str = NULL;

    return s;
}

/*
 * Function: GetUlongFromAddress
 * Description: Returns a ULONG residing at a given memory location.
 * Author: Created by shouse, 1.4.01 - copied largely from ndiskd.dll
 */
ULONG GetUlongFromAddress (ULONG64 Location) {
    ULONG result;
    ULONG Value;

    if ((!ReadMemory(Location, &Value, sizeof(ULONG), &result)) || (result < sizeof(ULONG))) {
        dprintf("unable to read from %08x\n", Location);
        return 0;
    }

    return Value;
}

/*
 * Function: GetPointerFromAddress
 * Description: Returns a memory address residing at a given memory location.
 * Author: Created by shouse, 1.4.01 - copied largely from ndiskd.dll
 */
ULONG64 GetPointerFromAddress (ULONG64 Location) {
    ULONG64 Value;

    if (ReadPtr(Location,&Value)) {
        dprintf("unable to read from %p\n", Location);
        return 0;
    }

    return Value;
}

/*
 * Function: GetData
 * Description: Reads data from a memory location into a buffer.
 * Author: Created by shouse, 1.4.01 - copied largely from ndiskd.dll
 */
BOOL GetData (IN LPVOID ptr, IN ULONG64 dwAddress, IN ULONG size, IN PCSTR type) {
    ULONG count = size;
    ULONG BytesRead;
    BOOL b;

    while (size > 0) {

        if (count >= 3000) count = 3000;

        b = ReadMemory(dwAddress, ptr, count, &BytesRead);

        if (!b || BytesRead != count) {
            dprintf("Unable to read %u bytes at %p, for %s\n", size, dwAddress, type);
            return FALSE;
        }

        dwAddress += count;
        size -= count;
        ptr = (LPVOID)((ULONG_PTR)ptr + count);
    }

    return TRUE;
}

/*
 * Function: GetString
 * Description: Copies a string from memory into a buffer.
 * Author: Created by shouse, 1.4.01 - copied largely from ndiskd.dll
 */
BOOL GetString (IN ULONG64 dwAddress, IN LPWSTR buf, IN ULONG MaxChars) {

    do {
        if (!GetData(buf, dwAddress, sizeof(*buf), "Character"))
            return FALSE;

        dwAddress += sizeof(*buf);

    } while (--MaxChars && *buf++ != '\0');

    return TRUE;
}

/*
 * Function: GetMAC
 * Description: Copies an ethernet MAC address from memory into a buffer.
 * Author: Created by shouse, 1.14.01
 */
BOOL GetMAC (IN ULONG64 dwAddress, IN UCHAR * buf, IN ULONG NumChars) {

    do {
        if (!GetData(buf, dwAddress, sizeof(*buf), "Character"))
            return FALSE;

        dwAddress += sizeof(*buf);

        buf++;

    } while (--NumChars);

    return TRUE;
}

/*
 * Function: TCPPacketTypeToString
 * Description: Returns a string corresponding to the enumerated TCP packet type.
 * Author: Created by shouse, 4.14.01
 */
CHAR * TCPPacketTypeToString (TCP_PACKET_TYPE ePktType) {

    switch (ePktType) {
    case SYN:
        return "SYN";
    case DATA:
        return "DATA";
    case FIN:
        return "FIN";
    case RST:
        return "RST";
    default:
        return "Unknown";
    }
}

/*
 * Function: Map
 * Description: This IS the NLB hashing function.
 * Author: Created by shouse, 4.14.01
 */
ULONG Map (ULONG v1, ULONG v2) {
    ULONG y = v1;
    ULONG z = v2;
    ULONG sum = 0;

    const ULONG a = 0x67; //key [0];
    const ULONG b = 0xdf; //key [1];
    const ULONG c = 0x40; //key [2];
    const ULONG d = 0xd3; //key [3];

    const ULONG delta = 0x9E3779B9;

    sum += delta;
    y += (z << 4) + a ^ z + sum ^ (z >> 5) + b;
    z += (y << 4) + c ^ y + sum ^ (y >> 5) + d;

    sum += delta;
    y += (z << 4) + a ^ z + sum ^ (z >> 5) + b;
    z += (y << 4) + c ^ y + sum ^ (y >> 5) + d;

    sum += delta;
    y += (z << 4) + a ^ z + sum ^ (z >> 5) + b;
    z += (y << 4) + c ^ y + sum ^ (y >> 5) + d;

    sum += delta;
    y += (z << 4) + a ^ z + sum ^ (z >> 5) + b;
    z += (y << 4) + c ^ y + sum ^ (y >> 5) + d;

    sum += delta;
    y += (z << 4) + a ^ z + sum ^ (z >> 5) + b;
    z += (y << 4) + c ^ y + sum ^ (y >> 5) + d;

    sum += delta;
    y += (z << 4) + a ^ z + sum ^ (z >> 5) + b;
    z += (y << 4) + c ^ y + sum ^ (y >> 5) + d;

    sum += delta;
    y += (z << 4) + a ^ z + sum ^ (z >> 5) + b;
    z += (y << 4) + c ^ y + sum ^ (y >> 5) + d;

    sum += delta;
    y += (z << 4) + a ^ z + sum ^ (z >> 5) + b;
    z += (y << 4) + c ^ y + sum ^ (y >> 5) + d;

    return y ^ z;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\exe\application.cpp ===
#include <afxext.h>
#include <netcfgx.h>
#include <devguid.h>
#include <cfg.h>
#include "resource.h"
#include "Application.h"
#include "Document.h"
#include "MainForm.h"
#include "LeftView.h"
#include "AboutDialog.h"
#include "disclaimer.h"

#include "MUsingCom.h"
#include "resourcestring.h"

Application theApplication;

MUsingCom usingCom;

BOOL CanRunNLB(void);

BEGIN_MESSAGE_MAP( Application, CWinApp )
    ON_COMMAND( ID_APP_ABOUT, OnAppAbout )
END_MESSAGE_MAP()

#define EVENT_NAME _T("NLB Cluster Manager")

#define szNLBMGRREG_BASE_KEY L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\NLB"
#define szNLBMGRREG_DISABLE_DISCLAIMER L"DisableNlbMgrDisclaimer"

HKEY
NlbMgrRegCreateKey(
    LPCWSTR szSubKey // Optional
    );

UINT
NlbMgrRegReadUINT(
    HKEY hKey,
    LPCWSTR szName,
    UINT Default
    );

VOID
NlbMgrRegWriteUINT(
    HKEY hKey,
    LPCWSTR szName,
    UINT Value
    );

BOOL NoAdminNics(void);

BOOL
Application::InitInstance()
{
    /*
     The following event is created to detect the existence of an instance of the NLB Manager. 
     If an instance exists, GetLastError will return ERROR_ALREADY_EXISTS. Then, we make that
     instance to be the current window
     Note : We do NOT save the handle returned by the CreateEvent call and hence do NOT close 
            it when we quit.  
    */
    if (CreateEvent(NULL, FALSE, TRUE, EVENT_NAME) == NULL) 
    {
        return FALSE;
    }
    if (GetLastError() == ERROR_ALREADY_EXISTS) 
    {
        CString str;
        HWND hWnd;
        if (str.LoadString(IDR_MAINFRAME) == 0)
            return FALSE;
        // Find the existing NLB Manager window
        if (!(hWnd = FindWindow(NULL, (LPCTSTR)str)))
            return FALSE;
        // If the existing NLB Manager window is Minimized, call ShowWindow to restore it, else
        // call SetForegroundWindow to bring it to the foreground
        if (IsIconic(hWnd)) 
            ShowWindow(hWnd, SW_RESTORE);
        else
            SetForegroundWindow(hWnd);
        return FALSE;
    }
    CSingleDocTemplate* pSingleDocumentTemplate =
        new CSingleDocTemplate( IDR_MAINFRAME,
                                RUNTIME_CLASS( Document ),
                                RUNTIME_CLASS( MainForm ),
                                RUNTIME_CLASS( LeftView) );

    AddDocTemplate( pSingleDocumentTemplate );

    CCommandLineInfo commandLineInfo;

    if( !ProcessShellCommand( commandLineInfo ) )
        return FALSE;

	if (!CanRunNLB())
	{
		return FALSE;
	}
	
    return TRUE;
}

void
Application::OnAppAbout()
{
    AboutDialog aboutDlg;
    aboutDlg.DoModal();
}


void
ShowDisclaimer(void)
/*
    We check the registry if we need to put up the disclaimer dialog.
    If we do we put it up and then afterwards check if the "don't show
    me" checkbox is checked. If it has, we save this fact in the registry.
*/
{


	HKEY hKey;
	hKey = NlbMgrRegCreateKey(NULL);
	if (hKey != NULL)
	{
		UINT uDisableDisclaimer;
		uDisableDisclaimer = NlbMgrRegReadUINT(
                                hKey,
                                szNLBMGRREG_DISABLE_DISCLAIMER,
                                0 // default value.
                                );

		if (!uDisableDisclaimer)
		{
			 DisclaimerDialog Dlg;
   			 Dlg.DoModal();
             if (Dlg.dontRemindMe)
             {
                NlbMgrRegWriteUINT(
                    hKey,
                    szNLBMGRREG_DISABLE_DISCLAIMER,
                    1
                    );
             }
		}
		RegCloseKey(hKey);
		hKey = NULL;
    }
}


BOOL CanRunNLB(void)
/*
	Checks if NLB can run on the current machine. The main check is to make sure that there is atleast one active NIC without NLB bound.
*/
{
    if (NoAdminNics())
    {

        ::MessageBox(
             NULL,
             GETRESOURCEIDSTRING( IDS_CANTRUN_NONICS_TEXT), // Contents
             GETRESOURCEIDSTRING( IDS_CANTRUN_NONICS_CAPTION), // caption
             MB_ICONSTOP | MB_OK );
    }
    else
    {
        ::ShowDisclaimer();
    }

	return TRUE;
}


UINT
NlbMgrRegReadUINT(
    HKEY hKey,
    LPCWSTR szName,
    UINT Default
    )
{
    LONG lRet;
    DWORD dwType;
    DWORD dwData;
    DWORD dwRet;

    dwData = sizeof(dwRet);
    lRet =  RegQueryValueEx(
              hKey,         // handle to key to query
              szName,
              NULL,         // reserved
              &dwType,   // address of buffer for value type
              (LPBYTE) &dwRet, // address of data buffer
              &dwData  // address of data buffer size
              );
    if (    lRet != ERROR_SUCCESS
        ||  dwType != REG_DWORD
        ||  dwData != sizeof(dwData))
    {
        dwRet = (DWORD) Default;
    }

    return (UINT) dwRet;
}


VOID
NlbMgrRegWriteUINT(
    HKEY hKey,
    LPCWSTR szName,
    UINT Value
    )
{
    LONG lRet;

    lRet = RegSetValueEx(
            hKey,           // handle to key to set value for
            szName,
            0,              // reserved
            REG_DWORD,     // flag for value type
            (BYTE*) &Value,// address of value data
            sizeof(Value)  // size of value data
            );

    if (lRet !=ERROR_SUCCESS)
    {
        // trace error
    }
}

HKEY
NlbMgrRegCreateKey(
    LPCWSTR szSubKey
    )
{
    WCHAR szKey[256];
    DWORD dwOptions = 0;
    HKEY hKey = NULL;

    wcscpy(szKey,  szNLBMGRREG_BASE_KEY);

    if (szSubKey != NULL)
    {
        if (wcslen(szSubKey)>128)
        {
            // too long.
            goto end;
        }
        wcscat(szKey, L"\\");
        wcscat(szKey, szSubKey);
    }

    DWORD dwDisposition;

    LONG lRet;
    lRet = RegCreateKeyEx(
            HKEY_LOCAL_MACHINE, // handle to an open key
            szKey,                // address of subkey name
            0,                  // reserved
            L"class",           // address of class string
            0,          //      special options flag
            KEY_ALL_ACCESS,     // desired security access
            NULL,               // address of key security structure
            &hKey,              // address of buffer for opened handle
            &dwDisposition   // address of disposition value buffer
            );
    if (lRet != ERROR_SUCCESS)
    {
        hKey = NULL;
    }

end:

    return hKey;
}


//
// This class manages NetCfg interfaces
//
class AppMyNetCfg
{

public:

    AppMyNetCfg(VOID)
    {
        m_pINetCfg  = NULL;
        m_pLock     = NULL;
    }

    ~AppMyNetCfg()
    {
        ASSERT(m_pINetCfg==NULL);
        ASSERT(m_pLock==NULL);
    }

    WBEMSTATUS
    Initialize(
        BOOL fWriteLock
        );

    VOID
    Deinitialize(
        VOID
        );


    WBEMSTATUS
    GetNlbCompatibleNics(
        OUT LPWSTR **ppszNics,
        OUT UINT   *pNumNics,
        OUT UINT   *pNumBoundToNlb // OPTIONAL
        );

    WBEMSTATUS
    GetBindingIF(
        IN  LPCWSTR                     szComponent,
        OUT INetCfgComponentBindings   **ppIBinding
        );

private:

    INetCfg     *m_pINetCfg;
    INetCfgLock *m_pLock;

}; // Class AppMyNetCfg


WBEMSTATUS
AppMyNetCfg::Initialize(
    BOOL fWriteLock
    )
{
    HRESULT     hr;
    INetCfg     *pnc = NULL;
    INetCfgLock *pncl = NULL;
    WBEMSTATUS  Status = WBEM_E_CRITICAL_ERROR;
    BOOL        fLocked = FALSE;
    BOOL        fInitialized=FALSE;
    
    if (m_pINetCfg != NULL || m_pLock != NULL)
    {
        ASSERT(FALSE);
        goto end;
    }

    hr = CoCreateInstance( CLSID_CNetCfg, 
                           NULL, 
                           CLSCTX_SERVER, 
                           IID_INetCfg, 
                           (void **) &pnc);

    if( !SUCCEEDED( hr ) )
    {
        // failure to create instance.
        //TRACE_CRIT("ERROR: could not get interface to Net Config");
        goto end;
    }

    //
    // If require, get the write lock
    //
    if (fWriteLock)
    {
        WCHAR *szLockedBy = NULL;
        hr = pnc->QueryInterface( IID_INetCfgLock, ( void **) &pncl );
        if( !SUCCEEDED( hr ) )
        {
            //TRACE_CRIT("ERROR: could not get interface to NetCfg Lock");
            goto end;
        }

        hr = pncl->AcquireWriteLock( 1, // One Second
                                     L"NLBManager",
                                     &szLockedBy);
        if( hr != S_OK )
        {
            //TRACE_CRIT("Could not get write lock. Lock held by %ws",
            // (szLockedBy!=NULL) ? szLockedBy : L"<null>");
            goto end;
            
        }
    }

    // Initializes network configuration by loading into 
    // memory all basic networking information
    //
    hr = pnc->Initialize( NULL );
    if( !SUCCEEDED( hr ) )
    {
        // failure to Initialize
        //TRACE_CRIT("INetCfg::Initialize failure ");
        goto end;
    }

    Status = WBEM_NO_ERROR; 
    
end:

    if (FAILED(Status))
    {
        if (pncl!=NULL)
        {
            if (fLocked)
            {
                pncl->ReleaseWriteLock();
            }
            pncl->Release();
            pncl=NULL;
        }
        if( pnc != NULL)
        {
            if (fInitialized)
            {
                pnc->Uninitialize();
            }
            pnc->Release();
            pnc= NULL;
        }
    }
    else
    {
        m_pINetCfg  = pnc;
        m_pLock     = pncl;
    }

    return Status;
}


VOID
AppMyNetCfg::Deinitialize(
    VOID
    )
{
    if (m_pLock!=NULL)
    {
        m_pLock->ReleaseWriteLock();
        m_pLock->Release();
        m_pLock=NULL;
    }
    if( m_pINetCfg != NULL)
    {
        m_pINetCfg->Uninitialize();
        m_pINetCfg->Release();
        m_pINetCfg= NULL;
    }
}




LPWSTR *
CfgUtilsAllocateStringArray(
    UINT NumStrings,
    UINT MaxStringLen      //  excluding ending NULL
    )
/*
    Allocate a single chunk of memory using the new LPWSTR[] operator.
    The first NumStrings LPWSTR values of this operator contain an array
    of pointers to WCHAR strings. Each of these strings
    is of size (MaxStringLen+1) WCHARS.
    The rest of the memory contains the strings themselve.

    Return NULL if NumStrings==0 or on allocation failure.

    Each of the strings are initialized to be empty strings (first char is 0).
*/
{
    LPWSTR *pStrings = NULL;
    UINT   TotalSize = 0;

    if (NumStrings == 0)
    {
        goto end;
    }

    //
    // Note - even if MaxStringLen is 0 we will allocate space for NumStrings
    // pointers and NumStrings empty (first char is 0) strings.
    //

    //
    // Calculate space for the array of pointers to strings...
    //
    TotalSize = NumStrings*sizeof(LPWSTR);

    //
    // Calculate space for the strings themselves...
    // Remember to add +1 for each ending 0 character.
    //
    TotalSize +=  NumStrings*(MaxStringLen+1)*sizeof(WCHAR);

    //
    // Allocate space for *both* the array of pointers and the strings
    // in one shot -- we're doing a new of type LPWSTR[] for the whole
    // lot, so need to specify the size in units of LPWSTR (with an
    // additional +1 in case there's roundoff.
    //
    pStrings = new LPWSTR[(TotalSize/sizeof(LPWSTR))+1];
    if (pStrings == NULL)
    {
        goto end;
    }

    //
    // Make sz point to the start of the place where we'll be placing
    // the string data.
    //
    LPWSTR sz = (LPWSTR) (pStrings+NumStrings);
    for (UINT u=0; u<NumStrings; u++)
    {
        *sz=NULL;
        pStrings[u] = sz;
        sz+=(MaxStringLen+1); // +1 for ending NULL
    }

end:

    return pStrings;

}



WBEMSTATUS
AppMyNetCfg::GetNlbCompatibleNics(
        OUT LPWSTR **ppszNics,
        OUT UINT   *pNumNics,
        OUT UINT   *pNumBoundToNlb // OPTIONAL
        )
/*
    Returns an array of pointers to string-version of GUIDS
    that represent the set of alive and healthy NICS that are
    suitable for NLB to bind to -- basically alive ethernet NICs.

    Delete ppNics using the delete WCHAR[] operator. Do not
    delete the individual strings.
*/
{
    #define MY_GUID_LENGTH  38

    WBEMSTATUS  Status = WBEM_E_CRITICAL_ERROR;
    HRESULT hr;
    IEnumNetCfgComponent* pencc = NULL;
    INetCfgComponent *pncc = NULL;
    ULONG                 countToFetch = 1;
    ULONG                 countFetched;
    DWORD                 characteristics;
    UINT                  NumNics = 0;
    LPWSTR               *pszNics = NULL;
    INetCfgComponentBindings    *pINlbBinding=NULL;
    UINT                  NumNlbBoundNics = 0;

    typedef struct _MYNICNODE MYNICNODE;

    typedef struct _MYNICNODE
    {
        LPWSTR szNicGuid;
        MYNICNODE *pNext;
    } MYNICNODE;

    MYNICNODE *pNicNodeList = NULL;
    MYNICNODE *pNicNode     = NULL;


    *ppszNics = NULL;
    *pNumNics = 0;

    if (pNumBoundToNlb != NULL)
    {
        *pNumBoundToNlb  = 0;
    }

    if (m_pINetCfg == NULL)
    {
        //
        // This means we're not initialized
        //
        ASSERT(FALSE);
        goto end;
    }

    hr = m_pINetCfg->EnumComponents( &GUID_DEVCLASS_NET, &pencc );
    if( !SUCCEEDED( hr ) )
    {
        // failure to Enumerate net components
        //TRACE_CRIT("%!FUNC! Could not enum netcfg adapters");
        pencc = NULL;
        goto end;
    }


    //
    // Check if nlb is bound to the nlb component.
    //

    //
    // If we need to count of NLB-bound nics, get instance of the nlb component
    //
    if (pNumBoundToNlb != NULL)
    {
        Status = GetBindingIF(L"ms_wlbs", &pINlbBinding);
        if (FAILED(Status))
        {
            //TRACE_CRIT("%!FUNC! WARNING: NLB doesn't appear to be installed on this machine");
            pINlbBinding = NULL;
        }
    }

    while( ( hr = pencc->Next( countToFetch, &pncc, &countFetched ) )== S_OK )
    {
        LPWSTR                szName = NULL; 

        hr = pncc->GetBindName( &szName );
        if (!SUCCEEDED(hr))
        {
            //TRACE_CRIT("%!FUNC! WARNING: couldn't get bind name for 0x%p, ignoring",
            //        (PVOID) pncc);
            continue;
        }

        do // while FALSE -- just to allow breaking out
        {


            UINT Len = wcslen(szName);
            if (Len != MY_GUID_LENGTH)
            {
                //TRACE_CRIT("%!FUNC! WARNING: GUID %ws has unexpected length %ul",
                //        szName, Len);
                break;
            }
    
            DWORD characteristics = 0;
    
            hr = pncc->GetCharacteristics( &characteristics );
            if(!SUCCEEDED(hr))
            {
                //TRACE_CRIT("%!FUNC! WARNING: couldn't get characteristics for %ws, ignoring",
                 //       szName);
                break;
            }
    
            if(characteristics & NCF_PHYSICAL)
            {
                ULONG devstat = 0;
    
                // This is a physical network card.
                // we are only interested in such devices
    
                // check if the nic is enabled, we are only
                // interested in enabled nics.
                //
                hr = pncc->GetDeviceStatus( &devstat );
                if(!SUCCEEDED(hr))
                {
                    //TRACE_CRIT(
                    //    "%!FUNC! WARNING: couldn't get dev status for %ws, ignoring",
                     //   szName
                     //   );
                    break;
                }
    
                // if any of the nics has any of the problem codes
                // then it cannot be used.
    
                if( devstat != CM_PROB_NOT_CONFIGURED
                    &&
                    devstat != CM_PROB_FAILED_START
                    &&
                    devstat != CM_PROB_NORMAL_CONFLICT
                    &&
                    devstat != CM_PROB_NEED_RESTART
                    &&
                    devstat != CM_PROB_REINSTALL
                    &&
                    devstat != CM_PROB_WILL_BE_REMOVED
                    &&
                    devstat != CM_PROB_DISABLED
                    &&
                    devstat != CM_PROB_FAILED_INSTALL
                    &&
                    devstat != CM_PROB_FAILED_ADD
                    )
                {
                    //
                    // No problem with this nic and also 
                    // physical device 
                    // thus we want it.
                    //

                    if (pINlbBinding != NULL)
                    {
                        BOOL fBound = FALSE;

                        hr = pINlbBinding->IsBoundTo(pncc);

                        if( !SUCCEEDED( hr ) )
                        {
                            //TRACE_CRIT("IsBoundTo method failed for Nic %ws", szName);
                            goto end;
                        }
                    
                        if( hr == S_OK )
                        {
                            //TRACE_VERB("BOUND: %ws\n", szName);
                            NumNlbBoundNics++;
                            fBound = TRUE;
                        }
                        else if (hr == S_FALSE )
                        {
                            //TRACE_VERB("NOT BOUND: %ws\n", szName);
                            fBound = FALSE;
                        }
                    }


                    // We allocate a little node to keep this string
                    // temporarily and add it to our list of nodes.
                    //
                    pNicNode = new MYNICNODE;
                    if (pNicNode  == NULL)
                    {
                        Status = WBEM_E_OUT_OF_MEMORY;
                        goto end;
                    }
                    ZeroMemory(pNicNode, sizeof(*pNicNode));
                    pNicNode->szNicGuid = szName;
                    szName = NULL; // so we don't delete inside the lopp.
                    pNicNode->pNext = pNicNodeList;
                    pNicNodeList = pNicNode;
                    NumNics++;
                }
                else
                {
                    // There is a problem...
                    //TRACE_CRIT(
                        // "%!FUNC! WARNING: Skipping %ws because DeviceStatus=0x%08lx",
                        // szName, devstat
                        // );
                    break;
                }
            }
            else
            {
                //TRACE_VERB("%!FUNC! Ignoring non-physical device %ws", szName);
            }

        } while (FALSE);

        if (szName != NULL)
        {
            CoTaskMemFree( szName );
        }
        pncc->Release();
        pncc=NULL;
    }

    if (pINlbBinding!=NULL)
    {
        pINlbBinding->Release();
        pINlbBinding = NULL;
    }

    if (NumNics==0)
    {
        Status = WBEM_NO_ERROR;
        goto end;
    }
    
    //
    // Now let's  allocate space for all the nic strings and:w
    // copy them over..
    //
    #define MY_GUID_LENGTH  38
    pszNics =  CfgUtilsAllocateStringArray(NumNics, MY_GUID_LENGTH);
    if (pszNics == NULL)
    {
        Status = WBEM_E_OUT_OF_MEMORY;
        goto end;
    }

    pNicNode= pNicNodeList;
    for (UINT u=0; u<NumNics; u++, pNicNode=pNicNode->pNext)
    {
        ASSERT(pNicNode != NULL); // because we just counted NumNics of em.
        UINT Len = wcslen(pNicNode->szNicGuid);
        if (Len != MY_GUID_LENGTH)
        {
            //
            // We should never get here beause we checked the length earlier.
            //
            //TRACE_CRIT("%!FUNC! ERROR: GUID %ws has unexpected length %ul",
            //            pNicNode->szNicGuid, Len);
            ASSERT(FALSE);
            Status = WBEM_E_CRITICAL_ERROR;
            goto end;
        }
        CopyMemory(
            pszNics[u],
            pNicNode->szNicGuid,
            (MY_GUID_LENGTH+1)*sizeof(WCHAR));
        ASSERT(pszNics[u][MY_GUID_LENGTH]==0);
    }

    Status = WBEM_NO_ERROR;


end:

    //
    // Now release the temporarly allocated memory.
    //
    pNicNode= pNicNodeList;
    while (pNicNode!=NULL)
    {
        MYNICNODE *pTmp = pNicNode->pNext;
        CoTaskMemFree(pNicNode->szNicGuid);
        pNicNode->szNicGuid = NULL;
        delete pNicNode;
        pNicNode = pTmp;
    }

    if (FAILED(Status))
    {
        // TRACE_CRIT("%!FUNC! fails with status 0x%08lx", (UINT) Status);
        NumNics = 0;
        if (pszNics!=NULL)
        {
            delete pszNics;
            pszNics = NULL;
        }
    }
    else
    {
        if (pNumBoundToNlb != NULL)
        {
            *pNumBoundToNlb = NumNlbBoundNics;
        }
        *ppszNics = pszNics;
        *pNumNics = NumNics;
    }

    if (pencc != NULL)
    {
        pencc->Release();
    }

    return Status;
}


WBEMSTATUS
AppMyNetCfg::GetBindingIF(
        IN  LPCWSTR                     szComponent,
        OUT INetCfgComponentBindings   **ppIBinding
        )
{
    WBEMSTATUS                  Status = WBEM_E_CRITICAL_ERROR;
    INetCfgComponent            *pncc = NULL;
    INetCfgComponentBindings    *pnccb = NULL;
    HRESULT                     hr;


    if (m_pINetCfg == NULL)
    {
        //
        // This means we're not initialized
        //
        ASSERT(FALSE);
        goto end;
    }


    hr = m_pINetCfg->FindComponent(szComponent,  &pncc);

    if (FAILED(hr))
    {
        // TRACE_CRIT("Error checking if component %ws does not exist\n", szComponent);
        pncc = NULL;
        goto end;
    }
    else if (hr == S_FALSE)
    {
        Status = WBEM_E_NOT_FOUND;
        // TRACE_CRIT("Component %ws does not exist\n", szComponent);
        goto end;
    }
   
   
    hr = pncc->QueryInterface( IID_INetCfgComponentBindings, (void **) &pnccb );
    if( !SUCCEEDED( hr ) )
    {
        // TRACE_CRIT("INetCfgComponent::QueryInterface failed ");
        pnccb = NULL;
        goto end;
    }

    Status = WBEM_NO_ERROR;

end:

    if (pncc)
    {
        pncc->Release();
        pncc=NULL;
    }

    *ppIBinding = pnccb;

    return Status;

}



WBEMSTATUS
CfgUtilsGetNlbCompatibleNics(
        OUT LPWSTR **ppszNics,
        OUT UINT   *pNumNics,
        OUT UINT   *pNumBoundToNlb // OPTIONAL
        )
{
    WBEMSTATUS Status = WBEM_NO_ERROR;
    BOOL fNetCfgInitialized = FALSE;
    AppMyNetCfg NetCfg;
    BOOL fBound = FALSE;


    //
    // Get and initialize interface to netcfg
    //
    Status = NetCfg.Initialize(FALSE); // TRUE == get write lock.
    if (FAILED(Status))
    {
        goto end;
    }
    fNetCfgInitialized = TRUE;

    //
    //
    //
    Status = NetCfg.GetNlbCompatibleNics(
                        ppszNics,
                        pNumNics,
                        pNumBoundToNlb // OPTIONAL
                        );

end:

    if (fNetCfgInitialized)
    {
        NetCfg.Deinitialize();
    }

    return Status;
}


BOOL NoAdminNics(void)
/*
    Return  TRUE IFF all NICs on this machine are bound to NLB.
*/
{
    LPWSTR *pszNics = NULL;
    OUT UINT   NumNics = 0;
    OUT UINT   NumBoundToNlb  = 0;
    WBEMSTATUS Status = WBEM_NO_ERROR;
    BOOL fNetCfgInitialized = FALSE;
    AppMyNetCfg NetCfg;
    BOOL fRet = FALSE;

    //
    // Get and initialize interface to netcfg
    //
    Status = NetCfg.Initialize(FALSE); // TRUE == get write lock.
    if (FAILED(Status))
    {
        goto end;
    }
    fNetCfgInitialized = TRUE;

    //
    // Get the total list of enabled nics and the list of nics
    // bound to NLB. If there are non-zero enabled nics and all are
    // bound to NLB, we return TRUE.
    //
    Status = NetCfg.GetNlbCompatibleNics(
                        &pszNics,
                        &NumNics,
                        &NumBoundToNlb
                        );

    if (!FAILED(Status))
    {
        fRet =  NumNics && (NumNics == NumBoundToNlb);
        if (NumNics)
        {
            delete pszNics; 
            pszNics = NULL;
        }
    }

end:

    if (fNetCfgInitialized)
    {
        NetCfg.Deinitialize();
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\exe\clusterconnectindirectpage.cpp ===
#include "ClusterConnectIndirectPage.h"
#include "LeftView.h"

#include "CommonUtils.h"
#include "CommonNLB.h"
#include "MWmiError.h"
#include "IpSubnetMaskControl.h"
#include "MIPAddress.h"
#include "ResourceString.h"

BEGIN_MESSAGE_MAP( ClusterConnectIndirectPage, CPropertyPage )

    ON_BN_CLICKED(IDC_ADD_MACHINE, OnButtonAdd)
    ON_BN_CLICKED(IDC_DEL_MACHINE, OnButtonDel)
    ON_WM_HELPINFO()        
    ON_WM_CONTEXTMENU()        

END_MESSAGE_MAP()

ClusterConnectIndirectPage::ClusterConnectIndirectPage( ClusterData* clusterData,
                                                        CWnd*        parent )
        :
        CPropertyPage( IDD ),
        DataSinkI(),
        m_clusterData( clusterData ),
        myParent( parent ),
        dataStore(L" ")
{}

void
ClusterConnectIndirectPage::DoDataExchange( CDataExchange* pDX )
{
    CPropertyPage::DoDataExchange( pDX );

    DDX_Control( pDX, IDC_CLUSTER_IP, clusterIP);
    DDX_Control( pDX, IDC_MACHINE, machineIP );
    DDX_Control( pDX, IDC_MACHINE_IP_LIST, machineIPList );
    DDX_Control( pDX, IDC_ADD_MACHINE, addButton );
    DDX_Control( pDX, IDC_DEL_MACHINE, removeButton );

    DDX_Control( pDX, IDC_CLUSTER_CONNECTION_STATUS, connectionStatus );
}


void
ClusterConnectIndirectPage::OnOK()
{
    CPropertyPage::OnOK();
}


BOOL
ClusterConnectIndirectPage::OnKillActive()
{
    // clear the old status if any.
    dataStore = L" ";

    // get cluster ip.
    //
    _bstr_t clusterIPAddress = 
        CommonUtils::getCIPAddressCtrlString( clusterIP );

    // validate this ip.
    bool isIPValid = MIPAddress::checkIfValid( clusterIPAddress );
    if( isIPValid == false )
    {
        // invalid ip.
        dataSink( GETRESOURCEIDSTRING( IDS_WARNING_IP_INVALID ) + clusterIPAddress );

        CPropertyPage::OnCancel();
        return 0;
    }
        

    // check if this cluster already exists in view.

    if( myParent != 0 )
    {
        bool isClusterDuplicate = ( (LeftView * )myParent)->doesClusterExistInView( clusterIPAddress );
        if( isClusterDuplicate == true )
        {
            dataSink( clusterIPAddress + L":" + GETRESOURCEIDSTRING (IDS_CLUSTER_ALREADY ) );

            CPropertyPage::OnCancel();
            return 0;
        }
    }


    // get all the ips in the machine ip list.
    // this list should not be empty.

    if( machineIPList.GetCount() == 0 )
    {
        // machine ip list is empty
        dataSink( GETRESOURCEIDSTRING (IDS_MACHINE_LIST_EMPTY ) );

        CPropertyPage::OnCancel();
        return 0;
    }

    wchar_t ipBuf[1000];
    vector<_bstr_t> connectionIPS;

    for( int i = 0; i < machineIPList.GetCount(); ++i )
    {
        machineIPList.GetText( i, ipBuf );
        connectionIPS.push_back( ipBuf );
    }

    try
    {

#if 1
        CommonNLB::connectToClusterIndirect( clusterIPAddress,
                                             connectionIPS,
                                             m_clusterData,
                                             this );
#else
    vector<ClusterData> clusterDataStore;
    bool clusterPropertiesMatched;

    CommonNLB::connectToClusterIndirectNew( clusterIPAddress,
                                            connectionIPS,
                                            &clusterDataStore,
                                            clusterPropertiesMatched,                                            
                                            this );

    *(m_clusterData) = clusterDataStore[0];

#endif
    }
    catch( _com_error e )
    {
        _bstr_t errText;
        GetErrorCodeText(  e.Error(), errText );
        
        dataSink( errText );

        CPropertyPage::OnCancel();
        return 0;
    }

    return CPropertyPage::OnKillActive();
}

BOOL
ClusterConnectIndirectPage::OnInitDialog()
{
    CPropertyPage::OnInitDialog();

    // fill in cluster ip but only if not null.
    //
    if( m_clusterData->cp.cIP != _bstr_t( L"0.0.0.0" ) )
    {
        CommonUtils::fillCIPAddressCtrlString( clusterIP,
                                               m_clusterData->cp.cIP );

        // fill in machine ip list.
        // connect to each host.
        map<_bstr_t, HostData >::iterator top;

        for( top = m_clusterData->hosts.begin();
             top != m_clusterData->hosts.end();
             ++top )
        { 
            machineIPList.InsertString( -1, (*top).second.connectionIP );
        }

        // select the first ip in machine IP list.
        machineIPList.SetCurSel( 0 );        
    }
    
    return TRUE;
}

void
ClusterConnectIndirectPage::dataSink( _bstr_t data )
{
    dataStore += data;
    dataStore += L"\r\n";

    connectionStatus.SetWindowText( dataStore );
    UpdateWindow();
}

void ClusterConnectIndirectPage::OnButtonAdd() 
{
    // get and check if machine ip is valid.
    _bstr_t machineIPAddress =
        CommonUtils::getCIPAddressCtrlString( machineIP );

    bool isIPValid = MIPAddress::checkIfValid( machineIPAddress );
    if( isIPValid == false )
    {
        // invalid ip.
        dataSink( GETRESOURCEIDSTRING( IDS_WARNING_IP_INVALID ) + machineIPAddress );
        return;
    }

    // check if machine ip to add already exists in list.
    // 
    wchar_t ipBuf[1000];
    for( int i = 0; i < machineIPList.GetCount(); ++i )
    {
        machineIPList.GetText( i, ipBuf );
        if( machineIPAddress == _bstr_t( ipBuf ) )
        {
            // duplicate, cannot add.
            dataSink( GETRESOURCEIDSTRING( IDS_MACHINE_ALREADY ) + L":" + machineIPAddress );

            // select this duplicate string in list.
            machineIPList.SetCurSel( i );

            return;
        }
    }


    // add it to list.
    int index = machineIPList.InsertString( -1, machineIPAddress );

    // select this string.
    machineIPList.SetCurSel( index );

}

void ClusterConnectIndirectPage::OnButtonDel() 
{
    // delete the ip selected from the list.
    int index = machineIPList.GetCurSel();
    if( index != LB_ERR )
    {
        machineIPList.DeleteString( index );
    }
}

BOOL
ClusterConnectIndirectPage::OnHelpInfo (HELPINFO* helpInfo )
{
    if( helpInfo->iContextType == HELPINFO_WINDOW )
    {
        ::WinHelp( static_cast<HWND> ( helpInfo->hItemHandle ), 
                   CVY_CTXT_HELP_FILE, 
                   HELP_WM_HELP, 
                   (ULONG_PTR ) g_aHelpIDs_IDD_CLUSTER_CONNECT_INDIRECT_PAGE);
    }

    return TRUE;
}

void
ClusterConnectIndirectPage::OnContextMenu( CWnd* pWnd, CPoint point )
{
    ::WinHelp( m_hWnd, 
               CVY_CTXT_HELP_FILE, 
               HELP_CONTEXTMENU,   
               (ULONG_PTR ) g_aHelpIDs_IDD_CLUSTER_CONNECT_INDIRECT_PAGE);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\exe\clusterconnectpage.h ===
#ifndef CLUSTERCONNECTPAGE_H
#define CLUSTERCONNECTPAGE_H

#include "stdafx.h"

#include "resource.h"
#include "DataSinkI.h"
#include "Document.h"

#include "MNLBUIData.h"

class ClusterConnectPage :  public CPropertyPage, public DataSinkI
{
public:
    enum
    {
        IDD = IDD_CLUSTER_CONNECT_PAGE,
    };

    ClusterConnectPage( ClusterData* clusterData,
                        CWnd*        parent = NULL);

    // member controls

    CIPAddressCtrl clusterIP;

    CIPAddressCtrl clusterMemberName;

    CEdit connectionStatus;

    // overrides of CDialog
    virtual void OnOK();

    virtual BOOL OnKillActive();

    virtual BOOL OnInitDialog();

    virtual void DoDataExchange( CDataExchange* pDX );

    afx_msg BOOL OnHelpInfo (HELPINFO* helpInfo );

    afx_msg void OnContextMenu( CWnd* pWnd, CPoint point );


    // override of DataSinkI
    virtual void dataSink( _bstr_t data );
    

protected:
    ClusterData* m_clusterData;

    CWnd* myParent;

    _bstr_t dataStore;

    DECLARE_MESSAGE_MAP()
};

static DWORD g_aHelpIDs_IDD_CLUSTER_CONNECT_PAGE [] = {
    IDC_TEXT_CLUSTER_IP,     IDC_TEXT_CLUSTER_IP, 
    IDC_CLUSTER_IP,          IDC_CLUSTER_IP, 
    IDC_TEXT_CLUSTER_MEMBER, IDC_TEXT_CLUSTER_MEMBER,
    IDC_CLUSTER_MEMBER,      IDC_CLUSTER_MEMBER,
    IDC_TEXT_CONNECTION_STATUS, IDC_TEXT_CONNECTION_STATUS,
    IDC_CLUSTER_CONNECTION_STATUS, IDC_CLUSTER_CONNECTION_STATUS,
    0, 0
};
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\exe\clusterconnectpage.cpp ===
#include "ClusterConnectPage.h"
#include "LeftView.h"

#include "CommonUtils.h"
#include "CommonNLB.h"
#include "MWmiError.h"
#include "IpSubnetMaskControl.h"
#include "MIPAddress.h"
#include "ResourceString.h"

BEGIN_MESSAGE_MAP( ClusterConnectPage, CPropertyPage )
    ON_WM_CONTEXTMENU()        
    ON_WM_HELPINFO()        
END_MESSAGE_MAP()

ClusterConnectPage::ClusterConnectPage( ClusterData* clusterData,
                                        CWnd*        parent )
        :
        CPropertyPage( IDD ),
        DataSinkI(),
        m_clusterData( clusterData ),
        myParent( parent ),
        dataStore(L" ")
{}

void
ClusterConnectPage::DoDataExchange( CDataExchange* pDX )
{
    CPropertyPage::DoDataExchange( pDX );

    DDX_Control( pDX, IDC_CLUSTER_IP, clusterIP);
    DDX_Control( pDX, IDC_CLUSTER_MEMBER, clusterMemberName );
    DDX_Control( pDX, IDC_CLUSTER_CONNECTION_STATUS, connectionStatus );
}


void
ClusterConnectPage::OnOK()
{
    CPropertyPage::OnOK();
}


BOOL
ClusterConnectPage::OnKillActive()
{
    // clear the old status if any.
    dataStore = L" ";

    // get cluster ip.
    //
    _bstr_t clusterIPAddress = 
        CommonUtils::getCIPAddressCtrlString( clusterIP );

    // validate this ip.
    bool isIPValid = MIPAddress::checkIfValid( clusterIPAddress );
    if( isIPValid == false )
    {
        // invalid ip.
        dataSink( GETRESOURCEIDSTRING( IDS_WARNING_IP_INVALID ) + clusterIPAddress );

        CPropertyPage::OnCancel();
        return 0;
    }
        

    // get member of this cluster
    //
    _bstr_t clusterMember = 
        CommonUtils::getCIPAddressCtrlString( clusterMemberName );

    // validate this ip.
    isIPValid = MIPAddress::checkIfValid( clusterMember );
    if( isIPValid == false )
    {
        // invalid ip.
        dataSink( GETRESOURCEIDSTRING( IDS_WARNING_IP_INVALID ) + clusterMember );

        CPropertyPage::OnCancel();
        return 0;
    }
    

    // the member ip should not be the cluster ip.
    if( clusterMember == clusterIPAddress )
    {
        // cluster ip and member are same.
        // This is not allowed.
        // invalid ip.
        dataSink( GETRESOURCEIDSTRING( IDS_WARNING_CL_CONN_SAME ) );

        CPropertyPage::OnCancel();
        return 0;
    }

    // check if this cluster already exists in view, but ensure that pointer is valid.

    if( myParent != 0 )
    {
        bool isClusterDuplicate = ( (LeftView * )myParent)->doesClusterExistInView( clusterIPAddress );
        if( isClusterDuplicate == true )
        {
            dataSink( clusterIPAddress + L":" + GETRESOURCEIDSTRING (IDS_CLUSTER_ALREADY ) );

            CPropertyPage::OnCancel();
            return 0;
        }
    }

    try
    {
        CommonNLB::connectToClusterDirect( clusterIPAddress,
                                           clusterMember,
                                           m_clusterData,
                                           this
                                           );
    }
    catch( _com_error e )
    {
        _bstr_t errText;
        GetErrorCodeText(  e.Error(), errText );
        
        dataSink( errText );

        CPropertyPage::OnCancel();
        return 0;
    }

    return CPropertyPage::OnKillActive();
}

BOOL
ClusterConnectPage::OnInitDialog()
{
    /* Limit the zeroth field of the dedicated IP address between 1 and 223. */

    CPropertyPage::OnInitDialog();

    // fill in cluster ip but only if not null.
    //
    if( m_clusterData->cp.cIP != _bstr_t( L"0.0.0.0" ) )
    {
        CommonUtils::fillCIPAddressCtrlString( clusterIP,
                                               m_clusterData->cp.cIP );

        // fill in machine ip list.
        // connect to each host.
        map<_bstr_t, HostData >::iterator top;

        for( top = m_clusterData->hosts.begin();
             top != m_clusterData->hosts.end();
             ++top )
        { 
            // just use the first hosts connection ip.
            CommonUtils::fillCIPAddressCtrlString( clusterMemberName,
                                                   (*top).second.connectionIP );
            break;
        }

    }
    
    return TRUE;
}

void
ClusterConnectPage::dataSink( _bstr_t data )
{
    dataStore += data;
    dataStore += L"\r\n";

    connectionStatus.SetWindowText( dataStore );
    UpdateWindow();
}
    
BOOL
ClusterConnectPage::OnHelpInfo (HELPINFO* helpInfo )
{
    if( helpInfo->iContextType == HELPINFO_WINDOW )
    {
        ::WinHelp( static_cast<HWND> ( helpInfo->hItemHandle ), 
                   CVY_CTXT_HELP_FILE, 
                   HELP_WM_HELP, 
                   (ULONG_PTR ) g_aHelpIDs_IDD_CLUSTER_CONNECT_PAGE );
    }

    return TRUE;
}

void
ClusterConnectPage::OnContextMenu( CWnd* pWnd, CPoint point )
{
    ::WinHelp( m_hWnd, 
               CVY_CTXT_HELP_FILE, 
               HELP_CONTEXTMENU, 
               (ULONG_PTR ) g_aHelpIDs_IDD_CLUSTER_CONNECT_PAGE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\exe\clusterconnectindirectpage.h ===
#ifndef CLUSTERCONNECTINDIRECTPAGE_H
#define CLUSTERCONNECTINDIRECTPAGE_H

#include "stdafx.h"

#include "resource.h"
#include "DataSinkI.h"
#include "Document.h"

#include "MNLBUIData.h"

class ClusterConnectIndirectPage :  public CPropertyPage, public DataSinkI
{
public:
    enum
    {
        IDD = IDD_CLUSTER_CONNECT_INDIRECT_PAGE,
    };

    ClusterConnectIndirectPage( ClusterData* clusterData,
                                CWnd*        parent = NULL);

    // member controls

    CIPAddressCtrl clusterIP;

    CIPAddressCtrl machineIP;

    CListBox       machineIPList;
    
    CEdit connectionStatus;

    CButton       addButton;

    CButton       removeButton;

    // overrides of CDialog
    virtual void OnOK();

    virtual BOOL OnKillActive();

    virtual BOOL OnInitDialog();

    virtual void DoDataExchange( CDataExchange* pDX );

    afx_msg void OnButtonAdd();

    afx_msg void OnButtonDel();

    afx_msg BOOL OnHelpInfo (HELPINFO* helpInfo );

    afx_msg void OnContextMenu( CWnd* pWnd, CPoint point );


    // override of DataSinkI
    virtual void dataSink( _bstr_t data );
    
protected:
    ClusterData* m_clusterData;

    CWnd* myParent;

    _bstr_t dataStore;

    DECLARE_MESSAGE_MAP()
};

static DWORD g_aHelpIDs_IDD_CLUSTER_CONNECT_INDIRECT_PAGE [] = {
    IDC_TEXT_CLUSTER_IP,     IDC_TEXT_CLUSTER_IP, 
    IDC_CLUSTER_IP,          IDC_CLUSTER_IP, 
    IDC_TEXT_MACHINE,        IDC_TEXT_MACHINE,
    IDC_MACHINE,             IDC_MACHINE,
    IDC_ADD_MACHINE,         IDC_ADD_MACHINE,
    IDC_TEXT_MACHINE_IP_LIST, IDC_TEXT_MACHINE_IP_LIST,
    IDC_MACHINE_IP_LIST,     IDC_MACHINE_IP_LIST,
    IDC_DEL_MACHINE,         IDC_DEL_MACHINE,
    IDC_TEXT_CONNECTION_STATUS, IDC_TEXT_CONNECTION_STATUS,
    IDC_CLUSTER_CONNECTION_STATUS, IDC_CLUSTER_CONNECTION_STATUS,
    0, 0
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\exe\clusterpage.cpp ===
#include "ClusterPage.h"

#include "CommonUtils.h"

// History:
// --------
// 
// Revised by : mhakim
// Date       : 02-12-01
// Reason     : Added passwords and remote control for nlbmgr.



BEGIN_MESSAGE_MAP( ClusterPage, CPropertyPage )
    ON_WM_HELPINFO()        
    ON_WM_CONTEXTMENU()
END_MESSAGE_MAP()

ClusterPage::ClusterPage( ClusterProperties* pClusterProperty,
                          bool fDisablePage, UINT ID )
        :
        CPropertyPage( ID ),
        m_pClusterProperty( pClusterProperty ),
        m_fDisablePage (fDisablePage)
{
    ZeroMemory(&m_WlbsConfig, sizeof(m_WlbsConfig));

    lstrcpyn(m_WlbsConfig.cl_ip_addr, pClusterProperty->cIP, CVY_MAX_CL_IP_ADDR);
    lstrcpyn(m_WlbsConfig.cl_net_mask, pClusterProperty->cSubnetMask, CVY_MAX_NETWORK_ADDR);
    lstrcpyn(m_WlbsConfig.domain_name, pClusterProperty->cFullInternetName, CVY_MAX_DOMAIN_NAME);
    lstrcpyn(m_WlbsConfig.cl_mac_addr, pClusterProperty->cNetworkAddress, CVY_MAX_NETWORK_ADDR);

    //
    // pClusterProperty->multicastIPAddress could be NULL
    //
    if (pClusterProperty->multicastIPAddress.length() > 0)
    {
        lstrcpyn(m_WlbsConfig.szMCastIpAddress, pClusterProperty->multicastIPAddress, CVY_MAX_CL_IP_ADDR);
    }
    m_WlbsConfig.fMcastSupport = pClusterProperty->multicastSupportEnabled;
    m_WlbsConfig.fIGMPSupport = pClusterProperty->igmpSupportEnabled;
    m_WlbsConfig.fRctEnabled = pClusterProperty->remoteControlEnabled;
    m_WlbsConfig.fMcastSupport = pClusterProperty->multicastSupportEnabled;
    m_WlbsConfig.fIpToMCastIp = pClusterProperty->clusterIPToMulticastIP;
    m_WlbsConfig.fConvertMac = TRUE;  // Always generate the MAC address from IP
    
    lstrcpyn(m_WlbsConfig.szPassword, pClusterProperty->password, CVY_MAX_RCT_CODE + 1);

//    m_pCommonClusterPage = new CCommonClusterPage(AfxGetInstanceHandle(), 
//        &m_WlbsConfig, true, NULL);  // fDisablePassword = true

    m_pCommonClusterPage = new CCommonClusterPage(AfxGetInstanceHandle(), 
                                                  &m_WlbsConfig, false, NULL);  // fDisablePassword = true
}

ClusterPage::~ClusterPage()
{
    delete m_pCommonClusterPage;
}




//+----------------------------------------------------------------------------
//
// Function:  ClusterPage::OnInitDialog
//
// Description:  Process WM_INITDIALOG message
//
// Arguments: None
//
// Returns:   BOOL - 
//
// History:   fengsun Created Header    1/4/01
//
//+----------------------------------------------------------------------------
BOOL ClusterPage::OnInitDialog()
{
    CPropertyPage::OnInitDialog();

    //
    // Always set that the page has changed, so we don't have to keep track of this.
    //
    SetModified(TRUE);

    m_pCommonClusterPage->OnInitDialog(m_hWnd);

    if (m_fDisablePage)
    {
        //
        // The page is for host property.  
        // disable all cluster windows as we are at host level.
        //
        ::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_CL_IP), FALSE );
        ::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_CL_MASK), FALSE );
        ::EnableWindow(::GetDlgItem(m_hWnd, IDC_RADIO_UNICAST), FALSE );
        ::EnableWindow(::GetDlgItem(m_hWnd, IDC_RADIO_MULTICAST), FALSE );
        ::EnableWindow(::GetDlgItem(m_hWnd, IDC_CHECK_IGMP), FALSE );
        ::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_DOMAIN), FALSE );
        ::EnableWindow(::GetDlgItem(m_hWnd, IDC_CHECK_RCT), FALSE );
        ::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_PASSW), FALSE );
        ::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_PASSW2), FALSE );
    }
    else
    {
        //
        // The page is for cluster property
        //
        // enable all cluster windows as we are at cluster level.
        //
        ::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_CL_IP), TRUE );
        ::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_CL_MASK), TRUE );
        ::EnableWindow(::GetDlgItem(m_hWnd, IDC_RADIO_UNICAST), TRUE );
        ::EnableWindow(::GetDlgItem(m_hWnd, IDC_RADIO_MULTICAST), TRUE );
        ::EnableWindow(::GetDlgItem(m_hWnd, IDC_CHECK_IGMP), TRUE );
        ::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_DOMAIN), TRUE );
        ::EnableWindow(::GetDlgItem(m_hWnd, IDC_CHECK_RCT), TRUE );

        // enable remote control check box only if remote control is disabled.  
        //

        // if remote control is enabled , enable password windows
        // else disable them.

        if (m_WlbsConfig.fRctEnabled)
        {
            ::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_PASSW), TRUE );
            ::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_PASSW2), TRUE );
        }  
        else
        {
            ::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_PASSW), FALSE );
            ::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_PASSW2), FALSE );
        }
    }

    ::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_ETH), FALSE );

    return TRUE;
}



//+----------------------------------------------------------------------------
//
// Function:  ClusterPage::OnContextMenu
//
// Description:  Process WM_CONTEXTMENU message
//
// Arguments: CWnd* pWnd - 
//            CPoint point - 
//
// Returns:   Nothing
//
// History:   fengsun Created Header    1/4/01
//
//+----------------------------------------------------------------------------




//+----------------------------------------------------------------------------
//
// Function:  ClusterPage::OnCommand
//
// Description:  Process WM_COMMAND message
//
// Arguments: WPARAM wParam - 
//            LPARAM lParam - 
//
// Returns:   BOOL - 
//
// History:   fengsun Created Header    1/4/01
//
//+----------------------------------------------------------------------------
BOOL ClusterPage::OnCommand(WPARAM wParam, LPARAM lParam) 
{
    switch (LOWORD(wParam))
    {
    case IDC_EDIT_CL_IP:
        return m_pCommonClusterPage->OnEditClIp(HIWORD(wParam),LOWORD(wParam), (HWND)lParam);
        break;

    case IDC_EDIT_CL_MASK:
        return m_pCommonClusterPage->OnEditClMask(HIWORD(wParam),LOWORD(wParam), (HWND)lParam);
        break;

    case IDC_CHECK_RCT:
        return m_pCommonClusterPage->OnCheckRct(HIWORD(wParam),LOWORD(wParam), (HWND)lParam);
        break;

    case IDC_BUTTON_HELP:
        return m_pCommonClusterPage->OnButtonHelp(HIWORD(wParam),LOWORD(wParam), (HWND)lParam);
        break;

    case IDC_RADIO_UNICAST:
        return m_pCommonClusterPage->OnCheckMode(HIWORD(wParam),LOWORD(wParam), (HWND)lParam);
        break;

    case IDC_RADIO_MULTICAST:
        return m_pCommonClusterPage->OnCheckMode(HIWORD(wParam),LOWORD(wParam), (HWND)lParam);
        break;

    case IDC_CHECK_IGMP:
        return m_pCommonClusterPage->OnCheckIGMP(HIWORD(wParam),LOWORD(wParam), (HWND)lParam);
        break;

    }
	return CPropertyPage::OnCommand(wParam, lParam);
}



//+----------------------------------------------------------------------------
//
// Function:  ClusterPage::OnNotify
//
// Description:  Process WM_NOTIFY message
//
// Arguments: WPARAM idCtrl - 
//            LPARAM pnmh - 
//            LRESULT* pResult - 
//
// Returns:   BOOL - 
//
// History:   fengsun Created Header    1/4/01
//
//+----------------------------------------------------------------------------
BOOL ClusterPage::OnNotify(WPARAM idCtrl , LPARAM pnmh , LRESULT* pResult) 
{
    NMHDR* pNmhdr = (NMHDR*)pnmh ;
    switch(pNmhdr->code)
    {
    case PSN_APPLY:
        *pResult = m_pCommonClusterPage->OnApply(idCtrl, pNmhdr, *(BOOL*)pResult);
        if (*pResult == PSNRET_NOERROR)
        {
            //
            //  Call the base class, such that OnOk can be called
            //
            return CPropertyPage::OnNotify(idCtrl, pnmh, pResult);
        }
        else
        {
            return TRUE;
        }

    case PSN_KILLACTIVE:
        *pResult = m_pCommonClusterPage->OnKillActive(idCtrl, pNmhdr, *(BOOL*)pResult);
        return TRUE;

    case PSN_SETACTIVE:
        *pResult =  m_pCommonClusterPage->OnActive(idCtrl, pNmhdr, *(BOOL*)pResult);
        return TRUE;

    case PSN_RESET:
        *pResult =  m_pCommonClusterPage->OnCancel(idCtrl, pNmhdr, *(BOOL*)pResult);
        return TRUE;

    case IPN_FIELDCHANGED:
        *pResult =  m_pCommonClusterPage->OnIpFieldChange(idCtrl, pNmhdr, *(BOOL*)pResult);
        return TRUE;
    }
	return CPropertyPage::OnNotify(idCtrl, pnmh, pResult);
}




//+----------------------------------------------------------------------------
//
// Function:  ClusterPage::OnOK
//
// Description:  The property page is closed by OK
//
// Arguments: None
//
// Returns:   Nothing
//
// History:   fengsun Created Header    1/4/01
//
//+----------------------------------------------------------------------------
void ClusterPage::OnOK() 
{
    m_pClusterProperty->cIP  = m_WlbsConfig.cl_ip_addr;
    m_pClusterProperty->cSubnetMask = m_WlbsConfig.cl_net_mask;
    m_pClusterProperty->cFullInternetName = m_WlbsConfig.domain_name;
    m_pClusterProperty->cNetworkAddress = m_WlbsConfig.cl_mac_addr;
    m_pClusterProperty->multicastIPAddress = m_WlbsConfig.szMCastIpAddress;
    m_pClusterProperty->multicastSupportEnabled= m_WlbsConfig.fMcastSupport;
    m_pClusterProperty->igmpSupportEnabled = m_WlbsConfig.fIGMPSupport;
    m_pClusterProperty->remoteControlEnabled = m_WlbsConfig.fRctEnabled;
    m_pClusterProperty->multicastSupportEnabled = m_WlbsConfig.fMcastSupport;
    m_pClusterProperty->clusterIPToMulticastIP = m_WlbsConfig.fIpToMCastIp;
    m_pClusterProperty->password = m_WlbsConfig.szPassword;

	CPropertyPage::OnOK();
}


BOOL
ClusterPage::OnHelpInfo (HELPINFO* helpInfo )
{
    if( helpInfo->iContextType == HELPINFO_WINDOW )
    {
        ::WinHelp( static_cast<HWND> ( helpInfo->hItemHandle ), 
                   CVY_CTXT_HELP_FILE, 
                   HELP_WM_HELP, 
                   (ULONG_PTR ) g_aHelpIDs_IDD_CLUSTER_PAGE);
    }

    return TRUE;
}

void
ClusterPage::OnContextMenu( CWnd* pWnd, CPoint point )
{
    ::WinHelp( m_hWnd, 
               CVY_CTXT_HELP_FILE, 
               HELP_CONTEXTMENU, 
               (ULONG_PTR ) g_aHelpIDs_IDD_CLUSTER_PAGE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\exe\clusterpage.h ===
#ifndef CLUSTERPAGE_H
#define CLUSTERPAGE_H

#include "stdafx.h"

#include "resource.h"

#include "MNLBUIData.h"
#include "CommonClusterPage.h"

class ClusterPage : public CPropertyPage
{
public:
    enum
    {
        IDD = IDD_CLUSTER_PAGE,
    };

    ClusterPage( ClusterProperties* pClusterProperty,
                 bool fDisablePage,
                 UINT         ID = ClusterPage::IDD );

    ~ClusterPage();


    // overrides of CPropertyPage
    virtual BOOL OnInitDialog();
    virtual BOOL OnNotify(WPARAM idCtrl , LPARAM pnmh , LRESULT* pResult) ;
    virtual BOOL OnCommand(WPARAM wParam, LPARAM lParam) ;
    virtual void OnOK();

    afx_msg BOOL OnHelpInfo (HELPINFO* helpInfo );

    afx_msg void OnContextMenu( CWnd* pWnd, CPoint point );

protected:
    ClusterProperties* m_pClusterProperty;

    //
    // Pointer to the object that does the actual work
    //
    CCommonClusterPage* m_pCommonClusterPage;

    //
    // The struct to be passed to the CCommonClusterPage as input and output
    //
    NETCFG_WLBS_CONFIG  m_WlbsConfig;

    bool m_fDisablePage;  // True is the page is for host property
                           // Otherwise tha page is for cluster property

    DECLARE_MESSAGE_MAP()
};

static DWORD g_aHelpIDs_IDD_CLUSTER_PAGE [] = {
    IDC_GROUP_CL_IP,              IDC_GROUP_CL_IP,
    IDC_TEXT_CL_IP,               IDC_EDIT_CL_IP,
    IDC_EDIT_CL_IP,               IDC_EDIT_CL_IP,
    IDC_TEXT_CL_MASK,             IDC_EDIT_CL_MASK,
    IDC_EDIT_CL_MASK,             IDC_EDIT_CL_MASK,
    IDC_TEXT_DOMAIN,              IDC_EDIT_DOMAIN,
    IDC_EDIT_DOMAIN,              IDC_EDIT_DOMAIN,
    IDC_TEXT_ETH,                 IDC_EDIT_ETH,
    IDC_EDIT_ETH,                 IDC_EDIT_ETH,
    IDC_GROUP_CL_MODE,            IDC_GROUP_CL_MODE,
    IDC_RADIO_UNICAST,            IDC_RADIO_UNICAST,
    IDC_RADIO_MULTICAST,          IDC_RADIO_MULTICAST,
    IDC_CHECK_IGMP,               IDC_CHECK_IGMP,
    IDC_GROUP_RCT,                IDC_CHECK_RCT,
    IDC_CHECK_RCT,                IDC_CHECK_RCT,
    IDC_TEXT_PASSW,               IDC_EDIT_PASSW,
    IDC_EDIT_PASSW,               IDC_EDIT_PASSW,
    IDC_TEXT_PASSW2,              IDC_EDIT_PASSW2,
    IDC_EDIT_PASSW2,              IDC_EDIT_PASSW2,
    0, 0
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\exe\commonclusterpage.h ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    CommonClusterDlg.h

Abstract:

    Windows Load Balancing Service (WLBS)
    Cluster page UI.  Shared by Notifier object and NLB Manager

Author:

    kyrilf
    shouse

--*/

#pragma once

#include "resource.h"
#include "wlbsparm.h"
#include "IpSubnetMaskControl.h"


#define WLBS_MAX_PASSWORD 16

//
// Common port rule structure shared by wlbscfg and nlbmanager
//
struct NETCFG_WLBS_PORT_RULE {
    DWORD start_port;             // Starting port number. 
    DWORD end_port;               // Ending port number. 
    DWORD mode;                   // Filtering mode. WLBS_PORT_RULE_XXXX 
    DWORD protocol;               // WLBS_TCP, WLBS_UDP or WLBS_TCP_UDP 

    union {
        struct {
            DWORD priority;       // Mastership priority: 1..32 or 0 for not-specified. 
        } single;                 // Data for single server mode. 

        struct {
            WORD equal_load;      // TRUE - Even load distribution. 
            WORD affinity;        // WLBS_AFFINITY_XXX 
            DWORD load;           // Percentage of load to handle locally 0..100. 
        } multi;                  // Data for multi-server mode. 

    } mode_data;                  // Data for appropriate port group mode. 
};

//
// Common properties that can be configured by wlbscfg and nlbmanager
//

struct NETCFG_WLBS_CONFIG {
    DWORD dwHostPriority;                             // Host priority ID.
    bool fRctEnabled;                                 // TRUE - remote control enabled. 
    bool fJoinClusterOnBoot;                          // TRUE - join cluster on boot.
    bool fMcastSupport;                               // TRUE - multicast mode, FALSE - unicast mode.
    bool fIGMPSupport;                                // TRUE - IGMP enabled.
    bool fIpToMCastIp;                                // TRUE - derive multicast IP from cluster IP.

    WCHAR szMCastIpAddress[CVY_MAX_CL_IP_ADDR + 1];   // The multicast IP address, if user-specified.
    TCHAR cl_mac_addr[CVY_MAX_NETWORK_ADDR + 1];      // Cluster MAC address.
    TCHAR cl_ip_addr[CVY_MAX_CL_IP_ADDR + 1];         // Cluster IP address.
    TCHAR cl_net_mask[CVY_MAX_CL_NET_MASK + 1];       // Netmask for cluster IP.
    TCHAR ded_ip_addr[CVY_MAX_DED_IP_ADDR + 1];       // Dedicated IP address or "" for none.
    TCHAR ded_net_mask[CVY_MAX_DED_NET_MASK + 1];     // Netmask for dedicated IP address or "" for none.
    TCHAR domain_name[CVY_MAX_DOMAIN_NAME + 1];       // Full Qualified Domain Name of the cluster. 

    bool fChangePassword;                             // Whether to change password, valid for SetAdapterConfig only.
    TCHAR szPassword[CVY_MAX_RCT_CODE + 1];           // Remote control password, valid for SetAdapterConfig only.

    bool fConvertMac;                                 // Whether the mac address is generated from IP.
    DWORD dwMaxHosts;                                 // Maximum # hosts allowed.
    DWORD dwMaxRules;                                 // Maximum # port group rules allowed.
    
    DWORD dwNumRules;                                 // # active port group rules 
    NETCFG_WLBS_PORT_RULE port_rules[CVY_MAX_RULES];  // Port rules
};


//+----------------------------------------------------------------------------
//
// class CCommonClusterPage
//
// Description: Provide a common class to display cluster property page for
//              notifier object and NLB Manager
//
// History:     shouse initial code
//              fengsun Created Header    1/04/01
//
//+----------------------------------------------------------------------------
class CCommonClusterPage
{
public:
    /* Constructors/Destructors. */
    CCommonClusterPage (HINSTANCE hInstance, NETCFG_WLBS_CONFIG * paramp, 
        bool fDisablePassword, const DWORD * phelpIDs = NULL);
    ~CCommonClusterPage ();

public:
    /* Message map functions. */
    LRESULT OnInitDialog (HWND hWnd);
    LRESULT OnContextMenu ();
    LRESULT OnHelp (UINT uMsg, WPARAM wParam, LPARAM lParam);

    LRESULT OnApply (int idCtrl, LPNMHDR pnmh, BOOL & fHandled);
    LRESULT OnKillActive (int idCtrl, LPNMHDR pnmh, BOOL & fHandled);
    LRESULT OnActive (int idCtrl, LPNMHDR pnmh, BOOL & fHandled);
    LRESULT OnCancel (int idCtrl, LPNMHDR pnmh, BOOL & fHandled);
    LRESULT OnIpFieldChange (int idCtrl, LPNMHDR pnmh, BOOL & fHandled);

    LRESULT OnEditClIp (WORD wNotifyCode, WORD wID, HWND hWndCtl);
    LRESULT OnEditClMask (WORD wNotifyCode, WORD wID, HWND hWndCtl);
    LRESULT OnCheckRct (WORD wNotifyCode, WORD wID, HWND hWndCtl);
    LRESULT OnButtonHelp (WORD wNotifyCode, WORD wID, HWND hWndCtl);
    LRESULT OnCheckMode (WORD wNotifyCode, WORD wID, HWND hWndCtl);
    LRESULT OnCheckIGMP (WORD wNotifyCode, WORD wID, HWND hWndCtl);

private:
    void SetClusterMACAddress ();
    BOOL CheckClusterMACAddress ();

    void SetInfo ();
    void UpdateInfo ();

    LRESULT ValidateInfo ();          

    NETCFG_WLBS_CONFIG * m_paramp;

    const DWORD * m_adwHelpIDs;

    BOOL m_rct_warned;
    BOOL m_igmp_warned;
    BOOL m_igmp_mcast_warned;

    WCHAR m_passw[CVY_MAX_RCT_CODE + 1];
    WCHAR m_passw2[CVY_MAX_RCT_CODE + 1];

    CIpSubnetMaskControl m_IpSubnetControl;

    HWND m_hWnd;
    HINSTANCE m_hInstance;
    bool m_fDisablePassword; // If true, always disable password editing
};

PCWSTR
SzLoadStringPcch (
    IN HINSTANCE   hinst,
    IN UINT        unId,
    OUT int*       pcch);

PCWSTR
SzLoadString (
    HINSTANCE   hinst,
    UINT        unId);

INT
WINAPIV
NcMsgBox (
    IN HINSTANCE   hinst,
    IN HWND        hwnd,
    IN UINT        unIdCaption,
    IN UINT        unIdFormat,
    IN UINT        unStyle,
    IN ...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\exe\clusterportsdlg.h ===
#ifndef CLUSTERPORTSDLG_H
#define CLUSTERPORTSDLG_H

#include "stdafx.h"

#include "resource.h"

#include "MNLBUIData.h"
#include "CommonNLB.h"

// forward declaration
class PortsPage;

class ClusterPortsDlg : public CDialog
{
    
public:
    enum
    {
        IDD = IDD_DIALOG_PORT_RULE_PROP_CLUSTER,
    };

    ClusterPortsDlg( PortsPage::PortData& portData,
                     CWnd* parent,
                     const int&   index = -1
                     );

    void PrintRangeError (unsigned int ids, int low, int high);

    // overrides of CDialog
    virtual void DoDataExchange( CDataExchange* pDX );

    virtual void OnOK();

    virtual BOOL OnInitDialog();


    // message handlers
    afx_msg void OnRadioMultiple();

    afx_msg void OnRadioSingle();

    afx_msg void OnRadioDisabled();

    afx_msg BOOL OnHelpInfo (HELPINFO* helpInfo );

    afx_msg void OnContextMenu( CWnd* pWnd, CPoint point );

private:

    PortsPage::PortData& m_portData;

    PortsPage* m_parent;

    int m_index;

    void
    SetControlData();

    DECLARE_MESSAGE_MAP()

};

static DWORD g_aHelpIDs_IDD_PORT_RULE_PROP_CLUSTER [] = {
    IDC_GROUP_RANGE,              IDC_GROUP_RANGE,
    IDC_TEXT_START,               IDC_EDIT_START,
    IDC_EDIT_START,               IDC_EDIT_START,
    IDC_SPIN_START,               IDC_EDIT_START,
    IDC_TEXT_END,                 IDC_EDIT_END,
    IDC_EDIT_END,                 IDC_EDIT_END,
    IDC_SPIN_END,                 IDC_EDIT_END,
    IDC_GROUP_PROTOCOLS,          IDC_GROUP_PROTOCOLS,
    IDC_RADIO_TCP,                IDC_RADIO_TCP,
    IDC_RADIO_UDP,                IDC_RADIO_UDP,
    IDC_RADIO_BOTH,               IDC_RADIO_BOTH,
    IDC_GROUP_DISABLED,           IDC_GROUP_DISABLED,
    IDC_GROUP_SINGLE,             IDC_GROUP_SINGLE,
    IDC_GROUP_MULTIPLE,           IDC_GROUP_MULTIPLE,
    IDC_RADIO_MULTIPLE,           IDC_RADIO_MULTIPLE,
    IDC_RADIO_SINGLE,             IDC_RADIO_SINGLE,
    IDC_RADIO_DISABLED,           IDC_RADIO_DISABLED,
    IDC_TEXT_AFF,                 IDC_TEXT_AFF,
    IDC_RADIO_AFF_NONE,           IDC_RADIO_AFF_NONE,
    IDC_RADIO_AFF_SINGLE,         IDC_RADIO_AFF_SINGLE,
    IDC_RADIO_AFF_CLASSC,         IDC_RADIO_AFF_CLASSC,
    IDC_TEXT_MULTI,               IDC_TEXT_MULTI,
    IDC_RADIO_EQUAL,              IDC_CHECK_EQUAL,
    IDC_RADIO_UNEQUAL,            IDC_EDIT_MULTI,
    0, 0
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\exe\commonclusterpage.cpp ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    CommonClusterPage.cpp

Abstract:

    Windows Load Balancing Service (WLBS)
    Cluster page UI.  Shared by Notifier object and NLB Manager

Author:

    kyrilf
    shouse

// History:
// --------
// 
// Revised by : mhakim
// Date       : 02-09-01
// Reason     : Igmp box was enabled when it needed to be grayed out.
//
// Revised by : mhakim
// Date       : 02-12-01
// Reason     : Mac address was not being retrieved fully.

--*/


//
//  To share the code with notifier object
//      share string resurce
//      share the common structure
//      call SetChangedFlag() in OnInitDialog
//      add trace, assert
//      Share help file and add help handler
//      
//

#include "stdafx.h"
#include <stdio.h>
#include <process.h>
#include "CommonClusterPage.h"
#include "wlbsconfig.h"
#include "wlbsutil.h"

#define DUMMY_PASSWORD L"somepassword"
#define EMPTY_PASSWORD L""

//
// No trace/assert for now
//
#define TraceMsg(x)
#define Assert(x)


//+---------------------------------------------------------------------------
//
//  Function:   SzLoadStringPcch
//
//  Purpose:    Load a resource string.  (This function will never return NULL.)
//
//  Arguments:
//      hinst [in]  Instance handle of module with the string resource.
//      unId  [in]  Resource ID of the string to load.
//      pcch  [out] Pointer to returned character length.
//
//  Returns:    Pointer to the constant string.
//
//  Author:     shaunco   24 Mar 1997
//              fengsun copied from net\config\common\ncbase\ncstring.cpp
//
//  Notes:      The loaded string is pointer directly into the read-only
//              resource section.  Any attempt to write through this pointer
//              will generate an access violation.
//
//              The implementations is referenced from "Win32 Binary Resource
//              Formats" (MSDN) 4.8 String Table Resources
//
//              User must have RCOPTIONS = -N turned on in your sources file.
//
PCWSTR
SzLoadStringPcch (
    IN HINSTANCE   hinst,
    IN UINT        unId,
    OUT int*       pcch)
{
    Assert(hinst);
    Assert(unId);
    Assert(pcch);

    static const WCHAR c_szSpace[] = L" ";

    PCWSTR psz = c_szSpace;
    int    cch = 1;

    // String Tables are broken up into 16 string segments.  Find the segment
    // containing the string we are interested in.
    HRSRC hrsrcInfo = FindResource (hinst,
                        (PWSTR)ULongToPtr( ((LONG)(((USHORT)unId >> 4) + 1)) ),
                        RT_STRING);
    if (hrsrcInfo)
    {
        // Page the resource segment into memory.
        HGLOBAL hglbSeg = LoadResource (hinst, hrsrcInfo);
        if (hglbSeg)
        {
            // Lock the resource.
            psz = (PCWSTR)LockResource(hglbSeg);
            if (psz)
            {
                // Move past the other strings in this segment.
                // (16 strings in a segment -> & 0x0F)
                unId &= 0x0F;

                cch = 0;
                do
                {
                    psz += cch;                // Step to start of next string
                    cch = *((WCHAR*)psz++);    // PASCAL like string count
                }
                while (unId--);

                // If we have a non-zero count, it includes the
                // null-terminiator.  Subtract this off for the return value.
                //
                if (cch)
                {
                    cch--;
                }
                else
                {
//                    AssertSz(0, "String resource not found");
                    psz = c_szSpace;
                    cch = 1;
                }
            }
            else
            {
                psz = c_szSpace;
                cch = 1;
//                TraceLastWin32Error("SzLoadStringPcch: LockResource failed.");
            }
        }
//        else
//            TraceLastWin32Error("SzLoadStringPcch: LoadResource failed.");
    }
//    else
//        TraceLastWin32Error("SzLoadStringPcch: FindResource failed.");

    *pcch = cch;
    Assert(*pcch);
    Assert(psz);
    return psz;
}

//+---------------------------------------------------------------------------
//
//  Function:   SzLoadString
//
//  Purpose:    Load a resource string.  (This function will never return NULL.)
//
//  Arguments:
//      hinst [in]  Instance handle of module with the string resource.
//      unId  [in]  Resource ID of the string to load.
//
//  Returns:    Pointer to the constant string.
//
//  Author:     shaunco   24 Mar 1997
//              fengsun copied from net\config\common\ncbase\ncstring.cpp
//
//  Notes:      See SzLoadStringPcch()
//
PCWSTR
SzLoadString (
    HINSTANCE   hinst,
    UINT        unId)
{
    int cch;
    return SzLoadStringPcch(hinst, unId, &cch);
}


//+---------------------------------------------------------------------------
//
//  Function:   NcMsgBox
//
//  Purpose:    Displays a message box using resource strings and replaceable
//              parameters.
//
//  Arguments:
//      hinst       [in] hinstance for resource strings
//      hwnd        [in] parent window handle
//      unIdCaption [in] resource id of caption string
//      unIdFormat  [in] resource id of text string (with %1, %2, etc.)
//      unStyle     [in] standard message box styles
//      ...         [in] replaceable parameters (optional)
//                          (these must be PCWSTRs as that is all
//                          FormatMessage handles.)
//
//  Returns:    the return value of MessageBox()
//
//  Author:     shaunco   24 Mar 1997
//              fengsun copied from net\config\common\ncbase\ncui.cpp
//
//  Notes:      FormatMessage is used to do the parameter substitution.
//
INT
WINAPIV
NcMsgBox (
    IN HINSTANCE   hinst,
    IN HWND        hwnd,
    IN UINT        unIdCaption,
    IN UINT        unIdFormat,
    IN UINT        unStyle,
    IN ...)
{
    PCWSTR pszCaption = SzLoadString (hinst, unIdCaption);
    PCWSTR pszFormat  = SzLoadString (hinst, unIdFormat);

    PWSTR  pszText = NULL;
    va_list val;
    va_start (val, unStyle);
    FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_STRING,
                   pszFormat, 0, 0, (PWSTR)&pszText, 0, &val);
    va_end (val);

    INT nRet = MessageBox (hwnd, pszText, pszCaption, unStyle);
    LocalFree (pszText);

    return nRet;
}


//+----------------------------------------------------------------------------
//
// Function:  CCommonClusterPage::CCommonClusterPage
//
// Description:  
//
// Arguments: HINSTANCE hInstance - instance handle for string resources
//            NETCFG_WLBS_CONFIG * paramp - IN/OUT NLB properties
//            bool fDisablePassword - whether do disable password editing
//            const DWORD * adwHelpIDs - a list of help ID pairs, or NULL.  
//                  The pointer has to be valid through the lifetime of this dialog.
//
// Returns:   Nothing
//
// History:   fengsun Created Header    1/4/01
//
//+----------------------------------------------------------------------------
CCommonClusterPage::CCommonClusterPage(HINSTANCE hInstance, 
                                       NETCFG_WLBS_CONFIG * paramp, 
                                       bool fDisablePassword, const DWORD * adwHelpIDs) :
                m_IpSubnetControl(IDC_EDIT_CL_IP, IDC_EDIT_CL_MASK)
{

    TraceMsg(L"CCommonClusterPage::CCommonClusterPage\n");

    m_paramp = paramp;
    m_adwHelpIDs = adwHelpIDs;
    m_rct_warned = FALSE;
    m_igmp_warned = FALSE;
    m_igmp_mcast_warned = FALSE;
    m_hInstance = hInstance;
    m_fDisablePassword = fDisablePassword;
}

/*
 * Method: CCommonClusterPage
 * Description: The class destructor.
 */
CCommonClusterPage::~CCommonClusterPage () {

    TraceMsg(L"CCommonClusterPage::~CCommonClusterPage\n");
}

/*
 * Method: OnInitDialog
 * Description: Called to initialize the cluster properties dialog.
 */
LRESULT CCommonClusterPage::OnInitDialog (HWND hWnd) 
{
    TraceMsg(L"CCommonClusterPage::OnInitDialog\n");

    m_hWnd = hWnd;

    /* Limit the field ranges for the address and password fields. */
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_DOMAIN, EM_SETLIMITTEXT, CVY_MAX_DOMAIN_NAME, 0);
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_ETH, EM_SETLIMITTEXT, CVY_MAX_NETWORK_ADDR, 0);
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_PASSW, EM_SETLIMITTEXT, CVY_MAX_RCT_CODE, 0);
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_PASSW2, EM_SETLIMITTEXT, CVY_MAX_RCT_CODE, 0);

    /* Disable the MAC address field.  It should be read-only. */
    if (m_paramp->fConvertMac) ::EnableWindow(::GetDlgItem (m_hWnd, IDC_EDIT_ETH), FALSE);

    m_IpSubnetControl.OnInitDialog(m_hWnd, AfxGetInstanceHandle()); 

    return 0;
}

/*
 * Method: OnContextMenu
 * Description: 
 */
LRESULT CCommonClusterPage::OnContextMenu () 
{

    TraceMsg(L"CCommonClusterPage::OnContextMenu\n");

    /* Spawn a help window. */
    if (m_adwHelpIDs != NULL)
        ::WinHelp(m_hWnd, CVY_CTXT_HELP_FILE, HELP_CONTEXTMENU, (ULONG_PTR)m_adwHelpIDs);

    return 0;
}

/*
 * Method: OnHelp
 * Description: 
 */
LRESULT CCommonClusterPage::OnHelp (UINT uMsg, WPARAM wParam, LPARAM lParam) {

    TraceMsg(L"CCommonClusterPage::OnHelp\n");

    LPHELPINFO lphi = reinterpret_cast<LPHELPINFO>(lParam);

    /* Spawn a help window. */
    if ((HELPINFO_WINDOW == lphi->iContextType) && (m_adwHelpIDs != NULL))
        ::WinHelp(static_cast<HWND>(lphi->hItemHandle), CVY_CTXT_HELP_FILE, HELP_WM_HELP, (ULONG_PTR)m_adwHelpIDs);

    return 0;
}

/*
 * Method: OnActive
 * Description: Called when the cluster settings tab becomes active (is clicked). 
 */
LRESULT CCommonClusterPage::OnActive (int idCtrl, LPNMHDR pnmh, BOOL & fHandled) 
{

    TraceMsg(L"CCommonClusterPage::OnActive\n");

    /* Populate the UI with the current configuration. */
    SetInfo();

    //
    // NLB mamager always has password editing disabled
    //

    /* Enable/disable the password entry boxes based on the state of the remote control checkbox. 
       Edited( mhakim 02-09-01)
       but only when remote control is enabled.
    */
    ::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_PASSW), 
                   ::IsDlgButtonChecked(m_hWnd, IDC_CHECK_RCT)
                   && 
                   ::IsWindowEnabled( ::GetDlgItem( m_hWnd, IDC_CHECK_RCT ) ) );
    
    ::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_PASSW2), 
                   ::IsDlgButtonChecked(m_hWnd, IDC_CHECK_RCT)
                   && 
                   ::IsWindowEnabled( ::GetDlgItem( m_hWnd, IDC_CHECK_RCT ) ) );

    /* Enable/disable the IGMP checkbox based on the state of the multicast checkbox. 
       Edited( mhakim 02-09-01)
       but only when multicast button is enabled.
     */
    ::EnableWindow(::GetDlgItem(m_hWnd, IDC_CHECK_IGMP), 
                   ::IsDlgButtonChecked (m_hWnd, IDC_RADIO_MULTICAST) 
                   && 
                   ::IsWindowEnabled( ::GetDlgItem( m_hWnd, IDC_RADIO_MULTICAST) ) );

    /* Fill in the cluster MAC address, based on the values of multicast, IGMP, and the cluster IP. */
    SetClusterMACAddress();

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, PSNRET_NOERROR);

    return 0;
}

/*
 * Method: OnKillActive
 * Description: Called When the focus moves away from the cluster settings tab.
 */
LRESULT CCommonClusterPage::OnKillActive (int idCtrl, LPNMHDR pnmh, BOOL & fHandled) 
{

    TraceMsg(L"CCommonClusterPage::OnKillActive\n");

    /* Get the new configuration from the UI. */
    UpdateInfo();

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, PSNRET_NOERROR);

    return 0;
}

/*
 * Method: OnApply
 * Description: Called when the user clicks "OK".
 */
LRESULT CCommonClusterPage::OnApply (int idCtrl, LPNMHDR pnmh, BOOL & fHandled) 
{
    LRESULT fError = PSNRET_NOERROR;

    TraceMsg(L"CCommonClusterPage::OnApply\n");

    /* Validate the UI values entered by the user. */
    fError = ValidateInfo();

    ::SetWindowLongPtr(m_hWnd, DWLP_MSGRESULT, fError);

    return fError;
}

/*
 * Method: OnCancel
 * Description: Called when the user clicks "Cancel".
 */
LRESULT CCommonClusterPage::OnCancel (int idCtrl, LPNMHDR pnmh, BOOL & fHandled) 
{

    TraceMsg(L"CCommonClusterPage::OnCancel\n");

    return 0;
}

/*
 * Method: OnButtonHelp
 * Description: Called when the user clicks the NLB "Help" button.
 */
LRESULT CCommonClusterPage::OnButtonHelp (WORD wNotifyCode, WORD wID, HWND hWndCtl) {
    WCHAR wbuf[CVY_STR_SIZE];

    TraceMsg(L"CCommonClusterPage::OnButtonHelp\n");

    switch (wNotifyCode) {
        case BN_CLICKED:
            /* Spawn the windows help process. */
            swprintf(wbuf, L"%%WINDIR%%\\help\\%ls::/installation.htm", CVY_HELP_FILE);
            _wspawnlp(P_NOWAIT, L"hh.exe", L"hh.exe", wbuf, NULL);
            break;
    }

    return 0;
}

/*
 * Method: OnEditClIp
 * Description: Called when the user edits the cluster IP address.
 */
LRESULT CCommonClusterPage::OnEditClIp (WORD wNotifyCode, WORD wID, HWND hWndCtl) {

    TraceMsg(L"CCommonClusterPage::OnEditClIp\n");

    switch (wNotifyCode) {
        case EN_CHANGE:
            /* Update the cluster MAC address. */
            SetClusterMACAddress();
            break;
    }

    return 0;
}

/*
 * Method: OnIpFieldChange
 * Description: Called wnen a field (byte) of the cluster IP address changes. We use this
 *              to make sure the first byte of the IP is not < 1 or > 223.
 */
LRESULT CCommonClusterPage::OnIpFieldChange (int idCtrl, LPNMHDR pnmh, BOOL & fHandled) 
{
	return m_IpSubnetControl.OnIpFieldChange(idCtrl, pnmh);
}

/*
 * Method: OnEditClMask
 * Description: Called when the user modifies the cluster netmask.
 */
LRESULT CCommonClusterPage::OnEditClMask (WORD wNotifyCode, WORD wID, HWND hWndCtl) 
{
    return m_IpSubnetControl.OnSubnetMask(wNotifyCode);
}

/*
 * Method: OnCheckRct
 * Description: Called when the user checks/unchecks the remote control enabled checkbox.
 */
LRESULT CCommonClusterPage::OnCheckRct (WORD wNotifyCode, WORD wID, HWND hWndCtl) {

    TraceMsg(L"CCommonClusterPage::OnCheckRct\n");

    switch (wNotifyCode) {
        case BN_CLICKED:
        /* Decide whether to enable or diable the password entry boxes based on the value of the remote checkbox. */
            ::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_PASSW), ::IsDlgButtonChecked(m_hWnd, IDC_CHECK_RCT));
        ::EnableWindow(::GetDlgItem(m_hWnd, IDC_EDIT_PASSW2), ::IsDlgButtonChecked(m_hWnd, IDC_CHECK_RCT));

    
        /* Warn the user about the implications of enabling remote control. */
        if (::IsDlgButtonChecked(m_hWnd, IDC_CHECK_RCT) && !m_rct_warned) {
            /* Alert the user. */
            NcMsgBox(m_hInstance, ::GetActiveWindow(), IDS_PARM_WARN, IDS_PARM_RCT_WARN,
                     MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);
            
            /* Only warn the user once. */
            m_rct_warned = TRUE;
        }
        
        break;
    }
    
    return 0;
}

/*
 * Method: OnCheckMode
 * Description: Called when the user changes cluster mode.
 */
LRESULT CCommonClusterPage::OnCheckMode (WORD wNotifyCode, WORD wID, HWND hWndCtl) {

    TraceMsg(L"CCommonClusterPage::OnCheckMode\n");

    switch (wNotifyCode) {
    case BN_CLICKED:
        /* If the user has IGMP checked, but is turning off multicast support, warn them. */
        if (::IsDlgButtonChecked(m_hWnd, IDC_CHECK_IGMP) && !::IsDlgButtonChecked(m_hWnd, IDC_RADIO_MULTICAST)) {
            if (!m_igmp_mcast_warned) {
                /* Alert the user. */
                NcMsgBox(m_hInstance, ::GetActiveWindow(), IDS_PARM_WARN, IDS_PARM_IGMP_MCAST,
                         MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);            

                /* Only warn the user once. */
                m_igmp_mcast_warned = TRUE;
            } 

            /* Uncheck and disable the IGMP checkbox and set the IGMP support flag to FALSE. */
            ::CheckDlgButton(m_hWnd, IDC_CHECK_IGMP, FALSE);
            ::EnableWindow(::GetDlgItem(m_hWnd, IDC_CHECK_IGMP), FALSE);
            m_paramp->fIGMPSupport = FALSE;
        } else {
            /* Enable/disable and check/uncheck the IGMP checkbox based on the value of the cluster mode radio buttons. */
            ::EnableWindow(::GetDlgItem(m_hWnd, IDC_CHECK_IGMP), ::IsDlgButtonChecked(m_hWnd, IDC_RADIO_MULTICAST));
        }

        /* Update the cluster MAC address. */
        SetClusterMACAddress();
    
        break;
    }

    return 0;
}

/*
 * Method: OnCheckIGMP
 * Description: Called when the user checks/unchecks the IGMP support checkbox.
 */
LRESULT CCommonClusterPage::OnCheckIGMP (WORD wNotifyCode, WORD wID, HWND hWndCtl) {

    TraceMsg(L"CCommonClusterPage::OnCheckIGMP\n");

    switch (wNotifyCode) {
    case BN_CLICKED:
        /* Update the cluster MAC address. */
        SetClusterMACAddress();
    
        /* Warn the user about the implications of enabling remote control. */
        if (::IsDlgButtonChecked(m_hWnd, IDC_CHECK_IGMP) && !m_igmp_warned) {
            /* Alert the user. */
            NcMsgBox(m_hInstance, ::GetActiveWindow(), IDS_PARM_WARN, IDS_PARM_IGMP_WARN,
                     MB_APPLMODAL | MB_ICONEXCLAMATION | MB_OK);
            
            /* Only warn the user once. */
            m_igmp_warned = TRUE;
        }

        break;
    }

    return 0;
}

/*
 * Method: SetClusterMACAddress
 * Description: Used to determine the cluster MAC address based on the cluster IP, and the
 *              state of multicast and IGMP support.
 */
void CCommonClusterPage::SetClusterMACAddress () {
    WCHAR cl_ip_addr[CVY_MAX_CL_IP_ADDR + 1];
    WCHAR cl_mac_addr[CVY_MAX_NETWORK_ADDR + 1];

    TraceMsg(L"CCommonClusterPage::SetClusterMACAddress\n");

    /* If the convert MAC flag isn't set, the bail out. */
    if (!m_paramp->fConvertMac) return;

    /* Retrieve the cluster IP address from the UI. */
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_CL_IP, WM_GETTEXT, CVY_MAX_CL_IP_ADDR + 1, (LPARAM)cl_ip_addr);
    
    /* Generate the cluster MAC address. */
    ParamsGenerateMAC(cl_ip_addr, cl_mac_addr, m_paramp->szMCastIpAddress, m_paramp->fConvertMac, ::IsDlgButtonChecked(m_hWnd, IDC_RADIO_MULTICAST), 
                      ::IsDlgButtonChecked(m_hWnd, IDC_CHECK_IGMP), m_paramp->fIpToMCastIp);
    
    /* Set the cluster MAC address. */
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_ETH, WM_SETTEXT, 0, (LPARAM)cl_mac_addr);
}

/*
 * Method: CheckClusterMACAddress
 * Description: Used to check the cluster MAC address in the case where we aren't generating it ourselves.
 */
BOOL CCommonClusterPage::CheckClusterMACAddress () {
    PWCHAR p1, p2;
    WCHAR mac_addr[WLBS_MAX_NETWORK_ADDR + 1];
    DWORD i, j;
    BOOL flag = TRUE;
    
    /* Valid formats include:
       02:bf:0b:0b:01:01
       02-bf-0b-0b-01-01
       02:bf:0b:b:01:1 */

    /* Make a copy of the MAC address. */
    _tcscpy(mac_addr, m_paramp->cl_mac_addr);
    
    /* Point to the beginning of the MAC. */
    p2 = p1 = mac_addr;
    
    /* Loop through all six bytes. */
    for (i = 0 ; i < 6 ; i++) {
        /* If we are pointing at the end of the string, its invalid. */
        if (*p2 == _TEXT('\0')) return FALSE;
        
        /* Convert the hex characters into decimal. */
        j = _tcstoul(p1, &p2, 16);
        
        /* If the number is greater than 255, then the format is bad. */
        if (j > 255) return FALSE;
        
        /* If the NEXT character is neither a -, :, nor the NUL character, then the format is bad. */
        if (!((*p2 == _TEXT('-')) || (*p2 == _TEXT(':')) || (*p2 == _TEXT('\0')))) return FALSE;
        
        /* If the NEXT character is the end of the string, but we don't have enough bytes yet, bail out. */
        if (*p2 == _TEXT('\0') && i < 5) return FALSE;
        
        /* Repoint to the NEXT character. */
        p1 = p2 + 1;
        p2 = p1;
    }

    return TRUE;
}

/*
 * Method: SetInfo
 * Description: Called to populate the UI with the current cluster settings.
 */
void CCommonClusterPage::SetInfo () {

    /* Check (or uncheck) the checkboxes. */
    ::CheckDlgButton(m_hWnd, IDC_CHECK_RCT, m_paramp->fRctEnabled);

    /* Check the appropriate radio button for cluster mode. */
    if (m_paramp->fMcastSupport) {
        ::CheckDlgButton(m_hWnd, IDC_RADIO_MULTICAST, TRUE);

        if (m_paramp->fIGMPSupport) ::CheckDlgButton(m_hWnd, IDC_CHECK_IGMP, TRUE);
    } else 
        ::CheckDlgButton(m_hWnd, IDC_RADIO_UNICAST, TRUE);

    m_IpSubnetControl.SetInfo(m_paramp->cl_ip_addr, m_paramp->cl_net_mask);

    /* Fill in the edit boxes. */
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_DOMAIN, WM_SETTEXT, 0, (LPARAM)m_paramp->domain_name);
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_ETH, WM_SETTEXT, 0, (LPARAM)m_paramp->cl_mac_addr);
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_PASSW, WM_SETTEXT, 0, (LPARAM)m_paramp->szPassword );
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_PASSW2, WM_SETTEXT, 0, (LPARAM)m_paramp->szPassword );
}

/*
 * Method: UpdateInfo
 * Description: Called to copy the UI state to the cluster configuration.
 */
void CCommonClusterPage::UpdateInfo () {

    TraceMsg(L"CCommonClusterPage::UpdateInfo\n");

    /* Retrieve the checkbox values. */
    m_paramp->fRctEnabled = ::IsDlgButtonChecked(m_hWnd, IDC_CHECK_RCT) == 1;

    /* Retrieve the cluster mode radio button value. */
    m_paramp->fIGMPSupport = ::IsDlgButtonChecked(m_hWnd, IDC_CHECK_IGMP) == 1;
    m_paramp->fMcastSupport = ::IsDlgButtonChecked(m_hWnd, IDC_RADIO_MULTICAST) == 1;

    m_IpSubnetControl.UpdateInfo(m_paramp->cl_ip_addr, m_paramp->cl_net_mask);

    /* Retrieve the entry box values. */
    // Edited ( mhakim 02-12-01 )
    // We need to retrieve one more byte for the domain name and network address.
//    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_DOMAIN, WM_GETTEXT, CVY_MAX_DOMAIN_NAME, (LPARAM)m_paramp->domain_name);
//    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_ETH, WM_GETTEXT, CVY_MAX_NETWORK_ADDR, (LPARAM)m_paramp->cl_mac_addr);

    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_DOMAIN, WM_GETTEXT, CVY_MAX_DOMAIN_NAME + 1, (LPARAM)m_paramp->domain_name);
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_ETH, WM_GETTEXT, CVY_MAX_NETWORK_ADDR + 1, (LPARAM)m_paramp->cl_mac_addr);
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_PASSW, WM_GETTEXT, CVY_MAX_RCT_CODE + 1, (LPARAM)m_passw);
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_PASSW2, WM_GETTEXT, CVY_MAX_RCT_CODE + 1, (LPARAM)m_passw2);
}

/*
 * Method: ValidateInfo
 * Description: Called to validate the entries made by the user.
 */
LRESULT CCommonClusterPage::ValidateInfo () {
    DWORD IPAddr;

    TraceMsg(L"CCommonClusterPage::ValidateInfo\n");

    if (!m_IpSubnetControl.ValidateInfo())
    {
        //
        // Check whether IP address and subnet mask pair is valid
        //
        
        return PSNRET_INVALID;
    }

    //
    // Get the user input
    //
    m_IpSubnetControl.UpdateInfo(m_paramp->cl_ip_addr, m_paramp->cl_net_mask);

        
    /* Check to make sure that the dedicated IP and cluster IP are not the same. */
    if (!wcscmp(m_paramp->ded_ip_addr, m_paramp->cl_ip_addr)) {
        /* Alert the user. */
        NcMsgBox(m_hInstance, ::GetActiveWindow(), IDS_PARM_ERROR, IDS_PARM_IP_CONFLICT,
                 MB_APPLMODAL | MB_ICONSTOP | MB_OK);
        
        /* An error occurred. */
        return PSNRET_INVALID;
    }

    if (!m_paramp->fConvertMac && !CheckClusterMACAddress()) {
        /* Alert the user. */
        NcMsgBox(m_hInstance, ::GetActiveWindow(), IDS_PARM_ERROR, IDS_PARM_INVAL_MAC,
                 MB_APPLMODAL | MB_ICONSTOP | MB_OK);

        /* An error occurred. */
        return PSNRET_INVALID;
    }

    /* Only check for invalid passwords and update if remote control is enabled. */
    if (::IsDlgButtonChecked(m_hWnd, IDC_CHECK_RCT)) {
        /* Make sure the passwords match. */
        if (wcscmp(m_passw, m_passw2) != 0) {
            /* Alert the user. */
            NcMsgBox(m_hInstance, ::GetActiveWindow(), IDS_PARM_ERROR, IDS_PARM_PASSWORD,
                     MB_APPLMODAL | MB_ICONSTOP | MB_OK);

            /* Empty the passwords. */
            m_passw [0] = m_passw2 [0] = 0;

            /* An error occurred. */
            return PSNRET_INVALID;
        } else {
            /* If the new password is not the dummy password, update the password. */
            if (wcscmp (m_passw, DUMMY_PASSWORD) != 0) {
                lstrcpy(m_paramp->szPassword, m_passw);
                m_paramp->fChangePassword = true;
            }

        }
    }

    return PSNRET_NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\exe\commonnlb.cpp ===
#include "CommonNLB.h"

#include "MNLBCluster.h"
#include "MNLBHost.h"
#include "MNLBMachine.h"
#include "MNLBNetCfg.h"
#include "MWmiError.h"
#include "MUsingCom.h"

#include "MIPAddressAdmin.h"

#include "ResourceString.h"
#include "resource.h"

#include <vector>
#include <memory>
#include <algorithm>
#include <algorithm>

using namespace std;

// global only temporarily.
//
LeftView* g_leftView;

CommonNLB::CommonNLB_Error
CommonNLB::connectToClusterDirect( const _bstr_t&          clusterIP,
                                   const _bstr_t&          hostMember,
                                   ClusterData*            p_clusterData,
                                   DataSinkI*              dataSinkObj )
{

    dataSinkObj->dataSink( 
        GETRESOURCEIDSTRING( IDS_INFO_CONNECTING) + hostMember );

    MNLBMachine nlbMachine( hostMember,
                            clusterIP );

    dataSinkObj->dataSink( 
        GETRESOURCEIDSTRING( IDS_INFO_DONE) );


    vector<MNLBMachine::HostInfo> hostInfo;

    dataSinkObj->dataSink( 
        GETRESOURCEIDSTRING( IDS_INFO_FINDING_H ) );

    nlbMachine.getPresentHostsInfo( &hostInfo );

    dataSinkObj->dataSink( 
        GETRESOURCEIDSTRING( IDS_INFO_DONE) );

    vector< _bstr_t> connectionIPS;

    for( int i = 0; i < hostInfo.size(); ++i )
    {
        connectionIPS.push_back( hostInfo[i].dedicatedIP );
    }


#if 1
    return connectToClusterIndirect( clusterIP,
                                     connectionIPS,
                                     p_clusterData,
                                     dataSinkObj );
#else
    vector<ClusterData> clusterDataStore;
    bool clusterPropertiesMatched;

    connectToClusterIndirectNew( clusterIP,
                                 connectionIPS,
                                 &clusterDataStore,
                                 clusterPropertiesMatched,
                                 dataSinkObj );
    (*p_clusterData) = clusterDataStore[0];

    return CommonNLB_SUCCESS;
#endif
}
    

CommonNLB::CommonNLB_Error
CommonNLB::connectToClusterIndirectNew( const _bstr_t&          clusterIP,
                                        const vector<_bstr_t>&  connectionIPS,
                                        vector< ClusterData>*   clusterDataStore,
                                        bool&                   clusterPropertiesMatched,
                                        DataSinkI*              dataSinkObj )

{
    // connect to each host.  
    // We are doing it here so that if there are any connectivity issues
    // we do not proceed with any further operation and ask user to
    // fix all issues before proceeding. 

    // connect to each host.
    map< bstr_t, auto_ptr<MNLBMachine> > nlbMachine;

    for( int i = 0; i < connectionIPS.size(); ++i )
    {
        dataSinkObj->dataSink( 
            GETRESOURCEIDSTRING( IDS_INFO_CONNECTING) + connectionIPS[i] );


        auto_ptr<MNLBMachine> p_nlbMachine = 
            auto_ptr<MNLBMachine> ( new MNLBMachine( connectionIPS[i],
                                                     clusterIP ) );
        nlbMachine[connectionIPS[i] ] = p_nlbMachine;

        dataSinkObj->dataSink( 
            GETRESOURCEIDSTRING( IDS_INFO_DONE) );
    }

    // get information from each host.
    //
    for( int i = 0; i < connectionIPS.size(); ++i )
    {

        ClusterData clusterData;
        
        // get cluster properties.
        dataSinkObj->dataSink( 
            GETRESOURCEIDSTRING( IDS_INFO_FINDING_CL_P ) );

        ClusterProperties cp;

        nlbMachine[connectionIPS[i] ]->getClusterProperties( &cp );

        clusterData.cp = cp;

        dataSinkObj->dataSink( 
            GETRESOURCEIDSTRING( IDS_INFO_DONE) );

        // get host properties.
        dataSinkObj->dataSink( 
            GETRESOURCEIDSTRING( IDS_INFO_FINDING_H_P ) );

        HostProperties hp;

        nlbMachine[connectionIPS[i] ]->getHostProperties( &hp );

        dataSinkObj->dataSink( 
            GETRESOURCEIDSTRING( IDS_INFO_DONE) );

        // set the host properties
        HostData hostData;

        hostData.hp = hp;

        // set the connection ip.
        hostData.connectionIP = connectionIPS[i];

        clusterData.hosts[hp.machineName] = hostData;

        // get port rules
        dataSinkObj->dataSink( 
            GETRESOURCEIDSTRING( IDS_INFO_FINDING_P ) );

        vector<MNLBPortRuleLoadBalanced> portsLB;
        vector<MNLBPortRuleFailover> portsF;
        vector<MNLBPortRuleDisabled> portsD;

        PortDataULB ulbPortRule;

        PortDataF fPortRule;

        PortDataELB elbPortRule;

        PortDataD dPortRule;

        nlbMachine[connectionIPS[i] ]->getPortRulesLoadBalanced( &portsLB );
        for( int j = 0; j < portsLB.size(); ++j )
        {
            if( portsLB[j]._isEqualLoadBalanced == true )
            {
                // equal load balanced port rule.
                elbPortRule._startPort = portsLB[j]._startPort;
                elbPortRule._key = portsLB[j]._startPort;
                elbPortRule._endPort   = portsLB[j]._endPort;
                elbPortRule._trafficToHandle   = portsLB[j]._trafficToHandle;
                elbPortRule._affinity   = portsLB[j]._affinity;

                clusterData.portELB[portsLB[j]._startPort] = elbPortRule;
            }
            else
            {
                ulbPortRule._startPort = portsLB[j]._startPort;
                ulbPortRule._key = portsLB[j]._startPort;
                ulbPortRule._endPort   = portsLB[j]._endPort;
                ulbPortRule._trafficToHandle   = portsLB[j]._trafficToHandle;
                ulbPortRule._affinity   = portsLB[j]._affinity;

                ulbPortRule.machineMapToLoadWeight[hp.machineName]  = portsLB[j]._load;

                clusterData.portULB[portsLB[j]._startPort] = ulbPortRule;
            }
        }
        portsLB.erase( portsLB.begin(), portsLB.end() );

        nlbMachine[connectionIPS[i] ]->getPortRulesFailover( &portsF );
        for( int j = 0; j < portsF.size(); ++j )
        {
            fPortRule._startPort = portsF[j]._startPort;
            fPortRule._key = portsF[j]._startPort;
            fPortRule._endPort   = portsF[j]._endPort;
            fPortRule._trafficToHandle   = portsF[j]._trafficToHandle;

            fPortRule.machineMapToPriority[ hp.machineName] = portsF[j]._priority;
                
            clusterData.portF[portsF[j]._startPort] = fPortRule;
        }
        portsF.erase( portsF.begin(), portsF.end() );

        // disabled port rules
        nlbMachine[connectionIPS[i] ]->getPortRulesDisabled( &portsD );

        for( int j = 0; j < portsD.size(); ++j )
        {
            dPortRule._startPort = portsD[j]._startPort;
            dPortRule._key = portsD[j]._startPort;
            dPortRule._endPort   = portsD[j]._endPort;
            dPortRule._trafficToHandle   = portsD[j]._trafficToHandle;
            
            clusterData.portD[portsD[j]._startPort] = dPortRule;
        }
        portsD.erase( portsD.begin(), portsD.end() );

        dataSinkObj->dataSink( 
            GETRESOURCEIDSTRING( IDS_INFO_DONE) );

        // get virtual ips.  These have already been got when we got the host properties
        // Thus here we are storing duplicate data, but this does ease
        // a lot of data structure manipulation.
        //
        
        clusterData.virtualIPs = clusterData.hosts[hp.machineName].hp.nicInfo.ipsOnNic;
        clusterData.virtualSubnets = clusterData.hosts[hp.machineName].hp.nicInfo.subnetMasks;

        clusterData.hosts[hp.machineName] = hostData;

        clusterDataStore->push_back( clusterData );

    }

    // now we will verify whether the cluster is 
    // converged or there are mismatches.

    // rules for a converged cluster.
    // 
    // cluster properties which need to 
    // be same:
    // cluster ip
    // cluster subnet 
    // full internet name
    // cluster mode
    // remote Control Enabled.
    // 
    // host properties
    // host id has to be unique across hosts any 
    // number from 1-32 inclusive.
    //
    // port rules
    // equal load balanced port rules have to be same
    // disabled port rules have to be same.
    // unequal load balanced port rules can differ only in load.
    // single host port rules can differ in priority, which has to be 
    // unique across hosts for a specific port rule any number between 1-32.
    //
    // Each machine must have the cluster ip.
    //
    // Each machine must have the exactly same ips on the nic.

    clusterPropertiesMatched = true;

    // check if cluster ip is added.
    //
    if( find( (*clusterDataStore)[0].virtualIPs.begin(),
              (*clusterDataStore)[0].virtualIPs.end(),
              (*clusterDataStore)[0].cp.cIP ) == (*clusterDataStore)[0].virtualIPs.end() )
    {
        clusterPropertiesMatched = false;
    }

    if( clusterDataStore->size() == 1 )
    {
        // only one host in cluster so only
        return CommonNLB_SUCCESS;
    }
    
    // sort the virtual ips of the first node.  Eases
    // comparision.
    sort( (*clusterDataStore)[0].virtualIPs.begin(),
          (*clusterDataStore)[0].virtualIPs.end() );

    for( int i = 1; i < clusterDataStore->size(); ++i )
    {
        // cluster properties must match.
        //

        if( (*clusterDataStore)[0].cp 
            != 
            (*clusterDataStore)[i].cp )
        {
            // mismatch in cluster properties.
            // MISMATCH
            clusterPropertiesMatched = false;
        }

        // the ELB, ULB, F, D port rules have to
        // match.
        if ( (*clusterDataStore)[0].portELB.size() 
             !=
             (*clusterDataStore)[i].portELB.size() )
        {
            // mismatch in port rules.
            // MISMATCH
            clusterPropertiesMatched = false;
        }
        else
        {
            // number of port rules are matching.
            map<long, PortDataELB>::iterator top;
            map<long, PortDataELB>::iterator location;            
            for( top = (*clusterDataStore)[i].portELB.begin();
                 top != (*clusterDataStore)[i].portELB.end();
                 ++top )
            {
                location = (*clusterDataStore)[0].portELB.find( (*top).first );
                if( location == (*clusterDataStore)[0].portELB.end() )
                {
                    // no such port exists.
                    // thus mismatch.
                    // MISMATCH
                    clusterPropertiesMatched = false;
                }
                else
                {
                    if( (*location).second._startPort != (*top).second._startPort 
                        ||
                        (*location).second._endPort != (*top).second._endPort 
                        ||
                        (*location).second._trafficToHandle != (*top).second._trafficToHandle
                        ||
                        (*location).second._affinity != (*top).second._affinity
                        )
                    {
                        // things other than key which is start port 
                        // has been modified.
                        // MISMATCH
                    }
                }
            }
        }

        if ( (*clusterDataStore)[0].portULB.size() 
             !=
             (*clusterDataStore)[i].portULB.size() )
        {
            // mismatch in port rules.
            // MISMATCH
            clusterPropertiesMatched = false;
        }
        else
        {
            // number of port rules are matching.
            map<long, PortDataULB>::iterator top;
            map<long, PortDataULB>::iterator location;            
            for( top = (*clusterDataStore)[i].portULB.begin();
                 top != (*clusterDataStore)[i].portULB.end();
                 ++top )
            {
                location = (*clusterDataStore)[0].portULB.find( (*top).first );
                if( location == (*clusterDataStore)[0].portULB.end() )
                {
                    // no such port exists.
                    // thus mismatch.
                    // MISMATCH
                    clusterPropertiesMatched = false;
                }
                else
                {
                    if( (*location).second._startPort != (*top).second._startPort 
                        ||
                        (*location).second._endPort != (*top).second._endPort 
                        ||
                        (*location).second._trafficToHandle != (*top).second._trafficToHandle
                        ||
                        (*location).second._affinity != (*top).second._affinity
                        )
                    {
                        // things other than key which is start port 
                        // has been modified.
                        // MISMATCH
                        clusterPropertiesMatched = false;
                    }
                }
            }

        }

        if ( (*clusterDataStore)[0].portF.size() 
             !=
             (*clusterDataStore)[i].portF.size() )
        {
            // mismatch in port rules.
            // MISMATCH
            clusterPropertiesMatched = false;
        }
        else
        {
            // number of port rules are matching.
            map<long, PortDataF>::iterator top;
            map<long, PortDataF>::iterator location;            
            for( top = (*clusterDataStore)[i].portF.begin();
                 top != (*clusterDataStore)[i].portF.end();
                 ++top )
            {
                location = (*clusterDataStore)[0].portF.find( (*top).first );
                if( location == (*clusterDataStore)[0].portF.end() )
                {
                    // no such port exists.
                    // thus mismatch.
                    // MISMATCH
                    clusterPropertiesMatched = false;
                }
                else
                {
                    if( (*location).second._startPort != (*top).second._startPort 
                        ||
                        (*location).second._endPort != (*top).second._endPort 
                        ||
                        (*location).second._trafficToHandle != (*top).second._trafficToHandle
                        )
                    {
                        // things other than key which is start port 
                        // has been modified.
                        // MISMATCH
                        clusterPropertiesMatched = false;
                    }
                }
            }
        }

        if ( (*clusterDataStore)[0].portD.size() 
             !=
             (*clusterDataStore)[i].portD.size() )
        {
            // mismatch in port rules.
            // MISMATCH
            clusterPropertiesMatched = false;
        }
        else
        {
            // number of port rules are matching.
            map<long, PortDataD>::iterator top;
            map<long, PortDataD>::iterator location;            
            for( top = (*clusterDataStore)[i].portD.begin();
                 top != (*clusterDataStore)[i].portD.end();
                 ++top )
            {
                location = (*clusterDataStore)[0].portD.find( (*top).first );
                if( location == (*clusterDataStore)[0].portD.end() )
                {
                    // no such port exists.
                    // thus mismatch.
                    // MISMATCH
                    clusterPropertiesMatched = false;
                }
                else
                {
                    if( (*location).second._startPort != (*top).second._startPort 
                        ||
                        (*location).second._endPort != (*top).second._endPort 
                        ||
                        (*location).second._trafficToHandle != (*top).second._trafficToHandle
                        )
                    {
                        // things other than key which is start port 
                        // has been modified.
                        // MISMATCH
                        clusterPropertiesMatched = false;
                    }
                }
            }
        }


        // check if each machine has the same virtual ips.
        //
        sort( (*clusterDataStore)[i].virtualIPs.begin(),
              (*clusterDataStore)[i].virtualIPs.end() );

        if( (*clusterDataStore)[0].virtualIPs
            != 
            (*clusterDataStore)[i].virtualIPs )
        {
            // MISMATCH
            clusterPropertiesMatched = false;
        }
    }

    // check if host ids are duplicate.
    map< _bstr_t, HostData>::iterator  onlyHost;    
    set<int> hostIDS;

    for( int i = 0; i < clusterDataStore->size(); ++i )    
    {
        onlyHost = (*clusterDataStore)[i].hosts.begin();

        // check if this host id has been used previously.
        if( hostIDS.find( (*onlyHost).second.hp.hID ) == hostIDS.end() )
        {
            // host id is unused.
            hostIDS.insert( (*onlyHost).second.hp.hID );
        }
        else
        {
            // host id has been used previously. 
            // Thus this is duplicate.
            // MISMATCH
            clusterPropertiesMatched = false;
        }
    }

    if( clusterPropertiesMatched == true )
    {
        // combine all the host information.
        //
        map<_bstr_t, HostData >::iterator top;
        for( int i = 1; i < clusterDataStore->size(); ++i )
        {
            top = (*clusterDataStore)[i].hosts.begin();

            (*clusterDataStore)[0].hosts[ (*top).first ] = (*top).second;
        }

#if 1
        // combine all the port information for ULB and disabled port rules.
        // this may be a little difficult, but it works.  Don't fiddle around
        // with this part.
        map<long, PortDataULB>::iterator topULB;        
        for( topULB = (*clusterDataStore)[0].portULB.begin();
             topULB != (*clusterDataStore)[0].portULB.end();
             ++topULB )
        {
            map<_bstr_t, long>& ref = (*topULB).second.machineMapToLoadWeight;
            
            for( int i = 1; i < clusterDataStore->size(); ++i )
            {
                // find the machine name for this clusterdata.
                map<_bstr_t, HostData>::iterator top;

                top = (*clusterDataStore)[i].hosts.begin();

                _bstr_t machineName = (*top).first;

                ref[machineName] = 
                    (*clusterDataStore)[i].portULB[ (*topULB).first ].machineMapToLoadWeight[ machineName];
            }
        }

        map<long, PortDataF>::iterator topF;        
        for( topF = (*clusterDataStore)[0].portF.begin();
             topF != (*clusterDataStore)[0].portF.end();
             ++topF )
        {
            map<_bstr_t, long>& ref = (*topF).second.machineMapToPriority;
            
            for( int i = 1; i < clusterDataStore->size(); ++i )
            {
                // find the machine name for this clusterdata.
                map<_bstr_t, HostData>::iterator top;

                top = (*clusterDataStore)[i].hosts.begin();

                _bstr_t machineName = (*top).first;

                ref[machineName] = 
                    (*clusterDataStore)[i].portF[ (*topF).first ].machineMapToPriority[ machineName];
            }
        }

#endif

    }

    return CommonNLB_SUCCESS;
}
    

CommonNLB::CommonNLB_Error
CommonNLB::connectToClusterIndirect( const _bstr_t&          clusterIP,
                                     const vector<_bstr_t>&  connectionIPS,
                                     ClusterData*            p_clusterData,
                                     DataSinkI*              dataSinkObj )
{
    // connect to each host.  
    // We are doing it here so that if there are any connectivity issues
    // we do not proceed with any further operation and ask user to
    // fix all issues before proceeding. 

    // connect to each host.
    map< bstr_t, auto_ptr<MNLBMachine> > nlbMachine;

    for( int i = 0; i < connectionIPS.size(); ++i )
    {
        dataSinkObj->dataSink( 
            GETRESOURCEIDSTRING( IDS_INFO_CONNECTING) + connectionIPS[i] );


        auto_ptr<MNLBMachine> p_nlbMachine = 
            auto_ptr<MNLBMachine> ( new MNLBMachine( connectionIPS[i],
                                                     clusterIP ) );
        nlbMachine[connectionIPS[i] ] = p_nlbMachine;

        dataSinkObj->dataSink( 
            GETRESOURCEIDSTRING( IDS_INFO_DONE) );
    }

    // rules for a converged cluster.
    // 
    // cluster properties which need to 
    // be same:
    // cluster ip
    // cluster subnet 
    // full internet name
    // cluster mode
    // 
    // host properties
    // host id has to be unique across hosts any 
    // number from 1-32 inclusive.
    //
    // port rules
    // equal load balanced port rules have to be same
    // disabled port rules have to be same.
    // unequal load balanced port rules can differ only in load.
    // single host port rules can differ in priority, which has to be 
    // unique across hosts for a specific port rule any number between 1-32.
    //

    
    for( int i = 0; i < connectionIPS.size(); ++i )
    {
        
        // get cluster properties.
        // cluster properties need to be got only for one host.
        if( i == 0 )
        {
            dataSinkObj->dataSink( 
                GETRESOURCEIDSTRING( IDS_INFO_FINDING_CL_P ) );

            ClusterProperties cp;

            nlbMachine[connectionIPS[i] ]->getClusterProperties( &cp );

            p_clusterData->cp = cp;

            dataSinkObj->dataSink( 
                GETRESOURCEIDSTRING( IDS_INFO_DONE) );

        }

        // get host properties.
        dataSinkObj->dataSink( 
            GETRESOURCEIDSTRING( IDS_INFO_FINDING_H_P ) );

        HostProperties hp;

        nlbMachine[connectionIPS[i] ]->getHostProperties( &hp );

        dataSinkObj->dataSink( 
            GETRESOURCEIDSTRING( IDS_INFO_DONE) );

        // set the host properties
        HostData hostData;

        hostData.hp = hp;

        // set the connection ip.
        hostData.connectionIP = connectionIPS[i];

        p_clusterData->hosts[hp.machineName] = hostData;

        // get port rules
        dataSinkObj->dataSink( 
            GETRESOURCEIDSTRING( IDS_INFO_FINDING_P ) );


        vector<MNLBPortRuleLoadBalanced> portsLB;
        vector<MNLBPortRuleFailover> portsF;
        vector<MNLBPortRuleDisabled> portsD;

        PortDataULB ulbPortRule;

        PortDataF fPortRule;

        PortDataELB elbPortRule;

        PortDataD dPortRule;

        nlbMachine[connectionIPS[i] ]->getPortRulesLoadBalanced( &portsLB );
        for( int j = 0; j < portsLB.size(); ++j )
        {
            if( portsLB[j]._isEqualLoadBalanced == true )
            {
                // equal load balanced port rule.
                elbPortRule._startPort = portsLB[j]._startPort;
                elbPortRule._key = portsLB[j]._startPort;
                elbPortRule._endPort   = portsLB[j]._endPort;
                elbPortRule._trafficToHandle   = portsLB[j]._trafficToHandle;
                elbPortRule._affinity   = portsLB[j]._affinity;

                p_clusterData->portELB[portsLB[j]._startPort] = elbPortRule;
            }
            else
            {
                // unequal load balanced.
                if( i == 0 )
                {
                    ulbPortRule._startPort = portsLB[j]._startPort;
                    ulbPortRule._key = portsLB[j]._startPort;
                    ulbPortRule._endPort   = portsLB[j]._endPort;
                    ulbPortRule._trafficToHandle   = portsLB[j]._trafficToHandle;
                    ulbPortRule._affinity   = portsLB[j]._affinity;

                    ulbPortRule.machineMapToLoadWeight[hp.machineName]  = portsLB[j]._load;

                    p_clusterData->portULB[portsLB[j]._startPort] = ulbPortRule;
                }
                else
                {
                    p_clusterData->portULB[portsLB[j]._startPort].machineMapToLoadWeight[ hp.machineName]  = portsLB[j]._load;
                }
            }
        }
        portsLB.erase( portsLB.begin(), portsLB.end() );

        nlbMachine[connectionIPS[i] ]->getPortRulesFailover( &portsF );
        for( int j = 0; j < portsF.size(); ++j )
        {
            if( i == 0 )
            {
                fPortRule._startPort = portsF[j]._startPort;
                fPortRule._key = portsF[j]._startPort;
                fPortRule._endPort   = portsF[j]._endPort;
                fPortRule._trafficToHandle   = portsF[j]._trafficToHandle;

                fPortRule.machineMapToPriority[ hp.machineName] = portsF[j]._priority;
                
                p_clusterData->portF[portsF[j]._startPort] = fPortRule;
            }
            else
            {
                p_clusterData->portF[portsF[j]._startPort].machineMapToPriority[ hp.machineName]  = portsF[j]._priority;
            }
        }
        portsF.erase( portsF.begin(), portsF.end() );

        // disabled need to be got only once.
        if( i == 0 )
        {
            nlbMachine[connectionIPS[i] ]->getPortRulesDisabled( &portsD );

            for( int j = 0; j < portsD.size(); ++j )
            {
                dPortRule._startPort = portsD[j]._startPort;
                dPortRule._key = portsD[j]._startPort;
                dPortRule._endPort   = portsD[j]._endPort;
                dPortRule._trafficToHandle   = portsD[j]._trafficToHandle;

                p_clusterData->portD[portsD[j]._startPort] = dPortRule;
            }
            portsD.erase( portsD.begin(), portsD.end() );
        }

        dataSinkObj->dataSink( 
            GETRESOURCEIDSTRING( IDS_INFO_DONE) );
    }

    dataSinkObj->dataSink( 
        GETRESOURCEIDSTRING( IDS_INFO_SUCCESS ) );

    return CommonNLB_SUCCESS;
}

CommonNLB::CommonNLB_Error
CommonNLB::connectToMachine( 
    const _bstr_t&                             machineToConnect,
    _bstr_t&                                   machineServerName,
    vector< CommonNLB::NicNLBBound >&          nicList,
    DataSinkI*                                 dataSinkObj )
{
    // connect to machine.
    //
    MWmiObject machine( machineToConnect,
                        L"root\\microsoftnlb",
                        L"administrator",
                        L"" );

    // find all nics on machine.
    //
    vector<MWmiInstance> instanceStore;
    machine.getInstances( L"NlbsNic",
                          &instanceStore );

    // check if nic has nlb bound.
    //
    // input parameters are none.
    //
    vector<MWmiParameter *> inputParameters;

    //  output parameters which are of interest.
    //
    vector<MWmiParameter *> outputParameters;
    MWmiParameter    ReturnValue(L"ReturnValue");
    outputParameters.push_back( &ReturnValue );

    vector<MWmiParameter *> parameterStore;

    MWmiParameter Server(L"__Server");
    parameterStore.push_back( &Server );

    MWmiParameter FullName(L"FullName");
    parameterStore.push_back( &FullName );

    MWmiParameter AdapterGuid(L"AdapterGuid");
    parameterStore.push_back( &AdapterGuid );

    MWmiParameter FriendlyName(L"FriendlyName");
    parameterStore.push_back( &FriendlyName );

    for( int i = 0; i < instanceStore.size(); ++i )
    {
        // get full name, guid and friendly name.
        //
        NicNLBBound temp;

        instanceStore[i].getParameters( parameterStore );
        temp.fullNicName = FullName.getValue();
        temp.adapterGuid = AdapterGuid.getValue();
        temp.friendlyName = FriendlyName.getValue();

        // get machine name.
        machineServerName = Server.getValue();

        // check if nic is bound to nlb or not.
        instanceStore[i].runMethod( L"isBound",
                                    inputParameters, 
                                    outputParameters );
        if( long( ReturnValue.getValue() ) == 1 )
        {
            // this nic is bound.
            temp.isBoundToNLB = true;
        }
        else
        {
            temp.isBoundToNLB = false;
        }

        // get all the ip's on this nic.
        MIPAddressAdmin ipAdmin( machineToConnect,
                                 temp.fullNicName );

        ipAdmin.getIPAddresses( &temp.ipsOnNic,
                                &temp.subnetMasks );

        // check if the nic is dhcp.
        ipAdmin.isDHCPEnabled( temp.dhcpEnabled );
                                 
        nicList.push_back( temp );
    }

    return CommonNLB_SUCCESS;
}
    

CommonNLB::CommonNLB_Error
CommonNLB::changeNLBClusterSettings( const ClusterData*        oldSettings,
                                     const ClusterData*        newSettings,
                                     DataSinkI*                dataSinkObj )
{
    return CommonNLB_SUCCESS;
}

CommonNLB::CommonNLB_Error
CommonNLB::changeNLBHostSettings( const ClusterData*        oldSettings,
                                  const ClusterData*        newSettings,
                                  const _bstr_t&            machineName,
                                  DataSinkI*                dataSinkObj )
{
    ClusterData* oldSettingsCopy = const_cast <ClusterData *>( oldSettings );
    ClusterData* newSettingsCopy = const_cast <ClusterData *>( newSettings );

    map<_bstr_t, HostData>::iterator topOld;
    map<_bstr_t, HostData>::iterator topNew;

    // change host properties for  host if that have changed.
    //
    if( oldSettingsCopy->hosts[machineName].hp
        != 
        newSettingsCopy->hosts[machineName].hp )
    {
        // connect to machine.
        //
        dataSinkObj->dataSink( 
            GETRESOURCEIDSTRING( IDS_INFO_CONNECTING ) + 
            oldSettingsCopy->hosts[machineName].connectionIP );

        MNLBMachine nlbMachine( 
            oldSettingsCopy->hosts[machineName].connectionIP,
            oldSettingsCopy->cp.cIP );
        
        dataSinkObj->dataSink( 
            GETRESOURCEIDSTRING( IDS_INFO_DONE) );
        
        dataSinkObj->dataSink( 
            GETRESOURCEIDSTRING( IDS_INFO_MODIFYING_H_P ) );

        // host properties have changed.
        unsigned long returnValue;
        nlbMachine.setHostProperties( newSettingsCopy->hosts[machineName].hp,
                                      &returnValue );

        dataSinkObj->dataSink( 
            GETRESOURCEIDSTRING( IDS_INFO_DONE) );
    }

    return CommonNLB_SUCCESS;
}


CommonNLB::CommonNLB_Error
CommonNLB::changeNLBHostPortSettings( const ClusterData*        oldSettings,
                                      const ClusterData*        newSettings,
                                      const _bstr_t&            machineName,
                                      DataSinkI*                dataSinkObj )
{
    ClusterData* oldSettingsCopy = const_cast <ClusterData *>( oldSettings );
    ClusterData* newSettingsCopy = const_cast <ClusterData *>( newSettings );

    map<_bstr_t, HostData>::iterator topOld;
    map<_bstr_t, HostData>::iterator topNew;

    // connect to machine.
    //
    dataSinkObj->dataSink( 
        GETRESOURCEIDSTRING( IDS_INFO_CONNECTING ) + 
        oldSettingsCopy->hosts[machineName].connectionIP );

    MNLBMachine nlbMachine( 
        oldSettingsCopy->hosts[machineName].connectionIP,
        oldSettingsCopy->cp.cIP );

    dataSinkObj->dataSink( 
        GETRESOURCEIDSTRING( IDS_INFO_DONE ) );


    // check if any load weights have changed.
    // for any unequal load balanced port rule.
    //
    map<long, PortDataULB>::iterator topOldULB;    
    map<long, PortDataULB>::iterator topNewULB;    

    for( topOldULB = oldSettingsCopy->portULB.begin(), 
             topNewULB = newSettingsCopy->portULB.begin();
         topOldULB != oldSettingsCopy->portULB.end();
         ++topOldULB, ++topNewULB )
    {
        if( (*topOldULB).second.machineMapToLoadWeight[machineName]
            !=
            (*topNewULB).second.machineMapToLoadWeight[machineName] 
            )
        {
            dataSinkObj->dataSink( 
                GETRESOURCEIDSTRING( IDS_INFO_MODIFYING_P_ULB ) );

            // load weight has changed.

            // remove old port rule
            MNLBPortRuleLoadBalanced portULB = (*topNewULB).second;
            portULB._load = 
                (*topOldULB).second.machineMapToLoadWeight[machineName];

            nlbMachine.removePortRuleLoadBalanced( portULB );

            // add this port rule.

            // only load weight can change.
            portULB._load = 
                (*topNewULB).second.machineMapToLoadWeight[machineName];

            nlbMachine.addPortRuleLoadBalanced( portULB );

            dataSinkObj->dataSink( 
                GETRESOURCEIDSTRING( IDS_INFO_DONE ) );
        }
    }

    // check if any priorities have changed.
    // for any failover port rules
    //
    map<long, PortDataF>::iterator topOldF;    
    map<long, PortDataF>::iterator topNewF;    

    for( topOldF = oldSettingsCopy->portF.begin(), 
             topNewF = newSettingsCopy->portF.begin();
         topOldF != oldSettingsCopy->portF.end();
         ++topOldF, ++topNewF )
    {
        if( (*topOldF).second.machineMapToPriority[machineName]
            !=
            (*topNewF).second.machineMapToPriority[machineName] 
            )
        {
            dataSinkObj->dataSink( 
                GETRESOURCEIDSTRING( IDS_INFO_MODIFYING_P_F ) );

            // priority has changed.

            MNLBMachine nlbMachine( 
                newSettingsCopy->hosts[machineName].connectionIP,
                newSettingsCopy->cp.cIP );

            // remove old port rule
            MNLBPortRuleFailover portF = (*topNewF).second;
            portF._priority = 
                (*topOldF).second.machineMapToPriority[machineName];

            nlbMachine.removePortRuleFailover( portF );

            // add new port rule.

            // only priority has changed.
            portF._priority = 
                (*topNewF).second.machineMapToPriority[machineName];

            nlbMachine.addPortRuleFailover( portF );

            dataSinkObj->dataSink( 
                GETRESOURCEIDSTRING( IDS_INFO_DONE ) );
        }
    }

    return CommonNLB_SUCCESS;
}


CommonNLB::CommonNLB_Error
CommonNLB::changeNLBClusterAndPortSettings( const ClusterData*        oldSettings,
                                            const ClusterData*        newSettings,
                                            DataSinkI*                dataSinkObj,
                                            bool*                     pbClusterIpChanged)
{
    ClusterData* oldSettingsCopy = const_cast <ClusterData *>( oldSettings );
    ClusterData* newSettingsCopy = const_cast <ClusterData *>( newSettings );
    bool         bClusterParametersChanged, bPortRulesChanged, bOnlyClusterNameChanged;

    // Find out if the cluster parameters have changed. Also, find if the cluster name
    // is the only parameter that has changed
    bClusterParametersChanged = newSettingsCopy->cp.HaveClusterPropertiesChanged(oldSettingsCopy->cp, 
                                                                                 &bOnlyClusterNameChanged,
                                                                                 pbClusterIpChanged);
    vector<long> rulesAddedELB;
    vector<long> rulesUnchangedELB;
    vector<long> rulesRemovedELB;

    findPortRulesAddedUnchangedRemovedELB( oldSettingsCopy,
                                           newSettingsCopy,
                                           dataSinkObj,
                                           rulesAddedELB,
                                           rulesUnchangedELB,
                                           rulesRemovedELB );


    vector<long> rulesAddedULB;
    vector<long> rulesUnchangedULB;
    vector<long> rulesRemovedULB;

    findPortRulesAddedUnchangedRemovedULB( oldSettingsCopy,
                                           newSettingsCopy,
                                           dataSinkObj,
                                           rulesAddedULB,
                                           rulesUnchangedULB,
                                           rulesRemovedULB );


    vector<long> rulesAddedD;
    vector<long> rulesUnchangedD;
    vector<long> rulesRemovedD;

    findPortRulesAddedUnchangedRemovedD( oldSettingsCopy,
                                         newSettingsCopy,
                                         dataSinkObj,
                                         rulesAddedD,
                                         rulesUnchangedD,
                                         rulesRemovedD );


    vector<long> rulesAddedF;
    vector<long> rulesUnchangedF;
    vector<long> rulesRemovedF;

    findPortRulesAddedUnchangedRemovedF( oldSettingsCopy,
                                         newSettingsCopy,
                                         dataSinkObj,
                                         rulesAddedF,
                                         rulesUnchangedF,
                                         rulesRemovedF );

    // check if any port rules have been added or removed 
    // if not we don't want to do anything.
    if(
        ( rulesAddedULB.size() == 0 )
        &&
        ( rulesRemovedULB.size() == 0 )
        &&
        ( rulesAddedELB.size() == 0 )
        &&
        ( rulesRemovedELB.size() == 0 )
        &&
        ( rulesAddedD.size() == 0 )
        &&
        ( rulesRemovedD.size() == 0 )
        &&
        ( rulesAddedF.size() == 0 )
        &&
        ( rulesRemovedF.size() == 0 )
        )
    {
        //return CommonNLB_SUCCESS;
        //OutputDebugString(_T("No Change to Port Rules\n"));
        bPortRulesChanged = false;
    }
    else
    {
        bPortRulesChanged = true;
    }

    // Neither the cluster parameters nor the port rules have changed, so return
    if (!bClusterParametersChanged && !bPortRulesChanged)
    {
        //OutputDebugString(_T("No Change to Cluster Parameters or Port Rules\n"));
        return CommonNLB_SUCCESS;
    }

    // connect to each host.  
    // We are doing it here so that if there are any connectivity issues
    // we do not proceed with any changes and just inform the user.
    // This is to ensure that we do not cause any convergence.  

    // connect to each host.
    map<_bstr_t, HostData >::iterator top;
    map< bstr_t, auto_ptr<MNLBMachine> > nlbMachine;

    for( top = oldSettingsCopy->hosts.begin();
         top != oldSettingsCopy->hosts.end();
         ++top )
    {
        dataSinkObj->dataSink( 
            GETRESOURCEIDSTRING( IDS_INFO_CONNECTING ) 
            + (*top).second.connectionIP );

        auto_ptr<MNLBMachine> p_nlbMachine = 
            auto_ptr<MNLBMachine> ( new MNLBMachine( (*top).second.connectionIP,
                                                     oldSettingsCopy->cp.cIP ) );
        nlbMachine[(*top).first] = p_nlbMachine;

        dataSinkObj->dataSink( 
            GETRESOURCEIDSTRING( IDS_INFO_DONE ) );

    }

    // for each host in cluster apply the changed port & cluster rules.
    for( top = oldSettingsCopy->hosts.begin();
         top != oldSettingsCopy->hosts.end();
         ++top )
    {
        if (bPortRulesChanged)
        {
            dataSinkObj->dataSink( 
                GETRESOURCEIDSTRING( IDS_INFO_MODIFYING_P ) );

            // remove all port rules which need to be erased.. 
            //
            for( int i = 0; i < rulesRemovedELB.size(); ++i )
            {
                nlbMachine[ (*top).first ]->removePortRuleLoadBalanced( oldSettingsCopy->portELB[ rulesRemovedELB[i] ] );
            }

            for( int i = 0; i < rulesRemovedULB.size(); ++i )
            {
                nlbMachine[ (*top).first ]->removePortRuleLoadBalanced( oldSettingsCopy->portULB[ rulesRemovedULB[i] ] );
            }

            for( int i = 0; i < rulesRemovedD.size(); ++i )
            {
                nlbMachine[ (*top).first ]->removePortRuleDisabled( oldSettingsCopy->portD[ rulesRemovedD[i] ] );
            }

            for( int i = 0; i < rulesRemovedF.size(); ++i )
            {
                nlbMachine[ (*top).first ]->removePortRuleFailover( oldSettingsCopy->portF[rulesRemovedF[i] ] );
            }

            // add all new port rules
            //
            for( int i = 0; i < rulesAddedELB.size(); ++i )
            {
                nlbMachine[ (*top).first ]->addPortRuleLoadBalanced( newSettingsCopy->portELB[ rulesAddedELB[i] ] );
            }
            
            for( int i = 0; i < rulesAddedULB.size(); ++i )
            {
                MNLBPortRuleLoadBalanced portULB =  newSettingsCopy->portULB[ rulesAddedULB[i] ];

                _bstr_t machineName = (*top).first;

                portULB._load = 
                    newSettingsCopy->portULB[rulesAddedULB[i]].machineMapToLoadWeight[ (*top).first ]; 
                nlbMachine[ (*top).first ]->addPortRuleLoadBalanced( portULB );
            }

            for( int i = 0; i < rulesAddedD.size(); ++i )
            {
                nlbMachine[ (*top).first ]->addPortRuleDisabled( newSettingsCopy->portD[rulesAddedD[i] ] );
            }

            for( int i = 0; i < rulesAddedF.size(); ++i )
            {
                MNLBPortRuleFailover portF =  newSettingsCopy->portF[rulesAddedF[i] ];
                
                portF._priority = 
                newSettingsCopy->portF[rulesAddedF[i]].machineMapToPriority[ (*top).first ];
            
                nlbMachine[ (*top).first ]->addPortRuleFailover( portF );
            }
            dataSinkObj->dataSink( 
                GETRESOURCEIDSTRING( IDS_INFO_DONE ) );
        }
        if (bClusterParametersChanged)
        {
            if (bOnlyClusterNameChanged)
            {
                unsigned long retVal;
                dataSinkObj->dataSink( 
                    GETRESOURCEIDSTRING( IDS_INFO_MODIFYING_CN ) );
                nlbMachine[ (*top).first ]->setClusterProperties(newSettingsCopy->cp, &retVal);

                // if remote control is enabled set the password.
                // even if password has not changed just making extra call.
                if( newSettingsCopy->cp.remoteControlEnabled == true )
                {
                    nlbMachine[ (*top).first ]->setPassword(newSettingsCopy->cp.password, &retVal);                
                }

            }
            else // Cluster Parameters other than Cluster name have changed too
            {
                dataSinkObj->dataSink( 
                    GETRESOURCEIDSTRING( IDS_INFO_REMOVING_CL_IP ) );
                MNLBNetCfg nlbNetCfg((*top).second.connectionIP, (*top).second.hp.nicInfo.fullNicName);
                nlbNetCfg.removeClusterIP(oldSettingsCopy->cp.cIP);
            }
            dataSinkObj->dataSink( 
                GETRESOURCEIDSTRING( IDS_INFO_DONE ) );
        }
    }

    // If Cluster Paraters other than the Cluster Name has changed, call the NLB Manager 
    // provider's "ModifyClusterProperties" (eventually) to modify cluster properties
    // and add the cluster ip to tcp/ip. Modification of the cluster properties will 
    // result in the disable/re-enable of the nic & hence the WMI DCOM connection might 
    // be lost. So, we are doing this two-step operation locally 
    
    if (bClusterParametersChanged && !bOnlyClusterNameChanged)
    {
        for( top = oldSettingsCopy->hosts.begin();
             top != oldSettingsCopy->hosts.end();
             ++top )
        {
            //OutputDebugString(_T("Modifying Cluster Parameters and adding cluster ip to tcp-ip !!!\n"));
            dataSinkObj->dataSink( 
                GETRESOURCEIDSTRING( IDS_INFO_MODIFYING_CP_AND_ADD_IP ) );

            MNLBNetCfg* p_nlbNetCfg = NULL;
            ModifyClusterPropertiesParameters* par = NULL;
            try {
                p_nlbNetCfg = new MNLBNetCfg((*top).second.connectionIP, (*top).second.hp.nicInfo.fullNicName);

                par = new ModifyClusterPropertiesParameters;

                par->nlbNetCfg = p_nlbNetCfg;

                par->clusterData = NULL;
                par->clusterData = new ClusterData( *newSettingsCopy );
                
                par->machineName = new _bstr_t( (*top).second.hp.machineName );
                g_leftView = (LeftView *) dataSinkObj;

            }
            catch(...)
            {
                delete  par->clusterData;
                delete  par;
                delete  p_nlbNetCfg;

                dataSinkObj->dataSink(GETRESOURCEIDSTRING(IDS_INFO_NEW_EXCEPTION));
                throw;
            }

            AfxBeginThread( (AFX_THREADPROC) ModifyClusterPropertiesThread, par );

            dataSinkObj->dataSink( 
                GETRESOURCEIDSTRING( IDS_INFO_DONE ) );
        }
    }
        
    return CommonNLB_SUCCESS;
}

CommonNLB::CommonNLB_Error
CommonNLB::findPortRulesAddedUnchangedRemovedELB( 
    const ClusterData*        oldSettings,
    const ClusterData*        newSettings,
    DataSinkI*                dataSinkObj,
    vector<long>&             rulesAdded,
    vector<long>&             rulesUnchanged,
    vector<long>&             rulesRemoved )
{
    map<long, PortDataELB>::iterator top;
    map<long, PortDataELB>::iterator location;

    // find ports which have been newly added or modified.
    //
    for( top = newSettings->portELB.begin();
         top != newSettings->portELB.end();
         ++top )
    {
        rulesAdded.push_back( (*top).first );
    }
    
    // find ports which have remain unchanged and ports which have 
    // been removed or modified.
    for( top = oldSettings->portELB.begin();
         top != oldSettings->portELB.end();
         ++top )
    {
        // check if this port rule has been removed or modified.
        location = newSettings->portELB.find( (*top).first ); 
        if( location == newSettings->portELB.end() )
        {
            // key has been removed
            rulesRemoved.push_back( (*top).first );
        }
        else
        {
            // may be things other than key are modified or totally
            // unchanged.
            if( (*location).second == (*top).second )
            {
                // totally unchanged
                rulesUnchanged.push_back( (*top).first );
                rulesAdded.erase (find( rulesAdded.begin(), 
                                        rulesAdded.end(), 
                                        (*top).first ) );
                
            }
            else
            {
                // key is same but the other parts are modified.
                rulesRemoved.push_back( (*top).first );
            }
        }
    }

    return CommonNLB_SUCCESS;
}

CommonNLB::CommonNLB_Error
CommonNLB::findPortRulesAddedUnchangedRemovedULB( 
    const ClusterData*        oldSettings,
    const ClusterData*        newSettings,
    DataSinkI*                dataSinkObj,
    vector<long>&             rulesAdded,
    vector<long>&             rulesUnchanged,
    vector<long>&             rulesRemoved )
{
    map<long, PortDataULB>::iterator top;
    map<long, PortDataULB>::iterator location;

    // find ports which have been newly added or modified.
    //
    for( top = newSettings->portULB.begin();
         top != newSettings->portULB.end();
         ++top )
    {
        rulesAdded.push_back( (*top).first );
    }
    
    // find ports which have remain unchanged and ports which have 
    // been removed or modified.
    for( top = oldSettings->portULB.begin();
         top != oldSettings->portULB.end();
         ++top )
    {
        // check if this port rule has been removed or modified.
        location = newSettings->portULB.find( (*top).first ); 
        if( location == newSettings->portULB.end() )
        {
            // key has been removed
            rulesRemoved.push_back( (*top).first );
        }
        else
        {
            // may be things other than key are modified or totally
            // unchanged.
            if( (*location).second == (*top).second )
            {
                // totally unchanged
                rulesUnchanged.push_back( (*top).first );
                rulesAdded.erase (find( rulesAdded.begin(), 
                                        rulesAdded.end(), 
                                        (*top).first ) );
                
            }
            else
            {
                // key is same but the other parts are modified.
                rulesRemoved.push_back( (*top).first );
            }
        }
    }

    return CommonNLB_SUCCESS;
}

CommonNLB::CommonNLB_Error
CommonNLB::findPortRulesAddedUnchangedRemovedD( 
    const ClusterData*        oldSettings,
    const ClusterData*        newSettings,
    DataSinkI*                dataSinkObj,
    vector<long>&             rulesAdded,
    vector<long>&             rulesUnchanged,
    vector<long>&             rulesRemoved )
{
    map<long, PortDataD>::iterator top;
    map<long, PortDataD>::iterator location;

    // find ports which have been newly added or modified.
    //
    for( top = newSettings->portD.begin();
         top != newSettings->portD.end();
         ++top )
    {
        rulesAdded.push_back( (*top).first );
    }
    
    // find ports which have remain unchanged and ports which have 
    // been removed or modified.
    for( top = oldSettings->portD.begin();
         top != oldSettings->portD.end();
         ++top )
    {
        // check if this port rule has been removed or modified.
        location = newSettings->portD.find( (*top).first ); 
        if( location == newSettings->portD.end() )
        {
            // key has been removed
            rulesRemoved.push_back( (*top).first );
        }
        else
        {
            // may be things other than key are modified or totally
            // unchanged.
            if( (*location).second == (*top).second )
            {
                // totally unchanged
                rulesUnchanged.push_back( (*top).first );
                rulesAdded.erase (find( rulesAdded.begin(), 
                                        rulesAdded.end(), 
                                        (*top).first ) );
                
            }
            else
            {
                // key is same but the other parts are modified.
                rulesRemoved.push_back( (*top).first );
            }
        }
    }

    return CommonNLB_SUCCESS;
}

CommonNLB::CommonNLB_Error
CommonNLB::findPortRulesAddedUnchangedRemovedF( 
    const ClusterData*        oldSettings,
    const ClusterData*        newSettings,
    DataSinkI*                dataSinkObj,
    vector<long>&             rulesAdded,
    vector<long>&             rulesUnchanged,
    vector<long>&             rulesRemoved )
{
    map<long, PortDataF>::iterator top;
    map<long, PortDataF>::iterator location;

    // find ports which have been newly added or modified.
    //
    for( top = newSettings->portF.begin();
         top != newSettings->portF.end();
         ++top )
    {
        rulesAdded.push_back( (*top).first );
    }
    
    // find ports which have remain unchanged and ports which have 
    // been removed or modified.
    for( top = oldSettings->portF.begin();
         top != oldSettings->portF.end();
         ++top )
    {
        // check if this port rule has been removed or modified.
        location = newSettings->portF.find( (*top).first ); 
        if( location == newSettings->portF.end() )
        {
            // key has been removed
            rulesRemoved.push_back( (*top).first );
        }
        else
        {
            // may be things other than key are modified or totally
            // unchanged.
            if( (*location).second == (*top).second )
            {
                // totally unchanged
                rulesUnchanged.push_back( (*top).first );
                rulesAdded.erase (find( rulesAdded.begin(), 
                                        rulesAdded.end(), 
                                        (*top).first ) );
                
            }
            else
            {
                // key is same but the other parts are modified.
                rulesRemoved.push_back( (*top).first );
            }
        }
    }

    return CommonNLB_SUCCESS;
}

CommonNLB::CommonNLB_Error
CommonNLB::removeCluster( const ClusterData* clusterSettings,
                          DataSinkI*         dataSinkObj )
{
    map<_bstr_t, HostData>::iterator top;

    for( top = clusterSettings->hosts.begin();
         top != clusterSettings->hosts.end();
         ++top )
    {
        removeHost( clusterSettings,
                    (*top).first,
                    dataSinkObj );
    }

    return CommonNLB_SUCCESS;
}

CommonNLB::CommonNLB_Error
CommonNLB::removeHost( const ClusterData* clusterSettings,
                       const _bstr_t&     machineName,
                       DataSinkI*         dataSinkObj )
{
    ClusterData* clusterSettingsCopy = 
        const_cast <ClusterData *>( clusterSettings );

    dataSinkObj->dataSink( 
        GETRESOURCEIDSTRING( IDS_INFO_CONNECTING ) 
        + clusterSettingsCopy->hosts[machineName].connectionIP );

    // note that we are not responsible for freeing this pointer
    // though if the removeClusterIP fails then we do need to free it.
    // TODO
    MNLBNetCfg* p_nlbNetCfg = new MNLBNetCfg( 
        clusterSettingsCopy->hosts[machineName].connectionIP,
        clusterSettingsCopy->hosts[machineName].hp.nicInfo.fullNicName
        );

    dataSinkObj->dataSink( 
        GETRESOURCEIDSTRING( IDS_INFO_DONE ) );
    
    dataSinkObj->dataSink( 
        GETRESOURCEIDSTRING( IDS_INFO_REMOVING_CL_IP ) + clusterSettingsCopy->cp.cIP );

    // remove cluster ip from machine specified.

    p_nlbNetCfg->removeClusterIP( 
        clusterSettingsCopy->cp.cIP );

    dataSinkObj->dataSink( 
        GETRESOURCEIDSTRING( IDS_INFO_DONE ) );

    dataSinkObj->dataSink( 
        GETRESOURCEIDSTRING( IDS_INFO_UNBINDING_NLB ) + clusterSettingsCopy->hosts[machineName].hp.nicInfo.fullNicName );

    AfxBeginThread( (AFX_THREADPROC ) UnbindThread,
                    p_nlbNetCfg );

    dataSinkObj->dataSink( 
        GETRESOURCEIDSTRING( IDS_INFO_REQUEST ) );

    return CommonNLB_SUCCESS;
}

CommonNLB::CommonNLB_Error
CommonNLB::runControlMethodOnCluster( const ClusterData* clusterSettings,
                                      DataSinkI*         dataSinkObj,
                                      const _bstr_t&     methodToRun,
                                      unsigned long      portToAffect )
{
    map<_bstr_t, HostData>::iterator top;

    for( top = clusterSettings->hosts.begin();
         top != clusterSettings->hosts.end();
         ++top )
    {
        runControlMethodOnHost( clusterSettings,
                                (*top).first,
                                dataSinkObj, 
                                methodToRun,
                                portToAffect );
    }

    return CommonNLB_SUCCESS;
}


CommonNLB::CommonNLB_Error
CommonNLB::runControlMethodOnHost( const ClusterData*       clusterSettings,
                                   const _bstr_t&           machineName,
                                   DataSinkI*               dataSinkObj,
                                   const _bstr_t&           methodToRun,
                                   unsigned long            portToAffect )
{
    ClusterData* clusterSettingsCopy = 
        const_cast <ClusterData *>( clusterSettings );

    dataSinkObj->dataSink( 
        GETRESOURCEIDSTRING( IDS_INFO_CONNECTING ) 
        + clusterSettingsCopy->hosts[machineName].connectionIP );


    MNLBMachine nlbMachine( 
        clusterSettingsCopy->hosts[machineName].connectionIP,
        clusterSettingsCopy->cp.cIP );        

    dataSinkObj->dataSink( 
        GETRESOURCEIDSTRING( IDS_INFO_DONE ) );

    unsigned long retVal;
    
    if( methodToRun == _bstr_t( L"query" ) )
    {
        dataSinkObj->dataSink( 
            GETRESOURCEIDSTRING( IDS_COMMAND_QUERY ) +  clusterSettingsCopy->cp.cIP + L":" + machineName );
        
        // the hoststatus has the current state of the host.
        HostProperties hp;
        nlbMachine.getHostProperties( &hp );
        retVal = hp.hostStatus;

    }
    else if( methodToRun == _bstr_t( L"start" ) )
    {
        dataSinkObj->dataSink( 
            GETRESOURCEIDSTRING( IDS_COMMAND_START ) +  clusterSettingsCopy->cp.cIP + L":" + machineName );

        nlbMachine.start( Common::THIS_HOST, &retVal );
    }
    else if( methodToRun == _bstr_t( L"stop" ) )
    {
        dataSinkObj->dataSink( 
            GETRESOURCEIDSTRING( IDS_COMMAND_STOP ) +  clusterSettingsCopy->cp.cIP + L":" + machineName );

        nlbMachine.stop( Common::THIS_HOST, &retVal );
    }
    else if( methodToRun == _bstr_t( L"drainstop" ) )
    {
        dataSinkObj->dataSink( 
            GETRESOURCEIDSTRING( IDS_COMMAND_DRAINSTOP ) +  clusterSettingsCopy->cp.cIP + L":" + machineName );

        nlbMachine.drainstop( Common::THIS_HOST, &retVal );
    }
    else if( methodToRun == _bstr_t( L"resume" ) )
    {
        dataSinkObj->dataSink( 
            GETRESOURCEIDSTRING( IDS_COMMAND_RESUME ) +  clusterSettingsCopy->cp.cIP + L":" + machineName );

        nlbMachine.resume( Common::THIS_HOST, &retVal );
    }
    else if( methodToRun == _bstr_t( L"suspend" ) )
    {
        dataSinkObj->dataSink( 
            GETRESOURCEIDSTRING( IDS_COMMAND_SUSPEND ) +  clusterSettingsCopy->cp.cIP + L":" + machineName );

        nlbMachine.suspend( Common::THIS_HOST, &retVal );
    }
    else if( methodToRun == _bstr_t( L"enable" ) )
    {
        dataSinkObj->dataSink( 
            GETRESOURCEIDSTRING( IDS_COMMAND_ENABLE ) +  clusterSettingsCopy->cp.cIP + L":" + machineName );

        nlbMachine.enable( Common::THIS_HOST, &retVal, portToAffect );
    }
    else if( methodToRun == _bstr_t( L"disable" ) )
    {
        dataSinkObj->dataSink( 
            GETRESOURCEIDSTRING( IDS_COMMAND_DISABLE ) +  clusterSettingsCopy->cp.cIP + L":" + machineName );

        nlbMachine.disable( Common::THIS_HOST, &retVal, portToAffect );
    }
    else if( methodToRun == _bstr_t( L"drain" ) )
    {
        dataSinkObj->dataSink( 
            GETRESOURCEIDSTRING( IDS_COMMAND_DRAIN ) +  clusterSettingsCopy->cp.cIP + L":" + machineName );

        nlbMachine.drain( Common::THIS_HOST, &retVal, portToAffect );
    }
    else
    {
        // unknown method.  It has to be one of above.
        dataSinkObj->dataSink( 
            GETRESOURCEIDSTRING( IDS_WLBS_UNKNOWN ) ); 
    }

    // decipher the return.
    _bstr_t errString;
    getWLBSErrorString( retVal,
                        errString );
    
    dataSinkObj->dataSink( errString );

    return CommonNLB_SUCCESS;
}



// the unbinding is done in a separate thread
// as this call though successful, unloads and reloads the nic
// when nlb is unbound which can cause the connection to fail.
// This failure can occur after a very long time, which causes nlb
// manager to hang if this operation is not carried out in
// separate thread.
// Also note that the ownership of the MNLBNetCfg object is given
// to this thread, thus it is deleting this object.  Thus caller
// needs to create the object on the heap, pass it in AfxBeginThread
// and be sure to not delete it.
UINT
CommonNLB::UnbindThread( LPVOID pParam )
{
    MUsingCom com;

    MNLBNetCfg* p_nlbNetCfg = ( MNLBNetCfg *) pParam;

    try
    {
        p_nlbNetCfg->unbind();
    }
    catch( _com_error (e ) )
    {
        // the above call may fail, thus we want 
        // to catch exception.
    }

    delete p_nlbNetCfg;

    return 0;
}

CommonNLB::CommonNLB_Error
CommonNLB::getWLBSErrorString( unsigned long     errStatus,      // IN
                               _bstr_t&          extErrString    // OUT
                               )
{
    switch( errStatus )
    {

        case 1000 : 
            extErrString = GETRESOURCEIDSTRING( IDS_WLBS_OK );
            break;

        case 1001 :
            extErrString = GETRESOURCEIDSTRING( IDS_WLBS_ALREADY );
            break;

        case 1002 : 
            extErrString = GETRESOURCEIDSTRING( IDS_WLBS_DRAIN_STOP );
            break;

        case 1003 : 
            extErrString = GETRESOURCEIDSTRING( IDS_WLBS_BAD_PARAMS );
            break;

        case 1004 : 
            extErrString = GETRESOURCEIDSTRING( IDS_WLBS_NOT_FOUND );
            break;

        case 1005 : 
            extErrString = GETRESOURCEIDSTRING( IDS_WLBS_STOPPED );
            break;


        case 1006 : 
            extErrString = GETRESOURCEIDSTRING( IDS_WLBS_CONVERGING );
            break;

        case 1007 : 
            extErrString = GETRESOURCEIDSTRING( IDS_WLBS_CONVERGED );
            break;

        case 1008 : 
            extErrString = GETRESOURCEIDSTRING( IDS_WLBS_DEFAULT );
            break;

        case 1009 : 
            extErrString = GETRESOURCEIDSTRING( IDS_WLBS_DRAINING );
            break;

        case 1013 :
            extErrString = GETRESOURCEIDSTRING( IDS_WLBS_SUSPENDED );
            break;

        case 1050 : 
            extErrString = GETRESOURCEIDSTRING( IDS_WLBS_REBOOT );
            break;

        case 1100 : 
            extErrString = GETRESOURCEIDSTRING( IDS_WLBS_INIT_ERROR );
            break;

        case 1101 : 
            extErrString = GETRESOURCEIDSTRING( IDS_WLBS_BAD_PASSW );
            break;

        case 1102: 
            extErrString = GETRESOURCEIDSTRING( IDS_WLBS_IO_ERROR );
            break;
            
        case 1103 : 
            extErrString = GETRESOURCEIDSTRING( IDS_WLBS_TIMEOUT );
            break;

        case 1150 : 
            extErrString = GETRESOURCEIDSTRING( IDS_WLBS_PORT_OVERLAP );
            break;

        case 1151 : 
            extErrString = GETRESOURCEIDSTRING( IDS_WLBS_BAD_PORT_PARAMS );
            break;

        case 1152 : 
            extErrString = GETRESOURCEIDSTRING( IDS_WLBS_MAX_PORT_RULES );
            break;

        case 1153 : 
            extErrString = GETRESOURCEIDSTRING( IDS_WLBS_TRUNCATED );
            break;

        case 1154 : 
            extErrString = GETRESOURCEIDSTRING( IDS_WLBS_REG_ERROR );
            break;

        default :
            extErrString = GETRESOURCEIDSTRING( IDS_WLBS_UNKNOWN ); 
            break;
    }

    return CommonNLB_SUCCESS;
}


CommonNLB::CommonNLB_Error
CommonNLB::addHostToCluster(  const ClusterData*       clusterToAddTo,
                              const _bstr_t&           machineName,
                              DataSinkI*               dataSinkObj )
{
    ClusterData* clusterToAddToCopy = 
        const_cast <ClusterData *>( clusterToAddTo );

    MNLBNetCfg* p_nlbNetCfg = NULL;
    BindAndConfigureParameters* par = NULL; 

    try {
        p_nlbNetCfg = new MNLBNetCfg(clusterToAddToCopy->hosts[machineName].connectionIP,
                                     clusterToAddToCopy->hosts[machineName].hp.nicInfo.fullNicName
                                    );

        par = new BindAndConfigureParameters;

        g_leftView = (LeftView *) dataSinkObj;

        par->nlbNetCfg = p_nlbNetCfg;
        par->clusterData = NULL;
        par->machineName = NULL;
        par->clusterData = new ClusterData( *clusterToAddToCopy );
        par->machineName = new _bstr_t( machineName );
    }
    catch(...)
    {
        if (par != NULL)
        {
            delete  par->machineName;
            delete  par->clusterData;
            delete  par;
        }
        delete  p_nlbNetCfg;

        dataSinkObj->dataSink(GETRESOURCEIDSTRING(IDS_INFO_NEW_EXCEPTION));
        throw;
    }

    AfxBeginThread( (AFX_THREADPROC ) BindAndConfigureThread,
                    par );

    return CommonNLB_SUCCESS;
}

// the binding and configuration is done in a separate thread
// as this call though successful, unloads and reloads the nic
// when nlb is bound which can cause the connection to fail.
// This failure can occur after a very long time, which causes nlb
// manager to hang if this operation is not carried out in
// separate thread.
// It is very important to ensure that you are completely sure
// that binding and configuration will succeed as this call will 
// run in its separate thread and does not generate errors even if
// failure occurs.
//
// Also note that the ownership of the MNLBNetCfg object is given
// to this thread, thus it is deleting this object.  Thus caller
// needs to create the object on the heap, pass it in AfxBeginThread
// and be sure to not delete it.
UINT
CommonNLB::BindAndConfigureThread( LPVOID pParam )
{
    MUsingCom com;

    BindAndConfigureParameters* parameters = 
        ( BindAndConfigureParameters *) pParam;

    MNLBNetCfg* p_nlbNetCfg = parameters->nlbNetCfg;

    ClusterData* p_clusterData = parameters->clusterData;

    _bstr_t* p_machineName = parameters->machineName;

    try
    {
        p_nlbNetCfg->bindAndConfigure( 
            p_clusterData,
            *p_machineName );
    }
    catch( _com_error (e ) )
    {
        // the above call may fail, thus we want 
        // to catch exception.
    }

    delete p_nlbNetCfg;
    delete p_clusterData;
    delete p_machineName;

    delete parameters;

    return 0;
}

// the modification of cluster properties is done in a separate thread
// as this call though successful, might unload and reload the nic driver
// when nlb is bound which can cause the connection to fail.
// This failure can occur after a very long time, which causes nlb
// manager to hang if this operation is not carried out in
// separate thread.
// It is very important to ensure that you are completely sure
// that this operation will succeed as this call will 
// run in its separate thread and does not generate errors even if
// failure occurs.
//
// Also note that the ownership of the MNLBNetCfg object is given
// to this thread, thus it is deleting this object.  Thus caller
// needs to create the object on the heap, pass it in AfxBeginThread
// and be sure to not delete it.
UINT
CommonNLB::ModifyClusterPropertiesThread( LPVOID pParam )
{
    MUsingCom com;

    ModifyClusterPropertiesParameters* parameters = 
        ( ModifyClusterPropertiesParameters *) pParam;

    MNLBNetCfg* p_nlbNetCfg = parameters->nlbNetCfg;

    ClusterProperties* p_clusterProperties = &(parameters->clusterData->cp);

    try
    {
        p_nlbNetCfg->modifyClusterProperties(p_clusterProperties);
    }
    catch( _com_error (e ) )
    {
        // the above call may fail, thus we want 
        // to catch exception.
    }

    delete p_nlbNetCfg;
    delete parameters->clusterData;

    delete parameters;

    return 0;
}




UINT
CommonNLB::DummyThread( LPVOID pParam )
{
    MUsingCom com;

    Sleep( 1000 );

    BindAndConfigureParameters* parameters = 
        ( BindAndConfigureParameters *) pParam;

    LeftView * leftView = g_leftView;

    TVINSERTSTRUCT item;
    item.hParent = leftView->GetTreeCtrl().GetRootItem();

    ClusterData* p_clusterDataItem;
    HTREEITEM hNextItem;
    HTREEITEM hChildItem;

    if( leftView->GetTreeCtrl().ItemHasChildren( leftView->GetTreeCtrl().GetRootItem() ) ) 
    {
        hChildItem = leftView->GetTreeCtrl().GetChildItem(leftView->GetTreeCtrl().GetRootItem() );
            
        while (hChildItem != NULL)
        {
            hNextItem = leftView->GetTreeCtrl().GetNextItem(hChildItem, TVGN_NEXT);

            p_clusterDataItem = ( ClusterData * ) leftView->GetTreeCtrl().GetItemData( hChildItem );
            
            if( p_clusterDataItem->cp.cIP == parameters->clusterData->cp.cIP )
            {
                // the cluster is found.
                
                // get the exact host.  Change icon of this host.
                hChildItem = leftView->GetTreeCtrl().GetChildItem( hChildItem );
                while( hChildItem != NULL )
                {
                    hNextItem = leftView->GetTreeCtrl().GetNextItem(hChildItem, TVGN_NEXT);
                    _bstr_t* machineName = (_bstr_t *) leftView->GetTreeCtrl().GetItemData( hChildItem );
                    if( *( machineName ) == *(parameters->machineName) )
                    {
                        // found machine to change icon of.
                        leftView->GetTreeCtrl().SetItemImage( hChildItem, 5, 5 );
                        goto outofloop;
                    }

                    hChildItem = hNextItem;
                }
            }
            
            hChildItem = hNextItem;
        }
    }

outofloop:

    // loop for around let us say 1 minute.
    // enable the icon.
    Sleep( 10000 );

    leftView->GetTreeCtrl().SetItemImage( hChildItem, 2, 2 );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\exe\clusterportsdlg.cpp ===
#include "stdafx.h"
#include "wlbsparm.h"
#include "PortsPage.h"
#include "ClusterPortsDlg.h"
#include "ResourceString.h"

BEGIN_MESSAGE_MAP(ClusterPortsDlg, CDialog)
    ON_BN_CLICKED(IDC_RADIO_DISABLED, OnRadioDisabled)
    ON_BN_CLICKED(IDC_RADIO_MULTIPLE, OnRadioMultiple)
    ON_BN_CLICKED(IDC_RADIO_SINGLE, OnRadioSingle)
    ON_WM_HELPINFO()        
    ON_WM_CONTEXTMENU()        

END_MESSAGE_MAP()



ClusterPortsDlg::ClusterPortsDlg( PortsPage::PortData& portData, 
                                  CWnd* parent,
                                  const int&   index
                                  )
        :
        m_portData( portData ),
        CDialog( ClusterPortsDlg::IDD, parent ),
        m_index( index )
{
    m_parent = (PortsPage *) parent;
}


void 
ClusterPortsDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange( pDX );
}

BOOL 
ClusterPortsDlg::OnInitDialog()
{
    CDialog::OnInitDialog();
    
    SetControlData();

    return TRUE;
}

void 
ClusterPortsDlg::OnOK()
{
    PortsPage::PortData portData;

    //
    // get port information.
    //

    BOOL fError;

    long start_port = ::GetDlgItemInt (m_hWnd, IDC_EDIT_START, &fError, FALSE);
    if( fError == FALSE )
    {
        // some problem with the data input.
        // it has been left blank.

        wchar_t buffer[Common::BUF_SIZE];

        swprintf( buffer, GETRESOURCEIDSTRING( IDS_PARM_PORT_BLANK ), CVY_MIN_PORT,CVY_MAX_PORT  );

        MessageBox( buffer,
                    GETRESOURCEIDSTRING( IDS_PARM_ERROR ),
                    MB_ICONSTOP | MB_OK );

        return;
    }

    wchar_t buf[Common::BUF_SIZE];

    swprintf( buf, L"%d", start_port );
    portData.start_port = buf;

    long end_port =  ::GetDlgItemInt (m_hWnd, IDC_EDIT_END, &fError, FALSE);
    if( fError == FALSE )
    {
        // some problem with the data input.
        // it has been left blank.

        wchar_t buffer[Common::BUF_SIZE];

        swprintf( buffer, GETRESOURCEIDSTRING( IDS_PARM_PORT_BLANK ), CVY_MIN_PORT,CVY_MAX_PORT  );

        MessageBox( buffer,
                    GETRESOURCEIDSTRING( IDS_PARM_ERROR ),
                    MB_ICONSTOP | MB_OK );


        return;
    }
    swprintf( buf, L"%d", end_port );
    portData.end_port = buf;

    // check if start port and end port both are in
    // proper range.
    if( !( start_port >= CVY_MIN_PORT 
           &&
           start_port <= CVY_MAX_PORT
           &&
           end_port >= CVY_MIN_PORT 
           &&
           end_port <= CVY_MAX_PORT )
        )
    {
        wchar_t buffer[Common::BUF_SIZE];

        swprintf( buffer, GETRESOURCEIDSTRING( IDS_PARM_PORT_VAL ), CVY_MIN_PORT,CVY_MAX_PORT  );

        MessageBox( buffer,
                    GETRESOURCEIDSTRING( IDS_PARM_ERROR ),
                    MB_ICONSTOP | MB_OK );

        return;
    }

    // check if start port is less than or equal to end port.
    if( !(start_port <= end_port ) )
    {
        // start port is not less than or equal to end port. 
        MessageBox( GETRESOURCEIDSTRING(IDS_PARM_RANGE ),
                    GETRESOURCEIDSTRING( IDS_PARM_ERROR ),
                    MB_ICONSTOP | MB_OK );

        ::SetDlgItemInt(m_hWnd, IDC_EDIT_END, end_port, FALSE);

        return;
    }

    // check if there are are overlapped port rules.
    wchar_t portBuf[Common::BUF_SIZE];
    for( int i = 0; i < m_parent->m_portList.GetItemCount(); ++i )
    {
        if( i != m_index )  // not comparing against self
        {
            m_parent->m_portList.GetItemText( i, 0, portBuf, Common::BUF_SIZE );
            long start_port_existing =  _wtoi( portBuf );
            
            m_parent->m_portList.GetItemText( i, 1, portBuf, Common::BUF_SIZE );
            long end_port_existing = _wtoi( portBuf );
            
            if ( (start_port < start_port_existing &&
                  end_port >= start_port_existing) ||
                 ( start_port >= start_port_existing &&
                   start_port <= end_port_existing))
                
            {
                MessageBox( GETRESOURCEIDSTRING(IDS_PARM_OVERLAP ),
                            GETRESOURCEIDSTRING( IDS_PARM_ERROR ),
                            MB_ICONSTOP | MB_OK );
                
                return;
            }
        }
    }

    // get protocol
    if (::IsDlgButtonChecked (m_hWnd, IDC_RADIO_TCP))
    {
        portData.protocol = GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_TCP );
    }
    else if( ::IsDlgButtonChecked (m_hWnd, IDC_RADIO_UDP))
    {
        portData.protocol = GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_UDP );
    }
    else 
    {
        portData.protocol = GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_BOTH);
    }

    // get filtering mode
    if (::IsDlgButtonChecked (m_hWnd, IDC_RADIO_MULTIPLE))
    {
        portData.mode = GETRESOURCEIDSTRING( IDS_REPORT_MODE_MULTIPLE );

        // get affinity
        if (::IsDlgButtonChecked (m_hWnd, IDC_RADIO_AFF_NONE))
        {
            portData.affinity = GETRESOURCEIDSTRING( IDS_REPORT_AFFINITY_NONE );            
        }
        else if (::IsDlgButtonChecked (m_hWnd, IDC_RADIO_AFF_SINGLE))
        {
            portData.affinity = GETRESOURCEIDSTRING( IDS_REPORT_AFFINITY_SINGLE );            
        }
        else
        {
            portData.affinity = GETRESOURCEIDSTRING( IDS_REPORT_AFFINITY_CLASSC );            
        }

        // get load balancing.
        if (::IsDlgButtonChecked (m_hWnd, IDC_RADIO_EQUAL))
        {
            portData.load = GETRESOURCEIDSTRING( IDS_REPORT_LOAD_EQUAL );            
        }
        else
        {
            portData.load = GETRESOURCEIDSTRING( IDS_REPORT_LOAD_UNEQUAL );            
        }

        // for multiple mode, priority is empty.
        portData.priority = GETRESOURCEIDSTRING( IDS_REPORT_EMPTY );
    }
    else if (::IsDlgButtonChecked (m_hWnd, IDC_RADIO_SINGLE))
    {
        portData.mode = GETRESOURCEIDSTRING( IDS_REPORT_MODE_SINGLE );
        portData.priority = GETRESOURCEIDSTRING( IDS_REPORT_NA );

        // for single mode load and affinity are empty.
        portData.load = GETRESOURCEIDSTRING( IDS_REPORT_EMPTY );
        portData.affinity = GETRESOURCEIDSTRING( IDS_REPORT_EMPTY );
    }
    else
    {
        portData.mode = GETRESOURCEIDSTRING( IDS_REPORT_MODE_DISABLED );

        // for single mode priority load and affinity are empty.
        portData.priority = GETRESOURCEIDSTRING( IDS_REPORT_EMPTY );
        portData.load = GETRESOURCEIDSTRING( IDS_REPORT_EMPTY );
        portData.affinity = GETRESOURCEIDSTRING( IDS_REPORT_EMPTY );
    }

    // set the new port rule.
    m_portData = portData;

    EndDialog( IDOK );
}


void
ClusterPortsDlg::SetControlData()
{
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_START, EM_SETLIMITTEXT, 5, 0);
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_END, EM_SETLIMITTEXT, 5, 0);
    ::SendDlgItemMessage(m_hWnd, IDC_SPIN_START, UDM_SETRANGE32, CVY_MIN_PORT, CVY_MAX_PORT);
    ::SendDlgItemMessage(m_hWnd, IDC_SPIN_END, UDM_SETRANGE32, CVY_MIN_PORT, CVY_MAX_PORT);

    // set the port range.
    ::SetDlgItemInt (m_hWnd, IDC_EDIT_START,  _wtoi( m_portData.start_port), FALSE);
    ::SetDlgItemInt (m_hWnd, IDC_EDIT_END,  _wtoi( m_portData.end_port ),   FALSE);

    // set the protocol.
    if( m_portData.protocol == GETRESOURCEIDSTRING(IDS_REPORT_PROTOCOL_TCP) )
    {
        ::CheckDlgButton( m_hWnd, IDC_RADIO_TCP, BST_CHECKED );
        ::CheckDlgButton( m_hWnd, IDC_RADIO_UDP, BST_UNCHECKED );
        ::CheckDlgButton( m_hWnd, IDC_RADIO_BOTH, BST_UNCHECKED );
    }
    else if( m_portData.protocol == GETRESOURCEIDSTRING(IDS_REPORT_PROTOCOL_UDP) )
    {
        ::CheckDlgButton( m_hWnd, IDC_RADIO_TCP, BST_UNCHECKED );
        ::CheckDlgButton( m_hWnd, IDC_RADIO_UDP, BST_CHECKED );
        ::CheckDlgButton( m_hWnd, IDC_RADIO_BOTH, BST_UNCHECKED );
    }
    else
    {
        ::CheckDlgButton( m_hWnd, IDC_RADIO_TCP, BST_UNCHECKED );
        ::CheckDlgButton( m_hWnd, IDC_RADIO_UDP, BST_UNCHECKED );
        ::CheckDlgButton( m_hWnd, IDC_RADIO_BOTH, BST_CHECKED );
    }

    // set the mode.
    if( m_portData.mode == GETRESOURCEIDSTRING(IDS_REPORT_MODE_MULTIPLE) )
    { 
        ::CheckDlgButton( m_hWnd, IDC_RADIO_MULTIPLE, BST_CHECKED );
        ::CheckDlgButton( m_hWnd, IDC_RADIO_SINGLE, BST_UNCHECKED );
        ::CheckDlgButton( m_hWnd, IDC_RADIO_DISABLED, BST_UNCHECKED );

        :: EnableWindow (GetDlgItem (IDC_RADIO_UNEQUAL)->m_hWnd,    TRUE);
        :: EnableWindow (GetDlgItem (IDC_RADIO_EQUAL)->m_hWnd,      TRUE);
        :: EnableWindow (GetDlgItem (IDC_RADIO_AFF_NONE)->m_hWnd,   TRUE);
        :: EnableWindow (GetDlgItem (IDC_RADIO_AFF_SINGLE)->m_hWnd, TRUE);
        :: EnableWindow (GetDlgItem (IDC_RADIO_AFF_CLASSC)->m_hWnd, TRUE);

        if( m_portData.load == GETRESOURCEIDSTRING(IDS_REPORT_LOAD_EQUAL) )
        {			  
            ::CheckDlgButton( m_hWnd, IDC_RADIO_EQUAL, BST_CHECKED );
            ::CheckDlgButton( m_hWnd, IDC_RADIO_UNEQUAL, BST_UNCHECKED );			
        }
        else
        {
            ::CheckDlgButton( m_hWnd, IDC_RADIO_EQUAL, BST_UNCHECKED );
            ::CheckDlgButton( m_hWnd, IDC_RADIO_UNEQUAL, BST_CHECKED );		
        }

        if( m_portData.affinity == GETRESOURCEIDSTRING(IDS_REPORT_AFFINITY_NONE ) )
        {
            ::CheckDlgButton( m_hWnd, IDC_RADIO_AFF_NONE, BST_CHECKED );
            ::CheckDlgButton( m_hWnd, IDC_RADIO_AFF_SINGLE, BST_UNCHECKED );
            ::CheckDlgButton( m_hWnd, IDC_RADIO_AFF_CLASSC, BST_UNCHECKED );
        }
        else if ( m_portData.affinity == GETRESOURCEIDSTRING(IDS_REPORT_AFFINITY_SINGLE) )
        {
            ::CheckDlgButton( m_hWnd, IDC_RADIO_AFF_NONE, BST_UNCHECKED );
            ::CheckDlgButton( m_hWnd, IDC_RADIO_AFF_SINGLE, BST_CHECKED );
            ::CheckDlgButton( m_hWnd, IDC_RADIO_AFF_CLASSC, BST_UNCHECKED );
        }
        else
        {
            ::CheckDlgButton( m_hWnd, IDC_RADIO_AFF_NONE, BST_UNCHECKED );
            ::CheckDlgButton( m_hWnd, IDC_RADIO_AFF_SINGLE, BST_UNCHECKED );
            ::CheckDlgButton( m_hWnd, IDC_RADIO_AFF_CLASSC, BST_CHECKED );
        }
    }
    else if( m_portData.mode == GETRESOURCEIDSTRING(IDS_REPORT_MODE_SINGLE) )
    {
        ::CheckDlgButton( m_hWnd, IDC_RADIO_MULTIPLE, BST_UNCHECKED );
        ::CheckDlgButton( m_hWnd, IDC_RADIO_SINGLE, BST_CHECKED );
        ::CheckDlgButton( m_hWnd, IDC_RADIO_DISABLED, BST_UNCHECKED );

        :: EnableWindow (GetDlgItem (IDC_RADIO_UNEQUAL)->m_hWnd,    FALSE);
        :: EnableWindow (GetDlgItem (IDC_RADIO_EQUAL)->m_hWnd,      FALSE);
        :: EnableWindow (GetDlgItem (IDC_RADIO_AFF_NONE)->m_hWnd,   FALSE);
        :: EnableWindow (GetDlgItem (IDC_RADIO_AFF_SINGLE)->m_hWnd, FALSE);
        :: EnableWindow (GetDlgItem (IDC_RADIO_AFF_CLASSC)->m_hWnd, FALSE);
    }
    else
    {
        ::CheckDlgButton( m_hWnd, IDC_RADIO_MULTIPLE, BST_UNCHECKED );
        ::CheckDlgButton( m_hWnd, IDC_RADIO_SINGLE, BST_UNCHECKED );
        ::CheckDlgButton( m_hWnd, IDC_RADIO_DISABLED, BST_CHECKED );

        :: EnableWindow (GetDlgItem (IDC_RADIO_UNEQUAL)->m_hWnd,    FALSE);
        :: EnableWindow (GetDlgItem (IDC_RADIO_EQUAL)->m_hWnd,      FALSE);
        :: EnableWindow (GetDlgItem (IDC_RADIO_AFF_NONE)->m_hWnd,   FALSE);
        :: EnableWindow (GetDlgItem (IDC_RADIO_AFF_SINGLE)->m_hWnd, FALSE);
        :: EnableWindow (GetDlgItem (IDC_RADIO_AFF_CLASSC)->m_hWnd, FALSE);
    }
}


void
ClusterPortsDlg::OnRadioMultiple() 
{
    // TODO: Add your control notification handler code here
    :: EnableWindow (GetDlgItem (IDC_RADIO_UNEQUAL)->m_hWnd,    TRUE);
    :: EnableWindow (GetDlgItem (IDC_RADIO_EQUAL)->m_hWnd,      TRUE);
    :: EnableWindow (GetDlgItem (IDC_RADIO_AFF_NONE)->m_hWnd,   TRUE);
    :: EnableWindow (GetDlgItem (IDC_RADIO_AFF_SINGLE)->m_hWnd, TRUE);
    :: EnableWindow (GetDlgItem (IDC_RADIO_AFF_CLASSC)->m_hWnd, TRUE);


    ::CheckDlgButton( m_hWnd, IDC_RADIO_AFF_NONE, BST_UNCHECKED );
    ::CheckDlgButton( m_hWnd, IDC_RADIO_AFF_SINGLE, BST_CHECKED );
    ::CheckDlgButton( m_hWnd, IDC_RADIO_AFF_CLASSC, BST_UNCHECKED );

    ::CheckDlgButton( m_hWnd, IDC_RADIO_EQUAL, BST_CHECKED );
    ::CheckDlgButton( m_hWnd, IDC_RADIO_UNEQUAL, BST_UNCHECKED );
}


void 
ClusterPortsDlg::OnRadioSingle() 
{
    // TODO: Add your control notification handler code here
    :: EnableWindow (GetDlgItem (IDC_RADIO_UNEQUAL)->m_hWnd,      FALSE);
    :: EnableWindow (GetDlgItem (IDC_RADIO_EQUAL)->m_hWnd,      FALSE);
    :: EnableWindow (GetDlgItem (IDC_RADIO_AFF_NONE)->m_hWnd,   FALSE);
    :: EnableWindow (GetDlgItem (IDC_RADIO_AFF_SINGLE)->m_hWnd, FALSE);
    :: EnableWindow (GetDlgItem (IDC_RADIO_AFF_CLASSC)->m_hWnd, FALSE);
}


void 
ClusterPortsDlg::OnRadioDisabled() 
{
    // TODO: Add your control notification handler code here
    :: EnableWindow (GetDlgItem (IDC_RADIO_UNEQUAL)->m_hWnd,      FALSE);
    :: EnableWindow (GetDlgItem (IDC_RADIO_EQUAL)->m_hWnd,      FALSE);
    :: EnableWindow (GetDlgItem (IDC_RADIO_AFF_NONE)->m_hWnd,   FALSE);
    :: EnableWindow (GetDlgItem (IDC_RADIO_AFF_SINGLE)->m_hWnd, FALSE);
    :: EnableWindow (GetDlgItem (IDC_RADIO_AFF_CLASSC)->m_hWnd, FALSE);
	
}

void ClusterPortsDlg::PrintRangeError (unsigned int ids, int low, int high) 
{
    /* Pop-up a message box. */
    wchar_t buffer[Common::BUF_SIZE];

    swprintf( buffer, GETRESOURCEIDSTRING( ids ), low, high );

    MessageBox( buffer,
                GETRESOURCEIDSTRING( IDS_PARM_ERROR ),
                MB_ICONSTOP | MB_OK );
}

BOOL
ClusterPortsDlg::OnHelpInfo (HELPINFO* helpInfo )
{
    if( helpInfo->iContextType == HELPINFO_WINDOW )
    {
        ::WinHelp( static_cast<HWND> ( helpInfo->hItemHandle ), 
                   CVY_CTXT_HELP_FILE, HELP_WM_HELP, 
                   (ULONG_PTR ) g_aHelpIDs_IDD_PORT_RULE_PROP_CLUSTER );
    }

    return TRUE;
}

void
ClusterPortsDlg::OnContextMenu( CWnd* pWnd, CPoint point )
{
    ::WinHelp( m_hWnd, 
               CVY_CTXT_HELP_FILE, 
               HELP_CONTEXTMENU, 
               (ULONG_PTR ) g_aHelpIDs_IDD_PORT_RULE_PROP_CLUSTER );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\exe\commonutils.h ===
#ifndef COMMONUTILS_H
#define COMMONUTILS_H

#include "stdafx.h"
#include <comdef.h>
#include <vector>

using namespace std;

class CommonUtils
{

public:
    // converts the CIPAddressCtrl embedded ip into
    // dotted decimal string representation.
    static
    _bstr_t
    getCIPAddressCtrlString( CIPAddressCtrl& ip );
    
    // fills the CIPAddressCtrl with the dotted decimal
    // string representation.
    static
    void
    fillCIPAddressCtrlString( CIPAddressCtrl& ip, 
                              const _bstr_t& ipAdddress );

    static
    void
    getVectorFromSafeArray( SAFEARRAY*&      stringArray,
                            vector<_bstr_t>& strings );

    static
    void
    getSafeArrayFromVector( const vector<_bstr_t>& strings,
                            SAFEARRAY*&      stringArray
                            );

    
private:
    enum
    {
        BUF_SIZE = 1000,
    };
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\exe\commonutils.cpp ===
#include "CommonUtils.h"

#include <winsock2.h>


_bstr_t
CommonUtils::getCIPAddressCtrlString( CIPAddressCtrl& ip )
{
    	unsigned long addr;
	ip.GetAddress( addr );
	
	PUCHAR bp = (PUCHAR) &addr;	

	wchar_t buf[BUF_SIZE];
	swprintf(buf, L"%d.%d.%d.%d", bp[3], bp[2], bp[1], bp[0] );

        return _bstr_t( buf );
}


void
CommonUtils::fillCIPAddressCtrlString( CIPAddressCtrl& ip, 
                                       const _bstr_t& ipAddress )
{
    // set the IPAddress control to blank if ipAddress is zero.

    unsigned long addr = inet_addr( ipAddress );
    if( addr != 0 )
    {

        PUCHAR bp = (PUCHAR) &addr;

        ip.SetAddress( bp[0], bp[1], bp[2], bp[3] );
    }
    else
    {
        ip.ClearAddress();
    }
}

void
CommonUtils::getVectorFromSafeArray( SAFEARRAY*&  stringArray, 
                                     vector<_bstr_t>& strings )
{
    LONG count = stringArray->rgsabound[0].cElements;
    BSTR* pbstr;
    HRESULT hr;

    if( SUCCEEDED( SafeArrayAccessData( stringArray, ( void **) &pbstr)))
    {
        for( LONG x = 0; x < count; x++ )
        {
            strings.push_back( pbstr[x] );
        }

        hr = SafeArrayUnaccessData( stringArray );
    }
}    


void
CommonUtils::getSafeArrayFromVector( 
    const vector<_bstr_t>& strings,
    SAFEARRAY*&      stringArray
    )
{
    LONG scount = 0;

    for( int i = 0; i < strings.size(); ++i )
    {
        scount = i;
        SafeArrayPutElement( stringArray, &scount, (BSTR ) strings[i] );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\exe\datasinki.h ===
#ifndef DATASINKI_H
#define DATASINKI_H


class DataSinkI 
{
public:
    virtual
    void
    dataSink( _bstr_t data ) = 0;

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\exe\document.cpp ===
#include "Document.h"
#include "MNLBUIData.h"

#include "resource.h"

IMPLEMENT_DYNCREATE( Document, CDocument )

Document::Document()
{
    //
    // load the images which are used.
    //

    m_images48x48 = new CImageList;

    m_images48x48->Create( 16,            // x
                           16,            // y
                           ILC_COLOR16,   // 16 bit color
                           0,             // initially image list is empty
                           10 );          // max images is 10.  This value arbitrary.

    // Add the icons which we are going to use.
     
    m_images48x48->Add( AfxGetApp()->LoadIcon( IDI_WORLD));
    m_images48x48->Add( AfxGetApp()->LoadIcon( IDI_CLUSTER));
    m_images48x48->Add( AfxGetApp()->LoadIcon( IDI_HOST_STARTED));
    m_images48x48->Add( AfxGetApp()->LoadIcon( IDI_HOST_STOPPED));
    m_images48x48->Add( AfxGetApp()->LoadIcon( IDI_PORTRULE) );
    m_images48x48->Add( AfxGetApp()->LoadIcon( IDI_PENDING ));
}


void
Document::registerLeftPane( CTreeView* treeView )
{
    m_treeView = treeView;
}

CTreeCtrl&
Document::getLeftPane()
{
    return m_treeView->GetTreeCtrl();
}

void
Document::registerStatusPane( CEditView* editView )
{
    m_editView = editView;
}


CEdit&
Document::getStatusPane()
{
    return m_editView->GetEditCtrl();
}

void
Document::registerListPane( CListView* listView )
{
    m_listView = listView;
}


CListCtrl&
Document::getListPane()
{
    return m_listView->GetListCtrl();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\exe\disclaimer.h ===
//***************************************************************************
//
//  DISCLAIMER.H
// 
//  Module: NLB Manager EXE
//
//  Purpose: sets up a disclaimer dialogbox, which has a "don't remind
//           me again checkbox".
//
//  Copyright (c)2001 Microsoft Corporation, All Rights Reserved
//
//  History:
//
//  05/20/01    JosephJ Created
//
//***************************************************************************

#ifndef DISCLAIMER_H
#define DISCLAIMER_H

#include "stdafx.h"

#include "resource.h"

class DisclaimerDialog : public CDialog
{
public:
    enum
    {
        IDD = IDD_DISCLAIMER,
    };

    DisclaimerDialog(CWnd* parent = NULL);

    virtual BOOL OnInitDialog();

    virtual void OnOK();


    // overrides CDialog -- see SDK documentation on DoDataExchange.
    // Used to map controls in resources to corresponding objects in this class.
    virtual void DoDataExchange( CDataExchange* pDX );

    // CButton        dontRemindMe;
    int			   dontRemindMe;
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\exe\document.h ===
#ifndef DOCUMENT_H
#define DOCUMENT_H

#include "stdafx.h"

class Document : public CDocument
{
    DECLARE_DYNCREATE( Document )

public:

    enum ListViewColumnSize
    {
        LV_COLUMN_SMALL = 80,
        LV_COLUMN_LARGE = 110,
    };


    // constructor
    Document();

    void
    registerLeftPane( CTreeView* treeView );

    CTreeCtrl&
    getLeftPane();

    void
    registerStatusPane( CEditView* editView );

    CEdit&
    getStatusPane();

    void
    registerListPane( CListView* listView );

    CListCtrl&
    getListPane();

    CImageList* m_images48x48;

private:
    CEditView* m_editView;

    CListView* m_listView;

    CTreeView* m_treeView;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\exe\commonnlb.h ===
#ifndef COMMONNLB_H
#define COMMONNLB_H

#include "stdafx.h"

#include "DataSinkI.h"

#include "LeftView.h"

#include "MNLBUIData.h"
#include "MNLBNetCfg.h"

#include "Common.h"

class CommonNLB
{

public:

    enum CommonNLB_Error
    {
        CommonNLB_SUCCESS = 0,
    };

#if 0
    class NicNLBBound
    {
    public:
        _bstr_t fullNicName;
        _bstr_t adapterGuid;
        _bstr_t friendlyName;

        bool   isDHCPEnabled;

        vector<_bstr_t> ipsOnNic;
        vector<_bstr_t> subnetMasks;

        bool    isBoundToNLB;
    };
#endif

    class NicNLBBound : public NicInfo
    {
    public:
        bool    isBoundToNLB;
    };


    static
    CommonNLB_Error
    connectToClusterDirectOld( const _bstr_t&            clusterIP,
                               ClusterData*              clusterData,
                               DataSinkI*                dataSinkObj );

    static
    CommonNLB_Error
    connectToClusterDirect( const _bstr_t&          clusterIP,
                            const _bstr_t&          hostMember,
                            ClusterData*            p_clusterData,
                            DataSinkI*              dataSinkObj );

    static
    CommonNLB_Error
    connectToClusterIndirect( const _bstr_t&          clusterIP,
                              const vector<_bstr_t>&  connectionIPS,
                              ClusterData*            clusterData,
                              DataSinkI*              dataSinkObj );


    static
    CommonNLB_Error
    connectToClusterIndirectNew( const _bstr_t&          clusterIP,
                                 const vector<_bstr_t>&  connectionIPS,
                                 vector< ClusterData>*   clusterDataStore,
                                 bool&                   clusterPropertiesMatched,
                                 DataSinkI*              dataSinkObj );

    static
    CommonNLB_Error
    connectToMachine( const _bstr_t&                  machineToConnect,
                      _bstr_t&                        machineServerName,
                      vector< NicNLBBound >&          nicList,
                      DataSinkI*                      dataSinkObj );  


    static
    CommonNLB_Error
    changeNLBHostSettings( const ClusterData*       oldSettings,
                           const ClusterData*       newSettings,
                           const _bstr_t&           machineName,
                           DataSinkI*               dataSinkObj );

    static
    CommonNLB_Error
    addHostToClusterOld(  const ClusterData*       clusterToAddTo,
                          const _bstr_t&           machineName,
                          DataSinkI*               dataSinkObj );

    static
    CommonNLB_Error
    addHostToCluster(  const ClusterData*       clusterToAddTo,
                       const _bstr_t&           machineName,
                       DataSinkI*               dataSinkObj );


    static
    CommonNLB_Error
    changeNLBClusterSettings( const ClusterData*       oldSettings,
                              const ClusterData*       newSettings,
                              DataSinkI*               dataSinkObj );


    static
    CommonNLB_Error
    changeNLBHostPortSettings( const ClusterData*       oldSettings,
                               const ClusterData*       newSettings,
                               const _bstr_t&           machineName,
                               DataSinkI*               dataSinkObj );

    static
    CommonNLB_Error
    changeNLBClusterAndPortSettings( const ClusterData*       oldSettings,
                                     const ClusterData*       newSettings,
                                     DataSinkI*               dataSinkObj, 
                                     bool*                    pbClusterIpChanged);

    static
    CommonNLB_Error
    removeCluster( const ClusterData* clusterSettings,
                   DataSinkI*         dataSinkObj );

    static
    CommonNLB_Error
    removeHost( const ClusterData*       clusterSettings,
                const _bstr_t&           machineName,
                DataSinkI*               dataSinkObj );

    static
    CommonNLB_Error
    runControlMethodOnCluster( const ClusterData*  clusterSettings,
                               DataSinkI*          dataSinkObj,
                               const _bstr_t&      methodToRun,
                               unsigned long       portToAffect = Common::ALL_PORTS
                            );
                            
    static
    CommonNLB_Error
    runControlMethodOnHost( const ClusterData*     clusterSettings,
                            const _bstr_t&         machineName,
                            DataSinkI*             dataSinkObj,
                            const _bstr_t&         methodToRun,
                            unsigned long          portToAffect = Common::ALL_PORTS
                            );

    static                            
    CommonNLB_Error
    getWLBSErrorString( unsigned long   retVal,
                       _bstr_t&        errString );





private:
    static
    UINT
    DummyThread( LPVOID pParam );

    static
    UINT
    UnbindThread( LPVOID pParam );

    static
    UINT
    BindAndConfigureThread( LPVOID pParam );

    static
    UINT
    ModifyClusterPropertiesThread( LPVOID pParam );

    static
    CommonNLB_Error
    findPortRulesAddedUnchangedRemovedELB( 
        const ClusterData*        oldSettings,
        const ClusterData*        newSettings,
        DataSinkI*                dataSinkObj,
        vector<long>&             rulesAdded,
        vector<long>&             rulesUnchanged,
        vector<long>&             rulesRemoved );

    static
    CommonNLB_Error
    findPortRulesAddedUnchangedRemovedULB( 
        const ClusterData*        oldSettings,
        const ClusterData*        newSettings,
        DataSinkI*                dataSinkObj,
        vector<long>&             rulesAdded,
        vector<long>&             rulesUnchanged,
        vector<long>&             rulesRemoved );

    static
    CommonNLB_Error
    findPortRulesAddedUnchangedRemovedD( 
        const ClusterData*        oldSettings,
        const ClusterData*        newSettings,
        DataSinkI*                dataSinkObj,
        vector<long>&             rulesAdded,
        vector<long>&             rulesUnchanged,
        vector<long>&             rulesRemoved );

    static
    CommonNLB_Error
    findPortRulesAddedUnchangedRemovedF( 
        const ClusterData*        oldSettings,
        const ClusterData*        newSettings,
        DataSinkI*                dataSinkObj,
        vector<long>&             rulesAdded,
        vector<long>&             rulesUnchanged,
        vector<long>&             rulesRemoved );


    struct BindAndConfigureParameters
    {
        MNLBNetCfg*     nlbNetCfg;
        ClusterData*    clusterData;
        _bstr_t*         machineName;
    };
    typedef struct BindAndConfigureParameters  ModifyClusterPropertiesParameters;

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\exe\disclaimer.cpp ===
//***************************************************************************
//
//  UPDATECFG.CPP
// 
//  Module: WMI Framework Instance provider 
//
//  Purpose: Defines class NlbConfigurationUpdate, used for 
//           async update of NLB properties associated with a particular NIC.
//
//  Copyright (c)2001 Microsoft Corporation, All Rights Reserved
//
//  History:
//
//  04/05/01    JosephJ Created
//
//***************************************************************************
#include "disclaimer.h"

DisclaimerDialog::DisclaimerDialog(CWnd* parent )
        :
        CDialog( IDD, parent )
{}

void
DisclaimerDialog::DoDataExchange( CDataExchange* pDX )
{  
	CDialog::DoDataExchange(pDX);

   // DDX_Control( pDX, IDC_DO_NOT_REMIND, dontRemindMe );
   DDX_Check(pDX, IDC_DO_NOT_REMIND, dontRemindMe);
}


BOOL
DisclaimerDialog::OnInitDialog()
{
    BOOL fRet = CDialog::OnInitDialog();

    dontRemindMe = 0;
    return fRet;
}

void DisclaimerDialog::OnOK()
{
    //
    // Get the current check status ....
    //


#if 0
    dontRemindMe = IsDlgButtonChecked(IDC_DO_NOT_REMIND);

    if (dontRemindMe)
    {
    	::MessageBox(
             NULL,
             L"DO NOT REMIND", // Contents
             L"Reminder Hint", // caption
             MB_ICONSTOP | MB_OK );
    }
    else
    {
    	::MessageBox(
             NULL,
             L"REMIND", // Contents
             L"Reminder Hint", // caption
             MB_ICONSTOP | MB_OK );
    }
#endif // 0

	CDialog::OnOK();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\exe\hostpage.h ===
#ifndef HOSTPAGE_H
#define HOSTPAGE_H

#include "stdafx.h"

#include "resource.h"

#include "MNLBUIData.h"
#include "CommonNLB.h"
#include "IpSubnetMaskControl.h"

//
// History:
// --------
// 
// Revised by : mhakim
// Date       : 02-14-01
// Reason     : Passing complete nic information instead of only the nic list.

class HostPage : public CPropertyPage
{
public:
    enum
    {
        IDD = IDD_HOST_PAGE,
    };

    HostPage( const _bstr_t&             machine,
              ClusterData*               p_clusterData,
              const vector<CommonNLB::NicNLBBound> listOfNics,
              const bool&                isNewHost,
              UINT                       ID = HostPage::IDD );

    // member controls

    CComboBox      nicName;

    CComboBox      priority;

    //
    // IpAddress and subnet mask
    //
    CIPAddressCtrl ipAddress;

    CIPAddressCtrl subnetMask;
    
    CButton        initialState;

    CEdit          detailedNicInfo;

    // overrides of CPropertyPage
    virtual void DoDataExchange( CDataExchange* pDX );

    virtual BOOL OnInitDialog();

    virtual void OnOK();

    virtual BOOL OnKillActive();

    afx_msg void OnSelectedNicChanged();

    afx_msg void OnGainFocusDedicatedIP();

    afx_msg void OnGainFocusDedicatedMask();

    afx_msg BOOL OnHelpInfo (HELPINFO* helpInfo );

    afx_msg void OnContextMenu( CWnd* pWnd, CPoint point );



protected:
    _bstr_t          m_machine;

    int              m_previousSelection;

    bool            m_isNewHost;

    // Edited (mhakim 02-14-01)
//    vector<_bstr_t> m_nicList;
    vector< CommonNLB::NicNLBBound > m_nicList;

    ClusterData* m_clusterData;

    void
    SetControlData();

    void
    ReadControlData();

    bool
    isDipConfiguredOK();

    DECLARE_MESSAGE_MAP()
};

// help ids for this dialog.
//
static DWORD g_aHelpIDs_IDD_HOST_PAGE [] = {
    IDC_GROUP_NIC,                IDC_GROUP_NIC,
    IDC_NIC_FRIENDLY,             IDC_NIC_FRIENDLY,
    IDC_NIC,                      IDC_NIC,  
    IDC_NIC_DETAIL,               IDC_NIC_DETAIL,
    IDC_TEXT_PRI,                 IDC_EDIT_PRI,
    IDC_EDIT_PRI,                 IDC_EDIT_PRI,
    IDC_GROUP_DED_IP,             IDC_GROUP_DED_IP,
    IDC_TEXT_DED_IP,              IDC_EDIT_DED_IP,
    IDC_EDIT_DED_IP,              IDC_EDIT_DED_IP,
    IDC_TEXT_DED_MASK,            IDC_EDIT_DED_MASK,
    IDC_EDIT_DED_MASK,            IDC_EDIT_DED_MASK,
    IDC_CHECK_ACTIVE,             IDC_CHECK_ACTIVE,
    0, 0
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\exe\hostportsdlg.cpp ===
#include "stdafx.h"
#include "wlbsparm.h"
#include "PortsPage.h"
#include "HostPortsDlg.h"
#include "ResourceString.h"

BEGIN_MESSAGE_MAP(HostPortsDlg, CDialog)
    ON_WM_HELPINFO()        
    ON_WM_CONTEXTMENU()        
END_MESSAGE_MAP()



HostPortsDlg::HostPortsDlg( PortsPage::PortData& portData, 
                            CWnd* parent
                            )
        :
        m_portData( portData ),
        CDialog( HostPortsDlg::IDD, parent )
{
    m_parent = (PortsPage *) parent;
}


void 
HostPortsDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange( pDX );

    DDX_Control(pDX, IDC_EDIT_SINGLE, m_priority);
}

BOOL 
HostPortsDlg::OnInitDialog()
{
    CDialog::OnInitDialog();
    
    SetControlData();

    return TRUE;
}

void 
HostPortsDlg::OnOK()
{
    wchar_t buffer[Common::BUF_SIZE];

    //
    // The only thing which potentially could change
    // is the load weight if mode is multiple and the priority
    // if mode is single.
    //

    // set the new port rule.
    if( m_portData.mode == GETRESOURCEIDSTRING( IDS_REPORT_MODE_MULTIPLE ) )
    {
        // set the load here.
        BOOL fError;
        int weight = ::GetDlgItemInt (m_hWnd, IDC_EDIT_MULTI, &fError, FALSE);
        if( fError == FALSE )
        {
            // some problem with the data input.
            // it has been left blank.
            
            swprintf( buffer, GETRESOURCEIDSTRING( IDS_PARM_LOAD_BLANK ), CVY_MIN_LOAD, CVY_MAX_LOAD);

            MessageBox( buffer,
                        GETRESOURCEIDSTRING( IDS_PARM_ERROR ),
                        MB_ICONSTOP | MB_OK );
            
            return;
        }

        if( !( weight >= CVY_MIN_LOAD 
               &&
               weight <= CVY_MAX_LOAD )
            )
        {
            // the weight value is not in valid range.
            // These controls are all screwed up, even 
            // after setting the limits we need to all 
            // this checking, it is amazing!!!
            //
            swprintf( buffer, GETRESOURCEIDSTRING( IDS_PARM_LOAD ), CVY_MIN_LOAD,CVY_MAX_LOAD  );

            MessageBox( buffer,
                        GETRESOURCEIDSTRING( IDS_PARM_ERROR ),
                        MB_ICONSTOP | MB_OK );
            
            return;
        }
            
        swprintf( buffer, L"%d", weight );
        m_portData.load = buffer;
    }
    else if( m_portData.mode == GETRESOURCEIDSTRING( IDS_REPORT_MODE_SINGLE ) )
    {
        ::GetDlgItemText(m_hWnd, IDC_EDIT_SINGLE, buffer, Common::BUF_SIZE );

        m_portData.priority = buffer;
    }

    EndDialog( IDOK );
}


void
HostPortsDlg::SetControlData()
{
    // set ranges.
    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_MULTI, EM_SETLIMITTEXT, 3, 0);
    ::SendDlgItemMessage(m_hWnd, IDC_SPIN_MULTI, UDM_SETRANGE32, CVY_MIN_LOAD, CVY_MAX_LOAD);

    ::SendDlgItemMessage(m_hWnd, IDC_EDIT_SINGLE, EM_SETLIMITTEXT, 2, 0);
    ::SendDlgItemMessage(m_hWnd, IDC_SPIN_SINGLE, UDM_SETRANGE32, CVY_MIN_MAX_HOSTS, CVY_MAX_MAX_HOSTS);

    // set the ports
    ::SetDlgItemInt (m_hWnd, IDC_EDIT_START,  _wtoi( m_portData.start_port), FALSE);
    ::SetDlgItemInt (m_hWnd, IDC_EDIT_END,  _wtoi( m_portData.end_port ),   FALSE);

    // set the protocol.
    if( m_portData.protocol == GETRESOURCEIDSTRING(IDS_REPORT_PROTOCOL_TCP) )
    {
        ::CheckDlgButton( m_hWnd, IDC_RADIO_TCP, BST_CHECKED );
        ::CheckDlgButton( m_hWnd, IDC_RADIO_UDP, BST_UNCHECKED );
        ::CheckDlgButton( m_hWnd, IDC_RADIO_BOTH, BST_UNCHECKED );
    }
    else if( m_portData.protocol == GETRESOURCEIDSTRING(IDS_REPORT_PROTOCOL_UDP) )
    {
        ::CheckDlgButton( m_hWnd, IDC_RADIO_TCP, BST_UNCHECKED );
        ::CheckDlgButton( m_hWnd, IDC_RADIO_UDP, BST_CHECKED );
        ::CheckDlgButton( m_hWnd, IDC_RADIO_BOTH, BST_UNCHECKED );
    }
    else
    {
        ::CheckDlgButton( m_hWnd, IDC_RADIO_TCP, BST_UNCHECKED );
        ::CheckDlgButton( m_hWnd, IDC_RADIO_UDP, BST_UNCHECKED );
        ::CheckDlgButton( m_hWnd, IDC_RADIO_BOTH, BST_CHECKED );
    }

    // set the mode.
    if( m_portData.mode == GETRESOURCEIDSTRING(IDS_REPORT_MODE_MULTIPLE) )
    { 
        ::CheckDlgButton( m_hWnd, IDC_RADIO_MULTIPLE, BST_CHECKED );
        ::CheckDlgButton( m_hWnd, IDC_RADIO_SINGLE, BST_UNCHECKED );
        ::CheckDlgButton( m_hWnd, IDC_RADIO_DISABLED, BST_UNCHECKED );

        ::CheckDlgButton( m_hWnd, IDC_CHECK_EQUAL, BST_UNCHECKED );

        ::SetDlgItemInt (m_hWnd, IDC_EDIT_MULTI,  _wtoi( m_portData.load), FALSE);

        :: EnableWindow (GetDlgItem (IDC_TEXT_MULTI)->m_hWnd,    TRUE);
        :: EnableWindow (GetDlgItem (IDC_EDIT_MULTI)->m_hWnd,    TRUE);
        :: EnableWindow (GetDlgItem (IDC_SPIN_MULTI)->m_hWnd,    TRUE);

        if( m_portData.affinity == GETRESOURCEIDSTRING(IDS_REPORT_AFFINITY_NONE ) )
        {
            ::CheckDlgButton( m_hWnd, IDC_RADIO_AFF_NONE, BST_CHECKED );
            ::CheckDlgButton( m_hWnd, IDC_RADIO_AFF_SINGLE, BST_UNCHECKED );
            ::CheckDlgButton( m_hWnd, IDC_RADIO_AFF_CLASSC, BST_UNCHECKED );
        }
        else if ( m_portData.affinity == GETRESOURCEIDSTRING(IDS_REPORT_AFFINITY_SINGLE) )
        {
            ::CheckDlgButton( m_hWnd, IDC_RADIO_AFF_NONE, BST_UNCHECKED );
            ::CheckDlgButton( m_hWnd, IDC_RADIO_AFF_SINGLE, BST_CHECKED );
            ::CheckDlgButton( m_hWnd, IDC_RADIO_AFF_CLASSC, BST_UNCHECKED );
        }
        else
        {
            ::CheckDlgButton( m_hWnd, IDC_RADIO_AFF_NONE, BST_UNCHECKED );
            ::CheckDlgButton( m_hWnd, IDC_RADIO_AFF_SINGLE, BST_UNCHECKED );
            ::CheckDlgButton( m_hWnd, IDC_RADIO_AFF_CLASSC, BST_CHECKED );
        }
    }
    else if( m_portData.mode == GETRESOURCEIDSTRING(IDS_REPORT_MODE_SINGLE) )
    {
        ::CheckDlgButton( m_hWnd, IDC_RADIO_MULTIPLE, BST_UNCHECKED );
        ::CheckDlgButton( m_hWnd, IDC_RADIO_SINGLE, BST_CHECKED );
        ::CheckDlgButton( m_hWnd, IDC_RADIO_DISABLED, BST_UNCHECKED );

        BOOL fError;

        set<long> availPriorities =
            m_parent->m_clusterData->portF[_wtoi( m_portData.start_port ) ].getAvailablePriorities();

        availPriorities.insert( _wtoi( m_portData.priority ) );
        wchar_t buf[Common::BUF_SIZE];

        set<long>::iterator top;
        for( top = availPriorities.begin(); 
             top != availPriorities.end();
             ++top )
        {
            swprintf( buf, L"%d", *top );
            
            m_priority.AddString( buf );
        }

        // set selection to present hostid
        swprintf( buf, L"%d", _wtoi( m_portData.priority ) );
        m_priority.SelectString( -1, buf );

        :: EnableWindow (GetDlgItem (IDC_TEXT_SINGLE)->m_hWnd,    TRUE);
        :: EnableWindow (GetDlgItem (IDC_EDIT_SINGLE)->m_hWnd,    TRUE);
    }
}


BOOL
HostPortsDlg::OnHelpInfo (HELPINFO* helpInfo )
{
    if( helpInfo->iContextType == HELPINFO_WINDOW )
    {
        ::WinHelp( static_cast<HWND> ( helpInfo->hItemHandle ), 
                   CVY_CTXT_HELP_FILE, HELP_WM_HELP, 
                   (ULONG_PTR ) g_aHelpIDs_IDD_PORT_RULE_PROP_HOSTS );
    }

    return TRUE;
}

void
HostPortsDlg::OnContextMenu( CWnd* pWnd, CPoint point )
{
    ::WinHelp( m_hWnd, 
               CVY_CTXT_HELP_FILE, 
               HELP_CONTEXTMENU, 
               (ULONG_PTR ) g_aHelpIDs_IDD_PORT_RULE_PROP_HOSTS );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\exe\hostpage.cpp ===
#include "HostPage.h"
#include "CommonUtils.h"
#include "CommonNLB.h"
#include "MIPAddress.h"
#include "ResourceString.h"

#include <vector>
#include <algorithm>

using namespace std;
//
// History:
// --------
// 
// Revised by : mhakim
// Date       : 02-14-01
// Reason     : Passing complete nic information instead of only the nic list.
//
// Reason     : If nic selected is the one which has the connection ip, then
//              dip has to be connection ip.

BEGIN_MESSAGE_MAP( HostPage, CPropertyPage )
    ON_EN_SETFOCUS( IDC_EDIT_DED_IP, OnGainFocusDedicatedIP )
    ON_EN_SETFOCUS( IDC_EDIT_DED_MASK, OnGainFocusDedicatedMask )
    ON_LBN_SELCHANGE(IDC_NIC, OnSelectedNicChanged )
    ON_WM_HELPINFO()        
    ON_WM_CONTEXTMENU()        
END_MESSAGE_MAP()

HostPage::HostPage( const _bstr_t&            machine,
                    ClusterData*              p_clusterData,
                    const vector<CommonNLB::NicNLBBound> listOfNics,
                    const bool&                isNewHost,
                    UINT         ID )
            :
        m_machine( machine ),
        m_clusterData( p_clusterData ),
        m_nicList( listOfNics ),
        m_isNewHost( isNewHost ),
        CPropertyPage( ID )
{
}

void
HostPage::DoDataExchange( CDataExchange* pDX )
{
    DDX_Control( pDX, IDC_NIC, nicName );    
    DDX_Control( pDX, IDC_EDIT_PRI, priority );    
    DDX_Control( pDX, IDC_CHECK_ACTIVE, initialState );
    DDX_Control( pDX, IDC_NIC_DETAIL, detailedNicInfo );
    DDX_Control( pDX, IDC_EDIT_DED_IP, ipAddress );    
    DDX_Control( pDX, IDC_EDIT_DED_MASK, subnetMask );    
}

BOOL
HostPage::OnInitDialog()
{
    CPropertyPage::OnInitDialog();

    SetControlData();

    return TRUE;
}

void
HostPage::SetControlData()
{
    // fill in nic name.
    for( int i = 0; i < m_nicList.size(); ++i )
    {
        // using insertstring so we can add it to exact position.
        //
        nicName.InsertString( i, m_nicList[i].friendlyName );
    }

    // keep a track of nic selection.
    m_previousSelection = nicName.SelectString( -1, 
                                                m_clusterData->hosts[m_machine].hp.nicInfo.friendlyName );

    // fill in detailed nic info.
    detailedNicInfo.SetWindowText( m_clusterData->hosts[m_machine].hp.nicInfo.fullNicName );

    // fill in priority.
    wchar_t buf[Common::BUF_SIZE];
    set<int> availHostIDS = m_clusterData->getAvailableHostIDS();

     // add this hosts priority.
    availHostIDS.insert( m_clusterData->hosts[m_machine].hp.hID );

    set<int>::iterator top;
    for( top = availHostIDS.begin(); 
         top != availHostIDS.end();
         ++top )
    {
        swprintf( buf, L"%d", *top );

        priority.AddString( buf );
    }

    // set selection to present hostid
    swprintf( buf, L"%d", m_clusterData->hosts[m_machine].hp.hID );
    priority.SelectString( -1, buf );

     // set initial cluster state.
    initialState.SetCheck( 
        m_clusterData->hosts[m_machine].hp.initialClusterStateActive );

    // fill in host ip
    CommonUtils::fillCIPAddressCtrlString( 
        ipAddress,
        m_clusterData->hosts[m_machine].hp.hIP );

    // set host mask.
    CommonUtils::fillCIPAddressCtrlString( 
        subnetMask,
        m_clusterData->hosts[m_machine].hp.hSubnetMask );

}

// ReadControlData
//
void
HostPage::ReadControlData()
{
    wchar_t buf[Common::BUF_SIZE ];

    // fill in nic name.
    int currentSelection = nicName.GetCurSel();
    m_clusterData->hosts[m_machine].hp.nicInfo.fullNicName = m_nicList[currentSelection].fullNicName;
    m_clusterData->hosts[m_machine].hp.nicInfo.adapterGuid = m_nicList[currentSelection].adapterGuid;
    m_clusterData->hosts[m_machine].hp.nicInfo.friendlyName = m_nicList[currentSelection].friendlyName;
    m_clusterData->hosts[m_machine].hp.nicInfo.dhcpEnabled = m_nicList[currentSelection].dhcpEnabled;

    m_clusterData->hosts[m_machine].hp.nicInfo.ipsOnNic = m_nicList[currentSelection].ipsOnNic;
    m_clusterData->hosts[m_machine].hp.nicInfo.subnetMasks = m_nicList[currentSelection].subnetMasks;

    // fill in priority.
    int selectedPriorityIndex = priority.GetCurSel();
    priority.GetLBText( selectedPriorityIndex, buf );
    m_clusterData->hosts[m_machine].hp.hID = _wtoi( buf );

    // fill in host ip
    m_clusterData->hosts[m_machine].hp.hIP = 
        CommonUtils::getCIPAddressCtrlString( ipAddress );

    // set host mask.
    m_clusterData->hosts[m_machine].hp.hSubnetMask = 
        CommonUtils::getCIPAddressCtrlString( subnetMask );


    // set initial cluster state.
    m_clusterData->hosts[m_machine].hp.initialClusterStateActive =
        initialState.GetCheck() ? true : false;
}

void
HostPage::OnOK()
{
    CPropertyPage::OnOK();    
}


bool 
HostPage::isDipConfiguredOK()
{
    // if nic selected has the connection ip then
    // connection ip has to match the dip to ensure 
    // future connectivity.
    //

     // if connection ip is same as dip then no need 
     // to worry.
     //
    if( m_clusterData->hosts[m_machine].hp.hIP ==
        m_clusterData->hosts[m_machine].connectionIP )
    {
        return true;
    }

    // check if selected nic has connection ip.
    if( find( m_clusterData->hosts[m_machine].hp.nicInfo.ipsOnNic.begin(),
              m_clusterData->hosts[m_machine].hp.nicInfo.ipsOnNic.end(),
              m_clusterData->hosts[m_machine].connectionIP )
        !=
        m_clusterData->hosts[m_machine].hp.nicInfo.ipsOnNic.end() )
    {
        // the nic selected has the connection ip.
        return false;
    }

    // selected nic does not have connection ip, so dont care.
    return true;
}


BOOL
HostPage::OnKillActive()
{
    ReadControlData();

    // ip is blank
    // subnet is blank
    // valid

    if( ( m_clusterData->hosts[m_machine].hp.hIP == _bstr_t( L"0.0.0.0") )
        &&
        ( m_clusterData->hosts[m_machine].hp.hSubnetMask == _bstr_t( L"0.0.0.0") )
        )
    {
        // both ip and subnet can be blank or 0.0.0.0 in host page.  both but not
        // either.
        // 
        // this is empty, we just need to catch this case.
    }
    else if( m_clusterData->hosts[m_machine].hp.hIP == _bstr_t( L"0.0.0.0") )
    {
        // if only ip is blank or 0.0.0.0 then this is not allowed
        MessageBox( GETRESOURCEIDSTRING( IDS_PARM_DED_IP_BLANK ),
                    GETRESOURCEIDSTRING( IDS_PARM_ERROR ),
                    MB_ICONSTOP | MB_OK );

        CPropertyPage::OnCancel();
        return 0;
    }
    else 
    {
        // check if ip is valid.
        bool isIPValid = MIPAddress::checkIfValid(m_clusterData->hosts[m_machine].hp.hIP ); 
        if( isIPValid != true )
        {
            MessageBox( GETRESOURCEIDSTRING( IDS_PARM_INVAL_DED_IP ),
                        GETRESOURCEIDSTRING( IDS_PARM_ERROR ),
                        MB_ICONSTOP | MB_OK );

            CPropertyPage::OnCancel();
            return 0;
        }

        // check if subnet is 0.0.0.0
        // if so ask user if he wants us to fill it or not.
        if( m_clusterData->hosts[m_machine].hp.hSubnetMask == _bstr_t( L"0.0.0.0") )
        {
            MessageBox( GETRESOURCEIDSTRING( IDS_PARM_DED_NM_BLANK ),
                        GETRESOURCEIDSTRING( IDS_PARM_ERROR ),
                        MB_ICONSTOP | MB_OK );


            MIPAddress::getDefaultSubnetMask( m_clusterData->hosts[m_machine].hp.hIP, 
                                              m_clusterData->hosts[m_machine].hp.hSubnetMask 
                                              );

            CommonUtils::fillCIPAddressCtrlString( subnetMask, 
                                                   m_clusterData->hosts[m_machine].hp.hSubnetMask );
            CPropertyPage::OnCancel();
            return 0;
        }

        // check if subnet is contiguous
        bool isSubnetContiguous = MIPAddress::isContiguousSubnetMask( m_clusterData->hosts[m_machine].hp.hSubnetMask );
        if( isSubnetContiguous == false )
        {
            MessageBox( GETRESOURCEIDSTRING( IDS_PARM_INVAL_DED_MASK ),
                        GETRESOURCEIDSTRING( IDS_PARM_ERROR ),
                        MB_ICONSTOP | MB_OK );

            CPropertyPage::OnCancel();
            return 0;

        }

        // check if ip address and subnet mask are valid as a pair
        bool isIPSubnetPairValid = MIPAddress::isValidIPAddressSubnetMaskPair( m_clusterData->hosts[m_machine].hp.hIP,
                                                                               m_clusterData->hosts[m_machine].hp.hSubnetMask );
        if( isIPSubnetPairValid == false )
        {
            MessageBox( GETRESOURCEIDSTRING( IDS_PARM_INVAL_DED_IP ),
                        GETRESOURCEIDSTRING( IDS_PARM_ERROR ),
                        MB_ICONSTOP | MB_OK );

            CPropertyPage::OnCancel();
            return 0;
        }
    }

    // Edited (mhakim 02-14-01 )
    //
    // check if dip is properly configured.
    //
    if( isDipConfiguredOK() != true )
    {
        MessageBox( GETRESOURCEIDSTRING( IDS_PARM_DIP_MISCONFIG ),
                    GETRESOURCEIDSTRING( IDS_PARM_ERROR ),
                    MB_ICONSTOP | MB_OK );


        // set the dedicated ip back to the connection ip.
        // and mask to derived from connection ip.
        //

        m_clusterData->hosts[m_machine].hp.hIP = 
            m_clusterData->hosts[m_machine].connectionIP;

        MIPAddress::getDefaultSubnetMask( m_clusterData->hosts[m_machine].hp.hIP, 
                                          m_clusterData->hosts[m_machine].hp.hSubnetMask 
                                          );

        CommonUtils::fillCIPAddressCtrlString( ipAddress, 
                                               m_clusterData->hosts[m_machine].hp.hIP );

        CommonUtils::fillCIPAddressCtrlString( subnetMask, 
                                               m_clusterData->hosts[m_machine].hp.hSubnetMask );

        CPropertyPage::OnCancel();
        return 0;
    }

    // check if dip is non zero, it must
    // be present on nic selected.
    if( m_clusterData->hosts[m_machine].hp.hIP 
        != _bstr_t(L"0.0.0.0") )
    {
        // check if the dip entered exists on that nic, if not display warning.
        if( find( m_clusterData->hosts[m_machine].hp.nicInfo.ipsOnNic.begin(),
                  m_clusterData->hosts[m_machine].hp.nicInfo.ipsOnNic.end(),
                  m_clusterData->hosts[m_machine].hp.hIP )
            ==
            m_clusterData->hosts[m_machine].hp.nicInfo.ipsOnNic.end() )
        {
            // the dip specified does not exist on
            // nic selected.  Display warning.
            int ignoreWarning = MessageBox( GETRESOURCEIDSTRING( IDS_INVAL_DIP ),
                                            GETRESOURCEIDSTRING( IDS_PARM_WARN ),
                                            MB_ICONEXCLAMATION | MB_YESNO );
            if( ignoreWarning == IDNO )
            {
                CPropertyPage::OnCancel();
                return 0;
            }
        }
    }

    // check if nic selected is dhcp and also the connection nic.
    // if so this is not allowed.
    if( m_clusterData->hosts[m_machine].hp.nicInfo.dhcpEnabled == true )
    {
        if( find( m_clusterData->hosts[m_machine].hp.nicInfo.ipsOnNic.begin(),
                  m_clusterData->hosts[m_machine].hp.nicInfo.ipsOnNic.end(),
                  m_clusterData->hosts[m_machine].connectionIP )
            !=
            m_clusterData->hosts[m_machine].hp.nicInfo.ipsOnNic.end() )
        {
            // the nic selected has the connection ip.

            MessageBox( GETRESOURCEIDSTRING( IDS_INVAL_DHCP_NIC ),
                        GETRESOURCEIDSTRING( IDS_PARM_ERROR ),
                        MB_ICONSTOP | MB_OK );

            CPropertyPage::OnCancel();
            return 0;
        }
    }
              
    return CPropertyPage::OnKillActive();
}

void
HostPage::OnSelectedNicChanged()
{
    // do any changes if in fact 
    // user has changed selection.

    // get current selection
    int currentSelection = nicName.GetCurSel();
    if( m_previousSelection == currentSelection )
    {
        // the nic is the same so no need 
        // to do anything else.
        return;
    }
    
    m_previousSelection = currentSelection;

    detailedNicInfo.SetWindowText( m_nicList[currentSelection].fullNicName );

    if( find( m_nicList[currentSelection].ipsOnNic.begin(),
              m_nicList[currentSelection].ipsOnNic.end(),
              m_clusterData->hosts[m_machine].connectionIP )
        !=
        m_nicList[currentSelection].ipsOnNic.end() )
    {
        // this is the connection nic
        
        // make the dip the connectionIP
        CommonUtils::fillCIPAddressCtrlString( 
            ipAddress,
            m_clusterData->hosts[m_machine].connectionIP );

        _bstr_t defaultConnectionIPSubnet;
        MIPAddress::getDefaultSubnetMask( m_clusterData->hosts[m_machine].connectionIP,
                                          defaultConnectionIPSubnet
                                          );

        CommonUtils::fillCIPAddressCtrlString( 
            subnetMask,
            defaultConnectionIPSubnet );

    }
    else
    {
        // this is not the connection nic

        // make the dip blank.
        CommonUtils::fillCIPAddressCtrlString( 
            ipAddress,
            L"0.0.0.0"  );

        // make the subnet also  blank.
        CommonUtils::fillCIPAddressCtrlString( 
            subnetMask,
            L"0.0.0.0"  );

    }
}

BOOL
HostPage::OnHelpInfo (HELPINFO* helpInfo )
{
    if( helpInfo->iContextType == HELPINFO_WINDOW )
    {
        ::WinHelp( static_cast<HWND> ( helpInfo->hItemHandle ), CVY_CTXT_HELP_FILE, HELP_WM_HELP, (ULONG_PTR ) g_aHelpIDs_IDD_HOST_PAGE);
    }

    return TRUE;
}

void
HostPage::OnContextMenu( CWnd* pWnd, CPoint point )
{
    ::WinHelp( m_hWnd, CVY_CTXT_HELP_FILE, HELP_CONTEXTMENU, (ULONG_PTR ) g_aHelpIDs_IDD_HOST_PAGE);
}

void
HostPage::OnGainFocusDedicatedIP()
{
}



void
HostPage::OnGainFocusDedicatedMask()
{
    // if dedicated ip is valid
    // and subnet mask is blank, then generate
    // the default subnet mask.
    _bstr_t ipAddressString = CommonUtils::getCIPAddressCtrlString( ipAddress );

    if( ( MIPAddress::checkIfValid( ipAddressString ) == true ) 
        &&
        ( subnetMask.IsBlank() == TRUE )
        )
    {
        _bstr_t subnetMaskString;

        MIPAddress::getDefaultSubnetMask( ipAddressString,
                                          subnetMaskString );

        CommonUtils::fillCIPAddressCtrlString( subnetMask,
                                               subnetMaskString );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\exe\hostportspage.h ===
#ifndef HOSTPORTSPAGE_H
#define HOSTPORTSPAGE_H

#include "stdafx.h"

#include "resource.h"

#include "MNLBUIData.h"
#include "CommonNLB.h"

class HostPortsPage : public CPropertyPage
{
    
public:
    enum
    {
        IDD = IDD_DIALOG_PORTS,
    };

    HostPortsPage( const _bstr_t& myMachineName,
                   ClusterData*         p_clusterData,
                   UINT                 ID = HostPortsPage::IDD );

    ~HostPortsPage();

    // overrides of CPropertyPage
    virtual BOOL OnInitDialog();

    virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support    

    CListCtrl	m_portList;

private:

    ClusterData* m_clusterData;

    void
    SetControlData();

    _bstr_t machine;

    DECLARE_MESSAGE_MAP()

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\exe\hostportspage.cpp ===
#include "stdafx.h"
#include "HostPortsPage.h"
#include "Document.h"
#include "ResourceString.h"

HostPortsPage::HostPortsPage( const _bstr_t& myMachineName,
                              ClusterData*        p_clusterData,
                              UINT                ID)
        : CPropertyPage(ID),
          m_clusterData( p_clusterData ),
          machine( myMachineName )
{}


HostPortsPage:: ~HostPortsPage()
{}

void HostPortsPage::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);

    DDX_Control(pDX, IDC_LIST_PORT_RULE, m_portList);
}

BEGIN_MESSAGE_MAP(HostPortsPage, CPropertyPage)

END_MESSAGE_MAP()

BOOL
HostPortsPage::OnInitDialog()
{
    CPropertyPage::OnInitDialog();

    m_portList.InsertColumn( 0, 
                             GETRESOURCEIDSTRING( IDS_HEADER_P_START ) , 
                             LVCFMT_LEFT, 
                             Document::LV_COLUMN_SMALL );
    m_portList.InsertColumn( 1, 
                             GETRESOURCEIDSTRING( IDS_HEADER_P_END ), 
                             LVCFMT_LEFT, 
                             Document::LV_COLUMN_SMALL );
    m_portList.InsertColumn( 2, 
                             GETRESOURCEIDSTRING( IDS_HEADER_P_PROTOCOL ),
                             LVCFMT_LEFT, 
                             Document::LV_COLUMN_SMALL );
    m_portList.InsertColumn( 3, 
                             GETRESOURCEIDSTRING( IDS_HEADER_P_MODE ),
                             LVCFMT_LEFT, 
                             Document::LV_COLUMN_SMALL );
    m_portList.InsertColumn( 4, 
                             GETRESOURCEIDSTRING( IDS_HEADER_P_PRIORITY ),
                             LVCFMT_LEFT, 
                             Document::LV_COLUMN_SMALL );
    m_portList.InsertColumn( 5, 
                             GETRESOURCEIDSTRING( IDS_HEADER_P_LOAD ),
                             LVCFMT_LEFT, 
                             Document::LV_COLUMN_SMALL );
    m_portList.InsertColumn( 6, 
                             GETRESOURCEIDSTRING( IDS_HEADER_P_AFFINITY ),
                             LVCFMT_LEFT, 
                             Document::LV_COLUMN_SMALL );

    m_portList.SetExtendedStyle( m_portList.GetExtendedStyle() | LVS_EX_FULLROWSELECT );

    SetControlData();

    int numItems = m_portList.GetItemCount();

    if( numItems > 0 )
    {
        m_portList.SetItemState( 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED );
    }

    
    return TRUE;
}

void
HostPortsPage::SetControlData()
{
    int index = 0;
    map< long, PortDataELB>::iterator topELB;
    for( topELB = m_clusterData->portELB.begin();
         topELB != m_clusterData->portELB.end();
         ++topELB )
    {

        wchar_t buf[100];

        // start port
        swprintf( buf, L"%d", (*topELB).second._startPort );
        LVITEM item;
        item.mask = LVIF_TEXT | LVIF_IMAGE;
        item.iItem = index;
        item.iSubItem = 0;
        item.iImage = 2;
        item.pszText = buf;
        item.cchTextMax = 100;
        m_portList.InsertItem( &item );

        // end port
        swprintf( buf, L"%d", (*topELB).second._endPort );
        item.mask = LVIF_TEXT;
        item.iItem = index;
        item.iSubItem = 1;	 
        item.pszText = buf;
        item.cchTextMax = 100;
        m_portList.SetItem( &item );

        // protocol
        item.mask = LVIF_TEXT; 
        item.iItem = index;
        item.iSubItem = 2;	 
        switch( (*topELB).second._trafficToHandle )
        {
            case MNLBPortRule::both :
                item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_BOTH );
                break;

            case MNLBPortRule::tcp :
                item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_TCP );
                break;

            case MNLBPortRule::udp :
                item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_UDP );
                break;
        }
        item.cchTextMax = 100;
        m_portList.SetItem( &item );

        // mode 
        item.mask = LVIF_TEXT; 
        item.iItem = index;
        item.iSubItem = 3;	 
        item.pszText = GETRESOURCEIDSTRING(IDS_REPORT_MODE_MULTIPLE );
        item.cchTextMax = 100;
        m_portList.SetItem( &item );
                
        // priority
        item.mask = LVIF_TEXT; 
        item.iItem = index;
        item.iSubItem = 4;	 
        item.pszText = GETRESOURCEIDSTRING(IDS_REPORT_EMPTY );
        item.cchTextMax = 100;
        m_portList.SetItem( &item );

        // load
        item.mask = LVIF_TEXT; 
        item.iItem = index;
        item.iSubItem = 5;	 
        item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_LOAD_EQUAL );
        item.cchTextMax = 100;
        m_portList.SetItem( &item );

        // affinity
        item.mask = LVIF_TEXT; 
        item.iItem = index;
        item.iSubItem = 6;	 
        switch( (*topELB).second._affinity )
        {
            case MNLBPortRule::none :
                item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_AFFINITY_NONE );
                break;

            case MNLBPortRule::single :
                item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_AFFINITY_SINGLE );
                break;

            case MNLBPortRule::classC :
                item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_AFFINITY_CLASSC );
                break;
        }
        item.cchTextMax = 100;
        m_portList.SetItem( &item );

        ++index;
    }

    index = 0;
    map< long, PortDataULB>::iterator topULB;
    for( topULB = m_clusterData->portULB.begin();
         topULB != m_clusterData->portULB.end();
         ++topULB )
    {

        wchar_t buf[100];

        // start port
        swprintf( buf, L"%d", (*topULB).second._startPort );
        LVITEM item;
        item.mask = LVIF_TEXT | LVIF_IMAGE;
        item.iItem = index;
        item.iSubItem = 0;
        item.iImage = 2;
        item.pszText = buf;
        item.cchTextMax = 100;
        m_portList.InsertItem( &item );

        // end port
        swprintf( buf, L"%d", (*topULB).second._endPort );
        item.mask = LVIF_TEXT;
        item.iItem = index;
        item.iSubItem = 1;	 
        item.pszText = buf;
        item.cchTextMax = 100;
        m_portList.SetItem( &item );

        // protocol
        item.mask = LVIF_TEXT; 
        item.iItem = index;
        item.iSubItem = 2;	 
        switch( (*topULB).second._trafficToHandle )
        {
            case MNLBPortRule::both :
                item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_BOTH );
                break;

            case MNLBPortRule::tcp :
                item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_TCP );
                break;

            case MNLBPortRule::udp :
                item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_UDP );
                break;
        }
        item.cchTextMax = 100;
        m_portList.SetItem( &item );

        // mode 
        item.mask = LVIF_TEXT; 
        item.iItem = index;
        item.iSubItem = 3;	 
        item.pszText = GETRESOURCEIDSTRING(IDS_REPORT_MODE_MULTIPLE );
        item.cchTextMax = 100;
        m_portList.SetItem( &item );
                
        // priority
        item.mask = LVIF_TEXT; 
        item.iItem = index;
        item.iSubItem = 4;	 
        item.pszText = GETRESOURCEIDSTRING(IDS_REPORT_EMPTY );
        item.cchTextMax = 100;
        m_portList.SetItem( &item );

        // load
        item.mask = LVIF_TEXT; 
        item.iItem = index;
        item.iSubItem = 5;	 
        swprintf( buf, L"%d", (*topULB).second.machineMapToLoadWeight[machine] );
        item.pszText = buf;
        item.cchTextMax = 100;
        m_portList.SetItem( &item );

        // affinity
        item.mask = LVIF_TEXT; 
        item.iItem = index;
        item.iSubItem = 6;	 
        switch( (*topULB).second._affinity )
        {
            case MNLBPortRule::none :
                item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_AFFINITY_NONE );
                break;

            case MNLBPortRule::single :
                item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_AFFINITY_SINGLE );
                break;

            case MNLBPortRule::classC :
                item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_AFFINITY_CLASSC );
                break;
        }
        item.cchTextMax = 100;
        m_portList.SetItem( &item );

        ++index;
    }

    index = 0;
    map< long, PortDataF>::iterator topF;
    for( topF = m_clusterData->portF.begin();
         topF != m_clusterData->portF.end();
         ++topF )
    {

        wchar_t buf[100];

        // start port
        swprintf( buf, L"%d", (*topF).second._startPort );
        LVITEM item;
        item.mask = LVIF_TEXT | LVIF_IMAGE;
        item.iItem = index;
        item.iSubItem = 0;
        item.iImage = 2;
        item.pszText = buf;
        item.cchTextMax = 100;
        m_portList.InsertItem( &item );

        // end port
        swprintf( buf, L"%d", (*topF).second._endPort );
        item.mask = LVIF_TEXT;
        item.iItem = index;
        item.iSubItem = 1;	 
        item.pszText = buf;
        item.cchTextMax = 100;
        m_portList.SetItem( &item );

        // protocol
        item.mask = LVIF_TEXT; 
        item.iItem = index;
        item.iSubItem = 2;	 
        switch( (*topF).second._trafficToHandle )
        {
            case MNLBPortRule::both :
                item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_BOTH );
                break;

            case MNLBPortRule::tcp :
                item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_TCP );
                break;

            case MNLBPortRule::udp :
                item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_UDP );
                break;
        }
        item.cchTextMax = 100;
        m_portList.SetItem( &item );

        // mode 
        item.mask = LVIF_TEXT; 
        item.iItem = index;
        item.iSubItem = 3;	 
        item.pszText = GETRESOURCEIDSTRING(IDS_REPORT_MODE_SINGLE );
        item.cchTextMax = 100;
        m_portList.SetItem( &item );
                
        // priority
        item.mask = LVIF_TEXT; 
        item.iItem = index;
        item.iSubItem = 4;	 
        swprintf( buf, L"%d", (*topF).second.machineMapToPriority[machine] );
        item.pszText = buf;
        item.cchTextMax = 100;
        m_portList.SetItem( &item );

        // load
        item.mask = LVIF_TEXT; 
        item.iItem = index;
        item.iSubItem = 5;	 
        item.pszText = GETRESOURCEIDSTRING(IDS_REPORT_EMPTY );
        item.cchTextMax = 100;
        m_portList.SetItem( &item );

        // affinity
        item.mask = LVIF_TEXT; 
        item.iItem = index;
        item.iSubItem = 6;	
        item.pszText = GETRESOURCEIDSTRING(IDS_REPORT_EMPTY );
        item.cchTextMax = 100;
        m_portList.SetItem( &item );

        ++index;
    }

    index = 0;
    map< long, PortDataD>::iterator topD;
    for( topD = m_clusterData->portD.begin();
         topD != m_clusterData->portD.end();
         ++topD )
    {

        wchar_t buf[100];

        // start port
        swprintf( buf, L"%d", (*topD).second._startPort );
        LVITEM item;
        item.mask = LVIF_TEXT | LVIF_IMAGE;
        item.iItem = index;
        item.iSubItem = 0;
        item.iImage = 2;
        item.pszText = buf;
        item.cchTextMax = 100;
        m_portList.InsertItem( &item );

        // end port
        swprintf( buf, L"%d", (*topD).second._endPort );
        item.mask = LVIF_TEXT;
        item.iItem = index;
        item.iSubItem = 1;	 
        item.pszText = buf;
        item.cchTextMax = 100;
        m_portList.SetItem( &item );

        // protocol
        item.mask = LVIF_TEXT; 
        item.iItem = index;
        item.iSubItem = 2;	 
        switch( (*topD).second._trafficToHandle )
        {
            case MNLBPortRule::both :
                item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_BOTH );
                break;

            case MNLBPortRule::tcp :
                item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_TCP );
                break;

            case MNLBPortRule::udp :
                item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_UDP );
                break;
        }
        item.cchTextMax = 100;
        m_portList.SetItem( &item );

        // mode 
        item.mask = LVIF_TEXT; 
        item.iItem = index;
        item.iSubItem = 3;	 
        item.pszText = GETRESOURCEIDSTRING(IDS_REPORT_MODE_DISABLED );
        item.cchTextMax = 100;
        m_portList.SetItem( &item );
                
        // priority
        item.mask = LVIF_TEXT; 
        item.iItem = index;
        item.iSubItem = 4;	 
        item.pszText = GETRESOURCEIDSTRING(IDS_REPORT_EMPTY );
        item.cchTextMax = 100;
        m_portList.SetItem( &item );

        // load
        item.mask = LVIF_TEXT; 
        item.iItem = index;
        item.iSubItem = 5;	 
        item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_EMPTY );
        item.cchTextMax = 100;
        m_portList.SetItem( &item );

        // affinity
        item.mask = LVIF_TEXT; 
        item.iItem = index;
        item.iSubItem = 6;	 
        item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_EMPTY );
        item.cchTextMax = 100;
        m_portList.SetItem( &item );

        ++index;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\exe\hostportsdlg.h ===
#ifndef HOSTPORTSDLG_H
#define HOSTPORTSDLG_H

#include "stdafx.h"

#include "resource.h"

#include "MNLBUIData.h"
#include "CommonNLB.h"

// forward declaration
class PortsPage;

class HostPortsDlg : public CDialog
{
    
public:
    enum
    {
        IDD = IDD_DIALOG_PORT_RULE_PROP_HOSTS,
    };

    HostPortsDlg( PortsPage::PortData& portData,
                  CWnd* parent
                     );

    // overrides of CDialog
    virtual void DoDataExchange( CDataExchange* pDX );

    virtual void OnOK();

    virtual BOOL OnInitDialog();

    afx_msg BOOL OnHelpInfo (HELPINFO* helpInfo );

    afx_msg void OnContextMenu( CWnd* pWnd, CPoint point );

    // message handlers

    // 
    CComboBox   m_priority;

private:

    PortsPage::PortData& m_portData;

    PortsPage* m_parent;

    void
    SetControlData();

    DECLARE_MESSAGE_MAP()

};

static DWORD g_aHelpIDs_IDD_PORT_RULE_PROP_HOSTS [] = {
    IDC_GROUP_RANGE,              IDC_GROUP_RANGE,
    IDC_TEXT_START,               IDC_EDIT_START,
    IDC_EDIT_START,               IDC_EDIT_START,
    IDC_SPIN_START,               IDC_EDIT_START,
    IDC_TEXT_END,                 IDC_EDIT_END,
    IDC_EDIT_END,                 IDC_EDIT_END,
    IDC_SPIN_END,                 IDC_EDIT_END,
    IDC_GROUP_PROTOCOLS,          IDC_GROUP_PROTOCOLS,
    IDC_RADIO_TCP,                IDC_RADIO_TCP,
    IDC_RADIO_UDP,                IDC_RADIO_UDP,
    IDC_RADIO_BOTH,               IDC_RADIO_BOTH,
    IDC_GROUP_DISABLED,           IDC_GROUP_DISABLED,
    IDC_GROUP_SINGLE,             IDC_GROUP_SINGLE,
    IDC_GROUP_MULTIPLE,           IDC_GROUP_MULTIPLE,
    IDC_RADIO_MULTIPLE,           IDC_RADIO_MULTIPLE,
    IDC_RADIO_SINGLE,             IDC_RADIO_SINGLE,
    IDC_RADIO_DISABLED,           IDC_RADIO_DISABLED,
    IDC_TEXT_AFF,                 IDC_TEXT_AFF,
    IDC_RADIO_AFF_NONE,           IDC_RADIO_AFF_NONE,
    IDC_RADIO_AFF_SINGLE,         IDC_RADIO_AFF_SINGLE,
    IDC_RADIO_AFF_CLASSC,         IDC_RADIO_AFF_CLASSC,
    IDC_TEXT_MULTI,               IDC_TEXT_MULTI,
    IDC_EDIT_MULTI,               IDC_EDIT_MULTI,
    IDC_SPIN_MULTI,               IDC_EDIT_MULTI,
    IDC_CHECK_EQUAL,              IDC_CHECK_EQUAL,
    IDC_TEXT_SINGLE,              IDC_EDIT_SINGLE,
    IDC_EDIT_SINGLE,              IDC_EDIT_SINGLE,
    0, 0
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\exe\ipsubnetmaskcontrol.cpp ===
#include "stdafx.h"
#include <stdio.h>
#include <process.h>
#include "IpSubnetMaskControl.h"
#include "wlbsconfig.h"
#include "wlbsutil.h"

/* Limitations for IP address fields. */
#define WLBS_FIELD_EMPTY -1
#define WLBS_FIELD_LOW 0
#define WLBS_FIELD_HIGH 255

#define WLBS_BLANK_HPRI -1

void PrintIPRangeError(HINSTANCE hInstance, HWND hWnd, unsigned int ids, int value, int low, int high);


CIpSubnetMaskControl::CIpSubnetMaskControl(DWORD dwIpAddressId, DWORD dwSubnetMaskId) 
{
    m_dwIpAddressId = dwIpAddressId;
    m_dwSubnetMaskId = dwSubnetMaskId;
    m_hWndDialog = NULL;
    m_hInstance = NULL;

    ZeroMemory(&m_IPFieldChangeState, sizeof(m_IPFieldChangeState));
}


//+----------------------------------------------------------------------------
//
// Function:  CIpSubnetMaskControl::OnInitDialog
//
// Description:  Called upon WM_INITDIALOG message.  
//
// Arguments: HWND hWnd - the parent dialog window
//            HINSTANCE hInstance - instance handle for resources
//
// Returns:   Nothing
//
// History:   fengsun Created Header    1/10/01
//
//+----------------------------------------------------------------------------
void CIpSubnetMaskControl::OnInitDialog(HWND hWnd, HINSTANCE hInstance) 
{
    m_hWndDialog = hWnd;
    m_hInstance = hInstance;

    /* Limit the field ranges for the address fields. */
    ::SendDlgItemMessage(hWnd, m_dwIpAddressId, EM_SETLIMITTEXT, CVY_MAX_CL_IP_ADDR, 0);
    ::SendDlgItemMessage(hWnd, m_dwSubnetMaskId, EM_SETLIMITTEXT, CVY_MAX_CL_NET_MASK, 0);

    /* Limit the zeroth field of the dedicated IP address between 1 and 223. */
    ::SendDlgItemMessage(m_hWndDialog, m_dwIpAddressId, IPM_SETRANGE, 0, (LPARAM)MAKEIPRANGE(WLBS_IP_FIELD_ZERO_LOW, WLBS_IP_FIELD_ZERO_HIGH));
}



/*
 * Method: OnSubnetMask
 * Description: Called when the user modifies the host netmask.
 */
LRESULT CIpSubnetMaskControl::OnSubnetMask(WORD wNotifyCode) 
{
    WCHAR wszIpAddress [CVY_MAX_CL_IP_ADDR + 1];
    WCHAR wszSubnetMask [CVY_MAX_CL_NET_MASK + 1];

    switch (wNotifyCode) 
    {
        case EN_SETFOCUS:
            /* Only generate a netmask if the netmask is currently empty and the IP address is not. */
            if (::SendMessage(::GetDlgItem(m_hWndDialog, m_dwSubnetMaskId), IPM_ISBLANK, 0, 0) &&
                !::SendMessage(::GetDlgItem(m_hWndDialog, m_dwIpAddressId), IPM_ISBLANK, 0, 0)) 
            {
                /* Retrieve the cluster IP address. */
                ::SendDlgItemMessage(m_hWndDialog, m_dwIpAddressId, WM_GETTEXT, CVY_MAX_CL_IP_ADDR + 1, (LPARAM)wszIpAddress);

                /* Fill the subnet mask. */
                ParamsGenerateSubnetMask(wszIpAddress, wszSubnetMask);

                /* Set the cluster subnet mask. */
                ::SendDlgItemMessage(m_hWndDialog, m_dwSubnetMaskId, WM_SETTEXT, 0, (LPARAM)wszSubnetMask);

                break;
            }
    }

    return 0;
}






/*
 * Method: OnIpFieldChange
 * Description: Called wnen a field (byte) of the IP address/subnetmask changes. We use this
 *              to make sure the first byte of the IP is not < 1 or > 223.
 */
LRESULT CIpSubnetMaskControl::OnIpFieldChange(int idCtrl, LPNMHDR pnmh) 
{
    LPNMIPADDRESS Ip;
    int low = WLBS_FIELD_LOW;
    int high = WLBS_FIELD_HIGH;

    Ip = (LPNMIPADDRESS)pnmh;

    if (idCtrl == m_dwIpAddressId)
    {
        /* Field zero of the cluster IP address has different limits. */
        if (!Ip->iField) 
        {
            low = WLBS_IP_FIELD_ZERO_LOW;
            high = WLBS_IP_FIELD_ZERO_HIGH;
        }        
    }

    /* The notifier may call us twice for the same change, so we have to do the bookkeeping to make 
       sure we only alert the user once.  Use static variables to keep track of our state.  This will 
       allow us to ignore duplicate alerts. */
    if ((m_IPFieldChangeState.IpControl != Ip->hdr.idFrom) || (m_IPFieldChangeState.Field != Ip->iField) || 
        (m_IPFieldChangeState.Value != Ip->iValue) || (m_IPFieldChangeState.RejectTimes > 0)) {
        m_IPFieldChangeState.RejectTimes = 0;
        m_IPFieldChangeState.IpControl = Ip->hdr.idFrom;
        m_IPFieldChangeState.Field = Ip->iField;
        m_IPFieldChangeState.Value = Ip->iValue;

        /* Check the field value against its limits. */
        if ((Ip->iValue != WLBS_FIELD_EMPTY) && ((Ip->iValue < low) || (Ip->iValue > high))) 
        {
            /* Alert the user. */
            PrintIPRangeError(m_hInstance, m_hWndDialog, 
                    (idCtrl == m_dwIpAddressId) ? IDS_PARM_CL_IP_FIELD : IDS_PARM_CL_NM_FIELD, 
                    Ip->iValue, low, high);
        }
    } else m_IPFieldChangeState.RejectTimes++;
        

    return 0;
}





//+----------------------------------------------------------------------------
//
// Function:  CIpSubnetMaskControl::SetInfo
//
// Description:  Set the value to the control
//
// Arguments: const WCHAR* pszIpAddress - 
//            const WCHAR* pszSubnetMask - 
//
// Returns:   Nothing
//
// History:  shouse initial code 
//           fengsun Created Header    1/10/01
//
//+----------------------------------------------------------------------------
void CIpSubnetMaskControl::SetInfo(const WCHAR* pszIpAddress, const WCHAR* pszSubnetMask)
{
    /* If the cluster IP address or subnet mask are the default values, set them to NUL strings. */

    /* If the dedicated IP address is empty, then clear the entry box.  Otherwise, populate it with the IP address. */
    if (!pszIpAddress[0] || !wcscmp(pszIpAddress, CVY_DEF_CL_IP_ADDR))
        ::SendMessage(::GetDlgItem(m_hWndDialog, m_dwIpAddressId), IPM_CLEARADDRESS, 0, 0);
    else
        ::SendDlgItemMessage(m_hWndDialog, m_dwIpAddressId, WM_SETTEXT, 0, (LPARAM)pszIpAddress);

    /* If the host subnet mask is empty, then clear the entry box.  Otherwise, populate it with the netmask. */
    if (!pszSubnetMask[0] || !wcscmp(pszSubnetMask, CVY_DEF_CL_NET_MASK))
        ::SendMessage(::GetDlgItem(m_hWndDialog, m_dwSubnetMaskId), IPM_CLEARADDRESS, 0, 0);
    else
        ::SendDlgItemMessage(m_hWndDialog, m_dwSubnetMaskId, WM_SETTEXT, 0, (LPARAM)pszSubnetMask);
}






//+----------------------------------------------------------------------------
//
// Function:  CIpSubnetMaskControl::UpdateInfo
//
// Description:  Retrieve value from control
//
// Arguments: OUT WCHAR* pszIpAddress - 
//            OUT WCHAR* pszSubnetMask - 
//
// Returns:   Nothing
//
// History:  shouse initial code 
//           fengsun Created Header    1/10/01
//
//+----------------------------------------------------------------------------
void CIpSubnetMaskControl::UpdateInfo(OUT WCHAR* pszIpAddress, OUT WCHAR* pszSubnetMask) 
{
    /* If the dedicated IP entry box is empty, then the dedicated IP address is NUL.  Otherwise, grab it from the UI. */
    if (::SendMessage(::GetDlgItem(m_hWndDialog, m_dwIpAddressId), IPM_ISBLANK, 0, 0))
    {
        lstrcpy(pszIpAddress, CVY_DEF_CL_IP_ADDR);
    }
    else
    {
        ::SendDlgItemMessage(m_hWndDialog, m_dwIpAddressId, WM_GETTEXT, CVY_MAX_CL_IP_ADDR, (LPARAM)pszIpAddress);
    }

    /* If the host net mask entry box is empty, then the host net mask is NUL.  Otherwise, grab it from the UI. */
    if (::SendMessage(::GetDlgItem(m_hWndDialog, m_dwSubnetMaskId), IPM_ISBLANK, 0, 0))
    {
        lstrcpy(pszSubnetMask, CVY_DEF_CL_NET_MASK);
    }
    else
    {
        ::SendDlgItemMessage(m_hWndDialog, m_dwSubnetMaskId, WM_GETTEXT, CVY_MAX_CL_NET_MASK, (LPARAM)pszSubnetMask);
    }
}



//+----------------------------------------------------------------------------
//
// Function:  CIpSubnetMaskControl::ValidateInfo
//
// Description:  Validate whether user input is valid
//
// Arguments: None
//
// Returns:   bool - TRUE if valid
//
// History:  shouse initial code 
//           fengsun Created Header    1/10/01
//
//+----------------------------------------------------------------------------
bool CIpSubnetMaskControl::ValidateInfo() 
{
    DWORD IPAddr;

    /* Check for blank IP address */
    if (::SendMessage(::GetDlgItem(m_hWndDialog, m_dwIpAddressId), IPM_ISBLANK, 0, 0)) 
    {
        /* Alert the user. */
        NcMsgBox(m_hInstance, ::GetActiveWindow(), IDS_PARM_ERROR, IDS_PARM_CL_IP_BLANK,
                 MB_APPLMODAL | MB_ICONSTOP | MB_OK);

        SetFocus(::GetDlgItem(m_hWndDialog, m_dwIpAddressId));

        /* An error occurred. */
        return false;
    }

    /* Check for blank netmask */
    if (::SendMessage(::GetDlgItem(m_hWndDialog, m_dwSubnetMaskId), IPM_ISBLANK, 0, 0)) 
    {
        /* Fill in the netmask for the user. */
        OnSubnetMask(EN_SETFOCUS);

        /* Alert the user. */
        NcMsgBox(m_hInstance, ::GetActiveWindow(), IDS_PARM_ERROR, IDS_PARM_CL_NM_BLANK,
                 MB_APPLMODAL | MB_ICONSTOP | MB_OK);

        /* An error occurred. */
        return false;
    }

    /* Only perform the rest of the IP checking if the user has specified both a dedicated
       IP address and a corresponding netmask. */
    if (!::SendMessage(::GetDlgItem(m_hWndDialog, m_dwIpAddressId), IPM_ISBLANK, 0, 0) &&
        !::SendMessage(::GetDlgItem(m_hWndDialog, m_dwSubnetMaskId), IPM_ISBLANK, 0, 0)) {
        /* Get the dedicated IP address. */
        ::SendDlgItemMessage(m_hWndDialog, m_dwIpAddressId, IPM_GETADDRESS, 0, (LPARAM)&IPAddr);
        
        /* Make sure that the first octet is not zero.  If it is, make it 1 and alter the user. */
        if (!FIRST_IPADDRESS(IPAddr)) {
            /* Make the first octet 1 instead of the erroneous 0. */
            IPAddr = IPAddr | (DWORD)(WLBS_IP_FIELD_ZERO_LOW << 24);
            
            /* Set the IP address and update our dedicated IP address string. */
            ::SendDlgItemMessage(m_hWndDialog, m_dwIpAddressId, IPM_SETADDRESS, 0, (LPARAM)IPAddr);
            
            /* Alert the user. */
            PrintIPRangeError(m_hInstance, m_hWndDialog, IDS_PARM_CL_IP_FIELD, 0, 
                            WLBS_IP_FIELD_ZERO_LOW, WLBS_IP_FIELD_ZERO_HIGH);

            SetFocus(::GetDlgItem(m_hWndDialog, m_dwIpAddressId));
            return false;
        }

        WCHAR szIpAddress [CVY_MAX_CL_IP_ADDR + 1];
        WCHAR szSubnetMask [CVY_MAX_CL_IP_ADDR + 1];

        ::SendDlgItemMessage(m_hWndDialog, m_dwIpAddressId, WM_GETTEXT, CVY_MAX_CL_IP_ADDR, (LPARAM)szIpAddress);
        ::SendDlgItemMessage(m_hWndDialog, m_dwSubnetMaskId, WM_GETTEXT, CVY_MAX_CL_NET_MASK, (LPARAM)szSubnetMask);

        /* Check for valid dedicated IP address/netmask pairs. */
        if (!IsValidIPAddressSubnetMaskPair(szIpAddress, szSubnetMask)) {
            /* Alert the user. */
            NcMsgBox(m_hInstance, ::GetActiveWindow(), IDS_PARM_ERROR, IDS_PARM_INVAL_CL_IP,
                     MB_APPLMODAL | MB_ICONSTOP | MB_OK);
            
            SetFocus(::GetDlgItem(m_hWndDialog, m_dwIpAddressId));

            /* An error occurred. */
            return false;
        }
        
        /* Check to make sure that the netmask is contiguous. */
        if (!IsContiguousSubnetMask(szSubnetMask)) {
            /* Alert the user. */
            NcMsgBox(m_hInstance, ::GetActiveWindow(), IDS_PARM_ERROR, IDS_PARM_INVAL_CL_MASK,
                     MB_APPLMODAL | MB_ICONSTOP | MB_OK);
            
            SetFocus(::GetDlgItem(m_hWndDialog, m_dwIpAddressId));

            /* An error occurred. */
            return false;
        }
    }

    return true;  // no error
}


/*
 * Method: PrintIPRangeError
 * Description: Displays a message box warning the user of an out-of-range entry in
 *              an IP address octet.
 */
void PrintIPRangeError (HINSTANCE hInstance, HWND hWnd, unsigned int ids, int value, int low, int high) 
{
    WCHAR szCurrent[10];
    WCHAR szLow[10];
    WCHAR szHigh[10];

    /* Fill in the range and the offending value. */
    wsprintfW(szHigh, L"%d", high);
    wsprintfW(szCurrent, L"%d", value);
    wsprintfW(szLow, L"%d", low);
    
    /* Pop-up a message box. */
    NcMsgBox(hInstance, hWnd, IDS_PARM_ERROR, ids, MB_APPLMODAL | MB_ICONSTOP | MB_OK, szCurrent, szLow, szHigh);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\exe\ipsubnetmaskcontrol.h ===
#pragma once

#include "resource.h"
#include "wlbsparm.h"

#define WLBS_IP_FIELD_ZERO_LOW 1
#define WLBS_IP_FIELD_ZERO_HIGH 223


//+----------------------------------------------------------------------------
//
// class CIpSubnetMaskControl
//
// Description: Add error checking for an IP address and subnet mask pair.
//              Generate default subnetmask based on ip
//
// History:     shouse initial code
//              fengsun Created class    1/12/01
//
//+----------------------------------------------------------------------------
class CIpSubnetMaskControl
{
public:
    CIpSubnetMaskControl(DWORD dwIpAddressResourceId, DWORD dwSubnetMaskResourceId);
    ~CIpSubnetMaskControl(){};

    void OnInitDialog(HWND hWnd, HINSTANCE hInstance);

    LRESULT OnSubnetMask(WORD wNotifyCode);
    LRESULT OnIpFieldChange(int idCtrl, LPNMHDR pnmh);

    void SetInfo(const WCHAR* pszIpAddress, const WCHAR* pszSubnetMask);
    void UpdateInfo(OUT WCHAR* pszIpAddress, OUT WCHAR* pszSubnetMask);
    bool ValidateInfo();

protected:

    DWORD m_dwIpAddressId;
    DWORD m_dwSubnetMaskId;
    HWND  m_hWndDialog;  // parent dialog window handle
    HINSTANCE m_hInstance; // instance handle for error string resource

    //
    // The PropertySheet may call us twice for the same change, so we have to do the bookkeeping to make 
    // sure we only alert the user once.  Use static variables to keep track of our state.  This will 
    //        allow us to ignore duplicate alerts. 
    //
    struct {
        UINT IpControl;
        int Field;
        int Value;
        UINT RejectTimes;
    } m_IPFieldChangeState;
};


INT
WINAPIV
NcMsgBox (
    IN HINSTANCE   hinst,
    IN HWND        hwnd,
    IN UINT        unIdCaption,
    IN UINT        unIdFormat,
    IN UINT        unStyle,
    IN ...);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\exe\machineconnectpage.cpp ===
#include "MachineConnectPage.h"
#include "Common.h"
#include "wlbsparm.h"

#include "CommonUtils.h"



BEGIN_MESSAGE_MAP( MachineConnectPage, CPropertyPage )
    ON_WM_HELPINFO()        
    ON_WM_CONTEXTMENU()        
END_MESSAGE_MAP()

void
MachineConnectPage::DoDataExchange( CDataExchange* pDX )
{
    CPropertyPage::DoDataExchange( pDX );

    DDX_Control( pDX, IDC_MACHINE, machineName );
}

MachineConnectPage::MachineConnectPage( _bstr_t* machine_name,
                                        UINT     ID )
        :
        CPropertyPage( ID ),
        m_machineName( machine_name )
{
}

void
MachineConnectPage::OnOK()
{
    _bstr_t machineIP = 
        CommonUtils::getCIPAddressCtrlString( machineName );
    
    *m_machineName = machineIP;

    CPropertyPage::OnOK();
}

BOOL
MachineConnectPage::OnHelpInfo (HELPINFO* helpInfo )
{
    if( helpInfo->iContextType == HELPINFO_WINDOW )
    {
        ::WinHelp( static_cast<HWND> ( helpInfo->hItemHandle ), 
                   CVY_CTXT_HELP_FILE, 
                   HELP_WM_HELP, 
                   (ULONG_PTR ) g_aHelpIDs_IDD_MACHINE_CONNECT_PAGE );
    }

    return TRUE;
}

void
MachineConnectPage::OnContextMenu( CWnd* pWnd, CPoint point )
{
    ::WinHelp( m_hWnd, 
               CVY_CTXT_HELP_FILE, 
               HELP_CONTEXTMENU, 
               (ULONG_PTR ) g_aHelpIDs_IDD_MACHINE_CONNECT_PAGE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\exe\machineconnectpage.h ===
#ifndef MACHINECONNECTPAGE_H
#define MACHINECONNECTPAGE_H

#include "stdafx.h"

#include "resource.h"

class MachineConnectPage : public CPropertyPage
{
public:
    enum
    {
        IDD = IDD_MACHINE_CONNECT_PAGE,
    };

    // member controls.
    MachineConnectPage( _bstr_t* machine_name,
                        UINT         ID = MachineConnectPage::IDD );

    CIPAddressCtrl          machineName;

    // overrides of CPropertyPage
    virtual void DoDataExchange( CDataExchange* pDX );

    virtual void OnOK();

    afx_msg BOOL OnHelpInfo (HELPINFO* helpInfo );

    afx_msg void OnContextMenu( CWnd* pWnd, CPoint point );

protected :

    _bstr_t* m_machineName;

    DECLARE_MESSAGE_MAP()
};

static DWORD g_aHelpIDs_IDD_MACHINE_CONNECT_PAGE [] = {
    IDC_TEXT_MACHINE, IDC_TEXT_MACHINE,
    IDC_MACHINE,      IDC_MACHINE,
    0,0
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\exe\leftview.h ===
#ifndef LEFTVIEW_H
#define LEFTVIEW_H

#include "stdafx.h"
#include "Document.h"

#include "MNLBUIData.h"
#include "DataSinkI.h"

class LeftView : public CTreeView, public DataSinkI
{
    DECLARE_DYNCREATE( LeftView )

public:

    virtual void OnInitialUpdate();

    LeftView();

    ~LeftView();

    // override of DataSinkI
    virtual void dataSink( _bstr_t data );

    bool
    doesClusterExistInView( const _bstr_t& clusterToCheck );

protected:
    Document* GetDocument();

private:
    TVINSERTSTRUCT rootItem;

    CString worldName;

    _bstr_t dataStore;

    _bstr_t title;

    void RefreshDirect();
    
    void RefreshIndirect();

    // message handlers.
    afx_msg void OnRButtonDown( UINT nFlags, CPoint point );

    // world level.
    afx_msg void OnWorldConnect();

    afx_msg void OnWorldConnectIndirect();

    afx_msg void OnWorldNewCluster();

    // cluster level.
    afx_msg void OnRefresh();

    
    afx_msg void OnClusterProperties();

    afx_msg void OnClusterManageVIPS();

    afx_msg void OnClusterRemove();

    afx_msg void OnClusterUnmanage();

    afx_msg void OnClusterAddHost();

    afx_msg void OnClusterControl(UINT nID );

    afx_msg void OnClusterPortControl(UINT nID );

    // host level
    afx_msg void OnHostProperties();

    afx_msg void OnHostRemove();

    afx_msg void OnHostControl(UINT nID );

    afx_msg void OnHostPortControl(UINT nID );

    // change in selection.
    afx_msg void OnSelchanged(NMHDR* pNMHDR, LRESULT* pResult);

    afx_msg void OnTest();

    void dumpClusterData( const ClusterData* clusterData );

    DECLARE_MESSAGE_MAP()
};    

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\exe\mainform.cpp ===
#include "MainForm.h"
#include "LeftView.h"
#include "RightTopView.h"
#include "RightBottomView.h"

#include "resource.h"

IMPLEMENT_DYNCREATE( MainForm, CFrameWnd )

BEGIN_MESSAGE_MAP( MainForm, CFrameWnd )

    ON_WM_CREATE()

END_MESSAGE_MAP()

MainForm::MainForm()
{
    m_bAutoMenuEnable = FALSE;
}

int 
MainForm::OnCreate( LPCREATESTRUCT lpCreateStruct )
{
    static const unsigned int indicator = ID_SEPARATOR;

    if (CFrameWnd::OnCreate(lpCreateStruct) == -1)
        return -1;

    statusBar.Create( this );
    statusBar.SetIndicators( &indicator, 1 );

#if 0
    if ( !toolBar.CreateEx(this, TBSTYLE_FLAT, WS_CHILD | WS_VISIBLE  | CBRS_TOP
                          | CBRS_GRIPPER | CBRS_TOOLTIPS | CBRS_FLYBY | CBRS_SIZE_DYNAMIC) 
        ||
        !toolBar.LoadToolBar(IDR_MAINFRAME) )
        return -1;
#endif

    return 0;
}

BOOL MainForm::PreCreateWindow(CREATESTRUCT& cs)
{
    if( !CFrameWnd::PreCreateWindow(cs) )
        return FALSE;
    // The following will prevent the "-" getting added to the window title
    cs.style &= ~FWS_ADDTOTITLE;
    return TRUE;
}

BOOL
MainForm::OnCreateClient( LPCREATESTRUCT lpcs, CCreateContext* pContext )
{
#if 0

    // create the splitter window.
    // it is really a splitter within a splitter

    //  ---------------------------------
    //  |        | List                 |
    //  |        |                      |
    //  |        |                      |
    //  | Tree   |                      |
    //  |        -----------------------|
    //  |        | Edit                 |
    //  |        |                      |
    //  |        |                      |
    //  ---------------------------------

 
    // left pane is a treeview control
    // right pane is another splitter with listview control
    // and editview control.
    splitterWindow.CreateStatic( this, 1, 2 );

    // create left hand tree view.
    splitterWindow.CreateView( 0, 
                               0, 
                               RUNTIME_CLASS( LeftView ),
                               CSize( 300, 300 ),
                               pContext );

    // create nested splitter.
    splitterWindow2.CreateStatic( &splitterWindow, 2, 1,
                                  WS_CHILD | WS_VISIBLE | WS_BORDER,
                                  splitterWindow.IdFromRowCol( 0, 1 )
                                  );

    splitterWindow2.CreateView( 0, 
                                0, 
                                RUNTIME_CLASS( RightTopView ),
                                CSize( 100, 400 ),
                                pContext );

    splitterWindow2.CreateView( 1, 
                                0, 
                                RUNTIME_CLASS( RightBottomView ),
                                CSize( 100, 200 ),
                                pContext );


    return TRUE;

#else
    // create the splitter window.
    // it is really a splitter within a splitter

    //  ---------------------------------
    //  |        | List                 |
    //  |        |                      |
    //  | Tree   |                      |
    //  |        |                      |
    //  |-------------------------------|
    //  |        Edit                   |
    //  |                               |
    //  |                               |
    //  ---------------------------------

    // left pane is a treeview control
    // right pane is another splitter with listview control
    // and bottom is editview control.

    splitterWindow.CreateStatic( this, 2, 1 );


    // create nested splitter.
    splitterWindow2.CreateStatic( &splitterWindow, 1, 2,
                                  WS_CHILD | WS_VISIBLE | WS_BORDER,
                                  splitterWindow.IdFromRowCol( 0, 0 )
                                  );

    splitterWindow2.CreateView( 0, 
                                0, 
                                RUNTIME_CLASS( LeftView ),
                                CSize( 0, 0 ),
                                pContext );

    splitterWindow2.CreateView( 0, 
                                1, 
                                RUNTIME_CLASS( RightTopView ),
                                CSize( 0, 0 ),
                                pContext );



    // create bottom text view
    splitterWindow.CreateView( 1, 
                               0, 
                               RUNTIME_CLASS( RightBottomView ),
                               CSize( 0, 0 ),
                               pContext );


    // go for 30-70 split column split
    // and 60-40 row split.
    CRect rect;
    GetWindowRect( &rect );
    splitterWindow2.SetColumnInfo( 0, rect.Width() * 0.3, 10 );
    splitterWindow2.SetColumnInfo( 1, rect.Width() * 0.6, 10 );
    splitterWindow2.RecalcLayout();

    splitterWindow.SetRowInfo( 0, rect.Height() * 0.6, 10 );
    splitterWindow.SetRowInfo( 1, rect.Height() * 0.4, 10 );
    splitterWindow.RecalcLayout();

    return TRUE;

#endif
}


void
MainForm::clusterMenuClicked( CCmdUI* pCmdUI )
{
    return;

    // find out what is present selection
    // whether cluster, world or host.
    // disable all menu items if current selection 
    // not cluster level, else enable.
    //

    CTreeView* treeView = (CTreeView * ) splitterWindow2.GetPane( 0, 0 );
    
    // Find the item from TreeCtrl which has been selected.
    HTREEITEM hdlSelItem = treeView->GetTreeCtrl().GetSelectedItem();

    TVITEM  selItem;
    selItem.hItem = hdlSelItem;
    selItem.mask = TVIF_IMAGE ;
    
    treeView->GetTreeCtrl().GetItem( &selItem );

    int level;
    switch( selItem.iImage )
    {
        case 0: // this is world level.
            level = 0;
            break;

        case 1:  // this is some cluster
            level = 1;
            break;

        default:  // this has to be host.
            level = 2;
            break;
    }

    if( level == 1 )
    {
        pCmdUI->m_pMenu->EnableMenuItem( 
            ID_CLUSTER_ADD_HOST,
            MF_BYCOMMAND | MF_ENABLED );

        pCmdUI->m_pMenu->EnableMenuItem( 
            ID_CLUSTER_REMOVE,
            MF_BYCOMMAND | MF_ENABLED );

        pCmdUI->m_pMenu->EnableMenuItem( 
            ID_CLUSTER_PROPERTIES,
            MF_BYCOMMAND | MF_ENABLED );

        pCmdUI->m_pMenu->EnableMenuItem( 
            ID_CLUSTER_UNMANAGE,
            MF_BYCOMMAND | MF_ENABLED );

    }
    else
    {
        pCmdUI->m_pMenu->EnableMenuItem( 
            ID_CLUSTER_ADD_HOST,
            MF_BYCOMMAND | MF_GRAYED | MF_DISABLED );

        pCmdUI->m_pMenu->EnableMenuItem( 
            ID_CLUSTER_REMOVE,
            MF_BYCOMMAND | MF_GRAYED | MF_DISABLED );

        pCmdUI->m_pMenu->EnableMenuItem( 
            ID_CLUSTER_PROPERTIES,
            MF_BYCOMMAND | MF_GRAYED | MF_DISABLED );

        pCmdUI->m_pMenu->EnableMenuItem( 
            ID_CLUSTER_UNMANAGE,
            MF_BYCOMMAND | MF_GRAYED | MF_DISABLED );

    }

    this->DrawMenuBar();
}


void
MainForm::hostMenuClicked( CCmdUI* pCmdUI )
{
    return;

    // find out what is present selection
    // whether cluster, world or host.
    // disable all menu items if current selection 
    // not host level, else enable.
    //
    CTreeView* treeView = (CTreeView * ) splitterWindow2.GetPane( 0, 0 );
    
    // Find the item from TreeCtrl which has been selected.
    HTREEITEM hdlSelItem = treeView->GetTreeCtrl().GetSelectedItem();

    TVITEM  selItem;
    selItem.hItem = hdlSelItem;
    selItem.mask = TVIF_IMAGE ;
    
    treeView->GetTreeCtrl().GetItem( &selItem );

    int level;
    switch( selItem.iImage )
    {
        case 0: // this is world level.
            level = 0;
            break;

        case 1:  // this is some cluster
            level = 1;
            break;

        default:  // this has to be host.
            level = 2;
            break;
    }

    if( level == 2 )
    {
        pCmdUI->m_pMenu->EnableMenuItem( 
            pCmdUI->m_nID,
//            ID_HOST_REMOVE,
            MF_BYCOMMAND | MF_ENABLED );
    }
    else
    {
        pCmdUI->m_pMenu->EnableMenuItem( 
            pCmdUI->m_nID,
            MF_BYCOMMAND | MF_GRAYED | MF_DISABLED );

    }

    this->DrawMenuBar();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\exe\managevirtualipspage.h ===
#ifndef MANAGEVIRTUALIPSPAGE_H
#define MANAGEVIRTUALIPSPAGE_H

#include "stdafx.h"

#include "resource.h"

#include "MNLBUIData.h"

class ManageVirtualIPSPage : public CPropertyPage
{
public:
    enum
    {
        IDD = IDD_MANAGE_VIRTUAL_IPS_PAGE,
    };

    ManageVirtualIPSPage( ClusterData* p_clusterData,
                          UINT         ID = ManageVirtualIPSPage::IDD );

    // member controls
    CIPAddressCtrl clusterIP;

    CIPAddressCtrl virtualIP;

    CButton        addVirtualIP;

    CButton        removeVirtualIP;
    
    CListBox       virtualIPSList;

    // overrides of CPropertyPage
    virtual void DoDataExchange( CDataExchange* pDX );

    virtual BOOL OnInitDialog();

    virtual void OnOK();

    // message handlers
    afx_msg void OnAddVirtualIP();

    afx_msg void OnRemoveVirtualIP();

protected:
    ClusterData* m_clusterData;

    void
    SetControlData();

    void
    ReadControlData();


    DECLARE_MESSAGE_MAP()
        
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\exe\leftview.cpp ===
#include "LeftView.h"
#include "ClusterConnectPage.h"
#include "ClusterConnectIndirectPage.h"
#include "ManageVirtualIPSPage.h"
#include "MachineConnectPage.h"
#include "PortsControlPage.h"
#include "HostPage.h"
#include "ClusterPage.h"
#include "ResourceString.h"
#include "PortsPage.h"
#include "CommonNLB.h"

#include "MNLBUIData.h"
#include "MNLBNetCfg.h"
#include "MWmiError.h"

#include "MIPAddress.h"

#include "MIPAddressAdmin.h"

#include "resource.h"

#include <vector>
#include <algorithm>

using namespace std;

IMPLEMENT_DYNCREATE( LeftView, CTreeView )

BEGIN_MESSAGE_MAP( LeftView, CTreeView )
    ON_WM_RBUTTONDOWN()
    ON_COMMAND( ID_WORLD_CONNECT, OnWorldConnect )
    ON_COMMAND( ID_WORLD_CONNECT_INDIRECT, OnWorldConnectIndirect )
    ON_COMMAND( ID_WORLD_NEW, OnWorldNewCluster )
    ON_COMMAND( ID_REFRESH, OnRefresh )

    ON_COMMAND( ID_CLUSTER_PROPERTIES, OnClusterProperties )

    ON_COMMAND( ID_CLUSTER_MANAGE_VIPS, OnClusterManageVIPS )

    ON_COMMAND( ID_CLUSTER_REMOVE, OnClusterRemove )
    ON_COMMAND( ID_CLUSTER_UNMANAGE, OnClusterUnmanage )
    ON_COMMAND( ID_CLUSTER_ADD_HOST, OnClusterAddHost )

    ON_COMMAND_RANGE( ID_CLUSTER_EXE_QUERY, ID_CLUSTER_EXE_SUSPEND,
                      OnClusterControl )

    ON_COMMAND_RANGE( ID_CLUSTER_EXE_ENABLE, ID_CLUSTER_EXE_DRAIN, 
                      OnClusterPortControl )

    ON_COMMAND( ID_HOST_PROPERTIES, OnHostProperties )
    ON_COMMAND( ID_HOST_REMOVE, OnHostRemove )

    ON_COMMAND_RANGE( ID_HOST_EXE_QUERY, ID_HOST_EXE_SUSPEND,
                      OnHostControl )
    ON_COMMAND_RANGE( ID_HOST_EXE_ENABLE, ID_HOST_EXE_DRAIN, 
                      OnHostPortControl )

    ON_NOTIFY_REFLECT(TVN_SELCHANGED, OnSelchanged)

END_MESSAGE_MAP()


// Sort the item in reverse alphabetical order.

LeftView::LeftView()
{
    // This is a hack as when ::dataSink calls
    // SetWindowText it sets both the caption
    // and the edit control.  Thus what is written
    // in the log pane also comes in caption.  By
    // making the caption initially very big
    // this hack ensures that the caption only shows 
    // the title and nothing else.
    // This is crazy stuff, but that is what you get
    // when you work with mfc and its very poor doc.
    // One disadvantage of this is that the bottom
    // pane will now show a horizontal scroll bar
    // when it really is not required, but that is
    // a tradeoff if a message pane title is required.

    title =  GETRESOURCEIDSTRING( IDS_BOTTOM_PANE_TITLE ) +
        L"                                                                                                                                                                                                                                                                                                                                                                                                                                                   " + 
        GETRESOURCEIDSTRING( IDS_INFO_NEWLINE );
}

LeftView::~LeftView()
{
}
 
Document*
LeftView::GetDocument()
{
    return ( Document *) m_pDocument;
}


void 
LeftView::OnInitialUpdate()
{
    CTreeView::OnInitialUpdate();

    // get present style.
    LONG presentStyle;
    
    presentStyle = GetWindowLong( m_hWnd, GWL_STYLE );

    // Set the last error to zero to avoid confusion.  See sdk for SetWindowLong.
    SetLastError(0);

    // set new style.
    LONG rcLong;

    rcLong = SetWindowLong( m_hWnd,
                            GWL_STYLE,
                            presentStyle | TVS_HASLINES | TVS_HASBUTTONS | TVS_SHOWSELALWAYS | TVS_LINESATROOT );

    //
    // Get and set the image list which is used by this 
    // tree view from document.
    //
    GetTreeCtrl().SetImageList( GetDocument()->m_images48x48, 
                                TVSIL_NORMAL );


    // insert root icon which is world

    const _bstr_t& worldLevel = GETRESOURCEIDSTRING( IDS_WORLD_NAME );

    rootItem.hParent        = TVI_ROOT;             
    rootItem.hInsertAfter   = TVI_FIRST;           
    rootItem.item.mask      = TVIF_IMAGE | TVIF_PARAM | TVIF_SELECTEDIMAGE | TVIF_TEXT | TVIF_CHILDREN;  
    rootItem.item.pszText   = worldLevel;
    rootItem.item.cchTextMax= worldLevel.length() + 1;
    rootItem.item.iImage    = 0;
    rootItem.item.iSelectedImage = 0;
    rootItem.item.lParam    = 0;   
    rootItem.item.cChildren = 1;

    GetTreeCtrl().InsertItem(  &rootItem );

    //
    // we will register 
    // with the document class, 
    // as we are the left pane
    //
    GetDocument()->registerLeftPane( this );
}


void 
LeftView::OnRButtonDown( UINT nFlags, CPoint point )
{

    // do a hit test
    // here we are checking that right button is down on 
    // a tree view item or icon.
    TVHITTESTINFO hitTest;

    hitTest.pt = point;

    GetTreeCtrl().HitTest( &hitTest );
    if( !(hitTest.flags == TVHT_ONITEMLABEL )
        && 
        !(hitTest.flags == TVHT_ONITEMICON )
        )
    {
        return;
    }

    // make the item right clicked on the 
    // selected item.

    GetTreeCtrl().SelectItem( hitTest.hItem );

    LRESULT result;
    OnSelchanged( NULL, &result );

    HTREEITEM hdlSelItem = hitTest.hItem;

    // get the image of the item which
    // has been selected.  From this we can make out it it is
    // world level, cluster level or host level.
    TVITEM  selItem;
    selItem.hItem = hdlSelItem;
    selItem.mask = TVIF_IMAGE ;
    
    GetTreeCtrl().GetItem( &selItem );
		
    /// Depending upon item selected show the pop up menu.
    int menuIndex;
    switch( selItem.iImage )
    {
        case 0: // this is world level.
            menuIndex = 0;
            break;

        case 1:  // this is some cluster
            menuIndex = 1;
            break;

        case 2:  // this has to be host.
            menuIndex = 2;
            break;
            
        default:  // don't know how to handle this image.
            return;
    }

    CMenu menu;
    menu.LoadMenu( IDR_POPUP );

    CMenu* pContextMenu = menu.GetSubMenu( menuIndex );

    ClientToScreen( &point );

    pContextMenu->TrackPopupMenu( TPM_RIGHTBUTTON,
                                  point.x,
                                  point.y,
                                  this );

    CTreeView::OnRButtonDown(nFlags, point);
}

void 
LeftView::OnRefresh()
{
    // Refresh is the following steps:
    //
    // * Remove the present cluster being refreshed from view.
    //
    // * Connect direct if cluster has connectedDirect = true, else indirect.

    // find tree view cluster member which has been selected.
    //
    HTREEITEM hdlSelectedItem = GetTreeCtrl().GetSelectedItem();

    TVITEM selectedItem;
    selectedItem.hItem = hdlSelectedItem;
    selectedItem.mask = TVIF_PARAM;
   
    GetTreeCtrl().GetItem( &selectedItem );

    ClusterData* p_clusterData = (ClusterData *) selectedItem.lParam;

    if( p_clusterData->connectedDirect == true )
    {
        RefreshDirect();
    }
    else
    {
        RefreshIndirect();
    }
}


void 
LeftView::RefreshDirect()
{
    // Refresh is the following steps:
    // * Remove the present cluster being refreshed from view.

    // * Connect direct back to the cluster.


    // find tree view cluster member which has been selected.
    //
    HTREEITEM hdlSelectedItem = GetTreeCtrl().GetSelectedItem();

    TVITEM selectedItem;
    selectedItem.hItem = hdlSelectedItem;
    selectedItem.mask = TVIF_PARAM;
   
    GetTreeCtrl().GetItem( &selectedItem );

    ClusterData* p_clusterData = (ClusterData *) selectedItem.lParam;

    // now reconnect.
    //
    ClusterConnectPage clusterConnect( p_clusterData );

    _bstr_t tabbedDlgCaption = GETRESOURCEIDSTRING( IDS_REFRESH_CLUSTER );

    CPropertySheet tabbedDlg( tabbedDlgCaption );

    tabbedDlg.m_psh.dwFlags = tabbedDlg.m_psh.dwFlags | PSH_NOAPPLYNOW; 

    tabbedDlg.AddPage( &clusterConnect );

    int rc = tabbedDlg.DoModal();
    if( rc != IDOK )
    {
        return;
    }
    else
    {
        // connection successful, thus remove old item.
        //
        GetTreeCtrl().DeleteItem( hdlSelectedItem );

        // deleting memory of host needs to be done.
        // TODO

        // form the tree
        //

        TVINSERTSTRUCT   item;
        item.hParent        = GetTreeCtrl().GetRootItem();
        item.hInsertAfter   = TVI_LAST;           
        item.item.mask      = TVIF_IMAGE | TVIF_PARAM | TVIF_SELECTEDIMAGE | TVIF_TEXT | TVIF_CHILDREN;  
        item.item.pszText   =  p_clusterData->cp.cIP;
        item.item.cchTextMax= p_clusterData->cp.cIP.length() + 1; 
        item.item.iImage    = 1;
        item.item.iSelectedImage = 1;
        item.item.lParam    = (LPARAM ) p_clusterData;    
        item.item.cChildren = 1;
        
        HTREEITEM clusterParent = GetTreeCtrl().InsertItem( &item );
        GetTreeCtrl().Expand( GetTreeCtrl().GetRootItem(), TVE_EXPAND );
        
        map<_bstr_t, HostData>::iterator topHostData;
        for( topHostData = p_clusterData->hosts.begin(); topHostData != p_clusterData->hosts.end(); ++topHostData )
        {
            item.hParent        = clusterParent;
            item.hInsertAfter   = TVI_LAST;           
            item.item.mask      = TVIF_IMAGE | TVIF_PARAM | TVIF_SELECTEDIMAGE | TVIF_TEXT | TVIF_CHILDREN;  
            item.item.pszText   = (*topHostData).second.hp.machineName;
            item.item.cchTextMax= (*topHostData).second.hp.machineName.length() + 1;
            item.item.iImage    = 2;
            item.item.iSelectedImage = 2;
            item.item.lParam    = (LPARAM )  new _bstr_t((*topHostData).second.hp.machineName );
            item.item.cChildren = 0;
            
            GetTreeCtrl().InsertItem( &item );
        }

        GetTreeCtrl().Expand( clusterParent, TVE_EXPAND );
    }

    LRESULT result;
    OnSelchanged( NULL, &result );
}

void 
LeftView::RefreshIndirect()
{
    // Refresh is the following steps:
    // Remove the present cluster being refreshed from view.
    // Connect direct or indirectly back to the cluster.

    // find tree view cluster member which has been selected.
    //
    HTREEITEM hdlSelectedItem = GetTreeCtrl().GetSelectedItem();

    TVITEM selectedItem;
    selectedItem.hItem = hdlSelectedItem;
    selectedItem.mask = TVIF_PARAM;
   
    GetTreeCtrl().GetItem( &selectedItem );

    ClusterData* p_clusterData = (ClusterData *) selectedItem.lParam;

    // now reconnect.
    //
    ClusterConnectIndirectPage clusterConnect( p_clusterData );

    _bstr_t tabbedDlgCaption = GETRESOURCEIDSTRING( IDS_REFRESH_CLUSTER );

    CPropertySheet tabbedDlg( tabbedDlgCaption );

    tabbedDlg.m_psh.dwFlags = tabbedDlg.m_psh.dwFlags | PSH_NOAPPLYNOW; 

    tabbedDlg.AddPage( &clusterConnect );

    int rc = tabbedDlg.DoModal();
    if( rc != IDOK )
    {
        return;
    }
    else
    {
        // connection successful, thus remove old item.
        //
        GetTreeCtrl().DeleteItem( hdlSelectedItem );

        // deleting memory of host needs to be done.
        // TODO


        // form the tree
        //

        TVINSERTSTRUCT   item;
        item.hParent        = GetTreeCtrl().GetRootItem();
        item.hInsertAfter   = TVI_LAST;           
        item.item.mask      = TVIF_IMAGE | TVIF_PARAM | TVIF_SELECTEDIMAGE | TVIF_TEXT | TVIF_CHILDREN;  
        item.item.pszText   =  p_clusterData->cp.cIP;
        item.item.cchTextMax= p_clusterData->cp.cIP.length() + 1; 
        item.item.iImage    = 1;
        item.item.iSelectedImage = 1;
        item.item.lParam    = (LPARAM ) p_clusterData;    
        item.item.cChildren = 1;
        
        HTREEITEM clusterParent = GetTreeCtrl().InsertItem( &item );
        GetTreeCtrl().Expand( GetTreeCtrl().GetRootItem(), TVE_EXPAND );
        
        map<_bstr_t, HostData>::iterator topHostData;
        for( topHostData = p_clusterData->hosts.begin(); topHostData != p_clusterData->hosts.end(); ++topHostData )
        {
            item.hParent        = clusterParent;
            item.hInsertAfter   = TVI_LAST;           
            item.item.mask      = TVIF_IMAGE | TVIF_PARAM | TVIF_SELECTEDIMAGE | TVIF_TEXT | TVIF_CHILDREN;  
            item.item.pszText   = (*topHostData).second.hp.machineName;
            item.item.cchTextMax= (*topHostData).second.hp.machineName.length() + 1;
            item.item.iImage    = 2;
            item.item.iSelectedImage = 2;
            item.item.lParam    = (LPARAM )  new _bstr_t((*topHostData).second.hp.machineName );
            item.item.cChildren = 0;
            
            GetTreeCtrl().InsertItem( &item );
        }

        GetTreeCtrl().Expand( clusterParent, TVE_EXPAND );
    }

    LRESULT result;
    OnSelchanged( NULL, &result );

}

void
LeftView::OnWorldConnect()
{
    ClusterData* p_clusterData = new ClusterData;

    ClusterConnectPage clusterConnect( p_clusterData, this );

    _bstr_t tabbedDlgCaption = GETRESOURCEIDSTRING( IDS_CONNECT_CLUSTER_CAPTION );

    CPropertySheet tabbedDlg( tabbedDlgCaption );

    tabbedDlg.m_psh.dwFlags = tabbedDlg.m_psh.dwFlags | PSH_NOAPPLYNOW; 

    tabbedDlg.AddPage( &clusterConnect );

    int rc = tabbedDlg.DoModal();
    if( rc != IDOK )
    {
        delete p_clusterData;

        return;
    }
    else
    {
        // we have connected directly.
        p_clusterData->connectedDirect = true;

        // form the tree
        //

        TVINSERTSTRUCT   item;
        item.hParent        = GetTreeCtrl().GetRootItem();
        item.hInsertAfter   = TVI_LAST;           
        item.item.mask      = TVIF_IMAGE | TVIF_PARAM | TVIF_SELECTEDIMAGE | TVIF_TEXT | TVIF_CHILDREN;  
        item.item.pszText   =  p_clusterData->cp.cIP;
        item.item.cchTextMax= p_clusterData->cp.cIP.length() + 1; 
        item.item.iImage    = 1;
        item.item.iSelectedImage = 1;
        item.item.lParam    = (LPARAM ) p_clusterData;    
        item.item.cChildren = 1;
        
        HTREEITEM clusterParent = GetTreeCtrl().InsertItem( &item );
        GetTreeCtrl().Expand( GetTreeCtrl().GetRootItem(), TVE_EXPAND );
        
        map<_bstr_t, HostData>::iterator topHostData;
        for( topHostData = p_clusterData->hosts.begin(); topHostData != p_clusterData->hosts.end(); ++topHostData )
        {
            item.hParent        = clusterParent;
            item.hInsertAfter   = TVI_LAST;           
            item.item.mask      = TVIF_IMAGE | TVIF_PARAM | TVIF_SELECTEDIMAGE | TVIF_TEXT | TVIF_CHILDREN;  
            item.item.pszText   = (*topHostData).second.hp.machineName;
            item.item.cchTextMax= (*topHostData).second.hp.machineName.length() + 1;
            item.item.iImage    = 2;
            item.item.iSelectedImage = 2;
            item.item.lParam    = (LPARAM )  new _bstr_t((*topHostData).second.hp.machineName );
            item.item.cChildren = 0;
            
            GetTreeCtrl().InsertItem( &item );
        }

        GetTreeCtrl().Expand( clusterParent, TVE_EXPAND );
    }

    LRESULT result;
    OnSelchanged( NULL, &result );
}


void
LeftView::OnWorldConnectIndirect()
{
    ClusterData* p_clusterData = new ClusterData;

    ClusterConnectIndirectPage clusterConnect( p_clusterData, this );

    _bstr_t tabbedDlgCaption = GETRESOURCEIDSTRING( IDS_CONNECT_CLUSTER_CAPTION );

    CPropertySheet tabbedDlg( tabbedDlgCaption );

    tabbedDlg.m_psh.dwFlags = tabbedDlg.m_psh.dwFlags | PSH_NOAPPLYNOW; 

    tabbedDlg.AddPage( &clusterConnect );

    int rc = tabbedDlg.DoModal();
    if( rc != IDOK )
    {
        delete p_clusterData;

        return;
    }
    else
    {
        // form the tree
        //

        // we have connected indirectly.
        p_clusterData->connectedDirect = false;

        TVINSERTSTRUCT   item;
        item.hParent        = GetTreeCtrl().GetRootItem();
        item.hInsertAfter   = TVI_LAST;           
        item.item.mask      = TVIF_IMAGE | TVIF_PARAM | TVIF_SELECTEDIMAGE | TVIF_TEXT | TVIF_CHILDREN;  
        item.item.pszText   =  p_clusterData->cp.cIP;
        item.item.cchTextMax= p_clusterData->cp.cIP.length() + 1; 
        item.item.iImage    = 1;
        item.item.iSelectedImage = 1;
        item.item.lParam    = (LPARAM ) p_clusterData;    
        item.item.cChildren = 1;
        
        HTREEITEM clusterParent = GetTreeCtrl().InsertItem( &item );
        GetTreeCtrl().Expand( GetTreeCtrl().GetRootItem(), TVE_EXPAND );
        
        map<_bstr_t, HostData>::iterator topHostData;
        for( topHostData = p_clusterData->hosts.begin(); topHostData != p_clusterData->hosts.end(); ++topHostData )
        {
            item.hParent        = clusterParent;
            item.hInsertAfter   = TVI_LAST;           
            item.item.mask      = TVIF_IMAGE | TVIF_PARAM | TVIF_SELECTEDIMAGE | TVIF_TEXT | TVIF_CHILDREN;  
            item.item.pszText   = (*topHostData).second.hp.machineName;
            item.item.cchTextMax= (*topHostData).second.hp.machineName.length() + 1;
            item.item.iImage    = 2;
            item.item.iSelectedImage = 2;
            item.item.lParam    = (LPARAM )  new _bstr_t((*topHostData).second.hp.machineName );
            item.item.cChildren = 0;
            
            GetTreeCtrl().InsertItem( &item );
        }

        GetTreeCtrl().Expand( clusterParent, TVE_EXPAND );
    }

    LRESULT result;
    OnSelchanged( NULL, &result );
}

void
LeftView::OnWorldNewCluster()
{
    ClusterData* p_clusterData = new ClusterData;

    // set up default values.
    // defaults for cluster.
    p_clusterData->cp.cIP = L"0.0.0.0";
    p_clusterData->cp.cSubnetMask = L"0.0.0.0";
    p_clusterData->cp.cFullInternetName = L"www.cluster.com";
    p_clusterData->cp.cNetworkAddress = L"00-00-00-00-00-00";


    // defaults for port rules.
    PortDataELB portRule;
    portRule._startPort = 0;
    portRule._key = portRule._startPort;
    portRule._endPort = 65535;
    portRule._trafficToHandle = MNLBPortRule::Protocol::both;
    portRule._isEqualLoadBalanced = true;

    p_clusterData->portELB[0] = portRule;

    //
    // fDisablePage = false
    //
    ClusterPage clusterPage( &p_clusterData->cp, false );

    PortsPage  portsPage( p_clusterData );

    CPropertySheet tabbedDlg( GETRESOURCEIDSTRING( IDS_PROPERTIES_CAPTION ) );

    tabbedDlg.m_psh.dwFlags = tabbedDlg.m_psh.dwFlags | PSH_NOAPPLYNOW; 

    tabbedDlg.AddPage( &clusterPage );

    tabbedDlg.AddPage( &portsPage );

    int rc = tabbedDlg.DoModal();
    if( rc != IDOK )
    {
        delete p_clusterData;
        return;
    }
    else
    {
        // when creating assume indirect.
        //
        p_clusterData->connectedDirect = false;

        
        // check if this cluster already exists in nlbmgr view.
        //
        bool isClusterDuplicate = doesClusterExistInView( p_clusterData->cp.cIP );
        if( isClusterDuplicate == true )
        {
            MessageBox( p_clusterData->cp.cIP + L":" + GETRESOURCEIDSTRING (IDS_CLUSTER_ALREADY ),
                        GETRESOURCEIDSTRING (IDR_MAINFRAME ),
                        MB_ICONEXCLAMATION );

            delete p_clusterData;

            return;
        }

        // form the tree
        //

        TVINSERTSTRUCT   item;
        item.hParent        = GetTreeCtrl().GetRootItem();
        item.hInsertAfter   = TVI_LAST;           
        item.item.mask      = TVIF_IMAGE | TVIF_PARAM | TVIF_SELECTEDIMAGE | TVIF_TEXT | TVIF_CHILDREN;  
        item.item.pszText   =  p_clusterData->cp.cIP;
        item.item.cchTextMax= p_clusterData->cp.cIP.length() + 1; 
        item.item.iImage    = 1;
        item.item.iSelectedImage = 1;
        item.item.lParam    = (LPARAM ) p_clusterData;    
        item.item.cChildren = 1;
        
        HTREEITEM clusterParent = GetTreeCtrl().InsertItem( &item );
        GetTreeCtrl().Expand( GetTreeCtrl().GetRootItem(), TVE_EXPAND );

    }

    LRESULT result;
    OnSelchanged( NULL, &result );
}
    

void
LeftView::OnClusterProperties()
{
    // find tree view cluster member which has been selected.
    //
    HTREEITEM hdlSelectedItem = GetTreeCtrl().GetSelectedItem();

    TVITEM selectedItem;
    selectedItem.hItem = hdlSelectedItem;
    selectedItem.mask = TVIF_PARAM;
   
    GetTreeCtrl().GetItem( &selectedItem );

    ClusterData* p_oldSettings = (ClusterData *) selectedItem.lParam;
    ClusterData newSettings = *( (ClusterData *) selectedItem.lParam );

    ClusterData* p_clusterData = (ClusterData *) selectedItem.lParam;

    ClusterPage clusterPage( &newSettings.cp, false );

    PortsPage  portsPage( &newSettings );
    
    _bstr_t tabbedDlgCaption = GETRESOURCEIDSTRING( IDS_PROPERTIES_CAPTION );

    CPropertySheet tabbedDlg( tabbedDlgCaption );

    tabbedDlg.m_psh.dwFlags = tabbedDlg.m_psh.dwFlags | PSH_NOAPPLYNOW; 

    tabbedDlg.AddPage( &clusterPage );

    tabbedDlg.AddPage( &portsPage );

    int rc = tabbedDlg.DoModal();
    if( rc != IDOK )
    {
        return;
    }
    else
    {
        // clear the old status if any.
        dataSink( GETRESOURCEIDSTRING( IDS_INFO_LINE_SEPARATOR ) );

        dumpClusterData( &newSettings );
        
        try
        {
            bool bClusterIpChanged;

            CommonNLB::changeNLBClusterAndPortSettings( p_oldSettings,
                                                        &newSettings,
                                                        this, 
                                                        &bClusterIpChanged);

            *p_clusterData = newSettings;

            if (bClusterIpChanged) 
            {
                GetTreeCtrl().SetItemText(hdlSelectedItem, newSettings.cp.cIP);
            }

        }
        catch( _com_error e )
        {
            _bstr_t errText;
            GetErrorCodeText(  e.Error(), errText );
            dataSink( errText );
            dataSink( GETRESOURCEIDSTRING( IDS_INFO_FAILED ) );
        }
    }

    LRESULT result;
    OnSelchanged( NULL, &result );
}

void
LeftView::OnClusterManageVIPS()
{
    return;

    // find tree view cluster member which has been selected.
    //
    HTREEITEM hdlSelectedItem = GetTreeCtrl().GetSelectedItem();

    TVITEM selectedItem;
    selectedItem.hItem = hdlSelectedItem;
    selectedItem.mask = TVIF_PARAM;
   
    GetTreeCtrl().GetItem( &selectedItem );

    ClusterData* p_clusterSettings = (ClusterData *) selectedItem.lParam;
    ClusterData newSettings = *( (ClusterData *) selectedItem.lParam );

    ManageVirtualIPSPage manageVirtualIPSPage( &newSettings );

    _bstr_t tabbedDlgCaption = GETRESOURCEIDSTRING( IDS_VIRTUAL_IPS_CAPTION );

    CPropertySheet tabbedDlg( tabbedDlgCaption );

    tabbedDlg.m_psh.dwFlags = tabbedDlg.m_psh.dwFlags | PSH_NOAPPLYNOW; 

    tabbedDlg.AddPage( &manageVirtualIPSPage );

    int rc = tabbedDlg.DoModal();
    if( rc != IDOK )
    {
        return;
    }

    LRESULT result;
    OnSelchanged( NULL, &result );
}


void
LeftView::OnHostProperties()
{
    // find tree view host member which has been selected.
    //
    HTREEITEM hdlSelectedItem = GetTreeCtrl().GetSelectedItem();

    TVITEM selectedItem;
    selectedItem.hItem = hdlSelectedItem;
    selectedItem.mask = TVIF_PARAM;
   
    GetTreeCtrl().GetItem( &selectedItem );

    // get parent cluster of the selected host member.
    HTREEITEM hdlParentItem;
    hdlParentItem = GetTreeCtrl().GetParentItem( hdlSelectedItem );

    TVITEM    parentItem;
    parentItem.hItem = hdlParentItem;
    parentItem.mask = TVIF_PARAM;
	
    GetTreeCtrl().GetItem( &parentItem );

    ClusterData* p_oldSettings = (ClusterData *) parentItem.lParam;

    ClusterData newSettings = *( (ClusterData *) parentItem.lParam );

    _bstr_t machine = *( (_bstr_t *) (selectedItem.lParam));

    ClusterData* p_clusterData = (ClusterData *) parentItem.lParam;

    vector<CommonNLB::NicNLBBound>   listOfNics;
    CommonNLB::NicNLBBound nicInfo;
    nicInfo.fullNicName = p_clusterData->hosts[machine].hp.nicInfo.fullNicName;
    nicInfo.adapterGuid = p_clusterData->hosts[machine].hp.nicInfo.adapterGuid;
    nicInfo.friendlyName = p_clusterData->hosts[machine].hp.nicInfo.friendlyName;
    nicInfo.ipsOnNic = p_clusterData->hosts[machine].hp.nicInfo.ipsOnNic;
    nicInfo.subnetMasks = p_clusterData->hosts[machine].hp.nicInfo.subnetMasks;

    nicInfo.isBoundToNLB = true;

    listOfNics.push_back( nicInfo );

    HostPage hostPage( machine,
                       &newSettings,
                       listOfNics,
                       false
                       );

    PortsPage portsPage( machine,
                         &newSettings );

    //
    // fDisablePage = true
    //
    ClusterPage clusterPage( &newSettings.cp, true );

    _bstr_t tabbedDlgCaption = GETRESOURCEIDSTRING( IDS_PROPERTIES_CAPTION );

    CPropertySheet tabbedDlg( tabbedDlgCaption );

    tabbedDlg.m_psh.dwFlags = tabbedDlg.m_psh.dwFlags | PSH_NOAPPLYNOW; 

    //
    // Display the host page first
    //
    tabbedDlg.m_psh.nStartPage = 1; 

    tabbedDlg.AddPage( &clusterPage );

    tabbedDlg.AddPage( &hostPage );

    tabbedDlg.AddPage( &portsPage );

    int rc = tabbedDlg.DoModal();
    if( rc != IDOK )
    {
        return;
    }
    else
    {
        // clear the old status if any.
        dataSink( GETRESOURCEIDSTRING( IDS_INFO_LINE_SEPARATOR ) );

        try
        {
            CommonNLB::changeNLBHostSettings( p_oldSettings,
                                              &newSettings,
                                              machine,
                                              this );

            CommonNLB::changeNLBHostPortSettings( p_oldSettings,
                                                  &newSettings,
                                                  machine,
                                                  this );

            *p_clusterData = newSettings;

        }
        catch( _com_error e )
        {
            _bstr_t errText;
            GetErrorCodeText(  e.Error(), errText );
            dataSink( errText );
            dataSink( GETRESOURCEIDSTRING( IDS_INFO_FAILED ) );
        }
    }

    LRESULT result;
    OnSelchanged( NULL, &result );
}


void
LeftView::OnClusterRemove()
{
    // verify once again that user really wants to remove.

    int userSelection = MessageBox( GETRESOURCEIDSTRING (IDS_WARNING_CLUSTER_REMOVE ),
                                    GETRESOURCEIDSTRING (IDR_MAINFRAME ),
                                    MB_YESNO | MB_ICONEXCLAMATION );
    if( userSelection == IDNO )
    {
        return;
    }

    // find tree view cluster member which has been selected.
    //
    HTREEITEM hdlSelectedItem = GetTreeCtrl().GetSelectedItem();

    TVITEM selectedItem;
    selectedItem.hItem = hdlSelectedItem;
    selectedItem.mask = TVIF_PARAM;
   
    GetTreeCtrl().GetItem( &selectedItem );

    ClusterData* p_clusterSettings = (ClusterData *) selectedItem.lParam;

    // remove cluster 
    try
    {
        // clear the old status if any.
        dataSink( GETRESOURCEIDSTRING( IDS_INFO_LINE_SEPARATOR ) );

        CommonNLB::removeCluster( p_clusterSettings,
                                  this );

        // need to remove it from our view too.
        // and free allocated memory.

        GetTreeCtrl().DeleteItem( hdlSelectedItem );

        // deleting memory of host needs to be done.
        // TODO

        delete p_clusterSettings;

        // free up the memory for the all the hosts 
        // TODO

    }
    catch( _com_error e )
    {
        _bstr_t errText;
        GetErrorCodeText(  e.Error(), errText );
        dataSink( errText );
        dataSink( GETRESOURCEIDSTRING( IDS_INFO_FAILED ) );
    }

    LRESULT result;
    OnSelchanged( NULL, &result );
}



void
LeftView::OnClusterUnmanage()
{
    // find tree view cluster member which has been selected.
    //
    HTREEITEM hdlSelectedItem = GetTreeCtrl().GetSelectedItem();

    TVITEM selectedItem;
    selectedItem.hItem = hdlSelectedItem;
    selectedItem.mask = TVIF_PARAM;
   
    GetTreeCtrl().GetItem( &selectedItem );

    ClusterData* p_clusterSettings = (ClusterData *) selectedItem.lParam;

    // need to remove it from our view
    // and free allocated memory.

    GetTreeCtrl().DeleteItem( hdlSelectedItem );
    
    // deleting memory of host needs to be done.
    // TODO

    delete p_clusterSettings;

    LRESULT result;
    OnSelchanged( NULL, &result );

 
}
 

void
LeftView::OnClusterAddHost()
{
    // find tree view cluster member which has been selected.
    //
    HTREEITEM hdlSelectedItem = GetTreeCtrl().GetSelectedItem();

    TVITEM selectedItem;
    selectedItem.hItem = hdlSelectedItem;
    selectedItem.mask = TVIF_PARAM;
   
    GetTreeCtrl().GetItem( &selectedItem );

    ClusterData* p_clusterSettings = (ClusterData *) selectedItem.lParam;
    ClusterData newSettings = *( (ClusterData *) selectedItem.lParam );

    // get machine which needs to be added.
    //

    _bstr_t machineToConnect;

    MachineConnectPage machineConnectPage( &machineToConnect );

    _bstr_t tabbedDlgCaptionConnect = GETRESOURCEIDSTRING( IDS_CONNECT_CAPTION );

    CPropertySheet tabbedDlgConnect( tabbedDlgCaptionConnect );
    tabbedDlgConnect.m_psh.dwFlags = tabbedDlgConnect.m_psh.dwFlags | PSH_NOAPPLYNOW; 

    tabbedDlgConnect.AddPage( &machineConnectPage );

    int rc = tabbedDlgConnect.DoModal();
    if( rc != IDOK )
    {
        return;
    }


    // connect to machine, and find nics which are there on 
    // this machine and which have nlb bound.  Also find
    // server name of this machine.
    //

    dataSink( GETRESOURCEIDSTRING( IDS_INFO_LINE_SEPARATOR ) );

    // check if ip provided to connect is valid.
    bool isIPValid = MIPAddress::checkIfValid( machineToConnect );
    if( isIPValid == false )
    {
        // invalid ip.
        dataSink( GETRESOURCEIDSTRING( IDS_WARNING_IP_INVALID ) + machineToConnect );
        dataSink( GETRESOURCEIDSTRING( IDS_INFO_FAILED ) );
        return;
    }

    // the machine ip should not be the cluster ip.
    if( machineToConnect == p_clusterSettings->cp.cIP )
    {
        // cluster ip and member are same.
        // This is not allowed.
        // invalid ip.
        dataSink( GETRESOURCEIDSTRING( IDS_WARNING_CL_CONN_SAME ) );
        dataSink( GETRESOURCEIDSTRING( IDS_INFO_FAILED ) );
        return;

    }

    vector<CommonNLB::NicNLBBound>   listOfNics;
    _bstr_t machineServerName;

    try
    {
        dataSink( 
            GETRESOURCEIDSTRING( IDS_INFO_CONNECTING ) + machineToConnect );

        CommonNLB::connectToMachine( 
            machineToConnect,
            machineServerName,
            listOfNics,
            this );

        dataSink( 
            GETRESOURCEIDSTRING( IDS_INFO_DONE ) );

    }
    catch( _com_error e )
    {
        _bstr_t errText;
        GetErrorCodeText(  e.Error(), errText );
        dataSink( errText );
        dataSink( GETRESOURCEIDSTRING( IDS_INFO_FAILED ) );
        return;
    }

    // check if machine has any nics
    if( listOfNics.size() == 0 )
    {
        // no nics on this machine, then how the hell did we connect?
        dataSink( GETRESOURCEIDSTRING( IDS_WLBS_UNKNOWN ) );
        dataSink( GETRESOURCEIDSTRING( IDS_INFO_FAILED ) );
        return;
    }
    
    // check if machine already is part of cluster.
    // if so we cannot add.
    if ( newSettings.hosts.find( machineServerName ) 
         != 
         newSettings.hosts.end() )
    {
        // this host is already part of the cluster
        // we cannot readd.
        dataSink( GETRESOURCEIDSTRING( IDS_HOST_ALREADY ) );
        dataSink( GETRESOURCEIDSTRING( IDS_INFO_FAILED ) );
        return;
    }
    
    set<int> availHostIDS = newSettings.getAvailableHostIDS();
    if( availHostIDS.size() == 0 )
    {
        // no more available host ids. 
        // max cluster size limit reached.
        dataSink( GETRESOURCEIDSTRING( IDS_CLUSTER_MAX ) );
        dataSink( GETRESOURCEIDSTRING( IDS_INFO_FAILED ) );

        return;
    }
    
    // this machine is new
    // set up all defaults.
    //
    
    newSettings.hosts[ machineServerName ].connectionIP 
        =
        machineToConnect;
    
    // need to fill in host ip and subnet.
    
    newSettings.hosts[ machineServerName ].hp.hID = 
        *(availHostIDS.begin() );
    
    newSettings.hosts[ machineServerName ].hp.initialClusterStateActive =
        true;
        
    newSettings.hosts[ machineServerName ].hp.machineName = 
        machineServerName;

    newSettings.hosts[ machineServerName ].hp.hIP = 
        machineToConnect;

    // find subnet corresponding to machineToConnect.
    //
    _bstr_t machineToConnectSubnet;
    MIPAddress::getDefaultSubnetMask( machineToConnect,
                                      machineToConnectSubnet );

    newSettings.hosts[ machineServerName ].hp.hSubnetMask = 
        machineToConnectSubnet;
        
    // make the nic selection to be the connection nic.
    //
    int i;
    for( i = 0; i < listOfNics.size(); ++i )
    {
        if( find( listOfNics[i].ipsOnNic.begin(),
                  listOfNics[i].ipsOnNic.end(),
                  machineToConnect )
            != 
            listOfNics[i].ipsOnNic.end() )
        {
            // connection nic found.
            break;
        }
    }
              
    newSettings.hosts[ machineServerName ].hp.nicInfo.fullNicName =
        listOfNics[i].fullNicName;

    newSettings.hosts[ machineServerName ].hp.nicInfo.adapterGuid =
        listOfNics[i].adapterGuid;
    
    newSettings.hosts[ machineServerName ].hp.nicInfo.friendlyName =
        listOfNics[i].friendlyName;

    newSettings.hosts[ machineServerName ].hp.nicInfo.ipsOnNic =
        listOfNics[i].ipsOnNic;

    newSettings.hosts[ machineServerName ].hp.nicInfo.subnetMasks = 
        listOfNics[i].subnetMasks;

    // set up all port rule defaults.
    map<long, PortDataULB>::iterator topULB;
    for( topULB = newSettings.portULB.begin();
         topULB != newSettings.portULB.end();
         ++topULB )
    {
        (*topULB).second.machineMapToLoadWeight[ machineServerName ] = 50;
    }

    map<long, PortDataF>::iterator topF;
    for( topF = newSettings.portF.begin();
         topF != newSettings.portF.end();
         ++topF )
    {
        set<long> availPriorities = (*topF).second.getAvailablePriorities();

        (*topF).second.machineMapToPriority[ machineServerName ] = 
            *(availPriorities.begin());
    }


    HostPage hostPage( machineServerName,
                       &newSettings,
                       listOfNics,
                       true
                       );

    PortsPage portsPage( machineServerName,
                         &newSettings );

    //
    // fDisablePage = true
    //
    ClusterPage clusterPage( &newSettings.cp, true);

    _bstr_t tabbedDlgCaption = GETRESOURCEIDSTRING( IDS_PROPERTIES_CAPTION );

    CPropertySheet tabbedDlg( tabbedDlgCaption );

    tabbedDlg.m_psh.dwFlags = tabbedDlg.m_psh.dwFlags | PSH_NOAPPLYNOW; 
    //
    // Display the host page first
    //
    tabbedDlg.m_psh.nStartPage = 1; 

    tabbedDlg.AddPage( &clusterPage );

    tabbedDlg.AddPage( &hostPage );

    tabbedDlg.AddPage( &portsPage );

    rc = tabbedDlg.DoModal();
    if( rc != IDOK )
    {
        return;
    }

    try
    {
        // check if host to add has nlb bound on nic
        // specified.
        MNLBNetCfg nlbNetCfg(         
            newSettings.hosts[machineServerName].connectionIP,
            newSettings.hosts[machineServerName].hp.nicInfo.fullNicName
            );

        if( nlbNetCfg.isBound() == MNLBNetCfg::BOUND )        
        {
            // nlb is already bound on this machine.
            // ask user if he wants to really proceed.
            // TODO

            // if yes need to remove old cluster ip from
            // machine.
            _bstr_t clusterIP = Common::mapNicToClusterIP( newSettings.hosts[machineServerName].connectionIP,
                                                           newSettings.hosts[machineServerName].hp.nicInfo.fullNicName );

            // ask user if he wants to continue.
            wchar_t buffer[Common::BUF_SIZE];
            swprintf( buffer, 
                      GETRESOURCEIDSTRING( IDS_NLB_ALREADY ), 
                      (wchar_t * ) newSettings.hosts[machineServerName].hp.nicInfo.friendlyName,
                      (wchar_t * ) clusterIP
                      );

            int ignoreWarning = MessageBox( buffer,
                                            GETRESOURCEIDSTRING( IDS_PARM_WARN ),
                                            MB_ICONEXCLAMATION | MB_YESNO );
            if( ignoreWarning == IDNO )
            {
                return;
            }

            dataSink( 
                GETRESOURCEIDSTRING( IDS_NIC_BOUND ) );

            dataSink( 
                GETRESOURCEIDSTRING( IDS_INFO_REMOVING_CL_IP ) );

            MIPAddressAdmin ipAdmin( newSettings.hosts[machineServerName].connectionIP,
                                     newSettings.hosts[machineServerName].hp.nicInfo.fullNicName );
            
            ipAdmin.deleteIPAddress( clusterIP );

            dataSink( 
                GETRESOURCEIDSTRING( IDS_INFO_DONE ) );

        }

        dataSink( 
            GETRESOURCEIDSTRING( IDS_HOST_ADDING ) );

        CommonNLB::addHostToCluster( &newSettings,
                                     machineServerName,
                                     this );

        dataSink( 
            GETRESOURCEIDSTRING( IDS_INFO_REQUEST ) );

    }
    catch( _com_error e )
    {
        _bstr_t errText;
        GetErrorCodeText(  e.Error(), errText );
        dataSink( errText );
        dataSink( GETRESOURCEIDSTRING( IDS_INFO_FAILED ) );
        return;
    }

    // host has been added successfully, add it to nlbmanager
    // view.
    
    *p_clusterSettings = newSettings;

    TVINSERTSTRUCT   item;
    item.hParent        = hdlSelectedItem;
    item.hInsertAfter   = TVI_LAST;           
    item.item.mask      = TVIF_IMAGE | TVIF_PARAM | TVIF_SELECTEDIMAGE | TVIF_TEXT | TVIF_CHILDREN;  
    item.item.pszText   = machineServerName;
    item.item.cchTextMax= machineServerName.length() + 1;
    item.item.iImage    = 2;
    item.item.iSelectedImage = 2;
    item.item.lParam    = (LPARAM )  new _bstr_t ( machineServerName );
    item.item.cChildren = 0;
            
    GetTreeCtrl().InsertItem( &item );
    GetTreeCtrl().Expand( hdlSelectedItem, TVE_EXPAND );

    LRESULT result;
    OnSelchanged( NULL, &result ); 
}

void
LeftView::OnHostRemove()
{
    // verify once again that user really wants to remove.

    int userSelection = MessageBox( GETRESOURCEIDSTRING (IDS_WARNING_HOST_REMOVE ),
                                    GETRESOURCEIDSTRING (IDR_MAINFRAME ),
                                    MB_YESNO | MB_ICONEXCLAMATION );                                    
    if( userSelection == IDNO )
    {
        return;
    }

    // find tree view host member which has been selected.
    //
    HTREEITEM hdlSelectedItem = GetTreeCtrl().GetSelectedItem();

    TVITEM selectedItem;
    selectedItem.hItem = hdlSelectedItem;
    selectedItem.mask = TVIF_PARAM;
   
    GetTreeCtrl().GetItem( &selectedItem );

    // get parent cluster of the selected host member.
    HTREEITEM hdlParentItem;
    hdlParentItem = GetTreeCtrl().GetParentItem( hdlSelectedItem );

    TVITEM    parentItem;
    parentItem.hItem = hdlParentItem;
    parentItem.mask = TVIF_PARAM;
	
    GetTreeCtrl().GetItem( &parentItem );

    ClusterData* p_clusterSettings = (ClusterData *) parentItem.lParam;

    _bstr_t machine = *( (_bstr_t *) (selectedItem.lParam));

    try
    {
        // clear the old status if any.
        dataSink( GETRESOURCEIDSTRING( IDS_INFO_LINE_SEPARATOR ) );

        CommonNLB::removeHost( p_clusterSettings,
                               machine,
                               this );

        // delete this host from host list.
        p_clusterSettings->hosts.erase( machine );

        // delete this host from ULB and F port rules

        map<long, PortDataULB>::iterator topULB;        
        for( topULB = p_clusterSettings->portULB.begin();
             topULB != p_clusterSettings->portULB.end();
             ++topULB )
        {
            (*topULB).second.machineMapToLoadWeight.erase( machine );
        }

        map<long, PortDataF>::iterator topF;        
        for( topF = p_clusterSettings->portF.begin();
             topF != p_clusterSettings->portF.end();
             ++topF )
        {
            (*topF).second.machineMapToPriority.erase( machine );
        }
        
        // need to remove it from our view too.
        // and modify p_clusterSettings to reflect this host
        // no longer present

        GetTreeCtrl().DeleteItem( hdlSelectedItem );

        // free up the memory for the display
        delete ( (_bstr_t *) (selectedItem.lParam));

    }
    catch( _com_error e )
    {
        _bstr_t errText;
        GetErrorCodeText(  e.Error(), errText );
        dataSink( errText );
        dataSink( GETRESOURCEIDSTRING( IDS_INFO_FAILED ) );
    }

    LRESULT result;
    OnSelchanged( NULL, &result );    
}

void
LeftView::OnClusterControl( UINT nID )
{
    // find tree view cluster member which has been selected.
    //
    HTREEITEM hdlSelectedItem = GetTreeCtrl().GetSelectedItem();

    TVITEM selectedItem;
    selectedItem.hItem = hdlSelectedItem;
    selectedItem.mask = TVIF_PARAM;
   
    GetTreeCtrl().GetItem( &selectedItem );

    ClusterData* p_oldSettings = (ClusterData *) selectedItem.lParam;
    ClusterData newSettings = *( (ClusterData *) selectedItem.lParam );

    // clear the old status if any.
    dataSink( GETRESOURCEIDSTRING( IDS_INFO_LINE_SEPARATOR ) );

    dataSink( L"cluster control");

    try
    {
        switch( nID )
        {
            case ID_CLUSTER_EXE_QUERY :
                CommonNLB::runControlMethodOnCluster( &newSettings,
                                                      this,
                                                      L"query",
                                                      0 );
                break;

            case ID_CLUSTER_EXE_START :
                CommonNLB::runControlMethodOnCluster( &newSettings,
                                                      this,
                                                      L"start",
                                                      0 );
                break;

            case ID_CLUSTER_EXE_STOP :
                CommonNLB::runControlMethodOnCluster( &newSettings,
                                                      this,
                                                      L"stop",
                                                      0 );
                break;

            case ID_CLUSTER_EXE_DRAINSTOP :
                CommonNLB::runControlMethodOnCluster( &newSettings,
                                                      this,
                                                      L"drainstop",
                                                      0 );
                break;

            case ID_CLUSTER_EXE_RESUME :
                CommonNLB::runControlMethodOnCluster( &newSettings,
                                                      this,
                                                      L"resume",
                                                      0 );
                break;

            case ID_CLUSTER_EXE_SUSPEND :
                CommonNLB::runControlMethodOnCluster( &newSettings,
                                                      this,
                                                      L"suspend",
                                                      0 );
                break;

            default:
                break;

        }

        dataSink( 
            GETRESOURCEIDSTRING( IDS_INFO_DONE ) );

    }
    catch( _com_error e )
    {
        _bstr_t errText;
        GetErrorCodeText(  e.Error(), errText );
        dataSink( errText );
        dataSink( GETRESOURCEIDSTRING( IDS_INFO_FAILED ) );
    }

    LRESULT result;
    OnSelchanged( NULL, &result );
}

void
LeftView::OnClusterPortControl( UINT nID )
{
    // clear the old status if any.
    dataSink( GETRESOURCEIDSTRING( IDS_INFO_LINE_SEPARATOR ) );

    // find tree view cluster member which has been selected.
    //
    HTREEITEM hdlSelectedItem = GetTreeCtrl().GetSelectedItem();

    TVITEM selectedItem;
    selectedItem.hItem = hdlSelectedItem;
    selectedItem.mask = TVIF_PARAM;
   
    GetTreeCtrl().GetItem( &selectedItem );

    ClusterData* p_clusterSettings = (ClusterData *) selectedItem.lParam;
    
    // check if there are any ports on which
    // control methods can be run.
    if( ( p_clusterSettings->portELB.size() == 0 )
        &&
        ( p_clusterSettings->portULB.size() == 0 )
        &&
        ( p_clusterSettings->portD.size() == 0 )
        &&
        ( p_clusterSettings->portF.size() == 0 )
        )
    {
        // there are no ports to run control method on.
        dataSink( 
            GETRESOURCEIDSTRING( IDS_PORTS_CONTROL_NONE ) );

        return;
    }

    unsigned long portAffected;
    PortsControlPage portsControlPage( p_clusterSettings,
                                       &portAffected );

    _bstr_t tabbedDlgCaption;

    switch( nID )
    {
        case ID_CLUSTER_EXE_ENABLE :
            tabbedDlgCaption = GETRESOURCEIDSTRING( IDS_COMMAND_ENABLE );
            break;
            
        case ID_CLUSTER_EXE_DISABLE :
            tabbedDlgCaption = GETRESOURCEIDSTRING( IDS_COMMAND_DISABLE );
            break;
            
        case ID_CLUSTER_EXE_DRAIN :
            tabbedDlgCaption = GETRESOURCEIDSTRING( IDS_COMMAND_DRAIN );
            break;
            
        default:
            break;
            
    }



    CPropertySheet tabbedDlg( tabbedDlgCaption );
    tabbedDlg.m_psh.dwFlags = tabbedDlg.m_psh.dwFlags | PSH_NOAPPLYNOW; 

    tabbedDlg.AddPage( &portsControlPage );

    int rc = tabbedDlg.DoModal();
    if( rc != IDOK )
    {
        return;
    }

    try
    {

        switch( nID )
        {
            case ID_CLUSTER_EXE_ENABLE :
                CommonNLB::runControlMethodOnCluster( p_clusterSettings,
                                                      this,
                                                      L"enable",
                                                      portAffected );
                break;
                
            case ID_CLUSTER_EXE_DISABLE :
                CommonNLB::runControlMethodOnCluster( p_clusterSettings,
                                                      this,
                                                      L"disable",
                                                      portAffected );
                break;
                
            case ID_CLUSTER_EXE_DRAIN :
                CommonNLB::runControlMethodOnCluster( p_clusterSettings,
                                                      this,
                                                      L"drain",
                                                      portAffected );
                break;

            default:
                break;

        }

        dataSink( 
            GETRESOURCEIDSTRING( IDS_INFO_DONE ) );
    }
    catch( _com_error e )
    {
        _bstr_t errText;
        GetErrorCodeText(  e.Error(), errText );
        dataSink( errText );
        dataSink( GETRESOURCEIDSTRING( IDS_INFO_FAILED ) );
    }

    LRESULT result;
    OnSelchanged( NULL, &result );
}

void
LeftView::OnHostControl( UINT nID )
{
    // find tree view host member which has been selected.
    //
    HTREEITEM hdlSelectedItem = GetTreeCtrl().GetSelectedItem();

    TVITEM selectedItem;
    selectedItem.hItem = hdlSelectedItem;
    selectedItem.mask = TVIF_PARAM;
   
    GetTreeCtrl().GetItem( &selectedItem );

    // get parent cluster of the selected host member.
    HTREEITEM hdlParentItem;
    hdlParentItem = GetTreeCtrl().GetParentItem( hdlSelectedItem );

    TVITEM    parentItem;
    parentItem.hItem = hdlParentItem;
    parentItem.mask = TVIF_PARAM;
	
    GetTreeCtrl().GetItem( &parentItem );

    ClusterData* p_oldSettings = (ClusterData *) parentItem.lParam;

    ClusterData newSettings = *( (ClusterData *) parentItem.lParam );

    _bstr_t machine = *( (_bstr_t *) (selectedItem.lParam));

    ClusterData* p_clusterData = (ClusterData *) parentItem.lParam;

    // clear the old status if any.
    dataSink( GETRESOURCEIDSTRING( IDS_INFO_LINE_SEPARATOR ) );

    dataSink( L"host control");

    try
    {
        switch( nID )
        {
            case ID_HOST_EXE_QUERY :
                CommonNLB::runControlMethodOnHost( &newSettings,
                                                   machine,
                                                   this,
                                                   L"query",
                                                   0 );
                break;

            case ID_HOST_EXE_START :
                CommonNLB::runControlMethodOnHost( &newSettings,
                                                   machine,
                                                   this,
                                                   L"start",
                                                   0 );
                break;

            case ID_HOST_EXE_STOP :
                CommonNLB::runControlMethodOnHost( &newSettings,
                                                   machine,                                               
                                                   this,
                                                   L"stop",
                                                   0 );
                break;

            case ID_HOST_EXE_DRAINSTOP :
                CommonNLB::runControlMethodOnHost( &newSettings,
                                                   machine,
                                                   this,
                                                   L"drainstop",
                                                   0 );
                break;

            case ID_HOST_EXE_RESUME :
                CommonNLB::runControlMethodOnHost( &newSettings,
                                                   machine,
                                                   this,
                                                   L"resume",
                                                   0 );
                break;

            case ID_HOST_EXE_SUSPEND :
                CommonNLB::runControlMethodOnHost( &newSettings,
                                                   machine,
                                                   this,
                                                   L"suspend",
                                                   0 );
                break;

            default:
                break;

        }
        
        dataSink( 
            GETRESOURCEIDSTRING( IDS_INFO_DONE ) );

    }
    catch( _com_error e )
    {
        _bstr_t errText;
        GetErrorCodeText(  e.Error(), errText );
        dataSink( errText );
        dataSink( GETRESOURCEIDSTRING( IDS_INFO_FAILED ) );
    }

    LRESULT result;
    OnSelchanged( NULL, &result );
}


void
LeftView::OnHostPortControl( UINT nID )
{
    // clear the old status if any.
    dataSink( GETRESOURCEIDSTRING( IDS_INFO_LINE_SEPARATOR ) );

    //
    HTREEITEM hdlSelectedItem = GetTreeCtrl().GetSelectedItem();

    TVITEM selectedItem;
    selectedItem.hItem = hdlSelectedItem;
    selectedItem.mask = TVIF_PARAM;
   
    GetTreeCtrl().GetItem( &selectedItem );

    // get parent cluster of the selected host member.
    HTREEITEM hdlParentItem;
    hdlParentItem = GetTreeCtrl().GetParentItem( hdlSelectedItem );

    TVITEM    parentItem;
    parentItem.hItem = hdlParentItem;
    parentItem.mask = TVIF_PARAM;
	
    GetTreeCtrl().GetItem( &parentItem );

    ClusterData* p_clusterSettings = (ClusterData *) parentItem.lParam;

    // check if there are any ports on which
    // control methods can be run.
    if( ( p_clusterSettings->portELB.size() == 0 )
        &&
        ( p_clusterSettings->portULB.size() == 0 )
        &&
        ( p_clusterSettings->portD.size() == 0 )
        &&
        ( p_clusterSettings->portF.size() == 0 )
        )
    {
        // there are no ports to run control method on.
        dataSink( 
            GETRESOURCEIDSTRING( IDS_PORTS_CONTROL_NONE ) );

        return;
    }

    _bstr_t machine = *( (_bstr_t *) (selectedItem.lParam));

    unsigned long portAffected;
    PortsControlPage portsControlPage( p_clusterSettings,
                                       &portAffected );

    _bstr_t tabbedDlgCaption;
    switch( nID )
    {
        case ID_HOST_EXE_ENABLE :
            tabbedDlgCaption = GETRESOURCEIDSTRING( IDS_COMMAND_ENABLE );
            break;
            
        case ID_HOST_EXE_DISABLE :
            tabbedDlgCaption = GETRESOURCEIDSTRING( IDS_COMMAND_DISABLE );
            break;
            
        case ID_HOST_EXE_DRAIN :
            tabbedDlgCaption = GETRESOURCEIDSTRING( IDS_COMMAND_DRAIN );
            break;
            
        default:
            break;
            
    }

    CPropertySheet tabbedDlg( tabbedDlgCaption );
    tabbedDlg.m_psh.dwFlags = tabbedDlg.m_psh.dwFlags | PSH_NOAPPLYNOW; 

    tabbedDlg.AddPage( &portsControlPage );

    int rc = tabbedDlg.DoModal();
    if( rc != IDOK )
    {
        return;
    }

    try
    {
        switch( nID )
        {
            case ID_HOST_EXE_ENABLE :
                CommonNLB::runControlMethodOnHost( p_clusterSettings,
                                                   machine,
                                                   this,
                                                   L"enable",
                                                   portAffected );
                break;
                
            case ID_HOST_EXE_DISABLE :
                CommonNLB::runControlMethodOnHost( p_clusterSettings,
                                                   machine,
                                                   this,
                                                   L"disable",
                                                   portAffected );
                break;
                
            case ID_HOST_EXE_DRAIN :
                CommonNLB::runControlMethodOnHost( p_clusterSettings,
                                                   machine,
                                                   this,
                                                   L"drain",
                                                   portAffected );
                break;

            default:
                break;
        }

        dataSink( 
            GETRESOURCEIDSTRING( IDS_INFO_DONE ) );
    }
    catch( _com_error e )
    {
        _bstr_t errText;
        GetErrorCodeText(  e.Error(), errText );
        dataSink( errText );
        dataSink( GETRESOURCEIDSTRING( IDS_INFO_FAILED ) );
    }

    LRESULT result;
    OnSelchanged( NULL, &result );
}

void
LeftView::dataSink( _bstr_t data )
{
    dataStore += data;
    dataStore += GETRESOURCEIDSTRING( IDS_INFO_NEWLINE );
    GetDocument()->getStatusPane().SetWindowText( title + 
                                                  dataStore );

    // scroll
    int numLines = GetDocument()->getStatusPane().GetLineCount();

    GetDocument()->getStatusPane().LineScroll( numLines - 1);

    UpdateWindow();

}

void 
LeftView::OnSelchanged(NMHDR* pNMHDR, LRESULT* pResult) 
{
    BOOL rcBOOL;

    // get selected item.
    //
    HTREEITEM hdlSelItem;    
    hdlSelItem = GetTreeCtrl().GetSelectedItem();

    TVITEM    selItem;
    selItem.hItem = hdlSelItem;
    selItem.mask = TVIF_PARAM | TVIF_IMAGE;
    GetTreeCtrl().GetItem( &selItem );

    // delete all previous items.
    //
    GetDocument()->getListPane().DeleteAllItems();	

    // Delete all of the previous columns.
    int nColumnCount = 
        GetDocument()->getListPane().GetHeaderCtrl()->GetItemCount();
    for (int i = 0; i < nColumnCount; i++)
    {
        GetDocument()->getListPane().DeleteColumn(0);
    }

    int index = 0;
    map<bstr_t, HostData>::iterator top;
    ClusterData* p_clusterData;

    CWnd* pMain = AfxGetMainWnd();
    CMenu* pMenu = pMain->GetMenu();
    CMenu* subMenu;
    UINT retValue;

    BOOL retBool;

    switch( selItem.iImage )
    {
        case 0: 

            // this is root icon.

            // disable all commands at cluster and host level.

            // cluster menu
            subMenu = pMenu->GetSubMenu( 1 );

            retValue = subMenu->EnableMenuItem( ID_CLUSTER_ADD_HOST,
                                                MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);

            retValue = subMenu->EnableMenuItem( ID_CLUSTER_REMOVE,
                                                MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);

            retValue = subMenu->EnableMenuItem( ID_CLUSTER_PROPERTIES,
                                                MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);                                               
            retValue = subMenu->EnableMenuItem( ID_REFRESH,
                                                MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);

            retValue = subMenu->EnableMenuItem( ID_CLUSTER_UNMANAGE,
                                                MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);                                               
            retValue = subMenu->EnableMenuItem( ID_CLUSTER_EXE_QUERY,
                                                MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);                                               

            retValue = subMenu->EnableMenuItem( ID_CLUSTER_EXE_START,
                                                MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);                                               

            retValue = subMenu->EnableMenuItem( ID_CLUSTER_EXE_STOP,
                                                MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);                                               

            retValue = subMenu->EnableMenuItem( ID_CLUSTER_EXE_DRAINSTOP,
                                                MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);                                               

            retValue = subMenu->EnableMenuItem( ID_CLUSTER_EXE_RESUME,
                                                MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);                                               

            retValue = subMenu->EnableMenuItem( ID_CLUSTER_EXE_SUSPEND,
                                                MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);                                               

            retValue = subMenu->EnableMenuItem( ID_CLUSTER_EXE_SUSPEND,
                                                MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);                                               

            retValue = subMenu->EnableMenuItem( ID_CLUSTER_EXE_ENABLE,
                                                MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);                                               

            retValue = subMenu->EnableMenuItem( ID_CLUSTER_EXE_DISABLE,
                                                MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);                                               

            retValue = subMenu->EnableMenuItem( ID_CLUSTER_EXE_DRAIN,
                                                MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);                                               
            // host menu
            subMenu = pMenu->GetSubMenu( 2 );

            retValue = subMenu->EnableMenuItem( ID_HOST_REMOVE,
                                                MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);

            retValue = subMenu->EnableMenuItem( ID_HOST_PROPERTIES,
                                                MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);                                               
            retValue = subMenu->EnableMenuItem( ID_HOST_EXE_QUERY,
                                                MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);                                               

            retValue = subMenu->EnableMenuItem( ID_HOST_EXE_START,
                                                MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);                                               

            retValue = subMenu->EnableMenuItem( ID_HOST_EXE_STOP,
                                                MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);                                               

            retValue = subMenu->EnableMenuItem( ID_HOST_EXE_DRAINSTOP,
                                                MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);                                               

            retValue = subMenu->EnableMenuItem( ID_HOST_EXE_RESUME,
                                                MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);                                               

            retValue = subMenu->EnableMenuItem( ID_HOST_EXE_SUSPEND,
                                                MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);                                               

            retValue = subMenu->EnableMenuItem( ID_HOST_EXE_SUSPEND,
                                                MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);                                               

            retValue = subMenu->EnableMenuItem( ID_HOST_EXE_ENABLE,
                                                MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);                                               

            retValue = subMenu->EnableMenuItem( ID_HOST_EXE_DISABLE,
                                                MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);                                               

            retValue = subMenu->EnableMenuItem( ID_HOST_EXE_DRAIN,
                                                MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);                                               


            pMain->DrawMenuBar();

            GetDocument()->getListPane().InsertColumn( 0, 
                                                       GETRESOURCEIDSTRING( IDS_HEADER_C_IP ) , 
                                                       LVCFMT_LEFT, 
                                                       Document::LV_COLUMN_LARGE );
            GetDocument()->getListPane().InsertColumn( 1, 
                                                       GETRESOURCEIDSTRING( IDS_HEADER_C_SUBNET ), 
                                                       LVCFMT_LEFT, 
                                                       Document::LV_COLUMN_LARGE );
            GetDocument()->getListPane().InsertColumn( 2, 
                                                       GETRESOURCEIDSTRING( IDS_HEADER_INTERNET_NAME ), 
                                                       LVCFMT_LEFT, 
                                                       Document::LV_COLUMN_LARGE );
            GetDocument()->getListPane().InsertColumn( 3, 
                                                       GETRESOURCEIDSTRING( IDS_HEADER_MAC_ADDRESS ),
                                                       LVCFMT_LEFT, 
                                                       Document::LV_COLUMN_LARGE );
            GetDocument()->getListPane().InsertColumn( 4, 
                                                       GETRESOURCEIDSTRING( IDS_HEADER_C_MODE ),
                                                       LVCFMT_LEFT, 
                                                       Document::LV_COLUMN_LARGE );
            GetDocument()->getListPane().InsertColumn( 5, 
                                                       GETRESOURCEIDSTRING( IDS_HEADER_REMOTE_CTRL ),
                                                       LVCFMT_LEFT, 
                                                       Document::LV_COLUMN_SMALL );
			 
            // get children of the selected item.
            if( GetTreeCtrl().ItemHasChildren( hdlSelItem ) )
            {
                HTREEITEM hNextItem;
                HTREEITEM hChildItem = GetTreeCtrl().GetChildItem( hdlSelItem );

                index = 0;
                while( hChildItem != NULL )
                {
                    hNextItem = GetTreeCtrl().GetNextItem( hChildItem, TVGN_NEXT );
                    selItem.hItem = hChildItem;
                    selItem.mask = TVIF_PARAM;
	
                    GetTreeCtrl().GetItem( &selItem );
                    p_clusterData = (ClusterData *) selItem.lParam;

                    LVITEM item;
                    item.mask = LVIF_TEXT | LVIF_IMAGE;
                    item.iItem = index;
                    item.iSubItem = 0;
                    item.iImage = 1;
                    item.pszText = p_clusterData->cp.cIP;
                    item.cchTextMax = p_clusterData->cp.cIP.length() + 1;
                    GetDocument()->getListPane().InsertItem( &item );

                    item.mask = LVIF_TEXT;
                    item.iItem = index;
                    item.iSubItem = 1;	 
                    item.pszText = p_clusterData->cp.cSubnetMask;
                    item.cchTextMax = p_clusterData->cp.cSubnetMask.length() + 1;
                    GetDocument()->getListPane().SetItem( &item );

                    item.mask = LVIF_TEXT; 
                    item.iItem = index;
                    item.iSubItem = 2;	 
                    item.pszText = p_clusterData->cp.cFullInternetName;
                    item.cchTextMax = p_clusterData->cp.cFullInternetName.length() + 1;
                    GetDocument()->getListPane().SetItem( &item );

                    item.mask = LVIF_TEXT;
                    item.iItem = index;
                    item.iSubItem = 3;	 
                    item.pszText = p_clusterData->cp.cNetworkAddress;
                    item.cchTextMax = p_clusterData->cp.cNetworkAddress.length() + 1;
                    GetDocument()->getListPane().SetItem( &item );

                    item.mask = LVIF_TEXT;
                    item.iItem = index;
                    item.iSubItem = 4;	 
                    if( p_clusterData->cp.multicastSupportEnabled  
                        && 
                        p_clusterData->cp.igmpSupportEnabled )
                    {
                        item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_IGMP );
                    }
                    else if( p_clusterData->cp.multicastSupportEnabled  )
                    {
                        item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_MULTICAST );
                    }
                    else
                    {
                        item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_UNICAST );
                    }
                    item.cchTextMax = 100;
                    GetDocument()->getListPane().SetItem( &item );

                    item.mask = LVIF_TEXT;
                    item.iItem = index;
                    item.iSubItem = 5;	 
                    if( p_clusterData->cp.remoteControlEnabled )
                    {
                        item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_ON );
                    }
                    else
                    {
                        item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_OFF );
                    }
                    item.cchTextMax = 100;
                    GetDocument()->getListPane().SetItem( &item );

                    hChildItem = hNextItem;

                    ++index;
                }
            }

            break;

        case 1:  
            // this is some cluster
            
            // enable all commands at cluster level menu.
            // disable all commands at host level.

            // cluster menu
            subMenu = pMenu->GetSubMenu( 1 );

            retValue = subMenu->EnableMenuItem( ID_CLUSTER_ADD_HOST,
                                                MF_BYCOMMAND | MF_ENABLED );

            retValue = subMenu->EnableMenuItem( ID_CLUSTER_REMOVE,
                                                MF_BYCOMMAND | MF_ENABLED );

            retValue = subMenu->EnableMenuItem( ID_CLUSTER_PROPERTIES,
                                                MF_BYCOMMAND | MF_ENABLED );

            retValue = subMenu->EnableMenuItem( ID_REFRESH,
                                                MF_BYCOMMAND | MF_ENABLED );

            retValue = subMenu->EnableMenuItem( ID_CLUSTER_UNMANAGE,
                                                MF_BYCOMMAND | MF_ENABLED );                                               

            retValue = subMenu->EnableMenuItem( ID_CLUSTER_EXE_QUERY,
                                                MF_BYCOMMAND |  MF_ENABLED);                                               

            retValue = subMenu->EnableMenuItem( ID_CLUSTER_EXE_START,
                                                MF_BYCOMMAND | MF_ENABLED);                                               

            retValue = subMenu->EnableMenuItem( ID_CLUSTER_EXE_STOP,
                                                MF_BYCOMMAND | MF_ENABLED);                                               

            retValue = subMenu->EnableMenuItem( ID_CLUSTER_EXE_DRAINSTOP,
                                                MF_BYCOMMAND | MF_ENABLED);                                               

            retValue = subMenu->EnableMenuItem( ID_CLUSTER_EXE_RESUME,
                                                MF_BYCOMMAND | MF_ENABLED);                                               

            retValue = subMenu->EnableMenuItem( ID_CLUSTER_EXE_SUSPEND,
                                                MF_BYCOMMAND | MF_ENABLED);                                               

            retValue = subMenu->EnableMenuItem( ID_CLUSTER_EXE_SUSPEND,
                                                MF_BYCOMMAND | MF_ENABLED);                                               

            retValue = subMenu->EnableMenuItem( ID_CLUSTER_EXE_ENABLE,
                                                MF_BYCOMMAND | MF_ENABLED);                                               

            retValue = subMenu->EnableMenuItem( ID_CLUSTER_EXE_DISABLE,
                                                MF_BYCOMMAND | MF_ENABLED);                                               

            retValue = subMenu->EnableMenuItem( ID_CLUSTER_EXE_DRAIN,
                                                MF_BYCOMMAND | MF_ENABLED);                                               
            // host menu
            subMenu = pMenu->GetSubMenu( 2 );

            retValue = subMenu->EnableMenuItem( ID_HOST_REMOVE,
                                                MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);

            retValue = subMenu->EnableMenuItem( ID_HOST_PROPERTIES,
                                                MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);                                               
            retValue = subMenu->EnableMenuItem( ID_HOST_EXE_QUERY,
                                                MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);                                               

            retValue = subMenu->EnableMenuItem( ID_HOST_EXE_START,
                                                MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);                                               

            retValue = subMenu->EnableMenuItem( ID_HOST_EXE_STOP,
                                                MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);                                               

            retValue = subMenu->EnableMenuItem( ID_HOST_EXE_DRAINSTOP,
                                                MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);                                               

            retValue = subMenu->EnableMenuItem( ID_HOST_EXE_RESUME,
                                                MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);                                               

            retValue = subMenu->EnableMenuItem( ID_HOST_EXE_SUSPEND,
                                                MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);                                               

            retValue = subMenu->EnableMenuItem( ID_HOST_EXE_SUSPEND,
                                                MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);                                               

            retValue = subMenu->EnableMenuItem( ID_HOST_EXE_ENABLE,
                                                MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);                                               

            retValue = subMenu->EnableMenuItem( ID_HOST_EXE_DISABLE,
                                                MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);                                               

            retValue = subMenu->EnableMenuItem( ID_HOST_EXE_DRAIN,
                                                MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);                                               

            pMain->DrawMenuBar();



            GetDocument()->getListPane().InsertColumn( 0, 
                                                       GETRESOURCEIDSTRING( IDS_HEADER_MACHINE ) , 
                                                       LVCFMT_LEFT, 
                                                       Document::LV_COLUMN_LARGE );
            GetDocument()->getListPane().InsertColumn( 1, 
                                                       GETRESOURCEIDSTRING( IDS_HEADER_D_IP ) , 
                                                       LVCFMT_LEFT, 
                                                       Document::LV_COLUMN_LARGE );
            GetDocument()->getListPane().InsertColumn( 2, 
                                                       GETRESOURCEIDSTRING( IDS_HEADER_D_SUBNET ), 
                                                       LVCFMT_LEFT, 
                                                       Document::LV_COLUMN_LARGE );
            GetDocument()->getListPane().InsertColumn( 3, 
                                                       GETRESOURCEIDSTRING( IDS_HEADER_PRIORITY ),
                                                       LVCFMT_LEFT, 
                                                       Document::LV_COLUMN_SMALL );
            GetDocument()->getListPane().InsertColumn( 4, 
                                                       GETRESOURCEIDSTRING( IDS_HEADER_INITIAL_STATE ),
                                                       LVCFMT_LEFT, 
                                                       Document::LV_COLUMN_SMALL );
            GetDocument()->getListPane().InsertColumn( 5, 
                                                       GETRESOURCEIDSTRING( IDS_HEADER_NIC ),
                                                       LVCFMT_LEFT, 
                                                       Document::LV_COLUMN_LARGE );
            
            p_clusterData = 
                (ClusterData *) selItem.lParam;

            index = 0;
            for( top = p_clusterData->hosts.begin(); 
                 top != p_clusterData->hosts.end(); 
                 ++top )
            {
                LVITEM item;
                item.mask = LVIF_TEXT | LVIF_IMAGE;
                item.iItem = index;
                item.iSubItem = 0;
                item.iImage = 2;
                item.pszText = (*top).second.hp.machineName;
                item.cchTextMax = (*top).second.hp.machineName.length() + 1;
                GetDocument()->getListPane().InsertItem( &item );

                item.mask = LVIF_TEXT;
                item.iItem = index;
                item.iSubItem = 1;	 
                item.pszText = (*top).second.hp.hIP;
                item.cchTextMax = (*top).second.hp.hIP.length() + 1;
                GetDocument()->getListPane().SetItem( &item );

                item.mask = LVIF_TEXT;
                item.iItem = index;
                item.iSubItem = 2;	 
                item.pszText = (*top).second.hp.hSubnetMask;
                item.cchTextMax = (*top).second.hp.hSubnetMask.length() + 1;
                GetDocument()->getListPane().SetItem( &item );

                item.mask = LVIF_TEXT; 
                item.iItem = index;
                item.iSubItem = 3;	 
                wchar_t buf[Common::BUF_SIZE];
                swprintf( buf, L"%d", (*top).second.hp.hID );
                item.pszText = buf;
                item.cchTextMax = 100;
                GetDocument()->getListPane().SetItem( &item );

                item.mask = LVIF_TEXT;
                item.iItem = index;
                item.iSubItem = 4;	 
                if( (*top).second.hp.initialClusterStateActive )
                {
                    item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_ON );
                }
                else
                {
                    item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_OFF );
                }
                item.cchTextMax = 100;
                GetDocument()->getListPane().SetItem( &item );

                item.mask = LVIF_TEXT;
                item.iItem = index;
                item.iSubItem = 5;	 
                item.pszText = (*top).second.hp.nicInfo.friendlyName;
                item.cchTextMax = (*top).second.hp.nicInfo.fullNicName.length() + 1;
                GetDocument()->getListPane().SetItem( &item );

                ++index;
            }

            break;

        case 2:
            // this is some node.

            // disable all commands at cluster level.
            // enable all commands at host level.

            // cluster menu
            subMenu = pMenu->GetSubMenu( 1 );

            retValue = subMenu->EnableMenuItem( ID_CLUSTER_ADD_HOST,
                                                MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);

            retValue = subMenu->EnableMenuItem( ID_CLUSTER_REMOVE,
                                                MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);

            retValue = subMenu->EnableMenuItem( ID_CLUSTER_PROPERTIES,
                                                MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);                                               

            retValue = subMenu->EnableMenuItem( ID_REFRESH,
                                                MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);

            retValue = subMenu->EnableMenuItem( ID_CLUSTER_UNMANAGE,
                                                MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);                                               

            retValue = subMenu->EnableMenuItem( ID_CLUSTER_EXE_QUERY,
                                                MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);                                               

            retValue = subMenu->EnableMenuItem( ID_CLUSTER_EXE_START,
                                                MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);                                               

            retValue = subMenu->EnableMenuItem( ID_CLUSTER_EXE_STOP,
                                                MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);                                               

            retValue = subMenu->EnableMenuItem( ID_CLUSTER_EXE_DRAINSTOP,
                                                MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);                                               

            retValue = subMenu->EnableMenuItem( ID_CLUSTER_EXE_RESUME,
                                                MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);                                               

            retValue = subMenu->EnableMenuItem( ID_CLUSTER_EXE_SUSPEND,
                                                MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);                                               

            retValue = subMenu->EnableMenuItem( ID_CLUSTER_EXE_SUSPEND,
                                                MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);                                               

            retValue = subMenu->EnableMenuItem( ID_CLUSTER_EXE_ENABLE,
                                                MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);                                               

            retValue = subMenu->EnableMenuItem( ID_CLUSTER_EXE_DISABLE,
                                                MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);                                               

            retValue = subMenu->EnableMenuItem( ID_CLUSTER_EXE_DRAIN,
                                                MF_BYCOMMAND | MF_DISABLED | MF_GRAYED);                                               

            // host menu
            subMenu = pMenu->GetSubMenu( 2 );

            retValue = subMenu->EnableMenuItem( ID_HOST_REMOVE,
                                                MF_BYCOMMAND | MF_ENABLED );

            retValue = subMenu->EnableMenuItem( ID_HOST_PROPERTIES,
                                                MF_BYCOMMAND | MF_ENABLED );                                               

            retValue = subMenu->EnableMenuItem( ID_HOST_EXE_QUERY,
                                                MF_BYCOMMAND |  MF_ENABLED);                                               

            retValue = subMenu->EnableMenuItem( ID_HOST_EXE_START,
                                                MF_BYCOMMAND | MF_ENABLED);                                               

            retValue = subMenu->EnableMenuItem( ID_HOST_EXE_STOP,
                                                MF_BYCOMMAND | MF_ENABLED);                                               

            retValue = subMenu->EnableMenuItem( ID_HOST_EXE_DRAINSTOP,
                                                MF_BYCOMMAND | MF_ENABLED);                                               

            retValue = subMenu->EnableMenuItem( ID_HOST_EXE_RESUME,
                                                MF_BYCOMMAND | MF_ENABLED);                                               

            retValue = subMenu->EnableMenuItem( ID_HOST_EXE_SUSPEND,
                                                MF_BYCOMMAND | MF_ENABLED);                                               

            retValue = subMenu->EnableMenuItem( ID_HOST_EXE_SUSPEND,
                                                MF_BYCOMMAND | MF_ENABLED);                                               

            retValue = subMenu->EnableMenuItem( ID_HOST_EXE_ENABLE,
                                                MF_BYCOMMAND | MF_ENABLED);                                               

            retValue = subMenu->EnableMenuItem( ID_HOST_EXE_DISABLE,
                                                MF_BYCOMMAND | MF_ENABLED);                                               

            retValue = subMenu->EnableMenuItem( ID_HOST_EXE_DRAIN,
                                                MF_BYCOMMAND | MF_ENABLED);                                               

            pMain->DrawMenuBar();

            GetDocument()->getListPane().InsertColumn( 0, 
                                                       GETRESOURCEIDSTRING( IDS_HEADER_P_START ) , 
                                                       LVCFMT_LEFT, 
                                                       Document::LV_COLUMN_SMALL );
            GetDocument()->getListPane().InsertColumn( 1, 
                                                       GETRESOURCEIDSTRING( IDS_HEADER_P_END ), 
                                                       LVCFMT_LEFT, 
                                                       Document::LV_COLUMN_SMALL );
            GetDocument()->getListPane().InsertColumn( 2, 
                                                       GETRESOURCEIDSTRING( IDS_HEADER_P_PROTOCOL ),
                                                       LVCFMT_LEFT, 
                                                       Document::LV_COLUMN_SMALL );
            GetDocument()->getListPane().InsertColumn( 3, 
                                                       GETRESOURCEIDSTRING( IDS_HEADER_P_MODE ),
                                                       LVCFMT_LEFT, 
                                                       Document::LV_COLUMN_SMALL );
            GetDocument()->getListPane().InsertColumn( 4, 
                                                       GETRESOURCEIDSTRING( IDS_HEADER_P_PRIORITY ),
                                                       LVCFMT_LEFT, 
                                                       Document::LV_COLUMN_SMALL );
            GetDocument()->getListPane().InsertColumn( 5, 
                                                       GETRESOURCEIDSTRING( IDS_HEADER_P_LOAD ),
                                                       LVCFMT_LEFT, 
                                                       Document::LV_COLUMN_SMALL );

            GetDocument()->getListPane().InsertColumn( 6, 
                                                       GETRESOURCEIDSTRING( IDS_HEADER_P_AFFINITY ),
                                                       LVCFMT_LEFT, 
                                                       Document::LV_COLUMN_SMALL );

            // get parent cluster of the selected host member.
            HTREEITEM hdlParentItem;
            hdlParentItem = GetTreeCtrl().GetParentItem( hdlSelItem );

            TVITEM    parentItem;
            parentItem.hItem = hdlParentItem;
            parentItem.mask = TVIF_PARAM;
	
            GetTreeCtrl().GetItem( &parentItem );
            
            ClusterData* p_clusterSettings = const_cast<ClusterData *> ( (ClusterData *) parentItem.lParam );

            _bstr_t machine = *( (_bstr_t *) (selItem.lParam));


            wchar_t buf[Common::BUF_SIZE];

            index = 0;
            map< long, PortDataELB>::iterator topELB;
            for( topELB = p_clusterSettings->portELB.begin();
                 topELB != p_clusterSettings->portELB.end();
                 ++topELB )
            {


                // start port
                swprintf( buf, L"%d", (*topELB).second._startPort );
                LVITEM item;
                item.mask = LVIF_TEXT | LVIF_IMAGE;;
                item.iItem = index;
                item.iSubItem = 0;
                item.iImage = 4;
                item.pszText = buf;
                item.cchTextMax = 100;
                GetDocument()->getListPane().InsertItem( &item );

                // end port
                swprintf( buf, L"%d", (*topELB).second._endPort );
                item.mask = LVIF_TEXT;
                item.iItem = index;
                item.iSubItem = 1;	 
                item.pszText = buf;
                item.cchTextMax = 100;
                GetDocument()->getListPane().SetItem( &item );

                // protocol
                item.mask = LVIF_TEXT; 
                item.iItem = index;
                item.iSubItem = 2;	 
                switch( (*topELB).second._trafficToHandle )
                {
                    case MNLBPortRule::both :
                        item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_BOTH );
                        break;

                    case MNLBPortRule::tcp :
                        item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_TCP );
                        break;

                    case MNLBPortRule::udp :
                        item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_UDP );
                        break;
                }
                item.cchTextMax = 100;
                GetDocument()->getListPane().SetItem( &item );

                // mode 
                item.mask = LVIF_TEXT; 
                item.iItem = index;
                item.iSubItem = 3;	 
                item.pszText = GETRESOURCEIDSTRING(IDS_REPORT_MODE_MULTIPLE );
                item.cchTextMax = 100;
                GetDocument()->getListPane().SetItem( &item );
                
                // priority
                item.mask = LVIF_TEXT; 
                item.iItem = index;
                item.iSubItem = 4;	 
                item.pszText = GETRESOURCEIDSTRING(IDS_REPORT_EMPTY );
                item.cchTextMax = 100;
                GetDocument()->getListPane().SetItem( &item );

                // load
                item.mask = LVIF_TEXT; 
                item.iItem = index;
                item.iSubItem = 5;	 
                item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_LOAD_EQUAL );
                item.cchTextMax = 100;
                GetDocument()->getListPane().SetItem( &item );

                // affinity
                item.mask = LVIF_TEXT; 
                item.iItem = index;
                item.iSubItem = 6;	 
                switch( (*topELB).second._affinity )
                {
                    case MNLBPortRule::none :
                        item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_AFFINITY_NONE );
                        break;

                    case MNLBPortRule::single :
                        item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_AFFINITY_SINGLE );
                        break;

                    case MNLBPortRule::classC :
                        item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_AFFINITY_CLASSC );
                        break;
                }
                item.cchTextMax = 100;
                GetDocument()->getListPane().SetItem( &item );

                ++index;
            }

            index = 0;
            map< long, PortDataULB>::iterator topULB;
            for( topULB = p_clusterSettings->portULB.begin();
                 topULB != p_clusterSettings->portULB.end();
                 ++topULB )
            {


                // start port
                swprintf( buf, L"%d", (*topULB).second._startPort );
                LVITEM item;
                item.mask = LVIF_TEXT | LVIF_IMAGE;
                item.iItem = index;
                item.iSubItem = 0;
                item.iImage = 4;
                item.pszText = buf;
                item.cchTextMax = 100;
                GetDocument()->getListPane().InsertItem( &item );

                // end port
                swprintf( buf, L"%d", (*topULB).second._endPort );
                item.mask = LVIF_TEXT;
                item.iItem = index;
                item.iSubItem = 1;	 
                item.pszText = buf;
                item.cchTextMax = 100;
                GetDocument()->getListPane().SetItem( &item );

                // protocol
                item.mask = LVIF_TEXT; 
                item.iItem = index;
                item.iSubItem = 2;	 
                switch( (*topULB).second._trafficToHandle )
                {
                    case MNLBPortRule::both :
                        item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_BOTH );
                        break;

                    case MNLBPortRule::tcp :
                        item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_TCP );
                        break;

                    case MNLBPortRule::udp :
                        item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_UDP );
                        break;
                }
                item.cchTextMax = 100;
                GetDocument()->getListPane().SetItem( &item );

                // mode 
                item.mask = LVIF_TEXT; 
                item.iItem = index;
                item.iSubItem = 3;	 
                item.pszText = GETRESOURCEIDSTRING(IDS_REPORT_MODE_MULTIPLE );
                item.cchTextMax = 100;
                GetDocument()->getListPane().SetItem( &item );
                
                // priority
                item.mask = LVIF_TEXT; 
                item.iItem = index;
                item.iSubItem = 4;	 
                item.pszText = GETRESOURCEIDSTRING(IDS_REPORT_EMPTY );
                item.cchTextMax = 100;
                GetDocument()->getListPane().SetItem( &item );

                // load
                item.mask = LVIF_TEXT; 
                item.iItem = index;
                item.iSubItem = 5;	 
                swprintf( buf, L"%d", (*topULB).second.machineMapToLoadWeight[machine] );
                item.pszText = buf;
                item.cchTextMax = 100;
                GetDocument()->getListPane().SetItem( &item );

                // affinity
                item.mask = LVIF_TEXT; 
                item.iItem = index;
                item.iSubItem = 6;	 
                switch( (*topULB).second._affinity )
                {
                    case MNLBPortRule::none :
                        item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_AFFINITY_NONE );
                        break;

                    case MNLBPortRule::single :
                        item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_AFFINITY_SINGLE );
                        break;

                    case MNLBPortRule::classC :
                        item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_AFFINITY_CLASSC );
                        break;
                }
                item.cchTextMax = 100;
                GetDocument()->getListPane().SetItem( &item );

                ++index;
            }

            index = 0;
            map< long, PortDataF>::iterator topF;
            for( topF = p_clusterSettings->portF.begin();
                 topF != p_clusterSettings->portF.end();
                 ++topF )
            {


                // start port
                swprintf( buf, L"%d", (*topF).second._startPort );
                LVITEM item;
                item.mask = LVIF_TEXT | LVIF_IMAGE;
                item.iItem = index;
                item.iSubItem = 0;
                item.iImage = 4;
                item.pszText = buf;
                item.cchTextMax = 100;
                GetDocument()->getListPane().InsertItem( &item );

                // end port
                swprintf( buf, L"%d", (*topF).second._endPort );
                item.mask = LVIF_TEXT;
                item.iItem = index;
                item.iSubItem = 1;	 
                item.pszText = buf;
                item.cchTextMax = 100;
                GetDocument()->getListPane().SetItem( &item );

                // protocol
                item.mask = LVIF_TEXT; 
                item.iItem = index;
                item.iSubItem = 2;	 
                switch( (*topF).second._trafficToHandle )
                {
                    case MNLBPortRule::both :
                        item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_BOTH );
                        break;

                    case MNLBPortRule::tcp :
                        item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_TCP );
                        break;

                    case MNLBPortRule::udp :
                        item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_UDP );
                        break;
                }
                item.cchTextMax = 100;
                GetDocument()->getListPane().SetItem( &item );

                // mode 
                item.mask = LVIF_TEXT; 
                item.iItem = index;
                item.iSubItem = 3;	 
                item.pszText = GETRESOURCEIDSTRING(IDS_REPORT_MODE_SINGLE );
                item.cchTextMax = 100;
                GetDocument()->getListPane().SetItem( &item );
                
                // priority
                item.mask = LVIF_TEXT; 
                item.iItem = index;
                item.iSubItem = 4;	 
                swprintf( buf, L"%d", (*topF).second.machineMapToPriority[machine] );
                item.pszText = buf;
                item.cchTextMax = 100;
                GetDocument()->getListPane().SetItem( &item );

                // load
                item.mask = LVIF_TEXT; 
                item.iItem = index;
                item.iSubItem = 5;	 
                item.pszText = GETRESOURCEIDSTRING(IDS_REPORT_EMPTY );
                item.cchTextMax = 100;
                GetDocument()->getListPane().SetItem( &item );

                // affinity
                item.mask = LVIF_TEXT; 
                item.iItem = index;
                item.iSubItem = 6;	
                item.pszText = GETRESOURCEIDSTRING(IDS_REPORT_EMPTY );
                item.cchTextMax = 100;
                GetDocument()->getListPane().SetItem( &item );

                ++index;
            }

            index = 0;
            map< long, PortDataD>::iterator topD;
            for( topD = p_clusterSettings->portD.begin();
                 topD != p_clusterSettings->portD.end();
                 ++topD )
            {


                // start port
                swprintf( buf, L"%d", (*topD).second._startPort );
                LVITEM item;
                item.mask = LVIF_TEXT | LVIF_IMAGE;
                item.iItem = index;
                item.iSubItem = 0;
                item.iImage = 4;
                item.pszText = buf;
                item.cchTextMax = 100;
                GetDocument()->getListPane().InsertItem( &item );

                // end port
                swprintf( buf, L"%d", (*topD).second._endPort );
                item.mask = LVIF_TEXT;
                item.iItem = index;
                item.iSubItem = 1;	 
                item.pszText = buf;
                item.cchTextMax = 100;
                GetDocument()->getListPane().SetItem( &item );

                // protocol
                item.mask = LVIF_TEXT; 
                item.iItem = index;
                item.iSubItem = 2;	 
                switch( (*topD).second._trafficToHandle )
                {
                    case MNLBPortRule::both :
                        item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_BOTH );
                        break;

                    case MNLBPortRule::tcp :
                        item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_TCP );
                        break;

                    case MNLBPortRule::udp :
                        item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_UDP );
                        break;
                }
                item.cchTextMax = 100;
                GetDocument()->getListPane().SetItem( &item );

                // mode 
                item.mask = LVIF_TEXT; 
                item.iItem = index;
                item.iSubItem = 3;	 
                item.pszText = GETRESOURCEIDSTRING(IDS_REPORT_MODE_DISABLED );
                item.cchTextMax = 100;
                GetDocument()->getListPane().SetItem( &item );
                
                // priority
                item.mask = LVIF_TEXT; 
                item.iItem = index;
                item.iSubItem = 4;	 
                item.pszText = GETRESOURCEIDSTRING(IDS_REPORT_EMPTY );
                item.cchTextMax = 100;
                GetDocument()->getListPane().SetItem( &item );

                // load
                item.mask = LVIF_TEXT; 
                item.iItem = index;
                item.iSubItem = 5;	 
                item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_EMPTY );
                item.cchTextMax = 100;
                GetDocument()->getListPane().SetItem( &item );

                // affinity
                item.mask = LVIF_TEXT; 
                item.iItem = index;
                item.iSubItem = 6;	 
                item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_EMPTY );
                item.cchTextMax = 100;
                GetDocument()->getListPane().SetItem( &item );

                ++index;
            }
            
            // sort it based on start port

            vector<PortsPage::PortData> ports;
            int index;
            
            // get all the port rules presently in the list.
            for( index = 0; index < GetDocument()->getListPane().GetItemCount(); ++index )
            {
                PortsPage::PortData portData;
                
                GetDocument()->getListPane().GetItemText( index, 0, buf, Common::BUF_SIZE );
                portData.start_port = buf;
                
                GetDocument()->getListPane().GetItemText( index, 1, buf, Common::BUF_SIZE );
                portData.end_port = buf;
                
                GetDocument()->getListPane().GetItemText( index, 2, buf, Common::BUF_SIZE );
                portData.protocol = buf;
                
                GetDocument()->getListPane().GetItemText( index, 3, buf, Common::BUF_SIZE );
                portData.mode = buf;
                
                GetDocument()->getListPane().GetItemText( index, 4, buf, Common::BUF_SIZE );
                portData.priority = buf;
                
                GetDocument()->getListPane().GetItemText( index, 5, buf, Common::BUF_SIZE );
                portData.load = buf;
                
                GetDocument()->getListPane().GetItemText( index, 6, buf, Common::BUF_SIZE );
                portData.affinity = buf;
                
                ports.push_back( portData );
            }

            sort( ports.begin(), ports.end(), comp_start_port() );

            int portIndex;
            int itemCount = GetDocument()->getListPane().GetItemCount();
            for( index = 0; index < itemCount; ++index )
            {
                portIndex = index;
                GetDocument()->getListPane().SetItemText( index, 0, ports[portIndex].start_port );
                GetDocument()->getListPane().SetItemText( index, 1, ports[portIndex].end_port );
                GetDocument()->getListPane().SetItemText( index, 2, ports[portIndex].protocol );
                GetDocument()->getListPane().SetItemText( index, 3, ports[portIndex].mode );
                GetDocument()->getListPane().SetItemText( index, 4, ports[portIndex].priority );
                GetDocument()->getListPane().SetItemText( index, 5, ports[portIndex].load );        
                GetDocument()->getListPane().SetItemText( index, 6, ports[portIndex].affinity );        
            }
            
            break;
    }
	
    *pResult = 0;
}


bool
LeftView::doesClusterExistInView( const _bstr_t& clusterToCheck )
{
    HTREEITEM rootItem = GetTreeCtrl().GetRootItem();
        
    ClusterData* p_clusterDataItem;
    
    if( GetTreeCtrl().ItemHasChildren( rootItem ) )
    {
        HTREEITEM hNextItem;
        HTREEITEM hChildItem = GetTreeCtrl().GetChildItem(rootItem);
            
        while (hChildItem != NULL)
        {
            hNextItem = GetTreeCtrl().GetNextItem(hChildItem, TVGN_NEXT);
            
            p_clusterDataItem = ( ClusterData * ) GetTreeCtrl().GetItemData( hChildItem );
            
            if( p_clusterDataItem->cp.cIP == clusterToCheck )
            {
                // this cluster already exists.
                return true;
            }
            
            hChildItem = hNextItem;
        }
    }
    
    return false;
}


void
LeftView::OnTest()
{
    MIPAddressAdmin ipAdmin( L"Intel 8255x-based PCI Ethernet Adapter (10/100)" );
    
    for( int i = 0; i < 100; ++i )
    {
        dataSink( GETRESOURCEIDSTRING( IDS_INFO_LINE_SEPARATOR ) );

        if ( ipAdmin.addIPAddress( L"1.1.1.121",
                                   L"255.0.0.0" ) !=
             MIPAddressAdmin::MIPAddressAdmin_SUCCESS ) 
        {
            dataSink( GETRESOURCEIDSTRING( IDS_INFO_FAILED ) );
        }
        else
        {
            dataSink( GETRESOURCEIDSTRING( IDS_INFO_DONE ) );
        }

        if ( ipAdmin.deleteIPAddress( L"1.1.1.121" )
             !=
             MIPAddressAdmin::MIPAddressAdmin_SUCCESS ) 
        {
            dataSink( GETRESOURCEIDSTRING( IDS_INFO_FAILED ) );
        }
        else
        {
            dataSink( GETRESOURCEIDSTRING( IDS_INFO_DONE ) );
        }
    }
}


void
LeftView::dumpClusterData( const ClusterData* clusterData )
{
    map< long, PortDataELB>::iterator topELB;
    PortDataELB portELB;
    for( topELB = clusterData->portELB.begin();
         topELB != clusterData->portELB.end();         
         ++topELB )
    {
        portELB = (*topELB).second;
    }

    map< long, PortDataULB>::iterator topULB;
    PortDataULB portULB;
    int loadWeight;
    for( topULB = clusterData->portULB.begin();
         topULB != clusterData->portULB.end();         
         ++topULB )
    {
        portULB = (*topULB).second;
        map< _bstr_t, HostData>::iterator topHosts;
        for( topHosts = clusterData->hosts.begin();
             topHosts != clusterData->hosts.end();             
             ++topHosts )
        {
            loadWeight = portULB.machineMapToLoadWeight[ (*topHosts).first ];
        }
    }

    map< long, PortDataF>::iterator topF;
    PortDataF portF;
    int priority;
    for( topF = clusterData->portF.begin();
         topF != clusterData->portF.end();         
         ++topF )
    {
        portF = (*topF).second;
        map< _bstr_t, HostData>::iterator topHosts;
        for( topHosts = clusterData->hosts.begin();
             topHosts != clusterData->hosts.end();             
             ++topHosts )
        {
            loadWeight = portF.machineMapToPriority[ (*topHosts).first ];
        }
    }

    map< long, PortDataD>::iterator topD;
    PortDataD portD;
    for( topD = clusterData->portD.begin();
         topD != clusterData->portD.end();         
         ++topD )
    {
        portD = (*topD).second;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\exe\managevirtualipspage.cpp ===
#include "ManageVirtualIPSPage.h"

#include "CommonUtils.h"

BEGIN_MESSAGE_MAP( ManageVirtualIPSPage, CPropertyPage )

    ON_BN_CLICKED( IDC_ADD_VIP, OnAddVirtualIP )
    ON_BN_CLICKED( IDC_REMOVE_VIP, OnRemoveVirtualIP ) 
END_MESSAGE_MAP()


ManageVirtualIPSPage::ManageVirtualIPSPage( ClusterData* p_clusterData,
                                            UINT ID )
        :
        CPropertyPage( ID ),
        m_clusterData( p_clusterData )
{}

void
ManageVirtualIPSPage::DoDataExchange( CDataExchange* pDX )
{
    CPropertyPage::DoDataExchange( pDX );

    DDX_Control( pDX, IDC_CLUSTER_IP, clusterIP );
    DDX_Control( pDX, IDC_VIRTUAL_IP, virtualIP );
    DDX_Control( pDX, IDC_ADD_VIP, addVirtualIP );
    DDX_Control( pDX, IDC_REMOVE_VIP, removeVirtualIP );
    DDX_Control( pDX, IDC_VIP_LIST, virtualIPSList );
}

BOOL
ManageVirtualIPSPage::OnInitDialog()
{
    CPropertyPage::OnInitDialog();

    SetControlData();

    return TRUE;
}

void
ManageVirtualIPSPage::SetControlData()
{
    // fill cluster ip.
    CommonUtils::fillCIPAddressCtrlString( clusterIP,
                                           m_clusterData->cp.cIP );                                           


    // fill present virtual ip list.
    for( int i = 0; i < m_clusterData->virtualIPs.size(); ++i )
    {
        virtualIPSList.AddString( m_clusterData->virtualIPs[i] );
    }

    virtualIPSList.SetCurSel( 0 );
}

void
ManageVirtualIPSPage::ReadControlData()
{
}


void
ManageVirtualIPSPage::OnOK()
{
    ReadControlData();

    CPropertyPage::OnOK();
}


void
ManageVirtualIPSPage::OnAddVirtualIP()
{
    // read vip to add.
    _bstr_t virtualIPToAdd = 
        CommonUtils::getCIPAddressCtrlString( virtualIP );
    
    int index = virtualIPSList.AddString( virtualIPToAdd );
    
    // set selection to vip added.
    virtualIPSList.SetCurSel( index );    
}

void
ManageVirtualIPSPage::OnRemoveVirtualIP()
{
    int index = virtualIPSList.GetCurSel();
    
    if( index != LB_ERR )
    {
        virtualIPSList.DeleteString( index );
    }

    virtualIPSList.SetCurSel( 0 );    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\exe\mainform.h ===
#ifndef MAINFORM_H
#define MAINFORM_H

#include "stdafx.h"

#include "Document.h"

class MainForm : public CFrameWnd
{
    DECLARE_DYNCREATE( MainForm )

public:
    MainForm();
 	virtual BOOL PreCreateWindow(CREATESTRUCT& cs);
private:

    CToolBar         toolBar;
    CStatusBar       statusBar; 

    CSplitterWnd     splitterWindow;
    CSplitterWnd     splitterWindow2;

protected:

    // message handlers
    afx_msg int OnCreate( LPCREATESTRUCT lpCreateStruct );

    afx_msg void clusterMenuClicked( CCmdUI* pCmdUI );

    afx_msg void hostMenuClicked( CCmdUI* pCmdUI );

    afx_msg void hostMenuClicked1( CCmdUI* pCmdUI );


    // overrides
    virtual
    BOOL
    OnCreateClient( LPCREATESTRUCT lpcs, CCreateContext* pContext );

    DECLARE_MESSAGE_MAP()
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\exe\portscontrolpage.cpp ===
#include "PortsControlPage.h"
#include "Common.h"
#include "wlbsparm.h"

#include "CommonUtils.h"
#include "ResourceString.h"



BEGIN_MESSAGE_MAP( PortsControlPage, CPropertyPage )
    ON_WM_HELPINFO()        
    ON_WM_CONTEXTMENU()        
END_MESSAGE_MAP()

void
PortsControlPage::DoDataExchange( CDataExchange* pDX )
{
    CPropertyPage::DoDataExchange( pDX );

    DDX_Control( pDX, IDC_PORTS, portList );
}

PortsControlPage::PortsControlPage( ClusterData*   p_clusterData,
                                    unsigned long*        portSelected,
                                    UINT     ID )
        :
        m_clusterData( p_clusterData ),
        m_portSelected( portSelected ),
        CPropertyPage( ID )
{
}

BOOL
PortsControlPage::OnInitDialog()
{
    CPropertyPage::OnInitDialog();

    // fill the portList with available ports.
    
    // first is allow user ability to select 
    // all ports.
    portList.AddString( GETRESOURCEIDSTRING( IDS_PORTS_ALL ) );

    wchar_t buf[Common::BUF_SIZE];

    map< long, PortDataELB>::iterator topELB;
    for( topELB = m_clusterData->portELB.begin();
         topELB != m_clusterData->portELB.end();
         ++topELB )
    {
        swprintf( buf, L"%d", (*topELB).second._startPort );
        portList.AddString( buf );
    }

    map< long, PortDataULB>::iterator topULB;
    for( topULB = m_clusterData->portULB.begin();
         topULB != m_clusterData->portULB.end();
         ++topULB )
    {
        swprintf( buf, L"%d", (*topULB).second._startPort );
        portList.AddString( buf );
    }

    map< long, PortDataF>::iterator topF;
    for( topF = m_clusterData->portF.begin();
         topF != m_clusterData->portF.end();
         ++topF )
    {
        swprintf( buf, L"%d", (*topF).second._startPort );
        portList.AddString(  buf );
    }

    map< long, PortDataD>::iterator topD;
    for( topD = m_clusterData->portD.begin();
         topD != m_clusterData->portD.end();
         ++topD )
    {
        swprintf( buf, L"%d", (*topD).second._startPort );
        portList.AddString(  buf );

    }

    // make the all ports selection the
    // default selection.
    portList.SelectString( -1,
                           GETRESOURCEIDSTRING( IDS_PORTS_ALL ) );
    return TRUE;
}

void
PortsControlPage::OnOK()
{
    // get port which needs to be affected.
    int currentSelection = portList.GetCurSel();
    wchar_t buf[ Common::BUF_SIZE ];
    
    portList.GetLBText( currentSelection, buf );

    if( _bstr_t ( buf ) == GETRESOURCEIDSTRING( IDS_PORTS_ALL ) )
    {
        *m_portSelected = Common::ALL_PORTS;
    }
    else
    {
        *m_portSelected = _wtoi( buf );
    }

    CPropertyPage::OnOK();
}

BOOL
PortsControlPage::OnHelpInfo (HELPINFO* helpInfo )
{
    if( helpInfo->iContextType == HELPINFO_WINDOW )
    {
        ::WinHelp( static_cast<HWND> ( helpInfo->hItemHandle ), 
                   CVY_CTXT_HELP_FILE, 
                   HELP_WM_HELP, 
                   (ULONG_PTR ) g_aHelpIDs_IDD_PORTS_CONTROL_PAGE );
    }

    return TRUE;
}

void
PortsControlPage::OnContextMenu( CWnd* pWnd, CPoint point )
{
    ::WinHelp( m_hWnd, 
               CVY_CTXT_HELP_FILE, 
               HELP_CONTEXTMENU, 
               (ULONG_PTR ) g_aHelpIDs_IDD_PORTS_CONTROL_PAGE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\exe\portscontrolpage.h ===
#ifndef PORTSCONTROLPAGE_H
#define PORTSCONTROLPAGE_H

#include "stdafx.h"

#include "resource.h"

#include "MNLBUIData.h"

class PortsControlPage : public CPropertyPage
{
public:
    enum
    {
        IDD = IDD_PORTS_CONTROL_PAGE,
    };

    // member controls.
    PortsControlPage( ClusterData*   p_clusterData,
                      unsigned long*        portSelected,
                      UINT         ID = PortsControlPage::IDD );

    CComboBox      portList;

    // overrides of CPropertyPage
    virtual void DoDataExchange( CDataExchange* pDX );

    virtual BOOL OnInitDialog();

    virtual void OnOK();

    afx_msg BOOL OnHelpInfo (HELPINFO* helpInfo );

    afx_msg void OnContextMenu( CWnd* pWnd, CPoint point );

protected :

    unsigned long* m_portSelected;

    ClusterData* m_clusterData;

    DECLARE_MESSAGE_MAP()
};

static DWORD g_aHelpIDs_IDD_PORTS_CONTROL_PAGE [] = {
    IDC_TEXT_START_PORT,        IDC_TEXT_START_PORT,
    IDC_PORTS,                  IDC_PORTS,
    0,0
};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\exe\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by resource.rc
//
#define IDR_MAINFRAME                   101
#define IDI_WORLD                       102
#define IDI_CLUSTER                     103
#define IDI_HOST_STARTED                104
#define IDI_HOST_STOPPED                105
#define IDR_POPUP                       108
#define IDD_ABOUT                       109
#define IDD_CLUSTER_CONNECT             110
#define IDD_MACHINE_CONNECT             112
#define IDD_MACHINE_CONNECT_PAGE        112
#define IDD_CLUSTER_PROPERTIES          113
#define IDD_CLUSTER_PAGE                113
#define IDD_HOST_PROPERTIES             114
#define IDD_HOST_PAGE                   114
#define IDI_PORTRULE                    119
#define IDI_PENDING                     123
#define IDD_CLUSTER_CLUSTER             533
#define IDD_HOST_PORTS                  535
#define IDD_CLUSTER_PORTS               536
#define IDD_CLUSTER_CONNECT_ADVANCED    537
#define IDD_CLUSTER_CONNECT_INDIRECT_PAGE 537
#define IDD_MANAGE_VIRTUAL_IPS_PAGE     538
#define IDD_CLUSTER_CONNECT1            539
#define IDD_CLUSTER_CONNECT_PAGE        539
#define IDD_DIALOG_PORTS                540
#define IDD_DIALOG_PORT_RULE_PROP_HOSTS 541
#define IDD_DIALOG_PORT_RULE_PROP_CLUSTER 542
#define IDD_PORTS_CONTROL_PAGE          543
#define IDD_DISCLAIMER                  544
#define IDC_GROUP_CL_IP                 1000
#define IDC_TEXT_CL_IP                  1001
#define IDC_EDIT_CL_IP                  1002
#define IDC_TEXT_CL_MASK                1003
#define IDC_EDIT_CL_MASK                1004
#define IDC_TEXT_DOMAIN                 1005
#define IDC_EDIT_DOMAIN                 1006
#define IDC_TEXT_ETH                    1007
#define IDC_EDIT_ETH                    1008
#define IDC_GROUP_CL_MODE               1009
#define IDC_RADIO_UNICAST               1010
#define IDC_RADIO_MULTICAST             1011
#define IDC_CHECK_IGMP                  1012
#define IDC_GROUP_RCT                   1013
#define IDC_CHECK_RCT                   1014
#define IDC_TEXT_PASSW                  1015
#define IDC_EDIT_PASSW                  1016
#define IDC_TEXT_PASSW2                 1017
#define IDC_EDIT_PASSW2                 1018
#define IDC_BUTTON_HELP                 1019
#define IDC_CLUSTER_MEMBER              1023
#define IDC_VIRTUAL_IP                  1025
#define IDC_ADD_VIP                     1026
#define IDC_VIP_LIST                    1027
#define IDC_REMOVE_VIP                  1028
#define IDC_SCROLLBAR1                  1031
#define IDC_NIC_DETAIL                  1032
#define IDC_GROUP_NIC                   1035
#define IDC_TEXT_CLUSTER_IP             1036
#define IDC_TEXT_MACHINE_IP             1037
#define IDC_TEXT_MACHINE_IP_LIST        1038
#define IDC_TEXT_CONNECTION_STATUS      1039
#define IDC_TEXT_CLUSTER_MEMBER         1040
#define IDC_TEXT_MACHINE                1042
#define IDC_TEXT_SECONDARY_IP           1043
#define IDC_TEXT_SECONDARY_IP_LIST      1044
#define IDC_DO_NOT_REMIND               1046
#define IDC_TEXT_PRI                    2000
#define IDC_EDIT_PRI                    2001
#define IDC_GROUP_DED_IP                2003
#define IDC_TEXT_DED_IP                 2004
#define IDC_EDIT_DED_IP                 2005
#define IDC_TEXT_DED_MASK               2006
#define IDC_EDIT_DED_MASK               2007
#define IDC_CHECK_ACTIVE                2008
#define IDC_TEXT_PORT_RULE              3000
#define IDC_LIST_PORT_RULE              3001
#define IDC_BUTTON_ADD                  3002
#define IDC_BUTTON_MODIFY               3003
#define IDC_BUTTON_DEL                  3004
#define IDC_GROUP_PORT_RULE_DESCR       3005
#define IDC_TEXT_PORT_RULE_DESCR        3006
#define IDC_GROUP_RANGE                 4000
#define IDC_EDIT_START                  4001
#define IDC_SPIN_START                  4002
#define IDC_EDIT_END                    4003
#define IDC_SPIN_END                    4004
#define IDC_GROUP_PROTOCOLS             4005
#define IDC_RADIO_TCP                   4006
#define IDC_RADIO_UDP                   4007
#define IDC_RADIO_BOTH                  4008
#define IDC_GROUP_SINGLE                4009
#define IDC_GROUP_MULTIPLE              4010
#define IDC_GROUP_DISABLED              4011
#define IDC_RADIO_SINGLE                4012
#define IDC_RADIO_MULTIPLE              4013
#define IDC_RADIO_DISABLED              4014
#define IDC_TEXT_AFF                    4015
#define IDC_RADIO_AFF_NONE              4016
#define IDC_RADIO_AFF_SINGLE            4017
#define IDC_RADIO_AFF_CLASSC            4018
#define IDC_TEXT_MULTI                  4019
#define IDC_EDIT_MULTI                  4020
#define IDC_SPIN_MULTI                  4021
#define IDC_CHECK_EQUAL                 4022
#define IDC_TEXT_SINGLE                 4023
#define IDC_EDIT_SINGLE                 4024
#define IDC_SPIN_SINGLE                 4025
#define IDC_TEXT_START                  4026
#define IDC_TEXT_END                    4027
#define ID_WORLD_NEW                    40001
#define ID_WORLD_CONNECT                40003
#define ID_WORLD_CONNECT_INDIRECT       40004
#define ID_REFRESH_DIRECT               40005
#define ID_REFRESH_INDIRECT             40006
#define ID_REFRESH                      40007
#define ID_HELP_TOPICS                  40009
#define ID_CLUSTER_ADD_HOST             40016
#define ID_CLUSTER_REMOVE               40017
#define ID_CLUSTER_PROPERTIES           40018
#define ID_CLUSTER_UNMANAGE             40019
#define ID_CLUSTER_EXE_QUERY            40020
#define ID_CLUSTER_EXE_START            40021
#define ID_CLUSTER_EXE_STOP             40022
#define ID_CLUSTER_EXE_DRAINSTOP        40023
#define ID_CLUSTER_EXE_RESUME           40024
#define ID_CLUSTER_EXE_SUSPEND          40025
#define ID_CLUSTER_EXE_ENABLE           40026
#define ID_CLUSTER_EXE_DISABLE          40027
#define ID_CLUSTER_EXE_DRAIN            40028
#define ID_CLUSTER_MANAGE_VIPS          40029
#define ID_VIEW_STATUSBAR               40042
#define ID_HOST_REMOVE                  40130
#define ID_HOST_PROPERTIES              40131
#define ID_HOST_EXE_QUERY               40132
#define ID_HOST_EXE_START               40133
#define ID_HOST_EXE_STOP                40134
#define ID_HOST_EXE_DRAINSTOP           40135
#define ID_HOST_EXE_RESUME              40136
#define ID_HOST_EXE_SUSPEND             40137
#define ID_HOST_EXE_ENABLE              40138
#define ID_HOST_EXE_DISABLE             40139
#define ID_HOST_EXE_DRAIN               40140
#define IDS_WORLD_NAME                  41040
#define IDS_PROPERTIES_CAPTION          41041
#define IDS_FULL_INTERNET_NAME          41042
#define IDS_INFO_DONE                   41143
#define IDS_INFO_SUCCESS                41144
#define IDS_INFO_FAILED                 41145
#define IDS_INFO_REQUEST                41146
#define IDS_INFO_NEW_EXCEPTION          41147
#define IDS_INFO_FINDING_P              41246
#define IDS_INFO_FINDING_CL             41247
#define IDS_INFO_FINDING_H              41248
#define IDS_INFO_FINDING_CL_P           41249
#define IDS_INFO_FINDING_H_P            41250
#define IDS_INFO_FINDING_P_ELB          41251
#define IDS_INFO_FINDING_P_ULB          41252
#define IDS_INFO_FINDING_P_D            41253
#define IDS_INFO_FINDING_P_F            41254
#define IDS_INFO_MODIFYING_P            41354
#define IDS_INFO_MODIFYING_CL_P         41355
#define IDS_INFO_MODIFYING_H_P          41356
#define IDS_INFO_MODIFYING_P_ELB        41357
#define IDS_INFO_MODIFYING_P_ULB        41358
#define IDS_INFO_MODIFYING_P_F          41359
#define IDS_INFO_MODIFYING_P_D          41360
#define IDS_INFO_MODIFYING_CN           41361
#define IDS_INFO_MODIFYING_CP_AND_ADD_IP 41362
#define IDS_INFO_CONNECTING             41446
#define IDS_INFO_NEWLINE                41540
#define IDS_INFO_LINE_SEPARATOR         41541
#define IDS_INFO_ADDING_CL_IP           41650
#define IDS_INFO_REMOVING_CL_IP         41651
#define IDS_INFO_BINDING_NLB            41750
#define IDS_INFO_UNBINDING_NLB          41751
#define IDS_WLBS_OK                     41850
#define IDS_WLBS_DRAIN_STOP             41851
#define IDS_WLBS_BAD_PARAMS             41852
#define IDS_WLBS_NOT_FOUND              41853
#define IDS_WLBS_STOPPED                41854
#define IDS_WLBS_CONVERGING             41855
#define IDS_WLBS_CONVERGED              41856
#define IDS_WLBS_DEFAULT                41857
#define IDS_WLBS_DRAINING               41858
#define IDS_WLBS_SUSPENDED              41859
#define IDS_WLBS_REBOOT                 41860
#define IDS_WLBS_INIT_ERROR             41861
#define IDS_WLBS_BAD_PASSW              41862
#define IDS_WLBS_IO_ERROR               41863
#define IDS_WLBS_TIMEOUT                41864
#define IDS_WLBS_PORT_OVERLAP           41865
#define IDS_WLBS_BAD_PORT_PARAMS        41866
#define IDS_WLBS_MAX_PORT_RULES         41867
#define IDS_WLBS_TRUNCATED              41868
#define IDS_WLBS_REG_ERROR              41869
#define IDS_WLBS_ALREADY                41870
#define IDS_COMMAND_QUERY               41880
#define IDS_COMMAND_START               41881
#define IDS_COMMAND_STOP                41882
#define IDS_COMMAND_DRAINSTOP           41883
#define IDS_COMMAND_RESUME              41884
#define IDS_COMMAND_SUSPEND             41885
#define IDS_COMMAND_ENABLE              41886
#define IDS_COMMAND_DISABLE             41887
#define IDS_COMMAND_DRAIN               41888
#define IDS_WLBS_UNKNOWN                41899
#define IDS_MACHINE_LIST_EMPTY          41947
#define IDS_MACHINE_ALREADY             41948
#define IDS_CLUSTER_ALREADY             41949
#define IDS_HOST_ALREADY                41950
#define IDS_HOST_ADDING                 41951
#define IDS_CLUSTER_MAX                 41952
#define IDS_NIC_BOUND                   41953
#define IDS_NIC_UNBOUND                 41954
#define IDS_HEADER_C_IP                 42100
#define IDS_HEADER_C_SUBNET             42101
#define IDS_HEADER_INTERNET_NAME        42102
#define IDS_HEADER_MAC_ADDRESS          42103
#define IDS_HEADER_C_MODE               42104
#define IDS_HEADER_REMOTE_CTRL          42105
#define IDS_HEADER_MACHINE              42199
#define IDS_HEADER_D_IP                 42200
#define IDS_HEADER_D_SUBNET             42201
#define IDS_HEADER_PRIORITY             42202
#define IDS_HEADER_INITIAL_STATE        42203
#define IDS_HEADER_NIC                  42204
#define IDS_HEADER_P_START              42250
#define IDS_HEADER_P_END                42251
#define IDS_HEADER_P_PROTOCOL           42252
#define IDS_HEADER_P_MODE               42253
#define IDS_HEADER_P_LOAD               42254
#define IDS_HEADER_P_AFFINITY           42255
#define IDS_HEADER_P_PRIORITY           42256
#define IDS_REPORT_MULTICAST            42300
#define IDS_REPORT_UNICAST              42301
#define IDS_REPORT_IGMP                 42302
#define IDS_REPORT_ON                   42303
#define IDS_REPORT_OFF                  42304
#define IDS_REPORT_PROTOCOL_TCP         42305
#define IDS_REPORT_PROTOCOL_UDP         42306
#define IDS_REPORT_PROTOCOL_BOTH        42307
#define IDS_REPORT_LOAD_EQUAL           42308
#define IDS_REPORT_LOAD_UNEQUAL         42309
#define IDS_REPORT_MODE_MULTIPLE        42310
#define IDS_REPORT_MODE_SINGLE          42311
#define IDS_REPORT_MODE_DISABLED        42312
#define IDS_REPORT_AFFINITY_SINGLE      42313
#define IDS_REPORT_AFFINITY_NONE        42314
#define IDS_REPORT_AFFINITY_CLASSC      42315
#define IDS_REPORT_EMPTY                42316
#define IDS_REPORT_NA                   42317
#define IDS_WARNING_CLUSTER_REMOVE      42400
#define IDS_WARNING_HOST_REMOVE         42401
#define IDS_VIRTUAL_IPS_CAPTION         42402
#define IDS_CONNECT_CAPTION             42403
#define IDS_CONNECT_CLUSTER_CAPTION     42404
#define IDS_WARNING_IP_INVALID          42405
#define IDS_WARNING_CL_CONN_SAME        42406
#define IDC_NIC                         52009
#define IDC_NIC_FRIENDLY                52010
#define IDC_RADIO_UNEQUAL               53010
#define IDC_RADIO_EQUAL                 53011
#define IDC_LIST                        53020
#define IDC_EDIT_PRIORITY               53038
#define IDC_SPIN_PRIORITY               53039
#define IDC_EDIT_LOAD                   53040
#define IDC_SPIN_LOAD                   53041
#define IDC_EDIT_LIST_TITLE             53070
#define IDC_MACHINE_CONNECTION_STATUS   54001
#define IDC_MACHINE                     54002
#define IDC_CLUSTER_IP                  55001
#define IDC_CLUSTER_CONNECTION_STATUS   55002
#define IDC_MACHINE_LIST                56001
#define IDC_MACHINE_IP_LIST             56001
#define IDC_ADD_MACHINE                 56002
#define IDC_ADVANCED                    56003
#define IDC_NOT_ADVANCED                56004
#define IDC_DEL_MACHINE                 56005
#define IDC_SECONDARY_IP                56006
#define IDC_SECONDARY_IP_LIST           56007
#define IDC_TEXT_START_PORT             56100
#define IDC_PORTS                       56101
#define IDS_PARM_PASSWORD               57001
#define IDS_PARM_IGMP_MCAST             57002
#define IDS_PARM_IGMP_WARN              57003
#define IDS_PARM_WARN                   57004
#define IDS_PARM_ERROR                  57005
#define IDS_PARM_CL_IP_BLANK            57006
#define IDS_PARM_CL_NM_BLANK            57007
#define IDS_PARM_INVAL_CL_IP            57008
#define IDS_PARM_INVAL_CL_MASK          57009
#define IDS_PARM_CL_IP_FIELD            57010
#define IDS_PARM_CL_NM_FIELD            57011
#define IDS_PARM_IP_CONFLICT            57012
#define IDS_PARM_INVAL_MAC              57013
#define IDS_PARM_RCT_WARN               57014
#define IDS_PARM_DIP_MISCONFIG          57015
#define IDS_PARM_DED_IP_BLANK           57016
#define IDS_PARM_DED_NM_BLANK           57017
#define IDS_PARM_INVAL_DED_IP           57018
#define IDS_PARM_INVAL_DED_MASK         57019
#define IDS_PARM_PORT_BLANK             57100
#define IDS_PARM_LOAD_BLANK             57101
#define IDS_PARM_PORT_VAL               57102
#define IDS_PARM_LOAD                   57103
#define IDS_PARM_RULES                  57104
#define IDS_PARM_RANGE                  57105
#define IDS_PARM_OVERLAP                57106
#define IDS_PORTS_ALL                   57107
#define IDS_PORTS_CONTROL_NONE          57108
#define IDS_INVAL_DHCP_NIC              57109
#define IDS_INVAL_DIP                   57110
#define IDS_NLB_ALREADY                 57111
#define IDS_BOTTOM_PANE_TITLE           57112
#define IDS_REFRESH_CLUSTER             57113
#define IDS_CANTRUN_NONICS_TEXT         57200
#define IDS_CANTRUN_NONICS_CAPTION      57201

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        124
#define _APS_NEXT_COMMAND_VALUE         40048
#define _APS_NEXT_CONTROL_VALUE         1047
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\exe\portspage.h ===
#ifndef PORTSPAGE_H
#define PORTSPAGE_H

#include "stdafx.h"

#include "resource.h"

#include "MNLBUIData.h"
#include "CommonNLB.h"

class PortsPage : public CPropertyPage
{
public:
    struct PortData
    {
        PortData();

        DWORD key;

        _bstr_t start_port;
        _bstr_t end_port;
        _bstr_t protocol;
        _bstr_t mode;
        _bstr_t priority;
        _bstr_t load;
        _bstr_t affinity;
    };


    enum
    {
        IDD = IDD_DIALOG_PORTS,
    };

    PortsPage( const _bstr_t&       myMachineName,
               ClusterData*         p_clusterData,
               UINT                 ID = PortsPage::IDD );

    PortsPage( ClusterData*         p_clusterData,
               UINT                 ID = PortsPage::IDD );
    
    ~PortsPage();

    void
    getPresentPorts( vector<PortData>* ports );

    // overrides of CPropertyPage
    virtual void OnOK();

    virtual BOOL OnKillActive();

    virtual BOOL OnInitDialog();

    virtual void DoDataExchange( CDataExchange* pDX );

    afx_msg void OnButtonAdd();

    afx_msg void OnButtonDel();

    afx_msg void OnButtonModify();

    afx_msg void OnDoubleClick( NMHDR * pNotifyStruct, LRESULT * result );

    afx_msg void OnColumnClick( NMHDR * pNotifyStruct, LRESULT * result );

    afx_msg void OnSelchanged( NMHDR * pNotifyStruct, LRESULT * result );

    afx_msg BOOL OnHelpInfo (HELPINFO* helpInfo );

    afx_msg void OnContextMenu( CWnd* pWnd, CPoint point );


    // data members 
    CListCtrl	m_portList;

    CButton     buttonAdd;

    CButton     buttonModify;

    CButton     buttonDel;

    ClusterData* m_clusterData;

    bool         m_isClusterLevel;

    _bstr_t      machine;

private:

    bool m_sort_ascending;

    int m_sort_column;

    void
    SetControlData();


    DECLARE_MESSAGE_MAP()

};

static DWORD g_aHelpIDs_IDD_DIALOG_PORTS [] = {
    IDC_TEXT_PORT_RULE,           IDC_LIST_PORT_RULE,
    IDC_LIST_PORT_RULE,           IDC_LIST_PORT_RULE,
    IDC_BUTTON_ADD,               IDC_BUTTON_ADD,
    IDC_BUTTON_MODIFY,            IDC_BUTTON_MODIFY,
    IDC_BUTTON_DEL,               IDC_BUTTON_DEL,
    IDC_GROUP_PORT_RULE_DESCR,    IDC_GROUP_PORT_RULE_DESCR,
    IDC_TEXT_PORT_RULE_DESCR,     IDC_GROUP_PORT_RULE_DESCR,
    0, 0
};

class comp_start_port
{
public:
    bool operator()( PortsPage::PortData x, PortsPage::PortData y )
        {
            return ( _wtoi( x.start_port ) < _wtoi( y.start_port ) );
        }
};

class comp_end_port
{
public:
    bool operator()( PortsPage::PortData x, PortsPage::PortData y )
        {
            return ( _wtoi( x.end_port ) < _wtoi( y.end_port ) );
        }
};

class comp_protocol
{
public:
    bool operator()( PortsPage::PortData x, PortsPage::PortData y )
        {
            return  ( x.protocol  <  y.protocol ); 
        }
};

class comp_mode
{
public:
    bool operator()( PortsPage::PortData x, PortsPage::PortData y )
        {
            return  ( x.mode  <  y.mode ); 
        }
};

class comp_priority_string
{
public:
    bool operator()( PortsPage::PortData x, PortsPage::PortData y )
        {
            return (  x.priority  <  y.priority );
        }
};

class comp_priority_int
{
public:
    bool operator()( PortsPage::PortData x, PortsPage::PortData y )
        {
            return ( _wtoi( x.priority ) < _wtoi( y.priority ) );
        }
};

class comp_load_string
{
public:
    bool operator()( PortsPage::PortData x, PortsPage::PortData y )
        {
            return  ( x.load  <  y.load ); 
        }
};

class comp_load_int
{
public:
    bool operator()( PortsPage::PortData x, PortsPage::PortData y )
        {
            return ( _wtoi( x.load ) < _wtoi( y.load ) );
        }
};


class comp_affinity
{
public:
    bool operator()( PortsPage::PortData x, PortsPage::PortData y )
        {
            return  ( x.affinity  <  y.affinity ); 
        }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\exe\resourcestring.cpp ===
#include "ResourceString.h"

#include "resource.h"

// static member definition.
map< UINT, _bstr_t>
ResourceString::resourceStrings;

ResourceString* ResourceString::_instance = 0;

#if OBSOLETE
// constructor
//
ResourceString::ResourceString()
{}
#endif // OBSOLETE

// Instance
//
ResourceString*
ResourceString::Instance()
{
    if( _instance == 0 )
    {
        _instance = new ResourceString;
    }

    return _instance;
}

// GetIDString
//
const _bstr_t&
ResourceString::GetIDString( UINT id )
{
    // check if string has been loaded previously.
    if( resourceStrings.find( id ) == resourceStrings.end() )
    {
        // first time load.
        CString str;
        if( str.LoadString( id ) == 0 )
        {
            // no string mapping to this id.
            throw _com_error( WBEM_E_NOT_FOUND );
        }

        resourceStrings[id] = str;
    }

    return resourceStrings[ id ];
}

// GETRESOURCEIDSTRING
// helper function.
//
const _bstr_t&
GETRESOURCEIDSTRING( UINT id )
{
#if OBSOLETE
    ResourceString* instance = ResourceString::Instance();

    return instance->GetIDString( id );
#else
	return ResourceString::GetIDString( id );
#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\exe\portspage.cpp ===
#include "stdafx.h"
#include "PortsPage.h"
#include "ClusterPortsDlg.h"
#include "HostPortsDlg.h"
#include "Document.h"
#include "wlbsparm.h"
#include "ResourceString.h"
#include "MNLBUIData.h"

#include <vector>
#include <map>
#include <algorithm>
using namespace std;

BEGIN_MESSAGE_MAP(PortsPage, CPropertyPage)
    ON_BN_CLICKED(IDC_BUTTON_ADD, OnButtonAdd)
    ON_BN_CLICKED(IDC_BUTTON_DEL, OnButtonDel)
    ON_BN_CLICKED(IDC_BUTTON_MODIFY, OnButtonModify)
    ON_NOTIFY( NM_DBLCLK, IDC_LIST_PORT_RULE, OnDoubleClick )
    ON_NOTIFY( LVN_ITEMCHANGED, IDC_LIST_PORT_RULE, OnSelchanged )
    ON_NOTIFY( LVN_COLUMNCLICK, IDC_LIST_PORT_RULE, OnColumnClick )
    ON_WM_HELPINFO()        
    ON_WM_CONTEXTMENU()        
    END_MESSAGE_MAP()

    PortsPage::PortData::PortData()
{
    wchar_t buf[Common::BUF_SIZE];
    swprintf( buf, L"%d", CVY_MIN_PORT );
    start_port = buf;

    swprintf( buf, L"%d", CVY_MAX_PORT );
    end_port = buf;

    protocol = GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_BOTH );
    mode = GETRESOURCEIDSTRING( IDS_REPORT_MODE_MULTIPLE );
    load = GETRESOURCEIDSTRING( IDS_REPORT_LOAD_EQUAL );
    affinity = GETRESOURCEIDSTRING( IDS_REPORT_AFFINITY_SINGLE );
}


PortsPage::PortsPage( ClusterData*        p_clusterData,
                      UINT                ID)
        : m_clusterData( p_clusterData ),
          m_isClusterLevel( true ),
          CPropertyPage(ID),
          m_sort_column( -1 )
{}

PortsPage::PortsPage( const _bstr_t&       myMachineName,
                      ClusterData*        p_clusterData,
                      UINT                ID)
        : m_clusterData( p_clusterData ),
          machine( myMachineName ),
          m_isClusterLevel( false ),
          CPropertyPage(ID),
          m_sort_column( -1 )
{}


PortsPage:: ~PortsPage()
{}

void PortsPage::DoDataExchange(CDataExchange* pDX)
{
    CPropertyPage::DoDataExchange(pDX);

    DDX_Control(pDX, IDC_LIST_PORT_RULE, m_portList);

    DDX_Control(pDX, IDC_BUTTON_ADD, buttonAdd );

    DDX_Control(pDX, IDC_BUTTON_MODIFY, buttonModify );

    DDX_Control(pDX, IDC_BUTTON_DEL, buttonDel );
}

void
PortsPage::OnOK()
{
    CPropertyPage::OnOK();
}

BOOL
PortsPage::OnKillActive()
{
    // get present port rules
    vector<PortData> ports;
    getPresentPorts( &ports );
    
    // now form the new port structure.
    PortDataELB elbPortRule;
    PortDataULB ulbPortRule;
    PortDataF   fPortRule;
    PortDataD   dPortRule;

    map< long, PortDataELB> portELB;
    map< long, PortDataULB> portULB;
    map< long, PortDataD> portD;
    map< long, PortDataF> portF;

    for( int i = 0; i < ports.size(); ++i )
    {
        // check which type of port rule it is.
        //

        if( ports[i].mode == GETRESOURCEIDSTRING( IDS_REPORT_MODE_MULTIPLE )
            &&
            ports[i].load == GETRESOURCEIDSTRING( IDS_REPORT_LOAD_EQUAL )
            )
        {
            // equal load balanced
            elbPortRule._startPort = _wtoi( ports[i].start_port );

            elbPortRule._endPort = _wtoi( ports[i].end_port );

            if( ports[i].protocol == GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_BOTH ) )
            {
                elbPortRule._trafficToHandle = MNLBPortRule::both;
            }
            else if( ports[i].protocol == GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_TCP ) )
            {
                elbPortRule._trafficToHandle = MNLBPortRule::tcp;
            }
            else if( ports[i].protocol == GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_UDP ) )
            {
                elbPortRule._trafficToHandle = MNLBPortRule::udp;
            }

            if( ports[i].affinity == GETRESOURCEIDSTRING( IDS_REPORT_AFFINITY_NONE ) )
            {
                elbPortRule._affinity = MNLBPortRule::none;
            }
            else if( ports[i].affinity == GETRESOURCEIDSTRING( IDS_REPORT_AFFINITY_SINGLE ) )
            {
                elbPortRule._affinity = MNLBPortRule::single;
            }
            else if( ports[i].affinity == GETRESOURCEIDSTRING( IDS_REPORT_AFFINITY_CLASSC ) )
            {
                elbPortRule._affinity = MNLBPortRule::classC;
            }

            elbPortRule._key = elbPortRule._startPort;

            portELB[ elbPortRule._startPort ] = elbPortRule;
        }
        else if( ports[i].mode == GETRESOURCEIDSTRING( IDS_REPORT_MODE_MULTIPLE )
                 &&
                 ports[i].load != GETRESOURCEIDSTRING( IDS_REPORT_LOAD_EQUAL )
                 )
        {
            // unequal load balanced
            ulbPortRule._startPort = _wtoi( ports[i].start_port );

            ulbPortRule._endPort = _wtoi( ports[i].end_port );

            if( ports[i].protocol == GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_BOTH ) )
            {
                ulbPortRule._trafficToHandle = MNLBPortRule::both;
            }
            else if( ports[i].protocol == GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_TCP ) )
            {
                ulbPortRule._trafficToHandle = MNLBPortRule::tcp;
            }
            else if( ports[i].protocol == GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_UDP ) )
            {
                ulbPortRule._trafficToHandle = MNLBPortRule::udp;
            }

            if( ports[i].affinity == GETRESOURCEIDSTRING( IDS_REPORT_AFFINITY_NONE ) )
            {
                ulbPortRule._affinity = MNLBPortRule::none;
            }
            else if( ports[i].affinity == GETRESOURCEIDSTRING( IDS_REPORT_AFFINITY_SINGLE ) )
            {
                ulbPortRule._affinity = MNLBPortRule::single;
            }
            else if( ports[i].affinity == GETRESOURCEIDSTRING( IDS_REPORT_AFFINITY_CLASSC ) )
            {
                ulbPortRule._affinity = MNLBPortRule::classC;
            }

            if( ports[i].key == -1 
                ||
                ( m_clusterData->portULB.find( ports[i].key )
                  ==
                  m_clusterData->portULB.end() )
                )
            {
                // new port rule.

                // user may change the rule completely if so
                // consider it as new.
                if( m_isClusterLevel == true )
                {
                    map< _bstr_t, HostData >::iterator top;
                    for( top = m_clusterData->hosts.begin();
                         top != m_clusterData->hosts.end();                 
                         ++top )
                    {
                        // default value is 50 load weight
                        // for each machine
                        ulbPortRule.machineMapToLoadWeight[(*top).first] = 50;
                    }
                }
                else
                {
                    ulbPortRule.machineMapToLoadWeight = 
                        m_clusterData->portULB[ ports[i].key ].machineMapToLoadWeight;

                    ulbPortRule.machineMapToLoadWeight[machine]
                        = _wtoi( ports[i].load );
                }
            }
            else
            {
                // existing port rule.
                ulbPortRule.machineMapToLoadWeight = 
                    m_clusterData->portULB[ ports[i].key ].machineMapToLoadWeight;

                if( m_isClusterLevel == false )
                {
                    ulbPortRule.machineMapToLoadWeight[machine]
                        = _wtoi( ports[i].load );
                }
            }

            ulbPortRule._key = ulbPortRule._startPort;

            portULB[ ulbPortRule._startPort ] = ulbPortRule;
        }
        else if( ports[i].mode == GETRESOURCEIDSTRING( IDS_REPORT_MODE_SINGLE ) )
        {
            // failover
            fPortRule._startPort = _wtoi( ports[i].start_port );

            fPortRule._endPort = _wtoi( ports[i].end_port );

            if( ports[i].protocol == GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_BOTH ) )
            {
                fPortRule._trafficToHandle = MNLBPortRule::both;
            }
            else if( ports[i].protocol == GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_TCP ) )
            {
                fPortRule._trafficToHandle = MNLBPortRule::tcp;
            }
            else if( ports[i].protocol == GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_UDP ) )
            {
                fPortRule._trafficToHandle = MNLBPortRule::udp;
            }

            if( ports[i].key == -1
                ||
                ( m_clusterData->portF.find( ports[i].key )
                  ==
                  m_clusterData->portF.end() )
                )
            {
                // new port rule.
                // by default make priority equal to host id.

                if( m_isClusterLevel == true )
                {
                    map< _bstr_t, HostData >::iterator top;
                    for( top = m_clusterData->hosts.begin();
                         top != m_clusterData->hosts.end();                 
                         ++top )
                    {
                        fPortRule.machineMapToPriority[(*top).first] = (*top).second.hp.hID;
                    }
                }
                else
                {
                    fPortRule.machineMapToPriority = 
                        m_clusterData->portF[ ports[i].key ].machineMapToPriority;

                    fPortRule.machineMapToPriority[machine]
                        = _wtoi( ports[i].priority );
                }
            }
            else
            {
                fPortRule.machineMapToPriority = 
                    m_clusterData->portF[ ports[i].key ].machineMapToPriority;

                if( m_isClusterLevel == false )
                {
                    fPortRule.machineMapToPriority[machine]
                        = _wtoi( ports[i].priority );
                }
            }

            fPortRule._key = fPortRule._startPort;

            portF[ fPortRule._startPort ] = fPortRule;
        }
        else if( ports[i].mode == GETRESOURCEIDSTRING( IDS_REPORT_MODE_DISABLED ) )
        {
            // disabled
            dPortRule._startPort = _wtoi( ports[i].start_port );

            dPortRule._endPort = _wtoi( ports[i].end_port );

            if( ports[i].protocol == GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_BOTH ) )
            {
                dPortRule._trafficToHandle = MNLBPortRule::both;
            }
            else if( ports[i].protocol == GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_TCP ) )
            {
                dPortRule._trafficToHandle = MNLBPortRule::tcp;
            }
            else if( ports[i].protocol == GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_UDP ) )
            {
                dPortRule._trafficToHandle = MNLBPortRule::udp;
            }

            dPortRule._key = dPortRule._startPort;

            portD[ dPortRule._startPort ] = dPortRule;
        }
    }

    m_clusterData->portELB = portELB;
    m_clusterData->portULB = portULB;
    m_clusterData->portF =   portF;
    m_clusterData->portD =   portD;

    return CPropertyPage::OnKillActive();
}

BOOL
PortsPage::OnInitDialog()
{
    CPropertyPage::OnInitDialog();

    // the size of columns is equal 
    // to core.  Wish there were some defines somewhere.
    //
    m_portList.InsertColumn( 0, 
                             GETRESOURCEIDSTRING( IDS_HEADER_P_START ) , 
                             LVCFMT_LEFT, 
                             43 );
    m_portList.InsertColumn( 1, 
                             GETRESOURCEIDSTRING( IDS_HEADER_P_END ), 
                             LVCFMT_LEFT, 
                             43 );
    m_portList.InsertColumn( 2, 
                             GETRESOURCEIDSTRING( IDS_HEADER_P_PROTOCOL ),
                             LVCFMT_LEFT, 
                             51 );
    m_portList.InsertColumn( 3, 
                             GETRESOURCEIDSTRING( IDS_HEADER_P_MODE ),
                             LVCFMT_LEFT, 
                             53 );
    m_portList.InsertColumn( 4, 
                             GETRESOURCEIDSTRING( IDS_HEADER_P_PRIORITY ),
                             LVCFMT_LEFT, 
                             45 );

    // load is bigger than core size of 39, because we could be saying "unequal"
    m_portList.InsertColumn( 5, 
                             GETRESOURCEIDSTRING( IDS_HEADER_P_LOAD ),
                             LVCFMT_LEFT, 
                             53 );
    m_portList.InsertColumn( 6, 
                             GETRESOURCEIDSTRING( IDS_HEADER_P_AFFINITY ),
                             LVCFMT_LEFT, 
                             47 );

    m_portList.SetExtendedStyle( m_portList.GetExtendedStyle() | LVS_EX_FULLROWSELECT );

    SetControlData();

    int numItems = m_portList.GetItemCount();

    if( numItems > 0 )
    {
        buttonModify.EnableWindow( TRUE );
        
        buttonDel.EnableWindow( TRUE );
        
        if( numItems >= CVY_MAX_USABLE_RULES )
        {
            // greater should not happen, 
            // but just to be sure.
            
            buttonAdd.EnableWindow( FALSE );
        }            
        else
        {
            buttonAdd.EnableWindow( TRUE );
        }

        // make selection the first item in list.
        //
        m_portList.SetItemState( 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED );
    }
    else
    {
        buttonAdd.EnableWindow( TRUE );
        
        // disable the edit and remove buttons.
        buttonModify.EnableWindow( FALSE );
            
        buttonDel.EnableWindow( FALSE );
    }

    return TRUE;
}

void
PortsPage::SetControlData()
{
    int index = 0;
    map< long, PortDataELB>::iterator topELB;
    for( topELB = m_clusterData->portELB.begin();
         topELB != m_clusterData->portELB.end();
         ++topELB )
    {

        wchar_t buf[Common::BUF_SIZE];

        // start port
        swprintf( buf, L"%d", (*topELB).second._startPort );
        LVITEM item;
        item.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
        item.iItem = index;
        item.iSubItem = 0;
        item.iImage = 2;
        item.pszText = buf;
        item.lParam = (*topELB).second._startPort;
        item.cchTextMax = Common::BUF_SIZE;
        m_portList.InsertItem( &item );

        // end port
        swprintf( buf, L"%d", (*topELB).second._endPort );
        item.mask = LVIF_TEXT;
        item.iItem = index;
        item.iSubItem = 1;	 
        item.pszText = buf;
        item.cchTextMax = Common::BUF_SIZE;
        m_portList.SetItem( &item );

        // protocol
        item.mask = LVIF_TEXT; 
        item.iItem = index;
        item.iSubItem = 2;	 
        switch( (*topELB).second._trafficToHandle )
        {
            case MNLBPortRule::both :
                item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_BOTH );
                break;

            case MNLBPortRule::tcp :
                item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_TCP );
                break;

            case MNLBPortRule::udp :
                item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_UDP );
                break;
        }
        item.cchTextMax = Common::BUF_SIZE;
        m_portList.SetItem( &item );

        // mode 
        item.mask = LVIF_TEXT; 
        item.iItem = index;
        item.iSubItem = 3;	 
        item.pszText = GETRESOURCEIDSTRING(IDS_REPORT_MODE_MULTIPLE );
        item.cchTextMax = Common::BUF_SIZE;
        m_portList.SetItem( &item );
                
        // priority
        item.mask = LVIF_TEXT; 
        item.iItem = index;
        item.iSubItem = 4;	 
        item.pszText = GETRESOURCEIDSTRING(IDS_REPORT_EMPTY );
        item.cchTextMax = Common::BUF_SIZE;
        m_portList.SetItem( &item );

        // load
        item.mask = LVIF_TEXT; 
        item.iItem = index;
        item.iSubItem = 5;	 
        item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_LOAD_EQUAL );
        item.cchTextMax = Common::BUF_SIZE;
        m_portList.SetItem( &item );

        // affinity
        item.mask = LVIF_TEXT; 
        item.iItem = index;
        item.iSubItem = 6;	 
        switch( (*topELB).second._affinity )
        {
            case MNLBPortRule::none :
                item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_AFFINITY_NONE );
                break;

            case MNLBPortRule::single :
                item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_AFFINITY_SINGLE );
                break;

            case MNLBPortRule::classC :
                item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_AFFINITY_CLASSC );
                break;
        }
        item.cchTextMax = Common::BUF_SIZE;
        m_portList.SetItem( &item );

        ++index;
    }

    index = 0;
    map< long, PortDataULB>::iterator topULB;
    for( topULB = m_clusterData->portULB.begin();
         topULB != m_clusterData->portULB.end();
         ++topULB )
    {

        wchar_t buf[Common::BUF_SIZE];

        // start port
        swprintf( buf, L"%d", (*topULB).second._startPort );
        LVITEM item;
        item.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
        item.iItem = index;
        item.iSubItem = 0;
        item.iImage = 2;
        item.lParam = (*topULB).second._startPort;
        item.pszText = buf;
        item.cchTextMax = Common::BUF_SIZE;
        m_portList.InsertItem( &item );

        // end port
        swprintf( buf, L"%d", (*topULB).second._endPort );
        item.mask = LVIF_TEXT;
        item.iItem = index;
        item.iSubItem = 1;	 
        item.pszText = buf;
        item.cchTextMax = Common::BUF_SIZE;
        m_portList.SetItem( &item );

        // protocol
        item.mask = LVIF_TEXT; 
        item.iItem = index;
        item.iSubItem = 2;	 
        switch( (*topULB).second._trafficToHandle )
        {
            case MNLBPortRule::both :
                item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_BOTH );
                break;

            case MNLBPortRule::tcp :
                item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_TCP );
                break;

            case MNLBPortRule::udp :
                item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_UDP );
                break;
        }
        item.cchTextMax = Common::BUF_SIZE;
        m_portList.SetItem( &item );

        // mode 
        item.mask = LVIF_TEXT; 
        item.iItem = index;
        item.iSubItem = 3;	 
        item.pszText = GETRESOURCEIDSTRING(IDS_REPORT_MODE_MULTIPLE );
        item.cchTextMax = Common::BUF_SIZE;
        m_portList.SetItem( &item );
                
        // priority
        item.mask = LVIF_TEXT; 
        item.iItem = index;
        item.iSubItem = 4;	 
        item.pszText = GETRESOURCEIDSTRING(IDS_REPORT_EMPTY );
        item.cchTextMax = Common::BUF_SIZE;
        m_portList.SetItem( &item );

        // load
        item.mask = LVIF_TEXT; 
        item.iItem = index;
        item.iSubItem = 5;	 
        if( m_isClusterLevel == true )
        {
            item.pszText = GETRESOURCEIDSTRING(IDS_REPORT_LOAD_UNEQUAL );
        }
        else
        {
            swprintf( buf, L"%d", (*topULB).second.machineMapToLoadWeight[machine] );            
            item.pszText = buf;
        }
        item.cchTextMax = Common::BUF_SIZE;
        m_portList.SetItem( &item );

        // affinity
        item.mask = LVIF_TEXT; 
        item.iItem = index;
        item.iSubItem = 6;	 
        switch( (*topULB).second._affinity )
        {
            case MNLBPortRule::none :
                item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_AFFINITY_NONE );
                break;

            case MNLBPortRule::single :
                item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_AFFINITY_SINGLE );
                break;

            case MNLBPortRule::classC :
                item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_AFFINITY_CLASSC );
                break;
        }
        item.cchTextMax = Common::BUF_SIZE;
        m_portList.SetItem( &item );

        ++index;
    }

    index = 0;
    map< long, PortDataF>::iterator topF;
    for( topF = m_clusterData->portF.begin();
         topF != m_clusterData->portF.end();
         ++topF )
    {

        wchar_t buf[Common::BUF_SIZE];

        // start port
        swprintf( buf, L"%d", (*topF).second._startPort );
        LVITEM item;
        item.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
        item.iItem = index;
        item.iSubItem = 0;
        item.iImage = 2;
        item.lParam = (*topF).second._startPort;
        item.pszText = buf;
        item.cchTextMax = Common::BUF_SIZE;
        m_portList.InsertItem( &item );

        // end port
        swprintf( buf, L"%d", (*topF).second._endPort );
        item.mask = LVIF_TEXT;
        item.iItem = index;
        item.iSubItem = 1;	 
        item.pszText = buf;
        item.cchTextMax = Common::BUF_SIZE;
        m_portList.SetItem( &item );

        // protocol
        item.mask = LVIF_TEXT; 
        item.iItem = index;
        item.iSubItem = 2;	 
        switch( (*topF).second._trafficToHandle )
        {
            case MNLBPortRule::both :
                item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_BOTH );
                break;

            case MNLBPortRule::tcp :
                item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_TCP );
                break;

            case MNLBPortRule::udp :
                item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_UDP );
                break;
        }
        item.cchTextMax = Common::BUF_SIZE;
        m_portList.SetItem( &item );

        // mode 
        item.mask = LVIF_TEXT; 
        item.iItem = index;
        item.iSubItem = 3;	 
        item.pszText = GETRESOURCEIDSTRING(IDS_REPORT_MODE_SINGLE );
        item.cchTextMax = Common::BUF_SIZE;
        m_portList.SetItem( &item );
                
        // priority
        item.mask = LVIF_TEXT; 
        item.iItem = index;
        item.iSubItem = 4;	 
        if( m_isClusterLevel )
        {
            item.pszText = GETRESOURCEIDSTRING(IDS_REPORT_NA );
        }
        else
        {
            swprintf( buf, L"%d", (*topF).second.machineMapToPriority[machine] );
            item.pszText = buf;
        }            

        item.cchTextMax = Common::BUF_SIZE;
        m_portList.SetItem( &item );

        // load
        item.mask = LVIF_TEXT; 
        item.iItem = index;
        item.iSubItem = 5;	 
        item.pszText = GETRESOURCEIDSTRING(IDS_REPORT_EMPTY );
        item.cchTextMax = Common::BUF_SIZE;
        m_portList.SetItem( &item );

        // affinity
        item.mask = LVIF_TEXT; 
        item.iItem = index;
        item.iSubItem = 6;	
        item.pszText = GETRESOURCEIDSTRING(IDS_REPORT_EMPTY );
        item.cchTextMax = Common::BUF_SIZE;
        m_portList.SetItem( &item );

        ++index;
    }

    index = 0;
    map< long, PortDataD>::iterator topD;
    for( topD = m_clusterData->portD.begin();
         topD != m_clusterData->portD.end();
         ++topD )
    {

        wchar_t buf[Common::BUF_SIZE];

        // start port
        swprintf( buf, L"%d", (*topD).second._startPort );
        LVITEM item;
        item.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
        item.iItem = index;
        item.iSubItem = 0;
        item.iImage = 2;
        item.lParam = (*topD).second._startPort;
        item.pszText = buf;
        item.cchTextMax = Common::BUF_SIZE;
        m_portList.InsertItem( &item );

        // end port
        swprintf( buf, L"%d", (*topD).second._endPort );
        item.mask = LVIF_TEXT;
        item.iItem = index;
        item.iSubItem = 1;	 
        item.pszText = buf;
        item.cchTextMax = Common::BUF_SIZE;
        m_portList.SetItem( &item );

        // protocol
        item.mask = LVIF_TEXT; 
        item.iItem = index;
        item.iSubItem = 2;	 
        switch( (*topD).second._trafficToHandle )
        {
            case MNLBPortRule::both :
                item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_BOTH );
                break;

            case MNLBPortRule::tcp :
                item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_TCP );
                break;

            case MNLBPortRule::udp :
                item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_PROTOCOL_UDP );
                break;
        }
        item.cchTextMax = Common::BUF_SIZE;
        m_portList.SetItem( &item );

        // mode 
        item.mask = LVIF_TEXT; 
        item.iItem = index;
        item.iSubItem = 3;	 
        item.pszText = GETRESOURCEIDSTRING(IDS_REPORT_MODE_DISABLED );
        item.cchTextMax = Common::BUF_SIZE;
        m_portList.SetItem( &item );
                
        // priority
        item.mask = LVIF_TEXT; 
        item.iItem = index;
        item.iSubItem = 4;	 
        item.pszText = GETRESOURCEIDSTRING(IDS_REPORT_EMPTY );
        item.cchTextMax = Common::BUF_SIZE;
        m_portList.SetItem( &item );

        // load
        item.mask = LVIF_TEXT; 
        item.iItem = index;
        item.iSubItem = 5;	 
        item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_EMPTY );
        item.cchTextMax = Common::BUF_SIZE;
        m_portList.SetItem( &item );

        // affinity
        item.mask = LVIF_TEXT; 
        item.iItem = index;
        item.iSubItem = 6;	 
        item.pszText = GETRESOURCEIDSTRING( IDS_REPORT_EMPTY );
        item.cchTextMax = Common::BUF_SIZE;
        m_portList.SetItem( &item );

        ++index;
    }
}

void
PortsPage::OnButtonAdd()
{
    PortData portData;
    
    ClusterPortsDlg clusterPortRuleDialog( portData, this );
  
    int rc = clusterPortRuleDialog.DoModal();
    if( rc != IDOK )
    {
        return;
    }
    else
    {
        // add this port rule.
        int index = 0;

        // start port
        LVITEM item;
        item.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
        item.iItem = index;
        item.iSubItem = 0;
        item.iImage = 2;
        item.lParam = -1;
        item.pszText = portData.start_port;
        item.cchTextMax = Common::BUF_SIZE;
        m_portList.InsertItem( &item );

        // end port
        item.mask = LVIF_TEXT;
        item.iItem = index;
        item.iSubItem = 1;	 
        item.pszText = portData.end_port;
        item.cchTextMax = Common::BUF_SIZE;
        m_portList.SetItem( &item );

        // protocol
        item.mask = LVIF_TEXT; 
        item.iItem = index;
        item.iSubItem = 2;	 
        item.pszText = portData.protocol;
        item.cchTextMax = Common::BUF_SIZE;
        m_portList.SetItem( &item );

        // mode
        item.mask = LVIF_TEXT; 
        item.iItem = index;
        item.iSubItem = 3;	 
        item.pszText = portData.mode;
        item.cchTextMax = Common::BUF_SIZE;
        m_portList.SetItem( &item );

        // priority
        item.mask = LVIF_TEXT; 
        item.iItem = index;
        item.iSubItem = 4;	 
        item.pszText = portData.priority;
        item.cchTextMax = Common::BUF_SIZE;
        m_portList.SetItem( &item );

        // load
        item.mask = LVIF_TEXT; 
        item.iItem = index;
        item.iSubItem = 5;	 
        item.pszText = portData.load;
        item.cchTextMax = Common::BUF_SIZE;
        m_portList.SetItem( &item );

        // affinity
        item.mask = LVIF_TEXT; 
        item.iItem = index;
        item.iSubItem = 6;	 
        item.pszText = portData.affinity;
        item.cchTextMax = Common::BUF_SIZE;
        m_portList.SetItem( &item );

        // check if max port limit reached.
        if( m_portList.GetItemCount() >= CVY_MAX_USABLE_RULES )
        {
            // as max port rule limit reached.
            // disable further additions.
            buttonAdd.EnableWindow( FALSE );

            buttonDel.EnableWindow( TRUE );

            buttonModify.EnableWindow( TRUE );                

            buttonDel.SetFocus();
        }
        else
        {
            buttonAdd.EnableWindow( TRUE );
            buttonDel.EnableWindow( TRUE );
            buttonModify.EnableWindow( TRUE );                
        }

        // set focus to this item
        m_portList.SetItemState( index, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED );
    }
}

void
PortsPage::OnButtonDel()
{
    // get the current selection.
    POSITION pos = m_portList.GetFirstSelectedItemPosition();
    if( pos == NULL )
    {
        return;
    }

    int index = m_portList.GetNextSelectedItem( pos );

    // delete it.
    m_portList.DeleteItem( index );

    // if this was the last port rule.
    if( m_portList.GetItemCount() == 0 )
    {
        // as no more port rules in list
        // disable modify and remove buttons.
        // also set focus to add button

        buttonAdd.EnableWindow( TRUE );

        buttonModify.EnableWindow( FALSE );

        buttonDel.EnableWindow( FALSE );
        
        buttonAdd.SetFocus();
    }
    else
    {
        // enable the add, modify button.
        buttonAdd.EnableWindow( TRUE );

        buttonModify.EnableWindow( TRUE );

        buttonDel.EnableWindow( TRUE );

        // make selection the first item in list.
        //
        m_portList.SetItemState( 0, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED );

    }
}


void
PortsPage::OnButtonModify()
{
    // get the current selection.
    POSITION pos = m_portList.GetFirstSelectedItemPosition();
    if( pos == NULL )
    {
        return;
    }

    int index = m_portList.GetNextSelectedItem( pos );

    PortData portData;
    
    wchar_t buffer[Common::BUF_SIZE];
    m_portList.GetItemText( index, 0, buffer, Common::BUF_SIZE );
    portData.start_port = buffer;

    m_portList.GetItemText( index, 1, buffer, Common::BUF_SIZE );
    portData.end_port = buffer;

    m_portList.GetItemText( index, 2, buffer, Common::BUF_SIZE );
    portData.protocol = buffer;

    m_portList.GetItemText( index, 3, buffer, Common::BUF_SIZE );
    portData.mode = buffer;

    m_portList.GetItemText( index, 4, buffer, Common::BUF_SIZE );
    portData.priority = buffer;

    m_portList.GetItemText( index, 5, buffer, Common::BUF_SIZE );
    portData.load = buffer;

    m_portList.GetItemText( index, 6, buffer, Common::BUF_SIZE );
    portData.affinity = buffer;

    ClusterPortsDlg clusterPortRuleDialog( portData, this, index );

    HostPortsDlg hostPortRuleDialog( portData, this );

    int rc;
    if( m_isClusterLevel == true )
    {
        rc = clusterPortRuleDialog.DoModal();        
    }
    else
    {
        rc = hostPortRuleDialog.DoModal();        
    }
        
    if( rc != IDOK )
    {
        return;
    }
    else
    {
        // delete the old item and add the new item.
        // before you delete the old item find its param 
        // value
        DWORD key = m_portList.GetItemData( index );
        m_portList.DeleteItem( index );

        // as this is being modified the 
        // key remains the old one.

        // start port
        LVITEM item;
        item.mask = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
        item.iItem = index;
        item.iSubItem = 0;
        item.iImage = 2;
        item.lParam = key;
        item.pszText = portData.start_port;
        item.cchTextMax = Common::BUF_SIZE;
        m_portList.InsertItem( &item );

        // end port
        item.mask = LVIF_TEXT;
        item.iItem = index;
        item.iSubItem = 1;	 
        item.pszText = portData.end_port;
        item.cchTextMax = Common::BUF_SIZE;
        m_portList.SetItem( &item );

        // protocol
        item.mask = LVIF_TEXT; 
        item.iItem = index;
        item.iSubItem = 2;	 
        item.pszText = portData.protocol;
        item.cchTextMax = Common::BUF_SIZE;
        m_portList.SetItem( &item );

        // mode
        item.mask = LVIF_TEXT; 
        item.iItem = index;
        item.iSubItem = 3;	 
        item.pszText = portData.mode;
        item.cchTextMax = Common::BUF_SIZE;
        m_portList.SetItem( &item );

        // priority
        item.mask = LVIF_TEXT; 
        item.iItem = index;
        item.iSubItem = 4;	 
        item.pszText = portData.priority;
        item.cchTextMax = Common::BUF_SIZE;
        m_portList.SetItem( &item );

        // load
        item.mask = LVIF_TEXT; 
        item.iItem = index;
        item.iSubItem = 5;	 
        item.pszText = portData.load;
        item.cchTextMax = Common::BUF_SIZE;
        m_portList.SetItem( &item );

        // affinity
        item.mask = LVIF_TEXT; 
        item.iItem = index;
        item.iSubItem = 6;	 
        item.pszText = portData.affinity;
        item.cchTextMax = Common::BUF_SIZE;
        m_portList.SetItem( &item );

        // set focus to this item
        m_portList.SetItemState( index, LVIS_SELECTED | LVIS_FOCUSED, LVIS_SELECTED | LVIS_FOCUSED );
    }
}

void
PortsPage::OnDoubleClick( NMHDR * pNotifyStruct, LRESULT * result )
{
    if( buttonModify.IsWindowEnabled() == TRUE )
    {
        OnButtonModify();
    }
}

void
PortsPage::OnSelchanged( NMHDR * pNotifyStruct, LRESULT * result )
{
    // if it is not cluster level, which means host level.
    if( m_isClusterLevel == false )
    {
        // get the current selection.
        POSITION pos = m_portList.GetFirstSelectedItemPosition();
        if( pos == NULL )
        {
            return;
        }

        // disable the add, and delete buttons.
        // enable the modify button only if the
        // selection is an unequal load balanced
        // or single host port rule.

        buttonAdd.EnableWindow( FALSE );
        
        buttonDel.EnableWindow( FALSE );

        // initially disable modify button
        buttonModify.EnableWindow( FALSE );


        int index = m_portList.GetNextSelectedItem( pos );

        PortData portData;
    
        wchar_t buffer[Common::BUF_SIZE];

        m_portList.GetItemText( index, 3, buffer, Common::BUF_SIZE );
        portData.mode = buffer;
        if(  portData.mode == GETRESOURCEIDSTRING( IDS_REPORT_MODE_MULTIPLE ) )
        {
            m_portList.GetItemText( index, 5, buffer, Common::BUF_SIZE );
            portData.load = buffer;

            if( portData.load != GETRESOURCEIDSTRING( IDS_REPORT_LOAD_EQUAL ) )
            {
                buttonModify.EnableWindow( TRUE );
            }
        }
        else if(  portData.mode == GETRESOURCEIDSTRING( IDS_REPORT_MODE_SINGLE ) )
        {
            buttonModify.EnableWindow( TRUE );
        }
    }
}

BOOL
PortsPage::OnHelpInfo (HELPINFO* helpInfo )
{
    if( helpInfo->iContextType == HELPINFO_WINDOW )
    {
        ::WinHelp( static_cast<HWND> ( helpInfo->hItemHandle ), CVY_CTXT_HELP_FILE, HELP_WM_HELP, (ULONG_PTR ) g_aHelpIDs_IDD_DIALOG_PORTS);
    }

    return TRUE;
}

void
PortsPage::OnContextMenu( CWnd* pWnd, CPoint point )
{
    ::WinHelp( m_hWnd, CVY_CTXT_HELP_FILE, HELP_CONTEXTMENU, (ULONG_PTR ) g_aHelpIDs_IDD_DIALOG_PORTS);
}

void
PortsPage::OnColumnClick( NMHDR * pNotifyStruct, LRESULT * result )
{
    // get present port rules in list.
    vector<PortData> ports;
    getPresentPorts( &ports );

    LPNMLISTVIEW lv = ( LPNMLISTVIEW) pNotifyStruct;

    // sort these port rules depending upon the header which has
    // been clicked.

    switch( lv->iSubItem )
    {
        case 0 :
            // user has clicked start port.
            sort( ports.begin(), ports.end(), comp_start_port() );
            break;

        case 1:
            // user has clicked end port            
            sort( ports.begin(), ports.end(), comp_end_port() );

            break;

        case 2:
            // user has clicked protocol
            sort( ports.begin(), ports.end(), comp_protocol() );
            break;

        case 3:
            // user has clicked mode
            sort( ports.begin(), ports.end(), comp_mode() );
            break;

        case 4:
            // user has clicked priority
            if( m_isClusterLevel == true )
            {
                sort( ports.begin(), ports.end(), comp_priority_string() );
            }
            else
            {
                sort( ports.begin(), ports.end(), comp_priority_int() );
            }
            break;

        case 5:
            // user has clicked load
            if( m_isClusterLevel == true )
            {
                sort( ports.begin(), ports.end(), comp_load_string() );
            }
            else
            {
                sort( ports.begin(), ports.end(), comp_load_int() );
            }


            break;

        case 6:
            // user has clicked affinity
            sort( ports.begin(), ports.end(), comp_affinity() );
            break;

        default:
            break;
    }

    /* If we are sorting by the same column we were previously sorting by, 
       then we reverse the sort order. */
    if( m_sort_column == lv->iSubItem )
    {
        m_sort_ascending = !m_sort_ascending;
    }
    else
    {
        // default sort is ascending.
        m_sort_ascending = true;
    }
    
    m_sort_column = lv->iSubItem;

    int portIndex;
    int itemCount = m_portList.GetItemCount();
    for( int index = 0; index < itemCount; ++index )
    {
        if( m_sort_ascending == true )
        {
            portIndex = index;
        }
        else
        {
            portIndex = ( itemCount - 1 ) - index;
        }

        m_portList.SetItemData( index, ports[portIndex].key );
        m_portList.SetItemText( index, 0, ports[portIndex].start_port );
        m_portList.SetItemText( index, 1, ports[portIndex].end_port );
        m_portList.SetItemText( index, 2, ports[portIndex].protocol );
        m_portList.SetItemText( index, 3, ports[portIndex].mode );
        m_portList.SetItemText( index, 4, ports[portIndex].priority );
        m_portList.SetItemText( index, 5, ports[portIndex].load );        
        m_portList.SetItemText( index, 6, ports[portIndex].affinity );        
    }

    return;
}


void
PortsPage::getPresentPorts( vector<PortData>* ports )
{
    // get all the port rules presently in the list.
    for( int index = 0; index < m_portList.GetItemCount(); ++index )
    {
        PortData portData;
        wchar_t buffer[Common::BUF_SIZE];

        portData.key = m_portList.GetItemData( index );

        m_portList.GetItemText( index, 0, buffer, Common::BUF_SIZE );
        portData.start_port = buffer;
        
        m_portList.GetItemText( index, 1, buffer, Common::BUF_SIZE );
        portData.end_port = buffer;

        m_portList.GetItemText( index, 2, buffer, Common::BUF_SIZE );
        portData.protocol = buffer;
        
        m_portList.GetItemText( index, 3, buffer, Common::BUF_SIZE );
        portData.mode = buffer;
        
        m_portList.GetItemText( index, 4, buffer, Common::BUF_SIZE );
        portData.priority = buffer;
        
        m_portList.GetItemText( index, 5, buffer, Common::BUF_SIZE );
        portData.load = buffer;
        
        m_portList.GetItemText( index, 6, buffer, Common::BUF_SIZE );
        portData.affinity = buffer;

        ports->push_back( portData );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\exe\resourcestring.h ===
#ifndef RESOURCESTRING_H
#define RESOURCESTRING_H

#include "stdafx.h"

#include <map>

using namespace std;

// singleton class.
// used for reading resource strings.
//

class ResourceString
{

public:

    static
    ResourceString*
    Instance();

    static
    const _bstr_t&
    GetIDString( UINT id );

protected:
#if OBSOLETE
    ResourceString();
#endif // OBSOLETE

private:
    static map< UINT, _bstr_t> resourceStrings;

    static ResourceString* _instance;

};

// helper functions
const _bstr_t&
GETRESOURCEIDSTRING( UINT id );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\exe\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	nlbmanager1.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\exe\rightbottomview.cpp ===
#include "RightBottomView.h"
#include "resource.h"
#include "ResourceString.h"

IMPLEMENT_DYNCREATE( RightBottomView, CEditView )

RightBottomView::RightBottomView()
{
}

Document*
RightBottomView::GetDocument()
{
    return ( Document *) m_pDocument;
}

BOOL RightBottomView::PreCreateWindow( CREATESTRUCT& cs )
{
    return CEditView::PreCreateWindow( cs );
}

void 
RightBottomView::OnInitialUpdate()
{
#if 1
    // get present style.
    LONG presentStyle;
    
    presentStyle = GetWindowLong( m_hWnd, GWL_STYLE );

    // Set the last error to zero to avoid confusion.  
    // See sdk for SetWindowLong.
    SetLastError(0);

    // set new style.
    // this edit control has a caption and is readonly.
    SetWindowLong( m_hWnd,
                   GWL_STYLE,
//                   presentStyle | WS_CAPTION | ES_READONLY );
                   presentStyle | WS_CAPTION );

    // change caption
    _bstr_t title =  GETRESOURCEIDSTRING( IDS_BOTTOM_PANE_TITLE );
 
    SetWindowText( title );

#endif

    // we will register 
    // with the document class, 
    // as we are the status pane
    // and status is reported via us.

    GetDocument()->registerStatusPane( this );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\exe\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__4ABADA68_E961_4E94_80C9_36FC8222478E__INCLUDED_)
#define AFX_STDAFX_H__4ABADA68_E961_4E94_80C9_36FC8222478E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afx.h>
#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxcview.h>
#include <afxdisp.h>        // MFC Automation classes
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#include <comdef.h>
#include <wbemidl.h>

#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <iostream>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__4ABADA68_E961_4E94_80C9_36FC8222478E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\exe\righttopview.cpp ===
#include "RightTopView.h"
#include "PortsPage.h"

#include <vector>
#include <algorithm>

using namespace std;

IMPLEMENT_DYNCREATE( RightTopView, CListView )

BEGIN_MESSAGE_MAP( RightTopView, CListView )

   ON_NOTIFY(HDN_ITEMCLICK, 0, OnColumnClick) 

END_MESSAGE_MAP()

Document*
RightTopView::GetDocument()
{
    return ( Document *) m_pDocument;
}

void 
RightTopView::OnInitialUpdate()
{
    //
    // set images for this view.
    //
    GetListCtrl().SetImageList( GetDocument()->m_images48x48, 
                                LVSIL_SMALL );

    //
    // set the style, we only want report
    // view
    //

    // get present style.
    LONG presentStyle;
    
    presentStyle = GetWindowLong( m_hWnd, GWL_STYLE );

    // Set the last error to zero to avoid confusion.  
    // See sdk for SetWindowLong.
    SetLastError(0);

    // set new style.
    SetWindowLong( m_hWnd,
                   GWL_STYLE,
                   presentStyle | LVS_REPORT );


    //
    // we will register 
    // with the document class, 
    // as we are the list pane
    //
    GetDocument()->registerListPane( this );

    // initially nothing has been clicked.
    m_sort_column = -1;
}


void RightTopView::OnColumnClick(NMHDR* pNotifyStruct, LRESULT* pResult) 
{
    HTREEITEM hdlSelItem;    
    hdlSelItem = GetDocument()->getLeftPane().GetSelectedItem();

    TVITEM  selItem;
    selItem.hItem = hdlSelItem;
    selItem.mask = TVIF_IMAGE ;
    
    GetDocument()->getLeftPane().GetItem( &selItem );
		
    // We only handle column clicks for port rules.
    if( selItem.iImage != 2 )
    {
        return;
    }

    LPNMLISTVIEW lv = ( LPNMLISTVIEW) pNotifyStruct;
    vector<PortsPage::PortData> ports;
    int index;

    // get all the port rules presently in the list.
    for( index = 0; index < GetListCtrl().GetItemCount(); ++index )
    {
        PortsPage::PortData portData;
        wchar_t buffer[Common::BUF_SIZE];

        GetListCtrl().GetItemText( index, 0, buffer, Common::BUF_SIZE );
        portData.start_port = buffer;
        
        GetListCtrl().GetItemText( index, 1, buffer, Common::BUF_SIZE );
        portData.end_port = buffer;

        GetListCtrl().GetItemText( index, 2, buffer, Common::BUF_SIZE );
        portData.protocol = buffer;
        
        GetListCtrl().GetItemText( index, 3, buffer, Common::BUF_SIZE );
        portData.mode = buffer;
        
        GetListCtrl().GetItemText( index, 4, buffer, Common::BUF_SIZE );
        portData.priority = buffer;
        
        GetListCtrl().GetItemText( index, 5, buffer, Common::BUF_SIZE );
        portData.load = buffer;
        
        GetListCtrl().GetItemText( index, 6, buffer, Common::BUF_SIZE );
        portData.affinity = buffer;

        ports.push_back( portData );
    }


    // sort these port rules depending upon the header which has
    // been clicked.

    switch( lv->iItem )
    {
        case 0 :
            // user has clicked start port.
            sort( ports.begin(), ports.end(), comp_start_port() );
            break;

        case 1:
            // user has clicked end port            
            sort( ports.begin(), ports.end(), comp_end_port() );

            break;

        case 2:
            // user has clicked protocol
            sort( ports.begin(), ports.end(), comp_protocol() );
            break;

        case 3:
            // user has clicked mode
            sort( ports.begin(), ports.end(), comp_mode() );
            break;

        case 4:
            // user has clicked priority
            sort( ports.begin(), ports.end(), comp_priority_int() );
            break;

        case 5:
            // user has clicked load
            sort( ports.begin(), ports.end(), comp_load_int() );
            break;

        case 6:
            // user has clicked affinity
            sort( ports.begin(), ports.end(), comp_affinity() );
            break;

        default:
            break;
    }

    /* If we are sorting by the same column we were previously sorting by, 
       then we reverse the sort order. */
    if( m_sort_column == lv->iItem )
    {
        m_sort_ascending = !m_sort_ascending;
    }
    else
    {
        // default sort is ascending.
        m_sort_ascending = true;
    }
    
    m_sort_column = lv->iItem;

    int portIndex;
    int itemCount = GetListCtrl().GetItemCount();
    for( index = 0; index < itemCount; ++index )
    {
        if( m_sort_ascending == true )
        {
            portIndex = index;
        }
        else
        {
            portIndex = ( itemCount - 1 ) - index;
        }

        GetListCtrl().SetItemText( index, 0, ports[portIndex].start_port );
        GetListCtrl().SetItemText( index, 1, ports[portIndex].end_port );
        GetListCtrl().SetItemText( index, 2, ports[portIndex].protocol );
        GetListCtrl().SetItemText( index, 3, ports[portIndex].mode );
        GetListCtrl().SetItemText( index, 4, ports[portIndex].priority );
        GetListCtrl().SetItemText( index, 5, ports[portIndex].load );        
        GetListCtrl().SetItemText( index, 6, ports[portIndex].affinity );        
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\inetcfg\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	nlbmanager1.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\inetcfg\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__4ABADA68_E961_4E94_80C9_36FC8222478E__INCLUDED_)
#define AFX_STDAFX_H__4ABADA68_E961_4E94_80C9_36FC8222478E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afx.h>
#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxcview.h>
#include <afxdisp.h>        // MFC Automation classes
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#include <comdef.h>
#include <wbemidl.h>

#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <iostream>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__4ABADA68_E961_4E94_80C9_36FC8222478E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\exe\rightbottomview.h ===
#ifndef RIGHTBOTTOMVIEW_H
#define RIGHTBOTTOMVIEW_H

#include "stdafx.h"
#include "Document.h"

class RightBottomView : public CEditView
{
    DECLARE_DYNCREATE( RightBottomView )

public:
    virtual void OnInitialUpdate();

    BOOL PreCreateWindow( CREATESTRUCT& cs );

    RightBottomView();

protected:
    Document* GetDocument();

};    

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\exe\righttopview.h ===
#ifndef RIGHTTOPVIEW_H
#define RIGHTTOPVIEW_H

#include "stdafx.h"
#include "Document.h"

class RightTopView : public CListView
{
    DECLARE_DYNCREATE( RightTopView )

public:
    virtual void OnInitialUpdate();

protected:
    Document* GetDocument();

    afx_msg void OnColumnClick( NMHDR* pNMHDR, LRESULT* pResult );

private:
    bool m_sort_ascending;

    int m_sort_column;

    DECLARE_MESSAGE_MAP()
};    

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\inetcfg\niccard.cpp ===
// Copyright (c)  Microsoft.  All rights reserved.
//
// This is unpublished source code of Microsoft.
// The copyright notice above does not evidence any
// actual or intended publication of such source code.

// OneLiner  :  Implementation of NICCard
// DevUnit   :  wlbstest
// Author    :  Murtaza Hakim

// History:
// --------
// 
// Revised by : mhakim
// Date       : 02-16-01
// Reason     : Added code to find friendly name of nic.

// include files

#include "NICCard.h"

#include <iostream>
#include <devguid.h>
#include <cfg.h>
using namespace std;

// constructor
NICCard::NICCard( IdentifierType   type,
                  wstring           id )
        : 
        pnc( NULL ), 
        nameType( type ),
        nicName( id ),
        status( NICCard_SUCCESS )
{
    HRESULT hr;

    // initialize com.
    hr = CoInitializeEx(NULL,
                        COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED );
    if( !SUCCEEDED( hr ) )
    {
        // failure to initialize com
        cout << "CoInitializeEx failure " << endl;
//        status = COM_FAILURE;
//        return;
    }

    
    // get INetCfg com interface.
    hr = CoCreateInstance( CLSID_CNetCfg, 
                           NULL, 
                           CLSCTX_SERVER, 
                           IID_INetCfg, 
                           (void **) &pnc );
    if( !SUCCEEDED( hr ) )
    {
        // failure to create instance.
        cout << "CoCreateInstance  failure" << endl;
        status = COM_FAILURE;
        return;
    }

}



// destructor
NICCard::~NICCard()
{
    // release resources.

    HRESULT hr;

    if( pnc )
    {
        hr = pnc->Release();
        pnc = 0;
    }


    // uninitialize.
    CoUninitialize();
}


//+----------------------------------------------------------------------------
//
// Function:  NICCard::isBoundTo
//
// Description:  whether a component is bound to the adapter
//
// Arguments: wstring component - component id, e.g. "ms_wlbs"
//
// Returns:   NICCard::NICCard_Error - 
//
// History:   Murtaza intitial code
//            fengsun Created Header    12/21/00
//
//+----------------------------------------------------------------------------
NICCard::NICCard_Error 
NICCard::isBoundTo( wstring component )
{
    HRESULT hr;
    NICCard_Error err;

    INetCfgComponent          *pnccNic = NULL;

    INetCfgComponent          *pnccComponent = NULL;

    INetCfgComponentBindings *pnccb = NULL;


    // check creation status.
    // if not success something went wrong during construction
    // and this object cannot be used.
    //
    if( status != NICCard_SUCCESS )
    {
        err = status;
        goto cleanup;
    }

    // Initializes network configuration by loading into 
    // memory all basic networking information
    //
    hr = pnc->Initialize( NULL );
    if( !SUCCEEDED( hr ) )
    {
        // failure to Initialize
        cout << "INetCfg::Initialize failure " << endl;

        err = COM_FAILURE;
        goto cleanup;
    }

    // check if physical nic object of nameType, and nicName exists.
    //
    err = findNIC( nameType,
                   nicName,
                   &pnccNic );
    if( err != NICCard_SUCCESS )
    {
        // nic specified does not exist.
        wprintf(L"nic specified as %s does not exist\n", nicName.c_str() );

        // err value set by findNic
        goto cleanup;
    }


    if (FAILED(hr = pnc->FindComponent(component.c_str(), 
        &pnccComponent)))
    {
        // not protocol, service or client.  No such component exists.
        wprintf(L"component specified as %s does not exist\n", component.c_str() );

        err = NO_SUCH_COMPONENT;
        goto cleanup;
    }

    
    // check if binding exists.
    //

    hr = pnccComponent->QueryInterface( IID_INetCfgComponentBindings, (void **) &pnccb );
    if( !SUCCEEDED( hr ) )
    {
        cout << "INetCfgComponent::QueryInterface failed " << endl;

        err = COM_FAILURE;
        goto cleanup;
    }

    hr = pnccb->IsBoundTo( pnccNic );
    if( hr == S_OK )
    {
        err = BOUND;
    }
    else if( hr == S_FALSE )
    {
        err = UNBOUND;
    }
    else
    {
        err = COM_FAILURE;
    }

    goto cleanup;
    


    // free up com resources.
  cleanup:

    if( pnccb )
    {
        pnccb->Release();
        pnccb = 0;
    }

    if( pnccComponent )
    {
        pnccComponent->Release();
        pnccComponent = 0;
    }

    if( pnccNic )
    {
        pnccNic->Release();
        pnccNic = 0;
    }

    pnc->Uninitialize();

    return err;
    
}



//+----------------------------------------------------------------------------
//
// Function:  NICCard::bind
//
// Description:  bind a component to the adapter
//
// Arguments: wstring component - component id, e.g. "ms_wlbs"
//
// Returns:   NICCard::NICCard_Error - 
//
// History:   Murtaza intitial code
//            fengsun Created Header    12/21/00
//
//+----------------------------------------------------------------------------
NICCard::NICCard_Error
NICCard::bind( wstring component )
{ 
    NICCard_Error err;

    err = isBoundTo( component );
    if( err == UNBOUND )
    {
        return toggleState( component );
    }
    else if( err == BOUND )
    {
        return NICCard_SUCCESS;
    }
    else
    {
        return err;
    }
}



//+----------------------------------------------------------------------------
//
// Function:  NICCard::unbind
//
// Description:  unbind a component to the adapter
//
// Arguments: wstring component - component id, e.g. "ms_wlbs"
//
// Returns:   NICCard::NICCard_Error - 
//
// History:   Murtaza intitial code
//            fengsun Created Header    12/21/00
//
//+----------------------------------------------------------------------------
NICCard::NICCard_Error
NICCard::unbind( wstring component )
{
    NICCard_Error err;

    err = isBoundTo( component );
    if( err == BOUND )
    {
        return toggleState( component );
    }
    else if( err == UNBOUND )
    {
        return NICCard_SUCCESS;
    }
    else
    {
        return err;
    }
}

// private
// returns true if found, else false.
NICCard::NICCard_Error
NICCard::findNIC( IdentifierType type,
                  wstring    nicName,
                  INetCfgComponent** ppnccNic )
{
    HRESULT hr;
    IEnumNetCfgComponent* pencc;
    INetCfgComponent*     pncc;
    ULONG                 countToFetch = 1;
    ULONG                 countFetched;
    DWORD                 characteristics;
    wstring               name;
    LPWSTR                pName; 


    hr = pnc->EnumComponents( &GUID_DEVCLASS_NET,
                              &pencc );
    if( !SUCCEEDED( hr ) )
    {
        // failure to Enumerate net components
        cout << "INetCfg::EnumComponents failure " << endl;
        return COM_FAILURE;
    }

    while( ( hr = pencc->Next( countToFetch, &pncc, &countFetched ) )== S_OK )
    {
        // here we have been given guid.
        if( type == guid )
        {
            hr = pncc->GetBindName( &pName );
        }
        else 
        {
            hr = pncc->GetDisplayName( &pName );
        }
        name = pName;
        CoTaskMemFree( pName );
        
        if( name == nicName )
        {
            *ppnccNic = pncc;

            if( pencc )
            {
                pencc->Release();
                pencc = 0;
            }

            return NICCard_SUCCESS;
        }
        pncc->Release();
    }

    if( pencc )
    {
        pencc->Release();
        pencc = 0;
    }

    *ppnccNic = NULL;

    return NO_SUCH_NIC;
}


//+----------------------------------------------------------------------------
//
// Function:  NICCard::toggleState
//
// Description:  toggle a component binding state to the adapter
//
// Arguments: wstring component - component id, e.g. "ms_wlbs"
//
// Returns:   NICCard::NICCard_Error - 
//
// History:   Murtaza intitial code
//            fengsun Created Header    12/21/00
//
//+----------------------------------------------------------------------------
NICCard::NICCard_Error
NICCard::toggleState( wstring component )
{
    HRESULT                     hr;
    NICCard_Error               err;

    INetCfgComponent            *pnccNic = NULL;
    INetCfgComponent            *pnccComponent = NULL;

    INetCfgComponentBindings    *pnccb = NULL;

    INetCfgLock                 *pncl = NULL;

    LPWSTR                      presentLockHolder = new wchar_t[1000];

    // check creation status.
    // if not success something went wrong during construction
    // and this object cannot be used.
    //
    if( status != NICCard_SUCCESS )
    {
        err = status;

        goto cleanup;
    }

    // as this operation can make modifications we require a lock.
    // thus get lock.
    //
    hr = pnc->QueryInterface( IID_INetCfgLock, ( void **) &pncl );
    if( !SUCCEEDED( hr ) )
    {
        cout << "INetCfg QueryInterface for IID_INetCfgLock failed " << endl;

        err = COM_FAILURE;
        goto cleanup;
    }


    hr = pncl->AcquireWriteLock( TIME_TO_WAIT,
                                 L"NLBManager",
                                 &presentLockHolder );
    if( hr != S_OK )
    {
        cout << "INetCfgLock::AcquireWriteLock failure is " << hr << endl;

        err = COM_FAILURE;
        goto cleanup;
        
    }

    // Initializes network configuration by loading into 
    // memory all basic networking information
    //
    hr = pnc->Initialize( NULL );
    if( !SUCCEEDED( hr ) )
    {
        // failure to Initialize
        cout << "INetCfg::Initialize failed with " << hr << endl;
        
        err = COM_FAILURE;
        goto cleanup;
    }

    // check if physical nic object of nameType, and nicName exists.
    //
    err = findNIC( nameType,
                   nicName,
                   &pnccNic );
    if( err != NICCard_SUCCESS )
    {
        // nic specified does not exist.
        wprintf(L"nic specified as %s does not exist\n", nicName.c_str() );

        goto cleanup;
    }

    if (FAILED(hr = pnc->FindComponent(component.c_str(), 
        &pnccComponent)))
    {
        // not protocol, service or client.  No such component exists.
        wprintf(L"component specified as %s does not exist\n", component.c_str() );

        err = NO_SUCH_COMPONENT;
        goto cleanup;
    }
   
    // check if binding exists.
    //
    hr = pnccComponent->QueryInterface( IID_INetCfgComponentBindings, (void **) &pnccb );
    if( !SUCCEEDED( hr ) )
    {
        cout << "INetCfgComponent::QueryInterface failed " << endl;

        err = COM_FAILURE;
        goto cleanup;
    }

    hr = pnccb->IsBoundTo( pnccNic );
    if( hr == S_OK )
    {
        hr = pnccb->UnbindFrom( pnccNic );
        if( !SUCCEEDED( hr ) )
        {
            if( hr == NETCFG_E_NO_WRITE_LOCK )
                cout << "Unable to obtain write lock.  Please verify properties page not already open" << endl;
            else
                cout << "INetCfgBindings::UnbindFrom failed with " << hr << endl;

            err = COM_FAILURE;
        }
        else
        {
            // apply the binding change made.
            hr = pnc->Apply();
            if( !SUCCEEDED( hr ) )
            {
                cout << "INetCfg::Apply failed with " << hr << endl;

                err = COM_FAILURE;
            }
            else
            {
                err = NICCard_SUCCESS;
            }
        }
    }
    else if( hr == S_FALSE )
    {
        hr = pnccb->BindTo( pnccNic );
        if( !SUCCEEDED( hr ) )
        {
            if( hr == NETCFG_E_NO_WRITE_LOCK )
                cout << "Unable to obtain write lock.  Please verify properties page not already open" << endl;
            else
                cout << "INetCfgBindings::BindTo failed with " << hr << endl;

            err = COM_FAILURE;
        }
        else
        {

            // apply the binding change made.
            hr = pnc->Apply();
            if( !SUCCEEDED( hr ) )
            {
                cout << "INetCfg::Apply failed with " << hr << endl;
                err = COM_FAILURE;
            }
            else
            {
                err = NICCard_SUCCESS;
            }
        }
    }
    else
    {
        cout << "INetCfgComponentBindings::IsBoundTo failed with " << hr << endl;        
        err = COM_FAILURE;
    }

    goto cleanup;
    

    // free up com resources.
  cleanup:

    if( pnccb )
    {
        pnccb->Release();
        pnccb = 0;
    }

    if( pnccComponent )
    {
        pnccComponent->Release();
        pnccComponent = 0;
    }

    if( pnccNic )
    {
        pnccNic->Release();
        pnccNic = 0;
    }

    if( pnc )
        pnc->Uninitialize();

    if( pncl )
    {
        pncl->ReleaseWriteLock();
        pncl->Release();
        pncl = 0;
    }

    delete [] presentLockHolder;

    return err;
}


// getNics
//
NICCard::NICCard_Error
NICCard::getNics( vector<NICCard::Info>*   nicList )
{
    HRESULT                hr;
    
    INetCfg                *pncStatic = 0;
    IEnumNetCfgComponent   *pencc = 0;
    INetCfgComponent       *pncc = 0;
   
    wstring                name;
    LPWSTR                 pName; 

    NICCard_Error          err;

    ULONG                  countToFetch = 1;
    ULONG                  countFetched;
    ULONG                  status;

    Info info;

    DWORD                  characteristics = 0;

    // initialize com.
    hr = CoInitializeEx(NULL,
                        COINIT_DISABLE_OLE1DDE | COINIT_APARTMENTTHREADED );
    if( !SUCCEEDED( hr ) )
    {
        // failure to initialize com
        cout << "CoInitializeEx failure " << endl;
//        err = COM_FAILURE;
//        goto cleanup;
    }

    
    // get INetCfg com interface.
    hr = CoCreateInstance( CLSID_CNetCfg, 
                           NULL, 
                           CLSCTX_SERVER, 
                           IID_INetCfg, 
                           (void **) &pncStatic );
    if( !SUCCEEDED( hr ) )
    {
        // failure to create instance.
        cout << "CoCreateInstance  failure" << endl;
        err = COM_FAILURE;
        goto cleanup;
    }

    // Initializes network configuration by loading into 
    // memory all basic networking information
    //
    hr = pncStatic->Initialize( NULL );
    if( !SUCCEEDED( hr ) )
    {
        // failure to Initialize
        cout << "INetCfg::Initialize failure " << endl;
        err = COM_FAILURE;
        goto cleanup;
    }

    hr = pncStatic->EnumComponents( &GUID_DEVCLASS_NET,
                                    &pencc );
    if( !SUCCEEDED( hr ) )
    {
        // failure to Enumerate net components
        cout << "INetCfg::EnumComponents failure " << endl;
        err = COM_FAILURE;
        goto cleanup;
    }

    while( ( hr = pencc->Next( countToFetch, &pncc, &countFetched ) )== S_OK )
    {
        hr = pncc->GetBindName( &pName );
        if( !SUCCEEDED( hr ) )
        {
            cout << "INetCfgComponent::GetBindName failure " << endl;
            err = COM_FAILURE;
            goto cleanup;
        }

        info.guid = pName;
        CoTaskMemFree( pName );

        hr = pncc->GetDisplayName( &pName );
        if( !SUCCEEDED( hr ) )
        {
            cout << "INetCfgComponent::GetDisplayName failure " << endl;
            err = COM_FAILURE;
            goto cleanup;
        }

        info.fullName = pName;
        CoTaskMemFree( pName );

        hr = pncc->GetCharacteristics( &characteristics );
        if( !SUCCEEDED( hr ) )
        {
            cout << "INetCfgComponent::GetCharacteristics failure " << endl;
            err = COM_FAILURE;
            goto cleanup;
        }

        GetFriendlyNICName( info.guid, info.friendlyName );

        if( characteristics & NCF_PHYSICAL )
        {
            // this is a physical network card.
            // we are only interested in such devices

            // check if the nic is enabled, we are only
            // interested in enabled nics.
            //
            hr = pncc->GetDeviceStatus( &status );
            if( !SUCCEEDED( hr ) )
            {
                cout << "INetCfgComponent::GetDeviceStatus failure " << endl;
                err = COM_FAILURE;
                goto cleanup;
            }

            // if any of the nics has any of the problem codes
            // then it cannot be used.
            if( status != CM_PROB_NOT_CONFIGURED
                &&
                status != CM_PROB_FAILED_START
                &&
                status != CM_PROB_NORMAL_CONFLICT
                &&
                status != CM_PROB_NEED_RESTART
                &&
                status != CM_PROB_REINSTALL
                &&
                status != CM_PROB_WILL_BE_REMOVED
                &&
                status != CM_PROB_DISABLED
                &&
                status != CM_PROB_FAILED_INSTALL
                &&
                status != CM_PROB_FAILED_ADD
                )
            {
                // no problem with this nic and also 
                // physical device 
                // thus we want it.

                nicList->push_back( info );
            }
        }

        if( pncc )
        {
            pncc->Release();
            pncc = 0;
        }

        characteristics = 0;
        countToFetch = 1;
    }
    
    err = NICCard_SUCCESS;
    
  cleanup:
    if( pncStatic )
    {
        pncStatic->Uninitialize();

        pncStatic->Release();
        pncStatic = 0;
    }

    if( pencc )
    {
        pencc->Release();
        pencc = 0;
    }

    if( pncc )
    {
        pncc->Release();
        pncc = 0;
    }

    return err;
}

    
NICCard::NICCard_Error
NICCard::isNetCfgAvailable()
{
    NICCard_Error err;
    HRESULT       hr;
    INetCfgLock                 *pncl = NULL;
    LPWSTR                      presentLockHolder = new wchar_t[1000];
 
   hr = pnc->QueryInterface( IID_INetCfgLock, ( void **) &pncl );
    if( !SUCCEEDED( hr ) )
    {
        cout << "INetCfg QueryInterface for IID_INetCfgLock failed " << endl;

        err = COM_FAILURE;
        goto cleanup;
    }
    
    hr = pncl->AcquireWriteLock( TIME_TO_WAIT,
                                 L"NLBManager",
                                 &presentLockHolder );
    if( hr != S_OK )
    {
        cout << "INetCfgLock::AcquireWriteLock failure is " << hr << endl;

        err = COM_FAILURE;
        goto cleanup;
        
    }

    err = NICCard_SUCCESS;

  cleanup:
    if( pncl )
    {
        pncl->ReleaseWriteLock();
        pncl->Release();
        pncl = 0;
    }
    delete [] presentLockHolder;

    return err;
}    

// code to find friendly name of nic.
// this code is modified for wstring, but
// otherwise is courtesy of hengz.
//
int 
NICCard::GetFriendlyNICName(const wstring& guid, wstring& name )
{
// HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Network

    HKEY hregkey=NULL, hkOpenKey=NULL, hkQueryKey=NULL;
    DWORD dwDataBuffer=200;
    DWORD dwValueType=REG_SZ;
    wchar_t data[200], path[200], adapters[200];
    wchar_t *pHost=NULL;
    int num=0, ret;
    FILETIME time;

    //make connection to the machine's registry
    if ((ret=RegConnectRegistry(pHost, HKEY_LOCAL_MACHINE, &hregkey)) != ERROR_SUCCESS) {
//        TRACE( MTrace::SEVERE_ERROR, L"(RegConnectRegistry) failure" );
        return (-1);
    }

    //look for the GUID

    if( (ret=RegOpenKeyEx(hregkey, L"SYSTEM\\CurrentControlSet\\Control\\Network", 0, KEY_READ, &hkOpenKey)) != ERROR_SUCCESS ) {
        RegCloseKey(hregkey);
//        TRACE( MTrace::SEVERE_ERROR, L"(RegOpenKeyEx) failed to open HKLM\\SYSTEM\\CurrentControlSet\\Control\\Network" );
        return (-1);
    }

    while (1) {
        adapters[0]=L'\0';
        dwDataBuffer=200;
        if( ((ret=RegEnumKeyEx(hkOpenKey, num, adapters, &dwDataBuffer, NULL,NULL,NULL, &time)) != ERROR_SUCCESS) 
            && (ret!=ERROR_MORE_DATA) ) 
        {
            if (ret==ERROR_NO_MORE_ITEMS)
            {
//                TRACE(MTrace::SEVERE_ERROR,L"(RegEnumKeyEx): failed to find network adapters in HKLM\\SYSTEM\\CurrentControlSet\\Control\\Network");
            }
            else 
            {
//                TRACE(MTrace::SEVERE_ERROR,L"(RegEnumKeyEx): fail to enum HKLM\\SYSTEM\\CurrentControlSet\\Control\\Network" ); 
            }

            RegCloseKey(hkOpenKey);
            RegCloseKey(hregkey);
            return (-1);
        }

        //open the items one by one
        swprintf(path, L"SYSTEM\\CurrentControlSet\\Control\\Network\\%s", adapters);
        if( (ret=RegOpenKeyEx(hregkey, path, 0, KEY_READ, &hkQueryKey)) != ERROR_SUCCESS ) {
            num++;	
            continue;
        }

        dwDataBuffer=200;
        data[0]=L'\0';
        if((ret=RegQueryValueEx(hkQueryKey, L"", 0, &dwValueType, (LPBYTE)data, &dwDataBuffer)) != ERROR_SUCCESS) {
            num++;	
            continue;
        }
        RegCloseKey(hkQueryKey);
        num++;		

        if (wcscmp(L"Network Adapters", data)==0)
            break;
    }
    RegCloseKey(hkOpenKey);

    //found the guid now
    //look for friendly nic name

    swprintf(path, L"SYSTEM\\CurrentControlSet\\Control\\Network\\%s\\%s\\Connection", adapters, guid.c_str() );
    if( (ret=RegOpenKeyEx(hregkey, path, 0, KEY_READ, &hkOpenKey)) != ERROR_SUCCESS ) {
        RegCloseKey(hregkey);
//        TRACE(MTrace::SEVERE_ERROR, L"(RegOpenKeyEx) fail to open " + wstring( path ) );
        return (-1);
    }

    dwDataBuffer=200;
    data[0]=L'\0';
    if((ret=RegQueryValueEx(hkOpenKey, L"Name", 0, &dwValueType, (LPBYTE)data, &dwDataBuffer)) != ERROR_SUCCESS) {
//        TRACE(MTrace::SEVERE_ERROR, L"(RegQueryValueEx) fail to query name " + wstring (path ) );

        RegCloseKey(hkOpenKey);
        RegCloseKey(hregkey);
        return (-1);
    }

    RegCloseKey(hkOpenKey);
    RegCloseKey(hregkey);

    name = data;

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\nlbsprov\mnicinfo.cpp ===
// Copyright (c)  Microsoft.  All rights reserved.
//
// This is unpublished source code of Microsoft.
// The copyright notice above does not evidence any
// actual or intended publication of such source code.

// OneLiner  :  Implementation of MNicInfo
// DevUnit   :  wlbstest
// Author    :  Murtaza Hakim

// include files
#include "MNicInfo.h"
#include "MWmiParameter.h"
#include "MWmiInstance.h"
#include "MWmiObject.h"
#include "Mtrace.h"

MNicInfo::MNicInfo_Error
MNicInfo::getNicInfo( _bstr_t            machineIP,
                      vector<MNicInfo::Info>*   nicList )
{
    MWmiObject  machine( machineIP,
                         L"root\\cimv2",
                         L"Administrator",
                         L"" );

    return getNicInfo_private( &machine, nicList );
}


MNicInfo::MNicInfo_Error
MNicInfo::getNicInfo( vector<MNicInfo::Info>*   nicList )
{
    MWmiObject  machine( L"root\\cimv2" );

    return getNicInfo_private( &machine, nicList );
}

MNicInfo::MNicInfo_Error
MNicInfo::getNicInfo_private( MWmiObject* p_machine,
                              vector<MNicInfo::Info>*   nicList )
{
    vector< MWmiInstance > instanceStore;

    MWmiObject::MWmiObject_Error errO;
    errO = p_machine->getInstances( L"Win32_NetworkAdapterConfiguration",
                                    &instanceStore );
    if( errO != MWmiObject::MWmiObject_SUCCESS )
    {
        TRACE( MTrace::SEVERE_ERROR, "MIPAddressAdmin::checkStatus failure\n");
        return COM_FAILURE;
    }


    // set parameters to get.
    vector<MWmiParameter* >   parameterStore;
    MWmiInstance::MWmiInstance_Error errI;

    MWmiParameter Caption(L"Caption");
    parameterStore.push_back( &Caption );

    MWmiParameter SettingID(L"SettingID");
    parameterStore.push_back( &SettingID );

    Info info;
    for( int i = 0; i < instanceStore.size(); ++i )
    {
        errI = instanceStore[i].getParameters( parameterStore );
        info.nicFullName = _bstr_t( (wchar_t *)_bstr_t( Caption.getValue())  + 11 );
        info.guid  = SettingID.getValue();
        nicList->push_back( info );
    }

    return MNicInfo_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\nlbsprov\mnicinfo.h ===
#ifndef _MNICINFO_H
#define _MNICINFO_H
//
// Copyright (c) Microsoft.  All Rights Reserved 
//
// THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF Microsoft.
// The copyright notice above does not evidence any
// actual or intended publication of such source code.
//
// OneLiner : MNicInfo_H interface.
// DevUnit  : wlbstest
// Author   : Murtaza Hakim
//
// Description: 
// -----------


// Include Files
#include <comdef.h>
#include <vector>
#include "MWmiObject.h"

using namespace std;

class MNicInfo
{
public:

    enum MNicInfo_Error
    {
        MNicInfo_SUCCESS = 0,
        COM_FAILURE  = 1,

        INVALID_IP = 2,
    };

    class Info
    {
    public:
        _bstr_t nicFullName;
        _bstr_t guid;
    };

    // gets the full names and guids of all nics on a specific machine.
    // this is remote call.
    //
    static
    MNicInfo_Error
    getNicInfo( _bstr_t                   machineIP,
                vector<MNicInfo::Info>*   nicList );

    // this is for local call.
    static
    MNicInfo_Error
    getNicInfo( vector<MNicInfo::Info>*   nicList );

private:
    static
    MNicInfo_Error
    getNicInfo_private( MWmiObject* p_machine,
                        vector<MNicInfo::Info>*   nicList );                        

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\nlbsprov\common.h ===
#ifndef _COMMON_H
#define _COMMON_H
//
// Copyright (c) Microsoft.  All Rights Reserved 
//
// THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF Microsoft.
// The copyright notice above does not evidence any
// actual or intended publication of such source code.
//
// OneLiner : common include file.
// DevUnit  : wlbstest
// Author   : Murtaza Hakim
//
// Description: 
// -----------

// History:
// --------
// 
//
// Revised by : mhakim
// Date       : 02-12-01
// Reason     : added password to clusterproperties.

#include <vector>

#include <wbemidl.h>
#include <comdef.h>

using namespace std;

#if 0
enum WLBS_STATUS
{
    WLBS_OK                  = 1000,
    WLBS_ALREADY             = 1001,
    WLBS_DRAIN_STOP          = 1002,
    WLBS_BAD_PARAMS          = 1003,
    WLBS_NOT_FOUND           = 1004,
    WLBS_STOPPED             = 1005,
    WLBS_CONVERGING          = 1006,
    WLBS_CONVERGED           = 1007,
    WLBS_DEFAULT             = 1008,
    WLBS_DRAINING            = 1009,
    WLBS_SUSPENDED           = 1013,
    WLBS_REBOOT              = 1050,
    WLBS_INIT_ERROR          = 1100,
    WLBS_BAD_PASSW           = 1101,
    WLBS_IO_ERROR            = 1102,
    WLBS_TIMEOUT             = 1103,
    WLBS_PORT_OVERLAP        = 1150,
    WLBS_BAD_PORT_PARAMS     = 1151,
    WLBS_MAX_PORT_RULES      = 1152,
    WLBS_TRUNCATED           = 1153,
    WLBS_REG_ERROR           = 1154,
};
#endif

struct NicInfo
{
    // default constructor
    NicInfo();
    
    // Equality operator
    bool
    operator==( const NicInfo& objToCompare );

    // inequality operator
    bool
    operator!=( const NicInfo& objToCompare );

    _bstr_t fullNicName;
    _bstr_t adapterGuid;
    _bstr_t friendlyName;

    bool    dhcpEnabled;

    vector<_bstr_t> ipsOnNic;
    vector<_bstr_t> subnetMasks;

};


struct ClusterProperties
{
    // default constructor
    ClusterProperties();
    
    // Equality operator
    bool
    operator==( const ClusterProperties& objToCompare );

    // inequality operator
    bool
    operator!=( const ClusterProperties& objToCompare );

    bool HaveClusterPropertiesChanged( const ClusterProperties& objToCompare, 
                                       bool *pbOnlyClusterNameChanged,
                                       bool *pbClusterIpChanged);

    _bstr_t cIP;                            // Primary IP address.

    _bstr_t cSubnetMask;                    // Subnet mask.

    _bstr_t cFullInternetName;              // Full Internet name.

    _bstr_t cNetworkAddress;                // Network address.

    bool   multicastSupportEnabled;         // Multicast support.

    bool   remoteControlEnabled;            // Remote control.

    // Edited (mhakim 12-02-01)
    // password may be required to be set.
    // but note that it cannot be got from an existing cluster.

    _bstr_t password;                       // Remote control password.

// for whistler

    bool   igmpSupportEnabled;              // igmp support 

    bool  clusterIPToMulticastIP;           // indicates whether to use cluster ip or user provided ip.

    _bstr_t multicastIPAddress;             // user provided multicast ip.

    long   igmpJoinInterval;                // user provided multicast ip.
};

struct HostProperties
{
    // default constructor
    HostProperties();
    
    // Equality operator
    bool
    operator==( const HostProperties& objToCompare );

    // inequality operator
    bool
    operator!=( const HostProperties& objToCompare );

    _bstr_t hIP;                           // Dedicated IP Address.
    _bstr_t hSubnetMask;                   // Subnet mask.
        
    long    hID;                           // Priority(Unique host ID).

    bool   initialClusterStateActive;      // Initial Cluster State.

    DWORD  hostStatus;                     // status of host.

    NicInfo nicInfo;                       // info about nic to which nlb bound.

    _bstr_t machineName;                   // machine name.
};

class Common
{
public:
    enum
    {
        BUF_SIZE = 1000,
        ALL_PORTS = 0xffffffff,
        ALL_HOSTS = 100,
        THIS_HOST = 0,
    };

    //WLBS_STATUS
    static
    DWORD
    getHostsInCluster( _bstr_t clusterIP, vector< HostProperties >* hostPropertiesStore );

    static
    void
    getWLBSErrorString( DWORD     errStatus,       // IN
                        _bstr_t&  errString,       // OUT
                        _bstr_t&  extErrString     // OUT
                        );

    static
    DWORD
    getNLBNicInfoForWin2k(  const _bstr_t& machineInfo, NicInfo& nicInfo );

    static
    DWORD
    getNLBNicInfoForWhistler( const _bstr_t& machineInfo, const _bstr_t& guid, NicInfo& nicInfo );

    static
    _bstr_t
    mapNicToClusterIP( const _bstr_t& machineIP,
                       const _bstr_t& fullNICName );

};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\nlbsprov\hostserverproto.h ===
#ifndef _HOSTSERVERPROTO_HH
#define _HOSTSERVERPROTO_HH
//
#include <string>
#include <wbemidl.h>
#include <comdef.h>
#include <string>

using namespace std;


//
#define HOST_PORT  "6000"       // port used by host to listen for requests.


enum _DEFINES
{
    MAX_NIC_NAME = 500,   // maximum size of nic name allowed.
    MAX_IP_SIZE  = 20,
};




enum COMMANDS
{
    BIND_NLBS,
    UNBIND_NLBS,
    ISBOUND_NLBS,
    QUIT,
};

enum RetCode
{
    R_BOUND               = 0,
    R_UNBOUND             = 1,
    R_NO_SUCH_NIC         = 2,
    R_NO_NLBS             = 3,
    R_COM_FAILURE         = 10,
};


// 
struct Command
{
    COMMANDS value;
};

struct NicInfo
{
    wchar_t fullName[ MAX_NIC_NAME ];
};


struct IPInfo
{
    wchar_t ip[ MAX_IP_SIZE];
};



//
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\nlbsprov\mnlbcluster.cpp ===
// Copyright (c)  Microsoft.  All rights reserved.
//
// This is unpublished source code of Microsoft.
// The copyright notice above does not evidence any
// actual or intended publication of such source code.

// OneLiner  :  Implementation of MNLBCluster
// DevUnit   :  wlbstest
// Author    :  Murtaza Hakim

// include files
#include "MNLBCluster.h"
#include "MWmiParameter.h"
#include "MTrace.h"
#include "WTokens.h"
#include "wlbsctrl.h"
#include "Common.h"
#include "MNLBExe.h"

#include <iostream>


using namespace std;

// constructor
//
MNLBCluster::MNLBCluster( _bstr_t cip )
        :
        m_clusterIP( cip ),
        m_pMachine( new MNLBMachine( cip, cip ) )
{
    TRACE(MTrace::INFO, L"mnlbcluster constructor\n" );
}

// default constructor
//
// note that default constructor is purposely left undefined.  
// NO one should be using it.  It is declared just for vector class usage.


// copy constructor
//
MNLBCluster::MNLBCluster( const MNLBCluster& mcluster )
        : 
        m_clusterIP( mcluster.m_clusterIP ),
        m_pMachine( m_pMachine )
{
    TRACE(MTrace::INFO, L"mnlbcluster copy constructor\n" );
}



// assignment operator
//
MNLBCluster&
MNLBCluster::operator=( const MNLBCluster& rhs )
{
    m_clusterIP = rhs.m_clusterIP;
    
    m_pMachine   = rhs.m_pMachine;

    TRACE(MTrace::INFO, L"mnlbcluster assignment operator\n" );

    return *this;
}
    
    
// destructor
//
MNLBCluster::~MNLBCluster()
{
    TRACE(MTrace::INFO, L"mlbcluster destructor\n" );
}


    
// getClusterProperties
//
MNLBCluster::MNLBCluster_Error
MNLBCluster::getClusterProperties( ClusterProperties* cp )
{

    m_pMachine->getClusterProperties( cp );

    return MNLBCluster_SUCCESS;

}        

// getHosts
//
MNLBCluster::MNLBCluster_Error
MNLBCluster::getHosts( vector<MNLBHost>* hosts )
{
    vector< MNLBMachine::HostInfo > hostInfoStore;

    m_pMachine->getPresentHostsInfo( &hostInfoStore );
    
    for( int i = 0; i < hostInfoStore.size(); ++i )
    {
        hosts->push_back( MNLBHost( m_clusterIP,
                                    hostInfoStore[i].hostID ) );
    }

    return MNLBCluster_SUCCESS;
}


// start
//
MNLBCluster::MNLBCluster_Error
MNLBCluster::start( unsigned long* retVal )
{
    m_pMachine->start( Common::ALL_HOSTS, retVal );

    return MNLBCluster_SUCCESS;
}



// stop
//
MNLBCluster::MNLBCluster_Error
MNLBCluster::stop( unsigned long* retVal )
{
    m_pMachine->stop( Common::ALL_HOSTS, retVal );

    return MNLBCluster_SUCCESS;
}



// resume
//
MNLBCluster::MNLBCluster_Error
MNLBCluster::resume( unsigned long* retVal )
{
    m_pMachine->resume( Common::ALL_HOSTS, retVal );
    return MNLBCluster_SUCCESS;
}


// suspend
//
MNLBCluster::MNLBCluster_Error
MNLBCluster::suspend( unsigned long* retVal )
{
    m_pMachine->suspend( Common::ALL_HOSTS, retVal );

    return MNLBCluster_SUCCESS;
}


// drainstop
//
MNLBCluster::MNLBCluster_Error
MNLBCluster::drainstop( unsigned long* retVal )
{
    m_pMachine->drainstop( Common::ALL_HOSTS, retVal );

    return MNLBCluster_SUCCESS;
}



// enable
//
MNLBCluster::MNLBCluster_Error
MNLBCluster::enable( unsigned long* retVal, unsigned long portToAffect )
{
    m_pMachine->enable( Common::ALL_HOSTS, retVal, portToAffect );

    return MNLBCluster_SUCCESS;
}


// disable
//
MNLBCluster::MNLBCluster_Error
MNLBCluster::disable( unsigned long* retVal, unsigned long portToAffect )
{
    m_pMachine->disable( Common::ALL_HOSTS, retVal, portToAffect );

    return MNLBCluster_SUCCESS;
}





// drain
//
MNLBCluster::MNLBCluster_Error
MNLBCluster::drain( unsigned long* retVal, unsigned long portToAffect )
{
    m_pMachine->drain( Common::ALL_HOSTS, retVal, portToAffect );

    return MNLBCluster_SUCCESS;
}


// refreshConnection
//
MNLBCluster::MNLBCluster_Error
MNLBCluster::refreshConnection()
{
    // reestablishing connection.
    //
    m_pMachine = 
        auto_ptr<MNLBMachine> (new MNLBMachine( m_clusterIP, m_clusterIP ) );

    return MNLBCluster_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\nlbsprov\mnlbcluster.h ===
#ifndef _MNLBCLUSTER_H
#define _MNLBCLUSTER_H
//
// Copyright (c) Microsoft.  All Rights Reserved 
//
// THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF Microsoft.
// The copyright notice above does not evidence any
// actual or intended publication of such source code.
//
// OneLiner : MNLBCluster interface.
// DevUnit  : wlbstest
// Author   : Murtaza Hakim
//
// Description: 
// -----------


// Include Files
#include "MNLBHost.h"
#include "Common.h"
#include "MNLBMachine.h"


#include <vector>
#include <memory>
#include <string>
#include <wbemidl.h>
#include <comdef.h>

using namespace std;

//
class MNLBCluster
{
public:

    enum MNLBCluster_Error
    {
        MNLBCluster_SUCCESS       = 0,

        COM_FAILURE            = 1,
        CONNECT_FAILED         = 2,
        NO_CLUSTER             = 3,
        UNCONSTRUCTED          = 4,
    };
    
    //

    //
    // Description:
    // -----------
    // constructor.
    // 
    // Parameters:
    // ----------
    // cip                      IN      : cluster ip address.
    // 
    // Returns:
    // -------
    // none.
    
    MNLBCluster( _bstr_t    cip );


    //
    // Description:
    // -----------
    // default constructor.
    // 
    // Parameters:
    // ----------
    // none.
    // 
    // Returns:
    // -------

    MNLBCluster();

    //
    // Description:
    // -----------
    // copy constructor.
    // 
    // Parameters:
    // ----------
    // mcluster             IN  :  object to copy.
    // 
    // Returns:
    // -------
    // none.

    MNLBCluster(const MNLBCluster& mcluster);

    //
    // Description:
    // -----------
    // assignment operator
    // 
    // Parameters:
    // ----------
    // rhs             IN   : object to assign.
    // 
    // Returns:
    // -------
    // self

    MNLBCluster&
    operator=( const MNLBCluster& rhs );


    //
    // Description:
    // -----------
    // destructor
    // 
    // Parameters:
    // ----------
    // none
    // 
    // Returns:
    // -------
    // none.

    ~MNLBCluster();


    //
    // Description:
    // -----------
    // refreshes the wmi connection to the host
    // 
    // Parameters:
    // ----------
    // none
    // 
    // Returns:
    // -------
    // SUCCESS else error code.
    MNLBCluster_Error
    refreshConnection();

    //
    // Description:
    // -----------
    // gets the cluster properties.
    // 
    // Parameters:
    // ----------
    // cp                       OUT      : cluster properties.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBCluster_Error
    getClusterProperties( ClusterProperties* cp );

    //
    // Description:
    // -----------
    // get the hosts participating in the cluster.
    // 
    // Parameters:
    // ----------
    // hosts           OUT    : hosts who are members of the cluster.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBCluster_Error
    getHosts( vector<MNLBHost>* hosts );

    // operations defined on cluster.

    //
    // Description:
    // -----------
    // starts cluster operations.
    // 
    // Parameters:
    // ----------
    // retVal            OUT   : return value of method ran.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBCluster_Error
    start( unsigned long* retVal );


    //
    // Description:
    // -----------
    // stops cluster operations.
    // 
    // Parameters:
    // ----------
    // retVal            OUT   : return value of method ran.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBCluster_Error
    stop( unsigned long* retVal );

    //
    // Description:
    // -----------
    // resume control over cluster operations.
    // 
    // Parameters:
    // ----------
    // retVal            OUT   : return value of method ran.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBCluster_Error
    resume( unsigned long* retVal );

    //
    // Description:
    // -----------
    // suspend control over cluster operations.
    // 
    // Parameters:
    // ----------
    // retVal            OUT   : return value of method ran.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBCluster_Error
    suspend( unsigned long* retVal );

    //
    // Description:
    // -----------
    // finishes all existing connections and
    // stops cluster operations.
    // 
    // Parameters:
    // ----------
    // retVal            OUT   : return value of method ran.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBCluster_Error
    drainstop( unsigned long* retVal );


    //
    // Description:
    // -----------
    // enables traffic for port rule.
    // 
    // Parameters:
    // ----------
    // retVal            OUT   : return value of method ran.
    // port              IN    : port to affect or default is all ports.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBCluster_Error
    enable( unsigned long* retVal, unsigned long port = Common::ALL_PORTS );

    //
    // Description:
    // -----------
    // disables ALL traffic for port rule.
    // 
    // Parameters:
    // ----------
    // retVal            OUT   : return value of method ran.
    // port              IN    : port to affect or default is all ports.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBCluster_Error
    disable( unsigned long* retVal, unsigned long port = Common::ALL_PORTS );

    //
    // Description:
    // -----------
    // disables NEW traffic for port rule.
    // 
    // Parameters:
    // ----------
    // retVal            OUT   : return value of method ran.
    // port              IN    : port to affect or default is all ports.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBCluster_Error
    drain( unsigned long* retVal, unsigned long port = Common::ALL_PORTS );

private:

    _bstr_t                        m_clusterIP;

    auto_ptr< MNLBMachine >        m_pMachine;

};



//
// Ensure type safety

typedef class MNLBCluster MNLBCluster;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\inetcfg\niccard.h ===
#ifndef _NICCARD_H
#define _NICCARD_H
//
// Copyright (c) Microsoft.  All Rights Reserved 
//
// THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF Microsoft.
// The copyright notice above does not evidence any
// actual or intended publication of such source code.
//
// OneLiner : NICCard interface.
// DevUnit  : wlbstest
// Author   : Murtaza Hakim
//
// History:
// --------
// 
// Revised by : mhakim
// Date       : 02-16-01
// Reason     : Added code to find friendly name of nic.

// Description: 
// -----------


// Include Files

#include <string>

#include <netcfgx.h>
#include <netcfgn.h>

#include <vector>

using namespace std;


class NICCard
{
public:

    enum NICCard_Error
    {
        NICCard_SUCCESS  = 0,
        COM_FAILURE      = 1,
        BOUND            = 4,
        UNBOUND          = 5,
        NO_SUCH_NIC      = 6,
        NO_SUCH_COMPONENT= 7,
    };

    enum IdentifierType
    {
        macAddress = 1,    // use mac address
        guid       = 2,    // use guid
        fullName   = 3,    // use descriptive name
    };


    class Info
    {
    public:
        wstring fullName;    // nic full name.
        wstring guid;           // nic guid.

        // Edited (mhakim 02-16-01)  nic friendly name support.
        wstring friendlyName;   // nic friendly name.
    };



    //
    // Description:
    // -----------
    // constructor.
    // 
    // Parameters:
    // ----------
    // type                     IN      : identifies what type it is whether guid, descriptive name, mac address.
    // id                       IN      : wstring representation of guid, descriptive name, mac address.
    // 
    // Returns:
    // -------
    // none.
    
    NICCard( IdentifierType type,
             wstring         id);



    //
    // Description:
    // -----------
    // destructor.
    // 
    // Parameters:
    // ----------
    // none
    // 
    // Returns:
    // -------
    // none.
    
    ~NICCard();


    //
    // Description:
    // -----------
    // Checks if the nic card is bound to the service, or protocol.
    // 
    // Parameters:
    // ----------
    // component    IN     : the component( protocol or service )  to check.
    // 
    // Returns:
    // -------
    // BOUND if bound, UNBOUND if not bound else error code.

    NICCard_Error    
    isBoundTo( wstring component );



    //
    // Description:
    // -----------
    // Binds the nic card to the service, or protocol. 
    // 
    // Parameters:
    // ----------
    // component    IN     : the component( protocol or service )  to bind.
    // 
    // Returns:
    // -------
    // 0 : success else error code.


    NICCard_Error
    bind( wstring component );


    //
    // Description:
    // -----------
    // unbinds the nic card from the service, or protocol. 
    // 
    // Parameters:
    // ----------
    // component    IN     : the component( protocol or service )  to unbind.
    // 
    // Returns:
    // -------
    // 0 : success else error code.


    NICCard_Error
    unbind( wstring component );


    //
    // Description:
    // -----------
    // checks if the netcfg lock is available.
    // 
    // Parameters:
    // ----------
    // none
    // 
    // Returns:
    // -------
    // 0 : success else error code.

    NICCard_Error
    isNetCfgAvailable();

    //
    // Description:
    // -----------
    // finds all nics on the machine.
    // 
    // Parameters:
    // ----------
    // nicList    IN     : vector container to store all nics found.
    // 
    // Returns:
    // -------
    // 0 : success else error code.


    static
    NICCard_Error
    getNics( vector<NICCard::Info>*   nicList );

private:

    enum
    {
        TIME_TO_WAIT = 5,
    };

    INetCfgComponent *pnccNic;

    INetCfg          *pnc;

    IdentifierType   nameType;

    wstring          nicName;

    NICCard_Error    status;

    
    NICCard::NICCard_Error
    findNIC( IdentifierType type,
             wstring    nicName,
             INetCfgComponent** ppnccNic );

    NICCard::NICCard_Error
    toggleState( wstring component );

    static
    int
    GetFriendlyNICName(const wstring& guid, wstring& name );
};



//
// Ensure type safety

typedef class NICCard  NICCard;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\nlbsprov\common.cpp ===
#include "Common.h"

#include "MWmiInstance.h"
#include "MWmiObject.h"

#include "MTrace.h"

#include "wlbsctrl.h"

#include "MIPAddressAdmin.h"

#include "WTokens.h"

#include <winsock2.h>
#include <vector>
#include <memory>

using namespace std;
// History:
// --------
// 
//
// Revised by : mhakim
// Date       : 02-12-01
// Reason     : remote control was checked by default, changed to unchecked.

int
WlbsAddressToString( DWORD address, wchar_t* buf, PDWORD len );


//WLBS_STATUS
DWORD
Common::getHostsInCluster( _bstr_t clusterIP, vector< HostProperties >* hostPropertiesStore )
{
    return WLBS_BAD_PARAMS;

    DWORD retValue;
    DWORD cluster;
    WLBS_RESPONSE response[ WLBS_MAX_HOSTS ];
    DWORD num_host = WLBS_MAX_HOSTS;
    DWORD host_map;
    wchar_t buf[ Common::BUF_SIZE];
    BOOL retBOOL;
    int i;
    DWORD len;
    HostProperties hp;
    char *char_buf;

    // do init call
//    retValue = WlbsInit (L"wlbs", WLBS_API_VER, NULL);

    // convert clusterIP into DWORD representation.
    cluster = inet_addr( clusterIP );
    if( cluster == INADDR_NONE )
    {
        TRACE( MTrace::SEVERE_ERROR, "cluster ip is invalid\n" );
        return WLBS_BAD_PARAMS;
    }

    // do wlbs query.
//    retValue = WlbsQuery( cluster, WLBS_ALL_HOSTS, response, &num_host, &host_map, NULL);
    if( retValue == WLBS_TIMEOUT )
    {
        return retValue;
    }

     // fill in the vector container.
    for( i = 0; i < num_host; ++i )
    {
        // get dip
        len = Common::BUF_SIZE;

        char_buf = inet_ntoa( *( ( struct in_addr *) &(response[i].address)));
        if( char_buf == NULL )
        {
            TRACE( MTrace::SEVERE_ERROR, "invalid ip address obtained\n");
            continue;
        }

        CharToWChar( char_buf, 
                     strlen( char_buf ) + 1,
                     buf,
                     Common::BUF_SIZE );
                     
        hp.hIP = buf;

        // get host id.
        hp.hID = response[i].id;

        // get host status
        hp.hostStatus = response[i].status;

        hostPropertiesStore->push_back( hp );
    }

    return retValue;
}


void
Common::getWLBSErrorString( DWORD     errStatus,      // IN
                            _bstr_t&  errString,       // OUT
                            _bstr_t&  extErrString    // OUT
                            )
{
    switch( errStatus )
    {

        case 1000 : 
            errString    = L"WLBS_OK";
            extErrString = L"WLBS_OK The operation completed successfully. \n";
            break;

        case 1001 :
            errString    = L"WLBS_ALREADY";
            extErrString = L"WLBS_ALREADY The specified target is already in the state that the requested operation would produce. \n";
            break;

        case 1002 : 
            errString    = L"WLBS_DRAIN_STOP";
            extErrString = L"WLBS_DRAIN_STOP One or more nodes reported a drain stop operation. \n";
            break;

        case 1003 : 
            errString    = L"WLBS_BAD_PARAMS";
            extErrString = L"WLBS_BAD_PARAMS Bad configuration parameters in a node's registry prevented the node from starting cluster operations. \n" ;
            break;

        case 1004 : 
            errString    = L"WLBS_NOT_FOUND";
            extErrString = L"WLBS_NOT_FOUND The specified port number was not found in any port rule.. \n";
            break;

        case 1005 : 
            errString    = L"WLBS_STOPPED";
            extErrString = L"WLBS_STOPPED Cluster operations have stopped on at least one node. \n"; 
            break;


        case 1006 : 
            errString    = L"WLBS_CONVERGING";
            extErrString = L"WLBS_CONVERGING The cluster is converging. \n";
            break;

        case 1007 : 
            errString    = L"WLBS_CONVERGED";
            extErrString = L"WLBS_CONVERGED The cluster has converged successfully. \n";
            break;

        case 1008 : 
            errString    = L"WLBS_DEFAULT";
            extErrString = L"WLBS_DEFAULT The specified node has converged as the default host.  \n"; 
            break;

        case 1009 : 
            errString    = L"WLBS_DRAINING";
            extErrString = L"WLBS_DRAINING One or more nodes are draining. \n"; 
            break;

        case 1013 :
            errString    = L"WLBS_SUSPENDED";
            extErrString = L"WLBS_SUSPENDED Cluster operations have been suspended on one or more nodes.  \n" ;
            break;

        case 1050 : 
            errString    = L"WLBS_REBOOT";
            extErrString = L"WLBS_REBOOT The node must be rebooted for the specified configuration changes to take effect.  \n" ;
            break;

        case 1100 : 
            errString    = L"WLBS_INIT_ERROR";
            extErrString = L"WLBS_INIT_ERROR An internal error prevented initialization of the cluster control module.  \n" ;
            break;

        case 1101 : 
            errString    = L"WLBS_BAD_PASSW";
            extErrString = L"WLBS_BAD_PASSW The specified password was not accepted by the cluster.  \n"; 
            break;

        case 1102: 
            errString    = L"WLBS_IO_ERROR";
            extErrString = L"WLBS_IO_ERROR A local I/O error prevents communication with the Network Load Balancing driver.  \n " ;
            break;
            
        case 1103 : 
            errString    = L"WLBS_TIMEOUT";
            extErrString = L"WLBS_TIMEOUT The requested operation timed out without receiving a response from the specified node.  \n";
            break;

        case 1150 : 
            errString    = L"WLBS_PORT_OVERLAP";
            extErrString = L"WLBS_PORT_OVERLAP At least one of the port numbers in the specified port rule is currently listed in at least one other port rule. \n";
            break;

        case 1151 : 
            errString    = L"WLBS_BAD_PORT_PARAMS";
            extErrString = L"WLBS_BAD_PORT_PARAMS The settings for one or more port rules contain one or more invalid values. \n";
            break;

        case 1152 : 
            errString    = L"WLBS_MAX_PORT_RULES";
            extErrString = L"WLBS_MAX_PORT_RULES The cluster contains the maximum number of port rules. \n";
            break;

        case 1153 : 
            errString    = L"WLBS_TRUNCATED";
            extErrString = L"WLBS_TRUNCATED The return value has been truncated. \n";
            break;

        case 1154 : 
            errString    = L"WLBS_REG_ERROR";
            extErrString = L"WLBS_REG_ERROR An internal registry access error occurred. ";
            break;

        default :
            errString    = L"WLBS_UNKNOWN";
            extErrString = L"unknown error.  Contact zubaira head of wlbs project.\n"; 
    }
}


DWORD
Common::getNLBNicInfoForWin2k( const _bstr_t& machineIP, NicInfo& nicInfo )
{
    MWmiObject machine( machineIP, 
                        L"root\\microsoftnlb",
                        L"Administrator", 
                        L"" );

    vector<MWmiInstance> instanceStore;

    machine.getInstances( L"NlbsNic",
                          &instanceStore );

    // input parameters are none.
    //
    vector<MWmiParameter *> inputParameters;

    //  output parameters which are of interest.
    //
    vector<MWmiParameter *> outputParameters;
    MWmiParameter    ReturnValue(L"ReturnValue");
    outputParameters.push_back( &ReturnValue );

    for( int i = 0; i < instanceStore.size(); ++i )
    {
        instanceStore[i].runMethod( L"isBound",
                                    inputParameters, 
                                    outputParameters );

        if( long( ReturnValue.getValue() ) == 1 )
        {

            // this is the nic we are looking for as 
            // for win2k there can only be one nic.
            vector<MWmiParameter *> parameterStore;

            MWmiParameter AdapterGuid(L"AdapterGuid");
            parameterStore.push_back( &AdapterGuid );

            MWmiParameter FullName(L"FullName");
            parameterStore.push_back( &FullName );

            MWmiParameter FriendlyName(L"FriendlyName");
            parameterStore.push_back( &FriendlyName );

            instanceStore[i].getParameters( parameterStore );

            nicInfo.fullNicName = FullName.getValue();
            nicInfo.adapterGuid = AdapterGuid.getValue();
            nicInfo.friendlyName = FriendlyName.getValue();

            // we also need to get all the ip addresses 
            // on this nic
            MIPAddressAdmin ipAdmin( machineIP, nicInfo.fullNicName );
            
            ipAdmin.getIPAddresses( &nicInfo.ipsOnNic,
                                    &nicInfo.subnetMasks );


            // check if this nic is dhcp or not.
            ipAdmin.isDHCPEnabled( nicInfo.dhcpEnabled );

            return 0;
        }
    }

    // this should not happen, as how come there is no nic
    // with nlbs bound.

    TRACE(MTrace::SEVERE_ERROR, L"not able to find nic on win2k\n");
    throw _com_error( WBEM_E_NOT_FOUND );  
}

    
DWORD
Common::getNLBNicInfoForWhistler( const _bstr_t& machineIP, const _bstr_t& guid, NicInfo& nicInfo )
{
    MWmiObject machine( machineIP, 
                        L"root\\microsoftnlb",
                        L"Administrator", 
                        L"" );

    vector<MWmiInstance> instanceStore;

    machine.getInstances( L"NlbsNic",
                          &instanceStore );

    // input parameters are none.
    //
    vector<MWmiParameter *> inputParameters;

    //  output parameters which are of interest.
    //
    vector<MWmiParameter *> outputParameters;
    MWmiParameter    ReturnValue(L"ReturnValue");
    outputParameters.push_back( &ReturnValue );

    vector<MWmiParameter *> parameterStore;
    MWmiParameter AdapterGuid(L"AdapterGuid");
    parameterStore.push_back( &AdapterGuid );

    MWmiParameter FullName(L"FullName");
    parameterStore.push_back( &FullName );

    MWmiParameter FriendlyName(L"FriendlyName");
    parameterStore.push_back( &FriendlyName );

    for( int i = 0; i < instanceStore.size(); ++i )
    {
        instanceStore[i].getParameters( parameterStore );
        if( _bstr_t( AdapterGuid.getValue()) == guid )
        {
            nicInfo.fullNicName = FullName.getValue();
            nicInfo.adapterGuid = AdapterGuid.getValue();
            nicInfo.friendlyName = FriendlyName.getValue();

            // we also need to get all the ip addresses 
            // on this nic
            MIPAddressAdmin ipAdmin( machineIP, nicInfo.fullNicName );
            
            ipAdmin.getIPAddresses( &nicInfo.ipsOnNic,
                                    &nicInfo.subnetMasks );

            return 0;
        }
    }

    // this should not happen, as how come there is no nic
    // with nlbs bound with guid specified.

    TRACE(MTrace::SEVERE_ERROR, L"not able to find nic with guid on whistler\n");
    throw _com_error( WBEM_E_NOT_FOUND );  
}    

_bstr_t
Common::mapNicToClusterIP( const _bstr_t& machineIP, 
                           const _bstr_t& fullNicName )
{
    //
    // ensure that nic is present, and bound to nlbs 
    // on nic specified.
    MWmiObject machine( machineIP,
                        L"root\\microsoftnlb",
                        L"administrator",
                        L"" );

    vector<MWmiInstance> instanceStore;
    _bstr_t relPath = L"NlbsNic.FullName=\"" + fullNicName + "\"";
    machine.getSpecificInstance( L"NlbsNic",
                                 relPath,
                                 &instanceStore );

    // input parameters are none.
    //
    vector<MWmiParameter *> inputParameters;

    //  output parameters which are of interest.
    //
    vector<MWmiParameter *> outputParameters;
    MWmiParameter    ReturnValue(L"ReturnValue");
    outputParameters.push_back( &ReturnValue );

    instanceStore[0].runMethod( L"IsBound",
                                inputParameters, 
                                outputParameters );
    if( long( ReturnValue.getValue() ) == 1 )
    {
        // it is bound so proceed.
    }
    else if( long( ReturnValue.getValue() ) == 0 )
    {
        TRACE( MTrace::SEVERE_ERROR, 
               L"Nic does not have nlb bound to it" );

        throw _com_error( WBEM_E_NOT_FOUND );
    }
    else
    {
        TRACE( MTrace::SEVERE_ERROR, 
               L"Not able to check if nlb is bound or not" );
        throw _com_error( WBEM_E_NOT_FOUND );
    }

    // get guid for this instance
    vector<MWmiParameter* >   parameterStore;

    MWmiParameter AdapterGuid(L"AdapterGuid");
    parameterStore.push_back( &AdapterGuid );
    
    instanceStore[0].getParameters( parameterStore );

    //
    // find clustersettingclass mapping to this nic.
    //

    // set parameters to get.
    //
    parameterStore.erase( parameterStore.begin(),
                          parameterStore.end() );

    MWmiParameter Name(L"Name");
    parameterStore.push_back( &Name );

    // get guid
    // This parameter not present on win2k nlbs provider.
    //
    MWmiParameter NLBAdapterGuid(L"AdapterGuid");
    parameterStore.push_back( &NLBAdapterGuid );

    // get instances of clustersetting class.    
    //
    instanceStore.erase( instanceStore.begin(),
                         instanceStore.end() );

    bool found = false;

    machine.getInstances( L"Microsoftnlb_ClusterSetting",
                          &instanceStore );
    found = false;
    for( int i = 0; i < instanceStore.size(); ++i )
    {
        try
        {
            instanceStore[i].getParameters( parameterStore );
        }
        catch( _com_error e )
        {
            // the above operation can fail on win2k machines.
            // if so we need to handle exception. This clustersetting is the actual one 
            // required.
            found = true;
            break;  // get out of for loop.
        }

        if( _bstr_t( NLBAdapterGuid.getValue()) == _bstr_t( AdapterGuid.getValue() ) )
        {
            // right object found
            found = true;
            break;
        }
    }
    
    if( found == false )
    {
        TRACE(MTrace::SEVERE_ERROR, L"this is unexpected and a bug.  NlbsNic and ClusterSetting class guids may not be matching\n");
        throw _com_error( WBEM_E_UNEXPECTED );
    }

    _bstr_t name = _bstr_t( Name.getValue() );

    WTokens        tok;
    vector<wstring> tokens;
    tok.init( wstring( name ),
              L":" );
    tokens = tok.tokenize();

    return tokens[0].c_str();

}

// default constructor
//
NicInfo::NicInfo()
        : 
        fullNicName( L"Not set"),
        adapterGuid( L"Not set"),
        friendlyName( L"Not set")
{}

// equality operator
//
bool
NicInfo::operator==( const NicInfo& objToCompare )
{
    if( ( fullNicName == objToCompare.fullNicName )
        &&
        ( adapterGuid == objToCompare.adapterGuid )
        )
    {
        return true;
    }
    else
    {
        return false;
    }
}

// inequality operator
//
bool
NicInfo::operator!=( const NicInfo& objToCompare )
{
    return !operator==(objToCompare );
}


// default constructor
//
ClusterProperties::ClusterProperties()
{
    cIP = L"0.0.0.0";
    cSubnetMask = L"0.0.0.0";
    cFullInternetName = L"www.nlb-cluster.com";
    cNetworkAddress = L"00-00-00-00-00-00";

    multicastSupportEnabled = false;

    // Edited (mhakim 12-02-01 )
    // remote control was on by default, changed it to mimic core
    // and now off.

//     remoteControlEnabled = true;
    remoteControlEnabled = false;

    password = L"";

    igmpSupportEnabled = false;

    clusterIPToMulticastIP = true;
}

// equality operator
//
bool
ClusterProperties::operator==( const ClusterProperties& objToCompare )
{
    bool btemp1, btemp2; // Variables to pass to below function. Returned values not used
    return !HaveClusterPropertiesChanged(objToCompare, &btemp1, &btemp2);
}

// equality operator
//
bool
ClusterProperties::HaveClusterPropertiesChanged( const ClusterProperties& objToCompare, 
                                                 bool                    *pbOnlyClusterNameChanged,
                                                 bool                    *pbClusterIpChanged)
{
    *pbClusterIpChanged = false;
    *pbOnlyClusterNameChanged = false;

    if( cIP != objToCompare.cIP )
    {
        *pbClusterIpChanged = true;
        return true;
    }
    else if (
        ( cSubnetMask != objToCompare.cSubnetMask )
        ||
        ( cNetworkAddress != objToCompare.cNetworkAddress )
        ||
        ( multicastSupportEnabled != objToCompare.multicastSupportEnabled )
        ||
        ( igmpSupportEnabled != objToCompare.igmpSupportEnabled )
        ||
        ( clusterIPToMulticastIP != objToCompare.clusterIPToMulticastIP )
        )
    {
        return true;
    }
    else if (
        ( cFullInternetName != objToCompare.cFullInternetName )
        ||
        ( remoteControlEnabled != objToCompare.remoteControlEnabled )
        )
    {
        *pbOnlyClusterNameChanged = true;
        return true;
    }
    else if (
        ( remoteControlEnabled == true )
        &&
        ( password != objToCompare.password )        
        )
    {
        *pbOnlyClusterNameChanged = true;
        return true;
    }

    return false;
}

// inequality operator
//
bool
ClusterProperties::operator!=( const ClusterProperties& objToCompare )
{
    bool btemp1, btemp2; // Variables to pass to below function. Returned values not used
    return HaveClusterPropertiesChanged(objToCompare, &btemp1, &btemp2);
}

// default constructor
//
HostProperties::HostProperties()
{
    // TODO set all properties with default values.
}

// equality operator
//
bool
HostProperties::operator==( const HostProperties& objToCompare )
{
    if( ( hIP == objToCompare.hIP )
        &&
        ( hSubnetMask == objToCompare.hSubnetMask )        
        &&
        ( hID == objToCompare.hID )
        &&
        ( initialClusterStateActive == objToCompare.initialClusterStateActive )
        &&
        ( hostStatus == objToCompare.hostStatus ) 
        &&                                        
        ( nicInfo == objToCompare.nicInfo )
        &&
        ( machineName == objToCompare.machineName )
        )
    {
        return true;
    }
    else
    {
        return false;
    }
}

// inequality operator
//
bool
HostProperties::operator!=( const HostProperties& objToCompare )
{
    return !operator==(objToCompare );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\nlbsprov\mnlbexe.h ===
#ifndef _MNLBEXE_H
#define _MNLBEXE_H
//
// Copyright (c) Microsoft.  All Rights Reserved 
//
// THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF Microsoft.
// The copyright notice above does not evidence any
// actual or intended publication of such source code.
//
// OneLiner : MNLBSetting interface.
// DevUnit  : wlbstest
// Author   : Murtaza Hakim
//
// Description: 
// -----------
#include "MWmiInstance.h"
#include "Common.h"

// Include Files
class MNLBExe
{
public:

    enum MNLBExe_Error
    {
        MNLBExe_SUCCESS       = 0,        

        COM_FAILURE            = 1,
    };
    

    static
    MNLBExe_Error
    start( MWmiInstance& instance, unsigned long* retVal );

    static
    MNLBExe_Error
    stop( MWmiInstance& instance, unsigned long* retVal );

    static
    MNLBExe_Error
    resume( MWmiInstance& instance, unsigned long* retVal );

    static
    MNLBExe_Error
    suspend( MWmiInstance& instance, unsigned long* retVal );


    static
    MNLBExe_Error
    drainstop( MWmiInstance& instance, unsigned long* retVal );


    static
    MNLBExe_Error
    enable( MWmiInstance& instance, unsigned long* retVal, unsigned long portToAffect = Common::ALL_PORTS );

    static
    MNLBExe_Error
    disable( MWmiInstance& instance, unsigned long* retVal, unsigned long portToAffect = Common::ALL_PORTS );


    static
    MNLBExe_Error
    drain( MWmiInstance& instance, unsigned long* retVal, unsigned long portToAffect = Common::ALL_PORTS );
    
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\nlbsprov\mnlbmachine.h ===
#ifndef _MNLBMACHINE_H
#define _MNLBMACHINE_H
//
// Copyright (c) Microsoft.  All Rights Reserved 
//
// THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF Microsoft.
// The copyright notice above does not evidence any
// actual or intended publication of such source code.
//
// OneLiner : MNLBMachine interface.
// DevUnit  : wlbstest
// Author   : Murtaza Hakim
//
// Description: 
// -----------


// Include Files


#include "MNLBPortRule.h"

#include "Common.h"

#include "MWmiObject.h"

#include "MWmiInstance.h"

#include <vector>
#include <memory>

#include <comdef.h>

using namespace std;

class MNLBMachine
{
public:
    enum MNLBMachine_Error
    {
        MNLBMachine_SUCCESS        = 0,
    };


    struct HostInfo
    {
        _bstr_t   dedicatedIP;
        long      hostID;
    };

    //
    // Description:
    // -----------
    // constructor.
    // 
    // Parameters:
    // ----------
    // ip                      IN      : ip address or machine name of machine to configure/admin nlbs on.
    // clusterIP               IN      : cluster ip on machine to configure.
    // 
    // Returns:
    // -------
    // none.
    //
    
    MNLBMachine( const _bstr_t&    ip,
                 const _bstr_t&    clusterIP );


    // for local machine.
    MNLBMachine( const _bstr_t&    clusterIP );


    // NOT IMPLEMENTED. 
    // 
    //
    // Description:
    // -----------
    // default constructor.
    // 
    // Parameters:
    // ----------
    // none.
    // 
    // Returns:
    // -------
    // none.

    MNLBMachine();


    //
    // Description:
    // -----------
    // copy constructor.
    // 
    // Parameters:
    // ----------
    // objToCopy             IN  :  object to copy.
    // 
    // Returns:
    // -------
    // none.

    MNLBMachine(const MNLBMachine& objToCopy );


    //
    // Description:
    // -----------
    // assignment operator
    // 
    // Parameters:
    // ----------
    // rhs             IN   : object to assign.
    // 
    // Returns:
    // -------
    // self

    MNLBMachine&
    operator=( const MNLBMachine& rhs );


    //
    // Description:
    // -----------
    // destructor
    // 
    // Parameters:
    // ----------
    // none
    // 
    // Returns:
    // -------
    // none.

    ~MNLBMachine();


    //
    // Description:
    // -----------
    // nlb host properties for machine.
    // 
    // Parameters:
    // ----------
    // hp                       OUT      : host properties.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBMachine_Error
    getHostProperties( HostProperties* hp );

    //
    // Description:
    // -----------
    // nlb cluster properties.
    // 
    // Parameters:
    // ----------
    // cp                       OUT      : cluster properties.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBMachine_Error
    getClusterProperties( ClusterProperties* cp );

    //
    // Description:
    // -----------
    // information of all hosts part of cluster
    // 
    // Parameters:
    // ----------
    // cp                       OUT      : cluster properties.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBMachine_Error
    getPresentHostsInfo( vector< HostInfo >* hostInfo );

    //
    // Description:
    // -----------
    // sets the nlbs host properties.
    // 
    // Parameters:
    // ----------
    // hp                       IN      : host properties to set.
    // retVal                   OUT     : return value of method ran.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBMachine_Error
    setHostProperties( const HostProperties& hp,
                       unsigned long* retVal );


    //
    // Description:
    // -----------
    // sets the nlbs cluster properties.
    // 
    // Parameters:
    // ----------
    // cp                       IN      : cluster properties to set.
    // retVal                   OUT     : return value of method ran.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBMachine_Error
    setClusterProperties( const ClusterProperties& cp,
                          unsigned long* retVal );

    //
    // Description:
    // -----------
    // get the load balanced port rules associated with this machine.
    // 
    // Parameters:
    // ----------
    // portsLB           OUT    : load balanced port rules associated with this machine.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.


    MNLBMachine_Error
    getPortRulesLoadBalanced( vector<MNLBPortRuleLoadBalanced>* portsLB );


    //
    // Description:
    // -----------
    // get the failover port rules associated with this machine.
    // 
    // Parameters:
    // ----------
    // portsF           OUT    : failover port rules associated with this machine.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBMachine_Error
    getPortRulesFailover( vector<MNLBPortRuleFailover>* portsF );


    //
    // Description:
    // -----------
    // get the disabled port rules associated with this machine.
    // 
    // Parameters:
    // ----------
    // portsD           OUT    : failover port rules associated with this machine.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBMachine_Error
    getPortRulesDisabled( vector<MNLBPortRuleDisabled>* portsD );

    //
    // Description:
    // -----------
    // adds a load balanced port rule to the machine.
    // 
    // Parameters:
    // ----------
    // portRuleLB             IN  :  load balanced port rule to add.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBMachine_Error
    addPortRuleLoadBalanced( const MNLBPortRuleLoadBalanced& portRuleLB );

    //
    // Description:
    // -----------
    // adds a failover port rule to the machine.
    // 
    // Parameters:
    // ----------
    // portRuleF             IN  :  failover port rule to add.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBMachine_Error
    addPortRuleFailover( const MNLBPortRuleFailover& portRuleF );


    //
    // Description:
    // -----------
    // adds a disabled port rule to the machine.
    // 
    // Parameters:
    // ----------
    // portRuleD             IN  :  disabled port rule to add.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBMachine_Error
    addPortRuleDisabled( const MNLBPortRuleDisabled& portRuleD );
    

    //
    // Description:
    // -----------
    // removes a load balanced port rule to the machine.
    // 
    // Parameters:
    // ----------
    // portRuleLB             IN  :  load balanced port rule to remove.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBMachine_Error
    removePortRuleLoadBalanced( const MNLBPortRuleLoadBalanced& portRuleLB );

    //
    // Description:
    // -----------
    // removes a failover port rule to the machine.
    // 
    // Parameters:
    // ----------
    // portRuleF             IN  :  failover port rule to remove.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBMachine_Error
    removePortRuleFailover( const MNLBPortRuleFailover& portRuleF );


    //
    // Description:
    // -----------
    // removes a disabled port rule to the machine.
    // 
    // Parameters:
    // ----------
    // portRuleD             IN  :  disabled port rule to remove.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBMachine_Error
    removePortRuleDisabled( const MNLBPortRuleDisabled& portRuleD );

    //
    // Description:
    // -----------
    // starts host/cluster operations.
    // 
    // Parameters:
    // ----------
    // hostID            IN    : host id or Common::ALL_HOSTS for cluster wide 
    //                           or Common::THIS_HOST for connected machine.
    // retVal            OUT   : return value of method ran.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBMachine_Error
    start( int hostID, unsigned long* retVal );


    //
    // Description:
    // -----------
    // stops host/cluster operations.
    // 
    // Parameters:
    // ----------
    // hostID            IN    : host id or Common::ALL_HOSTS for cluster wide or 
    //                           Common::THIS_HOST for connected machine.
    // retVal            OUT   : return value of method ran.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBMachine_Error
    stop( int hostID, unsigned long* retVal );

    //
    // Description:
    // -----------
    // resume control over host/cluster operations.
    // 
    // Parameters:
    // ----------
    // hostID            IN    : host id or Common::ALL_HOSTS for cluster wide or 
    //                           Common::THIS_HOST for connected machine.
    // retVal            OUT   : return value of method ran.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBMachine_Error
    resume( int hostID, unsigned long* retVal );

    //
    // Description:
    // -----------
    // suspend control over host/cluster operations.
    // 
    // Parameters:
    // ----------
    // hostID            IN    : host id or Common::ALL_HOSTS for cluster wide or 
    //                           Common::THIS_HOST for connected machine.
    // retVal            OUT   : return value of method ran.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBMachine_Error
    suspend( int hostID, unsigned long* retVal );

    //
    // Description:
    // -----------
    // finishes all existing connections and
    // stops host/cluster operations.
    // 
    // Parameters:
    // ----------
    // hostID            IN    : host id or Common::ALL_HOSTS for cluster wide or 
    //                           Common::THIS_HOST for connected machine.
    // retVal            OUT   : return value of method ran.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBMachine_Error
    drainstop( int hostID, unsigned long* retVal );

    //
    // Description:
    // -----------
    // enables traffic for port rule for host/cluster.
    // 
    // Parameters:
    // ----------
    // hostID            IN    : host id or Common::ALL_HOSTS for cluster wide or 
    //                           Common::THIS_HOST for connected machine.
    // retVal            OUT   : return value of method ran.
    // port              IN    : port to affect or default is all ports.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBMachine_Error
    enable( int hostID, 
            unsigned long* retVal, 
            unsigned long port = Common::ALL_PORTS );

    //
    // Description:
    // -----------
    // disables ALL traffic for port rule for host/cluster.
    // 
    // Parameters:
    // ----------
    // hostID            IN    : host id or Common::ALL_HOSTS for cluster wide or 
    //                           Common::THIS_HOST for connected machine.
    // retVal            OUT   : return value of method ran.
    // port              IN    : port to affect or default is all ports.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBMachine_Error
    disable( int hostID, unsigned long* retVal, unsigned long port  = Common::ALL_PORTS);

    //
    // Description:
    // -----------
    // disables NEW traffic for port rule for host/cluster.
    // 
    // Parameters:
    // ----------
    // hostID            IN    : host id or Common::ALL_HOSTS for cluster wide or 
    //                           Common::THIS_HOST for connected machine.
    // retVal            OUT   : return value of method ran.
    // port              IN    : port to affect or default is all ports.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBMachine_Error
    drain( int hostID, unsigned long* retVal, unsigned long port  = Common::ALL_PORTS );

    //
    // Description:
    // -----------
    // syncs the driver with the parameters in the registry.
    // this method is generally not required, but is provided 
    // if somehow the driver and the registry where parameters
    // are stored are out of sync.
    // 
    // Parameters:
    // ----------
    // retVal                   OUT     : return value of method ran.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBMachine_Error
    reload( unsigned long* retVal );        

    //
    // Description:
    // -----------
    // sets the nlbs remote control password.
    // 
    // Parameters:
    // ----------
    // password                 IN      : password to set.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBMachine_Error
    setPassword( const _bstr_t& password,
                 unsigned long* retVal );                 

    //
    // Description:
    // -----------
    // refreshes the wmi connection to the host
    // 
    // Parameters:
    // ----------
    // none
    // 
    // Returns:
    // -------
    // SUCCESS else error code.
    MNLBMachine_Error
    refreshConnection();


private:

    // data
    auto_ptr<MWmiObject>   p_machine;

    _bstr_t mIP;

    _bstr_t mClusterIP;

    _bstr_t mHostID;

    // functions

    MNLBMachine_Error
    connectToMachine();

    MNLBMachine_Error
    checkClusterIPAndSetHostID();


    MNLBMachine_Error
    getInstanceToRunMethodOn( int hostID, vector <MWmiInstance>* instanceStore );
    

    MNLBMachine::MNLBMachine_Error
    MNLBMachine::getPortRulesLoadBalanced_private( vector<MNLBPortRuleLoadBalanced>* portsLB, 
                                                   vector<MWmiInstance>*          instances );

    MNLBMachine::MNLBMachine_Error
    MNLBMachine::getPortRulesFailover_private( vector<MNLBPortRuleFailover>*     portsF,
                                               vector<MWmiInstance>*          instances );
    
    MNLBMachine::MNLBMachine_Error
    MNLBMachine::getPortRulesDisabled_private( vector<MNLBPortRuleDisabled>*     portsD,
                                               vector<MWmiInstance>*          instances );

};


// ensure type safety

typedef class MNLBMachine MNLBMachine;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\nlbsprov\mnlbhost.h ===
#ifndef _MNLBHOST_H
#define _MNLBHOST_H
//
// Copyright (c) Microsoft.  All Rights Reserved 
//
// THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF Microsoft.
// The copyright notice above does not evidence any
// actual or intended publication of such source code.
//
// OneLiner : MNLBHost interface.
// DevUnit  : wlbstest
// Author   : Murtaza Hakim
//
// Description: 
// -----------


// Include Files
#include <vector>
#include <wbemidl.h>
#include <comdef.h>

#include "MWmiObject.h"
#include "MWmiInstance.h"

#include "Common.h"

// forward declarations.
//
class MNLBCluster;

class MNLBPortRule;

class MNLBPortRuleLoadBalanced;

class MNLBPortRuleFailover;

class MNLBPortRuleDisabled;


using namespace std;


//
class MNLBHost
{
public:

    enum MNLBHost_Error
    {
        MNLBHost_SUCCESS        = 0,

        COM_FAILURE          = 1,
        CONNECT_FAILED       = 2,
        NO_CLUSTER           = 3,
        UNCONSTRUCTED        = 4,

    };

    //
    // Description:
    // -----------
    // constructor.
    // 
    // Parameters:
    // ----------
    // cip                      IN      : cluster ip address of host.
    // hID                      IN      : host id.
    // 
    // Returns:
    // -------
    // none.

    MNLBHost( _bstr_t      cip,  
           int          hID );

    //
    // Description:
    // -----------
    // default constructor.
    // 
    // Parameters:
    // ----------
    // none.
    // 
    // Returns:
    // -------
    // none.

    MNLBHost();

    //
    // Description:
    // -----------
    // copy constructor.
    // 
    // Parameters:
    // ----------
    // mhost             IN  :  object to copy.
    // 
    // Returns:
    // -------
    // none.

    MNLBHost(const MNLBHost& mhost);


    //
    // Description:
    // -----------
    // assignment operator
    // 
    // Parameters:
    // ----------
    // rhs             IN   : object to assign.
    // 
    // Returns:
    // -------
    // self

    MNLBHost&
    operator=( const MNLBHost& rhs );


    //
    // Description:
    // -----------
    // destructor
    // 
    // Parameters:
    // ----------
    // none
    // 
    // Returns:
    // -------
    // none.

    ~MNLBHost();


    //
    // Description:
    // -----------
    // refreshes the wmi connection to the host
    // 
    // Parameters:
    // ----------
    // none
    // 
    // Returns:
    // -------
    // SUCCESS else error code.
    MNLBHost_Error
    refreshConnection();

    //
    // Description:
    // -----------
    // gets the host properties.
    // 
    // Parameters:
    // ----------
    // hp                       OUT      : host properties.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBHost_Error
    getHostProperties( HostProperties* hp );

    //
    // Description:
    // -----------
    // gets the cluster which this host is member of.
    // 
    // Parameters:
    // ----------
    // cluster       OUT  :  cluster which this host is member of.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBHost_Error
    getCluster( MNLBCluster* cluster);

    //
    // Description:
    // -----------
    // get the load balanced port rules associated with this host.
    // 
    // Parameters:
    // ----------
    // portsLB           OUT    : load balanced port rules associated with this node.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.


    MNLBHost::MNLBHost_Error
    MNLBHost::getPortRulesLoadBalanced( vector<MNLBPortRuleLoadBalanced>* portsLB );



    //
    // Description:
    // -----------
    // get the failover port rules associated with this host.
    // 
    // Parameters:
    // ----------
    // portsF           OUT    : failover port rules associated with this node.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBHost::MNLBHost_Error
    MNLBHost::getPortRulesFailover( vector<MNLBPortRuleFailover>* portsF );


    //
    // Description:
    // -----------
    // get the disabled port rules associated with this host.
    // 
    // Parameters:
    // ----------
    // portsD           OUT    : failover port rules associated with this node.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBHost::MNLBHost_Error
    MNLBHost::getPortRulesDisabled( vector<MNLBPortRuleDisabled>* portsD );


    //
    // Description:
    // -----------
    // starts host operations.
    // 
    // Parameters:
    // ----------
    // retVal            OUT   : return value of method ran.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBHost_Error
    start( unsigned long* retVal );


    //
    // Description:
    // -----------
    // stops host operations.
    // 
    // Parameters:
    // ----------
    // retVal            OUT   : return value of method ran.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBHost_Error
    stop( unsigned long* retVal );

    //
    // Description:
    // -----------
    // resume control over host operations.
    // 
    // Parameters:
    // ----------
    // retVal            OUT   : return value of method ran.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBHost_Error
    resume( unsigned long* retVal );

    //
    // Description:
    // -----------
    // suspend control over host operations.
    // 
    // Parameters:
    // ----------
    // retVal            OUT   : return value of method ran.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBHost_Error
    suspend( unsigned long* retVal );

    //
    // Description:
    // -----------
    // finishes all existing connections and
    // stops host operations.
    // 
    // Parameters:
    // ----------
    // retVal            OUT   : return value of method ran.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBHost_Error
    drainstop( unsigned long* retVal );

    //
    // Description:
    // -----------
    // enables traffic for port rule.
    // 
    // Parameters:
    // ----------
    // retVal            OUT   : return value of method ran.
    // port              IN    : port to affect.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBHost_Error
    enable( unsigned long* retVal, unsigned long port = Common::ALL_PORTS );

    //
    // Description:
    // -----------
    // disables ALL traffic for port rule.
    // 
    // Parameters:
    // ----------
    // retVal            OUT   : return value of method ran.
    // port              IN    : port to affect.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBHost_Error
    disable( unsigned long* retVal, unsigned long port = Common::ALL_PORTS );

    //
    // Description:
    // -----------
    // drains NEW traffic for port rule.
    // 
    // Parameters:
    // ----------
    // retVal            OUT   : return value of method ran.
    // port              IN    : port to affect.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBHost_Error
    drain( unsigned long* retVal, unsigned long port = Common::ALL_PORTS );


    MNLBHost_Error
    getHostIP();

private:

    _bstr_t    hostIP;

//    wchar_t hostIDOfConnectedMachine[100];

    _bstr_t    clusterIP;

    int        hostID;
    
    bool       connectedToAny;

    MNLBHost_Error status;

    auto_ptr<MWmiObject>          p_machine;

    auto_ptr<MWmiInstance>        p_host;

    MNLBHost_Error
    connectToExactHost();

    MNLBHost_Error
    connectToAnyHost();


    MNLBHost::MNLBHost_Error
    MNLBHost::getPortRulesLoadBalanced_private( vector<MNLBPortRuleLoadBalanced>* portsLB, 
                                             vector<MWmiInstance>*          instances );

    MNLBHost::MNLBHost_Error
    MNLBHost::getPortRulesFailover_private( vector<MNLBPortRuleFailover>*     portsF,
                                             vector<MWmiInstance>*      instances );

    MNLBHost::MNLBHost_Error
    MNLBHost::getPortRulesDisabled_private( vector<MNLBPortRuleDisabled>*     portsD,
                                         vector<MWmiInstance>*          instances );




    friend MNLBCluster;
    
    friend MNLBPortRule;

    friend MNLBPortRuleLoadBalanced;

    friend MNLBPortRuleFailover;

    friend MNLBPortRuleDisabled;

};


//
// Ensure type safety

typedef class MNLBHost MNLBHost;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\nlbsprov\mnlbexe.cpp ===
// Copyright (c)  Microsoft.  All rights reserved.
//
// This is unpublished source code of Microsoft.
// The copyright notice above does not evidence any
// actual or intended publication of such source code.

// OneLiner  :  Implementation of MNLBExe
// DevUnit   :  wlbstest
// Author    :  Murtaza Hakim

// include files
#include "MNLBExe.h"

     
MNLBExe::MNLBExe_Error 
MNLBExe::start( MWmiInstance& instance, unsigned long* retVal )
{
    // input parameters are none.
    //
    vector<MWmiParameter *> inputParameters;

    //  output parameters which are of interest.
    //
    vector<MWmiParameter *> outputParameters;
    MWmiParameter    returnValue(L"ReturnValue");
    outputParameters.push_back( &returnValue );

    // execute the method.
    //
    instance.runMethod( L"Start",
                         inputParameters,
                         outputParameters );

    *retVal = long ( returnValue.getValue() );
    return MNLBExe_SUCCESS;
}


     
MNLBExe::MNLBExe_Error 
MNLBExe::stop( MWmiInstance& instance, unsigned long* retVal )
{
    // input parameters are none.
    //
    vector<MWmiParameter *> inputParameters;

    //  output parameters which are of interest.
    //
    vector<MWmiParameter *> outputParameters;
    MWmiParameter    returnValue(L"ReturnValue");
    outputParameters.push_back( &returnValue );

    // execute the method.
    //
    instance.runMethod( L"Stop",
                         inputParameters,
                         outputParameters );

    *retVal = long ( returnValue.getValue() );
    return MNLBExe_SUCCESS;
}

     
MNLBExe::MNLBExe_Error 
MNLBExe::resume( MWmiInstance& instance, unsigned long* retVal )
{
    // input parameters are none.
    //
    vector<MWmiParameter *> inputParameters;

    //  output parameters which are of interest.
    //
    vector<MWmiParameter *> outputParameters;
    MWmiParameter    returnValue(L"ReturnValue");
    outputParameters.push_back( &returnValue );

    // execute the method.
    //
    instance.runMethod( L"Resume",
                         inputParameters,
                         outputParameters );

    *retVal = long ( returnValue.getValue() );
    return MNLBExe_SUCCESS;
}

     
MNLBExe::MNLBExe_Error 
MNLBExe::suspend( MWmiInstance& instance, unsigned long* retVal )
{
    // input parameters are none.
    //
    vector<MWmiParameter *> inputParameters;

    //  output parameters which are of interest.
    //
    vector<MWmiParameter *> outputParameters;
    MWmiParameter    returnValue(L"ReturnValue");
    outputParameters.push_back( &returnValue );

    // execute the method.
    //
    instance.runMethod( L"Suspend",
                         inputParameters,
                         outputParameters );

    *retVal = long ( returnValue.getValue() );
    return MNLBExe_SUCCESS;
}


     
MNLBExe::MNLBExe_Error 
MNLBExe::drainstop( MWmiInstance& instance, unsigned long* retVal )
{
    // input parameters are none.
    //
    vector<MWmiParameter *> inputParameters;

    //  output parameters which are of interest.
    //
    vector<MWmiParameter *> outputParameters;
    MWmiParameter    returnValue(L"ReturnValue");
    outputParameters.push_back( &returnValue );

    // execute the method.
    //
    instance.runMethod( L"DrainStop",
                         inputParameters,
                         outputParameters );

    *retVal = long ( returnValue.getValue() );
    return MNLBExe_SUCCESS;
}


     
MNLBExe::MNLBExe_Error 
MNLBExe::enable( MWmiInstance& instance, unsigned long* retVal, unsigned long portToAffect )
{

    // input parameters to set.
    //
    vector<MWmiParameter *> inputParameters;
    MWmiParameter    port(L"Port");
    port.setValue( long (portToAffect) );

    inputParameters.push_back( &port );


    //  output parameters which are of interest.
    //
    vector<MWmiParameter *> outputParameters;
    MWmiParameter    returnValue(L"ReturnValue");
    outputParameters.push_back( &returnValue );

    // execute the method.
    //
    instance.runMethod( L"Enable",
                         inputParameters,
                         outputParameters );

    *retVal = long ( returnValue.getValue() );
    return MNLBExe_SUCCESS;
}

     
MNLBExe::MNLBExe_Error 
MNLBExe::disable( MWmiInstance& instance, unsigned long* retVal, unsigned long portToAffect )
{

    // input parameters to set.
    //
    vector<MWmiParameter *> inputParameters;
    MWmiParameter    port(L"Port");
    port.setValue( long (portToAffect) );

    inputParameters.push_back( &port );


    //  output parameters which are of interest.
    //
    vector<MWmiParameter *> outputParameters;
    MWmiParameter    returnValue(L"ReturnValue");
    outputParameters.push_back( &returnValue );

    // execute the method.
    //
    instance.runMethod( L"Disable",
                         inputParameters,
                         outputParameters );

    *retVal = long ( returnValue.getValue() );
    return MNLBExe_SUCCESS;
}


     
MNLBExe::MNLBExe_Error 
MNLBExe::drain( MWmiInstance& instance, unsigned long* retVal, unsigned long portToAffect )
{
    // input parameters to set.
    //
    vector<MWmiParameter *> inputParameters;
    MWmiParameter    port(L"Port");
    port.setValue( long (portToAffect) );

    inputParameters.push_back( &port );

    //  output parameters which are of interest.
    //
    vector<MWmiParameter *> outputParameters;
    MWmiParameter    returnValue(L"ReturnValue");
    outputParameters.push_back( &returnValue );

    // execute the method.
    //
    instance.runMethod( L"Drain",
                         inputParameters,
                         outputParameters );

    *retVal = long ( returnValue.getValue() );
    return MNLBExe_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\nlbsprov\mnlbhost.cpp ===
// Copyright (c)  Microsoft.  All rights reserved.
//
// This is unpublished source code of Microsoft.
// The copyright notice above does not evidence any
// actual or intended publication of such source code.

// OneLiner  :  Implementation of MNLBHost
// DevUnit   :  wlbstest
// Author    :  Murtaza Hakim

// include files
#include "MNLBHost.h"

#include "MNLBCluster.h"
#include "MNLBExe.h"

#include "MNLBPortRule.h"

#include "MTrace.h"

#include "WTokens.h"

#include "wlbsctrl.h"
#include "Common.h"

#include <iostream>

using namespace std;

// constructor
//
MNLBHost::MNLBHost( _bstr_t   cip,
                    int       hID )
        : 
        clusterIP( cip ),
        hostID( hID ),
        connectedToAny( false ),
        p_machine( NULL ),
        p_host( NULL )
{
    MTrace* trace = MTrace::Instance();

    MTrace::TraceLevel prevLevel = trace->GetLevel();

    try
    {
        trace->SetLevel( MTrace::NO_TRACE );
        connectToAnyHost();
        trace->SetLevel( prevLevel );
    }
    catch( _com_error e )
    {
        TRACE(MTrace::INFO, L"connection using clusterip has failed\n" );

        trace->SetLevel( prevLevel );
        connectToExactHost();
    }

    TRACE(MTrace::INFO, L"mhost constructor\n" );
}

// default constructor.
//
// note that default constructor is purposely left undefined.  
// NO one should be using it.  It is declared just for vector class usage.


// copy constructor
//
MNLBHost::MNLBHost(const MNLBHost& mhost)
        : clusterIP( mhost.clusterIP ),
          hostID( mhost.hostID ),
          hostIP( mhost.hostIP ),
          connectedToAny( mhost.connectedToAny )
{
    p_machine = auto_ptr<MWmiObject>(new MWmiObject( *mhost.p_machine ));

    p_host = auto_ptr<MWmiInstance>( new MWmiInstance( *mhost.p_host ));

    TRACE(MTrace::INFO, L"mhost copy constructor\n" );
}


// assignment operator
//
MNLBHost&
MNLBHost::operator=( const MNLBHost& rhs )
{
    clusterIP = rhs.clusterIP;
    hostID = rhs.hostID;
    hostIP = rhs.hostIP;
    connectedToAny =  rhs.connectedToAny; 

    p_machine = auto_ptr<MWmiObject>(new MWmiObject( *rhs.p_machine ));

    p_host = auto_ptr<MWmiInstance>( new MWmiInstance( *rhs.p_host ));

    TRACE(MTrace::INFO, L"mhost assignment operator\n" );

    return *this;
}

// destructor
//
MNLBHost::~MNLBHost()
{
    TRACE(MTrace::INFO, L"mhost destructor\n" );
}



// getHostProperties
//
// TODO: Code to find the nic name and nic guid remains to be added for win2k machines as well as whistler
//
MNLBHost::MNLBHost_Error
MNLBHost::getHostProperties( HostProperties* hp )
{
    if( connectedToAny == true )
    {
        TRACE(MTrace::INFO, L"retrying to connect to exact host\n" );
        connectToExactHost();
    }

    // get node properties
    //
    vector<MWmiParameter* >    parameterStore;

    // the status code is to be got from the Node class.
    //
    MWmiParameter  sc(L"StatusCode");
    parameterStore.push_back( &sc );    

    p_host->getParameters( parameterStore );

    hp->hostStatus = long( sc.getValue() );

    parameterStore.erase( parameterStore.begin(), parameterStore.end() );

    MWmiParameter  hip(L"DedicatedIPAddress");
    parameterStore.push_back( &hip );

    MWmiParameter  hnm(L"DedicatedNetworkMask");
    parameterStore.push_back( &hnm );

    MWmiParameter  hpr(L"HostPriority");
    parameterStore.push_back( &hpr );

    MWmiParameter  cmos(L"ClusterModeOnStart");
    parameterStore.push_back( &cmos );

    MWmiParameter Server("__Server");
    parameterStore.push_back( &Server);

    // get instances of nodesetting class.
    //
    vector< MWmiInstance >     instanceStore;

    wchar_t hostIDWChar[ Common::BUF_SIZE ];
    swprintf( hostIDWChar, L"%d", hostID );        

    _bstr_t relPath = L"MicrosoftNLB_NodeSetting.Name=\"" + clusterIP + L":" + hostIDWChar + L"\"";
    p_machine->getSpecificInstance( L"MicrosoftNLB_NodeSetting",
                                    relPath,
                                    &instanceStore );
    instanceStore[0].getParameters( parameterStore );

    // set parameters to get for whistler
    // these properties only present in whistler.
    //
    vector<MWmiParameter* >   parameterStoreWhistler;

    MWmiParameter AdapterGuid(L"AdapterGuid");
    parameterStoreWhistler.push_back( &AdapterGuid );

    // get whistler parameters
    bool machineIsWhistler = true;

    try
    {
        // this will fail on win2k
        // as adapterguid, igmpsupport etc are not present.
        instanceStore[0].getParameters( parameterStoreWhistler );
    }
    catch( _com_error e )
    {
        // maybe it was a win2k machine.  This exception is expected, thus catch.
        // for better safety, need to find exact error code returned and then only do the 
        // folllowing otherwise need to rethrow.
        //
        TRACE( MTrace::INFO, L"tried whistler operation on win2k, this is expected\n");
        machineIsWhistler = false;
    }

    hp->hIP         = hip.getValue();
            
    hp->hSubnetMask = hnm.getValue();
            
    hp->hID         = hpr.getValue();
            
    hp->initialClusterStateActive = cmos.getValue();

    hp->machineName = Server.getValue();

    if( machineIsWhistler == true )
    {
        Common::getNLBNicInfoForWhistler( hostIP, 
                                          _bstr_t( AdapterGuid.getValue() ),
                                          hp->nicInfo );
    }
    else
    {
        Common::getNLBNicInfoForWin2k(  hostIP, 
                                        hp->nicInfo );
    }

    return MNLBHost_SUCCESS;
}

// getPortRulesLoadBalanced
//
MNLBHost::MNLBHost_Error
MNLBHost::getPortRulesLoadBalanced( vector<MNLBPortRuleLoadBalanced>* portsLB )
{
    vector<MWmiInstance> instanceStore;

    return getPortRulesLoadBalanced_private( portsLB, 
                                             &instanceStore );

}

// getPortRulesLoadBalanced_private
//
MNLBHost::MNLBHost_Error
MNLBHost::getPortRulesLoadBalanced_private( vector<MNLBPortRuleLoadBalanced>* portsLB,
                                         vector<MWmiInstance>*          instances )
{
    if( connectedToAny == true )
    {
        TRACE(MTrace::INFO, L"retrying to connect to exact host\n" );
        connectToExactHost();
    }

    // get port properties.
    //
    vector<MWmiParameter* >    parameterStore;

    MWmiParameter   sp(L"StartPort");
    parameterStore.push_back( &sp );

    MWmiParameter ep(L"EndPort");
    parameterStore.push_back( &ep );

    MWmiParameter p(L"Protocol");
    parameterStore.push_back( &p );

    MWmiParameter el(L"EqualLoad");
    parameterStore.push_back( &el );

    MWmiParameter lw(L"LoadWeight");
    parameterStore.push_back( &lw );

    MWmiParameter a(L"Affinity");
    parameterStore.push_back( &a );    

    MWmiParameter name(L"Name");
    parameterStore.push_back( &name );

    MNLBPortRule::Affinity    affinity;
    MNLBPortRule::Protocol    trafficToHandle;

    p_machine->getInstances( L"MicrosoftNLB_PortRuleLoadBalanced",
                             instances );
    WTokens        tok;
    _bstr_t temp;
    vector<wstring> tokens;

    for( int i = 0; i < instances->size(); ++i )
    {
        (*instances)[i].getParameters( parameterStore );

        // check if this instance belongs to the cluster.
        temp = _bstr_t( name.getValue() );
        tok.init( wstring( temp ),
                  L":" );
        tokens = tok.tokenize();
        if( _bstr_t( tokens[0].c_str() ) != clusterIP ) 
        {
            // this instance does not belong to this cluster.
            continue;
        }

        switch( long (p.getValue()) )
        {
            case 1:
                trafficToHandle = MNLBPortRule::tcp;
                break;
                
            case 2:
                trafficToHandle = MNLBPortRule::udp;
                break;

            case 3:
                trafficToHandle = MNLBPortRule::both;
                break;

            default:
                // bug.
                TRACE( MTrace::SEVERE_ERROR, "unidentified protocol\n");
                throw _com_error( WBEM_E_UNEXPECTED );
                break;
        }


        switch(  long(a.getValue()) )
        {
            case 0:
                affinity = MNLBPortRule::none;
                break;

            case 1:
                affinity = MNLBPortRule::single;
                break;

            case 2:
                affinity = MNLBPortRule::classC;
                break;

            default:
                // bug.
                TRACE( MTrace::SEVERE_ERROR, "unidentified affinity\n");
                throw _com_error( WBEM_E_UNEXPECTED );
                break;
        }

                
        portsLB->push_back( MNLBPortRuleLoadBalanced(long (sp.getValue()),
                                                  long( ep.getValue()),
                                                  trafficToHandle,
                                                  bool( el.getValue()),
                                                  long( lw.getValue()),
                                                  affinity) );
                                
    }

    return MNLBHost_SUCCESS;
}


// getPortRulesFailover
//       
MNLBHost::MNLBHost_Error
MNLBHost::getPortRulesFailover( vector<MNLBPortRuleFailover>* portsF )
{
    vector<MWmiInstance> instanceStore;

    return getPortRulesFailover_private( portsF, 
                                         &instanceStore );
}
    

// getPortRulesFailover_private
//
MNLBHost::MNLBHost_Error
MNLBHost::getPortRulesFailover_private( vector<MNLBPortRuleFailover>* portsF,
                                     vector<MWmiInstance>*     instances )
{
    if( connectedToAny == true )
    {
        TRACE(MTrace::INFO, L"retrying to connect to exact host\n" );
        connectToExactHost();
    }

    // get port properties.
    //
    vector<MWmiParameter* >    parameterStore;

    MWmiParameter   sp(L"StartPort");
    parameterStore.push_back( &sp );

    MWmiParameter ep(L"EndPort");
    parameterStore.push_back( &ep );

    MWmiParameter p(L"Protocol");
    parameterStore.push_back( &p );

    MWmiParameter pr(L"Priority");
    parameterStore.push_back( &pr );

    MWmiParameter name(L"Name");
    parameterStore.push_back( &name );

    MNLBPortRule::Protocol       trafficToHandle;

    p_machine->getInstances( L"MicrosoftNLB_PortRuleFailover",
                             instances );
    WTokens        tok;
    _bstr_t temp;
    vector<wstring> tokens;

    for( int i = 0; i < instances->size(); ++i )
    {
        (*instances)[i].getParameters( parameterStore );
        // check if this instance belongs to the cluster.
        temp = _bstr_t( name.getValue() );
        tok.init( wstring( temp ),
                  L":" );
        tokens = tok.tokenize();
        if( _bstr_t( tokens[0].c_str() ) != clusterIP ) 
        {
            // this instance does not belong to this cluster.
            continue;
        }


        switch( long (p.getValue()) )
        {
            case 1:
                trafficToHandle = MNLBPortRule::tcp;
                break;

            case 2:
                trafficToHandle = MNLBPortRule::udp;
                break;

            case 3:
                trafficToHandle = MNLBPortRule::both;
                break;

            default:
                // bug.
                TRACE( MTrace::SEVERE_ERROR, "unidentified protocol\n");
                throw _com_error( WBEM_E_UNEXPECTED );
                break;
        }


        portsF->push_back( MNLBPortRuleFailover(long (sp.getValue()),
                                             long( ep.getValue()),
                                             trafficToHandle,
                                             long( pr.getValue()) )
                           );

    }

    return MNLBHost_SUCCESS;    
}


// getPortRulesDisabled
//
MNLBHost::MNLBHost_Error
MNLBHost::getPortRulesDisabled( vector<MNLBPortRuleDisabled>* portsD )
{
    vector<MWmiInstance> instanceStore;

    return getPortRulesDisabled_private( portsD, 
                                         &instanceStore );

}    


// getPortRulesDisabled_private
//
MNLBHost::MNLBHost_Error
MNLBHost::getPortRulesDisabled_private( vector<MNLBPortRuleDisabled>* portsD,
                                     vector<MWmiInstance>*      instances )
{
    if( connectedToAny == true )
    {
        TRACE(MTrace::INFO, L"retrying to connect to exact host\n" );
        connectToExactHost();
    }

    // get port properties.
    //
    vector<MWmiParameter* >    parameterStore;

    MWmiParameter   sp(L"StartPort");
    parameterStore.push_back( &sp );

    MWmiParameter ep(L"EndPort");
    parameterStore.push_back( &ep );

    MWmiParameter p(L"Protocol");
    parameterStore.push_back( &p );

    MWmiParameter name(L"Name");
    parameterStore.push_back( &name );

    MNLBPortRule::Protocol    trafficToHandle;

    p_machine->getInstances( L"MicrosoftNLB_PortRuleDisabled",
                             instances );
    WTokens        tok;
    _bstr_t temp;
    vector<wstring> tokens;

    for( int i = 0; i < instances->size(); ++i )
    {
        (*instances)[i].getParameters( parameterStore );
        // check if this instance belongs to the cluster.
        temp = _bstr_t( name.getValue() );
        tok.init( wstring( temp ),
                  L":" );
        tokens = tok.tokenize();
        if( _bstr_t( tokens[0].c_str() ) != clusterIP ) 
        {
            // this instance does not belong to this cluster.
            continue;
        }


        switch( long (p.getValue()) )
        {
            case 1:
                trafficToHandle = MNLBPortRule::tcp;
                break;

            case 2:
                trafficToHandle = MNLBPortRule::udp;
                break;

            case 3:
                trafficToHandle = MNLBPortRule::both;
                break;

            default:
                // bug.
                TRACE( MTrace::SEVERE_ERROR, "unidentified protocol\n");
                throw _com_error( WBEM_E_UNEXPECTED );
                break;
        }

            
        portsD->push_back( MNLBPortRuleDisabled( long (sp.getValue() ),
                                              long( ep.getValue() ),
                                              trafficToHandle ) );
            
    }
            
    return MNLBHost_SUCCESS;
}


// getCluster
//
MNLBHost::MNLBHost_Error
MNLBHost::getCluster( MNLBCluster* cluster)
{
    vector<MWmiParameter* >    parameterStore;

    MWmiParameter  Name(L"Name");
    parameterStore.push_back( &Name );    

    WTokens        tok;
    _bstr_t temp;
    vector<wstring> tokens;
    
    p_host->getParameters( parameterStore );
    // getting cluster ip from name of clusterip:hostid
    //
    temp = _bstr_t( Name.getValue() );
    tok.init( wstring( temp ),
                  L":" );
    tokens = tok.tokenize();

    *cluster =  MNLBCluster( tokens[0].c_str() );
        
    return MNLBHost_SUCCESS;
}


// connectToAnyHost
//
MNLBHost::MNLBHost_Error
MNLBHost::connectToAnyHost()
{
    vector< MWmiInstance > instanceStore;
    _bstr_t relPath;

    wchar_t hostIDWChar[ Common::BUF_SIZE ];
    swprintf( hostIDWChar, L"%d", hostID );        

    p_machine = auto_ptr<MWmiObject>( new MWmiObject( clusterIP,
                                                      L"root\\microsoftnlb",
                                                      L"Administrator",
                                                      L"") );

    relPath = L"MicrosoftNLB_Node.Name=\"" + clusterIP  + ":" + hostIDWChar + L"\"";

    p_machine->getSpecificInstance( L"MicrosoftNLB_Node",
                                    relPath,
                                    &instanceStore );

    p_host = auto_ptr<MWmiInstance>( new MWmiInstance( instanceStore[0] ) );

    connectedToAny = true;

    return MNLBHost_SUCCESS;
}


// connectToExactHost
//
MNLBHost::MNLBHost_Error
MNLBHost::connectToExactHost()
{
    wchar_t hostIDWChar[ Common::BUF_SIZE ];
    swprintf( hostIDWChar, L"%d", hostID );        

    //
    getHostIP();

    // check if host ip is zero.  If so we cannot proceed.
    if( hostIP == _bstr_t( L"0.0.0.0" ) )
    {
        TRACE( MTrace::SEVERE_ERROR, "dedicated ip of this host is 0.0.0.0.  This is not allowed. \n");
        throw _com_error( WBEM_E_INVALID_PROPERTY );
    }

    // connect to wmi object on host.
    //
    p_machine = auto_ptr<MWmiObject> ( new MWmiObject( hostIP,
                                                       L"root\\microsoftnlb",
                                                       L"Administrator",
                                                       L"") );

    // get instances of node.
    //
    _bstr_t relPath = L"MicrosoftNLB_Node.Name=\"" + clusterIP + ":" + hostIDWChar + L"\"";
    vector< MWmiInstance > instanceStore;

    p_machine->getSpecificInstance( L"MicrosoftNLB_Node",
                                    relPath,
                                    &instanceStore );
    p_host = auto_ptr<MWmiInstance>( new MWmiInstance( instanceStore[0] ) );

    // set flag to indicate that we have connected to the exact host.
    connectedToAny = false;

    return MNLBHost_SUCCESS;
}

// getHostIP
//
MNLBHost::MNLBHost_Error
MNLBHost::getHostIP()
{
    vector<HostProperties> hostPropertiesStore;

    // get all hosts participating in cluster.
    DWORD ret = Common::getHostsInCluster( clusterIP, &hostPropertiesStore );
    if( hostPropertiesStore.size() == 0 )
    {
        // no hosts are in this cluster.  Cannot proceed reliably.
        wstring errString;
        errString = L"cluster " +  wstring( clusterIP ) + L" reported as having no hosts.  Maybe cluster ip is wrong, or remote control is turned off\n";
        TRACE( MTrace::SEVERE_ERROR, errString );

        throw _com_error(WBEM_E_NOT_FOUND );
    }

    bool hostFound = false;
    for( int i = 0; i < hostPropertiesStore.size(); ++i )
    {
        if( hostPropertiesStore[i].hID == hostID )
        {
            hostIP = hostPropertiesStore[i].hIP;

            hostFound = true;
            break;
        }
    }

    if( hostFound == false )
    {
        wstring errString;
        errString = L"cluster " +  wstring( clusterIP ) + L" reported as having no host with specified host id\n";
        TRACE( MTrace::SEVERE_ERROR, errString );

        throw _com_error( WBEM_E_NOT_FOUND );
    }

    return MNLBHost_SUCCESS;
}


// start
//
MNLBHost::MNLBHost_Error
MNLBHost::start( unsigned long* retVal )
{
    MNLBExe::start( *p_host, retVal );

    return MNLBHost_SUCCESS;
}



// stop
//
MNLBHost::MNLBHost_Error
MNLBHost::stop( unsigned long* retVal )
{
    MNLBExe::stop( *p_host, retVal );

    return MNLBHost_SUCCESS;
}



// resume
//
MNLBHost::MNLBHost_Error
MNLBHost::resume( unsigned long* retVal )
{
    MNLBExe::resume( *p_host, retVal );

    return MNLBHost_SUCCESS;
}


// suspend
//
MNLBHost::MNLBHost_Error
MNLBHost::suspend( unsigned long* retVal )
{
    MNLBExe::suspend( *p_host, retVal );

    return MNLBHost_SUCCESS;
}


// drainstop
//
MNLBHost::MNLBHost_Error
MNLBHost::drainstop( unsigned long* retVal )
{
    MNLBExe::drainstop( *p_host, retVal );

    return MNLBHost_SUCCESS;
}



// enable
//
MNLBHost::MNLBHost_Error
MNLBHost::enable( unsigned long* retVal, unsigned long portToAffect )
{
    MNLBExe::enable( *p_host, retVal, portToAffect );

    return MNLBHost_SUCCESS;
}


// disable
//
MNLBHost::MNLBHost_Error
MNLBHost::disable( unsigned long* retVal, unsigned long portToAffect )
{
    MNLBExe::disable( *p_host, retVal, portToAffect );

    return MNLBHost_SUCCESS;
}





// drain
//
MNLBHost::MNLBHost_Error
MNLBHost::drain( unsigned long* retVal, unsigned long portToAffect )
{
    MNLBExe::drain( *p_host, retVal, portToAffect );

    return MNLBHost_SUCCESS;
}


// refreshConnection
//
MNLBHost::MNLBHost_Error
MNLBHost::refreshConnection()
{
    return connectToExactHost();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\nlbsprov\mnlbnetcfg.cpp ===
// Copyright (c)  Microsoft.  All rights reserved.
//
// This is unpublished source code of Microsoft.
// The copyright notice above does not evidence any
// actual or intended publication of such source code.

// OneLiner  :  Implementation of MNLBNetCfg
// DevUnit   :  wlbstest
// Author    :  Murtaza Hakim

// include files
#include "MNLBNetCfg.h"

#include "MTrace.h"
#include "WTokens.h"

// History:
// --------
// 
//
// Revised by : mhakim
// Date       : 02-12-01
// Reason     : Added password support.  

// constructor
//
MNLBNetCfg::MNLBNetCfg( const _bstr_t& ip,
                        const _bstr_t& fullNicName )
        : 
        m_ip( ip ),
        m_fullNicName( fullNicName )
{
}

// constructor
//
MNLBNetCfg::MNLBNetCfg( const _bstr_t& fullNicName )
        :
        m_ip( L"self"),
        m_fullNicName( fullNicName )
{
}


// unbind
//
MNLBNetCfg::MNLBNetCfg_Error
MNLBNetCfg::unbind()
{
    MWmiObject machine( m_ip,
                        L"root\\microsoftnlb",
                        L"administrator",
                        L"" );

    vector<MWmiInstance> instanceStore;
    _bstr_t relPath = L"NlbsNic.FullName=\"" + m_fullNicName + "\"";
    machine.getSpecificInstance( L"NlbsNic",
                                 relPath,
                                 &instanceStore );

    // input parameters are none.
    //
    vector<MWmiParameter *> inputParameters;

    //  output parameters which are of interest.
    //
    vector<MWmiParameter *> outputParameters;
    MWmiParameter    ReturnValue(L"ReturnValue");
    outputParameters.push_back( &ReturnValue );

    instanceStore[0].runMethod( L"Unbind",
                                inputParameters, 
                                outputParameters );
    if( long( ReturnValue.getValue() ) != 0 )
    {
        TRACE( MTrace::SEVERE_ERROR, 
               L"Not able to unbind nlb" );
        throw _com_error( WBEM_E_NOT_FOUND );
    }

    return MNLBNetCfg_SUCCESS;
}

// isBound
//
MNLBNetCfg::MNLBNetCfg_Error
MNLBNetCfg::isBound()
{
    MWmiObject machine( m_ip,
                        L"root\\microsoftnlb",
                        L"administrator",
                        L"" );

    vector<MWmiInstance> instanceStore;
    _bstr_t relPath = L"NlbsNic.FullName=\"" + m_fullNicName + "\"";
    machine.getSpecificInstance( L"NlbsNic",
                                 relPath,
                                 &instanceStore );

    // input parameters are none.
    //
    vector<MWmiParameter *> inputParameters;

    //  output parameters which are of interest.
    //
    vector<MWmiParameter *> outputParameters;
    MWmiParameter    ReturnValue(L"ReturnValue");
    outputParameters.push_back( &ReturnValue );

    instanceStore[0].runMethod( L"IsBound",
                                inputParameters, 
                                outputParameters );
    if( long( ReturnValue.getValue() ) == 1 )
    {
        return BOUND;
    }
    else if( long( ReturnValue.getValue() ) == 0 )
    {
        return UNBOUND;
    }
    else
    {
        TRACE( MTrace::SEVERE_ERROR, 
               L"Not able to check if nlb is bound or not" );
        throw _com_error( WBEM_E_NOT_FOUND );
    }

    return MNLBNetCfg_SUCCESS;
}

// addClusterIP
//
MNLBNetCfg::MNLBNetCfg_Error
MNLBNetCfg::addClusterIP( const _bstr_t& clusterIP,
                          const _bstr_t& subnet )
{
    if( m_ip == _bstr_t( L"self" ) )
    {
        MIPAddressAdmin ipAdmin( m_fullNicName );
        ipAdmin.addIPAddress( clusterIP,
                              subnet );

    }
    else
    {
        MIPAddressAdmin ipAdmin( m_ip,
                                 m_fullNicName );
        ipAdmin.addIPAddress( clusterIP,
                              subnet );

    }

    return MNLBNetCfg_SUCCESS;
}


// removeClusterIP
//
MNLBNetCfg::MNLBNetCfg_Error
MNLBNetCfg::removeClusterIP( const _bstr_t& clusterIP )
{
    if( m_ip == _bstr_t( L"self" ) )
    {
        MIPAddressAdmin ipAdmin( m_fullNicName );
        ipAdmin.deleteIPAddress( clusterIP );
    }
    else
    {
        MIPAddressAdmin ipAdmin( m_ip,
                                 m_fullNicName);
        ipAdmin.deleteIPAddress( clusterIP );
    }

    return MNLBNetCfg_SUCCESS;
}


MNLBNetCfg::MNLBNetCfg_Error
MNLBNetCfg::bind()
{
    MWmiObject machine( m_ip,
                        L"root\\microsoftnlb",
                        L"administrator",
                        L"" );

    vector<MWmiInstance> instanceStore;
    _bstr_t relPath = L"NlbsNic.FullName=\"" + m_fullNicName + "\"";
    machine.getSpecificInstance( L"NlbsNic",
                                 relPath,
                                 &instanceStore );

    // input parameters are none.
    //
    vector<MWmiParameter *> inputParameters;

    //  output parameters which are of interest.
    //
    vector<MWmiParameter *> outputParameters;
    MWmiParameter    ReturnValue(L"ReturnValue");
    outputParameters.push_back( &ReturnValue );

    instanceStore[0].runMethod( L"Bind",
                                inputParameters, 
                                outputParameters );
    if( long( ReturnValue.getValue() ) != 0 )
    {
        TRACE( MTrace::SEVERE_ERROR, 
               L"Not able to bind nlb" );
        throw _com_error( WBEM_E_NOT_FOUND );
    }

    return MNLBNetCfg_SUCCESS;
}
    

MNLBNetCfg::MNLBNetCfg_Error
MNLBNetCfg::bindAndConfigure( 
    const ClusterData* p_clusterData,
    const _bstr_t&      machineName
    )
{

    ClusterData* p_clusterDataCopy = 
        const_cast <ClusterData *>( p_clusterData );

    MWmiObject machine( m_ip,
                        L"root\\microsoftnlb",
                        L"administrator",
                        L"" );

    vector<MWmiInstance> instanceStore;
    _bstr_t relPath = L"NlbsNic.FullName=\"" + m_fullNicName + "\"";
    machine.getSpecificInstance( L"NlbsNic",
                                 relPath,
                                 &instanceStore );

    // input parameters 
    //
    vector<MWmiParameter *> inputParameters;

    // cluster properties
    MWmiParameter    ClusterIPAddress(L"ClusterIPAddress");
    inputParameters.push_back( &ClusterIPAddress );
    ClusterIPAddress.setValue( p_clusterDataCopy->cp.cIP );

    MWmiParameter    ClusterNetworkMask(L"ClusterNetworkMask");
    inputParameters.push_back( &ClusterNetworkMask );
    ClusterNetworkMask.setValue( p_clusterDataCopy->cp.cSubnetMask );

    MWmiParameter    ClusterName(L"ClusterName");
    inputParameters.push_back( &ClusterName );
    ClusterName.setValue( p_clusterDataCopy->cp.cFullInternetName );

    MWmiParameter    MulticastSupportEnabled(L"MulticastSupportEnabled");
    inputParameters.push_back( &MulticastSupportEnabled );
    MulticastSupportEnabled.setValue( p_clusterDataCopy->cp.multicastSupportEnabled );

    MWmiParameter    IGMPSupport(L"IGMPSupport");
    inputParameters.push_back( &IGMPSupport );
    IGMPSupport.setValue( p_clusterDataCopy->cp.igmpSupportEnabled );

    MWmiParameter    RemoteControlEnabled(L"RemoteControlEnabled");
    inputParameters.push_back( &RemoteControlEnabled );
    RemoteControlEnabled.setValue( p_clusterDataCopy->cp.remoteControlEnabled );

    MWmiParameter    Password(L"Password");
    inputParameters.push_back( &Password );
    Password.setValue( p_clusterDataCopy->cp.password );

    // host properties
    MWmiParameter    HostPriority(L"HostPriority");
    inputParameters.push_back( &HostPriority );
    HostPriority.setValue( p_clusterDataCopy->hosts[machineName].hp.hID );

    MWmiParameter    DedicatedIPAddress(L"DedicatedIPAddress");
    inputParameters.push_back( &DedicatedIPAddress );
    DedicatedIPAddress.setValue( p_clusterDataCopy->hosts[machineName].hp.hIP );

    MWmiParameter    DedicatedNetworkMask(L"DedicatedNetworkMask");
    inputParameters.push_back( &DedicatedNetworkMask );
    DedicatedNetworkMask.setValue( p_clusterDataCopy->hosts[machineName].hp.hSubnetMask );

    MWmiParameter    ClusterModeOnStart(L"ClusterModeOnStart");
    inputParameters.push_back( &ClusterModeOnStart );
    ClusterModeOnStart.setValue( p_clusterDataCopy->hosts[machineName].hp.initialClusterStateActive );

    // port rules
    vector<_bstr_t> portRulesVector;
    getPortRules( p_clusterData,
                  machineName,
                  portRulesVector );

    SAFEARRAY* portRulesArray;

    SAFEARRAYBOUND rgsabound[1];
    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = portRulesVector.size();
    portRulesArray = SafeArrayCreate( VT_BSTR, 1, rgsabound );

    LONG scount = 0;
    HRESULT hr;
    for( int i = 0; i < portRulesVector.size(); ++i )
    {
        scount = i;
        hr = SafeArrayPutElement( portRulesArray,
                                  &scount, 
                                  (wchar_t * ) portRulesVector[i] );
    }

    VARIANT portRulesVariant;
    portRulesVariant.vt = VT_ARRAY | VT_BSTR;
    portRulesVariant.parray = portRulesArray;

    MWmiParameter PortRules(L"PortRules");
    inputParameters.push_back( &PortRules );

    PortRules.setValue( portRulesVariant );

    //  output parameters which are of interest.
    //
    vector<MWmiParameter *> outputParameters;
    MWmiParameter    ReturnValue(L"ReturnValue");
    outputParameters.push_back( &ReturnValue );

    instanceStore[0].runMethod( L"BindAndConfigure",
                                inputParameters, 
                                outputParameters );
    
    return MNLBNetCfg_SUCCESS;
}


void 
MNLBNetCfg::getPortRules( const ClusterData* p_clusterData,
                          const _bstr_t&      myMachine,
                          vector<_bstr_t>& myPortRules )
{
    wchar_t portBuf[1000];
    wstring temp;
    WTokens tok;
    vector<wstring> tokens;
    
    map< long, PortDataELB>::iterator topELB;
    map< long, PortDataULB>::iterator topULB;
    map< long, PortDataD>::iterator topD;
    map< long, PortDataF>::iterator topF;

    wstring trafficToHandle;
    wstring affinity;

    for( topELB = p_clusterData->portELB.begin(); topELB != p_clusterData->portELB.end(); ++topELB )
    {
        if( (*topELB).second._trafficToHandle == MNLBPortRule::both )
        {
            trafficToHandle = L"Both";
        }
        else if( (*topELB).second._trafficToHandle == MNLBPortRule::tcp )
        {
            trafficToHandle = L"TCP";
        }
        else
        {
            trafficToHandle = L"UDP";
        }
        

        if( (*topELB).second._affinity == MNLBPortRule::single )
        {
            affinity = L"Single";
        }
        else if( (*topELB).second._affinity == MNLBPortRule::none )
        {
            affinity = L"None";
        }
        else
        {
            affinity = L"Class C";
        }
        
        wsprintf( portBuf, L"%d\t%d\t%s\tMultiple\t \tEqual\t%s\t", 
                  (*topELB).second._startPort, 
                  (*topELB).second._endPort, 
                  trafficToHandle.c_str(),
                  affinity.c_str() );

        myPortRules.push_back( portBuf );
    }

    for( topULB = p_clusterData->portULB.begin(); topULB != p_clusterData->portULB.end(); ++topULB )
    {
        if( (*topULB).second._trafficToHandle == MNLBPortRule::both )
        {
            trafficToHandle = L"Both";
        }
        else if( (*topULB).second._trafficToHandle == MNLBPortRule::tcp )
        {
            trafficToHandle = L"TCP";
        }
        else
        {
            trafficToHandle = L"UDP";
        }
        

        if( (*topULB).second._affinity == MNLBPortRule::single )
        {
            affinity = L"Single";
        }
        else if( (*topULB).second._affinity == MNLBPortRule::none )
        {
            affinity = L"None";
        }
        else
        {
            affinity = L"Class C";
        }

        int loadWeight = (*topULB).second.machineMapToLoadWeight[myMachine];
        
        wsprintf( portBuf, L"%d\t%d\t%s\tMultiple\t \t%d\t%s", 
                  (*topULB).second._startPort, 
                  (*topULB).second._endPort, 
                  trafficToHandle.c_str(),
                  loadWeight,
                  affinity.c_str() );

        myPortRules.push_back( portBuf );

    }

    for( topD = p_clusterData->portD.begin(); topD != p_clusterData->portD.end(); ++topD )
    {
        if( (*topD).second._trafficToHandle == MNLBPortRule::both )
        {
            trafficToHandle = L"Both";
        }
        else if( (*topD).second._trafficToHandle == MNLBPortRule::tcp )
        {
            trafficToHandle = L"TCP";
        }
        else
        {
            trafficToHandle = L"UDP";
        }
        wsprintf( portBuf, L"%d\t%d\t%s\tDisabled\t \t \t \t", 
                  (*topD).second._startPort, 
                  (*topD).second._endPort, 
                  trafficToHandle.c_str() );

        myPortRules.push_back( portBuf );
        
    }

    for( topF = p_clusterData->portF.begin(); topF != p_clusterData->portF.end(); ++topF )
    {
        if( (*topF).second._trafficToHandle == MNLBPortRule::both )
        {
            trafficToHandle = L"Both";
        }
        else if( (*topF).second._trafficToHandle == MNLBPortRule::tcp )
        {
            trafficToHandle = L"TCP";
        }
        else
        {
            trafficToHandle = L"UDP";
        }
        wsprintf( portBuf, L"%d\t%d\t%s\tSingle\t%d\t \t \t", 
                  (*topF).second._startPort, 
                  (*topF).second._endPort, 
                  trafficToHandle.c_str(),
                  (*topF).second.machineMapToPriority[ myMachine ] );


        myPortRules.push_back( portBuf );
        
    }
}


MNLBNetCfg::MNLBNetCfg_Error
MNLBNetCfg::modifyClusterProperties(const ClusterProperties* p_clusterProperties)
{

    MWmiObject machine( m_ip,
                        L"root\\microsoftnlb",
                        L"administrator",
                        L"" );

    vector<MWmiInstance> instanceStore;
    _bstr_t relPath = L"NlbsNic.FullName=\"" + m_fullNicName + "\"";
    machine.getSpecificInstance( L"NlbsNic",
                                 relPath,
                                 &instanceStore );

    // input parameters 
    //
    vector<MWmiParameter *> inputParameters;

    // cluster properties
    MWmiParameter    ClusterIPAddress(L"ClusterIPAddress");
    inputParameters.push_back( &ClusterIPAddress );
    ClusterIPAddress.setValue(p_clusterProperties->cIP);

    MWmiParameter    ClusterNetworkMask(L"ClusterNetworkMask");
    inputParameters.push_back( &ClusterNetworkMask );
    ClusterNetworkMask.setValue( p_clusterProperties->cSubnetMask );

    MWmiParameter    ClusterName(L"ClusterName");
    inputParameters.push_back( &ClusterName );
    ClusterName.setValue( p_clusterProperties->cFullInternetName );

    MWmiParameter    MulticastSupportEnabled(L"MulticastSupportEnabled");
    inputParameters.push_back( &MulticastSupportEnabled );
    MulticastSupportEnabled.setValue( p_clusterProperties->multicastSupportEnabled );

    MWmiParameter    IGMPSupport(L"IGMPSupport");
    inputParameters.push_back( &IGMPSupport );
    IGMPSupport.setValue( p_clusterProperties->igmpSupportEnabled );

    MWmiParameter    RemoteControlEnabled(L"RemoteControlEnabled");
    inputParameters.push_back( &RemoteControlEnabled );
    RemoteControlEnabled.setValue( p_clusterProperties->remoteControlEnabled );

    MWmiParameter    Password(L"Password");
    inputParameters.push_back( &Password );
    Password.setValue( p_clusterProperties->password );

    //  output parameters which are of interest.
    //
    vector<MWmiParameter *> outputParameters;
    MWmiParameter    ReturnValue(L"ReturnValue");
    outputParameters.push_back( &ReturnValue );

    instanceStore[0].runMethod( L"ModifyClusterProperties",
                                inputParameters, 
                                outputParameters );
    
    return MNLBNetCfg_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\nlbsprov\mnlbnetcfg.h ===
#ifndef _MNLBNETCFG_H
#define _MNLBNETCFG_H
//
// Copyright (c) Microsoft.  All Rights Reserved 
//
// THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF Microsoft.
// The copyright notice above does not evidence any
// actual or intended publication of such source code.
//
// OneLiner : MNLBNetCfg interface.
// DevUnit  : wlbstest
// Author   : Murtaza Hakim
//
// Description: 
// -----------

#include "MIPAddressAdmin.h"
#include "Common.h"
#include "MNLBUIData.h"

#include <comdef.h>
#include <iostream>
using namespace std;



// Include Files
class MNLBNetCfg
{
public:

    enum MNLBNetCfg_Error
    {
        MNLBNetCfg_SUCCESS  = 0,
        BOUND               = 4,
        UNBOUND             = 5,
        NO_SUCH_NIC         = 6,
        NO_NLB              = 7,
    };


    // constructor
    // for remote machine.
    MNLBNetCfg( const _bstr_t& iP,
                const _bstr_t& fullNicName );
                
    // for local 
    MNLBNetCfg( const _bstr_t& fullNicName );
    
    // bindAndConfigure
    MNLBNetCfg_Error
    bindAndConfigure( const ClusterData*    p_clusterData,
                      const _bstr_t&        machineName 
                      ); 

    // modifyClusterProperties
    MNLBNetCfg_Error
    modifyClusterProperties(const ClusterProperties* p_clusterProperties);

    // bind
    MNLBNetCfg_Error
    bind();

    // unbind nlb
    MNLBNetCfg_Error
    unbind(); 

    // is nlb bound?
    MNLBNetCfg_Error
    isBound(); 

    // add cluster ip
    MNLBNetCfg_Error
    addClusterIP( const _bstr_t& clusterIP,
                  const _bstr_t& subnet );

    // remove cluster ip
    MNLBNetCfg_Error
    removeClusterIP( const _bstr_t& clusterIP );

private:

    _bstr_t m_ip;
    _bstr_t m_fullNicName;

    void
    getPortRules( const ClusterData* p_clusterData,
                  const _bstr_t&      myMachine,
                  vector<_bstr_t>& myPortRules );

};

// ensure type safety

typedef class MNLBNetCfg MNLBNetCfg;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\nlbsprov\mnlbmachine.cpp ===
// Copyright (c)  Microsoft.  All rights reserved.
//
// This is unpublished source code of Microsoft.
// The copyright notice above does not evidence any
// actual or intended publication of such source code.

// OneLiner  :  Implementation of MNLBMachine
// DevUnit   :  wlbstest
// Author    :  Murtaza Hakim

// History:
// --------
// 
// Revised by : mhakim
// Date       : 02-09-01
// Reason     : clustersetting class no longer has igmpjoininterval
//              property.
//
// Revised by : mhakim
// Date       : 02-14-01
// Reason     : The order in which win2k and whistler settings
//              is done depends on previous state of cluster.

// include files
#include "MNLBMachine.h"
#include "MNLBExe.h"

#include "MTrace.h"
#include "MNicInfo.h"
#include "WTokens.h"

#include <iostream>

using namespace std;

// constructor
//
MNLBMachine::MNLBMachine( const _bstr_t&    ip,
                          const _bstr_t&    clusterIP )
        : mIP( ip ),
          mClusterIP( clusterIP ),
          p_machine( 0 )
{
    connectToMachine();
    TRACE(MTrace::INFO, L"mnlbmachine constructor\n");
}

// constructor for local machine
//
MNLBMachine::MNLBMachine( const _bstr_t&    clusterIP )
        : mIP( L"self" ),
          mClusterIP( clusterIP ), 
          p_machine( 0 )
{
    connectToMachine();
    TRACE(MTrace::INFO, L"mnlbmachine constructor\n");
}


// default constructor
// 
// note that default constructor is purposely left undefined.  
// NO one should be using it.  It is declared just for vector class usage.


// copy constructor
//
MNLBMachine::MNLBMachine(const MNLBMachine& objToCopy )
        : mIP( objToCopy.mIP ),
          mClusterIP( objToCopy.mClusterIP ),
          p_machine( auto_ptr<MWmiObject>( new MWmiObject( *objToCopy.p_machine ) ) )
{
    TRACE(MTrace::INFO, L"mnlbsmachine copy constructor\n");
}


// assignment operator
//
MNLBMachine&
MNLBMachine::operator=( const MNLBMachine& rhs )
{
    mIP = rhs.mIP;
    mClusterIP = rhs.mClusterIP;
    p_machine = auto_ptr<MWmiObject>( new MWmiObject( *rhs.p_machine ) );

    TRACE(MTrace::INFO, L"mnlbsmachine assignment operator\n");

    return *this;
}


// destructor
//
MNLBMachine::~MNLBMachine()
{
    TRACE(MTrace::INFO, L"mnlbsmachine destructor\n");
}

// getClusterProperties
//
MNLBMachine::MNLBMachine_Error
MNLBMachine::getClusterProperties( ClusterProperties* cp )
{
    // set parameters to get for win2k
    //
    vector<MWmiParameter* >   parameterStoreWin2k;

    MWmiParameter ClusterIPAddress(L"ClusterIPAddress");
    parameterStoreWin2k.push_back( &ClusterIPAddress );

    MWmiParameter ClusterNetworkMask(L"ClusterNetworkMask");
    parameterStoreWin2k.push_back( &ClusterNetworkMask );

    MWmiParameter ClusterName(L"ClusterName");
    parameterStoreWin2k.push_back( &ClusterName );

    MWmiParameter ClusteMACAddress(L"ClusterMACAddress");
    parameterStoreWin2k.push_back( &ClusteMACAddress );

    MWmiParameter MulticastSupportEnabled(L"MulticastSupportEnabled");
    parameterStoreWin2k.push_back( &MulticastSupportEnabled );

    MWmiParameter RemoteControlEnabled(L"RemoteControlEnabled");
    parameterStoreWin2k.push_back( &RemoteControlEnabled );

    // set parameters to get for whistler
    // these properties only present in whistler.
    //
    vector<MWmiParameter* >   parameterStoreWhistler;

    MWmiParameter IgmpSupport(L"IgmpSupport");
    parameterStoreWhistler.push_back( &IgmpSupport );

    MWmiParameter ClusterIPToMulticastIP(L"ClusterIPToMulticastIP");
    parameterStoreWhistler.push_back( &ClusterIPToMulticastIP );

    MWmiParameter MulticastIPAddress(L"MulticastIPAddress");
    parameterStoreWhistler.push_back( &MulticastIPAddress );

    // Edited( mhakim 02-09-01)
    // now no longer do we have any igmpjoininterval property.
    // 

    // MWmiParameter IgmpJoinInterval(L"IgmpJoinInterval");
    // parameterStoreWhistler.push_back( &IgmpJoinInterval );


    // get instances of clustersetting class.    
    //
    vector< MWmiInstance >    instanceStore;

    _bstr_t relPath = L"MicrosoftNLB_ClusterSetting.Name=\"" + mClusterIP + L":" + mHostID + L"\"";
        
    p_machine->getSpecificInstance( L"MicrosoftNLB_ClusterSetting",
                                    relPath,
                                    &instanceStore );

    // get win2k parameters
    instanceStore[0].getParameters( parameterStoreWin2k );

    // get whistler parameters
    bool machineIsWhistler = true;

    try
    {
        // this will fail on win2k
        // as adapterguid, igmpsupport etc are not present.
        instanceStore[0].getParameters( parameterStoreWhistler );
    }
    catch( _com_error e )
    {
        // maybe it was a win2k machine.  This exception is expected, thus catch.
        // for better safety, need to find exact error code returned and then only do the 
        // folllowing otherwise need to rethrow.
        //
        TRACE( MTrace::INFO, L"tried whistler operation on win2k, this is expected\n");
        machineIsWhistler = false;
    }

    cp->cIP = ClusterIPAddress.getValue();
    
    cp->cSubnetMask = ClusterNetworkMask.getValue();
            
    cp->cFullInternetName = ClusterName.getValue();
            
    cp->cNetworkAddress = ClusteMACAddress.getValue();
            
    cp->multicastSupportEnabled = MulticastSupportEnabled.getValue();
        
    cp->remoteControlEnabled  = RemoteControlEnabled.getValue();

    if( machineIsWhistler == true )
    {
        cp->igmpSupportEnabled = IgmpSupport.getValue();
                
        cp->clusterIPToMulticastIP = ClusterIPToMulticastIP.getValue();

        cp->multicastIPAddress = MulticastIPAddress.getValue();

        // Edited( mhakim 02-09-01)
        // now no longer do we have any igmpjoininterval property.
        // 

        // cp->igmpJoinInterval = IgmpJoinInterval.getValue();
    }

    return MNLBMachine_SUCCESS;
}    

// getHostProperties
//
MNLBMachine::MNLBMachine_Error
MNLBMachine::getHostProperties( HostProperties* hp )
{
    // get node properties
    //
    vector<MWmiParameter* >    parameterStoreWin2k;

    // the status code is to be got from the Node class.
    //
    MWmiParameter  StatusCode(L"StatusCode");
    parameterStoreWin2k.push_back( &StatusCode );    

    vector< MWmiInstance >    instanceStore;

    _bstr_t relPath = L"MicrosoftNLB_Node.Name=\"" + mClusterIP + L":" + mHostID + L"\"";

    p_machine->getSpecificInstance( L"MicrosoftNLB_Node",
                                    relPath,
                                    &instanceStore );
    instanceStore[0].getParameters( parameterStoreWin2k );

    hp->hostStatus = long( StatusCode.getValue() );

    parameterStoreWin2k.erase( parameterStoreWin2k.begin(), parameterStoreWin2k.end() );

    instanceStore.erase( instanceStore.begin(), instanceStore.end() );
    
    MWmiParameter  DedicatedIPAddress(L"DedicatedIPAddress");
    parameterStoreWin2k.push_back( &DedicatedIPAddress );

    MWmiParameter  DedicatedNetworkMask(L"DedicatedNetworkMask");
    parameterStoreWin2k.push_back( &DedicatedNetworkMask );

    MWmiParameter  HostPriority(L"HostPriority");
    parameterStoreWin2k.push_back( &HostPriority );

    MWmiParameter  ClusterModeOnStart(L"ClusterModeOnStart");
    parameterStoreWin2k.push_back( &ClusterModeOnStart );

    MWmiParameter Server("__Server");
    parameterStoreWin2k.push_back( &Server);

    // set parameters to get for whistler
    // these properties only present in whistler.
    //
    vector<MWmiParameter* >   parameterStoreWhistler;

    MWmiParameter AdapterGuid(L"AdapterGuid");
    parameterStoreWhistler.push_back( &AdapterGuid );


    // get instances of nodesetting class.
    //
    relPath = L"MicrosoftNLB_NodeSetting.Name=\"" + mClusterIP + L":" + mHostID + L"\"";
    p_machine->getSpecificInstance( L"MicrosoftNLB_NodeSetting",
                                    relPath,
                                    &instanceStore );

    // get win2k parameters.
    instanceStore[0].getParameters( parameterStoreWin2k );

    // get whistler parameters
    bool machineIsWhistler = true;

    try
    {
        // this will fail on win2k
        // as adapterguid, igmpsupport etc are not present.
        instanceStore[0].getParameters( parameterStoreWhistler );
    }
    catch( _com_error e )
    {
        // maybe it was a win2k machine.  This exception is expected, thus catch.
        // for better safety, need to find exact error code returned and then only do the 
        // folllowing otherwise need to rethrow.
        //
        TRACE( MTrace::INFO, L"tried whistler operation on win2k, this is expected\n");
        machineIsWhistler = false;
    }


    hp->hIP = DedicatedIPAddress.getValue();

    hp->hSubnetMask = DedicatedNetworkMask.getValue();
            
    hp->hID         = HostPriority.getValue();
            
    hp->initialClusterStateActive = ClusterModeOnStart.getValue();

    hp->machineName = Server.getValue();

    if( machineIsWhistler == true )
    {
        Common::getNLBNicInfoForWhistler( mIP,
                                          _bstr_t( AdapterGuid.getValue() ), 
                                          hp->nicInfo );
    }
    else
    {
        Common::getNLBNicInfoForWin2k(  mIP,
                                        hp->nicInfo );
    }

    return MNLBMachine_SUCCESS;
}


// setClusterProperties    
//
MNLBMachine::MNLBMachine_Error
MNLBMachine::setClusterProperties( const ClusterProperties& cp,
                                    unsigned long* retVal 
                                    )
{
    // set parameters to set for win2k
    vector<MWmiParameter* >   parameterStoreWin2k;

    MWmiParameter ClusterIPAddress(L"ClusterIPAddress");
    ClusterIPAddress.setValue( cp.cIP );
    parameterStoreWin2k.push_back( &ClusterIPAddress );
    

    MWmiParameter ClusterNetworkMask(L"ClusterNetworkMask");
    ClusterNetworkMask.setValue( cp.cSubnetMask );
    parameterStoreWin2k.push_back( &ClusterNetworkMask );

    MWmiParameter ClusterName(L"ClusterName");
    ClusterName.setValue( cp.cFullInternetName );
    parameterStoreWin2k.push_back( &ClusterName );

    // mac address cannot be set.

    MWmiParameter MulticastSupportEnabled(L"MulticastSupportEnabled");
    MulticastSupportEnabled.setValue( cp.multicastSupportEnabled );
    parameterStoreWin2k.push_back( &MulticastSupportEnabled );

    MWmiParameter RemoteControlEnabled(L"RemoteControlEnabled");
    RemoteControlEnabled.setValue( cp.remoteControlEnabled );
    parameterStoreWin2k.push_back( &RemoteControlEnabled );

    // set parameters for whistler.
    // these properties only for whistler
    vector<MWmiParameter* >   parameterStoreWhistler;

    MWmiParameter IgmpSupport(L"IgmpSupport");
    IgmpSupport.setValue( cp.igmpSupportEnabled );
    parameterStoreWhistler.push_back( &IgmpSupport );

    MWmiParameter ClusterIPToMulticastIP(L"ClusterIPToMulticastIP");
    ClusterIPToMulticastIP.setValue( cp.clusterIPToMulticastIP );
    parameterStoreWhistler.push_back( &ClusterIPToMulticastIP );

    MWmiParameter MulticastIPAddress(L"MulticastIPAddress");
    MulticastIPAddress.setValue( cp.multicastIPAddress );
    parameterStoreWhistler.push_back( &MulticastIPAddress );

    // Edited( mhakim 02-09-01)
    // now no longer do we have any igmpjoininterval property.
    // 

    // MWmiParameter IgmpJoinInterval(L"IgmpJoinInterval");
    // IgmpJoinInterval.setValue( cp.igmpJoinInterval );
    // parameterStoreWhistler.push_back( &IgmpJoinInterval );

    vector< MWmiInstance >    instanceStore;

    _bstr_t relPath = L"MicrosoftNLB_ClusterSetting.Name=\"" + mClusterIP + L":" + mHostID + L"\"";
    p_machine->getSpecificInstance( L"MicrosoftNLB_ClusterSetting",
                                    relPath,
                                    &instanceStore );

    // Edited( mhakim 02-14-01)
    //
    // The order in which win2k and whistler operations
    // need to be done depends on previous state of cluster.
    // If the previous mode of cluster was unicast, then
    // you have to do win2k first, whistler next.
    // If the previous mode was mcast+igmp you have to 
    // do whistler first, win2k next.
    // If the previous mode was mcast, the order does not
    // matter.
    // All this is because you cant have unicast+igmp 
    // together.

    // find previous cluster mode.
    ClusterProperties cpPrevious;
    getClusterProperties( &cpPrevious );

    if( cpPrevious.multicastSupportEnabled == false ) 
    {
        // mode is unicast

        // set win2k parameters.
        instanceStore[0].setParameters( parameterStoreWin2k );
        
        // set whistler parameters.
        try
        {
            instanceStore[0].setParameters( parameterStoreWhistler );
        }
        catch( _com_error e )
        {
            // maybe it was a win2k machine.  This exception is expected, thus catch.
            // For better safety, need to match error code returned with expected and then only do the 
            // folllowing otherwise need to rethrow.
            //
            TRACE( MTrace::INFO, L"tried whistler operation on win2k, this is expected\n");
        }
    }
    else
    {
        // set whistler parameters.
        try
        {
            instanceStore[0].setParameters( parameterStoreWhistler );
        }
        catch( _com_error e )
        {
            // maybe it was a win2k machine.  This exception is expected, thus catch.
            // For better safety, need to match error code returned with expected and then only do the 
            // folllowing otherwise need to rethrow.
            //
            TRACE( MTrace::INFO, L"tried whistler operation on win2k, this is expected\n");
        }

        // set win2k parameters.
        instanceStore[0].setParameters( parameterStoreWin2k );
    }

    // sync up the driver with these changes.
    reload( retVal );

    mClusterIP = cp.cIP;

    return MNLBMachine_SUCCESS;
}


// setHostProperties
//
MNLBMachine::MNLBMachine_Error
MNLBMachine::setHostProperties( const HostProperties& hp,
                                 unsigned long* retVal )
{
    // set node properties
    //
    vector<MWmiParameter* >    parameterStore;
    
    MWmiParameter  DedicatedIPAddress(L"DedicatedIPAddress");
    DedicatedIPAddress.setValue( hp.hIP );
    parameterStore.push_back( &DedicatedIPAddress );

    MWmiParameter  DedicatedNetworkMask(L"DedicatedNetworkMask");
    DedicatedNetworkMask.setValue( hp.hSubnetMask );
    parameterStore.push_back( &DedicatedNetworkMask );

    MWmiParameter  HostPriority(L"HostPriority");
    HostPriority.setValue( hp.hID );
    parameterStore.push_back( &HostPriority );

    MWmiParameter  ClusterModeOnStart(L"ClusterModeOnStart");
    ClusterModeOnStart.setValue( hp.initialClusterStateActive );
    parameterStore.push_back( &ClusterModeOnStart );

    // get instances of nodesetting class.
    //
    vector< MWmiInstance >     instanceStore;

    _bstr_t relPath = L"MicrosoftNLB_NodeSetting.Name=\"" + mClusterIP + L":" + mHostID + L"\"";
    p_machine->getSpecificInstance( L"MicrosoftNLB_NodeSetting",
                                    relPath,
                                    &instanceStore );

    instanceStore[0].setParameters( parameterStore );

    // convert hp.hID into string
    wchar_t hIDString[Common::BUF_SIZE];

    swprintf( hIDString, L"%d", hp.hID );
    
    // sync up the driver with these changes.
    reload( retVal );


    mHostID = hIDString;

    return MNLBMachine_SUCCESS;
}

// getPortRulesLoadBalanced
//
MNLBMachine::MNLBMachine_Error
MNLBMachine::getPortRulesLoadBalanced( vector<MNLBPortRuleLoadBalanced>* portsLB )
{
    vector<MWmiInstance> instanceStore;

    return getPortRulesLoadBalanced_private( portsLB, 
                                             &instanceStore );

}

// getPortRulesLoadBalanced_private
//
MNLBMachine::MNLBMachine_Error
MNLBMachine::getPortRulesLoadBalanced_private( vector<MNLBPortRuleLoadBalanced>* portsLB,
                                                vector<MWmiInstance>*          instances )
{
    _bstr_t myName = mClusterIP + L":" + mHostID;

    // get port properties.
    //
    vector<MWmiParameter* >    parameterStore;

    MWmiParameter   Name(L"Name");
    parameterStore.push_back( &Name );

    MWmiParameter   StartPort(L"StartPort");
    parameterStore.push_back( &StartPort );

    MWmiParameter EndPort(L"EndPort");
    parameterStore.push_back( &EndPort );

    MWmiParameter ProtocolProp(L"Protocol");
    parameterStore.push_back( &ProtocolProp );

    MWmiParameter EqualLoad(L"EqualLoad");
    parameterStore.push_back( &EqualLoad );

    MWmiParameter LoadWeight(L"LoadWeight");
    parameterStore.push_back( &LoadWeight );

    MWmiParameter AffinityProp(L"Affinity");
    parameterStore.push_back( &AffinityProp );    

    MNLBPortRule::Affinity    affinity;
    MNLBPortRule::Protocol    trafficToHandle;

    p_machine->getInstances( L"MicrosoftNLB_PortRuleLoadBalanced",
                             instances );
    for( int i = 0; i < instances->size(); ++i )
    {
        (*instances)[i].getParameters( parameterStore );
            
        if( _bstr_t( Name.getValue() ) != myName )
        {
            // this portrule is not for this cluster
            continue;
        }

        switch( long (ProtocolProp.getValue()) )
        {
            case 1:
                trafficToHandle = MNLBPortRule::tcp;
                break;

            case 2:
                trafficToHandle = MNLBPortRule::udp;
                break;

            case 3:
                trafficToHandle = MNLBPortRule::both;
                break;

            default:
                // bug.
                TRACE( MTrace::SEVERE_ERROR, "unidentified protocol\n" );
                throw _com_error( WBEM_E_UNEXPECTED );
                break;
        }


        switch(  long(AffinityProp.getValue()) )
        {
            case 0:
                affinity = MNLBPortRule::none;
                break;

            case 1:
                affinity = MNLBPortRule::single;
                break;

            case 2:
                affinity = MNLBPortRule::classC;
                break;

            default:
                // bug.
                TRACE( MTrace::SEVERE_ERROR, "unidentified affinity\n" );
                throw _com_error( WBEM_E_UNEXPECTED );
                break;
        }

                
        portsLB->push_back( MNLBPortRuleLoadBalanced(long (StartPort.getValue()),
                                                  long( EndPort.getValue()),
                                                  trafficToHandle,
                                                  bool( EqualLoad.getValue()),
                                                  long( LoadWeight.getValue()),
                                                  affinity) );
                                
    }

    return MNLBMachine_SUCCESS;
}


// getPortRulesFailover
//       
MNLBMachine::MNLBMachine_Error
MNLBMachine::getPortRulesFailover( vector<MNLBPortRuleFailover>* portsF )
{
    vector<MWmiInstance> instanceStore;

    return getPortRulesFailover_private( portsF, 
                                         &instanceStore );
}
    

// getPortRulesFailover_private
//
MNLBMachine::MNLBMachine_Error
MNLBMachine::getPortRulesFailover_private( vector<MNLBPortRuleFailover>* portsF,
                                            vector<MWmiInstance>*          instances )
{    
    _bstr_t myName = mClusterIP + L":" + mHostID;

    // get port properties.
    //
    vector<MWmiParameter* >    parameterStore;

    MWmiParameter   Name(L"Name");
    parameterStore.push_back( &Name );

    MWmiParameter   StartPort(L"StartPort");
    parameterStore.push_back( &StartPort );

    MWmiParameter EndPort(L"EndPort");
    parameterStore.push_back( &EndPort );

    MWmiParameter ProtocolProp(L"Protocol");
    parameterStore.push_back( &ProtocolProp );

    MWmiParameter Priority(L"Priority");
    parameterStore.push_back( &Priority );

    MNLBPortRule::Protocol    trafficToHandle;

    p_machine->getInstances( L"MicrosoftNLB_PortRuleFailover",
                             instances );

    for( int i = 0; i < instances->size(); ++i )
    {
        (*instances)[i].getParameters( parameterStore );
            
        if( _bstr_t( Name.getValue() ) != myName )
        {
            // this portrule is not for this cluster
            continue;
        }

        switch( long (ProtocolProp.getValue()) )
        {
            case 1:
                trafficToHandle = MNLBPortRule::tcp;
                break;

            case 2:
                trafficToHandle = MNLBPortRule::udp;
                break;

            case 3:
                trafficToHandle = MNLBPortRule::both;
                break;

            default:
                // bug.
                TRACE( MTrace::SEVERE_ERROR, "unidentified protocol\n" );
                throw _com_error( WBEM_E_UNEXPECTED );
                break;
        }

        portsF->push_back( MNLBPortRuleFailover(long (StartPort.getValue()),
                                             long( EndPort.getValue()),
                                             trafficToHandle,
                                             long( Priority.getValue()) )
                           );
    }

    return MNLBMachine_SUCCESS;
}


// getPortRulesDisabled
//
MNLBMachine::MNLBMachine_Error
MNLBMachine::getPortRulesDisabled( vector<MNLBPortRuleDisabled>* portsD )
{

    vector<MWmiInstance> instanceStore;

    return getPortRulesDisabled_private( portsD, 
                                         &instanceStore );

}    


// getPortRulesDisabled_private
//
MNLBMachine::MNLBMachine_Error
MNLBMachine::getPortRulesDisabled_private( vector<MNLBPortRuleDisabled>*         portsD,
                                            vector<MWmiInstance>*          instances )
{
    _bstr_t myName = mClusterIP + L":" + mHostID;

    // get port properties.
    //
    vector<MWmiParameter* >    parameterStore;

    MWmiParameter   Name(L"Name");
    parameterStore.push_back( &Name );

    MWmiParameter   StartPort(L"StartPort");
    parameterStore.push_back( &StartPort );

    MWmiParameter EndPort(L"EndPort");
    parameterStore.push_back( &EndPort );

    MWmiParameter ProtocolProp(L"Protocol");
    parameterStore.push_back( &ProtocolProp );

    MNLBPortRule::Protocol    trafficToHandle;

    p_machine->getInstances( L"MicrosoftNLB_PortRuleDisabled",
                             instances );
    for( int i = 0; i < instances->size(); ++i )
    {
        (*instances)[i].getParameters( parameterStore );
            
        if( _bstr_t( Name.getValue() ) != myName )
        {
            // this portrule is not for this cluster
            continue;
        }

        switch( long (ProtocolProp.getValue()) )
        {
            case 1:
                trafficToHandle = MNLBPortRule::tcp;
                break;

            case 2:
                trafficToHandle = MNLBPortRule::udp;
                break;

            case 3:
                trafficToHandle = MNLBPortRule::both;
                break;

            default:
                // bug.
                TRACE( MTrace::SEVERE_ERROR, "unidentified protocol\n" );
                throw _com_error( WBEM_E_UNEXPECTED );
                break;
        }

        portsD->push_back( MNLBPortRuleDisabled( long (StartPort.getValue() ),
                                              long( EndPort.getValue() ),
                                              trafficToHandle ) );
    }

    return MNLBMachine_SUCCESS;
}


// addPortRuleLoadBalanced
//
MNLBMachine::MNLBMachine_Error
MNLBMachine::addPortRuleLoadBalanced( const MNLBPortRuleLoadBalanced& portRuleLB )
{

    // set the name as "clusterip:hostid"
    _bstr_t str;
    str = mClusterIP + L":" + mHostID;

    vector<MWmiParameter *> instanceParameter;

    MWmiParameter  name(L"Name");
    name.setValue( str );
    instanceParameter.push_back( &name );

    MWmiParameter  sp(L"StartPort");
    sp.setValue( portRuleLB._startPort );
    instanceParameter.push_back( &sp );

    MWmiParameter  EndPort(L"EndPort");
    EndPort.setValue( portRuleLB._endPort );
    instanceParameter.push_back( &EndPort );

    long protocolValue;
    MWmiParameter  protocol(L"Protocol");
    switch( portRuleLB._trafficToHandle )
    {
        case MNLBPortRule::both:
            protocolValue = 3;
            protocol.setValue( protocolValue );
            break;
            
        case MNLBPortRule::tcp:
            protocolValue = 1;
            protocol.setValue( protocolValue );
            break;

        case MNLBPortRule::udp:
            protocolValue = 2;
            protocol.setValue( protocolValue );
            break;
                    
        default:
            // bug.
            TRACE( MTrace::SEVERE_ERROR, "unidentified protocol\n" );
            throw _com_error( WBEM_E_UNEXPECTED );
            break;
    }

    instanceParameter.push_back( &protocol );

    MWmiParameter  el(L"EqualLoad");
    el.setValue( portRuleLB._isEqualLoadBalanced );
    instanceParameter.push_back( &el );    

    MWmiParameter  lw(L"LoadWeight");
    lw.setValue( portRuleLB._load );
    instanceParameter.push_back( &lw );    

    MWmiParameter  affinity(L"Affinity");
    long affinityValue;
    switch(  portRuleLB._affinity )
    {
        case MNLBPortRule::none:
            affinityValue = 0;
            affinity.setValue(affinityValue);
            break;

        case MNLBPortRule::single:
            affinityValue = 1;
            affinity.setValue(affinityValue);
            break;

        case MNLBPortRule::classC:
            affinityValue = 2;
            affinity.setValue(affinityValue);
            break;

        default:
            // bug.
            TRACE( MTrace::SEVERE_ERROR, "unidentified affinity\n" );
            throw _com_error( WBEM_E_UNEXPECTED );
            break;
    }
    instanceParameter.push_back( &affinity );    

    p_machine->createInstance( L"MicrosoftNLB_PortRuleLoadBalanced",
                               instanceParameter
                               );
    // sync up the driver with these changes.
    unsigned long retVal;
    reload( &retVal );

    return MNLBMachine_SUCCESS;
}

// addPortRuleFailover
//
MNLBMachine::MNLBMachine_Error
MNLBMachine::addPortRuleFailover( const MNLBPortRuleFailover& portRuleF )
{

    // set the name as "clusterip:hostid"
    _bstr_t str;
    str = mClusterIP + L":" + mHostID;

    vector<MWmiParameter *> instanceParameter;

    MWmiParameter  name(L"Name");
    name.setValue( str );
    instanceParameter.push_back( &name );

    MWmiParameter  sp(L"StartPort");
    sp.setValue( portRuleF._startPort );
    instanceParameter.push_back( &sp );

    MWmiParameter  EndPort(L"EndPort");
    EndPort.setValue( portRuleF._endPort );
    instanceParameter.push_back( &EndPort );

    long protocolValue;
    MWmiParameter  protocol(L"Protocol");
    switch( portRuleF._trafficToHandle )
    {
        case MNLBPortRule::both:
            protocolValue = 3;
            protocol.setValue( protocolValue );
            break;
            
        case MNLBPortRule::tcp:
            protocolValue = 1;
            protocol.setValue( protocolValue );
            break;

        case MNLBPortRule::udp:
            protocolValue = 2;
            protocol.setValue( protocolValue );
            break;
                    
        default:
            TRACE( MTrace::SEVERE_ERROR, "unidentified protocol\n" );
            throw _com_error( WBEM_E_UNEXPECTED );
            break;
    }
    instanceParameter.push_back( &protocol );

    MWmiParameter p("Priority");
    p.setValue( portRuleF._priority);
    instanceParameter.push_back( &p );

    p_machine->createInstance( L"MicrosoftNLB_PortRuleFailover",
                               instanceParameter
                               );

    // sync up the driver with these changes.
    unsigned long retVal;
    reload( &retVal );

    return MNLBMachine_SUCCESS;
}


// addPortRuleDisabled
//
MNLBMachine::MNLBMachine_Error
MNLBMachine::addPortRuleDisabled( const MNLBPortRuleDisabled& portRuleD )
{

    // set the name as "clusterip:hostid"
    _bstr_t str;
    str = mClusterIP + L":" + mHostID;

    vector<MWmiParameter *> instanceParameter;

    MWmiParameter  name(L"Name");
    name.setValue( str );
    instanceParameter.push_back( &name );

    MWmiParameter  sp(L"StartPort");
    sp.setValue( portRuleD._startPort );
    instanceParameter.push_back( &sp );

    MWmiParameter  ep(L"EndPort");
    ep.setValue( portRuleD._endPort );
    instanceParameter.push_back( &ep );

    long protocolValue;
    MWmiParameter  protocol(L"Protocol");
    switch( portRuleD._trafficToHandle )
    {
        case MNLBPortRule::both:
            protocolValue = 3;
            protocol.setValue( protocolValue );
            break;
            
        case MNLBPortRule::tcp:
            protocolValue = 1;
            protocol.setValue( protocolValue );
            break;

        case MNLBPortRule::udp:
            protocolValue = 2;
            protocol.setValue( protocolValue );
            break;
                    
        default:
            // bug.
            TRACE( MTrace::SEVERE_ERROR, "unidentified protocol\n" );
            throw _com_error( WBEM_E_UNEXPECTED );
            break;
    }
    instanceParameter.push_back( &protocol );

    p_machine->createInstance( L"MicrosoftNLB_PortRuleDisabled",
                               instanceParameter
                               );

    // sync up the driver with these changes.
    unsigned long retVal;
    reload( &retVal );

    return MNLBMachine_SUCCESS;
}

// removePortRuleLoadBalanced
//
MNLBMachine::MNLBMachine_Error
MNLBMachine::removePortRuleLoadBalanced( const MNLBPortRuleLoadBalanced& portRuleLB )
{

    _bstr_t myName = mClusterIP + L":" + mHostID;

    wchar_t startPortBuffer[Common::BUF_SIZE];

    swprintf( startPortBuffer, L"%d", portRuleLB._startPort );

    vector<MWmiInstance >           instanceStorePortRuleLoadBalanced;
    _bstr_t relPath = L"MicrosoftNLB_PortRuleLoadBalanced.Name=\""  
        + mClusterIP + L":" + mHostID + L"\"" + L"," + L"StartPort=" + startPortBuffer;


    p_machine->getSpecificInstance( L"MicrosoftNlb_PortRuleLoadBalanced",
                                    relPath,
                                    &instanceStorePortRuleLoadBalanced );

    p_machine->deleteInstance( instanceStorePortRuleLoadBalanced[0] );

    // sync up the driver with these changes.
    unsigned long retVal;
    reload( &retVal );

    return MNLBMachine_SUCCESS;
}


// removePortRuleFailover
//
MNLBMachine::MNLBMachine_Error
MNLBMachine::removePortRuleFailover( const MNLBPortRuleFailover& portRuleF )
{
    _bstr_t myName = mClusterIP + L":" + mHostID;

    wchar_t startPortBuffer[Common::BUF_SIZE];

    swprintf( startPortBuffer, L"%d", portRuleF._startPort );

    vector<MWmiInstance >           instanceStorePortRuleFailover;
    _bstr_t relPath = L"MicrosoftNLB_PortRuleFailover.Name=\""  
        + mClusterIP + L":" + mHostID + L"\"" + L"," + L"StartPort=" + startPortBuffer;


    p_machine->getSpecificInstance( L"MicrosoftNlb_PortRuleFailover",
                                    relPath,
                                    &instanceStorePortRuleFailover );

    p_machine->deleteInstance( instanceStorePortRuleFailover[0] );

    // sync up the driver with these changes.
    unsigned long retVal;
    reload( &retVal );

    return MNLBMachine_SUCCESS;
}

// removePortRuleDisabled
//
MNLBMachine::MNLBMachine_Error
MNLBMachine::removePortRuleDisabled( const MNLBPortRuleDisabled& portRuleD )
{

    _bstr_t myName = mClusterIP + L":" + mHostID;

    wchar_t startPortBuffer[Common::BUF_SIZE];

    swprintf( startPortBuffer, L"%d", portRuleD._startPort );

    vector<MWmiInstance >           instanceStorePortRuleDisabled;
    _bstr_t relPath = L"MicrosoftNLB_PortRuleDisabled.Name=\""  
        + mClusterIP + L":" + mHostID + L"\"" + L"," + L"StartPort=" + startPortBuffer;


    p_machine->getSpecificInstance( L"MicrosoftNlb_PortRuleDisabled",
                                    relPath,
                                    &instanceStorePortRuleDisabled );

    p_machine->deleteInstance( instanceStorePortRuleDisabled[0] );

    // sync up the driver with these changes.
    unsigned long retVal;
    reload( &retVal );

    return MNLBMachine_SUCCESS;
}




// start
//
MNLBMachine::MNLBMachine_Error
MNLBMachine::start( int hostID, unsigned long* retVal )
{
    // get the specific instance to run method on.
    vector< MWmiInstance >  instanceStore;
    getInstanceToRunMethodOn( hostID, &instanceStore );

    MNLBExe::start( instanceStore[0], retVal );

    return MNLBMachine_SUCCESS;
}



// stop
//
MNLBMachine::MNLBMachine_Error
MNLBMachine::stop( int hostID, unsigned long* retVal )
{
    // get the specific instance to run method on.
    vector< MWmiInstance >  instanceStore;
    getInstanceToRunMethodOn( hostID, &instanceStore );

    MNLBExe::stop( instanceStore[0], retVal );

    return MNLBMachine_SUCCESS;
}


// resume
//
MNLBMachine::MNLBMachine_Error
MNLBMachine::resume( int hostID, unsigned long* retVal )
{
    // get the specific instance to run method on.
    vector< MWmiInstance >  instanceStore;
    getInstanceToRunMethodOn( hostID, &instanceStore );

    MNLBExe::resume( instanceStore[0], retVal );

    return MNLBMachine_SUCCESS;
}


// suspend
//
MNLBMachine::MNLBMachine_Error
MNLBMachine::suspend( int hostID, unsigned long* retVal )
{
    // get the specific instance to run method on.
    vector< MWmiInstance >  instanceStore;
    getInstanceToRunMethodOn( hostID, &instanceStore );

    MNLBExe::suspend( instanceStore[0], retVal );

    return MNLBMachine_SUCCESS;
}


// drainstop
//
MNLBMachine::MNLBMachine_Error
MNLBMachine::drainstop( int hostID, unsigned long* retVal )
{
    // get the specific instance to run method on.
    vector< MWmiInstance >  instanceStore;
    getInstanceToRunMethodOn( hostID, &instanceStore );

    MNLBExe::drainstop( instanceStore[0], retVal );

    return MNLBMachine_SUCCESS;
}


// disable
//
MNLBMachine::MNLBMachine_Error
MNLBMachine::disable( int hostID, unsigned long* retVal, unsigned long portToAffect )
{
    // get the specific instance to run method on.
    vector< MWmiInstance >  instanceStore;

    getInstanceToRunMethodOn( hostID, &instanceStore );

    MNLBExe::disable( instanceStore[0], retVal, portToAffect );

    return MNLBMachine_SUCCESS;
}


// enable
//
MNLBMachine::MNLBMachine_Error
MNLBMachine::enable( int hostID, unsigned long* retVal, unsigned long portToAffect )
{
    // get the specific instance to run method on.
    vector< MWmiInstance >  instanceStore;

    getInstanceToRunMethodOn( hostID, &instanceStore );

    MNLBExe::enable( instanceStore[0], retVal, portToAffect );

    return MNLBMachine_SUCCESS;
}


// drain
//
MNLBMachine::MNLBMachine_Error
MNLBMachine::drain( int hostID, unsigned long* retVal, unsigned long portToAffect )
{
    // get the specific instance to run method on.
    vector< MWmiInstance >  instanceStore;

    getInstanceToRunMethodOn( hostID, &instanceStore );

    MNLBExe::drain( instanceStore[0], retVal, portToAffect );

    return MNLBMachine_SUCCESS;
}


// reload
//
MNLBMachine::MNLBMachine_Error
MNLBMachine::reload( unsigned long* retVal )
{
    vector<MWmiInstance >           instanceStoreClusterSetting;
    _bstr_t relPath = L"MicrosoftNLB_ClusterSetting.Name=\"" + mClusterIP + L":" + mHostID + L"\"";
    p_machine->getSpecificInstance( L"MicrosoftNLB_ClusterSetting",
                                    relPath,
                                    &instanceStoreClusterSetting );

    // input parameters are none.
    //
    vector<MWmiParameter *> inputParameters;
            
    //  output parameters which are of interest.
    //
    vector<MWmiParameter *> outputParameters;
    MWmiParameter    returnValue(L"ReturnValue");
    outputParameters.push_back( &returnValue );
            
    instanceStoreClusterSetting[0].runMethod( L"LoadAllSettings",
                                              inputParameters,
                                              outputParameters );

    *retVal = ( long ) returnValue.getValue();

    return MNLBMachine_SUCCESS;
}    


// getInstanceToRunMethodOn
MNLBMachine::MNLBMachine_Error
MNLBMachine::getInstanceToRunMethodOn( int hID, vector <MWmiInstance>* instanceStore )
{
    vector<MWmiInstance> instanceStoreX;

    _bstr_t relPath;

    // see if we want to run clusterwide or host specific method.
    if( hID == Common::ALL_HOSTS )  
    {
        // cluster wide
        relPath = L"MicrosoftNLB_Cluster.Name=\"" + mClusterIP + L"\"";
        p_machine->getSpecificInstance( L"MicrosoftNLB_Cluster",
                                        relPath,
                                        &instanceStoreX );

        instanceStore->push_back( instanceStoreX[0] );
    }
    else if( hID == Common::THIS_HOST )
    {
        // this host specific
        relPath = L"MicrosoftNLB_Node.Name=\"" + mClusterIP + L":" + mHostID + L"\"";
        p_machine->getSpecificInstance( L"MicrosoftNLB_Node",
                                               relPath,
                                               &instanceStoreX );
        instanceStore->push_back( instanceStoreX[0] );

    }
    else
    { 
        // some other host

        // convert hID into string
        wchar_t hostIDBuf[1000];
        swprintf( hostIDBuf, L"%d", hID );

        relPath = L"MicrosoftNLB_Node.Name=\"" + mClusterIP + L":" + hostIDBuf + L"\"";
        p_machine->getSpecificInstance( L"MicrosoftNLB_Node",
                                               relPath,
                                               &instanceStoreX );

        instanceStore->push_back( instanceStoreX[0] );
    }
                
    return MNLBMachine_SUCCESS;
}
    
    
// refreshConnection
//
MNLBMachine::MNLBMachine_Error
MNLBMachine::refreshConnection()
{
    return connectToMachine();
}


// connectToMachine
//
MNLBMachine::MNLBMachine_Error
MNLBMachine::connectToMachine()
{
    MTrace* trace = MTrace::Instance();

    MTrace::TraceLevel prevLevel = trace->GetLevel();
    vector<HostProperties> hostPropertiesStore;

    // basically two operations need to succeed.
    // 1.  Is machine ip specified usable or not.
    // 2.  Is the nic specified bound to nlbs or not.
    //

    // connect to machine
    //
    if( mIP == _bstr_t( L"self")  )
    {
        // we want to connect to self machine.
        p_machine = auto_ptr< MWmiObject > ( new MWmiObject( L"root\\microsoftnlb") );
    }
    else if( mIP == mClusterIP )
    {
        // connecting to cluster remotely using cluster ip.  
        try
        {
            trace->SetLevel( MTrace::NO_TRACE );

            p_machine = auto_ptr<MWmiObject> ( new MWmiObject(  mIP,
                                                                L"root\\microsoftnlb",
                                                                L"Administrator",
                                                                L"" ) );
        }
        catch( _com_error e )
        {
            trace->SetLevel( prevLevel );
            TRACE(MTrace::INFO, L"connection using clusterip has failed\n" );
                    
            // Now we will be using api call wlbs query as situation may be that all hosts in cluster are stopped, and no connection
            // can be established to cluster ip, or there may be no such cluster and we will throw exception.
            //
            
            // get all hosts participating in cluster.
            DWORD ret = Common::getHostsInCluster( mClusterIP, &hostPropertiesStore );
            if( hostPropertiesStore.size() == 0 )
            {
                // no hosts are in this cluster.  Cannot proceed reliably.
                wstring errString;
                errString = L"cluster " +  wstring( mClusterIP ) + L" reported as having no hosts.  Maybe cluster ip is wrong, or remote control is turned off\n";
                TRACE( MTrace::SEVERE_ERROR, errString );

                throw _com_error( WBEM_E_NOT_FOUND );
            }

            // check if any host has dedicated ip not present
            // if this is so then object may not function reliably.
            bool allZero = true;
            int validHost;
            for( int i = 0; i < hostPropertiesStore.size(); ++i )
            {
                if( hostPropertiesStore[i].hIP == _bstr_t( L"0.0.0.0" ) )
                {
                    // host does not have valid dedicated ip.
                    TRACE( MTrace::SEVERE_ERROR, "a host has no dedicated ip.  Some object operations may not work as expected\n");
                }
                else
                {
                    // not all hosts have dedicated ip not filled in. 
                    // keep a track of this host.
                    allZero = false;
                    validHost = i;
                }
            }

            // check if all hosts had invalid dedicated ip.
            if( allZero == true )
            {
                // all hosts have dedicated ip invalid.
                TRACE( MTrace::SEVERE_ERROR, "all cluster hosts have dedicated ip 0.0.0.0\n");
                throw _com_error( WBEM_E_INVALID_PROPERTY );
            }
        
            p_machine = auto_ptr<MWmiObject>( new MWmiObject( hostPropertiesStore[validHost].hIP,
                                                              L"root\\microsoftnlb",
                                                              L"Administrator",
                                                              L"") );
        }
    }
    else
    {
        // we want to connect to remote machine.
        p_machine = auto_ptr<MWmiObject> ( new MWmiObject(  mIP,
                                                            L"root\\microsoftnlb",
                                                            L"Administrator",
                                                            L"" ) );
    }


    // check if specified cluster ip exists on this machine
    // and find the host id corresponding to this cluster on this machine.
    checkClusterIPAndSetHostID();

    return MNLBMachine_SUCCESS;
}

MNLBMachine::MNLBMachine_Error
MNLBMachine::checkClusterIPAndSetHostID()
{
    // set parameter to get.
    // we are interested in name.
    //
    vector<MWmiParameter* >   parameterStore;

    MWmiParameter Name(L"Name");
    parameterStore.push_back( &Name );

    // get instances of clustersetting class.    
    //
    vector< MWmiInstance >    instanceStore;
    bool found = false;
    int  i;

    p_machine->getInstances( L"Microsoftnlb_ClusterSetting",
                             &instanceStore );
    found = false;
    for( i = 0; i < instanceStore.size(); ++i )
    {
        instanceStore[i].getParameters( parameterStore );

        WTokens        tok;
        vector<wstring> tokens;
        tok.init( wstring( _bstr_t(Name.getValue()) ),
                  L":" );
        tokens = tok.tokenize();
            
        _bstr_t clusterIP = tokens[0].c_str();
        mHostID = tokens[1].c_str();

        if( mClusterIP == clusterIP )
        {
            // right object found
            found = true;
            break;
        }
    }
    
    if( found == false )
    {
        TRACE(
            MTrace::SEVERE_ERROR, 
            L"this machine does not have any cluster with specified cluster ip\n");
        throw _com_error( WBEM_E_NOT_FOUND );
    }

    return MNLBMachine_SUCCESS;
}


// getPresentHostsInfo
//
MNLBMachine::MNLBMachine_Error
MNLBMachine::getPresentHostsInfo( 
    vector< MNLBMachine::HostInfo >* hostInfoStore)
{
    vector<MWmiParameter* >   parameterStore;
    
    MWmiParameter  Name(L"Name");
    parameterStore.push_back( &Name );

    MWmiParameter  DedicatedIPAddress(L"DedicatedIPAddress");
    parameterStore.push_back( &DedicatedIPAddress );

    vector< MWmiInstance >    instanceStore;

    p_machine->getInstances( L"MicrosoftNLB_Node",
                             &instanceStore );
    for( int i = 0; i < instanceStore.size(); ++i )
    {
        instanceStore[i].getParameters( parameterStore );

        // Name is in format of "clusterIP:hostID"
        //
        WTokens        tok;
        vector<wstring> tokens;
        tok.init( wstring( _bstr_t(Name.getValue()) ),
                  L":" );
        tokens = tok.tokenize();
        _bstr_t clusterIP = tokens[0].c_str();

        if( mClusterIP == clusterIP )
        {
            HostInfo hostInfo;
            hostInfo.hostID = _wtoi( tokens[1].c_str() );
            hostInfo.dedicatedIP = DedicatedIPAddress.getValue();
            
            hostInfoStore->push_back( hostInfo );
        }
    }

    return MNLBMachine_SUCCESS;
}


// setPassword
//
MNLBMachine::MNLBMachine_Error
MNLBMachine::setPassword( const _bstr_t& password,
                          unsigned long* retVal 
                          )
{
    // form path
    _bstr_t relPath = L"MicrosoftNLB_ClusterSetting.Name=\"" + mClusterIP + L":" + mHostID + L"\"";

    vector<MWmiInstance >           instanceStoreClusterSetting;
    p_machine->getSpecificInstance( L"MicrosoftNLB_ClusterSetting",
                                    relPath,
                                    &instanceStoreClusterSetting );

    // input parameters is password
    //
    vector<MWmiParameter *> inputParameters;
    MWmiParameter    Password(L"Password");
    Password.setValue( password );
    inputParameters.push_back( &Password );
            
    // output parameters which are of interest.
    // none.
    //
    vector<MWmiParameter *> outputParameters;
            
    instanceStoreClusterSetting[0].runMethod( L"SetPassword",
                                              inputParameters,
                                              outputParameters );

    reload( retVal );

    return MNLBMachine_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\nlbsprov\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//	nlbmanager1.pch will be the pre-compiled header
//	stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

// TODO: reference any additional headers you need in STDAFX.H
// and not in this file
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\nlbsprov\stdafx.h ===
// stdafx.h : include file for standard system include files,
//  or project specific include files that are used frequently, but
//      are changed infrequently
//

#if !defined(AFX_STDAFX_H__4ABADA68_E961_4E94_80C9_36FC8222478E__INCLUDED_)
#define AFX_STDAFX_H__4ABADA68_E961_4E94_80C9_36FC8222478E__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define VC_EXTRALEAN		// Exclude rarely-used stuff from Windows headers

#include <afx.h>
#include <afxwin.h>         // MFC core and standard components
#include <afxext.h>         // MFC extensions
#include <afxcview.h>
#include <afxdisp.h>        // MFC Automation classes
#include <afxdtctl.h>		// MFC support for Internet Explorer 4 Common Controls
#include <comdef.h>
#include <wbemidl.h>

#ifndef _AFX_NO_AFXCMN_SUPPORT
#include <afxcmn.h>			// MFC support for Windows Common Controls
#endif // _AFX_NO_AFXCMN_SUPPORT

#include <iostream>

// TODO: reference additional headers your program requires here

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__4ABADA68_E961_4E94_80C9_36FC8222478E__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\nlbsprov\mnlbsetting.cpp ===
// Copyright (c)  Microsoft.  All rights reserved.
//
// This is unpublished source code of Microsoft.
// The copyright notice above does not evidence any
// actual or intended publication of such source code.

// OneLiner  :  Implementation of MNLBSetting
// DevUnit   :  wlbstest
// Author    :  Murtaza Hakim

// History:
// --------
// 
// Revised by : mhakim
// Date       : 02-09-01
// Reason     : clustersetting class no longer has igmpjoininterval
//              property.
//
// Revised by : mhakim
// Date       : 02-14-01
// Reason     : The order in which win2k and whistler settings
//              is done depends on previous state of cluster.


// include files
#include "MNLBSetting.h"
#include "MNLBExe.h"

#include "MTrace.h"
#include "MNicInfo.h"
#include "WTokens.h"

#include <iostream>

using namespace std;

// constructor
//
MNLBSetting::MNLBSetting( _bstr_t    ip,
                          _bstr_t    fullNICName )
        : mIP( ip ),
          nic( fullNICName ),
          p_machine( 0 )
{
    connectToMachine();
    TRACE(MTrace::INFO, L"mnlbssetting constructor\n");
}

// constructor for local machine
//
MNLBSetting::MNLBSetting( _bstr_t    fullNICName )
        : mIP( L"self" ),
          nic( fullNICName ),
          p_machine( 0 )
{
    connectToMachine();
    TRACE(MTrace::INFO, L"mnlbssetting constructor\n");
}


// default constructor
// 
// note that default constructor is purposely left undefined.  
// NO one should be using it.  It is declared just for vector class usage.


// copy constructor
//
MNLBSetting::MNLBSetting(const MNLBSetting& objToCopy )
        : mIP( objToCopy.mIP ),
          nic( objToCopy.nic ),
          p_machine( auto_ptr<MWmiObject>( new MWmiObject( *objToCopy.p_machine ) ) )
{
    TRACE(MTrace::INFO, L"mnlbssetting copy constructor\n");
}


// assignment operator
//
MNLBSetting&
MNLBSetting::operator=( const MNLBSetting& rhs )
{
    mIP = rhs.mIP;
    nic = rhs.nic;
    p_machine = auto_ptr<MWmiObject>( new MWmiObject( *rhs.p_machine ) );

    TRACE(MTrace::INFO, L"mnlbssetting assignment operator\n");

    return *this;
}


// destructor
//
MNLBSetting::~MNLBSetting()
{
    TRACE(MTrace::INFO, L"mnlbssetting destructor\n");
}

// getClusterProperties
//
MNLBSetting::MNLBSetting_Error
MNLBSetting::getClusterProperties( ClusterProperties* cp )
{
    _bstr_t clusterIP;
    _bstr_t hostID;

    getClusterIPAndHostID( clusterIP, hostID );

    // set parameters to get for win2k
    //
    vector<MWmiParameter* >   parameterStoreWin2k;

    MWmiParameter ClusterIPAddress(L"ClusterIPAddress");
    parameterStoreWin2k.push_back( &ClusterIPAddress );

    MWmiParameter ClusterNetworkMask(L"ClusterNetworkMask");
    parameterStoreWin2k.push_back( &ClusterNetworkMask );

    MWmiParameter ClusterName(L"ClusterName");
    parameterStoreWin2k.push_back( &ClusterName );

    MWmiParameter ClusteMACAddress(L"ClusterMACAddress");
    parameterStoreWin2k.push_back( &ClusteMACAddress );

    MWmiParameter MulticastSupportEnabled(L"MulticastSupportEnabled");
    parameterStoreWin2k.push_back( &MulticastSupportEnabled );

    MWmiParameter RemoteControlEnabled(L"RemoteControlEnabled");
    parameterStoreWin2k.push_back( &RemoteControlEnabled );

    // set parameters to get for whistler
    // these properties only present in whistler.
    //
    vector<MWmiParameter* >   parameterStoreWhistler;

    MWmiParameter IgmpSupport(L"IgmpSupport");
    parameterStoreWhistler.push_back( &IgmpSupport );

    MWmiParameter ClusterIPToMulticastIP(L"ClusterIPToMulticastIP");
    parameterStoreWhistler.push_back( &ClusterIPToMulticastIP );

    MWmiParameter MulticastIPAddress(L"MulticastIPAddress");
    parameterStoreWhistler.push_back( &MulticastIPAddress );

    // Edited( mhakim 02-09-01)
    // now no longer do we have any igmpjoininterval property.
    // 

    // MWmiParameter IgmpJoinInterval(L"IgmpJoinInterval");
    // parameterStoreWhistler.push_back( &IgmpJoinInterval );

    // get instances of clustersetting class.    
    //
    vector< MWmiInstance >    instanceStore;

    _bstr_t relPath = L"MicrosoftNLB_ClusterSetting.Name=\"" + clusterIP + L":" + hostID + L"\"";
    p_machine->getSpecificInstance( L"MicrosoftNLB_ClusterSetting",
                                    relPath,
                                    &instanceStore );

    // get win2k parameters
    instanceStore[0].getParameters( parameterStoreWin2k );

    // get whistler parameters
    bool machineIsWhistler = true;

    try
    {
        // this will fail on win2k
        // as adapterguid, igmpsupport etc are not present.
        instanceStore[0].getParameters( parameterStoreWhistler );
    }
    catch( _com_error e )
    {
        // maybe it was a win2k machine.  This exception is expected, thus catch.
        // for better safety, need to find exact error code returned and then only do the 
        // folllowing otherwise need to rethrow.
        //
        TRACE( MTrace::INFO, L"tried whistler operation on win2k, this is expected\n");
        machineIsWhistler = false;
    }

    cp->cIP = ClusterIPAddress.getValue();
    
    cp->cSubnetMask = ClusterNetworkMask.getValue();
            
    cp->cFullInternetName = ClusterName.getValue();
            
    cp->cNetworkAddress = ClusteMACAddress.getValue();
            
    cp->multicastSupportEnabled = MulticastSupportEnabled.getValue();
        
    cp->remoteControlEnabled  = RemoteControlEnabled.getValue();

    if( machineIsWhistler == true )
    {
        cp->igmpSupportEnabled = IgmpSupport.getValue();
                
        cp->clusterIPToMulticastIP = ClusterIPToMulticastIP.getValue();

        cp->multicastIPAddress = MulticastIPAddress.getValue();

        // Edited( mhakim 02-09-01)
        // now no longer do we have any igmpjoininterval property.
        // 

        // cp->igmpJoinInterval = IgmpJoinInterval.getValue();
    }

    return MNLBSetting_SUCCESS;
}    

// getHostProperties
//
// TODO: Code to find the nic guid remains to be added for win2k machines
//
MNLBSetting::MNLBSetting_Error
MNLBSetting::getHostProperties( HostProperties* hp )
{
    _bstr_t clusterIP;
    _bstr_t hostID;

    getClusterIPAndHostID( clusterIP, hostID );

    // get node properties
    //
    vector<MWmiParameter* >    parameterStoreWin2k;

    // the status code is to be got from the Node class.
    //
    MWmiParameter  StatusCode(L"StatusCode");
    parameterStoreWin2k.push_back( &StatusCode );    

    vector< MWmiInstance >    instanceStore;

    _bstr_t relPath = L"MicrosoftNLB_Node.Name=\"" + clusterIP + L":" + hostID + L"\"";

    p_machine->getSpecificInstance( L"MicrosoftNLB_Node",
                                    relPath,
                                    &instanceStore );
    instanceStore[0].getParameters( parameterStoreWin2k );

    hp->hostStatus = long( StatusCode.getValue() );

    parameterStoreWin2k.erase( parameterStoreWin2k.begin(), parameterStoreWin2k.end() );

    instanceStore.erase( instanceStore.begin(), instanceStore.end() );
    
    MWmiParameter  DedicatedIPAddress(L"DedicatedIPAddress");
    parameterStoreWin2k.push_back( &DedicatedIPAddress );

    MWmiParameter  DedicatedNetworkMask(L"DedicatedNetworkMask");
    parameterStoreWin2k.push_back( &DedicatedNetworkMask );

    MWmiParameter  HostPriority(L"HostPriority");
    parameterStoreWin2k.push_back( &HostPriority );

    MWmiParameter  ClusterModeOnStart(L"ClusterModeOnStart");
    parameterStoreWin2k.push_back( &ClusterModeOnStart );

    MWmiParameter Server("__Server");
    parameterStoreWin2k.push_back( &Server);

    // set parameters to get for whistler
    // these properties only present in whistler.
    //
    vector<MWmiParameter* >   parameterStoreWhistler;

    MWmiParameter AdapterGuid(L"AdapterGuid");
    parameterStoreWhistler.push_back( &AdapterGuid );


    // get instances of nodesetting class.
    //
    relPath = L"MicrosoftNLB_NodeSetting.Name=\"" + clusterIP + L":" + hostID + L"\"";
    p_machine->getSpecificInstance( L"MicrosoftNLB_NodeSetting",
                                    relPath,
                                    &instanceStore );

    // get win2k parameters.
    instanceStore[0].getParameters( parameterStoreWin2k );

    // get whistler parameters
    bool machineIsWhistler = true;

    try
    {
        // this will fail on win2k
        // as adapterguid, igmpsupport etc are not present.
        instanceStore[0].getParameters( parameterStoreWhistler );
    }
    catch( _com_error e )
    {
        // maybe it was a win2k machine.  This exception is expected, thus catch.
        // for better safety, need to find exact error code returned and then only do the 
        // folllowing otherwise need to rethrow.
        //
        TRACE( MTrace::INFO, L"tried whistler operation on win2k, this is expected\n");
        machineIsWhistler = false;
    }


    hp->hIP = DedicatedIPAddress.getValue();

    hp->hSubnetMask = DedicatedNetworkMask.getValue();
            
    hp->hID         = HostPriority.getValue();
            
    hp->initialClusterStateActive = ClusterModeOnStart.getValue();

    hp->machineName = Server.getValue();

    if( machineIsWhistler == true )
    {
        Common::getNLBNicInfoForWhistler( mIP,
                                          _bstr_t( AdapterGuid.getValue() ), 
                                          hp->nicInfo );
    }
    else
    {
        Common::getNLBNicInfoForWin2k(  mIP,
                                        hp->nicInfo );
    }

    return MNLBSetting_SUCCESS;
}


// setClusterProperties    
//
MNLBSetting::MNLBSetting_Error
MNLBSetting::setClusterProperties( const ClusterProperties& cp,
                                    unsigned long* retVal 
                                    )
{
    _bstr_t clusterIP;
    _bstr_t hostID;

    getClusterIPAndHostID( clusterIP, hostID );

    // set parameters to set for win2k
    vector<MWmiParameter* >   parameterStoreWin2k;

    MWmiParameter ClusterIPAddress(L"ClusterIPAddress");
    ClusterIPAddress.setValue( cp.cIP );
    parameterStoreWin2k.push_back( &ClusterIPAddress );
    

    MWmiParameter ClusterNetworkMask(L"ClusterNetworkMask");
    ClusterNetworkMask.setValue( cp.cSubnetMask );
    parameterStoreWin2k.push_back( &ClusterNetworkMask );

    MWmiParameter ClusterName(L"ClusterName");
    ClusterName.setValue( cp.cFullInternetName );
    parameterStoreWin2k.push_back( &ClusterName );

    // mac address cannot be set.

    MWmiParameter MulticastSupportEnabled(L"MulticastSupportEnabled");
    MulticastSupportEnabled.setValue( cp.multicastSupportEnabled );
    parameterStoreWin2k.push_back( &MulticastSupportEnabled );

    MWmiParameter RemoteControlEnabled(L"RemoteControlEnabled");
    RemoteControlEnabled.setValue( cp.remoteControlEnabled );
    parameterStoreWin2k.push_back( &RemoteControlEnabled );

    // set parameters for whistler.
    // these properties only for whistler
    vector<MWmiParameter* >   parameterStoreWhistler;

    MWmiParameter IgmpSupport(L"IgmpSupport");
    IgmpSupport.setValue( cp.igmpSupportEnabled );
    parameterStoreWhistler.push_back( &IgmpSupport );

    MWmiParameter ClusterIPToMulticastIP(L"ClusterIPToMulticastIP");
    ClusterIPToMulticastIP.setValue( cp.clusterIPToMulticastIP );
    parameterStoreWhistler.push_back( &ClusterIPToMulticastIP );

    MWmiParameter MulticastIPAddress(L"MulticastIPAddress");
    MulticastIPAddress.setValue( cp.multicastIPAddress );
    parameterStoreWhistler.push_back( &MulticastIPAddress );

    // Edited( mhakim 02-09-01)
    // now no longer do we have any igmpjoininterval property.
    // 

    // MWmiParameter IgmpJoinInterval(L"IgmpJoinInterval");
    // IgmpJoinInterval.setValue( cp.igmpJoinInterval );
    // parameterStoreWhistler.push_back( &IgmpJoinInterval );

    vector< MWmiInstance >    instanceStore;

    _bstr_t relPath = L"MicrosoftNLB_ClusterSetting.Name=\"" + clusterIP + L":" + hostID + L"\"";
    p_machine->getSpecificInstance( L"MicrosoftNLB_ClusterSetting",
                                    relPath,
                                    &instanceStore );

    // Edited( mhakim 02-14-01)
    //
    // The order in which win2k and whistler operations
    // need to be done depends on previous state of cluster.
    // If the previous mode of cluster was unicast, then
    // you have to do win2k first, whistler next.
    // If the previous mode was mcast+igmp you have to 
    // do whistler first, win2k next.
    // If the previous mode was mcast, the order does not
    // matter.
    // All this is because you cant have unicast+igmp 
    // together.

    // find previous cluster mode.
    ClusterProperties cpPrevious;
    getClusterProperties( &cpPrevious );

    if( cpPrevious.multicastSupportEnabled == false ) 
    {
        // mode is unicast

        // set win2k parameters.
        instanceStore[0].setParameters( parameterStoreWin2k );
        
        // set whistler parameters.
        try
        {
            instanceStore[0].setParameters( parameterStoreWhistler );
        }
        catch( _com_error e )
        {
            // maybe it was a win2k machine.  This exception is expected, thus catch.
            // For better safety, need to match error code returned with expected and then only do the 
            // folllowing otherwise need to rethrow.
            //
            TRACE( MTrace::INFO, L"tried whistler operation on win2k, this is expected\n");
        }
    }
    else
    {
        // set whistler parameters.
        try
        {
            instanceStore[0].setParameters( parameterStoreWhistler );
        }
        catch( _com_error e )
        {
            // maybe it was a win2k machine.  This exception is expected, thus catch.
            // For better safety, need to match error code returned with expected and then only do the 
            // folllowing otherwise need to rethrow.
            //
            TRACE( MTrace::INFO, L"tried whistler operation on win2k, this is expected\n");
        }

        // set win2k parameters.
        instanceStore[0].setParameters( parameterStoreWin2k );
    }

    // sync up the driver with these changes.
    reload( retVal );

    return MNLBSetting_SUCCESS;
}


// setHostProperties
//
MNLBSetting::MNLBSetting_Error
MNLBSetting::setHostProperties( const HostProperties& hp,
                                 unsigned long* retVal )
{
    _bstr_t clusterIP;
    _bstr_t hostID;

    getClusterIPAndHostID( clusterIP, hostID );

    // set node properties
    //
    vector<MWmiParameter* >    parameterStore;
    
    MWmiParameter  DedicatedIPAddress(L"DedicatedIPAddress");
    DedicatedIPAddress.setValue( hp.hIP );
    parameterStore.push_back( &DedicatedIPAddress );

    MWmiParameter  DedicatedNetworkMask(L"DedicatedNetworkMask");
    DedicatedNetworkMask.setValue( hp.hSubnetMask );
    parameterStore.push_back( &DedicatedNetworkMask );

    MWmiParameter  HostPriority(L"HostPriority");
    HostPriority.setValue( hp.hID );
    parameterStore.push_back( &HostPriority );

    MWmiParameter  ClusterModeOnStart(L"ClusterModeOnStart");
    ClusterModeOnStart.setValue( hp.initialClusterStateActive );
    parameterStore.push_back( &ClusterModeOnStart );

    // get instances of nodesetting class.
    //
    vector< MWmiInstance >     instanceStore;

    _bstr_t relPath = L"MicrosoftNLB_NodeSetting.Name=\"" + clusterIP + L":" + hostID + L"\"";
    p_machine->getSpecificInstance( L"MicrosoftNLB_NodeSetting",
                                    relPath,
                                    &instanceStore );

    instanceStore[0].setParameters( parameterStore );
    
    // sync up the driver with these changes.
    reload( retVal );

    return MNLBSetting_SUCCESS;
}

// getPortRulesLoadBalanced
//
MNLBSetting::MNLBSetting_Error
MNLBSetting::getPortRulesLoadBalanced( vector<MNLBPortRuleLoadBalanced>* portsLB )
{
    vector<MWmiInstance> instanceStore;

    return getPortRulesLoadBalanced_private( portsLB, 
                                             &instanceStore );

}

// getPortRulesLoadBalanced_private
//
MNLBSetting::MNLBSetting_Error
MNLBSetting::getPortRulesLoadBalanced_private( vector<MNLBPortRuleLoadBalanced>* portsLB,
                                                vector<MWmiInstance>*          instances )
{
    _bstr_t clusterIP;
    _bstr_t hostID;

    getClusterIPAndHostID( clusterIP, hostID );

    _bstr_t myName = clusterIP + L":" + hostID;

    // get port properties.
    //
    vector<MWmiParameter* >    parameterStore;

    MWmiParameter   Name(L"Name");
    parameterStore.push_back( &Name );

    MWmiParameter   StartPort(L"StartPort");
    parameterStore.push_back( &StartPort );

    MWmiParameter EndPort(L"EndPort");
    parameterStore.push_back( &EndPort );

    MWmiParameter ProtocolProp(L"Protocol");
    parameterStore.push_back( &ProtocolProp );

    MWmiParameter EqualLoad(L"EqualLoad");
    parameterStore.push_back( &EqualLoad );

    MWmiParameter LoadWeight(L"LoadWeight");
    parameterStore.push_back( &LoadWeight );

    MWmiParameter AffinityProp(L"Affinity");
    parameterStore.push_back( &AffinityProp );    

    MNLBPortRule::Affinity    affinity;
    MNLBPortRule::Protocol    trafficToHandle;

    p_machine->getInstances( L"MicrosoftNLB_PortRuleLoadBalanced",
                             instances );
    for( int i = 0; i < instances->size(); ++i )
    {
        (*instances)[i].getParameters( parameterStore );
            
        if( _bstr_t( Name.getValue() ) != myName )
        {
            // this portrule is not for this cluster
            continue;
        }

        switch( long (ProtocolProp.getValue()) )
        {
            case 1:
                trafficToHandle = MNLBPortRule::tcp;
                break;

            case 2:
                trafficToHandle = MNLBPortRule::udp;
                break;

            case 3:
                trafficToHandle = MNLBPortRule::both;
                break;

            default:
                // bug.
                TRACE( MTrace::SEVERE_ERROR, "unidentified protocol\n" );
                throw _com_error( WBEM_E_UNEXPECTED );
                break;
        }


        switch(  long(AffinityProp.getValue()) )
        {
            case 0:
                affinity = MNLBPortRule::none;
                break;

            case 1:
                affinity = MNLBPortRule::single;
                break;

            case 2:
                affinity = MNLBPortRule::classC;
                break;

            default:
                // bug.
                TRACE( MTrace::SEVERE_ERROR, "unidentified affinity\n" );
                throw _com_error( WBEM_E_UNEXPECTED );
                break;
        }

                
        portsLB->push_back( MNLBPortRuleLoadBalanced(long (StartPort.getValue()),
                                                  long( EndPort.getValue()),
                                                  trafficToHandle,
                                                  bool( EqualLoad.getValue()),
                                                  long( LoadWeight.getValue()),
                                                  affinity) );
                                
    }

    return MNLBSetting_SUCCESS;
}


// getPortRulesFailover
//       
MNLBSetting::MNLBSetting_Error
MNLBSetting::getPortRulesFailover( vector<MNLBPortRuleFailover>* portsF )
{
    vector<MWmiInstance> instanceStore;

    return getPortRulesFailover_private( portsF, 
                                         &instanceStore );
}
    

// getPortRulesFailover_private
//
MNLBSetting::MNLBSetting_Error
MNLBSetting::getPortRulesFailover_private( vector<MNLBPortRuleFailover>* portsF,
                                            vector<MWmiInstance>*          instances )
{    
    _bstr_t clusterIP;
    _bstr_t hostID;

    getClusterIPAndHostID( clusterIP, hostID );

    _bstr_t myName = clusterIP + L":" + hostID;

    // get port properties.
    //
    vector<MWmiParameter* >    parameterStore;

    MWmiParameter   Name(L"Name");
    parameterStore.push_back( &Name );

    MWmiParameter   StartPort(L"StartPort");
    parameterStore.push_back( &StartPort );

    MWmiParameter EndPort(L"EndPort");
    parameterStore.push_back( &EndPort );

    MWmiParameter ProtocolProp(L"Protocol");
    parameterStore.push_back( &ProtocolProp );

    MWmiParameter Priority(L"Priority");
    parameterStore.push_back( &Priority );

    MNLBPortRule::Protocol    trafficToHandle;

    p_machine->getInstances( L"MicrosoftNLB_PortRuleFailover",
                             instances );

    for( int i = 0; i < instances->size(); ++i )
    {
        (*instances)[i].getParameters( parameterStore );
            
        if( _bstr_t( Name.getValue() ) != myName )
        {
            // this portrule is not for this cluster
            continue;
        }

        switch( long (ProtocolProp.getValue()) )
        {
            case 1:
                trafficToHandle = MNLBPortRule::tcp;
                break;

            case 2:
                trafficToHandle = MNLBPortRule::udp;
                break;

            case 3:
                trafficToHandle = MNLBPortRule::both;
                break;

            default:
                // bug.
                TRACE( MTrace::SEVERE_ERROR, "unidentified protocol\n" );
                throw _com_error( WBEM_E_UNEXPECTED );
                break;
        }

        portsF->push_back( MNLBPortRuleFailover(long (StartPort.getValue()),
                                             long( EndPort.getValue()),
                                             trafficToHandle,
                                             long( Priority.getValue()) )
                           );
    }

    return MNLBSetting_SUCCESS;
}


// getPortRulesDisabled
//
MNLBSetting::MNLBSetting_Error
MNLBSetting::getPortRulesDisabled( vector<MNLBPortRuleDisabled>* portsD )
{

    vector<MWmiInstance> instanceStore;

    return getPortRulesDisabled_private( portsD, 
                                         &instanceStore );

}    


// getPortRulesDisabled_private
//
MNLBSetting::MNLBSetting_Error
MNLBSetting::getPortRulesDisabled_private( vector<MNLBPortRuleDisabled>*         portsD,
                                            vector<MWmiInstance>*          instances )
{
    _bstr_t clusterIP;
    _bstr_t hostID;

    getClusterIPAndHostID( clusterIP, hostID );

    _bstr_t myName = clusterIP + L":" + hostID;

    // get port properties.
    //
    vector<MWmiParameter* >    parameterStore;

    MWmiParameter   Name(L"Name");
    parameterStore.push_back( &Name );

    MWmiParameter   StartPort(L"StartPort");
    parameterStore.push_back( &StartPort );

    MWmiParameter EndPort(L"EndPort");
    parameterStore.push_back( &EndPort );

    MWmiParameter ProtocolProp(L"Protocol");
    parameterStore.push_back( &ProtocolProp );

    MNLBPortRule::Protocol    trafficToHandle;

    p_machine->getInstances( L"MicrosoftNLB_PortRuleDisabled",
                             instances );
    for( int i = 0; i < instances->size(); ++i )
    {
        (*instances)[i].getParameters( parameterStore );
            
        if( _bstr_t( Name.getValue() ) != myName )
        {
            // this portrule is not for this cluster
            continue;
        }

        switch( long (ProtocolProp.getValue()) )
        {
            case 1:
                trafficToHandle = MNLBPortRule::tcp;
                break;

            case 2:
                trafficToHandle = MNLBPortRule::udp;
                break;

            case 3:
                trafficToHandle = MNLBPortRule::both;
                break;

            default:
                // bug.
                TRACE( MTrace::SEVERE_ERROR, "unidentified protocol\n" );
                throw _com_error( WBEM_E_UNEXPECTED );
                break;
        }

        portsD->push_back( MNLBPortRuleDisabled( long (StartPort.getValue() ),
                                              long( EndPort.getValue() ),
                                              trafficToHandle ) );
    }

    return MNLBSetting_SUCCESS;
}


// addPortRuleLoadBalanced
//
MNLBSetting::MNLBSetting_Error
MNLBSetting::addPortRuleLoadBalanced( const MNLBPortRuleLoadBalanced& portRuleLB )
{
    _bstr_t clusterIP;
    _bstr_t hostID;

    getClusterIPAndHostID( clusterIP, hostID );

    // set the name as "clusterip:hostid"
    _bstr_t str;
    str = clusterIP + L":" + hostID;

    vector<MWmiParameter *> instanceParameter;

    MWmiParameter  name(L"Name");
    name.setValue( str );
    instanceParameter.push_back( &name );

    MWmiParameter  sp(L"StartPort");
    sp.setValue( portRuleLB._startPort );
    instanceParameter.push_back( &sp );

    MWmiParameter  EndPort(L"EndPort");
    EndPort.setValue( portRuleLB._endPort );
    instanceParameter.push_back( &EndPort );

    long protocolValue;
    MWmiParameter  protocol(L"Protocol");
    switch( portRuleLB._trafficToHandle )
    {
        case MNLBPortRule::both:
            protocolValue = 3;
            protocol.setValue( protocolValue );
            break;
            
        case MNLBPortRule::tcp:
            protocolValue = 1;
            protocol.setValue( protocolValue );
            break;

        case MNLBPortRule::udp:
            protocolValue = 2;
            protocol.setValue( protocolValue );
            break;
                    
        default:
            // bug.
            TRACE( MTrace::SEVERE_ERROR, "unidentified protocol\n" );
            throw _com_error( WBEM_E_UNEXPECTED );
            break;
    }

    instanceParameter.push_back( &protocol );

    MWmiParameter  el(L"EqualLoad");
    el.setValue( portRuleLB._isEqualLoadBalanced );
    instanceParameter.push_back( &el );    

    MWmiParameter  lw(L"LoadWeight");
    lw.setValue( portRuleLB._load );
    instanceParameter.push_back( &lw );    

    MWmiParameter  affinity(L"Affinity");
    long affinityValue;
    switch(  portRuleLB._affinity )
    {
        case MNLBPortRule::none:
            affinityValue = 0;
            affinity.setValue(affinityValue);
            break;

        case MNLBPortRule::single:
            affinityValue = 1;
            affinity.setValue(affinityValue);
            break;

        case MNLBPortRule::classC:
            affinityValue = 2;
            affinity.setValue(affinityValue);
            break;

        default:
            // bug.
            TRACE( MTrace::SEVERE_ERROR, "unidentified affinity\n" );
            throw _com_error( WBEM_E_UNEXPECTED );
            break;
    }
    instanceParameter.push_back( &affinity );    

    p_machine->createInstance( L"MicrosoftNLB_PortRuleLoadBalanced",
                               instanceParameter
                               );

    // sync up the driver with these changes.
    unsigned long retVal;
    reload( &retVal );

    return MNLBSetting_SUCCESS;
}

// addPortRuleFailover
//
MNLBSetting::MNLBSetting_Error
MNLBSetting::addPortRuleFailover( const MNLBPortRuleFailover& portRuleF )
{
    _bstr_t clusterIP;
    _bstr_t hostID;

    getClusterIPAndHostID( clusterIP, hostID );

    // set the name as "clusterip:hostid"
    _bstr_t str;
    str = clusterIP + L":" + hostID;

    vector<MWmiParameter *> instanceParameter;

    MWmiParameter  name(L"Name");
    name.setValue( str );
    instanceParameter.push_back( &name );

    MWmiParameter  sp(L"StartPort");
    sp.setValue( portRuleF._startPort );
    instanceParameter.push_back( &sp );

    MWmiParameter  EndPort(L"EndPort");
    EndPort.setValue( portRuleF._endPort );
    instanceParameter.push_back( &EndPort );

    long protocolValue;
    MWmiParameter  protocol(L"Protocol");
    switch( portRuleF._trafficToHandle )
    {
        case MNLBPortRule::both:
            protocolValue = 3;
            protocol.setValue( protocolValue );
            break;
            
        case MNLBPortRule::tcp:
            protocolValue = 1;
            protocol.setValue( protocolValue );
            break;

        case MNLBPortRule::udp:
            protocolValue = 2;
            protocol.setValue( protocolValue );
            break;
                    
        default:
            TRACE( MTrace::SEVERE_ERROR, "unidentified protocol\n" );
            throw _com_error( WBEM_E_UNEXPECTED );
            break;
    }
    instanceParameter.push_back( &protocol );

    MWmiParameter p("Priority");
    p.setValue( portRuleF._priority);
    instanceParameter.push_back( &p );

    p_machine->createInstance( L"MicrosoftNLB_PortRuleFailover",
                               instanceParameter
                               );

    // sync up the driver with these changes.
    unsigned long retVal;
    reload( &retVal );

    return MNLBSetting_SUCCESS;
}


// addPortRuleDisabled
//
MNLBSetting::MNLBSetting_Error
MNLBSetting::addPortRuleDisabled( const MNLBPortRuleDisabled& portRuleD )
{
    _bstr_t clusterIP;
    _bstr_t hostID;

    getClusterIPAndHostID( clusterIP, hostID );

    // set the name as "clusterip:hostid"
    _bstr_t str;
    str = clusterIP + L":" + hostID;

    vector<MWmiParameter *> instanceParameter;

    MWmiParameter  name(L"Name");
    name.setValue( str );
    instanceParameter.push_back( &name );

    MWmiParameter  sp(L"StartPort");
    sp.setValue( portRuleD._startPort );
    instanceParameter.push_back( &sp );

    MWmiParameter  ep(L"EndPort");
    ep.setValue( portRuleD._endPort );
    instanceParameter.push_back( &ep );

    long protocolValue;
    MWmiParameter  protocol(L"Protocol");
    switch( portRuleD._trafficToHandle )
    {
        case MNLBPortRule::both:
            protocolValue = 3;
            protocol.setValue( protocolValue );
            break;
            
        case MNLBPortRule::tcp:
            protocolValue = 1;
            protocol.setValue( protocolValue );
            break;

        case MNLBPortRule::udp:
            protocolValue = 2;
            protocol.setValue( protocolValue );
            break;
                    
        default:
            // bug.
            TRACE( MTrace::SEVERE_ERROR, "unidentified protocol\n" );
            throw _com_error( WBEM_E_UNEXPECTED );
            break;
    }
    instanceParameter.push_back( &protocol );

    p_machine->createInstance( L"MicrosoftNLB_PortRuleDisabled",
                               instanceParameter
                               );

    // sync up the driver with these changes.
    unsigned long retVal;
    reload( &retVal );

    return MNLBSetting_SUCCESS;
}

// removePortRuleLoadBalanced
//
MNLBSetting::MNLBSetting_Error
MNLBSetting::removePortRuleLoadBalanced( const MNLBPortRuleLoadBalanced& portRuleLB )
{
    _bstr_t clusterIP;
    _bstr_t hostID;

    getClusterIPAndHostID( clusterIP, hostID );

    _bstr_t myName = clusterIP + L":" + hostID;

    wchar_t startPortBuffer[Common::BUF_SIZE];

    swprintf( startPortBuffer, L"%d", portRuleLB._startPort );

    vector<MWmiInstance >           instanceStorePortRuleLoadBalanced;
    _bstr_t relPath = L"MicrosoftNLB_PortRuleLoadBalanced.Name=\""  
        + clusterIP + L":" + hostID + L"\"" + L"," + L"StartPort=" + startPortBuffer;


    p_machine->getSpecificInstance( L"MicrosoftNlb_PortRuleLoadBalanced",
                                    relPath,
                                    &instanceStorePortRuleLoadBalanced );

    p_machine->deleteInstance( instanceStorePortRuleLoadBalanced[0] );

    // sync up the driver with these changes.
    unsigned long retVal;
    reload( &retVal );

    return MNLBSetting_SUCCESS;
}


// removePortRuleFailover
//
MNLBSetting::MNLBSetting_Error
MNLBSetting::removePortRuleFailover( const MNLBPortRuleFailover& portRuleF )
{
    _bstr_t clusterIP;
    _bstr_t hostID;

    getClusterIPAndHostID( clusterIP, hostID );

    _bstr_t myName = clusterIP + L":" + hostID;

    wchar_t startPortBuffer[Common::BUF_SIZE];

    swprintf( startPortBuffer, L"%d", portRuleF._startPort );

    vector<MWmiInstance >           instanceStorePortRuleFailover;
    _bstr_t relPath = L"MicrosoftNLB_PortRuleFailover.Name=\""  
        + clusterIP + L":" + hostID + L"\"" + L"," + L"StartPort=" + startPortBuffer;


    p_machine->getSpecificInstance( L"MicrosoftNlb_PortRuleFailover",
                                    relPath,
                                    &instanceStorePortRuleFailover );

    p_machine->deleteInstance( instanceStorePortRuleFailover[0] );

    // sync up the driver with these changes.
    unsigned long retVal;
    reload( &retVal );

    return MNLBSetting_SUCCESS;
}

// removePortRuleDisabled
//
MNLBSetting::MNLBSetting_Error
MNLBSetting::removePortRuleDisabled( const MNLBPortRuleDisabled& portRuleD )
{
    _bstr_t clusterIP;
    _bstr_t hostID;

    getClusterIPAndHostID( clusterIP, hostID );

    _bstr_t myName = clusterIP + L":" + hostID;

    wchar_t startPortBuffer[Common::BUF_SIZE];

    swprintf( startPortBuffer, L"%d", portRuleD._startPort );

    vector<MWmiInstance >           instanceStorePortRuleDisabled;
    _bstr_t relPath = L"MicrosoftNLB_PortRuleDisabled.Name=\""  
        + clusterIP + L":" + hostID + L"\"" + L"," + L"StartPort=" + startPortBuffer;


    p_machine->getSpecificInstance( L"MicrosoftNlb_PortRuleDisabled",
                                    relPath,
                                    &instanceStorePortRuleDisabled );

    p_machine->deleteInstance( instanceStorePortRuleDisabled[0] );

    // sync up the driver with these changes.
    unsigned long retVal;
    reload( &retVal );
    return MNLBSetting_SUCCESS;
}


// start
//
MNLBSetting::MNLBSetting_Error
MNLBSetting::start( int hostID, unsigned long* retVal )
{
    // get the specific instance to run method on.
    vector< MWmiInstance >  instanceStore;
    getInstanceToRunMethodOn( hostID, &instanceStore );

    MNLBExe::start( instanceStore[0], retVal );

    return MNLBSetting_SUCCESS;
}



// stop
//
MNLBSetting::MNLBSetting_Error
MNLBSetting::stop( int hostID, unsigned long* retVal )
{
    // get the specific instance to run method on.
    vector< MWmiInstance >  instanceStore;
    getInstanceToRunMethodOn( hostID, &instanceStore );

    MNLBExe::stop( instanceStore[0], retVal );

    return MNLBSetting_SUCCESS;
}


// resume
//
MNLBSetting::MNLBSetting_Error
MNLBSetting::resume( int hostID, unsigned long* retVal )
{
    // get the specific instance to run method on.
    vector< MWmiInstance >  instanceStore;
    getInstanceToRunMethodOn( hostID, &instanceStore );

    MNLBExe::resume( instanceStore[0], retVal );

    return MNLBSetting_SUCCESS;
}


// suspend
//
MNLBSetting::MNLBSetting_Error
MNLBSetting::suspend( int hostID, unsigned long* retVal )
{
    // get the specific instance to run method on.
    vector< MWmiInstance >  instanceStore;
    getInstanceToRunMethodOn( hostID, &instanceStore );

    MNLBExe::suspend( instanceStore[0], retVal );

    return MNLBSetting_SUCCESS;
}


// drainstop
//
MNLBSetting::MNLBSetting_Error
MNLBSetting::drainstop( int hostID, unsigned long* retVal )
{
    // get the specific instance to run method on.
    vector< MWmiInstance >  instanceStore;
    getInstanceToRunMethodOn( hostID, &instanceStore );

    MNLBExe::drainstop( instanceStore[0], retVal );

    return MNLBSetting_SUCCESS;
}


// disable
//
MNLBSetting::MNLBSetting_Error
MNLBSetting::disable( int hostID, unsigned long* retVal, unsigned long portToAffect )
{
    // get the specific instance to run method on.
    vector< MWmiInstance >  instanceStore;

    getInstanceToRunMethodOn( hostID, &instanceStore );

    MNLBExe::disable( instanceStore[0], retVal, portToAffect );

    return MNLBSetting_SUCCESS;
}


// enable
//
MNLBSetting::MNLBSetting_Error
MNLBSetting::enable( int hostID, unsigned long* retVal, unsigned long portToAffect )
{
    // get the specific instance to run method on.
    vector< MWmiInstance >  instanceStore;

    getInstanceToRunMethodOn( hostID, &instanceStore );

    MNLBExe::enable( instanceStore[0], retVal, portToAffect );

    return MNLBSetting_SUCCESS;
}


// drain
//
MNLBSetting::MNLBSetting_Error
MNLBSetting::drain( int hostID, unsigned long* retVal, unsigned long portToAffect )
{
    // get the specific instance to run method on.
    vector< MWmiInstance >  instanceStore;

    getInstanceToRunMethodOn( hostID, &instanceStore );

    MNLBExe::drain( instanceStore[0], retVal, portToAffect );

    return MNLBSetting_SUCCESS;
}




// getInstanceToRunMethodOn
MNLBSetting::MNLBSetting_Error
MNLBSetting::getInstanceToRunMethodOn( int hID, vector <MWmiInstance>* instanceStore )
{
    _bstr_t clusterIP;
    _bstr_t hostID;

    getClusterIPAndHostID( clusterIP, hostID );

    vector<MWmiInstance> instanceStoreX;

    _bstr_t relPath;

    // see if we want to run clusterwide or host specific method.
    if( hID == Common::ALL_HOSTS )  
    {
        // cluster wide
        relPath = L"MicrosoftNLB_Cluster.Name=\"" + clusterIP + L"\"";
        p_machine->getSpecificInstance( L"MicrosoftNLB_Cluster",
                                               relPath,
                                               &instanceStoreX );

        instanceStore->push_back( instanceStoreX[0] );
    }
    else if( hID == Common::THIS_HOST )
    {
        // this host specific
        relPath = L"MicrosoftNLB_Node.Name=\"" + clusterIP + L":" + hostID + L"\"";
        p_machine->getSpecificInstance( L"MicrosoftNLB_Node",
                                               relPath,
                                               &instanceStoreX );
        instanceStore->push_back( instanceStoreX[0] );

    }
    else
    { 
        // some other host

        // convert hID into string
        wchar_t hostIDBuf[1000];
        swprintf( hostIDBuf, L"%d", hID );

        relPath = L"MicrosoftNLB_Node.Name=\"" + clusterIP + L":" + hostIDBuf + L"\"";
        p_machine->getSpecificInstance( L"MicrosoftNLB_Node",
                                               relPath,
                                               &instanceStoreX );

        instanceStore->push_back( instanceStoreX[0] );
    }
                
    return MNLBSetting_SUCCESS;
}
    
    
// refreshConnection
//
MNLBSetting::MNLBSetting_Error
MNLBSetting::refreshConnection()
{
    return connectToMachine();
}


// getClusterIPAndHostID
//
MNLBSetting::MNLBSetting_Error
MNLBSetting::getClusterIPAndHostID( _bstr_t& clusterIP,
                                     _bstr_t& hostID )
{
    //
    // this ensures that nic is present, and bound to nlbs 
    // on nic specified at construction time.
    //
    _bstr_t guid;
    checkNicBinding( guid );

    //
    // find clustersettingclass mapping to this nic.
    //

    // set parameters to get.
    //
    vector<MWmiParameter* >   parameterStore;

    MWmiParameter Name(L"Name");
    parameterStore.push_back( &Name );

    // get guid
    // This parameter not present on win2k nlbs provider.
    //
    MWmiParameter AdapterGuid(L"AdapterGuid");
    parameterStore.push_back( &AdapterGuid );

    // get instances of clustersetting class.    
    //
    vector< MWmiInstance >    instanceStore;
    bool found = false;
    int  i;

    p_machine->getInstances( L"Microsoftnlb_ClusterSetting",
                             &instanceStore );
    found = false;
    for( i = 0; i < instanceStore.size(); ++i )
    {
        try
        {
            instanceStore[i].getParameters( parameterStore );
        }
        catch( _com_error e )
        {
            // the above operation can fail on win2k machines.
            // if so we need to handle exception. This clustersetting is the actual one 
            // required.
            found = true;
            break;  // get out of for loop.
        }

        if( guid == _bstr_t( AdapterGuid.getValue() ) )
        {
            // right object found
            found = true;
            break;
        }
    }

    
    if( found == false )
    {
        TRACE(MTrace::SEVERE_ERROR, L"this is unexpected and a bug.  NlbsNic and ClusterSetting class guids may not be matching\n");
        throw _com_error( WBEM_E_UNEXPECTED );
    }

    _bstr_t name = _bstr_t( Name.getValue() );

    WTokens        tok;
    vector<wstring> tokens;
    tok.init( wstring( name ),
              L":" );
    tokens = tok.tokenize();
            
    clusterIP = tokens[0].c_str();
    hostID = tokens[1].c_str();

    return MNLBSetting_SUCCESS;
}


// connectToMachine
//
MNLBSetting::MNLBSetting_Error
MNLBSetting::connectToMachine()
{
    // basically two operations need to succeed.
    // 1.  Is machine ip specified usable or not.
    // 2.  Is the nic specified bound to nlbs or not.
    //

    // connect to machine
    //
    if( mIP != _bstr_t(L"self" ) )
    {
        // we want to connect to remote machine.
        p_machine = auto_ptr<MWmiObject> ( new MWmiObject(  mIP,
                                                            L"root\\microsoftnlb",
                                                            L"Administrator",
                                                            L"" ) );
    }
    else
    {
        // we want to connect to self machine.
        p_machine = auto_ptr< MWmiObject > ( new MWmiObject( L"root\\microsoftnlb") );
    }

    // check if nic is bound to nlbs.
    _bstr_t guid;
    checkNicBinding( guid );

    return MNLBSetting_SUCCESS;
}


// checkNicBinding
//
MNLBSetting::MNLBSetting_Error
MNLBSetting::checkNicBinding( _bstr_t& guid ) 
{
#if 0

    bool found = false;

    //
    //  check if nic with the full name provided exists on the machine.
    //  and it has nlbs bound
    //

    // get all nics on the machine.
    vector<MWmiInstance> instanceStoreNlbsNic;

    p_machine->getInstances( L"NlbsNic",
                             &instanceStoreNlbsNic );

    // get adapterguid and fullname for each nic
    vector<MWmiParameter* >    parameterStoreNlbsNic;

    MWmiParameter Guid(L"Guid"); 
    parameterStoreNlbsNic.push_back( &Guid );

    MWmiParameter FullName(L"FullName"); 
    parameterStoreNlbsNic.push_back( &FullName );

    for( int i = 0; i < instanceStoreNlbsNic.size(); ++i )
    {
        instanceStoreNlbsNic[i].getParameters( parameterStoreNlbsNic );

        if( _bstr_t( FullName.getValue() ) == nic )
        {
            // nic specified has been found.

            // set input parameters.  There are no parameters
            vector<MWmiParameter *>    inputParameters;

            // set output parameters
            vector<MWmiParameter *>    outputParameters;
            MWmiParameter ReturnValue(L"ReturnValue");
            outputParameters.push_back( &ReturnValue );

            // now check if bound to nlbs.
            instanceStoreNlbsNic[i].runMethod(L"IsBound",
                                              inputParameters,
                                              outputParameters );
            if( long( ReturnValue.getValue() ) != 1 )
            {
                // nic is not bound to nlbs.
                TRACE(MTrace::SEVERE_ERROR, L"nic specified does not have nlbs bound, or some other problem\n");
                throw _com_error( WBEM_E_NOT_FOUND );
            }

            // get the guid for the nic.
            guid = _bstr_t( Guid.getValue() );

            found = true;
            break;
        }
    }

    // check if nic specified was found or not.
    if( found != true )
    {
        // nic specified not found.
        TRACE(MTrace::SEVERE_ERROR, L"nic specified not found on machine\n");
        throw _com_error( WBEM_E_NOT_FOUND );
    }

#else

    bool found = false;
    // 4. check if nic with the full name provided exists on the machine.
    vector< MNicInfo::Info>    nicList;

    if( mIP != _bstr_t(L"self" ) )
    {
        MNicInfo::getNicInfo( mIP,
                              &nicList );
    }
    else
    {
        MNicInfo::getNicInfo( &nicList );
    }
    
    for( int i = 0; i < nicList.size(); ++i )
    {
        if( nicList[i].nicFullName == nic )
        {
            // nic specified found.
            guid = nicList[i].guid;
            found = true;
            break;
        }
    }

    if( found != true )
    {
        TRACE(MTrace::SEVERE_ERROR, L"nic specified not found on machine\n");
        throw _com_error( WBEM_E_NOT_FOUND );
    }

#endif
    return MNLBSetting_SUCCESS;
}


// reload
//
MNLBSetting::MNLBSetting_Error
MNLBSetting::reload( unsigned long* retVal )
{


    _bstr_t clusterIP;
    _bstr_t hostID;

    getClusterIPAndHostID( clusterIP, hostID );

    // form path
    _bstr_t relPath = L"MicrosoftNLB_ClusterSetting.Name=\"" + clusterIP + L":" + hostID + L"\"";

    vector<MWmiInstance >           instanceStoreClusterSetting;
    p_machine->getSpecificInstance( L"MicrosoftNLB_ClusterSetting",
                                    relPath,
                                    &instanceStoreClusterSetting );

    // input parameters are none.
    //
    vector<MWmiParameter *> inputParameters;
            
    //  output parameters which are of interest.
    //
    vector<MWmiParameter *> outputParameters;
    MWmiParameter    returnValue(L"ReturnValue");
    outputParameters.push_back( &returnValue );
            
    instanceStoreClusterSetting[0].runMethod( L"LoadAllSettings",
                                              inputParameters,
                                              outputParameters );

    *retVal = ( long ) returnValue.getValue();

    return MNLBSetting_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\nlbsprov\mnlbportrule.cpp ===
// Copyright (c)  Microsoft.  All rights reserved.
//
// This is unpublished source code of Microsoft.
// The copyright notice above does not evidence any
// actual or intended publication of such source code.

// OneLiner  :  Implementation of MNLBPortRule
// DevUnit   :  wlbstest
// Author    :  Murtaza Hakim

// include files
#include "MNLBPortRule.h"


// done
// constructor
//
MNLBPortRule::MNLBPortRule( long startPort,
                            long endPort,
                            Protocol      trafficToHandle )
        : _startPort( startPort ),
          _endPort( endPort ),
          _trafficToHandle( trafficToHandle ),
          _key( startPort )
{}


// done
// default constructor
//
MNLBPortRule::MNLBPortRule()
        :_startPort( 0 ),
         _endPort( 65535 ),
         _trafficToHandle( both ),
         _key( 0 )
{}


// done
// equality operator
bool
MNLBPortRule::operator==(const MNLBPortRule& objToCompare ) const
{
    if( (_startPort == objToCompare._startPort )
        &&
        (_endPort == objToCompare._endPort )        
        &&
        (_trafficToHandle == objToCompare._trafficToHandle )
        )
    {
        return true;
    }
    else
    {
        return false;
    }
}

// done
// inequality operator
bool
MNLBPortRule::operator!=(const MNLBPortRule& objToCompare ) const
{
    return !( *this == objToCompare );
}

// done
// constructor
//
MNLBPortRuleLoadBalanced::MNLBPortRuleLoadBalanced( long          startPort,
                                              long          endPort,
                                              Protocol      trafficToHandle,
                                              bool          isEqualLoadBalanced,
                                              long          load,
                                              Affinity      affinity ) :
        MNLBPortRule( startPort, endPort, trafficToHandle ),
        _isEqualLoadBalanced( isEqualLoadBalanced  ),
        _load( load ),
        _affinity( affinity )
{}

// done
// default constructor
//
MNLBPortRuleLoadBalanced::MNLBPortRuleLoadBalanced()
        : MNLBPortRule(),
          _isEqualLoadBalanced( true ),
          _load( 0 ),
          _affinity( single )
{}


// equality operator
// 
bool
MNLBPortRuleLoadBalanced::operator==(const MNLBPortRuleLoadBalanced& objToCompare ) const
{
    bool retVal;

    // compare bases.
    retVal = MNLBPortRule::operator==( objToCompare );
    if( retVal == true )
    {

        if( ( _isEqualLoadBalanced == objToCompare._isEqualLoadBalanced )
            &&
            ( _affinity == objToCompare._affinity )
            )
        {
            if( _isEqualLoadBalanced == false )
            {
                // as it is Unequal load balanced port rule, 
                // load weight is important.
                if( _load == objToCompare._load )
                {
                    return true;
                }
                else
                {
                    return false;
                }
            }
            else
            {
                // load weight is not important as it is equal load balanced.
                return true;
            }
        }
        else
        {
            return false;
        }
    }
    else
    {
        return false;
    }
        
}

// inequality operator
//
bool
MNLBPortRuleLoadBalanced::operator!=(const MNLBPortRuleLoadBalanced& objToCompare ) const
{
    return !( (*this) ==  objToCompare );
}

    

// constructor
//
MNLBPortRuleFailover::MNLBPortRuleFailover( long startPort,
                                      long endPort,
                                      Protocol      trafficToHandle,
                                      long priority )
        :
        MNLBPortRule( startPort, endPort, trafficToHandle ),
        _priority ( priority )
{}



// default constructor
//
MNLBPortRuleFailover::MNLBPortRuleFailover()
        : 
        MNLBPortRule(),
        _priority( 1 )
{}


// equality operator
//
bool
MNLBPortRuleFailover::operator==(const MNLBPortRuleFailover& objToCompare ) const
{
    bool retVal;
    retVal = MNLBPortRule::operator==( objToCompare );
    if( retVal == true )
    {
        if( _priority == objToCompare._priority )
        {
            return true;
        }
        else
        {
            return false;
        }
    }
    else
    {
        return false;
    }
}


// inequality operator
//
bool
MNLBPortRuleFailover::operator!=(const MNLBPortRuleFailover& objToCompare ) const
{
    return !( (*this) ==  objToCompare );
}

// constructor
//
MNLBPortRuleDisabled::MNLBPortRuleDisabled( long startPort,
                                      long endPort,
                                      Protocol      trafficToHandle )
        :
        MNLBPortRule( startPort, endPort, trafficToHandle )
{}


// default constructor
//
MNLBPortRuleDisabled::MNLBPortRuleDisabled()
        :
        MNLBPortRule()
{}


// equality operator
//
bool
MNLBPortRuleDisabled::operator==(const MNLBPortRuleDisabled& objToCompare ) const
{
    bool retVal;

    // compare bases.
    retVal = MNLBPortRule::operator==( objToCompare );

    return retVal;
}


// inequality operator
//
bool
MNLBPortRuleDisabled::operator!=(const MNLBPortRuleDisabled& objToCompare ) const
{
    return !( (*this) ==  objToCompare );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\nlbsprov\mnlbuidata.h ===
#ifndef _MNLBUIDATA_H
#define _MNLBUIDATA_H
//
// Copyright (c) Microsoft.  All Rights Reserved 
//
// THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF Microsoft.
// The copyright notice above does not evidence any
// actual or intended publication of such source code.
//
// OneLiner : muidata interface file.
// DevUnit  : wlbstest
// Author   : Murtaza Hakim
//
// Description: 
// -----------
// This data structure is as follows
//
// ClusterData has inforamtion about 
// cluster
// portrules 
// and hosts.
// 
// The portRules are map structures with the start port mapping to the detailed port rule.
//
// the portrules unequal load balanced have a map which maps the host id and the 
// load weight for that particular host.
//
// the portrules failover have a map which maps the host id and the 
// priority for that particular host.
//
//
#include "Common.h"
#include "MNLBPortRule.h"

#include <wbemidl.h>
#include <comdef.h>

#include <set>
#include <map>

using namespace std;

struct PortDataULB : public MNLBPortRuleLoadBalanced
{
    map< _bstr_t, long > machineMapToLoadWeight;

    // default constructor
    PortDataULB();

    // constructor
    PortDataULB( long startPort,
                 long endPort,
                 Protocol      traficToHandle,
                 Affinity      affinity );
};

struct PortDataELB : public MNLBPortRuleLoadBalanced
{
    // default constructor
    PortDataELB();

    // constructor
    PortDataELB( long startPort,
                 long endPort,
                 Protocol      traficToHandle,
                 Affinity      affinity );

    // equality operator
    bool
    operator==( const PortDataELB& objToCompare );

    // inequality
    bool
    operator!=( const PortDataELB& objToCompare );


};

struct PortDataD : public MNLBPortRuleDisabled
{
    // default constructor
    PortDataD();

    // constructor
    PortDataD( long startPort,
               long endPort,
               Protocol      traficToHandle );

    // equality operator
    bool
    operator==( const PortDataD& objToCompare );

    // inequality
    bool
    operator!=( const PortDataD& objToCompare );

};

struct PortDataF : public MNLBPortRuleFailover
{
    map< _bstr_t, long > machineMapToPriority;
    
    set<long>
    getAvailablePriorities(); 

    // default constructor
    PortDataF();

    PortDataF( long startPort,
              long endPort,
              Protocol      traficToHandle );

};

struct HostData
{
    HostProperties hp;
    
    _bstr_t        connectionIP;
};

struct ClusterData
{
    vector<_bstr_t> virtualIPs;
    vector<_bstr_t> virtualSubnets;

    ClusterProperties cp;

    map< long, PortDataELB> portELB;
    map< long, PortDataULB> portULB;
    map< long, PortDataD> portD;
    map< long, PortDataF> portF;

    map< _bstr_t, HostData>  hosts;

    set<int>
    getAvailableHostIDS();

    bool connectedDirect;

    void
    dump();
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\nlbsprov\mnlbsetting.h ===
#ifndef _MNLBSETTING_H
#define _MNLBSETTING_H
//
// Copyright (c) Microsoft.  All Rights Reserved 
//
// THIS IS UNPUBLISHED PROPRIETARY SOURCE CODE OF Microsoft.
// The copyright notice above does not evidence any
// actual or intended publication of such source code.
//
// OneLiner : MNLBSetting interface.
// DevUnit  : wlbstest
// Author   : Murtaza Hakim
//
// Description: 
// -----------


// Include Files


#include "MNLBPortRule.h"

#include "Common.h"

#include "MWmiObject.h"

#include "MWmiInstance.h"

#include <vector>
#include <memory>

#include <comdef.h>

using namespace std;

class MNLBSetting
{
public:
    enum MNLBSetting_Error
    {
        MNLBSetting_SUCCESS        = 0,

        COM_FAILURE                 = 1,

        UNCONSTRUCTED               = 2,

        MACHINE_FAILURE             = 3,
        
        BOUND                       = 4,

        UNBOUND                     = 5,

        NO_SUCH_NIC                 = 6,
        
        NLBS_NOT_INSTALLED          = 7,

        NO_SUCH_IP                  = 8,

        INVALID_RULE                = 9,
    };

    
    //
    // Description:
    // -----------
    // constructor.
    // 
    // Parameters:
    // ----------
    // ip                      IN      : ip address of machine to configure/admin nlbs on.
    // fullNICName             IN      : full name of nic to use.
    // 
    // Returns:
    // -------
    // none.
    //
    
    MNLBSetting( _bstr_t    ip,
                  _bstr_t    fullNICName );


    // for local machine.
    MNLBSetting( _bstr_t    fullNICName );


    // NOT IMPLEMENTED. 
    // 
    //
    // Description:
    // -----------
    // default constructor.
    // 
    // Parameters:
    // ----------
    // none.
    // 
    // Returns:
    // -------
    // none.

    MNLBSetting();


    //
    // Description:
    // -----------
    // copy constructor.
    // 
    // Parameters:
    // ----------
    // objToCopy             IN  :  object to copy.
    // 
    // Returns:
    // -------
    // none.

    MNLBSetting(const MNLBSetting& objToCopy );


    //
    // Description:
    // -----------
    // assignment operator
    // 
    // Parameters:
    // ----------
    // rhs             IN   : object to assign.
    // 
    // Returns:
    // -------
    // self

    MNLBSetting&
    operator=( const MNLBSetting& rhs );


    //
    // Description:
    // -----------
    // destructor
    // 
    // Parameters:
    // ----------
    // none
    // 
    // Returns:
    // -------
    // none.

    ~MNLBSetting();


    //
    // Description:
    // -----------
    // gets the nlbs host properties.
    // 
    // Parameters:
    // ----------
    // hp                       OUT      : host properties.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBSetting_Error
    getHostProperties( HostProperties* hp );

    //
    // Description:
    // -----------
    // gets the nlbs cluster properties.
    // 
    // Parameters:
    // ----------
    // cp                       OUT      : cluster properties.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBSetting_Error
    getClusterProperties( ClusterProperties* cp );


    //
    // Description:
    // -----------
    // sets the nlbs host properties.
    // 
    // Parameters:
    // ----------
    // hp                       IN      : host properties to set.
    // retVal                   OUT     : return value of method ran.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBSetting_Error
    setHostProperties( const HostProperties& hp,
                       unsigned long* retVal );


    //
    // Description:
    // -----------
    // sets the nlbs cluster properties.
    // 
    // Parameters:
    // ----------
    // cp                       IN      : cluster properties to set.
    // retVal                   OUT     : return value of method ran.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBSetting_Error
    setClusterProperties( const ClusterProperties& cp,
                          unsigned long* retVal );

    //
    // Description:
    // -----------
    // get the load balanced port rules associated with this machine.
    // 
    // Parameters:
    // ----------
    // portsLB           OUT    : load balanced port rules associated with this machine.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.


    MNLBSetting_Error
    getPortRulesLoadBalanced( vector<MNLBPortRuleLoadBalanced>* portsLB );


    //
    // Description:
    // -----------
    // get the failover port rules associated with this machine.
    // 
    // Parameters:
    // ----------
    // portsF           OUT    : failover port rules associated with this machine.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBSetting_Error
    getPortRulesFailover( vector<MNLBPortRuleFailover>* portsF );


    //
    // Description:
    // -----------
    // get the disabled port rules associated with this machine.
    // 
    // Parameters:
    // ----------
    // portsD           OUT    : failover port rules associated with this machine.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBSetting_Error
    getPortRulesDisabled( vector<MNLBPortRuleDisabled>* portsD );

    //
    // Description:
    // -----------
    // adds a load balanced port rule to the machine.
    // 
    // Parameters:
    // ----------
    // portRuleLB             IN  :  load balanced port rule to add.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBSetting_Error
    addPortRuleLoadBalanced( const MNLBPortRuleLoadBalanced& portRuleLB );

    //
    // Description:
    // -----------
    // adds a failover port rule to the machine.
    // 
    // Parameters:
    // ----------
    // portRuleF             IN  :  failover port rule to add.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBSetting_Error
    addPortRuleFailover( const MNLBPortRuleFailover& portRuleF );


    //
    // Description:
    // -----------
    // adds a disabled port rule to the machine.
    // 
    // Parameters:
    // ----------
    // portRuleD             IN  :  disabled port rule to add.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBSetting_Error
    addPortRuleDisabled( const MNLBPortRuleDisabled& portRuleD );
    

    //
    // Description:
    // -----------
    // removes a load balanced port rule to the machine.
    // 
    // Parameters:
    // ----------
    // portRuleLB             IN  :  load balanced port rule to remove.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBSetting_Error
    removePortRuleLoadBalanced( const MNLBPortRuleLoadBalanced& portRuleLB );

    //
    // Description:
    // -----------
    // removes a failover port rule to the machine.
    // 
    // Parameters:
    // ----------
    // portRuleF             IN  :  failover port rule to remove.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBSetting_Error
    removePortRuleFailover( const MNLBPortRuleFailover& portRuleF );


    //
    // Description:
    // -----------
    // removes a disabled port rule to the machine.
    // 
    // Parameters:
    // ----------
    // portRuleD             IN  :  disabled port rule to remove.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBSetting_Error
    removePortRuleDisabled( const MNLBPortRuleDisabled& portRuleD );

    //
    // Description:
    // -----------
    // starts host/cluster operations.
    // 
    // Parameters:
    // ----------
    // hostID            IN    : host id or Common::ALL_HOSTS for cluster wide 
    //                           or Common::THIS_HOST for connected machine.
    // retVal            OUT   : return value of method ran.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBSetting_Error
    start( int hostID, unsigned long* retVal );


    //
    // Description:
    // -----------
    // stops host/cluster operations.
    // 
    // Parameters:
    // ----------
    // hostID            IN    : host id or Common::ALL_HOSTS for cluster wide or 
    //                           Common::THIS_HOST for connected machine.
    // retVal            OUT   : return value of method ran.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBSetting_Error
    stop( int hostID, unsigned long* retVal );

    //
    // Description:
    // -----------
    // resume control over host/cluster operations.
    // 
    // Parameters:
    // ----------
    // hostID            IN    : host id or Common::ALL_HOSTS for cluster wide or 
    //                           Common::THIS_HOST for connected machine.
    // retVal            OUT   : return value of method ran.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBSetting_Error
    resume( int hostID, unsigned long* retVal );

    //
    // Description:
    // -----------
    // suspend control over host/cluster operations.
    // 
    // Parameters:
    // ----------
    // hostID            IN    : host id or Common::ALL_HOSTS for cluster wide or 
    //                           Common::THIS_HOST for connected machine.
    // retVal            OUT   : return value of method ran.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBSetting_Error
    suspend( int hostID, unsigned long* retVal );

    //
    // Description:
    // -----------
    // finishes all existing connections and
    // stops host/cluster operations.
    // 
    // Parameters:
    // ----------
    // hostID            IN    : host id or Common::ALL_HOSTS for cluster wide or 
    //                           Common::THIS_HOST for connected machine.
    // retVal            OUT   : return value of method ran.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBSetting_Error
    drainstop( int hostID, unsigned long* retVal );

    //
    // Description:
    // -----------
    // enables traffic for port rule for host/cluster.
    // 
    // Parameters:
    // ----------
    // hostID            IN    : host id or Common::ALL_HOSTS for cluster wide or 
    //                           Common::THIS_HOST for connected machine.
    // retVal            OUT   : return value of method ran.
    // port              IN    : port to affect or default is all ports.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBSetting_Error
    enable( int hostID, unsigned long* retVal, unsigned long port = Common::ALL_PORTS );

    //
    // Description:
    // -----------
    // disables ALL traffic for port rule for host/cluster.
    // 
    // Parameters:
    // ----------
    // hostID            IN    : host id or Common::ALL_HOSTS for cluster wide or 
    //                           Common::THIS_HOST for connected machine.
    // retVal            OUT   : return value of method ran.
    // port              IN    : port to affect or default is all ports.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBSetting_Error
    disable( int hostID, unsigned long* retVal, unsigned long port  = Common::ALL_PORTS);

    //
    // Description:
    // -----------
    // disables NEW traffic for port rule for host/cluster.
    // 
    // Parameters:
    // ----------
    // hostID            IN    : host id or Common::ALL_HOSTS for cluster wide or 
    //                           Common::THIS_HOST for connected machine.
    // retVal            OUT   : return value of method ran.
    // port              IN    : port to affect or default is all ports.
    // 
    // Returns:
    // -------
    // SUCCESS else error code.

    MNLBSetting_Error
    drain( int hostID, unsigned long* retVal, unsigned long port  = Common::ALL_PORTS );

    //
    // Description:
    // -----------
    // refreshes the wmi connection to the host
    // 
    // Parameters:
    // ----------
    // none
    // 
    // Returns:
    // -------
    // SUCCESS else error code.
    MNLBSetting_Error
    refreshConnection();

    MNLBSetting_Error
    reload( unsigned long* retVal );        


private:

    // data
    auto_ptr<MWmiObject>   p_machine;

    _bstr_t mIP;

    _bstr_t nic;    
    
    // functions

    MNLBSetting_Error
    connectToMachine();

    MNLBSetting_Error
    checkNicBinding(_bstr_t& guid );

    MNLBSetting_Error
    getInstanceToRunMethodOn( int hostID, vector <MWmiInstance>* instanceStore );
    

    MNLBSetting::MNLBSetting_Error
    MNLBSetting::getPortRulesLoadBalanced_private( vector<MNLBPortRuleLoadBalanced>* portsLB, 
                                                    vector<MWmiInstance>*          instances );

    MNLBSetting::MNLBSetting_Error
    MNLBSetting::getPortRulesFailover_private( vector<MNLBPortRuleFailover>*     portsF,
                                                vector<MWmiInstance>*          instances );
    
    MNLBSetting::MNLBSetting_Error
    MNLBSetting::getPortRulesDisabled_private( vector<MNLBPortRuleDisabled>*     portsD,
                                                vector<MWmiInstance>*          instances );

    MNLBSetting_Error
    getClusterIPAndHostID( _bstr_t& clusterIP,
                           _bstr_t& hostID );

};


// ensure type safety

typedef class MNLBSetting MNLBSetting;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\nlbsprov\mnlbuidata.cpp ===
// Copyright (c)  Microsoft.  All rights reserved.
//
// This is unpublished source code of Microsoft.
// The copyright notice above does not evidence any
// actual or intended publication of such source code.

// OneLiner  :  Implementation of MNLBCluster
// DevUnit   :  wlbstest
// Author    :  Murtaza Hakim

// include files
#include "MNLBUIData.h"
#include "wlbsctrl.h"

// PortDataULB default constructor
// 
PortDataULB::PortDataULB()
        :
        MNLBPortRuleLoadBalanced()
{
    _isEqualLoadBalanced = false;
}

// PortDataULB constructor
//
PortDataULB::PortDataULB( long startPort,
                          long endPort,
                          Protocol      trafficToHandle,
                          Affinity      affinity )
        :
        MNLBPortRuleLoadBalanced( startPort, 
                                  endPort,
                                  trafficToHandle,
                                  false,
                                  0,
                                  affinity )
{
}


// PortDataELB default constructor
//
PortDataELB::PortDataELB()
        :
        MNLBPortRuleLoadBalanced()
{
}

// PortDataELB constructor
//
PortDataELB::PortDataELB( long startPort,
                          long endPort,
                          Protocol      trafficToHandle,
                          Affinity      affinity )
        :
        MNLBPortRuleLoadBalanced( startPort, 
                                  endPort,
                                  trafficToHandle,
                                  true,
                                  0,
                                  affinity )
{
}

bool
PortDataELB::operator==( const PortDataELB& objToCompare )
{
    return MNLBPortRuleLoadBalanced::operator==( objToCompare );
}

bool
PortDataELB::operator!=( const PortDataELB& objToCompare )
{
    return !operator==( objToCompare );
}

// PortDataF default constructor
//
PortDataF::PortDataF()
        :
        MNLBPortRuleFailover()
{
}

// PortDataF constructor
//
PortDataF::PortDataF( long startPort,
                      long endPort,
                      Protocol      trafficToHandle )
        :
        MNLBPortRuleFailover( startPort,
                              endPort,
                              trafficToHandle,
                              0 )
{
}


// PortDataD default constructor
//
PortDataD::PortDataD()
        :
        MNLBPortRuleDisabled()
{
}

// PortDataD constructor
//
PortDataD::PortDataD( long startPort,
                      long endPort,
                      Protocol      trafficToHandle )
        :
        MNLBPortRuleDisabled( startPort,
                              endPort,
                              trafficToHandle )
{
}

// equality
//
bool
PortDataD::operator==( const PortDataD& objToCompare )
{
    return MNLBPortRuleDisabled::operator==( objToCompare );
}

// inequality
//
bool
PortDataD::operator!=( const PortDataD& objToCompare )
{
    return !operator==( objToCompare );
}

// getAvailableHostIDS
//
set<int>
ClusterData::getAvailableHostIDS()
{
    set<int> availableHostIDS;
    
    // initially make all available.
    for( int i = 1; i <= WLBS_MAX_HOSTS; ++i )
    {
        availableHostIDS.insert( i );
    }

    // remove host ids not available.
    map<_bstr_t, HostData>::iterator top;
    for( top = hosts.begin(); top != hosts.end(); ++top )
    {
        availableHostIDS.erase(  (*top).second.hp.hID );
    }

    return availableHostIDS;
}


set<long>
PortDataF::getAvailablePriorities()
{
    set<long> availablePriorities;

    // initially make all available.
    for( int i = 1; i <= WLBS_MAX_HOSTS; ++i )
    {
        availablePriorities.insert( i );
    }

    // remove priorities not available.
    map<_bstr_t, long>::iterator top;
    for( top = machineMapToPriority.begin(); 
         top != machineMapToPriority.end(); 
         ++top )
    {
        availablePriorities.erase(  (*top).second );
    }

    return availablePriorities;
}    

void
ClusterData::dump()
{
    map< _bstr_t, HostData>::iterator topHost;
    
    for( topHost = hosts.begin();
         topHost != hosts.end();
         ++topHost )
    {
        _bstr_t hostName = (*topHost).first;

        HostProperties hp = (*topHost).second.hp;

        _bstr_t connectionIP = (*topHost).second.connectionIP;
    }


    map< long, PortDataELB>::iterator topELB;
    for( topELB = portELB.begin();
         topELB != portELB.end();
         ++topELB )
    {
        long startport = (*topELB).first;

        PortDataELB portDataELB = (*topELB).second;
    }


    map< long, PortDataD>::iterator topD;
    for( topD = portD.begin();
         topD != portD.end();
         ++topD )
    {
        long startport = (*topD).first;

        PortDataD portDataD = (*topD).second;
    }


    map< long, PortDataULB>::iterator topULB;
    for( topULB = portULB.begin();
         topULB != portULB.end();
         ++topULB )
    {
        long startport = (*topULB).first;

        PortDataULB portDataULB = (*topULB).second;

        map< _bstr_t, long >::iterator topLW;
        for( topLW = (*topULB).second.machineMapToLoadWeight.begin();
             topLW != (*topULB).second.machineMapToLoadWeight.end();
             ++topLW )
        {
            _bstr_t machineName = (*topLW).first;

            long loadWeight     = (*topLW).second;
        }
        
    }


    map< long, PortDataF>::iterator topF;
    for( topF = portF.begin();
         topF != portF.end();
         ++topF )
    {
        long startport = (*topF).first;

        PortDataF portDataF = (*topF).second;

        map< _bstr_t, long >::iterator topP;
        for( topP = (*topF).second.machineMapToPriority.begin();
             topP != (*topF).second.machineMapToPriority.end();
             ++topP )
        {
            _bstr_t machineName = (*topP).first;

            long loadWeight     = (*topP).second;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\wlbs\nlbmgr\nlbsprov\wlbsctrl.h ===
/*++

Copyright(c) 1998,99  Microsoft Corporation

Module Name:

    wlbsctrl.c

Abstract:

    Windows Load Balancing Service (WLBS)
    API - specification.  This set of API is for internal use only.  
        another set of WMI API is provided for public use.

Author:

    fengsun

--*/

#ifndef _WLBSCTRL_H_
#define _WLBSCTRL_H_

/* CONSTANTS */

#define WLBS_API_VER_MAJOR       2       /* WLBS control API major version. */
#define WLBS_API_VER_MINOR       0       /* WLBS control API minor version. */
#define WLBS_API_VER             (WLBS_API_VER_MINOR | (WLBS_API_VER_MAJOR << 8))
                                         /* WLBS control API version. */
#define WLBS_PRODUCT_NAME        "WLBS"
                                         /* Default product name used for API
                                            initialization. */


#define WLBS_MAX_HOSTS           32      /* Maximum number of cluster hosts. */
#define WLBS_MAX_RULES           32      /* Maximum number of port rules. */



#define WLBS_ALL_CLUSTERS        0       /* Used to specify all clusters in
                                            WLBS...Set routines. */
#define WLBS_LOCAL_CLUSTER       0       /* Used to specify that cluster
                                            operations are to be performed on the
                                            local host. WLBS_LOCAL_HOST value
                                            below has to be used for the host
                                            argument when using
                                            WLBS_LOCAL_CLUSTER. */
#define WLBS_LOCAL_HOST          0       /* When specifying WLBS_LOCAL_CLUSTER,
                                            this value should be used for the
                                            host argument. */
#define WLBS_DEFAULT_HOST        0       /* Used to specify that remote cluster
                                            operations are to be performed on
                                            the default host. */
#define WLBS_ALL_HOSTS           0xffffffff
                                         /* Used to specify that remote cluster
                                            operation is to be performed on all
                                            hosts. */
#define WLBS_ALL_PORTS           0xffffffff
                                         /* Used to specify all load-balanced
                                            port rules as the target for
                                            enable/disable/drain commands. */



/* WLBS return values. Windows Sockets errors are returned 'as-is'. */

#define WLBS_OK                  1000    /* Success. */
#define WLBS_ALREADY             1001    /* Cluster mode is already stopped/
                                            started, or traffic handling is
                                            already enabled/disabled on specified
                                            port. */
#define WLBS_DRAIN_STOP          1002    /* Cluster mode stop or start operation
                                            interrupted connection draining
                                            process. */
#define WLBS_BAD_PARAMS          1003    /* Cluster mode could not be started
                                            due to configuration problems
                                            (bad registry parameters) on the
                                            target host. */
#define WLBS_NOT_FOUND           1004    /* Port number not found among port
                                            rules. */
#define WLBS_STOPPED             1005    /* Cluster mode is stopped on the
                                            host. */
#define WLBS_CONVERGING          1006    /* Cluster is converging. */
#define WLBS_CONVERGED           1007    /* Cluster or host converged
                                            successfully. */
#define WLBS_DEFAULT             1008    /* Host is converged as default host. */
#define WLBS_DRAINING            1009    /* Host is draining after
                                            WLBSDrainStop command. */
#define WLBS_PRESENT             1010    /* WLBS is installed on this host.
                                            Local operations possible. */
#define WLBS_REMOTE_ONLY         1011    /* WLBS is not installed on this host
                                            or is not functioning. Only remote
                                            control operations can be carried
                                            out. */
#define WLBS_LOCAL_ONLY          1012    /* WinSock failed to load. Only local
                                            operations can be carried out. */
#define WLBS_SUSPENDED           1013    /* Cluster control operations are
                                            suspended. */
#define WLBS_REBOOT              1050    /* Reboot required in order for config
                                            changes to take effect. */
#define WLBS_INIT_ERROR          1100    /* Error initializing control module. */
#define WLBS_BAD_PASSW           1101    /* Specified remote control password
                                            was not accepted by the cluster. */
#define WLBS_IO_ERROR            1102    /* Local I/O error opening or
                                            communicating with WLBS driver. */
#define WLBS_TIMEOUT             1103    /* Timed-out awaiting response from
                                            remote host. */
#define WLBS_PORT_OVERLAP        1150    /* Port rule overlaps with existing
                                            port rules. */
#define WLBS_BAD_PORT_PARAMS     1151    /* Invalid parameter(s) in port rule. */
#define WLBS_MAX_PORT_RULES      1152    /* Maximum number of port rules reached. */
#define WLBS_TRUNCATED           1153    /* Return value truncated */
#define WLBS_REG_ERROR           1154    /* Error while accessing the registry */


/* Filtering modes for port rules */

#define WLBS_SINGLE              1       /* single server mode */
#define WLBS_MULTI               2       /* multi-server mode (load balanced) */
#define WLBS_NEVER               3       /* mode for never handled by this server */
#define WLBS_ALL                 4       /* all server mode */

/* Protocol qualifiers for port rules */

#define WLBS_TCP                 1       /* TCP protocol */
#define WLBS_UDP                 2       /* UDP protocol */
#define WLBS_TCP_UDP             3       /* TCP or UDP protocols */

/* Server affinity values for multiple filtering mode */

#define WLBS_AFFINITY_NONE       0       /* no affinity (scale single client) */
#define WLBS_AFFINITY_SINGLE     1       /* single client affinity */
#define WLBS_AFFINITY_CLASSC     2       /* Class C affinity */


/* TYPES */


/* Response value type returned by each of the cluster hosts during remote
   operation. */

typedef struct
{
    DWORD       id;                     /* Priority ID of the responding cluster
                                           host */
    DWORD       address;                /* Dedicated IP address */
    DWORD       status;                 /* Status return value */
    DWORD       reserved1;              /* Reserved for future use */
    PVOID       reserved2;
}
WLBS_RESPONSE, * PWLBS_RESPONSE;





/* MACROS */


/* Local operations */

#define WlbsLocalQuery(host_map)                                  \
    WlbsQuery     (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, NULL, NULL, \
                     host_map, NULL)

#define WlbsLocalSuspend()                                        \
    WlbsSuspend   (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, NULL, NULL)

#define WlbsLocalResume()                                         \
    WlbsResume    (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, NULL, NULL)

#define WlbsLocalStart()                                          \
    WlbsStart     (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, NULL, NULL)

#define WlbsLocalStop()                                           \
    WlbsStop      (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, NULL, NULL)

#define WlbsLocalDrainStop()                                      \
    WlbsDrainStop (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, NULL, NULL)

#define WlbsLocalEnable(port)                                     \
    WlbsEnable    (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, NULL, NULL, port)

#define WlbsLocalDisable(port)                                    \
    WlbsDisable   (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, NULL, NULL, port)

#define WlbsLocalDrain(port)                                      \
    WlbsDrain     (WLBS_LOCAL_CLUSTER, WLBS_LOCAL_HOST, NULL, NULL, port)



/* Single host remote operations */

#define WlbsHostQuery(cluster, host, host_map)                    \
    WlbsQuery     (cluster, host, NULL, NULL, host_map, NULL)

#define WlbsHostSuspend(cluster, host)                            \
    WlbsSuspend   (cluster, host, NULL, NULL)

#define WlbsHostResume(cluster, host)                             \
    WlbsResume    (cluster, host, NULL, NULL)

#define WlbsHostStart(cluster, host)                              \
    WlbsStart     (cluster, host, NULL, NULL)

#define WlbsHostStop(cluster, host)                               \
    WlbsStop      (cluster, host, NULL, NULL)

#define WlbsHostDrainStop(cluster, host)                          \
    WlbsDrainStop (cluster, host, NULL, NULL)

#define WlbsHostEnable(cluster, host, port)                       \
    WlbsEnable    (cluster, host, NULL, NULL, port)

#define WlbsHostDisable(cluster, host, port)                      \
    WlbsDisable   (cluster, host, NULL, NULL, port)

#define WlbsHostDrain(cluster, host, port)                        \
    WlbsDrain     (cluster, host, NULL, NULL, port)

/* Cluster-wide remote operations */

#define WlbsClusterQuery(cluster, response, num_hosts, host_map)  \
    WlbsQuery     (cluster, WLBS_ALL_HOSTS, response, num_hosts,   \
                     host_map, NULL)

#define WlbsClusterSuspend(cluster, response, num_hosts)          \
    WlbsSuspend   (cluster, WLBS_ALL_HOSTS, response, num_hosts)

#define WlbsClusterResume(cluster, response, num_hosts)           \
    WlbsResume    (cluster, WLBS_ALL_HOSTS, response, num_hosts)

#define WlbsClusterStart(cluster, response, num_hosts)            \
    WlbsStart     (cluster, WLBS_ALL_HOSTS, response, num_hosts)

#define WlbsClusterStop(cluster, response, num_hosts)             \
    WlbsStop      (cluster, WLBS_ALL_HOSTS, response, num_hosts)

#define WlbsClusterDrainStop(cluster, response, num_hosts)        \
    WlbsDrainStop (cluster, WLBS_ALL_HOSTS, response, num_hosts)

#define WlbsClusterEnable(cluster, response, num_hosts, port)     \
    WlbsEnable    (cluster, WLBS_ALL_HOSTS, response, num_hosts, port)

#define WlbsClusterDisable(cluster, response, num_hosts, port)    \
    WlbsDisable   (cluster, WLBS_ALL_HOSTS, response, num_hosts, port)

#define WlbsClusterDrain(cluster, response, num_hosts, port)      \
    WlbsDrain     (cluster, WLBS_ALL_HOSTS, response, num_hosts, port)


/* PROCEDURES */

/*************************************
   Initialization and support routines
 *************************************/

#ifdef __cplusplus
extern "C" {
#endif

extern DWORD WINAPI WlbsInit
(
    WCHAR*          Reservered1,    /* IN  - for backward compatibility */
    DWORD           version,    /* IN  - Pass WLBS_API_VER value. */
    PVOID           Reservered2    /* IN  - Pass NULL. Reserved for future use. */
);
/*
    Initialize WLBS control module.

    returns:
        WLBS_PRESENT        => WLBS is installed on this host. Local and remote
                               control operations can be executed.
        WLBS_REMOTE_ONLY    => WLBS is not installed on this system or is not
                               functioning properly. Only remote operations can
                               be carried out.
        WLBS_LOCAL_ONLY     => WinSock failed to load. Only local operations can
                               be carried out.
        WLBS_INIT_ERROR     => Error initializing control module. Cannot perform
                               control operations.
*/




/******************************************************************************
   Cluster control routines:

   The following routines can be used to control individual cluster hosts or the
   entire cluster, both locally and remotely. They are designed to be as generic
   as possible. Macros, defined above, are designed to provide simpler
   interfaces for particular types of operations.

   It is highly recommended to make all response arrays of size WLBS_MAX_HOSTS
   to make your implementation independent of the actual cluster size.

   Please note that cluster address has to correspond to the primary cluster
   address as entered in the WLBS Setup Dialog. WLBS will not recognize
   control messages sent to dedicated or additional multi-homed cluster
   addresses.
 ******************************************************************************/


extern DWORD WINAPI WlbsQuery
(
    DWORD           cluster,    /* IN  - Cluster address or WLBS_LOCAL_CLUSTER
                                         for local or this cluster operation. */
    DWORD           host,       /* IN  - Host's dedicated address, priority ID,
                                         WLBS_DEFAULT_HOST for current default,
                                         WLBS_ALL_HOSTS for all hosts, or
                                         WLBS_LOCAL_HOST for local operation. */
    PWLBS_RESPONSE  response,   /* OUT - Array of response values from each of
                                         the hosts or NULL if response values
                                         are not desired or operations are being
                                         performed locally. */
    PDWORD          num_hosts,  /* IN  - Size of the response array or NULL if
                                         response array is not specified and
                                         host count is not desired.
                                   OUT - Number of responses received. Note that
                                         this value can be larger than the size
                                         of the response array. In this case
                                         only the first few responses that fit
                                         in the array are returned. */
    PDWORD          host_map,   /* OUT - Bitmap with ones in the bit positions
                                         representing priority IDs of the hosts
                                         currently present in the cluster. NULL
                                         if host map information is not
                                         needed. */
    PVOID           reserved    /* IN  - Pass NULL. Reserved for future use. */
);
/*
    Query status of specified host or all cluster hosts.

    returns:
        For local operations or remote operations on individual cluster hosts,
        return value represents status value returned by the target host. For
        cluster-wide remote operations, return value represents the summary of
        the return values from all cluster hosts. Individual host responses,
        corresponding to a single-host, return values are recorded in the
        response array.

        WLBS_INIT_ERROR  => Error initializing control module. Cannot perform
                            control operations.

        Single-host:

        WLBS_SUSPENDED   => Cluster mode control suspended.
        WLBS_STOPPED     => Cluster mode on the host is stopped.
        WLBS_CONVERGING  => Host is converging.
        WLBS_DRAINING    => Host is draining.
        WLBS_CONVERGED   => Host converged.
        WLBS_DEFAULT     => Host converged as default host.

        Cluster-wide:

        <1..32>          => Number of active cluster hosts when the cluster
                            is converged.
        WLBS_SUSPENDED   => Entire cluster is suspended. All cluster hosts
                            reported as being suspended.
        WLBS_STOPPED     => Entire cluster is stopped. All cluster hosts reported
                            as being stopped.
        WLBS_DRAINING    => Entire cluster is draining. All cluster hosts
                            reported as being stopped or draining.
        WLBS_CONVERGING  => Cluster is converging. At least one cluster host
                            reported its state as converging.

        Remote:

        WLBS_BAD_PASSW   => Specified password was not accepted by the cluster.
        WLBS_TIMEOUT     => No response received. If this value is returned when
                            accessing default host (using host priority ID
                            WLBS_DEFAULT_HOST) it might mean that entire cluster
                            is stopped and there was no default host to respond
     