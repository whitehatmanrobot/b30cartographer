peName) )
                        dbType = DBTYPE_I8;
                    break;

                default:
                    break;
            }
            break;

        case L'R':
        case L'r':
            switch ( pwszDBTypeName[8] )
            {
                case L'4':
                    if ( 0 == _wcsicmp(L"DBTYPE_R4", pwszDBTypeName) )
                        dbType = DBTYPE_R4;
                    break;

                case L'8':
                    if (0 == _wcsicmp(L"DBTYPE_R8", pwszDBTypeName))
                        dbType = DBTYPE_R8;
                    break;

                default:
                    break;
            }
            break;

        case L'B':
        case L'b':
            if ( 10 <= wcslen(pwszDBTypeName) )
                switch ( pwszDBTypeName[8] )
                {
                    case L'S':
                    case L's':
                        if ( 0 == _wcsicmp(L"DBTYPE_BSTR", pwszDBTypeName) )
                            dbType = DBTYPE_BSTR;
                        break;

                    case L'O':
                    case L'o':
                        if ( 0 == _wcsicmp(L"DBTYPE_BOOL", pwszDBTypeName) )
                            dbType = DBTYPE_BOOL;
                        break;

                    case L'Y':
                    case L'y':
                        if ( 0 == _wcsicmp(L"DBTYPE_BYREF", pwszDBTypeName) )
                            dbType = DBTYPE_BYREF;
                        break;

                    default:
                        break;
                }
            break;

        case L'E':
        case L'e':
            if ( 0 == _wcsicmp(L"DBTYPE_EMPTY", pwszDBTypeName) )
                dbType = DBTYPE_EMPTY;
            break;

        case L'N':
        case L'n':
            if ( 0 == _wcsicmp(L"DBTYPE_NULL", pwszDBTypeName) )
                dbType = DBTYPE_NULL;
            break;

        case L'C':
        case L'c':
            if ( 0 == _wcsicmp(L"DBTYPE_CY", pwszDBTypeName) )
                dbType = DBTYPE_CY;
            break;

        case L'D':
        case L'd':
            if ( 0 == _wcsicmp(L"DBTYPE_DATE", pwszDBTypeName) )
                dbType = DBTYPE_DATE;
            break;

        case L'G':
        case L'g':
            if ( 0 == _wcsicmp(L"DBTYPE_GUID", pwszDBTypeName) )
                dbType = DBTYPE_GUID;
            break;

        case L'S':
        case L's':
            if ( 0 == _wcsicmp(L"DBTYPE_STR", pwszDBTypeName) )
                dbType = DBTYPE_STR;
            break;

        case L'W':
        case L'w':
            if ( 0 == _wcsicmp(L"DBTYPE_WSTR", pwszDBTypeName) )
                dbType = DBTYPE_WSTR;
            break;

        case L'T':
        case L't':
            if ( 0 == _wcsicmp(L"VT_FILETIME", pwszDBTypeName) )
                dbType = VT_FILETIME;
            break;

        case L'V':
        case L'v':
            if ( 0 == _wcsicmp(L"DBTYPE_VECTOR", pwszDBTypeName) )
                dbType = DBTYPE_VECTOR;
            break;

        default:
            break;
        }

    return dbType;
}


const DBTYPENAMETABLE dbTypeNameTable[] =
    {
        {L"DBTYPE_EMPTY",   DBTYPE_EMPTY},
        {L"DBTYPE_NULL",    DBTYPE_NULL},
        {L"DBTYPE_I2",      DBTYPE_I2},
        {L"DBTYPE_I4",      DBTYPE_I4},
        {L"DBTYPE_R4",      DBTYPE_R4},
        {L"DBTYPE_R8",      DBTYPE_R8},
        {L"DBTYPE_CY",      DBTYPE_CY},
        {L"DBTYPE_DATE",    DBTYPE_DATE},
        {L"DBTYPE_BSTR",    DBTYPE_BSTR},
        {L"DBTYPE_BOOL",    DBTYPE_BOOL},
        {L"DBTYPE_UI1",     DBTYPE_UI1},
        {L"DBTYPE_I1",      DBTYPE_I1},
        {L"DBTYPE_UI2",     DBTYPE_UI2},
        {L"DBTYPE_UI4",     DBTYPE_UI4},
        {L"DBTYPE_I8",      DBTYPE_I8},
        {L"DBTYPE_UI8",     DBTYPE_UI8},
        {L"DBTYPE_GUID",    DBTYPE_GUID},
        {L"DBTYPE_STR",     DBTYPE_STR},
        {L"DBTYPE_WSTR",    DBTYPE_WSTR},
        {L"DBTYPE_BYREF",   DBTYPE_BYREF},
        {L"VT_FILETIME",    VT_FILETIME},
        {L"DBTYPE_VECTOR",  DBTYPE_VECTOR}
    };


//-----------------------------------------------------------------------------
// @func PctCreateContentNode
//
// This function takes a content string as input and creates a content node
// with the specified generate method and weight.
//
// @rdesc DBCOMMANDTREE*
//-----------------------------------------------------------------------------
DBCOMMANDTREE* PctCreateContentNode(
    LPWSTR          pwszContent,    // @parm IN | content for the node
    DWORD           dwGenerateMethod,//@parm IN | generate method
    LONG            lWeight,        // @parm IN | weight
    LCID            lcid,           // @parm IN | locale identifier
    DBCOMMANDTREE*  pctFirstChild ) // @parm IN | node to link to new node
{
    DBCOMMANDTREE* pct = PctCreateNode( DBOP_content, DBVALUEKIND_CONTENT, pctFirstChild, NULL );
    if ( 0 != pct )
    {
        pct->value.pdbcntntValue->pwszPhrase = CoTaskStrDup( pwszContent );
        if (pct->value.pdbcntntValue->pwszPhrase)
        {
            pct->value.pdbcntntValue->dwGenerateMethod = dwGenerateMethod;
            pct->value.pdbcntntValue->lWeight = lWeight;
            pct->value.pdbcntntValue->lcid = lcid;
        }
        else
        {
            DeleteDBQT( pct );
            pct = 0;
        }
    }
    return pct;
}


//-----------------------------------------------------------------------------
// @func PctCreateBooleanNode
//
// This function creates a content node with the specified children and weight.
//
// @rdesc DBCOMMANDTREE*
//-----------------------------------------------------------------------------
DBCOMMANDTREE* PctCreateBooleanNode(
    DBCOMMANDOP     op,         // @parm IN | op tag for new node
    LONG            lWeight,    // @parm IN | Weight of the boolean node
    DBCOMMANDTREE*  pctChild,   // @parm IN | child of boolean node
    DBCOMMANDTREE*  pctSibling )// @parm IN | second child of boolean node
{
    DBCOMMANDTREE* pct = PctCreateNode( op, DBVALUEKIND_I4, pctChild, pctSibling, NULL );
    if ( 0 != pct )
        pct->value.lValue = lWeight;
    return pct;
}

//-----------------------------------------------------------------------------
// @func PctCreateNotNode
//
// This function creates a not node with the specified child and weight.
//
// @rdesc DBCOMMANDTREE*
//-----------------------------------------------------------------------------
DBCOMMANDTREE* PctCreateNotNode(
    LONG            lWeight,    // @parm IN | Weight of the boolean node
    DBCOMMANDTREE*  pctChild )  // @parm IN | child of NOT node
{
    DBCOMMANDTREE* pct = PctCreateNode( DBOP_not, DBVALUEKIND_I4, pctChild, NULL );
    if ( 0 != pct )
        pct->value.lValue = lWeight;
    return pct;
}

//-----------------------------------------------------------------------------
// @func PctCreateRelationalNode
//
// This function creates a relational node with the specied op and weight.
//
// @rdesc DBCOMMANDTREE*
//-----------------------------------------------------------------------------
DBCOMMANDTREE* PctCreateRelationalNode(
    DBCOMMANDOP op,         // @parm IN | op tag for new node
    LONG        lWeight )   // @parm IN | Weight of the relational node
{
    DBCOMMANDTREE* pct = PctCreateNode(op, DBVALUEKIND_I4, NULL);
    if ( 0 != pct)
        pct->value.lValue = lWeight;
    return pct;
}


//-----------------------------------------------------------------------------
// @func SetLWeight
//
// This function sets the lWeight value for vector searches
//
//-----------------------------------------------------------------------------
void SetLWeight(
    DBCOMMANDTREE*  pct,        // @parm IN | node or subtree to set
    LONG            lWeight )   // @parm IN | weight value for node(s)
{
    if ( DBOP_content == pct->op )
        pct->value.pdbcntntValue->lWeight = lWeight;
    else
    {
        AssertReq( pct->pctFirstChild );
        AssertReq( pct->pctFirstChild->pctNextSibling );
        SetLWeight(pct->pctFirstChild, lWeight);
        DBCOMMANDTREE* pctNext = pct->pctFirstChild->pctNextSibling;
        while ( pctNext )
        {
            // A content_proximity node can have lots of siblings
            SetLWeight( pctNext, lWeight );
            pctNext = pctNext->pctNextSibling;
        }
    }
}


//-----------------------------------------------------------------------------
// @func GetLWeight
//
// This function gets the lWeight value for vector searches
//-----------------------------------------------------------------------------
LONG GetLWeight(
    DBCOMMANDTREE*  pct )   // @parm IN | node or subtree to set
{
    if ( DBOP_content == pct->op )
        return pct->value.pdbcntntValue->lWeight;
    else
    {
        AssertReq( pct->pctFirstChild );
        return GetLWeight( pct->pctFirstChild );
    }
}


//-----------------------------------------------------------------------------
// @func PctBuiltInProperty
//
// This function takes a column name string as input and creates a column_name
// node containing the appropriate GUID information if the column_name is a
// built-in property
//
// @rdesc DBCOMMANDTREE*
//-----------------------------------------------------------------------------
DBCOMMANDTREE* PctBuiltInProperty(
    LPWSTR                      pwszColumnName, // @parm IN | name of column
    CImpIParserSession*         pIPSession,     // @parm IN | Parser Session
    CImpIParserTreeProperties*  pIPTProps )     // @parm IN | Parser Properties
{
    DBCOMMANDTREE* pct = 0;
    DBID *pDBID = 0;
    DBTYPE uwType = 0;
    UINT uiWidth = 0;
    BOOL fOk = 0;
    ICiPropertyList* pIPropList = 0;
    IColumnMapper* pIColumnMapper = pIPSession->GetColumnMapperPtr();

    if ( 0 != pIColumnMapper )
    {
        // we were able to use the IColumnMapper interface
        HRESULT hr = S_OK;
        // Olympus kludge
        if ( 0 == _wcsicmp(pwszColumnName, L"URL") )
            hr = pIColumnMapper->GetPropInfoFromName( L"VPATH", &pDBID, &uwType, &uiWidth );
        else
            hr = pIColumnMapper->GetPropInfoFromName( pwszColumnName, &pDBID, &uwType, &uiWidth );

        if ( SUCCEEDED(hr) )
            fOk = TRUE;
        else
            fOk = FALSE;
    }
    else
        fOk = FALSE;    // @TODO:  this should generate some sort of error message.

    if ( fOk )    // this is a built-in (well known) property
    {
        pIPTProps->SetDBType( uwType );   // remember the type of this
        pct = PctCreateNode( DBOP_column_name, DBVALUEKIND_ID, NULL );
        if ( 0 != pct )
        {
            pct->value.pdbidValue->eKind = pDBID->eKind;
            pct->value.pdbidValue->uGuid.guid = pDBID->uGuid.guid;
            switch ( pct->value.pdbidValue->eKind )
            {
            case DBKIND_NAME:
            case DBKIND_GUID_NAME:
                // need to create a new string
                pct->value.pdbidValue->uName.pwszName = CoTaskStrDup(pDBID->uName.pwszName);
                break;
            case DBKIND_GUID:
            case DBKIND_GUID_PROPID:
                pct->value.pdbidValue->uName.pwszName = pDBID->uName.pwszName;
                break;
            case DBKIND_PGUID_NAME:
                // need to create a new string
                pct->value.pdbidValue->uName.pwszName = CoTaskStrDup(pDBID->uName.pwszName);
                // need to allocate and copy guid
                pct->value.pdbidValue->uGuid.pguid = (GUID*)CoTaskMemAlloc(sizeof(GUID));
                *pct->value.pdbidValue->uGuid.pguid = *pDBID->uGuid.pguid;
                break;
            case DBKIND_PGUID_PROPID:
                // need to allocate and copy guid
                pct->value.pdbidValue->uGuid.pguid = (GUID*)CoTaskMemAlloc(sizeof(GUID));
                *pct->value.pdbidValue->uGuid.pguid = *pDBID->uGuid.pguid;
                break;
            default:
                Assert(0);
            }
        }
        if ( 0 != pIPropList )
            pIPropList->Release();
    }
    return pct;
}

//-----------------------------------------------------------------------------
// @func PctMkColNodeFromStr
//
// This function takes a column name string as input and creates a column_name
// node containing the appropriate GUID information.
//
// @rdesc DBCOMMANDTREE*
//-----------------------------------------------------------------------------
DBCOMMANDTREE* PctMkColNodeFromStr(
    LPWSTR                      pwszColumnName, // @parm IN | name of column
    CImpIParserSession*         pIPSession,     // @parm IN | Parser Session
    CImpIParserTreeProperties*  pIPTProps )     // @parm IN | Parser Properties
{
    DBCOMMANDTREE* pct = 0;

    pct = PctBuiltInProperty( pwszColumnName, pIPSession, pIPTProps );
    if ( 0 == pct )
        { // this may be a user defined property, or is undefined
        DBTYPE dbType = 0;
        HRESULT hr = pIPSession->m_pCPropertyList->LookUpPropertyName( pwszColumnName, &pct, &dbType );

        if ( E_OUTOFMEMORY == hr )
            pIPTProps->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
        else if ( FAILED(hr) )
        {
            pIPTProps->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_COLUMN_NOT_DEFINED );
            pIPTProps->SetErrorToken( pwszColumnName );
        }
        else
        {
            AssertReq( 0 != pct );
            pIPTProps->SetDBType( dbType );
        }
    }
    return pct;
}


/* ************************************************************************************************ */
/* ************************************************************************************************ */
/* ************************************************************************************************ */

#define _OR 257
#define _AND 258
#define _NOT 259
#define _UMINUS 260
#define mHighest 261
#define _ALL 262
#define _ANY 263
#define _ARRAY 264
#define _AS 265
#define _ASC 266
#define _CAST 267
#define _COERCE 268
#define _CONTAINS 269
#define _CONTENTS 270
#define _CREATE 271
#define _DEEP_TRAVERSAL 272
#define _DESC 273
#define _DOT 274
#define _DOTDOT 275
#define _DOTDOT_SCOPE 276
#define _DOTDOTDOT 277
#define _DOTDOTDOT_SCOPE 278
#define _DROP 279
#define _EXCLUDE_SEARCH_TRAVERSAL 280
#define _FALSE 281
#define _FREETEXT 282
#define _FROM 283
#define _IS 284
#define _ISABOUT 285
#define _IS_NOT 286
#define _LIKE 287
#define _MATCHES 288
#define _NEAR 289
#define _NOT_LIKE 290
#define _NULL 291
#define _OF 292
#define _ORDER_BY 293
#define _PASSTHROUGH 294
#define _PROPERTYNAME 295
#define _PROPID 296
#define _RANKMETHOD 297
#define _SELECT 298
#define _SET 299
#define _SCOPE 300
#define _SHALLOW_TRAVERSAL 301
#define _FORMSOF 302
#define _SOME 303
#define _TABLE 304
#define _TRUE 305
#define _TYPE 306
#define _UNION 307
#define _UNKNOWN 308
#define _URL 309
#define _VIEW 310
#define _WHERE 311
#define _WEIGHT 312
#define _GE 313
#define _LE 314
#define _NE 315
#define _CONST 316
#define _ID 317
#define _TEMPVIEW 318
#define _INTNUM 319
#define _REALNUM 320
#define _SCALAR_FUNCTION_REF 321
#define _STRING 322
#define _DATE 323
#define _PREFIX_STRING 324
#define _DELIMITED_ID 325
#define YYERRCODE 256
short yylhs[] = {                                        -1,
    0,    0,    0,    2,    4,    4,    1,    1,    5,    5,
    5,    6,    6,   10,   10,   10,   10,   10,   13,   14,
   11,   11,   12,   12,   15,   16,    3,   17,   19,   19,
   20,   20,   23,   23,   24,   24,   24,   21,   21,   25,
   27,   27,   27,   29,   30,   30,   30,   33,   34,   32,
   32,   35,   35,   36,   36,   37,   37,   37,   38,   38,
   39,   28,   28,   26,   40,   40,   40,   40,   40,   40,
   40,   40,   31,   41,   41,   42,   22,   22,   43,   43,
   45,   45,   45,   45,   45,   45,   45,   46,   53,   53,
   55,   55,   55,   54,   54,   54,   54,   54,   54,   47,
   57,   57,   61,   58,   60,   60,   62,   62,   64,   64,
   66,   69,   66,   68,   68,   68,   68,   68,   63,   63,
   65,   65,   67,   67,   70,   71,   72,   76,   76,   77,
   75,   75,   78,   78,   78,   73,   79,   80,   80,   74,
   81,   81,   82,   82,   83,   83,   83,   83,   84,   59,
   59,   48,   49,   49,   85,   50,   86,   51,   89,   90,
   90,   87,   87,   87,   87,   87,   87,   87,   87,   87,
   87,   87,   87,   87,   87,   87,   87,   87,   87,   88,
   91,   93,   92,   92,   94,   94,   95,   52,   52,   44,
   44,   96,   96,   98,   98,   97,   99,  101,  100,  100,
  100,  100,  100,  100,  100,  103,  102,  102,  104,  105,
  105,  106,  108,  108,  108,  107,  107,   18,   18,    9,
    9,    9,  109,  109,  114,  115,  115,   56,   56,  117,
  113,  116,  112,  110,  118,  118,  111,    7,    8,
};
short yylen[] = {                                         2,
    1,    2,    1,    2,    0,    1,    3,    2,    1,    1,
    1,    0,    1,    1,    1,    1,    1,    1,    1,    1,
    8,    3,    1,    1,    1,    1,    2,    5,    0,    1,
    1,    1,    3,    1,    1,    3,    1,    1,    1,    3,
    1,    1,    1,    4,    5,    7,    5,    1,    1,    0,
    1,    3,    1,    4,    6,    0,    2,    2,    3,    1,
    1,    0,    2,    2,    1,    1,    3,    3,    5,    5,
    3,    3,    3,    4,    4,    2,    0,    1,    2,    5,
    1,    1,    1,    1,    1,    1,    1,    3,    1,    6,
    1,    3,    1,    1,    1,    1,    1,    1,    1,    8,
    0,    2,    0,    2,    1,    3,    1,    3,    1,    2,
    1,    0,    4,    1,    1,    1,    1,    1,    1,    1,
    1,    1,    1,    1,    1,    1,    2,    2,    1,    2,
    1,    1,    1,    3,    1,    6,    1,    3,    1,    4,
    3,    1,    5,    1,    1,    1,    1,    1,    1,    0,
    2,    6,    3,    3,    1,    7,    1,    3,    1,    1,
    1,    1,    2,    2,    1,    2,    2,    1,    2,    2,
    1,    2,    2,    1,    2,    2,    1,    2,    2,    4,
    1,    1,    0,    1,    3,    1,    1,    3,    3,    1,
    3,    1,    3,    1,    2,    1,    1,    1,    1,    3,
    3,    3,    3,    3,    3,    0,    2,    3,    2,    3,
    1,    2,    0,    1,    1,    1,    1,    0,    1,    1,
    1,    1,    8,    8,    1,    0,    2,    1,    3,    1,
    1,    1,    1,    3,    2,    1,    3,    7,    3,
};
short yydefred[] = {                                      0,
    0,    0,    0,    0,    0,    0,    3,    0,    0,    9,
   10,   11,    0,  220,  221,  222,    0,    0,   30,    0,
    0,    0,    0,    2,    0,    6,    4,   13,    8,    0,
   27,  219,   25,   65,    0,    0,    0,    0,  239,   32,
   37,    0,    0,    0,    0,   34,  233,    0,    0,  234,
  237,    7,   93,   20,  217,    0,    0,  216,    0,  211,
    0,    0,    0,    0,    0,    0,    0,    0,   38,   39,
    0,    0,  235,    0,    0,  214,  215,  212,   49,    0,
   72,   71,   67,   68,    0,   36,    0,    0,    0,   41,
   42,   43,    0,    0,   64,    0,   28,   78,   33,   19,
  232,  231,    0,    0,   92,  210,    0,    0,    0,    0,
    0,    0,    0,   40,    0,    0,    0,  198,    0,    0,
    0,    0,  192,  194,    0,    0,    0,    0,    0,   69,
   70,  238,    0,   76,    0,    0,   73,    0,    0,    0,
    0,    0,   53,   26,   63,    0,    0,    0,    0,    0,
  196,    0,  197,    0,  195,    0,    0,    0,    0,    0,
    0,  207,   81,   82,   83,   84,   85,   86,   87,    0,
    0,  225,    0,    0,    0,    0,    0,    0,    0,    0,
   44,    0,    0,    0,    0,  208,    0,    0,  193,  201,
  200,  202,  204,  203,  205,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,  223,  224,    0,   74,   75,   57,   58,    0,
   61,    0,   60,   52,    0,   45,   47,   80,    0,    0,
    0,    0,    0,  159,  161,  160,  163,  164,  178,  179,
  175,  176,  166,  167,  169,  170,  172,  173,   24,   23,
   14,   15,   16,   88,   17,   18,    0,    0,  158,  188,
  189,  155,  153,  154,  230,  227,    0,    0,    0,   54,
    0,    0,  102,  103,    0,    0,    0,  181,    0,    0,
    0,   59,   46,    0,    0,    0,    0,  157,    0,   22,
    0,  186,    0,    0,  229,   55,   90,    0,  123,  112,
    0,    0,  125,  126,  124,    0,    0,  107,  109,    0,
  111,    0,    0,  116,  117,  118,    0,    0,  152,    0,
    0,  182,  180,  187,    0,    0,    0,    0,    0,  119,
  120,    0,  121,  122,    0,  110,    0,  135,    0,  129,
    0,  151,  156,    0,  185,  100,    0,    0,    0,  147,
  148,    0,  142,    0,  137,    0,    0,  108,    0,  128,
  131,  132,  130,    0,  113,    0,  140,    0,    0,  134,
    0,  141,    0,  139,    0,   21,  149,    0,    0,  136,
  143,  138,
};
short yydgoto[] = {                                       5,
    6,    7,    8,   27,    9,   29,   10,   11,   12,  254,
  255,  256,  102,   55,   56,   57,   13,   31,   20,   44,
   68,   97,   45,   46,   69,   70,   89,  114,   90,   91,
   92,  141,   36,   37,  142,  143,  180,  222,  223,   38,
  110,  111,   98,  121,  162,  163,  164,  165,  166,  167,
  168,  169,  170,  206,   58,  266,  231,  285,  319,  306,
  286,  307,  332,  308,  335,  309,  310,  311,  327,  312,
  313,  314,  315,  316,  317,  339,  340,  341,  356,  375,
  352,  353,  354,  378,  263,  289,  207,  259,  237,  238,
  279,  293,  323,  294,  325,  122,  152,  123,  154,  124,
  125,  126,  127,   32,   59,   60,   61,   78,   14,   15,
   16,   48,  103,  173,  213,  104,  267,   50,
};
short yysindex[] = {                                    -81,
 -271, -241, -183, -155,    0,  -81,    0,   79,  107,    0,
    0,    0, -136,    0,    0,    0,  -52,  -52,    0,  -35,
 -171, -145, -134,    0,  107,    0,    0,    0,    0, -242,
    0,    0,    0,    0,    0,  -77,  -83,  -69,    0,    0,
    0,    0,  166,  -56,  195,    0,    0,  -48,  -65,    0,
    0,    0,    0,    0,    0,    0,  251,    0,  263,    0,
 -129,    7,  -26,   58,   45,    7,  -30,   28,    0,    0,
 -231,  -88,    0,    7, -242,    0,    0,    0,    0,   75,
    0,    0,    0,    0,  -35,    0,   44,  315,   96,    0,
    0,    0,  -21,  129,    0,  -27,    0,    0,    0,    0,
    0,    0,  100,  104,    0,    0,  124,  -56,    7,  -33,
  106,  347,    7,    0,    7,  351,  362,    0,  -31,  376,
  180,  165,    0,    0,  399, -102,  -58,    7,    7,    0,
    0,    0,    0,    0, -133,  171,    0,  186,  187, -142,
  409,  407,    0,    0,    0,  168,  347,  347,   -8,  130,
    0,  -31,    0,  -31,    0, -114,  -67,  413,  414,  415,
  416,    0,    0,    0,    0,    0,    0,    0,    0,  -42,
  -61,    0,  151,  151,    7,   44,   44,  167,  169,  -34,
    0,  347,  418,  419,  421,    0,  422,  165,    0,    0,
    0,    0,    0,    0,    0, -209, -209, -209, -209, -139,
 -139, -139, -139, -139, -139,  102,  200,  174,  175,  145,
  145,    7,    0,    0,  192,    0,    0,    0,    0,  160,
    0,  141,    0,    0,  347,    0,    0,    0,  205,  427,
  433,  152,  429,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,  435,  385,    0,    0,
    0,    0,    0,    0,    0,    0,  353,  196,  160,    0,
  437,    7,    0,    0,  438,  158,  -36,    0,  102,    7,
  442,    0,    0,  441,  444,   86,  423,    0,  443,    0,
  445,    0,  393,  446,    0,    0,    0,  447,    0,    0,
  451,  452,    0,    0,    0,  -97,  -13,    0,    0,  -38,
    0,    0,    0,    0,    0,    0, -110,  176,    0,  423,
  177,    0,    0,    0,  102,  423,   86,  -80,  172,    0,
    0,   86,    0,    0,   86,    0,  453,    0, -110,    0,
   72,    0,    0,  454,    0,    0,  -37,    0,    0,    0,
    0,  217,    0,  185,    0,  455,  -13,    0,  459,    0,
    0,    0,    0,    7,    0,  -80,    0,  461,  181,    0,
  463,    0,  183,    0,  235,    0,    0,  465,  181,    0,
    0,    0,
};
short yyrindex[] = {                                      0,
    0,    0,  -28,    0,    0,  487,    0,  502,   65,    0,
    0,    0,   41,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,   65,    0,    0,    0,    0,    0,
    0,    0,    0,    0,   35,    0,    0,    0,    0,    0,
    0,  -29,    0,    0,  225,    0,    0,    0,   59,    0,
    0,    0,    0,    0,    0,   12,    0,    0,   51,    0,
   55,    0,    0,    0,    0,    0,    0,   36,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,   24,    0,
    0,    0,    0,    0,    0,  118,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,  466,    0,    0,    0,    0,    0,    0,  118,    0,
   38,   23,    0,    0,  118,   11,    0,    0,    0,    0,
    0,    0,  162,    0,    0,    0,    0,    0,    0,  -19,
    0,  468,    0,    0,    0,    0,  466,  466,    0,    0,
    0,  118,    0,  118,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
   67,    0,   61,   61,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,   26,    0,    0,
    0,    0,    0,    0,    0,    0,  471,  189,    0, -149,
 -118, -112,   73,   92,   98,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,  466,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,   22,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,  420,    0,
    0,    0,    0,    0,    0,    0,   84,    0,    0,    0,
    0,    0,    0,  424,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  473,  -11,    0,    0,    0,
    0,   95,  109,    0,    0,    0,    0,    0,    0,   84,
    0,    0,    0,    0,    0,   84,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,   77,    0,   -7,    0,
    0,    0,    0,    0,    0,    0,    0,   60,   62,    0,
    0,    0,    0,  274,    0,    0,   37,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,
};
short yygindex[] = {                                      0,
    0,  508,    0,    0,  509,  491,    0,    0,    0, -190,
  154,    0,    0,    0,  -17,   68,    0,    0,    0,  434,
  412,    0,    0,  450,    0,    0,    0,    0,    0,  417,
    0, -104,   13,   40,    0,  340,    0,  303,  255,   42,
    0,  269,    0,  406,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,  -22,  256,  329,    0, -278,  202,
    0,  198,    0,  197,    0,  221,    0,    0,    0, -163,
 -275, -235, -212,    0,  193,    0,  194,    0,    0,    0,
    0,  170,    0,    0,  324,    0,    0,    0,  224,  229,
    0,    0,    0,    0,    0,  386,    0,  383,    0,  425,
    0,    0,    0,    0,    0,  464,    0,    0,    0,    0,
    0,    0,    0,  411,  367,    0,  262,    0,
};
#define YYTABLESIZE 550
short yytable[] = {                                      35,
   35,  300,   42,  365,  290,  220,   40,  137,  119,   87,
  199,   91,  119,   29,   35,  338,   26,  204,  200,  205,
   56,  228,  190,   62,  334,  191,  331,  105,   53,  105,
  127,  127,  186,  127,   66,   77,  127,   79,   17,   41,
  218,  343,  184,  185,   79,   82,   84,  346,   86,   35,
  209,  199,  349,   42,  213,   91,  105,   26,  236,   39,
  226,   53,  228,  190,   12,  362,  191,   42,   18,  199,
   91,   91,   91,   91,   33,  106,   54,  106,   19,   93,
  228,  190,   62,  150,  191,   33,  331,   43,  292,  131,
  349,  133,  350,   66,   77,  144,   79,   79,  213,  218,
  145,   80,  146,  145,  171,  146,   94,   33,   95,  209,
  172,  172,  105,  213,  162,  351,  127,  236,  305,  226,
  271,  135,  234,  235,  150,  300,   89,   89,   89,  178,
  350,   94,  114,  114,  345,  114,   76,   26,   43,   21,
  175,   22,  150,   77,  116,  177,  115,  115,  136,  115,
   47,  174,   43,  351,  146,   94,   30,   79,  179,  330,
  106,   23,   99,  236,  348,   28,  190,   94,   98,   94,
   94,   49,   94,  229,  230,  230,  233,  361,  337,  270,
  145,  156,   51,  157,  269,  131,   99,  132,  257,    1,
  191,   64,   98,  192,  265,   65,   62,    2,   99,   63,
   99,   99,  348,   99,   98,  374,   98,   98,  158,   98,
  159,   66,   53,  193,  215,  382,    3,    4,  114,  330,
  131,  302,  208,  160,  209,  210,   67,  118,  211,  161,
  100,  118,  115,  101,  132,   41,  281,  194,   71,  269,
  195,  303,   29,  304,  333,  105,  301,   72,  151,  127,
  127,   73,  115,   35,  265,   63,  116,  367,   33,  291,
  366,  257,  265,  302,   33,   34,  120,  199,  199,   88,
  201,  202,  203,  138,  221,  380,   91,   91,  379,  190,
   33,   33,  191,  303,   91,  304,   33,   34,   29,   56,
   33,   81,  228,  106,   62,   91,   74,   91,   91,   66,
  228,   91,   62,  199,  127,   66,   75,  257,   48,   49,
   49,   48,   48,   66,  144,  190,   62,  144,  191,  228,
  228,   62,   62,   33,   91,   91,   91,   66,   77,  236,
   79,  226,   66,   66,   62,   12,  165,  236,   96,  226,
  150,  150,   85,   12,  299,   66,  257,  109,  131,  107,
  132,  114,  114,   95,  112,  168,  236,  236,  226,  226,
  113,  171,   12,   12,  128,  115,  115,  150,  129,  150,
  301,  145,   96,  146,   33,   83,  150,   95,   97,   89,
   89,   89,  249,  131,  206,  140,  206,  302,  206,   95,
  147,   95,   95,  303,   95,  304,   96,  132,  133,  206,
  133,  148,   97,   64,  117,  206,  250,  303,   96,  304,
   96,   96,  139,   96,   97,  150,   97,   97,   33,   97,
  251,  252,  153,  253,  239,  241,  243,  245,  247,  240,
  242,  244,  246,  248,  206,   48,  151,   49,  119,   48,
   33,  130,  107,  183,  216,  217,  117,  176,  177,  181,
  182,  187,  196,  197,  198,  199,  212,  225,  218,  226,
  219,  227,  228,  258,  260,  261,  262,  183,  221,  272,
  273,  274,  276,  275,  277,  278,  280,  283,  287,  288,
  296,  297,  298,  320,  318,  322,    1,  326,  321,  324,
  328,  329,  359,  355,  342,  344,  368,  364,  369,  370,
  373,    5,  303,  376,  377,  381,   50,   31,   51,  101,
  101,  104,  183,   24,   25,   52,  184,  371,  108,  132,
   99,  224,  268,  282,  149,  134,  232,  284,  347,  357,
  336,  358,  360,  363,  264,  372,  189,  188,  106,  174,
  214,  295,    0,    0,    0,    0,    0,    0,    0,  155,
};
short yycheck[] = {                                      17,
   18,   40,   20,   41,   41,   40,   42,   41,   40,   40,
    0,    0,   40,   42,   44,  126,   46,   60,   61,   62,
   40,    0,    0,    0,   38,    0,  124,   39,  271,   41,
   38,   39,   41,   41,    0,    0,   44,    0,  310,  271,
    0,  320,  147,  148,   62,   63,   64,  326,   66,   67,
    0,   41,  328,   71,    0,   44,   74,   46,    0,   18,
    0,  271,   41,   41,    0,  341,   41,   85,  310,   59,
   59,   60,   61,   62,  317,   39,  319,   41,  262,   67,
   59,   59,   59,    0,   59,  317,  124,   20,  279,  107,
  366,  109,  328,   59,   59,  113,   59,  115,   44,   59,
   41,   62,   41,   44,  127,   44,   67,  317,   67,   59,
  128,  129,  124,   59,  264,  328,  124,   59,   33,   59,
  225,  109,  262,  263,   41,   40,   60,   61,   62,  272,
  366,  281,   38,   39,  325,   41,  266,   59,   71,  295,
  274,  297,   59,  273,  278,  264,   38,   39,  109,   41,
  322,  264,   85,  366,  115,  305,  293,  175,  301,  257,
  124,  317,  281,  303,  328,   59,  281,  317,  281,  319,
  320,  317,  322,  196,  197,  198,  199,  341,  289,   39,
  113,  284,  317,  286,   44,  126,  305,  126,  206,  271,
  305,  275,  305,  308,  212,  265,  274,  279,  317,  277,
  319,  320,  366,  322,  317,  369,  319,  320,  267,  322,
  269,   46,  271,  281,  175,  379,  298,  299,  124,  257,
  126,  302,  284,  282,  286,  287,  283,  259,  290,  288,
  319,  259,  124,  322,  126,  271,   41,  305,   44,   44,
  308,  322,  271,  324,  258,  257,  285,  296,  257,  257,
  258,  317,  274,  283,  272,  277,  278,   41,  317,  277,
   44,  279,  280,  302,  317,  318,  294,  257,  258,  300,
  313,  314,  315,  307,  309,   41,  265,  266,   44,  257,
  317,  317,  257,  322,  273,  324,  317,  318,  317,  309,
  317,  318,  271,  257,  271,  284,   46,  286,  287,  265,
  279,  290,  279,  293,  312,  271,   44,  325,  274,  275,
  276,  277,  278,  279,   41,  293,  293,   44,  293,  298,
  299,  298,  299,  317,  313,  314,  315,  293,  293,  271,
  293,  271,  298,  299,  311,  271,  264,  279,  311,  279,
  257,  258,  298,  279,  259,  311,  364,  304,  289,  275,
  289,  257,  258,  281,   40,  264,  298,  299,  298,  299,
  265,  264,  298,  299,  265,  257,  258,  284,  265,  286,
  285,  312,  281,  312,  317,  318,  293,  305,  281,  313,
  314,  315,  281,  289,  267,   39,  269,  302,  271,  317,
   40,  319,  320,  322,  322,  324,  305,  289,  322,  282,
  324,   40,  305,  275,  276,  288,  305,  322,  317,  324,
  319,  320,  307,  322,  317,   40,  319,  320,  317,  322,
  319,  320,  258,  322,  201,  202,  203,  204,  205,  201,
  202,  203,  204,  205,  317,  274,  257,  276,   40,  278,
  317,  318,  275,  276,  176,  177,  276,  262,  262,   41,
   44,  322,   40,   40,   40,   40,  306,   40,  292,   41,
  292,   41,   41,  264,  291,  291,  322,  276,  309,  265,
   44,   39,   44,  322,   40,   91,  124,   41,   41,  322,
   39,   41,   39,   41,   62,   93,    0,   41,   44,   44,
   40,   40,   40,  322,  319,  319,  312,   44,   44,   41,
   40,    0,  322,   41,  322,   41,   41,  283,   41,   39,
  322,   39,   93,    6,    6,   25,   93,  364,   85,  108,
   71,  182,  220,  269,  119,  109,  198,  272,  327,  332,
  310,  335,  339,  341,  211,  366,  154,  152,   75,  129,
  174,  280,   -1,   -1,   -1,   -1,   -1,   -1,   -1,  125,
};
#define YYFINAL 5
#ifndef YYDEBUG
#define YYDEBUG 0
#endif
#define YYMAXTOKEN 325
#if YYDEBUG != 0 || defined (YYERROR_VERBOSE)
char *yyname[] = {
"end-of-file",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
"'!'",0,0,0,0,"'&'","'\\''","'('","')'","'*'","'+'","','","'-'","'.'","'/'",0,0,
0,0,0,0,0,0,0,0,0,"';'","'<'","'='","'>'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,"'['",0,"']'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,"'|'",0,"'~'",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"_OR","_AND","_NOT","_UMINUS",
"mHighest","_ALL","_ANY","_ARRAY","_AS","_ASC","_CAST","_COERCE","_CONTAINS",
"_CONTENTS","_CREATE","_DEEP_TRAVERSAL","_DESC","_DOT","_DOTDOT",
"_DOTDOT_SCOPE","_DOTDOTDOT","_DOTDOTDOT_SCOPE","_DROP",
"_EXCLUDE_SEARCH_TRAVERSAL","_FALSE","_FREETEXT","_FROM","_IS","_ISABOUT",
"_IS_NOT","_LIKE","_MATCHES","_NEAR","_NOT_LIKE","_NULL","_OF","_ORDER_BY",
"_PASSTHROUGH","_PROPERTYNAME","_PROPID","_RANKMETHOD","_SELECT","_SET",
"_SCOPE","_SHALLOW_TRAVERSAL","_FORMSOF","_SOME","_TABLE","_TRUE","_TYPE",
"_UNION","_UNKNOWN","_URL","_VIEW","_WHERE","_WEIGHT","_GE","_LE","_NE",
"_CONST","_ID","_TEMPVIEW","_INTNUM","_REALNUM","_SCALAR_FUNCTION_REF",
"_STRING","_DATE","_PREFIX_STRING","_DELIMITED_ID",
};
char *yyrule[] = {
"$accept : entry_point",
"entry_point : definition_list",
"entry_point : definition_list executable_statement",
"entry_point : executable_statement",
"executable_statement : ordered_query_specification semicolon",
"semicolon :",
"semicolon : ';'",
"definition_list : definition_list definition opt_semi",
"definition_list : definition opt_semi",
"definition : create_view_statement",
"definition : drop_view_statement",
"definition : set_statement",
"opt_semi :",
"opt_semi : ';'",
"typed_literal : _INTNUM",
"typed_literal : _REALNUM",
"typed_literal : _STRING",
"typed_literal : relative_date_time",
"typed_literal : boolean_literal",
"unsigned_integer : _INTNUM",
"integer : _INTNUM",
"relative_date_time : identifier '(' identifier ',' _INTNUM ',' relative_date_time ')'",
"relative_date_time : identifier '(' ')'",
"boolean_literal : _TRUE",
"boolean_literal : _FALSE",
"identifier : _ID",
"correlation_name : identifier",
"ordered_query_specification : query_specification opt_order_by_clause",
"query_specification : _SELECT opt_set_quantifier select_list from_clause opt_where_clause",
"opt_set_quantifier :",
"opt_set_quantifier : _ALL",
"select_list : select_sublist",
"select_list : '*'",
"select_sublist : select_sublist ',' derived_column",
"select_sublist : derived_column",
"derived_column : identifier",
"derived_column : correlation_name '.' identifier",
"derived_column : _CREATE",
"from_clause : common_from_clause",
"from_clause : from_view_clause",
"common_from_clause : _FROM scope_specification opt_AS_clause",
"scope_specification : unqualified_scope_specification",
"scope_specification : qualified_scope_specification",
"scope_specification : union_all_scope_specification",
"unqualified_scope_specification : _SCOPE '(' scope_definition ')'",
"qualified_scope_specification : machine_name _DOTDOTDOT_SCOPE '(' scope_definition ')'",
"qualified_scope_specification : machine_name _DOT catalog_name _DOTDOT_SCOPE '(' scope_definition ')'",
"qualified_scope_specification : catalog_name _DOTDOT_SCOPE '(' scope_definition ')'",
"machine_name : identifier",
"catalog_name : identifier",
"scope_definition :",
"scope_definition : scope_element_list",
"scope_element_list : scope_element_list ',' scope_element",
"scope_element_list : scope_element",
"scope_element : '\\'' opt_traversal_exclusivity path_or_virtual_root_list '\\''",
"scope_element : '\\'' opt_traversal_exclusivity '(' path_or_virtual_root_list ')' '\\''",
"opt_traversal_exclusivity :",
"opt_traversal_exclusivity : _DEEP_TRAVERSAL _OF",
"opt_traversal_exclusivity : _SHALLOW_TRAVERSAL _OF",
"path_or_virtual_root_list : path_or_virtual_root_list ',' path_or_virtual_root",
"path_or_virtual_root_list : path_or_virtual_root",
"path_or_virtual_root : _URL",
"opt_AS_clause :",
"opt_AS_clause : _AS correlation_name",
"from_view_clause : _FROM view_name",
"view_name : _TEMPVIEW",
"view_name : identifier",
"view_name : catalog_name _DOTDOT _TEMPVIEW",
"view_name : catalog_name _DOTDOT identifier",
"view_name : machine_name _DOT catalog_name _DOTDOT _TEMPVIEW",
"view_name : machine_name _DOT catalog_name _DOTDOT identifier",
"view_name : machine_name _DOTDOTDOT identifier",
"view_name : machine_name _DOTDOTDOT _TEMPVIEW",
"union_all_scope_specification : '(' union_all_scope_element ')'",
"union_all_scope_element : union_all_scope_element _UNION _ALL explicit_table",
"union_all_scope_element : explicit_table _UNION _ALL explicit_table",
"explicit_table : _TABLE qualified_scope_specification",
"opt_where_clause :",
"opt_where_clause : where_clause",
"where_clause : _WHERE search_condition",
"where_clause : _WHERE _PASSTHROUGH '(' _STRING ')'",
"predicate : comparison_predicate",
"predicate : contains_predicate",
"predicate : freetext_predicate",
"predicate : like_predicate",
"predicate : matches_predicate",
"predicate : vector_comparison_predicate",
"predicate : null_predicate",
"comparison_predicate : column_reference_or_cast comp_op typed_literal",
"column_reference_or_cast : column_reference",
"column_reference_or_cast : _CAST '(' column_reference _AS dbtype ')'",
"column_reference : identifier",
"column_reference : correlation_name '.' identifier",
"column_reference : _CREATE",
"comp_op : '='",
"comp_op : _NE",
"comp_op : '<'",
"comp_op : '>'",
"comp_op : _LE",
"comp_op : _GE",
"contains_predicate : _CONTAINS '(' opt_contents_column_reference '\\'' content_search_condition '\\'' ')' opt_greater_than_zero",
"opt_contents_column_reference :",
"opt_contents_column_reference : column_reference ','",
"$$1 :",
"content_search_condition : $$1 content_search_cond",
"content_search_cond : content_boolean_term",
"content_search_cond : content_search_cond or_operator content_boolean_term",
"content_boolean_term : content_boolean_factor",
"content_boolean_term : content_boolean_term and_operator content_boolean_factor",
"content_boolean_factor : content_boolean_primary",
"content_boolean_factor : not_operator content_boolean_primary",
"content_boolean_primary : content_search_term",
"$$2 :",
"content_boolean_primary : '(' $$2 content_search_cond ')'",
"content_search_term : simple_term",
"content_search_term : prefix_term",
"content_search_term : proximity_term",
"content_search_term : stemming_term",
"content_search_term : isabout_term",
"or_operator : _OR",
"or_operator : '|'",
"and_operator : _AND",
"and_operator : '&'",
"not_operator : _NOT",
"not_operator : '!'",
"simple_term : _STRING",
"prefix_term : _PREFIX_STRING",
"proximity_term : proximity_operand proximity_expression_list",
"proximity_expression_list : proximity_expression_list proximity_expression",
"proximity_expression_list : proximity_expression",
"proximity_expression : proximity_specification proximity_operand",
"proximity_operand : simple_term",
"proximity_operand : prefix_term",
"proximity_specification : _NEAR",
"proximity_specification : _NEAR '(' ')'",
"proximity_specification : '~'",
"stemming_term : _FORMSOF '(' stem_type ',' stemmed_simple_term_list ')'",
"stem_type : _STRING",
"stemmed_simple_term_list : stemmed_simple_term_list ',' simple_term",
"stemmed_simple_term_list : simple_term",
"isabout_term : _ISABOUT '(' vector_component_list ')'",
"vector_component_list : vector_component_list ',' vector_component",
"vector_component_list : vector_component",
"vector_component : vector_term _WEIGHT '(' weight_value ')'",
"vector_component : vector_term",
"vector_term : simple_term",
"vector_term : prefix_term",
"vector_term : proximity_term",
"vector_term : stemming_term",
"weight_value : _STRING",
"opt_greater_than_zero :",
"opt_greater_than_zero : '>' _INTNUM",
"freetext_predicate : _FREETEXT '(' opt_contents_column_reference _STRING ')' opt_greater_than_zero",
"like_predicate : column_reference _LIKE wildcard_search_pattern",
"like_predicate : column_reference _NOT_LIKE wildcard_search_pattern",
"wildcard_search_pattern : _STRING",
"matches_predicate : _MATCHES '(' column_reference ',' matches_string ')' opt_greater_than_zero",
"matches_string : _STRING",
"vector_comparison_predicate : column_reference_or_cast vector_comp_op vector_literal",
"all : _ALL",
"some : _SOME",
"some : _ANY",
"vector_comp_op : '='",
"vector_comp_op : '=' all",
"vector_comp_op : '=' some",
"vector_comp_op : _NE",
"vector_comp_op : _NE all",
"vector_comp_op : _NE some",
"vector_comp_op : '<'",
"vector_comp_op : '<' all",
"vector_comp_op : '<' some",
"vector_comp_op : '>'",
"vector_comp_op : '>' all",
"vector_comp_op : '>' some",
"vector_comp_op : _LE",
"vector_comp_op : _LE all",
"vector_comp_op : _LE some",
"vector_comp_op : _GE",
"vector_comp_op : _GE all",
"vector_comp_op : _GE some",
"vector_literal : _ARRAY left_sqbrkt opt_literal_list right_sqbrkt",
"left_sqbrkt : '['",
"right_sqbrkt : ']'",
"opt_literal_list :",
"opt_literal_list : literal_list",
"literal_list : literal_list comma typed_literal",
"literal_list : typed_literal",
"comma : ','",
"null_predicate : column_reference _IS _NULL",
"null_predicate : column_reference _IS_NOT _NULL",
"search_condition : boolean_term",
"search_condition : search_condition or_op boolean_term",
"boolean_term : boolean_factor",
"boolean_term : boolean_term and_op boolean_factor",
"boolean_factor : boolean_test",
"boolean_factor : not_op boolean_test",
"or_op : _OR",
"and_op : _AND",
"not_op : _NOT",
"boolean_test : boolean_primary",
"boolean_test : boolean_primary _IS _TRUE",
"boolean_test : boolean_primary _IS _FALSE",
"boolean_test : boolean_primary _IS _UNKNOWN",
"boolean_test : boolean_primary _IS_NOT _TRUE",
"boolean_test : boolean_primary _IS_NOT _FALSE",
"boolean_test : boolean_primary _IS_NOT _UNKNOWN",
"$$3 :",
"boolean_primary : $$3 predicate",
"boolean_primary : '(' search_condition ')'",
"order_by_clause : _ORDER_BY sort_specification_list",
"sort_specification_list : sort_specification_list ',' sort_specification",
"sort_specification_list : sort_specification",
"sort_specification : sort_key opt_ordering_specification",
"opt_ordering_specification :",
"opt_ordering_specification : _ASC",
"opt_ordering_specification : _DESC",
"sort_key : column_reference",
"sort_key : integer",
"opt_order_by_clause :",
"opt_order_by_clause : order_by_clause",
"set_statement : set_propertyname_statement",
"set_statement : set_rankmethod_statement",
"set_statement : set_global_directive",
"set_propertyname_statement : _SET _PROPERTYNAME guid_format _PROPID property_id _AS column_alias opt_type_clause",
"set_propertyname_statement : _SET _PROPERTYNAME guid_format _PROPID property_name _AS column_alias opt_type_clause",
"column_alias : identifier",
"opt_type_clause :",
"opt_type_clause : _TYPE dbtype",
"dbtype : base_dbtype",
"dbtype : base_dbtype '|' base_dbtype",
"base_dbtype : identifier",
"property_id : unsigned_integer",
"property_name : _STRING",
"guid_format : _STRING",
"set_rankmethod_statement : _SET _RANKMETHOD rankmethod",
"rankmethod : _ID _ID",
"rankmethod : _ID",
"set_global_directive : _SET _ID _ID",
"create_view_statement : _CREATE _VIEW view_name _AS _SELECT select_list from_clause",
"drop_view_statement : _DROP _VIEW view_name",
};
#endif
#ifndef YYSTYPE
typedef int YYSTYPE;
#endif
YYPARSER::YYPARSER(CImpIParserSession* pParserSession, CImpIParserTreeProperties* pParserTreeProperties, YYLEXER & yylex)
        : CYYBase( pParserSession, pParserTreeProperties, yylex ) {
    xyyvs.SetSize(INITSTACKSIZE);
    yydebug = 0;
}
#define YYABORT(sc) { EmptyValueStack( yylval ); return ResultFromScode(sc); }
#define YYFATAL QPARSE_E_INVALID_QUERY
#define YYSUCCESS S_OK
#define YYREJECT goto yyabort
#define YYACCEPT goto yyaccept
int mystrlen(char * str)
{
    Win4Assert( 0 != str );
    int i = 0;
    while ( 0 != str[i] )
        i++;
    return i;        
}
void YYPARSER::ResetParser()
{
     yynerrs = 0;
    yyerrflag = 0;
    yychar = (-1);

yyssp = xyyss.Get();
yyvsp = xyyvs.Get();
    *yyssp = 0;
}

void YYPARSER::PopVs()
{
    if ( NULL != *yyvsp ) 
        DeleteDBQT(*yyvsp);
    yyvsp--;
}

void YYPARSER::EmptyValueStack( YYAPI_VALUETYPE yylval )
{
    if ( yyvsp != NULL ) 
    {
        if ((*yyvsp != yylval) && (NULL != yylval))
            DeleteDBQT(yylval);

        unsigned cCount = (unsigned)ULONG_PTR(yyvsp - xyyvs.Get());
        for ( unsigned i=0; i < cCount; i++ )
        {
            if (NULL != xyyvs[i] )
                DeleteDBQT(xyyvs[i]);
        }
    }

   //@TODO RE-ACTIVATE
   // note:  This was only done to empty any scope arrays
   //      m_pIPSession->SetScopeProperties(m_pICommand);

        m_pIPTProperties->SetContainsColumn(NULL);
}

int YYPARSER::Parse()
{
    register int yym, yyn, yystate;
#if YYDEBUG
    register char *yys;

    if (yys = getenv("YYDEBUG"))
    {
        yyn = *yys;
        if (yyn >= '0' && yyn <= '9')
            yydebug = yyn - '0';
    }
#endif

    yynerrs = 0;
    yyerrflag = 0;
    yychar = (-1);

yyssp = xyyss.Get();
yyvsp = xyyvs.Get();
    *yyssp = yystate = 0;

yyloop:
    if (yyn = yydefred[yystate]) goto yyreduce;
    if (yychar < 0)
    {
        YYAPI_VALUENAME = NULL;
        try
        {
            if ( (yychar = YYLEX(&YYAPI_VALUENAME)) < 0 ) 
                yychar = 0;
        }
        catch (HRESULT hr)
        {
            switch(hr)
            {
            case E_OUTOFMEMORY:
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT(E_OUTOFMEMORY);
                break;

            default:
                YYABORT(QPARSE_E_INVALID_QUERY);
                break;
            }
        }
#if YYDEBUG
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            printf("%sdebug: state %d, reading %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
    }
    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
#if YYDEBUG
        if (yydebug)
            printf("%sdebug: state %d, shifting to state %d\n",
                    YYPREFIX, yystate, yytable[yyn]);
#endif
        if ( yyssp >= xyyss.Get() + xyyss.Count() - 1 )
        {
            int yysspLoc = (int) ( yyssp - xyyss.Get() );
            xyyss.SetSize((unsigned) (yyssp-xyyss.Get())+2);
            yyssp = xyyss.Get() + yysspLoc;
        }
        if ( yyvsp >= xyyvs.Get() + xyyvs.Size() - 1 )
        {
            int yyvspLoc = (int) ( yyvsp - xyyvs.Get() );
            xyyvs.SetSize((unsigned) (yyvsp-xyyvs.Get())+2); 
            yyvsp = xyyvs.Get() + yyvspLoc;
        }
        *++yyssp = yystate = yytable[yyn];
        *++yyvsp = yylval;
        yychar = (-1);
        if (yyerrflag > 0)  --yyerrflag;
        goto yyloop;
    }
    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
        yyn = yytable[yyn];
        goto yyreduce;
    }
#ifdef YYERROR_VERBOSE
// error reporting; done before the goto error recovery
{

    // must be first - cleans m_pIPTProperties
    m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_PARSE_ERROR);

    int size = 0, totSize = 0;
    int curr_yychar;
    XGrowable<WCHAR> xMsg;
    for ( curr_yychar =0; curr_yychar<=YYMAXTOKEN; curr_yychar++)
    {
    
        if ( ( yycheck[yysindex[yystate] + curr_yychar] == curr_yychar ) ||
             ( yycheck[yyrindex[yystate] + curr_yychar] == curr_yychar ) )
        {          
         
            char * token_name = yyname[curr_yychar];
            if ( 0 != token_name )
            {
               if ( '_' == token_name[0] )
                   token_name++;
               size = mystrlen(token_name) + 1 ;
               xMsg.SetSize(totSize+size+2); // +2 for ", "
               if (0 == MultiByteToWideChar(CP_ACP, 0, token_name, size,
                                            xMsg.Get()+totSize, size))
               {
                    break;
               }
               totSize += size-1;
               wcscpy( xMsg.Get()+totSize, L", " );
               totSize+=2;
            }
        }
    }
    // get rid of last comma
    if ( totSize >= 2 ) 
        (xMsg.Get())[totSize-2] = 0;

    if ( wcslen((YY_CHAR*)m_yylex.YYText()) )
         m_pIPTProperties->SetErrorToken( (YY_CHAR*)m_yylex.YYText() );
    else
         m_pIPTProperties->SetErrorToken(L"<end of input>");
    
    m_pIPTProperties->SetErrorToken(xMsg.Get());
}
#endif //YYERROR_VERBOSE
    if (yyerrflag) goto yyinrecovery;
    yyerror("syntax error");
    ++yynerrs;
yyinrecovery:
    if (yyerrflag < 3)
    {
        yyerrflag = 3;
        for (;;)
        {
            if ((yyn = yysindex[*yyssp]) && (yyn += YYERRCODE) >= 0 &&
                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)
            {
#if YYDEBUG
                if (yydebug)
                    printf("%sdebug: state %d, error recovery shifting\
 to state %d\n", YYPREFIX, *yyssp, yytable[yyn]);
#endif
                if ( yyssp >= xyyss.Get() + xyyss.Count() - 1 )
                {
                    int yysspLoc = (int) ( yyssp - xyyss.Get() );
                    xyyss.SetSize((unsigned) (yyssp-xyyss.Get())+2);
                    yyssp = xyyss.Get() + yysspLoc;
                }
                if ( yyvsp >= xyyvs.Get() + xyyvs.Size() - 1 )
                {
                    int yyvspLoc = (int) ( yyvsp - xyyvs.Get() );
                    xyyvs.SetSize((unsigned) (yyvsp-xyyvs.Get())+2); 
                    yyvsp = xyyvs.Get() + yyvspLoc;
                }
                *++yyssp = yystate = yytable[yyn];
                *++yyvsp = yylval;
                goto yyloop;
            }
            else
            {
#if YYDEBUG
                if (yydebug)
                    printf("%sdebug: error recovery discarding state %d\
",
                            YYPREFIX, *yyssp);
#endif
                if (yyssp <= xyyss.Get()) goto yyabort;
                PopVs();
                --yyssp;
            }
        }
    }
    else
    {
        if (yychar == 0) goto yyabort;
#if YYDEBUG
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            printf("%sdebug: state %d, error recovery discards token %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
        yychar = (-1);
        goto yyloop;
    }
yyreduce:
#if YYDEBUG
    if (yydebug)
        printf("%sdebug: state %d, reducing by rule %d (%s)\n",
                YYPREFIX, yystate, yyn, yyrule[yyn]);
#endif
    yym = yylen[yyn];
    yyval = yyvsp[1-yym];
    switch (yyn)
    {
case 1:
{
            yyval = NULL;
            }
break;
case 2:
{
            yyval = yyvsp[0];
            }
break;
case 3:
{
            yyval = yyvsp[0];
            }
break;
case 4:
{
            if (yyvsp[0])
                {
                /* There is a semicolon, either as a statement terminator or as*/
                /* a statement separator.  We don't allow either of those.*/
                m_pIPTProperties->SetErrorHResult(DB_E_MULTIPLESTATEMENTS, MONSQL_SEMI_COLON);
                YYABORT(DB_E_MULTIPLESTATEMENTS);
                }
            yyval = yyvsp[-1];
            }
break;
case 5:
{
            yyval = NULL;
            }
break;
case 6:
{
            yyval = PctAllocNode(DBVALUEKIND_NULL, DBOP_NULL);
            }
break;
case 7:
{
            yyval = NULL;
            }
break;
case 8:
{
            yyval = NULL;
            }
break;
case 9:
{
            yyval = NULL;
            }
break;
case 10:
{
            yyval = NULL;
            }
break;
case 11:
{
            yyval = NULL;
            }
break;
case 14:
{
            AssertReq(yyvsp[0]);
            Assert(VT_UI8 == ((PROPVARIANT*)yyvsp[0]->value.pvValue)->vt ||
                    VT_I8 == ((PROPVARIANT*)yyvsp[0]->value.pvValue)->vt ||
                    VT_BSTR == ((PROPVARIANT*)yyvsp[0]->value.pvValue)->vt);

            m_pIPTProperties->AppendCiRestriction((YY_CHAR*)m_yylex.YYText(), wcslen(m_yylex.YYText()));

            HRESULT hr = CoerceScalar(m_pIPTProperties->GetDBType(), &yyvsp[0]);
            if (S_OK != hr)
                YYABORT(hr);
            yyval = yyvsp[0];
            }
break;
case 15:
{
            AssertReq(yyvsp[0]);
            Assert(VT_R8 == ((PROPVARIANT*)yyvsp[0]->value.pvValue)->vt ||
                    VT_BSTR == ((PROPVARIANT*)yyvsp[0]->value.pvValue)->vt);

            m_pIPTProperties->AppendCiRestriction((YY_CHAR*)m_yylex.YYText(), wcslen(m_yylex.YYText()));

            HRESULT hr = CoerceScalar(m_pIPTProperties->GetDBType(), &yyvsp[0]);
            if (S_OK != hr)
                YYABORT(hr);
            yyval = yyvsp[0];
            }
break;
case 16:
{
            AssertReq(yyvsp[0]);
            Assert(VT_BSTR == ((PROPVARIANT*)yyvsp[0]->value.pvValue)->vt);

            if (VT_DATE     == m_pIPTProperties->GetDBType() ||
                VT_FILETIME == m_pIPTProperties->GetDBType())
                m_pIPTProperties->AppendCiRestriction(((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal,
                                                wcslen(((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal));
            else
                {
                m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L"\""));
                m_pIPTProperties->AppendCiRestriction(((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal,
                                                wcslen(((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal));
                m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L"\""));
                }

            HRESULT hr = CoerceScalar(m_pIPTProperties->GetDBType(), &yyvsp[0]);
            if (S_OK != hr)
                YYABORT(hr);
            yyval = yyvsp[0];
            }
break;
case 17:
{
            AssertReq(yyvsp[0]);
            Assert(VT_FILETIME == ((PROPVARIANT*)yyvsp[0]->value.pvValue)->vt);

            SYSTEMTIME stValue = {0, 0, 0, 0, 0, 0, 0, 0};
            if (FileTimeToSystemTime(&(((PROPVARIANT*)yyvsp[0]->value.pvValue)->filetime), &stValue))
                {
                WCHAR wchDateTime[50];
                if (NULL == wchDateTime)
                    {
                    m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                    YYABORT(E_OUTOFMEMORY);
                    }

                int cItems = swprintf(wchDateTime, L" %4d/%02d/%02d %02d:%02d:%02d",
                                                    stValue.wYear,
                                                    stValue.wMonth,
                                                    stValue.wDay,
                                                    stValue.wHour,
                                                    stValue.wMinute,
                                                    stValue.wSecond);
                m_pIPTProperties->AppendCiRestriction(wchDateTime, wcslen(wchDateTime));
                }

            HRESULT hr = CoerceScalar(m_pIPTProperties->GetDBType(), &yyvsp[0]);
            if (S_OK != hr)
                YYABORT(hr);

            yyval = yyvsp[0];
        }
break;
case 18:
{
            m_pIPTProperties->AppendCiRestriction((YY_CHAR*)m_yylex.YYText(), wcslen(m_yylex.YYText()));

            HRESULT hr = CoerceScalar(m_pIPTProperties->GetDBType(), &yyvsp[0]);
            if (S_OK != hr)
                YYABORT(hr);
            yyval = yyvsp[0];
            }
break;
case 19:
{
            HRESULT hr = CoerceScalar(VT_UI4, &yyvsp[0]);
            if (S_OK != hr)
                YYABORT(hr);
            yyval = yyvsp[0];
            }
break;
case 20:
{
            HRESULT hr = CoerceScalar(VT_I4, &yyvsp[0]);
            if (S_OK != hr)
                YYABORT(hr);
            yyval = yyvsp[0];
            }
break;
case 21:
{
            /* should be DateAdd(<datepart>, <negative integer>, <relative date/time>)*/
            AssertReq(yyvsp[-7]);
            AssertReq(yyvsp[-5]);
            AssertReq(yyvsp[-3]);
            AssertReq(yyvsp[-1]);

            if (0 != _wcsicmp(L"DateAdd", yyvsp[-7]->value.pwszValue))
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_PARSE_ERROR);
                m_pIPTProperties->SetErrorToken(yyvsp[-7]->value.pwszValue);
                m_pIPTProperties->SetErrorToken(L"DateAdd");
                YYABORT(DB_E_ERRORSINCOMMAND);
                }

            HRESULT hr = CoerceScalar(VT_I4, &yyvsp[-3]);
            if (S_OK != hr)
                YYABORT(hr);

            if (((PROPVARIANT*)yyvsp[-3]->value.pvValue)->iVal > 0)
                {
                WCHAR wchError[30];
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_PARSE_ERROR);
                swprintf(wchError, L"%d", ((PROPVARIANT*)yyvsp[-3]->value.pvValue)->iVal);
                m_pIPTProperties->SetErrorToken(wchError);
                swprintf(wchError, L"%d", -((PROPVARIANT*)yyvsp[-3]->value.pvValue)->iVal);
                m_pIPTProperties->SetErrorToken(wchError);
                YYABORT(DB_E_ERRORSINCOMMAND);
                }

            LARGE_INTEGER hWeek     =   {686047232,    1408};
            LARGE_INTEGER hDay      =   {711573504,     201};
            LARGE_INTEGER hHour     =   {1640261632,      8};
            LARGE_INTEGER hMinute   =   {600000000,       0};
            LARGE_INTEGER hSecond   =   {10000000,        0};

            LARGE_INTEGER hIncr = {0,0};

            bool    fHandleMonth = false;
            ULONG   ulMonths = 1;

            switch ( yyvsp[-5]->value.pwszValue[0] )
                {
                case L'Y':
                case L'y':
                    if (0 == (_wcsicmp(L"YY", yyvsp[-5]->value.pwszValue) & _wcsicmp(L"YEAR", yyvsp[-5]->value.pwszValue)))
                    {
                        /* fall through and handle as 12 months*/
                        ulMonths = 12;
                    }

                case L'Q':
                case L'q':
                    if (0 == (_wcsicmp(L"QQ", yyvsp[-5]->value.pwszValue) & _wcsicmp(L"QUARTER", yyvsp[-5]->value.pwszValue)))
                    {
                        /* fall through and handle as 3 months*/
                        ulMonths = 3;
                    }

                case L'M':
                case L'm':
                    if ( 0 == (_wcsicmp(L"YY", yyvsp[-5]->value.pwszValue) & _wcsicmp(L"YEAR", yyvsp[-5]->value.pwszValue)) ||
                         0 == (_wcsicmp(L"QQ", yyvsp[-5]->value.pwszValue) & _wcsicmp(L"QUARTER", yyvsp[-5]->value.pwszValue)) ||
                         0 == (_wcsicmp(L"MM", yyvsp[-5]->value.pwszValue) & _wcsicmp(L"MONTH", yyvsp[-5]->value.pwszValue)))
                    {
                        /**/
                        /* Convert to system time*/
                        /**/
                        SYSTEMTIME st = { 0, 0, 0, 0, 0, 0, 0, 0 };
                        FileTimeToSystemTime( &((PROPVARIANT*)yyvsp[-1]->value.pvValue)->filetime, &st );

                        LONGLONG llDays       =  0;
                        LONG     lMonthsLeft = ulMonths * -((PROPVARIANT*)yyvsp[-3]->value.pvValue)->iVal;
                        LONG     yr          = st.wYear;
                        LONG     lCurMonth   = st.wMonth-1;

                        while ( lMonthsLeft )
                        {
                            LONG lMonthsDone = 1;
                            while ( lMonthsDone<=lMonthsLeft )
                            {
                                /* Will we still be in the current year when looking at the prev month?*/
                                if ( 0 == lCurMonth )
                                    break;

                                /* Subtract the number of days in the previous month.  We will adjust*/
                                llDays += DaysInMonth( yr, lCurMonth-1);

                                lMonthsDone++;
                                lCurMonth--;
                            }

                            /* Months left over in prev year*/
                            lMonthsLeft -= lMonthsDone-1;

                            if ( 0 != lMonthsLeft )
                            {
                                yr--;
                                lCurMonth = 12;  /* 11 is December.*/
                            }
                        }

                        /**/
                        /* adjust current date to at most max of destination month*/
                        /**/
                        if ( llDays > 0 && st.wDay > DaysInMonth(yr, lCurMonth-1) )
                            llDays += st.wDay - DaysInMonth(yr, lCurMonth-1);

                        hIncr.QuadPart = hDay.QuadPart * llDays;
                        fHandleMonth = true;
                    }
                    else if (0 == (_wcsicmp(L"MI", yyvsp[-5]->value.pwszValue) & _wcsicmp(L"MINUTE", yyvsp[-5]->value.pwszValue)))
                        hIncr = hMinute;
                    break;

                case L'W':
                case L'w':
                    if (0 == (_wcsicmp(L"WK", yyvsp[-5]->value.pwszValue) & _wcsicmp(L"WEEK", yyvsp[-5]->value.pwszValue)))
                        hIncr = hWeek;
                    break;

                case L'D':
                case L'd':
                    if (0 == (_wcsicmp(L"DD", yyvsp[-5]->value.pwszValue) & _wcsicmp(L"DAY", yyvsp[-5]->value.pwszValue)))
                        hIncr = hDay;
                    break;

                case L'H':
                case L'h':
                    if (0 == (_wcsicmp(L"HH", yyvsp[-5]->value.pwszValue) & _wcsicmp(L"HOUR", yyvsp[-5]->value.pwszValue)))
                        hIncr = hHour;
                    break;

                case L'S':
                case L's':
                    if (0 == (_wcsicmp(L"SS", yyvsp[-5]->value.pwszValue) & _wcsicmp(L"SECOND", yyvsp[-5]->value.pwszValue)))
                        hIncr = hSecond;
                    break;

                default:
                    break;
                }

            if (0 == hIncr.LowPart && 0 == hIncr.HighPart)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_PARSE_ERROR);
                m_pIPTProperties->SetErrorToken(yyvsp[-5]->value.pwszValue);
                m_pIPTProperties->SetErrorToken(
                    L"YEAR, QUARTER, MONTH, WEEK, DAY, HOUR, MINUTE, SECOND");
                YYABORT(DB_E_ERRORSINCOMMAND);
                }

            if ( fHandleMonth )
            {
                ((PROPVARIANT*)yyvsp[-1]->value.pvValue)->hVal.QuadPart -= hIncr.QuadPart;
#ifdef DEBUG
                SYSTEMTIME st1 = { 0, 0, 0, 0, 0, 0, 0, 0 };
                FileTimeToSystemTime( &((PROPVARIANT*)yyvsp[-1]->value.pvValue)->filetime, &st1 );
#endif
            }
            else
            {
                for (int i = 0; i < -((PROPVARIANT*)yyvsp[-3]->value.pvValue)->iVal; i++)
                    ((PROPVARIANT*)yyvsp[-1]->value.pvValue)->hVal.QuadPart -= hIncr.QuadPart;
            }

            yyval = yyvsp[-1];
            DeleteDBQT(yyvsp[-7]);
            DeleteDBQT(yyvsp[-5]);
            DeleteDBQT(yyvsp[-3]);
            }
break;
case 22:
{
            /* should be getgmdate()*/
            AssertReq(yyvsp[-2]);

            if (0 != _wcsicmp(L"GetGMTDate", yyvsp[-2]->value.pwszValue))
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_PARSE_ERROR);
                m_pIPTProperties->SetErrorToken(yyvsp[-2]->value.pwszValue);
                m_pIPTProperties->SetErrorToken(L"GetGMTDate");
                YYABORT(DB_E_ERRORSINCOMMAND);
                }
            DeleteDBQT(yyvsp[-2]);
            yyvsp[-2] = 0;

            yyval = PctAllocNode(DBVALUEKIND_VARIANT, DBOP_scalar_constant);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT(E_OUTOFMEMORY);
                }

            HRESULT hr = CoFileTimeNow(&(((PROPVARIANT*)yyval->value.pvValue)->filetime));
            ((PROPVARIANT*)yyval->value.pvValue)->vt = VT_FILETIME;
            }
break;
case 23:
{
            yyval = PctAllocNode(DBVALUEKIND_VARIANT, DBOP_scalar_constant);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT(E_OUTOFMEMORY);
                }
            ((PROPVARIANT*)yyval->value.pvValue)->vt = VT_BOOL;
            ((PROPVARIANT*)yyval->value.pvValue)->boolVal = VARIANT_TRUE;
            }
break;
case 24:
{
            yyval = PctAllocNode(DBVALUEKIND_VARIANT, DBOP_scalar_constant);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT(E_OUTOFMEMORY);
                }
            ((PROPVARIANT*)yyval->value.pvValue)->vt = VT_BOOL;
            ((PROPVARIANT*)yyval->value.pvValue)->boolVal = VARIANT_FALSE;
            }
break;
case 27:
{
            AssertReq(yyvsp[-1]);      /* need a query specification tree*/

            if (NULL != yyvsp[0])     /* add optional ORDER BY nodes*/
                {
                /* Is project list built correctly?*/
                AssertReq(yyvsp[-1]->pctFirstChild);
                AssertReq(yyvsp[-1]->pctFirstChild->pctNextSibling);
                AssertReq(yyvsp[-1]->pctFirstChild->pctNextSibling->pctFirstChild);
                Assert((yyvsp[-1]->op == DBOP_project) &&
                        (yyvsp[-1]->pctFirstChild->pctNextSibling->op == DBOP_project_list_anchor));

                DBCOMMANDTREE* pctSortList = yyvsp[0]->pctFirstChild;
                AssertReq(pctSortList);

                while (pctSortList)
                    {
                    /* Is sort list built correctly?*/
                    Assert(pctSortList->op == DBOP_sort_list_element);
                    AssertReq(pctSortList->pctFirstChild);
                    Assert((pctSortList->pctFirstChild->op == DBOP_column_name) ||
                            (pctSortList->pctFirstChild->op == DBOP_scalar_constant));

                    if (pctSortList->pctFirstChild->op == DBOP_scalar_constant)
                        {
                        /* we've got an ordinal rather than a column number, so we've got to*/
                        /* walk through the project list to find the corresponding column*/
                        Assert(DBVALUEKIND_VARIANT == pctSortList->pctFirstChild->wKind);
                        Assert(VT_I4 == pctSortList->pctFirstChild->value.pvarValue->vt);

                        DBCOMMANDTREE* pctProjectList = yyvsp[-1]->pctFirstChild->pctNextSibling->pctFirstChild;
                        AssertReq(pctProjectList);

                        LONG cProjectListElements = GetNumberOfSiblings(pctProjectList);
                        if ((cProjectListElements < pctSortList->pctFirstChild->value.pvarValue->lVal) ||
                            (0 >= pctSortList->pctFirstChild->value.pvarValue->lVal))
                            {
                            /* ordinal is larger than number of elements in project list*/
                            WCHAR wchError[30];
                            m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_ORDINAL_OUT_OF_RANGE);
                            swprintf(wchError, L"%d", pctSortList->pctFirstChild->value.pvarValue->lVal);
                            m_pIPTProperties->SetErrorToken(wchError);
                            swprintf(wchError, L"%d", cProjectListElements);
                            m_pIPTProperties->SetErrorToken(wchError);
                            YYABORT(DB_E_ERRORSINCOMMAND);
                            }
                        else
                            {
                            LONG lColumnNumber = 1;

                            while (pctProjectList &&
                                    (lColumnNumber < pctSortList->pctFirstChild->value.pvarValue->lVal))
                                {
                                /* find the ulVal'th column in the project list*/
                                Assert(pctProjectList->op == DBOP_project_list_element);
                                pctProjectList = pctProjectList->pctNextSibling;
                                lColumnNumber++;
                                }

                            DeleteDBQT(pctSortList->pctFirstChild);
                            HRESULT hr = HrQeTreeCopy(&pctSortList->pctFirstChild,
                                                        pctProjectList->pctFirstChild);
                            if (FAILED(hr))
                                {
                                m_pIPTProperties->SetErrorHResult(hr, MONSQL_OUT_OF_MEMORY);
                                YYABORT(hr);
                                }
                            }
                        }

                    pctSortList = pctSortList->pctNextSibling;
                    }

                m_pIPTProperties->SetSortDesc(QUERY_SORTASCEND);    /* reset "stick" sort direction*/
                yyval = PctCreateNode(DBOP_sort, yyvsp[-1], yyvsp[0], NULL);
                }
            else
                {
                yyval = yyvsp[-1];
                }

            AssertReq(yyval);
            }
break;
case 28:
{
            AssertReq(yyvsp[-2]);      /* need a select list*/
            AssertReq(yyvsp[-1]);      /* need a from clause*/

            if (NULL != yyvsp[-1]->pctNextSibling)
                {   /* the from clause is a from view*/
                if (DBOP_outall_name == yyvsp[-2]->op)
                    {
                    DeleteDBQT( yyvsp[-2] );
                    yyvsp[-2] = yyvsp[-1];
                    yyvsp[-1] = yyvsp[-2]->pctNextSibling;
                    yyvsp[-2]->pctNextSibling = NULL;

                    AssertReq( yyvsp[-2]->pctFirstChild );   /* first project list element*/
                    DBCOMMANDTREE* pct = yyvsp[-2]->pctFirstChild;
                    while ( pct )
                        {   /* recheck the properties to get current definitions*/
                        DeleteDBQT( pct->pctFirstChild );
                        pct->pctFirstChild =
                            PctMkColNodeFromStr( pct->value.pwszValue, m_pIPSession, m_pIPTProperties );
                        if ( 0 == pct->pctFirstChild )
                            YYABORT( DB_E_ERRORSINCOMMAND );
                        pct = pct->pctNextSibling;
                        }
                    }
                else
                    {
                    yyvsp[-4] = yyvsp[-1];
                    yyvsp[-1] = yyvsp[-4]->pctNextSibling;
                    yyvsp[-4]->pctNextSibling = NULL;
                    AssertReq(yyvsp[-2]);                                  /* project list anchor*/
                    AssertReq(yyvsp[-2]->pctFirstChild);                   /* first project list element*/
                    DBCOMMANDTREE* pctNewPrjLst = yyvsp[-2]->pctFirstChild;
                    AssertReq(yyvsp[-4]);                                  /* project list anchor*/
                    AssertReq(yyvsp[-4]->pctFirstChild);                   /* first project list element*/
                    DBCOMMANDTREE* pctViewPrjLst = NULL;            /* initialized within loop*/
                    while (pctNewPrjLst)
                        {
                        pctViewPrjLst = yyvsp[-4]->pctFirstChild;
                        Assert( DBOP_project_list_element == pctNewPrjLst->op );
                        Assert( DBVALUEKIND_WSTR == pctNewPrjLst->wKind );
                        while ( pctViewPrjLst )
                            {
                            Assert( DBOP_project_list_element == pctViewPrjLst->op );
                            Assert( DBVALUEKIND_WSTR == pctViewPrjLst->wKind );
                            if ( 0 == _wcsicmp(pctNewPrjLst->value.pwszValue, pctViewPrjLst->value.pwszValue) )
                                break;
                            pctViewPrjLst = pctViewPrjLst->pctNextSibling;
                            if ( !pctViewPrjLst )
                                {
                                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_NOT_COLUMN_OF_VIEW );
                                m_pIPTProperties->SetErrorToken( pctNewPrjLst->value.pwszValue );
                                /* UNDONE:  Might want to include a view name on error message*/
                                YYABORT( DB_E_ERRORSINCOMMAND );
                                }
                            }
                        pctNewPrjLst = pctNewPrjLst->pctNextSibling;
                        }
                    DeleteDBQT( yyvsp[-4] );
                    yyvsp[-4] = 0;
                    }
                }
            else
                {
                /* "standard" from clause*/
                if ( DBOP_outall_name == yyvsp[-2]->op )
                    if ( DBDIALECT_MSSQLJAWS != m_pIPSession->GetSQLDialect() )
                        {
                        /* SELECT * only allowed in JAWS*/
                        m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_SELECT_STAR );
                        YYABORT( DB_E_ERRORSINCOMMAND );
                        }
                    else
                        {
                        yyvsp[-2] = PctCreateNode( DBOP_project_list_element, yyvsp[-2], NULL );
                        if ( NULL == yyvsp[-2] )
                            {
                            m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                            YYABORT( E_OUTOFMEMORY );
                            }

                        yyvsp[-2] = PctCreateNode( DBOP_project_list_anchor, yyvsp[-2], NULL );
                        if ( NULL == yyvsp[-2] )
                            {
                            m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                            YYABORT( E_OUTOFMEMORY );
                            }
                        }
                }

            if ( NULL != yyvsp[0] )
                {
                yyvsp[-4] = PctCreateNode( DBOP_select, yyvsp[-1], yyvsp[0], NULL );
                if ( NULL == yyvsp[-4] )
                    {
                    m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                    YYABORT( E_OUTOFMEMORY );
                    }
                }
            else
                yyvsp[-4] = yyvsp[-1];

            yyval = PctCreateNode( DBOP_project, yyvsp[-4], yyvsp[-2], NULL );
            if ( NULL == yyval )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }
            }
break;
case 29:
{
            yyval = NULL;
            }
break;
case 30:
{
            /* ignore ALL keyword, its just noise*/
            yyval = NULL;
            }
break;
case 31:
{
            AssertReq(yyvsp[0]);

            yyvsp[0] = PctReverse(yyvsp[0]);
            yyval = PctCreateNode(DBOP_project_list_anchor, yyvsp[0], NULL);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT(E_OUTOFMEMORY);
                }
            }
break;
case 32:
{
            yyval = PctCreateNode(DBOP_outall_name, NULL);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT(E_OUTOFMEMORY);
                }
            }
break;
case 33:
{
            AssertReq(yyvsp[-2]);
            AssertReq(yyvsp[0]);

            /**/
            /* chain project list elements together*/
            /**/
            yyval = PctLink( yyvsp[0], yyvsp[-2] );
            if ( NULL == yyval )
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT(E_OUTOFMEMORY);
                }
            }
break;
case 35:
{
            AssertReq(yyvsp[0]);

            yyvsp[0]->op = DBOP_project_list_element;
            yyvsp[0]->pctFirstChild = PctMkColNodeFromStr(yyvsp[0]->value.pwszValue, m_pIPSession, m_pIPTProperties);
            if (NULL == yyvsp[0]->pctFirstChild)
                YYABORT(DB_E_ERRORSINCOMMAND);
            yyval = yyvsp[0];
            }
break;
case 36:
{
            AssertReq(yyvsp[-2]);
            AssertReq(yyvsp[0]);

            DeleteDBQT(yyvsp[-2]);     /* UNDONE:  Don't use the correlation name for now*/
            yyvsp[-2] = NULL;
            yyvsp[0]->op = DBOP_project_list_element;
            yyvsp[0]->pctFirstChild = PctMkColNodeFromStr(yyvsp[0]->value.pwszValue, m_pIPSession, m_pIPTProperties);
            if (NULL == yyvsp[0]->pctFirstChild)
                YYABORT(DB_E_ERRORSINCOMMAND);
            yyval = yyvsp[0];
            }
break;
case 37:
{
            yyval = PctMkColNodeFromStr(L"CREATE", m_pIPSession, m_pIPTProperties);
            if (NULL == yyval)
                YYABORT(DB_E_ERRORSINCOMMAND);

            yyval = PctCreateNode(DBOP_project_list_element, DBVALUEKIND_WSTR, yyval, NULL);
            yyval->value.pwszValue = CoTaskStrDup(L"CREATE");
            }
break;
case 40:
{
            AssertReq( yyvsp[-1] );

            yyval = yyvsp[-1];

            if ( NULL != yyvsp[0] )
                {
                yyvsp[0]->pctFirstChild = yyval;
                yyval = yyvsp[0];
                }
            }
break;
case 41:
{
            AssertReq( yyvsp[0] );
            yyval = yyvsp[0];
            }
break;
case 42:
{
            AssertReq( yyvsp[0] );
            yyval = yyvsp[0];
            }
break;
case 43:
{
            AssertReq( yyvsp[0] );
            yyval = yyvsp[0];
            }
break;
case 44:
{ /* _SCOPE '(' scope_definition ')'*/
            AssertReq( yyvsp[-1] );

            /**/
            /* Set the machine and catalog to the defaults*/
            /**/
            (yyvsp[-1]->value.pdbcntnttblValue)->pwszMachine = CoTaskStrDup( m_pIPSession->GetDefaultMachine() );
            if ( NULL == (yyvsp[-1]->value.pdbcntnttblValue)->pwszMachine )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            (yyvsp[-1]->value.pdbcntnttblValue)->pwszCatalog = CoTaskStrDup( m_pIPSession->GetDefaultCatalog() );
            if ( NULL == (yyvsp[-1]->value.pdbcntnttblValue)->pwszCatalog )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            yyval = yyvsp[-1];
            }
break;
case 45:
{ /* machine_name _DOTDOTDOT_SCOPE '(' scope_definition ')'*/
            AssertReq( yyvsp[-4] );
            AssertReq( yyvsp[-1] );

            (yyvsp[-1]->value.pdbcntnttblValue)->pwszMachine = CoTaskStrDup( yyvsp[-4]->value.pwszValue );
            if ( NULL == (yyvsp[-1]->value.pdbcntnttblValue)->pwszMachine )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            SCODE sc = m_pIPSession->GetIPVerifyPtr()->VerifyCatalog(
                                                        yyvsp[-4]->value.pwszValue,
                                                        m_pIPSession->GetDefaultCatalog() );
            if ( S_OK != sc )
                {
                m_pIPTProperties->SetErrorHResult( sc, MONSQL_INVALID_CATALOG );
                m_pIPTProperties->SetErrorToken( m_pIPSession->GetDefaultCatalog() );
                YYABORT( sc );
                }

            (yyvsp[-1]->value.pdbcntnttblValue)->pwszCatalog = CoTaskStrDup( m_pIPSession->GetDefaultCatalog() );
            if ( NULL == (yyvsp[-1]->value.pdbcntnttblValue)->pwszCatalog )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            DeleteDBQT( yyvsp[-4] );
            yyval = yyvsp[-1];
            }
break;
case 46:
{ /* machine_name _DOT catalog_name _DOTDOT_SCOPE '(' scope_definition ')'*/
            AssertReq( yyvsp[-6] );
            AssertReq( yyvsp[-4] );
            AssertReq( yyvsp[-1] );

            (yyvsp[-1]->value.pdbcntnttblValue)->pwszMachine = CoTaskStrDup( yyvsp[-6]->value.pwszValue );
            if ( NULL == (yyvsp[-1]->value.pdbcntnttblValue)->pwszMachine )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            /**/
            /* Verify catalog on machine specified*/
            /**/

            SCODE sc = m_pIPSession->GetIPVerifyPtr()->VerifyCatalog(
                                                        yyvsp[-6]->value.pwszValue,
                                                        yyvsp[-4]->value.pwszValue );
            if ( S_OK != sc )
                {
                m_pIPTProperties->SetErrorHResult( sc, MONSQL_INVALID_CATALOG );
                m_pIPTProperties->SetErrorToken( yyvsp[-4]->value.pwszValue );
                YYABORT( sc );
                }

            (yyvsp[-1]->value.pdbcntnttblValue)->pwszCatalog = CoTaskStrDup( yyvsp[-4]->value.pwszValue );
            if ( NULL == (yyvsp[-1]->value.pdbcntnttblValue)->pwszCatalog )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            DeleteDBQT( yyvsp[-6] );
            DeleteDBQT( yyvsp[-4] );
            yyval = yyvsp[-1];
            }
break;
case 47:
{ /* catalog_name _DOTDOT_SCOPE '(' scope_definition ')'*/
            AssertReq( yyvsp[-4] );
            AssertReq( yyvsp[-1] );

            (yyvsp[-1]->value.pdbcntnttblValue)->pwszMachine = CoTaskStrDup( m_pIPSession->GetDefaultMachine() );
            if ( NULL == (yyvsp[-1]->value.pdbcntnttblValue)->pwszMachine )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            /**/
            /* See if catalog is valid on default machine*/
            /**/

            SCODE sc = m_pIPSession->GetIPVerifyPtr()->VerifyCatalog(
                                                        m_pIPSession->GetDefaultMachine(),
                                                        yyvsp[-4]->value.pwszValue );
            if ( S_OK != sc )
                {
                m_pIPTProperties->SetErrorHResult( sc, MONSQL_INVALID_CATALOG );
                m_pIPTProperties->SetErrorToken( yyvsp[-4]->value.pwszValue );
                YYABORT( sc );
                }

            (yyvsp[-1]->value.pdbcntnttblValue)->pwszCatalog = CoTaskStrDup( yyvsp[-4]->value.pwszValue );
            if ( NULL == (yyvsp[-1]->value.pdbcntnttblValue)->pwszCatalog )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            DeleteDBQT( yyvsp[-4] );
            yyval = yyvsp[-1];
            }
break;
case 48:
{
            AssertReq( yyvsp[0] );
            yyval = yyvsp[0];
            }
break;
case 49:
{
            AssertReq( yyvsp[0] );

            /**/
            /* Defer validation of the catalog to the point where we*/
            /* know the machine name.  Return whatever was parsed here.*/
            /**/

            yyval = yyvsp[0];
            }
break;
case 50:
{ /* empty rule for scope_definition*/

            /**/
            /* Create a DBOP_content_table node with default scope settings*/
            /**/
            yyval = PctAllocNode( DBVALUEKIND_CONTENTTABLE, DBOP_content_table );
            if ( NULL == yyval )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND,
                                                   MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }
            }
break;
case 51:
{ /* scope_element_list*/

            AssertReq(yyvsp[0]);

            yyvsp[0] = PctReverse( yyvsp[0] );
            yyval = PctCreateNode( DBOP_scope_list_anchor, yyvsp[0], NULL );
            if ( NULL == yyval )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            yyval = PctCreateNode( DBOP_content_table, DBVALUEKIND_CONTENTTABLE, yyval, NULL );
            if ( NULL == yyval )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }
            }
break;
case 52:
{
            AssertReq( yyvsp[-2] );
            AssertReq( yyvsp[0]);

            /**/
            /* chain scope list elements together*/
            /**/
            yyval = PctLink( yyvsp[0], yyvsp[-2] );
            }
break;
case 53:
{
            AssertReq( yyvsp[0] );

            yyval = yyvsp[0];
            }
break;
case 54:
{
            AssertReq( yyvsp[-2] );
            AssertReq( yyvsp[-1] );

            yyvsp[-1] = PctReverse( yyvsp[-1] );

            SetDepthAndInclusion( yyvsp[-2], yyvsp[-1] );

            DeleteDBQT( yyvsp[-2] );
            yyval = yyvsp[-1];
            }
break;
case 55:
{
            AssertReq( yyvsp[-4] );
            AssertReq( yyvsp[-2] );

            yyvsp[-2] = PctReverse( yyvsp[-2] );

            SetDepthAndInclusion( yyvsp[-4], yyvsp[-2] );

            DeleteDBQT( yyvsp[-4] );
            yyval = yyvsp[-2];
            }
break;
case 56:
{
            yyval = PctAllocNode( DBVALUEKIND_CONTENTSCOPE, DBOP_scope_list_element );
            if ( NULL == yyval )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            yyval->value.pdbcntntscpValue->dwFlags   |= SCOPE_FLAG_DEEP;
            yyval->value.pdbcntntscpValue->dwFlags   |= SCOPE_FLAG_INCLUDE;
            }
break;
case 57:
{
            yyval = PctAllocNode( DBVALUEKIND_CONTENTSCOPE, DBOP_scope_list_element );
            if ( NULL == yyval )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            yyval->value.pdbcntntscpValue->dwFlags   |= SCOPE_FLAG_DEEP;
            yyval->value.pdbcntntscpValue->dwFlags   |= SCOPE_FLAG_INCLUDE;
            }
break;
case 58:
{
            yyval = PctAllocNode( DBVALUEKIND_CONTENTSCOPE, DBOP_scope_list_element );
            if ( NULL == yyval )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            yyval->value.pdbcntntscpValue->dwFlags   &= ~(SCOPE_FLAG_DEEP);
            yyval->value.pdbcntntscpValue->dwFlags   |= SCOPE_FLAG_INCLUDE;
            }
break;
case 59:
{
            AssertReq( yyvsp[-2] );
            AssertReq( yyvsp[0] );

            /**/
            /* chain path/vpath nodes together*/
            /**/
            yyval = PctLink( yyvsp[0], yyvsp[-2] );
            }
break;
case 60:
{
            AssertReq( yyvsp[0] );

            yyval = yyvsp[0];
            }
break;
case 61:
{
            AssertReq( yyvsp[0] );

            yyval = PctAllocNode( DBVALUEKIND_CONTENTSCOPE, DBOP_scope_list_element );
            if ( NULL == yyval )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND,
                                                   MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            yyval->value.pdbcntntscpValue->pwszElementValue =
                CoTaskStrDup( (yyvsp[0]->value.pvarValue)->bstrVal );

            if ( NULL == yyval->value.pdbcntntscpValue->pwszElementValue )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND,
                                                   MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            if ( NULL != wcschr(((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal, L'/'))
                yyval->value.pdbcntntscpValue->dwFlags |= SCOPE_TYPE_VPATH;
            else
                yyval->value.pdbcntntscpValue->dwFlags |= SCOPE_TYPE_WINPATH;

            /**/
            /* Path names need backlashes not forward slashes*/
            /**/
            for (WCHAR *wcsLetter = yyval->value.pdbcntntscpValue->pwszElementValue;
                 *wcsLetter != L'\0';
                 wcsLetter++)
                     if (L'/' == *wcsLetter)
                         *wcsLetter = L'\\';

            DeleteDBQT( yyvsp[0] );
            }
break;
case 62:
{
            yyval = NULL;
            }
break;
case 63:
{
            AssertReq(yyvsp[0]);
/*          $2->op = DBOP_alias;            // retag _ID node to be table alias*/
/*          $$ = $2;                        // UNDONE:  This doesn't work with Index Server*/
            DeleteDBQT(yyvsp[0]);
            yyvsp[0] = NULL;
            yyval = NULL;
            }
break;
case 64:
{ /* _FROM view_name*/
            AssertReq( yyvsp[0] );

            /* node telling where the view is defined*/
            Assert( DBOP_content_table == yyvsp[0]->op );

            /* name of the view*/
            AssertReq( yyvsp[0]->pctNextSibling );

            yyval = m_pIPSession->GetLocalViewList()->GetViewDefinition( m_pIPTProperties,
                                                                      yyvsp[0]->pctNextSibling->value.pwszValue,
                                                                      (yyvsp[0]->value.pdbcntnttblValue)->pwszCatalog );
            if ( 0 == yyval )
                yyval = m_pIPSession->GetGlobalViewList()->GetViewDefinition( m_pIPTProperties,
                                                                           yyvsp[0]->pctNextSibling->value.pwszValue,
                                                                           (yyvsp[0]->value.pdbcntnttblValue)->pwszCatalog );
            if ( 0 == yyval )
                {   /* If this isn't JAWS, this is an undefined view*/
                if (DBDIALECT_MSSQLJAWS != m_pIPSession->GetSQLDialect())
                    {
                    m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_VIEW_NOT_DEFINED );
                    m_pIPTProperties->SetErrorToken( yyvsp[0]->pctNextSibling->value.pwszValue );
                    m_pIPTProperties->SetErrorToken( (yyvsp[0]->value.pdbcntnttblValue)->pwszCatalog );
                    YYABORT( DB_E_ERRORSINCOMMAND );
                    }

                /* setting the default scope for JAWS*/
                CScopeData* pScopeData = m_pIPTProperties->GetScopeDataPtr();
                pScopeData->SetTemporaryDepth(QUERY_DEEP);
                pScopeData->MaskTemporaryDepth(QUERY_VIRTUAL_PATH);
                pScopeData->SetTemporaryScope(VAL_AND_CCH_MINUS_NULL(L"/"));
                pScopeData->SetTemporaryCatalog(yyvsp[0]->value.pwszValue, wcslen(yyvsp[0]->value.pwszValue));
                pScopeData->IncrementScopeCount();

                yyval = yyvsp[0]->pctNextSibling;
                yyvsp[0]->pctNextSibling = NULL;
                DeleteDBQT(yyvsp[0]);
                }
            else    /* actually a view name*/
                {

                /* If we didn't store scope information (global views), set up the scope now*/
                if ( 0 == yyval->pctNextSibling )
                    {
                    /* name of the view*/
                    DeleteDBQT( yyvsp[0]->pctNextSibling );
                    yyvsp[0]->pctNextSibling = 0;

                    yyval->pctNextSibling = yyvsp[0];
                    }
                else
                    {
                    AssertReq( DBOP_content_table == yyval->pctNextSibling->op );
                    DeleteDBQT( yyvsp[0] );  /* throw away the view name*/
                    }
                }
            }
break;
case 65:
{ /* _TEMPVIEW*/
            AssertReq( yyvsp[0] );

            yyval = PctAllocNode( DBVALUEKIND_CONTENTTABLE, DBOP_content_table );
            if ( 0 == yyval )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            (yyval->value.pdbcntnttblValue)->pwszMachine = CoTaskStrDup( m_pIPSession->GetDefaultMachine() );
            if ( 0 == (yyval->value.pdbcntnttblValue)->pwszMachine )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            (yyval->value.pdbcntnttblValue)->pwszCatalog = CoTaskStrDup( m_pIPSession->GetDefaultCatalog() );
            if ( 0 == (yyval->value.pdbcntnttblValue)->pwszCatalog )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            yyval->pctNextSibling = yyvsp[0];
            }
break;
case 66:
{ /* identifier*/
            AssertReq( yyvsp[0] );

            yyval = PctAllocNode( DBVALUEKIND_CONTENTTABLE, DBOP_content_table );
            if ( 0 == yyval )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            (yyval->value.pdbcntnttblValue)->pwszMachine = CoTaskStrDup( m_pIPSession->GetDefaultMachine() );
            if ( 0 == (yyval->value.pdbcntnttblValue)->pwszMachine )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            (yyval->value.pdbcntnttblValue)->pwszCatalog = CoTaskStrDup( m_pIPSession->GetDefaultCatalog() );
            if ( 0 == (yyval->value.pdbcntnttblValue)->pwszCatalog )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            yyval->pctNextSibling = yyvsp[0];
            }
break;
case 67:
{ /* catalog_name _DOTDOT _TEMPVIEW*/
            AssertReq(yyvsp[-2]);
            AssertReq(yyvsp[0]);

            yyval = PctAllocNode( DBVALUEKIND_CONTENTTABLE, DBOP_content_table );
            if ( 0 == yyval )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            (yyval->value.pdbcntnttblValue)->pwszMachine = CoTaskStrDup( m_pIPSession->GetDefaultMachine() );
            if ( 0 == (yyval->value.pdbcntnttblValue)->pwszMachine )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            (yyval->value.pdbcntnttblValue)->pwszCatalog = CoTaskStrDup( yyvsp[-2]->value.pwszValue );
            if ( 0 == (yyval->value.pdbcntnttblValue)->pwszCatalog )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            DeleteDBQT( yyvsp[-2] );
            yyval->pctNextSibling = yyvsp[0];
            }
break;
case 68:
{ /* catalog_name _DOTDOT identifier*/
            AssertReq(yyvsp[-2]);
            AssertReq(yyvsp[0]);

            yyval = PctAllocNode( DBVALUEKIND_CONTENTTABLE, DBOP_content_table );
            if ( 0 == yyval )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            (yyval->value.pdbcntnttblValue)->pwszMachine = CoTaskStrDup( m_pIPSession->GetDefaultMachine() );
            if ( 0 == (yyval->value.pdbcntnttblValue)->pwszMachine )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            (yyval->value.pdbcntnttblValue)->pwszCatalog = CoTaskStrDup( yyvsp[-2]->value.pwszValue );
            if ( 0 == (yyval->value.pdbcntnttblValue)->pwszCatalog )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            DeleteDBQT( yyvsp[-2] );
            yyval->pctNextSibling = yyvsp[0];
            }
break;
case 69:
{ /* machine_name _DOT catalog_name _DOTDOT _TEMPVIEW*/
            AssertReq( yyvsp[-4] );
            AssertReq( yyvsp[-2] );
            AssertReq( yyvsp[0] );

            yyval = PctAllocNode( DBVALUEKIND_CONTENTTABLE, DBOP_content_table );
            if ( 0 == yyval )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            (yyval->value.pdbcntnttblValue)->pwszMachine = CoTaskStrDup( yyvsp[-4]->value.pwszValue );
            if ( 0 == (yyval->value.pdbcntnttblValue)->pwszMachine )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            (yyval->value.pdbcntnttblValue)->pwszCatalog = CoTaskStrDup( yyvsp[-2]->value.pwszValue );
            if ( 0 == (yyval->value.pdbcntnttblValue)->pwszCatalog )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            DeleteDBQT( yyvsp[-4] );
            DeleteDBQT( yyvsp[-2] );
            yyval->pctNextSibling = yyvsp[0];
            }
break;
case 70:
{ /* machine_name _DOT catalog_name _DOTDOT identifier*/
            AssertReq( yyvsp[-4] );
            AssertReq( yyvsp[-2] );
            AssertReq( yyvsp[0] );

            yyval = PctAllocNode( DBVALUEKIND_CONTENTTABLE, DBOP_content_table );
            if ( 0 == yyval )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            (yyval->value.pdbcntnttblValue)->pwszMachine = CoTaskStrDup( yyvsp[-4]->value.pwszValue );
            if ( 0 == (yyval->value.pdbcntnttblValue)->pwszMachine )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            (yyval->value.pdbcntnttblValue)->pwszCatalog = CoTaskStrDup( yyvsp[-2]->value.pwszValue );
            if ( 0 == (yyval->value.pdbcntnttblValue)->pwszCatalog )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            DeleteDBQT( yyvsp[-4] );
            DeleteDBQT( yyvsp[-2] );
            yyval->pctNextSibling = yyvsp[0];
            }
break;
case 71:
{ /* machine_name _DOTDOTDOT identifier*/
            AssertReq( yyvsp[-2] );
            AssertReq( yyvsp[0] );

            yyval = PctAllocNode( DBVALUEKIND_CONTENTTABLE, DBOP_content_table );
            if ( 0 == yyval )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            (yyval->value.pdbcntnttblValue)->pwszMachine = CoTaskStrDup( yyvsp[-2]->value.pwszValue );
            if ( 0 == (yyval->value.pdbcntnttblValue)->pwszMachine )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }
            (yyval->value.pdbcntnttblValue)->pwszCatalog = CoTaskStrDup( m_pIPSession->GetDefaultCatalog() );
            if ( 0 == (yyval->value.pdbcntnttblValue)->pwszCatalog )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            DeleteDBQT( yyvsp[-2] );
            yyval->pctNextSibling = yyvsp[0];
            }
break;
case 72:
{ /* machine_name _DOTDOTDOT _TEMPVIEW*/
            AssertReq( yyvsp[-2] );
            AssertReq( yyvsp[0] );

            yyval = PctAllocNode( DBVALUEKIND_CONTENTTABLE, DBOP_content_table );
            if ( 0 == yyval )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            (yyval->value.pdbcntnttblValue)->pwszMachine = CoTaskStrDup( yyvsp[-2]->value.pwszValue );
            if ( 0 == (yyval->value.pdbcntnttblValue)->pwszMachine )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }
            (yyval->value.pdbcntnttblValue)->pwszCatalog = CoTaskStrDup( m_pIPSession->GetDefaultCatalog() );
            if ( 0 == (yyval->value.pdbcntnttblValue)->pwszCatalog )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            DeleteDBQT( yyvsp[-2] );
            yyval->pctNextSibling = yyvsp[0];
            }
break;
case 73:
{
            yyval = yyvsp[-1];
            }
break;
case 74:
{
            AssertReq( yyvsp[-3] );
            AssertReq( yyvsp[0] );

            yyval = PctCreateNode( DBOP_set_union, yyvsp[-3], yyvsp[0], NULL );
            if ( NULL == yyval )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND,
                                                   MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }
            }
break;
case 75:
{
            AssertReq( yyvsp[-3] );
            AssertReq( yyvsp[0] );

            yyval = PctCreateNode( DBOP_set_union, yyvsp[-3], yyvsp[0], NULL );
            if ( NULL == yyval )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND,
                                                   MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }
            }
break;
case 76:
{
            AssertReq( yyvsp[0] );
            yyval = yyvsp[0];
            }
break;
case 77:
{
            yyval = NULL;
            }
break;
case 79:
{
            AssertReq(yyvsp[0]);
            yyval = yyvsp[0];
            }
break;
case 80:
{
            AssertReq(yyvsp[-1]);

            if (wcslen(((PROPVARIANT*)yyvsp[-1]->value.pvValue)->bstrVal))
                m_pIPTProperties->AppendCiRestriction(((PROPVARIANT*)yyvsp[-1]->value.pvValue)->bstrVal,
                                                    wcslen(((PROPVARIANT*)yyvsp[-1]->value.pvValue)->bstrVal));

            UINT cSize = 0;
            CIPROPERTYDEF* pPropTable = m_pIPSession->m_pCPropertyList->GetPropertyTable(&cSize);
            if (!pPropTable)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT(E_OUTOFMEMORY);
                }

            if (FAILED(CITextToSelectTreeEx(((PROPVARIANT*)yyvsp[-1]->value.pvValue)->bstrVal,
                                        ISQLANG_V2,
                                        &yyval,
                                        cSize,
                                        pPropTable,
                                        m_pIPSession->GetLCID())))
                {
                m_pIPSession->m_pCPropertyList->DeletePropertyTable(pPropTable, cSize);
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_CITEXTTOSELECTTREE_FAILED);
                m_pIPTProperties->SetErrorToken(((PROPVARIANT*)yyvsp[-1]->value.pvValue)->bstrVal);
                YYABORT(DB_E_ERRORSINCOMMAND);
                }
            DeleteDBQT(yyvsp[-1]);
            yyvsp[-1] = NULL;
            m_pIPSession->m_pCPropertyList->DeletePropertyTable(pPropTable, cSize);
            }
break;
case 88:
{
            AssertReq(yyvsp[-2]);
            AssertReq(yyvsp[-1]);

            if (m_pIPTProperties->GetDBType() & DBTYPE_VECTOR)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_PARSE_ERROR);
                m_pIPTProperties->SetErrorToken(L"<literal>");
                m_pIPTProperties->SetErrorToken(L"ARRAY");
                YYABORT(DB_E_ERRORSINCOMMAND);
                }

            yyvsp[-2]->pctNextSibling = yyvsp[0];
            yyvsp[-1]->pctFirstChild = yyvsp[-2];
            yyval = yyvsp[-1];
            }
break;
case 89:
{
            AssertReq(yyvsp[0]);

            m_pIPTProperties->UseCiColumn(L'@');
            yyval = yyvsp[0];
            }
break;
case 90:
{
            AssertReq(yyvsp[-3]);
            AssertReq(yyvsp[-1]);

            if (DBDIALECT_MSSQLJAWS != m_pIPSession->GetSQLDialect())
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_PARSE_ERROR);
                m_pIPTProperties->SetErrorToken(L"CAST");
                m_pIPTProperties->SetErrorToken(L"column_reference");
                YYABORT(DB_E_ERRORSINCOMMAND);
                }

            m_pIPTProperties->UseCiColumn(L'@');

            m_pIPTProperties->SetDBType(yyvsp[-1]->value.usValue);
            DeleteDBQT(yyvsp[-1]);
            yyval = yyvsp[-3];
            }
break;
case 91:
{
            AssertReq(yyvsp[0]);

            yyval = PctMkColNodeFromStr(yyvsp[0]->value.pwszValue, m_pIPSession, m_pIPTProperties);
            if (NULL == yyval)
                YYABORT(DB_E_ERRORSINCOMMAND);

            m_pIPTProperties->SetCiColumn(yyvsp[0]->value.pwszValue);
            DeleteDBQT(yyvsp[0]);
            yyvsp[0] = NULL;
            }
break;
case 92:
{
            AssertReq(yyvsp[-2]);
            AssertReq(yyvsp[0]);

            yyval = PctMkColNodeFromStr(yyvsp[0]->value.pwszValue, m_pIPSession, m_pIPTProperties);
            if (NULL == yyval)
                YYABORT(DB_E_ERRORSINCOMMAND);

            m_pIPTProperties->SetCiColumn(yyvsp[0]->value.pwszValue);
            DeleteDBQT(yyvsp[0]);
            yyvsp[0] = NULL;
            DeleteDBQT(yyvsp[-2]);     /* UNDONE:  Don't use the correlation name for now*/
            yyvsp[-2] = NULL;
            }
break;
case 93:
{
            m_pIPTProperties->SetCiColumn(L"CREATE");
            yyval = PctMkColNodeFromStr(L"CREATE", m_pIPSession, m_pIPTProperties);
            if (NULL == yyval)
                YYABORT(DB_E_ERRORSINCOMMAND);

            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L"CREATE "));
            }
break;
case 94:
{
            yyval = PctCreateRelationalNode(DBOP_equal, DEFAULTWEIGHT);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT(E_OUTOFMEMORY);
                }
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L"="));
            }
break;
case 95:
{
            yyval = PctCreateRelationalNode(DBOP_not_equal, DEFAULTWEIGHT);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT(E_OUTOFMEMORY);
                }
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L"!="));
            }
break;
case 96:
{
            yyval = PctCreateRelationalNode(DBOP_less, DEFAULTWEIGHT);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT(E_OUTOFMEMORY);
                }
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L"<"));
            }
break;
case 97:
{
            yyval = PctCreateRelationalNode(DBOP_greater, DEFAULTWEIGHT);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT(E_OUTOFMEMORY);
                }
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L">"));
            }
break;
case 98:
{
            yyval = PctCreateRelationalNode(DBOP_less_equal, DEFAULTWEIGHT);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT(E_OUTOFMEMORY);
                }
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L"<="));
            }
break;
case 99:
{
            yyval = PctCreateRelationalNode(DBOP_greater_equal, DEFAULTWEIGHT);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT(E_OUTOFMEMORY);
                }
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L">="));
            }
break;
case 100:
{
            AssertReq(!yyvsp[-5]); /* should have been NULLed out in opt_contents_column_reference*/
            AssertReq(yyvsp[-3]);

            yyval = yyvsp[-3];
            DeleteDBQT(m_pIPTProperties->GetContainsColumn());
            m_pIPTProperties->SetContainsColumn(NULL);
            }
break;
case 101:
{ /* opt_contents_column_reference empty rule*/
            yyval = PctMkColNodeFromStr(L"CONTENTS", m_pIPSession, m_pIPTProperties);
            if (NULL == yyval)
                YYABORT(DB_E_ERRORSINCOMMAND);

            m_pIPTProperties->SetCiColumn(L"CONTENTS");
            m_pIPTProperties->SetContainsColumn(yyval);
            yyval = NULL;
            }
break;
case 102:
{ /* column_reference ','*/
            m_pIPTProperties->SetContainsColumn(yyvsp[-1]);
            yyval = NULL;
            }
break;
case 103:
{
            /* This forces a left parentheses before the content search condition*/
            /* The matching right paren will be added below.*/
            m_pIPTProperties->CiNeedLeftParen();
            yyval = NULL;
            }
break;
case 104:
{
            AssertReq(yyvsp[0]);

            yyval = yyvsp[0];
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L")"));
            }
break;
case 106:
{
            if (DBOP_not == yyvsp[0]->op)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OR_NOT);
                YYABORT(DB_E_ERRORSINCOMMAND);
                }
            yyval = PctCreateBooleanNode(DBOP_or, DEFAULTWEIGHT, yyvsp[-2], yyvsp[0]);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT(E_OUTOFMEMORY);
                }
            }
break;
case 108:
{
            yyval = PctCreateBooleanNode(DBOP_and, DEFAULTWEIGHT, yyvsp[-2], yyvsp[0]);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT(E_OUTOFMEMORY);
                }
            }
break;
case 110:
{
            yyval = PctCreateNotNode(DEFAULTWEIGHT, yyvsp[0]);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT(E_OUTOFMEMORY);
                }
            }
break;
case 112:
{
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L"("));
            }
break;
case 113:
{
            AssertReq(yyvsp[-1]);

            yyval = yyvsp[-1];
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L")"));
            }
break;
case 119:
{
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" | "));
            }
break;
case 120:
{
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" | "));
            }
break;
case 121:
{
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" & "));
            }
break;
case 122:
{
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" & "));
            }
break;
case 123:
{
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" ! "));
            }
break;
case 124:
{
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" ! "));
            }
break;
case 125:
{
            AssertReq(yyvsp[0]);

            HRESULT hr = HrQeTreeCopy(&yyval, m_pIPTProperties->GetContainsColumn());
            if (FAILED(hr))
                {
                m_pIPTProperties->SetErrorHResult(hr, MONSQL_OUT_OF_MEMORY);
                YYABORT(hr);
                }
            m_pIPTProperties->UseCiColumn(L'@');
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L"\""));
            m_pIPTProperties->AppendCiRestriction(((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal,
                                                wcslen(((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal));
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L"\""));
            yyval = PctCreateContentNode(((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal, GENERATE_METHOD_EXACT,
                                        DEFAULTWEIGHT, m_pIPSession->GetLCID(), yyval);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT(E_OUTOFMEMORY);
                }
            DeleteDBQT(yyvsp[0]);
            yyvsp[0] = NULL;
            }
break;
case 126:
{
            AssertReq(yyvsp[0]);
            Assert(((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal[wcslen(
                ((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal)-1] == L'*');

            m_pIPTProperties->UseCiColumn(L'@');
            m_pIPTProperties->AppendCiRestriction(((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal,
                                                wcslen(((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal));
            ((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal[wcslen(
                ((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal)-1] = L'\0';
            HRESULT hr = HrQeTreeCopy(&yyval, m_pIPTProperties->GetContainsColumn());
            if (FAILED(hr))
                {
                m_pIPTProperties->SetErrorHResult(hr, MONSQL_OUT_OF_MEMORY);
                YYABORT(hr);
                }
            yyval = PctCreateContentNode(((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal, GENERATE_METHOD_PREFIX,
                                        DEFAULTWEIGHT, m_pIPSession->GetLCID(), yyval);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT(E_OUTOFMEMORY);
                }
            DeleteDBQT(yyvsp[0]);
            yyvsp[0] = NULL;
            }
break;
case 127:
{
            AssertReq(yyvsp[-1]);
            AssertReq(yyvsp[0]);

            yyvsp[0] = PctReverse(yyvsp[0]);
            yyval = PctCreateNode(DBOP_content_proximity, DBVALUEKIND_CONTENTPROXIMITY, yyvsp[-1], yyvsp[0], NULL);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT(E_OUTOFMEMORY);
                }
            yyval->value.pdbcntntproxValue->dwProximityUnit = PROXIMITY_UNIT_WORD;
            yyval->value.pdbcntntproxValue->ulProximityDistance = 50;
            yyval->value.pdbcntntproxValue->lWeight = DEFAULTWEIGHT;
            }
break;
case 128:
{
            AssertReq(yyvsp[-1]);
            AssertReq(yyvsp[0]);

            yyval = PctLink(yyvsp[0], yyvsp[-1]);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT(E_OUTOFMEMORY);
                }
            }
break;
case 130:
{
            AssertReq(yyvsp[0]);

            yyval = yyvsp[0];        /* UNDONE:  What is proximity_specification good for?*/
            }
break;
case 133:
{
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" ~ "));
            }
break;
case 134:
{
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" ~ "));
            }
break;
case 135:
{
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" ~ "));
            }
break;
case 136:
{
            AssertReq(yyvsp[-1]);

            /* UNDONE:  Should make use of $3 somewhere in here*/
            yyval = yyvsp[-1];
            }
break;
case 137:
{
            if (0 == _wcsicmp(((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal, L"INFLECTIONAL"))
                {
                DeleteDBQT(yyvsp[0]);
                yyvsp[0] = NULL;
                yyval = NULL;
                }
/*  *************************************NOT IMPLEMENTED BY INDEX SERVER **************************************
            else if (0 == _wcsicmp(((PROPVARIANT*)$1->value.pvValue)->bstrVal, L"DERIVATIONAL"))
                {
                m_pIPTProperties->SetErrorHResult(E_NOTIMPL, MONSQL_PARSE_ERROR);
                m_pIPTProperties->SetErrorToken(L"DERIVATIONAL");
                YYABORT(E_NOTIMPL);
                }
            else if (0 == _wcsicmp(((PROPVARIANT*)$1->value.pvValue)->bstrVal, L"SOUNDEX"))
                {
                m_pIPTProperties->SetErrorHResult(E_NOTIMPL, MONSQL_PARSE_ERROR);
                m_pIPTProperties->SetErrorToken(L"DERIVATIONAL");
                YYABORT(E_NOTIMPL);
                }
            else if (0 == _wcsicmp(((PROPVARIANT*)$1->value.pvValue)->bstrVal, L"THESAURUS"))
                {
                m_pIPTProperties->SetErrorHResult(E_NOTIMPL, MONSQL_PARSE_ERROR);
                m_pIPTProperties->SetErrorToken(L"THESAURUS");
                YYABORT(E_NOTIMPL);
                }
    *************************************NOT IMPLEMENTED BY INDEX SERVER ************************************** */
            else
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_PARSE_ERROR);
                m_pIPTProperties->SetErrorToken(((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal);
                m_pIPTProperties->SetErrorToken(L"INFLECTIONAL");
                YYABORT(E_NOTIMPL);
                }
            }
break;
case 138:
{
            AssertReq(yyvsp[-2]);
            AssertReq(yyvsp[0]);
            Assert(DBOP_content == yyvsp[0]->op);

            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L"**"));
            yyvsp[0]->value.pdbcntntValue->dwGenerateMethod = GENERATE_METHOD_INFLECT;
            yyval = PctCreateBooleanNode(DBOP_or, DEFAULTWEIGHT, yyvsp[-2], yyvsp[0]);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT(E_OUTOFMEMORY);
                }
            }
break;
case 139:
{
            AssertReq(yyvsp[0]);
            Assert(DBOP_content == yyvsp[0]->op);

            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L"**"));
            yyvsp[0]->value.pdbcntntValue->dwGenerateMethod = GENERATE_METHOD_INFLECT;
            yyval = yyvsp[0];
            }
break;
case 140:
{
            AssertReq(yyvsp[-1]);
            yyvsp[-1] = PctReverse(yyvsp[-1]);
            yyval = PctCreateNode(DBOP_content_vector_or, DBVALUEKIND_CONTENTVECTOR, yyvsp[-1], NULL);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT(E_OUTOFMEMORY);
                }
            yyval->value.pdbcntntvcValue->dwRankingMethod = m_pIPSession->GetRankingMethod();
            yyval->value.pdbcntntvcValue->lWeight = DEFAULTWEIGHT;
            }
break;
case 141:
{
            AssertReq(yyvsp[-2]);
            AssertReq(yyvsp[0]);
            Assert((DBOP_content == yyvsp[0]->op) || (DBOP_or == yyvsp[0]->op) || (DBOP_content_proximity == yyvsp[0]->op));

            yyval = PctLink(yyvsp[0], yyvsp[-2]);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT(E_OUTOFMEMORY);
                }
            }
break;
case 142:
{
            AssertReq(yyvsp[0]);
            Assert((DBOP_content == yyvsp[0]->op) || (DBOP_or == yyvsp[0]->op) || (DBOP_content_proximity == yyvsp[0]->op));

            yyval = yyvsp[0];
            }
break;
case 143:
{
            AssertReq(yyvsp[-4]);
            AssertReq(yyvsp[-1]);
            if ((yyvsp[-1]->value.pvarValue->dblVal < 0.0) ||
                (yyvsp[-1]->value.pvarValue->dblVal > 1.0))
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_WEIGHT_OUT_OF_RANGE);
                WCHAR wchErr[30];
                swprintf(wchErr, L"%f", yyvsp[-1]->value.pvarValue->dblVal);
                m_pIPTProperties->SetErrorToken(wchErr);
                YYABORT(DB_E_ERRORSINCOMMAND);
                }
            yyval = yyvsp[-4];
            SetLWeight(yyval, (LONG) (yyvsp[-1]->value.pvarValue->dblVal * DEFAULTWEIGHT));
            WCHAR wchWeight[10];
            if (swprintf(wchWeight, L"%d", (LONG) (yyvsp[-1]->value.pvarValue->dblVal * DEFAULTWEIGHT)))
                {
                m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L"["));
                m_pIPTProperties->AppendCiRestriction(wchWeight, wcslen(wchWeight));
                m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L"] "));
                }
            DeleteDBQT(yyvsp[-1]);
            yyvsp[-1] = NULL;
            }
break;
case 144:
{
        m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" "));
        yyval = yyvsp[0];
        }
break;
case 149:
{
            HRESULT hr = CoerceScalar(VT_R8, &yyvsp[0]);
            if (S_OK != hr)
                YYABORT(hr);

            yyval = yyvsp[0];
            }
break;
case 150:
{
            yyval = NULL;
            }
break;
case 151:
{
            HRESULT hr = CoerceScalar(VT_I4, &yyvsp[0]);
            if (S_OK != hr)
                YYABORT(hr);

            if (0 != yyvsp[0]->value.pvarValue->lVal)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_PARSE_ERROR);
                WCHAR wchErr[30];
                swprintf(wchErr, L"%d", yyvsp[0]->value.pvarValue->lVal);
                m_pIPTProperties->SetErrorToken(wchErr);
                m_pIPTProperties->SetErrorToken(L"0");
                YYABORT(DB_E_ERRORSINCOMMAND);
                }
            DeleteDBQT(yyvsp[0]);
            yyvsp[0] = NULL;
            yyval = NULL;
            }
break;
case 152:
{
            AssertReq(!yyvsp[-3]);
            AssertReq(yyvsp[-2]);

            HRESULT hr = HrQeTreeCopy(&yyval, m_pIPTProperties->GetContainsColumn());
            if (FAILED(hr))
                {
                m_pIPTProperties->SetErrorHResult(hr, MONSQL_OUT_OF_MEMORY);
                YYABORT(hr);
                }
            m_pIPTProperties->UseCiColumn(L'$');
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L"\""));
            m_pIPTProperties->AppendCiRestriction(((PROPVARIANT*)yyvsp[-2]->value.pvValue)->bstrVal,
                                            wcslen(((PROPVARIANT*)yyvsp[-2]->value.pvValue)->bstrVal));
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L"\""));

            yyval = PctCreateNode(DBOP_content_freetext, DBVALUEKIND_CONTENT, yyval, NULL);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT(E_OUTOFMEMORY);
                }
            yyval->value.pdbcntntValue->pwszPhrase = CoTaskStrDup(((PROPVARIANT*)yyvsp[-2]->value.pvValue)->bstrVal);
            yyval->value.pdbcntntValue->dwGenerateMethod = GENERATE_METHOD_EXACT;
            yyval->value.pdbcntntValue->lWeight = DEFAULTWEIGHT;
            yyval->value.pdbcntntValue->lcid = m_pIPSession->GetLCID();

            DeleteDBQT(m_pIPTProperties->GetContainsColumn());
            m_pIPTProperties->SetContainsColumn(NULL);
            DeleteDBQT(yyvsp[-2]);
            yyvsp[-2] = NULL;
            }
break;
case 153:
{
            AssertReq(yyvsp[-2]);
            AssertReq(yyvsp[0]);

            m_pIPTProperties->UseCiColumn(L'#');
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L"\""));
            m_pIPTProperties->AppendCiRestriction(((PROPVARIANT*)yyvsp[0]->value.pvValue)->pwszVal,
                                            wcslen(((PROPVARIANT*)yyvsp[0]->value.pvValue)->pwszVal));
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L"\""));
            yyval = PctCreateNode(DBOP_like, DBVALUEKIND_LIKE, yyvsp[-2], yyvsp[0], NULL);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT(E_OUTOFMEMORY);
                }
            yyval->value.pdblikeValue->guidDialect = DBGUID_LIKE_OFS;
            yyval->value.pdblikeValue->lWeight = DEFAULTWEIGHT;
            }
break;
case 154:
{
            AssertReq(yyvsp[-2]);
            AssertReq(yyvsp[0]);

            m_pIPTProperties->UseCiColumn(L'#');
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L"\""));
            m_pIPTProperties->AppendCiRestriction(((PROPVARIANT*)yyvsp[0]->value.pvValue)->pwszVal,
                                            wcslen(((PROPVARIANT*)yyvsp[0]->value.pvValue)->pwszVal));
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L"\""));
            yyvsp[-1] = PctCreateNode(DBOP_like, DBVALUEKIND_LIKE, yyvsp[-2], yyvsp[0], NULL);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT(E_OUTOFMEMORY);
                }
            yyvsp[-1]->value.pdblikeValue->guidDialect = DBGUID_LIKE_OFS;
            yyvsp[-1]->value.pdblikeValue->lWeight = DEFAULTWEIGHT;
            yyval = PctCreateNotNode(DEFAULTWEIGHT, yyvsp[-1]);
            }
break;
case 155:
{
            UINT cLen = wcslen(((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal);
            BSTR bstrCopy = SysAllocStringLen(NULL, 4 * cLen);
            if ( 0 == bstrCopy )
            {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
            }

            UINT j = 0;
            for (UINT i = 0; i <= cLen; i++)
                {
                switch ( ((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal[i] )
                    {
                    case L'%':
                        bstrCopy[j++] = L'*';
                        break;

                    case L'_':
                        bstrCopy[j++] = L'?';
                        break;

                    case L'|':
                        bstrCopy[j++] = L'|';
                        bstrCopy[j++] = L'|';
                        break;

                    case L'*':
                        bstrCopy[j++] = L'|';
                        bstrCopy[j++] = L'[';
                        bstrCopy[j++] = L'*';
                        bstrCopy[j++] = L']';
                        break;

                    case L'?':
                        bstrCopy[j++] = L'|';
                        bstrCopy[j++] = L'[';
                        bstrCopy[j++] = L'?';
                        bstrCopy[j++] = L']';
                        break;

                    case L'[':
                        /* UNDONE:  Make sure we're not going out of range with these tests*/
                        if ((L'%' == ((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal[i+1]) &&
                            (L']' == ((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal[i+2]))
                            {
                            bstrCopy[j++] = L'%';
                            i = i + 2;
                            }
                        else if ((L'_' == ((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal[i+1]) &&
                                (L']' == ((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal[i+2]))
                            {
                            bstrCopy[j++] = L'_';
                            i = i + 2;
                            }
                        else if ((L'[' == ((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal[i+1]) &&
                                (L']' == ((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal[i+2]))
                            {
                            bstrCopy[j++] = L'[';
                            i = i + 2;
                            }
                        else if ((L'^' == ((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal[i+1]) &&
                                (L']' == ((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal[i+2]) &&
                                (wcschr((WCHAR*)&(((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal[i+3]), L']')))
                            {
                            bstrCopy[j++] = L'|';
                            bstrCopy[j++] = L'[';
                            bstrCopy[j++] = L'^';
                            bstrCopy[j++] = L']';
                            i = i + 2;
                            }
                        else
                            {
                            bstrCopy[j++] = L'|';
                            bstrCopy[j++] = ((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal[i++];

                            while ((((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal[i] != L']') && (i < cLen))
                                bstrCopy[j++] = ((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal[i++];

                            if (i < cLen)
                                bstrCopy[j++] = ((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal[i];
                            }
                        break;

                    default:
                        bstrCopy[j++] = ((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal[i];
                        break;
                    }
                }

            SysFreeString(((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal);
            ((PROPVARIANT*)yyvsp[0]->value.pvValue)->pwszVal = CoTaskStrDup(bstrCopy);
            ((PROPVARIANT*)yyvsp[0]->value.pvValue)->vt = VT_LPWSTR;
            SysFreeString(bstrCopy);
            yyval = yyvsp[0];
            }
break;
case 156:
{
            AssertReq(yyvsp[-4]);
            AssertReq(yyvsp[-2]);
            m_pIPTProperties->UseCiColumn(L'#');
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L"\""));
            m_pIPTProperties->AppendCiRestriction(((PROPVARIANT*)yyvsp[-2]->value.pvValue)->pwszVal,
                                            wcslen(((PROPVARIANT*)yyvsp[-2]->value.pvValue)->pwszVal));
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L"\""));
            yyval = PctCreateNode(DBOP_like, DBVALUEKIND_LIKE, yyvsp[-4], yyvsp[-2], NULL);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT(E_OUTOFMEMORY);
                }
            yyval->value.pdblikeValue->guidDialect = DBGUID_LIKE_OFS;
            yyval->value.pdblikeValue->lWeight = DEFAULTWEIGHT;
            }
break;
case 157:
{
            AssertReq(yyvsp[0]);
            HRESULT hr = CoerceScalar(VT_LPWSTR, &yyvsp[0]);
            if (S_OK != hr)
                YYABORT(hr);

            LPWSTR pwszMatchString = ((PROPVARIANT*)yyvsp[0]->value.pvValue)->pwszVal;
            while (*pwszMatchString)
                {
                /* perform some soundness checking on string since Index Server won't be happy*/
                /* with an ill formed string*/
                if (L'|' == *pwszMatchString++)
                    {
                    hr = DB_E_ERRORSINCOMMAND;
                    switch ( *pwszMatchString++ )
                        {
                        case L'(':
                            while (*pwszMatchString)
                                if (L'|' == *pwszMatchString++)
                                    if (*pwszMatchString)
                                        if (L')' == *pwszMatchString++)
                                            {
                                            hr = S_OK;
                                            break;
                                            }
                            break;

                        case L'{':
                            while (*pwszMatchString)
                                if (L'|' == *pwszMatchString++)
                                    if (*pwszMatchString)
                                        if (L'}' == *pwszMatchString++)
                                            {
                                            hr = S_OK;
                                            break;
                                            }
                            break;

                        default:
                            hr = S_OK;
                        }
                    }
                }

            if (S_OK != hr)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_MATCH_STRING);
                YYABORT(hr);
                }

            yyval = yyvsp[0];
            }
break;
case 158:
{
            AssertReq(yyvsp[-2]);
            AssertReq(yyvsp[-1]);

            DBCOMMANDTREE * pct = 0;
            if ( m_pIPTProperties->GetDBType() & DBTYPE_VECTOR )
                {
                pct = PctAllocNode(DBVALUEKIND_VARIANT, DBOP_scalar_constant);
                if (NULL == pct)
                    {
                    m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                    YYABORT( E_OUTOFMEMORY );
                    }

                DBCOMMANDTREE* pctList=yyvsp[0];
                UINT i = 0;

                pct->value.pvarValue->vt = m_pIPTProperties->GetDBType();
                ((PROPVARIANT*)pct->value.pvarValue)->caub.cElems = GetNumberOfSiblings(yyvsp[0]);

                if (0 == ((PROPVARIANT*)pct->value.pvarValue)->caub.cElems)
                    {
                    ((PROPVARIANT*)pct->value.pvarValue)->caub.pElems = (UCHAR*) NULL;
                    }
                else
                    {
                    switch ( m_pIPTProperties->GetDBType() )
                        {
                        case (VT_UI1|VT_VECTOR):
                            ((PROPVARIANT*)pct->value.pvarValue)->caub.pElems =
                                (UCHAR*) CoTaskMemAlloc(sizeof(UCHAR)*((PROPVARIANT*)pct->value.pvarValue)->caub.cElems);

                            if (NULL == ((PROPVARIANT*)pct->value.pvarValue)->caub.pElems)
                                {
                                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                                YYABORT( E_OUTOFMEMORY );
                                }

                            for (i = 0; i<((PROPVARIANT*)pct->value.pvarValue)->caub.cElems; i++)
                                {
                                ((PROPVARIANT*)pct->value.pvarValue)->caub.pElems[i] = pctList->value.pvarValue->bVal;
                                pctList = pctList->pctNextSibling;
                                }
                            break;

                        case (VT_I1|VT_VECTOR):
                            ((PROPVARIANT*)pct->value.pvarValue)->cac.pElems =
                                (CHAR*) CoTaskMemAlloc(sizeof(CHAR)*((PROPVARIANT*)pct->value.pvarValue)->cac.cElems);

                            if (NULL == ((PROPVARIANT*)pct->value.pvarValue)->cac.pElems)
                                {
                                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                                YYABORT( E_OUTOFMEMORY );
                                }

                            for (i = 0; i<((PROPVARIANT*)pct->value.pvarValue)->cac.cElems; i++)
                                {
                                ((PROPVARIANT*)pct->value.pvarValue)->cac.pElems[i] = pctList->value.pvarValue->cVal;
                                pctList = pctList->pctNextSibling;
                                }
                            break;

                        case (VT_UI2|VT_VECTOR):
                            ((PROPVARIANT*)pct->value.pvarValue)->caui.pElems =
                                (USHORT*) CoTaskMemAlloc(sizeof(USHORT)*((PROPVARIANT*)pct->value.pvarValue)->caui.cElems);

                            if (NULL == ((PROPVARIANT*)pct->value.pvarValue)->caui.pElems)
                                {
                                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                                YYABORT( E_OUTOFMEMORY );
                                }

                            for (i = 0; i<((PROPVARIANT*)pct->value.pvarValue)->caui.cElems; i++)
                                {
                                ((PROPVARIANT*)pct->value.pvarValue)->caui.pElems[i] = pctList->value.pvarValue->uiVal;
                                pctList = pctList->pctNextSibling;
                                }
                            break;

                        case (VT_I2|VT_VECTOR):
                            ((PROPVARIANT*)pct->value.pvarValue)->cai.pElems =
                                (SHORT*) CoTaskMemAlloc(sizeof(SHORT)*((PROPVARIANT*)pct->value.pvarValue)->cai.cElems);

                            if (NULL == ((PROPVARIANT*)pct->value.pvarValue)->cai.pElems)
                                {
                                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                                YYABORT( E_OUTOFMEMORY );
                                }

                            for (i = 0; i<((PROPVARIANT*)pct->value.pvarValue)->cai.cElems; i++)
                                {
                                ((PROPVARIANT*)pct->value.pvarValue)->cai.pElems[i] = pctList->value.pvarValue->iVal;
                                pctList = pctList->pctNextSibling;
                                }
                            break;

                        case (VT_UI4|VT_VECTOR):
                            ((PROPVARIANT*)pct->value.pvarValue)->caul.pElems =
                                (ULONG*) CoTaskMemAlloc(sizeof(ULONG)*((PROPVARIANT*)pct->value.pvarValue)->caul.cElems);

                            if (NULL == ((PROPVARIANT*)pct->value.pvarValue)->caul.pElems)
                                {
                                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                                YYABORT( E_OUTOFMEMORY );
                                }

                            for (i = 0; i<((PROPVARIANT*)pct->value.pvarValue)->caul.cElems; i++)
                                {
                                ((PROPVARIANT*)pct->value.pvarValue)->caul.pElems[i] = pctList->value.pvarValue->ulVal;
                                pctList = pctList->pctNextSibling;
                                }
                            break;

                        case (VT_I4|VT_VECTOR):
                            ((PROPVARIANT*)pct->value.pvarValue)->cal.pElems =
                                (LONG*) CoTaskMemAlloc(sizeof(LONG)*((PROPVARIANT*)pct->value.pvarValue)->cal.cElems);

                            if (NULL == ((PROPVARIANT*)pct->value.pvarValue)->cal.pElems)
                                {
                                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                                YYABORT( E_OUTOFMEMORY );
                                }

                            for (i = 0; i<((PROPVARIANT*)pct->value.pvarValue)->cal.cElems; i++)
                                {
                                ((PROPVARIANT*)pct->value.pvarValue)->cal.pElems[i] = pctList->value.pvarValue->lVal;
                                pctList = pctList->pctNextSibling;
                                }
                            break;

                        case (VT_UI8|VT_VECTOR):
                            ((PROPVARIANT*)pct->value.pvarValue)->cauh.pElems =
                                (ULARGE_INTEGER*) CoTaskMemAlloc(sizeof(ULARGE_INTEGER)*((PROPVARIANT*)pct->value.pvarValue)->cauh.cElems);

                            if (NULL == ((PROPVARIANT*)pct->value.pvarValue)->cauh.pElems)
                                {
                                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                                YYABORT( E_OUTOFMEMORY );
                                }

                            for (i = 0; i<((PROPVARIANT*)pct->value.pvarValue)->cauh.cElems; i++)
                                {
                                ((PROPVARIANT*)pct->value.pvarValue)->cauh.pElems[i] = ((PROPVARIANT*)pctList->value.pvarValue)->uhVal;
                                pctList = pctList->pctNextSibling;
                                }
                            break;

                        case (VT_I8|VT_VECTOR):
                            ((PROPVARIANT*)pct->value.pvarValue)->cah.pElems =
                                (LARGE_INTEGER*) CoTaskMemAlloc(sizeof(LARGE_INTEGER)*((PROPVARIANT*)pct->value.pvarValue)->cah.cElems);

                            if (NULL == ((PROPVARIANT*)pct->value.pvarValue)->cah.pElems)
                                {
                                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                                YYABORT( E_OUTOFMEMORY );
                                }

                            for (i = 0; i<((PROPVARIANT*)pct->value.pvarValue)->cah.cElems; i++)
                                {
                                ((PROPVARIANT*)pct->value.pvarValue)->cah.pElems[i] = ((PROPVARIANT*)pctList->value.pvarValue)->hVal;
                                pctList = pctList->pctNextSibling;
                                }
                            break;

                        case (VT_R4|VT_VECTOR):
                            ((PROPVARIANT*)pct->value.pvarValue)->caflt.pElems =
                                (float*) CoTaskMemAlloc(sizeof(float)*((PROPVARIANT*)pct->value.pvarValue)->caflt.cElems);

                            if (NULL == ((PROPVARIANT*)pct->value.pvarValue)->caflt.pElems)
                                {
                                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                                YYABORT( E_OUTOFMEMORY );
                                }

                            for (i = 0; i<((PROPVARIANT*)pct->value.pvarValue)->caflt.cElems; i++)
                                {
                                ((PROPVARIANT*)pct->value.pvarValue)->caflt.pElems[i] = pctList->value.pvarValue->fltVal;
                                pctList = pctList->pctNextSibling;
                                }
                            break;

                        case (VT_R8|VT_VECTOR):
                            ((PROPVARIANT*)pct->value.pvarValue)->cadbl.pElems =
                                (double*) CoTaskMemAlloc(sizeof(double)*((PROPVARIANT*)pct->value.pvarValue)->cadbl.cElems);

                            if (NULL == ((PROPVARIANT*)pct->value.pvarValue)->cadbl.pElems)
                                {
                                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                                YYABORT( E_OUTOFMEMORY );
                                }

                            for (i = 0; i<((PROPVARIANT*)pct->value.pvarValue)->cadbl.cElems; i++)
                                {
                                ((PROPVARIANT*)pct->value.pvarValue)->cadbl.pElems[i] = pctList->value.pvarValue->dblVal;
                                pctList = pctList->pctNextSibling;
                                }
                            break;

                        case (VT_BOOL|VT_VECTOR):
                            ((PROPVARIANT*)pct->value.pvarValue)->cabool.pElems =
                                (VARIANT_BOOL*) CoTaskMemAlloc(sizeof(VARIANT_BOOL)*((PROPVARIANT*)pct->value.pvarValue)->cabool.cElems);

                            if (NULL == ((PROPVARIANT*)pct->value.pvarValue)->cabool.pElems)
                                {
                                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                                YYABORT( E_OUTOFMEMORY );
                                }

                            for (i = 0; i<((PROPVARIANT*)pct->value.pvarValue)->cabool.cElems; i++)
                                {
                                ((PROPVARIANT*)pct->value.pvarValue)->cabool.pElems[i] = pctList->value.pvarValue->boolVal;
                                pctList = pctList->pctNextSibling;
                                }
                            break;

                        case (VT_CY|VT_VECTOR):
                            ((PROPVARIANT*)pct->value.pvarValue)->cacy.pElems =
                                (CY*) CoTaskMemAlloc(sizeof(CY)*((PROPVARIANT*)pct->value.pvarValue)->cacy.cElems);

                            if (NULL == ((PROPVARIANT*)pct->value.pvarValue)->cacy.pElems)
                                {
                                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                                YYABORT( E_OUTOFMEMORY );
                                }

                            for (i = 0; i<((PROPVARIANT*)pct->value.pvarValue)->cacy.cElems; i++)
                                {
                                ((PROPVARIANT*)pct->value.pvarValue)->cacy.pElems[i] =
                                    ((PROPVARIANT*)pctList->value.pvarValue)->cyVal;
                                pctList = pctList->pctNextSibling;
                                }
                            break;

                        case (VT_DATE|VT_VECTOR):
                            ((PROPVARIANT*)pct->value.pvarValue)->cadbl.pElems =
                                (double*) CoTaskMemAlloc(sizeof(double)*((PROPVARIANT*)pct->value.pvarValue)->cadbl.cElems);

                            if (NULL == ((PROPVARIANT*)pct->value.pvarValue)->cadbl.pElems)
                                {
                                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                                YYABORT( E_OUTOFMEMORY );
                                }

                            for (i = 0; i<((PROPVARIANT*)pct->value.pvarValue)->cadbl.cElems; i++)
                                {
                                ((PROPVARIANT*)pct->value.pvarValue)->cadbl.pElems[i] =
                                    ((PROPVARIANT*)pctList->value.pvarValue)->date;
                                pctList = pctList->pctNextSibling;
                                }
                            break;

                        case (VT_FILETIME|VT_VECTOR):
                            ((PROPVARIANT*)pct->value.pvarValue)->cafiletime.pElems =
                                (FILETIME*) CoTaskMemAlloc(sizeof(FILETIME)*((PROPVARIANT*)pct->value.pvarValue)->cafiletime.cElems);

                            if (NULL == ((PROPVARIANT*)pct->value.pvarValue)->cafiletime.pElems)
                                {
                                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                                YYABORT( E_OUTOFMEMORY );
                                }

                            for (i = 0; i<((PROPVARIANT*)pct->value.pvarValue)->cafiletime.cElems; i++)
                                {
                                ((PROPVARIANT*)pct->value.pvarValue)->cafiletime.pElems[i] =
                                    ((PROPVARIANT*)pctList->value.pvarValue)->filetime;
                                pctList = pctList->pctNextSibling;
                                }
                            break;

                        case (VT_BSTR|VT_VECTOR):
                            ((PROPVARIANT*)pct->value.pvarValue)->cabstr.pElems =
                                (BSTR*) CoTaskMemAlloc(sizeof(BSTR)*((PROPVARIANT*)pct->value.pvarValue)->cabstr.cElems);

                            if (NULL == ((PROPVARIANT*)pct->value.pvarValue)->cabstr.pElems)
                                {
                                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                                YYABORT( E_OUTOFMEMORY );
                                }

                            for (i = 0; i<((PROPVARIANT*)pct->value.pvarValue)->cabstr.cElems; i++)
                                {
                                    ((PROPVARIANT*)pct->value.pvarValue)->cabstr.pElems[i] =
                                        SysAllocString(pctList->value.pvarValue->bstrVal);
                                    if ( 0 == ((PROPVARIANT*)pct->value.pvarValue)->cabstr.pElems[i] )
                                    {
                                        m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                                        YYABORT( E_OUTOFMEMORY );
                                    }
                                    pctList = pctList->pctNextSibling;
                                }
                            break;

                        case (DBTYPE_STR|VT_VECTOR):
                            pct->value.pvarValue->vt = VT_LPSTR | VT_VECTOR;
                            ((PROPVARIANT*)pct->value.pvarValue)->calpstr.pElems =
                                (LPSTR*) CoTaskMemAlloc(sizeof(LPSTR)*((PROPVARIANT*)pct->value.pvarValue)->calpstr.cElems);

                            if (NULL == ((PROPVARIANT*)pct->value.pvarValue)->calpstr.pElems)
                                {
                                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                                YYABORT( E_OUTOFMEMORY );
                                }

                            for (i = 0; i<((PROPVARIANT*)pct->value.pvarValue)->calpstr.cElems; i++)
                                {
                                ((PROPVARIANT*)pct->value.pvarValue)->calpstr.pElems[i] =
                                    (LPSTR)CoTaskMemAlloc((lstrlenA(((PROPVARIANT*)pctList->value.pvarValue)->pszVal)+2)*sizeof(CHAR));
                                if ( 0 == ((PROPVARIANT*)pct->value.pvarValue)->calpstr.pElems[i] )
                                    {
                                    /* free allocations made so far*/
                                    for ( int j = i-1; j >= 0; j++ )
                                        CoTaskMemFree( ((PROPVARIANT*)pct->value.pvarValue)->calpstr.pElems[i] );
                                    CoTaskMemFree( ((PROPVARIANT*)pct->value.pvarValue)->calpstr.pElems );

                                    m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                                    YYABORT( E_OUTOFMEMORY );
                                    }

                                strcpy(((PROPVARIANT*)pct->value.pvarValue)->calpstr.pElems[i],
                                    ((PROPVARIANT*)pctList->value.pvarValue)->pszVal);
                                pctList = pctList->pctNextSibling;
                                }
                            break;

                        case (DBTYPE_WSTR|VT_VECTOR):
                            pct->value.pvarValue->vt = VT_LPWSTR | VT_VECTOR;
                            ((PROPVARIANT*)pct->value.pvarValue)->calpwstr.pElems =
                                (LPWSTR*) CoTaskMemAlloc(sizeof(LPWSTR)*((PROPVARIANT*)pct->value.pvarValue)->calpwstr.cElems);

                            if ( 0 == ((PROPVARIANT*)pct->value.pvarValue)->calpwstr.pElems )
                                {
                                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                                YYABORT( E_OUTOFMEMORY );
                                }

                            for ( i = 0; i<((PROPVARIANT*)pct->value.pvarValue)->calpwstr.cElems; i++ )
                                {
                                ((PROPVARIANT*)pct->value.pvarValue)->calpwstr.pElems[i] =
                                    CoTaskStrDup(((PROPVARIANT*)pctList->value.pvarValue)->pwszVal);
                                if ( 0 == ((PROPVARIANT*)pct->value.pvarValue)->calpwstr.pElems[i] )
                                    {
                                    /* free allocations made so far*/
                                    for ( int j = i-1; j >= 0; j++ )
                                        CoTaskMemFree( ((PROPVARIANT*)pct->value.pvarValue)->calpwstr.pElems[i] );
                                    CoTaskMemFree( ((PROPVARIANT*)pct->value.pvarValue)->calpwstr.pElems );

                                    m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                                    YYABORT( E_OUTOFMEMORY );
                                    }


                                pctList = pctList->pctNextSibling;
                                }
                            break;

                        case (VT_CLSID|VT_VECTOR):
                            pct->value.pvarValue->vt = VT_CLSID | VT_VECTOR;
                            ((PROPVARIANT*)pct->value.pvarValue)->cauuid.pElems =
                                (GUID*) CoTaskMemAlloc(sizeof(GUID)*((PROPVARIANT*)pct->value.pvarValue)->cauuid.cElems);

                            if ( NULL == ((PROPVARIANT*)pct->value.pvarValue)->cauuid.pElems )
                                {
                                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                                YYABORT( E_OUTOFMEMORY );
                                }

                            for ( i = 0; i<((PROPVARIANT*)pct->value.pvarValue)->cauuid.cElems; i++ )
                                {
                                ((PROPVARIANT*)pct->value.pvarValue)->cauuid.pElems[i] =
                                    *((PROPVARIANT*)pctList->value.pvarValue)->puuid;
                                pctList = pctList->pctNextSibling;
                                }
                            break;

                        default:
                            assert(!"PctAllocNode: illegal wKind");
                            m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_PARSE_ERROR);
                            m_pIPTProperties->SetErrorToken(L"ARRAY");
                            DeleteDBQT( pct );
                            YYABORT(DB_E_ERRORSINCOMMAND);
                        }
                    }
                }
            else
                {
                switch ( m_pIPTProperties->GetDBType() )
                    {
                    case VT_UI1:
                    case VT_UI2:
                    case VT_UI4:
                    case VT_UI8:
                        /* Allows:*/
                        /*      DBOP_allbits*/
                        /*      DBOP_anybits*/
                        /* when the LHS is a non vector.*/
                        /**/
                        /* There isn't a way to say the following through SQL currently:*/
                        /*      DBOP_anybits_all*/
                        /*      DBOP_anybits_any*/
                        /*      DBOP_allbits_all*/
                        /*      DBOP_allbits_any*/
                        pct = yyvsp[0];
                        yyvsp[0] = 0;
                        break;

                    default:
                        assert(!"PctAllocNode: illegal wKind");
                        m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_PARSE_ERROR);
                        m_pIPTProperties->SetErrorToken(L"ARRAY");
                        YYABORT(DB_E_ERRORSINCOMMAND);
                    }
                }

            if (yyvsp[0])
                {
                DeleteDBQT(yyvsp[0]);
                yyvsp[0] = NULL;
                }
            yyvsp[-2]->pctNextSibling = pct;
            yyvsp[-1]->pctFirstChild = yyvsp[-2];
            yyval = yyvsp[-1];
            }
break;
case 162:
{
            if ( m_pIPTProperties->GetDBType() & DBTYPE_VECTOR )
                yyval = PctCreateRelationalNode( DBOP_equal, DEFAULTWEIGHT );
            else
                yyval = PctCreateRelationalNode( DBOP_equal, DEFAULTWEIGHT );

            if ( NULL == yyval )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }
            m_pIPTProperties->AppendCiRestriction( VAL_AND_CCH_MINUS_NULL(L" = ") );
            }
break;
case 163:
{
            if ( m_pIPTProperties->GetDBType() & DBTYPE_VECTOR )
                yyval = PctCreateRelationalNode( DBOP_equal_all, DEFAULTWEIGHT );
            else
                yyval = PctCreateRelationalNode( DBOP_allbits, DEFAULTWEIGHT );

            if ( NULL == yyval )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            if ( m_pIPTProperties->GetDBType() & DBTYPE_VECTOR )
                m_pIPTProperties->AppendCiRestriction( VAL_AND_CCH_MINUS_NULL(L" = ^a ") );
            else
                m_pIPTProperties->AppendCiRestriction( VAL_AND_CCH_MINUS_NULL(L" ^a ") );
            }
break;
case 164:
{
            if ( m_pIPTProperties->GetDBType() & DBTYPE_VECTOR )
                yyval = PctCreateRelationalNode( DBOP_equal_any, DEFAULTWEIGHT );
            else
                yyval = PctCreateRelationalNode( DBOP_anybits, DEFAULTWEIGHT );

            if ( NULL == yyval )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }

            if ( m_pIPTProperties->GetDBType() & DBTYPE_VECTOR )
                m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" = ^s "));
            else
                m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" ^s "));
            }
break;
case 165:
{
            if ( m_pIPTProperties->GetDBType() & DBTYPE_VECTOR )
                yyval = PctCreateRelationalNode( DBOP_not_equal, DEFAULTWEIGHT );

            if ( NULL == yyval )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY );
                YYABORT( E_OUTOFMEMORY );
                }
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" != ") );
            }
break;
case 166:
{
            yyval = PctCreateRelationalNode(DBOP_not_equal_all, DEFAULTWEIGHT);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" != ^a "));
            }
break;
case 167:
{
            yyval = PctCreateRelationalNode(DBOP_not_equal_any, DEFAULTWEIGHT);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" != ^s "));
            }
break;
case 168:
{
            yyval = PctCreateRelationalNode(DBOP_less, DEFAULTWEIGHT);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" < "));
            }
break;
case 169:
{
            yyval = PctCreateRelationalNode(DBOP_less_all, DEFAULTWEIGHT);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" < ^a "));
            }
break;
case 170:
{
            yyval = PctCreateRelationalNode(DBOP_less_any, DEFAULTWEIGHT);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" < ^s "));
            }
break;
case 171:
{
            yyval = PctCreateRelationalNode(DBOP_greater, DEFAULTWEIGHT);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" > "));
            }
break;
case 172:
{
            yyval = PctCreateRelationalNode(DBOP_greater_all, DEFAULTWEIGHT);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" > ^a "));
            }
break;
case 173:
{
            yyval = PctCreateRelationalNode(DBOP_greater_any, DEFAULTWEIGHT);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" > ^s "));
            }
break;
case 174:
{
            yyval = PctCreateRelationalNode(DBOP_less_equal, DEFAULTWEIGHT);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" <= "));
            }
break;
case 175:
{
            yyval = PctCreateRelationalNode(DBOP_less_equal_all, DEFAULTWEIGHT);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" <= ^a "));
            }
break;
case 176:
{
            yyval = PctCreateRelationalNode(DBOP_less_equal_any, DEFAULTWEIGHT);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" <= ^s "));
            }
break;
case 177:
{
            yyval = PctCreateRelationalNode(DBOP_greater_equal, DEFAULTWEIGHT);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" >= "));
            }
break;
case 178:
{
            yyval = PctCreateRelationalNode(DBOP_greater_equal_all, DEFAULTWEIGHT);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" >= ^a "));
            }
break;
case 179:
{
            yyval = PctCreateRelationalNode(DBOP_greater_equal_any, DEFAULTWEIGHT);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" >= ^s "));
            }
break;
case 180:
{
            yyval = PctReverse(yyvsp[-1]);
            }
break;
case 181:
{
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L"{"));
            }
break;
case 182:
{
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L"}"));
            }
break;
case 183:
{
            yyval = NULL;
            }
break;
case 185:
{
            AssertReq(yyvsp[-2]);

            if (NULL == yyvsp[0])
                YYABORT(DB_E_CANTCONVERTVALUE);
            yyval = PctLink(yyvsp[0], yyvsp[-2]);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            }
break;
case 186:
{
            if (NULL == yyvsp[0])
                YYABORT(DB_E_CANTCONVERTVALUE);
            yyval = yyvsp[0];
            }
break;
case 187:
{
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L","));
            }
break;
case 188:
{
            AssertReq(yyvsp[-2]);

            yyvsp[-1] = PctAllocNode(DBVALUEKIND_VARIANT, DBOP_scalar_constant);
            if (NULL == yyvsp[-1])
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }

            ((PROPVARIANT*)yyvsp[-1]->value.pvValue)->vt = VT_EMPTY;
            yyval = PctCreateRelationalNode(DBOP_equal, DEFAULTWEIGHT);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            yyval->pctFirstChild = yyvsp[-2];
            yyvsp[-2]->pctNextSibling = yyvsp[-1];
            }
break;
case 189:
{
            AssertReq(yyvsp[-2]);

            yyvsp[-1] = PctAllocNode(DBVALUEKIND_VARIANT, DBOP_scalar_constant);
            if (NULL == yyvsp[-1])
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }

            ((PROPVARIANT*)yyvsp[-1]->value.pvValue)->vt = VT_EMPTY;
/*          $$ = PctCreateRelationalNode(DBOP_not_equal, DEFAULTWEIGHT);*/
            yyval = PctCreateRelationalNode(DBOP_equal, DEFAULTWEIGHT);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            yyval->pctFirstChild = yyvsp[-2];
            yyvsp[-2]->pctNextSibling = yyvsp[-1];
            yyval = PctCreateNotNode(DEFAULTWEIGHT, yyval);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            }
break;
case 191:
{
            AssertReq(yyvsp[-2]);
            AssertReq(yyvsp[0]);

            yyval = PctCreateBooleanNode(DBOP_or, DEFAULTWEIGHT, yyvsp[-2], yyvsp[0]);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            }
break;
case 193:
{
            AssertReq(yyvsp[-2]);
            AssertReq(yyvsp[0]);

            yyval = PctCreateBooleanNode(DBOP_and, DEFAULTWEIGHT, yyvsp[-2], yyvsp[0]);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            }
break;
case 195:
{
            AssertReq(yyvsp[0]);

            yyval = PctCreateNotNode(DEFAULTWEIGHT, yyvsp[0]);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            }
break;
case 196:
{
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" OR "));
            }
break;
case 197:
{
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" AND "));
            }
break;
case 198:
{
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L" NOT "));
            }
break;
case 200:
{
            AssertReq(yyvsp[-2]);
            yyval = PctCreateNode(DBOP_is_TRUE, yyvsp[-2], NULL);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            }
break;
case 201:
{
            AssertReq(yyvsp[-2]);
            yyval = PctCreateNode(DBOP_is_FALSE, yyvsp[-2], NULL);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            }
break;
case 202:
{
            AssertReq(yyvsp[-2]);
            yyval = PctCreateNode(DBOP_is_INVALID, yyvsp[-2], NULL);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            }
break;
case 203:
{
            AssertReq(yyvsp[-2]);
            yyvsp[-1] = PctCreateNode(DBOP_is_TRUE, yyvsp[-2], NULL);
            if (NULL == yyvsp[-1])
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            yyval = PctCreateNotNode(DEFAULTWEIGHT, yyvsp[-1]);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            }
break;
case 204:
{
            AssertReq(yyvsp[-2]);
            yyvsp[-1] = PctCreateNode(DBOP_is_FALSE, yyvsp[-2], NULL);
            if (NULL == yyvsp[-1])
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            yyval = PctCreateNotNode(DEFAULTWEIGHT, yyvsp[-1]);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            }
break;
case 205:
{
            AssertReq(yyvsp[-2]);
            yyvsp[-1] = PctCreateNode(DBOP_is_INVALID, yyvsp[-2], NULL);
            if (NULL == yyvsp[-1])
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            yyval = PctCreateNotNode(DEFAULTWEIGHT, yyvsp[-1]);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            }
break;
case 206:
{
            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L"("));
            yyval = NULL;
            }
break;
case 207:
{
            AssertReq(yyvsp[0]);

            m_pIPTProperties->AppendCiRestriction(VAL_AND_CCH_MINUS_NULL(L")"));
            yyval = yyvsp[0];
            }
break;
case 208:
{
            AssertReq(yyvsp[-1]);

            yyval = yyvsp[-1];
            }
break;
case 209:
{
            AssertReq(yyvsp[0]);

            yyvsp[0] = PctReverse(yyvsp[0]);
            yyval = PctCreateNode(DBOP_sort_list_anchor, yyvsp[0], NULL);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            }
break;
case 210:
{
            AssertReq(yyvsp[-2]);
            AssertReq(yyvsp[0]);

            yyval = PctLink(yyvsp[0], yyvsp[-2]);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            }
break;
case 212:
{
            AssertReq(yyvsp[-1]);
            AssertReq(yyvsp[0]);

            yyvsp[0]->value.pdbsrtinfValue->lcid = m_pIPSession->GetLCID();
            yyvsp[0]->pctFirstChild = yyvsp[-1];
            yyval = yyvsp[0];
            }
break;
case 213:
{
            yyval = PctCreateNode(DBOP_sort_list_element, DBVALUEKIND_SORTINFO, NULL);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            yyval->value.pdbsrtinfValue->fDesc = m_pIPTProperties->GetSortDesc();
            }
break;
case 214:
{
            yyval = PctCreateNode(DBOP_sort_list_element, DBVALUEKIND_SORTINFO, NULL);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }
            yyval->value.pdbsrtinfValue->fDesc = QUERY_SORTASCEND;
            m_pIPTProperties->SetSortDesc(QUERY_SORTASCEND);
            }
break;
case 215:
{
            yyval = PctCreateNode(DBOP_sort_list_element, DBVALUEKIND_SORTINFO, NULL);
            if (NULL == yyval)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT(E_OUTOFMEMORY );
                }
            yyval->value.pdbsrtinfValue->fDesc = QUERY_SORTDESCEND;
            m_pIPTProperties->SetSortDesc(QUERY_SORTDESCEND);
            }
break;
case 216:
{
/*@SetCiColumn does the clear   m_pCMonarchSessionData->ClearCiColumn();*/
            }
break;
case 218:
{
            yyval = NULL;
            }
break;
case 219:
{
            yyval = yyvsp[0];
            }
break;
case 223:
{
            HRESULT hr = S_OK;
            yyvsp[-7] = PctBuiltInProperty(yyvsp[-1]->value.pwszValue, m_pIPSession, m_pIPTProperties);
            if (NULL != yyvsp[-7])
                {
                /* This is a built-in friendly name.  Definition better match built in definition.*/
                if (*yyvsp[-5]->value.pGuid != yyvsp[-7]->value.pdbidValue->uGuid.guid     ||
                    m_pIPTProperties->GetDBType() != yyvsp[0]->value.usValue ||
                    DBKIND_GUID_PROPID != yyvsp[-7]->value.pdbidValue->eKind        ||
                    yyvsp[-3]->value.pvarValue->lVal != (long)yyvsp[-7]->value.pdbidValue->uName.ulPropid)
                    {
                    m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_BUILTIN_PROPERTY);
                    m_pIPTProperties->SetErrorToken(yyvsp[-1]->value.pwszValue);
                    YYABORT(DB_E_ERRORSINCOMMAND);
                    }
                }
            else
                m_pIPSession->m_pCPropertyList->SetPropertyEntry(yyvsp[-1]->value.pwszValue,
                                                yyvsp[0]->value.ulValue,
                                                *yyvsp[-5]->value.pGuid,
                                                DBKIND_GUID_PROPID,
                                                (LPWSTR) LongToPtr( yyvsp[-3]->value.pvarValue->lVal ),
                                                m_pIPSession->GetGlobalDefinition());
            if (FAILED(hr))
                {
                /* Unable to store the property name and/or values in the symbol table*/
                m_pIPTProperties->SetErrorHResult(hr, MONSQL_PARSE_ERROR);
                m_pIPTProperties->SetErrorToken(yyvsp[-1]->value.pwszValue);
                YYABORT(DB_E_ERRORSINCOMMAND);
                }

            if (yyvsp[-7])
                DeleteDBQT(yyvsp[-7]);
            DeleteDBQT(yyvsp[-5]);
            DeleteDBQT(yyvsp[-3]);
            DeleteDBQT(yyvsp[-1]);
            DeleteDBQT(yyvsp[0]);
            yyval = NULL;
            }
break;
case 224:
{
            HRESULT hr = S_OK;
            yyvsp[-7] = PctBuiltInProperty(yyvsp[-1]->value.pwszValue, m_pIPSession, m_pIPTProperties);
            if (NULL != yyvsp[-7])
                {
                /* This is a built-in friendly name.  Definition better match built in definition.*/
                if (*yyvsp[-5]->value.pGuid != yyvsp[-7]->value.pdbidValue->uGuid.guid     ||
                    m_pIPTProperties->GetDBType() != yyvsp[0]->value.ulValue ||
                    DBKIND_GUID_NAME != yyvsp[-7]->value.pdbidValue->eKind          ||
                    0 != _wcsicmp(((PROPVARIANT*)yyvsp[-3]->value.pvValue)->bstrVal, yyvsp[-7]->value.pdbidValue->uName.pwszName))
                    {
                    m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_BUILTIN_PROPERTY);
/*                  m_pIPTProperties->SetErrorToken($1->value.pwszValue);*/
                    YYABORT(DB_E_ERRORSINCOMMAND);
                    }
                }
            else
                hr = m_pIPSession->m_pCPropertyList->SetPropertyEntry(yyvsp[-1]->value.pwszValue,
                                                        yyvsp[0]->value.ulValue,
                                                        *yyvsp[-5]->value.pGuid,
                                                        DBKIND_GUID_NAME,
                                                        ((PROPVARIANT*)yyvsp[-3]->value.pvValue)->bstrVal,
                                                        m_pIPSession->GetGlobalDefinition());
            if (FAILED(hr))
                {
                /* Unable to store the property name and/or values in the symbol table*/
                m_pIPTProperties->SetErrorHResult(hr, MONSQL_PARSE_ERROR);
                m_pIPTProperties->SetErrorToken(yyvsp[-1]->value.pwszValue);
                YYABORT(DB_E_ERRORSINCOMMAND);
                }

            if (yyvsp[-7])
                DeleteDBQT(yyvsp[-7]);
            DeleteDBQT(yyvsp[-5]);
            DeleteDBQT(yyvsp[-3]);
            DeleteDBQT(yyvsp[-1]);
            DeleteDBQT(yyvsp[0]);
            }
break;
case 226:
{
            yyval = PctCreateNode(DBOP_scalar_constant, DBVALUEKIND_UI2, NULL);
            yyval->value.usValue = DBTYPE_WSTR|DBTYPE_BYREF;
            }
break;
case 227:
{
            yyval = yyvsp[0];
            }
break;
case 228:
{
            AssertReq(yyvsp[0]);

            DBTYPE dbType = GetDBTypeFromStr(yyvsp[0]->value.pwszValue);
            if ((DBTYPE_EMPTY == dbType) ||
                (DBTYPE_BYREF == dbType) ||
                (DBTYPE_VECTOR == dbType))
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_PARSE_ERROR);
                m_pIPTProperties->SetErrorToken(yyvsp[0]->value.pwszValue);
                m_pIPTProperties->SetErrorToken(L"<base Indexing Service dbtype1");
                YYABORT(DB_E_ERRORSINCOMMAND);
                }

            DeleteDBQT(yyvsp[0]);
            yyvsp[0] = NULL;
            yyval = PctCreateNode(DBOP_scalar_constant, DBVALUEKIND_UI2, NULL);
            if (DBTYPE_WSTR == dbType || DBTYPE_STR == dbType)
                dbType = dbType | DBTYPE_BYREF;
            yyval->value.usValue = dbType;
            }
break;
case 229:
{
            AssertReq(yyvsp[-2]);
            AssertReq(yyvsp[0]);

            DBTYPE dbType1 = GetDBTypeFromStr(yyvsp[-2]->value.pwszValue);
            DBTYPE dbType2 = GetDBTypeFromStr(yyvsp[0]->value.pwszValue);
            if ((DBTYPE_BYREF == dbType1 || DBTYPE_VECTOR == dbType1) &&
                (DBTYPE_BYREF == dbType2 || DBTYPE_VECTOR == dbType2))
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_PARSE_ERROR);
                m_pIPTProperties->SetErrorToken(yyvsp[0]->value.pwszValue);
                m_pIPTProperties->SetErrorToken(
                    L"DBTYPE_I2, DBTYPE_I4, DBTYPE_R4, DBTYPE_R8, DBTYPE_CY, DBTYPE_DATE, DBTYPE_BSTR, DBTYPE_BOOL, DBTYPE_STR, DBTYPE_WSTR");
                YYABORT(DB_E_ERRORSINCOMMAND);
                }

            if (DBTYPE_BYREF != dbType1 && DBTYPE_VECTOR != dbType1 &&
                DBTYPE_BYREF != dbType2 && DBTYPE_VECTOR != dbType2)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_PARSE_ERROR);
                m_pIPTProperties->SetErrorToken(yyvsp[0]->value.pwszValue);
                m_pIPTProperties->SetErrorToken(L"DBTYPE_BYREF, DBTYPE_VECTOR");
                YYABORT(DB_E_ERRORSINCOMMAND);
                }
            DeleteDBQT(yyvsp[-2]);
            yyvsp[-2] = NULL;
            DeleteDBQT(yyvsp[0]);
            yyvsp[0] = NULL;
            yyval = PctCreateNode(DBOP_scalar_constant, DBVALUEKIND_UI2, NULL);
            yyval->value.usValue = dbType1 | dbType2;
            }
break;
case 233:
{
            GUID* pGuid = (GUID*) CoTaskMemAlloc(sizeof GUID);  /* this will become part of tree*/
            if (NULL == pGuid)
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                YYABORT( E_OUTOFMEMORY );
                }

            BOOL bRet = ParseGuid(((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal, *pGuid);
            if ( bRet && GUID_NULL != *pGuid)
                {
                SCODE sc = PropVariantClear((PROPVARIANT*)yyvsp[0]->value.pvValue);
                Assert(SUCCEEDED(sc));  /* UNDONE:  meaningful error message*/
                CoTaskMemFree(yyvsp[0]->value.pvValue);
                yyvsp[0]->wKind = DBVALUEKIND_GUID;
                yyvsp[0]->value.pGuid = pGuid;
                yyval = yyvsp[0];
                }
            else
                {
                CoTaskMemFree(pGuid);
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_PARSE_ERROR);
                m_pIPTProperties->SetErrorToken(((PROPVARIANT*)yyvsp[0]->value.pvValue)->bstrVal);
                YYABORT(DB_E_ERRORSINCOMMAND);
                }
            }
break;
case 234:
{
            yyval = NULL;
            }
break;
case 235:
{
            AssertReq(yyvsp[-1]);
            AssertReq(yyvsp[0]);

            if ((0==_wcsicmp(yyvsp[-1]->value.pwszValue, L"Jaccard")) &&
                (0==_wcsicmp(yyvsp[0]->value.pwszValue, L"coefficient")))
                m_pIPSession->SetRankingMethod(VECTOR_RANK_JACCARD);
            else if ((0==_wcsicmp(yyvsp[-1]->value.pwszValue, L"dice")) &&
                (0==_wcsicmp(yyvsp[0]->value.pwszValue, L"coefficient")))
                m_pIPSession->SetRankingMethod(VECTOR_RANK_DICE);
            else if ((0==_wcsicmp(yyvsp[-1]->value.pwszValue, L"inner")) &&
                (0==_wcsicmp(yyvsp[0]->value.pwszValue, L"product")))
                m_pIPSession->SetRankingMethod(VECTOR_RANK_INNER);
            else
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_PARSE_ERROR);
                m_pIPTProperties->SetErrorToken(yyvsp[-1]->value.pwszValue);
                m_pIPTProperties->SetErrorToken(L"MINIMUM, MAXIMUM, JACCARD COEFFICIENT, DICE COEFFICIENT, INNER PRODUCT");
                YYABORT(DB_E_ERRORSINCOMMAND);
                }

            DeleteDBQT(yyvsp[0]);
            yyvsp[0] = NULL;
            DeleteDBQT(yyvsp[-1]);
            yyvsp[-1] = NULL;
            yyval = NULL;
            }
break;
case 236:
{
            AssertReq(yyvsp[0]);

            if (0==_wcsicmp(yyvsp[0]->value.pwszValue, L"minimum"))
                m_pIPSession->SetRankingMethod(VECTOR_RANK_MIN);
            else if (0==_wcsicmp(yyvsp[0]->value.pwszValue, L"maximum"))
                m_pIPSession->SetRankingMethod(VECTOR_RANK_MAX);
            else
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_PARSE_ERROR);
                m_pIPTProperties->SetErrorToken(yyvsp[0]->value.pwszValue);
                m_pIPTProperties->SetErrorToken(L"MINIMUM, MAXIMUM, JACCARD COEFFICIENT, DICE COEFFICIENT, INNER PRODUCT");
                YYABORT(DB_E_ERRORSINCOMMAND);
                }

            DeleteDBQT(yyvsp[0]);
            yyvsp[0] = NULL;
            yyval = NULL;
            }
break;
case 237:
{
            if (0 != _wcsicmp(yyvsp[-1]->value.pwszValue, L"GLOBAL"))
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_PARSE_ERROR);
                m_pIPTProperties->SetErrorToken(yyvsp[-1]->value.pwszValue);
                m_pIPTProperties->SetErrorToken(L"GLOBAL");
                YYABORT(DB_E_ERRORSINCOMMAND);
                }
            if (0 == _wcsicmp(yyvsp[0]->value.pwszValue, L"ON"))
                m_pIPSession->SetGlobalDefinition(TRUE);
            else if (0 == _wcsicmp(yyvsp[0]->value.pwszValue, L"OFF"))
                m_pIPSession->SetGlobalDefinition(FALSE);
            else
                {
                m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_PARSE_ERROR);
                m_pIPTProperties->SetErrorToken(yyvsp[0]->value.pwszValue);
                m_pIPTProperties->SetErrorToken(L"ON, OFF");
                YYABORT(DB_E_ERRORSINCOMMAND);
                }
            DeleteDBQT(yyvsp[-1]);
            DeleteDBQT(yyvsp[0]);
            yyval = NULL;
            }
break;
case 238:
{ /* _CREATE _VIEW view_name _AS _SELECT select_list from_clause*/
            AssertReq( yyvsp[-4] );
            AssertReq( yyvsp[-1] );
            AssertReq( yyvsp[0] );

            /**/
            /* Can create views only on the current catalog*/
            /**/
            if ( 0 != _wcsicmp((yyvsp[-4]->value.pdbcntnttblValue)->pwszMachine, m_pIPSession->GetDefaultMachine()) &&
                 0 != _wcsicmp((yyvsp[-4]->value.pdbcntnttblValue)->pwszCatalog, m_pIPSession->GetDefaultCatalog()) )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_PARSE_ERROR);
                m_pIPTProperties->SetErrorToken( (yyvsp[-4]->pctNextSibling)->value.pwszValue );
                m_pIPTProperties->SetErrorToken( L"<unqualified temporary view name>" );
                YYABORT( DB_E_ERRORSINCOMMAND );
                }

            if ( DBOP_outall_name == yyvsp[-1]->op )
                {
                m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_PARSE_ERROR );
                m_pIPTProperties->SetErrorToken( L"*" );
                m_pIPTProperties->SetErrorToken( L"<select list>" );
                YYABORT( DB_E_ERRORSINCOMMAND );
                }

            Assert( DBOP_content_table == yyvsp[-4]->op );
            AssertReq( yyvsp[-4]->pctNextSibling );        /* name of the view*/

            SCODE sc = S_OK;

            /* This is the LA_proj, which doesn't have a NextSibling.*/
            /* Use the next sibling to store contenttable tree*/
            /* specified in the from_clause*/
            Assert( 0 == yyvsp[-1]->pctNextSibling );

            if ( L'#' != yyvsp[-4]->pctNextSibling->value.pwszValue[0] )
                {
                if ( m_pIPSession->GetGlobalDefinition() )
                    sc = m_pIPSession->GetGlobalViewList()->SetViewDefinition(
                                                                m_pIPSession,
                                                                m_pIPTProperties,
                                                                yyvsp[-4]->pctNextSibling->value.pwszValue,
                                                                NULL,       /* all catalogs*/
                                                                yyvsp[-1]);
                else
                    {
                    m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_PARSE_ERROR );
                    m_pIPTProperties->SetErrorToken( yyvsp[-4]->pctNextSibling->value.pwszValue );
                    m_pIPTProperties->SetErrorToken( L"<temporary view name>" );
                    YYABORT( DB_E_ERRORSINCOMMAND );
                    }
                }
            else
                {
                if ( 1 >= wcslen(yyvsp[-4]->pctNextSibling->value.pwszValue) )
                    {
                    m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_PARSE_ERROR );
                    m_pIPTProperties->SetErrorToken( yyvsp[-4]->pctNextSibling->value.pwszValue );
                    m_pIPTProperties->SetErrorToken( L"<temporary view name>" );
                    YYABORT( DB_E_ERRORSINCOMMAND );
                    }
                else if ( L'#' == yyvsp[-4]->pctNextSibling->value.pwszValue[1] )
                    {
                    /* store the scope information for the view*/

                    yyvsp[-1]->pctNextSibling = yyvsp[0];
                    yyvsp[0] = 0;

                    sc = m_pIPSession->GetLocalViewList()->SetViewDefinition(
                                                                        m_pIPSession,
                                                                        m_pIPTProperties,
                                                                        yyvsp[-4]->pctNextSibling->value.pwszValue,
                                                                        (yyvsp[-4]->value.pdbcntnttblValue)->pwszCatalog,
                                                                        yyvsp[-1]);
                    }
                else
                    {
                    yyvsp[-1]->pctNextSibling = yyvsp[0];
                    yyvsp[0] = 0;

                    sc = m_pIPSession->GetGlobalViewList()->SetViewDefinition(
                                                                        m_pIPSession,
                                                                        m_pIPTProperties,
                                                                        yyvsp[-4]->pctNextSibling->value.pwszValue,
                                                                        (yyvsp[-4]->value.pdbcntnttblValue)->pwszCatalog,
                                                                        yyvsp[-1]);
                    }
                }

            if ( FAILED(sc) )
                {
                if ( E_INVALIDARG == sc )
                    {
                    m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_VIEW_ALREADY_DEFINED );
                    m_pIPTProperties->SetErrorToken( yyvsp[-4]->pctNextSibling->value.pwszValue );
                    m_pIPTProperties->SetErrorToken( (yyvsp[-4]->value.pdbcntnttblValue)->pwszCatalog );
                    YYABORT( DB_E_ERRORSINCOMMAND );
                    }
                else
                    {
                    m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_PARSE_ERROR );
                    m_pIPTProperties->SetErrorToken( yyvsp[-4]->pctNextSibling->value.pwszValue );
                    YYABORT( DB_E_ERRORSINCOMMAND );
                    }
                }

            DeleteDBQT( yyvsp[-4] );
            DeleteDBQT( yyvsp[-1] );

            if ( 0 != yyvsp[0] )
                DeleteDBQT( yyvsp[0] );

            yyval = 0;
            }
break;
case 239:
{
            AssertReq( yyvsp[0] );
            AssertReq( yyvsp[0]->pctNextSibling ); /* name of the view*/

            SCODE sc = S_OK;
            if ( L'#' != yyvsp[0]->pctNextSibling->value.pwszValue[0] )
                {
                if ( m_pIPSession->GetGlobalDefinition() )
                    sc = m_pIPSession->GetGlobalViewList()->DropViewDefinition( yyvsp[0]->pctNextSibling->value.pwszValue, NULL );
                else
                    {
                    m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_PARSE_ERROR );
                    m_pIPTProperties->SetErrorToken( yyvsp[0]->pctNextSibling->value.pwszValue );
                    m_pIPTProperties->SetErrorToken( L"<temporary view name>" );
                    YYABORT( DB_E_ERRORSINCOMMAND );
                    }
                }
            else
                {
                if ( 1 >= wcslen(yyvsp[0]->pctNextSibling->value.pwszValue) )
                    {
                    m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_PARSE_ERROR );
                    m_pIPTProperties->SetErrorToken( yyvsp[0]->pctNextSibling->value.pwszValue );
                    m_pIPTProperties->SetErrorToken( L"<temporary view name>" );
                    YYABORT( DB_E_ERRORSINCOMMAND );
                    }
                else if ( L'#' == yyvsp[0]->pctNextSibling->value.pwszValue[1] )
                    sc = m_pIPSession->GetLocalViewList()->DropViewDefinition( yyvsp[0]->pctNextSibling->value.pwszValue,
                                                                               (yyvsp[0]->value.pdbcntnttblValue)->pwszCatalog );
                else
                    sc = m_pIPSession->GetGlobalViewList()->DropViewDefinition( yyvsp[0]->pctNextSibling->value.pwszValue,
                                                                                (yyvsp[0]->value.pdbcntnttblValue)->pwszCatalog );
                }
            if ( FAILED(sc) )
                    {
                    m_pIPTProperties->SetErrorHResult( DB_E_ERRORSINCOMMAND, MONSQL_VIEW_NOT_DEFINED );
                    m_pIPTProperties->SetErrorToken( yyvsp[0]->pctNextSibling->value.pwszValue );
                    m_pIPTProperties->SetErrorToken( (yyvsp[0]->value.pdbcntnttblValue)->pwszCatalog );
                    YYABORT( DB_E_ERRORSINCOMMAND );
                    }
            DeleteDBQT( yyvsp[0] );
            yyval = 0;
            }
break;
    }
    yyssp -= yym;
    yystate = *yyssp;
    yyvsp -= yym;
    yym = yylhs[yyn];
    if (yystate == 0 && yym == 0)
    {
#if YYDEBUG
        if (yydebug)
            printf("%sdebug: after reduction, shifting from state 0 to\
 state %d\n", YYPREFIX, YYFINAL);
#endif
        yystate = YYFINAL;
        *++yyssp = YYFINAL;
        *++yyvsp = yyval;
        if (yychar < 0)
        {
            YYAPI_VALUENAME = NULL;
            try
            {
                if ( (yychar = YYLEX(&YYAPI_VALUENAME)) < 0 ) 
                    yychar = 0;
            }
            catch (HRESULT hr)
            {
                switch(hr)
                {
                case E_OUTOFMEMORY:
                    m_pIPTProperties->SetErrorHResult(DB_E_ERRORSINCOMMAND, MONSQL_OUT_OF_MEMORY);
                    YYABORT(E_OUTOFMEMORY);
                    break;

                default:
                    YYABORT(QPARSE_E_INVALID_QUERY);
                    break;
                }
            }
#if YYDEBUG
            if (yydebug)
            {
                yys = 0;
                if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
                if (!yys) yys = "illegal-symbol";
                printf("%sdebug: state %d, reading %d (%s)\n",
                        YYPREFIX, YYFINAL, yychar, yys);
            }
#endif
        }
        if (yychar == 0) goto yyaccept;
        goto yyloop;
    }
    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)
        yystate = yytable[yyn];
    else
        yystate = yydgoto[yym];
#if YYDEBUG
    if (yydebug)
        printf("%sdebug: after reduction, shifting from state %d \
to state %d\n", YYPREFIX, *yyssp, yystate);
#endif
    if ( yyssp >= xyyss.Get() + xyyss.Count() - 1 )
    {
        int yysspLoc = (int) ( yyssp - xyyss.Get() );
        xyyss.SetSize((unsigned) ( yyssp-xyyss.Get())+2);
        yyssp = xyyss.Get() + yysspLoc;
    }
    if ( yyvsp >= xyyvs.Get() + xyyvs.Size() - 1 )
    {
        int yyvspLoc = (int) ( yyvsp - xyyvs.Get() );
        xyyvs.SetSize((unsigned) ( yyvsp-xyyvs.Get())+2);
        yyvsp = xyyvs.Get() + yyvspLoc;
    }
    *++yyssp = (short) yystate;
    *++yyvsp = yyval;
    goto yyloop;
yyabort:
    EmptyValueStack(yylval);
    return YYFATAL;
yyaccept:
    return YYSUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sqltext\mssqltab.h ===
#ifndef lint
static char yysccsid[] = "@(#)yaccpar     1.9 (Berkeley) 02/21/93";
#endif
#define YYBYACC 1
#define YYMAJOR 1
#define YYMINOR 9
#define yyclearin (yychar=(-1))
#define yyerrok (yyerrflag=0)
#define YYRECOVERING (yyerrflag!=0)
#define _OR 257
#define _AND 258
#define _NOT 259
#define _UMINUS 260
#define mHighest 261
#define _ALL 262
#define _ANY 263
#define _ARRAY 264
#define _AS 265
#define _ASC 266
#define _CAST 267
#define _COERCE 268
#define _CONTAINS 269
#define _CONTENTS 270
#define _CREATE 271
#define _DEEP_TRAVERSAL 272
#define _DESC 273
#define _DOT 274
#define _DOTDOT 275
#define _DOTDOT_SCOPE 276
#define _DOTDOTDOT 277
#define _DOTDOTDOT_SCOPE 278
#define _DROP 279
#define _EXCLUDE_SEARCH_TRAVERSAL 280
#define _FALSE 281
#define _FREETEXT 282
#define _FROM 283
#define _IS 284
#define _ISABOUT 285
#define _IS_NOT 286
#define _LIKE 287
#define _MATCHES 288
#define _NEAR 289
#define _NOT_LIKE 290
#define _NULL 291
#define _OF 292
#define _ORDER_BY 293
#define _PASSTHROUGH 294
#define _PROPERTYNAME 295
#define _PROPID 296
#define _RANKMETHOD 297
#define _SELECT 298
#define _SET 299
#define _SCOPE 300
#define _SHALLOW_TRAVERSAL 301
#define _FORMSOF 302
#define _SOME 303
#define _TABLE 304
#define _TRUE 305
#define _TYPE 306
#define _UNION 307
#define _UNKNOWN 308
#define _URL 309
#define _VIEW 310
#define _WHERE 311
#define _WEIGHT 312
#define _GE 313
#define _LE 314
#define _NE 315
#define _CONST 316
#define _ID 317
#define _TEMPVIEW 318
#define _INTNUM 319
#define _REALNUM 320
#define _SCALAR_FUNCTION_REF 321
#define _STRING 322
#define _DATE 323
#define _PREFIX_STRING 324
#define _DELIMITED_ID 325
#ifdef YYSTACKSIZE
#undef YYMAXDEPTH
#define YYMAXDEPTH YYSTACKSIZE
#else
#ifdef YYMAXDEPTH
#define YYSTACKSIZE YYMAXDEPTH
#else
#define YYSTACKSIZE 500
#define YYMAXDEPTH 500
#endif
#endif
#define INITSTACKSIZE 30
class YYPARSER : public CYYBase
{
    friend class YYLEXER;
public:

    YYPARSER(CImpIParserSession* pParserSession, CImpIParserTreeProperties* pParserTreeProperties, YYLEXER & yylex);

    ~YYPARSER() {}

    void ResetParser();             // Use to possibly restart parser
    int  Parse();

#ifdef YYAPI_VALUETYPE
    YYAPI_VALUETYPE GetParseTree()      // Get result of parse
                    {
                        return yyval;
                    }
#endif

    void EmptyValueStack( YYAPI_VALUETYPE yylval );
    void PopVs();

private:

    int yydebug;
    int yynerrs;
    int yyerrflag;
    int yychar;
    short *yyssp;
    YYSTYPE *yyvsp;
    YYSTYPE yyval;
    YYSTYPE yylval;
    XGrowable<short, INITSTACKSIZE> xyyss;
    CDynArrayInPlace<YYSTYPE> xyyvs;
};
#define yystacksize YYSTACKSIZE
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sqltext\ptprops.h ===
//----------------------------------------------------------------------------
// Microsoft OLE DB Implementation For Index Server
// (C) Copyright 1997 By Microsoft Corporation.
//
// @doc
//
// @module PTPROPS.H | 
//
// @rev 1 | 10-13-97 | Briants  | Created
//

// Includes ------------------------------------------------------------------
#ifndef _PTPROPS_H_
#define _PTPROPS_H_

const ULONG MAX_CCH_COLUMNNAME = 128;  // per Section 3.1 of spec
const ULONG CCH_CIRESTRICTION_INCREMENT = 128;
const ULONG CB_SCOPE_DATA_BUFFER_INC = 512;
const ULONG SCOPE_BUFFERS_INCREMENT = 5;
const ULONG UNUSED_OFFSET = (ULONG)-1;

#define MAX_ERRORS  2

class CScopeData
{
    private: //@access Private Data Members
        LONG        m_cRef;

        ULONG       m_cScope;
        ULONG       m_cMaxScope;
        ULONG*      m_rgulDepths;
        ULONG*      m_rgCatalogOffset;
        ULONG*      m_rgScopeOffset;
        ULONG*      m_rgMachineOffset;

        ULONG       m_cbData;
        ULONG       m_cbMaxData;
        BYTE*       m_rgbData;

    private: //@access Private Member Functions
        HRESULT         CacheData(LPVOID pData, ULONG cb, ULONG* pulOffset);

    public:
        CScopeData();
        ~CScopeData();

        HRESULT         FInit(LPCWSTR pcwszMachine);
        HRESULT         Reset(void);

        // Handle sharing of this object
        ULONG           AddRef(void);
        ULONG           Release(void);

        
        HRESULT         GetData(ULONG uPropId, VARIANT* pvValue, LPCWSTR pcwszCatalog = NULL);
        HRESULT         SetTemporaryMachine(LPWSTR pwszMachine, ULONG cch);
        HRESULT         SetTemporaryCatalog(LPWSTR pwszCatalog, ULONG cch);
        HRESULT         SetTemporaryScope(LPWSTR pwszScope, ULONG cch);
        HRESULT         IncrementScopeCount();


        //--------------------------------------------------------------------
        // @mfunc Stores the traversl depth used for setting scope properties
        //  in the compiler environment. 
        //
        // @rdesc none
        //
        inline void     SetTemporaryDepth( 
            ULONG   ulDepth     // @parm IN | search depth
            )
        {
            m_rgulDepths[m_cScope] = ulDepth;
        }


        //--------------------------------------------------------------------
        // @func Masks the traversal depth used for setting scope          
        //       properties in the compiler environment.  This is used
        //       to specify virtual or physical paths.
        //
        // @rdesc none
        //
        inline void     MaskTemporaryDepth(
            ULONG   ulMask      // @parm IN | search mask (virtual or physical)
            )
        {
            m_rgulDepths[m_cScope] |= ulMask;
        }
};


//  CImpIParserTreeProperties Object
class CImpIParserTreeProperties : public IParserTreeProperties 
{
    private:
        LONG        m_cRef;

        //@cmember 
        CScopeData* m_pCScopeData;

        LPWSTR      m_pwszCatalog;

        HRESULT     m_LastHR;
        UINT        m_iErrOrd;
        WCHAR*      m_pwszErrParams[MAX_ERRORS];
        ULONG       m_cErrParams;

        // Have buffer with space for max column name + 
        // a space before the column name.
        WCHAR       m_rgwchCiColumn[MAX_CCH_COLUMNNAME + 2];
        ULONG       m_cchMaxRestriction;
        ULONG       m_cchRestriction;
        LPWSTR      m_pwszRestriction;
        LPWSTR      m_pwszRestrictionAppendPtr;
        bool        m_fLeftParen;

        BOOL        m_fDesc;            // make the sort direction "sticky"
        DBTYPE      m_dbType;
        DBCOMMANDTREE*  m_pctContainsColumn;


    public: 
        // CTOR and DTOR
        CImpIParserTreeProperties();
        ~CImpIParserTreeProperties();

        HRESULT         FInit(LPCWSTR pwszCatalog, LPCWSTR pwszMachine);
        
        STDMETHODIMP    QueryInterface(
                        REFIID riid, LPVOID* ppVoid);
        STDMETHODIMP_(ULONG) Release (void);
        STDMETHODIMP_(ULONG) AddRef (void);

        STDMETHODIMP    GetProperties(
                        ULONG eParseProp, VARIANT* vParseProp);

        void            SetCiColumn(LPWSTR pwszColumn);
        HRESULT         AppendCiRestriction(LPWSTR pwsz, ULONG cch);
        HRESULT         UseCiColumn(WCHAR wch);
        HRESULT         CreateNewScopeDataObject(LPCWSTR pwszMachine);
        void            ReplaceScopeDataPtr(CScopeData* pCScopeData);

        // Inline Functions
        inline CScopeData*  GetScopeDataPtr()
            { return m_pCScopeData; }

        inline void     CiNeedLeftParen(void)
            { m_fLeftParen = true; }

        inline void     SetNumErrParams(UINT cErrParams)
            { m_cErrParams = cErrParams; }

        inline UINT     GetNumErrParams()
            { return m_cErrParams; }

        inline void     SetErrorHResult(HRESULT hr, UINT iErrOrd=0)
            {
            m_LastHR = hr;
            m_iErrOrd = iErrOrd;
            m_cErrParams = 0;
            }

        inline void     SetErrorToken(const WCHAR* pwstr)
            {
            assert(m_cErrParams < MAX_ERRORS);  // can't happen
            WCHAR * pwc = CopyString( pwstr );

            // Truncate long errors since FormatMessage will fail otherwise

            if ( wcslen( pwc ) >= (MAX_PATH-1) )
                pwc[ MAX_PATH-1] = 0;

            m_pwszErrParams[m_cErrParams++] = pwc;
            }

        inline HRESULT  GetErrorHResult()
            { return m_LastHR; }

        inline UINT     GetErrorOrdinal()
            { return m_iErrOrd; }

        inline void FreeErrorDescriptions()
            { 
                for (UINT i = 0; i < m_cErrParams; i++) 
                    delete [] m_pwszErrParams[i]; 
            }

        inline DBTYPE           GetDBType()
            { return m_dbType; }

        inline void             SetDBType(DBTYPE dbType)
            { m_dbType = dbType; }

        inline BOOL             GetSortDesc()
            { return m_fDesc; }

        inline void             SetSortDesc(BOOL fDesc)
            { m_fDesc = fDesc; }

        inline DBCOMMANDTREE*   GetContainsColumn()
            { return m_pctContainsColumn; }

        inline void             SetContainsColumn(DBCOMMANDTREE* pct)
            { m_pctContainsColumn = pct; }

};  // End of Class

#endif // _PTPROPS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sqltext\ptprops.cpp ===
//----------------------------------------------------------------------------
// Microsoft OLE DB Implementation For Index Server
// (C) Copyright 1997 By Microsoft Corporation.
//
// @doc
//
// @module PTPROPS.CPP | 
//
// @rev 1 | 10-13-97 | Briants  | Created
//

// Includes ------------------------------------------------------------------
#pragma hdrstop
#include "msidxtr.h"

// Constants and Static Struct -----------------------------------------------
#define CALC_CCH_MINUS_NULL(p1) (sizeof(p1) / sizeof(*(p1))) - 1

// Code ----------------------------------------------------------------------
// CScopeData::CScopeData ---------------------------------------------------
//
// @mfunc Constructor
//
CScopeData::CScopeData()
{
    m_cRef              = 1;
    m_cScope            = 0;
    m_cMaxScope         = 0;

    m_cbData            = 0;
    m_cbMaxData         = 0;

    m_rgbData           = NULL;
    m_rgulDepths        = NULL;
    m_rgCatalogOffset   = NULL;
    m_rgScopeOffset     = NULL;
    m_rgMachineOffset   = NULL;
}


// CScopeData::~CScopeData ---------------------------------------------------
//
// @mfunc Destructor
//
CScopeData::~CScopeData()
{
    delete m_rgulDepths;
    delete m_rgCatalogOffset;
    delete m_rgScopeOffset;
    delete m_rgMachineOffset;
    delete m_rgbData;
}

// CScopeData::Reset ---------------------------------------------------------
//
// @mfunc Reset the scope count and offsets back to initial state.
//
// @rdesc HRESULT | status of methods success / failure
//      @flags OTHER | from called methods
//
HRESULT CScopeData::Reset(void)
{
    
    // Reset the offsets to unused
    for (ULONG i = 0; i<m_cMaxScope; i++)
    {
        m_rgScopeOffset[i] = UNUSED_OFFSET;
        m_rgCatalogOffset[i] = UNUSED_OFFSET;
        m_rgMachineOffset[i] = UNUSED_OFFSET;
    }

    // Set Scope Index Back to 0
    m_cScope = 0;
    
    return S_OK;
}

// CScopeData::FInit ---------------------------------------------------------
//
// @mfunc Initialize the Constructed Object
//
// @rdesc HRESULT | status of methods success / failure
//      @flags OTHER | from called methods
//
HRESULT CScopeData::FInit
    (
    LPCWSTR pwszMachine     // @param IN | current default machine
    )
{
    HRESULT hr;
    
    // Allocate Scope buffers
    // @devnote: IncrementScopeCount() has special logic for the first 
    // allocation, thus the m_cScope will remain 0 after this call
    if( SUCCEEDED(hr = IncrementScopeCount()) )
    {
        assert( m_cScope == 0 );

        // Initialize the machine 
        hr = SetTemporaryMachine((LPWSTR)pwszMachine, CALC_CCH_MINUS_NULL(L"."));
    }

    return hr;
}


// CScopeData::AddRef ------------------------------------------
//
// @mfunc Increments a persistence count for the object
//
// @rdesc Current reference count
//
ULONG CScopeData::AddRef (void)
{
    return InterlockedIncrement( (long*) &m_cRef);
}


// CScopeData::Release -----------------------------------------
//
// @mfunc Decrements a persistence count for the object and if
// persistence count is 0, the object destroys itself.
//
// @rdesc Current reference count
//
ULONG CScopeData::Release (void)
{
    assert( m_cRef > 0 );

    ULONG cRef = InterlockedDecrement( (long *) &m_cRef );
    if( 0 == cRef )
    {
        delete this;
        return 0;
    }

    return cRef;
}


// CScopeData::GetData -------------------------------------------------------
//
// @mfunc Copies the current value of our scope data into the passed in 
//  variant
//
// @rdesc HRESULT | status of methods success / failure
//      @flags S_OK | retrieved the scope data
//      @flags E_INVALIDARG | Unknown PropId requested
//      @flags OTHER | from called methods
//
HRESULT CScopeData::GetData(
    ULONG       uPropId,    //@parm IN | id of scope data to return
    VARIANT*    pvValue,        //@parm INOUT | Variant to return data in
    LPCWSTR     pcwszCatalog
    )
{
    assert( pvValue );

    HRESULT         hr;
    ULONG           ul;
    SAFEARRAYBOUND  rgsabound[1];   
    SAFEARRAY FAR*  psa = NULL;
    rgsabound[0].lLbound = 0;
    rgsabound[0].cElements = m_cScope;

    // Make sure that we free any memory that may be held by the variant.
    VariantClear(pvValue);

    switch( uPropId )
    {
        LONG    rgIx[1];
    
        case PTPROPS_SCOPE:
        {
            // Create a 1 dim safe array of type BSTR
            psa = SafeArrayCreate(VT_BSTR, 1, rgsabound);
            if( psa )
            {
                for(ul=0; ul<m_cScope; ul++)
                {
                    rgIx[0] = ul;
                    BSTR    bstrVal = SysAllocString((LPWSTR)(m_rgbData + m_rgScopeOffset[ul]));
                    if( bstrVal )
                    {
                        hr = SafeArrayPutElement(psa, rgIx, bstrVal);
                        SysFreeString(bstrVal);
                        if( FAILED(hr) )
                            goto error_delete;
                    }
                    else
                    {
                        hr = ResultFromScode(E_OUTOFMEMORY);
                        goto error_delete;
                    }
                }
                V_VT(pvValue) = VT_BSTR | VT_ARRAY;
                V_ARRAY(pvValue) = psa;
                psa = NULL;
            }
            else
                return ResultFromScode(E_OUTOFMEMORY);
        }
            break;
        case PTPROPS_DEPTH:
        {
            // Create a 1 dim safe array of type I4
            psa = SafeArrayCreate(VT_I4, 1, rgsabound);
            if( psa )
            {
                for(ul=0; ul<m_cScope; ul++)
                {
                    rgIx[0] = ul;

                    hr = SafeArrayPutElement(psa, rgIx, (void*)&m_rgulDepths[ul]);
                    if( FAILED(hr) )
                        goto error_delete;
                }
                V_VT(pvValue) = VT_I4 | VT_ARRAY;
                V_ARRAY(pvValue) = psa;
                psa = NULL;
            }
            else
                return ResultFromScode(E_OUTOFMEMORY);
        }
            break;
        case PTPROPS_CATALOG:
        {
            assert( pcwszCatalog );
            // Create a 1 dim safe array of type BSTR
            psa = SafeArrayCreate(VT_BSTR, 1, rgsabound);
            if( psa )
            {
                for(ul=0; ul<m_cScope; ul++)
                {
                    rgIx[0] = ul;
                    BSTR    bstrVal;
                    // Check to see if the catalog value has been cached, if not
                    // 
                    if( m_rgCatalogOffset[ul] != UNUSED_OFFSET )
                    {
                        bstrVal = SysAllocString((LPWSTR)(m_rgbData + m_rgCatalogOffset[ul]));
                    }
                    else
                    {
                        bstrVal = SysAllocString(pcwszCatalog);
                    }
                    
                    if( bstrVal )
                    {
                        hr = SafeArrayPutElement(psa, rgIx, bstrVal);
                        SysFreeString(bstrVal);
                        if( FAILED(hr) )
                            goto error_delete;
                    }
                    else
                    {
                        hr = ResultFromScode(E_OUTOFMEMORY);
                        goto error_delete;
                    }
                }
                V_VT(pvValue) = VT_BSTR | VT_ARRAY;
                V_ARRAY(pvValue) = psa;
                psa = NULL;
            }
            else
                return ResultFromScode(E_OUTOFMEMORY);
        }
            break;
        case PTPROPS_MACHINE:
        {
            // Create a 1 dim safe array of type BSTR
            psa = SafeArrayCreate(VT_BSTR, 1, rgsabound);
            if( psa )
            {
                for(ul=0; ul<m_cScope; ul++)
                {
                    rgIx[0] = ul;
                    BSTR    bstrVal = SysAllocString((LPWSTR)(m_rgbData + m_rgMachineOffset[ul]));
                    if( bstrVal )
                    {
                        hr = SafeArrayPutElement(psa, rgIx, bstrVal);
                        SysFreeString(bstrVal);
                        if( FAILED(hr) )
                            goto error_delete;
                    }
                    else
                    {
                        hr = ResultFromScode(E_OUTOFMEMORY);
                        goto error_delete;
                    }
                }
                V_VT(pvValue) = VT_BSTR | VT_ARRAY;
                V_ARRAY(pvValue) = psa;
                psa = NULL;
            }
            else
                return ResultFromScode(E_OUTOFMEMORY);
        }
            break;
        default:
            return ResultFromScode(E_INVALIDARG);
            break;
    }

    hr = S_OK;

error_delete:
    if( psa )
        SafeArrayDestroy(psa);

    return hr;
}


// CScopeData::CacheData -----------------------------------------------------
//
// @mfunc Manages storing data values in our buffer
//
// @rdesc HRESULT | status of methods success / failure
//      @flags S_OK | Data value stored at returned offset.
//      @flags E_OUTOFMEMORY | Could not allocate resources.
//
HRESULT CScopeData::CacheData(
    LPVOID  pData,
    ULONG   cb,
    ULONG*  pulOffset
    )
{
    SCODE sc = S_OK;

    TRY
    {
        assert( pData && pulOffset && cb > 0 );

        // Check to see if there is room in the Data buffer, if not
        // reallocate data buffer
        if( m_cbData + cb > m_cbMaxData )
        {
            ULONG cbTempMax = m_cbMaxData + ( (cb < CB_SCOPE_DATA_BUFFER_INC) ? 
                                              (CB_SCOPE_DATA_BUFFER_INC) : 
                                              (cb + CB_SCOPE_DATA_BUFFER_INC) );

            m_rgbData = renewx( m_rgbData, m_cbMaxData, cbTempMax );
            m_cbMaxData = cbTempMax;
        }

        // copy data and terminator
        RtlCopyMemory( (m_rgbData + m_cbData), pData, cb );

        // Set the offset where the new value can be found
        *pulOffset = m_cbData;
    
        // Adjust offset to start on an 8 Byte boundary.
        assert( (m_cbData % 8) == 0 );

        // @devnote: After this calculation, m_cchData may actually be larger
        // than m_cchMaxData.  This is OK, because FindOffsetBuffer will re-alloc
        // the next time around.
        m_cbData += cb + (8 - (cb % 8));  
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    return sc;
}


// CScopeData::SetTemporaryMachine -------------------------------------------
//
// @mfunc Stores the machine name used for setting machine properties
//        in the compiler environment. 
//
// @rdesc HRESULT | status of methods success / failure
//      @flags OTHER | from called methods
//
HRESULT CScopeData::SetTemporaryMachine
    (
    LPWSTR  pwszMachine,    // @parm IN | machine to store
    ULONG   cch             // @parm IN | count of characters for new scope, exclude terminator
    )
{
    HRESULT hr;
    ULONG   ulOffset;

    assert( pwszMachine );
    assert( wcslen(pwszMachine) == cch );

    // Increment count of characters to include null terminator
    cch++;

    hr = CacheData(pwszMachine, (cch * sizeof(WCHAR)), &ulOffset);
    if( SUCCEEDED(hr) )
    {
        m_rgMachineOffset[m_cScope] = ulOffset;
    }

    return hr;
}


// CScopeData::SetTemporaryCatalog -------------------------------------------
//
// @mfunc Stores the catalog name used for setting scope properties
//       in the compiler environment. 
//
// @rdesc HRESULT | status of methods success / failure
//      @flags S_OK | Data value stored at returned offset.
//      @flags OTHER | from called methods
//
HRESULT CScopeData::SetTemporaryCatalog
    (
    LPWSTR  pwszCatalog,    // @parm IN | catalog name
    ULONG   cch
    )
{
    assert( pwszCatalog );
    assert( wcslen(pwszCatalog) == cch );

    ULONG   ulOffset;

    // Increment count of characters to include null terminator
    cch++;

    // Store the catalog value
    HRESULT hr = CacheData( pwszCatalog, (cch * sizeof(WCHAR)), &ulOffset );

    if( SUCCEEDED(hr) )
        m_rgCatalogOffset[m_cScope] = ulOffset;

    return hr;
}


// CScopeData::SetTemporaryScope ---------------------------------------------
//
// @mfunc Stores the scope name used for setting scope properties
//        in the compiler environment. 
//
// @rdesc HRESULT | status of methods success / failure
//      @flags OTHER | from called methods
//
HRESULT CScopeData::SetTemporaryScope
    (
    LPWSTR  pwszScope,  // @parm IN | scope to store
    ULONG   cch         // @parm IN | count of characters for new scope, exclude terminator
    )
{
    HRESULT hr;
    ULONG   ulOffset;

    assert( pwszScope );
    assert( wcslen(pwszScope) == cch );

    // Increment count of characters to include null terminator
    cch++;

    hr = CacheData(pwszScope, (cch * sizeof(WCHAR)), &ulOffset);
    if( SUCCEEDED(hr) )
    {
        m_rgScopeOffset[m_cScope] = ulOffset;

        // @devnote: Fixup for '/' being in the scope, Index Server requires
        // this to rewritten.
        for (WCHAR *wcsLetter = (WCHAR*)(m_rgbData + ulOffset); *wcsLetter != L'\0'; wcsLetter++)
            if (L'/' == *wcsLetter)
                *wcsLetter = L'\\'; // path names needs backslashes, not forward slashes
    }

    return hr;
}


// CScopeData::IncrementScopeCount -------------------------------------------
//
// @mfunc Increments the number of temporary scopes defined.  It also
//        copies the depth values to the next scope in case multiple
//        scopes are defined with the same traversal depth.
//
// @rdesc HRESULT | status of methods success / failure
//      @flags S_OK | Activated next scope arrays element
//      @flags E_OUTOFMEMORY | could allocate enough resources to do this.
//
HRESULT CScopeData::IncrementScopeCount()
{
    SCODE sc = S_OK;

    TRY
    {
        ULONG cCurScope = m_cScope + 1;

        // Check if re-alloc must be done.
        if( cCurScope >= m_cMaxScope )
        {
            ULONG cNewMaxScope = m_cMaxScope + SCOPE_BUFFERS_INCREMENT;

            m_rgulDepths = renewx( m_rgulDepths, m_cMaxScope, cNewMaxScope );
            m_rgScopeOffset = renewx( m_rgScopeOffset, m_cMaxScope, cNewMaxScope );
            m_rgCatalogOffset = renewx( m_rgCatalogOffset, m_cMaxScope, cNewMaxScope );
            m_rgMachineOffset = renewx( m_rgMachineOffset, m_cMaxScope, cNewMaxScope );

            // If the is the initial Allocation, then make our current scope
            // equal to 0
            if( m_cMaxScope == 0 )
                cCurScope = 0;

            // Initialize new elements
            for (ULONG i = cCurScope; i<cNewMaxScope; i++)
            {
                m_rgScopeOffset[i] = UNUSED_OFFSET;
                m_rgCatalogOffset[i] = UNUSED_OFFSET;
                m_rgMachineOffset[i] = UNUSED_OFFSET;
            }

            // Save new Max Elements.
            m_cMaxScope = cNewMaxScope;
        }

        // Transfer Depth from previous node
        if( m_rgulDepths[m_cScope] & QUERY_SHALLOW )
            m_rgulDepths[cCurScope] = QUERY_SHALLOW;
        else
            m_rgulDepths[cCurScope] = QUERY_DEEP;

        // Transfer Machine and Catalog from previous node

        m_rgCatalogOffset[cCurScope] = m_rgCatalogOffset[m_cScope];
        m_rgMachineOffset[cCurScope] = m_rgMachineOffset[m_cScope];

        // Set the current # of used scopes to our new node.
        m_cScope = cCurScope;
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    return sc;
}




//============================================================================
//=
//= CImpIParserTreeProperties
//=
//============================================================================

// CImpIParserTreeProperties::CImpIParserTreeProperties ------------------------
//
// @mfunc Constructor
//
// @rdesc None
//
CImpIParserTreeProperties::CImpIParserTreeProperties()
{
    // Reference count.
    m_cRef                      = 1;

    m_LastHR                    = S_OK;
    m_iErrOrd                   = 0;
    m_cErrParams                = 0;
    m_dbType                    = 0;
    m_fDesc                     = QUERY_SORTASCEND;
    m_pctContainsColumn         = NULL;

    m_pCScopeData               = NULL;
    m_pwszCatalog               = NULL;

    // initialize the CiRestriction data
    m_rgwchCiColumn[0]          = L' ';     // First character to a <space>
    m_rgwchCiColumn[1]          = L'\0';    // Second is Null Term
    m_cchMaxRestriction         = 0;
    m_cchRestriction            = 0;
    m_pwszRestriction           = NULL;
    m_pwszRestrictionAppendPtr  = NULL;
    m_fLeftParen                = false;
}


// CImpIParserTreeProperties::~CImpIParserTreeProperties -----------------------
//
// @mfunc Destructor
//
// @rdesc None
//
CImpIParserTreeProperties::~CImpIParserTreeProperties()
{
    FreeErrorDescriptions();

    delete [] m_pwszRestriction;
    delete [] m_pwszCatalog;

    if( 0 != m_pCScopeData )
        m_pCScopeData->Release();
}


// CImpIParserTreeProperties::FInit -------------------------------
//
// @mfunc Initialize class
//
// @rdesc HResult indicating the status of the method
//      @flag S_OK | Init'd
//
HRESULT CImpIParserTreeProperties::FInit(
    LPCWSTR pcwszCatalog,   //@parm IN | Current Catalog
    LPCWSTR pcwszMachine )  //@parm IN | Current Machine
{
    SCODE sc = S_OK;
    
    TRY
    {
        Win4Assert( 0 != pcwszCatalog );
        Win4Assert( 0 == m_pwszCatalog );

        XPtrST<WCHAR> xCatalog( CopyString(pcwszCatalog) );
        sc = CreateNewScopeDataObject( pcwszMachine );

        if (SUCCEEDED(sc) )
            m_pwszCatalog = xCatalog.Acquire();
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    return sc;
}


// CImpIParserTreeProperties::GetTreeProperties -------------------------------
//
// @mfunc Allows retrieval of properties
//
// @rdesc HResult indicating the status of the method
//      @flag S_OK | Property Value retrieved
//
STDMETHODIMP CImpIParserTreeProperties::GetProperties(
    ULONG       eParseProp,     //@parm IN | property to return value for
    VARIANT*    vParseProp      //@parm IN | Value of property
    )
{
    // Require a buffer
    assert( vParseProp );

//@TODO should we have to do this, or assume it is clean.
    VariantClear(vParseProp);

    switch( eParseProp )
    {
        case PTPROPS_SCOPE:
        case PTPROPS_DEPTH:
        case PTPROPS_MACHINE:
            return m_pCScopeData->GetData(eParseProp, vParseProp);
            break;
        case PTPROPS_CATALOG:
            return m_pCScopeData->GetData(eParseProp, vParseProp, m_pwszCatalog);
            break;
        case PTPROPS_CIRESTRICTION:
            V_BSTR(vParseProp) = SysAllocString(m_pwszRestriction);
            V_VT(vParseProp) = VT_BSTR;
            break;

        case PTPROPS_ERR_IDS:
            V_I4(vParseProp) = m_iErrOrd;
            V_VT(vParseProp) = VT_I4;            
            break;
        case PTPROPS_ERR_HR:
            V_I4(vParseProp) = m_LastHR;
            V_VT(vParseProp) = VT_I4;            
            break;          
        case PTPROPS_ERR_DISPPARAM:
        {
            HRESULT         hr = NOERROR;
            SAFEARRAYBOUND  rgsabound[1];   

            V_VT(vParseProp) = VT_BSTR | VT_ARRAY;
            V_ARRAY(vParseProp) = NULL;         

            rgsabound[0].lLbound = 0;
            rgsabound[0].cElements = m_cErrParams;

            // Create a 1 dim safe array of type BSTR
            SAFEARRAY FAR* psa = SafeArrayCreate(VT_BSTR, 1, rgsabound);
            if( psa )
            {
                LONG rgIx[1];
                for(ULONG ul=0; ul<m_cErrParams; ul++)
                {
                    rgIx[0] = ul;
                    BSTR bstrVal = SysAllocString(m_pwszErrParams[ul]);
                    if( bstrVal )
                    {
                        hr = SafeArrayPutElement(psa, rgIx, bstrVal);
                        SysFreeString(bstrVal);
                        if( FAILED(hr) )
                            break;
                    }
                    else
                    {
                        hr = ResultFromScode(E_OUTOFMEMORY);
                        break;
                    }
                }
                if( SUCCEEDED(hr) )
                    V_ARRAY(vParseProp) = psa;
                else
                    SafeArrayDestroy(psa);
            }
        }
            break;          
        default:
            return ResultFromScode(E_INVALIDARG);
            break;
    }

    return S_OK;
}


// CImpIParserTreeProperties::QueryInterface ----------------------------------
//
// @mfunc Returns a pointer to a specified interface. Callers use 
// QueryInterface to determine which interfaces the called object 
// supports. 
//
// @rdesc HResult indicating the status of the method
//      @flag S_OK | Interface is supported and ppvObject is set.
//      @flag E_NOINTERFACE | Interface is not supported by the object
//      @flag E_INVALIDARG | One or more arguments are invalid. 
//
STDMETHODIMP CImpIParserTreeProperties::QueryInterface
    (
    REFIID riid,                //@parm IN | Interface ID of the interface being queried for. 
    LPVOID * ppv                //@parm OUT | Pointer to interface that was instantiated      
    )
{
    if( ppv == NULL )
        return ResultFromScode(E_INVALIDARG);

    if( (riid == IID_IUnknown) ||
        (riid == IID_IParserTreeProperties) )
        *ppv = (LPVOID)this;
    else
        *ppv = NULL;


    //  If we're going to return an interface, AddRef it first
    if( *ppv )
    {
        ((LPUNKNOWN)*ppv)->AddRef();
        return NOERROR;
    }

    return ResultFromScode(E_NOINTERFACE);
}


// CImpIParserTreeProperties::AddRef ------------------------------------------
//
// @mfunc Increments a persistence count for the object
//
// @rdesc Current reference count
//
STDMETHODIMP_(ULONG) CImpIParserTreeProperties::AddRef (void)
{
    return InterlockedIncrement( (long*) &m_cRef);
}


// CImpIParserTreeProperties::Release -----------------------------------------
//
// @mfunc Decrements a persistence count for the object and if
// persistence count is 0, the object destroys itself.
//
// @rdesc Current reference count
//
STDMETHODIMP_(ULONG) CImpIParserTreeProperties::Release (void)
{
    assert( m_cRef > 0 );

        ULONG cRef = InterlockedDecrement( (long *) &m_cRef );
    if( 0 == cRef )
    {
        delete this;
        return 0;
    }

    return cRef;
}


// CImpIParserTreeProperties::SetCiColumn -------------------------------------
//
// @mfunc Store the current column name to be applied to the
// restriction later
//
// @rdesc None
//
void CImpIParserTreeProperties::SetCiColumn
    (
    LPWSTR pwszColumn   // @parm IN | column name for this portion of restriction
    )
{
    // Should alway remain a <space>
    assert( *m_rgwchCiColumn == L' ' ); 
    assert( wcslen(pwszColumn) <= MAX_CCH_COLUMNNAME );

    // Copy column name into buffer.
    wcscpy(&m_rgwchCiColumn[1], pwszColumn);
}


// CImpIParserTreeProperties::AppendCiRestriction -----------------------------
//
// @mfunc Appends the given string to the end of the contructed CiRestriction. 
//
// @rdesc HRESULT | status of methods success / failure
//      @flags S_OK
//      @flags E_OUTOFMEMORY
//
HRESULT CImpIParserTreeProperties::AppendCiRestriction
    (
    LPWSTR  pwsz,   // @parm IN | latest addition to the generated CiRestriction
    ULONG   cch     // @parm IN | count of characters for new token, exclude terminator
    )
{
    SCODE sc = S_OK;

    TRY
    {
        assert( 0 != pwsz && 0 != cch );
        assert( wcslen(pwsz) == cch );    // cch should NOT include space for terminator

        // Determine if buffer is large enough or needs to be expanded.
        if( m_cchRestriction + cch > m_cchMaxRestriction )
        {
            ULONG cchNew = m_cchRestriction + ( (cch >= CCH_CIRESTRICTION_INCREMENT) ? 
                                                (CCH_CIRESTRICTION_INCREMENT + cch) :
                                                CCH_CIRESTRICTION_INCREMENT);

            LPWSTR pwszTemp = renewx( m_pwszRestriction, m_cchMaxRestriction, cchNew );
            if ( 0 != pwszTemp )
            {
                // First allocation Processing
                if( 0 == m_cchMaxRestriction )
                {
                    *pwszTemp = L'\0';
                    m_cchRestriction = 1;
                }

                // Recalculate Append Pointer
                m_pwszRestrictionAppendPtr = pwszTemp + (m_pwszRestrictionAppendPtr - m_pwszRestriction);

                // Set member variable to new buffer.
                m_pwszRestriction = pwszTemp;

                // Set Max number of character slots
                m_cchMaxRestriction = cchNew;
            }
            else
                return E_OUTOFMEMORY;
        }

        assert( m_pwszRestriction );
        assert( *m_pwszRestrictionAppendPtr == L'\0' ); //Should always be on Null Terminator
    
        wcscpy( m_pwszRestrictionAppendPtr, pwsz );
        m_cchRestriction += cch;
        m_pwszRestrictionAppendPtr += cch;
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH
    
    return sc;
}


// CImpIParserTreeProperties::UseCiColumn -------------------------------------
//
// @mfunc Copies the current CiRestriction column name to the CiRestriction
//
// @rdesc HRESULT | status of methods success / failure
//      @flags S_OK
//      @flags OTHER | from called methods
//
HRESULT CImpIParserTreeProperties::UseCiColumn
    (
    WCHAR wch   // @parm IN | prefix for column access
    )
{
    SCODE sc = S_OK;

    // Do we have a column name stored
    if( m_rgwchCiColumn[1] != L'\0' )
    {
        m_rgwchCiColumn[0] = wch;

        sc = AppendCiRestriction( m_rgwchCiColumn, wcslen(m_rgwchCiColumn) );
        if( SUCCEEDED(sc) )
        {
            if( true == m_fLeftParen )
            {
                sc = AppendCiRestriction(L" (", CALC_CCH_MINUS_NULL(L" ("));
                m_fLeftParen = false;
            }
            else
            {
                sc = AppendCiRestriction(L" ", CALC_CCH_MINUS_NULL(L" "));
            }
        }

        m_rgwchCiColumn[0] = L' ';
    }

    return sc;
}



// CImpIParserTreeProperties::CreateNewScopeDataObject -------------------------
//
// @mfunc Creates a new ScopeData container
//
// @rdesc HRESULT | status of methods success / failure
//      @flags S_OK
//      @flags E_FAIL | FInit failed
//      @flags E_OUTOFMEMORY
//
HRESULT CImpIParserTreeProperties::CreateNewScopeDataObject
    (
    LPCWSTR pcwszMachine        // @param IN | the current default machine
    )
{
    Assert( 0 != pcwszMachine );

    SCODE sc = S_OK;

    TRY
    {
        // Allocate ScopeData container
        // @devnote: After this allocation has succeeded, all
        // deletions of this object should be done through refcounts
        XInterface<CScopeData> xpScopeData( new CScopeData() );

        sc = xpScopeData->FInit( pcwszMachine );
        if( SUCCEEDED(sc) )
        {
            if ( m_pCScopeData )
                m_pCScopeData->Release();
            m_pCScopeData = xpScopeData.Acquire();
        }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    return sc;
}
        

// CImpIParserTreeProperties::ReplaceScopeDataPtr -------------------------
//
// @mfunc Take ownership of the ScopeData
//
// @rdesc void 
//
void CImpIParserTreeProperties::ReplaceScopeDataPtr(CScopeData* pCScopeData)
{
    assert( pCScopeData );

    if( m_pCScopeData )
    {
        ULONG ulRef = m_pCScopeData->Release();
        assert( ulRef == 0 );
    }

    m_pCScopeData = pCScopeData;
    m_pCScopeData->AddRef();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sqltext\treeutil.h ===
//--------------------------------------------------------------------
// Microsoft OLE-DB Monarch
//
// Copyright 1997 Microsoft Corporation.  All Rights Reserved.
//
// @doc
//
// @module treeutil.h | 
// 
// Contains prototypes for tree manipulation utility functions for OLE-DB trees.
//
//
// @rev   0 | 04-Feb-97 | v-charca  | Created
//
#ifdef DEBUG
#include <iostream.h>
#endif

// Change a variant to from BSTR to I8 or UI8
HRESULT PropVariantChangeTypeI64(PROPVARIANT* pvarValue);

////////// OLE-DB tree manipulation prototypes /////////////
//Allocate a tree of given kind and type.
DBCOMMANDTREE * PctAllocNode(DBVALUEKIND wKind,DBCOMMANDOP op = DBOP_DEFAULT);

// Make a list of dbcommandtree nodes
//--------------------------------------------------------------------
// @func Links two DBCOMMANDTREEs together.
//
// @rdesc (inline) DBCOMMANDTREE *
//
_inline DBCOMMANDTREE * PctLink
    (
    DBCOMMANDTREE *pct1,                // @parm IN | 1st node in list
    DBCOMMANDTREE *pct2                 // @parm IN | 2nd node in list
    )
    {
    Assert(pct1 != NULL && pct2 != NULL);
    DBCOMMANDTREE* pct = pct1;
    
    while(pct->pctNextSibling != NULL) 
        pct = pct->pctNextSibling;
    pct->pctNextSibling = pct2;

    return pct1;
    }


DBCOMMANDTREE * PctCreateNode(DBCOMMANDOP op, DBVALUEKIND wKind, DBCOMMANDTREE * pctxpr, ...);
DBCOMMANDTREE * PctCreateNode(DBCOMMANDOP op, DBCOMMANDTREE * pctxpr, ...);
DBCOMMANDTREE * PctReverse(DBCOMMANDTREE * pct);

// Count the number of siblings of a node
UINT GetNumberOfSiblings(DBCOMMANDTREE *pct);

// Delete tree
void DeleteDBQT(DBCOMMANDTREE * pct);

// Copy a tree.
HRESULT HrQeTreeCopy(DBCOMMANDTREE **pctDest, const DBCOMMANDTREE *pctSrc);

void SetDepthAndInclusion( DBCOMMANDTREE* pctInfo, DBCOMMANDTREE * pctScpList );

// Defined in querylib.lib
BOOL ParseGuid( WCHAR* pwszGuid, GUID & guid );

#ifdef DEBUG
// Print a wide character string
ostream& operator <<(ostream &osOut, LPWSTR pwszName);
// Print given tree
ostream& operator <<(ostream &osOut, DBCOMMANDTREE& qe);
ostream& operator <<(ostream &osOut, GUID guid);
ostream& operator <<(ostream &osOut, DBID __RPC_FAR *pdbid);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sqltext\treeutil.cpp ===
//--------------------------------------------------------------------
// Microsoft OLE-DB Query
//
// Copyright 1997 Microsoft Corporation.  All Rights Reserved.
//
// @doc
//
// @module treeutil.cpp | 
//
//  Contains tree manipulation utility functions for both OLE-DB and QTE trees.
//
// @devnote None
//
// @rev   0 | 12-Feb-97 | v-charca      | Created
//
#pragma hdrstop
#include "msidxtr.h"


#define INDENTLINE setfill('\t') << setw(indentLevel) << "" 
#define VAL_AND_CCH_MINUS_NULL(p1) (p1), ((sizeof(p1) / sizeof(*(p1))) - 1)



//--------------------------------------------------------------------
// @func Converts a wide character string string into a LARGEINTEGER
// @rdesc Pointer to new UNICODE string

HRESULT PropVariantChangeTypeI64( 
    PROPVARIANT* pvarValue )
{
    LPWSTR pwszVal = pvarValue->bstrVal;
    ULONGLONG uhVal = 0;
    UINT iBase = 10;
    BOOL fNegative = FALSE;
    UINT uiDigitVal = 0;
    if (L'-' == *pwszVal)
    {
        fNegative = TRUE;   // remember we need to negate later
        pwszVal++;
    }
    else if (L'+' == *pwszVal)
        pwszVal++;      // a plus sign is simply noise

    if ((L'0' == pwszVal[0]) && (L'x' == pwszVal[1] || L'X' == pwszVal[1]))
    {
        iBase = 16;
        pwszVal += 2;
    }
    ULONGLONG uhMaxPartial = _UI64_MAX / iBase;

    while (*pwszVal)
    {
        if (iswdigit(*pwszVal))
            uiDigitVal = *pwszVal - L'0';
        else /* a-fA-F */
            uiDigitVal = towupper(*pwszVal) - L'A' + 10;

        if (uhVal < uhMaxPartial ||
            (uhVal == uhMaxPartial && (ULONGLONG)uiDigitVal <= _UI64_MAX % iBase))
            uhVal = uhVal * iBase + uiDigitVal;
        else  // adding this digit would cause an overflow to occur
            return DISP_E_OVERFLOW;

        pwszVal++;
    }

    
    if (fNegative)
    {
        if (uhVal > -_I64_MIN)
            return DISP_E_OVERFLOW;
        else
        {
            SysFreeString(pvarValue->bstrVal);
            pvarValue->vt = VT_I8;
            pvarValue->hVal.QuadPart = -(LONGLONG)uhVal;
        }
    }
    else
    {
        SysFreeString(pvarValue->bstrVal);
        pvarValue->vt = VT_UI8;
        pvarValue->uhVal.QuadPart = uhVal;
    }

    return S_OK;
}


#ifdef DEBUG
//--------------------------------------------------------------------
// @func ostream& | operator shift-left |
//   Dumps the given LPOLESTR string into the given ostream.
// @rdesc ostream
ostream & operator <<
    (
    ostream     &osOut,    //@parm INOUT   | ostream in which node is to be placed.
    LPWSTR      pwszName   //@parm IN      | LPWSTR string to dump.
    )
{
    UINT cLen = wcslen(pwszName);
    for (UINT i=0; i<cLen; i++)
        osOut << char(pwszName[i]);
    return osOut;
}
#endif

//--------------------------------------------------------------------
//@func Allocates and initializes an OLE-DB DBCOMMANDTREE 
//  of the given kind and op.
//
//@rdesc DBCommandTree node of the correct kind and
//  with any additional memory for the value field allocated.
//  All other fields are NULL or default values.
//
DBCOMMANDTREE * PctAllocNode(
    DBVALUEKIND wKind,  //@parm IN | kind of tree to create
    DBCOMMANDOP op )    //@parm IN 
{
    DBCOMMANDTREE* pTableNode = NULL;
    
    pTableNode = (DBCOMMANDTREE*) CoTaskMemAlloc(sizeof(DBCOMMANDTREE));
    if (NULL == pTableNode)
        return NULL;

    // Set default values
    pTableNode->op = op;
    pTableNode->wKind = (WORD)wKind;
    pTableNode->pctFirstChild = NULL;
    pTableNode->pctNextSibling = NULL;
    pTableNode->value.pvValue = NULL;
    pTableNode->hrError = S_OK;

    switch (wKind)
    {
    case DBVALUEKIND_BYGUID:
        pTableNode->value.pdbbygdValue = (DBBYGUID*) CoTaskMemAlloc(sizeof DBBYGUID);
        if (NULL == pTableNode->value.pdbbygdValue)
        {
            CoTaskMemFree(pTableNode);
            pTableNode = NULL;
        }
        break;

    case DBVALUEKIND_COLDESC:
        pTableNode->value.pcoldescValue = (DBCOLUMNDESC*) CoTaskMemAlloc(sizeof DBCOLUMNDESC);
        if (NULL == pTableNode->value.pcoldescValue)
        {
            CoTaskMemFree(pTableNode);
            pTableNode = NULL;
        }
        break;

    case DBVALUEKIND_ID:
        pTableNode->value.pdbidValue = (DBID*) CoTaskMemAlloc(sizeof DBID);
        if (NULL == pTableNode->value.pdbidValue)
        {
            CoTaskMemFree(pTableNode);
            pTableNode = NULL;
        }
        break;

    case DBVALUEKIND_CONTENT:
        pTableNode->value.pdbcntntValue = (DBCONTENT*) CoTaskMemAlloc(sizeof DBCONTENT);
        if (NULL == pTableNode->value.pdbcntntValue)
        {
            CoTaskMemFree(pTableNode);
            pTableNode = NULL;
        }
        break;

    case DBVALUEKIND_CONTENTSCOPE:
        pTableNode->value.pdbcntntscpValue = (DBCONTENTSCOPE*) CoTaskMemAlloc(sizeof DBCONTENTSCOPE);
        if ( NULL == pTableNode->value.pdbcntntscpValue )
        {
            CoTaskMemFree( pTableNode );
            pTableNode = NULL;
        }
        else
            RtlZeroMemory( pTableNode->value.pdbcntntscpValue, sizeof(DBCONTENTSCOPE) );
        break;

    case DBVALUEKIND_CONTENTTABLE:
        pTableNode->value.pdbcntnttblValue = (DBCONTENTTABLE*) CoTaskMemAlloc(sizeof DBCONTENTTABLE);
        if ( NULL == pTableNode->value.pdbcntnttblValue )
        {
            CoTaskMemFree( pTableNode );
            pTableNode = NULL;
        }
        else
            RtlZeroMemory( pTableNode->value.pdbcntnttblValue, sizeof(DBCONTENTTABLE) );
        break;

    case DBVALUEKIND_CONTENTVECTOR:
        pTableNode->value.pdbcntntvcValue = (DBCONTENTVECTOR*) CoTaskMemAlloc(sizeof DBCONTENTVECTOR);
        if (NULL == pTableNode->value.pdbcntntvcValue)
        {
            CoTaskMemFree(pTableNode);
            pTableNode = NULL;
        }
        break;

    case DBVALUEKIND_GROUPINFO:
        pTableNode->value.pdbgrpinfValue = (DBGROUPINFO*) CoTaskMemAlloc(sizeof DBGROUPINFO);
        if (NULL == pTableNode->value.pdbgrpinfValue)
        {
            CoTaskMemFree(pTableNode);
            pTableNode = NULL;
        }
        break;

//      case DBVALUEKIND_PARAMETER:
//      case DBVALUEKIND_PROPERTY:

    case DBVALUEKIND_SETFUNC:
        pTableNode->value.pdbstfncValue = (DBSETFUNC*) CoTaskMemAlloc(sizeof DBSETFUNC);
        if (NULL == pTableNode->value.pdbstfncValue)
        {
            CoTaskMemFree(pTableNode);
            pTableNode = NULL;
        }
        break;

    case DBVALUEKIND_SORTINFO:
        pTableNode->value.pdbsrtinfValue = (DBSORTINFO*) CoTaskMemAlloc(sizeof DBSORTINFO);
        if (NULL == pTableNode->value.pdbsrtinfValue)
        {
            CoTaskMemFree(pTableNode);
            pTableNode = NULL;
        }
        break;

    case DBVALUEKIND_TEXT:
        pTableNode->value.pdbtxtValue = (DBTEXT*) CoTaskMemAlloc(sizeof DBTEXT);
        if (NULL == pTableNode->value.pdbtxtValue)
        {
            CoTaskMemFree(pTableNode);
            pTableNode = NULL;
        }
        break;

    case DBVALUEKIND_COMMAND:
    case DBVALUEKIND_MONIKER:
    case DBVALUEKIND_ROWSET:
        break;

    case DBVALUEKIND_LIKE:
        pTableNode->value.pdblikeValue = (DBLIKE*) CoTaskMemAlloc(sizeof DBLIKE);
        if (NULL == pTableNode->value.pdblikeValue)
        {
            CoTaskMemFree(pTableNode);
            pTableNode = NULL;
        }
        break;

    case DBVALUEKIND_CONTENTPROXIMITY:
        pTableNode->value.pdbcntntproxValue = (DBCONTENTPROXIMITY*) CoTaskMemAlloc(sizeof DBCONTENTPROXIMITY);
        if (NULL == pTableNode->value.pdbcntntproxValue)
        {
            CoTaskMemFree(pTableNode);
            pTableNode = NULL;
        }
        break;

    case DBVALUEKIND_IDISPATCH:
    case DBVALUEKIND_IUNKNOWN:
    case DBVALUEKIND_EMPTY:
    case DBVALUEKIND_NULL:
    case DBVALUEKIND_I2:
    case DBVALUEKIND_I4:
    case DBVALUEKIND_R4:
    case DBVALUEKIND_R8:
    case DBVALUEKIND_CY:
    case DBVALUEKIND_DATE:
    case DBVALUEKIND_BSTR:
    case DBVALUEKIND_ERROR:
    case DBVALUEKIND_BOOL:
        break;

    case DBVALUEKIND_VARIANT:
        // NOTE:  This is really a PROPVARIANT node, but there is no DBVALUEKIND for PROPVARIANT.
        pTableNode->value.pvValue = (PROPVARIANT*) CoTaskMemAlloc(sizeof PROPVARIANT);
        if (NULL == pTableNode->value.pvValue )
        {
            CoTaskMemFree(pTableNode);
            pTableNode = NULL;
        }
        else
            PropVariantInit((PROPVARIANT*)(pTableNode->value.pvValue));
        break;  

    case DBVALUEKIND_VECTOR:
    case DBVALUEKIND_ARRAY:
    case DBVALUEKIND_BYREF:
    case DBVALUEKIND_I1:
    case DBVALUEKIND_UI1:
    case DBVALUEKIND_UI2:
    case DBVALUEKIND_UI4:
    case DBVALUEKIND_I8:
    case DBVALUEKIND_UI8:
        break;

    case DBVALUEKIND_GUID:
        pTableNode->value.pGuid = (GUID*) CoTaskMemAlloc(sizeof GUID);
        if (NULL == pTableNode->value.pGuid)
        {
            CoTaskMemFree(pTableNode);
            pTableNode = NULL;
        }
        break;

    case DBVALUEKIND_BYTES:
    case DBVALUEKIND_STR:
    case DBVALUEKIND_WSTR:
    case DBVALUEKIND_NUMERIC:
//      case DBVALUEKIND_DBDATE:
//      case DBVALUEKIND_DBTIME:
//      case DBVALUEKIND_DBTIMESTAMP:
        break;

    default:
        assert(!"PctAllocNode: illegal wKind");
        CoTaskMemFree(pTableNode);
        pTableNode = NULL;
        break;
    }

    return pTableNode;
}


//--------------------------------------------------------------------
// @func Reverses a linked list of DBCOMMANDTREE siblings. This is necessary 
//      for left recursive rule in the YACC grammar.
//
// @rdesc DBCOMMANDTREE *
//
DBCOMMANDTREE * PctReverse(
    DBCOMMANDTREE * pct )       // @parm IN | original list to be reversed
{
    DBCOMMANDTREE *pctPrev = NULL;
    DBCOMMANDTREE *pctNext = pct;

    /** NULL or 1 item list is itself **/
    if(pct == NULL || pct->pctNextSibling == NULL)  
        return pct;
    
    Assert(pct != NULL);

    while(pct != NULL)
    {
        pctNext = pctNext->pctNextSibling;
        pct->pctNextSibling = pctPrev;
        pctPrev = pct;
        pct = pctNext;
    }

    return pctPrev;
}



//--------------------------------------------------------------------
// @func Creates a DBCOMMANDTREE and tags it by the given op and sets its
//      arguments. Note that this routine is takes variable params to DBCOMMANDTREE's.  This
//      allows the YACC grammer file to use a central entry point to create a
//      parse tree complete with all its children args.
//
// @side This routine will traverse arg inputs before appending trailing args. This
//      gives the effect of appending lists to lists.
//
// @rdesc DBCOMMANDTREE *
//
// @devnote 
//  Last argument must be NULL: As end of var args is detected with NULL.
//
DBCOMMANDTREE *PctCreateNode(
    DBCOMMANDOP op,                 // @parm IN | op tag for new node
    DBVALUEKIND wKind,              //@parm IN | kind to node to allocate
    DBCOMMANDTREE * pctArg,         // @parm IN | var arg children
    ... )                            
{
    HRESULT hr = S_OK;
    DBCOMMANDTREE * pctRoot = NULL;
    DBCOMMANDTREE * pctCurArg = NULL;
    USHORT cNode = 0;
    va_list pArg;

    if (pctArg != NULL)
    {
        va_start(pArg, pctArg);     // start var arg list

        /** create arg list by chaining all input node togther **/
        pctCurArg = pctArg;
        while(TRUE)
        {

            /** walk to the end of the current list **/
            while (pctCurArg->pctNextSibling != NULL)
            {
                pctCurArg = pctCurArg->pctNextSibling;
                cNode++;
            }

            /** place the next arg onto the tail of the list (this might also be a list) **/
            pctCurArg->pctNextSibling = va_arg(pArg, DBCOMMANDTREE *); // get next var arg

            /** no more args to append to list**/
            if (pctCurArg->pctNextSibling == NULL)
                break;
        }

        va_end(pArg);   // destruct var arg list
    }

    /** create the node and add specifc type info **/
    if((pctRoot = PctAllocNode(wKind)) == NULL)
    { 
        hr = E_OUTOFMEMORY;
        goto CreateErr;
    }
    

    /** tag node type and set child arg list **/
    pctRoot->op = op;   
    pctRoot->pctFirstChild = pctArg;

    Assert(NULL != pctRoot);
    
    /** Success **/
    return pctRoot;

CreateErr:
    return NULL;
}

//--------------------------------------------------------------------
// @func Creates a DBCOMMANDTREE and tags it by the given op and sets its
//      arguments. Note that this routine is takes variable params to DBCOMMANDTREE's.  This
//      allows the YACC grammer file to use a central entry point to create a
//      parse tree complete with all its children args.
//
// @side This routine will traverse arg inputs before appending trailing args. This
//      gives the effect of appending lists to lists.
//
// @rdesc DBCOMMANDTREE *
//
// @devnote 
//  Last argument must be NULL: As end of var args is detected with NULL.
//
DBCOMMANDTREE *PctCreateNode(
    DBCOMMANDOP op,                 // @parm IN | op tag for new node
    DBCOMMANDTREE * pctArg,         // @parm IN | var arg children
    ... )
{
    HRESULT hr = S_OK;
    DBCOMMANDTREE * pctRoot = NULL;
    DBCOMMANDTREE * pctCurArg = NULL;
    USHORT cNode = 0;
    va_list pArg;

    if (pctArg != NULL)
    {
        va_start(pArg, pctArg);     // start var arg list

        /** create arg list by chaining all input node togther **/
        pctCurArg = pctArg;
        while(TRUE)
        {

            /** walk to the end of the current list **/
            while (pctCurArg->pctNextSibling != NULL)
            {
                pctCurArg = pctCurArg->pctNextSibling;
                cNode++;
            }

            /** place the next arg onto the tail of the list (this might also be a list) **/
            pctCurArg->pctNextSibling = va_arg(pArg, DBCOMMANDTREE *); // get next var arg

            /** no more args to append to list**/
            if (pctCurArg->pctNextSibling == NULL)
                break;
        }

        va_end(pArg);   // destruct var arg list
    }

    /** create the node and add specifc type info **/
    if((pctRoot = PctAllocNode(DBVALUEKIND_EMPTY)) == NULL)
    { 
        hr = E_OUTOFMEMORY;
        goto CreateErr;
    }
    

    /** tag node type and set child arg list **/
    pctRoot->op = op;   
    pctRoot->pctFirstChild = pctArg;

    Assert(NULL != pctRoot);
    
    /** Success **/
    return pctRoot;

CreateErr:
    return NULL;
}


//--------------------------------------------------------------------
//@func Determines the number of siblings of a given node.
//
UINT GetNumberOfSiblings(
    DBCOMMANDTREE *pct ) //@parm IN | starting node
{
    UINT cSiblings =0;
    while (pct)
    {
        cSiblings++;
        pct=pct->pctNextSibling;
    }
    return cSiblings;
}

//--------------------------------------------------------------------
//@func Recursively deletes a command tree using CoTaskMemFree
//
void DeleteDBQT(
    DBCOMMANDTREE* pTableNode )  //@parm IN | Tree to delete
{
    if ( 0 == pTableNode )
        return;

    //delete children and siblings
    if (pTableNode->pctFirstChild)
        DeleteDBQT(pTableNode->pctFirstChild);
    if (pTableNode->pctNextSibling)
        DeleteDBQT(pTableNode->pctNextSibling);

    //delete member pointers
    switch (pTableNode->wKind)
    {
    case DBVALUEKIND_BYGUID:
        CoTaskMemFree(pTableNode->value.pdbbygdValue);
        break;

    case DBVALUEKIND_COLDESC:
        CoTaskMemFree(pTableNode->value.pcoldescValue);
        break;

    case DBVALUEKIND_ID:
        switch (pTableNode->value.pdbidValue->eKind)
        {
        case DBKIND_NAME:
        case DBKIND_GUID_NAME:
            CoTaskMemFree(pTableNode->value.pdbidValue->uName.pwszName);
            break;

        case DBKIND_PGUID_PROPID:
            CoTaskMemFree(pTableNode->value.pdbidValue->uGuid.pguid);
            break;

        case DBKIND_PGUID_NAME:
            CoTaskMemFree(pTableNode->value.pdbidValue->uName.pwszName);
            CoTaskMemFree(pTableNode->value.pdbidValue->uGuid.pguid);
            break;

        case DBKIND_GUID:
        case DBKIND_GUID_PROPID:
            break;  // nothing to get rid of

        default:    // It shouldn't be anything else
            Assert(0);
        }
        CoTaskMemFree(pTableNode->value.pdbidValue);
        break;

    case DBVALUEKIND_CONTENT:
        CoTaskMemFree(pTableNode->value.pdbcntntValue->pwszPhrase);
        CoTaskMemFree(pTableNode->value.pdbcntntValue);
        break;

    case DBVALUEKIND_CONTENTSCOPE:
        CoTaskMemFree(pTableNode->value.pdbcntntscpValue->pwszElementValue);
        CoTaskMemFree(pTableNode->value.pdbcntntscpValue);
        break;

    case DBVALUEKIND_CONTENTTABLE:
        CoTaskMemFree(pTableNode->value.pdbcntnttblValue->pwszMachine);
        CoTaskMemFree(pTableNode->value.pdbcntnttblValue->pwszCatalog);
        CoTaskMemFree(pTableNode->value.pdbcntnttblValue);
        break;

    case DBVALUEKIND_CONTENTVECTOR:
        CoTaskMemFree(pTableNode->value.pdbcntntvcValue);
        break;

    case DBVALUEKIND_LIKE:
        CoTaskMemFree(pTableNode->value.pdblikeValue);
        break;

    case DBVALUEKIND_CONTENTPROXIMITY:
        CoTaskMemFree(pTableNode->value.pdbcntntproxValue);
        break;

    case DBVALUEKIND_GROUPINFO:
        CoTaskMemFree(pTableNode->value.pdbgrpinfValue);
        break;

    case DBVALUEKIND_SETFUNC:
        CoTaskMemFree(pTableNode->value.pdbstfncValue);
        break;

    case DBVALUEKIND_SORTINFO:
        CoTaskMemFree(pTableNode->value.pdbsrtinfValue);
        break;

    case DBVALUEKIND_TEXT:
        Assert(NULL != pTableNode->value.pdbtxtValue);
        Assert(NULL != pTableNode->value.pdbtxtValue->pwszText);
        CoTaskMemFree(pTableNode->value.pdbtxtValue->pwszText);
        CoTaskMemFree(pTableNode->value.pdbtxtValue);
        break;

    case DBVALUEKIND_COMMAND:
    case DBVALUEKIND_MONIKER:
    case DBVALUEKIND_ROWSET:
    case DBVALUEKIND_IDISPATCH:
    case DBVALUEKIND_IUNKNOWN:
    case DBVALUEKIND_EMPTY:
    case DBVALUEKIND_NULL:
    case DBVALUEKIND_I2:
    case DBVALUEKIND_I4:
    case DBVALUEKIND_R4:
    case DBVALUEKIND_R8:
    case DBVALUEKIND_CY:
    case DBVALUEKIND_DATE:
        break;

    case DBVALUEKIND_BSTR:
        CoTaskMemFree(pTableNode->value.pbstrValue);
        break;

    case DBVALUEKIND_ERROR:
    case DBVALUEKIND_BOOL:
        break;

    case DBVALUEKIND_VARIANT:
        {
        HRESULT hr = PropVariantClear((PROPVARIANT*)pTableNode->value.pvValue);
        if (FAILED(hr))
            Assert(0);  // UNDONE:  meaningful error message
        CoTaskMemFree(pTableNode->value.pvValue);
        }
        break;

    case DBVALUEKIND_VECTOR:
    case DBVALUEKIND_ARRAY:
    case DBVALUEKIND_BYREF:
        assert(!"DeleteDBQT Vector,array,byref not implemented");
        break;
    
    case DBVALUEKIND_I1:
    case DBVALUEKIND_UI1:
    case DBVALUEKIND_UI2:
    case DBVALUEKIND_UI4:
    case DBVALUEKIND_I8:
    case DBVALUEKIND_UI8:
        break;

    case DBVALUEKIND_GUID:
        CoTaskMemFree(pTableNode->value.pGuid);
        break;

    case DBVALUEKIND_BYTES:
        assert(!"DeleteDBQT BYTES not implemented");
        break;

    case DBVALUEKIND_WSTR:
        CoTaskMemFree(pTableNode->value.pwszValue);
        break;

    case DBVALUEKIND_NUMERIC:
        CoTaskMemFree(pTableNode->value.pdbnValue);
        break;

    default :
        Assert(FALSE);
        break;
    }
    CoTaskMemFree(pTableNode);
}

//--------------------------------------------------------------------
//@func Copies the OLE-DB tree (pTableNodeSrc) into a new tree
//@rdesc Return pointer to new tree in ppTableNodeDest
//
HRESULT HrQeTreeCopy(
    DBCOMMANDTREE **ppTableNodeDest,     // @parm OUT | destination for copy
    const DBCOMMANDTREE *pTableNodeSrc ) // @parm IN | src OLE-DB tree
{
    HRESULT hr = S_OK;

    *ppTableNodeDest = NULL;
    if (pTableNodeSrc == NULL)
        return hr;

    // Allocates the correct 
    DBCOMMANDTREE * pTableNode = PctAllocNode(pTableNodeSrc->wKind);
    if (NULL == pTableNode)
        return E_OUTOFMEMORY;

    pTableNode->op = pTableNodeSrc->op;
    pTableNode->hrError = pTableNodeSrc->hrError;
    
    
    //Now for byref data, make a copy of the data
    switch(pTableNode->wKind)
    {
    case DBVALUEKIND_ID:
        RtlCopyMemory(pTableNode->value.pdbidValue,pTableNodeSrc->value.pdbidValue,sizeof(DBID));
        switch (pTableNodeSrc->value.pdbidValue->eKind)
        {
        case DBKIND_NAME:
        case DBKIND_GUID_NAME:
            // need to create a new string
            pTableNode->value.pdbidValue->uName.pwszName =
                CoTaskStrDup(pTableNodeSrc->value.pdbidValue->uName.pwszName);
            break;
        case DBKIND_GUID:
        case DBKIND_GUID_PROPID:
            // nothing new to copy
            break;
        case DBKIND_PGUID_NAME:
            // need to create a new string
            pTableNode->value.pdbidValue->uName.pwszName =
                CoTaskStrDup(pTableNodeSrc->value.pdbidValue->uName.pwszName);
            // need to allocate and copy guid
            pTableNode->value.pdbidValue->uGuid.pguid =
                (GUID*)CoTaskMemAlloc(sizeof(GUID));
            *pTableNode->value.pdbidValue->uGuid.pguid =
                *pTableNodeSrc->value.pdbidValue->uGuid.pguid;
            break;
        case DBKIND_PGUID_PROPID:
            // need to allocate and copy guid
            pTableNode->value.pdbidValue->uGuid.pguid =
                (GUID*)CoTaskMemAlloc(sizeof(GUID));
            *pTableNode->value.pdbidValue->uGuid.pguid =
                *pTableNodeSrc->value.pdbidValue->uGuid.pguid;
            break;
        default:
            Assert(0);
        }
        break;
    case DBVALUEKIND_BYGUID:
        RtlCopyMemory(pTableNode->value.pdbbygdValue,pTableNodeSrc->value.pdbbygdValue,sizeof(DBBYGUID));
        break;
    case DBVALUEKIND_COLDESC:
        if (NULL == pTableNodeSrc->value.pcoldescValue)
            pTableNode->value.pcoldescValue = NULL;
        else
        {
            RtlCopyMemory(pTableNode->value.pcoldescValue, pTableNodeSrc->value.pcoldescValue, sizeof(DBCOLUMNDESC));

            if (NULL != pTableNodeSrc->value.pcoldescValue->dbcid.uName.pwszName)
                pTableNode->value.pcoldescValue->dbcid.uName.pwszName = CoTaskStrDup(pTableNodeSrc->value.pcoldescValue->dbcid.uName.pwszName);
            else
                pTableNode->value.pcoldescValue->dbcid.uName.pwszName = NULL;
        }
        break;
    case DBVALUEKIND_CONTENT:
        RtlCopyMemory(pTableNode->value.pdbcntntValue, pTableNodeSrc->value.pdbcntntValue, sizeof(DBCONTENT));
// UNDONE: allocate and stuff ->pwszPhrase
        break;
    case DBVALUEKIND_CONTENTSCOPE:
        (pTableNode->value.pdbcntntscpValue)->pwszElementValue = CoTaskStrDup( (pTableNodeSrc->value.pdbcntntscpValue)->pwszElementValue );
        (pTableNode->value.pdbcntntscpValue)->dwFlags = (pTableNodeSrc->value.pdbcntntscpValue)->dwFlags;
        // RtlCopyMemory(pTableNode->value.pdbcntntscpValue, pTableNodeSrc->value.pdbcntntscpValue, sizeof(DBCONTENTSCOPE));
        break;
    case DBVALUEKIND_CONTENTTABLE:
        (pTableNode->value.pdbcntnttblValue)->pwszMachine = CoTaskStrDup( (pTableNodeSrc->value.pdbcntnttblValue)->pwszMachine );
        (pTableNode->value.pdbcntnttblValue)->pwszCatalog = CoTaskStrDup( (pTableNodeSrc->value.pdbcntnttblValue)->pwszCatalog );
        // RtlCopyMemory(pTableNode->value.pdbcntnttblValue, pTableNodeSrc->value.pdbcntnttblValue, sizeof(DBCONTENTTABLE));
        break;
    case DBVALUEKIND_LIKE:
        RtlCopyMemory(pTableNode->value.pdblikeValue,pTableNodeSrc->value.pdblikeValue,sizeof(DBLIKE));
        break;
    case DBVALUEKIND_CONTENTPROXIMITY:
        RtlCopyMemory(pTableNode->value.pdbcntntproxValue, pTableNodeSrc->value.pdbcntntproxValue, sizeof(DBCONTENTPROXIMITY));
// UNDONE: allocate and stuff ->pwszPhrase
        break;
    case DBVALUEKIND_CONTENTVECTOR:
//UNDONE:           CoTaskMemFree(pTableNode->value.pdbcntntvcValue->rgulWeights);
        RtlCopyMemory(pTableNode->value.pdbcntntvcValue, pTableNodeSrc->value.pdbcntntvcValue, sizeof(DBCONTENTVECTOR));
        break;
    case DBVALUEKIND_GROUPINFO:
        RtlCopyMemory(pTableNode->value.pdbgrpinfValue,pTableNodeSrc->value.pdbgrpinfValue,sizeof(DBGROUPINFO));
        break;
    case DBVALUEKIND_SETFUNC:
        RtlCopyMemory(pTableNode->value.pdbstfncValue,pTableNodeSrc->value.pdbstfncValue,sizeof(DBSETFUNC));
        break;
    case DBVALUEKIND_SORTINFO:
        RtlCopyMemory(pTableNode->value.pdbsrtinfValue,pTableNodeSrc->value.pdbsrtinfValue,sizeof(DBSORTINFO));
        break;
    case DBVALUEKIND_TEXT:
        pTableNode->value.pdbtxtValue->guidDialect = pTableNodeSrc->value.pdbtxtValue->guidDialect;
        pTableNode->value.pdbtxtValue->pwszText = CoTaskStrDup(pTableNodeSrc->value.pdbtxtValue->pwszText);
        pTableNode->value.pdbtxtValue->ulErrorLocator = pTableNodeSrc->value.pdbtxtValue->ulErrorLocator;
        pTableNode->value.pdbtxtValue->ulTokenLength = pTableNodeSrc->value.pdbtxtValue->ulTokenLength;
        break;

    case DBVALUEKIND_BSTR:
        assert(!"HrQeTreeCopy:BSTR not implemented");
        break;

    case DBVALUEKIND_VARIANT:
        PropVariantCopy((PROPVARIANT*)pTableNode->value.pvValue,
                        (PROPVARIANT*)pTableNodeSrc->value.pvValue);
        break;
        
    case DBVALUEKIND_VECTOR:
    case DBVALUEKIND_ARRAY:
    case DBVALUEKIND_BYREF:
        assert(!"HrQeTreeCopy:Vector,Array,Byref not implemented");
        break;

    case DBVALUEKIND_GUID:
        *(pTableNode->value.pGuid) = *(pTableNodeSrc->value.pGuid);
        break;

    case DBVALUEKIND_BYTES:
        assert(!"HrQeTreeCopy:bytes not implemented");
        break;

    case DBVALUEKIND_WSTR:
        pTableNode->value.pwszValue = CoTaskStrDup(pTableNodeSrc->value.pwszValue);
        break;
        
    // Copied as part of first 8 bytes
    case DBVALUEKIND_COMMAND:
    case DBVALUEKIND_MONIKER:
    case DBVALUEKIND_ROWSET:
    case DBVALUEKIND_IDISPATCH:
    case DBVALUEKIND_IUNKNOWN:
    //NYI : rossbu (6/29/95) -- AddRef interfaces on copy
    case DBVALUEKIND_EMPTY:
    case DBVALUEKIND_NULL:
    case DBVALUEKIND_I2:
    case DBVALUEKIND_I4:
    case DBVALUEKIND_R4:
    case DBVALUEKIND_R8:
    case DBVALUEKIND_CY:
    case DBVALUEKIND_DATE:
    
    // Copied as part of first 8 bytes
    case DBVALUEKIND_ERROR:
    case DBVALUEKIND_BOOL:

    // Copied as part of first 8 bytes
    case DBVALUEKIND_I1:
    case DBVALUEKIND_UI1:
    case DBVALUEKIND_UI2:
    case DBVALUEKIND_UI4:
    case DBVALUEKIND_I8:
    case DBVALUEKIND_UI8:
        //Copy the data values
        RtlCopyMemory(&(pTableNode->value), &(pTableNodeSrc->value),(sizeof pTableNode->value));
        break;
        
    default :
        Assert(FALSE);
        break;
    }

    hr = HrQeTreeCopy(&pTableNode->pctFirstChild, pTableNodeSrc->pctFirstChild);
    if (FAILED(hr))
        return ResultFromScode(hr);

    hr = HrQeTreeCopy(&pTableNode->pctNextSibling, pTableNodeSrc->pctNextSibling);
    if (FAILED(hr))
        return ResultFromScode(hr);

    *ppTableNodeDest = pTableNode;
    return ResultFromScode(hr);
}

// ----------------------------------------------------------------------------
// 
//  Method:     SetDepthAndInclusion
//
//  Synopsis:   Walks through the list of scopes and applies the scope
//              information provided by pctInfo to each node.
//
//  Arguments:  [pctInfo]     -- a node with deep/shallow, include/exclude info 
//              [pctScpList]  -- a list of scope_list_element nodes
// 
//  History:    07-25-98    danleg          Created
//
// ----------------------------------------------------------------------------

void SetDepthAndInclusion( 
    DBCOMMANDTREE * pctInfo,
    DBCOMMANDTREE * pctScpList )
{
    Assert( 0 != pctInfo && NULL != pctScpList );

    DBCOMMANDTREE* pct = pctScpList;
    while( NULL != pct )
    {
        pct->value.pdbcntntscpValue->dwFlags |= 
            (pctInfo->value.pdbcntntscpValue->dwFlags & (SCOPE_FLAG_MASK));

        pct = pct->pctNextSibling;
    }
}

/////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////// DEBUG OUTPUT////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
#ifdef DEBUG



/* 
** DBOP to string map.  Used to dump name rather than op # in OLE-DB tree nodes 
** This map should be kept consistent with the OLE-DB op definitions since there
** is a one to one mapping.
*/
LPSTR mpoplpstr[] = {
    "DBOP_scalar_constant",
    "DBOP_DEFAULT",
    "DBOP_NULL",
    "DBOP_bookmark_name",
    "DBOP_catalog_name",
    "DBOP_column_name",
    "DBOP_schema_name",
    "DBOP_outall_name",
    "DBOP_qualifier_name",
    "DBOP_qualified_column_name",
    "DBOP_table_name",
    "DBOP_nested_table_name",
    "DBOP_nested_column_name",
    "DBOP_row",
    "DBOP_table",
    "DBOP_sort",
    "DBOP_distinct",
    "DBOP_distinct_order_preserving",
    "DBOP_alias",
    "DBOP_cross_join",
    "DBOP_union_join",
    "DBOP_inner_join",
    "DBOP_left_semi_join",
    "DBOP_right_semi_join",
    "DBOP_left_anti_semi_join",
    "DBOP_right_anti_semi_join",
    "DBOP_left_outer_join",
    "DBOP_right_outer_join",
    "DBOP_full_outer_join",
    "DBOP_natural_join",
    "DBOP_natural_left_outer_join",
    "DBOP_natural_right_outer_join",
    "DBOP_natural_full_outer_join",
    "DBOP_set_intersection",
    "DBOP_set_union",
    "DBOP_set_left_difference",
    "DBOP_set_right_difference",
    "DBOP_set_anti_difference",
    "DBOP_bag_intersection",
    "DBOP_bag_union",
    "DBOP_bag_left_difference",
    "DBOP_bag_right_difference",
    "DBOP_bag_anti_difference",
    "DBOP_division",
    "DBOP_relative_sampling",
    "DBOP_absolute_sampling",
    "DBOP_transitive_closure",
    "DBOP_recursive_union",
    "DBOP_aggregate",
    "DBOP_remote_table",
    "DBOP_select",
    "DBOP_order_preserving_select",
    "DBOP_project",
    "DBOP_project_order_preserving",
    "DBOP_top",
    "DBOP_top_percent",
    "DBOP_top_plus_ties",
    "DBOP_top_percent_plus_ties",
    "DBOP_rank",
    "DBOP_rank_ties_equally",
    "DBOP_rank_ties_equally_and_skip",
    "DBOP_navigate",
    "DBOP_nesting",
    "DBOP_unnesting",
    "DBOP_nested_apply",
    "DBOP_cross_tab",
    "DBOP_is_NULL",
    "DBOP_is_NOT_NULL",
    "DBOP_equal",
    "DBOP_not_equal",
    "DBOP_less",
    "DBOP_less_equal",
    "DBOP_greater",
    "DBOP_greater_equal",
    "DBOP_equal_all",
    "DBOP_not_equal_all",
    "DBOP_less_all",
    "DBOP_less_equal_all",
    "DBOP_greater_all",
    "DBOP_greater_equal_all",
    "DBOP_equal_any",
    "DBOP_not_equal_any",
    "DBOP_less_any",
    "DBOP_less_equal_any",
    "DBOP_greater_any",
    "DBOP_greater_equal_any",
    "DBOP_anybits",
    "DBOP_allbits",
    "DBOP_anybits_any",
    "DBOP_allbits_any",
    "DBOP_anybits_all",
    "DBOP_allbits_all",
    "DBOP_between",
    "DBOP_between_unordered",
    "DBOP_match",
    "DBOP_match_unique",
    "DBOP_match_partial",
    "DBOP_match_partial_unique",
    "DBOP_match_full",
    "DBOP_match_full_unique",
    "DBOP_scalar_parameter",
    "DBOP_scalar_function",
    "DBOP_plus",
    "DBOP_minus",
    "DBOP_times",
    "DBOP_over",
    "DBOP_div",
    "DBOP_modulo",
    "DBOP_power",
    "DBOP_like",
    "DBOP_sounds_like",
    "DBOP_like_any",
    "DBOP_like_all",
    "DBOP_is_INVALID",
    "DBOP_is_TRUE",
    "DBOP_is_FALSE",
    "DBOP_and",
    "DBOP_or",
    "DBOP_xor",
    "DBOP_equivalent",
    "DBOP_not",
    "DBOP_implies",
    "DBOP_overlaps",
    "DBOP_case_condition",
    "DBOP_case_value",
    "DBOP_nullif",
    "DBOP_cast",
    "DBOP_coalesce",
    "DBOP_position",
    "DBOP_extract",
    "DBOP_char_length",
    "DBOP_octet_length",
    "DBOP_bit_length",
    "DBOP_substring",
    "DBOP_upper",
    "DBOP_lower",
    "DBOP_trim",
    "DBOP_translate",
    "DBOP_convert",
    "DBOP_string_concat",
    "DBOP_current_date",
    "DBOP_current_time",
    "DBOP_current_timestamp",
    "DBOP_content_select",
    "DBOP_content",
    "DBOP_content_freetext",
    "DBOP_content_proximity",
    "DBOP_content_vector_or",
    "DBOP_delete",
    "DBOP_update",
    "DBOP_insert",
    "DBOP_min",
    "DBOP_max",
    "DBOP_count",
    "DBOP_sum",
    "DBOP_avg",
    "DBOP_any_sample",
    "DBOP_stddev",
    "DBOP_stddev_pop",
    "DBOP_var",
    "DBOP_var_pop",
    "DBOP_first",
    "DBOP_last",
    "DBOP_in",
    "DBOP_exists",
    "DBOP_unique",
    "DBOP_subset",
    "DBOP_proper_subset",
    "DBOP_superset",
    "DBOP_proper_superset",
    "DBOP_disjoint",
    "DBOP_pass_through",
    "DBOP_defined_by_GUID",
    "DBOP_text_command",
    "DBOP_SQL_select",
    "DBOP_prior_command_tree",
    "DBOP_add_columns",
    "DBOP_column_list_anchor",
    "DBOP_column_list_element",
    "DBOP_command_list_anchor",
    "DBOP_command_list_element",
    "DBOP_from_list_anchor",
    "DBOP_from_list_element",
    "DBOP_project_list_anchor", 
    "DBOP_project_list_element",
    "DBOP_row_list_anchor",
    "DBOP_row_list_element",
    "DBOP_scalar_list_anchor",  
    "DBOP_scalar_list_element",
    "DBOP_set_list_anchor",
    "DBOP_set_list_element",
    "DBOP_sort_list_anchor",
    "DBOP_sort_list_element",
    "DBOP_alter_character_set", 
    "DBOP_alter_collation",
    "DBOP_alter_domain",
    "DBOP_alter_index",
    "DBOP_alter_procedure",
    "DBOP_alter_schema",
    "DBOP_alter_table",
    "DBOP_alter_trigger",
    "DBOP_alter_view",
    "DBOP_coldef_list_anchor",
    "DBOP_coldef_list_element",
    "DBOP_create_assertion",
    "DBOP_create_character_set",
    "DBOP_create_collation",
    "DBOP_create_domain",
    "DBOP_create_index",
    "DBOP_create_procedure",
    "DBOP_create_schema",
    "DBOP_create_synonym",
    "DBOP_create_table",
    "DBOP_create_temporary_tab",
    "DBOP_create_translation",
    "DBOP_create_trigger",
    "DBOP_create_view",
    "DBOP_drop_assertion",
    "DBOP_drop_character_set",
    "DBOP_drop_collation",
    "DBOP_drop_domain",
    "DBOP_drop_index",
    "DBOP_drop_procedure",
    "DBOP_drop_schema",
    "DBOP_drop_synonym",
    "DBOP_drop_table",
    "DBOP_drop_translation",
    "DBOP_drop_trigger",
    "DBOP_drop_view",
    "DBOP_foreign_key", 
    "DBOP_grant_privileges",
    "DBOP_index_list_anchor",
    "DBOP_index_list_element",
    "DBOP_primary_key",
    "DBOP_property_list_anchor",
    "DBOP_property_list_element",
    "DBOP_referenced_table",
    "DBOP_rename_object",
    "DBOP_revoke_privileges",
    "DBOP_schema_authorization",
    "DBOP_unique_key",
    "DBOP_scope_list_anchor",
    "DBOP_scope_list_element",
    "DBOP_content_table",
    NULL,   // needed for DBOP_from_string (able to find the end of the list)
   };

int indentLevel=0;


//--------------------------------------------------------------------
// @func ostream& | operator shift-left |
//   Dumps the given GUID node into the given ostream.
// @rdesc ostream
ostream & operator <<
    (
    ostream &osOut, //@parm INOUT   | ostream in which node is to be placed.
    GUID    guid    //@parm IN      | DBID node to dump.
    )
    {
    osOut.setf(ios::hex,ios::basefield);
    osOut << guid.Data1 << "-" << guid.Data2 << "-" << guid.Data3 << "-";
    
    for (int i=0; i<8; i++)
        osOut << (unsigned int)guid.Data4[i] << " ";
    osOut.setf(ios::dec,ios::basefield);
    return osOut;
    }



//--------------------------------------------------------------------
// @func ostream& | operator shift-left |
//   Dumps the given DBID node into the given ostream.
// @rdesc ostream
ostream & operator <<
    (
    ostream             &osOut,     //@parm INOUT   | ostream in which node is to be placed.
    VARIANT __RPC_FAR   *pvarValue  //@parm IN      | DBID node to dump.
    )
    {
    switch (pvarValue->vt)
        {
        case VT_EMPTY:
            osOut << "VT_EMPTY" << endl;
            break;
                    
        case VT_NULL:
            osOut << "VT_NULL" << endl;
            break;
                    
        case VT_UI1:
            osOut << "VT_UI1 = " << pvarValue->bVal << endl;
            break;
                    
        case VT_I2:
            osOut << "VT_I2 = " << pvarValue->iVal << endl;
            break;
                    
        case VT_UI2:
            osOut << "VT_UI2 = " << pvarValue->uiVal << endl;
            break;
                    
        case VT_BOOL:
            if (VARIANT_TRUE == pvarValue->boolVal)
                osOut << "VT_BOOL = TRUE" << endl;
            else
                osOut << "VT_BOOL = FALSE" << endl;
            break;

        case VT_I4:
            osOut << "VT_I4 = " << pvarValue->lVal << endl;
            break;
                    
        case VT_UI4:
            osOut << "VT_UI4 = " << pvarValue->ulVal << endl;
            break;
                    
        case VT_I8:
            {
            WCHAR pwszI8[20];
            swprintf(pwszI8, L"%I64d", ((PROPVARIANT*)pvarValue)->hVal);
            osOut << "VT_I8 = " << pwszI8 << endl;
            }
            break;
                    
        case VT_UI8:
            {
            WCHAR pwszUI8[20];
            swprintf(pwszUI8, L"%I64u (%I64x)",
                    ((PROPVARIANT*)pvarValue)->uhVal,
                    ((PROPVARIANT*)pvarValue)->uhVal);
            osOut << "VT_UI8 = " << pwszUI8 << endl;
            }
            break;
                    
        case VT_R4:
            osOut << "VT_R4 = " << pvarValue->fltVal << endl;
            break;
                    
        case VT_R8:
            osOut << "VT_R8 = " << pvarValue->dblVal << endl;
            break;
                    
        case VT_CY:
            {
            WCHAR pwszI8[20];
            swprintf(pwszI8, L"%I64d", ((PROPVARIANT*)pvarValue)->cyVal);
            osOut << "VT_CY = " << pwszI8 << endl;
            }
            break;
                    
        case VT_DATE:
            {
            BSTR bstrVal = NULL;
            HRESULT hr = VarBstrFromDate(pvarValue->date , LOCALE_SYSTEM_DEFAULT, 0, &bstrVal);

            osOut << "VT_DATE = \"" << (LPWSTR)bstrVal << "\"" << endl;
            SysFreeString(bstrVal);
            }
            break;
                    
        case VT_CLSID:
            osOut << "VT_CLSID = " << ((PROPVARIANT*)pvarValue)->puuid << "  " 
                  << *((PROPVARIANT*)pvarValue)->puuid << endl;
            break;
                    
        case VT_BSTR:
            osOut << "VT_BSTR = \"" << pvarValue->bstrVal << "\"" << endl;
            break;
                    
        case VT_LPSTR:
            osOut << "VT_LPSTR (tagDBVARIANT) = \"" << ((PROPVARIANT*)pvarValue)->pszVal << "\"" << endl;
            break;
                    
        case VT_LPWSTR:
            osOut << "VT_LPWSTR (tagDBVARIANT) = \"" << ((PROPVARIANT*)pvarValue)->pwszVal << "\"" << endl;
            break;
                    
        case VT_FILETIME:
            {
            SYSTEMTIME systemTime;
            FileTimeToSystemTime(&(((PROPVARIANT*)pvarValue)->filetime),&systemTime);
            osOut << "VT_FILETIME  (tagPROPVARIANT)  = \"" << systemTime.wYear << "-" << 
                     systemTime.wMonth << "-" << systemTime.wDay << "  " <<
                     systemTime.wHour << ":" <<  systemTime.wMinute << ":" << 
                     systemTime.wSecond << "." << systemTime.wMilliseconds << endl;
            }
            break;

        case (VT_UI1|VT_VECTOR):
            {
            osOut << "VT_UI1|VT_VECTOR = " << ((PROPVARIANT*)pvarValue)->caub.cElems;
            for (ULONG i = 0; i<((PROPVARIANT*)pvarValue)->caub.cElems; i++)
                osOut << " " << ((PROPVARIANT*)pvarValue)->caub.pElems[i];
            osOut << endl;
            }
            break;

        case (VT_I2|VT_VECTOR):
            {
            osOut << "VT_I2|VT_VECTOR = " << ((PROPVARIANT*)pvarValue)->cai.cElems;
            for (ULONG i = 0; i<((PROPVARIANT*)pvarValue)->cai.cElems; i++)
                osOut << " " << ((PROPVARIANT*)pvarValue)->cai.pElems[i];
            osOut << endl;
            }
            break;

        case (VT_UI2|VT_VECTOR):
            {
            osOut << "VT_UI2|VT_VECTOR = " << ((PROPVARIANT*)pvarValue)->caui.cElems;
            for (ULONG i = 0; i<((PROPVARIANT*)pvarValue)->caui.cElems; i++)
                osOut << " " << ((PROPVARIANT*)pvarValue)->caui.pElems[i];
            osOut << endl;
            }
            break;

        case (VT_BOOL|VT_VECTOR):
            {
            osOut << "VT_BOOL|VT_VECTOR = " << ((PROPVARIANT*)pvarValue)->cabool.cElems;
            for (ULONG i = 0; i<((PROPVARIANT*)pvarValue)->cabool.cElems; i++)
                osOut << " " << ((PROPVARIANT*)pvarValue)->cabool.pElems[i];
            osOut << endl;
            }
            break;

        case (VT_I4|VT_VECTOR):
            {
            osOut << "VT_I4|VT_VECTOR = " << ((PROPVARIANT*)pvarValue)->cal.cElems;
            for (ULONG i = 0; i<((PROPVARIANT*)pvarValue)->cal.cElems; i++)
                osOut << " " << ((PROPVARIANT*)pvarValue)->cal.pElems[i];
            osOut << endl;
            }
            break;

        case (VT_UI4|VT_VECTOR):
            {
            osOut << "VT_UI4|VT_VECTOR = " << ((PROPVARIANT*)pvarValue)->caul.cElems;
            for (ULONG i = 0; i<((PROPVARIANT*)pvarValue)->caul.cElems; i++)
                osOut << " " << ((PROPVARIANT*)pvarValue)->caul.pElems[i];
            osOut << endl;
            }
            break;

        case (VT_R4|VT_VECTOR):
            {
            osOut << "VT_R4|VT_VECTOR = " << ((PROPVARIANT*)pvarValue)->caflt.cElems;
            for (ULONG i = 0; i<((PROPVARIANT*)pvarValue)->caflt.cElems; i++)
                osOut << " " << ((PROPVARIANT*)pvarValue)->caflt.pElems[i];
            osOut << endl;
            }
            break;

        case (VT_ERROR|VT_VECTOR):
            {
            osOut << "VT_ERROR|VT_VECTOR = " << ((PROPVARIANT*)pvarValue)->cascode.cElems;
            for (ULONG i = 0; i<((PROPVARIANT*)pvarValue)->cascode.cElems; i++)
                osOut << " " << ((PROPVARIANT*)pvarValue)->cascode.pElems[i];
            osOut << endl;
            }
            break;

        case (VT_I8|VT_VECTOR):
            {
            osOut << "VT_I8|VT_VECTOR = " << ((PROPVARIANT*)pvarValue)->cah.cElems;
//          for (ULONG i = 0; i<((PROPVARIANT*)pvarValue)->cah.cElems; i++)
//              osOut << " " << ((PROPVARIANT*)pvarValue)->cah.pElems[i];
            osOut << endl;
            }
            break;

        case (VT_UI8|VT_VECTOR):
            {
            osOut << "VT_UI8|VT_VECTOR = " << ((PROPVARIANT*)pvarValue)->cauh.cElems;
//          for (ULONG i = 0; i<((PROPVARIANT*)pvarValue)->cauh.cElems; i++)
//              osOut << " " << ((PROPVARIANT*)pvarValue)->cauh.pElems[i];
            osOut << endl;
            }
            break;

        case (VT_R8|VT_VECTOR):
            {
            osOut << "VT_R8|VT_VECTOR = " << ((PROPVARIANT*)pvarValue)->cadbl.cElems;
            for (ULONG i = 0; i<((PROPVARIANT*)pvarValue)->cadbl.cElems; i++)
                osOut << " " << ((PROPVARIANT*)pvarValue)->cadbl.pElems[i];
            osOut << endl;
            }
            break;

        case (VT_CY|VT_VECTOR):
            {
            osOut << "VT_CY|VT_VECTOR = " << ((PROPVARIANT*)pvarValue)->cacy.cElems;
//          for (ULONG i = 0; i<((PROPVARIANT*)pvarValue)->cacy.cElems; i++)
//              osOut << " " << ((PROPVARIANT*)pvarValue)->cacy.pElems[i];
            osOut << endl;
            }
            break;

        case (VT_DATE|VT_VECTOR):
            {
            osOut << "VT_DATE|VT_VECTOR = " << ((PROPVARIANT*)pvarValue)->cadate.cElems;
            for (ULONG i = 0; i<((PROPVARIANT*)pvarValue)->cadate.cElems; i++)
                osOut << " " << ((PROPVARIANT*)pvarValue)->cadate.pElems[i];
            osOut << endl;
            }
            break;

        case (VT_FILETIME|VT_VECTOR):
            {
            osOut << "VT_FILETIME|VT_VECTOR = " << ((PROPVARIANT*)pvarValue)->cafiletime.cElems;
//          for (ULONG i = 0; i<((PROPVARIANT*)pvarValue)->cafiletime.cElems; i++)
//              osOut << " " << ((PROPVARIANT*)pvarValue)->cafiletime.pElems[i];
            osOut << endl;
            }
            break;

        case (VT_CLSID|VT_VECTOR):
            {
            osOut << "VT_CLSID|VT_VECTOR = " << ((PROPVARIANT*)pvarValue)->cauuid.cElems;
            for (ULONG i = 0; i<((PROPVARIANT*)pvarValue)->cauuid.cElems; i++)
                osOut << " " << ((PROPVARIANT*)pvarValue)->cauuid.pElems[i];
            osOut << endl;
            }
            break;

        case (VT_CF|VT_VECTOR):
            {
            osOut << "VT_CF|VT_VECTOR = " << ((PROPVARIANT*)pvarValue)->caclipdata.cElems;
//          for (ULONG i = 0; i<((PROPVARIANT*)pvarValue)->caclipdata.cElems; i++)
//              osOut << " " << ((PROPVARIANT*)pvarValue)->caclipdata.pElems[i];
            osOut << endl;
            }
            break;

        case (VT_BSTR|VT_VECTOR):
            {
            osOut << "VT_BSTR|VT_VECTOR = " << ((PROPVARIANT*)pvarValue)->cabstr.cElems;
            for (ULONG i = 0; i<((PROPVARIANT*)pvarValue)->cabstr.cElems; i++)
                osOut << " " << ((PROPVARIANT*)pvarValue)->cabstr.pElems[i];
            osOut << endl;
            }
            break;

        case (VT_LPSTR|VT_VECTOR):
            {
            osOut << "VT_LPSTR|VT_VECTOR = " << ((PROPVARIANT*)pvarValue)->calpstr.cElems;
            for (ULONG i = 0; i<((PROPVARIANT*)pvarValue)->calpstr.cElems; i++)
                osOut << " " << ((PROPVARIANT*)pvarValue)->calpstr.pElems[i];
            osOut << endl;
            }
            break;

        case (VT_LPWSTR|VT_VECTOR):
            {
            osOut << "VT_LPWSTR|VT_VECTOR = " << ((PROPVARIANT*)pvarValue)->calpwstr.cElems;
            for (ULONG i = 0; i<((PROPVARIANT*)pvarValue)->calpwstr.cElems; i++)
                osOut << " " << ((PROPVARIANT*)pvarValue)->calpwstr.pElems[i];
            osOut << endl;
            }
            break;

        case (VT_VARIANT|VT_VECTOR):
            {
            osOut << "VT_VARIANT|VT_VECTOR = " << ((PROPVARIANT*)pvarValue)->capropvar.cElems;
//          for (ULONG i = 0; i<((PROPVARIANT*)pvarValue)->capropvar.cElems; i++)
//              osOut << " " << ((PROPVARIANT*)pvarValue)->capropvar.pElems[i];
            osOut << endl;
            }
            break;

        default:
            osOut << "type :" << pvarValue->vt << endl;
            break;
        }
    return osOut;
    }


//--------------------------------------------------------------------
// @func ostream& | operator shift-left |
//   Dumps the given DBID node into the given ostream.
// @rdesc ostream
ostream & operator <<
    (
    ostream         &osOut, //@parm INOUT   | ostream in which node is to be placed.
    DBID __RPC_FAR *pdbid   //@parm IN      | DBID node to dump.
    )
    {
    osOut << endl;
    switch (pdbid->eKind)
        {
        case DBKIND_NAME:
            osOut << INDENTLINE << "\t\tpwszName: " << pdbid->uName.pwszName << endl;
            break;
        case DBKIND_GUID:
            osOut << INDENTLINE << "\t\tguid: "<< pdbid->uGuid.guid << endl;
            break;
        case DBKIND_GUID_NAME:
            osOut << INDENTLINE << "\t\tguid: "<< pdbid->uGuid.guid << endl;
            osOut << INDENTLINE << "\t\tpwszName: " << pdbid->uName.pwszName << endl;
            break;
        case DBKIND_GUID_PROPID:
            osOut << INDENTLINE << "\t\tguid: "<< pdbid->uGuid.guid << endl;
            osOut << INDENTLINE << "\t\tulPropid: " << pdbid->uName.ulPropid << endl;
            break;
        case DBKIND_PGUID_NAME:
            osOut << INDENTLINE << "\t\tpguid: "<< (void*)pdbid->uGuid.pguid << "  " << *pdbid->uGuid.pguid << endl;
            osOut << INDENTLINE << "\t\tpwszName: " << pdbid->uName.pwszName << endl;
            break;
        case DBKIND_PGUID_PROPID:
            osOut << INDENTLINE << "\t\tpguid: "<< (void*)pdbid->uGuid.pguid << "  " << *pdbid->uGuid.pguid << endl;
            osOut << INDENTLINE << "\t\tulPropid: " << pdbid->uName.ulPropid << endl;
            break;
        default:
            Assert(0);
        }
    return osOut;
    }



//--------------------------------------------------------------------
// @func ostream& | operator shift-left |
//   Dumps the given DBCONTENTVECTOR node into the given ostream.
// @rdesc ostream
ostream & operator <<
    (
    ostream         &osOut,                     //@parm INOUT   | ostream in which node is to be placed.
    DBCONTENTVECTOR __RPC_FAR *pdbcntntvcValue  //@parm IN      | DBCONTENTVECTOR node to dump.
    )
    {
    osOut << endl << INDENTLINE << "\t\tdwRankingMethod " << pdbcntntvcValue->dwRankingMethod;
    switch(pdbcntntvcValue->dwRankingMethod)
        {
        case VECTOR_RANK_MIN:
            osOut << " VECTOR_RANK_MIN" << endl;
            break;
        case VECTOR_RANK_MAX:
            osOut << " VECTOR_RANK_MAX" << endl;
            break;
        case VECTOR_RANK_INNER:
            osOut << " VECTOR_RANK_INNER" << endl;
            break;
        case VECTOR_RANK_DICE:
            osOut << " VECTOR_RANK_DICE" << endl;
            break;
        case VECTOR_RANK_JACCARD:
            osOut << " VECTOR_RANK_JACCARD" << endl;
            break;
        }
    osOut << endl;
    return osOut;
    }


//--------------------------------------------------------------------
//@func:(DEBUG) ostream& | operator shift-left |
//   Dumps the given DBCOMMANDTREE node into the given ostream.
//@rdesc ostream
//
ostream & operator <<
    (
    ostream &osOut, //@parm INOUT   | ostream in which node is to be placed.
    DBCOMMANDTREE &qt   //@parm IN  | OLE-DB node to dump.
    )
    {
    DBCOMMANDTREE *pTableNodeT = NULL;

    osOut << INDENTLINE << "Node" << &qt << endl;
    osOut << INDENTLINE << "{" << endl;
    osOut << INDENTLINE << "\tOP = " << mpoplpstr[qt.op] << "  // Enum value: " << (USHORT) qt.op  << endl;
//  osOut << INDENTLINE << "\tError = " << qt.hrError << endl;
    if (qt.pctFirstChild)
        osOut << INDENTLINE << "\tpctFirstChild =  " << qt.pctFirstChild << endl;
    if (qt.pctNextSibling)
        osOut << INDENTLINE << "\tpctNextSibling = " << qt.pctNextSibling << endl;

    switch(qt.wKind)
        {
        case DBVALUEKIND_BYGUID:
            osOut << INDENTLINE << "\twKind : BYGUID" << endl;
            osOut << INDENTLINE << "\tcbInfo:" << qt.value.pdbbygdValue->cbInfo << endl;
            osOut << INDENTLINE << "\tpbInfo:" << (VOID*)qt.value.pdbbygdValue->pbInfo << endl;
            osOut << INDENTLINE << "\tguid:" << qt.value.pdbbygdValue->guid << endl;
            break;

        case DBVALUEKIND_ID:
            osOut << INDENTLINE << "\twKind : ID " << qt.value.pdbidValue <<endl;
            break;

        case DBVALUEKIND_CONTENT:
            osOut << INDENTLINE << "\twKind : CONTENT " << qt.value.pdbcntntValue <<endl;
            osOut << INDENTLINE << "\t\tpwszPhrase \"" << qt.value.pdbcntntValue->pwszPhrase << "\"" << endl;
            osOut << INDENTLINE << "\t\tdwGenerateMethod " << qt.value.pdbcntntValue->dwGenerateMethod;
            switch(qt.value.pdbcntntValue->dwGenerateMethod)
                {
                    case GENERATE_METHOD_EXACT:
                        osOut << " GENERATE_METHOD_EXACT" << endl;
                        break;
                    case GENERATE_METHOD_PREFIX:
                        osOut << " GENERATE_METHOD_PREFIX" << endl;
                        break;
                    case GENERATE_METHOD_INFLECT:
                        osOut << " GENERATE_METHOD_INFLECT" << endl;
                        break;
                }
            osOut << INDENTLINE << "\t\tlWeight " << qt.value.pdbcntntValue->lWeight << endl;
            osOut << INDENTLINE << "\t\tlcid " << qt.value.pdbcntntValue->lcid << endl;
            break;

        case DBVALUEKIND_CONTENTSCOPE:
            osOut << INDENTLINE << "\tdwFlags" << endl;
            osOut << INDENTLINE << "\t\tInclude = " << (qt.value.pdbcntntscpValue->dwFlags & SCOPE_FLAG_INCLUDE) << endl;
            osOut << INDENTLINE << "\t\tDeep = " << (qt.value.pdbcntntscpValue->dwFlags & SCOPE_FLAG_DEEP) << endl;
            osOut << INDENTLINE << "\t\tType = " << (qt.value.pdbcntntscpValue->dwFlags & ~SCOPE_FLAG_MASK);
            switch (qt.value.pdbcntntscpValue->dwFlags & ~(SCOPE_FLAG_MASK) )
                {
                    case SCOPE_TYPE_WINPATH:
                        osOut << " SCOPE_TYPE_WINPATH" << endl;
                        break;
                    case SCOPE_TYPE_VPATH:
                        osOut << " SCOPE_TYPE_VPATH" << endl;
                        break;
                    default:
                        osOut << " Unknown type" << endl;
                        break;
                }
            osOut << INDENTLINE << "\tpwszElementValue = " << qt.value.pdbcntntscpValue->pwszElementValue << endl;
            break;

        case DBVALUEKIND_CONTENTTABLE:
            osOut << INDENTLINE << "\tpwszMachine = " << qt.value.pdbcntnttblValue->pwszMachine << endl;
            osOut << INDENTLINE << "\tpwszCatalog = " << qt.value.pdbcntnttblValue->pwszCatalog << endl;
            break;

        case DBVALUEKIND_LIKE:
            osOut << INDENTLINE << "\twKind : LIKE " << qt.value.pdblikeValue << endl;
            break;

        case DBVALUEKIND_CONTENTPROXIMITY:
            osOut << INDENTLINE << "\twKind : CONTENTPROXIMITY " << qt.value.pdbcntntproxValue << endl;
            osOut << INDENTLINE << "\t\tProximityUnit: " << qt.value.pdbcntntproxValue->dwProximityUnit << endl;
            osOut << INDENTLINE << "\t\tProximityDistance: " << qt.value.pdbcntntproxValue->ulProximityDistance << endl;
            osOut << INDENTLINE << "\t\tlWeight: " << qt.value.pdbcntntproxValue->lWeight << endl;
            break;
        case DBVALUEKIND_CONTENTVECTOR:
            osOut << INDENTLINE << "\twKind : CONTENTVECTOR " << qt.value.pdbcntntvcValue <<endl;
            break;

        case DBVALUEKIND_GROUPINFO:
            osOut << INDENTLINE << "\twKind : GROUPINFO" << endl;
            osOut << INDENTLINE << "\tlcid : " << (long)qt.value.pdbgrpinfValue->lcid << endl;
            break;

        case DBVALUEKIND_PROPERTY:
            osOut << "\twKind : PROPERTY" << endl;

        case DBVALUEKIND_SORTINFO:
            osOut << INDENTLINE << "\twKind : sort info" << endl;
            osOut << INDENTLINE << "\tlcid : " << (long)qt.value.pdbsrtinfValue->lcid << endl;
            osOut << INDENTLINE << "\tsort direction : ";
            if (TRUE == qt.value.pdbsrtinfValue->fDesc)
                osOut << "Desc" << endl;
            else 
                osOut << "Asc" << endl;
            break;

        case DBVALUEKIND_TEXT:
            osOut << INDENTLINE << "//\twKind : TEXT" << endl;
            osOut << INDENTLINE << "\t\t dialect guid: " << qt.value.pdbtxtValue->guidDialect << endl;
            osOut << INDENTLINE << "\t\tpwszText : " << qt.value.pdbtxtValue->pwszText << endl;
            break;

        case DBVALUEKIND_COMMAND:
        case DBVALUEKIND_MONIKER:
        case DBVALUEKIND_ROWSET:
        case DBVALUEKIND_IDISPATCH:
        case DBVALUEKIND_IUNKNOWN:
            assert(!"operator << for DBCOMMANDTREE: no COMMAND-UNKNOWN not implemented");
            break;

        case DBVALUEKIND_EMPTY:
            osOut << INDENTLINE << "\twKind = empty" << endl;
            break;
        case DBVALUEKIND_NULL:
        case DBVALUEKIND_I2:
            osOut << INDENTLINE << "\twKind = I2" << endl;
            osOut << INDENTLINE << "\t\t sValue = " << qt.value.sValue << endl;
            break;
        case DBVALUEKIND_I4:
            osOut << INDENTLINE << "\twKind = I4" << endl;
            osOut << INDENTLINE << "\t\t lValue = " << qt.value.lValue << endl;
            break;
        case DBVALUEKIND_R4:
            osOut << INDENTLINE << "\twKind = R4" << endl;
            osOut << INDENTLINE << "\t\t flValue = " << qt.value.flValue << endl;
            break;
        case DBVALUEKIND_R8:
            osOut << INDENTLINE << "\twKind = R8" << endl;
            osOut << INDENTLINE << "\t\t dblValue = " << qt.value.dblValue << endl;
            break;
        case DBVALUEKIND_CY:
            osOut << INDENTLINE << "\twKind = CY" << endl;
            assert(!"Printing Currency values not implemented");
//          osOut << "\t\t cyValue = " << qt.value.cyValue << endl;
            break;
        case DBVALUEKIND_DATE:
            osOut << INDENTLINE << "\twKind = DATE" << endl;
            osOut << INDENTLINE << "\t\t dateValue = " << qt.value.dateValue << endl;
            break;
        case DBVALUEKIND_BSTR:
            osOut << INDENTLINE << "\twKind = BSTR" << endl;
            osOut << INDENTLINE << "\t\t pbstrValue = " << qt.value.pbstrValue << endl;
            break;
        case DBVALUEKIND_ERROR:
            osOut << INDENTLINE << "\twKind = ERROR" << endl;
            osOut << INDENTLINE << "\t\t scodeValue = " << qt.value.scodeValue << endl;
            break;
        case DBVALUEKIND_BOOL:
            osOut << INDENTLINE << "\twKind = BOOL" << endl;
            osOut << INDENTLINE << "\t\t fValue = " << qt.value.fValue << endl;
            break;
        case DBVALUEKIND_VARIANT:
            osOut << INDENTLINE << "\twKind : VARIANT " << qt.value.pvarValue << endl;
            break;
        case DBVALUEKIND_VECTOR:
            osOut << INDENTLINE << "\twKind = VECTOR" << endl;
            osOut << INDENTLINE << "\t\t pdbvectorValue = " << qt.value.pdbvectorValue << endl;
            break;
        case DBVALUEKIND_ARRAY:
            osOut << INDENTLINE << "\twKind = ARRAY" << endl;
            osOut << "\t\t parrayValue = " << qt.value.parrayValue << endl;
            break;
        case DBVALUEKIND_BYREF:
            osOut << INDENTLINE << "\twKind = BYREF" << endl;
            osOut << INDENTLINE << "\t\t pvValue = " << qt.value.pvValue << endl;
            break;
        
        case DBVALUEKIND_I1:
            osOut << INDENTLINE << "\twKind = I1" << endl;
            osOut << INDENTLINE << "\t\t bValue = " << qt.value.schValue << endl;
            break;
        case DBVALUEKIND_UI1:
            osOut << INDENTLINE << "\twKind = UI1" << endl;
            osOut << INDENTLINE << "\t\t bValue = " << qt.value.uchValue << endl;
            break;
        case DBVALUEKIND_UI2:
            osOut << INDENTLINE << "\twKind = UI2" << endl;
            osOut << INDENTLINE << "\t\t sValue = " << qt.value.sValue << endl;
            break;
        case DBVALUEKIND_UI4:
            osOut << INDENTLINE << "\twKind = UI4" << endl;
            osOut << INDENTLINE << "\t\t ulValue = " << qt.value.ulValue << endl;
            break;
        case DBVALUEKIND_I8:
            osOut << INDENTLINE << "\twKind = I8" << endl;
            assert(!"llValue printing not supported");
            break;
        case DBVALUEKIND_UI8:
            osOut << INDENTLINE << "\twKind = UI8" << endl;
            assert(!"ullValue printing not supported");
            break;
        case DBVALUEKIND_GUID:
            osOut << INDENTLINE << "\twKind = GUID" << endl;
            osOut << INDENTLINE << "\t\t pGuid = " << qt.value.pGuid << endl;
            break;
        case DBVALUEKIND_BYTES:
            osOut << INDENTLINE << "\twKind = BYTES" << endl;
            osOut << INDENTLINE << "\t\t pbValue = " << qt.value.pbValue << endl;
            break;
        case DBVALUEKIND_WSTR:
            osOut << INDENTLINE << "\twKind = WSTR" << endl;
            osOut << INDENTLINE << "\t pwszValue = " << (void*) qt.value.pwszValue 
                    << " : " << qt.value.pwszValue << endl;
            break;
        case DBVALUEKIND_NUMERIC:
            osOut << INDENTLINE << "\twKind = NUMERIC" << endl;
            osOut << INDENTLINE << "\t\t pdbnValue = " << qt.value.pdbnValue << endl;
            break;
        default :
            osOut << INDENTLINE << "\twKind = UNKNOWN " << (UINT) qt.wKind << endl;
            assert(FALSE);
            break;
        }
    
//  short cnt;
//  for (cnt = 0, pTableNodeT = qt.pctFirstChild; pTableNodeT != NULL; pTableNodeT = pTableNodeT->pctNextSibling, cnt++)
//      {
//      osOut << INDENTLINE << "\tinput[" << cnt << "]: " << endl;
//      osOut << INDENTLINE << "\t\tchild = " << "Node" << pTableNodeT << endl;
//      }
    
    osOut << INDENTLINE << "}" << endl << endl;

    indentLevel++;
    for (pTableNodeT = qt.pctFirstChild; pTableNodeT != NULL; pTableNodeT = pTableNodeT->pctNextSibling)
        osOut << *pTableNodeT;
    indentLevel--;

    return osOut;
    }


#endif //DEBUG
/////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////// DEBUG OUTPUT////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\txtfilt\mmistrm.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       mmistrm.hxx
//
//  Contents:   Memory Mapped IStream
//
//  Classes:    CMmIStream
//
//  History:    11-Feb-97 KyleP     Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <mmistrm.hxx>

unsigned const cbMaxMappable = 1024 * 1024;

//+-------------------------------------------------------------------------
//
//  Member:     CMmIStream::CMMIStream, public
//
//  Synopsis:   Constructor
//
//  History:    11-Feb-97 KyleP     Created
//
//--------------------------------------------------------------------------

CMmIStream::CMmIStream()
        : _pStream( 0 ),
          _pBuf( 0 )
{
}

//+-------------------------------------------------------------------------
//
//  Member:     CMmIStream::~CMMIStream, public
//
//  Synopsis:   Destructor
//
//  History:    11-Feb-97 KyleP     Created
//
//--------------------------------------------------------------------------

CMmIStream::~CMmIStream()
{
    Close();
}

//+-------------------------------------------------------------------------
//
//  Member:     CMmIStream::Open, public
//
//  Synopsis:   Opens a stream
//
//  History:    11-Feb-97 KyleP     Created
//
//--------------------------------------------------------------------------

void CMmIStream::Open( IStream * pStream )
{
    Win4Assert( 0 == _pStream );
    Win4Assert( 0 == _pBuf );

    _pStream = pStream;
    _pStream->AddRef();

    //
    // Get stream stats.
    //

    SCODE sc = pStream->Stat( &_statstg, STATFLAG_NONAME );

    if ( FAILED(sc) )
    {
        THROW( CException( sc ) );
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CMmIStream::Close, public
//
//  Synopsis:   Close a stream
//
//  History:    11-Feb-97 KyleP     Created
//
//--------------------------------------------------------------------------

void CMmIStream::Close()
{
    if ( 0 != _pStream )
        _pStream->Release();

    delete [] _pBuf;

    _pStream = 0;
    _pBuf = 0;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMmIStream::MapAll, public
//
//  Synopsis:   Map all of a stream
//
//  Arguments:  [sbuf] -- Stream buffer to fill in
//
//  History:    11-Feb-97 KyleP     Created
//
//--------------------------------------------------------------------------

void CMmIStream::MapAll( CMmStreamBuf& sbuf )
{
    //
    // Only 'map' up to a reasonable size.
    //

    if ( 0 != SizeHigh() )
        THROW( CException( STATUS_SECTION_TOO_BIG ) );

    Map( sbuf, SizeLow(), 0, 0 );
}

//+-------------------------------------------------------------------------
//
//  Member:     CMmIStream::Map, public
//
//  Synopsis:   Map part of a stream
//
//  Arguments:  [sbuf]         -- Stream buffer to fill in
//              [cb]           -- Size to map
//              [offLow]       -- Offset in stream
//              [offHigh]      -- Offset in stream
//              [fMapForWrite] -- TRUE --> Writeable (invalid option here)
//
//  History:    11-Feb-97 KyleP     Created
//
//--------------------------------------------------------------------------

void CMmIStream::Map ( CMmStreamBuf& sbuf,
                       ULONG cb,
                       ULONG offLow,
                       ULONG offHigh,
                       BOOL  fMapForWrite )
{
    //
    // Only 'map' up to a reasonable size.
    //

    if ( cb > cbMaxMappable )
        THROW( CException( STATUS_SECTION_TOO_BIG ) );

    //
    // Now, allocate the memory.
    //

    Win4Assert( 0 == _pBuf );
    _pBuf = new BYTE [ cb ];

    //
    // Then seek and read.
    //

    LARGE_INTEGER off = { offLow, offHigh };

    SCODE sc = _pStream->Seek( off,
                               STREAM_SEEK_SET,     // From beginning of file
                               0 );                 // Don't return new seek pointer

    if ( FAILED(sc) )
    {
        THROW( CException( sc ) );
    }

    ULONG cbRead = 0;

    sc = _pStream->Read( _pBuf, cb, &cbRead );

    if ( FAILED(sc) )
    {
        THROW( CException( sc ) );
    }

    if ( cb > cbRead )
    {
        THROW( CException( E_FAIL ) );
    }

    //
    // Finally, set up the buffer.
    //

    sbuf.SetBuf( _pBuf );
    sbuf.SetSize ( cbRead );
    sbuf.SetStream ( this );
}

//+-------------------------------------------------------------------------
//
//  Member:     CMmIStream::Unmap, public
//
//  Synopsis:   Unmap stream
//
//  Arguments:  [sbuf]         -- Stream buffer to unmap
//
//  History:    11-Feb-97 KyleP     Created
//
//--------------------------------------------------------------------------

void CMmIStream::Unmap ( CMmStreamBuf& sbuf )
{
    Win4Assert( sbuf.Get() == _pBuf );

    sbuf.SetBuf( 0 );
    sbuf.SetSize( 0 );

    delete [] _pBuf;
    _pBuf = 0;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMmIStream::Flush, public
//
//  Synopsis:   Flush stream
//
//  Arguments:  [sbuf] -- Stream buffer to flush
//              [cb]   -- # bytes to flush
//
//  History:    11-Feb-97 KyleP     Created
//
//  Notes:      Only r/o streams supported.  Flush has no meaning.
//
//--------------------------------------------------------------------------

void CMmIStream::Flush ( CMmStreamBuf& sbuf, ULONG cb, BOOL fThrowOnFailure )
{
    Win4Assert( !"Not implemented" );
    THROW( CException( E_FAIL ) );
}

//+-------------------------------------------------------------------------
//
//  Member:     CMmIStream::FlushMetaData, public
//
//  Synopsis:   Flush stream
//
//  Arguments:  [sbuf] -- Stream buffer to flush
//              [cb]   -- # bytes to flush
//
//  History:    11-Feb-97 KyleP     Created
//
//  Notes:      Only r/o streams supported.  Flush has no meaning.
//
//--------------------------------------------------------------------------

void CMmIStream::FlushMetaData( BOOL fThrowOnFailure )
{
    Win4Assert( !"Not implemented" );
    THROW( CException( E_FAIL ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sqltext\yybase.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1999.
//
//  File:       YYBase.cxx
//
//  Contents:   Custom base class for YYPARSER
//
//  History:    30-Nov-1999   KyleP       Created
//
//----------------------------------------------------------------------------

#pragma hdrstop

#include "msidxtr.h"
#include "yybase.hxx"


//+-------------------------------------------------------------------------
//
//  Member:     CYYBase::CYYBase, public
//
//  Synopsis:   Constructor
//
//  Arguments:  [pParserSession]        -- Session state
//              [pParserTreeProperties] -- Command properties
//              [yylex]                 -- Lexer
//
//  History:    30-Nov-1999   KyleP       Created
//
//--------------------------------------------------------------------------

CYYBase::CYYBase( CImpIParserSession* pParserSession,
                  CImpIParserTreeProperties* pParserTreeProperties,
                  YYLEXER & yylex )
        : m_yylex( yylex ),
          m_pIPSession( pParserSession ),
          m_pIPTProperties( pParserTreeProperties )
{
}

//+-------------------------------------------------------------------------
//
//  Member:     CYYBase::~CYYBase, public
//
//  Synopsis:   Destructor
//
//  History:    30-Nov-1999   KyleP       Created
//
//--------------------------------------------------------------------------

CYYBase::~CYYBase()
{
}

//+-------------------------------------------------------------------------
//
//  Member:     CYYBase::CoerceScalar, public
//
//  Synopsis:   Converts a scalar node to specified type.
//
//  Arguments:  [dbTypeExpected] -- Expected type
//              [ppct]           -- Node to convert
//
//  Returns:    Error if conversion not possible
//
//  History:    30-Nov-1999   KyleP       Moved from YYPARSER
//
//--------------------------------------------------------------------------

HRESULT CYYBase::CoerceScalar(
    DBTYPE                  dbTypeExpected,         // @parm IN | DBTYPE that is expected in current context
    DBCOMMANDTREE**         ppct )                    // @parm IN/OUT | scalar node
{
    Assert( VT_I8       == ((PROPVARIANT*)(*ppct)->value.pvValue)->vt ||
            VT_UI8      == ((PROPVARIANT*)(*ppct)->value.pvValue)->vt ||
            VT_R8       == ((PROPVARIANT*)(*ppct)->value.pvValue)->vt ||
            VT_BSTR     == ((PROPVARIANT*)(*ppct)->value.pvValue)->vt ||
            VT_BOOL     == ((PROPVARIANT*)(*ppct)->value.pvValue)->vt ||
            VT_FILETIME == ((PROPVARIANT*)(*ppct)->value.pvValue)->vt );

    DBTYPE dbType = dbTypeExpected & ~DBTYPE_VECTOR;

    if (DBTYPE_STR == (dbType & ~DBTYPE_BYREF))
        dbType = VT_LPSTR;
    if (DBTYPE_WSTR == (dbType & ~DBTYPE_BYREF))
        dbType = VT_LPWSTR;

    HRESULT hr = (*ppct)->hrError;
    if (S_OK != hr)
        goto error;
    if (dbType == ((PROPVARIANT*)(*ppct)->value.pvValue)->vt)
        return hr;

    switch ( ((PROPVARIANT*)(*ppct)->value.pvValue)->vt )
    {
    case VT_UI8:
       {
            ULONGLONG uhVal = ((PROPVARIANT*)(*ppct)->value.pvValue)->uhVal.QuadPart;
            switch ( dbType )
            {
            case VT_UI1:
                if (uhVal > UCHAR_MAX)
                    hr = DISP_E_TYPEMISMATCH;
                else
                {
                    ((PROPVARIANT*)(*ppct)->value.pvValue)->bVal = (UCHAR)uhVal;
                    ((PROPVARIANT*)(*ppct)->value.pvValue)->vt   = VT_UI1;
                }
                break;

            case VT_I1:
                if (uhVal > CHAR_MAX)
                    hr = DB_E_DATAOVERFLOW;
                else
                {
                    ((PROPVARIANT*)(*ppct)->value.pvValue)->cVal = (CHAR)uhVal;
                    ((PROPVARIANT*)(*ppct)->value.pvValue)->vt   = VT_I1;
                }
                break;

            case VT_UI2:
                if (uhVal > USHRT_MAX)
                    hr = DB_E_DATAOVERFLOW;
                else
                {
                    ((PROPVARIANT*)(*ppct)->value.pvValue)->uiVal = (USHORT)uhVal;
                    ((PROPVARIANT*)(*ppct)->value.pvValue)->vt    = VT_UI2;
                }
                break;

            case VT_I2:
                if (uhVal > SHRT_MAX)
                    hr = DB_E_DATAOVERFLOW;
                else
                {
                    ((PROPVARIANT*)(*ppct)->value.pvValue)->iVal = (SHORT)uhVal;
                    ((PROPVARIANT*)(*ppct)->value.pvValue)->vt   = VT_I2;
                }
                break;

            case VT_UI4:
                if (uhVal > ULONG_MAX)
                    hr = DB_E_DATAOVERFLOW;
                else
                {
                    ((PROPVARIANT*)(*ppct)->value.pvValue)->ulVal = (ULONG)uhVal;
                    ((PROPVARIANT*)(*ppct)->value.pvValue)->vt    = VT_UI4;
                }
                break;

            case VT_I4:
                if (uhVal > LONG_MAX)
                    hr = DB_E_DATAOVERFLOW;
                else
                {
                    ((PROPVARIANT*)(*ppct)->value.pvValue)->lVal = (LONG)uhVal;
                    ((PROPVARIANT*)(*ppct)->value.pvValue)->vt   = VT_I4;
                }
                break;

            case VT_I8:
                if (uhVal > _I64_MAX)
                    hr = DB_E_DATAOVERFLOW;
                else
                {
                    ((PROPVARIANT*)(*ppct)->value.pvValue)->hVal.QuadPart = (LONGLONG)uhVal;
                    ((PROPVARIANT*)(*ppct)->value.pvValue)->vt            = VT_I8;
                }
                break;

            case VT_R4:
                ((PROPVARIANT*)(*ppct)->value.pvValue)->fltVal = (float)(LONGLONG)uhVal;
                ((PROPVARIANT*)(*ppct)->value.pvValue)->vt = VT_R4;
                break;

            case VT_R8:
                ((PROPVARIANT*)(*ppct)->value.pvValue)->dblVal = (double)(LONGLONG)uhVal;
                ((PROPVARIANT*)(*ppct)->value.pvValue)->vt = VT_R8;
                break;

            default:
                hr = DB_E_CANTCONVERTVALUE;
            }
        }
        break;

    case VT_I8:
        {
            LONGLONG hVal = ((PROPVARIANT*)(*ppct)->value.pvValue)->hVal.QuadPart;
            switch ( dbType )
            {
            case VT_UI1:
            case VT_UI2:
            case VT_UI4:
            case VT_UI8:
                hr = DB_E_CANTCONVERTVALUE;
                break;

            case VT_I1:
                if (hVal < CHAR_MIN || hVal > CHAR_MAX)
                    hr = DB_E_DATAOVERFLOW;
                else
                {
                    ((PROPVARIANT*)(*ppct)->value.pvValue)->cVal = (CHAR)hVal;
                    ((PROPVARIANT*)(*ppct)->value.pvValue)->vt   = VT_I1;
                }
                break;

            case VT_I2:
                if (hVal < SHRT_MIN || hVal > SHRT_MAX)
                    hr = DB_E_DATAOVERFLOW;
                else
                {
                    ((PROPVARIANT*)(*ppct)->value.pvValue)->iVal = (SHORT)hVal;
                    ((PROPVARIANT*)(*ppct)->value.pvValue)->vt   = VT_I2;
                }
                break;

            case VT_I4:
                if (hVal < LONG_MIN || hVal > LONG_MAX)
                    hr = DB_E_DATAOVERFLOW;
                else
                {
                    ((PROPVARIANT*)(*ppct)->value.pvValue)->lVal = (LONG)hVal;
                    ((PROPVARIANT*)(*ppct)->value.pvValue)->vt   = VT_I4;
                }
                break;

            case VT_R4:
                ((PROPVARIANT*)(*ppct)->value.pvValue)->fltVal = (float)hVal;
                ((PROPVARIANT*)(*ppct)->value.pvValue)->vt = VT_R4;
                break;

            case VT_R8:
                ((PROPVARIANT*)(*ppct)->value.pvValue)->dblVal = (double)hVal;
                ((PROPVARIANT*)(*ppct)->value.pvValue)->vt = VT_R8;
                break;

            default:
                hr = DB_E_CANTCONVERTVALUE;
            }
        }
        break;

    case VT_R8:
        switch ( dbType )
        {
        case VT_R4:
            ((PROPVARIANT*)(*ppct)->value.pvValue)->fltVal =
                (float)((PROPVARIANT*)(*ppct)->value.pvValue)->dblVal;
            ((PROPVARIANT*)(*ppct)->value.pvValue)->vt = VT_R4;
            break;

        case VT_CY:
            hr = VariantChangeTypeEx( (*ppct)->value.pvarValue,  // convert in place
                                      (*ppct)->value.pvarValue,
                                      LOCALE_SYSTEM_DEFAULT,
                                      0,
                                      VT_CY );
            break;

        default:
            hr = DB_E_CANTCONVERTVALUE;
        }
        break;

    case VT_BSTR:
        switch ( dbType )
        {
        case VT_R8:
            //
            // Our syntax doesn't allow for numeric separators in other
            // locales than US English.  So, use the English US lcid for this
            // conversion.
            //
            hr = VariantChangeTypeEx((*ppct)->value.pvarValue,  // convert in place
                                (*ppct)->value.pvarValue,
                                MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
                                                   SORT_DEFAULT),
                                0,
                                VT_R8);
            break;

        case VT_LPSTR:
            {
                int cLen = WideCharToMultiByte(
                        CP_ACP,
                        0,
                        ((PROPVARIANT*)(*ppct)->value.pvValue)->bstrVal,
                        SysStringLen(((PROPVARIANT*)(*ppct)->value.pvValue)->bstrVal), // number of characters in string
                        NULL,       // address of buffer for new string
                        0,          // size of buffer
                        NULL,       // address of default for unmappable characters
                        NULL);      // address of flag set when default char. used

                LPSTR pszVal = (LPSTR) CoTaskMemAlloc(cLen+1);
                if (NULL == pszVal)
                    hr = E_OUTOFMEMORY;
                else
                {
                    cLen =  WideCharToMultiByte(
                            CP_ACP,
                            0,
                            ((PROPVARIANT*)(*ppct)->value.pvValue)->bstrVal,
                            SysStringLen(((PROPVARIANT*)(*ppct)->value.pvValue)->bstrVal), // number of characters in string
                            pszVal,     // address of buffer for new string
                            cLen+1,     // size of buffer
                            NULL,       // address of default for unmappable characters
                            NULL);      // address of flag set when default char. used
                    SysFreeString(((PROPVARIANT*)(*ppct)->value.pvValue)->bstrVal);
                    pszVal[cLen] = '\0';
                    ((PROPVARIANT*)(*ppct)->value.pvValue)->vt = VT_LPSTR;
                    ((PROPVARIANT*)(*ppct)->value.pvValue)->pszVal = pszVal;
                }
            }
            break;

        case VT_LPWSTR:
            {
                LPWSTR pwszVal = CoTaskStrDup(((PROPVARIANT*)(*ppct)->value.pvValue)->bstrVal);
                if (NULL == pwszVal)
                    hr = E_OUTOFMEMORY;
                else
                {
                    SysFreeString(((PROPVARIANT*)(*ppct)->value.pvValue)->bstrVal);
                    ((PROPVARIANT*)(*ppct)->value.pvValue)->vt = VT_LPWSTR;
                    ((PROPVARIANT*)(*ppct)->value.pvValue)->pwszVal = pwszVal;
                }
            }
            break;

        case VT_CLSID:
            {
                GUID* pGuid = (GUID*) CoTaskMemAlloc(sizeof GUID);
                if (NULL == pGuid)
                    hr = E_OUTOFMEMORY;
                else
                {
                    BOOL bRet = ParseGuid(((PROPVARIANT*)(*ppct)->value.pvValue)->bstrVal, *pGuid);
                    if ( bRet && GUID_NULL != *pGuid )
                    {
                        SysFreeString(((PROPVARIANT*)(*ppct)->value.pvValue)->bstrVal);
                        ((PROPVARIANT*)(*ppct)->value.pvValue)->vt = VT_CLSID;
                        ((PROPVARIANT*)(*ppct)->value.pvValue)->puuid = pGuid;
                    }
                    else
                    {
                        CoTaskMemFree(pGuid);
                        hr = DB_E_CANTCONVERTVALUE;
                    }
                }
            }
            break;

        case VT_FILETIME:
        case VT_DATE:
            {
                SYSTEMTIME stValue = {0, 0, 0, 0, 0, 0, 0, 0};
                // convert a string to a filetime value
                int cItems = swscanf(((PROPVARIANT*)(*ppct)->value.pvValue)->bstrVal,
                                    L"%4hd/%2hd/%2hd %2hd:%2hd:%2hd:%3hd",
                                    &stValue.wYear,
                                    &stValue.wMonth,
                                    &stValue.wDay,
                                    &stValue.wHour,
                                    &stValue.wMinute,
                                    &stValue.wSecond,
                                    &stValue.wMilliseconds);

                if (1 == cItems)
                    cItems = swscanf(((PROPVARIANT*)(*ppct)->value.pvValue)->bstrVal,
                                    L"%4hd-%2hd-%2hd %2hd:%2hd:%2hd:%3hd",
                                    &stValue.wYear,
                                    &stValue.wMonth,
                                    &stValue.wDay,
                                    &stValue.wHour,
                                    &stValue.wMinute,
                                    &stValue.wSecond,
                                    &stValue.wMilliseconds );

                if (cItems != 3 && cItems != 6 && cItems != 7)
                    hr = E_FAIL;

                //
                // Make a sensible split for Year 2000 using the user's system settings
                //

                if ( stValue.wYear < 100 )
                {
                    DWORD dwYearHigh = 0;
                    if ( 0 == GetCalendarInfo ( m_pIPSession->GetLCID(),
                                                CAL_GREGORIAN,
                                                CAL_ITWODIGITYEARMAX | CAL_RETURN_NUMBER,
                                                0,
                                                0,
                                                &dwYearHigh ) )
                    {
                        hr = HRESULT_FROM_WIN32 ( GetLastError() );
                    }

                    if ( ( dwYearHigh < 99 ) || ( dwYearHigh > 9999 ) )
                        dwYearHigh = 2029;

                    WORD wMaxDecade = (WORD) dwYearHigh % 100;
                    WORD wMaxCentury = (WORD) dwYearHigh - wMaxDecade;
                    if ( stValue.wYear <= wMaxDecade )
                        stValue.wYear += wMaxCentury;
                    else
                        stValue.wYear += ( wMaxCentury - 100 );
                }

                SysFreeString(((PROPVARIANT*)(*ppct)->value.pvValue)->bstrVal);

                int iResult = 0;
                if (VT_FILETIME == dbType)
                    iResult = SystemTimeToFileTime(&stValue, &((PROPVARIANT*)(*ppct)->value.pvValue)->filetime);
                else
                    iResult = SystemTimeToVariantTime(&stValue, &((PROPVARIANT*)(*ppct)->value.pvValue)->date);
                if (0 == iResult)
                {
                    // SystemTimeTo* conversion failed. Most likely we were given the date in a bogus format.
                    (*ppct)->hrError = DB_E_CANTCONVERTVALUE;
                    hr = DB_E_CANTCONVERTVALUE;
                }
                else
                    ((PROPVARIANT*)(*ppct)->value.pvValue)->vt = dbType;
            }
            break;

        default:
            hr = DB_E_CANTCONVERTVALUE;
        }
        break;

    case VT_FILETIME:
        switch ( dbType )
        {
        case VT_DATE:
            {
                SYSTEMTIME stValue = {0, 0, 0, 0, 0, 0, 0, 0};
                if ( FileTimeToSystemTime(&((PROPVARIANT*)(*ppct)->value.pvValue)->filetime, &stValue) )
                {
                    int iResult = SystemTimeToVariantTime(&stValue, &((PROPVARIANT*)(*ppct)->value.pvValue)->date);
                    if (0 == iResult)
                    {
                        // SystemTimeToVariantTime failed. Most likely we were given the date in a bogus format.
                        (*ppct)->hrError = DB_E_CANTCONVERTVALUE;
                        hr = DB_E_CANTCONVERTVALUE;
                    }
                    else
                        ((PROPVARIANT*)(*ppct)->value.pvValue)->vt = VT_DATE;
                }
                else
                    hr = DISP_E_TYPEMISMATCH;
            }
            break;

        default:
            hr = DB_E_CANTCONVERTVALUE;
        }
        break;

    default:
        hr = DB_E_CANTCONVERTVALUE;
        break;
    }

error:
    if (S_OK != hr)
    {
        switch ( hr )
        {
        case DB_E_DATAOVERFLOW:
            m_pIPTProperties->SetErrorHResult(hr, MONSQL_OUT_OF_RANGE);
            break;

        case E_OUTOFMEMORY:
            m_pIPTProperties->SetErrorHResult(hr, MONSQL_OUT_OF_MEMORY);
            break;

        default:
            m_pIPTProperties->SetErrorHResult(hr, MONSQL_CANNOT_CONVERT);
        }

        m_pIPTProperties->SetErrorToken((YY_CHAR*)m_yylex.YYText());

        switch ( dbType )
        {
        case DBTYPE_UI1:
            m_pIPTProperties->SetErrorToken(L"DBTYPE_UI1");
            break;

        case DBTYPE_I1:
            m_pIPTProperties->SetErrorToken(L"DBTYPE_I1");
            break;

        case DBTYPE_UI2:
            m_pIPTProperties->SetErrorToken(L"DBTYPE_UI2");
            break;

        case DBTYPE_UI4:
            m_pIPTProperties->SetErrorToken(L"DBTYPE_UI4");
            break;

        case DBTYPE_UI8:
            m_pIPTProperties->SetErrorToken(L"DBTYPE_UI8");
            break;

        case DBTYPE_I2:
            m_pIPTProperties->SetErrorToken(L"DBTYPE_I2");
            break;

        case DBTYPE_I4:
            m_pIPTProperties->SetErrorToken(L"DBTYPE_I4");
            break;

        case DBTYPE_I8:
            m_pIPTProperties->SetErrorToken(L"DBTYPE_I8");
            break;

        case DBTYPE_R4:
            m_pIPTProperties->SetErrorToken(L"DBTYPE_R4");
            break;

        case DBTYPE_R8:
            m_pIPTProperties->SetErrorToken(L"DBTYPE_R8");
            break;

        case DBTYPE_CY:
            m_pIPTProperties->SetErrorToken(L"DBTYPE_CY");
            break;

        case DBTYPE_DATE:
            m_pIPTProperties->SetErrorToken(L"DBTYPE_DATE");
            break;

        case DBTYPE_BSTR:
            m_pIPTProperties->SetErrorToken(L"DBTYPE_BSTR");
            break;

        case DBTYPE_BOOL:
            m_pIPTProperties->SetErrorToken(L"DBTYPE_BOOL");
            break;

        case DBTYPE_GUID:
            m_pIPTProperties->SetErrorToken(L"DBTYPE_GUID");
            break;

        case DBTYPE_STR:
            m_pIPTProperties->SetErrorToken(L"DBTYPE_STR");
            break;

        case DBTYPE_STR | DBTYPE_BYREF:
            m_pIPTProperties->SetErrorToken(L"DBTYPE_STR|DBTYPE_BYREF");
            break;

        case DBTYPE_WSTR:
            m_pIPTProperties->SetErrorToken(L"DBTYPE_WSTR");
            break;

        case DBTYPE_WSTR | DBTYPE_BYREF:
            m_pIPTProperties->SetErrorToken(L"DBTYPE_WSTR | DBTYPE_BYREF");
            break;

        case VT_FILETIME:
            m_pIPTProperties->SetErrorToken(L"VT_FILETIME");
            break;

        default:
            m_pIPTProperties->SetErrorToken(L"DBTYPE_NULL");
            break;
        }
    }
    return hr;
}

//+-------------------------------------------------------------------------
//
//  Member:     CYYBase::yyprimebuffer, public
//
//  Synopsis:   Prime lexer with text (passthrough to lexer)
//
//  Arguments:  [pszBuffer] -- Buffer
//
//  History:    30-Nov-1999   KyleP       Moved from YYPARSER
//
//--------------------------------------------------------------------------

void CYYBase::yyprimebuffer(YY_CHAR *pszBuffer)
{
    m_yylex.yyprimebuffer(pszBuffer);
}

//+-------------------------------------------------------------------------
//
//  Member:     CYYBase::yyprimelexer, public
//
//  Synopsis:   Prime lexer with initial token (passthrough to lexer)
//
//  Arguments:  [eToken] -- Token
//
//  History:    30-Nov-1999   KyleP       Moved from YYPARSER
//
//--------------------------------------------------------------------------

void CYYBase::yyprimelexer(int eToken)
{
    m_yylex.yyprimelexer(eToken);
}

//+-------------------------------------------------------------------------
//
//  Member:     CYYBase::yyerror, protected
//
//  Synopsis:   Report parsing errors
//
//  Arguments:  [szError] -- Error string
//
//  History:    30-Nov-1999   KyleP       Moved from YYPARSER
//
//--------------------------------------------------------------------------

void CYYBase::yyerror( char const * szError )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\sqltext\yypars.hpp ===
// Notes: The parser is embodied/encapsulated in the class YYPARSER. Given a 
// <grammar>.y the C++ YACC generates a YYPARSER object along with the needed 
// parse tables as static data members. To create a parser object is as simple 
// as creating an object of class YYPARSER. The YYPARSER code now is 
// automatically re-entrant.

#ifndef YYPARS_INCLUDED
#define YYPARS_INCLUDED


#ifdef UNICODE
#define yyitos  _itow
#else
#define yyitos  _itoa
#endif


#ifndef YYAPI_PACKAGE
# define YYAPI_TOKENNAME        yychar          //name used for return value of yylex   
# define YYAPI_TOKENTYPE        int             //type of the token
# define YYAPI_TOKENEME(t)      (t)             //the value of the token that the parser should see
# define YYAPI_TOKENNONE        -2              //the representation when there is no token
# define YYAPI_TOKENSTR(t)      (yyitos(t,yyitoa,10))       //string representation of the token
# define YYAPI_VALUENAME        yylval          //the name of the value of the token
# define YYAPI_VALUETYPE        YYSTYPE         //the type of the value of the token (if null, then the value is derivable from the token itself)
# define YYAPI_VALUEOF(v)       (v)             //how to get the value of the token
# define YYAPI_CALLAFTERYYLEX(t)                //
# define YYAPI_PACKAGE                          //package is in use
#endif  // YYAPI_PACKAGE

#ifndef YYPARSER
# define YYPARSER               yyparse
#endif
#ifndef YYLEX
# define YYLEX                  yylex
#endif
#ifndef YYPARSEPROTO
# define YYPARSEPROTO 
#endif
#ifndef YYSTYPE
# define YYSTYPE                int
#endif

#define yyerrok                 ClearErrRecoveryState()     //provided for compatibility with YACC
#define yyclearin               YYAPI_TOKENNAME = YYAPI_TOKENNONE

#ifndef YYMAXDEPTH
#define YYMAXDEPTH 150
#endif

#ifndef YYR_T
#define YYR_T   int
typedef YYR_T   yyr_t;
#endif


class CImpIParserSession;
class CImpIParserTreeProperties;

class YYPARSER {
    friend class YYLEXER;
// ctor & dtor
public: 
    YYPARSER(CImpIParserSession* pParserSession, CImpIParserTreeProperties* pParserTreeProperties);
    ~YYPARSER();

// Public interface
public:
    void ResetParser();     //use to possibly restart parser
    HRESULT Parse(YYPARSEPROTO);            //bread and butter function

// Public interface that's reluctantly provided
public:
    int NoOfErrors();                   //current count of parsing errors
    int ErrRecoveryState();             //error recovery state.
    void ClearErrRecoveryState();       //error recovery is complete. 

#ifdef YYAPI_VALUETYPE                  
    YYAPI_VALUETYPE GetParseTree()      // Get result of parse
        {
        return /*YYAPI_VALUENAME*/yyval;
        };
#endif

    YYAPI_TOKENTYPE GetCurrentToken();              //current token seen by the parser. 
    void SetCurrentToken(YYAPI_TOKENTYPE newToken); //change current token. 
    void YYPARSER::yySetBuffer(short iBuffer, YY_CHAR *szValue);
    YY_CHAR *YYPARSER::yyGetBuffer(short iBuffer);
    void yyprimebuffer(YY_CHAR *pszBuffer);
    void yyprimelexer(int eToken);
    void EmptyValueStack();
    HRESULT CoerceScalar(DBTYPE dbTypeExpected, DBCOMMANDTREE** ppct);



// private data
private:
    int yyn;
    int yychar1;        /*  lookahead token as an internal (translated) token number */
    short   yyssa[YYMAXDEPTH];  /*  the state stack         */
    YYSTYPE yyvsa[YYMAXDEPTH];  /*  the semantic value stack        */
    short *yyss;                /*  refer to the stacks thru separate pointers */
    YYSTYPE *yyvs;              /*  to allow yyoverflow to reallocate them elsewhere */
    int yystacksize;
    int yynerrs;

    YYSTYPE yyval;/*  the variable used to return       */
                /*  semantic values from the action */
                /*  routines                */
    int yylen;


    YYAPI_TOKENTYPE YYAPI_TOKENNAME;    //current input token
 #ifdef YYAPI_VALUETYPE                 
    //could be defined as attribute of the token; In this case.
    //YYAPI_TOKENNAME and YYAPI_VALUENAME must match.
    YYAPI_VALUETYPE YYAPI_VALUENAME;    //value of current input token
 #endif
    int yyerrflag;                      //error recovery flag
    int yyerrstatus;    /*  number of tokens to shift before error messages enabled */

// private pointer data
private:
    short yystate;                      //parse state
    short *yyssp;                       //state pointer
    YYSTYPE *yyvsp;                     //pointer to value of a state
    CImpIParserSession* m_pIPSession;   //all of the data necessary for this parser
    CImpIParserTreeProperties * m_pIPTProperties;

public:
    YYLEXER  m_yylex;                   // lexer object for this instance of parser

// private tables
private:
    //These may be allocated dynamically
    YY_CHAR yyitoa[20];                 // Buff to store text version of token

// debugging helpers
public:
//  ICommand* m_pICommand;              //command object
#ifdef YYDEBUG
    int yydebug;
#endif

private:
#ifdef YYDUMP
    void DumpYYS();
    void DumpYYV();
#endif

    void Trace(TCHAR *message);
    void Trace(TCHAR *message, const TCHAR *tokname, short state = 0);
    void Trace(TCHAR *message, int state, short tostate = 0, short token = 0);

private:
# define maxYYBuffer 5
    YY_CHAR *rgpszYYBuffer[maxYYBuffer];
};

#endif  // YYPARS_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\tdbv1\tdbv1.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2001.
//
//  File:       tdbv1.CXX
//
//  Contents:   Test program for OLE-DB phase 3 interface classes.
//
//  TODO:
//              Large result sets
//
//  History:    30 June 1994    Alanw   Created (from cidrt)
//              10 Nov. 1994    Alanw   Converted for OLE-DB phase 3 interfaces
//              01 Oct. 1996    Alanw   Converted for OLE-DB V1.0 interfaces
//
//--------------------------------------------------------------------------

#define DO_NOTIFICATION
#define DO_CATEG_TESTS

#define DO_CONTENT_TESTS

#define DO_MULTI_LEVEL_CATEG_TEST

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <olectl.h>
}

#include <windows.h>

#if !defined(UNIT_TEST)
#define DBINITCONSTANTS
#if !defined(OLEDBVER)
#define OLEDBVER 0x0250
#endif  // !OLEDBVER
#endif  // !UNIT_TEST

#include <oledb.h>
#include <oledberr.h>
#include <ntquery.h>
#include <query.h>
#include <ciintf.h>
#include <cierror.h>
#include <stgprop.h>

#include <vquery.hxx>
#include <dbcmdtre.hxx>

#include <crt\io.h>
#include <stdlib.h>
#include <stdio.h>
#include <stddef.h>
#include <string.h>
#include <time.h>
#include <process.h>
#include <propapi.h>
#include <propvar.h>

#include <oleext.h>

#include <initguid.h>
#include <srvprvdr.h>

#if defined(UNIT_TEST)
#define PROG_NAME       "tdbv1"
//#include "tabledbg.hxx"

#else  // !UNIT_TEST
#define PROG_NAME       "fsdbdrt"

#endif // UNIT_TEST

#if defined(UNIT_TEST)
#include <compare.hxx>
#include <coldesc.hxx>
#endif

WCHAR *pwcThisMachine = L".";
#define TEST_MACHINE ( pwcThisMachine )

WCHAR const wcsDefaultTestCatalog[] = L"::_noindex_::";
#define TEST_CATALOG ( wcsTestCatalog )

WCHAR const wcsDefaultContentCatalog[] = L"system";
#define CONTENT_CATALOG ( wcsDefaultContentCatalog )

BOOL isEven(unsigned n)
{
     return !(n & 0x1);
}

//
// Maximum time for test to complete.
//

int const MAXTIME = 120;
int const MINREPORTTIME = 5;
int const MAXWAITTIME = 10;

int const MAXCOLUMNS = 20;

const int cbPV = sizeof PROPVARIANT;
const int cbPPV = sizeof( PROPVARIANT * );

const HCHAPTER DBCHP_FIRST = 1;

time_t tstart;
BOOL CheckTime();


//
// Test files
//

WCHAR const wcsTestDir[]     = L"QueryTest";
WCHAR const wcsTestFile[]    = L"Test file for OFS Query";

WCHAR const wcsPropFile[] = L"Test file for Property Query.txt";
WCHAR const wcsPropFile2[] = L"Test file for Property Query2.txt";

WCHAR const wcsTestCiFile1[] = L"Test file for OFS Content Query1.txt";
WCHAR const wcsTestCiFile2[] = L"Test file for OFS Content Query2.txt";
WCHAR const wcsTestCiFile3[] = L"Test file for OFS Content Query3.txt";

DBOBJECT dbPersistObject;

// For testing safearrays of various types.

GUID const guidArray = { 0x92452ac2, 0xfcbb, 0x11d1,
                         0xb7, 0xca, 0x00, 0xa0, 0xc9, 0x06, 0xb2, 0x39 };

//
// Storage Properties
//

#define PSID_PSSecurityTest { 0xa56168e0,       \
                              0x0ef3, 0x11cf,   \
                              0xbb, 0x01, 0x00, 0x00, 0x4c, 0x75, 0x2a, 0x9a }


#define PSID_PSMyPropSet { 0x49691CF4, \
                           0x7E17, 0x101A, \
                           0xA9, 0x1C, 0x08, 0x00, 0x2B, 0x2E, 0xCD, 0xA9 }

#define guidZero { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }

GUID const guidMyPropSet = PSID_PSMyPropSet;
GUID const guidSecurityTest = PSID_PSSecurityTest;

const DBID dbcolNull = { {0,0,0,{0,0,0,0,0,0,0,0}},DBKIND_GUID_PROPID,0};
const GUID guidQueryExt = DBPROPSET_QUERYEXT;

const GUID guidFsCiFrmwrkExt = DBPROPSET_FSCIFRMWRK_EXT;

const GUID guidCiFrmwrkExt = DBPROPSET_CIFRMWRKCORE_EXT;

const GUID guidMsidxsExt = DBPROPSET_MSIDXS_ROWSETEXT;

CDbColId const psSecurityTest = CDbColId( guidSecurityTest, 2 );

CDbColId const psTestProperty1 = CDbColId( guidMyPropSet, 2 );
CDbColId const psTestProperty2 = CDbColId( guidMyPropSet, L"A Property" );
CDbColId const psTestProperty10 = CDbColId( guidMyPropSet, L"An Empty Property" );
CDbColId const psTestProperty11 = CDbColId( guidMyPropSet, L"A Bstr Property" );
CDbColId const psTestProperty12 = CDbColId( guidMyPropSet, L"A Bstr Vector Property" );
CDbColId const psBlobTest = CDbColId( guidMyPropSet,
                                                L"BlobTest" );
CDbColId const psGuidTest = CDbColId( guidMyPropSet,
                                                L"GuidTest" );

CDbColId const psTestProperty13 = CDbColId( guidMyPropSet, 13 );
CDbColId const psTestProperty14 = CDbColId( guidMyPropSet, 14 );
CDbColId const psTestProperty15 = CDbColId( guidMyPropSet, 15 );
CDbColId const psTestProperty16 = CDbColId( guidMyPropSet, 16 );
CDbColId const psTestProperty17 = CDbColId( guidMyPropSet, 17 );
CDbColId const psTestProperty18 = CDbColId( guidMyPropSet, 18 );
CDbColId const psTestProperty19 = CDbColId( guidMyPropSet, 19 );
CDbColId const psTestProperty20 = CDbColId( guidMyPropSet, 20 );

CDbColId const psTestProperty21 = CDbColId( guidMyPropSet, 21 );
CDbColId const psTestProperty22 = CDbColId( guidMyPropSet, 22 );

#ifndef PROPID_PSDocument
//#include <winole.h>
#define PSID_PSDocument { \
                        0xF29F85E0, \
                        0x4FF9, 0x1068, \
                        0xAB, 0x91, 0x08, 0x00, 0x2B, 0x27, 0xB3, 0xD9 \
}
#define PROPID_PSDocument_Author        4
#define PROPID_PSDocument_Keywords      5
#endif // PROPID_PSDocument

static GUID guidDocument = PSID_PSDocument;

CDbColId const psAuthor = CDbColId( guidDocument,
                                    PROPID_PSDocument_Author );
CDbColId const psKeywords = CDbColId( guidDocument,
                                      PROPID_PSDocument_Keywords );

CDbColId const psRelevantWords = CDbColId( guidMyPropSet,
                                           L"RelevantWords" );

CDbColId const psManyRW = CDbColId( guidMyPropSet,
                                    L"ManyRW" );

PROPVARIANT varProp1;
PROPVARIANT varProp2;
PROPVARIANT varProp3;
PROPVARIANT varProp4;
PROPVARIANT varProp5;
PROPVARIANT varProp6;
PROPVARIANT varProp7;
PROPVARIANT varProp8, varProp8A;
PROPVARIANT varProp9;
PROPVARIANT varProp10;
PROPVARIANT varProp11, varProp11A;
PROPVARIANT varProp12;
// for coercion test
PROPVARIANT varProp13;
PROPVARIANT varProp14;
PROPVARIANT varProp15;
PROPVARIANT varProp16;
PROPVARIANT varProp17;
PROPVARIANT varProp18, varProp18A;
PROPVARIANT varProp19;
PROPVARIANT varProp20;
PROPVARIANT varProp21;
PROPVARIANT varProp22;

VARTYPE const PROP1_TYPE = VT_I4;
VARTYPE const PROP2_TYPE = VT_LPWSTR;
VARTYPE const PROP3_TYPE = VT_LPWSTR;
VARTYPE const PROP4_TYPE = (VT_VECTOR|VT_LPWSTR);
VARTYPE const PROP5_TYPE = (VT_VECTOR|VT_I4);
VARTYPE const PROP6_TYPE = VT_BLOB;
VARTYPE const PROP7_TYPE = VT_CLSID;
VARTYPE const PROP8_TYPE = (VT_VECTOR|VT_I4);
VARTYPE const PROP9_TYPE = VT_I4;
VARTYPE const PROP10_TYPE = VT_LPWSTR;
VARTYPE const PROP11_TYPE = VT_BSTR;
VARTYPE const PROP12_TYPE = (VT_VECTOR|VT_BSTR);
// for coercion test
VARTYPE const PROP13_TYPE = VT_UI1;
VARTYPE const PROP14_TYPE = VT_I2;
VARTYPE const PROP15_TYPE = VT_UI2;
VARTYPE const PROP16_TYPE = VT_I4;
VARTYPE const PROP17_TYPE = VT_R4;
VARTYPE const PROP18_TYPE = VT_R8;
VARTYPE const PROP19_TYPE = VT_BOOL;
VARTYPE const PROP20_TYPE = VT_LPSTR;
VARTYPE const PROP21_TYPE = VT_CF;
VARTYPE const PROP22_TYPE = VT_CF | VT_VECTOR;

const long PROP1_VAL = 1234;
#define PROP1_cb ( sizeof ULONG )
const long PROP1_VAL_Alternate = 123;

const WCHAR * PROP2_VAL = L"Wow! In a property.";
#define PROP2_cb ( ( sizeof WCHAR ) * ( wcslen(PROP2_VAL) ) )

const WCHAR * PROP3_VAL = L"AlanW";
#define PROP3_cb ( ( sizeof WCHAR ) * ( wcslen(PROP3_VAL) ) )

const WCHAR * alpwstrProp4[] = {        L"This",
                                        L"is",
                                        L"a",
                                        L"Vector",
                                        L"Property",
                                };
const int clpwstrProp4 = (sizeof alpwstrProp4 / sizeof (WCHAR *));
const CALPWSTR PROP4_VAL = { clpwstrProp4, (WCHAR * *) alpwstrProp4 };
#define PROP4_cb 0

const LONG SecondRelevantWord = 0x23;

LONG alProp5[] = { 0x12, SecondRelevantWord, 0x35, 0x47, 0x59 };
const int clProp5 = (sizeof alProp5 / sizeof (LONG));
CAL PROP5_VAL = { clProp5, &alProp5[0] };

LONG alProp5Less[] = { alProp5[0]-1, alProp5[1]-1, alProp5[2]-1, alProp5[3]-1, alProp5[4]-1 };
const int clProp5Less = (sizeof alProp5Less / sizeof (LONG));
CAL PROP5_VAL_LESS = { clProp5Less, &alProp5Less[0] };

LONG alProp5More[] = { alProp5[0]+1, alProp5[1]+1, alProp5[2]+1, alProp5[3]+1, alProp5[4]+1 };
const int clProp5More = (sizeof alProp5More / sizeof (LONG));
CAL PROP5_VAL_MORE = { clProp5More, &alProp5More[0] };

LONG alProp5AllLess[] = { 1, 2, 3, 4, 5 };
const int clProp5AllLess = (sizeof alProp5AllLess / sizeof (LONG));
CAL PROP5_VAL_ALLLESS = { clProp5AllLess, &alProp5AllLess[0] };

LONG alProp5AllMore[] = { 0xffff, 0xfffe, 0xfffd, 0xfffc, 0xfffb };
const int clProp5AllMore = (sizeof alProp5AllMore / sizeof (LONG));
CAL PROP5_VAL_ALLMORE = { clProp5AllMore, &alProp5AllMore[0] };

LONG alProp5Jumble[] = { alProp5[4], alProp5[3], alProp5[1], alProp5[2], alProp5[0] };
const int clProp5Jumble = (sizeof alProp5Jumble / sizeof (LONG));
CAL PROP5_VAL_JUMBLE = { clProp5Jumble, &alProp5Jumble[0] };

LONG alProp5Like[] = { 0x1, 0x1, 0x2, 0x3, SecondRelevantWord };
const int clProp5Like = (sizeof alProp5Like / sizeof (LONG));
CAL PROP5_VAL_LIKE = { clProp5Like, &alProp5Like[0] };

LONG alProp5None[] = { 0x1, 0x1, 0x2, 0x3, 0x4 };
const int clProp5None = (sizeof alProp5None / sizeof (LONG));
CAL PROP5_VAL_NONE = { clProp5None, &alProp5None[0] };
#define PROP5_cb 0

BLOB PROP6_VAL = { sizeof alProp5, (BYTE*) &alProp5[0] };
#define PROP6_cb ( sizeof PROPVARIANT )

GUID PROP7_VAL = guidMyPropSet;
#define PROP7_cb ( sizeof GUID )
#define PROP7_STR_VAL "{49691CF4-7E17-101A-A91C-08002B2ECDA9}"

// note: loading the value of prop8 will be deferred
LONG alProp8[5000];
const int clProp8 = (sizeof alProp8 / sizeof (LONG));
CAL PROP8_VAL = { clProp8, &alProp8[0] };
#define PROP8_cb 0

const long PROP9_VAL = 4321;
#define PROP9_cb ( sizeof ULONG )

const WCHAR * PROP10_VAL = L"";                 // an empty string
#define PROP10_cb ( ( sizeof WCHAR ) * (wcslen(PROP10_VAL) ) )

const WCHAR * PROP11_VAL = L"This is a BSTR";  // string for a BSTR prop
WCHAR PROP11_LONGVAL[5000] = L"This is a large BSTR     ";  // string for a BSTR prop

const char PROP13_VAL = 65;
#define PROP13_cb ( sizeof char )
#define PROP13_STR_VAL "65"

const short PROP14_VAL = -1234;
#define PROP14_cb ( sizeof short )
#define PROP14_STR_VAL "-1234"

const unsigned short PROP15_VAL = 1234;
#define PROP15_cb ( sizeof (unsigned short) )
#define PROP15_STR_VAL "1234"

const int PROP16_VAL = -1234;
#define PROP16_cb ( sizeof int )
#define PROP16_STR_VAL "-1234"

const float PROP17_VAL = 1234.5678F;
#define PROP17_cb ( sizeof (float) )
// This would get truncated in result as we supply a smaller buffer
#define PROP17_STR_VAL "123"

const double PROP18_VAL = 1234.12345678;
#define PROP18_cb ( sizeof double )
#define PROP18_STR_VAL "1234.12345678"

const WORD PROP19_VAL = 0;
#define PROP19_cb ( sizeof WORD )
#define PROP19_STR_VAL "False"

const LPSTR PROP20_VAL = "1245.5678";
#define PROP20_cb ( strlen( PROP20_VAL ) )
#define PROP20_DBL_VAL 1245.5678

// note: not all the data in the CF is used, just the # of bytes specified

CLIPDATA aClipData[3] =
{
    { 20, 3, (BYTE *) "abcdefghijklmnopqrstuvwxyz" },
    { 16, 5, (BYTE *) "zyxwvutsrqponmlkjihgfedcba" },
    { 24, 7, (BYTE *) "01234567abcdefghijklmnopqrstuvwxyz" },
};

#define PROP21_cb (sizeof( void *) )
#define PROP21_VAL &aClipData[0]
#define PROP22_cb 0
#define PROP22_VAL aClipData
#define PROP22_CVALS ( sizeof aClipData / sizeof aClipData[0] )


// safearray propvariants:
PROPVARIANT vaI4;
PROPSPEC psSA_I4 = { PRSPEC_PROPID, 2 };
CDbColId const colSA_I4 = CDbColId( guidArray, 2 );
PROPVARIANT vaBSTR;
PROPSPEC psSA_BSTR = { PRSPEC_PROPID, 3 };
CDbColId const colSA_BSTR = CDbColId( guidArray, 3 );
PROPVARIANT vaVARIANT;
PROPSPEC psSA_VARIANT = { PRSPEC_PROPID, 4 };
CDbColId const colSA_VARIANT = CDbColId( guidArray, 4 );
PROPVARIANT vaR8;
PROPSPEC psSA_R8 = { PRSPEC_PROPID, 5 };
CDbColId const colSA_R8 = CDbColId( guidArray, 5 );
PROPVARIANT vaDATE;
PROPSPEC psSA_DATE = { PRSPEC_PROPID, 6 };
CDbColId const colSA_DATE = CDbColId( guidArray, 6 );
PROPVARIANT vaBOOL;
PROPSPEC psSA_BOOL = { PRSPEC_PROPID, 7 };
CDbColId const colSA_BOOL = CDbColId( guidArray, 7 );
PROPVARIANT vaDECIMAL;
PROPSPEC psSA_DECIMAL = { PRSPEC_PROPID, 8 };
CDbColId const colSA_DECIMAL = CDbColId( guidArray, 8 );
PROPVARIANT vaI1;
PROPSPEC psSA_I1 = { PRSPEC_PROPID, 9 };
CDbColId const colSA_I1 = CDbColId( guidArray, 9 );
PROPVARIANT vaR4;
PROPSPEC psSA_R4 = { PRSPEC_PROPID, 10 };
CDbColId const colSA_R4 = CDbColId( guidArray, 10 );
PROPVARIANT vaCY;
PROPSPEC psSA_CY = { PRSPEC_PROPID, 11 };
CDbColId const colSA_CY = CDbColId( guidArray, 11 );
PROPVARIANT vaUINT;
PROPSPEC psSA_UINT = { PRSPEC_PROPID, 12 };
CDbColId const colSA_UINT = CDbColId( guidArray, 12 );
PROPVARIANT vaINT;
PROPSPEC psSA_INT = { PRSPEC_PROPID, 13 };
CDbColId const colSA_INT = CDbColId( guidArray, 13 );
PROPVARIANT vaERROR;
PROPSPEC psSA_ERROR = { PRSPEC_PROPID, 14 };
CDbColId const colSA_ERROR = CDbColId( guidArray, 14 );

//
//  Desired output columns (as both CDbColId and DBCOMUNID)
//

static GUID guidSystem = PSGUID_STORAGE;
static GUID guidQuery = PSGUID_QUERY;
static GUID guidBmk = DBBMKGUID;
static GUID guidSelf = DBCOL_SELFCOLUMNS;


static CDbColId psName( guidSystem, PID_STG_NAME );
static CDbColId psPath( guidSystem, PID_STG_PATH );
static CDbColId psAttr( guidSystem, PID_STG_ATTRIBUTES );
static CDbColId psSize( guidSystem, PID_STG_SIZE );
static CDbColId psWriteTime( guidSystem, PID_STG_WRITETIME );
static CDbColId psClassid( guidSystem, PID_STG_CLASSID );
static CDbColId psContents( guidSystem, PID_STG_CONTENTS );

static CDbColId psRank( guidQuery, DISPID_QUERY_RANK );
static CDbColId psWorkid( guidQuery, DISPID_QUERY_WORKID );
static CDbColId psBookmark( guidBmk, PROPID_DBBMK_BOOKMARK );
static CDbColId psSelf( guidSelf, PROPID_DBSELF_SELF );
static CDbColId psChapt( guidBmk, PROPID_DBBMK_CHAPTER );


static CDbSortKey sortSize( psSize, QUERY_SORTDESCEND );
static CDbSortKey sortClassid( psClassid, QUERY_SORTDESCEND );
static CDbSortKey sortWriteTime( psWriteTime, QUERY_SORTASCEND );
static CDbSortKey sortName( psName, QUERY_SORTDESCEND );
static CDbSortKey sortAttr( psName, QUERY_SORTASCEND );

CDbSortKey  aSortCols[] = {
    sortSize, sortClassid, sortWriteTime, sortName,
};

CDbSortKey  aCatSortCols[] = {
    sortSize, sortWriteTime,
};

CDbSortKey  aMultiCatSortCols[] = {
    sortAttr, sortSize,
};


static CDbSortKey sortKeywords( psKeywords, QUERY_SORTASCEND );
static CDbSortKey sortRelevantWords( psRelevantWords, QUERY_SORTASCEND );
static CDbSortKey sortTestProperty1( psTestProperty1, QUERY_SORTASCEND );


CDbSortKey aPropSortCols[] = {
    sortKeywords, sortRelevantWords, sortTestProperty1
};


const int cSortColumns = (sizeof aSortCols) / (sizeof aSortCols[0]);
const int cCatSortColumns = (sizeof aCatSortCols) / (sizeof aCatSortCols[0]);
const int cMultiCatSortColumns = (sizeof aMultiCatSortCols) / (sizeof aMultiCatSortCols[0]);
const int cPropSortColumns = (sizeof aPropSortCols) / (sizeof aPropSortCols[0]);



const BYTE bmkFirst = (BYTE) DBBMK_FIRST;
const BYTE bmkLast = (BYTE) DBBMK_LAST;

//
// Text in content index files
//

char const szCIFileData1[] =
    "   The content index was created by Kyle Peltonen and Bartosz Milewski\n"
    "with help from Amy Arlin, Wade Richards, Mike Hewitt and a host of others.\n"
    "   \"To be or not to be\" is most likely a noise phrase.  \"To be or\n"
    "not to be, that is the question\" contains at least one non-noise\n"
    "word.\n"
    "Now is the time for all good men to come to the aid of their country.\n"
    "The content index is a superb piece of engineering. ;-)\n";

char const szCIFileData2[] =
    "\"Anybody can be good in the country.  "
    "There are no temptations there.\"\n"
    "\n"
    "Oscar Wilde (1854-1900), Anglo-Irish playwright, author.\n"
    "Lord Henry, in The Picture of Dorian Gray, ch. 19 (1891).\n";

char const szOFSFileData[] = "PLEASE DELETE ME!\n";

WCHAR wcsTestPath[MAX_PATH];
WCHAR wcsTestCatalog[MAX_PATH];

struct SBasicTest
{
    // field lengths
    DBLENGTH  cbClsid;
    DBLENGTH  cbSize;
    DBLENGTH  cbWriteTime;
    DBLENGTH  cbAttr;
    DBLENGTH  cbName;
    DBLENGTH  cbPath;

    // field status
    ULONG     sClsid;
    ULONG     sSize;
    ULONG     sWriteTime;
    ULONG     sIPSStorage;
    ULONG     sAttr;
    ULONG     sName;
    ULONG     sPath;

    // field data
    CLSID     clsid;
    _int64    size;
    _int64    writeTime;
    unsigned  attr;
    WCHAR     awcName[MAX_PATH + 1];
    WCHAR    *pwcPath;
    IUnknown *pIPSStorage;
};

struct SBasicAltTest
{
    // field lengths
    DBLENGTH  cbSize;
    DBLENGTH  cbWriteTime1;
    DBLENGTH  cbWriteTime2;
    DBLENGTH  cbWriteTime3;

    // field status
    ULONG     sSize;
    ULONG     sWriteTime1;
    ULONG     sWriteTime2;
    ULONG     sWriteTime3;

    // field data
    LONG      Size;
    DBDATE    writeTime1;
    DBTIME    writeTime2;
    DBTIMESTAMP writeTime3;
};


const ULONG cbRowName = sizeof WCHAR * (MAX_PATH + 1);


#define ALLPARTS ( DBPART_VALUE|DBPART_LENGTH|DBPART_STATUS )

DBBINDING aBasicTestCols[] =
{
  // the iOrdinal field is filled in after the cursor is created

  { 0,
    offsetof(SBasicTest,clsid),
    offsetof(SBasicTest,cbClsid),
    offsetof(SBasicTest,sClsid),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    sizeof CLSID,
    0, DBTYPE_GUID,
    0, 0 },
  { 0,
    offsetof(SBasicTest,size),
    offsetof(SBasicTest,cbSize),
    offsetof(SBasicTest,sSize),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    sizeof LONGLONG,
    0, DBTYPE_UI8,
    0, 0 },
  { 0,
    offsetof(SBasicTest,writeTime),
    offsetof(SBasicTest,cbWriteTime),
    offsetof(SBasicTest,sWriteTime),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    sizeof LONGLONG,
    0, VT_FILETIME,
    0, 0 },
  { 0,
    offsetof(SBasicTest,attr),
    offsetof(SBasicTest,cbAttr),
    offsetof(SBasicTest,sAttr),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    3, // 3 for cb is ok: fixed len field so ignored
    0, DBTYPE_I4,
    0, 0 },
  { 0,
    offsetof(SBasicTest,awcName),
    offsetof(SBasicTest,cbName),
    offsetof(SBasicTest,sName),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    cbRowName,
    0, DBTYPE_WSTR,
    0, 0 },
  { 0,
    offsetof(SBasicTest,pwcPath),
    offsetof(SBasicTest,cbPath),
    offsetof(SBasicTest,sPath),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    0,
    0, DBTYPE_WSTR|DBTYPE_BYREF,
    0, 0 },
  { 0,
    offsetof(SBasicTest,pIPSStorage),
    0,
    offsetof(SBasicTest,sIPSStorage),
    0, // pTypeInfo
    &dbPersistObject, // pObject
    0,  // pBindExt
    DBPART_VALUE|DBPART_STATUS,  // dwPart
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM, // dwMemOwner
    0,               // cbMaxLen
    0,               // dwFlags
    DBTYPE_IUNKNOWN, // wType
    0, 0 },          // bPrecision, bScale
};

const ULONG cBasicTestCols = sizeof aBasicTestCols / sizeof aBasicTestCols[0];

DBBINDING aBasicAltCols[] =
{
  // the iOrdinal field is filled in after the cursor is created

  { 0,
    offsetof(SBasicAltTest,Size),
    offsetof(SBasicAltTest,cbSize),
    offsetof(SBasicAltTest,sSize),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    3, // 3 for cb is ok: fixed len field so ignored
    0, DBTYPE_I4,
    0, 0 },
  { 0,
    offsetof(SBasicAltTest,writeTime1),
    offsetof(SBasicAltTest,cbWriteTime1),
    offsetof(SBasicAltTest,sWriteTime1),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    sizeof DBDATE,
    0, DBTYPE_DBDATE,
    0, 0 },
  { 0,
    offsetof(SBasicAltTest,writeTime2),
    offsetof(SBasicAltTest,cbWriteTime2),
    offsetof(SBasicAltTest,sWriteTime2),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    sizeof DBTIME,
    0, DBTYPE_DBTIME,
    0, 0 },
  { 0,
    offsetof(SBasicAltTest,writeTime3),
    offsetof(SBasicAltTest,cbWriteTime3),
    offsetof(SBasicAltTest,sWriteTime3),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    sizeof DBTIMESTAMP,
    0, DBTYPE_DBTIMESTAMP,
    0, 0 },
};

const ULONG cBasicAltCols = sizeof aBasicAltCols / sizeof aBasicAltCols[0];

int     fTimeout = 1;   // non-zero if query times out
int     fVerbose = 0;   // non-zero if verbose mode
int     cFailures = 0;  // count of failures in test (unit test only)


// Class to be used as an outer unknown.  All QIs are simply
// passed on to inner unknown.
class COuterUnk: public IUnknown
{
public:

    //
    // IUnknown methods.
    //

    STDMETHOD(QueryInterface) ( THIS_ REFIID riid,
                                LPVOID *ppiuk )
                           {
                              // do blindly delegate for purpose of test
                              // don't AddRef as the inner unk will do it
                              return _pInnerUnk->QueryInterface(riid,ppiuk);
                           }
    STDMETHOD_(ULONG, AddRef) (THIS)
                            {
                                InterlockedIncrement( (long *)&_ref );
                                return( _ref );
                            }

    STDMETHOD_(ULONG, Release) (THIS)
                            {
                                if ( InterlockedDecrement( (long *)&_ref ) <= 0 )
                                {
                                    InterlockedIncrement( (long *)&_ref ); // artificial ref count for aggr
                                    delete this;
                                    return 0;
                                }
                                return ( _ref );
                            }
     void Set(IUnknown *pInnerUnk)  {_pInnerUnk = pInnerUnk;
                                     _pInnerUnk->AddRef();}


     COuterUnk() :   _ref(1), _pInnerUnk(NULL)
                          {};
    ~COuterUnk() {
                    if (_pInnerUnk)
                    {
                       _pInnerUnk->Release();
                       _pInnerUnk = 0;
                    }
       };

private:
    long  _ref;                   // OLE reference count
    IUnknown * _pInnerUnk;
};

void DownlevelTest(BOOL fSequential);
void SingleLevelCategTest();
void MultiLevelCategTest();
void CategTest( HCHAPTER hUpperChapt,
                IRowset *pRowsetCateg, IRowset *pRowset, unsigned cCols );

void RunPropTest( );
void RunSafeArrayTest( );
void RunDistribQueryTest( BOOL fDoContentTest );
void DeleteTest(BOOL fSequential);
void ContentTest(void);

void ConflictingPropsTest( LPWSTR pwszScope,
                           CDbCmdTreeNode * pTree,
                           COuterUnk * pobjOuterUnk,
                           ICommandTree **ppCmdTree );

void CheckColumns( IUnknown* pRowset, CDbColumns& rColumns, BOOL fQuiet = FALSE );
void CheckPropertiesInError( ICommand* pCmd, BOOL fQuiet = FALSE );
void CheckPropertiesOnCommand( ICommand* pCmd, BOOL fQuiet = FALSE );
void BasicTest( IRowset* pRowset,
                BOOL fSequential, HCHAPTER hChapt, unsigned cCols,
                BOOL fByRef, ICommandTree * pCmdTree = 0 );
void BackwardsFetchTest( IRowset* pRowset );
void FetchTest(IRowset* pRowset);
void BindingTest(IUnknown* pRowset, BOOL fICommand = FALSE, BOOL fSequential = FALSE );
void MoveTest(IRowset* pRowset, HCHAPTER hChapt = DB_NULL_HCHAPTER);

int CheckHrowIdentity( IRowsetIdentity * pRowsetIdentity,
                       DBROWCOUNT lOffset,
                       DBCOUNTITEM cRows1,
                       HROW * phRows1,
                       DBCOUNTITEM cRows2,
                       HROW * phRows2 );

void TestIAccessorOnCommand( ICommandTree * pCmdTree );

void CheckPropertyValue( PROPVARIANT const & varntPropRet,
                         PROPVARIANT const & varntPropExp);

BOOL GetBooleanProperty ( IRowset * pRowset, DBPROPID dbprop );
BOOL SetBooleanProperty ( ICommand * pCmd, DBPROPID dbprop, VARIANT_BOOL f );

CDbCmdTreeNode * FormQueryTree( CDbCmdTreeNode * pRst,
                                CDbColumns & Cols,
                                CDbSortSet * pSort,
                                LPWSTR * aColNames = 0 );

void GetCommandTreeErrors(ICommandTree* pCmdTree);

IRowsetScroll * InstantiateRowset(
    ICommand *pQueryIn,
    DWORD dwDepth,
    LPWSTR pwszScope,
    CDbCmdTreeNode * pTree,
    REFIID riid,
    COuterUnk *pobjOuterUnk = 0,
    ICommandTree ** ppCmdTree = 0,
    BOOL fExtendedTypes = TRUE
);

void InstantiateMultipleRowsets(
    DWORD dwDepth,
    LPWSTR pwszScope,
    CDbCmdTreeNode * pTree,
    REFIID riid,
    unsigned cRowsets,
    IUnknown ** aRowsets,
    ICommandTree ** ppCmdTree = 0
);

void ReleaseStaticHrows( IRowset * pRowset, DBCOUNTITEM cRows, HROW * phRows );
void FreeHrowsArray( IRowset * pRowset, DBCOUNTITEM cRows, HROW ** pphRows );

HACCESSOR MapColumns(
        IUnknown * pUnknown,
        DBORDINAL cCols,
        DBBINDING * pBindings,
        const DBID * pColIds,
        BOOL fByRef = FALSE );
void ReleaseAccessor( IUnknown * pUnknown, HACCESSOR hAcc );

int  WaitForCompletion( IRowset *pRowset, BOOL fQuiet = FALSE );
void Setup(void);
void Cleanup(void);
ULONG Delnode( WCHAR const * wcsDir );
void BuildFile( WCHAR const * wcsFile, char const * data, ULONG cb );

void CantRun(void);
void Fail(void);
void Usage(void);

void LogProgress( char const * pszFormat, ... );
void LogError( char const * pszFormat, ... );
void LogFail( char const * pszFormat, ... );
WCHAR * FormatGuid( GUID const & guid );

void DBSortTest(void);

SCODE SetScopeProperties( ICommand * pCmd,
                         unsigned cDirs,
                         WCHAR const * const * apDirs,
                         ULONG const *  aulFlags,
                         WCHAR const * const * apCats = 0,
                         WCHAR const * const * apMachines = 0 );

BOOL DoContentQuery(
    ICommand * pQuery,
    CDbRestriction & CiRst,
    unsigned cExpectedHits );

char *ProgName = PROG_NAME;

void Usage(void)
{
#ifdef UNIT_TEST
    printf("Usage:  %s [ -d[:InfoLevel] ] [-v] [-V] [-t] [-c]\n",
           ProgName);
#else // !UNIT_TEST
    printf("Usage:  %s [-v] [-V] [-t] [-c]\n", ProgName);
#endif // UNIT_TEST
    printf("\t-v\tverbose\n"
           "\t-V\tvery verbose - dumps tables, column and rowset info\n"
           "\t-t\tdon't timeout queries\n"
           "\t-c\tdon't do content query test\n");
    //       "\t-dl\tdon't do tests on downlevel file system\n"
    //       "\t-ofs\tdon't do tests on OFS file system\n");
    //       "\t-n{d,o}\tdon't do tests on downlevel (-nd) or OFS (-no)\n");
#ifdef UNIT_TEST
    printf("\t-d[:InfoLevel]\tset debug infolevel to InfoLevel\n");
#endif // UNIT_TEST
    exit(2);
}


//+-------------------------------------------------------------------------
//
//  Function:   IsContentFilteringEnabled, public
//
//  Synopsis:   Read the registry for the key FilterContent at the
//              location
//
//--------------------------------------------------------------------------

BOOL IsContentFilteringEnabled()
{
    WCHAR wcsFilterContents[] = L"FilterContents";
    WCHAR wcsRegAdmin[]       = L"ContentIndex";
    BOOL  fFilteringEnabled    = FALSE;

    RTL_QUERY_REGISTRY_TABLE regtab[2];

    regtab[0].DefaultType   = REG_NONE;
    regtab[0].DefaultData   = 0;
    regtab[0].DefaultLength = 0;
    regtab[0].QueryRoutine  = 0;
    regtab[0].Name          = wcsFilterContents;
    regtab[0].EntryContext  = &fFilteringEnabled;
    regtab[0].Flags         = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;

    regtab[1].QueryRoutine = 0;
    regtab[1].Flags = 0;

    NTSTATUS Status = RtlQueryRegistryValues( RTL_REGISTRY_CONTROL,
                                              wcsRegAdmin,
                                              &regtab[0],
                                              0,
                                              0 );

    if ( NT_ERROR(Status) || !fFilteringEnabled )
        return FALSE;

    ISimpleCommandCreator * pCmdCreator = 0;
    CLSID clsidSCC = CLSID_CISimpleCommandCreator;
    SCODE sc = CoCreateInstance( clsidSCC,
                                 NULL,
                                 CLSCTX_INPROC_SERVER,
                                 IID_ISimpleCommandCreator,
                                 (void **)&pCmdCreator );

    if ( S_OK != sc )
    {
        LogError( "CoCreateInstance for cmd creator returned %08x\n", sc );
        return FALSE;
    }

    WCHAR awchCatalog[80];
    ULONG cchCat = 0;
    sc = pCmdCreator->GetDefaultCatalog( awchCatalog,
                                  sizeof awchCatalog/sizeof(awchCatalog[0]),
                                  &cchCat );

    if ( S_OK != sc )
    {
        LogError( "GetDefaultCatalog returned %08x\n", sc );
        pCmdCreator->Release();
        return FALSE;
    }

    sc = pCmdCreator->VerifyCatalog( TEST_MACHINE, CONTENT_CATALOG );
    pCmdCreator->Release();

    return sc == S_OK;
}


//+-------------------------------------------------------------------------
//
//  Function:   main, public
//
//  Synopsis:   Test the file system implementation of the IRowset
//              family of interfaces.
//
//  Notes:
//
//  History:    25 Mar 1994     Alanw   Created
//
//--------------------------------------------------------------------------

int __cdecl main(int argc, char **argv)
{
    #ifdef UNIT_TEST
        DBSortTest();
    #endif

    unsigned i;
    BOOL fDoContentTest = TRUE;

    //
    // Parse arguments.
    //

    ProgName = argv[0];

    for ( i = 1; i < (unsigned)argc ; i++ )
    {
        char *pszArg = argv[i];
        if ( *pszArg == '-' ) {
            switch ( *++pszArg )
            {
            case 'd':
               // if (pszArg[1] == 'l')  // -dl - no downlevel tests
               // {
               //     fNoDownlevel = TRUE;
               //     break;
               // }
#if defined (UNIT_TEST) && (DBG == 1)
                if (*++pszArg == ':')   // -d:xx - debug output mode
                    pszArg++;

                {
                    unsigned fInfoLevel = atoi(pszArg);
                    tbInfoLevel = fInfoLevel ? fInfoLevel : 0xFFFFF;
                }
                break;
#else // !UNIT_TEST
                Usage();
                exit(2);
#endif // UNIT_TEST

            case 't':           // don't timeout
                fTimeout = 0;
                break;

            case 'c':
                fDoContentTest = FALSE;
                break;

            case 'V':           // very verbose, dumps table
                fVerbose++;
            case 'v':           // verbose
                fVerbose++;
                break;

            default:
                Usage();
                exit (2);
            }
        } else {

            //  Exit the argument loop

            argc -= i;
            argv += i;
            break;
        }
    }

    printf( "%s: OLE-DB cursor unit test.\n"
#if defined (UNIT_TEST)
                "   No expected failures\n"
#if !(defined(DO_CATEG_TESTS) && \
      defined(DO_NOTIFICATION) && \
      defined(DO_CONTENT_TESTS) && \
      defined(MULTI_LEVEL_CATEG_TEST) )
                "   Not all tests are turned on\n"
#endif // conditional tests
#endif // defined(UNIT_TEST)
                , ProgName );

    for (i = 0; i < clProp8; i++)
        alProp8[i] = i;

    CoInitialize( 0 );

    Setup();

    // Patch in this iid, which can't be done in the initializer

    dbPersistObject.dwFlags = STGM_PRIORITY | STGM_READ;
    dbPersistObject.iid = IID_IPropertySetStorage;

    //
    // Base functionality test
    //


    RunPropTest( );
    RunSafeArrayTest();

    RunDistribQueryTest( fDoContentTest );

    DownlevelTest(TRUE);
    DownlevelTest(FALSE);

    #ifdef DO_CATEG_TESTS
        SingleLevelCategTest();

        #ifdef DO_MULTI_LEVEL_CATEG_TEST
            MultiLevelCategTest();
        #endif

    #endif // DO_CATEG_TESTS

    #ifdef DO_CONTENT_TESTS
        if ( fDoContentTest && IsContentFilteringEnabled() )
        {
            ContentTest();
        }
        else
    #endif
            LogProgress("WARNING: Content Query test disabled\n");

    DeleteTest(TRUE);
    DeleteTest(FALSE);

    CIShutdown();

//#if defined (UNIT_TEST)
    if (cFailures)
    {
        printf("%d failures occurred\n", cFailures);
        Fail();
    }
//#endif // defined(UNIT_TEST)

    Cleanup();
    CoUninitialize();

    printf( "%s: PASSED\n", ProgName );
    if (! _isatty(_fileno(stdout)) )
        fprintf( stderr, "%s: PASSED\n", ProgName );
    return( 0 );
} //main


//+-------------------------------------------------------------------------
//
//  Function:   DownlevelTest, public
//
//  Synopsis:   Basic query feature test.
//
//  History:    30 Jun 94       AlanW     Created
//
//  Notes:      Just looks for files in the system directory.
//
//--------------------------------------------------------------------------

void DownlevelTest(BOOL fSequential)
{
    LogProgress( "Non-content %s query\n",
                fSequential? "sequential" : "scrollable");

    SCODE sc;

    //
    // Find system directory

    WCHAR wcsSysDir[MAX_PATH];

    #if 0
    wcscpy(wcsSysDir, L"F:\\winnt\\system32");
    #else
    if( !GetSystemDirectory( wcsSysDir, sizeof(wcsSysDir) / sizeof(WCHAR) ) )
    {
        LogFail( "Unable to determine system directory.\n" );
    }
    #endif

    //
    // Get name, size and class id for *.exe, *.dll, *.doc and *.sys
    //

    int cCol = 7;
    if ( !fSequential )
        cCol++;

    CDbColumns cols(cCol);

    cols.Add( psClassid, 0 );
    cols.Add( psSize, 1 );
    cols.Add( psWriteTime, 2 );
    cols.Add( psAttr, 3 );
    cols.Add( psName, 4 );
    cols.Add( psPath, 5 );
    cols.Add( psSelf, 6 );
    if ( !fSequential )
    {
        cols.Add( psWorkid, 7);
    }

    CDbPropertyRestriction rst;

    rst.SetRelation( DBOP_like );
    rst.SetProperty( psName );
    rst.SetValue( L"*.|(exe|,dll|,doc|,sys|,zzz|)" );

    CDbSortSet ss(cSortColumns);
    for (unsigned i = 0; i<cSortColumns; i++)
         ss.Add(aSortCols[i], i);

    CDbCmdTreeNode * pDbCmdTree = FormQueryTree(&rst, cols, &ss);


    if (! fSequential)
    {
        ConflictingPropsTest(wcsSysDir, pDbCmdTree, 0, 0);
    }

    ICommandTree * pCmdTree=0;
    COuterUnk *pOuterUnk = new COuterUnk();

    IRowset * pRowset = InstantiateRowset(
                            0,
                            QUERY_SHALLOW,           // Depth
                            wcsSysDir,               // Scope
                            pDbCmdTree,              // DBCOMMANDTREE
                            fSequential ? IID_IRowset :
                                  IID_IRowsetScroll, // IID of i/f to return
                            pOuterUnk,
                            &pCmdTree );

    //
    // Verify columns
    //
    CheckColumns( pRowset, cols );

    if ( !WaitForCompletion( pRowset, TRUE ) )
    {
        pCmdTree->Release();
        pRowset->Release();
        LogFail( "Downlevel query unsuccessful.\n" );
    }

    //
    //  Do basic function tests.
    //
    BasicTest(pRowset, fSequential,  0, cBasicTestCols, TRUE);
    BasicTest(pRowset, fSequential,  0, cBasicTestCols, TRUE, pCmdTree);

    //
    // Do backward fetch tests
    //
    if ( !fSequential )
    {
        BackwardsFetchTest( pRowset );
    }

    FetchTest(pRowset);

    //
    // Test SetBindings, GetBindings, Move and Scroll
    //
    BindingTest(pRowset, FALSE, fSequential );
    BindingTest(pCmdTree, TRUE, fSequential );

    if ( ! fSequential )
    {
        MoveTest(pRowset);
    }

    pCmdTree->Release();
    pRowset->Release();

    pOuterUnk->Release(); // truly release it

} //DownlevelTest


//+---------------------------------------------------------------------------
//
//  Function:   ConflictingPropsTest
//
//  Synopsis:   Tests handling of conflicting settings of rowset properties.
//
//  Arguments:  [pswzScope] - Query scope
//              [pTree]     - pointer to DBCOMMANDTREE for the query
//              [pUnkOuter] - pointer to outer unknown object
//              [ppCmdTree] - if non-zero, ICommandTree will be returned here.
//
//  Returns:    NOTHING
//
//  History:    26 May  1998   AlanW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

void ConflictingPropsTest(
    LPWSTR pwszScope,
    CDbCmdTreeNode * pTree,
    COuterUnk * pobjOuterUnk,
    ICommandTree **ppCmdTree
) {
    DWORD dwDepth = QUERY_SHALLOW;

    // run the query
    ICommand * pQuery = 0;

    IUnknown * pIUnknown;
    SCODE sc = CICreateCommand( &pIUnknown,
                                (IUnknown *)pobjOuterUnk,
                                IID_IUnknown,
                                TEST_CATALOG,
                                TEST_MACHINE );

    if ( FAILED( sc ) )
        LogFail( "ConflictingPropsTest - error 0x%x Unable to create command\n",
                     sc );

    if (pobjOuterUnk)
    {
       pobjOuterUnk->Set(pIUnknown);
    }

    if (pobjOuterUnk)
        sc = pobjOuterUnk->QueryInterface(IID_ICommand, (void **) &pQuery );
    else
        sc = pIUnknown->QueryInterface(IID_ICommand, (void **) &pQuery );

    pIUnknown->Release();

    if ( FAILED( sc ) )
        LogFail( "ConflictingPropsTest - error 0x%x Unable to QI ICommand\n",
                 sc );

    sc = SetScopeProperties( pQuery,
                             1,
                             &pwszScope,
                             &dwDepth );

    if ( FAILED( sc ) )
        LogFail( "ConflictingPropsTest - error 0x%x Unable to set scope '%ws'\n",
                 sc, pwszScope );

    CheckPropertiesOnCommand( pQuery );

    ICommandTree *pCmdTree = 0;

    if (pobjOuterUnk)
        sc = pobjOuterUnk->QueryInterface(IID_ICommandTree, (void **)&pCmdTree);
    else
        sc = pQuery->QueryInterface(IID_ICommandTree, (void **)&pCmdTree);

    if (FAILED (sc) )
    {
        if ( 0 != pQuery )
            pQuery->Release();

        LogFail("QI for ICommandTree failed\n");
    }

    DBCOMMANDTREE * pRoot = pTree->CastToStruct();

    sc = pCmdTree->SetCommandTree( &pRoot, 0, TRUE);
    if (FAILED (sc) )
    {
        if ( 0 != pQuery )
           pQuery->Release();

        pCmdTree->Release();
        LogFail("SetCommandTree failed, %08x\n", sc);
    }

    ICommandProperties *pCmdProp = 0;
    if (pobjOuterUnk)
        sc = pobjOuterUnk->QueryInterface(IID_ICommandProperties, (void **)&pCmdProp);
    else
        sc = pQuery->QueryInterface(IID_ICommandProperties, (void **)&pCmdProp);

    if (FAILED (sc) )
    {
        if ( 0 != pQuery )
            pQuery->Release();

        LogFail("QI for ICommandProperties failed\n");
    }

    //
    //  Set conflicting properties
    //
    const unsigned MAX_PROPS = 6;
    DBPROPSET  aPropSet[MAX_PROPS];
    DBPROP     aProp[MAX_PROPS];
    ULONG      cProp = 0;

    aProp[cProp].dwPropertyID = DBPROP_IRowsetScroll;
    aProp[cProp].dwOptions    = DBPROPOPTIONS_REQUIRED;
    aProp[cProp].dwStatus     = 0;         // Ignored
    aProp[cProp].colid        = dbcolNull;
    aProp[cProp].vValue.vt    = VT_BOOL;
    aProp[cProp].vValue.boolVal  = VARIANT_TRUE;

    aPropSet[cProp].rgProperties = &aProp[cProp];
    aPropSet[cProp].cProperties = 1;
    aPropSet[cProp].guidPropertySet = DBPROPSET_ROWSET;

    cProp++;

    aProp[cProp].dwPropertyID = DBPROP_BOOKMARKS;
    aProp[cProp].dwOptions    = DBPROPOPTIONS_REQUIRED;
    aProp[cProp].dwStatus     = 0;         // Ignored
    aProp[cProp].colid        = dbcolNull;
    aProp[cProp].vValue.vt    = VT_BOOL;
    aProp[cProp].vValue.boolVal  = VARIANT_FALSE;

    aPropSet[cProp].rgProperties = &aProp[cProp];
    aPropSet[cProp].cProperties = 1;
    aPropSet[cProp].guidPropertySet = DBPROPSET_ROWSET;

    cProp++;


    sc = pCmdProp->SetProperties( cProp, aPropSet );
    //pCmdProp->Release();

    if ( FAILED(sc) || DB_S_ERRORSOCCURRED == sc )
    {
        if ( 0 != pQuery )
            pQuery->Release();

        LogError("ICommandProperties::SetProperties failed\n");
        cFailures++;
    }

    IRowset * pRowset = 0;

    sc = pQuery->Execute( 0,                    // no aggr. IUnknown
                          IID_IRowset,          // IID for i/f to return
                          0,                    // disp. params
                          0,                    // count of rows affected
                          (IUnknown **)&pRowset);  // Returned interface

    if (SUCCEEDED (sc))
    {
        if ( 0 == pRowset )
            LogError("ICommand::Execute returned success(%x), but pRowset is null\n", sc);
        else
            LogError("ICommand::Execute returned success(%x) with conflicting props\n", sc);

        if (DB_S_ERRORSOCCURRED == sc)
        {
            CheckPropertiesInError(pQuery);
        }
        pRowset->Release();
        pCmdProp->Release();
        pCmdTree->Release();
        pQuery->Release();
        Fail();
    }
    else // FAILED (sc)
    {

        if (DB_E_ERRORSOCCURRED != sc)
        {
            LogError("ICommand::Execute with conflicing props failed, %x\n", sc);
            if (DB_E_ERRORSINCOMMAND == sc)
                GetCommandTreeErrors(pCmdTree);

            pCmdProp->Release();
            pCmdTree->Release();
            pQuery->Release();
            Fail();
        }
        CheckPropertiesInError(pQuery, TRUE);
    }

// TODO: check other combinations of conflicting properties
//       check that execute succeeds on same ICommand after reset
    // Set properties back to their default state
    cProp = 0;

    aProp[cProp].dwPropertyID = DBPROP_IRowsetLocate;
    aProp[cProp].dwOptions    = DBPROPOPTIONS_OPTIONAL;
    aProp[cProp].dwStatus     = 0;         // Ignored
    aProp[cProp].colid        = dbcolNull;
    aProp[cProp].vValue.vt    = VT_BOOL;
    aProp[cProp].vValue.boolVal  = VARIANT_FALSE;

    aPropSet[cProp].rgProperties = &aProp[cProp];
    aPropSet[cProp].cProperties = 1;
    aPropSet[cProp].guidPropertySet = DBPROPSET_ROWSET;

    cProp++;

    aProp[cProp].dwPropertyID = DBPROP_BOOKMARKS;
    aProp[cProp].dwOptions    = DBPROPOPTIONS_OPTIONAL;
    aProp[cProp].dwStatus     = 0;         // Ignored
    aProp[cProp].colid        = dbcolNull;
    aProp[cProp].vValue.vt    = VT_BOOL;
    aProp[cProp].vValue.boolVal  = VARIANT_FALSE;

    aPropSet[cProp].rgProperties = &aProp[cProp];
    aPropSet[cProp].cProperties = 1;
    aPropSet[cProp].guidPropertySet = DBPROPSET_ROWSET;

    cProp++;

    aProp[cProp].dwPropertyID = DBPROP_IRowsetScroll;
    aProp[cProp].dwOptions    = DBPROPOPTIONS_OPTIONAL;
    aProp[cProp].dwStatus     = 0;         // Ignored
    aProp[cProp].colid        = dbcolNull;
    aProp[cProp].vValue.vt    = VT_BOOL;
    aProp[cProp].vValue.boolVal = VARIANT_FALSE;

    aPropSet[cProp].rgProperties = &aProp[cProp];
    aPropSet[cProp].cProperties = 1;
    aPropSet[cProp].guidPropertySet = DBPROPSET_ROWSET;

    cProp++;

    sc = pCmdProp->SetProperties( cProp, aPropSet );
    pCmdProp->Release();

    if (FAILED (sc) )
    {
        LogError("ICommandProperties::SetProperties failed, %08x\n", sc);
        if (DB_E_ERRORSINCOMMAND == sc)
        {
            GetCommandTreeErrors(pCmdTree);
        }
        if (DB_E_ERRORSOCCURRED == sc)
        {
            CheckPropertiesInError(pQuery);
        }
        pQuery->Release();
        pCmdTree->Release();
        Fail();
    }

    pQuery->Release();
    if ( 0 == ppCmdTree )
    {
        pCmdTree->Release();
    }
    else
    {
        *ppCmdTree = pCmdTree;
    }

    return;
}


#ifdef DO_CATEG_TESTS
//+-------------------------------------------------------------------------
//
//  Function:   SingleLevelCategTest, public
//
//  Synopsis:   Basic query categorization feature test.
//
//  History:    30 Mar 95       dlee     Created
//
//  Notes:      Just looks for files in the system directory.
//
//--------------------------------------------------------------------------

void SingleLevelCategTest()
{
    LogProgress( "Non-content categorization query\n" );

    SCODE sc;

    //
    // Find system directory
    //

    WCHAR wcsSysDir[MAX_PATH];

#if 0
    wcscpy(wcsSysDir,L"g:\\winnt\\system32");
#else
    if( !GetSystemDirectory( wcsSysDir, sizeof(wcsSysDir) / sizeof(WCHAR) ) )
        LogFail( "Unable to determine system directory.\n" );
#endif

    //
    // Get name, size and class id for *.exe, *.dll, *.doc, and *.sys
    //
    CDbColumns cols(8);

    cols.Add( psClassid, 0 );
    cols.Add( psSize, 1 );
    cols.Add( psWriteTime, 2 );
    cols.Add( psAttr, 3 );
    cols.Add( psName, 4 );
    cols.Add( psPath, 5 );
    cols.Add( psSelf, 6 );
    cols.Add( psBookmark, 7);

    CDbNestingNode nest;

    nest.AddGroupingColumn( psSize );

    nest.AddParentColumn( psBookmark );
    nest.AddParentColumn( psSize );

    nest.AddChildColumn( psClassid );
    nest.AddChildColumn( psSize );
    nest.AddChildColumn( psWriteTime );
    nest.AddChildColumn( psAttr );
    nest.AddChildColumn( psName );
    nest.AddChildColumn( psPath );
    nest.AddChildColumn( psSelf );
    nest.AddChildColumn( psBookmark);

    CDbPropertyRestriction rst;

    rst.SetRelation( DBOP_like );
    rst.SetProperty( psName );
    rst.SetValue( L"*.|(exe|,dll|,doc|,sys|,zzz|)" );

    CDbSelectNode * pSelect = new CDbSelectNode();
    pSelect->AddRestriction( rst.Clone() );

    nest.AddTable( pSelect );
    pSelect = 0;

    IRowset * pRowsets[2];
    ICommandTree * pCmdTree = 0;

    InstantiateMultipleRowsets(
                            QUERY_SHALLOW,           // Depth
                            wcsSysDir,               // Scope
                            nest.Clone(),            // DBCOMMANDTREE
                            IID_IRowsetScroll,       // IID for i/f to return
                            2,
                            (IUnknown **)pRowsets,
                            &pCmdTree );

    IRowset *pRowsetCateg = pRowsets[0];
    IRowset *pRowset = pRowsets[1];

    //
    // Verify columns
    //

    CDbColumns chapCols(3);

    chapCols.Add( psBookmark, 0 );
    chapCols.Add( psSize, 1 );
    chapCols.Add( psChapt, 2 ); // chapt must be last since it is added to
                                // the end automatically above.
    CheckColumns( pRowsetCateg, chapCols );
    CheckColumns( pRowset, cols );

    if ( !WaitForCompletion( pRowset, FALSE ) )
    {
        pCmdTree->Release();
        pRowset->Release();
        pRowsetCateg->Release();
        LogFail( "Downlevel query unsuccessful.\n" );
    }

    //
    //  Do basic function tests.
    //
    FetchTest(pRowset);

    //
    // Test SetBindings, GetBindings, Move and Scroll
    //
    BindingTest(pRowset);
    BindingTest(pCmdTree, TRUE);

    CategTest(0, pRowsetCateg, pRowset, cBasicTestCols);

    pCmdTree->Release();
    pRowset->Release();
    pRowsetCateg->Release();
} //SingleLevelCategTest


#define MAX_CHAPT_LENGTH     32

static DBBINDING aCategCols[] =
{
  {
    0, sizeof DBLENGTH,
    0, 0,
    0,0,0,
    DBPART_VALUE|DBPART_LENGTH,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    MAX_CHAPT_LENGTH,
    0, DBTYPE_BYTES,
    0,0 },
};

const ULONG cCategCols = sizeof aCategCols / sizeof aCategCols[0];

static DBBINDING aSizeCol[] =
{
  {
    0, 0,
    0, 0,
    0,0,0,
    DBPART_VALUE,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    sizeof LONGLONG,
    0, DBTYPE_UI8,
    0, 0 },
};

static DBBINDING aAttrCol[] =
{
  {
    0, 0,
    0, 0,
    0,0,0,
    DBPART_VALUE,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    sizeof LONG,
    0, DBTYPE_I4,
    0, 0 },
};

struct ChaptBinding
{
    DBLENGTH len;
    ULONG    chapt; // because I know the first 4 bytes are the chapt
    char     abChapt[MAX_CHAPT_LENGTH - sizeof ULONG];
};

void CategTest(
    HCHAPTER  hUpperChapt,
    IRowset * pRowsetCateg,
    IRowset * pRowset,
    unsigned  cCols )
{
    LogProgress( " Categorization test\n" );

    BOOL fBackwardFetch = GetBooleanProperty( pRowset, DBPROP_CANFETCHBACKWARDS );
    BOOL fCanHoldRows   = GetBooleanProperty( pRowset, DBPROP_CANHOLDROWS );

    if ( !fBackwardFetch || !fCanHoldRows )
        LogProgress("WARNING: Categorized backward fetch test disabled\n");

    IUnknown * pAccessor = pRowsetCateg;

    HACCESSOR hAccCateg = MapColumns( pAccessor,
                                      cCategCols, aCategCols, &psChapt);

    HACCESSOR hAccSize = MapColumns( pRowsetCateg,
                                     1, aSizeCol, &psSize);

    IRowsetLocate * pRLC = 0;
    SCODE sc = pRowsetCateg->QueryInterface( IID_IRowsetLocate,
                                             (void **)&pRLC);

    if (FAILED(sc) || pRLC == 0)
        LogFail("QueryInterface to IRowsetLocate failed\n");

    IRowsetIdentity * pRowsetIdentity = 0;
    sc = pRowsetCateg->QueryInterface( IID_IRowsetIdentity,
                                       (void **)&pRowsetIdentity);

    if (FAILED(sc) && (sc != E_NOINTERFACE || pRowsetIdentity != 0)) {
        LogError("QueryInterface to IRowsetIdentity failed (%x)\n", sc);
        pRowsetIdentity = 0;
        cFailures++;
    }

    IChapteredRowset * pChapteredRowset = 0;
    sc = pRowset->QueryInterface( IID_IChapteredRowset,
                                  (void **)&pChapteredRowset);

    if (FAILED(sc)) {
        LogError("QueryInterface to IChapteredRowset failed (%x)\n", sc);
        pChapteredRowset = 0;
        cFailures++;
    }

    IRowsetScroll * pRS = 0;
    sc = pRowset->QueryInterface( IID_IRowsetScroll,
                                  (void **)&pRS);

    if (FAILED(sc) || pRS == 0)
        LogFail("QueryInterface to IRowsetScroll failed\n");

    SCODE scHier = S_OK;
    HROW ahRows[10];
    HROW* phRows = ahRows;
    DBCOUNTITEM cCategories = 0;
    DBCOUNTITEM cRowsTotal = 0;
    DBCOUNTITEM cRowsReturned = 0;

    LONGLONG llSizePrev = -1;

    while (scHier != DB_S_ENDOFROWSET)
    {
        scHier = pRLC->GetNextRows( hUpperChapt, 0, 10, &cRowsReturned, &phRows);
        if (FAILED(scHier))
            LogFail("pRLC->GetNextRows failed: 0x%lx\n", scHier);

        if ( 0 == cRowsReturned )
        {
            if ( DB_S_ENDOFROWSET != scHier )
                LogFail("pRLC->GetNextRows bad return at end of rowset: 0x%lx\n", scHier);
            continue;
        }

        cCategories += cRowsReturned;
        HCHAPTER hLastChapter = DB_NULL_HCHAPTER;

        for (ULONG row = 0; row < cRowsReturned; row++)
        {
            ChaptBinding data;

            SCODE sc = pRLC->GetData(phRows[row], hAccCateg, &data);
            if ( FAILED( sc ) )
                LogFail("Can't get category data in CategTest()\n");

            LONGLONG llSize;
            sc = pRLC->GetData(phRows[row], hAccSize, &llSize);
            if ( FAILED( sc ) )
                LogFail("Can't get size data in CategTest()\n");

            if (fVerbose > 1)
                printf( "  category, file size: %lx, %d\n",
                        data.chapt,
                        (int) llSize );

            if ( llSize == llSizePrev )
                LogFail("Duplicate size categories\n");

            if ( llSizePrev > llSize )
                LogFail("categories unsorted by size\n");

            llSizePrev = llSize;

            DBCOUNTITEM cRows;
            sc = pRS->GetApproximatePosition( data.chapt, 0, 0, 0, &cRows );
            if ( FAILED( sc ) )
                LogFail("GetApproximatePosition with chapter failed %x\n", sc);
            cRowsTotal += cRows;

            // then test fetching rows in the category

            BasicTest(pRowset, FALSE, data.chapt, cCols, FALSE);
            MoveTest(pRowset, data.chapt);
            if (cCategories == cRowsReturned && 0 == row &&
                DB_NULL_HCHAPTER == hUpperChapt)
            {
                // Do testing on entire base rowset
                BasicTest(pRowset, FALSE, DB_NULL_HCHAPTER, cCols, FALSE);
                MoveTest(pRowset, DB_NULL_HCHAPTER);
            }

            if (pChapteredRowset && row != (cRowsReturned - 1))
            {
                ULONG ulRefCnt = 10;
                sc = pChapteredRowset->ReleaseChapter( data.chapt, &ulRefCnt );
                
                if ( FAILED( sc ) )
                {
                    LogError("ReleaseChapter failed, sc = %x\n", sc);
                    cFailures++;
                }
                else if ( ulRefCnt != 0 )
                {
                    LogError("ReleaseChapter returned bad refcount: got %d, exp 0\n", ulRefCnt);
                    cFailures++;
                }
            }
            else
                hLastChapter = data.chapt;
        }

        if (pChapteredRowset)
        {
            ULONG ulRefCnt = 10;
            sc = pChapteredRowset->AddRefChapter( hLastChapter, &ulRefCnt );
            
            if ( FAILED( sc ) )
            {
                LogError("AddRefChapter failed, sc = %x\n", sc);
                cFailures++;
            }
            else if ( ulRefCnt != 2 )
            {
                LogError("AddRefChapter returned bad refcount: %d\n", ulRefCnt);
                cFailures++;
            }
        }
        if ( fBackwardFetch && fCanHoldRows )
        {
            HROW  ahRows2[10];
            HROW* phRows2 = ahRows2;
            DBCOUNTITEM cRowsRet2 = 0;
            DBROWOFFSET oRows = - (DBROWOFFSET)cRowsReturned;

            // fetch the categories BACKWARD to test GetNextRows behavior
            // over chapters.
            sc = pRLC->GetNextRows( hUpperChapt, 0, oRows,
                                    &cRowsRet2, &phRows2);
            if (FAILED(sc))
                LogFail("pRLC->GetNextRows backward fetch failed: 0x%lx\n", sc);
    
            if ( cRowsRet2 != cRowsReturned )
            {
                LogFail("pRLC->GetNextRows different row count on fwd/bkwd fetch: %d %d\n",
                         cRowsReturned, cRowsRet2);
            }

            // The first row retrieved in ahRows2 is the last retrieved in
            // ahRows.  Fetch the chapter again and check its refcount to see
            // if it was collapsed properly.
            if (pChapteredRowset)
            {
                ChaptBinding data;
    
                sc = pRLC->GetData(phRows2[0], hAccCateg, &data);
                if ( FAILED( sc ) )
                    LogFail("Can't re-fetch category data in CategTest()\n");

                ULONG ulRefCnt = 10;
                sc = pChapteredRowset->ReleaseChapter( data.chapt, &ulRefCnt );
                
                if ( FAILED( sc ) )
                {
                    LogError("ReleaseChapter failed on chapt refetch, sc = %x\n", sc);
                    cFailures++;
                }
                else if ( ulRefCnt != 2 )
                {
                    LogError("ReleaseChapter returned bad refcount: got %d, exp 2\n", ulRefCnt);
                    cFailures++;
                }
                else
                {
                    pChapteredRowset->ReleaseChapter( data.chapt, &ulRefCnt );
                    pChapteredRowset->ReleaseChapter( data.chapt, &ulRefCnt );
                }
            }

            // Reverse the order of the rows for HROW identity check
            unsigned i, j;
            for (i=0, j=(unsigned)(cRowsRet2-1); i < j; i++, j--)
            {
                HROW hrTmp = ahRows2[i];
                ahRows2[i] = ahRows2[j];
                ahRows2[j] = hrTmp;
            }
            
            int cFailed = CheckHrowIdentity( pRowsetIdentity, 0,
                                             cRowsReturned, ahRows,
                                             cRowsRet2, ahRows2 );
            if ( cFailed > 0 )
            {
                LogFail( "Backwards category fetch CheckHrowIdentity returned %d\n", cFailed );
            }

            // Release first row in handle array, use that position to refetch
            // last row in array.
            sc = pRLC->ReleaseRows( 1, phRows2, 0, 0, 0 );
    
            DBCOUNTITEM cRowsRet3 = 0;
            sc = pRLC->GetNextRows( hUpperChapt, cRowsRet2-1, 1,
                                    &cRowsRet3, &phRows2);
            if (FAILED(sc))
                LogFail("pRLC->GetNextRows re-fetch failed: 0x%lx\n", sc);
    
            if ( cRowsRet3 != 1 )
            {
                LogFail("pRLC->GetNextRows unexpected row count on re-fetch: %d\n",
                         cRowsRet3);
            }
            cFailed = CheckHrowIdentity( pRowsetIdentity, cRowsRet2-1,
                                         1, ahRows2,
                                         1, ahRows2 );
            if ( cFailed > 0 )
            {
                LogFail( "Category re-fetch CheckHrowIdentity returned %d\n", cFailed );
            }
            sc = pRLC->ReleaseRows( cRowsRet2, phRows2, 0, 0, 0 );
        }

        sc = pRLC->ReleaseRows( cRowsReturned, phRows, 0, 0, 0 );
    }

    if (cCategories == 0)
        LogFail("No categories found\n");

    DBCOUNTITEM cRows;
    sc = pRS->GetApproximatePosition( DB_NULL_HCHAPTER, 0, 0, 0, &cRows );
    if ( FAILED( sc ) )
        LogFail("GetApproximatePosition with NULL chapter failed %x\n", sc);

    if (DB_NULL_HCHAPTER == hUpperChapt && cRowsTotal != cRows)
        LogFail("Sum of rows in chapters(%d) is not same as total rows(%d)\n",
                cRowsTotal, cRows);
    if (DB_NULL_HCHAPTER != hUpperChapt && cRowsTotal > cRows)
        LogFail("Sum of rows in chapters(%d) is greater than total rows(%d)\n",
                cRowsTotal, cRows);

    ReleaseAccessor( pAccessor, hAccCateg );
    ReleaseAccessor( pRowsetCateg, hAccSize );

    pRLC->Release();
    pRS->Release();
    if (pRowsetIdentity)
        pRowsetIdentity->Release();
    if (pChapteredRowset)
        pChapteredRowset->Release();

} //CategTest
#endif // DO_CATEG_TESTS


#ifdef DO_MULTI_LEVEL_CATEG_TEST

void UpperLevelCategTest(
    IRowset *pRowsetUpperCateg,
    IRowset *pRowsetLowerCateg,
    IRowset *pRowset,
    unsigned cCols)
{
    LogProgress( " Upper Level Categorization test\n" );

    HACCESSOR hAccCateg = MapColumns( pRowsetUpperCateg,
                                      cCategCols, aCategCols, &psChapt);

    HACCESSOR hAccAttr = MapColumns( pRowsetUpperCateg,
                                     1, aAttrCol, &psAttr);

    IRowsetLocate * pRLUC = 0;
    SCODE sc = pRowsetUpperCateg->QueryInterface( IID_IRowsetLocate,
                                             (void **)&pRLUC);

    if (FAILED(sc) || pRLUC == 0)
        LogFail("QueryInterface to IRowsetLocate failed\n");

    IRowsetScroll * pRSLC = 0;
    sc = pRowsetLowerCateg->QueryInterface( IID_IRowsetScroll,
                                            (void **)&pRSLC);

    if (FAILED(sc) || pRSLC == 0)
        LogFail("QueryInterface to IRowsetScroll failed\n");
    SCODE scHier = S_OK;
    HROW ahRows[10];
    HROW* phRows = ahRows;
    ULONG cCategories = 0;
    DBCOUNTITEM cRowsTotal = 0;
    DBCOUNTITEM cRowsReturned = 0;

    LONG lAttrPrev = 0xffffffff;

    while (scHier != DB_S_ENDOFROWSET)
    {
        scHier = pRLUC->GetNextRows(0, 0, 10, &cRowsReturned, &phRows);
        if (FAILED(scHier))
            LogFail("pRLUC->GetNextRows failed: 0x%lx\n", scHier);

        cCategories += (ULONG) cRowsReturned;

        for (ULONG row = 0; row < cRowsReturned; row++)
        {
            ChaptBinding data;

            SCODE sc = pRLUC->GetData(phRows[row],hAccCateg,&data);
            if ( FAILED( sc ) )
                LogFail("GetData in UpperLevelCategTest failed: 0x%lx\n",sc);

            LONG lAttr;
            sc = pRLUC->GetData(phRows[row],hAccAttr,&lAttr);
            if ( FAILED( sc ) )
                LogFail("GetData in UpperLevelCategTest failed: 0x%lx\n",sc);

            if (fVerbose > 1)
                printf( "upper level category, attr:: %lx, %lx\n",
                        data.chapt,
                        lAttr );

            if ( lAttrPrev == lAttr )
                LogFail("duplicate attrib categories\n");

            if ( lAttrPrev > lAttr )
                LogFail("categories unsorted by attrib\n");

            lAttrPrev = lAttr;

            DBCOUNTITEM cRows;
            sc = pRSLC->GetApproximatePosition( data.chapt, 0, 0, 0, &cRows );
            if ( FAILED( sc ) )
                LogFail("GetApproximatePosition with chapter failed %x\n", sc);
            cRowsTotal += cRows;

            // then test fetching rows in the category

            MoveTest( pRowsetLowerCateg,
                      data.chapt );

            CategTest( data.chapt,
                       pRowsetLowerCateg,
                       pRowset,
                       cCols );
        }

        sc = pRLUC->ReleaseRows( cRowsReturned, phRows, 0, 0, 0 );
    }

    if (cCategories == 0)
        LogFail("No categories found\n");

    DBCOUNTITEM cRows;
    sc = pRSLC->GetApproximatePosition( DB_NULL_HCHAPTER, 0, 0, 0, &cRows );
    if ( FAILED( sc ) )
        LogFail("GetApproximatePosition with NULL chapter failed %x\n", sc);
    if (cRowsTotal != cRows)
        LogFail("Sum of rows in chapters(%d) is not same as total rows(%d)\n",
                cRowsTotal, cRows);

    ReleaseAccessor( pRLUC, hAccCateg );
    ReleaseAccessor( pRLUC, hAccAttr );

    pRSLC->Release();
    pRLUC->Release();
} //UpperLevelCategTest

//+-------------------------------------------------------------------------
//
//  Function:   MultiLevelCategTest, public
//
//  Synopsis:   Basic query categorization feature test.
//
//  History:    30 Mar 95       dlee     Created
//
//  Notes:      Just looks for files in the system directory.
//
//--------------------------------------------------------------------------

void MultiLevelCategTest()
{
    LogProgress( "Non-content multi-level categorization query\n" );

    SCODE sc;

    WCHAR wcsSysDir[MAX_PATH];

#if 0
    wcscpy(wcsSysDir,L"g:\\winnt\\system32");
#else
    if( !GetSystemDirectory( wcsSysDir, sizeof(wcsSysDir) / sizeof(WCHAR) ) )
        LogFail( "Unable to determine system directory.\n" );
#endif

    //
    // Get name, size and class id for *.exe, *.dll, *.doc, and *.sys
    // Group on attribute, then size.
    //
    CDbColumns cols(8);

    cols.Add( psClassid, 0 );
    cols.Add( psSize, 1 );
    cols.Add( psWriteTime, 2 );
    cols.Add( psAttr, 3 );
    cols.Add( psName, 4 );
    cols.Add( psPath, 5 );
    cols.Add( psSelf, 6 );
    cols.Add( psBookmark, 7);

    CDbNestingNode nest1;

    nest1.AddGroupingColumn( psAttr );

    nest1.AddParentColumn( psBookmark );
    nest1.AddParentColumn( psAttr );

    CDbNestingNode nest2;

    nest2.AddGroupingColumn( psSize );

    nest2.AddParentColumn( psBookmark );
    nest2.AddParentColumn( psSize );

    nest2.AddChildColumn( psClassid );
    nest2.AddChildColumn( psSize );
    nest2.AddChildColumn( psWriteTime );
    nest2.AddChildColumn( psAttr );
    nest2.AddChildColumn( psName );
    nest2.AddChildColumn( psPath );
    nest2.AddChildColumn( psSelf );
    nest2.AddChildColumn( psBookmark);

    CDbPropertyRestriction rst;

    rst.SetRelation( DBOP_like );
    rst.SetProperty( psName );
    rst.SetValue( L"*.|(exe|,dll|,doc|,sys|,zzz|)" );

    CDbSelectNode * pSelect = new CDbSelectNode();
    pSelect->AddRestriction( rst.Clone() );

    nest2.AddTable( pSelect );
    pSelect = 0;
    nest1.AddTable( nest2.Clone() );

    IRowset * pRowsets[3];
    ICommandTree * pCmdTree;

    InstantiateMultipleRowsets(
                            QUERY_SHALLOW,           // Depth
                            wcsSysDir,               // Scope
                            nest1.Clone(),           // DBCOMMANDTREE
                            IID_IRowsetScroll,       // IID for i/f to return
                            3,
                            (IUnknown **)pRowsets,
                            &pCmdTree );

    IRowset *pRowsetUpperCateg = pRowsets[0];
    IRowset *pRowsetLowerCateg = pRowsets[1];
    IRowset *pRowset = pRowsets[2];

    //
    // Verify columns
    //

    CDbColumns chapCols(4);

    chapCols.Add( psBookmark, 0 );
    chapCols.Add( psAttr, 1 );
    chapCols.Add( psChapt, 2 );

    CheckColumns( pRowsetUpperCateg, chapCols );

    chapCols.Add( psSize, 1 );
    chapCols.Add( psChapt, 2 );
    CheckColumns( pRowsetLowerCateg, chapCols );

    CheckColumns( pRowset, cols );

    if ( !WaitForCompletion( pRowset, FALSE ) )
    {
        pRowset->Release();
        LogFail( "Downlevel query unsuccessful.\n" );
    }

    //
    //  Do basic function tests.
    //
    FetchTest(pRowset);

    //
    // Test SetBindings, GetBindings, Move and Scroll
    //
    BindingTest(pRowset);
    BindingTest(pCmdTree, TRUE);

    MoveTest( pRowsetUpperCateg );

    UpperLevelCategTest( pRowsetUpperCateg,
                         pRowsetLowerCateg,
                         pRowset,
                         cBasicTestCols );

    pCmdTree->Release();

    pRowset->Release();

    pRowsetUpperCateg->Release();
    pRowsetLowerCateg->Release();

} //MultiLevelCategTest

#endif // DO_MULTI_LEVEL_CATEG_TEST

//+-------------------------------------------------------------------------
//
//  Function:   RunPropQuery, public
//
//  Synopsis:   Execute a retricted query and check results
//
//  History:
//
//--------------------------------------------------------------------------

static DBBINDING aPropTestColsByRef[] =
{
  { 0, 0 * (sizeof( PROPVARIANT * )), 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof( PROPVARIANT * ), 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0},
  { 1, 1 * (sizeof( PROPVARIANT * )), 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof( PROPVARIANT * ), 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0},
  { 2, 2 * (sizeof( PROPVARIANT * )), 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof( PROPVARIANT * ), 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0},
  { 3, 3 * (sizeof( PROPVARIANT * )), 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof( PROPVARIANT * ), 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0},
  { sizeof( PROPVARIANT * ), 4 * (sizeof( PROPVARIANT * )), 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof( PROPVARIANT * ), 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0},
  { 5, 5 * (sizeof( PROPVARIANT * )), 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof( PROPVARIANT * ), 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0},
  { 6, 6 * (sizeof( PROPVARIANT * )), 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof( PROPVARIANT * ), 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0},
  { 7, 7 * (sizeof( PROPVARIANT * )), 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof( PROPVARIANT * ), 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0},
  { 8, 8 * (sizeof( PROPVARIANT * )), 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof( PROPVARIANT * ), 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0},
  { 9, 9 * (sizeof( PROPVARIANT * )), 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof( PROPVARIANT * ), 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0},
  { 10,10* (sizeof( PROPVARIANT * )), 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof( PROPVARIANT * ), 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0},
  { 11,11* (sizeof( PROPVARIANT * )), 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof( PROPVARIANT * ), 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0},
  { 12,12* (sizeof( PROPVARIANT * )), 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof( PROPVARIANT * ), 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0},
  { 13,13* (sizeof( PROPVARIANT * )), 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof( PROPVARIANT * ), 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0},
};

const ULONG cPropTestColsByRef = sizeof aPropTestColsByRef /
                                 sizeof aPropTestColsByRef[0];


LPWSTR aPropTestColNames[] = {
    L"TestProp1",
    L"TestProp2",
    L"Author",
    L"Keywords",
    L"RelevantWords",
    L"MyBlob",
    L"MyGuid",
    L"ManyRW",
    L"SecurityTest",
    L"TestProp10",
    L"TestProp11",
    L"TestProp12",
    L"TestProp21",
    L"TestProp22",
    L"Path",
};


void RunPropQueryByRefBindings(
    ICommand * pQuery,
    CDbRestriction & PropRst,
    unsigned cExpectedHits,
    unsigned numTest )
{
    //
    // Get twelve properties back
    //

    CDbColumns cols(cPropTestColsByRef);
    cols.Add( psTestProperty1, 0 );
    cols.Add( psTestProperty2, 1 );
    cols.Add( psAuthor, 2 );
    cols.Add( psKeywords, 3 );
    cols.Add( psRelevantWords, 4 );
    cols.Add( psBlobTest, 5 );
    cols.Add( psGuidTest, 6 );
    cols.Add( psManyRW, 7 );
    cols.Add( psSecurityTest, 8 );
    cols.Add( psTestProperty10, 9 );
    cols.Add( psTestProperty11, 10 );
    cols.Add( psTestProperty12, 11 );
    cols.Add( psTestProperty21, 12 );
    cols.Add( psTestProperty22, 13 );
    if (isEven( numTest/2 ))
        cols.Add( psPath, cols.Count() );

    BOOL fSeq = isEven( numTest );

    CDbSortSet ss(cPropSortColumns);
    for (unsigned i = 0; i < cPropSortColumns; i++)
        ss.Add (aPropSortCols[i], i);

    //
    // Do it!
    //

    CDbCmdTreeNode * pDbCmdTree = FormQueryTree( &PropRst,
                                                 cols,
                                                 fSeq ? 0 : &ss,
                                                 aPropTestColNames );
    ICommandTree * pCmdTree = 0;

    IRowsetScroll * pRowset = InstantiateRowset(
                                pQuery,
                                QUERY_SHALLOW,          // Depth
                                0,                      // Scope
                                pDbCmdTree,             // DBCOMMANDTREE
                                fSeq ? IID_IRowset : IID_IRowsetScroll,   // IID for i/f to return
                                0,
                                &pCmdTree );

    //
    // Verify columns
    //
    CheckColumns( pRowset, cols, TRUE );

    if ( !WaitForCompletion( pRowset, TRUE ) )
    {
        LogError( "property query unsuccessful.\n" );
        pCmdTree->Release();
        pRowset->Release();
        Fail();
    }

    //
    // Get data
    //

    DBCOUNTITEM cRowsReturned = 0;
    HROW* pgrhRows = 0;

    SCODE sc = pRowset->GetNextRows(0, 0, 10, &cRowsReturned, &pgrhRows);

    if ( FAILED( sc ) )
    {
        LogError( "IRowset->GetRowsAt A returned 0x%x\n", sc );
        pCmdTree->Release();
        pRowset->Release();
        Fail();
    }

    if ( 0 == cExpectedHits )
    {
        pCmdTree->Release();
        pRowset->Release();

        if ( cRowsReturned > 0 )
            LogFail("RunPropQueryByRefBindings, %d returned rows, expected 0\n",
                    cRowsReturned);
        else
            return;

    }

    if (sc != DB_S_ENDOFROWSET &&
        cRowsReturned != 10)
    {
        LogError( "IRowset->GetRowsAt B returned %d of %d rows,"
                " status (%x) != DB_S_ENDOFROWSET\n",
                    cRowsReturned, 10,
                    sc);
        pCmdTree->Release();
        pRowset->Release();
#if defined(UNIT_TEST)
        cFailures++;
        return;
#else
        Fail();
#endif
    }

    //
    //  Expect 1 or 2 hits
    //
    if (sc != DB_S_ENDOFROWSET || cRowsReturned != cExpectedHits)
    {
        LogError( "IRowset->GetRowsAt C returned %d rows (expected %d),"
                 " status (%x)\n",
                cRowsReturned, cExpectedHits, sc );
        pCmdTree->Release();
        pRowset->Release();
#if defined(UNIT_TEST)
        cFailures++;
        return;
#else
        Fail();
#endif
    }

    //
    // Patch the column index numbers with true column ids
    //

    DBID aDbCols[cPropTestColsByRef];
    aDbCols[0] = psTestProperty1;
    aDbCols[1] = psTestProperty2;
    aDbCols[2] = psAuthor;
    aDbCols[3] = psKeywords;
    aDbCols[4] = psRelevantWords;
    aDbCols[5] = psBlobTest;
    aDbCols[6] = psGuidTest;
    aDbCols[7] = psManyRW;
    aDbCols[8] = psSecurityTest;
    aDbCols[9] = psTestProperty10;
    aDbCols[10] = psTestProperty11;
    aDbCols[11] = psTestProperty12;
    aDbCols[12] = psTestProperty21;
    aDbCols[13] = psTestProperty22;

    IUnknown * pAccessor = (IUnknown *) pRowset; // hAccessor must be created on rowset
                                 // to be used with rowset->GetData below

    HACCESSOR hAccessor = MapColumns( pAccessor, cPropTestColsByRef,
                                      aPropTestColsByRef, aDbCols, TRUE);

    //
    // Fetch the data
    //

    PROPVARIANT * aVarnt[cPropTestColsByRef];

    for (unsigned row = 0; row < cRowsReturned; row++)
    {
        sc = pRowset->GetData(pgrhRows[row], hAccessor, aVarnt);

        if (S_OK != sc)
        {
            LogError("IRowset->GetData returned 0x%x (expected 0)\n",sc);
            pCmdTree->Release();
            pRowset->Release();
            Fail();
        }

        //
        // Verify the data.
        //

        // Ascending sort, prop1 > prop1Alternate.
        // If one hit, it's PROP1_VAL, not the alternate.
        // prop1=1234, alternate=123

        BOOL fAlternate = FALSE;
        if ( fSeq )
        {
            if ( 1 == cRowsReturned )
            {
                varProp1.lVal = PROP1_VAL;
                CheckPropertyValue( *aVarnt[0], varProp1 );
            }
            else
            {
                // no sort order -- it's either prop1 or alternate

                if ( PROP1_TYPE != aVarnt[0]->vt )
                    LogFail( "bad datatype for prop1: 0x%x\n", aVarnt[0]->vt );

                if ( PROP1_VAL != aVarnt[0]->lVal &&
                     PROP1_VAL_Alternate != aVarnt[0]->lVal )
                    LogFail( "bad value for prop1: 0x%x\n", aVarnt[0]->lVal );
                fAlternate = aVarnt[0]->lVal == PROP1_VAL_Alternate;
            }
        }
        else
        {
            fAlternate = (0 == row) && (1 != cRowsReturned);
            varProp1.lVal = fAlternate ?
                            PROP1_VAL_Alternate :
                            PROP1_VAL;
            CheckPropertyValue( *aVarnt[0], varProp1 );
        }

        CheckPropertyValue( *aVarnt[1], varProp2 );
        CheckPropertyValue( *aVarnt[2], varProp3 );
        CheckPropertyValue( *aVarnt[3], varProp4 );
        CheckPropertyValue( *aVarnt[4], varProp5 );
        CheckPropertyValue( *aVarnt[5], varProp6 );
        CheckPropertyValue( *aVarnt[6], varProp7 );
        CheckPropertyValue( *aVarnt[7], fAlternate ? varProp8A : varProp8 );
        CheckPropertyValue( *aVarnt[8], varProp9 );
        CheckPropertyValue( *aVarnt[9], varProp10 );
        if ( aVarnt[10]->vt == VT_BSTR &&
             SysStringLen( aVarnt[10]->bstrVal) < 1000 )
        {
            CheckPropertyValue( *aVarnt[10], varProp11 );
        }
        else
        {
            CheckPropertyValue( *aVarnt[10], varProp11A );
        }
        CheckPropertyValue( *aVarnt[11], varProp12 );
        CheckPropertyValue( *aVarnt[12], varProp21 );
        CheckPropertyValue( *aVarnt[13], varProp22 );
    }

    sc = pRowset->ReleaseRows( cRowsReturned, pgrhRows, 0, 0, 0);

    if (S_OK != sc)
    {
        LogError("IRowset->ReleaseRows returned 0x%x (expected 0)\n",sc);
        pCmdTree->Release();
        pRowset->Release();
        Fail();
    }

    CoTaskMemFree(pgrhRows);
    pgrhRows = 0;

    //
    // Clean up.
    //

    ReleaseAccessor( pAccessor, hAccessor);

    pCmdTree->Release();
    pRowset->Release();
} //RunPropQueryByRefBindings

struct SPropTestColsTight
{
    int         p1_i4;
    WCHAR *     p2_pwc;
    WCHAR *     p3_pwc;
    int         dummy1;  // vectors need 8 byte alignment
    DBVECTOR    p4_vpwc;
    DBVECTOR    p5_vi;
    PROPVARIANT* p6_pvar;
    GUID *      p7_pguid;
    DBVECTOR    p8_vi;
    SAFEARRAY * p8a_ai;
    int         p9_i4;
    WCHAR *     p10_pwc;
    BSTR        p11_pwc;
    DBVECTOR    p12_vpwc;
    CLIPDATA *  p21_pclipdata;
    int         dummy3;  // vectors need 8 byte alignment
    CACLIPDATA  p22_caclipdata;
    WCHAR *     p2a_pwc;

    DBLENGTH    p1_cb;
    DBLENGTH    p2_cb;
    DBLENGTH    p3_cb;
    DBLENGTH    p4_cb;
    DBLENGTH    p5_cb;
    DBLENGTH    p6_cb;
    DBLENGTH    p7_cb;
    DBLENGTH    p8_cb;
    DBLENGTH    p8a_cb;
    DBLENGTH    p9_cb;
    DBLENGTH    p10_cb;
    DBLENGTH    p11_cb;
    DBLENGTH    p12_cb;
    DBLENGTH    p21_cb;
    DBLENGTH    p22_cb;
    DBLENGTH    p2a_cb;

    ULONG       p1_status;
    ULONG       p2_status;
    ULONG       p3_status;
    ULONG       p4_status;
    ULONG       p5_status;
    ULONG       p6_status;
    ULONG       p7_status;
    ULONG       p8_status;
    ULONG       p8a_status;
    ULONG       p9_status;
    ULONG       p10_status;
    ULONG       p11_status;
    ULONG       p12_status;
    ULONG       p21_status;
    ULONG       p22_status;
    ULONG       p2a_status;
};

#define DBTYPE_BRWSTR ( DBTYPE_BYREF | DBTYPE_WSTR )

static DBBINDING aPropTestColsTight[] =
{
  { 0,
    offsetof(SPropTestColsTight,p1_i4),
    offsetof(SPropTestColsTight,p1_cb),
    offsetof(SPropTestColsTight,p1_status),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    sizeof ULONG, 0,
    DBTYPE_I4,
    0, 0 },
  { 1,
    offsetof(SPropTestColsTight,p2_pwc),
    offsetof(SPropTestColsTight,p2_cb),
    offsetof(SPropTestColsTight,p2_status),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof (WCHAR *), 0,
    DBTYPE_BRWSTR,
    0, 0 },
  { 2,
    offsetof(SPropTestColsTight,p3_pwc),
    offsetof(SPropTestColsTight,p3_cb),
    offsetof(SPropTestColsTight,p3_status),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof (WCHAR *), 0,
    DBTYPE_BRWSTR,
    0, 0 },
  { 3,
    offsetof(SPropTestColsTight,p4_vpwc),
    offsetof(SPropTestColsTight,p4_cb),
    offsetof(SPropTestColsTight,p4_status),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof DBVECTOR, 0,
    DBTYPE_VECTOR|VT_LPWSTR,
    0, 0 },
  { 4,
    offsetof(SPropTestColsTight,p5_vi),
    offsetof(SPropTestColsTight,p5_cb),
    offsetof(SPropTestColsTight,p5_status),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof DBVECTOR, 0,
    DBTYPE_VECTOR|DBTYPE_I4,
    0, 0 },
  { 5,
    offsetof(SPropTestColsTight,p6_pvar),
    offsetof(SPropTestColsTight,p6_cb),
    offsetof(SPropTestColsTight,p6_status),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof (PROPVARIANT *), 0,
    DBTYPE_VARIANT|DBTYPE_BYREF,
    0, 0 },
  { 6,
    offsetof(SPropTestColsTight,p7_pguid),
    offsetof(SPropTestColsTight,p7_cb),
    offsetof(SPropTestColsTight,p7_status),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof (GUID *), 0,
    DBTYPE_GUID|DBTYPE_BYREF,
    0, 0 },
  { 7,
    offsetof(SPropTestColsTight,p8_vi),
    offsetof(SPropTestColsTight,p8_cb),
    offsetof(SPropTestColsTight,p8_status),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof DBVECTOR, 0,
    DBTYPE_VECTOR|DBTYPE_I4,
    0, 0 },
  { 8,
    offsetof(SPropTestColsTight,p9_i4),
    offsetof(SPropTestColsTight,p9_cb),
    offsetof(SPropTestColsTight,p9_status),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    sizeof ULONG, 0,
    DBTYPE_I4,
    0, 0 },
  { 9,
    offsetof(SPropTestColsTight,p10_pwc),
    offsetof(SPropTestColsTight,p10_cb),
    offsetof(SPropTestColsTight,p10_status),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof (WCHAR *), 0,
    DBTYPE_BRWSTR,
    0, 0 },
  { 10,
    offsetof(SPropTestColsTight,p11_pwc),
    offsetof(SPropTestColsTight,p11_cb),
    offsetof(SPropTestColsTight,p11_status),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof (BSTR), 0,
    DBTYPE_BSTR,
    0, 0 },
  { 11,
    offsetof(SPropTestColsTight,p12_vpwc),
    offsetof(SPropTestColsTight,p12_cb),
    offsetof(SPropTestColsTight,p12_status),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof DBVECTOR, 0,
    DBTYPE_VECTOR|DBTYPE_BSTR,
    0, 0 },
  { 12,
    offsetof(SPropTestColsTight,p21_pclipdata),
    offsetof(SPropTestColsTight,p21_cb),
    offsetof(SPropTestColsTight,p21_status),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof( CLIPDATA * ), 0,
    VT_CF | DBTYPE_BYREF,
    0, 0 },
  { 13,
    offsetof(SPropTestColsTight,p22_caclipdata),
    offsetof(SPropTestColsTight,p22_cb),
    offsetof(SPropTestColsTight,p22_status),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof CACLIPDATA, 0,
    DBTYPE_VECTOR | VT_CF,
    0, 0 },
  { 14,         // Prop 2 again, as a different type
    offsetof(SPropTestColsTight,p2a_pwc),
    offsetof(SPropTestColsTight,p2a_cb),
    offsetof(SPropTestColsTight,p2a_status),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    30, 0,
    DBTYPE_WSTR | DBTYPE_BYREF,
    0, 0 },
  { 15,         // Prop 8 again, as a different type
    offsetof(SPropTestColsTight,p8a_ai),
    offsetof(SPropTestColsTight,p8a_cb),
    offsetof(SPropTestColsTight,p8a_status),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof (SAFEARRAY *), 0,
    DBTYPE_ARRAY|DBTYPE_I4,
    0, 0 },
};

const ULONG cPropTestColsTight = sizeof aPropTestColsTight /
                                 sizeof aPropTestColsTight[0];

void RunPropQueryTightBindings(
    ICommand * pQuery,
    CDbRestriction & PropRst,
    unsigned cExpectedHits,
    unsigned numTest )
{
    //
    // Get twelve properties back
    //

    CDbColumns cols(cPropTestColsTight);
    cols.Add( psTestProperty1, 0 );
    cols.Add( psTestProperty2, 1 );
    cols.Add( psAuthor, 2 );
    cols.Add( psKeywords, 3 );
    cols.Add( psRelevantWords, 4 );
    cols.Add( psBlobTest, 5 );
    cols.Add( psGuidTest, 6 );
    cols.Add( psManyRW, 7 );
    cols.Add( psSecurityTest, 8 );
    cols.Add( psTestProperty10, 9 );
    cols.Add( psTestProperty11, 10 );
    cols.Add( psTestProperty12, 11 );
    cols.Add( psTestProperty21, 12 );
    cols.Add( psTestProperty22, 13 );

    CDbSortSet ss(cPropSortColumns);
    for (unsigned i = 0; i < cPropSortColumns; i++)
        ss.Add (aPropSortCols[i], i);

    //
    // Do it!
    //

    CDbCmdTreeNode * pDbCmdTree = FormQueryTree(&PropRst, cols, &ss);
    ICommandTree * pCmdTree = 0;

    IRowsetScroll * pRowset = InstantiateRowset(
                                pQuery,
                                QUERY_SHALLOW,          // Depth
                                0,                      // Scope
                                pDbCmdTree,             // DBCOMMANDTREE
                                IID_IRowsetScroll,      // IID for i/f to return
                                0,
                                &pCmdTree,
                                TRUE );

    //
    // Verify columns
    //
    CheckColumns( pRowset, cols, TRUE );

    if ( !WaitForCompletion( pRowset, TRUE ) )
    {
        LogError( "property query unsuccessful.\n" );
        pCmdTree->Release();
        pRowset->Release();
        Fail();
    }

    //
    // Get data
    //

    DBCOUNTITEM cRowsReturned = 0;
    HROW* pgrhRows = 0;

    SCODE sc = pRowset->GetRowsAt(0,0, 1, &bmkFirst, 0, 10, &cRowsReturned,
                                  &pgrhRows);

    if ( FAILED( sc ) )
    {
        LogError( "IRowset->GetRowsAt D returned 0x%x\n", sc );
        pCmdTree->Release();
        pRowset->Release();
        Fail();
    }

    if ( 0 == cExpectedHits )
    {
        pCmdTree->Release();
        pRowset->Release();

        if ( cRowsReturned > 0 )
        {
            LogError("RunPropQueryTightBindings, %d returned rows, expected 0\n",
                    cRowsReturned);
#if defined(UNIT_TEST)
            cFailures++;
            return;
#else
            Fail();
#endif
        }
        else
            return;

    }

    if (sc != DB_S_ENDOFROWSET &&
        cRowsReturned != 10)
    {
        LogError( "IRowset->GetRowsAt E returned %d of %d rows,"
                " status (%x) != DB_S_ENDOFROWSET\n",
                    cRowsReturned, 10,
                    sc);
        pCmdTree->Release();
        pRowset->Release();
#if defined(UNIT_TEST)
        cFailures++;
        return;
#else
        Fail();
#endif
    }

    //
    //  Expect 1 or 2 hits
    //
    if (sc != DB_S_ENDOFROWSET || cRowsReturned != cExpectedHits)
    {
        LogError( "IRowset->GetRowsAt F returned %d rows (expected %d),"
                 " status (%x)\n",
                cRowsReturned, cExpectedHits, sc );
        pCmdTree->Release();
        pRowset->Release();
#if defined(UNIT_TEST)
        cFailures++;
        return;
#else
        Fail();
#endif
    }

    //
    // Patch the column index numbers with true column ids
    //

    DBID aDbCols[cPropTestColsTight];
    aDbCols[0] = psTestProperty1;
    aDbCols[1] = psTestProperty2;
    aDbCols[2] = psAuthor;
    aDbCols[3] = psKeywords;
    aDbCols[4] = psRelevantWords;
    aDbCols[5] = psBlobTest;
    aDbCols[6] = psGuidTest;
    aDbCols[7] = psManyRW;
    aDbCols[8] = psSecurityTest;
    aDbCols[9] = psTestProperty10;
    aDbCols[10] = psTestProperty11;
    aDbCols[11] = psTestProperty12;
    aDbCols[12] = psTestProperty21;
    aDbCols[13] = psTestProperty22;
    aDbCols[14] = psTestProperty2;      // repeated
    aDbCols[15] = psManyRW;             // repeated


    IUnknown * pAccessor = (IUnknown *) pRowset;  // hAccessor must be created on rowset
                                 // to be used with rowset->GetData below

    HACCESSOR hAccessor = MapColumns( pAccessor, cPropTestColsTight,
                                      aPropTestColsTight, aDbCols, TRUE);

    //
    // Fetch the data
    //

    for (unsigned row = 0; row < cRowsReturned; row++)
    {
        SPropTestColsTight sRow;

        // Ascending sort, prop1 > prop1Alternate.
        // If one hit, it's not the alternate.

        BOOL fAlternate = (0 == row) && (1 != cRowsReturned);

        sc = pRowset->GetData( pgrhRows[row], hAccessor, & sRow );

        // Either the conversion of varProp8 to array will fail, or the
        // conversion of varProp8A to vector will fail.
        if (DB_S_ERRORSOCCURRED != sc && !fAlternate)
        {
            LogError("IRowset->GetData returned 0x%x (expected 0)\n",sc);
            LogError("IRowset->GetData returned 0x%x (expected 0x40eda)\n",sc);
            if (S_OK != sc &&
                DB_E_ERRORSOCCURRED != sc)
            {
                pCmdTree->Release();
                pRowset->Release();
                Fail();
            }
        }

        if (DB_S_ERRORSOCCURRED != sc && fAlternate)
        {
            // Prop 8 should fail to convert for alternate row.
            LogError("IRowset->GetData returned 0x%x (expected 0x40eda)\n",sc);
            if (S_OK != sc && DB_E_ERRORSOCCURRED != sc)
            {
                pCmdTree->Release();
                pRowset->Release();
                Fail();
            }
        }

        //
        // Verify the data.  Put output data into variants for comparison
        //

        PROPVARIANT vTest;

        if ( DBSTATUS_S_OK != sRow.p1_status )
            LogFail( "status of property 1 is bad: %x\n", sRow.p1_status );
        varProp1.lVal = fAlternate ? PROP1_VAL_Alternate : PROP1_VAL;
        vTest.vt = DBTYPE_I4;
        vTest.iVal = (SHORT) sRow.p1_i4;
        CheckPropertyValue( vTest, varProp1 );
        if ( sRow.p1_cb != PROP1_cb )
            LogFail( "cb of property 1 is %ld, should be %ld\n",
                     sRow.p1_cb, PROP1_cb );

        if ( DBSTATUS_S_OK != sRow.p2_status )
            LogFail( "status of property 2 is bad: %x\n", sRow.p2_status );
        vTest.vt = VT_LPWSTR;
        vTest.pwszVal = sRow.p2_pwc;
        CheckPropertyValue( vTest, varProp2 );
        if ( sRow.p2_cb != PROP2_cb )
            LogFail( "cb of property 2 is %ld, should be %ld\n",
                     sRow.p2_cb, PROP2_cb );

        if ( DBSTATUS_S_OK != sRow.p3_status )
            LogFail( "status of property 3 is bad: %x\n", sRow.p3_status );
        vTest.vt = VT_LPWSTR;
        vTest.pwszVal = sRow.p3_pwc;
        CheckPropertyValue( vTest, varProp3 );
        if ( sRow.p3_cb != PROP3_cb )
            LogFail( "cb of property 3 is %ld, should be %ld\n",
                     sRow.p3_cb, PROP3_cb );

        if ( DBSTATUS_S_OK != sRow.p4_status )
            LogFail( "status of property 4 is bad: %x\n", sRow.p4_status );
        vTest.vt = VT_VECTOR | VT_LPWSTR;
        memcpy( & vTest.cal, & sRow.p4_vpwc, sizeof DBVECTOR );
        CheckPropertyValue( vTest, varProp4 );
        if ( sRow.p4_cb != PROP4_cb )
            LogFail( "cb of property 4 is %ld, should be %ld\n",
                     sRow.p4_cb, PROP4_cb );

        if ( DBSTATUS_S_OK != sRow.p5_status )
            LogFail( "status of property 5 is bad: %x\n", sRow.p5_status );
        vTest.vt = VT_VECTOR | VT_I4;
        memcpy( & vTest.cal, & sRow.p5_vi, sizeof DBVECTOR );
        CheckPropertyValue( vTest, varProp5 );
        if ( sRow.p5_cb != PROP5_cb )
            LogFail( "cb of property 5 is %ld, should be %ld\n",
                     sRow.p5_cb, PROP5_cb );

        if ( DBSTATUS_S_OK != sRow.p6_status )
            LogFail( "status of property 6 is bad: %x\n", sRow.p6_status );
        CheckPropertyValue( *sRow.p6_pvar, varProp6 );
        // is cb of 20 right, or is 0 right?  blobs aren't in OLEDB!
        if ( sRow.p6_cb != PROP6_cb )
            LogFail( "cb of property 6 is %ld, should be %ld\n",
                     sRow.p6_cb, PROP6_cb );

        if ( DBSTATUS_S_OK != sRow.p7_status )
            LogFail( "status of property 7 is bad: %x\n", sRow.p7_status );
        vTest.vt = VT_CLSID;
        vTest.puuid = sRow.p7_pguid;
        CheckPropertyValue( vTest, varProp7 );
        if ( sRow.p7_cb != PROP7_cb )
            LogFail( "cb of property 7 is %ld, should be %ld\n",
                     sRow.p7_cb, PROP7_cb );


        if (! fAlternate)
        {
            if ( DBSTATUS_S_OK != sRow.p8_status )
                LogFail( "status of property 8 is bad: %x\n", sRow.p8_status );
            if ( DBSTATUS_E_CANTCONVERTVALUE != sRow.p8a_status )
                LogFail( "alt. status of property 8 is OK for prim: %x\n", sRow.p8a_status );
            vTest.vt = VT_VECTOR | VT_I4;
            memcpy( & vTest.cal, & sRow.p8_vi, sizeof DBVECTOR );
            CheckPropertyValue( vTest, varProp8 );
            if ( sRow.p8_cb != PROP8_cb )
                LogFail( "cb of property 8 is %ld, should be %ld\n",
                         sRow.p8_cb, PROP8_cb );
        }
        else
        {
            if ( DBSTATUS_E_CANTCONVERTVALUE != sRow.p8_status )
                LogFail( "status of property 8 is OK for alt: %x\n", sRow.p8_status );
            if ( DBSTATUS_S_OK != sRow.p8a_status )
                LogFail( "alt status of property 8 is bad: %x\n", sRow.p8a_status );
            vTest.vt = VT_ARRAY | VT_I4;
            memcpy( &vTest.parray, &sRow.p8a_ai, sizeof (SAFEARRAY *) );
            CheckPropertyValue( vTest, varProp8A );
        }

        // can't see prop9 due to its no-read security
        if ( DBSTATUS_S_ISNULL != sRow.p9_status )
            LogFail( "status of property 9 is bad: %x\n", sRow.p9_status );
        if ( 0 != sRow.p9_cb )
            LogFail( "cb of property 9 is bad: %x\n", sRow.p9_cb );

        if ( DBSTATUS_S_OK != sRow.p10_status )
            LogFail( "status of property 10 is bad: %x\n", sRow.p10_status );
        vTest.vt = VT_LPWSTR;
        vTest.pwszVal = sRow.p10_pwc;
        CheckPropertyValue( vTest, varProp10 );
        if ( sRow.p10_cb != PROP10_cb )
            LogFail( "cb of property 10 is %ld, should be %ld\n",
                     sRow.p10_cb, PROP10_cb );

        if ( DBSTATUS_S_OK != sRow.p11_status )
            LogFail( "status of property 11 is bad: %x\n", sRow.p11_status );
        vTest.vt = VT_BSTR;
        vTest.pwszVal = sRow.p11_pwc;
        // Note: prop 11 conditional on size...
        if ( SysStringLen(sRow.p11_pwc) > 1000)
        {
            CheckPropertyValue( vTest, varProp11A );
        }
        else
        {
            CheckPropertyValue( vTest, varProp11 );
        }

        // NOTE: the length of a BSTR is sizeof BSTR
        //unsigned PROP11_cb = SysStringLen(varProp11.bstrVal) * sizeof (OLECHAR)
        //                      + sizeof (DWORD) + sizeof (OLECHAR);
        unsigned PROP11_cb = sizeof BSTR;
        if ( sRow.p11_cb != PROP11_cb )
            LogFail( "cb of property 11 is %ld, should be %ld\n",
                     sRow.p11_cb, PROP11_cb );

        if ( DBSTATUS_S_OK != sRow.p12_status )
            LogFail( "status of property 12 is bad: %x\n", sRow.p12_status );
        vTest.vt = VT_VECTOR | VT_BSTR;
        memcpy( & vTest.cal, & sRow.p12_vpwc, sizeof DBVECTOR );
        CheckPropertyValue( vTest, varProp12 );
        if ( sRow.p12_cb != PROP4_cb )
            LogFail( "cb of property 12 is %ld, should be %ld\n",
                     sRow.p12_cb, PROP4_cb );

        if ( DBSTATUS_S_OK != sRow.p21_status )
            LogFail( "status of property 21 is bad: %x\n", sRow.p21_status );
        vTest.vt = VT_CF;
        vTest.pclipdata = sRow.p21_pclipdata;
        CheckPropertyValue( vTest, varProp21 );
        if ( sRow.p21_cb != PROP21_cb )
            LogFail( "cb of property 21 is %ld, should be %ld\n",
                     sRow.p21_cb, PROP21_cb );

        if ( DBSTATUS_S_OK != sRow.p22_status )
            LogFail( "status of property 22 is bad: %x\n", sRow.p22_status );
        vTest.vt = VT_VECTOR | VT_CF;
        vTest.caclipdata = sRow.p22_caclipdata;
        CheckPropertyValue( vTest, varProp22 );
        if ( sRow.p22_cb != PROP22_cb )
            LogFail( "cb of property 22 is %ld, should be %ld\n",
                     sRow.p22_cb, PROP22_cb );

        if ( DBSTATUS_S_OK != sRow.p2a_status )
            LogFail( "status of property 2 as WSTR is bad: %x\n", sRow.p2a_status );

        vTest.vt = VT_LPWSTR;
        vTest.pwszVal = sRow.p2a_pwc;
        CheckPropertyValue( vTest, varProp2 );

        if ( sRow.p2a_cb != PROP2_cb )
            LogFail( "cb of property 2 as WSTR is %ld, should be %ld\n",
                     sRow.p2a_cb, PROP2_cb );
        // Don't free anything -- this is byref
    }

    sc = pRowset->ReleaseRows( cRowsReturned, pgrhRows, 0, 0, 0);

    if (S_OK != sc)
    {
        LogError("IRowset->ReleaseRows returned 0x%x (expected 0)\n",sc);
        pRowset->Release();
        Fail();
    }

    CoTaskMemFree(pgrhRows);
    pgrhRows = 0;

    //
    // Clean up.
    //

    ReleaseAccessor( pAccessor, hAccessor);

    pCmdTree->Release();
    pRowset->Release();

} //RunPropQueryTightBindings

//+-------------------------------------------------------------------------
//
//  Function:   RunPropQuery, public
//
//  Synopsis:   Execute a retricted query and check results
//
//  History:
//
//--------------------------------------------------------------------------

static DBBINDING aPropTestCols[] =
{
  { 0, 0 * cbPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    cbPV, 0, DBTYPE_VARIANT, 0, 0},
  { 1, 1 * cbPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    cbPV, 0, DBTYPE_VARIANT, 0, 0},
  { 2, 2 * cbPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    cbPV, 0, DBTYPE_VARIANT, 0, 0},
  { 3, 3 * cbPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    cbPV, 0, DBTYPE_VARIANT, 0, 0},
  { 4, 4 * cbPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    cbPV, 0, DBTYPE_VARIANT, 0, 0},
  { 5, 5 * cbPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    cbPV, 0, DBTYPE_VARIANT, 0, 0},
  { 6, 6 * cbPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    cbPV, 0, DBTYPE_VARIANT, 0, 0},
  { 7, 7 * cbPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    cbPV, 0, DBTYPE_VARIANT, 0, 0},
  { 8, 8 * cbPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    cbPV, 0, DBTYPE_VARIANT, 0, 0},
  { 9, 9 * cbPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    cbPV, 0, DBTYPE_VARIANT, 0, 0},
  { 10,10* cbPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    cbPV, 0, DBTYPE_VARIANT, 0, 0},
  { 11,11* cbPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    cbPV, 0, DBTYPE_VARIANT, 0, 0},
  { 12,12* cbPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    cbPV, 0, DBTYPE_VARIANT, 0, 0},
  { 13,13* cbPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    cbPV, 0, DBTYPE_VARIANT, 0, 0},
};

const ULONG cPropTestCols = sizeof aPropTestCols / sizeof aPropTestCols[0];

void RunPropQuery(
    ICommand * pQuery,
    CDbRestriction & PropRst,
    unsigned cExpectedHits,
    unsigned numTest )
{
    RunPropQueryTightBindings( pQuery, PropRst, cExpectedHits, numTest );
    RunPropQueryByRefBindings( pQuery, PropRst, cExpectedHits, numTest );

    //
    // Get twelve properties back
    //

    CDbColumns cols(cPropTestCols);
    cols.Add( psTestProperty1, 0 );
    cols.Add( psTestProperty2, 1 );
    cols.Add( psAuthor, 2 );
    cols.Add( psKeywords, 3 );
    cols.Add( psRelevantWords, 4 );
    cols.Add( psBlobTest, 5 );
    cols.Add( psGuidTest, 6 );
    cols.Add( psManyRW, 7 );
    cols.Add( psSecurityTest, 8 );
    cols.Add( psTestProperty10, 9 );
    cols.Add( psTestProperty11, 10 );
    cols.Add( psTestProperty12, 11 );
    cols.Add( psTestProperty21, 12 );
    cols.Add( psTestProperty22, 13 );

    BOOL fSeq = isEven( numTest );

    CDbSortSet ss(cPropSortColumns);
    for (unsigned i = 0; i < cPropSortColumns; i++)
        ss.Add (aPropSortCols[i], i);

    //
    // Do it!
    //

    CDbCmdTreeNode * pDbCmdTree = FormQueryTree( &PropRst,
                                                 cols,
                                                 fSeq ? 0 : &ss );

    ICommandTree * pCmdTree = 0;

    IRowsetScroll * pRowset = InstantiateRowset(
                                pQuery,
                                QUERY_SHALLOW,           // Depth
                                0,
                                pDbCmdTree,              // DBCOMMANDTREE
                                fSeq ? IID_IRowset : IID_IRowsetScroll,   // IID for i/f to return
                                0,
                                &pCmdTree );

    //
    // Verify columns
    //
    CheckColumns( pRowset, cols, TRUE );

    if ( !WaitForCompletion( pRowset, TRUE ) )
    {
        pCmdTree->Release();
        pRowset->Release();
        LogFail( "property query unsuccessful.\n" );
    }

    //
    // Get data
    //

    DBCOUNTITEM cRowsReturned = 0;
    HROW* pgrhRows = 0;

    SCODE sc = pRowset->GetNextRows(0, 0, 10, &cRowsReturned, &pgrhRows);

    if ( FAILED( sc ) )
    {
        pCmdTree->Release();
        pRowset->Release();
        LogFail( "IRowset->GetRowsAt G returned 0x%x\n", sc );
    }

    if ( 0 == cExpectedHits )
    {
        pCmdTree->Release();
        pRowset->Release();

        if ( cRowsReturned > 0 )
            LogFail("RunPropQuery, %d returned rows, expected none\n",
                    cRowsReturned);
        else
            return;

    }

    if (sc != DB_S_ENDOFROWSET &&
        cRowsReturned != 10)
    {
        LogError( "IRowset->GetRowsAt H returned %d of %d rows,"
                " status (%x) != DB_S_ENDOFROWSET\n",
                    cRowsReturned, 10,
                    sc);
        pCmdTree->Release();
        pRowset->Release();
#if defined(UNIT_TEST)
        cFailures++;
        return;
#else
        Fail();
#endif
    }

    //
    //  Expect 1 or 2 hits
    //
    if (sc != DB_S_ENDOFROWSET || cRowsReturned != cExpectedHits)
    {
        LogError( "IRowset->GetRowsAt I returned %d rows (expected %d),"
                 " status (%x)\n",
                cRowsReturned, cExpectedHits, sc );
        pCmdTree->Release();
        pRowset->Release();
#if defined(UNIT_TEST)
        cFailures++;
        return;
#else
        Fail();
#endif
    }

    //
    // Patch the column index numbers with true column ids
    //

    DBID aDbCols[cPropTestCols];
    aDbCols[0] = psTestProperty1;
    aDbCols[1] = psTestProperty2;
    aDbCols[2] = psAuthor;
    aDbCols[3] = psKeywords;
    aDbCols[4] = psRelevantWords;
    aDbCols[5] = psBlobTest;
    aDbCols[6] = psGuidTest;
    aDbCols[7] = psManyRW;
    aDbCols[8] = psSecurityTest;
    aDbCols[9] = psTestProperty10;
    aDbCols[10] = psTestProperty11;
    aDbCols[11] = psTestProperty12;
    aDbCols[12] = psTestProperty21;
    aDbCols[13] = psTestProperty22;

    IUnknown * pAccessor = (IUnknown *) pRowset;  // hAccessor must be created on rowset
                                 // to be used with rowset->GetData below
    HACCESSOR hAccessor = MapColumns(pAccessor, cPropTestCols, aPropTestCols, aDbCols);

    //
    // Fetch the data
    //

    PROPVARIANT aVarnt[cPropTestCols];

    for (unsigned row = 0; row < cRowsReturned; row++)
    {
        sc = pRowset->GetData(pgrhRows[row], hAccessor, aVarnt);

        if (S_OK != sc)
        {
            LogError("IRowset->GetData returned 0x%x (expected 0)\n",sc);
            pCmdTree->Release();
            pRowset->Release();
            Fail();
        }

        //
        // Verify the data.
        //

        // Ascending sort, prop1 > prop1Alternate.
        // If one hit, it's PROP1_VAL, not the alternate.
        // prop1=1234, alternate=123

        BOOL fAlternate = FALSE;
        if ( fSeq )
        {
            if ( 1 == cRowsReturned )
            {
                varProp1.lVal = PROP1_VAL;
                CheckPropertyValue( aVarnt[0], varProp1 );
            }
            else
            {
                // no sort order -- it's either prop1 or alternate

                if ( PROP1_TYPE != aVarnt[0].vt )
                    LogFail( "bad datatype for prop1: 0x%x\n", aVarnt[0].vt );

                if ( PROP1_VAL != aVarnt[0].lVal &&
                     PROP1_VAL_Alternate != aVarnt[0].lVal )
                    LogFail( "bad value for prop1: 0x%x\n", aVarnt[0].lVal );
                fAlternate = aVarnt[0].lVal == PROP1_VAL_Alternate;
            }
        }
        else
        {
            fAlternate = (0 == row) && (1 != cRowsReturned);
            varProp1.lVal = fAlternate ?
                                PROP1_VAL_Alternate :
                                PROP1_VAL;
            CheckPropertyValue( aVarnt[0], varProp1 );
        }

        CheckPropertyValue( aVarnt[1], varProp2 );
        CheckPropertyValue( aVarnt[2], varProp3 );
        CheckPropertyValue( aVarnt[3], varProp4 );
        CheckPropertyValue( aVarnt[4], varProp5 );
        CheckPropertyValue( aVarnt[5], varProp6 );
        CheckPropertyValue( aVarnt[6], varProp7 );
        CheckPropertyValue( aVarnt[7], fAlternate ? varProp8A : varProp8 );
        CheckPropertyValue( aVarnt[8], varProp9 );
        CheckPropertyValue( aVarnt[9], varProp10 );
        if ( aVarnt[10].vt == VT_BSTR &&
             SysStringLen( aVarnt[10].bstrVal) < 1000 )
        {
            CheckPropertyValue( aVarnt[10], varProp11 );
        }
        else
        {
            CheckPropertyValue( aVarnt[10], varProp11A );
        }
        CheckPropertyValue( aVarnt[11], varProp12 );
        CheckPropertyValue( aVarnt[12], varProp21 );
        CheckPropertyValue( aVarnt[13], varProp22 );

        //
        // Free extra data allocated byref in the variants above
        //

        CoTaskMemFree(aVarnt[1].pwszVal);
        CoTaskMemFree(aVarnt[2].pwszVal);

        for (unsigned x = 0; x < aVarnt[3].calpwstr.cElems; x++ )
            CoTaskMemFree( aVarnt[3].calpwstr.pElems[ x ] );

        CoTaskMemFree(aVarnt[3].calpwstr.pElems);
        CoTaskMemFree(aVarnt[4].cal.pElems);
        CoTaskMemFree(aVarnt[5].blob.pBlobData);
        CoTaskMemFree(aVarnt[6].puuid);

        // sometimes a VT_VECTOR, sometimes a VT_ARRAY

        HRESULT hrPVC = PropVariantClear( &aVarnt[7] );
        if ( S_OK != hrPVC )
            LogError( "bad propvariant clear: %#x\n", hrPVC );

        // nothing to free for [8] -- insufficient security to load value
        CoTaskMemFree(aVarnt[9].pwszVal);
        PropVariantClear(&aVarnt[10]);
        PropVariantClear(&aVarnt[11]);
        PropVariantClear(&aVarnt[12]);
        PropVariantClear(&aVarnt[13]);
    }

    sc = pRowset->ReleaseRows( cRowsReturned, pgrhRows, 0, 0, 0);

    if (S_OK != sc)
    {
        LogError("IRowset->ReleaseRows returned 0x%x (expected 0)\n",sc);
        pCmdTree->Release();
        pRowset->Release();
        Fail();
    }

    CoTaskMemFree(pgrhRows);
    pgrhRows = 0;

    //
    // Clean up.
    //

    ReleaseAccessor( pAccessor, hAccessor);

    pCmdTree->Release();
    pRowset->Release();
} //RunPropQuery



const int COERCE_PROP_BUF_SIZE = 129;

struct CoercePropStruct
{
    char szProp13[COERCE_PROP_BUF_SIZE];
    char szProp14[COERCE_PROP_BUF_SIZE];
    char szProp15[COERCE_PROP_BUF_SIZE];
    char szProp16[COERCE_PROP_BUF_SIZE];
    char szProp17[COERCE_PROP_BUF_SIZE];
    char szProp18[COERCE_PROP_BUF_SIZE];
    char szProp19[COERCE_PROP_BUF_SIZE];
    char szProp7[COERCE_PROP_BUF_SIZE];
    double szProp20;
} ;


static DBBINDING aPropTestCoerceCols[] =
{

  { 0, COERCE_PROP_BUF_SIZE * 0, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    COERCE_PROP_BUF_SIZE, 0, DBTYPE_STR, 0, 0}, // prop13

  { 1, COERCE_PROP_BUF_SIZE * 1, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    COERCE_PROP_BUF_SIZE, 0, DBTYPE_STR, 0, 0}, // prop14

  { 2, COERCE_PROP_BUF_SIZE * 2, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    COERCE_PROP_BUF_SIZE, 0, DBTYPE_STR, 0, 0}, // prop15

  { 3, COERCE_PROP_BUF_SIZE * 3, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    COERCE_PROP_BUF_SIZE, 0, DBTYPE_STR, 0, 0}, // prop16

  { 4, COERCE_PROP_BUF_SIZE * 4, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    4, 0, DBTYPE_STR, 0, 0}, // prop17  // give smaller size to test if truncation works

  { 5, COERCE_PROP_BUF_SIZE * 5, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    COERCE_PROP_BUF_SIZE, 0, DBTYPE_STR, 0, 0}, //prop18

  { 6, COERCE_PROP_BUF_SIZE * 6, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    COERCE_PROP_BUF_SIZE, 0, DBTYPE_STR, 0, 0}, // prop19

  { 7, COERCE_PROP_BUF_SIZE * 7, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    COERCE_PROP_BUF_SIZE, 0, DBTYPE_STR, 0, 0},   // prop7

  { 8, COERCE_PROP_BUF_SIZE * 8, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    sizeof( double ), 0, DBTYPE_R8, 0, 0}   // prop20
};

const ULONG cPropTestCoerceCols = sizeof aPropTestCoerceCols / sizeof aPropTestCoerceCols[0];


void RunPropQueryAndCoerce(
    ICommand * pQuery,
    CDbRestriction & PropRst,
    unsigned cExpectedHits,
    unsigned numTest )
{

    CoercePropStruct CoerceResultTestData;

    // set up the expected result data
    memset( &CoerceResultTestData, 0, sizeof CoercePropStruct );
    strcpy( CoerceResultTestData.szProp13, PROP13_STR_VAL );
    strcpy( CoerceResultTestData.szProp14, PROP14_STR_VAL );
    strcpy( CoerceResultTestData.szProp15, PROP15_STR_VAL );
    strcpy( CoerceResultTestData.szProp16, PROP16_STR_VAL );
    strcpy( CoerceResultTestData.szProp17, PROP17_STR_VAL );
    strcpy( CoerceResultTestData.szProp18, PROP18_STR_VAL );
    strcpy( CoerceResultTestData.szProp19, PROP19_STR_VAL );
    strcpy( CoerceResultTestData.szProp7,  PROP7_STR_VAL );
    CoerceResultTestData.szProp20 = PROP20_DBL_VAL;

    CDbColumns cols(cPropTestCoerceCols);
    cols.Add( psTestProperty13, 0 );
    cols.Add( psTestProperty14, 1 );
    cols.Add( psTestProperty15, 2 );
    cols.Add( psTestProperty16, 3 );
    cols.Add( psTestProperty17, 4 );
    cols.Add( psTestProperty18, 5 );
    cols.Add( psTestProperty19, 6 );
    cols.Add( psGuidTest, 7 );
    cols.Add( psTestProperty20, 8 );

    //
    // Do it!
    //

    CDbCmdTreeNode * pDbCmdTree = FormQueryTree( &PropRst,
                                                 cols,
                                                 0);

    ICommandTree * pCmdTree = 0;

    IRowsetScroll * pRowset = InstantiateRowset(
                                pQuery,
                                QUERY_SHALLOW,           // Depth
                                0,
                                pDbCmdTree,              // DBCOMMANDTREE
                                IID_IRowset,  // IID for i/f to return
                                0,
                                &pCmdTree );

    //
    // Verify columns
    //
    CheckColumns( pRowset, cols, TRUE );

    if ( !WaitForCompletion( pRowset, TRUE ) )
    {
        pCmdTree->Release();
        pRowset->Release();
        LogFail( "property query unsuccessful.\n" );
    }

    //
    // Get data
    //

    DBCOUNTITEM cRowsReturned = 0;
    HROW* pgrhRows = 0;

    SCODE sc = pRowset->GetNextRows(0, 0, 10, &cRowsReturned, &pgrhRows);

    if ( FAILED( sc ) )
    {
        pCmdTree->Release();
        pRowset->Release();
        LogFail( "RunPropQueryAndCoerce IRowset->GetNextRows A returned 0x%x\n", sc );
    }

    if ( 0 == cExpectedHits )
    {
        pCmdTree->Release();
        pRowset->Release();

        if ( cRowsReturned > 0 )
            LogFail("RunPropQueryAndCoerce, %d returned rows, expected none\n",
                    cRowsReturned);
        else
            return;

    }

    if (sc != DB_S_ENDOFROWSET &&
        cRowsReturned != 10)
    {
        LogError( "RunPropQueryAndCoerce IRowset->GetNextRows C returned %d of %d rows,"
                " status (%x) != DB_S_ENDOFROWSET\n",
                    cRowsReturned, 10,
                    sc);
        pCmdTree->Release();
        pRowset->Release();
#if defined(UNIT_TEST)
        cFailures++;
        return;
#else
        Fail();
#endif
    }

    //
    //  Expect 1 or 2 hits
    //
    if (sc != DB_S_ENDOFROWSET || cRowsReturned != cExpectedHits)
    {
        LogError( "RunPropQueryAndCoerce IRowset->GetNextRows D returned %d rows (expected %d),"
                 " status (%x)\n",
                cRowsReturned, cExpectedHits, sc );
        pCmdTree->Release();
        pRowset->Release();
#if defined(UNIT_TEST)
        cFailures++;
        return;
#else
        Fail();
#endif
    }

    //
    // Patch the column index numbers with true column ids
    //

    DBID aDbCols[cPropTestCoerceCols];

    aDbCols[0] = psTestProperty13;
    aDbCols[1] = psTestProperty14;
    aDbCols[2] = psTestProperty15;
    aDbCols[3] = psTestProperty16;
    aDbCols[4] = psTestProperty17;
    aDbCols[5] = psTestProperty18;
    aDbCols[6] = psTestProperty19;
    aDbCols[7] = psGuidTest;
    aDbCols[8] = psTestProperty20;

    IUnknown * pAccessor = (IUnknown *) pRowset;  // hAccessor must be created on rowset
                                 // to be used with rowset->GetData below
    HACCESSOR hAccessor = MapColumns(pAccessor, cPropTestCoerceCols, aPropTestCoerceCols, aDbCols);

    //
    // Fetch the data
    //

    //PROPVARIANT aVarnt[cPropTestCols];

    CoercePropStruct rowData;

    memset( &rowData, 0, sizeof CoercePropStruct );

    for (unsigned row = 0; row < cRowsReturned; row++)
    {
        sc = pRowset->GetData(pgrhRows[row], hAccessor, &rowData);

        if (S_OK != sc)
        {
            LogError("RunPropQueryAndCoerce IRowset->GetData returned 0x%x (expected 0)\n",sc);
            pCmdTree->Release();
            pRowset->Release();
            Fail();
        }

        // verify
        if ( memcmp( &rowData, &CoerceResultTestData, sizeof CoercePropStruct ) )
        {
            LogFail( "RunPropQueryAndCoerce failed." );
        }

    }
    sc = pRowset->ReleaseRows( cRowsReturned, pgrhRows, 0, 0, 0);

    if (S_OK != sc)
    {
        LogError("IRowset->ReleaseRows returned 0x%x (expected 0)\n",sc);
        pCmdTree->Release();
        pRowset->Release();
        Fail();
    }

    CoTaskMemFree(pgrhRows);
    pgrhRows = 0;

    //
    // Clean up.
    //

    ReleaseAccessor( pAccessor, hAccessor);

    pCmdTree->Release();
    pRowset->Release();
} //RunPropQueryAndCoerce



//+-------------------------------------------------------------------------
//
//  Function:   RunDistribQueryTest, public
//
//  Synopsis:   Minimal test for the distributed rowset
//
//  History:    07 Oct 98   vikasman    created
//
//  Notes:      This is a pretty minimal test; should try sorted and
//              scrollable (all combinations), larger result sets
//
//--------------------------------------------------------------------------

void RunDistribQueryTest( BOOL fDoContentTest )
{
    LogProgress( "Distributed Query Test\n" );

    IUnknown * pIUnknown;
    ICommand * pQuery = 0;

    SCODE scIC = CICreateCommand( &pIUnknown,
                                  0,
                                  IID_IUnknown,
                                  TEST_CATALOG,
                                  TEST_MACHINE );
    if ( FAILED( scIC ) )
        LogFail( "RunDistribQueryTest - error 0x%x Unable to create ICommand\n",
                 scIC );

    scIC = pIUnknown->QueryInterface(IID_ICommand, (void **) &pQuery );
    pIUnknown->Release();

    if ( FAILED( scIC ) )
        LogFail( "RunDistribQueryTest - error 0x%x Unable to QI ICommand\n",
                 scIC  );

    if ( 0 == pQuery )
        LogFail( "RunDistribQueryTest - CICreateCommand succeeded, but returned null pQuery\n" );

    WCHAR * awcMachines[2];
    WCHAR * awcCatalogs[2];
    WCHAR * awcScopes[2];
    WCHAR aComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    DWORD aDepths[2];
    ULONG cComputerName = MAX_COMPUTERNAME_LENGTH + 1;

    GetComputerName( aComputerName, &cComputerName );

    awcMachines[0] = TEST_MACHINE;
    awcCatalogs[0] = TEST_CATALOG;
    awcScopes[0]   = wcsTestPath;
    aDepths[0]     = QUERY_SHALLOW;

    awcMachines[1] = aComputerName;
    awcCatalogs[1] = TEST_CATALOG;
    awcScopes[1]   = wcsTestPath;
    aDepths[1]     = QUERY_SHALLOW;
    

    scIC = SetScopeProperties( pQuery,
                               2,
                               awcScopes,
                               aDepths,
                               awcCatalogs,
                               awcMachines );

    if ( FAILED( scIC ) )
        LogFail( "RunDistribQueryTest - error 0x%x Unable to set scope '%ws'\n",
                 scIC, wcsTestPath );

    CheckPropertiesOnCommand( pQuery );

    unsigned numTest = 1;

    // singleton DBOP_equal singleton - Coersion test
    {
        LogProgress( " DistributedRowset -  Property coercion to String test\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psTestProperty1 );
        PropRst.SetRelation( DBOP_equal );
        PropRst.SetValue( PROP1_VAL );
        RunPropQueryAndCoerce( pQuery, PropRst, 2, numTest++ );
    }

    pQuery->Release();
}


//+-------------------------------------------------------------------------
//
//  Function:   RunPropTest, public
//
//  Synopsis:   Very minimal test of property query
//
//  History:    13-May-93       KyleP   Created
//              15 Oct 94       Alanw   Converted to OLE-DB query
//
//--------------------------------------------------------------------------

void RunPropTest( void )
{
    LogProgress( "Property Retrieval Test\n" );

    PROPVARIANT pvProp5;
    pvProp5.vt = VT_I4|VT_VECTOR;
    pvProp5.cal.cElems = clProp5;
    pvProp5.cal.pElems = (LONG *) alProp5;

    PROPVARIANT pvProp5Jumble;
    pvProp5Jumble.vt = VT_I4|VT_VECTOR;
    pvProp5Jumble.cal.cElems = clProp5Jumble;
    pvProp5Jumble.cal.pElems = (LONG *) alProp5Jumble;

    PROPVARIANT pvProp5Like;
    pvProp5Like.vt = VT_I4|VT_VECTOR;
    pvProp5Like.cal.cElems = clProp5Like;
    pvProp5Like.cal.pElems = (LONG *) alProp5Like;

    PROPVARIANT pvProp5None;
    pvProp5None.vt = VT_I4|VT_VECTOR;
    pvProp5None.cal.cElems = clProp5None;
    pvProp5None.cal.pElems = (LONG *) alProp5None;

    PROPVARIANT pvProp5Less;
    pvProp5Less.vt = VT_I4|VT_VECTOR;
    pvProp5Less.cal.cElems = clProp5Less;
    pvProp5Less.cal.pElems = (LONG *) alProp5Less;

    PROPVARIANT pvProp5AllLess;
    pvProp5AllLess.vt = VT_I4|VT_VECTOR;
    pvProp5AllLess.cal.cElems = clProp5AllLess;
    pvProp5AllLess.cal.pElems = (LONG *) alProp5AllLess;

    PROPVARIANT pvProp5More;
    pvProp5More.vt = VT_I4|VT_VECTOR;
    pvProp5More.cal.cElems = clProp5More;
    pvProp5More.cal.pElems = (LONG *) alProp5More;

    PROPVARIANT pvProp5AllMore;
    SAFEARRAY saProp5AllMore = { 1,               // Dimension
                          FADF_AUTO,              // Flags: on stack
                          sizeof(LONG),           // Size of an element
                          1,                      // Lock count.  1 for safety.
                          (void *)alProp5AllMore, // The data
                          { clProp5AllMore, 0 } };// Bounds (element count, low bound)
    pvProp5AllMore.vt = VT_I4|VT_ARRAY;
    pvProp5AllMore.parray = &saProp5AllMore;

    WCHAR *pwszScope = wcsTestPath;

    DWORD dwDepth = QUERY_SHALLOW;
    IUnknown * pIUnknown;
    ICommand * pQuery = 0;
    SCODE scIC = CICreateCommand( &pIUnknown,
                                  0,
                                  IID_IUnknown,
                                  TEST_CATALOG,
                                  TEST_MACHINE );
    if ( FAILED( scIC ) )
        LogFail( "RunPropTest - error 0x%x Unable to create ICommand\n",
                 scIC );

    scIC = pIUnknown->QueryInterface(IID_ICommand, (void **) &pQuery );
    pIUnknown->Release();

    if ( FAILED( scIC ) )
        LogFail( "RunPropTest - error 0x%x Unable to QI ICommand\n",
                 scIC  );

    if ( 0 == pQuery )
        LogFail( "RunPropTest - CICreateCommand succeeded, but returned null pQuery\n" );

    scIC = SetScopeProperties( pQuery,
                               1,
                               &pwszScope,
                               &dwDepth );

    if ( FAILED( scIC ) )
        LogFail( "RunPropTest - error 0x%x Unable to set scope '%ws'\n",
                 scIC, pwszScope );

    CheckPropertiesOnCommand( pQuery );

    unsigned numTest = 1;

    // singleton DBOP_equal singleton - Coersion test
    {
        LogProgress( " Property coercion to String test 0\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psTestProperty1 );
        PropRst.SetRelation( DBOP_equal );
        PropRst.SetValue( PROP1_VAL );
        RunPropQueryAndCoerce( pQuery, PropRst, 1, numTest++ );
    }

    // singleton DBOP_equal singleton
    {
        LogProgress( " Property Retrieval test 0\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psTestProperty1 );
        PropRst.SetRelation( DBOP_equal );
        PropRst.SetValue( PROP1_VAL );
        RunPropQuery( pQuery, PropRst, 1, numTest++ );
    }

    // vector DBOP_equal vector
    {
        LogProgress( " Property Retrieval test 1\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psRelevantWords );
        PropRst.SetRelation( DBOP_equal );
        PropRst.SetValue( * ((CStorageVariant *) (void *) (&pvProp5)) );
        RunPropQueryAndCoerce( pQuery, PropRst, 2, numTest );
        RunPropQuery( pQuery, PropRst, 2, numTest++ );
    }

    // vector DBOP_equal_all vector (FAIL getting any hits back)
    {
        LogProgress( " Property Retrieval test 2\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psRelevantWords );
        PropRst.SetRelation( DBOP_equal_all );
        PropRst.SetValue( * ((CStorageVariant *) (void *) (&pvProp5)) );
        RunPropQuery( pQuery, PropRst, 0, numTest++ );
    }

    // singleton DBOP_equal_any singleton
    {
        LogProgress( " Property Retrieval test 3\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psTestProperty1 );
        PropRst.SetRelation( DBOP_equal_any );
        PropRst.SetValue( PROP1_VAL );
        RunPropQuery( pQuery, PropRst, 1, numTest++ );
    }

    // singleton DBOP_equal vector (FAIL getting any hits back)
    {
        LogProgress( " Property Retrieval test 4\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psRelevantWords );
        PropRst.SetRelation( DBOP_equal );
        PropRst.SetValue( SecondRelevantWord );
        RunPropQuery( pQuery, PropRst, 0, numTest++ );
    }

    // singleton DBOP_equal_any vector (FAIL -- singleton not in vector)
    {
        LogProgress( " Property Retrieval test 5\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psRelevantWords );
        PropRst.SetRelation( DBOP_equal_any );
        PropRst.SetValue( (LONG) 666 );
        RunPropQuery( pQuery, PropRst, 0, numTest++ );
    }

    // singleton DBOP_equal_any vector
    {
        LogProgress( " Property Retrieval test 6\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psRelevantWords );
        PropRst.SetRelation( DBOP_equal_any );
        PropRst.SetValue( SecondRelevantWord );
        RunPropQuery( pQuery, PropRst, 2, numTest++ );
    }

    // reordered vector DBOP_equal_any vector
    {
        LogProgress( " Property Retrieval test 7\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psRelevantWords );
        PropRst.SetRelation( DBOP_equal_any );
        PropRst.SetValue( * ((CStorageVariant *) (void *) (&pvProp5Jumble)) );
        RunPropQuery( pQuery, PropRst, 2 , numTest++ );
    }

    // vector with one element match DBOP_equal_any vector
    {
        LogProgress( " Property Retrieval test 8\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psRelevantWords );
        PropRst.SetRelation( DBOP_equal_any );
        PropRst.SetValue( * ((CStorageVariant *) (void *) (&pvProp5Like)) );
        RunPropQuery( pQuery, PropRst, 2, numTest++ );
    }

    // vector with 0 element overlap DBOP_equal_any vector (FAIL getting any hits back)
    {
        LogProgress( " Property Retrieval test 9\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psRelevantWords );
        PropRst.SetRelation( DBOP_equal_any );
        PropRst.SetValue( * ((CStorageVariant *) (void *) (&pvProp5None)) );
        RunPropQuery( pQuery, PropRst, 0, numTest++ );
    }

    // reordered vector DBOP_equal_any vector
    {
        LogProgress( " Property Retrieval test 10\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psRelevantWords );
        PropRst.SetRelation( DBOP_equal_any );
        PropRst.SetValue( * ((CStorageVariant *) (void *) (&pvProp5Jumble)) );
        RunPropQuery( pQuery, PropRst, 2, numTest++ );
    }

    // vector with one element match DBOP_equal_all vector (FAIL getting hits back)
    {
        LogProgress( " Property Retrieval test 11\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psRelevantWords );
        PropRst.SetRelation( DBOP_equal_all );
        PropRst.SetValue( * ((CStorageVariant *) (void *) (&pvProp5Like)) );
        RunPropQuery( pQuery, PropRst, 0, numTest++ );
    }

    // less vector DBOP_less vector (FAIL getting hits back)
    {
        LogProgress( " Property Retrieval test 12\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psRelevantWords );
        PropRst.SetRelation( DBOP_less );
        PropRst.SetValue( * ((CStorageVariant *) (void *) (&pvProp5Less)) );
        RunPropQuery( pQuery, PropRst, 0, numTest++ );
    }

    // less vector DBOP_greater vector
    {
        LogProgress( " Property Retrieval test 13\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psRelevantWords );
        PropRst.SetRelation( DBOP_greater );
        PropRst.SetValue( * ((CStorageVariant *) (void *) (&pvProp5Less)) );
        RunPropQuery( pQuery, PropRst, 2, numTest++ );
    }

    // more vector DBOP_greater_equal vector (FAIL getting hits back)
    {
        LogProgress( " Property Retrieval test 14\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psRelevantWords );
        PropRst.SetRelation( DBOP_greater_equal );
        PropRst.SetValue( * ((CStorageVariant *) (void *) (&pvProp5More)) );
        RunPropQuery( pQuery, PropRst, 0, numTest++ );
    }

    // more vector DBOP_less_equal vector
    {
        LogProgress( " Property Retrieval test 15\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psRelevantWords );
        PropRst.SetRelation( DBOP_less_equal );
        PropRst.SetValue( * ((CStorageVariant *) (void *) (&pvProp5More)) );
        RunPropQuery( pQuery, PropRst, 2, numTest++ );
    }

    // less vector DBOP_less_all vector (FAIL getting hits back)
    {
        LogProgress( " Property Retrieval test 16\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psRelevantWords );
        PropRst.SetRelation( DBOP_less_all );
        PropRst.SetValue( * ((CStorageVariant *) (void *) (&pvProp5AllLess)) );
        RunPropQuery( pQuery, PropRst, 0, numTest++ );
    }

    // less vector DBOP_greater_all vector
    {
        LogProgress( " Property Retrieval test 17\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psRelevantWords );
        PropRst.SetRelation( DBOP_greater_all );
        PropRst.SetValue( * ((CStorageVariant *) (void *) (&pvProp5AllLess)) );
        RunPropQuery( pQuery, PropRst, 2, numTest++ );
    }

    // more vector DBOP_greater_equal_all vector (FAIL getting hits back)
    {
        LogProgress( " Property Retrieval test 18\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psRelevantWords );
        PropRst.SetRelation( DBOP_greater_equal_all );
        PropRst.SetValue( * ((CStorageVariant *) (void *) (&pvProp5AllMore)) );
        RunPropQuery( pQuery, PropRst, 0, numTest++ );
    }

    // more vector DBOP_less_equal_all vector
    {
        LogProgress( " Property Retrieval test 19\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psRelevantWords );
        PropRst.SetRelation( DBOP_less_equal_all );
        PropRst.SetValue( * ((CStorageVariant *) (void *) (&pvProp5AllMore)) );
        RunPropQuery( pQuery, PropRst, 2, numTest++ );
    }

    // less vector DBOP_less_any vector (FAIL getting hits back)
    {
        LogProgress( " Property Retrieval test 20\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psRelevantWords );
        PropRst.SetRelation( DBOP_less_any );
        PropRst.SetValue( * ((CStorageVariant *) (void *) (&pvProp5AllLess)) );
        RunPropQuery( pQuery, PropRst, 0, numTest++ );
    }

    // less vector DBOP_greater_any vector
    {
        LogProgress( " Property Retrieval test 21\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psRelevantWords );
        PropRst.SetRelation( DBOP_greater_any );
        PropRst.SetValue( * ((CStorageVariant *) (void *) (&pvProp5AllLess)) );
        RunPropQuery( pQuery, PropRst, 2, numTest++ );
    }

    // more vector DBOP_greater_equal_any vector (FAIL getting hits back)
    {
        LogProgress( " Property Retrieval test 22\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psRelevantWords );
        PropRst.SetRelation( DBOP_greater_equal_any );
        PropRst.SetValue( * ((CStorageVariant *) (void *) (&pvProp5AllMore)) );
        RunPropQuery( pQuery, PropRst, 0, numTest++ );
    }

    // more vector DBOP_less_equal_any vector
    {
        LogProgress( " Property Retrieval test 23\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psRelevantWords );
        PropRst.SetRelation( DBOP_less_equal_any );
        PropRst.SetValue( * ((CStorageVariant *) (void *) (&pvProp5AllMore)) );
        RunPropQuery( pQuery, PropRst, 2, numTest++ );
    }

    // singleton wstr DBOP_equal_any string vector
    {
        LogProgress( " Property Retrieval test 24\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psKeywords );
        PropRst.SetRelation( DBOP_equal_any );
        PropRst.SetValue( L"is" );
        RunPropQuery( pQuery, PropRst, 2, numTest++ );
    }

    // bogus singleton wstr DBOP_equal_any string vector (FAIL getting hits back)
    {
        LogProgress( " Property Retrieval test 25\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psKeywords );
        PropRst.SetRelation( DBOP_equal_any );
        PropRst.SetValue( L"666" );
        RunPropQuery( pQuery, PropRst, 0, numTest++ );
    }

    // bogus singleton DBOP_equal_any singleton
    {
        LogProgress( " Property Retrieval test 26\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psTestProperty1 );
        PropRst.SetRelation( DBOP_equal_any );
        PropRst.SetValue( PROP1_VAL + 100 );
        RunPropQuery( pQuery, PropRst, 0, numTest++ );
    }

    // singleton DBOP_equal singleton (empty string)
    {
        LogProgress( " Property Retrieval test 27\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psTestProperty10 );
        PropRst.SetRelation( DBOP_equal );
        PropRst.SetValue( PROP10_VAL );
        RunPropQuery( pQuery, PropRst, 2, numTest++ );
    }

    // singleton DBOP_equal singleton (BSTR string)
    {
        LogProgress( " Property Retrieval test 28\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psTestProperty11 );
        PropRst.SetRelation( DBOP_equal );
        PropRst.SetValue( varProp11 );
        RunPropQuery( pQuery, PropRst, 1, numTest++ );
    }

    // less vector DBOP_less_all large vector (FAIL getting hits back)
    {
        LogProgress( " Property Retrieval test 29\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psManyRW );
        PropRst.SetRelation( DBOP_less_all );
        PropRst.SetValue( * ((CStorageVariant *) (void *) (&pvProp5AllLess)) );
        RunPropQuery( pQuery, PropRst, 0, numTest++ );
    }

    // less vector DBOP_greater_all large vector (FAIL getting hits back)
    {
        LogProgress( " Property Retrieval test 30\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psManyRW );
        PropRst.SetRelation( DBOP_greater_all );
        PropRst.SetValue( * ((CStorageVariant *) (void *) (&pvProp5AllLess)) );
        RunPropQuery( pQuery, PropRst, 0, numTest++ );
    }

    // more vector DBOP_less_all large vector
    {
        LogProgress( " Property Retrieval test 31\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psManyRW );
        PropRst.SetRelation( DBOP_less_all );
        PropRst.SetValue( * ((CStorageVariant *) (void *) (&pvProp5AllMore)) );
        RunPropQuery( pQuery, PropRst, 2, numTest++ );
    }

    // singleton DBOP_less_equal_all large vector
    {
        LogProgress( " Property Retrieval test 32\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( psManyRW );
        PropRst.SetRelation( DBOP_less_equal_all );
        PropRst.SetValue( (LONG) (clProp8-1) );
        RunPropQuery( pQuery, PropRst, 2, numTest++ );
    }

    pQuery->Release();

} //RunPropTest

struct SSafeArrayTestColsTight
{
    SAFEARRAY * a_I4;
    SAFEARRAY * a_BSTR;
    SAFEARRAY * a_VARIANT;
    SAFEARRAY * a_R8;
    SAFEARRAY * a_DATE;
    SAFEARRAY * a_BOOL;
    SAFEARRAY * a_DECIMAL;
    SAFEARRAY * a_I1;
    SAFEARRAY * a_R4;
    SAFEARRAY * a_CY;
    SAFEARRAY * a_UINT;
    SAFEARRAY * a_INT;
    SAFEARRAY * a_ERROR;

    DBLENGTH    I4_cb;
    DBLENGTH    BSTR_cb;
    DBLENGTH    VARIANT_cb;
    DBLENGTH    R8_cb;
    DBLENGTH    DATE_cb;
    DBLENGTH    BOOL_cb;
    DBLENGTH    DECIMAL_cb;
    DBLENGTH    I1_cb;
    DBLENGTH    R4_cb;
    DBLENGTH    CY_cb;
    DBLENGTH    UINT_cb;
    DBLENGTH    INT_cb;
    DBLENGTH    ERROR_cb;

    ULONG    I4_status;
    ULONG    BSTR_status;
    ULONG    VARIANT_status;
    ULONG    R8_status;
    ULONG    DATE_status;
    ULONG    BOOL_status;
    ULONG    DECIMAL_status;
    ULONG    I1_status;
    ULONG    R4_status;
    ULONG    CY_status;
    ULONG    UINT_status;
    ULONG    INT_status;
    ULONG    ERROR_status;
};

static DBBINDING aSafeArrayTestColsTight[] =
{
  { 0,
    offsetof(SSafeArrayTestColsTight,a_I4),
    offsetof(SSafeArrayTestColsTight,I4_cb),
    offsetof(SSafeArrayTestColsTight,I4_status),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof (SAFEARRAY *), 0,
    DBTYPE_ARRAY|DBTYPE_I4,
    0, 0 },
  { 1,
    offsetof(SSafeArrayTestColsTight,a_BSTR),
    offsetof(SSafeArrayTestColsTight,BSTR_cb),
    offsetof(SSafeArrayTestColsTight,BSTR_status),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof (SAFEARRAY *), 0,
    DBTYPE_ARRAY|DBTYPE_BSTR,
    0, 0 },
  { 2,
    offsetof(SSafeArrayTestColsTight,a_VARIANT),
    offsetof(SSafeArrayTestColsTight,VARIANT_cb),
    offsetof(SSafeArrayTestColsTight,VARIANT_status),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof (SAFEARRAY *), 0,
    DBTYPE_ARRAY|DBTYPE_VARIANT,
    0, 0 },
  { 3,
    offsetof(SSafeArrayTestColsTight,a_R8),
    offsetof(SSafeArrayTestColsTight,R8_cb),
    offsetof(SSafeArrayTestColsTight,R8_status),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof (SAFEARRAY *), 0,
    DBTYPE_ARRAY|DBTYPE_R8,
    0, 0 },
  { 4,
    offsetof(SSafeArrayTestColsTight,a_DATE),
    offsetof(SSafeArrayTestColsTight,DATE_cb),
    offsetof(SSafeArrayTestColsTight,DATE_status),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof (SAFEARRAY *), 0,
    DBTYPE_ARRAY|DBTYPE_DATE,
    0, 0 },
  { 5,
    offsetof(SSafeArrayTestColsTight,a_BOOL),
    offsetof(SSafeArrayTestColsTight,BOOL_cb),
    offsetof(SSafeArrayTestColsTight,BOOL_status),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof (SAFEARRAY *), 0,
    DBTYPE_ARRAY|DBTYPE_BOOL,
    0, 0 },
  { 6,
    offsetof(SSafeArrayTestColsTight,a_DECIMAL),
    offsetof(SSafeArrayTestColsTight,DECIMAL_cb),
    offsetof(SSafeArrayTestColsTight,DECIMAL_status),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof (SAFEARRAY *), 0,
    DBTYPE_ARRAY|DBTYPE_DECIMAL,
    0, 0 },
  { 7,
    offsetof(SSafeArrayTestColsTight,a_I1),
    offsetof(SSafeArrayTestColsTight,I1_cb),
    offsetof(SSafeArrayTestColsTight,I1_status),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof (SAFEARRAY *), 0,
    DBTYPE_ARRAY|DBTYPE_I1,
    0, 0 },
  { 8,
    offsetof(SSafeArrayTestColsTight,a_R4),
    offsetof(SSafeArrayTestColsTight,R4_cb),
    offsetof(SSafeArrayTestColsTight,R4_status),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof (SAFEARRAY *), 0,
    DBTYPE_ARRAY|DBTYPE_R4,
    0, 0 },
  { 9,
    offsetof(SSafeArrayTestColsTight,a_CY),
    offsetof(SSafeArrayTestColsTight,CY_cb),
    offsetof(SSafeArrayTestColsTight,CY_status),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof (SAFEARRAY *), 0,
    DBTYPE_ARRAY|DBTYPE_CY,
    0, 0 },
  { 10,
    offsetof(SSafeArrayTestColsTight,a_UINT),
    offsetof(SSafeArrayTestColsTight,UINT_cb),
    offsetof(SSafeArrayTestColsTight,UINT_status),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof (SAFEARRAY *), 0,
    DBTYPE_ARRAY|VT_UINT,
    0, 0 },
  { 11,
    offsetof(SSafeArrayTestColsTight,a_INT),
    offsetof(SSafeArrayTestColsTight,INT_cb),
    offsetof(SSafeArrayTestColsTight,INT_status),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof (SAFEARRAY *), 0,
    DBTYPE_ARRAY|VT_INT,
    0, 0 },
  { 12,
    offsetof(SSafeArrayTestColsTight,a_ERROR),
    offsetof(SSafeArrayTestColsTight,ERROR_cb),
    offsetof(SSafeArrayTestColsTight,ERROR_status),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    sizeof (SAFEARRAY *), 0,
    DBTYPE_ARRAY|DBTYPE_ERROR,
    0, 0 },
};

const ULONG cSafeArrayTestColsTight = sizeof aSafeArrayTestColsTight /
                                 sizeof aSafeArrayTestColsTight[0];

void RunSafeArrayTightBindings(
    ICommand * pQuery,
    CDbRestriction & PropRst,
    unsigned cExpectedHits,
    unsigned numTest )
{
    //
    // Get 13 properties back
    //

    CDbColumns cols(cSafeArrayTestColsTight);
    cols.Add( colSA_I4, 0 );
    cols.Add( colSA_BSTR, 1 );
    cols.Add( colSA_VARIANT, 2 );
    cols.Add( colSA_R8, 3 );
    cols.Add( colSA_DATE, 4 );
    cols.Add( colSA_BOOL, 5 );
    cols.Add( colSA_DECIMAL, 6 );
    cols.Add( colSA_I1, 7 );
    cols.Add( colSA_R4, 8 );
    cols.Add( colSA_CY, 9 );
    cols.Add( colSA_UINT, 10 );
    cols.Add( colSA_INT, 11 );
    cols.Add( colSA_ERROR, 12 );

    BOOL fSeq = isEven( numTest );

    CDbSortSet ss( 1 );
    ss.Add( colSA_VARIANT, 0 );

    //
    // Do it!
    //

    CDbCmdTreeNode * pDbCmdTree = FormQueryTree( &PropRst,
                                                 cols,
                                                 fSeq ? 0 : &ss );

    ICommandTree * pCmdTree = 0;

    IRowsetScroll * pRowset = InstantiateRowset(
                                pQuery,
                                QUERY_SHALLOW,           // Depth
                                0,
                                pDbCmdTree,              // DBCOMMANDTREE
                                fSeq ? IID_IRowset : IID_IRowsetScroll,   // IID for i/f to return
                                0,
                                &pCmdTree );

    //
    // Verify columns
    //
    CheckColumns( pRowset, cols, TRUE );

    if ( !WaitForCompletion( pRowset, TRUE ) )
    {
        pCmdTree->Release();
        pRowset->Release();
        LogFail( "property query unsuccessful.\n" );
    }

    //
    // Get data
    //

    DBCOUNTITEM cRowsReturned = 0;
    HROW* pgrhRows = 0;

    SCODE sc = pRowset->GetNextRows(0, 0, 10, &cRowsReturned, &pgrhRows);

    if ( FAILED( sc ) )
    {
        pCmdTree->Release();
        pRowset->Release();
        LogFail( "IRowset->GetRowsAt G returned 0x%x\n", sc );
    }

    if ( 0 == cExpectedHits )
    {
        pCmdTree->Release();
        pRowset->Release();

        if ( cRowsReturned > 0 )
            LogFail("RunPropQuery, %d returned rows, expected none\n",
                    cRowsReturned);
        else
            return;

    }

    if (sc != DB_S_ENDOFROWSET &&
        cRowsReturned != 10)
    {
        LogError( "IRowset->GetRowsAt H returned %d of %d rows,"
                " status (%x) != DB_S_ENDOFROWSET\n",
                    cRowsReturned, 10,
                    sc);
        pCmdTree->Release();
        pRowset->Release();
#if defined(UNIT_TEST)
        cFailures++;
        return;
#else
        Fail();
#endif
    }

    //
    //  Expect 1 or 2 hits
    //
    if (sc != DB_S_ENDOFROWSET || cRowsReturned != cExpectedHits)
    {
        LogError( "IRowset->GetRowsAt I returned %d rows (expected %d),"
                 " status (%x)\n",
                cRowsReturned, cExpectedHits, sc );
        pCmdTree->Release();
        pRowset->Release();
#if defined(UNIT_TEST)
        cFailures++;
        return;
#else
        Fail();
#endif
    }

    //
    // Patch the column index numbers with true column ids
    //

    DBID aDbCols[cSafeArrayTestColsTight];
    aDbCols[0] =  colSA_I4;
    aDbCols[1] =  colSA_BSTR;
    aDbCols[2] =  colSA_VARIANT;
    aDbCols[3] =  colSA_R8;
    aDbCols[4] =  colSA_DATE;
    aDbCols[5] =  colSA_BOOL;
    aDbCols[6] =  colSA_DECIMAL;
    aDbCols[7] =  colSA_I1;
    aDbCols[8] =  colSA_R4;
    aDbCols[9] =  colSA_CY;
    aDbCols[10] = colSA_UINT;
    aDbCols[11] = colSA_INT;
    aDbCols[12] = colSA_ERROR;

    IUnknown * pAccessor = (IUnknown *) pRowset;  // hAccessor must be created on rowset
                                 // to be used with rowset->GetData below
    HACCESSOR hAccessor = MapColumns( pAccessor,
                                      cSafeArrayTestColsTight,
                                      aSafeArrayTestColsTight,
                                      aDbCols,
                                      TRUE );

    //
    // Fetch the data
    //

    SSafeArrayTestColsTight saData;

    for (unsigned row = 0; row < cRowsReturned; row++)
    {
        sc = pRowset->GetData(pgrhRows[row], hAccessor, &saData );

        if (S_OK != sc)
        {
            LogError("IRowset->GetData returned 0x%x (expected 0)\n",sc);
            pCmdTree->Release();
            pRowset->Release();
            Fail();
        }

        //
        // Verify the data.
        //

        PROPVARIANT var;

        var.vt = VT_ARRAY | VT_I4;
        var.parray = saData.a_I4;
        CheckPropertyValue( var, vaI4 );

        var.vt = VT_ARRAY | VT_BSTR;
        var.parray = saData.a_BSTR;
        CheckPropertyValue( var, vaBSTR );

        var.vt = VT_ARRAY | VT_VARIANT;
        var.parray = saData.a_VARIANT;
        CheckPropertyValue( var, vaVARIANT );

        var.vt = VT_ARRAY | VT_R8;
        var.parray = saData.a_R8;
        CheckPropertyValue( var, vaR8 );

        var.vt = VT_ARRAY | VT_DATE;
        var.parray = saData.a_DATE;
        CheckPropertyValue( var, vaDATE );

        var.vt = VT_ARRAY | VT_BOOL;
        var.parray = saData.a_BOOL;
        CheckPropertyValue( var, vaBOOL );

        var.vt = VT_ARRAY | VT_DECIMAL;
        var.parray = saData.a_DECIMAL;
        CheckPropertyValue( var, vaDECIMAL );

        var.vt = VT_ARRAY | VT_I1;
        var.parray = saData.a_I1;
        CheckPropertyValue( var, vaI1 );

        var.vt = VT_ARRAY | VT_R4;
        var.parray = saData.a_R4;
        CheckPropertyValue( var, vaR4 );

        var.vt = VT_ARRAY | VT_CY;
        var.parray = saData.a_CY;
        CheckPropertyValue( var, vaCY );

        var.vt = VT_ARRAY | VT_UINT;
        var.parray = saData.a_UINT;
        CheckPropertyValue( var, vaUINT );

        var.vt = VT_ARRAY | VT_INT;
        var.parray = saData.a_INT;
        CheckPropertyValue( var, vaINT );

        var.vt = VT_ARRAY | VT_ERROR;
        var.parray = saData.a_ERROR;
        CheckPropertyValue( var, vaERROR );
    }

    sc = pRowset->ReleaseRows( cRowsReturned, pgrhRows, 0, 0, 0);

    if (S_OK != sc)
    {
        LogError("IRowset->ReleaseRows returned 0x%x (expected 0)\n",sc);
        pCmdTree->Release();
        pRowset->Release();
        Fail();
    }

    CoTaskMemFree(pgrhRows);
    pgrhRows = 0;

    //
    // Clean up.
    //

    ReleaseAccessor( pAccessor, hAccessor);

    pCmdTree->Release();
    pRowset->Release();
} //RunSafeArrayTightBindings

static DBBINDING aSafeArrayTestByRefCols[] =
{
  { 0, 0 * cbPPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    cbPPV, 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0},
  { 1, 1 * cbPPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    cbPPV, 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0},
  { 2, 2 * cbPPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    cbPPV, 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0},
  { 3, 3 * cbPPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    cbPPV, 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0},
  { 4, 4 * cbPPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    cbPPV, 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0},
  { 5, 5 * cbPPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    cbPPV, 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0},
  { 6, 6 * cbPPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    cbPPV, 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0},
  { 7, 7 * cbPPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    cbPPV, 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0},
  { 8, 8 * cbPPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    cbPPV, 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0},
  { 9, 9 * cbPPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    cbPPV, 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0},
  { 10,10* cbPPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    cbPPV, 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0},
  { 11,11* cbPPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    cbPPV, 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0},
  { 12,12* cbPPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_PROVIDEROWNED, DBPARAMIO_NOTPARAM,
    cbPPV, 0, DBTYPE_VARIANT|DBTYPE_BYREF, 0, 0},
};

const ULONG cSafeArrayTestByRefCols = sizeof aSafeArrayTestByRefCols / sizeof aSafeArrayTestByRefCols[0];

void RunSafeArrayByRefBindings(
    ICommand * pQuery,
    CDbRestriction & PropRst,
    unsigned cExpectedHits,
    unsigned numTest )
{
    //
    // Get 13 properties back
    //

    CDbColumns cols(cSafeArrayTestByRefCols);
    cols.Add( colSA_I4, 0 );
    cols.Add( colSA_BSTR, 1 );
    cols.Add( colSA_VARIANT, 2 );
    cols.Add( colSA_R8, 3 );
    cols.Add( colSA_DATE, 4 );
    cols.Add( colSA_BOOL, 5 );
    cols.Add( colSA_DECIMAL, 6 );
    cols.Add( colSA_I1, 7 );
    cols.Add( colSA_R4, 8 );
    cols.Add( colSA_CY, 9 );
    cols.Add( colSA_UINT, 10 );
    cols.Add( colSA_INT, 11 );
    cols.Add( colSA_ERROR, 12 );

    BOOL fSeq = isEven( numTest );

    CDbSortSet ss( 1 );
    ss.Add( colSA_CY, 0 );

    //
    // Do it!
    //

    CDbCmdTreeNode * pDbCmdTree = FormQueryTree( &PropRst,
                                                 cols,
                                                 fSeq ? 0 : &ss );

    ICommandTree * pCmdTree = 0;

    IRowsetScroll * pRowset = InstantiateRowset(
                                pQuery,
                                QUERY_SHALLOW,           // Depth
                                0,
                                pDbCmdTree,              // DBCOMMANDTREE
                                fSeq ? IID_IRowset : IID_IRowsetScroll,   // IID for i/f to return
                                0,
                                &pCmdTree );

    //
    // Verify columns
    //
    CheckColumns( pRowset, cols, TRUE );

    if ( !WaitForCompletion( pRowset, TRUE ) )
    {
        pCmdTree->Release();
        pRowset->Release();
        LogFail( "property query unsuccessful.\n" );
    }

    //
    // Get data
    //

    DBCOUNTITEM cRowsReturned = 0;
    HROW* pgrhRows = 0;

    SCODE sc = pRowset->GetNextRows(0, 0, 10, &cRowsReturned, &pgrhRows);

    if ( FAILED( sc ) )
    {
        pCmdTree->Release();
        pRowset->Release();
        LogFail( "IRowset->GetRowsAt G returned 0x%x\n", sc );
    }

    if ( 0 == cExpectedHits )
    {
        pCmdTree->Release();
        pRowset->Release();

        if ( cRowsReturned > 0 )
            LogFail("RunPropQuery, %d returned rows, expected none\n",
                    cRowsReturned);
        else
            return;

    }

    if (sc != DB_S_ENDOFROWSET &&
        cRowsReturned != 10)
    {
        LogError( "IRowset->GetRowsAt H returned %d of %d rows,"
                " status (%x) != DB_S_ENDOFROWSET\n",
                    cRowsReturned, 10,
                    sc);
        pCmdTree->Release();
        pRowset->Release();
#if defined(UNIT_TEST)
        cFailures++;
        return;
#else
        Fail();
#endif
    }

    //
    //  Expect 1 or 2 hits
    //
    if (sc != DB_S_ENDOFROWSET || cRowsReturned != cExpectedHits)
    {
        LogError( "IRowset->GetRowsAt I returned %d rows (expected %d),"
                 " status (%x)\n",
                cRowsReturned, cExpectedHits, sc );
        pCmdTree->Release();
        pRowset->Release();
#if defined(UNIT_TEST)
        cFailures++;
        return;
#else
        Fail();
#endif
    }

    //
    // Patch the column index numbers with true column ids
    //

    DBID aDbCols[cSafeArrayTestByRefCols];
    aDbCols[0] =  colSA_I4;
    aDbCols[1] =  colSA_BSTR;
    aDbCols[2] =  colSA_VARIANT;
    aDbCols[3] =  colSA_R8;
    aDbCols[4] =  colSA_DATE;
    aDbCols[5] =  colSA_BOOL;
    aDbCols[6] =  colSA_DECIMAL;
    aDbCols[7] =  colSA_I1;
    aDbCols[8] =  colSA_R4;
    aDbCols[9] =  colSA_CY;
    aDbCols[10] = colSA_UINT;
    aDbCols[11] = colSA_INT;
    aDbCols[12] = colSA_ERROR;

    IUnknown * pAccessor = (IUnknown *) pRowset;  // hAccessor must be created on rowset
                                 // to be used with rowset->GetData below
    HACCESSOR hAccessor = MapColumns( pAccessor,
                                      cSafeArrayTestByRefCols,
                                      aSafeArrayTestByRefCols,
                                      aDbCols,
                                      TRUE );

    //
    // Fetch the data
    //

    PROPVARIANT * aVarnt[cSafeArrayTestByRefCols];

    for (unsigned row = 0; row < cRowsReturned; row++)
    {
        sc = pRowset->GetData(pgrhRows[row], hAccessor, aVarnt);

        if (S_OK != sc)
        {
            LogError("IRowset->GetData returned 0x%x (expected 0)\n",sc);
            pCmdTree->Release();
            pRowset->Release();
            Fail();
        }

        //
        // Verify the data.
        //

        CheckPropertyValue( *aVarnt[0], vaI4 );
        CheckPropertyValue( *aVarnt[1], vaBSTR );
        CheckPropertyValue( *aVarnt[2], vaVARIANT );
        CheckPropertyValue( *aVarnt[3], vaR8 );
        CheckPropertyValue( *aVarnt[4], vaDATE );
        CheckPropertyValue( *aVarnt[5], vaBOOL );
        CheckPropertyValue( *aVarnt[6], vaDECIMAL );
        CheckPropertyValue( *aVarnt[7], vaI1 );
        CheckPropertyValue( *aVarnt[8], vaR4 );
        CheckPropertyValue( *aVarnt[9], vaCY );
        CheckPropertyValue( *aVarnt[10], vaUINT );
        CheckPropertyValue( *aVarnt[11], vaINT );
        CheckPropertyValue( *aVarnt[12], vaERROR );
    }

    sc = pRowset->ReleaseRows( cRowsReturned, pgrhRows, 0, 0, 0);

    if (S_OK != sc)
    {
        LogError("IRowset->ReleaseRows returned 0x%x (expected 0)\n",sc);
        pCmdTree->Release();
        pRowset->Release();
        Fail();
    }

    CoTaskMemFree(pgrhRows);
    pgrhRows = 0;

    //
    // Clean up.
    //

    ReleaseAccessor( pAccessor, hAccessor);

    pCmdTree->Release();
    pRowset->Release();
} //RunSafeArrayByRefBindings

static DBBINDING aSafeArrayTestCols[] =
{
  { 0, 0 * cbPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    cbPV, 0, DBTYPE_VARIANT, 0, 0},
  { 1, 1 * cbPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    cbPV, 0, DBTYPE_VARIANT, 0, 0},
  { 2, 2 * cbPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    cbPV, 0, DBTYPE_VARIANT, 0, 0},
  { 3, 3 * cbPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    cbPV, 0, DBTYPE_VARIANT, 0, 0},
  { 4, 4 * cbPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    cbPV, 0, DBTYPE_VARIANT, 0, 0},
  { 5, 5 * cbPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    cbPV, 0, DBTYPE_VARIANT, 0, 0},
  { 6, 6 * cbPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    cbPV, 0, DBTYPE_VARIANT, 0, 0},
  { 7, 7 * cbPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    cbPV, 0, DBTYPE_VARIANT, 0, 0},
  { 8, 8 * cbPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    cbPV, 0, DBTYPE_VARIANT, 0, 0},
  { 9, 9 * cbPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    cbPV, 0, DBTYPE_VARIANT, 0, 0},
  { 10,10* cbPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    cbPV, 0, DBTYPE_VARIANT, 0, 0},
  { 11,11* cbPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    cbPV, 0, DBTYPE_VARIANT, 0, 0},
  { 12,12* cbPV, 0, 0,
    0, 0, 0,
    DBPART_VALUE, DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    cbPV, 0, DBTYPE_VARIANT, 0, 0},
};

const ULONG cSafeArrayTestCols = sizeof aSafeArrayTestCols / sizeof aSafeArrayTestCols[0];

void RunSafeArrayQuery(
    ICommand * pQuery,
    CDbRestriction & PropRst,
    unsigned cExpectedHits,
    unsigned numTest )
{
    RunSafeArrayTightBindings( pQuery, PropRst, cExpectedHits, numTest );
    RunSafeArrayByRefBindings( pQuery, PropRst, cExpectedHits, numTest );

    //
    // Get twelve properties back
    //

    CDbColumns cols(cSafeArrayTestCols);
    cols.Add( colSA_I4, 0 );
    cols.Add( colSA_BSTR, 1 );
    cols.Add( colSA_VARIANT, 2 );
    cols.Add( colSA_R8, 3 );
    cols.Add( colSA_DATE, 4 );
    cols.Add( colSA_BOOL, 5 );
    cols.Add( colSA_DECIMAL, 6 );
    cols.Add( colSA_I1, 7 );
    cols.Add( colSA_R4, 8 );
    cols.Add( colSA_CY, 9 );
    cols.Add( colSA_UINT, 10 );
    cols.Add( colSA_INT, 11 );
    cols.Add( colSA_ERROR, 12 );

    BOOL fSeq = isEven( numTest );

    CDbSortSet ss( 1 );
    ss.Add( colSA_BSTR, 0 );

    //
    // Do it!
    //

    CDbCmdTreeNode * pDbCmdTree = FormQueryTree( &PropRst,
                                                 cols,
                                                 fSeq ? 0 : &ss );

    ICommandTree * pCmdTree = 0;

    IRowsetScroll * pRowset = InstantiateRowset(
                                pQuery,
                                QUERY_SHALLOW,           // Depth
                                0,
                                pDbCmdTree,              // DBCOMMANDTREE
                                fSeq ? IID_IRowset : IID_IRowsetScroll,   // IID for i/f to return
                                0,
                                &pCmdTree );

    //
    // Verify columns
    //
    CheckColumns( pRowset, cols, TRUE );

    if ( !WaitForCompletion( pRowset, TRUE ) )
    {
        pCmdTree->Release();
        pRowset->Release();
        LogFail( "property query unsuccessful.\n" );
    }

    //
    // Get data
    //

    DBCOUNTITEM cRowsReturned = 0;
    HROW* pgrhRows = 0;

    SCODE sc = pRowset->GetNextRows(0, 0, 10, &cRowsReturned, &pgrhRows);

    if ( FAILED( sc ) )
    {
        pCmdTree->Release();
        pRowset->Release();
        LogFail( "IRowset->GetRowsAt G returned 0x%x\n", sc );
    }

    if ( 0 == cExpectedHits )
    {
        pCmdTree->Release();
        pRowset->Release();

        if ( cRowsReturned > 0 )
            LogFail("RunPropQuery, %d returned rows, expected none\n",
                    cRowsReturned);
        else
            return;

    }

    if (sc != DB_S_ENDOFROWSET &&
        cRowsReturned != 10)
    {
        LogError( "IRowset->GetRowsAt H returned %d of %d rows,"
                " status (%x) != DB_S_ENDOFROWSET\n",
                    cRowsReturned, 10,
                    sc);
        pCmdTree->Release();
        pRowset->Release();
#if defined(UNIT_TEST)
        cFailures++;
        return;
#else
        Fail();
#endif
    }

    //
    //  Expect 1 or 2 hits
    //
    if (sc != DB_S_ENDOFROWSET || cRowsReturned != cExpectedHits)
    {
        LogError( "IRowset->GetRowsAt I returned %d rows (expected %d),"
                 " status (%x)\n",
                cRowsReturned, cExpectedHits, sc );
        pCmdTree->Release();
        pRowset->Release();
#if defined(UNIT_TEST)
        cFailures++;
        return;
#else
        Fail();
#endif
    }

    //
    // Patch the column index numbers with true column ids
    //

    DBID aDbCols[cSafeArrayTestCols];
    aDbCols[0] =  colSA_I4;
    aDbCols[1] =  colSA_BSTR;
    aDbCols[2] =  colSA_VARIANT;
    aDbCols[3] =  colSA_R8;
    aDbCols[4] =  colSA_DATE;
    aDbCols[5] =  colSA_BOOL;
    aDbCols[6] =  colSA_DECIMAL;
    aDbCols[7] =  colSA_I1;
    aDbCols[8] =  colSA_R4;
    aDbCols[9] =  colSA_CY;
    aDbCols[10] = colSA_UINT;
    aDbCols[11] = colSA_INT;
    aDbCols[12] = colSA_ERROR;

    IUnknown * pAccessor = (IUnknown *) pRowset;  // hAccessor must be created on rowset
                                 // to be used with rowset->GetData below
    HACCESSOR hAccessor = MapColumns(pAccessor, cSafeArrayTestCols, aSafeArrayTestCols, aDbCols);

    //
    // Fetch the data
    //

    PROPVARIANT aVarnt[cSafeArrayTestCols];

    for (unsigned row = 0; row < cRowsReturned; row++)
    {
        sc = pRowset->GetData(pgrhRows[row], hAccessor, aVarnt);

        if (S_OK != sc)
        {
            LogError("IRowset->GetData returned 0x%x (expected 0)\n",sc);
            pCmdTree->Release();
            pRowset->Release();
            Fail();
        }

        //
        // Verify the data.
        //

        CheckPropertyValue( aVarnt[0], vaI4 );
        CheckPropertyValue( aVarnt[1], vaBSTR );
        CheckPropertyValue( aVarnt[2], vaVARIANT );
        CheckPropertyValue( aVarnt[3], vaR8 );
        CheckPropertyValue( aVarnt[4], vaDATE );
        CheckPropertyValue( aVarnt[5], vaBOOL );
        CheckPropertyValue( aVarnt[6], vaDECIMAL );
        CheckPropertyValue( aVarnt[7], vaI1 );
        CheckPropertyValue( aVarnt[8], vaR4 );
        CheckPropertyValue( aVarnt[9], vaCY );
        CheckPropertyValue( aVarnt[10], vaUINT );
        CheckPropertyValue( aVarnt[11], vaINT );
        CheckPropertyValue( aVarnt[12], vaERROR );
        for ( int i = 0; i < 13; i++ )
            PropVariantClear( & aVarnt[i] );
    }

    sc = pRowset->ReleaseRows( cRowsReturned, pgrhRows, 0, 0, 0);

    if (S_OK != sc)
    {
        LogError("IRowset->ReleaseRows returned 0x%x (expected 0)\n",sc);
        pCmdTree->Release();
        pRowset->Release();
        Fail();
    }

    CoTaskMemFree(pgrhRows);
    pgrhRows = 0;

    //
    // Clean up.
    //

    ReleaseAccessor( pAccessor, hAccessor);

    pCmdTree->Release();
    pRowset->Release();
} //RunSafeArrayQuery

//+-------------------------------------------------------------------------
//
//  Function:   RunSafeArrayTest, public
//
//  Synopsis:   Very minimal test of safe array property query
//
//  History:    17-Jun-98       dlee   Created
//
//--------------------------------------------------------------------------

void RunSafeArrayTest( void )
{
    LogProgress( "SafeArray Retrieval Test\n" );

    WCHAR *pwszScope = wcsTestPath;
    DWORD dwDepth = QUERY_SHALLOW;
    IUnknown * pIUnknown;
    ICommand * pQuery = 0;
    SCODE scIC = CICreateCommand( &pIUnknown,
                                  0,
                                  IID_IUnknown,
                                  TEST_CATALOG,
                                  TEST_MACHINE );
    if ( FAILED( scIC ) )
        LogFail( "RunSafeArrayTest - error 0x%x Unable to create ICommand\n",
                 scIC );

    scIC = pIUnknown->QueryInterface(IID_ICommand, (void **) &pQuery );
    pIUnknown->Release();

    if ( FAILED( scIC ) )
        LogFail( "RunSafeArrayTest - error 0x%x Unable to QI ICommand\n",
                 scIC  );

    if ( 0 == pQuery )
        LogFail( "RunSafeArrayTest - CICreateCommand succeeded, but returned null pQuery\n" );

    scIC = SetScopeProperties( pQuery,
                               1,
                               &pwszScope,
                               &dwDepth );

    if ( FAILED( scIC ) )
        LogFail( "RunSafeArrayTest - error 0x%x Unable to set scope '%ws'\n",
                 scIC, pwszScope );

    CheckPropertiesOnCommand( pQuery );

    unsigned numTest = 1;

    {
        LogProgress( " SafeArray test 1\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( colSA_I4 );
        PropRst.SetRelation( DBOP_equal );
        PropRst.SetValue( vaI4 );
        RunSafeArrayQuery( pQuery, PropRst, 2, numTest++ );
    }

    {
        LogProgress( " SafeArray test 2\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( colSA_BSTR );
        PropRst.SetRelation( DBOP_equal );
        PropRst.SetValue( vaBSTR );
        RunSafeArrayQuery( pQuery, PropRst, 2, numTest++ );
    }

    {
        LogProgress( " SafeArray test 3\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( colSA_VARIANT );
        PropRst.SetRelation( DBOP_equal );
        PropRst.SetValue( vaVARIANT );
        RunSafeArrayQuery( pQuery, PropRst, 2, numTest++ );
    }

    {
        LogProgress( " SafeArray test 4\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( colSA_R8 );
        PropRst.SetRelation( DBOP_equal );
        PropRst.SetValue( vaR8 );
        RunSafeArrayQuery( pQuery, PropRst, 2, numTest++ );
    }

    {
        LogProgress( " SafeArray test 5\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( colSA_DATE );
        PropRst.SetRelation( DBOP_equal );
        PropRst.SetValue( vaDATE );
        RunSafeArrayQuery( pQuery, PropRst, 2, numTest++ );
    }

    {
        LogProgress( " SafeArray test 6\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( colSA_BOOL );
        PropRst.SetRelation( DBOP_equal );
        PropRst.SetValue( vaBOOL );
        RunSafeArrayQuery( pQuery, PropRst, 2, numTest++ );
    }

    {
        LogProgress( " SafeArray test 7\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( colSA_DECIMAL );
        PropRst.SetRelation( DBOP_equal );
        PropRst.SetValue( vaDECIMAL );
        RunSafeArrayQuery( pQuery, PropRst, 2, numTest++ );
    }

    {
        LogProgress( " SafeArray test 8\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( colSA_I1 );
        PropRst.SetRelation( DBOP_equal );
        PropRst.SetValue( vaI1 );
        RunSafeArrayQuery( pQuery, PropRst, 2, numTest++ );
    }

    {
        LogProgress( " SafeArray test 9\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( colSA_R4 );
        PropRst.SetRelation( DBOP_equal );
        PropRst.SetValue( vaR4 );
        RunSafeArrayQuery( pQuery, PropRst, 2, numTest++ );
    }

    {
        LogProgress( " SafeArray test 10\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( colSA_CY );
        PropRst.SetRelation( DBOP_equal );
        PropRst.SetValue( vaCY );
        RunSafeArrayQuery( pQuery, PropRst, 2, numTest++ );
    }

    {
        LogProgress( " SafeArray test 11\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( colSA_UINT );
        PropRst.SetRelation( DBOP_equal );
        PropRst.SetValue( vaUINT );
        RunSafeArrayQuery( pQuery, PropRst, 2, numTest++ );
    }

    {
        LogProgress( " SafeArray test 12\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( colSA_INT );
        PropRst.SetRelation( DBOP_equal );
        PropRst.SetValue( vaINT );
        RunSafeArrayQuery( pQuery, PropRst, 2, numTest++ );
    }

    {
        LogProgress( " SafeArray test 13\n" );
        CDbPropertyRestriction PropRst;
        PropRst.SetProperty( colSA_ERROR );
        PropRst.SetRelation( DBOP_equal );
        PropRst.SetValue( vaERROR );
        RunSafeArrayQuery( pQuery, PropRst, 2, numTest++ );
    }

    pQuery->Release();
} //RunSafeArrayTest

//+-------------------------------------------------------------------------
//
//  Function:   CheckPropertyValue, public
//
//  Synopsis:   Check that a returned property value is as expected
//
//  Arguments:  [varntPropRet] -- Returned property value
//              [varntPropExp] -- Expected property value
//
//  Returns:    nothing - calls Fail() if error
//
//  History:    20 Oct 93       Alanw     Created
//
//--------------------------------------------------------------------------

void CheckPropertyValue(
    PROPVARIANT const & varntPropRet,
    PROPVARIANT const & varntPropExp
) {
    if ( varntPropRet.vt != varntPropExp.vt )
    {
        LogError( "Invalid return data type for property!\n" );
        LogError( "   Got %x expected %x\n",
                varntPropRet.vt, varntPropExp.vt );
        cFailures++;
        //Fail();
    }
    else if (varntPropExp.vt & VT_ARRAY)
    {
        SAFEARRAY * pSaRet = varntPropRet.parray;
        SAFEARRAY * pSaExp = varntPropExp.parray;

        if (pSaRet->fFeatures != pSaExp->fFeatures ||
         //   pSaRet->cLocks    != pSaExp->cLocks    ||
            pSaRet->cDims     != pSaExp->cDims     ||
            pSaRet->cbElements!= pSaExp->cbElements)
        {
            LogError( "Mismatched safearray param!\n" );
            LogError( "   Got %x expected %x\n", pSaRet, pSaExp );
            cFailures++;
            //Fail();
        }
        else
        {
            BOOL fValuesEqual = TRUE;
            unsigned cDataElements = 1;

            //
            // get total data memory, and number of data elements in it.
            //
            for ( unsigned i = 0; i < pSaExp->cDims; i++ )
            {
                if ( pSaExp->rgsabound[i].cElements != pSaRet->rgsabound[i].cElements ||
                     pSaExp->rgsabound[i].lLbound != pSaRet->rgsabound[i].lLbound )
                {
                    LogError( "Mismatched safearray dimension %d!\n", i );
                    LogError( "   Got %x expected %x\n", pSaRet, pSaExp );
                    fValuesEqual = FALSE;
                    //Fail();
                }

                cDataElements *= pSaExp->rgsabound[i].cElements;
            }

            if (fValuesEqual)
            {
                ULONG cb = cDataElements * pSaExp->cbElements;
                if ( varntPropExp.vt == (VT_ARRAY|VT_VARIANT ))
                {
                    // Not needed as the engine doesn't support it yet.

                    LogError( "can't validate arrays of variant\n" );
                }
                else if (varntPropExp.vt != (VT_ARRAY|VT_BSTR))
                {
                    fValuesEqual = memcmp( pSaExp->pvData, pSaRet->pvData, cb ) == 0;
                    if (! fValuesEqual)
                    {
                        if ( 0 == ( cb % sizeof ULONGLONG ) )
                        {
                            ULONG c = cb / sizeof ULONGLONG;
                            unsigned __int64 *pE = (unsigned __int64 *) pSaExp->pvData;
                            unsigned __int64 *pR = (unsigned __int64 *) pSaRet->pvData;
                            for ( ULONG i = 0; i < c; i++ )
                            {
                                printf( "%d: e %#I64x, r %#I64x\n",
                                        i, pE[i], pR[i] );
                            }
                        }
                        printf( "varntPropExp: %#x\n", varntPropExp.vt );
                        printf( "varntPropRet: %#x\n", varntPropRet.vt );
                        LogError("Incorrect value for safearray property.\n");
                               // "   Got %d, expected %d\n", i,
                               // varntPropRet.cal.pElems[i],
                               // varntPropExp.cal.pElems[i]);
                    }
                }
                else
                {
                    BSTR * rgbstrExp = (BSTR *)pSaExp->pvData;
                    BSTR * rgbstrRet = (BSTR *)pSaRet->pvData;
                    for (unsigned i=0; i<cDataElements; i++)
                    {
                        fValuesEqual = (BSTRLEN(rgbstrRet[i]) ==
                                        BSTRLEN(rgbstrExp[i])) &&
                                       (memcmp(rgbstrRet[i],
                                               rgbstrExp[i],
                                          BSTRLEN(rgbstrExp[i])) == 0);
                        if (! fValuesEqual)
                        {
                            LogError("Incorrect value for BSTR array property [%d].\n"
                                    "   Got <%ws>, expected <%ws>\n", i,
                                    rgbstrRet[i],
                                    rgbstrExp[i]);
                            break;
                        }
                    }
                }
            }

            if (! fValuesEqual)
            {
                cFailures++;
                //Fail();
            }
        }
    }
    else if (varntPropExp.vt & VT_VECTOR)
    {
        if (varntPropExp.cal.cElems != varntPropRet.cal.cElems)
        {
            LogError( "Incorrect value count for property.\n"
                    "   Got count %d, expected count %d\n",
                    varntPropRet.cal.cElems, varntPropExp.cal.cElems);
            cFailures++;
            //Fail();
        }

        BOOL fValuesEqual = FALSE;

        for (unsigned i=0; i<varntPropRet.cal.cElems; i++) {

            switch (varntPropExp.vt)
            {
            case VT_VECTOR|VT_I4:
                fValuesEqual = varntPropRet.cal.pElems[i] ==
                                varntPropExp.cal.pElems[i];
                if (! fValuesEqual)
                    LogError("Incorrect value for vector property [%d].\n"
                            "   Got %d, expected %d\n", i,
                            varntPropRet.cal.pElems[i],
                            varntPropExp.cal.pElems[i]);
                break;

            case VT_VECTOR|VT_LPWSTR:
                fValuesEqual = wcscmp(varntPropRet.calpwstr.pElems[i],
                                      varntPropExp.calpwstr.pElems[i]) == 0;
                if (! fValuesEqual)
                    LogError("Incorrect value for vector property [%d].\n"
                            "   Got <%ws>, expected <%ws>\n", i,
                            varntPropRet.calpwstr.pElems[i],
                            varntPropExp.calpwstr.pElems[i]);
                break;

            case VT_VECTOR|VT_BSTR:
                fValuesEqual = (BSTRLEN(varntPropRet.cabstr.pElems[i]) ==
                                BSTRLEN(varntPropExp.cabstr.pElems[i])) &&
                               (memcmp(varntPropRet.cabstr.pElems[i],
                                       varntPropExp.cabstr.pElems[i],
                                  BSTRLEN(varntPropExp.cabstr.pElems[i])) == 0);
                if (! fValuesEqual)
                    LogError("Incorrect value for vector property [%d].\n"
                            "   Got <%ws>, expected <%ws>\n", i,
                            varntPropRet.cabstr.pElems[i],
                            varntPropExp.cabstr.pElems[i]);
                break;

            case VT_VECTOR|VT_CF:
            {
                CLIPDATA & cdR = varntPropRet.caclipdata.pElems[i];
                CLIPDATA & cdE = varntPropExp.caclipdata.pElems[i];
                fValuesEqual = ( ( cdR.cbSize == cdE.cbSize ) &&
                                 ( cdR.ulClipFmt == cdE.ulClipFmt ) &&
                                 ( 0 != cdR.pClipData ) &&
                                 ( 0 != cdE.pClipData ) &&
                                 ( 0 == memcmp( cdR.pClipData,
                                                cdE.pClipData,
                                                CBPCLIPDATA( cdR ) ) ) );
                if ( !fValuesEqual )
                    LogError( "Incorrect value for VT_VECTOR|VT_CF property\n" );
                break;
            }

            default:
                LogError("Unexpected property variant type %x\n", varntPropExp.vt);
            }
            if (! fValuesEqual)
            {
                cFailures++;
                //Fail();
            }
        }
    }
    else
    {
        BOOL fValuesEqual = FALSE;

        switch (varntPropExp.vt)
        {
        case VT_I4:
            fValuesEqual = varntPropRet.iVal == varntPropExp.iVal;
            if (! fValuesEqual)
                LogError("Incorrect value for property.\n"
                         "   Got %d, expected %d\n",
                         varntPropRet.iVal, varntPropExp.iVal);
            break;

        case VT_LPWSTR:
        case DBTYPE_WSTR | DBTYPE_BYREF:
            fValuesEqual = wcscmp(varntPropRet.pwszVal, varntPropExp.pwszVal)
                                == 0;
            if (! fValuesEqual)
                LogError("Incorrect value for property.\n"
                         "   Got <%ws>, expected <%ws>\n",
                         varntPropRet.pwszVal, varntPropExp.pwszVal);
            break;

        case VT_BSTR:
            fValuesEqual =
                ( SysStringLen( varntPropRet.bstrVal ) ==
                  SysStringLen( varntPropExp.bstrVal ) ) &&
                memcmp( varntPropRet.bstrVal, varntPropExp.bstrVal,
                        SysStringLen( varntPropExp.bstrVal ) ) == 0;

            if ( SysStringLen( varntPropRet.bstrVal ) !=
                 SysStringLen( varntPropExp.bstrVal ) )
                LogError("Incorrect BSTR length for property.\n"
                         "   Got %d, expected %d\n",
                         SysStringLen( varntPropRet.bstrVal ),
                         SysStringLen( varntPropExp.bstrVal ) );
            else if (! fValuesEqual)
                LogError("Incorrect value for property.\n"
                         "   Got <%ws>, expected <%ws>\n",
                         varntPropRet.pwszVal, varntPropExp.pwszVal);
            break;

        case VT_CLSID:
            fValuesEqual = *varntPropRet.puuid == *varntPropExp.puuid;

            if (! fValuesEqual)
                LogError("Incorrect value for guid property.\n");
            break;


        case VT_BLOB:
            fValuesEqual =
                (varntPropRet.blob.cbSize == varntPropExp.blob.cbSize) &&
                memcmp(varntPropRet.blob.pBlobData, varntPropExp.blob.pBlobData,
                        varntPropExp.blob.cbSize)
                                == 0;
            if (! fValuesEqual)
                LogError("Incorrect value for blob property.\n");
            break;

        case VT_CF:
        {
            CLIPDATA & cdR = *varntPropRet.pclipdata;
            CLIPDATA & cdE = *varntPropExp.pclipdata;
            fValuesEqual = ( ( cdR.cbSize == cdE.cbSize ) &&
                             ( cdR.ulClipFmt == cdE.ulClipFmt ) &&
                             ( 0 != cdR.pClipData ) &&
                             ( 0 != cdE.pClipData ) &&
                             ( 0 == memcmp( cdR.pClipData,
                                            cdE.pClipData,
                                            CBPCLIPDATA( cdR ) ) ) );
            if ( !fValuesEqual )
                LogError( "Incorrect value for VT_CF property\n" );
            break;
        }

        case VT_EMPTY:
            // nothing to check
            fValuesEqual = TRUE;
            break;

        default:
            LogError("Unexpected property variant type %d\n", varntPropExp.vt);
        }
        if (! fValuesEqual)
        {
            cFailures++;
            //Fail();
        }
    }

    return;
} //CheckPropertyValue


#ifdef DO_CONTENT_TESTS

//+-------------------------------------------------------------------------
//
//  Function:   DoContentQuery, public
//
//  Synopsis:   Execute a retricted content query and check results
//
//  Arguments:  [pQuery]        -- ICommand * for the query
//              [CiRst]         -- content restirction
//              [cExpectedHits] -- expected number of hits
//
//  Returns:    BOOL - FALSE if first content query, and less than the
//                     expected number of hits was found.  Probably indicates
//                     that the content index was not up-to-date.
//
//  History:    01 Aug 1995    AlanW    Created
//
//--------------------------------------------------------------------------

const unsigned MAX_CI_RETRIES = 5;
const unsigned CI_SLEEP_TICKS = 15 * 1000;

BOOL DoContentQuery(
    ICommand * pQuery,
    CDbRestriction & CiRst,
    unsigned cExpectedHits )
{
    static fFirstTime = TRUE;

    //
    // Get three properties back
    //

    CDbColumns cols(3);
    cols.Add( psName, 0 );
    cols.Add( psPath, 1 );
    cols.Add( psRank, 2 );

    //
    // Do it!
    //

    unsigned cRetries = 0;
    DBCOUNTITEM cRowsReturned = 0;
    HROW* pgrhRows = 0;
    SCODE sc;
    IRowset * pRowset = 0;

    do {

        CDbCmdTreeNode * pCmdTree = FormQueryTree(&CiRst, cols, 0);

        pRowset = InstantiateRowset( pQuery,
                                     QUERY_SHALLOW,     // Depth
                                     wcsTestPath,       // Scope
                                     pCmdTree,          // DBCOMMANDTREE
                                     IID_IRowset);      // IID of i/f to return

        //
        // Verify columns
        //
        CheckColumns( pRowset, cols, TRUE );

        if ( !WaitForCompletion( pRowset, TRUE ) )
        {
            LogError( "Content query unsuccessful.\n" );
            pRowset->Release();
            Fail();
        }

        //
        // Get data
        //

        sc = pRowset->GetNextRows(0, 0, 10, &cRowsReturned, &pgrhRows);

        if ( FAILED( sc ) )
        {
            LogError( "IRowset->GetNextRows returned 0x%x\n", sc );
            pRowset->Release();
            Fail();
        }

        //
        // Check to see if the CI is up-to-date
        //

        IRowsetQueryStatus * pRowsetQueryStatus = 0;

        SCODE scTemp = pRowset->QueryInterface(IID_IRowsetQueryStatus,
                                               (void **) &pRowsetQueryStatus);

        if ( FAILED( scTemp ) &&  scTemp != E_NOINTERFACE )
        {
            LogError( "IRowset::QI IRowsetQueryStatus failed, 0x%x\n", sc );
            cFailures++;
        }

        DWORD dwStatus = 0;
        if (pRowsetQueryStatus != 0)
        {
            scTemp = pRowsetQueryStatus->GetStatus( &dwStatus );
            pRowsetQueryStatus->Release();

            if ( QUERY_RELIABILITY_STATUS(dwStatus) & STAT_CONTENT_OUT_OF_DATE )
            {
                FreeHrowsArray( pRowset, cRowsReturned, &pgrhRows );
                pRowset->Release();
                cRetries++;
                if (cRetries < MAX_CI_RETRIES)
                {
                    Sleep( CI_SLEEP_TICKS );
                    continue;
                }
            }
            break;
        }
        else if (fFirstTime && cRowsReturned < cExpectedHits)
        {
            FreeHrowsArray( pRowset, cRowsReturned, &pgrhRows );
            pRowset->Release();
            cRetries++;
            if (cRetries < MAX_CI_RETRIES)
                Sleep( CI_SLEEP_TICKS );
        }
        else
        {
            break;
        }
    } while ( cRetries < MAX_CI_RETRIES );

    if (cRetries >= MAX_CI_RETRIES)
    {
        LogError( "Content query test skipped due to timeout\n" );
        return FALSE;
    }
    fFirstTime = FALSE;

    if ( 0 == cExpectedHits )
    {
        pRowset->Release();

        if ( cRowsReturned > 0 )
            LogFail("DoContentQuery, %d returned rows, expected none\n",
                    cRowsReturned);
        else
            return TRUE;

    }

    if (sc != DB_S_ENDOFROWSET && cRowsReturned != 10)
    {
        LogError( "IRowset->GetNextRows returned %d of %d rows,"
                " status (%x) != DB_S_ENDOFROWSET\n",
                    cRowsReturned, 10,
                    sc);
        pRowset->Release();
#if defined(UNIT_TEST)
        cFailures++;
        return TRUE;
#else
        Fail();
#endif
    }

    //
    //  Expect 1 to 5 hits
    //
    if (sc != DB_S_ENDOFROWSET || cRowsReturned != cExpectedHits)
    {
        LogError( "IRowset->GetNextRows returned %d rows (expected %d),"
                  " status (%x)\n",
                 cRowsReturned, cExpectedHits, sc );
        pRowset->Release();
#if defined(UNIT_TEST)
        cFailures++;
        return TRUE;
#else
        Fail();
#endif
    }

    FreeHrowsArray( pRowset, cRowsReturned, &pgrhRows );

    //
    // Clean up.
    //

    pRowset->Release();
    return TRUE;
} //DoContentQuery


//+-------------------------------------------------------------------------
//
//  Function:   ContentTest, public
//
//  Synopsis:   Very minimal test of Content query
//
//  History:    13-May-93       KyleP   Created
//              15 Oct 94       Alanw   Converted to OLE-DB query
//
//--------------------------------------------------------------------------

void ContentTest()
{
    LogProgress( "Content Query\n" );

    WCHAR *pwszScope = wcsTestPath;

    DWORD dwDepth = QUERY_SHALLOW;
    ICommand * pQuery = 0;
    SCODE scIC = CICreateCommand( (IUnknown **)&pQuery,
                                  0,
                                  IID_ICommand,
                                  CONTENT_CATALOG,
                                  TEST_MACHINE );
    if ( FAILED( scIC ) )
        LogFail( "RunPropTest - error 0x%x Unable to create ICommand\n", scIC );

    if ( 0 == pQuery )
        LogFail( "RunPropTest - CICreateCommand succeeded, but returned null pQuery\n" );

    scIC = SetScopeProperties( pQuery,
                               1,
                               &pwszScope,
                               &dwDepth );

    // simple content query
    {
        LogProgress( " Content Query test 0\n" );
        CDbContentRestriction CiRst( L"country", psContents);
        if (! DoContentQuery( pQuery, CiRst, 2 ))
        {
            pQuery->Release();
            return;
        }
    }

    // content query on property
    {
        LogProgress( " Content Query test 1\n" );
        CDbContentRestriction CiRst( L"alanw", psAuthor);
        DoContentQuery( pQuery, CiRst, 2 );
    }

    // natural language query
    {
        LogProgress( " Content Query test 2\n" );
        CDbNatLangRestriction CiRst( L"who is oscar wilde", psContents);
        DoContentQuery( pQuery, CiRst, 1 );
    }

    // content query with prefix match
    {
        LogProgress( " Content Query test 3\n" );
        CDbContentRestriction CiRst( L"cont", psContents, GENERATE_METHOD_PREFIX );
        DoContentQuery( pQuery, CiRst, 1 );
    }

    // content query with stemming
    {
        LogProgress( " Content Query test 4\n" );
        CDbContentRestriction CiRst( L"temptation", psContents, GENERATE_METHOD_INFLECT );
        DoContentQuery( pQuery, CiRst, 1 );
    }

    // content query with more obscure stemming (prefix match)
    {
        LogProgress( " Content Query test 4A\n" );
        CDbContentRestriction CiRst( L"crea", psContents, GENERATE_METHOD_PREFIX );
        DoContentQuery( pQuery, CiRst, 1 );
    }

    // content query with more obscure stemming (stemmed)
    {
        LogProgress( " Content Query test 4B\n" );
        CDbContentRestriction CiRst( L"crea", psContents, GENERATE_METHOD_INFLECT );
        DoContentQuery( pQuery, CiRst, 0 );
    }

    // content query with more obscure stemming (prefix match)
    {
        LogProgress( " Content Query test 4C\n" );
        CDbContentRestriction CiRst( L"create", psContents, GENERATE_METHOD_PREFIX );
        DoContentQuery( pQuery, CiRst, 1 );
    }

    // content query with more obscure stemming (stemmed)
    {
        LogProgress( " Content Query test 4D\n" );
        CDbContentRestriction CiRst( L"create", psContents, GENERATE_METHOD_INFLECT );
        DoContentQuery( pQuery, CiRst, 1 );
    }

    // and content query
    {
        LogProgress( " Content Query test 5\n" );
        CDbBooleanNodeRestriction CiRst( DBOP_and );
        CDbContentRestriction *pRst1 = new
                  CDbContentRestriction( L"country", psContents);
        CDbContentRestriction *pRst2 = new
                  CDbContentRestriction( L"content", psContents);
        CiRst.AppendChild(pRst1);
        CiRst.AppendChild(pRst2);
        DoContentQuery( pQuery, CiRst, 1 );
    }

    // and not content query
    {
        LogProgress( " Content Query test 6\n" );
        CDbBooleanNodeRestriction CiRst( DBOP_and );
        CDbContentRestriction *pRst1 = new
                  CDbContentRestriction( L"country", psContents);
        CDbContentRestriction *pRst2 = new
                  CDbContentRestriction( L"content", psContents);
        CDbNotRestriction *pRst3 = new CDbNotRestriction( pRst2 );
        CiRst.AppendChild(pRst1);
        CiRst.AppendChild(pRst3);
        DoContentQuery( pQuery, CiRst, 1 );
    }

    // proximity content query
    {
        LogProgress( " Content Query test 7\n" );
        CDbProximityNodeRestriction CiRst;
        CDbContentRestriction *pRst1 = new
                  CDbContentRestriction( L"country", psContents);
        CDbContentRestriction *pRst2 = new
                  CDbContentRestriction( L"temptations", psContents);
        CiRst.AppendChild(pRst1);
        CiRst.AppendChild(pRst2);
        DoContentQuery( pQuery, CiRst, 1 );
    }

    // vector or query
    {
        LogProgress( " Content Query test 8\n" );
        CDbVectorRestriction CiRst( VECTOR_RANK_MIN );
        CDbContentRestriction *pRst1 = new
                  CDbContentRestriction( L"country", psContents);
        CDbContentRestriction *pRst2 = new
                  CDbContentRestriction( L"temptations", psContents);
        CDbContentRestriction *pRst3 = new
                  CDbContentRestriction( L"DELETE", psContents);

        pRst1->SetWeight( 500 );
        pRst2->SetWeight( 1000 );
        pRst3->SetWeight( 50 );

        CiRst.AppendChild( pRst1 );
        CiRst.AppendChild( pRst2 );
        CiRst.AppendChild( pRst3 );

        // This might return 3 if the test directory is on FAT
        const unsigned cMatches = 2;
        DoContentQuery( pQuery, CiRst, cMatches );
    }

    pQuery->Release();
} //ContentTest

#endif // DO_CONTENT_TESTS


#if defined( DO_NOTIFICATION )
class CTestRowsetNotify : public IRowsetNotify
{
    public:
        CTestRowsetNotify() :
            _fChecking(FALSE),
            _cRef(1),
            _dwReasonToCheck(0),
            _cNotifies(0) {}

        ~CTestRowsetNotify()
        {
        }

        void StartCheck(DWORD dwReason)
        {
            _fChecking = TRUE;
            _dwReasonToCheck = dwReason;
            _cNotifies = 0;
        }

        void TestCheck( ULONG cNotifies )
        {
            if (_cNotifies != cNotifies )
                LogError ( "CTestRowsetNotify::TestCheck failed, "
                           "reason %d, exp %d  got %d\n",
                            _dwReasonToCheck, cNotifies, _cNotifies );
            _fChecking = FALSE;
        }

        //
        // IUnknown methods.
        //

        STDMETHOD(QueryInterface) (THIS_ REFIID riid,LPVOID *ppiuk)
            {
                *ppiuk = (void **) this; // hold our breath and jump
                AddRef();
                return S_OK;
            }

        STDMETHOD_(ULONG, AddRef) (THIS)
            { return ++_cRef; }

        STDMETHOD_(ULONG, Release) (THIS)
            { return --_cRef; }

    //
    // IRowsetNotify methods.
    //

    STDMETHOD(OnFieldChange) ( IRowset *    pRowset,
                               HROW         hRow,
                               DBORDINAL    cColumns,
                               DBORDINAL    rgColumns[],
                               DBREASON     eReason,
                               DBEVENTPHASE ePhase,
                               BOOL         fCantDeny )
        {
            if ( _fChecking && eReason == _dwReasonToCheck )
            {
                _cNotifies++;
            }
            return S_OK;
        }

    STDMETHOD(OnRowChange) ( IRowset *    pRowset,
                             DBCOUNTITEM  cRows,
                             const HROW   rghRows[],
                             DBREASON     eReason,
                             DBEVENTPHASE ePhase,
                             BOOL         fCantDeny )
        {
            if ( _fChecking && eReason == _dwReasonToCheck )
            {
                _cNotifies++;
            }
            return S_OK;
        }

    STDMETHOD(OnRowsetChange) ( IRowset *    pRowset,
                                DBREASON     eReason,
                                DBEVENTPHASE ePhase,
                                BOOL         fCantDeny )
        {
            if ( _fChecking && eReason == _dwReasonToCheck )
            {
                _cNotifies++;
            }
            return S_OK;
        }

    private:
        ULONG _cRef;
        BOOL  _fChecking;
        DWORD _dwReasonToCheck;
        ULONG _cNotifies;
};


class CTestWatchNotify : public IRowsetWatchNotify
{
    public:
        CTestWatchNotify() :
            _fChecking(FALSE),
            _fRequery(FALSE),
            _fComplete(FALSE),
            _cRowChanges(0),
            _cRef(1) {}

        void DoChecking(BOOL fChecking)
        {
            _fChecking = fChecking;
        }

        ~CTestWatchNotify()
        {
            if (_fChecking)
            {
                if (1 != _cRef) // NOTE: notify objects are static allocated
                {
                    LogFail( "Bad refcount on CTestWatchNotify: %#x, %d.\n",
                             this, _cRef );
                }
            }
        }

        //
        // IUnknown methods.
        //

        STDMETHOD(QueryInterface) (THIS_ REFIID riid,LPVOID *ppiuk)
            {
                *ppiuk = (void **) this; // hold our breath and jump
                AddRef();
                return S_OK;
            }

        STDMETHOD_(ULONG, AddRef) (THIS)
            { /*printf( "addref: %d\n", _cRef+1 );*/ return ++_cRef; }

        STDMETHOD_(ULONG, Release) (THIS)
            { /*printf( "release: %d\n", _cRef-1 );*/ return --_cRef; }

        //void DumpRef() { printf( "ref: %d\n", _cRef ); }

        //
        // IRowsetNotifyWatch method
        //

        STDMETHOD(OnChange) (THIS_ IRowset* pRowset, DBWATCHNOTIFY changeType)
        {
            switch (changeType)
            {
            case DBWATCHNOTIFY_ROWSCHANGED:
                _cRowChanges++;         break;
            case DBWATCHNOTIFY_QUERYDONE:
                _fComplete = TRUE;      break;
            case DBWATCHNOTIFY_QUERYREEXECUTED:
                _fRequery = TRUE;       break;
            default:
                _BadChangeType = changeType;
            }
            return S_OK;
        }

    private:
        ULONG   _cRef;
        BOOL    _fChecking;
        BOOL    _fComplete;
        BOOL    _fRequery;
        ULONG   _cRowChanges;
        DBWATCHNOTIFY _BadChangeType;
};


//+-------------------------------------------------------------------------
//
//  Function:   NotificationTest, public
//
//  Synopsis:   Test basic notification functionality
//
//  Returns:    Nothing
//
//  Notes:      At the point this is called, the notification has been
//              set up.  This function adds/deletes/modifies files and
//              expects to get notifications of these changes.
//
//  History:    14 Oct 94       dlee    created
//
//--------------------------------------------------------------------------

void NotificationTest()
{
    LogProgress( " Notification test\n" );

    //
    // Makes files in the nt\system32 directory that look like "X.zzz"
    //

    WCHAR wcsSysDir[MAX_PATH];
    if( !GetSystemDirectory( wcsSysDir, sizeof(wcsSysDir) / sizeof(WCHAR) ) )
    {
        LogFail( "Unable to determine system directory.\n" );
    }

    wcscat(wcsSysDir,L"\\X.zzz");
    unsigned iNamePos = wcslen(wcsSysDir) - 5;

    DWORD dwStart = GetTickCount();

    //
    // create / touch / delete files for 5 seconds
    //

    while ((GetTickCount() - dwStart) < 3000)
    {
        Sleep(rand() % 300);

        wcsSysDir[iNamePos] = (WCHAR) ('a' + (rand() % 10));

        HANDLE h = CreateFile(wcsSysDir,
                   GENERIC_READ | GENERIC_WRITE,
                   FILE_SHARE_READ,
                   0,
                   OPEN_ALWAYS,
                   FILE_ATTRIBUTE_NORMAL |
                   (((rand() % 103) < 20) ? FILE_FLAG_DELETE_ON_CLOSE : 0),
                   0);

        if (INVALID_HANDLE_VALUE != h)
        {
            DWORD dw = 0xf0f0f0f0;
            DWORD dwWritten;
            WriteFile(h,&dw,sizeof(DWORD),&dwWritten,0);

            CloseHandle(h);
        }
        else
        {
            LogFail( "Can't create test file in the system32 directory.\n" );
        }
    }

    //
    // sleep some more to pick up all the notifications
    //

    Sleep(1000);

} //NotificationTest
#endif // defined( DO_NOTIFICATION )



//+-------------------------------------------------------------------------
//
//  Function:   CheckColumns, public
//
//  Synopsis:   Verify that the cursor contains all the requested columns
//              Also, check to see if the IColumnsInfo and IColumnsRowset
//              interfaces are supported.  Print out column info. and rowset
//              properties if the very verbose option is chosen.
//
//  Arguments:  [pRowset] - a pointer to an IRowset* to be tested.
//              [rColumns] - a reference to a CDbColumns giving the input
//                      columns
//
//  Returns:    Nothing
//
//  Notes:      This function may be called prior to the rowset population
//              having completed.
//
//  History:    14 Nov 94       Alanw   Created
//
//--------------------------------------------------------------------------


char *DBTYPE_Tag (DBTYPE type)
{
    #define CASE(name) \
            case DBTYPE_ ## name: \
                    return #name

    switch (type)
    {
    CASE (NULL);
    CASE (BOOL);
    CASE (I1);
    CASE (UI1);
    CASE (I2);
    CASE (I4);
    CASE (UI2);
    CASE (UI4);
    CASE (I8);
    CASE (UI8);
    CASE (R4);
    CASE (R8);
    CASE (CY);
    CASE (DATE);
    CASE (VARIANT);
    CASE (GUID);
    CASE (STR);
    CASE (BYTES);
    CASE (WSTR);
    CASE (NUMERIC);

    default:
        return "BAD";
    }

    #undef CASE
}

void PrintColumnFlags (DBCOLUMNFLAGS flags)
{
    #define FLAG(name) \
            if (flags & DBCOLUMNFLAGS_ ## name) \
                    printf (#name " ")

    FLAG (ISBOOKMARK);
    FLAG (MAYDEFER);
//  FLAG (MAYREFERENCE);
    FLAG (WRITE);
    FLAG (WRITEUNKNOWN);
//  FLAG (ISSIGNED);
    FLAG (ISFIXEDLENGTH);
    FLAG (ISNULLABLE);
    FLAG (MAYBENULL);
    FLAG (ISCHAPTER);
    FLAG (ISLONG);
    FLAG (ISROWID);
    FLAG (ISROWVER);
    FLAG (CACHEDEFERRED);

    #undef FLAG
}


DBPROP * LocateProperty (
    REFIID rPropSet,
    DWORD  dwPropId,
    ULONG cPropSets,
    DBPROPSET * pPropSets)
{
    for (unsigned i=0; i<cPropSets; i++, pPropSets++)
    {
        if (pPropSets->guidPropertySet != rPropSet)
            continue;

        for (unsigned j=0; j<pPropSets->cProperties; j++)
        {
            if (pPropSets->rgProperties[j].dwPropertyID == dwPropId)
                return &pPropSets->rgProperties[j];
        }
        return 0;
    }

    return 0;
}

DBPROPINFO UNALIGNED * LocatePropertyInfo (
    REFIID rPropSet,
    DWORD  dwPropId,
    ULONG cPropInfoSets,
    DBPROPINFOSET * pPropInfoSets)
{
    for (unsigned i=0; i<cPropInfoSets; i++, pPropInfoSets++)
    {
        if (pPropInfoSets->guidPropertySet != rPropSet)
            continue;

        for (unsigned j=0; j<pPropInfoSets->cPropertyInfos; j++)
        {
            if (pPropInfoSets->rgPropertyInfos[j].dwPropertyID == dwPropId)
                return &pPropInfoSets->rgPropertyInfos[j];
        }
        return 0;
    }

    return 0;
}

BOOL CheckBooleanProperty (
    REFIID rPropSet,
    DWORD  dwPropId,
    ULONG cProps,
    DBPROPSET * pProps)
{
    DBPROP * pPropDesc = LocateProperty( rPropSet, dwPropId, cProps, pProps );

    if (pPropDesc)
    {
        if ( !( (pPropDesc->vValue.vt == VT_EMPTY &&
                 pPropDesc->dwStatus == DBPROPSTATUS_NOTSUPPORTED)  ||
                (pPropDesc->vValue.vt == VT_BOOL &&
                 (pPropDesc->vValue.boolVal == VARIANT_TRUE ||
                  pPropDesc->vValue.boolVal == VARIANT_FALSE)) ) )
        {
            LogError( "Bad boolean property value %d, %d\n",
                       pPropDesc->vValue.vt, pPropDesc->vValue.lVal );
        }
        return (pPropDesc->vValue.vt == VT_BOOL &&
                pPropDesc->vValue.boolVal == VARIANT_TRUE);
    }
    return FALSE;
}

BOOL CheckNumericProperty (
    REFIID rPropSet,
    DWORD  dwPropId,
    ULONG cProps,
    DBPROPSET * pProps,
    LONG & rlVal)
{
    DBPROP * pPropDesc = LocateProperty( rPropSet, dwPropId, cProps, pProps );

    if (pPropDesc)
    {
        if ( !( (pPropDesc->vValue.vt == VT_EMPTY &&
                 pPropDesc->dwStatus == DBPROPSTATUS_NOTSUPPORTED)  ||
                (pPropDesc->vValue.vt == VT_I4) ) )
        {
            LogError( "Bad numeric property value %d\n", pPropDesc->vValue.vt );
            return FALSE;
        }
        rlVal = pPropDesc->vValue.lVal;
        return (pPropDesc->vValue.vt == VT_I4);
    }
    return FALSE;
}

void CheckSafeArrayProperty (
    REFIID rPropSet,
    DWORD  dwPropId,
    ULONG cProps,
    DBPROPSET * pProps )
{
    DBPROP * pPropDesc = LocateProperty( rPropSet, dwPropId, cProps, pProps );

    if (pPropDesc)
    {
        if ( pPropDesc->vValue.vt == (VT_ARRAY | VT_BSTR ) )
        {
            if ( 1 != SafeArrayGetDim( pPropDesc->vValue.parray ) )
                printf( "Bad array dimension\n" );
            else
            {
                long LBound = 1;
                long UBound = 0;

                SafeArrayGetLBound( pPropDesc->vValue.parray, 1, &LBound );
                SafeArrayGetUBound( pPropDesc->vValue.parray, 1, &UBound );

                for ( long j = LBound; j <= UBound; j++ )
                {
                    WCHAR ** pwcsVal;

                    SCODE sc = SafeArrayPtrOfIndex( pPropDesc->vValue.parray, &j, (void **)&pwcsVal );

                    if ( SUCCEEDED(sc) )
                    {
                        if ( j != LBound )
                            printf( ", " );
                        printf( "%ws", *pwcsVal );
                    }
                }
            }
        }
        else if ( pPropDesc->vValue.vt == VT_BSTR )
        {
            printf( "%ws", pPropDesc->vValue.bstrVal );
        }
        else if ( pPropDesc->vValue.vt == (VT_ARRAY | VT_I4 ) )
        {
            if ( 1 != SafeArrayGetDim( pPropDesc->vValue.parray ) )
                printf( "Bad array dimension\n" );
            else
            {
                long LBound = 1;
                long UBound = 0;

                SafeArrayGetLBound( pPropDesc->vValue.parray, 1, &LBound );
                SafeArrayGetUBound( pPropDesc->vValue.parray, 1, &UBound );

                for ( long j = LBound; j <= UBound; j++ )
                {
                    ULONG ulVal;

                    SCODE sc = SafeArrayGetElement( pPropDesc->vValue.parray, &j, &ulVal );

                    if ( SUCCEEDED(sc) )
                    {
                        if ( j != LBound )
                            printf( ", " );
                        printf( "%u", ulVal );
                    }
                }
            }
        }
        else if ( pPropDesc->vValue.vt == VT_I4 )
        {
            printf( "%u", pPropDesc->vValue.lVal );
        }
        else
            printf( "Unknown VT type %d\n", pPropDesc->vValue.vt );
    }
    else
        printf( "n/a" );
}

//
//  GetBooleanProperty - return boolean property value setting for dbprop
//

BOOL GetBooleanProperty ( IRowset * pRowset, DBPROPID dbprop )
{
    DBPROPSET *pPropInfo = 0;
    ULONG cPropSets = 0;
    DBPROPIDSET PropIdSet;
    DBPROPID PropID = dbprop;

    PropIdSet.rgPropertyIDs = &PropID;
    PropIdSet.cPropertyIDs = 1;
    PropIdSet.guidPropertySet = DBPROPSET_ROWSET;

    IRowsetInfo *pIRowInfo = 0;
    SCODE sc = pRowset->QueryInterface(IID_IRowsetInfo,(void **) &pIRowInfo);

    sc = pIRowInfo->GetProperties( 1, &PropIdSet, &cPropSets, &pPropInfo );
    pIRowInfo->Release();

    BOOL fReturnValue = FALSE;
    if ( FAILED( sc ) || cPropSets != 1 || pPropInfo->cProperties != 1 )
    {
        LogFail( "IRowsetInfo::GetProperties returned sc=0x%lx, cPropSets=%d\n", sc, cPropSets );
    }
    else
    {
        if (pPropInfo->rgProperties->vValue.vt == VT_BOOL &&
            pPropInfo->rgProperties->dwStatus == DBPROPSTATUS_OK)
        {
            fReturnValue = (pPropInfo->rgProperties->vValue.boolVal == VARIANT_TRUE);
        }
        else
        {
            LogFail( "IRowsetInfo::GetProperties returned bad DBPROPSET,"
                      " vt = %d  status = %x\n",
               pPropInfo->rgProperties->vValue.vt, pPropInfo->rgProperties->dwStatus );
        }
        if (pPropInfo)
        {
            if (pPropInfo->rgProperties)
                CoTaskMemFree(pPropInfo->rgProperties);
            CoTaskMemFree(pPropInfo);
        }
    }
    return fReturnValue;
}


void PrintRowsetProps (ULONG cProps, DBPROPSET * pProps)
{
    printf("\nRowset Properties:" );

    unsigned cBoolProps = 0;

    #define BOOLPROP(name)                                               \
            if (CheckBooleanProperty( DBPROPSET_ROWSET, DBPROP_ ## name, cProps, pProps) ) \
            {       if ((cBoolProps % 4) == 0) printf("\n\t");           \
                    cBoolProps++;                                        \
                    printf (#name " ");                                  \
            }

    BOOLPROP (ABORTPRESERVE);
    BOOLPROP (APPENDONLY);
    BOOLPROP (BLOCKINGSTORAGEOBJECTS);
    BOOLPROP (BOOKMARKS);
    BOOLPROP (BOOKMARKSKIPPED);
    BOOLPROP (CACHEDEFERRED);
    BOOLPROP (CANFETCHBACKWARDS);
    BOOLPROP (CANHOLDROWS);
    BOOLPROP (CANSCROLLBACKWARDS);
    BOOLPROP (CHANGEINSERTEDROWS);
#ifdef DBPROP_CHAPTERED
    BOOLPROP (CHAPTERED);
#endif // DBPROP_CHAPTERED
    BOOLPROP (COLUMNRESTRICT);
    BOOLPROP (COMMITPRESERVE);
    BOOLPROP (DEFERRED);
    BOOLPROP (DELAYSTORAGEOBJECTS);
    BOOLPROP (IMMOBILEROWS);
    BOOLPROP (LITERALBOOKMARKS);
    BOOLPROP (LITERALIDENTITY);
#ifdef DBPROP_MULTICHAPTERED
    BOOLPROP (MULTICHAPTERED);
#endif // DBPROP_MULTICHAPTERED
    BOOLPROP (MAYWRITECOLUMN);
    BOOLPROP (ORDEREDBOOKMARKS);
    BOOLPROP (OTHERINSERT);
    BOOLPROP (OTHERUPDATEDELETE);
    BOOLPROP (OWNINSERT);
    BOOLPROP (OWNUPDATEDELETE);
    BOOLPROP (QUICKRESTART);
    BOOLPROP (REENTRANTEVENTS);
    BOOLPROP (REMOVEDELETED);
    BOOLPROP (REPORTMULTIPLECHANGES);
    BOOLPROP (RETURNPENDINGINSERTS);
    BOOLPROP (ROWRESTRICT);
    BOOLPROP (SERVERCURSOR);
    BOOLPROP (STRONGIDENTITY);
    BOOLPROP (TRANSACTEDOBJECT);

    cBoolProps = 0;
    BOOLPROP (IAccessor);
    BOOLPROP (IChapteredRowset);
    BOOLPROP (IColumnsInfo);
    BOOLPROP (IColumnsRowset);
    BOOLPROP (IConnectionPointContainer);
    BOOLPROP (IDBAsynchStatus);
    BOOLPROP (IRowset);
    BOOLPROP (IRowsetChange);
    BOOLPROP (IRowsetIdentity);
    BOOLPROP (IRowsetInfo);
    BOOLPROP (IRowsetLocate);
    BOOLPROP (IRowsetResynch);
    BOOLPROP (IRowsetScroll);
    BOOLPROP (IRowsetUpdate);
    BOOLPROP (ISupportErrorInfo);
    BOOLPROP (IRowsetAsynch);
    BOOLPROP (IRowsetWatchAll);
    BOOLPROP (IRowsetWatchRegion);

// The following are per-column
//    BOOLPROP (ILockBytes);
//    BOOLPROP (ISequentialStream);
//    BOOLPROP (IStorage);
//    BOOLPROP (IStream);

    #undef BOOLPROP

    printf("\n");

    LONG n;

    #define NUMPROP(name)                                                   \
            if (CheckNumericProperty( DBPROPSET_ROWSET, DBPROP_ ## name, cProps, pProps, n) ) \
                    printf ("\t" #name ":\t%d\n", n);                       \
            else                                                            \
                    printf ("\t" #name ":\t--\n");

    NUMPROP( BOOKMARKTYPE );
    NUMPROP( COMMANDTIMEOUT );
    NUMPROP( MAXOPENROWS );
#ifdef DBPROP_MAXOPENROWSPERCHAPTER
    NUMPROP( MAXOPENROWSPERCHAPTER );
#endif // DBPROP_MAXOPENROWSPERCHAPTER
    NUMPROP( MAXPENDINGROWS );
    NUMPROP( MAXROWS );
#ifdef DBPROP_MAXPENDINGCHANGESCHAPTER
    NUMPROP( MAXPENDINGCHANGESPERCHAPTER );
#endif // DBPROP_MAXPENDINGCHANGESCHAPTER
    NUMPROP( MEMORYUSAGE );
    NUMPROP( NOTIFICATIONGRANULARITY );
    NUMPROP( NOTIFICATIONPHASES );
    NUMPROP( NOTIFYROWSETRELEASE );
    NUMPROP( NOTIFYROWSETFETCHPOSITIONCHANGE );
    // NUMPROP( NOTIFYCOLUMNSET, et al. );
    NUMPROP( ROWSET_ASYNCH );
    NUMPROP( ROWTHREADMODEL );
    NUMPROP( UPDATABILITY );

    #undef NUMPROP

    #define BOOLPROP(name)                                               \
            if (CheckBooleanProperty( guidQueryExt, DBPROP_ ## name, cProps, pProps) ) \
            {       if ((cBoolProps % 4) == 0) printf("\n\t");           \
                    cBoolProps++;                                        \
                    printf (#name " ");                                  \
            }

    cBoolProps = 0;
    BOOLPROP (USECONTENTINDEX);
    BOOLPROP (DEFERNONINDEXEDTRIMMING);
    BOOLPROP (USEEXTENDEDDBTYPES);

    #undef BOOLPROP

    printf("\n\n");

    #define SAPROP(name)                                               \
            printf ( "\t" #name ": ");                                       \
            CheckSafeArrayProperty( guidFsCiFrmwrkExt, DBPROP_ ## name, cProps, pProps); \
            printf ( "\n" );

    SAPROP (CI_INCLUDE_SCOPES);
    SAPROP (CI_DEPTHS);
    SAPROP (CI_CATALOG_NAME);

    #undef SAPROP
    #define SAPROP(name)                                               \
            printf ( "\t" #name ": ");                                       \
            CheckSafeArrayProperty( guidCiFrmwrkExt, DBPROP_ ## name, cProps, pProps); \
            printf ( "\n" );

    SAPROP (MACHINE);

    #undef SAPROP

    printf ( "\n" );

    #define SAPROP(name)                                               \
            printf ( "\t" #name ": ");                                       \
            CheckSafeArrayProperty( guidMsidxsExt, MSIDXSPROP_ ## name, cProps, pProps); \
            printf ( "\n" );

    SAPROP (ROWSETQUERYSTATUS);
    SAPROP (COMMAND_LOCALE_STRING);
    SAPROP (QUERY_RESTRICTION);


    #undef SAPROP
}

//
//  CheckRowsetProperties - print rowset properties.  If IServiceProperties is
//                        supported, check that the set of properties returned
//                        by GetPropertyInfo is the same.
//
void CheckRowsetProperties( ULONG cProps,
                            DBPROPSET * pProps,
                            IUnknown * pUnk,
                            BOOL fCheckAllProperties = TRUE )
{
    IServiceProperties *pSvcProp = 0;
    SCODE sc = pUnk->QueryInterface(IID_IServiceProperties,(void **) &pSvcProp);

    DBPROPSTATUS ExpStatus = fCheckAllProperties ? DBPROPSTATUS_OK :
                                                   DBPROPSTATUS_CONFLICTING;

    if (SUCCEEDED( sc ))
    {
        DBPROPINFOSET * pPropInfoSet = 0;
        ULONG cPropInfoSet = 0;
        WCHAR * pwszDescriptions = 0;

        DBPROPIDSET PropID;
        PropID.cPropertyIDs = 0;
        PropID.rgPropertyIDs = 0;
        PropID.guidPropertySet = DBPROPSET_ROWSETALL;

        sc = pSvcProp->GetPropertyInfo( 1, &PropID,
                                        &cPropInfoSet, &pPropInfoSet,
                                        &pwszDescriptions );
        pSvcProp->Release();

        if ( FAILED( sc ) )
        {
            LogFail( "IServiceProperties::GetPropertyInfo returned 0x%lx\n",
                      sc );
        }

        //
        // Check that all properties returned by GetProperties are in the
        // propinfo structures.
        //
        for (unsigned iPropSet=0; iPropSet < cProps; iPropSet++)
        {
            DBPROP *pDbProp = pProps[iPropSet].rgProperties;

            for (unsigned iProp=0; iProp<pProps[iPropSet].cProperties; iProp++)
            {
                DBPROPINFO UNALIGNED * pPropInfo = LocatePropertyInfo(
                                             pProps[iPropSet].guidPropertySet,
                                             pDbProp[iProp].dwPropertyID,
                                             cPropInfoSet, pPropInfoSet );

                if (0 == pPropInfo)
                {
                    LogError("Property info record couldn't be found for property %ws %d\n",
                             FormatGuid(pProps[iPropSet].guidPropertySet),
                             pDbProp[iProp].dwPropertyID);
                    cFailures++;
                    continue;
                }
                if (pDbProp[iProp].dwStatus != ExpStatus)
                {
                    LogError("Property status error (%d) for property %ws %d (%ws)\n",
                             pDbProp[iProp].dwStatus,
                             FormatGuid(pProps[iPropSet].guidPropertySet),
                             pDbProp[iProp].dwPropertyID,
                             pPropInfo->pwszDescription);
                    cFailures++;
                }
                if (pPropInfo->vtType != pDbProp[iProp].vValue.vt)
                {
                    LogError("Property type mismatch (%d %d) for property %ws %d (%ws)\n",
                             pPropInfo->vtType, pDbProp[iProp].vValue.vt,
                             FormatGuid(pProps[iPropSet].guidPropertySet),
                             pDbProp[iProp].dwPropertyID,
                             pPropInfo->pwszDescription);
                    cFailures++;
                }
            }
        }

        if (fCheckAllProperties)
        {
            //
            // Check that all properties returned by GetPropertyInfo are in the
            // DBPROP structures.
            //
            for (iPropSet=0; iPropSet<cPropInfoSet; iPropSet++)
            {
                DBPROPINFO UNALIGNED *pPropInfo = pPropInfoSet[iPropSet].rgPropertyInfos;

                for ( unsigned iProp=0;
                      iProp < pPropInfoSet[iPropSet].cPropertyInfos;
                      iProp++)
                {
                    DBPROP * pDbProp = LocateProperty(
                                     pPropInfoSet[iPropSet].guidPropertySet,
                                     pPropInfo[iProp].dwPropertyID,
                                     cProps, pProps );

                    if (0 == pDbProp)
                    {
                        LogError("Property record couldn't be found for property %ws %d\n",
                                 FormatGuid(pPropInfoSet[iPropSet].guidPropertySet),
                                 pPropInfo[iProp].dwPropertyID);
                        cFailures++;
                    }
                }
            }
        }

        //
        // Free all the structures in the DBPROPINFOSET
        //
        for (iPropSet=0; iPropSet<cPropInfoSet; iPropSet++)
        {
            DBPROPINFO UNALIGNED *pPropInfo = pPropInfoSet[iPropSet].rgPropertyInfos;

            for (unsigned iProp=0;
                 iProp<pPropInfoSet[iPropSet].cPropertyInfos;
                 iProp++)
            {
                VARIANT v;
                RtlCopyMemory( &v, &pPropInfo[iProp].vValues, sizeof v );
                VariantClear( &v );
            }
            CoTaskMemFree( pPropInfo );
        }
        CoTaskMemFree( pPropInfoSet );
        CoTaskMemFree( pwszDescriptions );
    }
    else
    {

        //
        // Check the status of all properties returned by GetProperties.
        //
        for (unsigned iPropSet=0; iPropSet < cProps; iPropSet++)
        {
            DBPROP *pDbProp = pProps[iPropSet].rgProperties;

            for (unsigned iProp=0; iProp<pProps[iPropSet].cProperties; iProp++)
            {
                if (pDbProp[iProp].dwStatus != ExpStatus)
                {
                    LogError("Property status error (%d) for property %ws %d\n",
                             pDbProp[iProp].dwStatus,
                             FormatGuid(pProps[iPropSet].guidPropertySet),
                             pDbProp[iProp].dwPropertyID );
                    cFailures++;
                }

            }
        }
    }

    if (fVerbose > 1)
    {
        PrintRowsetProps (cProps, pProps);
        printf ("\n");
    }
    for (unsigned i=0; i<cProps; i++)
    {
        CoTaskMemFree(pProps[i].rgProperties);
    }
    CoTaskMemFree(pProps);
}

void CheckPropertiesInError( ICommand* pCmd, BOOL fQuiet )
{
    if (! fQuiet)
        LogProgress( " Checking properties in error\n" );

    DBPROPSET * pPropInfo = 0;
    ULONG cPropsets = 0;

    DBPROPIDSET PropIDSet;
    PropIDSet.rgPropertyIDs = 0;
    PropIDSet.cPropertyIDs = 0;
    PropIDSet.guidPropertySet = DBPROPSET_PROPERTIESINERROR;

    ICommandProperties *pCmdProp = 0;
    SCODE sc = pCmd->QueryInterface(IID_ICommandProperties,(void **) &pCmdProp);

    sc = pCmdProp->GetProperties( 1, &PropIDSet, &cPropsets, &pPropInfo );
    pCmdProp->Release();
    if ( FAILED( sc ) )
    {
        LogFail( "ICommandProperties::GetProperties returned 0x%lx\n", sc );
    }
    if ( 0 == cPropsets || 0 == pPropInfo )
    {
        LogFail( "ICommandProperties::GetProperties returned no properties\n");
    }

    if (!fQuiet)
        fVerbose++;
    CheckRowsetProperties( cPropsets, pPropInfo, pCmd, FALSE );
    if (!fQuiet)
        fVerbose--;
}


void CheckPropertiesOnCommand( ICommand* pCmd, BOOL fQuiet )
{
    if (! fQuiet)
        LogProgress( " Verifying rowset properties (from command object)\n" );

    DBPROPSET * pPropInfo = 0;
    ULONG cPropsets = 0;

    ICommandProperties *pCmdProp = 0;
    SCODE sc = pCmd->QueryInterface(IID_ICommandProperties,(void **) &pCmdProp);

    sc = pCmdProp->GetProperties( 0, 0, &cPropsets, &pPropInfo );

    pCmdProp->Release();

    if ( FAILED( sc ) )
    {
        //
        // This isn't really kosher, but it helps to avoid spurious (client-side) memory leaks.
        //

        pCmd->Release();
        LogFail( "ICommandProperties::GetProperties returned 0x%lx\n", sc );
    }

    CheckRowsetProperties( cPropsets, pPropInfo, pCmd );
}


void CheckColumns( IUnknown* pRowset, CDbColumns& rColumns, BOOL fQuiet )
{
    if (! fQuiet)
        LogProgress( " Verifying output columns\n" );

    DBPROPSET * pPropInfo = 0;
    ULONG cPropsets = 0;

    IRowsetInfo *pIRowInfo = 0;
    SCODE sc = pRowset->QueryInterface(IID_IRowsetInfo,(void **) &pIRowInfo);

    sc = pIRowInfo->GetProperties( 0, 0, &cPropsets, &pPropInfo );
    pIRowInfo->Release();
    if ( FAILED( sc ) )
    {
        LogFail( "IRowsetInfo::GetProperties returned 0x%lx\n", sc );
    }

    CheckRowsetProperties( cPropsets, pPropInfo, pRowset );

    DBID aDbCols[MAXCOLUMNS];

    if (rColumns.Count() > MAXCOLUMNS)
    {
        LogError( "TEST ERROR: MAXCOLUMNS is too small\n" );
        CantRun();
    }

    for (ULONG x = 0; x < rColumns.Count(); x++)
        aDbCols[x] = * ((DBID *) &rColumns.Get(x));

    aDbCols[0].uGuid.pguid = &(((DBID *)(&rColumns.Get(0)))->uGuid.guid);
    if (aDbCols[0].eKind == DBKIND_GUID_PROPID)
        aDbCols[0].eKind = DBKIND_PGUID_PROPID;
    else
        aDbCols[0].eKind = DBKIND_PGUID_NAME;

    IColumnsInfo *pIColInfo = 0;
    sc = pRowset->QueryInterface(IID_IColumnsInfo,(void **) &pIColInfo);

    if ( FAILED( sc ) )
    {
        if ( sc == E_NOINTERFACE )
            LogError( "IColumnsInfo failed (must be supported for MapColumnIDs), 0x%x\n", sc );

        LogError( "IRowset::QI IColumnsInfo failed, 0x%x\n", sc );
        cFailures++;
    }

    DBORDINAL aColIds[MAXCOLUMNS];
    sc = pIColInfo->MapColumnIDs(rColumns.Count(), aDbCols, aColIds);

    if (S_OK != sc)
    {
        LogFail( "CheckColumns, IRowset->MapColumnIDs returned 0x%lx\n",sc);
    }

    unsigned iExpCol = 1;
    for (unsigned i = 0; i < rColumns.Count(); i++)
    {
        DBID dbidCol = rColumns.Get(i);
        if (dbidCol.eKind = DBKIND_GUID_PROPID &&
            dbidCol.uName.ulPropid == PROPID_DBBMK_BOOKMARK &&
            dbidCol.uGuid.guid == guidBmk)
        {
            if (aColIds[i] != 0)
            {
                LogError( "IRowset->MapColumnIDs returned unexpected column number for bookmark col.\n" );
                cFailures++;
            }
        }
        else
        {
            if (aColIds[i] != iExpCol)
            {
                LogError( "IRowset->MapColumnIDs returned unexpected column number for col. %d\n", i);
                cFailures++;
            }
            iExpCol++;
        }
    }

    DBORDINAL cColumns = 0;
    DBCOLUMNINFO *pColumnInfo = 0;
    WCHAR *pColumnNames = 0;

    sc = pIColInfo->GetColumnInfo( &cColumns, &pColumnInfo, &pColumnNames );

    if ( FAILED( sc ) )
    {
        LogError( "IColumnsInfo::GetColumnInfo failed, 0x%x\n", sc );
        cFailures++;
    }
    else
    {
        if ( cColumns < rColumns.Count() )
        {
            LogError( "Rowset has too few columns, %d %d\n",
                            cColumns, rColumns.Count() );
            cFailures++;
        }
    }

    if (pColumnInfo != 0)
    {
        if (fVerbose > 1)
            printf("Columns Info:\n" );

        for (ULONG iCol = 0; iCol < cColumns; iCol++)
        {
            DBCOLUMNINFO &Info = pColumnInfo [iCol];

            if ( ( 0 == Info.iOrdinal &&
                   !Info.dwFlags & DBCOLUMNFLAGS_ISBOOKMARK) ||
                 Info.iOrdinal > cColumns)
            {
                LogError( "IColumnsInfo->GetColumnInfo returned bad column number %d) for col. %d\n", Info.iOrdinal, iCol);
                cFailures++;
            }
            if (Info.columnid.eKind != DBKIND_GUID_PROPID &&
                Info.columnid.eKind != DBKIND_GUID_NAME &&
                Info.columnid.eKind != DBKIND_PGUID_PROPID &&
                Info.columnid.eKind != DBKIND_PGUID_NAME &&
                Info.columnid.eKind != DBKIND_NAME)
            {
                LogError( "IColumnsInfo->GetColumnInfo returned bad column kind %d) for col. %d\n", Info.columnid.eKind, iCol);
                cFailures++;
            }

            if (fVerbose > 1)
            {
                if (Info.columnid.eKind == DBKIND_GUID_PROPID)
                    printf ("(G) %-12li ", Info.columnid.uName.ulPropid);
                else if (Info.columnid.eKind == DBKIND_GUID_NAME)
                    printf ("(G) '%-10ls' ", Info.columnid.uName.pwszName);
                else if (Info.columnid.eKind == DBKIND_PGUID_PROPID)
                    printf ("(PG) %-12li ", Info.columnid.uName.ulPropid);
                else if (Info.columnid.eKind == DBKIND_PGUID_NAME)
                    printf ("(PG) '%-10ls' ", Info.columnid.uName.pwszName);
                else if (Info.columnid.eKind == DBKIND_NAME)
                    printf ("'%-14ls' ", Info.columnid.uName.pwszName);
                else
                    printf ("BAD NAME ");

                printf ("'%-14ls' %2lu %6s %2lu", Info.pwszName, Info.iOrdinal,
                        DBTYPE_Tag (Info.wType), Info.ulColumnSize);

                printf ("\n     ");
                PrintColumnFlags (Info.dwFlags);

                printf ("\n");
            }
        }
        CoTaskMemFree(pColumnInfo);
        CoTaskMemFree(pColumnNames);
    }


    IColumnsRowset *pIColRowset = 0;

    sc = pRowset->QueryInterface(IID_IColumnsRowset,(void **) &pIColRowset );

    if ( FAILED( sc ) && sc != E_NOINTERFACE )
    {
        LogError( "IRowset::qi for IColumnsRowset failed, 0x%x\n", sc );
        cFailures++;
    }

    if (0 == pIColRowset && 0 == pIColInfo)
    {
        LogError( "At least one of IColumnsInfo and IColumnsRowset "
                "must be implemented\n" );
        cFailures++;
    }

    if (pIColRowset)
    {
        IRowset *pRowsetCols = 0;
        SCODE scCC = pIColRowset->GetColumnsRowset(0, 0, 0, IID_IRowset, 0, 0,
                                                   (IUnknown**)&pRowsetCols);

        if (FAILED(scCC))
        {
            LogError( "IColumnsRowset::GetColumnsRowset failed, 0x%x\n", scCC );
            cFailures++;
        }

        if (SUCCEEDED(scCC))
            pRowsetCols->Release();
    }

    if (pIColInfo)
    {
        pIColInfo->Release();
        pIColInfo = 0;
    }
    if ( pIColRowset )
    {
        pIColRowset->Release();
        pIColRowset = 0;
    }

} //CheckColumns


//+-------------------------------------------------------------------------
//
//  Function:   BasicTest, public
//
//  Synopsis:   Test basic cursor functionality
//
//  Arguments:  [pCursor] - a pointer to an IRowset* to be tested.
//              [fSequential] - if TRUE, the pCursor will not support
//                              IRowsetLocate, etc.
//              [hChapt]  - chapter pointer
//              [cCols]   - # of columns over which to test
//
//  Returns:    Nothing
//
//  Notes:      The passed in cursor is assumed to be set up with the
//              usual column bindings.  It is also assumed that the
//              query has not necesarily completed.
//
//  History:    26 Sep 94       AlanW   Created from DownLevel test
//              11 Nov 94       Alanw   Converted for phase 3
//
//--------------------------------------------------------------------------

void BasicTest(
    IRowset* pCursor,
    BOOL fSequential,
    HCHAPTER hChapt,
    unsigned cCols,
    BOOL fByRef,
    ICommandTree * pCmdTree )
{
    int fFailed = 0;
    DBCOUNTITEM cRows = 0;
    IRowsetScroll * pIRowsetScroll = 0;
    BOOL fChaptered = GetBooleanProperty( pCursor, DBPROP_IChapteredRowset );

    if (cCols != cBasicTestCols && cCols != cBasicTestCols-1)
        LogFail( "TEST ERROR - bad cCols (%d) passed to BasicTest\n", cCols );

    SCODE sc = pCursor->QueryInterface(IID_IRowsetScroll,(void **) &pIRowsetScroll );

    if ( FAILED( sc ) && sc != E_NOINTERFACE )
    {
        LogError( "IRowset::qi for IRowsetScroll failed, 0x%x\n", sc );
        cFailures++;
    }

    if ( fSequential )
    {
        if (0 != pIRowsetScroll )
        {
            LogError( "Sequential cursor supports IRowsetScroll\n" );
            cFailures++;
        }
    }
    else
    {
        if (0 == pIRowsetScroll )
        {
            LogError( "Non-sequential cursor does not support IRowsetScroll\n" );
            cFailures++;
        }
        else
        {
            sc = pIRowsetScroll->GetApproximatePosition(hChapt, 0,0,
                                                        0, &cRows);

            if ( FAILED( sc ) )
            {
                LogError( "IRowset->GetApproximatePosition returned 0x%lx\n", sc );
                cFailures++;
            }

            if ( cRows == 0 )
            {
                LogError( "Query failed to return data\n" );
                pIRowsetScroll->Release();
                pCursor->Release();
                Fail();
            }
        }
    }

    //
    // Patch the column index numbers with true numbers
    //

    DBID aDbCols[cBasicTestCols];
    aDbCols[0] = psClassid;
    aDbCols[1] = psSize;
    aDbCols[2] = psWriteTime;
    aDbCols[3] = psAttr;
    aDbCols[4] = psName;
    aDbCols[5] = psPath;
    aDbCols[6] = psSelf;

    IUnknown * pAccessor = (IUnknown *) pCursor; // hAccessor must be created on rowset
                                 // to be used with rowset->GetData below


    if (fByRef)
    {
        aBasicTestCols[5].dwMemOwner = DBMEMOWNER_PROVIDEROWNED;
    }
    else
    {
        aBasicTestCols[5].dwMemOwner = DBMEMOWNER_CLIENTOWNED;
    }
    HACCESSOR hAccessor = MapColumns( pAccessor,
                                      cCols,
                                      aBasicTestCols,
                                      aDbCols,
                                      fByRef );

    DBID aDbAltCols[cBasicAltCols];
    aDbAltCols[0] = psSize;
    aDbAltCols[1] = psWriteTime;
    aDbAltCols[2] = psWriteTime;
    aDbAltCols[3] = psWriteTime;

    HACCESSOR hAccessor2 = MapColumns( pAccessor,
                                       cBasicAltCols,
                                       aBasicAltCols,
                                       aDbAltCols,
                                       fByRef );

#if defined( DO_NOTIFICATION )
    IConnectionPoint *pConnectionPoint = 0;
    DWORD dwAdviseID = 0;

    CTestWatchNotify Notify;

    if ( ! fSequential )
    {
        Notify.DoChecking(TRUE);

        //
        // Get the connection point container
        //

        IConnectionPointContainer *pConnectionPointContainer = 0;
        sc = pCursor->QueryInterface(IID_IConnectionPointContainer,
                                     (void **) &pConnectionPointContainer);
        if (FAILED(sc))
        {
            LogError( "IRowset->QI for IConnectionPointContainer failed: 0x%x\n",
                    sc );
            pCursor->Release();
            Fail();
        }

        //
        // Make a connection point from the connection point container
        //

        sc = pConnectionPointContainer->FindConnectionPoint(
                 IID_IRowsetWatchNotify,
                 &pConnectionPoint);

        if (FAILED(sc) && CONNECT_E_NOCONNECTION != sc )
        {
            LogError( "FindConnectionPoint failed: 0x%x\n",sc );
            pCursor->Release();
            Fail();
        }

        pConnectionPointContainer->Release();

        if (0 != pConnectionPoint)
        {
            //
            // Give a callback object to the connection point
            //

            sc = pConnectionPoint->Advise((IUnknown *) &Notify,
                                          &dwAdviseID);
            if (FAILED(sc))
            {
                LogError( "IConnectionPoint->Advise failed: 0x%x\n",sc );
                pConnectionPoint->Release();
                pCursor->Release();
                Fail();
            }
        }
    }
#endif // DO_NOTIFICATION

    DBCOUNTITEM totalRowsFetched = 0;
    DBCOUNTITEM cRowsReturned = 0;
    HROW ahRows[10];
    HROW* phRows = ahRows;
    LONGLONG PrevFileSize = 0x7fffffffffffffff;

    //
    // Try passing chapters to non-chaptered rowsets.
    // This causes an exception, so just do it once for each case.
    //

    static BOOL fTriedChaptOnNonChaptered = FALSE;

#if 0   // NOTE: null chapters work on chaptered rowsets!
    static BOOL fTriedNoChaptOnChaptered = FALSE;
    if ( !fTriedNoChaptOnChaptered && 0 != hChapt )
    {
        fTriedNoChaptOnChaptered = TRUE;
        sc = pCursor->GetNextRows(DB_NULL_HCHAPTER, 0, 10, &cRowsReturned, &phRows);
        if (!FAILED(sc))
            LogFail("chaptered IRowset->GetNextRows should have failed\n");
    }
#endif 0

    if ( !fTriedChaptOnNonChaptered && (0 == hChapt) )
    {
        fTriedChaptOnNonChaptered = TRUE;
        sc = pCursor->GetNextRows(DBCHP_FIRST, 0, 10, &cRowsReturned, &phRows);
        if (!FAILED(sc))
            LogFail("unchaptered IRowset->GetNextRows should have failed\n");
    }

    do
    {
        sc = pCursor->GetNextRows(hChapt, 0, 10, &cRowsReturned, &phRows);

        if ( FAILED( sc ) )
        {
            LogError( "IRowset->GetNextRows returned 0x%x\n", sc );
            pCursor->Release();
            Fail();
        }

        if (sc != DB_S_ENDOFROWSET &&
            cRowsReturned != 10)
        {
            LogError( "IRowset->GetNextRows returned %d of %d rows,"
                    " status (%x) != DB_S_ENDOFROWSET\n",
                        cRowsReturned, 10,
                        sc);
#if defined (UNIT_TEST)
            cFailures++;
#else // defined(UNIT_TEST)
            pCursor->Release();
            Fail();
#endif // defined(UNIT_TEST)
        }

        totalRowsFetched += cRowsReturned;

        if ( (0 != pIRowsetScroll ) &&
             (totalRowsFetched > cRows) )
        {
            //
            // check that no more rows have been added while we were
            // fetching.
            //
            LogProgress("Checking for expansion of result set\n");

            SCODE sc1 = pIRowsetScroll->GetApproximatePosition(hChapt,
                                                0,0, 0, &cRows);

            if ( totalRowsFetched > cRows )
            {
                LogError("Fetched more rows than exist in the result set, %d %d\n",
                        totalRowsFetched, cRows);
                cFailures++;
            }
        }
        //
        // Make sure the hits are sorted by size and that the query
        // really was shallow and that the length fields are correct.
        //

        unsigned i;
        for (i = 0; i < cRowsReturned; i++)
        {
            SBasicTest Row;
            Row.pIPSStorage = 0;

            SCODE sc1 = pCursor->GetData(ahRows[i],hAccessor,&Row);

            if ( FAILED( sc1 ) )
                LogFail( "IRowset->GetData returned 0x%x\n", sc1 );

            LONGLONG size = Row.size;
            if ( PrevFileSize < size &&
                 ( ! fChaptered || hChapt != DB_NULL_HCHAPTER) )
                LogFail("Hitset not sorted by filesize\n");

            if (wcsstr( Row.pwcPath, L"system32\\drivers\\" ) ||
                wcsstr( Row.pwcPath, L"SYSTEM32\\DRIVERS\\" ) ||
                wcsstr( Row.pwcPath, L"System32\\Drivers\\" ))
                LogFail("Query wasn't shallow as expected\n");

            if ( Row.sClsid == DBSTATUS_S_OK &&
                 Row.cbClsid != sizeof CLSID )
                LogFail("length of clsid column not correct: %d\n", Row.cbClsid);

            if ( Row.sSize != DBSTATUS_S_OK ||
                 Row.cbSize != sizeof LONGLONG )
                LogFail("status or length of size column not correct: %d\n",
                        Row.cbSize);

            if ( Row.sWriteTime != DBSTATUS_S_OK ||
                 Row.cbWriteTime != sizeof LONGLONG)
                LogFail("status or length of time column not correct: %d\n", Row.cbWriteTime);

            if ( Row.sAttr != DBSTATUS_S_OK ||
                 Row.cbAttr != sizeof ULONG)
                LogFail("length of attr column not correct: %d\n", Row.cbAttr);

            if ( Row.sName == DBSTATUS_S_OK &&
                 Row.cbName != wcslen(Row.awcName) * sizeof (WCHAR) )
                LogFail( "length of name column 0x%x not consistent with data 0x%x\n",
                         Row.cbName,
                         wcslen(Row.awcName) * sizeof WCHAR );

            if ( Row.sPath == DBSTATUS_S_OK &&
                 Row.cbPath != (wcslen(Row.pwcPath) * sizeof (WCHAR)) )
                LogFail("length of path column not consistent with data\n");

            if ( !fByRef )
                CoTaskMemFree(Row.pwcPath);

            if ( 0 != Row.pIPSStorage )
            {
                Row.pIPSStorage->Release();
                Row.pIPSStorage = 0;
            }

            SBasicAltTest AltRow;
            SCODE sc2 = pCursor->GetData(ahRows[i], hAccessor2, &AltRow);

            if ( FAILED( sc2 ) )
                LogFail( "IRowset->GetData returned 0x%x\n", sc2 );

            if ( AltRow.sSize != DBSTATUS_S_OK ||
                 AltRow.cbSize != sizeof AltRow.Size )
                LogFail("status or length of alt size column not correct: %d\n",
                        AltRow.cbSize);

            if ( AltRow.Size != Row.size )
                LogFail("size column doesn't compare in alt. accessor\n");

            //
            //  Check time conversions
            //
            FILETIME LocalFTime;
            SYSTEMTIME SysTime;

            FileTimeToSystemTime((FILETIME *) &(Row.writeTime), &SysTime);

            if ( AltRow.sWriteTime1 != DBSTATUS_S_OK ||
                 AltRow.cbWriteTime1 != sizeof AltRow.writeTime1)
                LogFail("status or length of writeTime1 column not correct: %d\n",
                         AltRow.cbWriteTime1);

            if ( AltRow.sWriteTime2 != DBSTATUS_S_OK ||
                 AltRow.cbWriteTime2 != sizeof AltRow.writeTime2)
                LogFail("status or length of writeTime2 column not correct: %d\n",
                         AltRow.cbWriteTime2);

            if ( AltRow.sWriteTime3 != DBSTATUS_S_OK ||
                 AltRow.cbWriteTime3 != sizeof AltRow.writeTime3)
                LogFail("status or length of writeTime3 column not correct: %d\n",
                        AltRow.cbWriteTime3);

            if ( SysTime.wYear != AltRow.writeTime1.year ||
                 SysTime.wMonth != AltRow.writeTime1.month ||
                 SysTime.wDay != AltRow.writeTime1.day)
                LogFail("Write time 1 mismatch\n");

            if ( SysTime.wHour != AltRow.writeTime2.hour ||
                 SysTime.wMinute != AltRow.writeTime2.minute ||
                 SysTime.wSecond != AltRow.writeTime2.second)
                LogFail("Write time 2 mismatch\n");

            if ( SysTime.wYear != AltRow.writeTime3.year ||
                 SysTime.wMonth != AltRow.writeTime3.month ||
                 SysTime.wDay != AltRow.writeTime3.day ||
                 SysTime.wHour != AltRow.writeTime3.hour ||
                 SysTime.wMinute != AltRow.writeTime3.minute ||
                 SysTime.wSecond != AltRow.writeTime3.second ||
                 SysTime.wMilliseconds != AltRow.writeTime3.fraction/1000000)
                LogFail("Write time 3 mismatch\n");


            PrevFileSize = size;
        }

        if (fVerbose > 1)
        {
            for (i = 0; i < cRowsReturned; i++)
            {
                SBasicTest Row;
                Row.pIPSStorage = 0;

                SCODE sc1 = pCursor->GetData(ahRows[i],hAccessor,&Row);

                if ( FAILED( sc1 ) )
                {
                    LogError( "IRowset->GetData returned 0x%x\n", sc1 );
                    pCursor->Release();
                    Fail();
                }

                //
                //  print name, attributes and size
                //
                printf( "\t%-16.16ws%04x\t%7d\t",
                        Row.awcName,
                        Row.attr,
                        (ULONG) Row.size );

                //
                //  print file mod. time
                //
                FILETIME LocalFTime;
                SYSTEMTIME SysTime;

                FileTimeToLocalFileTime((FILETIME *) &(Row.writeTime),
                                        &LocalFTime);
                FileTimeToSystemTime(&LocalFTime, &SysTime);

                printf("%02d/%02d/%02d %2d:%02d:%02d\n",
                    SysTime.wMonth, SysTime.wDay, SysTime.wYear % 100,
                    SysTime.wHour, SysTime.wMinute, SysTime.wSecond);

                if ( !fByRef )
                    CoTaskMemFree(Row.pwcPath);

                if (0 != Row.pIPSStorage )
                {
                    Row.pIPSStorage->Release();
                    Row.pIPSStorage = 0;
                }
            }
        }

        if (0 != cRowsReturned)
        {
            SCODE sc1 = pCursor->ReleaseRows(cRowsReturned, ahRows, 0, 0, 0);
            if ( FAILED( sc1 ) )
            {
                LogError( "IRowset->ReleaseRows returned 0x%x\n", sc1 );
                pCursor->Release();
                Fail();
            }
            cRowsReturned = 0;
        }

    } while (SUCCEEDED(sc) && sc != DB_S_ENDOFROWSET);

    if (0 != cRowsReturned)
    {
        SCODE sc1 = pCursor->ReleaseRows(cRowsReturned, ahRows, 0, 0, 0);
        if ( FAILED( sc1 ) )
        {
            LogError( "IRowset->ReleaseRows returned 0x%x\n", sc1 );
            pCursor->Release();
            Fail();
        }
    }

    if ( 0 == totalRowsFetched && 0 != hChapt )
        LogFail("Chapter had no rows for GetNextRows()\n");

    ReleaseAccessor( pAccessor, hAccessor);
    ReleaseAccessor( pAccessor, hAccessor2);

#if defined( DO_NOTIFICATION )
    if ( ! fSequential && 0 != pConnectionPoint )
    {
        NotificationTest();

        //
        // Clean up notification stuff
        //

        sc = pConnectionPoint->Unadvise(dwAdviseID);

        if (S_OK != sc)
        {
            LogError( "IConnectionPoint->Unadvise returned 0x%lx\n",sc);
            pCursor->Release();
            Fail();
        }

        pConnectionPoint->Release();
        //Notify.Release();
    }
#endif // DO_NOTIFICATION

    if (0 != pIRowsetScroll )
    {
        pIRowsetScroll->Release();
        pIRowsetScroll = 0;
    }

#if !defined(UNIT_TEST)
    if (cFailures) {
        pCursor->Release();
        Fail();
    }
#endif // !UNIT_TEST
} //BasicTest



//+-------------------------------------------------------------------------
//
//  Function:   BackwardsFetchTest, public
//
//  Synopsis:   Test backwards fetching
//
//  Arguments:  [pRowset] - IRowset to be tested
//
//  History:    03-Sep-97       SitaramR    Created
//
//--------------------------------------------------------------------------

void BackwardsFetchTest( IRowset* pRowset )
{
    //
    // Patch the column index numbers with true numbers
    //

    DBID aDbCols[cBasicTestCols];
    aDbCols[0] = psClassid;
    aDbCols[1] = psSize;
    aDbCols[2] = psWriteTime;
    aDbCols[3] = psAttr;
    aDbCols[4] = psName;
    aDbCols[5] = psPath;
    aDbCols[6] = psSelf;

    IUnknown * pAccessor = (IUnknown *) pRowset; // hAccessor must be created on rowset
                                                 // to be used with rowset->GetData below

    aBasicTestCols[5].dwMemOwner = DBMEMOWNER_PROVIDEROWNED;

    HACCESSOR hAccessor = MapColumns( pAccessor,
                                      cBasicTestCols,
                                      aBasicTestCols,
                                      aDbCols,
                                      TRUE );

    DBCOUNTITEM cRowsReturned = 0;
    HROW ahRows[10];
    HROW* phRows = ahRows;

    //
    // Backwards fetch for GetNextRows
    //

    SCODE sc = pRowset->RestartPosition( 0 );
    if ( FAILED( sc ) )
    {
        LogError( "IRowset->RestartPosition returned 0x%x\n", sc );
        pRowset->Release();
        Fail();
    }

    sc = pRowset->GetNextRows(0, 9, -9, &cRowsReturned, &phRows);

    if ( FAILED( sc ) )
    {
        LogError( "IRowset->GetNextRows returned 0x%x\n", sc );
        pRowset->Release();
        Fail();
    }

    if ( cRowsReturned != 9 )
    {
        LogError( "IRowset->GetNextRows returned %d of %d rows,"
                  " status (%x) != DB_S_ENDOFROWSET\n",
                  cRowsReturned,
                  10,
                  sc);
#if defined (UNIT_TEST)
        cFailures++;
#else
        pRowset->Release();
        Fail();
#endif
    }

    //
    // Check data of some of the fields
    //

    for ( unsigned i = 0; i < cRowsReturned; i++)
    {
        SBasicTest Row;
        Row.pIPSStorage = 0;

        SCODE sc1 = pRowset->GetData(ahRows[i],hAccessor,&Row);

        if ( FAILED( sc1 ) )
            LogFail( "IRowset->GetData returned 0x%x\n", sc1 );

        if (wcsstr( Row.pwcPath, L"system32\\drivers\\" ) ||
            wcsstr( Row.pwcPath, L"SYSTEM32\\DRIVERS\\" ) ||
            wcsstr( Row.pwcPath, L"System32\\Drivers\\" ))
            LogFail("Query wasn't shallow as expected\n");

        if ( Row.sClsid == DBSTATUS_S_OK &&
             Row.cbClsid != sizeof CLSID )
            LogFail("length of clsid column not correct: %d\n", Row.cbClsid);

        if ( Row.sSize != DBSTATUS_S_OK ||
             Row.cbSize != sizeof LONGLONG )
            LogFail("status or length of size column not correct: %d\n",
                    Row.cbSize);
    }

    if (0 != cRowsReturned)
    {
        SCODE sc1 = pRowset->ReleaseRows(cRowsReturned, ahRows, 0, 0, 0);
        if ( FAILED( sc1 ) )
        {
            LogError( "IRowset->ReleaseRows returned 0x%x\n", sc1 );
            pRowset->Release();
            Fail();
        }
    }

    sc = pRowset->RestartPosition( 0 );
    if ( FAILED( sc ) )
    {
        LogError( "IRowset->RestartPosition returned 0x%x\n", sc );
        pRowset->Release();
        Fail();
    }

    //
    // Backwards fetch for GetRowsAt
    //

    IRowsetLocate *pRowsetLocate = 0;
    sc = pRowset->QueryInterface(IID_IRowsetLocate,(void **) &pRowsetLocate );

    if ( FAILED( sc ) && sc != E_NOINTERFACE )
    {
        LogError( "IRowset::qi for IRowsetLocate failed, 0x%x\n", sc );
#if defined (UNIT_TEST)
        cFailures++;
#else
        pRowset->Release();
        Fail();
#endif
    }

    sc = pRowsetLocate->GetRowsAt(0, 0, 1, &bmkFirst, 9, -10, &cRowsReturned, &phRows);

    if ( FAILED( sc ) )
    {
        LogError( "IRowsetLocate->GetRowsAt returned 0x%x\n", sc );
        pRowsetLocate->Release();
        Fail();
    }

    if ( cRowsReturned != 10 )
    {
        LogError( "IRowset->GetRowsAt returned %d of %d rows,"
                  " status (%x) != DB_S_ENDOFROWSET\n",
                  cRowsReturned,
                  10,
                  sc);
#if defined (UNIT_TEST)
        cFailures++;
#else
        pRowsetLocate->Release();
        Fail();
#endif
    }

    //
    // Check data of some of the fields
    //

    for ( i = 0; i < cRowsReturned; i++)
    {
        SBasicTest Row;
        Row.pIPSStorage = 0;

        SCODE sc1 = pRowsetLocate->GetData(ahRows[i],hAccessor,&Row);

        if ( FAILED( sc1 ) )
            LogFail( "IRowset->GetData returned 0x%x\n", sc1 );

        if (wcsstr( Row.pwcPath, L"system32\\drivers\\" ) ||
            wcsstr( Row.pwcPath, L"SYSTEM32\\DRIVERS\\" ) ||
            wcsstr( Row.pwcPath, L"System32\\Drivers\\" ))
            LogFail("Query wasn't shallow as expected\n");

        if ( Row.sClsid == DBSTATUS_S_OK &&
             Row.cbClsid != sizeof CLSID )
            LogFail("length of clsid column not correct: %d\n", Row.cbClsid);

        if ( Row.sSize != DBSTATUS_S_OK ||
             Row.cbSize != sizeof LONGLONG )
            LogFail("status or length of size column not correct: %d\n",
                    Row.cbSize);
    }

    HROW ahRows2[10];
    HROW ahRows3[10];
    DBCOUNTITEM cRowsReturned2;
    HROW *phRows2 = ahRows2;

    //
    // Forward fetch rows 1 to 10 for CheckHrowIdentity comparison below
    //

    sc = pRowsetLocate->GetRowsAt(0, 0, 1, &bmkFirst, 0, 10, &cRowsReturned2, &phRows2);

    if ( FAILED( sc ) )
    {
        LogError( "IRowsetLocate->GetRowsAt returned 0x%x\n", sc );
        pRowsetLocate->Release();
        Fail();
    }

    if ( cRowsReturned2 != 10 )
    {
        LogError( "IRowset->GetRowsAt returned %d of %d rows,"
                  " status (%x) != DB_S_ENDOFROWSET\n",
                  cRowsReturned,
                  10,
                  sc);
#if defined (UNIT_TEST)
        cFailures++;
#else
        pRowsetLocate->Release();
        Fail();
#endif
    }

    //
    // Reverse ahRows2 into ahRows3 in preparation for CheckHrowIdentity
    // comparison below.
    //
    for ( i=0; i<10; i++ )
        ahRows3[i] = ahRows2[9-i];

    //
    // Check that forward fetch of rows 1 thru 10 and backwards fetch of
    // rows 10 thru 1 (and then reversed) are the same.
    //
    int fFailed = CheckHrowIdentity( 0, 0, 10, ahRows, 10, ahRows3 );
    if ( fFailed > 0 )
    {
        LogError( "Backwards fetch CheckHrowIdentity returned 0x%x\n", fFailed );
        pRowsetLocate->Release();
        Fail();
    }

    if (0 != cRowsReturned2)
    {
        SCODE sc1 = pRowsetLocate->ReleaseRows(cRowsReturned2, ahRows2, 0, 0, 0);
        if ( FAILED( sc1 ) )
        {
            LogError( "IRowset->ReleaseRows returned 0x%x\n", sc1 );
            pRowsetLocate->Release();
            Fail();
        }
    }

    if (0 != cRowsReturned)
    {
        SCODE sc1 = pRowsetLocate->ReleaseRows(cRowsReturned, ahRows, 0, 0, 0);
        if ( FAILED( sc1 ) )
        {
            LogError( "IRowset->ReleaseRows returned 0x%x\n", sc1 );
            pRowsetLocate->Release();
            Fail();
        }
    }

    pRowsetLocate->Release();

    //
    // Backwards fetch for GetRowsAtRatio
    //

    IRowsetScroll *pRowsetScroll = 0;
    sc = pRowset->QueryInterface(IID_IRowsetScroll,(void **) &pRowsetScroll );

    if ( FAILED( sc ) && sc != E_NOINTERFACE )
    {
        LogError( "IRowset::qi for IRowsetScroll failed, 0x%x\n", sc );
#if defined (UNIT_TEST)
        cFailures++;
#else
        pRowset->Release();
        Fail();
#endif
    }

    sc = pRowsetScroll->GetRowsAtRatio(0, 0, 50, 100, -9, &cRowsReturned, &phRows);

    if ( FAILED( sc ) )
    {
        LogError( "IRowsetScroll->GetRowsAtRatio returned 0x%x\n", sc );
        pRowsetScroll->Release();
        Fail();
    }

    //
    // Check data of some of the fields
    //

    for ( i = 0; i < cRowsReturned; i++)
    {
        SBasicTest Row;
        Row.pIPSStorage = 0;

        SCODE sc1 = pRowsetScroll->GetData(ahRows[i],hAccessor,&Row);

        if ( FAILED( sc1 ) )
            LogFail( "IRowsetScroll->GetData returned 0x%x\n", sc1 );

        if (wcsstr( Row.pwcPath, L"system32\\drivers\\" ) ||
            wcsstr( Row.pwcPath, L"SYSTEM32\\DRIVERS\\" ) ||
            wcsstr( Row.pwcPath, L"System32\\Drivers\\" ))
            LogFail("Query wasn't shallow as expected\n");

        if ( Row.sClsid == DBSTATUS_S_OK &&
             Row.cbClsid != sizeof CLSID )
            LogFail("length of clsid column not correct: %d\n", Row.cbClsid);

        if ( Row.sSize != DBSTATUS_S_OK ||
             Row.cbSize != sizeof LONGLONG )
            LogFail("status or length of size column not correct: %d\n",
                    Row.cbSize);
    }

    if (0 != cRowsReturned)
    {
        SCODE sc1 = pRowsetScroll->ReleaseRows(cRowsReturned, ahRows, 0, 0, 0);
        if ( FAILED( sc1 ) )
        {
            LogError( "IRowsetScroll->ReleaseRows returned 0x%x\n", sc1 );
            pRowsetScroll->Release();
            Fail();
        }
    }

    pRowsetScroll->Release();
    ReleaseAccessor( pAccessor, hAccessor);
}


//+-------------------------------------------------------------------------
//
//  Function:   FetchTest, public
//
//  Synopsis:   Test GetNextRows variations
//
//  Arguments:  [pRowset] - a pointer to an IRowset to be tested.
//
//  Returns:    Nothing
//
//  Notes:      The passed in Rowset is assumed to be set up with the
//              usual column bindings and is capable of supporting
//              Rowset movement via bookmarks in GetRowsAt.
//
//  History:    30 Sep 94       AlanW   Created from BasicTest test
//
//  ToDo:       add tests:
//                  backward fetch
//                  caller/callee allocated hrow array
//                  fetch of 0 rows
//
//--------------------------------------------------------------------------

void FetchTest( IRowset* pRowset )
{
    LogProgress( " Row fetch test\n" ); 

    int fFailed = 0;
    HROW hBad = (HROW) 0xDEDEDEDE;
    ULONG cRefsLeft = 0;
    DBROWSTATUS RowStatus = 0;

    // Try releasing a bad HROW (bug #7449)
    SCODE sc = pRowset->ReleaseRows( 1, &hBad, 0, &cRefsLeft, &RowStatus );
    if (sc != DB_E_ERRORSOCCURRED ||
        RowStatus != DBROWSTATUS_E_INVALID)
    {
        LogError( "ReleaseRows of bad handle returned %x, %x\n", sc, RowStatus );
        fFailed++;
    }

    cFailures += fFailed;
#if !defined(UNIT_TEST)
    if (fFailed) {
        pRowset->Release();
        Fail();
    }
#endif // !UNIT_TEST
} //FetchTest


//+-------------------------------------------------------------------------
//
//  Function:   BindingTest, public
//
//  Synopsis:   Test some of the many possible error paths in CreateAccessor
//
//  Arguments:  [pCursor] - a pointer to an IRowset* to be tested.
//
//  Returns:    Nothing
//
//  Notes:      The helper function TryBinding does much of the work,
//              trying a couple of different scenarios with each input
//              binding set, checking results and reporting errors.
//
//  History:    02 Jul 94       AlanW   Created
//
//--------------------------------------------------------------------------

static DBBINDING aTestBindings[] =
{
  { 0,                   // binding 0
    0,
    0,
    0,
    0,0,0,
    DBPART_VALUE,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    sizeof (VARIANT),
    0, DBTYPE_VARIANT,
    0,0},
  { 2,                   // binding 1
    0,
    0,
    0,
    0,0,0,
    DBPART_VALUE,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    0,
    0, DBTYPE_I8,
    0,0},
  { 2,                  // binding 2
    2 * sizeof (VARIANT),
    0,
    0,
    0,0,0,
    (DBPART) 0x01000000,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    sizeof (VARIANT),
    0, DBTYPE_VARIANT,
    0,0},
  { 2,                  // binding 3
    3 * sizeof (VARIANT),
    0,
    0,
    0,0,0,
    DBPART_STATUS,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    sizeof (VARIANT),
    0, DBTYPE_VARIANT,
    0,0},
  { 2,                  // binding 4
    7,
    0,
    0,
    0,0,0,
    DBPART_VALUE,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    1,
    0, DBTYPE_I8,
    0,0},
  { 1,                  // binding 5
    0,
    0,
    0,
    0,0,0,
    DBPART_VALUE|DBPART_STATUS,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    1,
    0, DBTYPE_I8,
    0,0},
  { 1,                  // binding 6
    0,
    0,
    0,
    0,0,0,
    DBPART_VALUE,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    1,
    0, DBTYPE_GUID,
    0,0},
  { 1,                  // binding 7
    0,
    0,
    0,
    0,0,0,
    DBPART_VALUE,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    1,
    0, DBTYPE_GUID,
    0,0},
  { 1,                  // binding 8
    0,
    0,
    0,
    (ITypeInfo *) 1,0,0,
    DBPART_VALUE,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    1,
    0, DBTYPE_VARIANT,
    0,0},
  { 1,                  // binding 9
    0,
    0,
    0,
    0,0,0,
    DBPART_VALUE,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    1,
    0, DBTYPE_GUID,
    0,0},
  { 1,                  // binding 10
    0,
    0,
    0,
    0,0,0,
    DBPART_VALUE,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    1,
    0, DBTYPE_I4|DBTYPE_BYREF,
    0,0},
  { 1,                  // binding 11
    0,
    20,
    0,
    0,0,0,
    DBPART_VALUE,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    1,
    DBBINDFLAG_HTML, DBTYPE_WSTR,
    0,0},
  { 1,                  // binding 12
    0,
    20,
    0,
    0,0,0,
    DBPART_VALUE,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    1,
    0x20, DBTYPE_WSTR,
    0,0},
};

int TryBinding(
    int        iTest,
    IAccessor * pIAccessor,
    DBACCESSORFLAGS   dwAccessorFlags,
    ULONG      cBindings,
    ULONG      iFirstBinding,
    SCODE      scExpected,
    DBBINDSTATUS FailStatus = DBBINDSTATUS_OK)
{
    HACCESSOR hAccessor = 0;
    DBBINDSTATUS aBindStatus[20];
    SCODE sc = pIAccessor->CreateAccessor( dwAccessorFlags,
                                           cBindings,
                                           &(aTestBindings[iFirstBinding]),
                                           0,
                                           &hAccessor,
                                           aBindStatus );

    int iRet = 0;

    if (scExpected != sc)
    {
        LogError( "IAccessor->CreateAccessor test %d returned 0x%x (expected 0x%x)\n",
                iTest,
                sc,
                scExpected );
        iRet = 1;
    }

    if ((SUCCEEDED(sc) || DB_E_ERRORSOCCURRED == sc) &&
        DBBINDSTATUS_OK != FailStatus)
    {
        for (unsigned i=0; i<cBindings; i++)
        {
            if (aBindStatus[i] == FailStatus)
                break;
        }

        if (i == cBindings)
        {
            LogError( "IAccessor->CreateAccessor test %d returned DBBINDSTATUS 0x%x (expected 0x%x)\n",
                    iTest,
                    aBindStatus[0],
                    FailStatus );
            iRet = 1;
        }
    }

    if (! FAILED(sc))
        pIAccessor->ReleaseAccessor( hAccessor, 0);

    return iRet;
} //TryBinding

void BindingTest( IUnknown* pUnk, BOOL fICommand, BOOL fSequential )
{
    LogProgress( " Accessor binding test\n" );

    int fFailed = 0;
    DBACCESSORFLAGS StdFlags = DBACCESSOR_ROWDATA;

    IAccessor * pIAcc = 0;

    SCODE sc = pUnk->QueryInterface( IID_IAccessor, (void **)&pIAcc);
    if ( FAILED( sc ) || pIAcc == 0 )
    {
        LogFail( "QueryInterface for IAccessor returned 0x%lx\n", sc );
    }

    // regr test for bug #71492, check that we can QI to IConvertType
    // from IAccessor

    IConvertType * pICvtType = 0;
    sc = pUnk->QueryInterface( IID_IConvertType, (void **)&pICvtType);
    if ( FAILED( sc ) || pICvtType == 0 )
    {
        LogError( "QueryInterface for IConvertType returned 0x%lx\n", sc );
        fFailed++;
    }
    else
    {
        pICvtType->Release();
    }

    sc = pIAcc->QueryInterface( IID_IConvertType, (void **)&pICvtType);
    if ( FAILED( sc ) || pICvtType == 0 )
    {
        LogError( "QueryInterface for IConvertType from accessor returned 0x%lx\n", sc );
        fFailed++;
    }
    else
    {
        pICvtType->Release();
    }

    SCODE scExpected = (fSequential & !fICommand) ? DB_E_ERRORSOCCURRED : S_OK;
    DBBINDSTATUS BindStatExp = (fSequential & !fICommand) ?
                                             DBBINDSTATUS_BADORDINAL :
                                             DBBINDSTATUS_OK;

    // Test the return value for a bad column ordinal
    aTestBindings[0].iOrdinal = 0;
    fFailed += TryBinding( 1, pIAcc, StdFlags, 1, 0, scExpected, BindStatExp);

    scExpected = fICommand ? S_OK : DB_E_ERRORSOCCURRED;
    BindStatExp = fICommand ? DBBINDSTATUS_OK : DBBINDSTATUS_BADORDINAL;

    // Test the return value for another bad column ordinal
    aTestBindings[0].iOrdinal = 1000;
    fFailed += TryBinding( 2, pIAcc, StdFlags, 1, 0, scExpected, BindStatExp);

    // Don't allow room for the I8 to be returned
    // But that's ok! fixed-len fields are allowed to pass bogus
    // values for length
    fFailed += TryBinding( 3, pIAcc, StdFlags, 1, 1, S_OK );

    // bogus accessor flags (no bits on, and unused bits turned on)
    fFailed += TryBinding( 4, pIAcc, 0, 1, 1, DB_E_BADACCESSORFLAGS );
    fFailed += TryBinding( 5, pIAcc, DBACCESSOR_ROWDATA|(DBACCESSOR_OPTIMIZED<<1), 1, 1, DB_E_BADACCESSORFLAGS );

    // null binding array
    fFailed += TryBinding( 6, pIAcc, StdFlags, 0, 1, DB_E_NULLACCESSORNOTSUPPORTED );

    // ofs doesn't support Param accessors (yet)
    fFailed += TryBinding( 7, pIAcc, DBACCESSOR_PARAMETERDATA, 1, 1, DB_E_BADACCESSORFLAGS ); //E_NOTIMPL );

#if 0 // Replace these with some other test...
    // ofs doesn't support writable accessors
    fFailed += TryBinding( 8, pIAcc, DBACCESSOR_ROWDATA, 1, 1, DB_E_ACCESSVIOLATION );
#endif // 

    // ofs doesn't support passbyref accessors
    fFailed += TryBinding( 9, pIAcc, DBACCESSOR_ROWDATA|DBACCESSOR_PASSBYREF, 1, 1, DB_E_BYREFACCESSORNOTSUPPORTED );

    // bogus dbcolumnpart -- none of the valid bits turned on
    fFailed += TryBinding( 10, pIAcc, StdFlags, 1, 2, DB_E_ERRORSOCCURRED, DBBINDSTATUS_BADBINDINFO );

    // just ask for status -- not for data too
    fFailed += TryBinding( 11, pIAcc, StdFlags, 1, 3, S_OK );

    // bad alignment for output data -- No longer fatal.
    fFailed += TryBinding( 12, pIAcc, StdFlags, 1, 4, S_OK );

    // overlap value and status output fields
    fFailed += TryBinding( 13, pIAcc, StdFlags, 1, 5, DB_E_ERRORSOCCURRED, DBBINDSTATUS_BADBINDINFO );

    // make sure each of the two duplicate bindings used below is ok by itself
    fFailed += TryBinding( 14, pIAcc, StdFlags, 1, 6, S_OK );
    fFailed += TryBinding( 15, pIAcc, StdFlags, 1, 7, S_OK );

    // overlap value fields in two bindings
    fFailed += TryBinding( 16, pIAcc, StdFlags, 2, 6, DB_E_ERRORSOCCURRED, DBBINDSTATUS_BADBINDINFO );

    // supply ITypeInfo field
    fFailed += TryBinding( 17, pIAcc, StdFlags, 1, 8, DB_E_ERRORSOCCURRED, DBBINDSTATUS_BADBINDINFO );

    // direct bind to GUID type
    fFailed += TryBinding( 18, pIAcc, StdFlags, 1, 9, S_OK );

    // unsupported byref binding
    fFailed += TryBinding( 19, pIAcc, StdFlags, 1, 10, DB_E_ERRORSOCCURRED, DBBINDSTATUS_BADBINDINFO ); //danleg changed hraccess... UNSUPPORTEDCONVERSION );

    // unsupported HTML flag
    fFailed += TryBinding( 20, pIAcc, StdFlags, 1, 11, DB_E_ERRORSOCCURRED, DBBINDSTATUS_BADBINDINFO );

    // unknown dwFlags field
    fFailed += TryBinding( 21, pIAcc, StdFlags, 1, 12, DB_E_ERRORSOCCURRED, DBBINDSTATUS_BADBINDINFO );

    cFailures += fFailed;
    pIAcc->Release();

#if !defined(UNIT_TEST)
    if (fFailed) {
        pUnk->Release();
        Fail();
    }
#endif // !UNIT_TEST

} //BindingTest


void TestIAccessorOnCommand( ICommandTree * pCmdTree )
{
    DBID aDbCols[cBasicTestCols];
    aDbCols[0] = psClassid;
    aDbCols[1] = psSize;
    aDbCols[2] = psWriteTime;
    aDbCols[3] = psAttr;
    aDbCols[4] = psName;
    aDbCols[5] = psPath;
    aDbCols[6] = psSelf;

    HACCESSOR hAccessor = MapColumns( pCmdTree,
                                      cBasicTestCols,
                                      aBasicTestCols,
                                      aDbCols,
                                      FALSE );

    //
    // Clean up.
    //
    ReleaseAccessor( pCmdTree, hAccessor);
}

#define MAX_BOOKMARK_LENGTH     16

DBBINDING aMoveTestCols[] =
{
  // the iOrdinal field is filled out after the cursor is created

  {
    0,
    sizeof DBLENGTH,
    0,
    0,
    0,0,0,
    DBPART_VALUE|DBPART_LENGTH,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    MAX_BOOKMARK_LENGTH,
    0, DBTYPE_BYTES,
    0, 0},
};

const ULONG cMoveTestCols = sizeof aMoveTestCols / sizeof aMoveTestCols[0];

struct BookmarkBinding {
    DBLENGTH    cbBmk;
    BYTE        abBmk[MAX_BOOKMARK_LENGTH];
};


BookmarkBinding aBmks[21];

HACCESSOR hBmkAccessor = 0;


//+-------------------------------------------------------------------------
//
//  Function:   GetBookmarks, public
//
//  Synopsis:   Retrieve bookmarks into the global bookmarks array
//
//  Effects:    aBmks is loaded with bookmarks, one for each row
//
//  Arguments:  [pRowset] - a pointer to IRowsetLocate
//              [cRows]   - nuumber of HROWs in the array
//              [phRows] - a pointer to the HROWs array
//
//  Returns:    0/1 - count of failures
//
//  Notes:      Assumes hBmkAccessor is bound to the rowset for
//              retrieving into the BookmarkBinding struct.
//
//  History:    30 Mar 1995     AlanW   Created
//
//--------------------------------------------------------------------------

int GetBookmarks(
    IRowsetLocate * pRowset,
    DBCOUNTITEM cRows,
    HROW * phRows )
{
    int fFailed = 0;
    SCODE sc;

    for (unsigned i=0; i<cRows; i++)
    {
        sc = pRowset->GetData(phRows[i], hBmkAccessor, &aBmks[i]);
        if (FAILED(sc) || DB_S_ERRORSOCCURRED == sc)
        {
            if (! fFailed)
                LogError( "IRowset::GetData for bookmark failed 0x%x\n", sc );
            fFailed++;
        }
    }
    if (fFailed)
        LogError(" %d/%d failures\n", fFailed, cRows);

    return fFailed != 0;
}


//+-------------------------------------------------------------------------
//
//  Function:   CheckHrowIdentity, private
//
//  Synopsis:   Check for hrow identity among two arrays of HROWs
//
//  Arguments:  [pRowsetIdentity] - if non-zero, a pointer to an
//                      IRowsetIdentity for comparing the HROWs.
//              [lOffset] - offset of matching rows in the two arrays.
//                      Positive if second array is shifted from first,
//                      negative otherwise.
//              [cRows1] - count of rows in first array
//              [phRows1] - pointer to HROWs, first array
//              [cRows2] - count of rows in second array
//              [phRows2] - pointer to HROWs, second array
//
//  Returns:    int - error count
//
//  Notes:
//
//  History:     03 Apr 95      AlanW   Created
//
//--------------------------------------------------------------------------

int CheckHrowIdentity(
    IRowsetIdentity * pRowsetIdentity,
    DBROWCOUNT lOffset,
    DBCOUNTITEM cRows1,
    HROW * phRows1,
    DBCOUNTITEM cRows2,
    HROW * phRows2
) {
    int fFailed = 0;
    SCODE sc;

    DBROWCOUNT o1 = 0, o2 = 0;
    DBCOUNTITEM cRows = min(cRows1, cRows2);

    if (lOffset < 0)
    {
        o1 = -lOffset;
        if (cRows1 - o1 < cRows)
            cRows = cRows1 - o1;
    }
    else if (lOffset > 0)
    {
        o2 = lOffset;
        if (cRows2 - o2 < cRows)
            cRows = cRows2 - o2;
    }

    for (unsigned i=0; i<cRows; i++)
    {
        int fHrowEqual = 0;

        // Compare HROWs for identity
        if (pRowsetIdentity)
        {
            sc = pRowsetIdentity->IsSameRow(phRows1[i+o1], phRows2[i+o2]);
            if (sc == S_OK)
                fHrowEqual = 1;
            else if (sc == S_FALSE)
                fHrowEqual = 0;
            else
            {
                LogError("IRowsetIdentity->IsSameRow returned %x\n", sc);
                fFailed++;
                fHrowEqual = 1;         // only one error for this
            }
        }
        else
            fHrowEqual = (phRows1[i+o1] == phRows2[i+o2]);

        if (! fHrowEqual)
        {
            LogError( "Hrows didn't compare for equality (used identity %d), %x %x\n",
                      ( 0 != pRowsetIdentity ), phRows1[i+o1], phRows2[i+o2] );
            fFailed++;
        }

        if (o1 == o2 || phRows1 == phRows2)
            continue;

        //  Now compare two which should be unequal
        if (pRowsetIdentity)
        {
            sc = pRowsetIdentity->IsSameRow(phRows1[i], phRows2[i]);
            if (sc == S_OK)
                fHrowEqual = 1;
            else if (sc == S_FALSE)
                fHrowEqual = 0;
            else
            {
                LogError("IRowsetIdentity->IsSameRow (2) returned %x\n", sc);
                fFailed++;
                fHrowEqual = 1;         // only one error for this
            }
        }
        else
            fHrowEqual = (phRows1[i] == phRows2[i]);

        if (fHrowEqual)
        {
            LogError("Different Hrows compared equal, %x %x\n",
                                    phRows1[i], phRows2[i]);
            fFailed++;
        }
    }
    return fFailed;
}


//+-------------------------------------------------------------------------
//
//  Function:   MoveTest, public
//
//  Synopsis:   Test IRowsetLocate and IRowsetScroll methods
//
//  Arguments:  [pRowset] - a rowset supporting IRowsetLocate and
//                          optionally IRowsetScroll
//              [hChapt]  - rowset chapter if chaptered
//
//  Returns:    Nothing, exits if test error
//
//  Notes:      IRowsetLocate tests:
//                  QI to IRowsetLocate
//                  QI to IRowsetIdentity
//                  Bind to bookmark column
//                  Compare bookmarks with standard bookmark combinations
//                  Move to beginning and fetch
//                  Get bookmarks for fetched rows
//                  Compare bookmarks for first and second rows
//                  Fetch starting at second row
//                  Check bookmark equivalence for overlapping rows
//                  Check HROW identity for overlapping rows
//                  Move to end and fetch, check cRowsReturned and status
//                  Move after end and fetch, check cRowsReturned and status
//
//              IRowsetScroll tests:
//                  QI to IRowsetScroll
//                  Scroll to 50% and fetch, check GetApproximatePosition
//                  Scroll to 14/27 and fetch, compare rows from 50% fetch
//                  Scroll to 14/13, check for error
//                  Check GetApproximatePosition with std bookmarks
//
//  History:    16 Aug 94       AlanW   Created
//              02 Apr 95       AlanW   Updated for ole-db phase 3, bookmark
//                                      bindings.
//
//--------------------------------------------------------------------------

BookmarkBinding FirstRowBmk;
BookmarkBinding SecondRowBmk;
BookmarkBinding LastRowBmk;
BookmarkBinding PenultimateRowBmk;

const long cLocateTest = 7;
const long cLocateTest2 = 9;

void MoveTest(
    IRowset * pRowset, HCHAPTER hChapt
) {
    int fFailed = 0;

    if (hChapt == DB_NULL_HCHAPTER)
        LogProgress( " IRowsetLocate test\n" );

    IRowsetLocate * pRowsetLocate = 0;
    SCODE sc = pRowset->QueryInterface(IID_IRowsetLocate,
                                       (void **)&pRowsetLocate);

    if (FAILED(sc) || pRowsetLocate == 0) {
        LogFail("QueryInterface to IRowsetLocate failed\n");
    }

    IRowsetIdentity * pRowsetIdentity = 0;
    sc = pRowset->QueryInterface(IID_IRowsetIdentity,
                                       (void **)&pRowsetIdentity);

    if (FAILED(sc) && (sc != E_NOINTERFACE || pRowsetIdentity != 0)) {
        LogError("QueryInterface to IRowsetIdentity failed (%x)\n", sc);
        pRowsetIdentity = 0;
        fFailed++;
    }

    BOOL fCompareOrdered = GetBooleanProperty( pRowset, DBPROP_ORDEREDBOOKMARKS );
    BOOL fBookmarkBound = FALSE;

    // need to know how many rows in the chapter total, so that tests
    // below can be relaxed if there are just a few.

    DBCOUNTITEM cTableRows;
    IRowsetScroll * pIRowsetScroll = 0;
    SCODE sca = pRowset->QueryInterface(IID_IRowsetScroll,(void **) &pIRowsetScroll );
    if ( FAILED( sca ) )
    {
        LogError( "IRowset::qi for rowsetscroll returned 0x%lx\n", sca );
        fFailed++;
    }

    sca = pIRowsetScroll->GetApproximatePosition(hChapt,
                                                0,0, 0, &cTableRows);

    if ( FAILED( sca ) )
    {
        LogError( "IRowsetScroll::GetApproximatePosition returned 0x%lx\n", sca );
        fFailed++;
    }

    if (fVerbose > 1)
        LogProgress("   Movable rowset has %d rows\n",cTableRows);

    pIRowsetScroll->Release();

    //
    //  Get the column number for the standard bookmark if available
    //
    hBmkAccessor = MapColumns(pRowset, 1, aMoveTestCols, &psBookmark);
    fBookmarkBound = TRUE;

    if ( aMoveTestCols[0].iOrdinal != 0 )
    {
        LogError( "Bookmark column is not ordinal 0 ( = %d)\n",
                  aMoveTestCols[0].iOrdinal );
        fFailed++;
    }

    HROW* phRows = 0;
    DBROWCOUNT cRowsRequested = 1000;
    DBCOUNTITEM cRowsReturned =   0;

    //
    //  Fetch 1000 rows from the beginning of the rowset.
    //
    sc = pRowsetLocate->GetRowsAt( 0, hChapt, 1, &bmkFirst, 0,
                                   cRowsRequested, &cRowsReturned, &phRows);

    if ( FAILED( sc ) )
    {
        LogError( "IRowsetLocate->GetRowsAt(1000) returned 0x%x\n", sc );
        fFailed++;
    }
    else if (sc != DB_S_ENDOFROWSET &&
             cRowsReturned != (DBCOUNTITEM) cRowsRequested)
    {
        LogError( "IRowsetLocate->GetRowsAt J returned %d of %d rows\n",
                    cRowsReturned, cRowsRequested);
        fFailed++;
    }

    if (phRows)
        FreeHrowsArray( pRowsetLocate, cRowsReturned, &phRows);

    //
    //  Fetch 10 rows from the beginning of the rowset.
    //
    cRowsRequested = 10;
    sc = pRowsetLocate->GetRowsAt(0, hChapt, 1,&bmkFirst, 0,
                             cRowsRequested, &cRowsReturned, &phRows);

    if ( FAILED( sc ) )
    {
        LogError( "IRowsetLocate->GetRowsAt K returned 0x%x\n", sc );
        fFailed++;
    }
    else if (sc != DB_S_ENDOFROWSET &&
             cRowsReturned != (DBCOUNTITEM) cRowsRequested)
    {
        LogError( "IRowsetLocate->GetRowsAt L returned %d of %d rows\n",
                    cRowsReturned, cRowsRequested);
        fFailed++;
    }

    HROW* phRows2 = 0;
    DBCOUNTITEM cRowsReturned2 = 0;

    DWORD dwCompare = 0xFFFFFFFF;

    if (fBookmarkBound)
    {
        fFailed += GetBookmarks( pRowsetLocate, cRowsReturned, phRows);
        FirstRowBmk = aBmks[0];

        if ( cRowsReturned > 1 )
            SecondRowBmk = aBmks[1];
        else
            SecondRowBmk.cbBmk = 0;

        sc = pRowsetLocate->Compare(hChapt, 1,&bmkFirst,
                            FirstRowBmk.cbBmk, FirstRowBmk.abBmk, &dwCompare);

        if ( FAILED( sc ) )
        {
            LogError( "IRowsetLocate->Compare of DBBMK_FIRST returned 0x%x\n", sc );
            fFailed++;
        }
        else if (dwCompare != DBCOMPARE_NE)
        {
            // DBBMK_FIRST is not the same as the first row's bookmark
            LogError( "Compare of DBBMK_FIRST and returned bookmark not "
                        "notequal (%d)\n", dwCompare );
            fFailed++;
        }
        if (cRowsReturned >= 2)
        {
            sc = pRowsetLocate->Compare(hChapt,
                                    FirstRowBmk.cbBmk, FirstRowBmk.abBmk,
                                    SecondRowBmk.cbBmk, SecondRowBmk.abBmk,
                                    &dwCompare);

            if ( FAILED( sc ) )
            {
                LogError( "IRowsetLocate->Compare returned 0x%x\n", sc );
                fFailed++;
            }
            else if ((fCompareOrdered && dwCompare != DBCOMPARE_LT) ||
                     (! fCompareOrdered && dwCompare != DBCOMPARE_NE))
            {
                LogError( "Compare of first and second returned bookmarks not "
                            "%s (%d)\n",
                            fCompareOrdered? "less than" : "not equal",
                            dwCompare );
                fFailed++;
            }

            //
            //  Fetch 10 rows starting at the second row.  Compare
            //  the overlapping returned HROWs.
            //

            sc = pRowsetLocate->GetRowsAt(0, hChapt,
                                    SecondRowBmk.cbBmk, SecondRowBmk.abBmk, 0,
                                    cRowsRequested, &cRowsReturned2, &phRows2);

            if ( FAILED( sc ) )
            {
                LogError("IRowsetLocate->GetRowsAt (2) returned 0x%x\n", sc );
                fFailed++;
            }
            else if (sc != DB_S_ENDOFROWSET &&
                     cRowsReturned2 != (DBCOUNTITEM) cRowsRequested)
            {
                LogError("IRowsetLocate->GetRowsAt (2) returned %d of %d rows\n",
                            cRowsReturned2, cRowsRequested);
                fFailed++;
            }
            else if (sc == DB_S_ENDOFROWSET &&
                     cRowsReturned2 < (DBCOUNTITEM) cRowsRequested &&
                     cRowsReturned2 != cRowsReturned - 1)
            {
                LogError("IRowsetLocate->GetRowsAt (2) returned inconsistent row count, %d  - %d\n",
                            cRowsReturned2, cRowsReturned);
                fFailed++;
            }

            fFailed += CheckHrowIdentity(pRowsetIdentity, -1,
                                         cRowsReturned, phRows,
                                         cRowsReturned2, phRows2);


            fFailed += GetBookmarks( pRowsetLocate, 1, phRows2);

            sc = pRowsetLocate->Compare(hChapt,
                                    SecondRowBmk.cbBmk, SecondRowBmk.abBmk,
                                    aBmks[0].cbBmk, aBmks[0].abBmk,
                                    &dwCompare);

            if ( FAILED( sc ) )
            {
                LogError( "IRowsetLocate->Compare returned 0x%x\n", sc );
                fFailed++;
            }
            else if (dwCompare != DBCOMPARE_EQ)
            {
                LogError( "Compare of second row bookmarks not equal (%d)\n",
                                        dwCompare );
                fFailed++;
            }
            FreeHrowsArray( pRowsetLocate, cRowsReturned2, &phRows2);
        }
    }

    FreeHrowsArray( pRowsetLocate, cRowsReturned, &phRows);

    //
    //  Fetch at end, 3 cases:
    //          Last - 1        expect 2 rows returned
    //          Last + 0        expect 1 row returned
    //          Last + 1        expect 0 rows
    //

    sc = pRowsetLocate->GetRowsAt(0, hChapt, 1,&bmkLast, -1,
                                cRowsRequested, &cRowsReturned, &phRows);

    PenultimateRowBmk.cbBmk = 0;
    LastRowBmk.cbBmk = 0;

    if ( FAILED( sc ) )
    {
        LogError( "IRowsetLocate->GetRowsAt M returned 0x%x\n", sc );
        fFailed++;
    }
    else if (sc != DB_S_ENDOFROWSET ||
             (cRowsReturned != 2 && cTableRows >= 2 ) )
    {
        LogError( "IRowsetLocate->GetRowsAt N returned %d rows at DBBMK_LAST - 1, sc: %lx\n",
                    cRowsReturned, sc );
        fFailed++;
    }
    else if (fBookmarkBound && cRowsReturned >= 2)
    {
        fFailed += GetBookmarks( pRowsetLocate, cRowsReturned, phRows);
        LastRowBmk = aBmks[1];
        PenultimateRowBmk = aBmks[0];

        sc = pRowsetLocate->Compare(hChapt, 1,&bmkLast,
                            LastRowBmk.cbBmk, LastRowBmk.abBmk, &dwCompare);

        if ( FAILED( sc ) )
        {
            LogError( "IRowsetLocate->Compare of DBBMK_LAST returned 0x%x\n", sc );
            fFailed++;
        }
        else if (dwCompare != DBCOMPARE_NE)
        {
            // DBBMK_LAST is not the same as the last row's bookmark
            LogError( "Compare of DBBMK_LAST and returned bookmark not "
                        "notequal (%d)\n", dwCompare );
            fFailed++;
        }

        if (cRowsReturned >= 2)
        {
            sc = pRowsetLocate->Compare(hChapt,
                                    LastRowBmk.cbBmk, LastRowBmk.abBmk,
                                    aBmks[0].cbBmk, aBmks[0].abBmk,
                                    &dwCompare);

            if ( FAILED( sc ) )
            {
                LogError( "IRowsetLocate->Compare returned 0x%x\n", sc );
                fFailed++;
            }
            else if ((fCompareOrdered && dwCompare != DBCOMPARE_GT) ||
                     (! fCompareOrdered && dwCompare != DBCOMPARE_NE))
            {
                LogError( "Compare of last and penultimate returned bookmarks not "
                            "%s (%d)\n",
                            fCompareOrdered? "greater than" : "not equal",
                            dwCompare );
                fFailed++;
            }
        }
    }

    FreeHrowsArray( pRowsetLocate, cRowsReturned, &phRows);

    sc = pRowsetLocate->GetRowsAt(0, hChapt, 1,&bmkLast, 0,
                                cRowsRequested, &cRowsReturned, &phRows);

    if ( FAILED( sc ) )
    {
        LogError( "IRowsetLocate->GetRowsAt O returned 0x%x\n", sc );
        fFailed++;
    }
    else if (sc != DB_S_ENDOFROWSET ||
             cRowsReturned != 1 )
    {
        LogError( "IRowsetLocate->GetRowsAt P returned %d rows at DBBMK_LAST, sc: %lx\n",
                    cRowsReturned, sc );
        fFailed++;
    }

    FreeHrowsArray( pRowsetLocate, cRowsReturned, &phRows);

    sc = pRowsetLocate->GetRowsAt(0, hChapt, 1,&bmkLast, 1,
                                cRowsRequested, &cRowsReturned, &phRows);

    if ( FAILED( sc ) /* && DB_E_BADSTARTPOSITION != sc */ )
    {
        LogError( "IRowsetLocate->GetRowsAt Q returned 0x%x\n", sc );
        fFailed++;
    }
    else if ( sc != DB_S_ENDOFROWSET || cRowsReturned != 0 )
    {
        LogError( "IRowsetLocate->GetRowsAt R returned sc 0x%x, %d rows at DBBMK_LAST + 1\n",
                   sc, cRowsReturned );
        fFailed++;
    }

    if (0 == cRowsReturned &&
        phRows != 0)            // Bug #7668 (part)
    {
        LogError("HROW array allocated without returned rows\n");
        fFailed++;
    }

    FreeHrowsArray( pRowsetLocate, cRowsReturned, &phRows);

    // OLE-DB spec. bug #1007
    sc = pRowsetLocate->GetRowsAt(0, hChapt, 1,&bmkLast, 0,
                                1, &cRowsReturned, &phRows);

    if ( FAILED( sc ) )
    {
        LogError( "IRowsetLocate->GetRowsAt S returned 0x%x\n", sc );
        fFailed++;
    }
    else if (sc == DB_S_ENDOFROWSET ||
             cRowsReturned != 1 )
    {
        LogError( "IRowsetLocate->GetRowsAt T returned ENDOFROWSET inappropriately"
                " at DBBMK_LAST, %d\n",
                    cRowsReturned );
        fFailed++;
    }
    FreeHrowsArray( pRowsetLocate, cRowsReturned, &phRows);

    if ( cTableRows > cLocateTest2 )
    {
        sc = pRowsetLocate->GetRowsAt(0, hChapt, 1,&bmkLast, -cLocateTest,
                            cLocateTest + 1, &cRowsReturned, &phRows);

        if ( FAILED( sc ) )
        {
            LogError("IRowsetLocate->GetRowsAt U (end-%d) returned 0x%x\n", cLocateTest,
                     sc );
            fFailed++;
        }
        else if (fBookmarkBound)
            fFailed += GetBookmarks( pRowsetLocate, cRowsReturned, phRows);

        sc = pRowsetLocate->GetRowsAt(0, hChapt, 1,&bmkLast, -cLocateTest2,
                            cLocateTest2 + 1, &cRowsReturned2, &phRows2);

        if ( FAILED( sc ) )
        {
            LogError("IRowsetLocate->GetRowsAt(2) V (end-%d) returned 0x%x\n",
                     cLocateTest2, sc );
            fFailed++;
        }
        else if ( (cRowsReturned <= cLocateTest && cRowsReturned2 != cRowsReturned) ||
                  (cRowsReturned == (cLocateTest+1) && cRowsReturned2 <= cLocateTest) )
        {
            if ( sc != DB_S_ENDOFROWSET )
            {
                LogError("IRowsetLocate->GetRowsAt W (end-%d) returned %d rows\n",
                         cLocateTest2, cRowsReturned2 );
                fFailed++;
            }
        }
        else
        {
            fFailed += CheckHrowIdentity( pRowsetIdentity,
                                          cRowsReturned2 - cRowsReturned,
                                          cRowsReturned, phRows,
                                          cRowsReturned2, phRows2);

        }
        FreeHrowsArray( pRowsetLocate, cRowsReturned2, &phRows2);
        FreeHrowsArray( pRowsetLocate, cRowsReturned, &phRows);

        if (fBookmarkBound)
        {
            // Attempt to call GetRowsByBookmark with bookmarks we've collected.

            const unsigned cBybmkTest = cLocateTest + 1 + 5 + 1;
            DBBKMARK rgcbBookmarks[cBybmkTest];
            BYTE* rgpBookmarks[cBybmkTest];
            ULONG cBookmarks = 0;

            for (unsigned i = 0; i<cRowsReturned; i++)
            {
                rgcbBookmarks[cBookmarks] = aBmks[i].cbBmk;
                rgpBookmarks[cBookmarks] = &aBmks[i].abBmk[0];
                cBookmarks++;
            }

            rgcbBookmarks[cBookmarks] = FirstRowBmk.cbBmk;
            rgpBookmarks[cBookmarks++] = &FirstRowBmk.abBmk[0];

            if ( 0 != SecondRowBmk.cbBmk )
            {
                rgcbBookmarks[cBookmarks] = SecondRowBmk.cbBmk;
                rgpBookmarks[cBookmarks++] = &SecondRowBmk.abBmk[0];
            }

            if ( 0 != LastRowBmk.cbBmk )
            {
                rgcbBookmarks[cBookmarks] = LastRowBmk.cbBmk;
                rgpBookmarks[cBookmarks++] = &LastRowBmk.abBmk[0];
            }

            if ( 0 != PenultimateRowBmk.cbBmk )
            {
                rgcbBookmarks[cBookmarks] = PenultimateRowBmk.cbBmk;
                rgpBookmarks[cBookmarks++] = &PenultimateRowBmk.abBmk[0];
            }

            rgcbBookmarks[cBookmarks] = FirstRowBmk.cbBmk;
            rgpBookmarks[cBookmarks++] = &FirstRowBmk.abBmk[0];

            DBROWSTATUS BmkErrors[cBybmkTest];
            HROW hRows[cBybmkTest];
            sc = pRowsetLocate->GetRowsByBookmark( hChapt,
                                                   cBookmarks, rgcbBookmarks,
                                                   (const BYTE **)rgpBookmarks,
                                                   hRows, BmkErrors);
            if ( FAILED( sc ) )
            {
                LogError( "IRowsetLocate->GetRowsByBookmark returned 0x%x\n", sc );
                fFailed++;
            }
            else if ( sc != S_OK )
            {
                LogError( "Not all rows returned from GetRowsByBookmark, sc = 0x%x"
                            "\t%d\n", sc, cBookmarks );
                fFailed++;
            }
            else
            {
                fFailed += GetBookmarks( pRowsetLocate, cBookmarks, hRows);
            }

            ReleaseStaticHrows( pRowsetLocate, cBookmarks, hRows);

            //
            // Try with a bad bookmark; check that correct status and
            // HROW are returned.  Regression test for #80381.
            //
            unsigned iBadRow = cBookmarks / 2;
            rgcbBookmarks[cBookmarks] = rgcbBookmarks[iBadRow];
            rgpBookmarks[cBookmarks++] = rgpBookmarks[iBadRow];

            rgcbBookmarks[iBadRow] = 1;
            rgpBookmarks[iBadRow] = (BYTE *)&bmkFirst;

            sc = pRowsetLocate->GetRowsByBookmark( hChapt,
                                                   cBookmarks, rgcbBookmarks,
                                                   (const BYTE **)rgpBookmarks,
                                                   hRows, BmkErrors);

            if ( sc != DB_S_ERRORSOCCURRED )
            {
                LogError( "GetRowsByBookmark with special bookmark didn't give error, sc = 0x%x"
                            "\t%d\n", sc, cBookmarks );
                fFailed++;
            }
            else if (hRows[iBadRow] != DB_NULL_HROW ||
                     BmkErrors[iBadRow] != DBROWSTATUS_E_INVALID)
            {
                LogError( "GetRowsByBookmark with special bookmark didn't give null hrow or correct status, "
                          "hrow = 0x%x\trs = 0x%x\n", hRows[iBadRow], BmkErrors[iBadRow] );
                fFailed++;
            }
            ReleaseStaticHrows( pRowsetLocate, cBookmarks, hRows);
        }
    }


    //-------------------------
    //
    //  IRowsetScroll tests
    //
    //-------------------------

    IRowsetScroll * pRowsetScroll;
    sc = pRowset->QueryInterface(IID_IRowsetScroll,
                                 (void **)&pRowsetScroll);

    BOOL fScroll = SUCCEEDED(sc);

    if (fScroll)
    {
        if (hChapt == DB_NULL_HCHAPTER)
            LogProgress( " IRowsetScroll test\n" );

        DBCOUNTITEM ulNum = 1, cRows = 0;
        BookmarkBinding HalfRowBmk;

/***
Additional Scroll tests to be coded up:
    Scroll to 10%, 20%, 30%..., GetBookmark, GetPosition and check
    Try bad fractions, 0/0, 101/100, fffffffe/ffffffff, etc.
***/
        //
        //  Try a simple scroll
        //

        cRowsRequested = 20;
        sc = pRowsetScroll->GetRowsAtRatio(0, hChapt, 50, 100,
                                    cRowsRequested, &cRowsReturned, &phRows);

        if ( FAILED( sc ) )
        {
            LogError( "IRowset->GetRowsAtRatio returned 0x%x\n", sc );
            fFailed++;
        }
        else if (sc != DB_S_ENDOFROWSET &&
                 cRowsReturned != (DBCOUNTITEM) cRowsRequested)
        {
            LogError( "IRowset->GetRowsAtRatio returned %d of %d rows\n",
                        cRowsReturned,
                        cRowsRequested);
            fFailed++;
        }
        else if (fBookmarkBound)
        {
            fFailed += GetBookmarks(pRowsetScroll, cRowsReturned, phRows);

            HalfRowBmk = aBmks[0];
            sc = pRowsetScroll->GetApproximatePosition(hChapt,
                                        HalfRowBmk.cbBmk, HalfRowBmk.abBmk,
                                        &ulNum, &cRows);
            if ( FAILED( sc ) )
            {
                LogError( "IRowset->GetApproximatePosition returned 0x%x\n", sc );
                fFailed++;
            }
            else if (cRows == 0 ||
                     (ulNum-1 < ((cRows-1)*40)/100 || ulNum-1 > (cRows*60)/100))
            {
                LogError( "Scroll 50%%/GetApproximatePosition returned %d, %d\n",
                                ulNum, cRows );
                fFailed++;
            }
        }

        cRowsRequested = 10;
        sc = pRowsetScroll->GetRowsAtRatio(0, hChapt, 14, 27,
                                    cRowsRequested, &cRowsReturned2, &phRows2);
        if ( FAILED( sc ) )
        {
            LogError( "IRowset->GetRowsAtRation 14/27 returned 0x%x\n", sc );
            fFailed++;
        }
        else if (fBookmarkBound)
        {
            DBCOUNTITEM ulNum2 = 0;
            fFailed += GetBookmarks(pRowsetScroll, cRowsReturned2, phRows2);

            sc = pRowsetScroll->GetApproximatePosition( hChapt,
                                        aBmks[0].cbBmk, aBmks[0].abBmk,
                                        &ulNum2, &cRows);
            if ( FAILED( sc ) )
            {
                LogError( "IRowset->GetApproximatePosition 14/27 returned 0x%x\n", sc );
                fFailed++;
            }
            else if (cRows == 0 || ulNum > ulNum2)
            {
                LogError( "Scroll 51.8%%/GetApproximatePosition returned %d, %d, %d, total rows: %d\n",
                                ulNum, ulNum2, cRows, cTableRows );
                fFailed++;
            }
            else if (ulNum != ulNum2)
            {
                sc = pRowsetLocate->Compare(hChapt,
                                        HalfRowBmk.cbBmk, HalfRowBmk.abBmk,
                                        aBmks[0].cbBmk, aBmks[0].abBmk,
                                        &dwCompare);

                if ( FAILED( sc ) )
                {
                    LogError( "IRowsetLocate->Compare returned 0x%x\n", sc );
                    fFailed++;
                }
                else if ((fCompareOrdered && dwCompare != DBCOMPARE_LT) ||
                         (! fCompareOrdered && dwCompare != DBCOMPARE_NE))
                {
                    LogError( "Compare of 50%% and 51.8%% returned bookmarks not "
                                "%s (%d)\n",
                                fCompareOrdered? "less than" : "not equal",
                                dwCompare );
                    fFailed++;
                }
            }

            if ( ( ulNum2 - ulNum ) < (DBCOUNTITEM) cRowsRequested)
            {
                DBCOUNTITEM oRowDiff = ulNum - ulNum2;
                fFailed += CheckHrowIdentity( pRowsetIdentity, oRowDiff,
                                              cRowsReturned, phRows,
                                              cRowsReturned2, phRows2);
            }
        }
        FreeHrowsArray(pRowsetScroll, cRowsReturned2, &phRows2);
        FreeHrowsArray(pRowsetScroll, cRowsReturned, &phRows);

        static cTimesBadRatioTested = 0;

        if ( cTimesBadRatioTested < 10  )
        {
            // limited to 10 tests of this because it causes an exception
            // internally which slows the drt down unnecessarily

            cTimesBadRatioTested++;
            sc = pRowsetScroll->GetRowsAtRatio(0, hChapt, 14, 13,
                                        cRowsRequested, &cRowsReturned, &phRows);
            if ( sc != DB_E_BADRATIO )
            {
                LogError( "IRowset->GetRowsAtRatio returned 0x%x for invalid fraction\n",
                            sc );
                fFailed++;
            }

            FreeHrowsArray(pRowsetScroll, cRowsReturned, &phRows);
        }

        sc = pRowsetScroll->GetRowsAtRatio(0, hChapt, 0, 100,
                                    cRowsRequested, &cRowsReturned, &phRows);
        if ( FAILED( sc ) )
        {
            LogError( "IRowset->GetRowsAtRatio, 0%% returned 0x%x\n", sc );
            fFailed++;
        }
        else if (fBookmarkBound)
            fFailed += GetBookmarks( pRowsetScroll, cRowsReturned, phRows);

        FreeHrowsArray(pRowsetScroll, cRowsReturned, &phRows);

        if (fBookmarkBound)
        {
            sc = pRowsetScroll->GetApproximatePosition( hChapt,
                                            aBmks[0].cbBmk, aBmks[0].abBmk,
                                            &ulNum, &cRows);
            if ( FAILED( sc ) )
            {
                LogError( "IRowset->GetApproximatePosition 0%% returned 0x%x\n", sc );
                fFailed++;
            }
            else if (cRows == 0 || ulNum != 1)
            {
                LogError( "GetApproximatePosition, first row returned %d, %d\n",
                                ulNum, cRows );
                fFailed++;
            }
        }

        if ( 0 == hChapt )
        {
            sc = pRowsetScroll->GetRowsAtRatio(0, hChapt, 100, 100,
                                        cRowsRequested, &cRowsReturned, &phRows);
    //      if ( FAILED(sc) )
            if (cRowsReturned != 0 || sc != DB_S_ENDOFROWSET)
            {
                LogError( "IRowsetScroll->GetRowsAtRatio 100%% returned sc: 0x%x, cRowsReturned: 0x%x\n",
                          sc, cRowsReturned );
                fFailed++;
            }
            FreeHrowsArray(pRowsetScroll, cRowsReturned, &phRows);
        }

        sc = pRowsetScroll->GetApproximatePosition( hChapt,
                                            1, &bmkLast,
                                            &ulNum, &cRows);
        if ( FAILED( sc ) )
        {
            LogError( "IRowset->GetApproximatePosition DBBMK_LAST returned 0x%x\n", sc );
            fFailed++;
        }
        else if (ulNum != cRows)
        {
            LogError( "GetApproximatePosition, last row returned %d, %d\n",
                            ulNum, cRows );
            fFailed++;
        }
        pRowsetScroll->Release();
    }   // end if (fScroll)


    cFailures += fFailed;
    pRowsetLocate->Release();
    if (fBookmarkBound)
        ReleaseAccessor( pRowset, hBmkAccessor);

    if (0 != pRowsetIdentity)
        pRowsetIdentity->Release();

#if !defined(UNIT_TEST)
//    if (fFailed) {
//        pRowset->Release();
//        Fail();
//    }
#endif // !UNIT_TEST
    return;
} //MoveTest


//+-------------------------------------------------------------------------
//
//  Function:   DeleteTest, public
//
//  Synopsis:   Check that row delete works correctly
//
//  Returns:    Nothing
//
//  Notes:      Duplication scenario for bug# 12282
//
//  History:    18 May 1995       AlanW   Created
//
//--------------------------------------------------------------------------

struct SDeleteTest
{
    DBLENGTH  cbName;
    DBLENGTH  cbPath;

    DBROWSTATUS sName;
    DBROWSTATUS sPath;

    WCHAR     awcName[40];
    WCHAR     awcPath[MAX_PATH+1];
};

DBBINDING aDeleteTestCols[] =
{
  // the iOrdinal field is filled out after the cursor is created

  { 0,
    offsetof(SDeleteTest,awcName),
    offsetof(SDeleteTest,cbName),
    offsetof(SDeleteTest,sName),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    40 * sizeof (WCHAR),
    0, DBTYPE_WSTR,
    0,0,
    },
  { 0,
    offsetof(SDeleteTest,awcPath),
    offsetof(SDeleteTest,cbPath),
    offsetof(SDeleteTest,sPath),
    0,0,0,
    ALLPARTS,
    DBMEMOWNER_CLIENTOWNED, DBPARAMIO_NOTPARAM,
    cbRowName,
    0, DBTYPE_WSTR,
    0,0,
    },
};

const ULONG cDeleteTestCols = sizeof aDeleteTestCols / sizeof aDeleteTestCols[0];

void DeleteTest(BOOL fSequential)
{
    LogProgress( "Delete function test with %s rowset\n",
                  fSequential ? "sequential" : "movable" );

    WCHAR wcsTestSubDir[MAX_PATH];
    wcscpy( wcsTestSubDir, wcsTestPath );
    wcscat( wcsTestSubDir, L"\\DeleteTest." );
    wcscat( wcsTestSubDir, fSequential ? L"1" : L"2" );

    unsigned cchTestSubDir = wcslen(wcsTestSubDir);

    //
    // Get name, size and class id for *.*
    //

    CDbColumns cols(2);

    cols.Add( psName, 0 );
    cols.Add( psPath, 1 );

    CDbSortSet ss(1);

    if (! fSequential )
        ss.Add(psName, QUERY_SORTASCEND, 0);

    CDbCmdTreeNode * pCmdTree = FormQueryTree( 0, cols, &ss );

    IRowset * pRowset = InstantiateRowset(
                                0,
                                QUERY_DEEP,              // Depth
                                wcsTestPath,             // Scope
                                pCmdTree,                // DBCOMMANDTREE
                                IID_IRowsetScroll);      // IID of i/f to return

    //
    // Verify columns
    //
    CheckColumns( pRowset, cols );

    if ( !WaitForCompletion( pRowset ) )
    {
        LogError( "DeleteTest query unsuccessful.\n" );
        pRowset->Release();
        Fail();
    }

    int fFailed = 0;

    //
    // Get an IRowsetScroll if possible.
    //

    DBCOUNTITEM cRows = 0;

    IRowsetScroll * pIRowsetScroll = 0;

    SCODE sc = pRowset->QueryInterface(IID_IRowsetScroll,(void **) &pIRowsetScroll );

    if ( FAILED( sc ) && sc != E_NOINTERFACE )
    {
        LogError( "IRowset::qi for IRowsetScroll failed, 0x%x\n", sc );
        cFailures++;
    }

    if (0 == pIRowsetScroll )
    {
        if (! fSequential)
        {
            LogError( "Non-sequential cursor does not support IRowsetScroll\n" );
            cFailures++;
        }
    }
    else
    {
        sc = pIRowsetScroll->GetApproximatePosition(0, 0,0, 0, &cRows);

        if ( FAILED( sc ) )
        {
            LogError( "IRowset->GetApproximatePosition returned 0x%lx\n", sc );
            cFailures++;
        }

        if ( cRows == 0 )
        {
            LogError( "Query failed to return data\n" );
            pIRowsetScroll->Release();
            pRowset->Release();
            Fail();
        }
    }

    //
    // Patch the column index numbers with true numbers
    //

    DBID aDbCols[cDeleteTestCols];
    aDbCols[0] = psName;
    aDbCols[1] = psPath;

    HACCESSOR hAccessor = MapColumns(pRowset, cDeleteTestCols, aDeleteTestCols, aDbCols);

    DBCOUNTITEM totalRowsFetched = 0;
    DBCOUNTITEM cRowsReturned = 0;
    HROW ahRows[10];
    HROW* phRows = ahRows;

    BOOL fDidDelete = FALSE;
    BOOL fDidDirDelete = FALSE;

    do
    {
        sc = pRowset->GetNextRows(0, 0, 1, &cRowsReturned, &phRows);

        if ( FAILED( sc ) )
        {
            LogError( "IRowset->GetNextRows returned 0x%x\n", sc );
            pRowset->Release();
            Fail();
        }

        if (sc != DB_S_ENDOFROWSET &&
            cRowsReturned != 1)
        {
            LogError( "IRowset->GetNextRows returned %d of %d rows,"
                    " status (%x) != DB_S_ENDOFROWSET\n",
                        cRowsReturned, 1,
                        sc);
#if defined (UNIT_TEST)
            cFailures++;
#else // defined(UNIT_TEST)
            pRowset->Release();
            Fail();
#endif // defined(UNIT_TEST)
        }

        totalRowsFetched += cRowsReturned;

        if ( (0 != pIRowsetScroll ) &&
             (totalRowsFetched > cRows) )
        {
            //
            // check that no more rows have been added while we were
            // fetching.
            //
            LogProgress("Checking for expansion of result set\n");

            SCODE sc1 = pIRowsetScroll->GetApproximatePosition(0,
                                                0,0, 0, &cRows);

            if ( totalRowsFetched > cRows )
            {
                LogError("Fetched more rows than exist in the result set, %d %d\n",
                        totalRowsFetched, cRows);
                cFailures++;
            }
        }
        //
        // When the retrieved row is the file name "F0005.txt" in the
        // test directory, delete that file and
        // continue the enumeration.  We expect that GetNextRows can
        // deal with the deletion.
        //
        // When the retrieved row is the file name "F0009.txt" in the
        // test directory, delete the entire test directory and
        // continue the enumeration.  We expect that GetNextRows can
        // deal with this deletion also.
        //

        unsigned i;
        for (i = 0; i < cRowsReturned; i++)
        {
            SDeleteTest Row;

            SCODE sc1 = pRowset->GetData(ahRows[i],hAccessor,&Row);

            if ( FAILED( sc1 ) )
            {
                LogError( "IRowset->GetData returned 0x%x\n", sc1 );
                pRowset->Release();
                Fail();
            }

            if ( Row.sName == DBSTATUS_S_OK &&
                 Row.cbName != (wcslen(Row.awcName) * sizeof (WCHAR)) )
                LogFail( "length of name column 0x%x not consistent with data 0x%x\n",
                         Row.cbName,
                         wcslen(Row.awcName) * sizeof WCHAR );

            if ( Row.sPath == DBSTATUS_S_OK &&
                 Row.cbPath != (wcslen(Row.awcPath) * sizeof (WCHAR)) )
                LogFail("length of path column not consistent with data\n");

            if ( _wcsicmp( Row.awcName, L"F0005.txt" ) == 0 &&
                 _wcsnicmp( Row.awcPath, wcsTestSubDir, cchTestSubDir) == 0)
            {
                fDidDelete = DeleteFile(Row.awcPath);
                if (!fDidDelete)
                {
                    if (fDidDirDelete && fSequential)
                    {
                        // Already did the delnode; we expect the delete to fail
                        fDidDelete = TRUE;
                    }
                    else
                    {
                        LogError( "Delete of %ws failed\n", Row.awcPath );
                    }
                }
                Sleep(2000);    // Give time for delete to be processed
            }

            if ( _wcsicmp( Row.awcName, L"F0009.txt" ) == 0 &&
                 _wcsnicmp( Row.awcPath, wcsTestSubDir, cchTestSubDir) == 0)
            {
                fDidDirDelete = TRUE;
                if ( Delnode(wcsTestSubDir) != NO_ERROR )
                    LogError( "Delnode of %ws failed\n", wcsTestSubDir );
                Sleep(2000);    // Give time for delete to be processed
            }
        }

        if (0 != cRowsReturned)
        {
            SCODE sc1 = pRowset->ReleaseRows(cRowsReturned, ahRows, 0, 0, 0);
            if ( FAILED( sc1 ) )
            {
                LogError( "IRowset->ReleaseRows returned 0x%x\n", sc1 );
                pRowset->Release();
                Fail();
            }
            cRowsReturned = 0;
        }

    } while (SUCCEEDED(sc) && sc != DB_S_ENDOFROWSET);

    if (0 != cRowsReturned)
    {
        SCODE sc1 = pRowset->ReleaseRows(cRowsReturned, ahRows, 0, 0, 0);
        if ( FAILED( sc1 ) )
        {
            LogError( "IRowset->ReleaseRows returned 0x%x\n", sc1 );
            pRowset->Release();
            Fail();
        }
    }

    if (!fDidDirDelete)
    {
        LogFail("Couldn't find file to trigger directory delete\n");
    }
    if (!fDidDelete)
    {
        // NOTE:  if F0009.txt is found before F0005.txt, this could
        //        occur, but we don't expect that with OFS's normal
        //        directory order.
        LogFail("Couldn't find file to delete\n");
    }
    if (totalRowsFetched < 10)
    {
        LogFail("Unexpectedly small number of files found in delete test, %d\n",
                  totalRowsFetched);
    }

    ReleaseAccessor( pRowset, hAccessor);

    if ( (0 != pIRowsetScroll ) &&
        (totalRowsFetched != cRows) )
    {
        //
        // check that no more rows have been added while we were
        // fetching.
        //
        LogError("Wrong number of rows returned.  Exp %d, got %d\n",
                                                  cRows, totalRowsFetched);
        cFailures++;
    }

    if (0 != pIRowsetScroll )
    {
        pIRowsetScroll->Release();
        pIRowsetScroll = 0;
    }

#if !defined(UNIT_TEST)
    if (cFailures) {
        pRowset->Release();
        Fail();
    }
#endif // !UNIT_TEST

    pRowset->Release();
} //DeleteTest

//+-------------------------------------------------------------------------
//
//  Function:   GiveAccess
//
//  Synopsis:   Gives access to the system or current user
//
//--------------------------------------------------------------------------

BOOL GiveAccess(
    WCHAR * pwcFile,
    BOOL    fCurrUser,
    DWORD   accessMask )
{
    PACL pACLNew;
    DWORD cbACL = 1024;
    DWORD cbSID = 1024;
    DWORD cchDomainName = 80;
    PSID pSID;
    PSID_NAME_USE psnuType;
    WCHAR * pwcDomain;

    WCHAR awcUser[100];

    // setup username -- current user or system

    if ( fCurrUser )
    {
        DWORD cwc = sizeof awcUser / sizeof WCHAR;
        if ( !GetUserName( awcUser, &cwc ) )
            LogFail("Couldn't get user name\n");
    }
    else
    {
        wcscpy( awcUser, L"SYSTEM" );
    }

    // Initialize a new security descriptor.

    PSECURITY_DESCRIPTOR pSD = (PSECURITY_DESCRIPTOR)
                               LocalAlloc( LPTR,
                                           SECURITY_DESCRIPTOR_MIN_LENGTH );
    if (pSD == NULL)
        LogFail("Couldn't alloc security descriptor\n");

    if ( !InitializeSecurityDescriptor( pSD,
                                        SECURITY_DESCRIPTOR_REVISION ) )
        LogFail("Couldn't init security descriptor\n");

    // Initialize a new ACL.

    pACLNew = (PACL) LocalAlloc(LPTR, cbACL);
    if (pACLNew == NULL)
        LogFail("Couldn't alloc acl\n");

    if (!InitializeAcl(pACLNew, cbACL, ACL_REVISION2))
        LogFail("Couldn't init acl\n");

    // Retrieve the SID for user

    pSID = (PSID) LocalAlloc(LPTR, cbSID);
    psnuType = (PSID_NAME_USE) LocalAlloc(LPTR, 1024);
    pwcDomain = (WCHAR *) LocalAlloc(LPTR, cchDomainName);
    if (pSID == NULL || psnuType == NULL ||
        pwcDomain == NULL)
        LogFail("Couldn't alloc security data\n");

    if ( !LookupAccountName( (WCHAR *) NULL,
                             awcUser,
                             pSID,
                             &cbSID,
                             pwcDomain,
                             &cchDomainName,
                             psnuType ) )
        LogFail("Couldn't lookup account '%ws'\n", awcUser );

    // Allow write but not read access to the file.

    if ( !AddAccessAllowedAce( pACLNew,
                               ACL_REVISION2,
                               accessMask,
                               pSID ))
        LogFail("Couldn't AddAccessAllowedAce\n");

    // Add a new ACL to the security descriptor.

    if ( !SetSecurityDescriptorDacl( pSD,
                                     TRUE,  // fDaclPresent flag
                                     pACLNew,
                                     FALSE ) )  // not a default disc. ACL
        LogFail("Couldn't SetSecurityDescriptorDacl\n");

    // Apply the new security descriptor to the file.

    if ( !SetFileSecurity( pwcFile,
                           DACL_SECURITY_INFORMATION,
                           pSD))
        LogFail("Couldn't SetFileSecurity\n");

    LogProgress( "set security '%ws' user '%ws' domain '%ws' to %x\n",
                 pwcFile, awcUser, pwcDomain, accessMask );

    FreeSid(pSID);
    LocalFree((HLOCAL) pSD);
    LocalFree((HLOCAL) pACLNew);
    LocalFree((HLOCAL) psnuType);
    LocalFree((HLOCAL) pwcDomain);

    return TRUE;
} //GiveAccess

//+-------------------------------------------------------------------------
//
//  Function:   DenyAllAccess
//
//  Synopsis:   Deniess all access to a file
//
//--------------------------------------------------------------------------

BOOL DenyAllAccess( WCHAR *pwcFile )
{
    // Initialize a security descriptor.

    PSECURITY_DESCRIPTOR pSD = (PSECURITY_DESCRIPTOR)
                               LocalAlloc( LPTR,
                                           SECURITY_DESCRIPTOR_MIN_LENGTH );
    if (pSD == NULL)
        LogFail("Couldn't alloc security descriptor\n");

    if ( !InitializeSecurityDescriptor( pSD,
                                        SECURITY_DESCRIPTOR_REVISION ) )
        LogFail("Couldn't InitializeSecurityDescriptor\n");

    // Initialize a DACL.

    DWORD cbACL;
    cbACL = 1024;
    PACL pACL;
    pACL = (PACL) LocalAlloc(LPTR, cbACL);
    if (pACL == NULL)
        LogFail("Couldn't allocate acl\n");

    if (!InitializeAcl(pACL, cbACL, ACL_REVISION2))
        LogFail("Couldn't init acl\n");

    // Add an empty ACL to the SD to deny access.

    if ( !SetSecurityDescriptorDacl( pSD,
                                     TRUE,     // fDaclPresent flag
                                     pACL,
                                     FALSE ) ) // not a default acl
        LogFail("Couldn't SetSecurityDescriptorDacl\n");

    // Use the new SD as the file's security info.

    if ( !SetFileSecurity( pwcFile,
                           DACL_SECURITY_INFORMATION,
                           pSD ) )
        LogFail("Couldn't SetFileSecurity\n");

    if(pSD != NULL)
        LocalFree((HLOCAL) pSD);
    if(pACL != NULL)
        LocalFree((HLOCAL) pACL);

    return TRUE;
} //DenyAllAccess

void AddSafeArrays( IPropertySetStorage * ppsstg )
{
    // aI4 (DBTYPE_I4, 10) = 92452ac2-fcbb-11d1-b7ca-00a0c906b239 2
    // aBstr (DBTYPE_BSTR, 10) = 92452ac2-fcbb-11d1-b7ca-00a0c906b239 3
    // aVariant (DBTYPE_I4, 10) = 92452ac2-fcbb-11d1-b7ca-00a0c906b239 4
    // aR8 (DBTYPE_R8, 10) = 92452ac2-fcbb-11d1-b7ca-00a0c906b239 5
    // aDate (DBTYPE_DATE, 10) = 92452ac2-fcbb-11d1-b7ca-00a0c906b239 6
    // aBool (DBTYPE_BOOL, 10) = 92452ac2-fcbb-11d1-b7ca-00a0c906b239 7
    // aDecimal (DBTYPE_R8, 10) = 92452ac2-fcbb-11d1-b7ca-00a0c906b239 8
    // aI1 (DBTYPE_I1, 10) = 92452ac2-fcbb-11d1-b7ca-00a0c906b239 9
    // aR4 (DBTYPE_R4, 10) = 92452ac2-fcbb-11d1-b7ca-00a0c906b239 10
    // aCy (DBTYPE_R8, 10) = 92452ac2-fcbb-11d1-b7ca-00a0c906b239 11
    // aUINT (DBTYPE_UI4, 10) = 92452ac2-fcbb-11d1-b7ca-00a0c906b239 12
    // aINT (DBTYPE_I4, 10) = 92452ac2-fcbb-11d1-b7ca-00a0c906b239 13
    // aError (DBTYPE_I4, 10) = 92452ac2-fcbb-11d1-b7ca-00a0c906b239 14

    IPropertyStorage * ppstg;
    ULONG ulMode = STGM_DIRECT | STGM_SHARE_EXCLUSIVE;
    SCODE sc = ppsstg->Create( guidArray, // property set guid
                               0,
                               PROPSETFLAG_DEFAULT,
                               ulMode | STGM_READWRITE,    // Open mode
                               &ppstg );                   // IProperty
    if ( FAILED(sc) )
        LogFail( "SA: can't create ps %#x\n", sc );

    // VT_ARRAY | VT_I4

    {
        SAFEARRAYBOUND saBounds[3];
        saBounds[0].lLbound = 1;
        saBounds[0].cElements = 3;
        saBounds[1].lLbound = 1;
        saBounds[1].cElements = 4;
        saBounds[2].lLbound = 1;
        saBounds[2].cElements = 2;

        SAFEARRAY * psa = SafeArrayCreateEx( VT_I4, 3, saBounds, 0 );
        if ( 0 == psa )
            LogFail( "SA: can't create sa I4: %#x\n", sc );

        vaI4.vt = VT_I4 | VT_ARRAY;
        vaI4.parray = psa;

        for ( int x = 1; x <= 3; x++ )
            for ( int y = 1; y <= 4; y++ )
                for ( int z = 1; z <= 2; z++ )
                {
                    LONG *pl;
                    LONG aDim[3];
                    aDim[0] = x;
                    aDim[1] = y;
                    aDim[2] = z;
                    HRESULT hr = SafeArrayPtrOfIndex( psa, aDim, (void **) &pl );
                    *pl = (x-1) * 8 + (y-1) * 2 + (z-1);
                }

        sc = ppstg->WriteMultiple( 1,
                                   &psSA_I4,
                                   &vaI4,
                                   0x1000 );
        if ( FAILED( sc ) )
            LogFail( "SA: can't writemultiple VT_I4 %#x\n", sc );
    }

    // VT_ARRAY | VT_BSTR

    {
        SAFEARRAYBOUND saBounds[3];
        saBounds[0].lLbound = -1;
        saBounds[0].cElements = 2;
        saBounds[1].lLbound = 0;
        saBounds[1].cElements = 3;
        saBounds[2].lLbound = 49;
        saBounds[2].cElements = 2;

        SAFEARRAY * psa = SafeArrayCreateEx( VT_BSTR, 3, saBounds, 0 );
        if ( 0 == psa )
            LogFail( "SA: can't create sa I4\n" );

        vaBSTR.vt = VT_BSTR | VT_ARRAY;
        vaBSTR.parray = psa;

        int i = 0;

        for ( int x = -1; x <= 0; x++ )
            for ( int y = 0; y <= 2; y++ )
                for ( int z = 49; z <= 50; z++ )
                {
                    void * pv;
                    LONG aDim[3];
                    aDim[0] = x;
                    aDim[1] = y;
                    aDim[2] = z;
                    HRESULT hr = SafeArrayPtrOfIndex( psa, aDim, &pv );
                    WCHAR awc[20];
                    swprintf( awc, L"%db", i );
                    BSTR bstr = SysAllocString( awc );
                    * (BSTR *) pv = bstr;
                    i++;
                }

        sc = ppstg->WriteMultiple( 1,
                                   &psSA_BSTR,
                                   &vaBSTR,
                                   0x1000 );
        if ( FAILED( sc ) )
            LogFail( "SA: can't writemultiple VT_BSTR %#x\n", sc );
    }

    // VT_ARRAY | VT_VARIANT

    {
        SAFEARRAYBOUND saBounds[3];
        saBounds[0].lLbound = 0;
        saBounds[0].cElements = 2;
        saBounds[1].lLbound = -3;
        saBounds[1].cElements = 2;
        saBounds[2].lLbound = 20;
        saBounds[2].cElements = 4;

        SAFEARRAY * psa = SafeArrayCreateEx( VT_VARIANT, 3, saBounds, 0 );
        if ( 0 == psa )
            LogFail( "SA: can't create sa VARIANT\n" );

        vaVARIANT.vt = VT_VARIANT | VT_ARRAY;
        vaVARIANT.parray = psa;

        int i = 0;
        for ( int x = 0; x <= 1; x++ )
            for ( int y = -3; y <= -2; y++ )
                for ( int z = 20; z <= 23; z++ )
                {
                    LONG aDim[3];
                    aDim[0] = x;
                    aDim[1] = y;
                    aDim[2] = z;

                    PROPVARIANT * pVar;
                    HRESULT hr = SafeArrayPtrOfIndex( psa,
                                                      aDim,
                                                      (void **) &pVar );

                    if ( 20 == z )
                    {
                        pVar->lVal = i;
                        pVar->vt = VT_I4;
                    }
                    else if ( 21 == z )
                    {
                        WCHAR awc[20];
                        swprintf( awc, L"%db", i );
                        pVar->bstrVal = SysAllocString( awc );
                        pVar->vt = VT_BSTR;

                    }
#if 0 // in 1829, the OLE group removed support for this!
                    else if ( 22 == z )
                    {
                        *pVar = vaI4;
                    }
                    else if ( 23 == z )
                    {
                        *pVar = vaBSTR;
                    }
#endif
                    else
                    {
                        pVar->fltVal = (float) i;
                        pVar->vt = VT_R4;
                    }

                    i++;
                }

        sc = ppstg->WriteMultiple( 1,
                                   &psSA_VARIANT,
                                   &vaVARIANT,
                                   0x1000 );
        if ( FAILED( sc ) )
            LogFail( "SA: can't writemultiple VT_VARIANT %#x\n", sc );
    }

    // VT_ARRAY | VT_R8

    {
        SAFEARRAYBOUND saBounds[2];
        saBounds[0].lLbound = 100;
        saBounds[0].cElements = 3;
        saBounds[1].lLbound = -100;
        saBounds[1].cElements = 4;

        SAFEARRAY * psa = SafeArrayCreateEx( VT_R8, 2, saBounds, 0 );
        if ( 0 == psa )
            LogFail( "SA: can't create sa r8\n" );
        vaR8.vt = VT_R8 | VT_ARRAY;
        vaR8.parray = psa;

        double d = 0.0l;

        for ( int x = 100; x <= 102; x++ )
            for ( int y = -100; y <= -97; y++ )
            {
                double * pd;
                LONG aDim[2];
                aDim[0] = x;
                aDim[1] = y;
                HRESULT hr = SafeArrayPtrOfIndex( psa, aDim, (void **) &pd );
                *pd = d;
                d = d + 2.0l;
            }

        sc = ppstg->WriteMultiple( 1,
                                   &psSA_R8,
                                   &vaR8,
                                   0x1000 );
        if ( FAILED( sc ) )
            LogFail( "SA: can't writemultiple VT_r8 %#x\n", sc );
    }

    // VT_ARRAY | VT_DATE

    {
        SAFEARRAYBOUND saBounds[2];
        saBounds[0].lLbound = 1;
        saBounds[0].cElements = 2;
        saBounds[1].lLbound = 1;
        saBounds[1].cElements = 3;

        SAFEARRAY * psa = SafeArrayCreateEx( VT_DATE, 2, saBounds, 0 );
        if ( 0 == psa )
            LogFail( "can't create safearray of VT_DATE\n" );

        vaDATE.vt = VT_DATE | VT_ARRAY;
        vaDATE.parray = psa;

        int i = 0;

        for ( int x = 1; x <= 2; x++ )
            for ( int y = 1; y <= 3; y++ )
            {
                LONG aDim[2];
                aDim[0] = x;
                aDim[1] = y;
                DATE *pdate;
                HRESULT hr = SafeArrayPtrOfIndex( psa, aDim, (void **) &pdate );

                // round the seconds and milliseconds to 0 since the
                // property set API often is off by as much as 4 seconds
                // when you marshall and unmarshall the value.

                SYSTEMTIME st;
                GetSystemTime( &st );
                st.wSecond = 0;
                st.wMilliseconds = 0;
                st.wYear += (USHORT) i;
                SystemTimeToVariantTime( &st, pdate );
                i++;
            }

        sc = ppstg->WriteMultiple( 1,
                                   &psSA_DATE,
                                   &vaDATE,
                                   0x1000 );
        if ( FAILED( sc ) )
            LogFail( "can't writemultiple date %#x\n", sc );
    }

    // VT_ARRAY | VT_BOOL

    {
        SAFEARRAYBOUND saBounds[2];
        saBounds[0].lLbound = 1;
        saBounds[0].cElements = 2;
        saBounds[1].lLbound = 1;
        saBounds[1].cElements = 3;

        SAFEARRAY * psa = SafeArrayCreateEx( VT_BOOL, 2, saBounds, 0 );
        if ( 0 == psa )
            LogFail( "can't create safearray of VT_BOOL\n" );

        vaBOOL.vt = VT_BOOL | VT_ARRAY;
        vaBOOL.parray = psa;

        int i = 0;
        GUID guid = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 };

        for ( int x = 1; x <= 2; x++ )
            for ( int y = 1; y <= 3; y++ )
            {
                LONG aDim[2];
                aDim[0] = x;
                aDim[1] = y;
                VARIANT_BOOL *pB;
                HRESULT hr = SafeArrayPtrOfIndex( psa, aDim, (void **) &pB );
                *pB = (i & 1) ? VARIANT_TRUE : VARIANT_FALSE;
                i++;
            }

        sc = ppstg->WriteMultiple( 1,
                                   &psSA_BOOL,
                                   &vaBOOL,
                                   0x1000 );
        if ( FAILED( sc ) )
            LogFail( "can't writemultiple bool %#x\n", sc );
    }

    // VT_ARRAY | VT_DECIMAL

    {
        SAFEARRAYBOUND saBounds[2];
        saBounds[0].lLbound = 1;
        saBounds[0].cElements = 2;
        saBounds[1].lLbound = 1;
        saBounds[1].cElements = 3;

        SAFEARRAY * psa = SafeArrayCreateEx( VT_DECIMAL, 2, saBounds, 0 );
        if ( 0 == psa )
            LogFail( "can't create safearray of VT_DECIMAL\n" );

        vaDECIMAL.vt = VT_DECIMAL | VT_ARRAY;
        vaDECIMAL.parray = psa;

        int i = 0;

        for ( int x = 1; x <= 2; x++ )
            for ( int y = 1; y <= 3; y++ )
            {
                LONG aDim[2];
                aDim[0] = x;
                aDim[1] = y;
                DECIMAL *pd;
                HRESULT hr = SafeArrayPtrOfIndex( psa, aDim, (void **) &pd );
                if ( FAILED( hr ) )
                    LogFail( "can't get ptr of index for DECIMAL %#x", hr );
                double d = i;
                VarDecFromR8( d, pd );
                i++;
            }

        sc = ppstg->WriteMultiple( 1,
                                   &psSA_DECIMAL,
                                   &vaDECIMAL,
                                   0x1000 );
        if ( FAILED( sc ) )
            LogFail( "can't writemultiple decimal %#x\n", sc );
    }

    // VT_ARRAY | VT_I4

    {
        SAFEARRAYBOUND saBounds[3];
        saBounds[0].lLbound = 1;
        saBounds[0].cElements = 3;
        saBounds[1].lLbound = 1;
        saBounds[1].cElements = 4;
        saBounds[2].lLbound = 1;
        saBounds[2].cElements = 2;

        SAFEARRAY * psa = SafeArrayCreateEx( VT_I1, 3, saBounds, 0 );
        vaI1.vt = VT_I1 | VT_ARRAY;
        vaI1.parray = psa;

        for ( int x = 1; x <= 3; x++ )
            for ( int y = 1; y <= 4; y++ )
                for ( int z = 1; z <= 2; z++ )
                {
                    BYTE *pb;
                    LONG aDim[3];
                    aDim[0] = x;
                    aDim[1] = y;
                    aDim[2] = z;
                    HRESULT hr = SafeArrayPtrOfIndex( psa, aDim, (void **) &pb );
                    *pb = (x-1) * 8 + (y-1) * 2 + (z-1);
                }

        sc = ppstg->WriteMultiple( 1,
                                   &psSA_I1,
                                   &vaI1,
                                   0x1000 );
        if ( FAILED( sc ) )
            LogFail( "can't writemultiple i1 %#x\n", sc );
    }

    // VT_ARRAY | VT_R4

    {
        SAFEARRAYBOUND saBounds[2];
        saBounds[0].lLbound = 100;
        saBounds[0].cElements = 3;
        saBounds[1].lLbound = -100;
        saBounds[1].cElements = 4;

        SAFEARRAY * psa = SafeArrayCreateEx( VT_R4, 2, saBounds, 0 );
        vaR4.vt = VT_R4 | VT_ARRAY;
        vaR4.parray = psa;

        float f = 0.0;

        for ( int x = 100; x <= 102; x++ )
            for ( int y = -100; y <= -97; y++ )
            {
                float * pf;
                LONG aDim[2];
                aDim[0] = x;
                aDim[1] = y;
                HRESULT hr = SafeArrayPtrOfIndex( psa, aDim, (void **) &pf );
                RtlCopyMemory( pf, &f, sizeof f );
                f = (float) ( f + (float) 3.0 );
            }

        sc = ppstg->WriteMultiple( 1,
                                   &psSA_R4,
                                   &vaR4,
                                   0x1000 );
        if ( FAILED( sc ) )
            LogFail( "can't writemultiple r4 %#x\n", sc );
    }

    // VT_ARRAY | VT_CY

    {
        SAFEARRAYBOUND saBounds[2];
        saBounds[0].lLbound = 100;
        saBounds[0].cElements = 3;
        saBounds[1].lLbound = -100;
        saBounds[1].cElements = 4;

        SAFEARRAY * psa = SafeArrayCreateEx( VT_CY, 2, saBounds, 0 );
        vaCY.vt = VT_CY | VT_ARRAY;
        vaCY.parray = psa;

        double d = 0.0l;

        for ( int x = 100; x <= 102; x++ )
            for ( int y = -100; y <= -97; y++ )
            {
                CY *pcy;
                LONG aDim[2];
                aDim[0] = x;
                aDim[1] = y;
                HRESULT hr = SafeArrayPtrOfIndex( psa, aDim, (void **) &pcy );
                CY cy;
                VarCyFromR8( d, &cy );
                *pcy = cy;
                d = d + 4.0l;
            }

        sc = ppstg->WriteMultiple( 1,
                                   &psSA_CY,
                                   &vaCY,
                                   0x1000 );
        if ( FAILED( sc ) )
            LogFail( "can't writemultiple cy %#x\n", sc );
    }

    // VT_ARRAY | VT_UINT

    {
        SAFEARRAYBOUND saBounds[3];
        saBounds[0].lLbound = 1;
        saBounds[0].cElements = 3;
        saBounds[1].lLbound = 1;
        saBounds[1].cElements = 4;
        saBounds[2].lLbound = 1;
        saBounds[2].cElements = 2;

        SAFEARRAY * psa = SafeArrayCreateEx( VT_UINT, 3, saBounds, 0 );
        if ( 0 == psa )
            LogFail( "can't create safearray of uint\n" );

        vaUINT.vt = VT_UINT | VT_ARRAY;
        vaUINT.parray = psa;

        for ( int x = 1; x <= 3; x++ )
            for ( int y = 1; y <= 4; y++ )
                for ( int z = 1; z <= 2; z++ )
                {
                    unsigned *p;
                    LONG aDim[3];
                    aDim[0] = x;
                    aDim[1] = y;
                    aDim[2] = z;
                    HRESULT hr = SafeArrayPtrOfIndex( psa, aDim, (void **) &p );
                    *p = (unsigned) ( (x-1) * 8 + (y-1) * 2 + (z-1) );
                }

        sc = ppstg->WriteMultiple( 1,
                                   &psSA_UINT,
                                   &vaUINT,
                                   0x1000 );
        if ( FAILED( sc ) )
            LogFail( "can't writemultiple uint %#x\n", sc );
    }

    // VT_ARRAY | VT_INT

    {
        SAFEARRAYBOUND saBounds[3];
        saBounds[0].lLbound = 1;
        saBounds[0].cElements = 3;
        saBounds[1].lLbound = 1;
        saBounds[1].cElements = 4;
        saBounds[2].lLbound = 1;
        saBounds[2].cElements = 2;

        SAFEARRAY * psa = SafeArrayCreateEx( VT_INT, 3, saBounds, 0 );
        if ( 0 == psa )
            LogFail( "can't create safearray of int\n" );

        vaINT.vt = VT_INT | VT_ARRAY;
        vaINT.parray = psa;

        for ( int x = 1; x <= 3; x++ )
            for ( int y = 1; y <= 4; y++ )
                for ( int z = 1; z <= 2; z++ )
                {
                    int *p;
                    LONG aDim[3];
                    aDim[0] = x;
                    aDim[1] = y;
                    aDim[2] = z;
                    HRESULT hr = SafeArrayPtrOfIndex( psa, aDim, (void **) &p );
                    *p = (x-1) * 8 + (y-1) * 2 + (z-1);
                }

        sc = ppstg->WriteMultiple( 1,
                                   &psSA_INT,
                                   &vaINT,
                                   0x1000 );
        if ( FAILED( sc ) )
            LogFail( "can't writemultiple int %#x\n", sc );
    }

    // VT_ARRAY | VT_ERROR

    {
        SAFEARRAYBOUND saBounds[3];
        saBounds[0].lLbound = 1;
        saBounds[0].cElements = 3;
        saBounds[1].lLbound = 1;
        saBounds[1].cElements = 4;
        saBounds[2].lLbound = 1;
        saBounds[2].cElements = 2;

        SAFEARRAY * psa = SafeArrayCreateEx( VT_ERROR, 3, saBounds, 0 );
        if ( 0 == psa )
            LogFail( "can't create safearray of error\n" );

        vaERROR.vt = VT_ERROR | VT_ARRAY;
        vaERROR.parray = psa;

        for ( int x = 1; x <= 3; x++ )
            for ( int y = 1; y <= 4; y++ )
                for ( int z = 1; z <= 2; z++ )
                {
                    HRESULT *p;
                    LONG aDim[3];
                    aDim[0] = x;
                    aDim[1] = y;
                    aDim[2] = z;
                    HRESULT hr = SafeArrayPtrOfIndex( psa, aDim, (void **) &p );
                    *p = 0x80070000 + ( (x-1) * 8 + (y-1) * 2 + (z-1) );
                }

        sc = ppstg->WriteMultiple( 1,
                                   &psSA_ERROR,
                                   &vaERROR,
                                   0x1000 );
        if ( FAILED( sc ) )
            LogFail( "can't writemultiple error %#x\n", sc );
    }

    ppstg->Release();
} //AddSafeArrays

//+-------------------------------------------------------------------------
//
//  Function:   AddPropsToStorage, public
//
//  Synopsis:   Add several props to a file
//
//  Arguments:  [fAlternate]   -- TRUE to open alternate file
//
//--------------------------------------------------------------------------

typedef HRESULT (STDAPICALLTYPE * tdStgCreateStorage)
    ( const OLECHAR FAR* pwcsName,
      DWORD grfMode,
      DWORD dwStgFmt,
      LPSECURITY_ATTRIBUTES pssSecurity,
      IStorage FAR * FAR *ppstg);

tdStgCreateStorage pStgCreateStorage = 0;

static int fDidInitOfVariants = 0;

void AddPropsToStorage( BOOL fAlternate )
{
    SCODE sc;

    if (! fDidInitOfVariants)
    {
        //
        // Create a multi-dimensional safearray for an alternate value for
        // property 8.
        //
        SAFEARRAYBOUND saBounds[3];
        saBounds[0].lLbound = 1;
        saBounds[0].cElements = 50;
        saBounds[1].lLbound = 1;
        saBounds[1].cElements = 10;
        saBounds[2].lLbound = 1;
        saBounds[2].cElements = 10;

        SAFEARRAY * psa = SafeArrayCreateEx( VT_I4, 3, saBounds, 0 );
        LONG * plData;
        sc = SafeArrayAccessData( psa, (void **)&plData );

        if ( FAILED(sc) )
        {
            LogError( "SafeArrayAccessData returned 0x%x\n", sc );
            CantRun();
        }
        memcpy( plData, alProp8, sizeof alProp8 );
        sc = SafeArrayUnaccessData( psa );
        varProp8A.vt = VT_I4 | VT_ARRAY;
        varProp8A.parray = psa;

        varProp11.vt = PROP11_TYPE;
        varProp11.bstrVal = SysAllocString( PROP11_VAL );

        const unsigned cchProp11A = sizeof PROP11_LONGVAL/sizeof PROP11_LONGVAL[0];
        for (unsigned i = 0; i + 25 + 25 < cchProp11A; i += 25)
            wcsncpy(&PROP11_LONGVAL[i+25], &PROP11_LONGVAL[i], 25);
        varProp11A.vt = PROP11_TYPE;
        varProp11A.bstrVal = SysAllocStringLen( PROP11_LONGVAL, wcslen(PROP11_LONGVAL) );

        varProp12.vt = PROP12_TYPE;
        varProp12.cabstr.pElems = (BSTR *)CoTaskMemAlloc( PROP4_VAL.cElems * sizeof (BSTR) );
        varProp12.cabstr.cElems = PROP4_VAL.cElems;
        for (i=0; i < PROP4_VAL.cElems; i++)
            varProp12.cabstr.pElems[i] = SysAllocString( PROP4_VAL.pElems[i] );

        fDidInitOfVariants++;
    }

    // Create a storage

    IStorage * pstg;
    ULONG ulMode = STGM_DIRECT | STGM_SHARE_EXCLUSIVE;
    sc = StgCreateDocfile( wcsTestPath,                 // Name
                           ulMode | STGM_READWRITE | STGM_CREATE,
                           0,                                // reserved
                           &pstg );                          // Result


    if ( FAILED(sc) )
    {
        LogError( "StgCreateDocfile %ws returned 0x%x\n", wcsTestPath, sc );
        CantRun();
    }

    // Create a property set

    IPropertySetStorage * ppsstg;
    sc = pstg->QueryInterface( IID_IPropertySetStorage, (void **)&ppsstg );
    pstg->Release();
    if ( FAILED(sc) )
    {
        LogError( "QueryInterface(IPropertySetStorage) returned 0x%lx\n", sc );
        CantRun();
    }

    AddSafeArrays( ppsstg );

    IPropertyStorage * ppstg;
    sc = ppsstg->Create( guidMyPropSet,               // Property set GUID
                         0,
                         PROPSETFLAG_DEFAULT,
                         ulMode | STGM_READWRITE,              // Open mode
                         &ppstg );                   // IProperty
    if ( FAILED(sc) )
    {
        LogError( "IPropertySetStorage::Create returned 0x%lx\n", sc );
        CantRun();
    }

    // Add property values

    PROPID pid=0x1000;

    varProp1.vt = PROP1_TYPE;
    varProp1.lVal = fAlternate ? PROP1_VAL_Alternate : PROP1_VAL;
    sc = ppstg->WriteMultiple( 1,                               // Count
                               &psTestProperty1.GetPropSpec(),  // Property
                               &varProp1,                       // Value
                               pid );                           // Propid
    if ( FAILED(sc) )
    {
        LogError( "IPropertyStorage::WriteMultiple 1 returned 0x%lx\n", sc );
        CantRun();
    }


    varProp2.vt = PROP2_TYPE;
    varProp2.pwszVal = (WCHAR *)PROP2_VAL;
    sc = ppstg->WriteMultiple( 1,                               // Count
                               &psTestProperty2.GetPropSpec(),  // Property
                               &varProp2,                       // Value
                               pid );                           // Propid
    if ( FAILED(sc) )
    {
        LogError( "IPropertyStorage::WriteMultiple 2 returned 0x%lx\n", sc );
        CantRun();
    }

    varProp10.vt = PROP10_TYPE;
    varProp10.pwszVal = (WCHAR *)PROP10_VAL;
    sc = ppstg->WriteMultiple( 1,                               // Count
                               &psTestProperty10.GetPropSpec(), // Property
                               &varProp10,                      // Value
                               pid );                           // Propid
    if ( FAILED(sc) )
    {
        LogError( "IPropertyStorage::WriteMultiple 10 returned 0x%lx\n", sc );
        CantRun();
    }

    sc = ppstg->WriteMultiple( 1,                               // Count
                               &psTestProperty11.GetPropSpec(), // Property
                               fAlternate ? &varProp11A :
                                            &varProp11,         // Value
                               pid );                           // Propid
    if ( FAILED(sc) )
    {
        LogError( "IPropertyStorage::WriteMultiple 11 returned 0x%lx\n", sc );
        CantRun();
    }

    sc = ppstg->WriteMultiple( 1,                               // Count
                               &psTestProperty12.GetPropSpec(), // Property
                               &varProp12,                      // Value
                               pid );                           // Propid
    if ( FAILED(sc) )
    {
        LogError( "IPropertyStorage::WriteMultiple 12 returned 0x%lx\n", sc );
        CantRun();
    }


    varProp5.vt = PROP5_TYPE;
    varProp5.cal = PROP5_VAL;
    sc = ppstg->WriteMultiple( 1,                               // Count
                               &psRelevantWords.GetPropSpec(),  // Property
                               &varProp5,                       // Value
                               pid );                           // Propid
    if ( FAILED(sc) )
    {
        LogError( "IPropertyStorage::WriteMultiple 5 returned 0x%lx\n", sc );
        CantRun();
    }

    varProp6.vt = PROP6_TYPE;
    varProp6.blob = PROP6_VAL;
    sc = ppstg->WriteMultiple( 1,                               // Count
                               &psBlobTest.GetPropSpec(),       // Property
                               &varProp6,                       // Value
                               pid );                           // Propid
    if ( FAILED(sc) )
    {
        LogError( "IPropertyStorage::WriteMultiple 6 returned 0x%lx\n", sc );
        CantRun();
    }

    varProp7.vt = PROP7_TYPE;
    varProp7.puuid = &PROP7_VAL;
    sc = ppstg->WriteMultiple( 1,                               // Count
                               &psGuidTest.GetPropSpec(),       // Property
                               &varProp7,                       // Value
                               pid );                           // Propid
    if ( FAILED(sc) )
    {
        LogError( "IPropertyStorage::WriteMultiple 7 returned 0x%lx\n", sc );
        CantRun();
    }

    varProp8.vt = PROP8_TYPE;
    varProp8.cal = PROP8_VAL;
    sc = ppstg->WriteMultiple( 1,                               // Count
                               &psManyRW.GetPropSpec(),         // Property
                               fAlternate ? &varProp8A :
                                            &varProp8,          // Value
                               pid );                           // Propid
    if ( FAILED(sc) )
    {
        LogError( "IPropertyStorage::WriteMultiple 8 returned 0x%lx\n", sc );
        CantRun();
    }


    varProp13.vt = PROP13_TYPE;
    varProp13.bVal = PROP13_VAL;
    sc = ppstg->WriteMultiple( 1,                               // Count
                               &psTestProperty13.GetPropSpec(), // Property
                               &varProp13,                       // Value
                               pid );                           // Propid
    if ( FAILED(sc) )
    {
        LogError( "IPropertyStorage::WriteMultiple 13 returned 0x%lx\n", sc );
        CantRun();
    }

    varProp14.vt = PROP14_TYPE;
    varProp14.iVal = PROP14_VAL;
    sc = ppstg->WriteMultiple( 1,                               // Count
                               &psTestProperty14.GetPropSpec(), // Property
                               &varProp14,                       // Value
                               pid );                           // Propid
    if ( FAILED(sc) )
    {
        LogError( "IPropertyStorage::WriteMultiple 14 returned 0x%lx\n", sc );
        CantRun();
    }

    varProp15.vt = PROP15_TYPE;
    varProp15.uiVal = PROP15_VAL;
    sc = ppstg->WriteMultiple( 1,                               // Count
                               &psTestProperty15.GetPropSpec(), // Property
                               &varProp15,                      // Value
                               pid );                           // Propid
    if ( FAILED(sc) )
    {
        LogError( "IPropertyStorage::WriteMultiple 13 returned 0x%lx\n", sc );
        CantRun();
    }

    varProp16.vt = PROP16_TYPE;
    varProp16.lVal = PROP16_VAL;
    sc = ppstg->WriteMultiple( 1,                               // Count
                               &psTestProperty16.GetPropSpec(), // Property
                               &varProp16,                      // Value
                               pid );                           // Propid
    if ( FAILED(sc) )
    {
        LogError( "IPropertyStorage::WriteMultiple 16 returned 0x%lx\n", sc );
        CantRun();
    }

    varProp17.vt = PROP17_TYPE;
    varProp17.fltVal = PROP17_VAL;
    sc = ppstg->WriteMultiple( 1,                               // Count
                               &psTestProperty17.GetPropSpec(), // Property
                               &varProp17,                      // Value
                               pid );                           // Propid
    if ( FAILED(sc) )
    {
        LogError( "IPropertyStorage::WriteMultiple 17 returned 0x%lx\n", sc );
        CantRun();
    }

    if (fAlternate)
    {
        varProp18A.decVal.sign = 0;
        varProp18A.decVal.Hi32 = 0;
        varProp18A.decVal.Lo64 = 123412345678i64;
        varProp18A.decVal.scale = 8;
        varProp18A.vt = VT_DECIMAL;

        //double dbl = 0.;
        //VarR8FromDec( &varProp18A.decVal, &dbl );
        //LogError("\tvarProp18A.decVal = %.8f\n", dbl );
    }
    else
    {
        varProp18.vt = PROP18_TYPE;
        varProp18.dblVal = PROP18_VAL;
    }
    sc = ppstg->WriteMultiple( 1,                               // Count
                               &psTestProperty18.GetPropSpec(), // Property
                               fAlternate ? &varProp18A :
                                            &varProp18,         // Value
                               pid );                           // Propid
    if ( FAILED(sc) )
    {
        LogError( "IPropertyStorage::WriteMultiple 18 returned 0x%lx\n", sc );
        CantRun();
    }

    varProp19.vt = PROP19_TYPE;
    varProp19.boolVal = PROP19_VAL;
    sc = ppstg->WriteMultiple( 1,                               // Count
                               &psTestProperty19.GetPropSpec(), // Property
                               &varProp19,                       // Value
                               pid );                           // Propid
    if ( FAILED(sc) )
    {
        LogError( "IPropertyStorage::WriteMultiple 19 returned 0x%lx\n", sc );
        CantRun();
    }

    varProp20.vt = PROP20_TYPE;
    varProp20.pszVal = PROP20_VAL;
    sc = ppstg->WriteMultiple( 1,                               // Count
                               &psTestProperty20.GetPropSpec(), // Property
                               &varProp20,                       // Value
                               pid );                           // Propid
    if ( FAILED(sc) )
    {
        LogError( "IPropertyStorage::WriteMultiple 20 returned 0x%lx\n", sc );
        CantRun();
    }


    varProp21.vt = PROP21_TYPE;
    varProp21.pclipdata = PROP21_VAL;
    sc = ppstg->WriteMultiple( 1,                               // Count
                               &psTestProperty21.GetPropSpec(), // Property
                               &varProp21,                       // Value
                               pid );                           // Propid
    if ( FAILED(sc) )
    {
        LogError( "IPropertyStorage::WriteMultiple 21 returned 0x%lx\n", sc );
        CantRun();
    }

    varProp22.vt = PROP22_TYPE;
    varProp22.caclipdata.pElems = PROP22_VAL;
    varProp22.caclipdata.cElems = PROP22_CVALS;
    sc = ppstg->WriteMultiple( 1,                               // Count
                               &psTestProperty22.GetPropSpec(), // Property
                               &varProp22,                       // Value
                               pid );                           // Propid
    if ( FAILED(sc) )
    {
        LogError( "IPropertyStorage::WriteMultiple 22 returned 0x%lx\n", sc );
        CantRun();
    }


    ppstg->Release();

    // PROP3 and PROP4 are in a different propertyset!

    sc = ppsstg->Create( guidDocument,               // Property set GUID
                         0,
                         PROPSETFLAG_DEFAULT,
                         ulMode | STGM_READWRITE,              // Open mode
                         &ppstg );                   // IProperty
    if ( FAILED(sc) )
    {
        LogError( "IPropertySetStorage::Create returned 0x%lx\n", sc );
        CantRun();
    }

    varProp3.vt = PROP3_TYPE;
    varProp3.pwszVal = (WCHAR *)PROP3_VAL;
    sc = ppstg->WriteMultiple( 1,                              // Count
                               &psAuthor.GetPropSpec(),        // Property
                               &varProp3,                      // Value
                               pid );                           // Propid
    if ( FAILED(sc) )
    {
        LogError( "IPropertyStorage::WriteMultiple 3 returned 0x%lx\n", sc );
        CantRun();
    }

    varProp4.vt = PROP4_TYPE;
    varProp4.calpwstr = PROP4_VAL;
    sc = ppstg->WriteMultiple( 1,                              // Count
                               &psKeywords.GetPropSpec(),      // Property
                               &varProp4,                      // Value
                               pid );                           // Propid
    if ( FAILED(sc) )
    {
        LogError( "IPropertyStorage::WriteMultiple 4 returned 0x%lx\n", sc );
        CantRun();
    }




    ppstg->Release();

    /////////////////////// the secure prop plan 9

    sc = ppsstg->Create( guidSecurityTest,
                         0,
                         PROPSETFLAG_DEFAULT,
                         ulMode | STGM_READWRITE, // Open mode
                         &ppstg );                // IProperty
    if ( FAILED(sc) )
        LogFail( "IPropertySetStorage::Create (security2) returned 0x%lx\n", sc );

    // this value will be invisible to queries due to permissions...
    varProp9.vt = VT_EMPTY;
    varProp9.lVal = 0;

    ppstg->Release();
    ppsstg->Release();

} //AddPropsToStorage


//+-------------------------------------------------------------------------
//
//  Function:   AddFiles, public
//
//  Synopsis:   Add several files to a directory.
//
//  Arguments:  [wszPath] - path name where files should be added
//              [cFiles] - number of files to create
//              [wszPattern] - wsprintf string to create file name
//
//  History:    18 May 1995  AlanW     Created
//
//--------------------------------------------------------------------------

void AddFiles( const WCHAR *wszPath, unsigned cFiles, const WCHAR *wszPattern)
{
    WCHAR wszFileName[MAX_PATH];
    const unsigned owcFile = wcslen( wszPath );

    for (unsigned i=0; i < cFiles; i++)
    {
        wcscpy( wszFileName, wszPath );
        swprintf( &wszFileName[ owcFile ], wszPattern, i );

        BuildFile( wszFileName, szOFSFileData, strlen( szOFSFileData ) );
    }
}


//+-------------------------------------------------------------------------
//
//  Function:   Setup, public
//
//  Synopsis:   Clean up and initialize state
//
//  History:    13-May-93 KyleP     Created
//
//--------------------------------------------------------------------------

void Setup()
{
    if ( 0 == wcsTestCatalog[0] )
        wcscpy( wcsTestCatalog, wcsDefaultTestCatalog );

    if ( GetEnvironmentVariable( L"TEMP",
                                 wcsTestPath,
                                 sizeof(wcsTestPath) ) == 0 )
    {
        LogError( "Unable to find test directory.  Set TEMP variable.\n" );
        CantRun();
    }

    wcscat( wcsTestPath, L"\\" );
    int ccPath = wcslen( wcsTestPath );

    wcscat( wcsTestPath, wcsTestDir );

    if (Delnode( wcsTestPath ))
    {
        LogError("Delnode %ws failed\n", wcsTestPath);
        CantRun();
    }

    //
    // Create test directory.
    //

    if ( !CreateDirectory( (WCHAR *)wcsTestPath, 0 ) )
    {
        LogError( "Error 0x%lx creating directory %ws\n",
                    GetLastError(), wcsTestPath );
        CantRun();
    }

    //
    // Add property file + properties
    //

    wcscpy( wcsTestPath + ccPath, wcsTestDir );
    wcscat( wcsTestPath, L"\\" );
    wcscat( wcsTestPath, wcsPropFile );
    AddPropsToStorage( FALSE );

    //
    // Make a second (similar) file
    //

    wcscpy( wcsTestPath + ccPath, wcsTestDir );
    wcscat( wcsTestPath, L"\\" );
    wcscat( wcsTestPath, wcsPropFile2 );
    AddPropsToStorage( TRUE );

    wcscpy( wcsTestPath + ccPath, wcsTestDir );

    //
    // Add more files for the delete tests
    //

    wcscpy( wcsTestPath + ccPath, wcsTestDir );
    wcscat( wcsTestPath, L"\\DeleteTest.1" );
    if ( !CreateDirectory( (WCHAR *)wcsTestPath, 0 ) )
    {
        LogError( "Error 0x%lx creating directory %ws\n",
                    GetLastError(), wcsTestPath );
        CantRun();
    }

    AddFiles(  wcsTestPath, 20, L"\\\\F%04d.txt" );

    wcscpy( wcsTestPath + ccPath, wcsTestDir );
    wcscat( wcsTestPath, L"\\DeleteTest.2" );
    if ( !CreateDirectory( (WCHAR *)wcsTestPath, 0 ) )
    {
        LogError( "Error 0x%lx creating directory %ws\n",
                    GetLastError(), wcsTestPath );
        CantRun();
    }

    AddFiles(  wcsTestPath, 20, L"\\\\F%04d.txt" );

    //
    //  Add three files for content query tests
    //

    wcscpy( wcsTestPath + ccPath, wcsTestDir );
    wcscat( wcsTestPath, L"\\" );
    wcscat( wcsTestPath, wcsTestCiFile1 );
    BuildFile( wcsTestPath, szCIFileData1, strlen( szCIFileData1 ) );

    wcscpy( wcsTestPath + ccPath, wcsTestDir );
    wcscat( wcsTestPath, L"\\" );
    wcscat( wcsTestPath, wcsTestCiFile2 );
    BuildFile( wcsTestPath, szCIFileData2, strlen( szCIFileData2 ) );

    // make file 2 visible to both filter daemon and current user.
    // (it was already, but this verifies the file3 code below really works)
#ifdef CAIRO_SECURITY_WORKS
    DenyAllAccess( wcsTestPath );
    GiveAccess( wcsTestPath, TRUE, GENERIC_READ );
    GiveAccess( wcsTestPath, FALSE, GENERIC_READ );
#endif

    //
    // make a file that should show up in content queries.
    // give it write access to current user, read access to filter daemon
    //  => in the content index, but the current user can't see hit
    //

    wcscpy( wcsTestPath + ccPath, wcsTestDir );
    wcscat( wcsTestPath, L"\\" );
    wcscat( wcsTestPath, wcsTestCiFile3 );
    BuildFile( wcsTestPath, szCIFileData2, strlen( szCIFileData2 ) );
    DenyAllAccess( wcsTestPath );
#ifdef CAIRO_SECURITY_WORKS
    GiveAccess( wcsTestPath, TRUE, GENERIC_WRITE ); // just for kicks
    GiveAccess( wcsTestPath, FALSE, GENERIC_READ );
#endif

    //
    // Back to just directory
    //
    wcscpy( wcsTestPath + ccPath, wcsTestDir );

} //Setup

//+-------------------------------------------------------------------------
//
//  Function:   Cleanup, public
//
//  Synopsis:   Clean up and initialize state
//
//  History:    13-May-93 KyleP     Created
//
//--------------------------------------------------------------------------

void Cleanup()
{
    if (Delnode( wcsTestPath ))
    {
        LogError("Delnode %ws failed\n", wcsTestPath);
        CantRun();
    }

    if ( fDidInitOfVariants )
    {
        PropVariantClear( &varProp8A );
        PropVariantClear( &varProp11 );
        PropVariantClear( &varProp11A );
        PropVariantClear( &varProp12 );
    }

    char acSysDir[MAX_PATH];
    if( !GetSystemDirectoryA( acSysDir, sizeof(acSysDir) ) )
    {
        LogFail( "Unable to determine system directory.\n" );
    }

#if defined( DO_NOTIFICATION )
    char acCmd[MAX_PATH];
    sprintf(acCmd,"del %s\\*.zzz",acSysDir);
    system(acCmd);
#endif  // DO_NOTIFICATION

} //Cleanup


//+---------------------------------------------------------------------------
//
//  Function:   FormQueryTree
//
//  Synopsis:   Forms a query tree consisting of the projection nodes,
//              sort node(s), selection node and the restriction tree.
//
//  Arguments:  [pRst]      - pointer to Restriction tree describing the query
//              [Cols]      - Columns in the resulting table
//              [pSort]     - pointer to sort set; may be null
//              [aColNames] - pointer to column names; may be null
//
//  Returns:    A pointer to the query tree. It is the responsibility of
//              the caller to later free it.
//
//  History:    06 July 1995   AlanW   Created
//
//  Notes:
//
//----------------------------------------------------------------------------

CDbCmdTreeNode * FormQueryTree( CDbCmdTreeNode * pRst,
                                CDbColumns & Cols,
                                CDbSortSet * pSort,
                                LPWSTR * aColNames )
{
    CDbCmdTreeNode *  pTree = 0;        // return value

    if (pRst)
    {
        //
        // First create a selection node and append the restriction tree to it
        //
        CDbSelectNode * pSelect = new CDbSelectNode();
        if ( 0 == pSelect )
        {
            LogFail("FormQueryTree: out of memory 0\n");
        }

        pTree = pSelect;
        if ( !pSelect->IsValid() )
        {
            delete pTree;
            LogFail("FormQueryTree: out of memory 1\n");
        }

        //
        // Clone the restriction and use it.
        //
        CDbCmdTreeNode * pExpr = pRst->Clone();
        if ( 0 == pExpr )
        {
            delete pTree;
            LogFail("FormQueryTree: out of memory 2\n");
        }

        //
        // Now make the restriction a child of the selection node.
        //
        pSelect->AddRestriction( pExpr );
    }
    else
    {
        //
        // No restriction.  Just use table ID node as start of tree.
        //
        pTree = new CDbTableId();
        if ( 0 == pTree )
        {
            LogFail("FormQueryTree: out of memory 3\n");
        }
    }

    //
    // Next create the projection nodes
    //
    CDbProjectNode * pProject = new CDbProjectNode();
    if ( 0 == pProject )
    {
        delete pTree;
        LogFail("FormQueryTree: out of memory 4\n");
    }

    //
    // Make the selection a child of the projection node.
    //
    pProject->AddTable( pTree );
    pTree = pProject;

    //
    // Next add all the columns in the state.
    //
    unsigned int cCol = Cols.Count();
    for ( unsigned int i = 0; i < cCol; i++ )
    {
        if ( !pProject->AddProjectColumn( Cols.Get(i),
                                          aColNames ? aColNames[i] : 0 ))
        {
            delete pTree;
            LogFail("FormQueryTree: out of memory 5\n");
        }
    }

    //
    // Next add a sort node and make the project node a child of the
    // sort node
    //

    if (pSort && pSort->Count())
    {
        unsigned int cSortProp = pSort->Count();
        CDbSortNode * pSortNode = new CDbSortNode();

        if ( 0 == pSortNode )
        {
            delete pTree;
            LogFail("FormQueryTree: out of memory 6\n");
        }

        //
        // Make the project node a child of the sort node.
        //
        pSortNode->AddTable( pTree );
        pTree = pSortNode;

        DWORD sd = QUERY_SORTASCEND;
        LCID lcid = 0;
        for( i = 0; i < cSortProp; i++ )
        {
            //
            // Add the sort column.
            //
            if ( !pSortNode->AddSortColumn(pSort->Get(i)))
            {
                delete pTree;
                LogFail("FormQueryTree: out of memory 7\n");
            }
        }
    }

    return pTree;
}

void GetCommandTreeErrors(ICommandTree* pCmdTree)
{

    DBCOMMANDTREE * pTreeCopy = 0;
    SCODE sc = pCmdTree->GetCommandTree(&pTreeCopy);
    if (FAILED(sc))
    {
        pCmdTree->Release();
        LogFail("GetCommandTree failed, %08x\n", sc);
    }

    ULONG cErrorNodes = 0;
    DBCOMMANDTREE ** rgpErrorNodes = 0;

    sc = pCmdTree->FindErrorNodes(pTreeCopy, &cErrorNodes, &rgpErrorNodes);
    if (FAILED(sc))
    {
        pCmdTree->FreeCommandTree(&pTreeCopy);
        pCmdTree->Release();
        LogFail("FindErrorNodes failed, %08x\n", sc);
    }

    for (unsigned i=0; i<cErrorNodes; i++)
    {
        DBCOMMANDTREE* pNode = rgpErrorNodes[i];
        if (pNode->hrError != S_OK)
        {
            LogError("tree node %08x\top=%d\tOp Error=%x\n",
                       pNode, pNode->op, pNode->hrError);
        }
        else
            LogError("tree node %x\top=%d\tNO ERROR!!\n",
                       pNode, pNode->op);
    }

    pCmdTree->FreeCommandTree(&pTreeCopy);
}

//+---------------------------------------------------------------------------
//
//  Function:   InstantiateRowset
//
//  Synopsis:   Forms a query tree consisting of the projection nodes,
//              sort node(s), selection node and the restriction tree.
//
//  Arguments:  [pQueryIn]  - Input ICommand or NULL
//              [dwDepth]   - Query depth, one of QUERY_DEEP or QUERY_SHALLOW
//              [pswzScope] - Query scope
//              [pTree]     - pointer to DBCOMMANDTREE for the query
//              [riid]      - Interface ID of the desired rowset interface
//              [pUnkOuter] - pointer to outer unknown object
//              [ppCmdTree] - if non-zero, ICommandTree will be returned here.
//              [fExtendedTypes] - if TRUE, set property for extended variants
//
//  Returns:    IRowsetScroll* - a pointer to an instantiated rowset
//
//  History:    22 July 1995   AlanW   Created
//              01 July 1997   EmilyB  Added outer unknown support for
//                             ICommand only.
//
//  Notes:      Although the returned pointer is to IRowsetScroll, the
//              returned pointer may only support IRowset, depending
//              upon the riid parameter.
//
//              Ownership of the query tree is given to the ICommandTree
//              object.  The caller does not need to delete it.
//
//              Use InstantiateMultipleRowsets for categorized queries.
//
//----------------------------------------------------------------------------

static g_cLocatable = 0;

IRowsetScroll * InstantiateRowset(
    ICommand *pQueryIn,
    DWORD dwDepth,
    LPWSTR pwszScope,
    CDbCmdTreeNode * pTree,
    REFIID riid,
    COuterUnk * pobjOuterUnk,
    ICommandTree **ppCmdTree,
    BOOL fExtendedTypes
) {
    // run the query
    ICommand * pQuery = 0;
    if ( 0 == pQueryIn )
    {
        IUnknown * pIUnknown;
        SCODE sc = CICreateCommand( &pIUnknown,
                                    (IUnknown *)pobjOuterUnk,
                                    IID_IUnknown,
                                    TEST_CATALOG,
                                    TEST_MACHINE );

        if ( FAILED( sc ) )
            LogFail( "InstantiateRowset - error 0x%x Unable to create ICommand\n",
                     sc );

        if (pobjOuterUnk)
        {
           pobjOuterUnk->Set(pIUnknown);
        }

        if (pobjOuterUnk)
            sc = pobjOuterUnk->QueryInterface(IID_ICommand, (void **) &pQuery );
        else
            sc = pIUnknown->QueryInterface(IID_ICommand, (void **) &pQuery );

        pIUnknown->Release();

        if ( FAILED( sc ) )
            LogFail( "InstantiateRowset - error 0x%x Unable to QI ICommand\n",
                     sc );

        if ( 0 == pQuery )
            LogFail( "InstantiateRowset - CICreateCommand succeeded, but returned null pQuery\n" );

        sc = SetScopeProperties( pQuery,
                                 1,
                                 &pwszScope,
                                 &dwDepth );

        if ( FAILED( sc ) )
            LogFail( "InstantiateRowset - error 0x%x Unable to set scope '%ws'\n",
                     sc, pwszScope );

        CheckPropertiesOnCommand( pQuery );
    }
    else
    {
        pQuery = pQueryIn;
    }

    ICommandTree *pCmdTree = 0;
    SCODE sc;
    if (pobjOuterUnk)
        sc = pobjOuterUnk->QueryInterface(IID_ICommandTree, (void **)&pCmdTree);
    else
        sc = pQuery->QueryInterface(IID_ICommandTree, (void **)&pCmdTree);

    if (FAILED (sc) )
    {
        if ( 0 == pQueryIn )
            pQuery->Release();

        LogFail("QI for ICommandTree failed\n");
    }

    DBCOMMANDTREE * pRoot = pTree->CastToStruct();

    sc = pCmdTree->SetCommandTree( &pRoot, 0, FALSE);
    if (FAILED (sc) )
    {
        if ( 0 == pQueryIn )
           pQuery->Release();

        pCmdTree->Release();
        LogFail("SetCommandTree failed, %08x\n", sc);
    }

    if (fExtendedTypes)
    {
        ICommandProperties *pCmdProp = 0;
        if (pobjOuterUnk)
            sc = pobjOuterUnk->QueryInterface(IID_ICommandProperties, (void **)&pCmdProp);
        else
            sc = pQuery->QueryInterface(IID_ICommandProperties, (void **)&pCmdProp);

        if (FAILED (sc) )
        {
            if ( 0 == pQueryIn )
                pQuery->Release();

            LogFail("QI for ICommandProperties failed\n");
        }

        //
        //  If we should NOT be using a enumerated query, notify pCommand
        //
        const unsigned MAX_PROPS = 6;
        DBPROPSET  aPropSet[MAX_PROPS];
        DBPROP     aProp[MAX_PROPS];
        ULONG      cProp = 0;

        aProp[cProp].dwPropertyID = DBPROP_USEEXTENDEDDBTYPES;
        aProp[cProp].dwOptions    = DBPROPOPTIONS_OPTIONAL;
        aProp[cProp].dwStatus     = 0;         // Ignored
        aProp[cProp].colid        = dbcolNull;
        aProp[cProp].vValue.vt    = VT_BOOL;
        aProp[cProp].vValue.boolVal  = VARIANT_TRUE;

        aPropSet[cProp].rgProperties = &aProp[cProp];
        aPropSet[cProp].cProperties = 1;
        aPropSet[cProp].guidPropertySet = guidQueryExt;

        cProp++;

        if (riid == IID_IRowsetLocate)
        {
            aProp[cProp].dwPropertyID = DBPROP_IRowsetLocate;
            aProp[cProp].dwOptions    = DBPROPOPTIONS_REQUIRED;
            aProp[cProp].dwStatus     = 0;         // Ignored
            aProp[cProp].colid        = dbcolNull;
            aProp[cProp].vValue.vt    = VT_BOOL;
            aProp[cProp].vValue.boolVal  = VARIANT_TRUE;

            aPropSet[cProp].rgProperties = &aProp[cProp];
            aPropSet[cProp].cProperties = 1;
            aPropSet[cProp].guidPropertySet = DBPROPSET_ROWSET;

            cProp++;

            aProp[cProp].dwPropertyID = DBPROP_BOOKMARKS;
            aProp[cProp].dwOptions    = DBPROPOPTIONS_REQUIRED;
            aProp[cProp].dwStatus     = 0;         // Ignored
            aProp[cProp].colid        = dbcolNull;
            aProp[cProp].vValue.vt    = VT_BOOL;
            aProp[cProp].vValue.boolVal  = VARIANT_TRUE;

            aPropSet[cProp].rgProperties = &aProp[cProp];
            aPropSet[cProp].cProperties = 1;
            aPropSet[cProp].guidPropertySet = DBPROPSET_ROWSET;

            cProp++;

            g_cLocatable++;
            if (g_cLocatable % 2)
            {
                aProp[cProp].dwPropertyID = DBPROP_IDBAsynchStatus;
                aProp[cProp].dwOptions    = DBPROPOPTIONS_REQUIRED;
                aProp[cProp].dwStatus     = 0;         // Ignored
                aProp[cProp].colid        = dbcolNull;
                aProp[cProp].vValue.vt    = VT_BOOL;
                aProp[cProp].vValue.boolVal = VARIANT_TRUE;

                aPropSet[cProp].rgProperties = &aProp[cProp];
                aPropSet[cProp].cProperties = 1;
                aPropSet[cProp].guidPropertySet = DBPROPSET_ROWSET;

                cProp++;
            }
            if ((g_cLocatable % 4) == 3)
            {
                aProp[cProp].dwPropertyID = DBPROP_IRowsetWatchAll;
                aProp[cProp].dwOptions    = DBPROPOPTIONS_REQUIRED;
                aProp[cProp].dwStatus     = 0;         // Ignored
                aProp[cProp].colid        = dbcolNull;
                aProp[cProp].vValue.vt    = VT_BOOL;
                aProp[cProp].vValue.boolVal = VARIANT_TRUE;

                aPropSet[cProp].rgProperties = &aProp[cProp];
                aPropSet[cProp].cProperties = 1;
                aPropSet[cProp].guidPropertySet = DBPROPSET_ROWSET;

                cProp++;
            }
        }
        else if (riid == IID_IRowsetScroll)
        {
            aProp[cProp].dwPropertyID = DBPROP_IRowsetScroll;
            aProp[cProp].dwOptions    = DBPROPOPTIONS_REQUIRED;
            aProp[cProp].dwStatus     = 0;         // Ignored
            aProp[cProp].colid        = dbcolNull;
            aProp[cProp].vValue.vt    = VT_BOOL;
            aProp[cProp].vValue.boolVal = VARIANT_TRUE;

            aPropSet[cProp].rgProperties = &aProp[cProp];
            aPropSet[cProp].cProperties = 1;
            aPropSet[cProp].guidPropertySet = DBPROPSET_ROWSET;

            cProp++;

            g_cLocatable++;
            if (g_cLocatable % 2)
            {
                aProp[cProp].dwPropertyID = DBPROP_ROWSET_ASYNCH;
                aProp[cProp].dwOptions    = DBPROPOPTIONS_OPTIONAL;
                aProp[cProp].dwStatus     = 0;         // Ignored
                aProp[cProp].colid        = dbcolNull;
                aProp[cProp].vValue.vt    = VT_I4;
                aProp[cProp].vValue.lVal  = DBPROPVAL_ASYNCH_RANDOMPOPULATION;

                aPropSet[cProp].rgProperties = &aProp[cProp];
                aPropSet[cProp].cProperties = 1;
                aPropSet[cProp].guidPropertySet = DBPROPSET_ROWSET;

                cProp++;
            }
            if ((g_cLocatable % 4) == 3)
            {
                aProp[cProp].dwPropertyID = DBPROP_IRowsetWatchAll;
                aProp[cProp].dwOptions    = DBPROPOPTIONS_REQUIRED;
                aProp[cProp].dwStatus     = 0;         // Ignored
                aProp[cProp].colid        = dbcolNull;
                aProp[cProp].vValue.vt    = VT_BOOL;
                aProp[cProp].vValue.boolVal = VARIANT_TRUE;

                aPropSet[cProp].rgProperties = &aProp[cProp];
                aPropSet[cProp].cProperties = 1;
                aPropSet[cProp].guidPropertySet = DBPROPSET_ROWSET;

                cProp++;
            }
        }

        sc = pCmdProp->SetProperties( cProp, aPropSet );
        pCmdProp->Release();

        if ( FAILED(sc) || DB_S_ERRORSOCCURRED == sc )
        {
            if ( 0 == pQueryIn )
                pQuery->Release();

            LogError("ICommandProperties::SetProperties failed\n");
        }
    }

    IRowset * pRowset = 0;

    sc = pQuery->Execute( 0,                    // no aggr. IUnknown
                          (riid != IID_IRowset) ?
                                IID_IRowsetIdentity :
                                IID_IRowset,    // IID for i/f to return
                          0,                    // disp. params
                          0,                    // count of rows affected
                          (IUnknown **)&pRowset);  // Returned interface

    if (SUCCEEDED (sc) && 0 == pRowset )
    {
        LogError("ICommand::Execute returned success(%x), but pRowset is null\n", sc);
        if (DB_S_ERRORSOCCURRED == sc)
        {
            CheckPropertiesInError(pQuery);
        }
        pCmdTree->Release();
        pQuery->Release();
        Fail();
    }


    if ( 0 == pQueryIn )
        pQuery->Release();

    if (FAILED (sc) )
    {
        LogError("ICommand::Execute failed, %08x\n", sc);
        if (DB_E_ERRORSINCOMMAND == sc)
        {
            GetCommandTreeErrors(pCmdTree);
        }
        if (DB_E_ERRORSOCCURRED == sc)
        {
            CheckPropertiesInError(pQuery);
        }
        pCmdTree->Release();

        //
        // This isn't really kosher, but it helps to avoid spurious (client-side) memory leaks.
        //

        pQuery->Release();
        Fail();
    }

    if (riid != IID_IRowset)
    {
        IRowset * pRowset2 = 0;

        sc = pRowset->QueryInterface(riid, (void **)&pRowset2);

        if (FAILED (sc) )
        {
            LogError("InstantiateRowset - QI to riid failed, %08x\n", sc);
            pCmdTree->Release();
            Fail();
        }
        pRowset->Release();
        pRowset = pRowset2;
    }

    if ( 0 == ppCmdTree )
    {
        pCmdTree->Release();
    }
    else
    {
        *ppCmdTree = pCmdTree;
    }

    return (IRowsetScroll *)pRowset;
}


//+---------------------------------------------------------------------------
//
//  Function:   InstantiateMultipleRowsets
//
//  Synopsis:   Forms a query tree consisting of the projection nodes,
//              sort node(s), selection node and the restriction tree.
//
//  Arguments:  [dwDepth]   - Query depth, one of QUERY_DEEP or QUERY_SHALLOW
//              [pswzScope] - Query scope
//              [pTree]     - pointer to DBCOMMANDTREE for the query
//              [riid]      - Interface ID of the desired rowset interface
//              [cRowsets]  - Number of rowsets to be returned
//              [ppRowsets] - Pointer to location where rowsets are returned
//              [ppCmdTree] - if non-zero, ICommandTree will be returned here.
//
//  Returns:    Nothing
//
//  History:    22 July 1995   AlanW   Created
//
//  Notes:      Ownership of the query tree is given to the ICommandTree
//              object.  The caller does not need to delete it.
//
//----------------------------------------------------------------------------

void
InstantiateMultipleRowsets(
    DWORD dwDepth,
    LPWSTR pwszScope,
    CDbCmdTreeNode * pTree,
    REFIID riid,
    unsigned cRowsets,
    IUnknown **ppRowsets,
    ICommandTree ** ppCmdTree
) {
    // run the query
    ICommand * pQuery = 0;
    IUnknown * pIUnknown;
    SCODE scIC = CICreateCommand( &pIUnknown,
                                  0,
                                  IID_IUnknown,
                                  TEST_CATALOG,
                                  TEST_MACHINE );

    if (FAILED(scIC))
        LogFail( "InstantiateMultipleRowsets - error 0x%x, Unable to create ICommand\n",
                 scIC );

    scIC = pIUnknown->QueryInterface(IID_ICommand, (void **) &pQuery );
    pIUnknown->Release();

    if ( FAILED( scIC ) )
        LogFail( "InstantiateMultipleRowsets - error 0x%x Unable to QI ICommand\n",
                 scIC );


    if ( 0 == pQuery )
        LogFail( "InstantiateMultipleRowsets - CICreateCommand succeeded, but returned null pQuery\n" );

    scIC = SetScopeProperties( pQuery,
                               1,
                               &pwszScope,
                               &dwDepth );

    if ( FAILED( scIC ) )
        LogFail( "InstantiateMultipleRowsets - error 0x%x Unable to set scope '%ws'\n",
                 scIC, pwszScope );

    scIC = SetBooleanProperty( pQuery, DBPROP_CANHOLDROWS, VARIANT_TRUE );

    if ( FAILED( scIC ) )
        LogFail( "InstantiateMultipleRowsets - error 0x%x Unable to set HoldRows\n",
                 scIC );

    CheckPropertiesOnCommand( pQuery );

    ICommandTree *pCmdTree = 0;
    SCODE sc = pQuery->QueryInterface(IID_ICommandTree, (void **)&pCmdTree);

    if (FAILED (sc) )
    {
        pQuery->Release();
        LogFail("QI for ICommandTree failed\n");
    }

    DBCOMMANDTREE * pRoot = pTree->CastToStruct();
    sc = pCmdTree->SetCommandTree( &pRoot, 0, FALSE);
    if (FAILED (sc) )
    {
        pQuery->Release();
        pCmdTree->Release();
        LogFail("SetCommandTree failed, %08x\n", sc);
    }

    sc = pQuery->Execute( 0,                    // no aggr. IUnknown
                          riid,                 // IID for i/f to return
                          0,                    // disp. params
                          0,                    // count of rows affected
                          (IUnknown **)ppRowsets);  // Returned interface

    pQuery->Release();

    if (FAILED (sc) )
    {
        LogError("ICommand::Execute failed, %08x\n", sc);
        if (DB_E_ERRORSINCOMMAND == sc)
        {
            GetCommandTreeErrors(pCmdTree);
        }
        pCmdTree->Release();
        Fail();
    }

    // Get rowset pointers for all child rowsets
    for (unsigned i=1; i<cRowsets; i++)
    {
        IUnknown * pRowset = ppRowsets[i-1];
        IColumnsInfo * pColumnsInfo = 0;
        sc = pRowset->QueryInterface(IID_IColumnsInfo, (void **)&pColumnsInfo);
        if (FAILED (sc) )
        {
            pCmdTree->Release();
            LogFail("QI for IColumnsInfo failed\n");
        }
        DBORDINAL iChaptOrdinal = 0;
        sc = pColumnsInfo->MapColumnIDs(1, &psChapt, &iChaptOrdinal);
        pColumnsInfo->Release();
        if (FAILED (sc) )
        {
            pCmdTree->Release();
            LogFail("MapColumnIDs of chapter column failed, %x\n", sc);
        }

        IRowsetInfo * pRowsetInfo = 0;
        sc = pRowset->QueryInterface(IID_IRowsetInfo, (void **)&pRowsetInfo);
        if (FAILED (sc) )
        {
            pCmdTree->Release();
            LogFail("QI for IRowsetInfo failed\n");
        }
        sc = pRowsetInfo->GetReferencedRowset(iChaptOrdinal, riid, &ppRowsets[i]);
        pRowsetInfo->Release();
        if (FAILED (sc) )
        {
            pCmdTree->Release();
            LogFail("GetReferencedRowset failed, %x\n", sc);
        }
    }

    if ( 0 == ppCmdTree )
    {
        pCmdTree->Release();
    }
    else
    {
        *ppCmdTree = pCmdTree;
    }

    return;
}


//+-------------------------------------------------------------------------
//
//  Function:   ReleaseStaticHrows, public
//
//  Synopsis:   Release a caller allocated HROW array
//
//  Arguments:  [pRowset] - a pointer to IRowset
//              [cRows]   - nuumber of HROWs in the array
//              [phRows]  - a pointer to the HROWs array
//
//  Returns:    Nothing
//
//  History:    03 Oct 1996     AlanW   Created
//
//--------------------------------------------------------------------------

const unsigned MAX_ROWSTATUS = 20;

ULONG aRowRefcount[MAX_ROWSTATUS];
DBROWSTATUS aRowStatus[MAX_ROWSTATUS];

void ReleaseStaticHrows( IRowset * pRowset, DBCOUNTITEM cRows, HROW * phRows )
{
    ULONG *pRefCount = 0;
    DBROWSTATUS *pRowStatus = 0;

    if (cRows <= MAX_ROWSTATUS)
    {
        pRefCount = aRowRefcount;
        pRowStatus = aRowStatus;
    }

    SCODE sc = pRowset->ReleaseRows(cRows, phRows, 0, pRefCount, pRowStatus);
    if (sc != S_OK && sc != DB_S_ERRORSOCCURRED)
    {
        LogError("ReleaseStaticHrows: ReleaseRows failed, sc=%x\n", sc);
        cFailures++;
    }
    else if (cRows <= MAX_ROWSTATUS)
    {
        for (unsigned i=0; i<cRows; i++)
        {
            if ( pRowStatus[i] != DBROWSTATUS_S_OK &&
                 ! ( pRowStatus[i] == DBROWSTATUS_E_INVALID &&
                     phRows[i] == DB_NULL_HROW ))
            {
                LogError("ReleaseStaticHrows: ReleaseRows row status/refcount, "
                         "hrow=%x ref=%d stat=%d\n", phRows[i], pRefCount[i], pRowStatus[i]);
                cFailures++;
                continue;
            }
            if ( pRowStatus[i] != DBROWSTATUS_S_OK &&
                 sc != DB_S_ERRORSOCCURRED )
            {
                LogError("ReleaseStaticHrows: bad return status, sc = %x\n", sc);
                cFailures++;
                continue;
            }
        }
    }
} //ReleaseStaticHrows


//+-------------------------------------------------------------------------
//
//  Function:   FreeHrowsArray, public
//
//  Synopsis:   Release and free a callee allocated HROW array
//
//  Effects:    Memory is freed; pointer is zeroed
//
//  Arguments:  [pRowset] - a pointer to IRowset
//              [cRows]   - nuumber of HROWs in the array
//              [pphRows] - a pointer to pointer to the HROWs array
//
//  History:    01 Feb 1995     AlanW   Created
//
//--------------------------------------------------------------------------

void FreeHrowsArray( IRowset * pRowset, DBCOUNTITEM cRows, HROW ** pphRows )
{
    if (*pphRows)
    {
        ReleaseStaticHrows(pRowset, cRows, *pphRows);
        CoTaskMemFree(*pphRows);
        *pphRows = 0;
    }
} //FreeHrowsArray


//+-------------------------------------------------------------------------
//
//  Function:   MapColumns, public
//
//  Synopsis:   Map column IDs in column bindings.  Create an accessor
//              for the binding array.
//
//  Arguments:  [pUnknown]  -- Interface capable of returning IColumnsInfo and
//                             IAccessor
//              [cCols]     -- number of columns in arrays
//              [pBindings] -- column data binding array
//              [pDbCols]   -- column IDs array
//              [fByRef]    -- true if byref/vector columns should be byref
//
//  Returns:    HACCESSOR - a read accessor for the column bindings.
//
//  History:    18 May 1995     AlanW     Created
//
//--------------------------------------------------------------------------

static DBORDINAL aMappedColumnIDs[20];

HACCESSOR MapColumns(
    IUnknown * pUnknown,
    DBORDINAL cCols,
    DBBINDING * pBindings,
    const DBID * pDbCols,
    BOOL fByRef )
{
    IColumnsInfo * pColumnsInfo = 0;

    SCODE sc = pUnknown->QueryInterface( IID_IColumnsInfo, (void **)&pColumnsInfo);
    if ( FAILED( sc ) || pColumnsInfo == 0 )
    {
        LogFail( "IUnknown::QueryInterface for IColumnsInfo returned 0x%lx\n", sc );
    }

    sc = pColumnsInfo->MapColumnIDs(cCols, pDbCols, aMappedColumnIDs);
    pColumnsInfo->Release();

    if (S_OK != sc)
    {
        LogFail( "IColumnsInfo->MapColumnIDs returned 0x%lx\n",sc);
    }

    for (ULONG i = 0; i < cCols; i++)
    {
        pBindings[i].iOrdinal = aMappedColumnIDs[i];
        if ( fByRef &&
             ( (pBindings[i].wType & (DBTYPE_BYREF|DBTYPE_VECTOR)) ||
               pBindings[i].wType == DBTYPE_BSTR ||
               pBindings[i].wType == VT_LPWSTR ||
               pBindings[i].wType == VT_LPSTR ) &&
             pBindings[i].dwMemOwner != DBMEMOWNER_PROVIDEROWNED)
        {
            LogError( "Test error -- MapColumns with fByref, bad accessor %d\n", i);
        }

        if ( ! fByRef &&
             ( (pBindings[i].wType & (DBTYPE_BYREF|DBTYPE_VECTOR)) ||
               pBindings[i].wType == DBTYPE_BSTR ||
               pBindings[i].wType == VT_LPWSTR ||
               pBindings[i].wType == VT_LPSTR ) &&
             pBindings[i].dwMemOwner != DBMEMOWNER_CLIENTOWNED)
        {
            LogError( "Test error -- MapColumns without fByref, bad accessor %d\n", i);
        }
    }

    IAccessor * pIAccessor = 0;

    sc = pUnknown->QueryInterface( IID_IAccessor, (void **)&pIAccessor);
    if ( FAILED( sc ) || pIAccessor == 0 )
    {
        LogFail( "IRowset::QueryInterface for IAccessor returned 0x%lx\n", sc );
    }

    HACCESSOR hAcc;
    sc = pIAccessor->CreateAccessor( DBACCESSOR_ROWDATA, cCols, pBindings,
                                     0, &hAcc, 0 );
    pIAccessor->Release();

    if (S_OK != sc)
    {
        LogFail( "IAccessor->CreateAccessor returned 0x%lx\n", sc);
    }
    return hAcc;
}

//+-------------------------------------------------------------------------
//
//  Function:   ReleaseAccessor, public
//
//  Synopsis:   Release an accessor obtained from MapColumns
//
//  Arguments:  [pUnknown]  -- Something that we can QI the IAccessor on
//              [hAcc]      -- Accessor handle to be released.
//
//  Returns:    nothing
//
//  History:    14 June 1995     AlanW     Created
//
//--------------------------------------------------------------------------

void ReleaseAccessor( IUnknown * pUnknown, HACCESSOR hAcc )
{
    IAccessor * pIAccessor = 0;

    SCODE sc = pUnknown->QueryInterface( IID_IAccessor, (void **)&pIAccessor);
    if ( FAILED( sc ) || pIAccessor == 0 )
    {
        LogFail( "IUnknown::QueryInterface for IAccessor returned 0x%lx\n", sc );
    }

    ULONG cRef;
    sc = pIAccessor->ReleaseAccessor( hAcc, &cRef );
    pIAccessor->Release();

    if (S_OK != sc)
    {
        LogFail( "IAccessor->ReleaseAccessor returned 0x%lx\n", sc);
    }
    if (0 != cRef)
    {
        LogFail( "IAccessor->ReleaseAccessor not last ref: %d\n", cRef);
    }
}

#if defined( DO_NOTIFICATION )
class CNotifyAsynch : public IDBAsynchNotify
{
    public:
        CNotifyAsynch() :
            _fChecking(FALSE),
            _fComplete(FALSE),
            _cRef(1)
        {}

        ~CNotifyAsynch()
        {
            if (_fChecking)
            {
                if (1 != _cRef) // NOTE: notify objects are static allocated
                {
                    LogError( "Bad refcount on CNotifyAsynch.\n" );
                }
            }
        }

        void DoChecking(BOOL fChecking)
        {
            _fChecking = fChecking;
        }

        //
        // IUnknown methods.
        //

        STDMETHOD(QueryInterface) (THIS_ REFIID riid,LPVOID *ppiuk)
            {
                *ppiuk = (void **) this; // hold our breath and jump
                AddRef();
                return S_OK;
            }

        STDMETHOD_(ULONG, AddRef) (THIS)
            { return ++_cRef; }

        STDMETHOD_(ULONG, Release) (THIS)
            { return --_cRef; }

        //
        // IDBAsynchNotify methods
        //

        STDMETHOD(OnLowResource) (THIS_ DB_DWRESERVE dwReserved)
        {
            return S_OK;
        }

        STDMETHOD(OnProgress) (THIS_ HCHAPTER hChap, DBASYNCHOP ulOp,
                               DBCOUNTITEM ulProg, DBCOUNTITEM ulProgMax,
                               DBASYNCHPHASE ulStat, LPOLESTR pwszStatus )
        {
            if (ulProg == ulProgMax)
                _fComplete = TRUE;
            return S_OK;
        }

        STDMETHOD(OnStop) (THIS_ HCHAPTER hChap, ULONG ulOp,
                           HRESULT hrStat, LPOLESTR pwszStatus )
        {
            return S_OK;
        }

        BOOL IsComplete(void)
            { return _fComplete; }

    private:
        ULONG _cRef;
        BOOL _fChecking;
        BOOL _fComplete;
};
#endif //defined( DO_NOTIFICATION )

//+-------------------------------------------------------------------------
//
//  Function:   WaitForCompletion, public
//
//  Synopsis:   Loops until query is finished
//
//  Arguments:  [pRowset] -- Table cursor to wait for
//
//  Returns:    TRUE if successful
//
//  History:    30 Jun 94       AlanW     Created
//
//--------------------------------------------------------------------------

int WaitForCompletion( IRowset *pRowset, BOOL fQuiet )
{
    IDBAsynchStatus * pRowsetAsynch = 0;

    SCODE sc = pRowset->QueryInterface( IID_IDBAsynchStatus,
                                        (void **)&pRowsetAsynch);
    if ( sc == E_NOINTERFACE )
        return TRUE;

    if ( FAILED( sc ) || pRowsetAsynch == 0 )
    {
        LogError( "IRowset::QueryInterface for IDBAsynchStatus returned 0x%lx\n", sc );
        return( FALSE );
    }

    if (! fQuiet)
        LogProgress( "  Waiting for query to complete" );

    time( &tstart );
    ULONG ulSleep = 25;

    BOOL fDone = FALSE;

#if defined( DO_NOTIFICATION )
    IConnectionPoint *pConnectionPoint = 0;
    DWORD dwAdviseID = 0;

    CNotifyAsynch Notify;

    Notify.DoChecking(TRUE);

    //
    // Get the connection point container
    //

    IConnectionPointContainer *pConnectionPointContainer = 0;
    sc = pRowset->QueryInterface(IID_IConnectionPointContainer,
                                 (void **) &pConnectionPointContainer);
    if (FAILED(sc))
    {
        LogError( "IRowset->QI for IConnectionPointContainer failed: 0x%x\n",
                sc );
        pRowset->Release();
        Fail();
    }

    //
    // Make a connection point from the connection point container
    //

    sc = pConnectionPointContainer->FindConnectionPoint(
             IID_IDBAsynchNotify,
             &pConnectionPoint);

    if (FAILED(sc) && CONNECT_E_NOCONNECTION != sc )
    {
        LogError( "FindConnectionPoint failed: 0x%x\n",sc );
        pRowset->Release();
        Fail();
    }

    pConnectionPointContainer->Release();

    if (0 != pConnectionPoint)
    {
        //
        // Give a callback object to the connection point
        //

        sc = pConnectionPoint->Advise((IUnknown *) &Notify,
                                      &dwAdviseID);
        if (FAILED(sc))
        {
            LogError( "IConnectionPoint->Advise failed: 0x%x\n",sc );
            pConnectionPoint->Release();
            pRowset->Release();
            Fail();
        }
    }
#endif // DO_NOTIFICATION

    do
    {
#if defined( DO_NOTIFICATION )
       fDone = Notify.IsComplete( );
#else // ! defined( DO_NOTIFICATION )
        ULONG ulDen,ulNum,ulPhase;
        sc = pRowsetAsynch->GetStatus( DB_NULL_HCHAPTER, DBASYNCHOP_OPEN,
                                       &ulNum, &ulDen, &ulPhase, 0 );

        if ( FAILED( sc ) )
        {
            LogError( "IDBAsynchStatus::GetStatus returned 0x%lx\n", sc );
            break;
        }

        fDone = (ulDen == ulNum);

        if ( fDone   && ulPhase != DBASYNCHPHASE_COMPLETE ||
             ! fDone && ulPhase != DBASYNCHPHASE_POPULATION )
        {
            LogError( "IDBAsynchStatus::GetStatus returned invalid ulPhase %d\n", ulPhase );
            break;
        }
#endif // DO_NOTIFICATION

        if (fDone)
            break;

        if ( !CheckTime() )
        {
            LogError( "\nQuery took too long to complete.\n" );
            break;
        }

        if (! fQuiet)
            LogProgress( "." );
        Sleep( ulSleep );
#if 1
        ulSleep *= 2;
        if (ulSleep > MAXWAITTIME * 1000)
            ulSleep = MAXWAITTIME * 1000;
#else
        ulSleep = 500;
#endif

    } while ( ! fDone );

#if defined( DO_NOTIFICATION )
    if ( 0 != pConnectionPoint )
    {
        //
        // Clean up notification stuff
        //

        sc = pConnectionPoint->Unadvise(dwAdviseID);

        if (S_OK != sc)
        {
            LogError( "IConnectionPoint->Unadvise returned 0x%lx\n",sc);
            pRowset->Release();
            Fail();
        }

        pConnectionPoint->Release();
        //Notify.Release();
    }
#endif // DO_NOTIFICATION
    pRowsetAsynch->Release();

    if (fVerbose && !fQuiet)
    {
        //
        // Was it a long-running query?  If so, report how long.
        //
        time_t tend;
        time( &tend );

        if ( difftime( tend, tstart ) >= MINREPORTTIME )
            LogProgress( "Query took %d seconds to complete.",
                        (LONG)difftime(tend, tstart) );
        LogProgress("\n");
    }
    return fDone;
} //WaitForCompletion

//+-------------------------------------------------------------------------
//
//  Function:   Delnode, private
//
//  Synopsis:   Deletes a directory recursively.
//
//  Arguments:  [wcsDir] -- Directory to kill
//
//  Returns:    ULONG - error code if failure
//
//  History:    22-Jul-92 KyleP     Created
//              06 May 1995 AlanW   Made recursive, and more tolerant of
//                                  errors in case of interactions with
//                                  CI filtering.
//
//--------------------------------------------------------------------------

ULONG Delnode( WCHAR const * wcsDir )
{
    WIN32_FIND_DATA finddata;
    WCHAR wcsBuffer[MAX_PATH];

    wcscpy( wcsBuffer, wcsDir );
    wcscat( wcsBuffer, L"\\*.*" );

    HANDLE hFindFirst = FindFirstFile( wcsBuffer, &finddata );

    while( hFindFirst != INVALID_HANDLE_VALUE )
    {
        //
        // Look for . and ..
        //

        if ( ! (finddata.cFileName[0] == '.' &&
               (finddata.cFileName[1] == 0 ||
                 (finddata.cFileName[1] == '.' &&
                   finddata.cFileName[2] == 0 ) ) ) )
        {
            wcscpy( wcsBuffer, wcsDir );
            wcscat( wcsBuffer, L"\\");
            wcscat( wcsBuffer, finddata.cFileName );

            if ( finddata.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
                Delnode( wcsBuffer);
            else if ( !DeleteFile( wcsBuffer ) )
            {
                ULONG ulFailure = GetLastError();
                LogError("Error 0x%lx deleting %ws\n", ulFailure, wcsBuffer);
                return (ulFailure == 0) ? 0xFFFFFFFF : ulFailure;
            }
        }

        if ( !FindNextFile( hFindFirst, &finddata ) )
        {
            FindClose( hFindFirst );
            break;
        }
    }

    RemoveDirectory( (WCHAR *)wcsDir );

    // if racing with CI Filtering, retry after a short time
    if (GetLastError() == ERROR_DIR_NOT_EMPTY)
    {
        Sleep(2 * 1000);
        RemoveDirectory( (WCHAR *)wcsDir );
    }

    //
    // Make sure it's removed.
    //

    if ( FindFirstFile( (WCHAR *)wcsDir, &finddata ) != INVALID_HANDLE_VALUE )
    {
        ULONG ulFailure = GetLastError();
        LogError("Error 0x%lx removing directory %ws\n", ulFailure, wcsDir);
        return (ulFailure == 0) ? 0xFFFFFFFF : ulFailure;
    }
    return 0;
} //Delnode


//+-------------------------------------------------------------------------
//
//  Function:   BuildFile, private
//
//  Synopsis:   Creates a file and fills it with data.
//
//  Arguments:  [wcsFile] -- Path to file.
//              [data]    -- Contents of file.
//              [cb]      -- Size in bytes of [data]
//
//  History:    22-Jul-92 KyleP     Created
//
//--------------------------------------------------------------------------

void BuildFile( WCHAR const * wcsFile, char const * data, ULONG cb )
{
    ULONG mode = CREATE_NEW;

    HANDLE hFile = CreateFile( (WCHAR *)wcsFile,
                               GENERIC_WRITE,
                               0,
                               0,
                               mode,
                               0,
                               0 );

    if ( hFile == INVALID_HANDLE_VALUE )
    {
        LogError( "Error 0x%lx opening file %ws\n", GetLastError(), wcsFile );
        CantRun();
    }

    ULONG ulWritten;

    if ( !WriteFile( hFile, data, cb, &ulWritten, 0 ) ||
         ulWritten != cb )
    {
        LogError( "Error 0x%lx writing file %ws\n", GetLastError(), wcsFile );
        CantRun();
    }

    if ( !CloseHandle( hFile ) )
    {
        LogError( "Error 0x%lx closing file %ws\n", GetLastError(), wcsFile );
        CantRun();
    }
} //BuildFile


//+-------------------------------------------------------------------------
//
//  Function:   CantRun, private
//
//  Synopsis:   Prints a "Can't Run" message and exits.
//
//  History:    09 Oct 1995   Alanw     Created
//
//--------------------------------------------------------------------------

void CantRun()
{
    printf( "%s: CAN'T RUN\n", ProgName );
    if (! _isatty(_fileno(stdout)) )
        fprintf( stderr, "%s: CAN'T RUN\n", ProgName );

//  CIShutdown();
    CoUninitialize();
    exit( 2 );
} //Fail


//+-------------------------------------------------------------------------
//
//  Function:   Fail, private
//
//  Synopsis:   Prints a failure message and exits.
//
//  History:    22-Jul-92 KyleP     Created
//
//--------------------------------------------------------------------------

void Fail()
{
    printf( "%s: FAILED\n", ProgName );
    if (! _isatty(_fileno(stdout)) )
        fprintf( stderr, "%s: FAILED\n", ProgName );

//  CIShutdown();
    CoUninitialize();
    exit( 1 );
} //Fail



//+-------------------------------------------------------------------------
//
//  Function:   LogProgress, public
//
//  Synopsis:   Prints a verbose-mode message.
//
//  Arguments:  [pszfmt] -- Format string
//
//  History:    13-Jul-93 KyleP     Created
//
//--------------------------------------------------------------------------

void LogProgress( char const * pszfmt, ... )
{
    if ( fVerbose )
    {
        va_list pargs;

        va_start(pargs, pszfmt);
        vprintf( pszfmt, pargs );
        va_end(pargs);
    }
} //LogProgress


//+-------------------------------------------------------------------------
//
//  Function:   LogError, public
//
//  Synopsis:   Prints a verbose-mode message.
//
//  Arguments:  [pszfmt] -- Format string
//
//  History:    13-Jul-93 KyleP     Created
//
//--------------------------------------------------------------------------

static fLogError = TRUE;

void LogError( char const * pszfmt, ... )
{
    if ( fVerbose || fLogError )
    {
        fLogError = FALSE;      // print only first error if non-verbose

        va_list pargs;

        va_start(pargs, pszfmt);
        vprintf( pszfmt, pargs );
        va_end(pargs);
    }
} //LogError

//+-------------------------------------------------------------------------
//
//  Function:   LogFail, public
//
//  Synopsis:   Prints a verbose-mode message and fails the drt
//
//  Arguments:  [pszfmt] -- Format string
//
//  History:    3-Apr-95 dlee     Created
//
//--------------------------------------------------------------------------

void LogFail( char const * pszfmt, ... )
{
    if ( fVerbose || fLogError )
    {
        va_list pargs;

        va_start(pargs, pszfmt);
        vprintf( pszfmt, pargs );
        va_end(pargs);
    }

    Fail();
} //LogFail


//+-------------------------------------------------------------------------
//
//  Function:   FormatGuid, public
//
//  Synopsis:   Formats a guid in standard form
//
//  Arguments:  [pszfmt] -- Format string
//
//  Returns:    PWSTR - pointer to formatted guid
//
//  Notes:      Return value points to static memory.
//
//  History:    12 Sep 1997  AlanW     Created
//
//--------------------------------------------------------------------------

WCHAR * FormatGuid( GUID const & guid )
{
    static WCHAR awchGuid[40];
    StringFromGUID2( guid, awchGuid, sizeof awchGuid / sizeof WCHAR );
    return awchGuid;
} //FormatGuid


BOOL CheckTime()
{
    if ( fTimeout )
    {
        time_t tend;

        //
        // Did we run out of time?
        //

        time( &tend );

        return ( difftime( tend, tstart ) <= MAXTIME );

    }
    else
    {
        return( TRUE );
    }
} //CheckTime

/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

#if defined(UNIT_TEST)

//+-------------------------------------------------------------------------
//
//  Class:      CCompareDBValues
//
//  Purpose:    Compares oledb values.
//
//  History:    25-May-95 dlee     Created
//
//--------------------------------------------------------------------------

class CCompareDBValues : INHERIT_UNWIND
{
    INLINE_UNWIND( CCompareDBValues )

public:

    CCompareDBValues() : _aColComp( 0 ), _cColComp( 0 )
        { END_CONSTRUCTION( CCompareDBValues ); }

    ~CCompareDBValues() { delete _aColComp; }

    void Init( int              cCols,
               CSortSet const * psort,
               DBTYPEENUM *     aTypes );

    inline BOOL IsEmpty() { return( _aColComp == 0 ); }

    BOOL IsLT( BYTE ** rows1, ULONG *acb1, BYTE **rows2, ULONG *acb2 );
    BOOL IsGT( BYTE ** rows1, ULONG *acb1, BYTE **rows2, ULONG *acb2 );
    BOOL IsEQ( BYTE ** rows1, ULONG *acb1, BYTE **rows2, ULONG *acb2 );

private:

    struct SColCompare
    {
        ULONG _dir;                     // Direction
        ULONG _pt;                      // Property type (matches fns below)

        //
        // LE/GE are a bit of a misnomer.  If the sort order for a column
        // is reversed ( large to small ) then LE is really GE and
        // vice-versa.
        //

        FDBCmp _comp;
        int _DirMult;                   // -1 if directions reversed.
    };

    UINT          _cColComp;
    SColCompare * _aColComp;
};

//+-------------------------------------------------------------------------
//
//  Member:     CCompareDBValues::Init, public
//
//  Synopsis:   [Re] Initializes property comparator to use a different
//              sort order.
//
//  Arguments:  [cCols]     -- Count of columns
//              [pSort]     -- Sort keys
//              [aTypes]    -- Data types of each column to be compared
//
//  History:    25-May-95   dlee     Created
//
//--------------------------------------------------------------------------

void CCompareDBValues::Init( int              cCols,
                             CSortSet const * pSort,
                             DBTYPEENUM *     aTypes )
{
    delete _aColComp;
    _aColComp = 0;

    if ( cCols > 0 )
    {
        _cColComp = cCols;
        _aColComp = new SColCompare[ _cColComp ];

        for ( unsigned i = 0; i < _cColComp; i++ )
        {
            _aColComp[i]._dir = pSort->Get(i).dwOrder;
            _aColComp[i]._DirMult =
                ( ( _aColComp[i]._dir & QUERY_SORTDESCEND ) != 0 ) ? -1 : 1;
            _aColComp[i]._pt = aTypes[i];
            _aColComp[i]._comp = VariantCompare.GetDBComparator( aTypes[i] );
        }
    }
} //Init

//+-------------------------------------------------------------------------
//
//  Member:     CCompareDBValues::IsLT, public
//
//  Synopsis:   Compares two rows (property sets).
//
//  Arguments:  [row1] -- First row.
//              [row2] -- Second row.
//
//  Returns:    TRUE if [row1] < [row2].
//
//  History:    25-May-95   dlee     Created
//
//--------------------------------------------------------------------------

BOOL CCompareDBValues::IsLT(
    BYTE ** row1,
    ULONG * acb1,
    BYTE ** row2,
    ULONG * acb2 )
{
    //Win4Assert( !IsEmpty() );

    int iLT = 0;

    for ( unsigned i = 0; 0 == iLT && i < _cColComp; i++ )
    {
        if ( 0 != _aColComp[i]._comp )
            iLT = _aColComp[i]._comp( row1[i],
                                      acb1[i],
                                      row2[i],
                                      acb2[i] ) *
                  _aColComp[i]._DirMult;
        else
            LogFail("islt has no comparator!\n");
    }

    return ( iLT < 0 );
} //IsLT

//+-------------------------------------------------------------------------
//
//  Member:     CCompareDBValues::IsGT, public
//
//  Synopsis:   Compares two rows (property sets).
//
//  Arguments:  [row1] -- First row.
//              [row2] -- Second row.
//
//  Returns:    TRUE if [row1] > [row2].
//
//  History:    25-May-95   dlee     Created
//
//--------------------------------------------------------------------------

BOOL CCompareDBValues::IsGT(
    BYTE ** row1,
    ULONG * acb1,
    BYTE ** row2,
    ULONG * acb2 )
{
    //Win4Assert( !IsEmpty() );

    int iGT = 0;

    for ( unsigned i = 0; 0 == iGT && i < _cColComp; i++ )
    {
        if ( 0 != _aColComp[i]._comp )
            iGT = _aColComp[i]._comp( row1[i],
                                      acb1[i],
                                      row2[i],
                                      acb2[i] ) *
                  _aColComp[i]._DirMult;
    }

    return ( iGT > 0 );
} //IsGT

//+-------------------------------------------------------------------------
//
//  Member:     CCompareDBValues::IsEQ, public
//
//  Synopsis:   Compares two rows (property sets).
//
//  Arguments:  [row1] -- First row.
//              [row2] -- Second row.
//
//  Returns:    TRUE if [row1] == [row2].
//
//  History:    25-May-95   dlee     Created
//
//--------------------------------------------------------------------------

BOOL CCompareDBValues::IsEQ(
    BYTE ** row1,
    ULONG * acb1,
    BYTE ** row2,
    ULONG * acb2 )
{
    //Win4Assert( !IsEmpty() );

    int iEQ = 0;

    for ( unsigned i = 0; 0 == iEQ && i < _cColComp; i++ )
    {
        if ( 0 != _aColComp[i]._comp )
            iEQ = _aColComp[i]._comp( row1[i],
                                      acb1[i],
                                      row2[i],
                                      acb2[i] );
    }

    return ( iEQ == 0 );
} //IsEQ

struct SSortTestRow
{
    PROPVARIANT vI4;             // variant:  i4
    PROPVARIANT vV_I4;           // variant:  i4 vector
    DBVECTOR    aI4;             // dbvector: i4
    WCHAR       aWSTR[20];       // inline:   wstr
    WCHAR *     pWSTR;           // inline:   byref wstr
    PROPVARIANT vLPWSTR;         // variant:  lpwstr
    PROPVARIANT vV_LPWSTR;       // variant:  lpwstr vector
    DBVECTOR    aLPWSTR;         // dbvector: byref wstr
    int         i;               // inline:   i4
};

long ai4[] = { 3, 7, 9 };
LPWSTR alpwstr[] = { L"one", L"two", L"three" };

void InitTest( SSortTestRow &s )
{
    s.vI4.vt = VT_I4;
    s.vI4.lVal = 4;

    s.vV_I4.vt = VT_VECTOR | VT_I4;
    s.vV_I4.cal.cElems = 3;
    s.vV_I4.cal.pElems = ai4;

    s.aI4.size = 3;
    s.aI4.ptr = ai4;

    s.aWSTR[0] = L'h';
    s.aWSTR[1] = L'e';
    s.aWSTR[2] = L'l';

    s.pWSTR = L"yello";

    s.vLPWSTR.vt = VT_LPWSTR;
    s.vLPWSTR.pwszVal = L"green";

    s.vV_LPWSTR.vt = VT_VECTOR | VT_LPWSTR;
    s.vV_LPWSTR.calpwstr.cElems = 3;
    s.vV_LPWSTR.calpwstr.pElems = alpwstr;

    s.aLPWSTR.size = 3;
    s.aLPWSTR.ptr = alpwstr;
} //InitTest

SSortTestRow sr1,sr2,sr3;

BYTE * apr1[] =
{
    { (BYTE *) & sr1.vI4 },
    { (BYTE *) & sr1.vV_I4 },
    { (BYTE *) & sr1.aI4 },
    { (BYTE *) & sr1.aWSTR },
    { (BYTE *) & sr1.pWSTR },
    { (BYTE *) & sr1.vLPWSTR },
    { (BYTE *) & sr1.vV_LPWSTR },
    { (BYTE *) & sr1.aLPWSTR },
    { (BYTE *) & sr1.i },
};

BYTE * apr2[] =
{
    { (BYTE *) & sr2.vI4 },
    { (BYTE *) & sr2.vV_I4 },
    { (BYTE *) & sr2.aI4 },
    { (BYTE *) & sr2.aWSTR },
    { (BYTE *) & sr2.pWSTR },
    { (BYTE *) & sr2.vLPWSTR },
    { (BYTE *) & sr2.vV_LPWSTR },
    { (BYTE *) & sr2.aLPWSTR },
    { (BYTE *) & sr2.i },
};

BYTE * apr3[] =
{
    { (BYTE *) & sr3.vI4 },
    { (BYTE *) & sr3.vV_I4 },
    { (BYTE *) & sr3.aI4 },
    { (BYTE *) & sr3.aWSTR },
    { (BYTE *) & sr3.pWSTR },
    { (BYTE *) & sr3.vLPWSTR },
    { (BYTE *) & sr3.vV_LPWSTR },
    { (BYTE *) & sr3.aLPWSTR },
    { (BYTE *) & sr3.i },
};

DBTYPEENUM aEnum[] =
{
    { DBTYPE_VARIANT },
    { DBTYPE_VARIANT },
    { (DBTYPEENUM) (DBTYPE_VECTOR | DBTYPE_I4) },
    { DBTYPE_WSTR },
    { (DBTYPEENUM) (DBTYPE_BYREF | DBTYPE_WSTR) },
    { DBTYPE_VARIANT },
    { DBTYPE_VARIANT },
    { (DBTYPEENUM) (DBTYPE_VECTOR | DBTYPE_BYREF | DBTYPE_WSTR) },
    { DBTYPE_I4 },
};

ULONG aLen[] =
{
    0,
    0,
    0,
    6,
    0,
    0,
    0,
    0,
};

const ULONG cArray = sizeof aEnum / sizeof DBTYPEENUM;

void DBSortTest()
{
    InitTest( sr1 );
    sr1.i = 1;

    InitTest( sr2 );
    sr2.i = 2;

    InitTest( sr3 );
    sr3.i = 3;

    CSortSet ss( cArray );

    SSortKey sk = { 0, 0, 0 };

    for (unsigned x = 0; x < cArray; x++)
        ss.Add( sk, x );

    CCompareDBValues c;

    c.Init( cArray, &ss, aEnum );

    BOOL fLT = c.IsLT( apr1, aLen, apr2, aLen );

    if (!fLT)
        LogFail("compare test 1 failed\n");

    fLT = c.IsLT( apr2, aLen, apr1, aLen );

    if (fLT)
        LogFail("compare test 2 failed\n");


} //DBSortTest

#endif // UNIT_TEST


BOOL SetBooleanProperty ( ICommand * pCmd, DBPROPID dbprop, VARIANT_BOOL f )
{
    ICommandProperties * pCmdProp;

    SCODE sc = pCmd->QueryInterface( IID_ICommandProperties, (void **) &pCmdProp );

    if ( FAILED( sc ) )
    {
         LogError( "Error 0x%x from QI for ICommandProperties\n", sc );
         return sc;
    }

    DBPROPSET  aPropSet[1];
    DBPROP     aProp[1];

    aProp[0].dwPropertyID   = dbprop;
    aProp[0].dwOptions      = DBPROPOPTIONS_REQUIRED;
    aProp[0].dwStatus       = 0;         // Ignored
    aProp[0].colid          = dbcolNull;
    aProp[0].vValue.vt      = VT_BOOL;
    aProp[0].vValue.boolVal = f;

    aPropSet[0].rgProperties = &aProp[0];
    aPropSet[0].cProperties = 1;
    aPropSet[0].guidPropertySet = DBPROPSET_ROWSET;

    sc = pCmdProp->SetProperties( 1, aPropSet );
    pCmdProp->Release();

    if ( FAILED(sc) )
        LogError( "ICommandProperties::SetProperties returned 0x%x\n", sc );

    return sc;
}


SCODE SetScopeProperties( ICommand * pCmd,
                          unsigned cDirs,
                          WCHAR const * const * apDirs,
                          ULONG const *  aulFlags,
                          WCHAR const * const * apCats,
                          WCHAR const * const * apMachines )
{
    ICommandProperties * pCmdProp;

    SCODE sc = pCmd->QueryInterface( IID_ICommandProperties, (void **) &pCmdProp );

    if ( FAILED( sc ) )
    {
         LogError( "Error 0x%x from QI for ICommandProperties\n", sc );
         return sc;
    }

    BSTR abDirs[10];
    if ( 0 != apDirs )
        for ( unsigned i = 0; i < cDirs; i++ )
            abDirs[i] = SysAllocString( apDirs[i] );

    BSTR abCats[10];
    if ( 0 != apCats )
        for ( unsigned i = 0; i < cDirs; i++ )
            abCats[i] = SysAllocString( apCats[i] );

    BSTR abMachines[10];
    if ( 0 != apMachines )
        for ( unsigned i = 0; i < cDirs; i++ )
            abMachines[i] = SysAllocString( apMachines[i] );

    //
    // Cheating here.  Big time. These aren't really BSTRs, but I also know the
    // size before the string won't be referenced.  By ::SetProperties.
    //

    SAFEARRAY saScope = { 1,                      // Dimension
                          FADF_AUTO | FADF_BSTR,  // Flags: on stack, contains BSTRs
                          sizeof(BSTR),           // Size of an element
                          1,                      // Lock count.  1 for safety.
                          (void *)abDirs,         // The data
                          { cDirs, 0 } };         // Bounds (element count, low bound)

    SAFEARRAY saDepth = { 1,                      // Dimension
                          FADF_AUTO,              // Flags: on stack
                          sizeof(LONG),           // Size of an element
                          1,                      // Lock count.  1 for safety.
                          (void *)aulFlags,       // The data
                          { cDirs, 0 } };         // Bounds (element count, low bound)

    SAFEARRAY saCatalog = { 1,                    // Dimension
                            FADF_AUTO | FADF_BSTR,// Flags: on stack, contains BSTRs
                            sizeof(BSTR),         // Size of an element
                            1,                    // Lock count.  1 for safety.
                            (void *)abCats,       // The data
                            { cDirs, 0 } };       // Bounds (element count, low bound)

    SAFEARRAY saMachine = { 1,                    // Dimension
                            FADF_AUTO | FADF_BSTR,// Flags: on stack, contains BSTRs
                            sizeof(BSTR),         // Size of an element
                            1,                    // Lock count.  1 for safety.
                            (void *)abMachines,   // The data
                            { cDirs, 0 } };       // Bounds (element count, low bound)

    DBPROP    aQueryPropsScopeOnly[2] = { { DBPROP_CI_INCLUDE_SCOPES, 0, DBPROPSTATUS_OK, {0, 0, 0}, { VT_BSTR | VT_ARRAY, 0, 0, 0, (LONG_PTR)&saScope } },
                                          { DBPROP_CI_DEPTHS        , 0, DBPROPSTATUS_OK, {0, 0, 0}, { VT_I4   | VT_ARRAY, 0, 0, 0, (LONG_PTR)&saDepth } } };

    DBPROPSET QueryPropsetScopeOnly = { aQueryPropsScopeOnly, 2, DBPROPSET_FSCIFRMWRK_EXT };

    DBPROP    aQueryProps[3] = { { DBPROP_CI_INCLUDE_SCOPES ,   0, DBPROPSTATUS_OK, {0, 0, 0}, { VT_BSTR | VT_ARRAY, 0, 0, 0, (LONG_PTR)&saScope } },
                                 { DBPROP_CI_DEPTHS         ,   0, DBPROPSTATUS_OK, {0, 0, 0}, { VT_I4   | VT_ARRAY, 0, 0, 0, (LONG_PTR)&saDepth } },
                                 { DBPROP_CI_CATALOG_NAME   ,   0, DBPROPSTATUS_OK, {0, 0, 0}, { VT_BSTR | VT_ARRAY, 0, 0, 0, (LONG_PTR)&saCatalog } } };


    DBPROP    aCoreProps[1]  = { { DBPROP_MACHINE ,   0, DBPROPSTATUS_OK, {0, 0, 0}, { VT_BSTR | VT_ARRAY, 0, 0, 0, (LONG_PTR)&saMachine } } };

    DBPROPSET aAllPropsets[2] = {  {aQueryProps, 3, DBPROPSET_FSCIFRMWRK_EXT   } ,
                                   {aCoreProps , 1, DBPROPSET_CIFRMWRKCORE_EXT } };

    if ( 0 == apCats || 0 == apMachines )
        sc = pCmdProp->SetProperties( 1, &QueryPropsetScopeOnly );
    else
        sc = pCmdProp->SetProperties( 2, aAllPropsets );

    if ( 0 != apMachines )
        for ( unsigned i = 0; i < cDirs; i++ )
            SysFreeString( abMachines[i] );

    if ( 0 != apCats )
        for ( unsigned i = 0; i < cDirs; i++ )
            SysFreeString( abCats[i] );

    if ( 0 != apDirs )
        for ( unsigned i = 0; i < cDirs; i++ )
            SysFreeString( abDirs[i] );

    pCmdProp->Release();

    if ( FAILED(sc) )
        LogError( "ICommandProperties::SetProperties returned 0x%x\n", sc );

    return sc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\txtfilt\exports.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994
//
//  File:       exports.cxx
//
//  Contents:   Code to export filter and word breaker class factories
//
//  History:    15-Aug-1994     SitaramR   Created
//
//  Notes:      Copied from txtifilt.hxx and then modified
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <nullfilt.hxx>
#include <txtifilt.hxx>
#include <defbreak.hxx>
#include <classf.hxx>
#include <cicontrl.hxx>

#include "classid.hxx"

long gulcInstances = 0;

//+-------------------------------------------------------------------------
//
//  Function:   DllGetClassObject
//
//  Synopsis:   Ole DLL load class routine
//
//  Arguments:  [cid]    -- Class to load
//              [iid]    -- Interface to bind to on class object
//              [ppvObj] -- Interface pointer returned here
//
//  Returns:    Text filter or a word breaker class factory
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

extern "C" SCODE STDMETHODCALLTYPE DllGetClassObject( REFCLSID   cid,
                                                      REFIID     iid,
                                                      void **    ppvObj )
{
    IUnknown *  pResult;
    SCODE       sc      = S_OK;

    TRY
    {
        if ( CLSID_CTextIFilter == cid || CLSID_CTextClass == cid ) {
            
            pResult = (IUnknown *)new CTextIFilterCF;
        
        } else if ( CLSID_CNullIFilter == cid ) {
            
            pResult = (IUnknown *)new CNullIFilterCF;
        
        } else if ( CLSID_Neutral_WBreaker == cid ) {
            
            pResult = (IUnknown *)new CDefWordBreakerCF;
        
        } else if ( guidStorageFilterObject == cid) {
            
            pResult = (IUnknown *) new CStorageFilterObjectCF;
        
        } else if ( guidStorageDocStoreLocatorObject == cid) {
            
            pResult = (IUnknown *) new CStorageDocStoreLocatorObjectCF;
        
        } else if ( clsidCiControl == cid) {            
            pResult = (IUnknown *) new CCiControlObjectCF;
        } else {
            
            ciDebugOut(( DEB_ITRACE, "DllGetClassObject: no such interface found\n" ));
            pResult = 0;
            sc = E_NOINTERFACE;
        
        }
    }
    CATCH(CException, e)
    {
        switch( e.GetErrorCode() )
        {
        case E_OUTOFMEMORY:
            sc = (E_OUTOFMEMORY);
            break;
        default:
            sc = (E_UNEXPECTED);
        }
    }
    END_CATCH;

    if (0 != pResult) {
        sc = pResult->QueryInterface( iid, ppvObj );
        pResult->Release( );
    }

    return (sc);
}

//+-------------------------------------------------------------------------
//
//  Method:     DllCanUnloadNow
//
//  Synopsis:   Notifies DLL to unload (cleanup global resources)
//
//  Returns:    S_OK if it is acceptable for caller to unload DLL.
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

extern "C" SCODE STDMETHODCALLTYPE DllCanUnloadNow( void )
{
    if ( gulcInstances <= 0 )
        return( S_OK );
    else
        return( S_FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\txtfilt\mmscbuf.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1998
//
//  File:       mmscbuf.cxx
//
//  Contents:   Memory Mapped Stream buffer for consecutive buffer mapping
//
//  Classes:    CMmStreamConsecBuf
//
//  History:    22-Jul-93 AmyA      Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <mmscbuf.hxx>

//+-------------------------------------------------------------------------
//
//  Member:     CMmStreamConsecBuf::CMmStreamConsecBuf, public
//
//  Synopsis:   Constructor
//
//  History:    22-Jul-93 AmyA      Created
//
//--------------------------------------------------------------------------

CMmStreamConsecBuf::CMmStreamConsecBuf()
: _pMmStream(0)
{
    _liOffset.QuadPart = 0;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMmStreamConsecBuf::Map, public
//
//  Synopsis:   Map next consecutive part of file
//
//  Arguments:  [cb] -- size of the mapped area
//
//  History:    22-Jul-93 AmyA      Created
//
//--------------------------------------------------------------------------

void CMmStreamConsecBuf::Map( ULONG cb )
{
    Win4Assert( 0 != _pMmStream );

    if ( Get() != 0 )
        _pMmStream->Unmap( *this );

    LARGE_INTEGER liNewOffset;
    LARGE_INTEGER liStreamSize={_pMmStream->SizeLow(), _pMmStream->SizeHigh()};

     liNewOffset.QuadPart = cb + _liOffset.QuadPart;

    if ( liNewOffset.QuadPart > liStreamSize.QuadPart )
    {
        cb = (ULONG)(liStreamSize.QuadPart - _liOffset.QuadPart);
        liNewOffset = liStreamSize;
    }

    _pMmStream->Map( *this,
                     cb,
                     _liOffset.LowPart,
                     _liOffset.HighPart );

    _liOffset = liNewOffset;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMmStreamConsecBuf::Init, public
//
//  Synopsis:   Initizializes CMmStreamConsecBuf
//
//  Arguments:  [pMmStream] -- pointer to the CMmStream from which to fill
//                             the buffer
//
//  History:    22-Jul-93 AmyA      Created
//
//--------------------------------------------------------------------------

void CMmStreamConsecBuf::Init( PMmStream * pMmStream )
{
    _pMmStream = pMmStream;
    _liOffset.QuadPart = 0;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMmStreamConsecBuf::Rewind, public
//
//  Synopsis:   Rewind file to beginning.
//
//  History:    13-Dec-93 AmyA      Created
//
//--------------------------------------------------------------------------

void CMmStreamConsecBuf::Rewind()
{
    if ( 0 != Get() )
    {
        Win4Assert( 0 != _pMmStream );

        _pMmStream->Unmap( *this );
    }

    _liOffset.QuadPart = 0;
}

//+-------------------------------------------------------------------------
//
//  Member:     CMmStreamConsecBuf::Eof, public
//
//  Synopsis:   Returns whether end of file has been hit
//
//  Returns:    FALSE if there is still more file to be mapped.  TRUE
//              otherwise.
//
//  History:    22-Jul-93 AmyA      Created
//
//--------------------------------------------------------------------------

BOOL CMmStreamConsecBuf::Eof()
{
    Win4Assert( 0 != _pMmStream );
    return( ( (ULONG) _liOffset.HighPart == _pMmStream->SizeHigh() ) &&
            ( _liOffset.LowPart == _pMmStream->SizeLow() ) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\txtfilt\tfilt.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2001.
//
//  File:       TFILT.CXX
//
//  Contents:   Text Filter
//
//  History:    16-Jul-93   AmyA        Created
//              23-Feb-94   KyleP       Cleaned up
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <scode.h>
#include <tfilt.hxx>
#include <pfilter.hxx>
#include <codepage.hxx>

// has to be COMMON_PAGE_SIZE multiple
const ULONG TEXT_FILTER_CHUNK_SIZE = 1 * COMMON_PAGE_SIZE;

GUID const guidStorage  = PSGUID_STORAGE;

extern "C" GUID CLSID_CTextIFilter;

extern ULONG g_cbMaxTextFilter;

//+---------------------------------------------------------------------------
//
//  Member:     CTextIFilter::CTextIFilter, public
//
//  Synopsis:   Constructor
//
//  History:    16-Jul-93   AmyA           Created.
//
//----------------------------------------------------------------------------

CTextIFilter::CTextIFilter( LCID locale )
        : _idChunk(1),
          _bytesReadFromChunk(0),
          _pwszFileName(0),
          _pStream(0),
          _fUniCode(FALSE),
          _fBigEndian(FALSE),
          _fContents(FALSE),
          _fNSS(FALSE),
          _locale(locale),
          _fDBCSSplitChar(FALSE)
{
    //
    // We need a code page for MultiByteToWideChar.
    //
    _ulCodePage = LocaleToCodepage( locale );

    _fDBCSCodePage = IsDBCSCodePage( _ulCodePage );
}

//+---------------------------------------------------------------------------
//
//  Member:     CTextIFilter::~CTextIFilter, public
//
//  Synopsis:   Destructor
//
//  History:    16-Jul-93   AmyA           Created.
//
//----------------------------------------------------------------------------

CTextIFilter::~CTextIFilter()
{
    delete [] _pwszFileName;

    if ( 0 != _pStream )
        _pStream->Release();
}

//+---------------------------------------------------------------------------
//
//  Member:     CTextIFilter::Init, public
//
//  Synopsis:   Initializes instance of text filter
//
//  Arguments:  [grfFlags]    -- Flags for filter behavior
//              [cAttributes] -- Number of strings in array ppwcsAttributes
//              [aAttributes] -- Array of attribute strings
//              [pFlags]      -- Must be zero for Cairo V1
//
//  History:    16-Jul-93   AmyA           Created.
//              23-Feb-94   KyleP          Cleaned up.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CTextIFilter::Init( ULONG grfFlags,
                                            ULONG cAttributes,
                                            FULLPROPSPEC const * aAttributes,
                                            ULONG * pFlags )
{
    SCODE sc = S_OK;

    //
    // Text files only support the 'contents' attribute.
    //

    if( cAttributes > 0 )
    {
        //
        // Known, safe cast
        //

        CFullPropSpec const * pAttrib = (CFullPropSpec const *)aAttributes;

        if ( pAttrib == 0 )
            return E_FAIL;

        for ( ULONG i = 0; i < cAttributes; i++ )
        {
            if ( pAttrib[i].IsPropertyPropid() &&
                 pAttrib[i].GetPropertyPropid() == PID_STG_CONTENTS &&
                 memcmp( &pAttrib[i].GetPropSet(),
                         &guidStorage,
                         sizeof(guidStorage) ) == 0 )
            {
                break;
            }
        }

        if ( i < cAttributes )
            _fContents = TRUE;
        else
            _fContents = FALSE;
    }
    else if ( 0 == grfFlags || (grfFlags & IFILTER_INIT_APPLY_INDEX_ATTRIBUTES) )
    {
        _fContents = TRUE;
    }
    else
        _fContents = FALSE;

    //
    // Open memory-mapped file
    //

    if ( 0 != _pwszFileName )
    {
        if ( _mmStream.Ok() )
        {
            _mmStreamBuf.Rewind();
        }
        else
        {
            if ( !_fNSS )
            {
                TRY
                {
                    _mmStreamBuf.Rewind();
                    _mmStream.Close();
                    _mmStream.Open( _pwszFileName,
                                    GENERIC_READ,
                                    FILE_SHARE_READ,
                                    OPEN_EXISTING );

                    if ( _mmStream.Ok() )
                        _mmStreamBuf.Init( &_mmStream );
                    else
                    {
                        sc = ( STATUS_ACCESS_DENIED == GetLastError() ?   // Open sets the last error
                               FILTER_E_PASSWORD :
                               FILTER_E_ACCESS );
                    }
                }
                CATCH( CException, e )
                {
                    if ( e.GetErrorCode() == HRESULT_FROM_WIN32( ERROR_BAD_EXE_FORMAT ) )
                    {
                        _fNSS = TRUE;
                        sc = S_OK;
                    }
                    else
                    {
                        sc = ( STATUS_ACCESS_DENIED == e.GetErrorCode() ?
                               FILTER_E_PASSWORD :
                               FILTER_E_ACCESS );
                    }
                }
                END_CATCH;
            }
        }
    }

    //
    // ...or, Memory mapped stream
    //

    else if ( 0 != _pStream )
    {
        if ( _mmIStream.Ok() )
        {
            _mmStreamBuf.Rewind();
        }
        else
        {
            TRY
            {
                _mmIStream.Close();
                _mmIStream.Open( _pStream );

                if ( _mmIStream.Ok() )
                    _mmStreamBuf.Init( &_mmIStream );
                else
                {
                    sc = ( STG_E_ACCESSDENIED == GetLastError() ?
                           FILTER_E_PASSWORD :
                           FILTER_E_ACCESS );
                }
            }
            CATCH( CException, e )
            {
                sc = ( STG_E_ACCESSDENIED == e.GetErrorCode() ?
                       FILTER_E_PASSWORD :
                       FILTER_E_ACCESS );
            }
            END_CATCH;
        }
    }

    //
    // Might as well try filtering properties.
    //

    *pFlags = IFILTER_FLAGS_OLE_PROPERTIES;

    //
    // Re-initialize
    //

    _idChunk = 1;
    _bytesReadFromChunk = 0;
    _fDBCSSplitChar = FALSE;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTextIFilter::GetChunk, public
//
//  Synopsis:   Gets the next chunk and returns chunk information in ppStat
//
//  Arguments:  [ppStat] -- for chunk information
//
//  History:    16-Jul-93   AmyA           Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CTextIFilter::GetChunk( STAT_CHUNK * pStat )
{
    //
    // Error checking
    //

    if ( _fNSS )
        return FILTER_E_END_OF_CHUNKS;

    if ( (IsFileBased() && !_mmStream.Ok()) ||
         (IsStreamBased() && !_mmIStream.Ok()) )
        return FILTER_E_ACCESS;

    if ( !_fContents || _mmStreamBuf.Eof() )
        return FILTER_E_END_OF_CHUNKS;

    // Is the file to big?  If so, stop filtering now

    if ( (ULONGLONG) _mmStreamBuf.CurrentOffset() > (ULONGLONG) g_cbMaxTextFilter )
        return FILTER_E_PARTIALLY_FILTERED;

    SCODE sc = S_OK;

    TRY
    {
        _mmStreamBuf.Map( TEXT_FILTER_CHUNK_SIZE );
    }
    CATCH( CException, e )
    {
        return FILTER_E_ACCESS;
    }
    END_CATCH;

    _bytesReadFromChunk = 0;

    //
    // If this is the first time we've touched the file, determine if it
    // is a UniCode or ASCII stream.  The first two bytes of all UniCode
    // plain text streams are 0xff 0xfe
    //

    WCHAR const wcUniCode = 0xfeff;
    WCHAR const wcBigUniCode = 0xfffe;

    if ( _idChunk == 1 )
    {
        //
        // Are there at least two bytes in file?
        //

        if ( _mmStreamBuf.Size() >= 2 )
        {
            if ( *(WCHAR *)(_mmStreamBuf.Get()) == wcUniCode &&
                 _mmStreamBuf.Size() % sizeof(WCHAR) == 0 )
            {
                _fUniCode = TRUE;
                _bytesReadFromChunk += sizeof(WCHAR);
            }
            else if ( *(WCHAR *)(_mmStreamBuf.Get()) == wcBigUniCode &&
                 _mmStreamBuf.Size() % sizeof(WCHAR) == 0 )
            {
                _fUniCode = TRUE;
                _fBigEndian = TRUE;
                _bytesReadFromChunk += sizeof(WCHAR);
            }
            else
                _fUniCode = FALSE;
        }
        else
            _fUniCode = FALSE;
    }

    pStat->idChunk = _idChunk;
    pStat->flags   = CHUNK_TEXT;
    pStat->locale  = _locale;
    pStat->attribute.guidPropSet = guidStorage;
    pStat->attribute.psProperty.ulKind = PRSPEC_PROPID;
    pStat->attribute.psProperty.propid = PID_STG_CONTENTS;
    pStat->breakType = CHUNK_NO_BREAK;
    pStat->idChunkSource = _idChunk;
    pStat->cwcStartSource = 0;
    pStat->cwcLenSource = 0;

    _idChunk++;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTextIFilter::GetText, public
//
//  Synopsis:   Retrieves text from current chunk
//
//  Arguments:  [pcwcBuffer] -- count of UniCode characters in buffer
//              [awcBuffer]  -- buffer for text
//
//  History:    16-Jul-93       AmyA            Created.
//              30-Aug-94       Bartoszm        Rewrote
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CTextIFilter::GetText( ULONG * pcwcOutput,
                                               WCHAR * awcOutput )
{
    if ( 0 == awcOutput || 0 == pcwcOutput )
    { 
        return E_INVALIDARG;  
    }

    if ( !_fContents || _fNSS )
    {
        *pcwcOutput = 0;
        return FILTER_E_NO_MORE_TEXT;
    }

    if ( 0 == *pcwcOutput )
    { 
        if ( _bytesReadFromChunk == _mmStreamBuf.Size() )
        {
            return FILTER_E_NO_MORE_TEXT;
        }

        if ( _fUniCode )
        {
            ULONG ccInput = _mmStreamBuf.Size() - _bytesReadFromChunk;
            ccInput /= sizeof(WCHAR);

            //
            // Handle bogus Unicode file with an odd byte count.
            //

            if ( 0 == ccInput )
            {
                return FILTER_E_NO_MORE_TEXT;
            }
        }
        
        return S_OK;
    }

    if ( _fDBCSSplitChar )
    {
        //
        // Convert DBCS lead byte from the previous mapping and the trail byte (first
        // char) from this mapping to Unicode
        //
        Win4Assert( IsDBCSLeadByteEx( _ulCodePage, _abDBCSInput[0] ) );

        _abDBCSInput[1] = * (BYTE *) _mmStreamBuf.Get();

        if ( 1 == *pcwcOutput )
        {
            //
            // In the DBCS case, output buffer must be bigger than one byte
            //
            return E_INVALIDARG;
        }

        ULONG cwcActual = MultiByteToWideChar( _ulCodePage,
                                               0,
                                               (char *) _abDBCSInput,
                                               2,
                                               awcOutput,
                                               *pcwcOutput );
        if ( cwcActual == 0 )
        {
            //
            // Input buffer is 2 bytes, and output buffer is 2k, hence there
            // should be ample space
            //
            Win4Assert( GetLastError() != ERROR_INSUFFICIENT_BUFFER );

            return E_FAIL;
        }

        *pcwcOutput = cwcActual;
        _bytesReadFromChunk = 1;
        _fDBCSSplitChar = FALSE;

        return S_OK;
    }

    if ( _bytesReadFromChunk == _mmStreamBuf.Size() )
        _fDBCSSplitChar = FALSE;
    else
    {
        _fDBCSSplitChar = _fDBCSCodePage
                          && _bytesReadFromChunk == _mmStreamBuf.Size() - 1
                          && IsDBCSLeadByteEx( _ulCodePage,
                                               *( (BYTE *) _mmStreamBuf.Get()
                                                     + _bytesReadFromChunk ) );
    }

    if ( _bytesReadFromChunk == _mmStreamBuf.Size()
         || _fDBCSSplitChar )
    {
        if ( _fDBCSSplitChar )
        {
            //
            // Store the DBCS lead byte for conversion as part of next chunk.
            // This works across chunks because the chunks are emitted
            // with CHUNK_NO_BREAK break type.
            //
            _abDBCSInput[0] = *( (BYTE *) _mmStreamBuf.Get()
                                             + _bytesReadFromChunk );
        }

        *pcwcOutput = 0;
        return FILTER_E_NO_MORE_TEXT;
    }

    Win4Assert( _mmStreamBuf.Size() >= _bytesReadFromChunk );

    SCODE sc = S_OK;
    ULONG ccInput = _mmStreamBuf.Size() - _bytesReadFromChunk;
    BYTE* pbInput = (BYTE*) _mmStreamBuf.Get() + _bytesReadFromChunk;
    ULONG cwcOutput = *pcwcOutput; // size of the output buffer

    if ( _fUniCode )
    {
        ccInput /= sizeof(WCHAR);

        //
        // Handle bogus Unicode file with an odd byte count.
        //

        if ( 0 == ccInput )
        {
            *pcwcOutput = 0;
            return FILTER_E_NO_MORE_TEXT;
        }
    }

    //
    // ASCII text must be converted to UniCode.
    // UniCode text must be folded into pre-composed characters
    // There is no guarantee about how many UniCode characters it takes
    // to represent a single multi-byte character.  Most of the time, it
    // takes 1 UniCode character to represent 1 ASCII character.
    //
    // MultiByteToWideChar returns 0 and sets LastError to
    // ERROR_INSUFFICIENT_BUFFER if all characters in the input buffer cannot
    // be translated in the output space provided.
    //
    // We'll assume a fairly optimistic target count of 1:1 translations
    // (7/8 of all characters) and deal with the overflow when it occurs.
    //

    // Let's try to convert this many characters from the input buffer

    ULONG cInputChar = 1 + cwcOutput / 2 + cwcOutput / 4 + cwcOutput / 8;


    //
    // Don't overflow
    //

    if (cInputChar > ccInput)
        cInputChar = ccInput;

    //
    // Translate
    //

    ULONG cwcActual = 0;

    do
    {
        if ( _fUniCode )
        {
            if ( _fBigEndian )
            {
                TRY
                {
                    XArray<WCHAR> xTmp( cInputChar );

                    for ( ULONG i = 0; i < cInputChar; i++ )
                        xTmp[i] = MAKEWORD( pbInput[ sizeof WCHAR * i + 1 ],
                                            pbInput[ sizeof WCHAR * i ] );

                    cwcActual = FoldStringW( MAP_PRECOMPOSED,
                                             xTmp.GetPointer(),
                                             cInputChar,
                                             awcOutput,
                                             cwcOutput );

                    ciDebugOut(( DEB_ITRACE, "before %#x, after %#x\n",
                                 pbInput, awcOutput ));
                }
                CATCH( CException, e )
                {
                    sc = e.GetErrorCode();
                    break;
                }
                END_CATCH
            }
            else
            {
                cwcActual = FoldStringW( MAP_PRECOMPOSED,
                                         (WCHAR*) pbInput,
                                         cInputChar,
                                         awcOutput,
                                         cwcOutput );
            }
        }
        else
        {
            //
            // If last char is a DBCS lead byte, then don't convert the last char
            //
            if ( _fDBCSCodePage
                 && IsLastCharDBCSLeadByte( pbInput, cInputChar ) )
            {
                Win4Assert( cInputChar > 1 );
                cInputChar--;
            }

            cwcActual = MultiByteToWideChar( _ulCodePage,
                                             0,
                                             (char*) pbInput,
                                             cInputChar,
                                             awcOutput,
                                             cwcOutput);
        }

        if ( 0 == cwcActual )
        {
            if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER &&
                 cInputChar >= 2 )
            {
                cInputChar /= 2;
            }
            else
            {
                Win4Assert( !"Can't translate single char" );
                sc = E_FAIL;
                break;
            }
        }

    } while ( cwcActual == 0 );

    if ( SUCCEEDED(sc) )
    {
        *pcwcOutput = cwcActual;
        if ( _fUniCode )
            _bytesReadFromChunk += cInputChar * sizeof(WCHAR);
        else
            _bytesReadFromChunk += cInputChar;
    }
    else
        *pcwcOutput = 0;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTextIFilter::GetValue, public
//
//  Synopsis:   No value chunks for plain text.
//
//  History:    16-Jul-93   AmyA           Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CTextIFilter::GetValue( PROPVARIANT ** ppPropValue )
{
    return FILTER_E_NO_VALUES;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTextIFilter::BindRegion, public
//
//  Synopsis:   Creates moniker or other interface for text indicated
//
//  Arguments:  [origPos] -- the region of text to be mapped to a moniker
//              [riid]    -- Interface to bind
//              [ppunk]   -- Output pointer to interface
//
//  History:    16-Jul-93   AmyA           Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CTextIFilter::BindRegion( FILTERREGION origPos,
                                                  REFIID riid,
                                                  void ** ppunk )
{
    return E_NOTIMPL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTextIFilter::GetClassID, public
//
//  Synopsis:   Returns the class id of this class.
//
//  Arguments:  [pClassID] -- the class id
//
//  History:    16-Jul-93   AmyA           Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CTextIFilter::GetClassID( CLSID * pClassID )
{
    *pClassID = CLSID_CTextIFilter;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTextIFilter::IsDirty, public
//
//  Synopsis:   Always returns S_FALSE since this class is read-only.
//
//  History:    16-Jul-93   AmyA           Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CTextIFilter::IsDirty()
{
    return S_FALSE; // Since the filter is read-only, there will never be
                    // changes to the file.
}

//+---------------------------------------------------------------------------
//
//  Function:   WellKnownExtension
//
//  Synopsis:   Checks if the file extension is well-known to the text filter
//
//  Arguments:  [pwcFile]  -- path of the file to be checked
//
//  Returns:    TRUE if the extension is well-known by the text filter
//
//  History:    28-Jul-98   dlee         Created.
//
//----------------------------------------------------------------------------

BOOL WellKnownExtension( WCHAR const * pwcFile )
{
    //
    // All we really care about is .dic and .txt files.  Others have script
    // code that is better broken by the neutral word breaker.
    //

    const WCHAR *aKnownExt[] =
    {
        L"dic",     // MS spell-check custom word dictionary
        L"txt",
//        L"wtx",
//        L"bat",
//        L"cmd",
//        L"idq",
//        L"ini",
//        L"inx",
//        L"reg",
//        L"inf",
//        L"vbs",
    };
    
    const unsigned cKnownExt = sizeof aKnownExt / sizeof aKnownExt[0];

    WCHAR const * pwcExt = wcsrchr( pwcFile, '.' );

    if ( 0 == pwcExt )
        return FALSE;

    pwcExt++;
    unsigned cwc = wcslen( pwcExt );

    // all the entries in the array above are 3 long

    if ( 3 == cwc )
    {
        WCHAR awcExt[ 4 ];

        unsigned cwcOut = LCMapString( LOCALE_NEUTRAL,
                                       LCMAP_LOWERCASE,
                                       pwcExt,
                                       3,
                                       awcExt,
                                       3 );
    
        Win4Assert( 3 == cwcOut );
        awcExt[ 3 ] = 0;

        for ( unsigned i = 0; i < cKnownExt; i++ )
            if ( !wcscmp( awcExt, aKnownExt[i] ) )
                return TRUE;
    }

    return FALSE;
} //WellKnownExtension

//+---------------------------------------------------------------------------
//
//  Member:     CTextIFilter::Load, public
//
//  Synopsis:   Loads the indicated file
//
//  Arguments:  [pszFileName] -- the file name
//              [dwMode] -- the mode to load the file in
//
//  History:    16-Jul-93   AmyA           Created.
//
//  Notes:      dwMode must be either 0 or STGM_READ.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CTextIFilter::Load(LPCWSTR pszFileName, DWORD dwMode)
{
    _fNSS = FALSE;

    if ( 0 != _pStream )
    {
        _pStream->Release();
        _pStream = 0;
        _mmIStream.Close();
    }

    if (_pwszFileName != 0)
    {
        delete _pwszFileName;
        _pwszFileName = 0;
        _mmStreamBuf.Rewind();
        _mmStream.Close();
    }

    SCODE sc = S_OK;
    unsigned cc = 0;

    TRY
    {
        //
        // If it's a file the text filter knows how to filter, use the
        // default system locale.  Otherwise, use the neutral locale.
        //

        LCID lcid = MAKELCID( MAKELANGID( LANG_NEUTRAL, SUBLANG_NEUTRAL ),
                              SORT_DEFAULT );

        if ( WellKnownExtension( pszFileName ) )
            lcid = GetSystemDefaultLCID();

        if ( _locale != lcid )
        {
            _locale = lcid;
            _ulCodePage = LocaleToCodepage( _locale );
            _fDBCSCodePage = IsDBCSCodePage( _ulCodePage );
        }

        cc = wcslen( pszFileName ) + 1;

        _pwszFileName = new WCHAR [cc];

        wcscpy( _pwszFileName, pszFileName );

        _mmStream.Open( _pwszFileName,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        OPEN_EXISTING );

        if ( _mmStream.Ok() )
            _mmStreamBuf.Init( &_mmStream );
        else
            sc = ( STATUS_ACCESS_DENIED == GetLastError() ?   // Open sets the last error
                   FILTER_E_PASSWORD :
                   FILTER_E_ACCESS );
    }
    CATCH( CException, e )
    {
        if ( e.GetErrorCode() == HRESULT_FROM_WIN32( ERROR_BAD_EXE_FORMAT ) )
        {
            _fNSS = TRUE;
            sc = S_OK;
        }
        else
        {
            sc = ( STATUS_ACCESS_DENIED == e.GetErrorCode() ?
                   FILTER_E_PASSWORD :
                   FILTER_E_ACCESS );
        }
    }
    END_CATCH;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTextIFilter::Save, public
//
//  Synopsis:   Always returns E_FAIL, since the file is opened read-only
//
//  History:    16-Jul-93   AmyA           Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CTextIFilter::Save(LPCWSTR pszFileName, BOOL fRemember)
{
    return E_FAIL;  // cannot be saved since it is read-only
}

//+---------------------------------------------------------------------------
//
//  Member:     CTextIFilter::SaveCompleted, public
//
//  Synopsis:   Always returns S_OK since the file is opened read-only
//
//  History:    16-Jul-93   AmyA           Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CTextIFilter::SaveCompleted(LPCWSTR pszFileName)
{
    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTextIFilter::GetCurFile, public
//
//  Synopsis:   Returns a copy of the current file name
//
//  Arguments:  [ppszFileName] -- where the copied string is returned.
//
//  History:    09-Aug-93   AmyA           Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CTextIFilter::GetCurFile(LPWSTR * ppszFileName)
{
    if ( _pwszFileName == 0 )
        return E_FAIL;

    SCODE sc = S_OK;

    unsigned cc = wcslen( _pwszFileName ) + 1;
    *ppszFileName = (WCHAR *)CoTaskMemAlloc(cc*sizeof(WCHAR));

    if ( *ppszFileName )
        wcscpy( *ppszFileName, _pwszFileName );
    else
        sc = E_OUTOFMEMORY;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTextIFilter::Load, public
//
//  Synopsis:   Loads the indicated stream
//
//  Arguments:  [pStm] -- The IStream
//
//  History:    11-Feb-97   KyleP          Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CTextIFilter::Load( IStream * pStm )
{
    _fNSS = FALSE;

    //
    // Close any previously open stuff.
    //

    if ( 0 != _pStream )
    {
        _pStream->Release();
        _pStream = 0;
        _mmIStream.Close();
    }

    if (_pwszFileName != 0)
    {
        delete _pwszFileName;
        _pwszFileName = 0;

        _mmStreamBuf.Rewind();
        _mmStream.Close();
    }

    //
    // Try to initialize map.
    //

    SCODE sc = S_OK;

    TRY
    {
        _pStream = pStm;
        _pStream->AddRef();

        _mmIStream.Open( pStm );

        if ( _mmIStream.Ok() )
            _mmStreamBuf.Init( &_mmIStream );
        else
        {
            sc = ( STG_E_ACCESSDENIED == GetLastError() ?
                   FILTER_E_PASSWORD :
                   FILTER_E_ACCESS );
        }
    }
    CATCH( CException, e )
    {
        sc = ( STG_E_ACCESSDENIED == e.GetErrorCode() ?
               FILTER_E_PASSWORD :
               FILTER_E_ACCESS );
    }
    END_CATCH;

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTextIFilter::Save, public
//
//  Synopsis:   Always returns E_FAIL, since the stream is opened read-only
//
//  Arguments:  [pStm]        -- Stream
//              [fClearDirty] -- TRUE --> Clear dirty bit in stream
//
//  History:    11-Feb-97   KyleP          Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CTextIFilter::Save( IStream * pStm, BOOL fClearDirty )
{
    return E_FAIL;
}

//+---------------------------------------------------------------------------
//
//  Member:     CTextIFilter::GetSizeMax, public
//
//  Synopsis:   Always returns E_FAIL, since the stream is opened read-only
//
//  Arguments:  [pcbSize] -- Size of stream needed to save object.
//
//  History:    11-Feb-97   KyleP          Created.
//
//----------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CTextIFilter::GetSizeMax( ULARGE_INTEGER * pcbSize )
{
    return E_FAIL;
}

//+-------------------------------------------------------------------------
//
//  Method:     CTextIFilter::IsLastCharDBCSLeadByte
//
//  Synopsis:   Check if last byte in buffer is a DBCS lead byte
//
//  Arguments:  [pbIn]    --  Input buffer
//              [cChIn]   --  Buffer length
//
//  History:    6-Jan-96      SitaramR           Created
//
//--------------------------------------------------------------------------

BOOL CTextIFilter::IsLastCharDBCSLeadByte( BYTE *pbIn,
                                           ULONG cChIn )
{
    Win4Assert( IsDBCSCodePage( _ulCodePage ) );

    for ( ULONG cCh=0; cCh<cChIn; cCh++ )
        if ( IsDBCSLeadByteEx( _ulCodePage, pbIn[cCh] ) )
            cCh++;

    //
    // If last char is DBCS lead byte, then cCh == cChIn + 1, else cCh == cChIin
    //
    return cCh != cChIn;
}



//+-------------------------------------------------------------------------
//
//  Method:     CTextIFilter::IsDBCSCodePage
//
//  Synopsis:   Check if the codepage is a DBCS code page
//
//  Arguments:  [codePage]    --  Code page to check
//
//  History:    6-Jan-96      SitaramR           Created
//
//--------------------------------------------------------------------------

BOOL CTextIFilter::IsDBCSCodePage( ULONG ulCodePage )
{
    CPINFO cpInfo;

    BOOL fSuccess = GetCPInfo( ulCodePage, &cpInfo );

    if ( fSuccess )
    {
        if ( cpInfo.LeadByte[0] != 0 && cpInfo.LeadByte[1] != 0 )
            return TRUE;
        else
            return FALSE;
    }

    ciDebugOut(( DEB_ERROR,
                 "IsDBCSCodePage failed, 0x%x\n",
                 GetLastError() ));
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\web\dll\htx.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:       htx.cxx
//
//  Contents:   Parser for a HTX file
//
//  History:    96/Jan/3    DwightKr    Created
//
//----------------------------------------------------------------------------


#include <pch.cxx>
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Member:     CHTXScanner::CHTXScanner - public constructor
//
//  Synopsis:   Builds a scanner for a section within a HTX file
//
//  Arguments:  [variableSet] - list of replaceable parameters
//              [wcsPrefix]   - prefix delimiter for replacable parameters
//              [wcsSuffix]   - suffix delimiter for replacable parameters
//
//  Notes:      The wcsPrefix and wcsSuffix are expected to be the same
//              length and either one or two characters.
//
//  History:    96/Jan/03   DwightKr    created
//
//----------------------------------------------------------------------------
CHTXScanner::CHTXScanner( CVariableSet & variableSet,
                          WCHAR const * wcsPrefix,
                          WCHAR const * wcsSuffix ) :
                                    _wcsPrefix(wcsPrefix),
                                    _wcsSuffix(wcsSuffix),
                                    _variableSet(variableSet),
                                    _type(eNone),
                                    _nextType(eNone),
                                    _wcsString(0),
                                    _wcsPrefixToken(0),
                                    _wcsSuffixToken(0)
{
    Win4Assert( wcslen( _wcsPrefix ) == wcslen( _wcsSuffix ) &&
                wcslen( _wcsPrefix ) <= 2 );

    if ( _wcsPrefix[1] == L'\0' )
        _cchPrefix = _cchSuffix = 1;
    else
        _cchPrefix = _cchSuffix = 2;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHTXScanner::Init - public
//
//  Synopsis:   Saves a pointer to the string to be parsed.
//
//  Arguments:  [wcsString] - the string to be parsed
//
//  History:    96/Jan/03   DwightKr    created
//
//  NOTES:      THIS STRING WILL BE MODIFIED BY SUBSEQUENT CALLS TO MEMBER
//              FUNCTIONS OF THIS CLASS.
//
//----------------------------------------------------------------------------
void CHTXScanner::Init( WCHAR * wcsString )
{
    _wcsString = wcsString;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHTXScanner::IsToken - private
//
//  Synopsis:   Determines if a string is a special token.
//
//  Arguments:  [wcs] - start of string to be tested.
//
//  Notes:      If the string is a token, the members _type, _wcsPrefixToken
//              and _wcsSuffixToken are set appropriately.
//
//  History:    96/Apr/02   AlanW       Created
//              96/May/17   DwightKr    Treat all <%..%> as variables
//
//----------------------------------------------------------------------------

BOOL CHTXScanner::IsToken(WCHAR * wcs)
{
    if ( wcsncmp( _wcsPrefix, wcs, _cchPrefix ) != 0 )
    {
        ciGibDebugOut(( DEB_USER1, "CHTXScanner::IsToken  end of string\n" ));
        return FALSE;
    }

    wcs += _cchPrefix;
    WCHAR * wcsSuffixTok = wcs2chr( wcs, _wcsSuffix );
    if ( 0 == wcsSuffixTok )
    {
        ciGibDebugOut(( DEB_USER1, "CHTXScanner::IsToken  no suffix token\n" ));
        return FALSE;
    }

    *wcsSuffixTok = L'\0';
    _wcsPrefixToken = wcs - _cchPrefix;
    _wcsupr( wcs );

    //
    //  Strip leading spaces before token
    //
    while ( iswspace(*wcs) && (wcs < wcsSuffixTok) )
    {
        wcs++;
    }

    //
    //  Strip trailing spaces after token
    //
    WCHAR * wcsSuffix = wcsSuffixTok - 1;
    while ( iswspace(*wcsSuffix) && (wcsSuffix > wcs) )
    {
        *wcsSuffix = 0;
        wcsSuffix--;
    }

    ciGibDebugOut(( DEB_USER1, "CHTXScanner::IsToken  wcs=%ws\n", wcs ));

    if ( wcsncmp( wcs, L"IF ", 3 ) == 0 )
    {
        _type = eIf;
    }
    else if ( wcscmp( wcs, L"ELSE" ) == 0 )
    {
        _type = eElse;
    }
    else if ( wcscmp( wcs, L"ENDIF" ) == 0 )
    {
        _type = eEndIf;
    }
    else if ( wcsncmp( wcs, L"ESCAPEHTML ", 11 ) == 0 )
    {
        _type = eEscapeHTML;
    }
    else if ( wcsncmp( wcs, L"ESCAPEURL ", 10 ) == 0 )
    {
        _type = eEscapeURL;
    }
    else if ( wcsncmp( wcs, L"ESCAPERAW ", 10 ) == 0 )
    {
        _type = eEscapeRAW;
    }
    else
    {
        //
        //  Find this name in the list of replaceable parameters.  Note that
        //  if we can't find this variable in the list of replaceable
        //  parameters, we've converted some output text to uppercase.  This
        //  is probably OK since the user used <% ... %> to delimit their
        //  output; <% & %> are reserved tokens hence this would be an error.
        //
        CVariable *pVariable = _variableSet.Find( wcs );

        if ( 0 != pVariable )
        {
            //
            //  We have a match, this is a replaceable parameter.  Compiler
            //  bug.  _type needs to be assigned in both places.
            //
            _type = eParameter | pVariable->GetFlags();
        }
        else
        {
            ciGibDebugOut(( DEB_IWARN,
                            "Warning: CHTXScanner::IsToken found a unknown variable: '%ws'\n",
                            wcs ));

            _type = eParameter;
        }
    }

    *_wcsPrefixToken = L'\0';
    _wcsSuffixToken = wcsSuffixTok;
    _wcsNextToken = wcsSuffixTok + _cchSuffix;

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHTXScanner::FindNextToken - public
//
//  Synopsis:   Locates the next token in the string.
//
//  History:    96/Jan/03   DwightKr    created
//
//----------------------------------------------------------------------------

BOOL CHTXScanner::FindNextToken()
{
    if (_nextType != eNone)
    {
        //
        // Found a token on the previous call.  Just return it.
        //
        Win4Assert ( _wcsPrefixToken && _wcsSuffixToken > _wcsPrefixToken );
        _type = _nextType;
        _nextType = eNone;
        _wcsString = _wcsNextToken = _wcsSuffixToken + _cchSuffix;
        return TRUE;
    }

    if ( (0 == _wcsString) || (0 == *_wcsString) )
    {
        _type = eNone;
        _wcsNextToken = 0;

        return FALSE;
    }

    if ( *_wcsString == *_wcsPrefix &&
         IsToken( _wcsString ) )
    {
        _nextType = eNone;
        return TRUE;
    }

    //
    // The string doesn't start with one of our special keywords.
    // Treat it as an ordinary string, and look ahead to the next
    // valid token.
    //

    _wcsPrefixToken = wcs2chr( _wcsString+1, _wcsPrefix );
    while ( _wcsPrefixToken )
    {
        if ( IsToken( _wcsPrefixToken ) )
        {
            _nextType = _type;
            _wcsNextToken = _wcsPrefixToken;
            _type = eString;
            return TRUE;
        }
        _wcsPrefixToken = wcs2chr( _wcsPrefixToken+_cchPrefix, _wcsPrefix );
    }

    _nextType = eNone;
    _type = eString;
    _wcsNextToken = _wcsString + wcslen( _wcsString );
    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHTXScanner::GetToken - public
//
//  Synopsis:   Returns a pointer to the replaceable parameter token found.
//              Prepares the scanner to return the next token.
//
//  History:    96/Jan/03   DwightKr    created
//              96/Mar/13   DwightKr    add support for eEscapeURL &
//                                      eEscapeHTML
//
//----------------------------------------------------------------------------

WCHAR * CHTXScanner::GetToken()
{
    if ( eString == _type )
    {
        if ( 0 != _wcsString )
        {
            WCHAR * wcsString = _wcsString;
            _wcsString = _wcsNextToken;

            return wcsString;
        }
    }
    else if ( eEscapeHTML == _type )
    {
        WCHAR * wcsString = _wcsPrefixToken + _cchPrefix;
        wcsString += 10;                        // Skip 'EscapeHTML'
        *_wcsSuffixToken = 0;                   // Null terminate

        while ( (0 != *wcsString) && iswspace(*wcsString) )
        {
            wcsString++;
        }

        _wcsString = _wcsNextToken;

        return wcsString;
    }
    else if ( eEscapeURL == _type ||
              eEscapeRAW == _type )
    {
        WCHAR * wcsString = _wcsPrefixToken + _cchPrefix;
        wcsString += 9;                         // Skip 'EscapeURL'
        *_wcsSuffixToken = 0;                   // Null terminate

        while ( (0 != *wcsString) && iswspace(*wcsString) )
        {
            wcsString++;
        }

        _wcsString = _wcsNextToken;

        return wcsString;
    }
    else
    {
        if ( 0 != _wcsPrefixToken )
        {
            Win4Assert( 0 != _wcsSuffixToken &&
                        _wcsPrefixToken < _wcsSuffixToken &&
                        _wcsSuffixToken < _wcsNextToken );

            *_wcsPrefixToken = 0;
            *_wcsSuffixToken = 0;

            _wcsString = _wcsNextToken;

            WCHAR * wcsString = _wcsPrefixToken + _cchPrefix;
            while ( (0 != *wcsString) && iswspace(*wcsString) )
            {
                wcsString++;
            }


            return wcsString;
        }
    }

    return 0;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHTXFile::CHTXFile - public constructor
//
//  Synopsis:   Builds a CHTXFile object and initializes values.
//
//  History:    96/Jan/03   DwightKr    created
//
//----------------------------------------------------------------------------
CHTXFile::CHTXFile( XPtrST<WCHAR> & wcsTemplate,
                    UINT codePage,
                    CSecurityIdentity const & securityIdentity,
                    ULONG ulServerInstance )
        : _wcsVirtualName( wcsTemplate.Acquire() ),
          _pVarHeader(0),
          _pVarRowDetails(0),
          _pVarFooter(0),
          _wcsFileBuffer(0),
          _fSequential(TRUE),
          _cIncludeFiles(0),
          _refCount(0),
          _codePage(codePage),
          _securityIdentity( securityIdentity ),
          _ulServerInstance( ulServerInstance )
{
    _wcsPhysicalName[0] = 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHTXFile::~CHTXFile - public destructor
//
//  History:    96/Jan/03   DwightKr    created
//
//----------------------------------------------------------------------------
CHTXFile::~CHTXFile()
{
    Win4Assert( _refCount == 0 );

    delete _wcsVirtualName;
    delete _pVarHeader;
    delete _pVarRowDetails;
    delete _pVarFooter;
    delete _wcsFileBuffer;

    for (unsigned i=0; i<_cIncludeFiles; i++)
    {
        delete _awcsIncludeFileName[i];
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CHTXFile::ParseFile - public
//
//  Synopsis:   Parses the HTX file and breaks it up into its sections.
//
//  History:    96/Jan/03   DwightKr    created
//
//----------------------------------------------------------------------------
void CHTXFile::ParseFile( WCHAR const * wcsFileName,
                          CVariableSet & variableSet,
                          CWebServer & webServer )
{
    Win4Assert( wcsFileName != 0 );

    wcscpy( _wcsPhysicalName, wcsFileName );

    //
    //  Read the entire file into a buffer
    //
    CVirtualString wcsBuffer;
    ExpandFile( _wcsPhysicalName, webServer, wcsBuffer, _ftHTXLastWriteTime );

    Win4Assert( wcsBuffer.GetPointer() != 0 );

    //
    //  Break the buffer into the sections; the header, the detail section,
    //  and the footer.  Verify that if there is a <%BeginDetail%>
    //  section, then there MUST be a <%EndDetail%> section AFTER it, not
    //  before.  Neither <%EndDetail%> nor <%BeginDetail%> can appear on
    //  their own.
    //

    //
    //  Find the <%BeginDetail%> and <%EndDetail%> sections
    //
    _wcsFileBuffer        = wcsBuffer.StrDup();         // Save buffer
    WCHAR * wcsHeader     = _wcsFileBuffer;             // Assume a header
    WCHAR * wcsRowDetails = wcsipattern(wcsHeader, L"<%BEGINDETAIL%>" );
    WCHAR * wcsFooter     = wcsipattern(wcsHeader, L"<%ENDDETAIL%>" );

    if ( wcsHeader == wcsRowDetails )
    {
        //
        //  No header found in this file; it begins with the detail section.
        //
        wcsHeader = 0;
    }

    const int cwcBeginDetail = 15;
    const int cwcEndDetail   = 13;

    Win4Assert( cwcBeginDetail == wcslen( L"<%BEGINDETAIL%>" ) );
    Win4Assert( cwcEndDetail == wcslen( L"<%ENDDETAIL%>" ) );

    if ( 0 != wcsRowDetails )
    {
        //
        //  A <%BeginDetail%> section was found.  We better also have an
        //  <%EndDetail%> section AFTER the <%BeginDetail%> section.
        //

        *wcsRowDetails = 0;         // Null terminate the header string
        wcsRowDetails += cwcBeginDetail;

        if ( 0 != wcsFooter )
        {
            if ( wcsFooter < wcsRowDetails )
            {
                //
                //  The <%EndDetail%> was found before the <%BeginDetail%>
                //
                WCHAR * wcsHTXFileName;
                LONG    lLineNumber;

                GetFileNameAndLineNumber( (int)(wcsFooter - _wcsFileBuffer),
                                          wcsHTXFileName,
                                          lLineNumber );

                THROW( CHTXException(MSG_CI_HTX_ENDDETAIL_BEFORE_BEGINDETAIL,
                                     wcsHTXFileName,
                                     lLineNumber) );
            }

            *wcsFooter = 0;         // Null terminate the BeginDetail section
            wcsFooter += cwcEndDetail;
        }
        else
        {
            //
            //  Report an error:  <%BeginDetail%> without an <%EndDetail%>
            //

            WCHAR * wcsHTXFileName;
            LONG    lLineNumber;

            GetFileNameAndLineNumber( (int)(wcsRowDetails - _wcsFileBuffer),
                                      wcsHTXFileName,
                                      lLineNumber );

            THROW( CHTXException(MSG_CI_HTX_NO_ENDDETAIL_SECTION,
                                 wcsHTXFileName,
                                 lLineNumber) );
        }
    }
    else if ( 0 != wcsFooter )
    {
        //
        //  A <%BeginDetail%> section could be found.  There should
        //  be no <%EndDetail%> section either.
        //

        WCHAR * wcsHTXFileName;
        LONG    lLineNumber;

        GetFileNameAndLineNumber( (int)(wcsFooter - _wcsFileBuffer),
                                  wcsHTXFileName,
                                  lLineNumber );

        THROW( CHTXException(MSG_CI_HTX_NO_BEGINDETAIL_SECTION,
                             wcsHTXFileName,
                             lLineNumber) );
    }


    if ( 0 != wcsHeader )
    {
        _pVarHeader = new CParameterReplacer ( wcsHeader,
                                               L"<%",
                                               L"%>" );
        _pVarHeader->ParseString( variableSet );
    }

    if ( 0 != wcsRowDetails )
    {
        _pVarRowDetails = new CParameterReplacer ( wcsRowDetails,
                                                   L"<%",
                                                   L"%>" );
        _pVarRowDetails->ParseString( variableSet );
    }

    if ( 0 != wcsFooter )
    {
        _pVarFooter = new CParameterReplacer ( wcsFooter,
                                               L"<%",
                                               L"%>" );
        _pVarFooter->ParseString( variableSet );
    }

    _fSequential = CheckForSequentialAccess();
}

//+---------------------------------------------------------------------------
//
//  Member:     CHTXFile::ReadFile - public
//
//  Synopsis:   Read the HTX file into a buffer
//
//  Arguments:  [wcsFileName]  - full physical path name of file
//              [ftLastWrite]  - File's last write time is stored here
//
//  History:    96/Jan/03   DwightKr    created
//              96/Apr/06   DwightKr    add support for unicode files
//
//----------------------------------------------------------------------------
WCHAR * CHTXFile::ReadFile( WCHAR const * wcsFileName,
                            FILETIME & ftLastWrite )
{
    Win4Assert ( 0 != wcsFileName );

    // We don't support impersonation for scripts.
    // It involves getting the server ip address, vpath and then using
    // that for impersonation

    if ( IsNetPath(wcsFileName) )
    {
        ciGibDebugOut(( DEB_ERROR, "The htx file (%ws) is on remote UNC\n",
                        wcsFileName ));
        THROW( CHTXException( MSG_CI_SCRIPTS_ON_REMOTE_UNC, wcsFileName, 0 ));
    }

    //
    //  Verify the HTX file exists, and is a file, not a directory.
    //
    WIN32_FIND_DATA ffData;
    if ( !GetFileAttributesEx( wcsFileName, GetFileExInfoStandard, &ffData ) )
    {
        ULONG error = GetLastError();

        ciGibDebugOut(( DEB_IERROR,
                        "Unable to GetFileAttributesEx(%ws) GetLastError=0x%x\n",
                        wcsFileName,
                        error ));

        THROW( CIDQException(MSG_CI_IDQ_NO_SUCH_TEMPLATE, 0) );
    }


    if ( (ffData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0 )
    {
        THROW( CIDQException(MSG_CI_IDQ_NO_SUCH_TEMPLATE, 0) );
    }

    //
    //  Save the last write time of this file.
    //
    ftLastWrite = ffData.ftLastWriteTime;


    //
    //  Open the file and map its contents
    //
    CFileMapView mapView( wcsFileName );
    mapView.Init();

    int cbBuffer = mapView.GetBufferSize() + 1;
    XArray<WCHAR> pwBuffer(cbBuffer);

    //
    //  If the first two BYTES of the file are 0xFF 0xFE, then this is a
    //  unicode file, and we don't need to convert it.
    //
    if ( mapView.IsUnicode() )
    {
        RtlCopyMemory( pwBuffer.Get(), mapView.GetBuffer()+2, cbBuffer-2 );
        pwBuffer[ ( cbBuffer - 2 ) / sizeof WCHAR ] = 0;

        return pwBuffer.Acquire();
    }

    //
    //  Copy & convert the ASCII buffer to a WCHAR buffer.
    //
    int cwBuffer = mapView.GetBufferSize() + 1;
    int cwConvert;

    do
    {
        cwConvert = MultiByteToWideChar(_codePage,
                                        0,
                         (const char *) mapView.GetBuffer(),    // Ptr to input buf
                                        mapView.GetBufferSize(),// Size of input buf
                                        pwBuffer.Get(), // Ptr to output buf
                                        cwBuffer - 1 ); // Size of output buf

        if ( 0 == cwConvert )
        {
            if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
            {
                cwBuffer += (cwBuffer/2);
                delete pwBuffer.Acquire();
                pwBuffer.Init(cwBuffer);
            }
            else
            {
                THROW( CException() );
            }
        }
        else
        {
            pwBuffer[cwConvert] = 0;        // Null terminate the buffer
        }

        Win4Assert( cwConvert < cwBuffer );

    } while ( 0 == cwConvert );

    return pwBuffer.Acquire();
}


//+---------------------------------------------------------------------------
//
//  Member:     CHTXFile::ExpandFile, public
//
//  Synopsis:   Expands the contents of an HTX file into memory, processing
//              included files.
//
//  Arguments:  [wcsFileName]  - file path name of the file to be expanded
//              [webServer]    - CWebServer for virtual path translation
//              [vString]      - String to which file contents are appended
//              [ftLastWrite]  - File's last write time is stored here
//
//----------------------------------------------------------------------------
void CHTXFile::ExpandFile( WCHAR const * wcsFileName,
                           CWebServer & webServer,
                           CVirtualString & vString,
                           FILETIME & ftLastWrite )
{
    Win4Assert ( 0 != wcsFileName );

    //
    //  Read the existing file into a WCHAR buffer.
    //
    XPtrST<WCHAR> wcsBuffer( ReadFile(wcsFileName, ftLastWrite) );

    WCHAR * wcsString = wcsBuffer.GetPointer();
    ULONG   cwcString = wcslen( wcsString );
    WCHAR * wcsEnd    = wcsString + cwcString;

    //
    //  Search the WCHAR buffer for <%include ... %>
    //
    WCHAR * wcsPattern = L"<%INCLUDE ";
    ULONG   cwcPattern = 10;

    Win4Assert( cwcPattern == wcslen(wcsPattern) );

    WCHAR * wcsToken = wcsipattern( wcsString, wcsPattern );

    while ( 0 != wcsToken )
    {
        if ( _cIncludeFiles >= MAX_HTX_INCLUDE_FILES )
        {
            LONG cLines = CountLines( wcsBuffer.GetPointer(), wcsToken );

            THROW( CHTXException(MSG_CI_HTX_TOO_MANY_INCLUDES,
                                 wcsFileName,
                                 cLines) );
        }

        //
        //  Concatentate everything before the <%include .. %> into the
        //  virtual string.
        //
        ULONG cwcCat = (ULONG)(wcsToken - wcsString);
        Win4Assert( cwcCat <= cwcString );
        *wcsToken = 0;                          // Null terminate the string
        vString.StrCat( wcsString, cwcCat );

        //
        //  Find the end of the <%include ... %>
        //

        wcsToken += cwcPattern;                 //  Skip the <%include
        WCHAR * wcsIncludeFileName = wcsToken;  //  Point to the include filename
        wcsString = wcs2chr( wcsToken, L"%>" );  //  Point to the end of the filename

        //
        //  wcsString should be pointing to the %> at the end of the include
        //
        if ( 0 == wcsString )
        {
            //
            //  Missing %>
            //

            LONG cLines = CountLines( vString.GetPointer(), wcsToken );

            THROW( CHTXException(MSG_CI_HTX_ILL_FORMED_INCLUDE,
                                 wcsFileName,
                                 cLines) );
        }

        //
        //  Process the <%include ... %>
        //
        *wcsString = 0;
        if ( (wcsString - wcsIncludeFileName) >= MAX_PATH )
        {
            LONG cLines = CountLines( wcsBuffer.GetPointer(), wcsToken );

            THROW( CHTXException(MSG_CI_HTX_INVALID_INCLUDE_FILENAME,
                                 wcsFileName,
                                 cLines ) );
        }

        WCHAR   awcPhysicalPath[MAX_PATH];
        webServer.GetPhysicalPath( wcsIncludeFileName,
                                   awcPhysicalPath,
                                   MAX_PATH );

        //
        //  Save the include filename away
        //
        ULONG cwcPhysicalPath = wcslen(awcPhysicalPath) + 1;
        _awcsIncludeFileName[_cIncludeFiles]  = new WCHAR[ cwcPhysicalPath ];
        _aulIncludeFileOffset[_cIncludeFiles] = vString.StrLen();

        RtlCopyMemory( _awcsIncludeFileName[_cIncludeFiles],
                       awcPhysicalPath,
                       cwcPhysicalPath * sizeof(WCHAR) );

        FILETIME & ftLastWrite = _aftIncludeLastWriteTime[ _cIncludeFiles ];
        _cIncludeFiles++;

        ExpandFile( awcPhysicalPath, webServer, vString, ftLastWrite );

        wcsString += 2;                     // Skip the %>
        cwcString = (ULONG)(wcsEnd - wcsString);
        wcsToken  = wcsipattern( wcsString, wcsPattern );
    }

    vString.StrCat( wcsString, cwcString );
}


//+---------------------------------------------------------------------------
//
//  Member:     CHTXFile::GetFileNameAndLineNumber
//
//  Synopsis:   Determines the filename & line number amoung a group of
//              nested includes for a particular offset into the buffer.
//
//  Arguments:  [offset] - offset of the error in the overall buffer
//              [wcsFileName] - resulting name of file containing error
//              [lineNumber]  - line # containing the error
//
//  History:    96/Jun/25   DwightKr    created
//
//----------------------------------------------------------------------------
void CHTXFile::GetFileNameAndLineNumber( int offset,
                                         WCHAR *& wcsFileName,
                                         LONG & lineNumber )
{
    //
    //  Search the array of offsets for the one containing our offset
    //
    for (ULONG i = 0;
         (i < _cIncludeFiles) && ((ULONG) offset > _aulIncludeFileOffset[i]);
         i++ )
    {
    }

    //
    //  Save a pointer to the name of the file containing the error
    //
    WCHAR const * pCurrent = _wcsFileBuffer;
    if ( 0 == i )
    {
        //
        //  We have a problem in the outer-most container file; not
        //  an include file.
        //
        wcsFileName = _wcsVirtualName;
    }
    else
    {
        wcsFileName = _awcsIncludeFileName[i-1];
        pCurrent += _aulIncludeFileOffset[i-1];
    }


    //
    //  Count the number of lines in this sub-file
    //
    Win4Assert( 0 != _wcsFileBuffer );
    WCHAR const * pEnd = _wcsFileBuffer + offset;

    lineNumber = CountLines( pCurrent, pEnd );
}


//+---------------------------------------------------------------------------
//
//  Member:     CHTXFile::CountLines - private
//
//  Synopsis:   Deterines the number of lines (CR's) between the start
//              of the buffer and the end.
//
//  Arguments:  [wcsStart] - start location of search
//              [wcsEnd]   - end of search
//
//  History:    96/Jun/25   DwightKr    created
//
//----------------------------------------------------------------------------
LONG CHTXFile::CountLines( WCHAR const * wcsStart,
                           WCHAR const * wcsEnd ) const
{
    Win4Assert( 0 != wcsStart );
    Win4Assert( 0 != wcsEnd );

    LONG cLines = 1;

    while ( wcsStart <= wcsEnd )
    {
        if ( L'\n' == *wcsStart )
        {
            cLines++;
        }

        wcsStart++;
    }

    return cLines;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHTXFile::IsCachedDataValid - public
//
//  Synopsis:   Determines if the cached & parsed data from the HTX file
//              is still valid.  The HTX file itself may have changed
//              since we read and parsed it.
//
//  History:    96/Jan/03   DwightKr    created
//              96/Mar/14   DwightKr    check <%include%> file times
//
//----------------------------------------------------------------------------
BOOL CHTXFile::IsCachedDataValid()
{
    FILETIME ft;

    SCODE sc = GetLastWriteTime( _wcsPhysicalName, ft );

    if ( FAILED( sc ) )
        return FALSE;

    if ( (_ftHTXLastWriteTime.dwLowDateTime != ft.dwLowDateTime) ||
         (_ftHTXLastWriteTime.dwHighDateTime != ft.dwHighDateTime) )
    {
        return FALSE;
    }

    for ( unsigned i=0; i<_cIncludeFiles; i++ )
    {
        sc = GetLastWriteTime(_awcsIncludeFileName[i], ft );

        if ( FAILED( sc ) )
            return FALSE;

        if ( (_aftIncludeLastWriteTime[i].dwLowDateTime != ft.dwLowDateTime) ||
             (_aftIncludeLastWriteTime[i].dwHighDateTime != ft.dwHighDateTime) )
        {
            return FALSE;
        }
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHTXFile::GetHeader - public
//
//  Synopsis:   Appends to a CVirtualString the data in the HTX file BEFORE
//              the <%begindetail%> section.  This may require replacing
//              parameters.
//
//  Arguments:  [string]       - the CVirtualString to append data to
//              [variableSet]  - a list of replaceable parameters
//              [outputFormat] - format for numbers & dates
//
//  History:    96/Jan/03   DwightKr    created
//
//----------------------------------------------------------------------------
void CHTXFile::GetHeader( CVirtualString & string,
                          CVariableSet & variableSet,
                          COutputFormat & outputFormat )
{
    if ( 0 != _pVarHeader )
    {
        _pVarHeader->ReplaceParams( string, variableSet, outputFormat );
    }
}



//+---------------------------------------------------------------------------
//
//  Member:     CHTXFile::GetFooter - public
//
//  Synopsis:   Appends to a CVirtualString the data in the HTX file AFTER
//              the <%enddetail%> section.  This may require replacing
//              parameters.
//
//  Arguments:  [string]      - the CVirtualString to append data to
//              [variableSet] - a list of replaceable parameters
//              [outputFormat] - format for numbers & dates
//
//  History:    96/Jan/03   DwightKr    created
//
//----------------------------------------------------------------------------
void CHTXFile::GetFooter( CVirtualString & string,
                          CVariableSet & variableSet,
                          COutputFormat & outputFormat )
{
    if ( 0 != _pVarFooter )
    {
        _pVarFooter->ReplaceParams( string, variableSet, outputFormat );
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CHTXFile::CheckForSequentialAccess - public
//
//  Synopsis:   Determines if a sequential query cursor can be used to
//              extract query results.  This is possible if the HTX file
//              does not use any replaceable parameters which require
//              data from an IRowsetScroll.
//
//  History:    96/Jan/03   DwightKr    created
//
//----------------------------------------------------------------------------
BOOL CHTXFile::CheckForSequentialAccess()
{
    //
    //  If an HTX file contains any of the following variables, it must
    //  use a non-sequential access, since we need one or more interfaces
    //  from IRowsetScroll.
    //
    //      CiMatchedRecordCount
    //      CiRecordsNextPage
    //      CiTotalNumberPages
    //

    if ( (0 != _pVarHeader) && (_pVarHeader->GetFlags() & eParamRequiresNonSequentialCursor) )
    {
        return FALSE;
    }

    if ( (0 != _pVarRowDetails) && (_pVarRowDetails->GetFlags() & eParamRequiresNonSequentialCursor) )
    {
        return FALSE;
    }

    if ( (0 != _pVarFooter) && (_pVarFooter->GetFlags() & eParamRequiresNonSequentialCursor) )
    {
        return FALSE;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CHTXFileList::Find - public
//
//  Synopsis:   Finds a matching parsed HTX file in list, or builds a new
//              one if a match can not be found.
//
//  Arguments:  [wcsFileName]      -- full path to HTX file
//              [variableSet]      -- list of replaceable parameters
//              [outputFormat]     -- format for numbers and dates
//              [securityIdentity] -- Logon for this query
//              [ulServerInstance] -- Virtual Server Instance Number
//
//  History:    96/Mar/27   DwightKr    Created.
//
//----------------------------------------------------------------------------

CHTXFile & CHTXFileList::Find( WCHAR const * wcsFileName,
                               CVariableSet & variableSet,
                               COutputFormat & outputFormat,
                               CSecurityIdentity const & securityIdentity,
                               ULONG ulServerInstance )
{
    Win4Assert( 0 != wcsFileName );

    //
    //  Determine the name of the HTX/template file.  It may have a
    //  replaceable value from the client.
    //

    ULONG cwcOut;
    XPtrST<WCHAR> wcsVirtualName( ReplaceParameters( wcsFileName,
                                                     variableSet,
                                                     outputFormat,
                                                     cwcOut ) );

    if ( 0 == *(wcsVirtualName.GetPointer()) )
    {
        THROW( CIDQException( MSG_CI_IDQ_MISSING_TEMPLATEFILE, 0 ) );
    }


    //
    //  Refcount everything in the list so that we can examine the list
    //  outside of the lock.
    //

    ULONG      cItems;
    XArray<CHTXFile *> aHTXFile;

    // ==========================================
    {
        CLock lock( _mutex );

        cItems = _aHTXFile.Count();         // Save count of items to examine
        aHTXFile.Init( cItems );

        for (unsigned i=0; i<cItems; i++)
        {
            aHTXFile[i] = _aHTXFile[i];
            aHTXFile[i]->LokAddRef();
        }
    }
    // ==========================================


    //
    //  Now walk though the list looking for a match; outside of the lock.
    //
    XInterface<CHTXFile> xHTXFile;
    SCODE sc = S_OK;

    TRY
    {
        for (unsigned i=0; i<cItems; i++)
        {
            if ( (_wcsicmp(aHTXFile[i]->GetVirtualName(), wcsVirtualName.GetPointer() ) == 0) &&
                 (aHTXFile[i]->GetCodePage() == outputFormat.CodePage()) &&
                 (aHTXFile[i]->GetServerInstance() == ulServerInstance) &&
                 (aHTXFile[i]->IsCachedDataValid() )
               )
            {
                xHTXFile.Set( aHTXFile[i] );

                ciGibDebugOut(( DEB_ITRACE,
                                "A cached version of HTX file %ws was found\n",
                                wcsVirtualName.GetPointer() ));

                break;
            }
        }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    //
    //  If xHTXFile is non-0, we've found a match.  Decrement the ref-count
    //  for all items which did not match.
    //

    for (unsigned i=0; i<cItems; i++)
    {
        if ( aHTXFile[i] != xHTXFile.GetPointer() )
        {
            aHTXFile[i]->Release();
        }
    }

    if ( S_OK != sc )
    {
        Win4Assert( xHTXFile.IsNull() );
        THROW( CException( sc ) );
    }

    //
    // We may have matched, but still not have access to this file.  First, make
    // a quick check for an exact match on security token, and then try harder
    // by opening the file.
    //

    if ( !xHTXFile.IsNull() )
    {
        if ( !xHTXFile->CheckSecurity( securityIdentity ) )
        {
            HANDLE h = CreateFile( xHTXFile->GetPhysicalName(),
                                   GENERIC_READ,
                                   FILE_SHARE_READ,
                                   0,
                                   OPEN_EXISTING,
                                   0,
                                   0 );

            //
            // Don't try to determine here if security caused the problem.
            // Just let the standard exception handling below in file parsing
            // deal with the error.
            //

            if ( INVALID_HANDLE_VALUE == h )
            {
                xHTXFile.Free();
            }
            else
            {
                CloseHandle( h );

                //
                // Update the security token of the cached Htx file,
                // to optimize away the CreateFile check in two cases:
                //   1.  When the file is first parsed with admin
                //       privileges, and all subsequent queries are with
                //       anonymous privileges.
                //   2.  When the security token changes over time
                //
                xHTXFile->SetSecurityToken( securityIdentity );
            }
        }
    }

    //
    //  If we didn't find a match, then open and parse a new HTX file, and
    //  add it to the list of parsed HTX files
    //

    if ( xHTXFile.IsNull() )
    {
        ciGibDebugOut(( DEB_ITRACE,
                        "Adding HTX file %ws to cache\n",
                        wcsVirtualName.GetPointer() ));

        WCHAR wcsPhysicalName[MAX_PATH];
        if ( outputFormat.IsValid() )
        {
            outputFormat.GetPhysicalPath( wcsVirtualName.GetPointer(),
                                          wcsPhysicalName,
                                          MAX_PATH );
        }
        else
        {
            if ( !GetFullPathName( wcsVirtualName.GetPointer(),
                                   MAX_PATH,
                                   wcsPhysicalName,
                                   0 ) )
            {
                THROW( CException() );
            }
        }

        XPtr<CHTXFile> xHTXFilePtr( new CHTXFile( wcsVirtualName,
                                                  outputFormat.CodePage(),
                                                  securityIdentity,
                                                  ulServerInstance ) );
        xHTXFilePtr->ParseFile( wcsPhysicalName,
                                variableSet,
                                outputFormat );

        {
            // ==========================================
            CLock lock( _mutex );
            _aHTXFile.Add( xHTXFilePtr.GetPointer(), _aHTXFile.Count() );
            xHTXFilePtr->LokAddRef();
            // ==========================================
        }

        xHTXFile.Set( xHTXFilePtr.Acquire() );
    }

    // CopyStringValue can fail.

    variableSet.CopyStringValue( ISAPI_CI_TEMPLATE,
                                 xHTXFile->GetVirtualName(),
                                 0 );

    return *xHTXFile.Acquire();
}

//+---------------------------------------------------------------------------
//
//  Member:     CHTXFileList::FindCanonicHTX
//
//  Synopsis:   Finds the standard HTX file for canonical output
//
//  Arguments:  [variableSet]      - list of replaceable parameters
//              [codePage]         - code page to open HTX with
//              [securityIdentity] - Identity of the htx file needed
//              [ulServerInstance] - Virtual Server metabase instance #
//
//  History:    7-03-96   srikants   Created
//
//  Notes:      There is nothing to be displayed for the canonical output.
//
//----------------------------------------------------------------------------

CHTXFile & CHTXFileList::FindCanonicHTX( CVariableSet & variableSet,
                                         UINT codePage,
                                         CSecurityIdentity const & securityIdentity,
                                         ULONG ulServerInstance )
{
    CHTXFile * pHTXFile = 0;

    CLock   lock(_mutex);

    if ( 0 == _pCanonicHTX )
    {
        ciGibDebugOut(( DEB_ITRACE,
                        "Adding Canonic HTX file cache\n" ));

        unsigned len = wcslen( CANONIC_HTX_FILE );
        XPtrST<WCHAR> wcsVirtualName( new WCHAR [len+1] );
        RtlCopyMemory( wcsVirtualName.GetPointer(), CANONIC_HTX_FILE,
                       (len+1)*sizeof(WCHAR) );

        pHTXFile = new CHTXFile( wcsVirtualName,
                                 codePage,
                                 securityIdentity,
                                 ulServerInstance );
        _pCanonicHTX = pHTXFile;

        pHTXFile->LokAddRef();
    }
    else
    {
        pHTXFile = _pCanonicHTX;
        pHTXFile->LokAddRef();
    }

    Win4Assert( 0 != variableSet.Find( ISAPI_CI_BOOKMARK ) );
    variableSet.CopyStringValue( ISAPI_CI_TEMPLATE,
                                 pHTXFile->GetVirtualName(),
                                 0 );

    return *pHTXFile;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHTXFileList::~CHTXFileList - public destructor
//
//  History:    96/Mar/27   DwightKr    Created.
//
//----------------------------------------------------------------------------
CHTXFileList::~CHTXFileList()
{
    for (unsigned i=0; i<_aHTXFile.Count(); i++)
    {
        ciGibDebugOut(( DEB_ITRACE,
                        "Deleting HTX cache entry %ws\n",
                        _aHTXFile[i]->GetVirtualName() ));

        delete _aHTXFile[i];
    }

    delete _pCanonicHTX;
}


//+---------------------------------------------------------------------------
//
//  Member:     CHTXFileList::Release - public
//
//  Synopsis:   Releases the HTX file by decrementing its refcount.
//
//  Arguments:  [htxFile] -- pointer to the HTX file object
//
//  History:    96/Mar/27   DwightKr    Created.
//
//----------------------------------------------------------------------------
void CHTXFileList::Release( CHTXFile & htxFile )
{
    htxFile.Release();
}


//+---------------------------------------------------------------------------
//
//  Member:     CHTXFileList::DeleteZombies - public
//
//  Synopsis:   Removes HTX files that are zombies; i.e. out of date
//
//  History:    96/Mar/28   DwightKr    Created.
//
//----------------------------------------------------------------------------
void CHTXFileList::DeleteZombies()
{
    // ==========================================
    CLock lock( _mutex );

    unsigned i=0;
    while ( i<_aHTXFile.Count() )
    {
        if ( _aHTXFile[i]->LokGetRefCount() == 0 &&
             !_aHTXFile[i]->IsCachedDataValid() )
        {
            CHTXFile * pHTXFile = _aHTXFile[i];
            _aHTXFile.Remove(i);

            ciGibDebugOut(( DEB_ITRACE,
                            "Deleting zombie HTX cache entry %ws, %d entries cached\n",
                            pHTXFile->GetVirtualName(),
                            _aHTXFile.Count() ));

            delete pHTXFile;
        }
        else
        {
            ciGibDebugOut(( DEB_ITRACE,
                            "HTX cache entry %ws was not deleted, refCount=%d\n",
                            _aHTXFile[i]->GetVirtualName(),
                            _aHTXFile[i]->LokGetRefCount() ));
            i++;
        }
    }
    // ==========================================
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\txtfilt\txtifilt.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1994
//
//  File:       txtifilt.cxx
//
//  Contents:   Text filter 'class factory'.
//
//  History:    23-Feb-1994     KyleP   Created
//
//  Notes:      Machine generated.  Hand modified.
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <tfilt.hxx>
#include <nullfilt.hxx>
#include <params.hxx>
#include <ciregkey.hxx>
#include <regacc.hxx>

extern long gulcInstances;

extern "C" GUID TYPID_CTextIFilter = {
    0xd5355200,
    0x77e3,
    0x101a,
    { 0xb5, 0x52, 0x08, 0x00, 0x2b, 0x33, 0xb0, 0xe6 }
};

ULONG g_cbMaxTextFilter = CI_MAX_TEXT_FILTER_BYTES_DEFAULT;

//+-------------------------------------------------------------------------
//
//  Method:     CTextIFilterBase::CTextIFilterBase
//
//  Synopsis:   Base constructor
//
//  Effects:    Manages global refcount
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

CTextIFilterBase::CTextIFilterBase()
        : _cRefs(1)
{
    InterlockedIncrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CTextIFilterBase::~CTextIFilterBase
//
//  Synopsis:   Base destructor
//
//  Effects:    Manages global refcount
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

CTextIFilterBase::~CTextIFilterBase()
{
    InterlockedDecrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CTextIFilterBase::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CTextIFilterBase::QueryInterface( REFIID riid,
                                                          void  ** ppvObject)
{
    SCODE sc = S_OK;

    if ( 0 == ppvObject )
        return E_INVALIDARG;

    *ppvObject = 0;

    if ( IID_IFilter == riid )
        *ppvObject = (IUnknown *)(IFilter *)this;
    else if ( IID_IPersist == riid )
        *ppvObject = (IUnknown *)(IPersist *)(IPersistFile *)this;
    else if ( IID_IPersistFile == riid )
        *ppvObject = (IUnknown *)(IPersistFile *)this;
    else if ( IID_IUnknown == riid )
        *ppvObject = (IUnknown *)(IPersist *)(IPersistFile *)this;
    else
        sc = E_NOINTERFACE;

    if ( SUCCEEDED( sc ) )
        AddRef();

    return sc;
} //QueryInterface

//+-------------------------------------------------------------------------
//
//  Method:     CTextIFilterBase::AddRef
//
//  Synopsis:   Increments refcount
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CTextIFilterBase::AddRef()
{
    return InterlockedIncrement( &_cRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CTextIFilterBase::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CTextIFilterBase::Release()
{
    unsigned long uTmp = InterlockedDecrement( &_cRefs );

    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}

//+-------------------------------------------------------------------------
//
//  Method:     CTextIFilterCF::CTextIFilterCF
//
//  Synopsis:   Text IFilter class factory constructor
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

CTextIFilterCF::CTextIFilterCF()
        : _cRefs( 1 )
{
    InterlockedIncrement( &gulcInstances );

    CRegAccess reg( RTL_REGISTRY_CONTROL, wcsRegAdmin );
    g_cbMaxTextFilter= reg.Read( wcsMaxTextFilterBytes,
                                 CI_MAX_TEXT_FILTER_BYTES_DEFAULT,
                                 CI_MAX_TEXT_FILTER_BYTES_MIN,
                                 CI_MAX_TEXT_FILTER_BYTES_MAX );
}

//+-------------------------------------------------------------------------
//
//  Method:     CTextIFilterCF::~CTextIFilterCF
//
//  Synopsis:   Text IFilter class factory constructor
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

CTextIFilterCF::~CTextIFilterCF()
{
    InterlockedDecrement( &gulcInstances );
}

//+-------------------------------------------------------------------------
//
//  Method:     CTextIFilterCF::QueryInterface
//
//  Synopsis:   Rebind to other interface
//
//  Arguments:  [riid]      -- IID of new interface
//              [ppvObject] -- New interface * returned here
//
//  Returns:    S_OK if bind succeeded, E_NOINTERFACE if bind failed
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CTextIFilterCF::QueryInterface( REFIID riid,
                                                        void  ** ppvObject )
{
    SCODE sc = S_OK;

    if ( 0 == ppvObject )
        return E_INVALIDARG;

    *ppvObject = 0;

    if ( IID_IClassFactory == riid )
        *ppvObject = (IUnknown *)(IClassFactory *)this;
    else if ( IID_IUnknown == riid )
        *ppvObject = (IUnknown *)(IClassFactory *)this;
    else if ( IID_ITypeLib == riid )
        sc = E_NOTIMPL;
    else
        sc = E_NOINTERFACE;

    if ( SUCCEEDED( sc ) )
        AddRef();

    return sc;
} //QueryInterface

//+-------------------------------------------------------------------------
//
//  Method:     CTextIFilterCF::AddRef
//
//  Synopsis:   Increments refcount
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CTextIFilterCF::AddRef()
{
    return InterlockedIncrement( &_cRefs );
}

//+-------------------------------------------------------------------------
//
//  Method:     CTextIFilterCF::Release
//
//  Synopsis:   Decrement refcount.  Delete if necessary.
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

ULONG STDMETHODCALLTYPE CTextIFilterCF::Release()
{
    unsigned long uTmp = InterlockedDecrement( &_cRefs );

    if ( 0 == uTmp )
        delete this;

    return(uTmp);
}


//+-------------------------------------------------------------------------
//
//  Method:     CTextIFilterCF::CreateInstance
//
//  Synopsis:   Creates new TextIFilter object
//
//  Arguments:  [pUnkOuter] -- 'Outer' IUnknown
//              [riid]      -- Interface to bind
//              [ppvObject] -- Interface returned here
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CTextIFilterCF::CreateInstance( IUnknown * pUnkOuter,
                                                        REFIID riid,
                                                        void  * * ppvObject )
{
    CTextIFilter *  pIUnk = 0;
    SCODE sc = S_OK;

    TRY
    {
        pIUnk = new CTextIFilter();
        sc = pIUnk->QueryInterface(  riid , ppvObject );

        pIUnk->Release();  // Release extra refcount from QueryInterface
    }
    CATCH(CException, e)
    {
        Win4Assert( 0 == pIUnk );

        switch( e.GetErrorCode() )
        {
        case E_OUTOFMEMORY:
            sc = (E_OUTOFMEMORY);
            break;
        default:
            sc = (E_UNEXPECTED);
        }
    }
    END_CATCH;

    return (sc);
}

//+-------------------------------------------------------------------------
//
//  Method:     CTextIFilterCF::LockServer
//
//  Synopsis:   Force class factory to remain loaded
//
//  Arguments:  [fLock] -- TRUE if locking, FALSE if unlocking
//
//  Returns:    S_OK
//
//  History:    23-Feb-1994     KyleP   Created
//
//--------------------------------------------------------------------------

SCODE STDMETHODCALLTYPE CTextIFilterCF::LockServer(BOOL fLock)
{
    if(fLock)
        InterlockedIncrement( &gulcInstances );
    else
        InterlockedDecrement( &gulcInstances );

    return(S_OK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\web\dll\express.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:       express.cxx
//
//  Contents:   Used to parse and evaluate IF expressions
//
//  History:    96/Jan/3    DwightKr    Created
//
//----------------------------------------------------------------------------


#include <pch.cxx>
#pragma hdrstop

// Copied from propvar.h
#define BSTRLEN(bstrVal)        *((ULONG *) bstrVal - 1)

//+---------------------------------------------------------------------------
//
//  Function:   IsEmpty (DBCS version), private
//
//  Arguments:  [pszVal]  -- string to search
//              [cc]      -- size (in chars) of string
//
//  Returns;    TRUE if string is empty (all chars in string space-like things)
//
//  History:    28-Jun-96   KyleP       created
//
//----------------------------------------------------------------------------

BOOL IsEmpty( char const * pszVal, unsigned cc )
{
    //
    // Optimize for the common case: non-empty strings
    //

    WORD aCharType[10];

    unsigned ccProcessed = 0;

    while ( ccProcessed < cc )
    {
        unsigned ccThisPass = (unsigned)min( sizeof(aCharType)/sizeof(aCharType[0]),
                                   cc - ccProcessed );

        if ( !GetStringTypeExA( LOCALE_SYSTEM_DEFAULT,
                                CT_CTYPE1,
                                pszVal + ccProcessed,
                                ccThisPass,
                                aCharType ) )
        {
            ciGibDebugOut(( DEB_ERROR, "Error %d from GetStringTypeExA\n", GetLastError() ));
            return FALSE;
        }

        for ( unsigned i = 0; i < ccThisPass; i++ )
        {
            if ( (aCharType[i] & (C1_SPACE | C1_CNTRL | C1_BLANK)) == 0 )
                return FALSE;
        }

        ccProcessed += ccThisPass;
    }

    return TRUE;
}

//+---------------------------------------------------------------------------
//
//  Function:   IsEmpty (UniCode version), private
//
//  Arguments:  [pwszVal]  -- string to search
//              [cc]      -- size (in chars) of string
//
//  Returns;    TRUE if string is empty (all chars in string space-like things)
//
//  History:    28-Jun-96   KyleP       created
//
//----------------------------------------------------------------------------

BOOL IsEmpty( WCHAR const * pwszVal, unsigned cc )
{
    //
    // Optimize for the common case: non-empty strings
    //

    WORD aCharType[10];

    unsigned ccProcessed = 0;

    while ( ccProcessed < cc )
    {
        unsigned ccThisPass = (unsigned)min( sizeof(aCharType)/sizeof(aCharType[0]),
                                   cc - ccProcessed );

        //
        // NOTE: the unicode version of GetStringTypeEx ignores the locale
        //

        if ( !GetStringTypeExW( LOCALE_SYSTEM_DEFAULT,
                                CT_CTYPE1,
                                pwszVal + ccProcessed,
                                ccThisPass,
                                aCharType ) )
        {
            ciGibDebugOut(( DEB_ERROR, "Error %d from GetStringTypeExA\n", GetLastError() ));
            return FALSE;
        }

        for ( unsigned i = 0; i < ccThisPass; i++ )
        {
            if ( (aCharType[i] & (C1_SPACE | C1_CNTRL | C1_BLANK)) == 0 )
                return FALSE;
        }

        ccProcessed += ccThisPass;
    }

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Function:   StringToSystemTime
//
//  Synopsis:   Read a SystemTime from a string
//
//  Arguments:  [wcsSystemTime] - system time to parse
//              [stUTC]         - resulting system time
//
//  Returns TRUE if the coearcion was possible, FALSE otherwise.
//
//  History:    96/Jun/27   DwightKr    created
//
//----------------------------------------------------------------------------
static BOOL StringToSystemTime( WCHAR const * wcsSystemTime,
                                SYSTEMTIME & stUTC )
{
    if ( 0 == wcsSystemTime )
    {
        return FALSE;
    }

    stUTC.wHour = 0;
    stUTC.wMinute = 0;
    stUTC.wSecond = 0;
    stUTC.wMilliseconds = 0;

    int cItems = swscanf( wcsSystemTime,
                          L"%4hd/%2hd/%2hd %2hd:%2hd:%2hd:%3hd",
                          &stUTC.wYear,
                          &stUTC.wMonth,
                          &stUTC.wDay,
                          &stUTC.wHour,
                          &stUTC.wMinute,
                          &stUTC.wSecond,
                          &stUTC.wMilliseconds );

    return (cItems >= 3);
}


//+---------------------------------------------------------------------------
//
//  Function:   StringToFileTime
//
//  Synopsis:   Read a FileTime from a string
//
//  Arguments:  [wcsSystemTime] - system time to parse
//              [filetime]      - resulting file time
//
//  Returns TRUE if the coearcion was possible, FALSE otherwise.
//
//  History:    96/Jun/27   DwightKr    created
//
//----------------------------------------------------------------------------
static BOOL StringToFileTime( WCHAR const * wcsSystemTime,
                              FILETIME & fileTime )
{
    SYSTEMTIME stUTC;

    if ( !StringToSystemTime( wcsSystemTime, stUTC ) )
    {
        return FALSE;
    }

    return SystemTimeToFileTime( &stUTC, &fileTime );
}


//+---------------------------------------------------------------------------
//
//  Function:   VectorCoerce
//
//  Synopsis:   Coerce's the type of a vector
//
//  Arguments:  [Value]      - value to coerce
//              [type]       - final type desired
//
//  Returns TRUE if the coearcion was possible, FALSE otherwise.
//
//  History:    96/Jun/27   DwightKr    created
//
//----------------------------------------------------------------------------
static BOOL VectorCoerce( CHTXIfExpressionValue & Value,
                           VARTYPE type,
                           PROPVARIANT & propVariant )
{
    ULONG size = Value.GetValue()->cal.cElems;
    _int64          i64Value;
    unsigned _int64 ui64Value;
    double          dblValue;

    switch (type)
    {
    case VT_LPSTR | VT_VECTOR:
    {
        XCoMem<PCHAR> aStr( size );
        for (unsigned i=0; i<size; i++)
        {
            XCoMem<CHAR> pszStringValue;
            if ( !Value.GetVectorValueStr(i, pszStringValue ) )
            {
                return FALSE;
            }

            aStr[i] = pszStringValue.Acquire();
        }

        propVariant.calpstr.cElems = size;
        propVariant.calpstr.pElems = (PCHAR *) aStr.Acquire();
    }
    break;

    case VT_LPWSTR | VT_VECTOR:
    {
        XCoMem<PWCHAR> aWStr( size );
        for (unsigned i=0; i<size; i++)
        {
            XCoMem<WCHAR> wszStringValue;
            if ( !Value.GetVectorValueWStr(i, wszStringValue) )
            {
                return FALSE;
            }

            aWStr[i] = wszStringValue.Acquire();
        }

        propVariant.calpwstr.cElems = size;
        propVariant.calpwstr.pElems = aWStr.Acquire();
    }
    break;

    case VT_BSTR | VT_VECTOR:
    {
        XCoMem<BSTR> aBStr( size );
        for (unsigned i=0; i<size; i++)
        {
            BSTR bwszStringValue;
            if ( !Value.GetVectorValueBStr(i, bwszStringValue) )
            {
                return FALSE;
            }

            aBStr[i] = bwszStringValue;
        }

        propVariant.cabstr.cElems = size;
        propVariant.cabstr.pElems = aBStr.Acquire();
    }
    break;

    case VT_UI1 | VT_VECTOR:
    {
        XCoMem<BYTE> aUI1( size );
        for (unsigned i=0; i<size; i++)
        {
            if ( !Value.GetVectorValueUnsignedInteger(i, ui64Value) ||
                  ui64Value > UCHAR_MAX )
            {
                return FALSE;
            }

            aUI1[i] = (BYTE) ui64Value;
        }

        propVariant.caub.cElems = size;
        propVariant.caub.pElems = aUI1.Acquire();
    }
    break;

    case VT_I1 | VT_VECTOR:
    {
        XCoMem<BYTE> aI1( size );
        for (unsigned i=0; i<size; i++)
        {
            if ( !Value.GetVectorValueInteger(i, i64Value) ||
                 (i64Value < SCHAR_MIN) || (i64Value > SCHAR_MAX) )
            {
                return FALSE;
            }

            aI1[i] = (BYTE) i64Value;
        }

        propVariant.caub.cElems = size;
        propVariant.caub.pElems = aI1.Acquire();
    }
    break;

    case VT_UI2 | VT_VECTOR:
    {
        XCoMem<USHORT> aUI2( size );
        for (unsigned i=0; i<size; i++)
        {
            if ( !Value.GetVectorValueUnsignedInteger(i, ui64Value) ||
                 (ui64Value > USHRT_MAX) )
            {
                return FALSE;
            }

            aUI2[i] = (USHORT) ui64Value;
        }

        propVariant.caui.cElems = size;
        propVariant.caui.pElems = (USHORT *) aUI2.Acquire();
    }
    break;

    case VT_I2 | VT_VECTOR:
    {
        XCoMem<SHORT> aI2( size );
        for (unsigned i=0; i<size; i++)
        {
            if ( !Value.GetVectorValueInteger(i, i64Value) ||
                 (i64Value < SHRT_MIN)|| (i64Value > SHRT_MAX) )
            {
                return FALSE;
            }

            aI2[i] = (SHORT) i64Value;
        }

        propVariant.cai.cElems = size;
        propVariant.cai.pElems = aI2.Acquire();
    }
    break;

    case VT_UI4 | VT_VECTOR:
    {
        XCoMem<ULONG> aUI4( size );
        for (unsigned i=0; i<size; i++)
        {
            if ( !Value.GetVectorValueUnsignedInteger(i, ui64Value) ||
                 (ui64Value > ULONG_MAX) )
            {
                return FALSE;
            }
            aUI4[i] = (ULONG) ui64Value;
        }

        propVariant.caul.cElems = size;
        propVariant.caul.pElems = aUI4.Acquire();
    }
    break;

    case VT_I4 | VT_VECTOR:
    {
        XCoMem<LONG> aI4( size );
        for (unsigned i=0; i<size; i++)
        {
            if ( !Value.GetVectorValueInteger(i, i64Value) ||
                 (i64Value < LONG_MIN) || (i64Value > LONG_MAX) )
            {
                return FALSE;
            }

            aI4[i] = (LONG) i64Value;
        }

        propVariant.cal.cElems = size;
        propVariant.cal.pElems = aI4.Acquire();
    }
    break;

    case VT_UI8 | VT_VECTOR:
    case VT_I8 | VT_VECTOR:
    {
        //
        // hVal used instead of uhVal because latter coercion
        // is not yet supported by x86 compiler.
        //

        XCoMem<LARGE_INTEGER> aUI8( size );
        for (unsigned i=0; i<size; i++)
        {
            if ( !Value.GetVectorValueInteger(i, i64Value) )
            {
                return FALSE;
            }

            aUI8[i].QuadPart = i64Value;
        }

        propVariant.cah.cElems = size;
        propVariant.cah.pElems = aUI8.Acquire();
    }
    break;

    case VT_R4 | VT_VECTOR:
    {
        XCoMem<float> aR4( size );
        for (unsigned i=0; i<size; i++)
        {
            if ( !Value.GetVectorValueDouble(i, dblValue) ||
                 (dblValue < -FLT_MAX) || (dblValue > FLT_MAX) )
            {
                return FALSE;
            }

            aR4[i] = (float) dblValue;
        }

        propVariant.caflt.cElems = size;
        propVariant.caflt.pElems = aR4.Acquire();
    }
    break;

    case VT_R8 | VT_VECTOR:
    {
        XCoMem<double> aR8( size );
        for (unsigned i=0; i<size; i++)
        {
            if ( !Value.GetVectorValueDouble(i, dblValue) )
            {
                return FALSE;
            }

            aR8[i] = (double) dblValue;
        }

        propVariant.cadbl.cElems = size;
        propVariant.cadbl.pElems = aR8.Acquire();
    }
    break;

    case VT_BOOL | VT_VECTOR:
    {
        XCoMem<VARIANT_BOOL> aBOOL( size );
        for (unsigned i=0; i<size; i++)
        {
            if ( Value.GetType() == (VT_LPWSTR | VT_VECTOR) )
            {
                if ( (_wcsicmp(Value.GetValue()->calpwstr.pElems[i], L"TRUE") == 0) ||
                     (_wcsicmp(Value.GetValue()->calpwstr.pElems[i], L"T") == 0)
                   )
                {
                    aBOOL[i] = VARIANT_TRUE;
                }
                else if ( (_wcsicmp(Value.GetValue()->calpwstr.pElems[i], L"FALSE") == 0) ||
                          (_wcsicmp(Value.GetValue()->calpwstr.pElems[i], L"F") == 0)
                        )
                {
                    aBOOL[i] = VARIANT_FALSE;
                }
                else
                {
                    return FALSE;
                }
            }
            else
            {
                if ( !Value.GetVectorValueInteger(i, i64Value) )
                {
                    return FALSE;
                }

                aBOOL[i] = (VARIANT_BOOL) i64Value != VARIANT_FALSE;
            }
        }

        propVariant.cabool.cElems = size;
        propVariant.cabool.pElems = aBOOL.Acquire();
    }
    break;

    case VT_DATE | VT_VECTOR:
    {
        //
        //  Dates are in the format YYYY/MM/DD hh:mm:ss:ii
        //

        if ( Value.GetType() != (VT_LPWSTR | VT_VECTOR) )
        {
            return FALSE;
        }

        XCoMem<DATE> aDate( size );
        for (unsigned i=0; i<size; i++)
        {
            SYSTEMTIME stUTC;

            if ( !StringToSystemTime( Value.GetValue()->calpwstr.pElems[i],
                                      stUTC )
               )
            {
                return FALSE;
            }

            if ( !SystemTimeToVariantTime( &stUTC, &aDate[i] ) )
            {
                return FALSE;
            }
        }

        propVariant.cadate.cElems = size;
        propVariant.cadate.pElems = aDate.Acquire();
    }
    break;

    case VT_FILETIME | VT_VECTOR:
    {
        //
        //  FileTimes are in the format YYYY/MM/DD hh:mm:ss:ii
        //

        if ( Value.GetType() != (VT_LPWSTR | VT_VECTOR) )
        {
            return FALSE;
        }

        XCoMem<FILETIME> aFileTime( size );
        for (unsigned i=0; i<size; i++)
        {
            SYSTEMTIME stUTC;

            if ( !StringToFileTime( Value.GetValue()->calpwstr.pElems[i],
                                    aFileTime[i] )
               )
            {
                return FALSE;
            }
        }

        propVariant.cafiletime.cElems = size;
        propVariant.cafiletime.pElems = aFileTime.Acquire();
    }
    break;

    case VT_CY | VT_VECTOR:
    {
        XCoMem<CY> acy( size );
        for (unsigned i=0; i<size; i++)
        {
            if ( !Value.GetVectorValueDouble(i, dblValue) )
            {
                return FALSE;
            }

            VarCyFromR8( dblValue, &acy[i] );
        }

        propVariant.cacy.cElems = size;
        propVariant.cacy.pElems = acy.Acquire();
    }
    break;

    default:
        return FALSE;
    break;
    }

    propVariant.vt = type;

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Function:   wcsistr
//
//  Synopsis:   A case-insensitive, WCHAR implemtation or strstr.
//
//  Arguments:  [wcsString]  - string to search
//              [wcsPattern] - pattern to look for
//
//  Returns;    pointer to pattern, 0 if no match found.
//
//  History:    96/Mar/12   DwightKr    created
//
//----------------------------------------------------------------------------
static WCHAR const * wcsistr( WCHAR const * wcsString, WCHAR const * wcsPattern )
{
    if ( (wcsPattern == 0) || (*wcsPattern == 0) )
    {
        return wcsString;
    }

    ULONG cwcPattern = wcslen(wcsPattern);

    while ( *wcsString != 0 )
    {
        while ( (*wcsString != 0) &&
                (towupper(*wcsString) != towupper(*wcsPattern))
              )
        {
            wcsString++;
        }

        if ( 0 == *wcsString )
        {
            return 0;
        }

        if ( _wcsnicmp( wcsString, wcsPattern, cwcPattern) == 0 )
        {
            return wcsString;
        }

        wcsString++;
    }

    return 0;
}


//+---------------------------------------------------------------------------
//
//  Function:   GetDoubleFromVariant - static
//
//  Synopsis:   Converts a numerical value in a variant to a double.
//
//  History:    96/Jan/03   DwightKr    created
//
//----------------------------------------------------------------------------
static double GetDoubleFromVariant( PROPVARIANT * pVariant )
{
    switch (pVariant->vt)
    {
    case VT_UI1:
        return (double)pVariant->bVal;
    break;

    case VT_I1:
        return (double)(char)pVariant->bVal;
    break;

    case VT_UI2:
        return (double)pVariant->uiVal;
    break;

    case VT_I2:
        return (double)pVariant->iVal;
    break;

    case VT_UI4:
    case VT_UINT:
        return (double)pVariant->ulVal;
    break;

    case VT_I4:
    case VT_INT:
    case VT_ERROR:
        return (double)pVariant->lVal;
    break;

    case VT_UI8:
        //
        // hVal used instead of uhVal because latter coercion
        // is not yet supported by x86 compiler.
        //
        return (double)pVariant->hVal.QuadPart;
    break;

    case VT_I8:
        return (double) pVariant->hVal.QuadPart;
    break;

    case VT_R4:
        return (double)pVariant->fltVal;
    break;

    case VT_R8:
        return pVariant->dblVal;
    break;

    case VT_BOOL:
        return (double)( VARIANT_FALSE != pVariant->boolVal );
    break;

    case VT_DATE:
        return (double) pVariant->date;
    break;

    case VT_CY:
    {
        double dblValue;

        VarR8FromCy( pVariant->cyVal, &dblValue );

        return dblValue;
    }
    case VT_DECIMAL:
    {
        double dblValue;

        VarR8FromDec( & pVariant->decVal, &dblValue );

        return dblValue;
    }
    break;

    default:
        Win4Assert( !"VT_TYPE not supported in GetDoubleFromVariant" );
    break;
    }

    return 0.0;
}


//+---------------------------------------------------------------------------
//
//  Function:   GetI64FromVariant - static
//
//  Synopsis:   Converts a numerical value in a variant to a _int64
//
//  History:    96/Jan/03   DwightKr    created
//
//----------------------------------------------------------------------------
static _int64 GetI64FromVariant( PROPVARIANT * pVariant )
{
    switch (pVariant->vt)
    {
    case VT_UI1:
        return (_int64)pVariant->bVal;
    break;

    case VT_I1:
        return (_int64)pVariant->bVal;
    break;

    case VT_UI2:
        return (_int64)pVariant->uiVal;
    break;

    case VT_I2:
        return (_int64)pVariant->iVal;
    break;

    case VT_UI4:
    case VT_UINT:
        return (_int64)pVariant->ulVal;
    break;

    case VT_I4:
    case VT_INT:
    case VT_ERROR:
        return (_int64)pVariant->lVal;
    break;

    case VT_UI8:
        return (_int64)pVariant->uhVal.QuadPart;
    break;

    case VT_I8:
        return pVariant->hVal.QuadPart;
    break;

    case VT_R4:
        Win4Assert( !"VT_R4 not supported in GetI64FromVariant, use GetDoubleFromVariant" );
    break;

    case VT_R8:
        Win4Assert( !"VT_R8 not supported in GetI64FromVariant, use GetDoubleFromVariant" );
    break;

    case VT_DECIMAL:
        Win4Assert( !"VT_DECIMAL not supported in GetI64FromVariant, use GetDoubleFromVariant" );
    break;

    case VT_DATE:
    {
        LONG lValue;
        VarI4FromDate( pVariant->date, & lValue );

        return lValue;
    }
    break;

    case VT_BOOL:
        return (_int64) ( VARIANT_FALSE != pVariant->boolVal );
    break;

    case VT_CY:
    {
        return (_int64) pVariant->cyVal.Hi;
    }
    break;

    default:
        Win4Assert( !"VT_TYPE not supported in GetI64FromVariant" );
    break;
    }

    return 0;
}


//+---------------------------------------------------------------------------
//
//  Method:     CHTXIfExpression::CHTXIfExpression - public constructor
//
//  Synopsis:   Builds a CHTXIfExpression object, and determines if
//              this is an IF expression.
//
//  Arguments:  [scanner]     - parser containing the line to be parsed
//              [variableSet] - list of replaceable parameters
//
//  History:    96/Jan/03   DwightKr    created
//
//----------------------------------------------------------------------------
CHTXIfExpression::CHTXIfExpression( CTokenizeString & scanner,
                                    CVariableSet & variableSet,
                                    COutputFormat & outputFormat ) :
                                      _scanner(scanner),
                                      _variableSet(variableSet),
                                      _outputFormat(outputFormat)
{
    //
    //  The first word better be an 'if'
    //
    Win4Assert ( _scanner.LookAhead() == TEXT_TOKEN );

    XPtrST<WCHAR> wcsIf( _scanner.AcqWord() );

    Win4Assert( _wcsicmp(wcsIf.GetPointer(), L"if") == 0 );

    _scanner.Accept();                  // Skip over the "if"
}


//+---------------------------------------------------------------------------
//
//  Method:     CHTXIfExpression::Evaluate - public
//
//  Synopsis:   Evaluates an IF expression by breaking it up into the
//              left-side, operator & right-side.
//
//  Returns:    TRUE or FALSE - the evaluation of the IF expression
//
//  History:    96/Jan/03   DwightKr    created
//
//----------------------------------------------------------------------------
BOOL CHTXIfExpression::Evaluate()
{
    CHTXIfExpressionValue    lhValue( _scanner, _variableSet, _outputFormat );
    lhValue.ParseValue();

    CHTXIfExpressionOperator ifOperator( _scanner );
    ifOperator.ParseOperator();

    if ( ifOperator.Operator() != ISEMPTY_TOKEN )
    {
        CHTXIfExpressionValue    rhValue( _scanner, _variableSet, _outputFormat );
        rhValue.ParseValue();

        return ifOperator.Evaluate( lhValue, rhValue );
    }
    else
    {
        if ( _scanner.LookAhead() != EOS_TOKEN )
            THROW( CHTXException( MSG_CI_HTX_EXPECTING_OPERATOR, 0, 0 ) );

        return ifOperator.Evaluate( lhValue );
    }
}


//+---------------------------------------------------------------------------
//
//  Method:     CHTXIfExpressionValue::CHTXIfExpressionValue - public constructor
//
//  Synopsis:   Parses one half of an IF expression and determines its value
//
//  Parameters: [scanner]     - parser containing the IF to be parsed
//              [variableSet] - list of replaceable paremeters
//
//  History:    96/Jan/03   DwightKr    created
//
//----------------------------------------------------------------------------
CHTXIfExpressionValue::CHTXIfExpressionValue( CTokenizeString & scanner,
                                              CVariableSet & variableSet,
                                              COutputFormat & outputFormat) :
                                              _scanner(scanner),
                                              _variableSet(variableSet),
                                              _outputFormat(outputFormat),
                                              _wcsStringValue(0),
                                              _fOwnVector(FALSE),
                                              _fIsConstant(FALSE)
{
}


//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
CHTXIfExpressionValue::~CHTXIfExpressionValue()
{
    delete _wcsStringValue;

    if ( _fOwnVector )
    {
        Win4Assert ( ( _propVariant.vt & VT_VECTOR ) != 0 );
        if ( _propVariant.vt == ( VT_LPWSTR | VT_VECTOR ) )
        {
            for (unsigned i=0; i<_propVariant.calpwstr.cElems; i++)
            {
                delete _propVariant.calpwstr.pElems[i];
            }
        }

        delete _propVariant.cal.pElems;
    }
}


//+---------------------------------------------------------------------------
//
//  Method:     CHTXIfExpressionValue::ParseValue - public
//
//  Synopsis:   Parses one side of an IF expression.
//
//  History:    96/Jan/03   DwightKr    created
//              96/Feb/13   DwightKr    add suppport for quoted strings
//
//----------------------------------------------------------------------------
void CHTXIfExpressionValue::ParseValue()
{
    //
    //  The first token on this line must be a word/phrase, and not an
    //  operator. It may be quoted.
    //
    _fIsConstant = TRUE;                // Assume it is a constant, not a var

    if ( _scanner.LookAhead() == QUOTES_TOKEN )
    {
        _scanner.AcceptQuote();                  // Skip over the opening "
        _propVariant.vt = VT_LPWSTR;

        _wcsStringValue = _scanner.AcqPhrase();
        _scanner.Accept();              // Skip over the string

        if ( _scanner.LookAhead() != QUOTES_TOKEN )
        {
            THROW( CHTXException(MSG_CI_HTX_MISSING_QUOTE, 0, 0) );
        }

        _scanner.Accept();              // Skip over the closing "
    }
    else if (_scanner.LookAhead() == C_OPEN_TOKEN )
    {
        _scanner.Accept();                  // Skip over the opening {
        _scanner.AcqVector( _propVariant );
        _fOwnVector = TRUE;

        if ( _scanner.LookAhead() != C_CLOSE_TOKEN )
        {
            THROW( CHTXException(MSG_CI_HTX_MISSING_BRACKET, 0, 0) );
        }

        _scanner.Accept();              // Skip over the closing }
    }
    else
    {
        if ( _scanner.LookAhead() != TEXT_TOKEN )
        {
            THROW( CHTXException(QPARSE_E_UNEXPECTED_EOS, 0, 0) );
        }

        //
        //  Determine if this is a number, or a string.  If it is a string,
        //  then look it up in the variableSet.  If it's defined in the
        //  variableSet, look up its value, and determine if this new value
        //  is a number.
        //
        if ( _scanner.GetGUID( _guid ) )
        {
            _propVariant.vt = VT_CLSID;
            _propVariant.puuid = &_guid;
        }
        else if ( _scanner.GetNumber( (unsigned _int64) *((unsigned _int64 *) (&_propVariant.uhVal)) ) )
        {
            _propVariant.vt = VT_UI8;
        }
        else if ( _scanner.GetNumber( (_int64) *((_int64 *) (&_propVariant.hVal))  ) )
        {
            _propVariant.vt = VT_I8;
        }
        else if ( _scanner.GetNumber( _propVariant.dblVal ) )
        {
            _propVariant.vt = VT_R8;
        }
        else
        {
            //
            //  Its not a number, get its value in a local buffer.
            //
            _propVariant.vt = VT_LPWSTR;
            XPtrST<WCHAR> wcsVariableName( _scanner.AcqWord() );

            //
            //  Try to find this variable/string in the variableSet
            //
            CVariable *pVariable = _variableSet.Find( wcsVariableName.GetPointer() );

            if ( 0 != pVariable )
            {
                _fIsConstant = FALSE;

                //
                //  We have a variable with this name.  Get its string value.
                //
                ULONG cwcValue;
                WCHAR * wcsValue = pVariable->GetStringValueRAW(_outputFormat, cwcValue);

                _wcsStringValue = new WCHAR[ cwcValue + 1 ];
                RtlCopyMemory( _wcsStringValue,
                               wcsValue,
                               (cwcValue+1) * sizeof(WCHAR) );

                _propVariant = *pVariable->GetValue();
            }
            else
            {
                //
                //  The variable name could not be found.
                //
                _wcsStringValue = wcsVariableName.Acquire();
            }
        }

        _scanner.Accept();              // Skip over the "value"
    }
}


//+---------------------------------------------------------------------------
//
//  Method:     CHTXIfExpressionValue::GetStringValue - public
//
//  Synopsis:   Returns the string value of the variable
//
//  History:    96/Jan/03   DwightKr    created
//
//----------------------------------------------------------------------------
WCHAR * CHTXIfExpressionValue::GetStringValue()
{
    if ( 0 == _wcsStringValue )
    {
        switch ( _propVariant.vt )
        {
        case VT_I4:
            _wcsStringValue = new WCHAR[20];
            _itow( _propVariant.ulVal, _wcsStringValue, 10 );
        break;

        case VT_UI4:
            _wcsStringValue = new WCHAR[20];
            _itow( _propVariant.lVal, _wcsStringValue, 10 );
        break;

        case VT_R8:
            _wcsStringValue = new WCHAR[320];
            swprintf( _wcsStringValue, L"%f", _propVariant.dblVal );
        break;

        default:
            _wcsStringValue = new WCHAR[1];
            _wcsStringValue[0] = 0;
        break;
        }
    }

    return _wcsStringValue;
}


//+---------------------------------------------------------------------------
//
//  Method:     CHTXIfExpressionOperator::CHTXIfExpressionOperator - public constructor
//
//  Synopsis:   Parses the operator in an IF expression
//
//  Parameters: [scanner]     - parser containing the operator to be parsed
//
//  History:    96/Jan/03   DwightKr    created
//
//----------------------------------------------------------------------------
CHTXIfExpressionOperator::CHTXIfExpressionOperator( CTokenizeString & scanner ) :
                               _scanner(scanner), _operator(EQUAL_TOKEN)
{
}


//+---------------------------------------------------------------------------
//
//  Method:     CHTXIfExpressionOperator::ParseOperator - public
//
//  Synopsis:   Parses the operator in an IF expression
//
//  History:    96/Jan/03   DwightKr    created
//
//----------------------------------------------------------------------------
void CHTXIfExpressionOperator::ParseOperator()
{
    //
    //  The first token on this line must be a word, and not an operator.
    //  We're looking for operators such as eq, ne, gt, ...
    //
    if ( _scanner.LookAhead() != TEXT_TOKEN )
    {
        THROW( CHTXException(MSG_CI_HTX_EXPECTING_OPERATOR, 0, 0) );
    }

    XPtrST<WCHAR> wcsOperator( _scanner.AcqWord() );

    if ( 0 == wcsOperator.GetPointer() )
        THROW( CHTXException(MSG_CI_HTX_EXPECTING_OPERATOR, 0, 0) );

    if ( wcscmp(wcsOperator.GetPointer(), L"EQ") == 0 )
    {
        _operator = EQUAL_TOKEN;
    }
    else if ( wcscmp(wcsOperator.GetPointer(), L"NE") == 0 )
    {
        _operator = NOT_EQUAL_TOKEN;
    }
    else if ( wcscmp(wcsOperator.GetPointer(), L"GT") == 0 )
    {
        _operator = GREATER_TOKEN;
    }
    else if ( wcscmp(wcsOperator.GetPointer(), L"GE") == 0 )
    {
        _operator = GREATER_EQUAL_TOKEN;
    }
    else if ( wcscmp(wcsOperator.GetPointer(), L"LT") == 0 )
    {
        _operator = LESS_TOKEN;
    }
    else if ( wcscmp(wcsOperator.GetPointer(), L"LE") == 0 )
    {
        _operator = LESS_EQUAL_TOKEN;
    }
    else if ( wcscmp(wcsOperator.GetPointer(), L"CONTAINS") == 0 )
    {
        _operator = CONTAINS_TOKEN;
    }
    else if ( wcscmp(wcsOperator.GetPointer(), L"ISEMPTY") == 0 )
    {
        _operator = ISEMPTY_TOKEN;
    }
    else if ( wcscmp(wcsOperator.GetPointer(), L"ISTYPEEQ") == 0 )
    {
        _operator = ISTYPEEQUAL_TOKEN;
    }
    else
    {
        THROW( CHTXException(MSG_CI_HTX_EXPECTING_OPERATOR, 0, 0) );
    }

    _scanner.Accept();                  // Skip over the "operator"
}


//+---------------------------------------------------------------------------
//
//  Method:     CHTXIfExpressionOperator::Evaluate - public
//
//  Synopsis:   Using the operator already obtained, it evaluates a TRUE/FALSE
//              result by comparing the lhValue and the rhValue.
//
//  Arguments:  [lhValue] - left hand value of the IF statement
//              [rhValue] - right hand value of the IF statement
//
//  History:    96/Jan/03   DwightKr    created
//
//----------------------------------------------------------------------------
BOOL CHTXIfExpressionOperator::Evaluate( CHTXIfExpressionValue & lhValue,
                                         CHTXIfExpressionValue & rhValue )
{
    //
    //  If the operator is CONTAINS_TOKEN, then we'll simply do a wcsistr
    //  of the string representations of the two values.
    //
    if ( CONTAINS_TOKEN == _operator )
    {
        return wcsistr(lhValue.GetStringValue(), rhValue.GetStringValue()) != 0;
    }

    //
    //  We must setup the comparision functions to examine like types.
    //  The type of lhValue and rhValue must be converted to like types.
    //  If any one of them is a string, then we'll treat both of them
    //  like strings.
    //

    PROPVARIANT lhVariant;
    PROPVARIANT rhVariant;

    SPropVariant xlhPropVariant;
    SPropVariant xrhPropVariant;

    //
    //  If neither one are vectors, perform the following conversions
    //
    if ( ((lhValue.GetType() & VT_VECTOR) == 0) &&
         ((rhValue.GetType() & VT_VECTOR) == 0) )
    {
        if ( (lhValue.GetType() == VT_LPWSTR) ||
             (rhValue.GetType() == VT_LPWSTR) ||
             (lhValue.GetType() == VT_LPSTR) ||
             (rhValue.GetType() == VT_LPSTR) ||
             (lhValue.GetType() == VT_BSTR) ||
             (rhValue.GetType() == VT_BSTR)
           )
        {
            lhVariant.vt = VT_LPWSTR;
            rhVariant.vt = VT_LPWSTR;

            lhVariant.pwszVal = lhValue.GetStringValue();
            rhVariant.pwszVal = rhValue.GetStringValue();
        }
        else if (lhValue.GetType() == rhValue.GetType() ||
                 lhValue.GetType() == VT_EMPTY ||
                 rhValue.GetType() == VT_EMPTY)
        {
            lhVariant = *lhValue.GetValue();
            rhVariant = *rhValue.GetValue();
        }
        else if ( (lhValue.GetType() == VT_FILETIME) ||
                  (rhValue.GetType() == VT_FILETIME) )
        {
            if ( lhValue.GetType() == VT_LPWSTR )
            {
                if ( !StringToFileTime( lhValue.GetValue()->pwszVal,
                                        lhVariant.filetime )
                   )
                {
                    return FALSE;
                }

                lhVariant.vt = VT_FILETIME;
                rhVariant = *rhValue.GetValue();
            }
            else if ( rhValue.GetType() == VT_LPWSTR )
            {
                if ( !StringToFileTime( rhValue.GetValue()->pwszVal,
                                        rhVariant.filetime )
                   )
                {
                    return FALSE;
                }

                rhVariant.vt = VT_FILETIME;
                lhVariant = *lhValue.GetValue();
            }
        }
        else if ( (lhValue.GetType() == VT_R4) || (lhValue.GetType() == VT_R8) ||
                  (rhValue.GetType() == VT_R4) || (rhValue.GetType() == VT_R8) ||
                  (lhValue.GetType() == VT_CY) || (rhValue.GetType() == VT_CY) ||
                  (lhValue.GetType() == VT_DECIMAL) || (rhValue.GetType() == VT_DECIMAL) ||
                  (lhValue.GetType() == VT_DATE) || (rhValue.GetType() == VT_DATE)
                )
        {
            //
            //  At least one of them is a floating number.  Convert them both
            //  to floating point.
            //
            lhVariant.vt = VT_R8;
            rhVariant.vt = VT_R8;

            lhVariant.dblVal = GetDoubleFromVariant( lhValue.GetValue() );
            rhVariant.dblVal = GetDoubleFromVariant( rhValue.GetValue() );
        }
        else if ( (lhValue.GetType() == VT_I8)  || (lhValue.GetType() == VT_I4) ||
                  (lhValue.GetType() == VT_I2)  || (lhValue.GetType() == VT_I1) ||
                  (rhValue.GetType() == VT_I8)  || (rhValue.GetType() == VT_I4) ||
                  (rhValue.GetType() == VT_I2)  || (rhValue.GetType() == VT_I1) ||
                  (lhValue.GetType() == VT_INT) || (rhValue.GetType() == VT_INT)
                )
        {
            lhVariant.vt = VT_I8;
            rhVariant.vt = VT_I8;

            lhVariant.hVal.QuadPart = GetI64FromVariant( lhValue.GetValue() );
            rhVariant.hVal.QuadPart = GetI64FromVariant( rhValue.GetValue() );
        }
        else if ( (lhValue.GetType() == VT_UI8)  || (lhValue.GetType() == VT_UI4) ||
                  (lhValue.GetType() == VT_UI2)  || (lhValue.GetType() == VT_UI1) ||
                  (rhValue.GetType() == VT_UI8)  || (rhValue.GetType() == VT_UI4) ||
                  (rhValue.GetType() == VT_UI2)  || (rhValue.GetType() == VT_UI1) ||
                  (lhValue.GetType() == VT_UINT) || (rhValue.GetType() == VT_UINT)
                )
        {
            lhVariant.vt = VT_UI8;
            rhVariant.vt = VT_UI8;

            lhVariant.uhVal.QuadPart = GetI64FromVariant( lhValue.GetValue() );
            rhVariant.uhVal.QuadPart = GetI64FromVariant( rhValue.GetValue() );
        }
        else
        {
            lhVariant = *lhValue.GetValue();
            rhVariant = *rhValue.GetValue();
        }
    }
    else if ( ((lhValue.GetType() & VT_VECTOR) != 0) &&
              ((rhValue.GetType() & VT_VECTOR) != 0)
            )
    {
        //
        //  Both are vectors
        //

        //
        //  If the vector's are of different types, attempt to Coerce one
        //  type into the other.
        //
        if ( lhValue.GetType() != rhValue.GetType() )
        {
            //
            //  Coerce the types to be the same if possible. Attempt to
            //  Coerce a constant into the type of the variable, rather
            //  then vise versa.  If this fails, attempt the opposite
            //  coearison.
            //
            if ( lhValue.IsConstant() )
            {
                if ( VectorCoerce( lhValue, rhValue.GetType(), lhVariant ) )
                {
                    Win4Assert( xlhPropVariant.IsNull() );
                    xlhPropVariant.Set( &lhVariant );
                    rhVariant = *rhValue.GetValue();
                }
                else
                {
                    if ( VectorCoerce( rhValue, lhValue.GetType(), rhVariant ) )
                    {
                        Win4Assert( xrhPropVariant.IsNull() );
                        xrhPropVariant.Set( &rhVariant );
                        lhVariant = *lhValue.GetValue();
                    }
                }
            }
            else if ( rhValue.IsConstant() )
            {
                if ( VectorCoerce( rhValue, lhValue.GetType(), rhVariant ) )
                {
                    Win4Assert( xrhPropVariant.IsNull() );
                    xrhPropVariant.Set( &rhVariant );
                    lhVariant = *lhValue.GetValue();
                }
                else
                {
                    if ( VectorCoerce( lhValue, rhValue.GetType(), lhVariant ) )
                    {
                        Win4Assert( xlhPropVariant.IsNull() );
                        xlhPropVariant.Set( &lhVariant );
                        rhVariant = *rhValue.GetValue();
                    }
                }
            }
            else
            {
                lhVariant = *lhValue.GetValue();
                rhVariant = *rhValue.GetValue();
            }

        }
        else
        {
            lhVariant = *lhValue.GetValue();
            rhVariant = *rhValue.GetValue();
        }
    }
    else
    {
        lhVariant = *lhValue.GetValue();
        rhVariant = *rhValue.GetValue();
    }

    switch ( _operator )
    {
    case EQUAL_TOKEN:
        return VT_VARIANT_EQ( lhVariant, rhVariant );
    break;

    case NOT_EQUAL_TOKEN:
        return VT_VARIANT_NE( lhVariant, rhVariant );
    break;

    case GREATER_TOKEN:
        return VT_VARIANT_GT( lhVariant, rhVariant );
    break;

    case GREATER_EQUAL_TOKEN:
        return VT_VARIANT_GE( lhVariant, rhVariant );
    break;

    case LESS_TOKEN:
        return VT_VARIANT_LT( lhVariant, rhVariant );
    break;

    case LESS_EQUAL_TOKEN:
        return VT_VARIANT_LE( lhVariant, rhVariant );
    break;

    case ISTYPEEQUAL_TOKEN:
    {
        //
        //  Three valid cases exist:
        //
        //      if variable IsTypeEQ constant
        //      if constant IsTypeEQ variable
        //      if variable IsTypeEQ variable
        //
        //  Therefore, at least ONE of them must be a variable.
        //
        if ( lhValue.IsConstant() && rhValue.IsConstant() )
        {
            THROW( CHTXException(MSG_CI_HTX_ISTYPEEQUAL_WITH_CONSTANTS, 0, 0) );
        }

        //
        //  If a constant is used, then it must be of type I4. Not floating,
        //  guid, vector, etc.
        //
        if ( lhValue.IsConstant() )
        {
            if ( lhValue.GetType() != VT_UI4 )
            {
                THROW( CHTXException(MSG_CI_HTX_ISTYPEEQUAL_INVALID_CONSTANT, 0, 0) );
            }

            return lhValue.GetValue()->ulVal == (ULONG) rhValue.GetType();
        }
        else if ( rhValue.IsConstant() )
        {
            if ( rhValue.GetType() != VT_UI4 )
            {
                THROW( CHTXException(MSG_CI_HTX_ISTYPEEQUAL_INVALID_CONSTANT, 0, 0) );
            }

            return rhValue.GetValue()->ulVal == (ULONG) lhValue.GetType();
        }
        else
        {
            return lhValue.GetType() == rhValue.GetType();
        }
    }
    break;

    default:
        Win4Assert(!"Illegal case in NON-VECTOR CExpressionOperator::Evaluate" );
        return FALSE;
    break;
    }

    return FALSE;
}


//+---------------------------------------------------------------------------
//
//  Method:     CHTXIfExpressionOperator::Evaluate - public
//
//  Synopsis:   Using the operator already obtained, it evaluates a TRUE/FALSE
//              result by comparing the lhValue and the rhValue.
//
//  Arguments:  [lhValue] - left hand value of the IF statement
//
//  History:    29-Jun-96   KyleP       created
//
//----------------------------------------------------------------------------

BOOL CHTXIfExpressionOperator::Evaluate( CHTXIfExpressionValue & lhValue )
{
    Win4Assert( ISEMPTY_TOKEN == _operator );

    BOOL fEmpty;
    ULONG vt = lhValue.GetType();

    switch ( vt )
    {
    case VT_EMPTY:
    case VT_NULL:
        fEmpty = TRUE;
        break;

    case VT_LPSTR:
    {
        char const * pszVal = lhValue.GetValue()->pszVal;
        unsigned cc = strlen( pszVal );

        fEmpty = IsEmpty( pszVal, cc );
        break;
    }

    case VT_LPSTR | VT_VECTOR:
    {
        for ( unsigned i = 0; i < lhValue.GetValue()->calpstr.cElems; i++ )
        {
        char const * pszVal = lhValue.GetValue()->calpstr.pElems[i];
        unsigned cc = strlen( pszVal );
        fEmpty = IsEmpty( pszVal, cc );

        if ( !fEmpty )
        break;
        }

        break;
    }

    case VT_BSTR:
    {
        WCHAR const * pwszVal = lhValue.GetValue()->bstrVal;
        unsigned cc = BSTRLEN( lhValue.GetValue()->bstrVal );

        fEmpty = IsEmpty( pwszVal, cc );
        break;
    }

    case VT_BSTR | VT_VECTOR:
    {
        for ( unsigned i = 0; i < lhValue.GetValue()->cabstr.cElems; i++ )
        {
        WCHAR const * pwszVal = lhValue.GetValue()->cabstr.pElems[i];
        unsigned cc = BSTRLEN( lhValue.GetValue()->cabstr.pElems[i] );

        fEmpty = IsEmpty( pwszVal, cc );

        if ( !fEmpty )
        break;
        }

        break;
    }

    case VT_LPWSTR:
    {
        WCHAR const * pwszVal = lhValue.GetValue()->pwszVal;
        unsigned cc = wcslen( pwszVal );

        fEmpty = IsEmpty( pwszVal, cc );
        break;
    }

    case VT_LPWSTR | VT_VECTOR:
    {
        for ( unsigned i = 0; i < lhValue.GetValue()->calpwstr.cElems; i++ )
        {
        WCHAR const * pwszVal = lhValue.GetValue()->calpwstr.pElems[i];
        unsigned cc = wcslen( pwszVal );
        fEmpty = IsEmpty( pwszVal, cc );

        if ( !fEmpty )
        break;
        }

        break;
    }

    default:
        fEmpty = FALSE;
    }

    return fEmpty;
}


//+---------------------------------------------------------------------------
//
//  Method:     CHTXIfExpressionValue::GetVectorValueInteger, public
//
//  Synopsis:   Returns the _int64 value of a vector's element
//
//  History:    96/Jun/27   DwightKr    created
//
//----------------------------------------------------------------------------
BOOL CHTXIfExpressionValue::GetVectorValueInteger( unsigned index,
                                                  _int64 & i64Value )
{
    switch ( GetType() )
    {
    case VT_UI1 | VT_VECTOR:
        i64Value = (_int64) _propVariant.caub.pElems[index];
    break;

    case VT_I1 | VT_VECTOR:
        i64Value = (_int64) _propVariant.caub.pElems[index];
    break;

    case VT_UI2 | VT_VECTOR:
        i64Value = (_int64) _propVariant.caui.pElems[index];
    break;

    case VT_I2 | VT_VECTOR:
        i64Value = (_int64) _propVariant.cai.pElems[index];
    break;

    case VT_UI4 | VT_VECTOR:
        i64Value = (_int64) _propVariant.caul.pElems[index];
    break;

    case VT_I4 | VT_VECTOR:
        i64Value = (_int64) _propVariant.cal.pElems[index];
    break;

    case VT_UI8 | VT_VECTOR:
        i64Value = (_int64) _propVariant.cauh.pElems[index].QuadPart;
    break;

    case VT_I8 | VT_VECTOR:
        i64Value = (_int64) _propVariant.cah.pElems[index].QuadPart;
    break;

    case VT_R4 | VT_VECTOR:
        return FALSE;
    break;

    case VT_R8 | VT_VECTOR:
        return FALSE;
    break;

    case VT_DATE | VT_VECTOR:
    {
        LONG lValue;
        VarI4FromDate( _propVariant.cadate.pElems[index], &lValue );

        i64Value = lValue;
    }
    break;

    case VT_BOOL | VT_VECTOR:
        i64Value = (_int64) ( VARIANT_FALSE != _propVariant.cabool.pElems[index] );
    break;

    case VT_CY | VT_VECTOR:
    {
        return FALSE;
    }
    break;

    default:
        return FALSE;
    break;
    }

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Method:     CHTXIfExpressionValue::GetVectorValueUnsignedInteger, public
//
//  Synopsis:   Returns the unsigned _int64 value of a vector's element
//
//  History:    96/Jun/27   DwightKr    created
//
//----------------------------------------------------------------------------
BOOL CHTXIfExpressionValue::GetVectorValueUnsignedInteger( unsigned index,
                                                           unsigned _int64 & ui64Value )
{
    switch ( GetType() )
    {
    case VT_UI1 | VT_VECTOR:
        ui64Value = (unsigned _int64) _propVariant.caub.pElems[index];
    break;

    case VT_I1 | VT_VECTOR:
        ui64Value = (unsigned _int64) _propVariant.caub.pElems[index];
    break;

    case VT_UI2 | VT_VECTOR:
        ui64Value = (unsigned _int64) _propVariant.caui.pElems[index];
    break;

    case VT_I2 | VT_VECTOR:
        if ( _propVariant.cai.pElems[index] < 0 )
            return FALSE;

        ui64Value = (unsigned _int64) _propVariant.cai.pElems[index];
    break;

    case VT_UI4 | VT_VECTOR:
        ui64Value = (unsigned _int64) _propVariant.caul.pElems[index];
    break;

    case VT_I4 | VT_VECTOR:
        if ( _propVariant.cal.pElems[index] < 0 )
            return FALSE;

        ui64Value = (unsigned _int64) _propVariant.cal.pElems[index];
    break;

    case VT_UI8 | VT_VECTOR:
        ui64Value = (unsigned _int64) _propVariant.cauh.pElems[index].QuadPart;
    break;

    case VT_I8 | VT_VECTOR:
        if ( _propVariant.cah.pElems[index].QuadPart < 0 )
            return FALSE;

        ui64Value = (unsigned _int64) _propVariant.cah.pElems[index].QuadPart;
    break;

    case VT_R4 | VT_VECTOR:
        return FALSE;
    break;

    case VT_R8 | VT_VECTOR:
        return FALSE;
    break;

    case VT_BOOL | VT_VECTOR:
        ui64Value = (unsigned _int64) ( VARIANT_FALSE != _propVariant.cabool.pElems[index] );
    break;

    case VT_CY | VT_VECTOR:
    {
        return FALSE;
    }
    break;

    default:
        return FALSE;
    break;
    }

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Method:     CHTXIfExpressionValue::GetVectorValueDouble, public
//
//  Synopsis:   Returns the double value of a vector's element
//
//  History:    96/Jun/27   DwightKr    created
//
//----------------------------------------------------------------------------
BOOL CHTXIfExpressionValue::GetVectorValueDouble(unsigned index,
                                                 double & dblValue)
{
    switch ( GetType() )
    {
    case VT_UI1 | VT_VECTOR:
        VarR8FromUI1( _propVariant.caub.pElems[index], &dblValue );
    break;

    case VT_I1 | VT_VECTOR:
        VarR8FromI1( _propVariant.caub.pElems[index], &dblValue );
    break;

    case VT_UI2 | VT_VECTOR:
        VarR8FromUI2( _propVariant.caui.pElems[index], &dblValue );
    break;

    case VT_I2 | VT_VECTOR:
        VarR8FromI2( _propVariant.cai.pElems[index], &dblValue );
    break;

    case VT_UI4 | VT_VECTOR:
        VarR8FromUI4( _propVariant.caul.pElems[index], &dblValue );
    break;

    case VT_I4 | VT_VECTOR:
        VarR8FromI4( _propVariant.cal.pElems[index], &dblValue );
    break;

    case VT_UI8 | VT_VECTOR:
        dblValue = (double) _propVariant.cah.pElems[index].QuadPart;
    break;

    case VT_I8 | VT_VECTOR:
        //
        // hVal used instead of uhVal because latter coercion
        // is not yet supported by x86 compiler.
        //
        dblValue = (double) _propVariant.cah.pElems[index].QuadPart;
    break;

    case VT_R4 | VT_VECTOR:
        VarR8FromR4( _propVariant.caflt.pElems[index], &dblValue );
    break;

    case VT_R8 | VT_VECTOR:
        dblValue = (double) _propVariant.cadbl.pElems[index];
    break;

    case VT_DATE | VT_VECTOR:
        VarR8FromDate( _propVariant.cadate.pElems[index], &dblValue );
    break;

    case VT_BOOL | VT_VECTOR:
        VarR8FromBool( _propVariant.cabool.pElems[index], &dblValue );
    break;

    case VT_CY | VT_VECTOR:
        VarR8FromCy( _propVariant.cacy.pElems[index], &dblValue );
    break;

    default:
        return FALSE;
    break;
    }

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Method:     CHTXIfExpressionValue::GetVectorValueWStr, public
//
//  Synopsis:   Returns the wide string representation of a vector's element
//              in OLE memory.
//
//  History:    96/Jun/27   DwightKr    created
//
//----------------------------------------------------------------------------
BOOL CHTXIfExpressionValue::GetVectorValueWStr(unsigned index,
                                              XCoMem<WCHAR> & wcsStringValue )
{
    switch ( GetType() )
    {
    case VT_BSTR | VT_VECTOR:
    case VT_LPWSTR | VT_VECTOR:
    {
        unsigned cwcStringValue;
        if ( GetType() == (VT_LPWSTR | VT_VECTOR) )
        {
            cwcStringValue = wcslen( _propVariant.calpwstr.pElems[index] ) + 1;
        }
        else
        {
            cwcStringValue = BSTRLEN( _propVariant.cabstr.pElems[index] ) + 1;
        }

        wcsStringValue.Init( cwcStringValue );

        RtlCopyMemory( wcsStringValue.GetPointer(),
                       _propVariant.calpwstr.pElems[index],
                       cwcStringValue * sizeof(WCHAR) );
    }
    break;

    case VT_LPSTR | VT_VECTOR:
    {
        XArray<WCHAR> wcsBuffer;
        ULONG cbBuffer = strlen(_propVariant.calpstr.pElems[index]) + 1;
        ULONG cwcBuffer = MultiByteToXArrayWideChar( (UCHAR const *) _propVariant.calpstr.pElems[index],
                                                     cbBuffer,
                                                     _outputFormat.CodePage(),
                                                     wcsBuffer );

        if ( 0 == cwcBuffer )
        {
            return FALSE;
        }

        wcsStringValue.Init( cwcBuffer + 1 );
        RtlCopyMemory( wcsStringValue.GetPointer(),
                       wcsBuffer.GetPointer(),
                       (cwcBuffer+1) * sizeof(WCHAR) );
    }
    break;

    default:
        return FALSE;
    break;
    }

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Method:     CHTXIfExpressionValue::GetVectorValueStr, public
//
//  Synopsis:   Returns the string representation of a vector's element
//              in OLE memory.
//
//  History:    96/Jun/27   DwightKr    created
//
//----------------------------------------------------------------------------
BOOL CHTXIfExpressionValue::GetVectorValueStr(unsigned index,
                                              XCoMem<CHAR> & pszStringValue )
{
    XCoMem<WCHAR> wcsStringValue;
    if ( !GetVectorValueWStr( index, wcsStringValue ) )
    {
        return FALSE;
    }

    ULONG cwcBuffer = wcslen( wcsStringValue.GetPointer() ) + 1;
    XArray<BYTE> pszMessage(cwcBuffer);
    ULONG cbBuffer = WideCharToXArrayMultiByte( wcsStringValue.GetPointer(),
                                                cwcBuffer,
                                                _outputFormat.CodePage(),
                                                pszMessage );

    if ( 0 == cbBuffer )
    {
        return FALSE;
    }

    pszStringValue.Init( cbBuffer + 1 );
    RtlCopyMemory( pszStringValue.GetPointer(),
                   pszMessage.GetPointer(),
                   cbBuffer + 1 );

    return TRUE;
}



//+---------------------------------------------------------------------------
//
//  Method:     CHTXIfExpressionValue::GetVectorValueBStr, public
//
//  Synopsis:   Returns the B string representation of a vector's element
//              in OLE memory.
//
//  History:    96/Jun/27   DwightKr    created
//
//----------------------------------------------------------------------------
BOOL CHTXIfExpressionValue::GetVectorValueBStr(unsigned index,
                                               BSTR & bwszStringValue )
{
    XCoMem<WCHAR> wszStringValue;
    if ( !GetVectorValueWStr(index, wszStringValue) )
    {
        return FALSE;
    }


    bwszStringValue = SysAllocString( wszStringValue.GetPointer() );
    if ( 0 == bwszStringValue )
    {
        THROW ( CException( E_OUTOFMEMORY ) );
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\web\dll\idqreg.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       idqreg.cxx
//
//  Contents:   CIdqRegParams class
//
//  History:    22 Oct 97   AlanW       Created from params.cxx
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <ciregkey.hxx>
#include <regacc.hxx>
#include <params.hxx>


const WCHAR * IS_DEFAULT_CATALOG_DIRECTORY = L"web";


//+-------------------------------------------------------------------------
//
//  Member:     CIdqRegParams::CIdqRegParams, public
//
//  Synopsis:   Constructor for registry param object
//
//  Arguments:  - NONE -
//
//  History:    12-Oct-96 dlee  Created
//
//--------------------------------------------------------------------------

CIdqRegParams::CIdqRegParams( )
{
    SetDefault();

    Refresh( );
} //CIdqRegParams

//+-------------------------------------------------------------------------
//
//  Member:     CIdqRegVars::SetDefault, public
//
//  Synopsis:   Sets default values for registry params
//
//  History:    12-Oct-96 dlee  Added header
//
//--------------------------------------------------------------------------

void CIdqRegVars::SetDefault()
{
    _maxISRowsInResultSet = IS_MAX_ROWS_IN_RESULT_DEFAULT;
    _maxISQueryCache = IS_MAX_ENTRIES_IN_CACHE_DEFAULT;
    _ISFirstRowsInResultSet = IS_FIRST_ROWS_IN_RESULT_DEFAULT;
    _ISCachePurgeInterval = IS_QUERY_CACHE_PURGE_INTERVAL_DEFAULT;
    _ISRequestQueueSize = IS_QUERY_REQUEST_QUEUE_SIZE_DEFAULT;
    _ISRequestThresholdFactor = IS_QUERY_REQUEST_THRESHOLD_FACTOR_DEFAULT;
    _ISDateTimeFormatting = IS_QUERY_DATETIME_FORMATTING_DEFAULT;
    _ISDateTimeLocal = IS_QUERY_DATETIME_LOCAL_DEFAULT;
    _maxActiveQueryThreads = CI_MAX_ACTIVE_QUERY_THREADS_DEFAULT;
    wcscpy( _awcISDefaultCatalog, IS_DEFAULT_CATALOG_DIRECTORY );
} //SetDefault

//+-------------------------------------------------------------------------
//
//  Member:     CIdqRegParams::_ReadAndOverrideValues, private
//
//  Synopsis:   Attempts to read values, with the default being the current
//              value.
//
//  History:    12-Oct-96 dlee  created
//
//--------------------------------------------------------------------------

void CIdqRegParams::_ReadAndOverrideValues( CRegAccess & reg )
{
    CIdqRegVars newVals;

    newVals._maxISRowsInResultSet     = reg.Read(wcsISMaxRecordsInResultSet, _maxISRowsInResultSet );
    newVals._maxISQueryCache          = reg.Read(wcsISMaxEntriesInQueryCache, _maxISQueryCache );
    newVals._ISFirstRowsInResultSet   = reg.Read(wcsISFirstRowsInResultSet, _ISFirstRowsInResultSet );
    newVals._ISCachePurgeInterval     = reg.Read(wcsISQueryCachePurgeInterval, _ISCachePurgeInterval );
    newVals._ISRequestQueueSize       = reg.Read(wcsISRequestQueueSize, _ISRequestQueueSize );
    newVals._ISRequestThresholdFactor = reg.Read(wcsISRequestThresholdFactor, _ISRequestThresholdFactor );
    newVals._ISDateTimeFormatting     = reg.Read(wcsISDateTimeFormatting, _ISDateTimeFormatting );
    newVals._ISDateTimeLocal          = reg.Read(wcsISDateTimeLocal, _ISDateTimeLocal );
    newVals._maxActiveQueryThreads    = reg.Read(wcsMaxActiveQueryThreads, _maxActiveQueryThreads );

    wcscpy( newVals._awcISDefaultCatalog, _awcISDefaultCatalog );

    _StoreNewValues( newVals );
} //_ReadAndOverrideValues

//+-------------------------------------------------------------------------
//
//  Member:     CIdqRegParams::_ReadValues, private
//
//  Synopsis:   Reads values for variables
//
//  History:    12-Oct-96 dlee  Added header
//
//--------------------------------------------------------------------------

void CIdqRegParams::_ReadValues(
    CRegAccess & reg,
    CIdqRegVars & vars )
{
    vars._maxISRowsInResultSet     = reg.Read(wcsISMaxRecordsInResultSet, IS_MAX_ROWS_IN_RESULT_DEFAULT);
    vars._maxISQueryCache          = reg.Read(wcsISMaxEntriesInQueryCache, IS_MAX_ENTRIES_IN_CACHE_DEFAULT);
    vars._ISFirstRowsInResultSet   = reg.Read(wcsISFirstRowsInResultSet, IS_FIRST_ROWS_IN_RESULT_DEFAULT);
    vars._ISCachePurgeInterval     = reg.Read(wcsISQueryCachePurgeInterval, IS_QUERY_CACHE_PURGE_INTERVAL_DEFAULT);
    vars._ISRequestQueueSize       = reg.Read(wcsISRequestQueueSize, IS_QUERY_REQUEST_QUEUE_SIZE_DEFAULT);
    vars._ISRequestThresholdFactor = reg.Read(wcsISRequestThresholdFactor, IS_QUERY_REQUEST_THRESHOLD_FACTOR_DEFAULT);
    vars._ISDateTimeFormatting     = reg.Read(wcsISDateTimeFormatting, IS_QUERY_DATETIME_FORMATTING_DEFAULT);
    vars._ISDateTimeLocal          = reg.Read(wcsISDateTimeLocal, IS_QUERY_DATETIME_LOCAL_DEFAULT);
    vars._maxActiveQueryThreads    = reg.Read(wcsMaxActiveQueryThreads, CI_MAX_ACTIVE_QUERY_THREADS_DEFAULT);

    XPtrST<WCHAR> xwszISDefaultCatalog( reg.Read(wcsISDefaultCatalogDirectory, IS_DEFAULT_CATALOG_DIRECTORY) );
    wcsncpy( vars._awcISDefaultCatalog, xwszISDefaultCatalog.GetPointer(), MAX_PATH );
} //_ReadValues

//+-------------------------------------------------------------------------
//
//  Member:     CIdqRegVars::_StoreNewValues, private
//
//  Synopsis:   Transfers range-checked values
//
//  History:    12-Oct-96 dlee  Added header
//
//--------------------------------------------------------------------------

void CIdqRegParams::_StoreNewValues(CIdqRegVars & vars )
{
    InterlockedExchange( (long *) &_maxISRowsInResultSet, Range( vars._maxISRowsInResultSet, IS_MAX_ROWS_IN_RESULT_MIN, IS_MAX_ROWS_IN_RESULT_MAX ) );
    InterlockedExchange( (long *) &_maxISQueryCache, Range( vars._maxISQueryCache, IS_MAX_ENTRIES_IN_CACHE_MIN, IS_MAX_ENTRIES_IN_CACHE_MAX ) );
    InterlockedExchange( (long *) &_ISFirstRowsInResultSet, Range( vars._ISFirstRowsInResultSet, IS_FIRST_ROWS_IN_RESULT_MIN, IS_FIRST_ROWS_IN_RESULT_MAX ) );
    InterlockedExchange( (long *) &_ISCachePurgeInterval, Range( vars._ISCachePurgeInterval, IS_QUERY_CACHE_PURGE_INTERVAL_MIN, IS_QUERY_CACHE_PURGE_INTERVAL_MAX ) );
    InterlockedExchange( (long *) &_ISRequestQueueSize, Range( vars._ISRequestQueueSize, IS_QUERY_REQUEST_QUEUE_SIZE_MIN, IS_QUERY_REQUEST_QUEUE_SIZE_MAX ) );
    InterlockedExchange( (long *) &_ISRequestThresholdFactor, Range( vars._ISRequestThresholdFactor, IS_QUERY_REQUEST_THRESHOLD_FACTOR_MIN, IS_QUERY_REQUEST_THRESHOLD_FACTOR_MAX ) );
    InterlockedExchange( (long *) &_ISDateTimeFormatting, Range( vars._ISDateTimeFormatting, IS_QUERY_DATETIME_FORMATTING_MIN, IS_QUERY_DATETIME_FORMATTING_MAX ) );
    InterlockedExchange( (long *) &_ISDateTimeLocal, vars._ISDateTimeLocal );
    InterlockedExchange( (long *) &_maxActiveQueryThreads, Range( vars._maxActiveQueryThreads, CI_MAX_ACTIVE_QUERY_THREADS_MIN, CI_MAX_ACTIVE_QUERY_THREADS_MAX ) );

    wcscpy( _awcISDefaultCatalog, vars._awcISDefaultCatalog );
} //_StoreNewValues

//+-------------------------------------------------------------------------
//
//  Member:     CIdqRegParams::Refresh, public
//
//  Synopsis:   Reads the values from the registry
//
//  History:    12-Oct-96 dlee  Added header, reorganized
//
//--------------------------------------------------------------------------

void CIdqRegParams::Refresh(
    BOOL             fUseDefaultsOnFailure )
{
    // Grab the lock so no other writers try to update at the same time

    CIdqRegVars newVals;
    CLock lock( _mutex );

    TRY
    {
        //  Query the registry.

        CRegAccess regAdmin( RTL_REGISTRY_CONTROL, wcsRegAdmin );

        _ReadValues( regAdmin, newVals );
        _StoreNewValues( newVals );
    }
    CATCH (CException, e)
    {
        // Only store defaults when told to do so -- the params
        // are still in good shape at this point and are more
        // accurate than the default settings.

        if ( fUseDefaultsOnFailure )
        {
            newVals.SetDefault();
            _StoreNewValues( newVals );
        }
    }
    END_CATCH
} //Refresh
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\web\dll\idq.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996-2000.
//
//  File:   idq.cxx
//
//  Contents:   Parser for an IDQ file
//
//  History:    96/Jan/3    DwightKr    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

//
//  These hash values MUST be unique.  They have been calculated to be
//  unique via the ISAPI_IDQHash function below.
//
//  If the spelling of a IDQ variable name is changed, or a new variable
//  is added to the list, this table must be re-generated using the
//  code supplied below.
//
static const ULONG ISAPI_CIBOOLVECTORPREFIX_HASH        = 0x1174d5c;
static const ULONG ISAPI_CIBOOLVECTORSEPARATOR_HASH     = 0x8ba6b1d;
static const ULONG ISAPI_CIBOOLVECTORSUFFIX_HASH        = 0x1174df4;
static const ULONG ISAPI_CICATALOG_HASH                 = 0x89c6;
static const ULONG ISAPI_CICOLUMNS_HASH                 = 0x8bb4;
static const ULONG ISAPI_CICURRENCYVECTORPREFIX_HASH    = 0x119add60;
static const ULONG ISAPI_CICURRENCYVECTORSEPARATOR_HASH = 0x8cd6eb21;
static const ULONG ISAPI_CICURRENCYVECTORSUFFIX_HASH    = 0x119addf8;
static const ULONG ISAPI_CICURRENTPAGENUMBER_HASH       = 0x233792f;
static const ULONG ISAPI_CICURRENTRECORDNUMBER_HASH     = 0x8ce0671;
static const ULONG ISAPI_CIDATEVECTORPREFIX_HASH        = 0x114fd5c;
static const ULONG ISAPI_CIDATEVECTORSEPARATOR_HASH     = 0x8a7eb1d;
static const ULONG ISAPI_CIDATEVECTORSUFFIX_HASH        = 0x114fdf4;
static const ULONG ISAPI_CIFORCEUSECI_HASH              = 0x46337;
static const ULONG ISAPI_CIDEFERTRIMMING_HASH           = 0x8a26e6f8;
static const ULONG ISAPI_CIDIALECT_HASH                 = 0x8a07;
static const ULONG ISAPI_CIFLAGS_HASH                   = 0x228c;
static const ULONG ISAPI_CILOCALE_HASH                  = 0x4631;
static const ULONG ISAPI_CIMATCHEDRECORDCOUNT_HASH      = 0x4639280;
static const ULONG ISAPI_CIMAXRECORDSINRESULTSET_HASH   = 0x2349b581;
static const ULONG ISAPI_CIMAXRECORDSPERPAGE_HASH       = 0x2349baa;
static const ULONG ISAPI_CIFIRSTROWSINRESULTSET_HASH    = 0x118dc580;   
static const ULONG ISAPI_CINUMBERVECTORPREFIX_HASH      = 0x476ad5e;
static const ULONG ISAPI_CINUMBERVECTORSEPARATOR_HASH   = 0x23b56b1f;
static const ULONG ISAPI_CINUMBERVECTORSUFFIX_HASH      = 0x476adf6;
static const ULONG ISAPI_CIRESTRICTION_HASH             = 0x8ed8d;
static const ULONG ISAPI_CISCOPE_HASH                   = 0x2350;
static const ULONG ISAPI_CISORT_HASH                    = 0x11c2;
static const ULONG ISAPI_CISTRINGVECTORPREFIX_HASH      = 0x4845d5e;
static const ULONG ISAPI_CISTRINGVECTORSEPARATOR_HASH   = 0x2422eb1f;
static const ULONG ISAPI_CISTRINGVECTORSUFFIX_HASH      = 0x4845df6;
static const ULONG ISAPI_CITEMPLATE_HASH                = 0x11d3b;
static const ULONG ISAPI_CICANONICALOUTPUT_HASH         = 0x8a0c9f;
static const ULONG ISAPI_CIDONTTIMEOUT_HASH             = 0x8c55f;

#if 0

//
//  Use the following routine to verify the above hash values are perfect.
//
//+---------------------------------------------------------------------------
//
//  Function:   main - program entry point; used to verify perfect hash
//
//----------------------------------------------------------------------------
int __cdecl main( int argc, char ** argv )
{
    ULONG aHash[100];
    Win4Assert( 100 > cISAPI_CiParams );

    for (unsigned i=0; i<cISAPI_CiParams; i++)
    {
        aHash[i] = ISAPI_IDQHash( aISAPI_CiParams[i] );
    }


    for (i=0; i<cISAPI_CiParams-1; i++)
    {
        for (unsigned j=i+1; j<cISAPI_CiParams; j++)
        {
            if ( aHash[i] == aHash[j] )
            {
                printf( "Hash collision between %ls(0x%x) and %ls(0x%x)\n",
                         aISAPI_CiParams[i],
                         aHash[i],
                         aISAPI_CiParams[j],
                         aHash[j] );
            }
        }
    }

    printf ("Hash table: Copy this as necessary into idq\\idq.cxx\n");
    for (i=0; i<cISAPI_CiParams; i++)
    {
        printf("static const ULONG ISAPI_%ws_HASH\t= 0x%x;\n", aISAPI_CiParams[i], aHash[i] );
    }

    return 0;
}

#endif  // 0

//+---------------------------------------------------------------------------
//
//  Member:     CIDQFile::CIDQFile - public constructor
//
//  Synopsis:   Builds a CIDQFile object, initializes values
//
//  Arguments:  [wcsFileName] -- full path to IDQ file
//              [codePage]    -- code page to translate IDQ file
//
//  History:    96/Jan/03   DwightKr    Created.
//
//----------------------------------------------------------------------------
CIDQFile::CIDQFile( WCHAR const * wcsFileName,
                    UINT codePage,
                    CSecurityIdentity const & securityIdentity )
        : _wcsRestriction(0),
          _wcsDialect(0),
          _wcsScope(0),
          _wcsSort(0),
          _wcsColumns(0),
          _wcsLocale(0),
          _wcsHTXFileName(0),
          _wcsMaxRecordsInResultSet(0),
          _wcsMaxRecordsPerPage(0),
          _wcsFirstRowsInResultSet(0),
          _wcsCatalog(0),
          _wcsForceUseCi(0),
          _wcsDeferTrimming(0),
          _wcsCanonicalOutput(0),
          _wcsDontTimeout(0),
          _wcsCiFlags(0),
          _wcsBoolVectorPrefix(0),
          _wcsBoolVectorSeparator(0),
          _wcsBoolVectorSuffix(0),
          _wcsCurrencyVectorPrefix(0),
          _wcsCurrencyVectorSeparator(0),
          _wcsCurrencyVectorSuffix(0),
          _wcsDateVectorPrefix(0),
          _wcsDateVectorSeparator(0),
          _wcsDateVectorSuffix(0),
          _wcsNumberVectorPrefix(0),
          _wcsNumberVectorSeparator(0),
          _wcsNumberVectorSuffix(0),
          _wcsStringVectorPrefix(0),
          _wcsStringVectorSeparator(0),
          _wcsStringVectorSuffix(0),
          _cReplaceableParameters(0),
          _refCount(0),
          _codePage(codePage),
          _securityIdentity( securityIdentity )
{
    wcscpy( _wcsIDQFileName, wcsFileName );
}



//+---------------------------------------------------------------------------
//
//  Member:     CIDQFile::~CIDQFile - public destructor
//
//  History:    96/Jan/03   DwightKr    Created.
//
//----------------------------------------------------------------------------
CIDQFile::~CIDQFile()
{
    Win4Assert( _refCount == 0 );

    delete _wcsRestriction;
    delete _wcsDialect;
    delete _wcsScope;
    delete _wcsSort;
    delete _wcsColumns;
    delete _wcsLocale;
    delete _wcsHTXFileName;
    delete _wcsMaxRecordsInResultSet;
    delete _wcsMaxRecordsPerPage;
    delete _wcsFirstRowsInResultSet;
    delete _wcsCatalog;
    delete _wcsCiFlags;
    delete _wcsForceUseCi;
    delete _wcsDeferTrimming;
    delete _wcsCanonicalOutput;
    delete _wcsDontTimeout;
    delete _wcsBoolVectorPrefix;
    delete _wcsBoolVectorSeparator;
    delete _wcsBoolVectorSuffix;
    delete _wcsCurrencyVectorPrefix;
    delete _wcsCurrencyVectorSeparator;
    delete _wcsCurrencyVectorSuffix;
    delete _wcsDateVectorPrefix;
    delete _wcsDateVectorSeparator;
    delete _wcsDateVectorSuffix;
    delete _wcsNumberVectorPrefix;
    delete _wcsNumberVectorSeparator;
    delete _wcsNumberVectorSuffix;
    delete _wcsStringVectorPrefix;
    delete _wcsStringVectorSeparator;
    delete _wcsStringVectorSuffix;
}


//+---------------------------------------------------------------------------
//
//  Member:     CIDQFile::ParseFile, private
//
//  Synopsis:   Parses the given file and sets up the necessary variables
//
//  History:    96/Jan/03   DwightKr    Created.
//
//----------------------------------------------------------------------------
void CIDQFile::ParseFile()
{
    _xList.Set(new CLocalGlobalPropertyList( _codePage ));

    // We don't support impersonation for scripts.
    // It involves getting the server ip address, vpath and then using
    // that for impersonation

    Win4Assert( !IsNetPath( _wcsIDQFileName ) );

    //
    //  Now parse the query parameters
    //

    // Open the file in a TRY block, so we can make this an IDQ error
    // if the IDQ file isn't found.  Otherwise the error doesn't include
    // the IDQ filename.
    // For scoping reasons, the CFileMapView is new'ed, not on the stack.

    XPtr<CFileMapView> xMapView;

    TRY
    {
        xMapView.Set( new CFileMapView( _wcsIDQFileName ) );
        xMapView->Init();
    }
    CATCH( CException, e )
    {
        if ( HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ) == e.GetErrorCode() )
        {
            THROW( CIDQException( MSG_CI_IDQ_NOT_FOUND, 0 ) );
        }
        else
        {
            RETHROW();
        }
    }
    END_CATCH

    CFileBuffer idqFile( xMapView.GetReference(), _codePage );

    //
    //  Save the last write time of this file.
    //

    SCODE sc = GetLastWriteTime( _wcsIDQFileName, _ftIDQLastWriteTime );

    if ( FAILED( sc ) )
        THROW( CException( sc ) );

    //
    //  Process a line at a time, look for either the [Names] or the [Query]
    //  section and process lines within those sections.
    //

    BOOL fQuerySection = FALSE;
    BOOL fNamesSection = FALSE;
    int iLine = 0;                  // Start counting at line #1

    for( ;; )
    {
        iLine++;
        XGrowable<WCHAR> xLine;

        ULONG cwcChar = idqFile.fgetsw( xLine );

        if ( 0 == cwcChar )
        {
            break;
        }

        WCHAR *pwcLine = xLine.Get();

        //
        //  Skip ahead until we find a [Query] section
        //
        if ( L'[' == *pwcLine )
        {
            if (_wcsnicmp(pwcLine+1, L"Query]", 6) == 0 )
            {
                fQuerySection = TRUE;
                continue;
            }
            else if (_wcsnicmp(pwcLine+1, L"Names]", 6) == 0 )
            {
                fNamesSection = TRUE;
                continue;
            }
            else
            {
                fQuerySection = fNamesSection = FALSE;
                continue;
            }
        }
        else if ( L'#' == *pwcLine )
        {
            continue;
        }


        

        if ( fQuerySection )
        {
            CQueryScanner scanner( pwcLine, FALSE );
            ParseOneLine( scanner, iLine );
        }
        else if (fNamesSection)
        {
            XPtr<CPropEntry> propentry;

            CQueryScanner scanner( pwcLine, FALSE );
            CPropertyList::ParseOneLine(scanner, iLine, propentry);
            if (propentry.GetPointer())
            {
                _xList->AddEntry( propentry.GetPointer(), iLine );
                propentry.Acquire();
            }
        }
    }

    //
    //  Verify that the minimum set of parameters are specified.
    //

    //
    //  We must have all of the following:
    //
    //      - a restriction
    //      - a scope
    //      - a template (HTX) file
    //      - output columns
    //

    if ( 0 == _wcsRestriction )
    {
        // Report an error
        ciGibDebugOut(( DEB_IERROR, "Restriction not found in IDQ file\n" ));
        THROW( CIDQException(MSG_CI_IDQ_MISSING_RESTRICTION, 0) );
    }
    else if ( 0 == _wcsScope )
    {
        // Report an error
        ciGibDebugOut(( DEB_IERROR, "Scope not found in IDQ file\n" ));
        THROW( CIDQException(MSG_CI_IDQ_MISSING_SCOPE, 0) );
    }
    else if ( 0 == _wcsHTXFileName && !IsCanonicalOutput() )
    {
        // Report an error
        ciGibDebugOut(( DEB_IERROR, "HTX filename not found in IDQ file\n" ));
        THROW( CIDQException(MSG_CI_IDQ_MISSING_TEMPLATEFILE, 0) );
    }
    else if ( 0 == _wcsColumns )
    {
        // Report an error
        ciGibDebugOut(( DEB_IERROR, "Output columns not found in IDQ file\n" ));
        THROW( CIDQException(MSG_CI_IDQ_MISSING_OUTPUTCOLUMNS, 0) );
    }

    //
    //  If no catalog was specified, use the default catalog in the registry
    //
    if ( 0 == _wcsCatalog )
    {
        ciGibDebugOut(( DEB_ITRACE, "Using default catalog\n" ));

        WCHAR awcTmp[ MAX_PATH ];
        ULONG cwcRequired = TheIDQRegParams.GetISDefaultCatalog( awcTmp,
                                                                 MAX_PATH );
        if ( cwcRequired > MAX_PATH )
            THROW( CException(STATUS_INVALID_PARAMETER) );

        cwcRequired++; // make room for termination
        _wcsCatalog = new WCHAR[ cwcRequired ];
        RtlCopyMemory( _wcsCatalog, awcTmp, cwcRequired * sizeof WCHAR );
    }

}



//+---------------------------------------------------------------------------
//
//  Member:     CIDQFile::ParseOneLine, private
//
//  Synopsis:   Parses one line of the IDQ file
//
//  Arguments:  [scan]   -- scanner initialized with the current line
//              [iLine]  -- current line number
//
//  History:    96/Jan/03   DwightKr    created
//
//----------------------------------------------------------------------------

void CIDQFile::ParseOneLine( CQueryScanner & scan,
                             unsigned iLine )
{
    //
    //  Is this a comment line (does it start with #) or an empty line?
    //
    if ( scan.LookAhead() == PROP_REGEX_TOKEN || scan.LookAhead() == EOS_TOKEN )
    {
        return;
    }

    if ( scan.LookAhead() != TEXT_TOKEN )    //  Better be a word
    {
        // Report an error
        THROW( CIDQException( MSG_CI_IDQ_EXPECTING_NAME, iLine ) );
    }

    XPtrST<WCHAR> wcsAttribute( scan.AcqWord() );

    if( wcsAttribute.GetPointer() == 0 )                  // Better find a word
    {
        THROW( CIDQException( MSG_CI_IDQ_EXPECTING_TYPE, iLine ) );
    }

    scan.Accept();

    if ( scan.LookAhead() != EQUAL_TOKEN )
    {
        // Report an error
        THROW( CIDQException( MSG_CI_IDQ_EXPECTING_EQUAL, iLine ) );
    }

    scan.Accept();


    //
    //  Convert the string to upper-case and HASH it. Lookup the hashed value.
    //  Note that this code assumes the HASH IS PERFECT.  Whenever a IDQ
    //  variable is renamed or added, this assumption may no-longer be true.
    //  Check it out with the above program.
    //
    //  This code essentially replaces 25 wcsicmp functions; or an average
    //  of 12.5 wscicmp calls per line in the IDQ file.
    //
    Win4Assert( ISAPI_CICOLUMNS_HASH == ISAPI_IDQHash(ISAPI_CI_COLUMNS) );
    Win4Assert( ISAPI_CIFLAGS_HASH == ISAPI_IDQHash(ISAPI_CI_FLAGS) );
    Win4Assert( ISAPI_CIMAXRECORDSINRESULTSET_HASH == ISAPI_IDQHash(ISAPI_CI_MAX_RECORDS_IN_RESULTSET) );
    Win4Assert( ISAPI_CIMAXRECORDSPERPAGE_HASH == ISAPI_IDQHash(ISAPI_CI_MAX_RECORDS_PER_PAGE) );
    Win4Assert( ISAPI_CIFIRSTROWSINRESULTSET_HASH == ISAPI_IDQHash(ISAPI_CI_FIRST_ROWS_IN_RESULTSET) );
    Win4Assert( ISAPI_CIRESTRICTION_HASH == ISAPI_IDQHash(ISAPI_CI_RESTRICTION) );
    Win4Assert( ISAPI_CIDIALECT_HASH == ISAPI_IDQHash(ISAPI_CI_DIALECT) );
    Win4Assert( ISAPI_CISCOPE_HASH == ISAPI_IDQHash(ISAPI_CI_SCOPE) );
    Win4Assert( ISAPI_CISORT_HASH == ISAPI_IDQHash(ISAPI_CI_SORT) );
    Win4Assert( ISAPI_CITEMPLATE_HASH == ISAPI_IDQHash(ISAPI_CI_TEMPLATE) );
    Win4Assert( ISAPI_CICATALOG_HASH == ISAPI_IDQHash(ISAPI_CI_CATALOG) );
    Win4Assert( ISAPI_CILOCALE_HASH == ISAPI_IDQHash(ISAPI_CI_LOCALE) );
    Win4Assert( ISAPI_CIBOOLVECTORPREFIX_HASH == ISAPI_IDQHash(ISAPI_CI_BOOL_VECTOR_PREFIX) );
    Win4Assert( ISAPI_CIBOOLVECTORSEPARATOR_HASH == ISAPI_IDQHash(ISAPI_CI_BOOL_VECTOR_SEPARATOR) );
    Win4Assert( ISAPI_CIBOOLVECTORSUFFIX_HASH == ISAPI_IDQHash(ISAPI_CI_BOOL_VECTOR_SUFFIX) );
    Win4Assert( ISAPI_CICURRENCYVECTORPREFIX_HASH == ISAPI_IDQHash(ISAPI_CI_CURRENCY_VECTOR_PREFIX) );
    Win4Assert( ISAPI_CICURRENCYVECTORSEPARATOR_HASH == ISAPI_IDQHash(ISAPI_CI_CURRENCY_VECTOR_SEPARATOR) );
    Win4Assert( ISAPI_CICURRENCYVECTORSUFFIX_HASH == ISAPI_IDQHash(ISAPI_CI_CURRENCY_VECTOR_SUFFIX) );
    Win4Assert( ISAPI_CIDATEVECTORPREFIX_HASH == ISAPI_IDQHash(ISAPI_CI_DATE_VECTOR_PREFIX) );
    Win4Assert( ISAPI_CIDATEVECTORSEPARATOR_HASH == ISAPI_IDQHash(ISAPI_CI_DATE_VECTOR_SEPARATOR) );
    Win4Assert( ISAPI_CIDATEVECTORSUFFIX_HASH == ISAPI_IDQHash(ISAPI_CI_DATE_VECTOR_SUFFIX) );
    Win4Assert( ISAPI_CINUMBERVECTORPREFIX_HASH == ISAPI_IDQHash(ISAPI_CI_NUMBER_VECTOR_PREFIX) );
    Win4Assert( ISAPI_CINUMBERVECTORSEPARATOR_HASH == ISAPI_IDQHash(ISAPI_CI_NUMBER_VECTOR_SEPARATOR) );
    Win4Assert( ISAPI_CINUMBERVECTORSUFFIX_HASH == ISAPI_IDQHash(ISAPI_CI_NUMBER_VECTOR_SUFFIX) );
    Win4Assert( ISAPI_CISTRINGVECTORPREFIX_HASH == ISAPI_IDQHash(ISAPI_CI_STRING_VECTOR_PREFIX) );
    Win4Assert( ISAPI_CISTRINGVECTORSEPARATOR_HASH == ISAPI_IDQHash(ISAPI_CI_STRING_VECTOR_SEPARATOR) );
    Win4Assert( ISAPI_CISTRINGVECTORSUFFIX_HASH == ISAPI_IDQHash(ISAPI_CI_STRING_VECTOR_SUFFIX) );
    Win4Assert( ISAPI_CIFORCEUSECI_HASH == ISAPI_IDQHash(ISAPI_CI_FORCE_USE_CI) );
    Win4Assert( ISAPI_CIDEFERTRIMMING_HASH == ISAPI_IDQHash(ISAPI_CI_DEFER_NONINDEXED_TRIMMING ) );
    Win4Assert( ISAPI_CICANONICALOUTPUT_HASH == ISAPI_IDQHash(ISAPI_CI_CANONICAL_OUTPUT ) );
    Win4Assert( ISAPI_CIDONTTIMEOUT_HASH == ISAPI_IDQHash(ISAPI_CI_DONT_TIMEOUT ) );

    _wcsupr( wcsAttribute.GetPointer() );
    ULONG ulHash = ISAPI_IDQHash( wcsAttribute.GetPointer() );

    switch ( ulHash )
    {
    case  ISAPI_CICOLUMNS_HASH:
        GetStringValue( scan, iLine, &_wcsColumns );
    break;

    case ISAPI_CIFLAGS_HASH:
        GetStringValue( scan, iLine, &_wcsCiFlags );
    break;

    case ISAPI_CIMAXRECORDSINRESULTSET_HASH:
        GetStringValue( scan, iLine, &_wcsMaxRecordsInResultSet );
    break;

    case ISAPI_CIMAXRECORDSPERPAGE_HASH:
        GetStringValue( scan, iLine, &_wcsMaxRecordsPerPage );
    break;

    case ISAPI_CIFIRSTROWSINRESULTSET_HASH:
        GetStringValue( scan, iLine, &_wcsFirstRowsInResultSet );
    break;

    case ISAPI_CIRESTRICTION_HASH:
        GetStringValue( scan, iLine, &_wcsRestriction );
    break;

    case ISAPI_CIDIALECT_HASH:
        GetStringValue( scan, iLine, &_wcsDialect );
    break;

    case ISAPI_CISCOPE_HASH:
        GetStringValue( scan, iLine, &_wcsScope, FALSE );
    break;

    case ISAPI_CISORT_HASH:
        GetStringValue( scan, iLine, &_wcsSort );
    break;

    case ISAPI_CITEMPLATE_HASH:
        GetStringValue( scan, iLine, &_wcsHTXFileName );
    break;

    case ISAPI_CICATALOG_HASH:
        GetStringValue( scan, iLine, &_wcsCatalog );
    break;

    case ISAPI_CIBOOLVECTORPREFIX_HASH:
        GetStringValue( scan, iLine, &_wcsBoolVectorPrefix );
    break;

    case ISAPI_CIBOOLVECTORSEPARATOR_HASH:
        GetStringValue( scan, iLine, &_wcsBoolVectorSeparator );
    break;

    case ISAPI_CIBOOLVECTORSUFFIX_HASH:
        GetStringValue( scan, iLine, &_wcsBoolVectorSuffix );
    break;

    case ISAPI_CICURRENCYVECTORPREFIX_HASH:
        GetStringValue( scan, iLine, &_wcsCurrencyVectorPrefix );
    break;

    case ISAPI_CICURRENCYVECTORSEPARATOR_HASH:
        GetStringValue( scan, iLine, &_wcsCurrencyVectorSeparator );
    break;

    case ISAPI_CICURRENCYVECTORSUFFIX_HASH:
        GetStringValue( scan, iLine, &_wcsCurrencyVectorSuffix );
    break;

    case ISAPI_CIDATEVECTORPREFIX_HASH:
        GetStringValue( scan, iLine, &_wcsDateVectorPrefix );
    break;

    case ISAPI_CIDATEVECTORSEPARATOR_HASH:
        GetStringValue( scan, iLine, &_wcsDateVectorSeparator );
    break;

    case ISAPI_CIDATEVECTORSUFFIX_HASH:
        GetStringValue( scan, iLine, &_wcsDateVectorSuffix );
    break;

    case ISAPI_CINUMBERVECTORPREFIX_HASH:
        GetStringValue( scan, iLine, &_wcsNumberVectorPrefix );
    break;

    case ISAPI_CINUMBERVECTORSEPARATOR_HASH:
        GetStringValue( scan, iLine, &_wcsNumberVectorSeparator );
    break;

    case ISAPI_CINUMBERVECTORSUFFIX_HASH:
        GetStringValue( scan, iLine, &_wcsNumberVectorSuffix );
    break;

    case ISAPI_CISTRINGVECTORPREFIX_HASH:
        GetStringValue( scan, iLine, &_wcsStringVectorPrefix );
    break;

    case ISAPI_CISTRINGVECTORSEPARATOR_HASH:
        GetStringValue( scan, iLine, &_wcsStringVectorSeparator );
    break;

    case ISAPI_CISTRINGVECTORSUFFIX_HASH:
        GetStringValue( scan, iLine, &_wcsStringVectorSuffix );
    break;

    case ISAPI_CIFORCEUSECI_HASH:
        GetStringValue( scan, iLine, &_wcsForceUseCi );
    break;

    case ISAPI_CIDEFERTRIMMING_HASH:
        GetStringValue( scan, iLine, &_wcsDeferTrimming );
    break;

    case ISAPI_CILOCALE_HASH:
        GetStringValue( scan, iLine, &_wcsLocale );
    break;

    case ISAPI_CICANONICALOUTPUT_HASH:
        GetStringValue( scan, iLine, &_wcsCanonicalOutput );
    break;

    case ISAPI_CIDONTTIMEOUT_HASH:
        GetStringValue( scan, iLine, &_wcsDontTimeout );
    break;

    default:


        //
        //  We've found a keyword/attribute that we don't support.
        //  Don't report an error. This will allow this version of the
        //  parser to work with newer .IDQ file versions with new parameters.
        //
        ciGibDebugOut(( DEB_ERROR,
                        "Invalid string in hash table for %ws; hash = 0x%x\n",
                        wcsAttribute.GetPointer(),
                        ulHash ));
    break;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CIDQFile::ParseColumns, public
//
//  Synopsis:   Parses the columns attribute
//
//  Arguments:  [wcsColumns]  -- string to convert
//              [variableSet] -- list of replaceable parameters
//              [varColumns]  -- Column variables returned here
//
//  Returns:    CDbColumns* - counted array of column IDs
//
//  History:    96/Jan/03   DwightKr    created
//              96/Feb/23   DwightKr    Add check for duplicate value
//              96/Mar/12   DwightKr    Made public
//              96/May/23   AlanW       Detect duplicate column names
//
//----------------------------------------------------------------------------

CDbColumns * CIDQFile::ParseColumns( WCHAR const * wcsColumns,
                                     CVariableSet & variableSet,
                                     CDynArray<WCHAR> & awcsColumns )
{
    return ::ParseStringColumns( wcsColumns,
                                 _xList.GetPointer(),
                                 GetUserDefaultLCID(),
                                 &variableSet,
                                 &awcsColumns );
}


//+---------------------------------------------------------------------------
//
//  Member:     CIDQFile::ParseFlags, private
//
//  Synopsis:   Parses the flags attribute
//
//  Arguments:  [wcsCiFlags] -- flags
//
//  History:    96/Jan/03   DwightKr    created
//              96/Apr/12   DwightKr    mad a replaceable parameter
//
//----------------------------------------------------------------------------
ULONG CIDQFile::ParseFlags( WCHAR const * wcsCiFlags )
{
    if ( 0 == wcsCiFlags )
    {
        return QUERY_DEEP;
    }

    ULONG ulFlags;

    if ( _wcsicmp(wcsCiFlags, L"SHALLOW") == 0 )
    {
        ulFlags = QUERY_SHALLOW;
    }
    else if ( _wcsicmp(wcsCiFlags, L"DEEP") == 0 )
    {
        ulFlags = QUERY_DEEP;
    }
    else
    {
        THROW( CIDQException(MSG_CI_IDQ_EXPECTING_SHALLOWDEEP, 0) );
    }

    return ulFlags;
}

//+---------------------------------------------------------------------------
//
//  Member:     CIDQFile::IsCanonicalOutput
//
//  Synopsis:   Tests if canonical output is enabled.
//
//  Returns:    TRUE if canonical output is needed; FALSE o/w
//
//  History:    6-14-96   srikants   Created
//
//  Notes:      Assumed here that it is not a replaceable parameter.
//
//----------------------------------------------------------------------------

BOOL CIDQFile::IsCanonicalOutput() const
{
    if ( 0 == _wcsCanonicalOutput )
        return FALSE;

    return _wcsicmp(_wcsCanonicalOutput, L"TRUE") == 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CIDQFile::IsDontTimeout
//
//  Synopsis:   Specifies if the don't timeout parameter is true
//
//  History:    9-13-96   srikants   Created
//
//----------------------------------------------------------------------------

BOOL CIDQFile::IsDontTimeout() const
{
    if ( 0 == _wcsDontTimeout )
        return FALSE;

    return _wcsicmp(_wcsDontTimeout, L"TRUE") == 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CIDQFile::GetStringValue - private
//
//  Synopsis:   Gets the string value on the currenct line
//
//  Arguments:  [scan]            -- scanner initialized with the current line
//              [iLine]           -- current line number
//              [pwcsStringValue] -- value to put string into
//              [fParseQuotes]    -- if TRUE, remove first and trailing quotes
//
//  History:    96/Jan/03   DwightKr    created
//              96/Feb/23   DwightKr    Add check for duplicate value
//
//----------------------------------------------------------------------------
void CIDQFile::GetStringValue( CQueryScanner & scan,
                               unsigned iLine,
                               WCHAR ** pwcsStringValue,
                               BOOL fParseQuotes )
{
    if ( 0 != *pwcsStringValue )
    {
        ciGibDebugOut(( DEB_IWARN,
                        "Duplicate CiXX=value in IDQ file on line #%d\n",
                        iLine ));
        THROW( CIDQException(MSG_CI_IDQ_DUPLICATE_ENTRY, iLine) );
    }

    *pwcsStringValue = scan.AcqLine( fParseQuotes );

    if ( IsAReplaceableParameter( *pwcsStringValue ) != eIsSimpleString )
    {
        _cReplaceableParameters++;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CIDQFile::IsCachedDataValid - public
//
//  Synopsis:   Determines if the IDQ file is still vaid, or has it
//              changed since it was last read.
//
//  History:    96/Jan/03   DwightKr    created
//
//----------------------------------------------------------------------------
BOOL CIDQFile::IsCachedDataValid()
{
    FILETIME ft;
    SCODE sc = GetLastWriteTime( _wcsIDQFileName, ft );

    // this usually fails because the file no longer exists

    if ( FAILED( sc ) )
        return FALSE;

    return ( (_ftIDQLastWriteTime.dwLowDateTime == ft.dwLowDateTime) &&
             (_ftIDQLastWriteTime.dwHighDateTime == ft.dwHighDateTime) );

}


//+---------------------------------------------------------------------------
//
//  Function:   GetLastWriteTime
//
//  Purpose:    Gets the last change time of the file specified
//
//  Arguments:  [wcsFileName] - name of file to get last write time of
//              [filetime]    - where the filetime is returned
//
//  Returns:    SCODE result
//
//  History:    96/Jan/23   DwightKr    Created
//              96/Mar/13   DwightKr    Changed to use GetFileAttributesEx()
//
//----------------------------------------------------------------------------
SCODE GetLastWriteTime(
    WCHAR const * wcsFileName,
    FILETIME &    filetime )
{
    Win4Assert( 0 != wcsFileName );

    // CImpersonateRemoteAccess imprsnat;
    // imprsnat.ImpersonateIf( wcsFileName );

    WIN32_FIND_DATA ffData;

    if ( !GetFileAttributesEx( wcsFileName, GetFileExInfoStandard, &ffData ) )
    {
        ULONG error = GetLastError();

        ciGibDebugOut(( DEB_IERROR,
                        "Unable to GetFileAttributesEx(%ws) GetLastError=0x%x\n",
                        wcsFileName,
                        error ));
        return HRESULT_FROM_WIN32( error );
    }

    filetime = ffData.ftLastWriteTime;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CIDQFile::ParseForceUseCI - public
//
//  Synopsis:   Gets the TRUE/FALSE value for CiForceUseCI
//
//  Arguments:  [wcsForceUseCi] -- string to parse
//
//  History:    96/Mar/03   DwightKr    created
//
//----------------------------------------------------------------------------
BOOL CIDQFile::ParseForceUseCI( WCHAR const * wcsForceUseCi )
{
    if ( 0 == wcsForceUseCi )
    {
        return FALSE;
    }

    BOOL fForceUseCi;

    if ( _wcsicmp( wcsForceUseCi, L"FALSE" ) == 0 )
    {
        fForceUseCi = FALSE;
    }
    else if ( _wcsicmp( wcsForceUseCi, L"TRUE" ) == 0 )
    {
        fForceUseCi = TRUE;
    }
    else
    {
        THROW( CIDQException(MSG_CI_IDQ_EXPECTING_TRUEFALSE, 0) );
    }

    return fForceUseCi;
}

//+---------------------------------------------------------------------------
//
//  Member:     CIDQFile::ParseDeferTrimming - public
//
//  Synopsis:   Gets the TRUE/FALSE value for CiDeferNonIndexedTrimming
//
//  Arguments:  [wcsDeferTrimming] -- string to parse
//
//  History:    96/Mar/03   DwightKr    created
//
//----------------------------------------------------------------------------
BOOL CIDQFile::ParseDeferTrimming( WCHAR const * wcsDeferTrimming )
{
    if ( 0 == wcsDeferTrimming )
    {
        return FALSE;
    }

    BOOL fDeferTrimming;

    if ( _wcsicmp( wcsDeferTrimming, L"FALSE" ) == 0 )
    {
        fDeferTrimming = FALSE;
    }
    else if ( _wcsicmp( wcsDeferTrimming, L"TRUE" ) == 0 )
    {
        fDeferTrimming = TRUE;
    }
    else
    {
        THROW( CIDQException(MSG_CI_IDQ_EXPECTING_TRUEFALSE, 0) );
    }

    return fDeferTrimming;
}


//+---------------------------------------------------------------------------
//
//  Member:     CIDQFile::GetVectorFormatting, public
//
//  Synopsis:   Sets up the vector formatting for output
//
//  Arguments:  [outputFormat] -- the output format object to setup
//
//  History:    96/Feb/26   DwightKr    created
//
//----------------------------------------------------------------------------
void CIDQFile::GetVectorFormatting( COutputFormat & outputFormat )
{
    outputFormat.SetBoolVectorFormat( _wcsBoolVectorPrefix,
                                      _wcsBoolVectorSeparator,
                                      _wcsBoolVectorSuffix );

    outputFormat.SetCurrencyVectorFormat( _wcsCurrencyVectorPrefix,
                                          _wcsCurrencyVectorSeparator,
                                          _wcsCurrencyVectorSuffix );

    outputFormat.SetDateVectorFormat( _wcsDateVectorPrefix,
                                      _wcsDateVectorSeparator,
                                      _wcsDateVectorSuffix );

    outputFormat.SetNumberVectorFormat( _wcsNumberVectorPrefix,
                                        _wcsNumberVectorSeparator,
                                        _wcsNumberVectorSuffix );

    outputFormat.SetStringVectorFormat( _wcsStringVectorPrefix,
                                        _wcsStringVectorSeparator,
                                        _wcsStringVectorSuffix );
}


//+---------------------------------------------------------------------------
//
//  Member:     CIDQFileList::Find - public
//
//  Synopsis:   Finds a matching parsed IDQ file in list, or builds a new
//              one if a match can not be found.
//
//  Arguments:  [wcsFileName] -- full path to IDQ file
//              [codePage]    -- code page of parsed IDQ file
//
//  History:    96/Mar/27   DwightKr    Created.
//
//----------------------------------------------------------------------------
CIDQFile * CIDQFileList::Find( WCHAR const * wcsFileName,
                               UINT codePage,
                               CSecurityIdentity const & securityIdentity )
{
    //
    //  Refcount everything in the list so that we can examine the list
    //  outside of the lock.
    //

    ULONG      cItems;
    XArray<CIDQFile *> aIDQFile;

    // ==========================================
    {
        CLock lock( _mutex );

        cItems = _aIDQFile.Count();         // Save count of items to examine
        aIDQFile.Init( cItems );

        for (unsigned i=0; i<cItems; i++)
        {
            aIDQFile[i] = _aIDQFile[i];
            aIDQFile[i]->LokAddRef();
        }
    }
    // ==========================================

    // Can't throw while the .idq files are addref'ed -- remember the
    // error and throw it after the .idq files are released.
    // IsCachedDataValid() throws!

    SCODE sc = S_OK;
    CIDQFile * pIDQFile = 0;

    TRY
    {
        //
        //  Now walk though the list looking for a match; outside of the lock.
        //

        for (unsigned i=0; i<cItems; i++)
        {
            if ( (_wcsicmp(aIDQFile[i]->GetIDQFileName(), wcsFileName) == 0) &&
                 (aIDQFile[i]->GetCodePage() == codePage) &&
                 (aIDQFile[i]->IsCachedDataValid() )
               )
            {
                pIDQFile = aIDQFile[i];

                ciGibDebugOut(( DEB_ITRACE,
                                "A cached version of IDQ file %ws was found\n",
                                wcsFileName ));

                break;
            }
        }
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
    }
    END_CATCH

    //
    //  If pIDQFile is non-0, we've found a match.  Decrement the ref-count
    //  for all items which did not match.
    //

    for (unsigned i=0; i<cItems; i++)
    {
        if ( pIDQFile != aIDQFile[i] )
        {
            aIDQFile[i]->Release();
        }
    }

    if ( S_OK != sc )
    {
        Win4Assert( 0 == pIDQFile );
        THROW( CException( sc ) );
    }

    //
    // We may have matched, but still not have access to this file.  First, make
    // a quick check for an exact match on security token, and then try harder
    // by opening the file.
    //

    if ( 0 != pIDQFile )
    {
        if ( !pIDQFile->CheckSecurity( securityIdentity ) )
        {
            HANDLE h = CreateFile( wcsFileName,
                                   GENERIC_READ,
                                   FILE_SHARE_READ,
                                   0,
                                   OPEN_EXISTING,
                                   0,
                                   0 );

            //
            // Don't try to determine here if security caused the problem.
            // Just let the standard exception handling below in file parsing
            // deal with the error.
            //

            if ( INVALID_HANDLE_VALUE == h )
            {
                pIDQFile->Release();
                pIDQFile = 0;
            }
            else
            {
                CloseHandle( h );

                //
                // Update the security token of the cached Idq file,
                // to optimize away the CreateFile check in two cases:
                //   1.  When the file is first parsed with admin
                //       privileges, and all subsequent queries are with
                //       anonymous privileges.
                //   2.  When the security token changes over time
                //
                pIDQFile->SetSecurityToken( securityIdentity );
            }
        }
    }

    //
    //  If we didn't find a match, then open and parse a new IDQ file, and
    //  add it to the list of parsed IDQ files
    //

    if ( 0 == pIDQFile )
    {
        ciGibDebugOut(( DEB_ITRACE, "Adding IDQ file %ws to cache\n", wcsFileName ));

        pIDQFile = new CIDQFile(wcsFileName, codePage, securityIdentity);
        XPtr<CIDQFile> xIDQFile( pIDQFile );

        pIDQFile->ParseFile();

        {
            // ==========================================
            CLock lock( _mutex );
            _aIDQFile.Add( pIDQFile, _aIDQFile.Count() );
            pIDQFile->LokAddRef();
            // ==========================================
        }

        xIDQFile.Acquire();
    }

    return pIDQFile;
}


//+---------------------------------------------------------------------------
//
//  Member:     CIDQFileList::~CIDQFileList - public destructor
//
//  History:    96/Mar/27   DwightKr    Created.
//
//----------------------------------------------------------------------------
CIDQFileList::~CIDQFileList()
{
    for (unsigned i=0; i<_aIDQFile.Count(); i++)
    {
        ciGibDebugOut(( DEB_ITRACE,
                        "Deleting IDQ cache entry %ws\n",
                        _aIDQFile[i]->GetIDQFileName() ));

        delete _aIDQFile[i];
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CIDQFileList::Release - public
//
//  Synopsis:   Releases the IDQ file by decrementing its refcount.
//
//  Arguments:  [idqFile] -- pointer to the IDQ file object
//
//  History:    96/Mar/27   DwightKr    Created.
//
//----------------------------------------------------------------------------
void CIDQFileList::Release( CIDQFile & idqFile )
{
    idqFile.Release();
}


//+---------------------------------------------------------------------------
//
//  Member:     CIDQFileList::DeleteZombies - public
//
//  Synopsis:   Removes IDQ files that are zombies; i.e. out of date
//
//  History:    96/Mar/28   DwightKr    Created.
//
//----------------------------------------------------------------------------
void CIDQFileList::DeleteZombies()
{
    // ==========================================
    CLock lock( _mutex );

    unsigned i=0;
    while ( i<_aIDQFile.Count() )
    {
        if ( _aIDQFile[i]->LokGetRefCount() == 0 &&
             !_aIDQFile[i]->IsCachedDataValid() )
        {
            CIDQFile * pIDQFile = _aIDQFile[i];
            _aIDQFile.Remove(i);

            ciGibDebugOut(( DEB_ITRACE,
                            "Deleting zombie IDQ cache entry %ws, %d entries cached\n",
                            pIDQFile->GetIDQFileName(),
                            _aIDQFile.Count() ));

            delete pIDQFile;
        }
        else
        {
            ciGibDebugOut(( DEB_ITRACE,
                            "IDQ cache entry %ws was not deleted, refCount=%d\n",
                            _aIDQFile[i]->GetIDQFileName(),
                            _aIDQFile[i]->LokGetRefCount() ));
            i++;
        }
    }

    // ==========================================
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\web\dll\errormsg.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:       errormsg.cxx
//
//  Contents:   Error messages for output/running queries
//
//  History:    96/Mar/3    DwightKr    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#define ERROR_MESSAGE_SIZE 512

//+---------------------------------------------------------------------------
//
//  Function:   GetErrorPageNoThrow - public
//
//  Synposis:   Generates an error page based on the error parameters passed.
//
//  Arguments:  [eErrorClass]      - class of error (IDQ, HTX, restirction, etc)
//              [status]           - error code generated
//              [ulErrorLine]      - line on which the error occured
//              [wcsErrorFileName] - name of file which generated the error
//              [pVariableSet]     - replaceable parameters which generated the error
//              [pOutputFormat]    - format of dates & numbers
//              [locale]           - locale of the browser
//              [webServer]        - the web server
//              [vString]          - virtual string to contain error code
//
//  History:    96/Feb/29   DwightKr    Created
//
//----------------------------------------------------------------------------
void GetErrorPageNoThrow(
    int   eErrorClass,
    NTSTATUS status,
    ULONG ulErrorLine,
    WCHAR const * wcsErrorFileName,
    CVariableSet * pVariableSet,
    COutputFormat * pOutputFormat,
    LCID locale,
    CWebServer & webServer,
    CVirtualString & vString )
{
    //
    //  If the error was caused by a failure to WRITE to the web server,
    //  then don't bother trying to report an error, there is no one to
    //  receive it.
    //
    if ( eWebServerWriteError == eErrorClass )
    {
        ciGibDebugOut(( DEB_IWARN, "Failed to write to the web server" ));

        return;
    }

    //
    //  If the error was the result of an access denied problem, then simply
    //  return a 401 error to the browser
    //

    WCHAR awcsErrorMessage[ERROR_MESSAGE_SIZE];
    WCHAR * pwszErrorMessage = awcsErrorMessage;
    ULONG cchAvailMessage = ERROR_MESSAGE_SIZE;

    //
    //  Generate the Win32 error code by removing the facility code (7) and
    //  the error bit.
    //
    ULONG Win32status = status;
    if ( (Win32status & (FACILITY_WIN32 << 16)) == (FACILITY_WIN32 << 16) )
    {
        Win32status &= ~( 0x80000000 | (FACILITY_WIN32 << 16) );
    }

    if ( (STATUS_ACCESS_DENIED == status) ||
         (STATUS_NETWORK_ACCESS_DENIED == status) ||
         (ERROR_ACCESS_DENIED == Win32status) ||
         (ERROR_INVALID_ACCESS == Win32status) ||
         (ERROR_NETWORK_ACCESS_DENIED == Win32status)
       )
    {
        ciGibDebugOut(( DEB_WARN, "mapping 0x%x to 401 access denied\n", status ));

        ReturnServerError( HTTP_STATUS_DENIED, webServer );
        return;
    }

    //
    // Map special error codes to their message equivalents.
    //
    if ( QUERY_E_DUPLICATE_OUTPUT_COLUMN == status )
    {
        status = MSG_CI_IDQ_DUPLICATE_COLUMN;
    }
    else if ( QUERY_E_INVALID_OUTPUT_COLUMN == status )
    {
        status = MSG_CI_IDQ_NO_SUCH_COLUMN_PROPERTY;
    }

    if ( 0 != wcsErrorFileName )
    {
        WCHAR *p = wcsrchr( wcsErrorFileName, L'\\' );
        if ( 0 == p )
            p = wcsrchr( wcsErrorFileName, L'/' );
        if ( 0 == p )
            p = wcsrchr( wcsErrorFileName, L':' );

        if ( 0 != p )
            wcsErrorFileName = p + 1;
    }

    //
    // Don't pass a specific lang id to FormatMessage since it will
    // fail if there's no message in that language. Instead set
    // the thread locale, which will get FormatMessage to use a search
    // algorithm to find a message of the appropriate language or
    // use a reasonable fallback msg if there's none.
    //
    LCID SaveLCID = GetThreadLocale();
    SetThreadLocale(locale);

    switch (eErrorClass)
    {
    case eIDQParseError:
    {
        //
        //  These are errors encountered while parsing the IDQ file
        //
        DWORD_PTR args [] = {
                         (DWORD_PTR) ulErrorLine,
                         (DWORD_PTR) wcsErrorFileName
                        };

        if ( ! FormatMessage( FORMAT_MESSAGE_FROM_HMODULE |
                                FORMAT_MESSAGE_ARGUMENT_ARRAY,
                              GetModuleHandle(L"idq.dll"),
                              status,
                              0,
                              pwszErrorMessage,
                              cchAvailMessage,
                              (va_list *) args ) )
        {
            ciGibDebugOut(( DEB_ERROR, "Format message failed with error 0x%x\n", GetLastError() ));

            swprintf( pwszErrorMessage,
                     L"Processing of IDQ file %ls failed with error 0x%x\n",
                     wcsErrorFileName,
                     status );
        }
    }
    break;

    case eIDQPlistError:
    {
        //
        //  These are errors encountered while parsing the [names] section
        //

        if (wcsErrorFileName != 0)
        {
            DWORD_PTR args [] = {
                             (DWORD_PTR) wcsErrorFileName,
                             (DWORD_PTR) ulErrorLine,
                            };

            NTSTATUS MsgNum = MSG_IDQ_FILE_MESSAGE;
            if (ulErrorLine != 0)
            {
                MsgNum = MSG_IDQ_FILE_LINE_MESSAGE;
            }

            ULONG cchMsg = FormatMessage( FORMAT_MESSAGE_FROM_HMODULE |
                                             FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                          GetModuleHandle(L"idq.dll"),
                                          MsgNum,
                                          0,
                                          pwszErrorMessage,
                                          cchAvailMessage,
                                          (va_list *) args );
            pwszErrorMessage += cchMsg;
            cchAvailMessage -= cchMsg;
        }

        if ( ! FormatMessage( FORMAT_MESSAGE_FROM_HMODULE,
                              GetModuleHandle(L"query.dll"),
                              status,
                              0,
                              pwszErrorMessage,
                              cchAvailMessage,
                              0 ) )
        {
            ciGibDebugOut(( DEB_ERROR, "Format message failed with error 0x%x\n", GetLastError() ));

            swprintf( pwszErrorMessage,
                     L"Processing of IDQ file [names] failed with error 0x%x\n",
                     status );
        }
    }
    break;

    case eHTXParseError:
    {
        //
        //  These are errors encountered while parsing the IDQ file
        //
        DWORD_PTR args [] = {
                         (DWORD_PTR) ulErrorLine,
                         (DWORD_PTR) wcsErrorFileName
                        };

        if ( ! FormatMessage( FORMAT_MESSAGE_FROM_HMODULE |
                                 FORMAT_MESSAGE_ARGUMENT_ARRAY,
                               GetModuleHandle(L"idq.dll"),
                               status,
                               0,
                               pwszErrorMessage,
                               cchAvailMessage,
                               (va_list *) args ) )
        {
            ciGibDebugOut(( DEB_ERROR, "Format message failed with error 0x%x\n", GetLastError() ));

            swprintf( pwszErrorMessage,
                      L"Error 0x%x occured while parsing in HTX file %ls\n",
                      status,
                      wcsErrorFileName );
        }
    }
    break;

    case eRestrictionParseError:
    {
        //
        //  These are errors encountered while parsing the restriction
        //
        if ( ! FormatMessage( FORMAT_MESSAGE_FROM_HMODULE,
                               GetModuleHandle(L"query.dll"),
                               status,
                               0,
                               pwszErrorMessage,
                               cchAvailMessage,
                               0 ) )
        {
            ciGibDebugOut(( DEB_ERROR, "Format message failed with error 0x%x\n", GetLastError() ));

            swprintf( pwszErrorMessage,
                     L"Restriction parsing failed with error 0x%x\n",
                     status );
        }
    }
    break;

    default:
    {
        //
        //  All other errors; other major classes of errors are caught above.
        //

        DWORD_PTR args [] = {
                         (DWORD_PTR) ulErrorLine,
                         (DWORD_PTR) wcsErrorFileName
                        };

        if ( ! FormatMessage( FORMAT_MESSAGE_FROM_HMODULE |
                                FORMAT_MESSAGE_ARGUMENT_ARRAY,
                               GetModuleHandle(L"idq.dll"),
                               status,
                               0,
                               pwszErrorMessage,
                               cchAvailMessage,
                               (va_list *) args ) )
        {
            if (wcsErrorFileName != 0)
            {
                NTSTATUS MsgNum = MSG_IDQ_FILE_MESSAGE;
                args[0] = (DWORD_PTR)wcsErrorFileName;
                if (ulErrorLine != 0)
                {
                    args[1] = ulErrorLine;
                    MsgNum = MSG_IDQ_FILE_LINE_MESSAGE;
                }

                ULONG cchMsg = FormatMessage( FORMAT_MESSAGE_FROM_HMODULE |
                                                 FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                              GetModuleHandle(L"idq.dll"),
                                              MsgNum,
                                              0,
                                              pwszErrorMessage,
                                              cchAvailMessage,
                                              (va_list *) args );
                pwszErrorMessage += cchMsg;
                cchAvailMessage -= cchMsg;
            }

            if ( ! FormatMessage( FORMAT_MESSAGE_FROM_HMODULE,
                                   GetModuleHandle(L"query.dll"),
                                   status,
                                   0,
                                   pwszErrorMessage,
                                   cchAvailMessage,
                                   0 ) )
            {
                //
                //  Try looking up the error in the Win32 list of error codes
                //
                if ( ! FormatMessage( FORMAT_MESSAGE_FROM_HMODULE,
                                       GetModuleHandle(L"kernel32.dll"),
                                       Win32status,
                                       0,
                                       pwszErrorMessage,
                                       cchAvailMessage,
                                       0 ) )
                {
                    ciGibDebugOut(( DEB_ERROR,
                                    "Format message failed with error 0x%x\n",
                                    GetLastError() ));

                    swprintf( pwszErrorMessage,
                             L"Error 0x%x caught while processing query\n",
                             status );
                }
            }
        }
    }
    break;
    }
    SetThreadLocale(SaveLCID);

    BOOL fCaughtException = FALSE;

    //
    //  Try to bind to language object by looking up registry and get
    //  the error message HTX file associated with this class of error.
    //
    TRY
    {
        CWebLangLocator langreg( locale );

        WCHAR * wcsErrorFile = 0;

        if ( langreg.LocaleFound() )
        {
            //
            //  If the locale was found in the registry, get the error message
            //  file associated with this language.
            //

            switch (eErrorClass)
            {
            case eIDQParseError:
            case eIDQPlistError:
                wcsErrorFile = langreg.GetIDQErrorFile();
            break;

            case eHTXParseError:
                wcsErrorFile = langreg.GetHTXErrorFile();
            break;

            case eRestrictionParseError:
                wcsErrorFile = langreg.GetRestrictionErrorFile();
            break;

            default:
                wcsErrorFile = langreg.GetDefaultErrorFile();
            break;
            }
        }

        if ( ( 0 != pVariableSet ) &&
             ( 0 != pOutputFormat ) &&
             ( 0 != wcsErrorFile ) &&
             ( wcslen(wcsErrorFile) > 0 ) )
        {
            //
            //  Set CiErrorMessage and CiErrorNumber.
            //
            //  The variables won't own the memory for the strings;
            //  the pointers will be reset later.
            //
            PROPVARIANT propVariant;
            propVariant.vt = VT_LPWSTR;
            propVariant.pwszVal = awcsErrorMessage;

            pVariableSet->SetVariable( ISAPI_CI_ERROR_MESSAGE,
                                       &propVariant,
                                       0 );

            WCHAR achErrorNumber[11];
            swprintf( achErrorNumber, L"0x%8x", status );

            propVariant.pwszVal = achErrorNumber;
            pVariableSet->SetVariable( ISAPI_CI_ERROR_NUMBER,
                                       &propVariant,
                                       0 );

            WCHAR wcsPhysicalPath[_MAX_PATH];
            ULONG cwcVirtualPath = wcslen(wcsErrorFile) + 1;

            XPtrST<WCHAR> wcsVirtualPath( new WCHAR[cwcVirtualPath] );

            //
            // We could have a virtual root or a physical root
            // All virtual roots begin with a "/".
            //

            if (wcsErrorFile[0] == L'/')
            {
                //
                //  Ask the web server to convert the virtual path to our error
                //  message file to a physical path.
                //
                webServer.GetPhysicalPath( wcsErrorFile, wcsPhysicalPath, _MAX_PATH );
   
                RtlCopyMemory( wcsVirtualPath.GetPointer(),
                               wcsErrorFile,
                               cwcVirtualPath*sizeof(WCHAR) );
            }
            else
            {
                // simply copy the path to physical path. It has to be a physical
                // path. If not, it will result in an error later.

                wcscpy(wcsPhysicalPath, wcsErrorFile);
            }

            CSecurityIdentity securityStub;

            CHTXFile htxFile( wcsVirtualPath,
                              pOutputFormat->CodePage(),
                              securityStub,
                              pOutputFormat->GetServerInstance() );

            ciGibDebugOut((DEB_ITRACE, "File is: %ws\n", wcsPhysicalPath));
            htxFile.ParseFile( wcsPhysicalPath, *pVariableSet, webServer );
            htxFile.GetHeader( vString, *pVariableSet, *pOutputFormat );
        }
        else
        {
            vString.StrCat( L"<HTML>" );
            HTMLEscapeW( awcsErrorMessage,
                         vString, 
                         pOutputFormat->CodePage() );
        }
    }
    CATCH ( CException, e )
    {
        fCaughtException = TRUE;
    }
    END_CATCH

    TRY
    {
        // Extending the vstring can fail

        if ( fCaughtException )
        {
            vString.StrCat( L"<HTML>" );
            HTMLEscapeW( awcsErrorMessage,
                         vString, 
                         pOutputFormat->CodePage() );
        }

        // These can fail if the variable wasn't set above

        if ( pVariableSet )
        {
            PROPVARIANT propVariant;
            propVariant.vt = VT_EMPTY;

            pVariableSet->SetVariable( ISAPI_CI_ERROR_MESSAGE,
                                       &propVariant,
                                       0 );
            pVariableSet->SetVariable( ISAPI_CI_ERROR_NUMBER,
                                       &propVariant,
                                       0 );
        }
    }
    CATCH ( CException, e )
    {
        // give up
    }
    END_CATCH
} //GetErrorPageNoThrow


//+---------------------------------------------------------------------------
//
//  Function:   GetErrorPageNoThrow - public
//
//  Synposis:   Generates an error page based on the error parameters passed.
//              The error description is already available.
//
//  Arguments:  [scError]          - error SCODE generated
//              [pwszErrorMessage] - description provided by ole-db error mechanism
//              [pVariableSet]     - replaceable parameters which generated the error
//              [pOutputFormat]    - format of dates & numbers
//              [locale]           - locale of the browser
//              [webServer]        - the web server
//              [vString]          - virtual string to contain error code
//
//  History:    08-May-97   KrishnaN    Created
//
//----------------------------------------------------------------------------

void GetErrorPageNoThrow( int eErrorClass,
                          SCODE scError,
                          WCHAR const * pwszErrorMessage,
                          CVariableSet * pVariableSet,
                          COutputFormat * pOutputFormat,
                          LCID locale,
                          CWebServer & webServer,
                          CVirtualString & vString
                        )
{
    BOOL fCaughtException = FALSE;

    //
    //  Try to bind to language object by looking up registry and get
    //  the error message HTX file associated with this class of error.
    //
    TRY
    {
        //
        //  If the error was the result of an access denied problem, then simply
        //  return a 401 error to the browser
        //

        //
        //  Generate the Win32 error code by removing the facility code (7) and
        //  the error bit.
        //
        ULONG Win32status = scError;
        if ( (Win32status & (FACILITY_WIN32 << 16)) == (FACILITY_WIN32 << 16) )
        {
            Win32status &= ~( 0x80000000 | (FACILITY_WIN32 << 16) );
        }


        if ( (STATUS_ACCESS_DENIED == scError) ||
             (STATUS_NETWORK_ACCESS_DENIED == scError) ||
             (ERROR_ACCESS_DENIED == Win32status) ||
             (ERROR_INVALID_ACCESS == Win32status) ||
             (ERROR_NETWORK_ACCESS_DENIED == Win32status)
           )
        {
            ciGibDebugOut(( DEB_WARN, "mapping 0x%x to 401 access denied\n", scError ));

            ReturnServerError( HTTP_STATUS_DENIED, webServer );
            return;
        }

        CWebLangLocator langreg( locale );

        WCHAR * wcsErrorFile = 0;

        if ( langreg.LocaleFound() )
        {
            //
            //  If the locale was found in the registry, get the error message
            //  file associated with this language.
            //

            switch (eErrorClass)
            {
            case eIDQParseError:
            case eIDQPlistError:
                wcsErrorFile = langreg.GetIDQErrorFile();
            break;

            case eHTXParseError:
                wcsErrorFile = langreg.GetHTXErrorFile();
            break;

            case eRestrictionParseError:
                wcsErrorFile = langreg.GetRestrictionErrorFile();
            break;

            default:
                wcsErrorFile = langreg.GetDefaultErrorFile();
            break;
            }
        }

        if ( ( 0 != pVariableSet ) &&
             ( 0 != pOutputFormat ) &&
             ( 0 != wcsErrorFile ) &&
             ( wcslen(wcsErrorFile) > 0 ) )
        {
            //
            //  Set CiErrorMessage and CiErrorNumber.
            //
            //  The variables won't own the memory for the strings;
            //  the pointers will be reset later.
            //
            PROPVARIANT propVariant;
            propVariant.vt = VT_LPWSTR;
            propVariant.pwszVal = (LPWSTR)pwszErrorMessage;

            pVariableSet->SetVariable( ISAPI_CI_ERROR_MESSAGE,
                                       &propVariant,
                                       0 );

            WCHAR achErrorNumber[11];
            swprintf( achErrorNumber, L"0x%8x", scError );

            propVariant.pwszVal = achErrorNumber;
            pVariableSet->SetVariable( ISAPI_CI_ERROR_NUMBER,
                                       &propVariant,
                                       0 );

            WCHAR wcsPhysicalPath[_MAX_PATH];
            ULONG cwcVirtualPath = wcslen(wcsErrorFile) + 1;

            XPtrST<WCHAR> wcsVirtualPath( new WCHAR[cwcVirtualPath] );

            //
            // We could have a virtual root or a physical root
            // All virtual roots begin with a "/".
            //

            if (wcsErrorFile[0] == L'/')
            {
                //
                //  Ask the web server to convert the virtual path to our error
                //  message file to a physical path.
                //
                webServer.GetPhysicalPath( wcsErrorFile, wcsPhysicalPath, _MAX_PATH );
   
                RtlCopyMemory( wcsVirtualPath.GetPointer(),
                               wcsErrorFile,
                               cwcVirtualPath*sizeof(WCHAR) );
            }
            else
            {
                // simply copy the path to physical path. It has to be a physical
                // path. If not, it will result in an error later.

                wcscpy(wcsPhysicalPath, wcsErrorFile);
            }



            CSecurityIdentity securityStub;

            CHTXFile htxFile( wcsVirtualPath,
                              pOutputFormat->CodePage(),
                              securityStub,
                              pOutputFormat->GetServerInstance() );

            ciGibDebugOut((DEB_ITRACE, "File is: %ws\n", wcsPhysicalPath));
            htxFile.ParseFile( wcsPhysicalPath, *pVariableSet, webServer );
            htxFile.GetHeader( vString, *pVariableSet, *pOutputFormat );
        }
        else
        {
            vString.StrCat( L"<HTML>" );
            vString.StrCat( pwszErrorMessage );
        }
    }
    CATCH ( CException, e )
    {
        fCaughtException = TRUE;
    }
    END_CATCH

    TRY
    {
        // Extending the vstring can fail

        if ( fCaughtException )
        {
            vString.StrCat( L"<HTML>" );
            vString.StrCat( pwszErrorMessage );
        }

        // These can fail if the variable wasn't set above

        if ( pVariableSet )
        {
            PROPVARIANT propVariant;
            propVariant.vt = VT_EMPTY;

            pVariableSet->SetVariable( ISAPI_CI_ERROR_MESSAGE,
                                       &propVariant,
                                       0 );
            pVariableSet->SetVariable( ISAPI_CI_ERROR_NUMBER,
                                       &propVariant,
                                       0 );
        }
    }
    CATCH ( CException, e )
    {
        // give up
    }
    END_CATCH
} //GetErrorPageNoThrow


enum
{
    eAccessDeniedMsg = 0,
    eServerBusyMsg,
    eServerErrorMsg,
};

#define MAX_SERVER_ERROR_MSGSIZE 100

WCHAR g_awszServerErrorMsgs [3] [MAX_SERVER_ERROR_MSGSIZE] =
{
    L"Access denied.\r\n",
    L"Server too busy.\r\n",
    L"Unexpected server error.\r\n",
};

//+---------------------------------------------------------------------------
//
//  Function:   ReturnServerError - public
//
//  Synposis:   Generates an error page for an HTTP error code.
//
//  Arguments:  [httpError]       - the HTTP status code
//              [webServer]       - the web server
//
//  Notes:      This is used when the server is too busy; it should be a
//              very low-overhead path.
//
//  History:    12 Aug 1997     AlanW   Created
//
//----------------------------------------------------------------------------

void ReturnServerError( ULONG httpError,
                        CWebServer & webServer )
{
    char const * pszHeader = "";
    int iMessage = 0;

    switch (httpError)
    {
    case HTTP_STATUS_DENIED:
        pszHeader = "401 Access denied";
        iMessage = eAccessDeniedMsg;
        break;

    case HTTP_STATUS_SERVICE_UNAVAIL:
        pszHeader = "503 Server busy";
        iMessage = eServerBusyMsg;
        break;

    default:
        ciGibDebugOut(( DEB_ERROR, "unexpected server error status %d\n", httpError ));
        httpError = HTTP_STATUS_SERVER_ERROR;
        iMessage = eServerErrorMsg;
        break;
    }

    webServer.WriteHeader( 0, pszHeader );

    WCHAR * pwszMessage = g_awszServerErrorMsgs[iMessage];
    webServer.WriteClient( pwszMessage );
    webServer.SetHttpStatus( httpError );
}


//+---------------------------------------------------------------------------
//
//  Function:   LoadServerErrors - public
//
//  Synposis:   Load messages for server errors.
//
//  Arguments:  -NONE-
//
//  Notes:
//
//  History:    29 Sep 1997     AlanW   Created
//
//----------------------------------------------------------------------------

void LoadServerErrors( )
{
    unsigned iMessage = eAccessDeniedMsg;
    SCODE scMessage = MSG_CI_ACCESS_DENIED;
    const unsigned cMessages = sizeof g_awszServerErrorMsgs /
                               sizeof g_awszServerErrorMsgs[0];


    while (iMessage < cMessages)
    {
        FormatMessage( FORMAT_MESSAGE_FROM_HMODULE,
                       GetModuleHandle(L"idq.dll"),
                       scMessage,
                       GetSystemDefaultLangID(),
                       &g_awszServerErrorMsgs [iMessage][0],
                       MAX_SERVER_ERROR_MSGSIZE,
                       0 );
        scMessage++;
        iMessage++;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\web\dll\ida.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2001.
//
//  File:   ida.cxx
//
//  Contents:   Parser for an IDQ file
//
//  History:    96/Jan/3    DwightKr    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <fsciexps.hxx>

//
// Constants
//

static WCHAR const wcsPRootVar[] = L"PROOT_";
unsigned const ccPRootVar = sizeof(wcsPRootVar)/sizeof(WCHAR) - 1;

static WCHAR const wcsIndexVar[] = L"INDEX_";
unsigned const ccIndexVar = sizeof(wcsIndexVar)/sizeof(WCHAR) - 1;

static WCHAR const wcsNNTP[] = L"NNTP_";
unsigned const ccNNTP = sizeof(wcsNNTP)/sizeof(WCHAR) - 1;

static WCHAR const wcsIMAP[] = L"IMAP_";
unsigned const ccIMAP = sizeof(wcsIMAP)/sizeof(WCHAR) - 1;

static WCHAR const wcsScanVar[] = L"SCAN_";
unsigned const ccScanVar = sizeof(wcsScanVar)/sizeof(WCHAR) - 1;

unsigned const ccStringizedGuid = 36;

BOOL ParseGuid( WCHAR const * pwcsGuid, GUID & guid );

//+---------------------------------------------------------------------------
//
//  Member:     CIDAFile::CIDAFile - public constructor
//
//  Synopsis:   Builds a CIDAFile object, initializes values
//
//  Arguments:  [wcsFileName] -- full path to IDQ file
//
//  History:    13-Apr-96   KyleP       Created.
//
//----------------------------------------------------------------------------

CIDAFile::CIDAFile( WCHAR const * wcsFileName, UINT codePage )
        : _eOperation( CIDAFile::CiState ),
          _wcsCatalog(0),
          _wcsHTXFileName( 0 ),
          _wcsLocale(0),
          _cReplaceableParameters(0),
          _refCount(0),
          _codePage(codePage)
{
    ULONG cwc = wcslen(wcsFileName);

    if ( cwc >= sizeof(_wcsIDAFileName)/sizeof(WCHAR) )
    {
        ciGibDebugOut(( DEB_WARN, "Too long a path (%ws)\n", wcsFileName ));
        THROW( CException( STATUS_INVALID_PARAMETER ));
    }

    RtlCopyMemory( _wcsIDAFileName, wcsFileName, (cwc+1) * sizeof(WCHAR) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CIDAFile::~CIDAFile - public destructor
//
//  History:    13-Apr-96   KyleP       Created.
//
//----------------------------------------------------------------------------

CIDAFile::~CIDAFile()
{
    Win4Assert( _refCount == 0 );

    delete [] _wcsCatalog;
    delete [] _wcsHTXFileName;
    delete [] _wcsLocale;
}


//+---------------------------------------------------------------------------
//
//  Member:     CIDAFile::ParseFile, private
//
//  Synopsis:   Parses the given file and sets up the necessary variables
//
//  History:    13-Apr-96   KyleP       Created.
//              23-Jul-96   DwightKr    Use mapped file I/O which checks
//                                      ACLs and throws ACCESS_DENIED if
//                                      not available.
//
//----------------------------------------------------------------------------

void CIDAFile::ParseFile()
{
    //
    //  Parse the query parameters
    //

    XPtr<CFileMapView> xMapView;

    TRY
    {
        xMapView.Set( new CFileMapView( _wcsIDAFileName ) );
        xMapView->Init();
    }
    CATCH( CException, e )
    {
        if ( HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ) == e.GetErrorCode() )
        {
            THROW( CIDQException( MSG_CI_IDQ_NOT_FOUND, 0 ) );
        }
        else
        {
            RETHROW();
        }
    }
    END_CATCH

    CFileBuffer idaFile( xMapView.GetReference(), _codePage );

    //
    //  Process a line at a time, look for the [Admin] section and
    //  process lines within that section.
    //

    BOOL fAdminSection = FALSE;
    int iLine = 0;                  // Start counting at line #1

    for( ;; )
    {
        iLine++;
        XGrowable<WCHAR> xLine;

        ULONG cwcChar = idaFile.fgetsw( xLine );

        if( 0 == cwcChar )
        {
            break;
        }

        WCHAR *pwcLine = xLine.Get();

        //
        //  Skip ahead until we find a [Admin] section
        //

        if ( L'[' == *pwcLine )
        {
            if ( _wcsnicmp(pwcLine+1, L"Admin]", 6) == 0 )
                fAdminSection = TRUE;
            else
                fAdminSection = FALSE;

            continue;
        }

        //
        // Ignore comments.
        //

        else if ( L'#' == *pwcLine )
            continue;


        if ( fAdminSection )
        {
            CQueryScanner scanner( pwcLine, FALSE );
            ParseOneLine( scanner, iLine );
        }
    }

    //
    //  Verify that the minimum set of parameters are specified.
    //

    //
    //  We must have all of the following:
    //
    //      - a HTX file name
    //

    if ( 0 == _wcsHTXFileName )
    {
        // Report an error
        ciGibDebugOut(( DEB_IERROR, "Template not found in IDA file.\n" ));
        THROW( CIDQException(MSG_CI_IDQ_MISSING_TEMPLATEFILE, 0) );
    }

    //
    //  If no catalog was specified, use the default catalog in the registry
    //
    if ( 0 == _wcsCatalog )
    {
        ciGibDebugOut(( DEB_ITRACE, "Using default catalog\n" ));

        WCHAR awcTmp[ MAX_PATH ];
        ULONG cwcRequired = TheIDQRegParams.GetISDefaultCatalog( awcTmp,
                                                                 MAX_PATH );
        if ( cwcRequired > MAX_PATH )
            THROW( CException(STATUS_INVALID_PARAMETER) );

        cwcRequired++; // make room for termination
        _wcsCatalog = new WCHAR[ cwcRequired ];
        RtlCopyMemory( _wcsCatalog, awcTmp, cwcRequired * sizeof WCHAR );
    }

}

//+---------------------------------------------------------------------------
//
//  Member:     CIDAFile::ParseOneLine, private
//
//  Synopsis:   Parses one line of the IDQ file
//
//  Arguments:  [scan]   -- scanner initialized with the current line
//              [iLine]  -- current line number
//
//  History:    13-Apr-96   KyleP       Created.
//
//----------------------------------------------------------------------------

void CIDAFile::ParseOneLine( CQueryScanner & scan, unsigned iLine )
{
    //
    //  Is this a comment line (does it start with #) or an empty line?
    //
    if ( scan.LookAhead() == PROP_REGEX_TOKEN || scan.LookAhead() == EOS_TOKEN )
    {
        return;
    }

    if ( scan.LookAhead() != TEXT_TOKEN )    //  Better be a word
    {
        // Report an error
        THROW( CIDQException( MSG_CI_IDQ_EXPECTING_NAME, iLine ) );
    }

    XPtrST<WCHAR> wcsAttribute( scan.AcqWord() );

    if( wcsAttribute.GetPointer() == 0 )                  // Better find a word
    {
        THROW( CIDQException( MSG_CI_IDQ_EXPECTING_TYPE, iLine ) );
    }

    scan.Accept();

    if ( scan.LookAhead() != EQUAL_TOKEN )
    {
        // Report an error
        THROW( CIDQException( MSG_CI_IDQ_EXPECTING_EQUAL, iLine ) );
    }

    scan.Accept();

    if ( 0 == _wcsicmp( wcsAttribute.GetPointer(), ISAPI_CI_CATALOG ) )
        GetStringValue( scan, iLine, &_wcsCatalog );
    else if ( 0 == _wcsicmp( wcsAttribute.GetPointer(), ISAPI_CI_TEMPLATE ) )
        GetStringValue( scan, iLine, &_wcsHTXFileName );
    else if ( 0 == _wcsicmp( wcsAttribute.GetPointer(), ISAPI_CI_ADMIN_OPERATION ) )
    {
        WCHAR * pwcsTemp = 0;
        GetStringValue( scan, iLine, &pwcsTemp );

        XPtrST<WCHAR> xwcsTemp( pwcsTemp );

        if ( 0 == pwcsTemp )
        {
            THROW( CIDQException( MSG_CI_IDA_INVALID_OPERATION, iLine ) );
        }
        else if ( 0 == _wcsicmp( pwcsTemp, wcsOpGetState ) )
            _eOperation = CIDAFile::CiState;
        else if ( 0 == _wcsicmp( pwcsTemp, wcsOpForceMerge ) )
            _eOperation = CIDAFile::ForceMerge;
        else if ( 0 == _wcsicmp( pwcsTemp, wcsOpScanRoots ) )
            _eOperation = CIDAFile::ScanRoots;
        else if ( 0 == _wcsicmp( pwcsTemp, wcsOpUpdateCache ) )
            _eOperation = CIDAFile::UpdateCache;
        else
        {
            THROW( CIDQException( MSG_CI_IDA_INVALID_OPERATION, iLine ) );
        }
    }
    else if ( 0 == _wcsicmp( wcsAttribute.GetPointer(), ISAPI_CI_LOCALE ) )
    {
        GetStringValue( scan, iLine, &_wcsLocale );
    }
    else
    {
        //
        //  We've found a keyword/attribute that we don't support.
        //  Don't report an error. This will allow this version of the
        //  parser to work with newer .IDA file versions with new parameters.
        //

        ciGibDebugOut(( DEB_ERROR, "Invalid string in IDQ file: %ws\n", wcsAttribute.GetPointer() ));
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CIDAFile::GetStringValue - private
//
//  Synopsis:   Gets the string value on the currenct line
//
//  Arguments:  [scan]   -- scanner initialized with the current line
//              [iLine]  -- current line number
//              [pwcsStringValue] -- value to put string into
//
//  History:    13-Apr-96   KyleP       Created.
//
//----------------------------------------------------------------------------

void CIDAFile::GetStringValue( CQueryScanner & scan,
                               unsigned iLine,
                               WCHAR ** pwcsStringValue )
{
    if ( 0 != *pwcsStringValue )
    {
        ciGibDebugOut(( DEB_IWARN,
                        "Duplicate CiXX=value in IDA file on line #%d\n",
                        iLine ));
        THROW( CIDQException(MSG_CI_IDQ_DUPLICATE_ENTRY, iLine) );
    }

    *pwcsStringValue = scan.AcqLine();

    if ( IsAReplaceableParameter( *pwcsStringValue ) != eIsSimpleString )
    {
        _cReplaceableParameters++;
    }
}

//+---------------------------------------------------------------------------
//
//  Function:   FindEntry, public
//
//  Synopsis:   Helper function for admin variable parsing.
//
//  Arguments:  [pwcsName]   -- Variable name
//              [fScan]      -- TRUE for SCAN, FALSE for INDEX
//              [pwcsBuf]    -- Buffer for search token
//
//  History:    10-Oct-96   KyleP       Created.
//
//----------------------------------------------------------------------------

BOOL FindEntry( WCHAR const * * ppwcsName, BOOL fScan, WCHAR * pwcsBuf )
{
    if ( 0 != _wcsnicmp( *ppwcsName, wcsPRootVar, ccPRootVar ) )
        return FALSE;

    //
    // Scan or Index?
    //

    WCHAR const * pwcsOutputTag;
    unsigned ccOutputTag;

    if ( fScan )
    {
        pwcsOutputTag = wcsScanVar;
        ccOutputTag = ccScanVar;
    }
    else
    {
        pwcsOutputTag = wcsIndexVar;
        ccOutputTag = ccIndexVar;
    }

    //
    // IMAP, NNTP or W3?
    //

    unsigned ccPrefix = ccOutputTag;

    BOOL fW3 = FALSE;
    BOOL fNNTP = FALSE;
    BOOL fIMAP = FALSE;

    if ( 0 == _wcsnicmp( *ppwcsName + ccPRootVar, wcsNNTP, ccNNTP ) )
    {
        fNNTP = TRUE;
        *ppwcsName += ccNNTP;
        ccPrefix += ccNNTP;
    }
    else if ( 0 == _wcsnicmp( *ppwcsName + ccPRootVar, wcsIMAP, ccIMAP ) )
    {
        fIMAP = TRUE;
        *ppwcsName += ccIMAP;
        ccPrefix += ccIMAP;
    }
    else
    {
        fW3 = TRUE;
    }

    *ppwcsName += ccPRootVar;

    //
    // Length check.
    //

    unsigned ccName = wcslen( *ppwcsName ) + 1;

    if ( ccName + ccPrefix > (MAX_PATH + ccIndexVar + ccNNTP + 1) )
    {
        ciGibDebugOut(( DEB_WARN, "Path %ws too long for admin\n", *ppwcsName ));
        return FALSE;
    }

    if ( ccName + ccPrefix > (MAX_PATH + ccIndexVar + ccIMAP + 1) )
    {
        ciGibDebugOut(( DEB_WARN, "Path %ws too long for admin\n", *ppwcsName ));
        return FALSE;
    }

    //
    // Build output name
    //

    RtlCopyMemory( pwcsBuf, pwcsOutputTag, ccOutputTag * sizeof(WCHAR) );

    if ( fNNTP )
        RtlCopyMemory( pwcsBuf + ccOutputTag, wcsNNTP, ccNNTP * sizeof(WCHAR) );
    else if ( fIMAP )
        RtlCopyMemory( pwcsBuf + ccOutputTag, wcsIMAP, ccIMAP * sizeof(WCHAR) );

    RtlCopyMemory( pwcsBuf + ccPrefix, *ppwcsName, ccName * sizeof(WCHAR) );

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Function:   DoAdmin, public
//
//  Synopsis:   Executes an administrative change.
//
//  Arguments:  [wcsIDAFile]   -- Virtual path to .IDA file
//              [VarSet]       -- Query variables
//              [OutputFormat] -- Output format
//              [vsResults]    -- On success (non exception) result page
//                                written here.
//
//  History:    13-Apr-96   KyleP       Created.
//              22-Jul-96   DwightKr    Make CiLocale replaceable & visible
//                                      in HTX files
//              11-Jun-97   KyleP       Use web server in Output Format
//
//----------------------------------------------------------------------------

void DoAdmin( WCHAR const * wcsIDAFile,
              CVariableSet & VarSet,
              COutputFormat & OutputFormat,
              CVirtualString & vsResults )
{
    //
    // Parse .IDA file.  We don't bother to cache these.
    //

    XPtr<CIDAFile> xIDAFile( new CIDAFile(wcsIDAFile, OutputFormat.CodePage()) );
    xIDAFile->ParseFile();


    ULONG cwcOut;
    XPtrST<WCHAR> wcsLocaleID( ReplaceParameters( xIDAFile->GetLocale(),
                                                  VarSet,
                                                  OutputFormat,
                                                  cwcOut ) );

    XArray<WCHAR> wcsLocale;
    LCID locale = GetQueryLocale( wcsLocaleID.GetPointer(),
                                  VarSet,
                                  OutputFormat,
                                  wcsLocale );

    if ( OutputFormat.GetLCID() != locale )
    {

        ciGibDebugOut(( DEB_ITRACE,
                        "Wrong codePage used for loading IDA file, used 0x%x retrying with 0x%x\n",
                        OutputFormat.CodePage(),
                        LocaleToCodepage(locale) ));

        //
        //  We've parsed the IDA file with the wrong locale.
        //

        delete xIDAFile.Acquire();

        OutputFormat.LoadNumberFormatInfo( locale );

        xIDAFile.Set( new CIDAFile(wcsIDAFile, OutputFormat.CodePage()) );
        xIDAFile->ParseFile();
    }


    SetupDefaultCiVariables( VarSet );
    SetupDefaultISAPIVariables( VarSet );
    SetCGIVariables( VarSet, OutputFormat );

    //
    // Get the catalog.
    //

    XPtrST<WCHAR> wcsCiCatalog( ReplaceParameters( xIDAFile->GetCatalog(),
                                                   VarSet,
                                                   OutputFormat,
                                                   cwcOut ) );

    //
    //  Verify that the wcsCatalog is valid
    //
    if ( !IsAValidCatalog( wcsCiCatalog.GetPointer(), cwcOut ) )
    {
        THROW( CIDQException(MSG_CI_IDQ_NO_SUCH_CATALOG, 0) );
    }

    //
    // Get the catalog and machine from the URL style catalog.
    //

    XPtrST<WCHAR> wcsMachine( 0 );
    XPtrST<WCHAR> wcsCatalog( 0 );
    SCODE sc = ParseCatalogURL( wcsCiCatalog.GetPointer(),
                                wcsCatalog,
                                wcsMachine );

    if (FAILED(sc))
    {
        THROW( CException(sc) );
    }

    Win4Assert ( 0 != wcsMachine.GetPointer() );

    //
    // Check that the client is allowed to perform administration
    //
    CheckAdminSecurity( wcsMachine.GetPointer() );

    //
    // Build the HTX page for [success] output
    //

    XPtrST<WCHAR> wcsTemplate( ReplaceParameters( xIDAFile->GetHTXFileName(),
                                                  VarSet,
                                                  OutputFormat,
                                                  cwcOut ) );

    WCHAR wcsPhysicalName[_MAX_PATH];

    if ( OutputFormat.IsValid() )
    {
        OutputFormat.GetPhysicalPath( wcsTemplate.GetPointer(),
                                      wcsPhysicalName,
                                      _MAX_PATH );
    }
    else
    {
        if ( !GetFullPathName( wcsTemplate.GetPointer(),
                               MAX_PATH,
                               wcsPhysicalName,
                               0 ) )
        {
            THROW( CException() );
        }
    }


    //
    // Note: Parsing of HTX file needs to be done in different locations
    //       to ensure variables added to variable set by admin operations
    //       are added before parse.  But we also don't want to fail the
    //       parse *after* doing a dangerous operation (like force merge).
    //

    CSecurityIdentity securityStub;

    CHTXFile SuccessHTX( wcsTemplate,
                         OutputFormat.CodePage(),
                         securityStub,
                         OutputFormat.GetServerInstance() );

    switch ( xIDAFile->Operation() )
    {

    case CIDAFile::ScanRoots:
    {
        SuccessHTX.ParseFile( wcsPhysicalName, VarSet, OutputFormat );

        if ( SuccessHTX.DoesDetailSectionExist() )
        {
            THROW( CIDQException(MSG_CI_IDA_TEMPLATE_DETAIL_SECTION, 0) );
        }

        //
        // Execute the changes.  'Entries' have the following format:
        //     Variable: P<virtual root> = physical root for <virtual root>
        //     Variable: S<virtual root> = "on" / existence means root is scanned
        //     Variable: T<virtual root> = "on" / existence means full scan
        //

        CVariableSetIter iter( VarSet );

        while ( !iter.AtEnd() )
        {
            CVariable * pVar = iter.Get();
            WCHAR const * pwcsName = pVar->GetName();

            WCHAR wcsScanName[MAX_PATH + ccScanVar + __max( ccNNTP, ccIMAP ) + 1];

            if ( FindEntry( &pwcsName,     // Starting variable
                            TRUE,          // SCAN
                            wcsScanName )) // Matching search string returned here
            {
                PROPVARIANT * ppvPRoot = pVar->GetValue();

                CVariable * pScanVar = VarSet.Find( wcsScanName );

                if ( 0 !=  pScanVar )
                {
                    WCHAR const * pwszScanType = pScanVar->GetStringValueRAW();

                    if ( 0 != pwszScanType &&
                         ( 0 == _wcsicmp( pwszScanType, L"FullScan" ) ||
                           0 == _wcsicmp( pwszScanType, L"IncrementalScan")
                         ) )
                    {
                        BOOL fFull = (0 == _wcsicmp( pwszScanType, L"FullScan" ));
                        SCODE sc = UpdateContentIndex( ppvPRoot->pwszVal,
                                                       wcsCatalog.GetPointer(),
                                                       wcsMachine.GetPointer(),
                                                       fFull );
                        if ( FAILED(sc) )
                        {
                            ciGibDebugOut(( DEB_ERROR,
                                            "Error 0x%x scanning virtual scope %ws\n",
                                            pwcsName ));
                            THROW( CException( sc ) );
                        }

                    }
                }
            }

            iter.Next();
        }
        break;
    }

    case CIDAFile::UpdateCache:
    {
        SuccessHTX.ParseFile( wcsPhysicalName, VarSet, OutputFormat );

        if ( SuccessHTX.DoesDetailSectionExist() )
        {
            THROW( CIDQException(MSG_CI_IDA_TEMPLATE_DETAIL_SECTION, 0) );
        }

        //
        // Execute the changes.  'Entries' have the following format:
        //     Variable: CACHESIZE_<guid>_NAME_<name>     = Size for named entry
        //     Variable: CACHESIZE_<guid>_PROPID_<propid> = Size for numbered entry
        //     Variable: CACHETYPE_<guid>_NAME_<name>     = Type for named entry
        //     Variable: CACHETYPE_<guid>_PROPID_<propid> = Type for numbered entry
        //

        CVariableSetIter iter( VarSet );

        BOOL fSawOne = FALSE;
        ULONG_PTR ulToken;

        SCODE sc = BeginCacheTransaction( &ulToken,
                                          wcsCatalog.GetPointer(),
                                          wcsCatalog.GetPointer(),
                                          wcsMachine.GetPointer() );

        if ( FAILED(sc) )
        {
            ciGibDebugOut(( DEB_ERROR, "Error 0x%x setting up cache transaction.\n", sc ));
            THROW( CException( sc ) );
        }

        while ( !iter.AtEnd() )
        {
            CVariable * pVar = iter.Get();
            WCHAR const * pwcsName = pVar->GetName();

            //
            // We write out last prop twice, 2nd time to commit everything.
            //


            //
            // Constants.
            //

            static WCHAR const wcsSizeVar[] = L"CACHESIZE_";
            unsigned ccSizeVar = sizeof(wcsSizeVar)/sizeof(WCHAR) - 1;
            static WCHAR const wcsTypeVar[] = L"CACHETYPE_";
            unsigned ccTypeVar = sizeof(wcsTypeVar)/sizeof(WCHAR) - 1;

            if ( 0 == _wcsnicmp( pwcsName, wcsSizeVar, ccSizeVar ) )
            {
                CFullPropSpec ps;

                //
                // Parse the GUID.
                //

                unsigned cc = wcslen( pwcsName );
                GUID guid;

                if ( cc <= ccSizeVar || !ParseGuid( pwcsName + ccSizeVar, guid ) )
                {
                    ciGibDebugOut(( DEB_WARN, "Improperly formatted CACHESIZE entry %ws\n", pwcsName ));
                    iter.Next();
                    continue;
                }

                ps.SetPropSet( guid );

                //
                // PROPID or string?
                //

                static WCHAR const wcsName[] = L"_NAME_";
                unsigned ccName = sizeof(wcsName)/sizeof(WCHAR) - 1;
                static WCHAR const wcsPropid[] = L"_PROPID_";
                unsigned ccPropid = sizeof(wcsPropid)/sizeof(WCHAR) - 1;

                if ( 0 == _wcsnicmp( pwcsName + ccSizeVar + ccStringizedGuid, wcsPropid, ccPropid ) )
                {
                    CQueryScanner scan( pwcsName + ccSizeVar + ccStringizedGuid + ccPropid, FALSE );

                    PROPID propid;
                    BOOL fEnd;

                    if ( !scan.GetNumber( propid, fEnd ) )
                    {
                        ciGibDebugOut(( DEB_WARN, "Improperly formatted CACHESIZE entry %ws\n", pwcsName ));
                        iter.Next();
                        continue;
                    }

                    ps.SetProperty( propid );
                }
                else if ( 0 == _wcsnicmp( pwcsName + ccSizeVar + ccStringizedGuid, wcsName, ccName ) )
                {
                    ps.SetProperty( pwcsName + ccSizeVar + ccStringizedGuid + ccName );
                }
                else
                {
                    ciGibDebugOut(( DEB_WARN, "Improperly formatted CACHESIZE entry %ws\n", pwcsName ));
                    iter.Next();
                    continue;
                }

                //
                // Get value.
                //

                PROPVARIANT * ppvSize = pVar->GetValue();
                ULONG cb;

                if ( ppvSize->vt == VT_LPWSTR )
                {
                    CQueryScanner scan( ppvSize->pwszVal, FALSE );

                    BOOL fEnd;

                    if ( !scan.GetNumber( cb, fEnd ) )
                    {
                        ciGibDebugOut(( DEB_WARN, "Improper CACHESIZE size: \"%ws\".\n", ppvSize->pwszVal ));
                        iter.Next();
                        continue;
                    }
                }
                else
                {
                    ciGibDebugOut(( DEB_IWARN, "Improper CACHESIZE size (type = %d).\n", ppvSize->vt ));
                    iter.Next();
                    continue;
                }

                if ( 0 == cb )
                {
                    //
                    // Delete property from cache (if it was even there).
                    //

                    //
                    // If IDA were the future...
                    // Need to allow primary or secondary store to be chosen!
                    // Also allow the ability to set true/false for prop meta info
                    // modifiability.
                    //

                    SCODE sc = SetupCacheEx( ps.CastToStruct(),
                                             0,
                                             0,
                                             ulToken,
                                             TRUE,
                                             PRIMARY_STORE,
                                             wcsCatalog.GetPointer(),
                                             wcsCatalog.GetPointer(),
                                             wcsMachine.GetPointer() );

                    if ( FAILED(sc) )
                    {
                        ciGibDebugOut(( DEB_ERROR, "Error 0x%x modifying cache\n", sc ));
                        THROW( CException( sc ) );
                    }

                    fSawOne       = TRUE;
                    iter.Next();
                    continue;
                }

                //
                // At this point, we have a non-zero size. The property will
                // be added to the cache.
                //

                //
                // Fetch data type
                //

                XArray<WCHAR> xVar(cc+1);

                RtlCopyMemory( xVar.GetPointer(), pwcsName, (cc+1) * sizeof(WCHAR) );
                RtlCopyMemory( xVar.GetPointer(), wcsTypeVar, ccTypeVar * sizeof(WCHAR) );


                CVariable * pVarType =  VarSet.Find( xVar.GetPointer() );

                if ( 0 == pVarType )
                {
                    ciGibDebugOut(( DEB_WARN, "Missing CACHETYPE value.\n" ));
                    iter.Next();
                    continue;
                }

                PROPVARIANT * ppvType = pVarType->GetValue();
                ULONG type;

                if ( ppvType->vt == VT_LPWSTR )
                {
                    CQueryScanner scan( ppvType->pwszVal, FALSE );

                    BOOL fEnd;

                    if ( !scan.GetNumber( type, fEnd ) )
                    {
                        ciGibDebugOut(( DEB_WARN, "Improper CACHETYPE type: \"%ws\".\n", ppvType->pwszVal ));
                        iter.Next();
                        continue;
                    }
                }
                else
                {
                    ciGibDebugOut(( DEB_WARN, "Improper CACHETYPE size (type = %d).\n", ppvType->vt ));
                    iter.Next();
                    continue;
                }

                ciGibDebugOut(( DEB_WARN, "Add/change %ws\n", pwcsName ));

                //
                // If IDA were the future...
                // Need to allow primary or secondary store to be chosen!
                // Also allow the ability to set true/false for prop meta info
                // modifiability.
                //

                SCODE sc = SetupCacheEx( ps.CastToStruct(),
                                         type,
                                         cb,
                                         ulToken,
                                         TRUE,
                                         SECONDARY_STORE,
                                         wcsCatalog.GetPointer(),
                                         wcsCatalog.GetPointer(),
                                         wcsMachine.GetPointer() );

                if ( FAILED(sc) )
                {
                    ciGibDebugOut(( DEB_ERROR, "Error 0x%x modifying cache\n", sc ));
                    THROW( CException( sc ) );
                }

                fSawOne       = TRUE;
            }

            iter.Next();
        }

        sc = EndCacheTransaction( ulToken,
                                  fSawOne,
                                  wcsCatalog.GetPointer(),
                                  wcsCatalog.GetPointer(),
                                  wcsMachine.GetPointer() );

        if ( FAILED(sc) )
        {
            ciGibDebugOut(( DEB_ERROR, "Error 0x%x completing cache transaction.\n", sc ));
            THROW( CException( sc ) );
        }
        break;
    }

    case CIDAFile::CiState:
    {
        //
        // Populate the variable set.
        //

        CStorageVariant var;

        var.SetUI4( TheWebQueryCache.Hits() );
        VarSet.SetVariable( ISAPI_CI_ADMIN_CACHE_HITS, var, 0 );

        var.SetUI4( TheWebQueryCache.Misses() );
        VarSet.SetVariable( ISAPI_CI_ADMIN_CACHE_MISSES, var, 0 );

        var.SetUI4( TheWebQueryCache.Running() );
        VarSet.SetVariable( ISAPI_CI_ADMIN_CACHE_ACTIVE, var, 0 );

        var.SetUI4( TheWebQueryCache.Cached() );
        VarSet.SetVariable( ISAPI_CI_ADMIN_CACHE_COUNT, var, 0 );

        var.SetUI4( TheWebPendingRequestQueue.Count() );
        VarSet.SetVariable( ISAPI_CI_ADMIN_CACHE_PENDING, var, 0 );

        var.SetUI4( TheWebQueryCache.Rejected() );
        VarSet.SetVariable( ISAPI_CI_ADMIN_CACHE_REJECTED, var, 0 );

        var.SetUI4( TheWebQueryCache.Total() );
        VarSet.SetVariable( ISAPI_CI_ADMIN_CACHE_TOTAL, var, 0 );

        var.SetUI4( TheWebQueryCache.QPM() );
        VarSet.SetVariable( ISAPI_CI_ADMIN_CACHE_QPM, var, 0 );

        //
        // Fetch CI state.
        //

        CI_STATE sState;
        sState.cbStruct = sizeof(sState);

        SCODE sc = CIState ( wcsCatalog.GetPointer(),
                             wcsMachine.GetPointer(),
                             &sState );

        if ( FAILED(sc) )
        {
            ciGibDebugOut(( DEB_ERROR, "Error 0x%x getting CI state.\n", sc ));
            THROW( CException( sc ) );
        }

        var.SetUI4( sState.cWordList );
        VarSet.SetVariable( ISAPI_CI_ADMIN_INDEX_COUNT_WORDLISTS, var, 0 );

        var.SetUI4( sState.cPersistentIndex );
        VarSet.SetVariable( ISAPI_CI_ADMIN_INDEX_COUNT_PERSINDEX, var, 0 );

        var.SetUI4( sState.cQueries );
        VarSet.SetVariable( ISAPI_CI_ADMIN_INDEX_COUNT_QUERIES, var, 0 );

        var.SetUI4( sState.cDocuments );
        VarSet.SetVariable( ISAPI_CI_ADMIN_INDEX_COUNT_TOFILTER, var, 0 );

        var.SetUI4( sState.cFreshTest );
        VarSet.SetVariable( ISAPI_CI_ADMIN_INDEX_COUNT_FRESHTEST, var, 0 );

        var.SetUI4( sState.dwMergeProgress );
        VarSet.SetVariable( ISAPI_CI_ADMIN_INDEX_MERGE_PROGRESS, var, 0 );

        var.SetUI4( sState.cPendingScans );
        VarSet.SetVariable( ISAPI_CI_ADMIN_INDEX_COUNT_PENDINGSCANS, var, 0 );

        var.SetUI4( sState.cFilteredDocuments );
        VarSet.SetVariable( ISAPI_CI_ADMIN_INDEX_COUNT_FILTERED, var, 0 );

        var.SetUI4( sState.cTotalDocuments );
        VarSet.SetVariable( ISAPI_CI_ADMIN_INDEX_COUNT_TOTAL, var, 0 );

        var.SetUI4( sState.cUniqueKeys );
        VarSet.SetVariable( ISAPI_CI_ADMIN_INDEX_COUNT_UNIQUE, var, 0 );

        var.SetUI4( sState.dwIndexSize );
        VarSet.SetVariable( ISAPI_CI_ADMIN_INDEX_SIZE, var, 0 );

        if ( sState.eState & CI_STATE_SHADOW_MERGE )
            var.SetBOOL( VARIANT_TRUE );
        else
            var.SetBOOL( VARIANT_FALSE );

        VarSet.SetVariable( ISAPI_CI_ADMIN_INDEX_STATE_SHADOWMERGE, var, 0 );

        if ( sState.eState & CI_STATE_MASTER_MERGE )
            var.SetBOOL( VARIANT_TRUE );
        else
            var.SetBOOL( VARIANT_FALSE );

        VarSet.SetVariable( ISAPI_CI_ADMIN_INDEX_STATE_MASTERMERGE, var, 0 );

        if ( sState.eState & CI_STATE_ANNEALING_MERGE )
            var.SetBOOL( VARIANT_TRUE );
        else
            var.SetBOOL( VARIANT_FALSE );

        VarSet.SetVariable( ISAPI_CI_ADMIN_INDEX_STATE_ANNEALINGMERGE, var, 0 );

        if ( sState.eState & CI_STATE_CONTENT_SCAN_REQUIRED )
            var.SetBOOL( VARIANT_TRUE );
        else
            var.SetBOOL( VARIANT_FALSE );

        VarSet.SetVariable( ISAPI_CI_ADMIN_INDEX_STATE_SCANREQUIRED, var, 0 );

        if ( sState.eState & CI_STATE_SCANNING )
            var.SetBOOL( VARIANT_TRUE );
        else
            var.SetBOOL( VARIANT_FALSE );

        VarSet.SetVariable( ISAPI_CI_ADMIN_INDEX_STATE_SCANNING, var, 0 );

        if ( sState.eState & CI_STATE_RECOVERING )
            var.SetBOOL( VARIANT_TRUE );
        else
            var.SetBOOL( VARIANT_FALSE );

        VarSet.SetVariable( ISAPI_CI_ADMIN_INDEX_STATE_RECOVERING, var, 0 );

        //
        // Now that we've got the variables, we can parse the file.
        //

        SuccessHTX.ParseFile( wcsPhysicalName, VarSet, OutputFormat );

        if ( SuccessHTX.DoesDetailSectionExist() )
        {
            THROW( CIDQException(MSG_CI_IDA_TEMPLATE_DETAIL_SECTION, 0) );
        }

        break;
    }

    case CIDAFile::ForceMerge:
    {
        SuccessHTX.ParseFile( wcsPhysicalName, VarSet, OutputFormat );

        if ( SuccessHTX.DoesDetailSectionExist() )
        {
            THROW( CIDQException(MSG_CI_IDA_TEMPLATE_DETAIL_SECTION, 0) );
        }

        SCODE sc = ForceMasterMerge( wcsCatalog.GetPointer(),  // Drive
                                     wcsCatalog.GetPointer(),  // Catalog
                                     wcsMachine.GetPointer(),  // Machine
                                     1 );                      // Partition

        if ( FAILED(sc) )
        {
            ciGibDebugOut(( DEB_ERROR, "Error 0x%x calling ForceMerge for %ws\n",
                            sc, wcsCatalog.GetPointer() ));
            THROW( CException( sc ) );
        }
        break;
    }
    }

    //
    //  Set CiQueryTime
    //
    ULONG cwcQueryTime = 40;
    SYSTEMTIME QueryTime;
    GetLocalTime( &QueryTime );

    XArray<WCHAR> wcsQueryTime(cwcQueryTime-1);
    cwcQueryTime = OutputFormat.FormatTime( QueryTime,
                                            wcsQueryTime.GetPointer(),
                                            cwcQueryTime );

    //
    //  SetCiQueryDate
    //
    ULONG cwcQueryDate = 40;
    XArray<WCHAR> wcsQueryDate(cwcQueryDate-1);
    cwcQueryDate = OutputFormat.FormatDate( QueryTime,
                                            wcsQueryDate.GetPointer(),
                                            cwcQueryDate );


    VarSet.AcquireStringValue( ISAPI_CI_QUERY_TIME, wcsQueryTime.GetPointer(), 0 );
    wcsQueryTime.Acquire();

    VarSet.AcquireStringValue( ISAPI_CI_QUERY_DATE, wcsQueryDate.GetPointer(), 0 );
    wcsQueryDate.Acquire();

    //
    //  Set CiQueryTimeZone
    //
    TIME_ZONE_INFORMATION TimeZoneInformation;
    DWORD dwResult = GetTimeZoneInformation( &TimeZoneInformation );
    LPWSTR pwszTimeZoneName = 0;

    if ( TIME_ZONE_ID_DAYLIGHT == dwResult )
    {
        pwszTimeZoneName = TimeZoneInformation.DaylightName;
    }
    else if ( 0xFFFFFFFF == dwResult )
    {
#       if CIDBG == 1
           DWORD dwError = GetLastError();
           ciGibDebugOut(( DEB_ERROR, "Error %d from GetTimeZoneInformation.\n", dwError ));
           THROW(CException( HRESULT_FROM_WIN32(dwError) ));
#       else
           THROW( CException() );
#       endif
    }
    else
    {
        pwszTimeZoneName = TimeZoneInformation.StandardName;
    }

    VarSet.CopyStringValue( ISAPI_CI_QUERY_TIMEZONE, pwszTimeZoneName, 0);

    //
    //  Set CiCatalog, CiLocale and CiTemplate
    //
    VarSet.AcquireStringValue( ISAPI_CI_CATALOG, wcsCiCatalog.GetPointer(), 0 );
    wcsCiCatalog.Acquire();

    VarSet.AcquireStringValue( ISAPI_CI_LOCALE, wcsLocale.GetPointer(), 0 );
    wcsLocale.Acquire();

    VarSet.CopyStringValue( ISAPI_CI_TEMPLATE, SuccessHTX.GetVirtualName(), 0 );


    //
    // If we got here, then all changes succeeded and we build success page.
    //

    SuccessHTX.GetHeader( vsResults, VarSet, OutputFormat );
    SuccessHTX.GetFooter( vsResults, VarSet, OutputFormat );
}

BOOL ParseGuid( WCHAR const * pwcsGuid, GUID & guid )
{
    unsigned cc = wcslen( pwcsGuid );

    if ( cc < ccStringizedGuid ||
         L'-' != pwcsGuid[8] ||
         L'-' != pwcsGuid[13] ||
         L'-' != pwcsGuid[18] ||
         L'-' != pwcsGuid[23] )
    {
        ciGibDebugOut(( DEB_WARN, "Improperly formatted guid %ws\n", pwcsGuid ));
        return FALSE;
    }

    //
    // Copy into local, editable, storage
    //

    WCHAR wcsGuid[ccStringizedGuid + 1];

    RtlCopyMemory( wcsGuid, pwcsGuid, (ccStringizedGuid + 1) * sizeof(WCHAR) );
    wcsGuid[ccStringizedGuid] = 0;

    wcsGuid[8] = 0;
    WCHAR * pwcStart = &wcsGuid[0];
    WCHAR * pwcEnd;
    guid.Data1 = wcstoul( pwcStart, &pwcEnd, 16 );
    if ( (pwcEnd-pwcStart) != 8 )   // The 1st number MUST be 8 digits long
        return FALSE;

    wcsGuid[13] = 0;
    pwcStart = &wcsGuid[9];
    guid.Data2 = (USHORT)wcstoul( pwcStart, &pwcEnd, 16 );
    if ( (pwcEnd-pwcStart) != 4 ) //  The 2nd number MUST be 4 digits long
        return FALSE;

    wcsGuid[18] = 0;
    pwcStart = &wcsGuid[14];
    guid.Data3 = (USHORT)wcstoul( pwcStart, &pwcEnd, 16 );
    if ( (pwcEnd-pwcStart) != 4 ) //  The 3rd number MUST be 4 digits long
        return FALSE;

    WCHAR wc = wcsGuid[21];
    wcsGuid[21] = 0;
    pwcStart = &wcsGuid[19];
    guid.Data4[0] = (unsigned char)wcstoul( pwcStart, &pwcEnd, 16 );
    if ( (pwcEnd-pwcStart) != 2 ) //  The 4th number MUST be 4 digits long
        return FALSE;
    wcsGuid[21] = wc;

    wcsGuid[23] = 0;
    pwcStart = &wcsGuid[21];
    guid.Data4[1] = (unsigned char)wcstoul( pwcStart, &pwcEnd, 16 );
    if ( (pwcEnd-pwcStart) != 2 ) //  The 4th number MUST be 4 digits long
        return FALSE;

    for ( unsigned i = 0; i < 6; i++ )
    {
        wc = wcsGuid[26+i*2];
        wcsGuid[26+i*2] = 0;
        pwcStart = &wcsGuid[24+i*2];
        guid.Data4[2+i] = (unsigned char)wcstoul( pwcStart, &pwcEnd, 16 );
        if ( pwcStart == pwcEnd )
            return FALSE;

        wcsGuid[26+i*2] = wc;
    }

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Function:   CheckAdminSecurity, public
//
//  Synopsis:   Checks to see if the client has administrative access.
//
//  Arguments:  [pwszMachine] - machine name
//
//  Returns:    Nothing, throws if access is denied.
//
//  Notes:      The ACL on the HKEY_CURRENT_MACHINE\system\CurrentControlSet\
//              Control\ContentIndex registry key is used to determine if
//              access is permitted.
//
//              The access check is only done when the administrative operation
//              is local.  Otherwise, it will be checked in the course of doing
//              the administrative operation.
//
//  History:    26 Jun 96   AlanW       Created.
//
//----------------------------------------------------------------------------

void CheckAdminSecurity( WCHAR const * pwszMachine )
{
    HKEY hNewKey = (HKEY) INVALID_HANDLE_VALUE;

    if ( 0 != wcscmp( pwszMachine, CATURL_LOCAL_MACHINE ) )
        return;

    LONG dwError = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                                 wcsRegAdminSubKey,
                                 0,
                                 KEY_WRITE,
                                 &hNewKey );

    if ( ERROR_SUCCESS == dwError )
    {
        RegCloseKey( hNewKey );
    }
    else if ( ERROR_ACCESS_DENIED == dwError )
    {
        THROW(CException( STATUS_ACCESS_DENIED ) );
    }
    else
    {
        ciGibDebugOut(( DEB_ERROR,
                        "Can not open reg key %ws, error %d\n",
                        wcsRegAdminSubKey, dwError ));
        THROW(CException( HRESULT_FROM_WIN32( dwError ) ) );
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\web\dll\outfmt.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1997, Microsoft Corporation.
//
//  File:       OutFmt.cxx
//
//  Contents:   COutputFormat
//
//  History:    11-Jun-97   KyleP       Moved from WQIter.cxx
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

static WCHAR * wcsDefaultBoolVectorPrefix        = L" ";
static WCHAR * wcsDefaultBoolVectorSeparator     = L" ";
static WCHAR * wcsDefaultBoolVectorSuffix        = L" ";
static WCHAR * wcsDefaultCurrencyVectorPrefix    = L" ";
static WCHAR * wcsDefaultCurrencyVectorSeparator = L" ";
static WCHAR * wcsDefaultCurrencyVectorSuffix    = L" ";
static WCHAR * wcsDefaultDateVectorPrefix        = L" ";
static WCHAR * wcsDefaultDateVectorSeparator     = L" ";
static WCHAR * wcsDefaultDateVectorSuffix        = L" ";
static WCHAR * wcsDefaultNumberVectorPrefix      = L" ";
static WCHAR * wcsDefaultNumberVectorSeparator   = L" ";
static WCHAR * wcsDefaultNumberVectorSuffix      = L" ";
static WCHAR * wcsDefaultStringVectorPrefix      = L" ";
static WCHAR * wcsDefaultStringVectorSeparator   = L" ";
static WCHAR * wcsDefaultStringVectorSuffix      = L" ";

//+---------------------------------------------------------------------------
//
//  Function:   COutputFormat::COutputFormat - public
//
//  Arguments:  [webServer] - makes a copy of the web server to resolve CGI
//                            variables
//
//  Synopsis:   Constructor
//
//  History:    96-Jan-18   DwightKr    Created
//              96-Feb-26   DwightKr    Added vector formatting
//
//----------------------------------------------------------------------------

COutputFormat::COutputFormat( CWebServer & webServer )
        : CWebServer( webServer ),
          _wcsBoolVectorPrefix( wcsDefaultBoolVectorPrefix ),
          _wcsBoolVectorSeparator( wcsDefaultBoolVectorSeparator ),
          _wcsBoolVectorSuffix( wcsDefaultBoolVectorSuffix ),
          _wcsCurrencyVectorPrefix( wcsDefaultCurrencyVectorPrefix ),
          _wcsCurrencyVectorSeparator( wcsDefaultCurrencyVectorSeparator ),
          _wcsCurrencyVectorSuffix( wcsDefaultCurrencyVectorSuffix ),
          _wcsDateVectorPrefix( wcsDefaultDateVectorPrefix ),
          _wcsDateVectorSeparator( wcsDefaultDateVectorSeparator ),
          _wcsDateVectorSuffix( wcsDefaultDateVectorSuffix ),
          _wcsNumberVectorPrefix( wcsDefaultNumberVectorPrefix ),
          _wcsNumberVectorSeparator( wcsDefaultNumberVectorSeparator ),
          _wcsNumberVectorSuffix( wcsDefaultNumberVectorSuffix ),
          _wcsStringVectorPrefix( wcsDefaultStringVectorPrefix ),
          _wcsStringVectorSeparator( wcsDefaultStringVectorSeparator ),
          _wcsStringVectorSuffix( wcsDefaultStringVectorSuffix )
{
    _numberFormat.lpDecimalSep  = 0;
    _numberFormat.lpThousandSep = 0;

    _currencyFormat.lpDecimalSep     = 0;
    _currencyFormat.lpThousandSep    = 0;
    _currencyFormat.lpCurrencySymbol = 0;
}


//+---------------------------------------------------------------------------
//
//  Function:   COutputFormat::GetIntegerFormat - private
//
//  Synopsis:   Formats a number and returns results in the string
//              buffer supplied.
//
//  Arguments:  [wcsInput]  - string to convert
//              [wcsNumber] - output location for results
//              [_cwcNumber] - length of output buffer in WCHARs
//
//  Returns:    The number of characters in the final string, less the NULL
//              terminator.
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
int COutputFormat::GetIntegerFormat( WCHAR * const wcsInput,
                                     WCHAR * wcsNumber,
                                     ULONG cwcNumber )
{
    Win4Assert( 0 != _numberFormat.lpDecimalSep );
    Win4Assert( 0 != _numberFormat.lpThousandSep );
    Win4Assert( InvalidLCID != GetLCID() );

    ULONG numDigits = _numberFormat.NumDigits;
    _numberFormat.NumDigits = 0;

    int cwcResult = ::GetNumberFormat( GetLCID(),
                                       0,
                                       wcsInput,
                                      &_numberFormat,
                                       wcsNumber,
                                       cwcNumber );

    _numberFormat.NumDigits = numDigits;

    if ( 0 == cwcResult )
    {
        THROW( CException() );
    }

    return cwcResult - 1;
}


//+---------------------------------------------------------------------------
//
//  Function:   COutputFormat::FormatNumber - public
//
//  Synopsis:   Formats a unsigned number and returns results in the string
//              buffer supplied.
//
//  Arguments:  [ulNumber]  - number to convert
//              [wcsNumber] - output location for results
//              [cwcNumber] - length of output buffer in WCHARs
//
//  Returns:    The number of characters in the final string, less the NULL
//              terminator.
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
int COutputFormat::FormatNumber( ULONG ulNumber,
                                 WCHAR * wcsNumber,
                                 ULONG cwcNumber )
{
    WCHAR wcsBuffer[40];
    IDQ_ultow( ulNumber, wcsBuffer );

    return GetIntegerFormat( wcsBuffer, wcsNumber, cwcNumber );
}


//+---------------------------------------------------------------------------
//
//  Function:   COutputFormat::FormatNumber
//
//  Synopsis:   Formats a signed number and returns results in the string
//              buffer supplied.
//
//  Arguments:  [lNumber]   - number to convert
//              [wcsNumber] - output location for results
//              [cwcNumber] - length of output buffer in WCHARs
//
//  Returns:    The number of characters in the final string, less the NULL
//              terminator.
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
int COutputFormat::FormatNumber( LONG lNumber,
                                 WCHAR * wcsNumber,
                                 ULONG cwcNumber )
{
    WCHAR wcsBuffer[40];
    IDQ_ltow( lNumber, wcsBuffer );

    return GetIntegerFormat( wcsBuffer, wcsNumber, cwcNumber );
}


//+---------------------------------------------------------------------------
//
//  Function:   COutputFormat::FormatNumber
//
//  Synopsis:   Formats a _int64 and returns results in the string
//              buffer supplied.
//
//  Arguments:  [i64Number] - number to convert
//              [wcsNumber] - output location for results
//              [cwcNumber] - length of output buffer in WCHARs
//
//  Returns:    The number of characters in the final string, less the NULL
//              terminator.
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
int COutputFormat::FormatNumber( _int64 i64Number,
                                 WCHAR * wcsNumber,
                                 ULONG cwcNumber )
{
    WCHAR wcsBuffer[40];
    IDQ_lltow( i64Number, wcsBuffer );

    return GetIntegerFormat( wcsBuffer, wcsNumber, cwcNumber );
}


//+---------------------------------------------------------------------------
//
//  Function:   COutputFormat::FormatNumber
//
//  Synopsis:   Formats a unsigned _int64 and returns results in the string
//              buffer supplied.
//
//  Arguments:  [ui64Number] - number to convert
//              [wcsNumber]  - output location for results
//              [cwcNumber]  - length of output buffer in WCHARs
//
//  Returns:    The number of characters in the final string, less the NULL
//              terminator.
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
int COutputFormat::FormatNumber( unsigned _int64 ui64Number,
                                 WCHAR * wcsNumber,
                                 ULONG cwcNumber )
{
    WCHAR wcsBuffer[40];
    IDQ_ulltow( ui64Number, wcsBuffer );

    return GetIntegerFormat( wcsBuffer, wcsNumber, cwcNumber );
}


//+---------------------------------------------------------------------------
//
//  Method:     COutputFormat::FormatFloatRaw, public
//
//  Synopsis:   Formats a floating point number and returns results in the
//              string buffer supplied.
//
//  Arguments:  [flt]        - number to be formatted
//              [cchPrec]    - number of digits of precision to use
//              [pwszNumber] - output location for results
//              [cchNumber]  - length of output buffer in WCHARs
//
//  Returns:    The number of characters in the final string, less the NULL
//              terminator.
//
//  Notes:      GetNumberFormat isn't really very useful for numbers with
//              very large or small magnitudes.  It gives up when there are
//              about 100 digits to the left of the decimal place.
//
//  History:    96-Jan-18   DwightKr    Created
//              96-May-22   DwightKr    Increased buffer size
//              97-Mar-12   AlanW       Changed signature to better handle
//                                      single-precision floating point
//
//----------------------------------------------------------------------------

int COutputFormat::FormatFloatRaw( double flt,
                                   unsigned cchPrec,
                                   WCHAR * pwszNumber,
                                   ULONG cchNumber )
{
    int  iDec, fSign;
    char * pszCvt = _ecvt( flt, cchPrec, &iDec, &fSign );

    WCHAR *pwsz = pwszNumber;

    if (fSign)
        *pwsz++ = L'-';

    if (iDec <= 0)
    {
        *pwsz++ = L'.';
        while (iDec < 0)
        {
            *pwsz++ = L'0';
            iDec++;
        }
    }

    for (unsigned i=0; i< cchPrec; i++)
    {
        *pwsz++ = *pszCvt++;

        if (iDec && --iDec == 0)
            *pwsz++ = L'.';
    }

    while (iDec > 0)
    {
        *pwsz++ = L'0';
        iDec--;
    }
    *pwsz = L'\0';

    int cchResult = (int)(pwsz - pwszNumber);
    Win4Assert ((unsigned)cchResult < cchNumber);

    if ((unsigned)cchResult >= cchNumber)
    {
        ciGibDebugOut((DEB_WARN, "FormatFloatRaw - string buffer overflow!\n"));
        cchResult = -1;
    }

    return cchResult;
} //FormatFloatRaw

//+---------------------------------------------------------------------------
//
//  Method:     COutputFormat::FormatFloat, public
//
//  Synopsis:   Formats a floating point number and returns results in the
//              string buffer supplied.
//
//  Arguments:  [flt]        - number to be formatted
//              [cchPrec]    - number of digits of precision to use
//              [pwszNumber] - output location for results
//              [cchNumber]  - length of output buffer in WCHARs
//
//  Returns:    The number of characters in the final string, less the NULL
//              terminator.
//
//  Notes:      GetNumberFormat isn't really very useful for numbers with
//              very large or small magnitudes.  It gives up when there are
//              about 100 digits to the left of the decimal place.
//
//  History:    96-Jan-18   DwightKr    Created
//              96-May-22   DwightKr    Increased buffer size
//              97-Mar-12   AlanW       Changed signature to better handle
//                                      single-precision floating point
//
//----------------------------------------------------------------------------

int COutputFormat::FormatFloat( double flt,
                                unsigned cchPrec,
                                WCHAR * pwszNumber,
                                ULONG cchNumber )
{
    Win4Assert( 0 != _numberFormat.lpDecimalSep );
    Win4Assert( 0 != _numberFormat.lpThousandSep );
    Win4Assert( InvalidLCID != GetLCID() );

    WCHAR pwszInput[-DBL_MIN_10_EXP + DBL_DIG + 4];
    WCHAR *pwsz = pwszInput;

    int cch = FormatFloatRaw( flt,
                              cchPrec,
                              pwszInput,
                              sizeof pwszInput / sizeof pwszInput[0]);

    Win4Assert( cch > 0 );

    int cchResult = ::GetNumberFormat( GetLCID(),
                                       0,
                                       pwszInput,
                                       &_numberFormat,
                                       pwszNumber,
                                       cchNumber );

    if ( 0 == cchResult )
    {
        ciGibDebugOut(( DEB_WARN, "FormatFloat - GetNumberFormat failed, error = %d\n", GetLastError() ));
        THROW( CException() );
    }

    return cchResult - 1;
} //FormatFloat

//+---------------------------------------------------------------------------
//
//  Function:   COutputFormat::FormatDate
//
//  Synopsis:   Formats a SYSTEMTIME and returns results in the string
//              buffer supplied.
//
//  Arguments:  [sysTime] - date to convert
//              [wcsDate] - output location for results
//              [cwcDate] - length of output buffer in WCHARs
//
//  Returns:    The number of characters in the final string, less the NULL
//              terminator.
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------

int COutputFormat::FormatDate(
    SYSTEMTIME & sysTime,
    WCHAR *      wcsDate,
    ULONG        cwcDate )
{
    *wcsDate = 0;
    Win4Assert( InvalidLCID != GetLCID() );

    ULONG ulMethod = TheIDQRegParams.GetDateTimeFormatting();

    // Fixed, non-localized formatting

    if ( IS_DATETIME_FORMATTING_FAST_LCID == ulMethod )
    {
        if ( cwcDate < 10 )
            return 0;

        wsprintf( wcsDate, L"%4d/%02d/%02d",
                  (DWORD) sysTime.wYear,
                  (DWORD) sysTime.wMonth,
                  (DWORD) sysTime.wDay );
        return 10;
    }

    // Format the date using the locale provided.
    
    ULONG ulFlags = DATE_SHORTDATE;

    if ( IS_DATETIME_FORMATTING_SYSTEM_LCID == ulMethod )
        ulFlags |= LOCALE_NOUSEROVERRIDE;

    ULONG cwcUsed = GetDateFormat( GetLCID(),
                                   ulFlags,
                                   &sysTime,
                                   0,
                                   wcsDate,
                                   cwcDate );
    
    if ( 0 != cwcUsed )
    {
        Win4Assert( 0 == wcsDate[cwcUsed - 1] );
    
        // cwcUsed includes the null termination -- remove it.
    
        return cwcUsed - 1;
    }
    
    #if DBG == 1
    
        ULONG error = GetLastError();
    
        ciGibDebugOut(( DEB_ERROR,
                        "GetDateFormat failed: 0x%x\n",
                        error ));
    
        // ERROR_INVALID_PARAMETER indicates that the date is
        // bogus -- perhaps because the file was deleted.
    
        if ( ERROR_INVALID_PARAMETER != error )
            Win4Assert( !"GetTimeFormat failed" );
    
    #endif // DBG == 1
    
    return 0;
} //FormatDate

//+---------------------------------------------------------------------------
//
//  Function:   COutputFormat::FormatTime
//
//  Synopsis:   Formats a SYSTEMTIME and returns results in the string
//              buffer supplied.
//
//  Arguments:  [sysTime] - date to convert
//              [wcsTime] - output location for results
//              [cwcTime] - length of output buffer in WCHARs
//
//  Returns:    The number of characters in the final string, less the NULL
//              terminator.
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------

int COutputFormat::FormatTime(
    SYSTEMTIME & sysTime,
    WCHAR *      wcsTime,
    ULONG        cwcTime )
{
    *wcsTime = 0;
    Win4Assert( InvalidLCID != GetLCID() );

    ULONG ulMethod = TheIDQRegParams.GetDateTimeFormatting();

    // Fixed, non-localized formatting

    if ( IS_DATETIME_FORMATTING_FAST_LCID == ulMethod )
    {
        if ( cwcTime < 8 )
            return 0;

        wsprintf( wcsTime, L"%2d:%02d:%02d",
                  (DWORD) sysTime.wHour,
                  (DWORD) sysTime.wMinute,
                  (DWORD) sysTime.wSecond );
        return 8;
    }
    
    // Format the time using the locale provided.

    ULONG ulFlags = ( IS_DATETIME_FORMATTING_USER_LCID == ulMethod ) ?
                    0 : LOCALE_NOUSEROVERRIDE;

    ULONG cwcUsed = GetTimeFormat( GetLCID(),
                                   ulFlags,
                                   &sysTime,
                                   0,
                                   wcsTime,
                                   cwcTime );

    if ( 0 != cwcUsed )
    {
        Win4Assert( 0 == wcsTime[cwcUsed - 1] );

        // cwcUsed includes the null termination -- remove it.

        return cwcUsed - 1;
    }

    #if DBG == 1

        ULONG error = GetLastError();

        ciGibDebugOut(( DEB_ERROR,
                        "GetTimeFormat failed: 0x%x\n",
                        error ));

        // ERROR_INVALID_PARAMETER indicates that the date is
        // bogus -- perhaps because the file was deleted.

        if ( ERROR_INVALID_PARAMETER != error )
            Win4Assert( !"GetTimeFormat failed" );

    #endif // DBG == 1

    return 0;
} //FormatTime

//+---------------------------------------------------------------------------
//
//  Function:   COutputFormat::FormatDateTime
//
//  Synopsis:   Formats a SYSTEMTIME and returns results in the string
//              buffer supplied.
//
//  Arguments:  [sysTime] - date to convert
//              [wcsDate] - output location for results
//              [cwcDate] - length of output buffer in WCHARs
//
//  Returns:    The number of characters in the final string, less the NULL
//              terminator.
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------

int COutputFormat::FormatDateTime( SYSTEMTIME & SysTime,
                                   WCHAR * wcsDate,
                                   ULONG cwcDate )
{
    //
    // Convert UTC/GMT to local system time if set in the registry
    //

    if ( TheIDQRegParams.GetDateTimeLocal() )
    {
        FILETIME ft, ftLocal;
        SystemTimeToFileTime( &SysTime, &ft );
        FileTimeToLocalFileTime( &ft, &ftLocal );
        FileTimeToSystemTime( &ftLocal, &SysTime );
    }

    int cwcDateBuffer = FormatDate( SysTime, wcsDate, cwcDate );

    wcsDate[cwcDateBuffer] = L' ';

    int cwcBuffer = max( 0, ( (int) (cwcDate - cwcDateBuffer ) ) - 2 );

    int cwcTimeBuffer = FormatTime( SysTime,
                                    wcsDate+cwcDateBuffer+1,
                                    cwcBuffer );

    return cwcTimeBuffer + cwcDateBuffer + 1;
} //FormatDateTime

//+---------------------------------------------------------------------------
//
//  Function:   COutputFormat::FormatCurrency
//
//  Synopsis:   Formats a CY and returns results in the string
//              buffer supplied.
//
//  Arguments:  [cyValue]     - number to convert
//              [wcsCurrency] - output location for results
//              [cwcCurrency] - length of output buffer in WCHARs
//
//  Returns:    The number of characters in the final string, less the NULL
//              terminator.
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
int COutputFormat::FormatCurrency( CY cyValue,
                                   WCHAR * wcsCurrency,
                                   ULONG cwcCurrency )
{
    Win4Assert( 0 != _numberFormat.lpDecimalSep );
    Win4Assert( 0 != _numberFormat.lpThousandSep );
    Win4Assert( 0 != _currencyFormat.lpDecimalSep );
    Win4Assert( 0 != _currencyFormat.lpThousandSep );
    Win4Assert( InvalidLCID != GetLCID() );

    WCHAR wcsBuffer[320];
    double dblValue;
    VarR8FromCy( cyValue, &dblValue );

    swprintf( wcsBuffer, L"%lf", dblValue );

    int cwcResult = ::GetCurrencyFormat( GetLCID(),
                                         0,
                                         wcsBuffer,
                                        &_currencyFormat,
                                         wcsCurrency,
                                         cwcCurrency );
    if ( 0 == cwcResult )
    {
        THROW( CException() );
    }

    return cwcResult - 1;
} //FormatCurrency

//+---------------------------------------------------------------------------
//
//  Function:   COutputFormat::LoadNumberFormatInfo - public
//
//  Synopsis:   Fills the numberFormat stucture with formatting information
//              used to subsequently format numbers.
//
//  History:    97-Jun-24   t-elainc    Created
//
//----------------------------------------------------------------------------

void COutputFormat::LoadNumberFormatInfo( LCID lcid )
{
    LoadNumberFormatInfo(lcid, LocaleToCodepage(lcid) );
}

//+---------------------------------------------------------------------------
//
//  Function:   ConvertGroupingStringToInt
//
//  Synopsis:   Converts a grouping string from the registry to an integer,
//              as required by the Win32 number formatting API
//
//  History:    5-Feb-99   dlee      Stole from the Win32 implementation
//
//----------------------------------------------------------------------------

int ConvertGroupingStringToInt( WCHAR const * pwcGrouping )
{
    XGrowable<WCHAR> xDest( 1 + wcslen( pwcGrouping ) );
    WCHAR * pDest = xDest.Get();

    //
    //  Filter out all non-numeric values and all zero values.
    //  Store the result in the destination buffer.
    //

    WCHAR const * pSrc  = pwcGrouping;

    while (0 != *pSrc)
    {
        if ( ( *pSrc < L'1' ) || ( *pSrc > L'9' ) )
        {
            pSrc++;
        }
        else
        {
            if (pSrc != pDest)
                *pDest = *pSrc;

            pSrc++;
            pDest++;
        }
    }

    //
    // Make sure there is something in the destination buffer.
    // Also, see if we need to add a zero in the case of 3;2 becomes 320.
    //

    if ( ( pDest == xDest.Get() ) || ( *(pSrc - 1) != L'0' ) )
    {
        *pDest = L'0';
        pDest++;
    }

    // Null terminate the buffer.

    *pDest = 0;

    // Convert the string to an integer.

    return _wtoi( xDest.Get() );
} //ConvertGroupingStringToInt

//+---------------------------------------------------------------------------
//
//  Function:   COutputFormat::LoadNumberFormatInfo - public
//
//  Synopsis:   Fills the numberFormat stucture with formatting information
//              used to subsequently format numbers.
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------

void COutputFormat::LoadNumberFormatInfo( LCID lcid , ULONG codepage)
{
    Win4Assert( InvalidLCID != lcid );

    //
    // If we're already loaded, then don't do it again.
    //

    if ( lcid == GetLCID() && 0 != _numberFormat.lpDecimalSep )
        return;

    delete _numberFormat.lpDecimalSep;
    delete _numberFormat.lpThousandSep;
    delete _currencyFormat.lpDecimalSep;
    delete _currencyFormat.lpThousandSep;

    _numberFormat.lpDecimalSep = 0;
    _numberFormat.lpThousandSep = 0;
    _currencyFormat.lpDecimalSep = 0;
    _currencyFormat.lpThousandSep = 0;

    Win4Assert( 0 == _numberFormat.lpDecimalSep );
    Win4Assert( 0 == _numberFormat.lpThousandSep );
    Win4Assert( 0 == _currencyFormat.lpDecimalSep );
    Win4Assert( 0 == _currencyFormat.lpThousandSep );

    SetLCID( lcid, 0, 0 );

    TheFormattingCache.GetFormattingInfo( lcid,
                                          _numberFormat,
                                          _currencyFormat );

    SetCodePage( codepage );

    ciGibDebugOut(( DEB_ITRACE, "Using a codePage of 0x%x for locale 0x%x\n",
                                 CodePage(),
                                 GetLCID() ));
} //LoadNumberFormatInfo


//+---------------------------------------------------------------------------
//
//  Method:     CFormatItem::CFormatItem, public
//
//  Synopsis:   Constructs formatting info.
//
//  Arguments:  [lcid]  -- The locale to use.
//
//  History:    99-Feb-10     dlee  Created
//
//----------------------------------------------------------------------------

CFormatItem::CFormatItem( LCID lcid ) : _lcid( lcid )
{
    WCHAR wcsBuffer[256];

    RtlZeroMemory( &_numberFormat, sizeof _numberFormat );
    RtlZeroMemory( &_currencyFormat, sizeof _currencyFormat );

    //  Get the number of decimal digits.
    GetLocaleInfo(lcid, LOCALE_IDIGITS, wcsBuffer, sizeof(wcsBuffer) / sizeof(WCHAR));
    _numberFormat.NumDigits = _wtoi(wcsBuffer);

    //  Get the leading zero in decimal fields option.
    GetLocaleInfo(lcid, LOCALE_ILZERO, wcsBuffer, sizeof(wcsBuffer) / sizeof(WCHAR));
    _numberFormat.LeadingZero = _wtoi(wcsBuffer);

    //  Get the negative ordering.
    GetLocaleInfo(lcid, LOCALE_INEGNUMBER, wcsBuffer, sizeof(wcsBuffer) / sizeof(WCHAR));
    _numberFormat.NegativeOrder = _wtoi(wcsBuffer);

    //  Get the grouping left of the decimal.
    GetLocaleInfo(lcid, LOCALE_SGROUPING, wcsBuffer, sizeof(wcsBuffer) / sizeof(WCHAR));
    _numberFormat.Grouping = ConvertGroupingStringToInt( wcsBuffer );
    ciGibDebugOut(( DEB_ITRACE, "grouping '%ws' -> %d\n",
                    wcsBuffer, _numberFormat.Grouping ));

    //  Get the decimal separator.
    GetLocaleInfo(lcid, LOCALE_SDECIMAL, wcsBuffer, sizeof(wcsBuffer) / sizeof(WCHAR));
    XPtrST<WCHAR> xNumDecimalSep( CopyString( wcsBuffer ) );
    _numberFormat.lpDecimalSep = xNumDecimalSep.GetPointer();

    //  Get the thousand separator.
    GetLocaleInfo(lcid, LOCALE_STHOUSAND, wcsBuffer, sizeof(wcsBuffer) / sizeof(WCHAR));
    XPtrST<WCHAR> xNumThousandSep( CopyString( wcsBuffer ) );
    _numberFormat.lpThousandSep = xNumThousandSep.GetPointer();

    //  Get the number of currency digits.
    GetLocaleInfo(lcid, LOCALE_ICURRDIGITS, wcsBuffer, sizeof(wcsBuffer) / sizeof(WCHAR));
    _currencyFormat.NumDigits = _wtoi(wcsBuffer);

    GetLocaleInfo(lcid, LOCALE_ILZERO, wcsBuffer, sizeof(wcsBuffer) / sizeof(WCHAR));
    //  Get the leading zero in currency fields option.
    _currencyFormat.LeadingZero = _wtoi(wcsBuffer);

    //  Get the currency grouping left of the decimal.
    GetLocaleInfo(lcid, LOCALE_SMONGROUPING, wcsBuffer, sizeof(wcsBuffer) / sizeof(WCHAR));
    _currencyFormat.Grouping = _wtoi(wcsBuffer);

    //  Get the currency decimal separator.
    GetLocaleInfo(lcid, LOCALE_SMONDECIMALSEP, wcsBuffer, sizeof(wcsBuffer) / sizeof(WCHAR));
    XPtrST<WCHAR> xCurDecimalSep( CopyString( wcsBuffer ) );
    _currencyFormat.lpDecimalSep = xCurDecimalSep.GetPointer();

    //  Get the currency thousand separator.
    GetLocaleInfo(lcid, LOCALE_SMONTHOUSANDSEP, wcsBuffer, sizeof(wcsBuffer) / sizeof(WCHAR));
    XPtrST<WCHAR> xCurThousandSep( CopyString( wcsBuffer ) );
    _currencyFormat.lpThousandSep = xCurThousandSep.GetPointer();

    //  Get the negative ordering.
    GetLocaleInfo(lcid, LOCALE_INEGCURR, wcsBuffer, sizeof(wcsBuffer) / sizeof(WCHAR));
    _currencyFormat.NegativeOrder = _wtoi(wcsBuffer);

    //  Get the positive ordering.
    GetLocaleInfo(lcid, LOCALE_ICURRENCY, wcsBuffer, sizeof(wcsBuffer) / sizeof(WCHAR));
    _currencyFormat.PositiveOrder = _wtoi(wcsBuffer);

    _currencyFormat.lpCurrencySymbol = L"";

    xNumDecimalSep.Acquire();
    xNumThousandSep.Acquire();
    xCurDecimalSep.Acquire();
    xCurThousandSep.Acquire();
} //CFormatItem

//+---------------------------------------------------------------------------
//
//  Method:     CFormatItem::~CFormatItem, public
//
//  Synopsis:   Frees formatting info.
//
//  History:    99-Feb-10     dlee  Created
//
//----------------------------------------------------------------------------

CFormatItem::~CFormatItem()
{
    delete _numberFormat.lpDecimalSep;
    delete _numberFormat.lpThousandSep;
    delete _currencyFormat.lpDecimalSep;
    delete _currencyFormat.lpThousandSep;
} //~CFormatItem

//+---------------------------------------------------------------------------
//
//  Method:     CFormatItem::Copy, public
//
//  Synopsis:   Copies formatting info into the arguments
//
//  Arguments:  [numberFormat]   -- Where the number format is copied to
//              [currencyFormat] -- Where the currency format is copied to
//
//  History:    99-Feb-10     dlee  Created
//
//----------------------------------------------------------------------------

void CFormatItem::Copy(
    NUMBERFMT &   numberFormat,
    CURRENCYFMT & currencyFormat ) const
{
    XPtrST<WCHAR> xNumDecimalSep( CopyString( _numberFormat.lpDecimalSep ) );
    XPtrST<WCHAR> xNumThousandSep( CopyString( _numberFormat.lpThousandSep ) );
    XPtrST<WCHAR> xCurDecimalSep( CopyString( _currencyFormat.lpDecimalSep ) );
    XPtrST<WCHAR> xCurThousandSep( CopyString( _currencyFormat.lpDecimalSep ) );

    RtlCopyMemory( &numberFormat, &_numberFormat, sizeof NUMBERFMT );
    RtlCopyMemory( &currencyFormat, &_currencyFormat, sizeof CURRENCYFMT );

    numberFormat.lpDecimalSep = xNumDecimalSep.Acquire();
    numberFormat.lpThousandSep = xNumThousandSep.Acquire();
    currencyFormat.lpDecimalSep = xCurDecimalSep.Acquire();
    currencyFormat.lpThousandSep = xCurThousandSep.Acquire();
} //Copy

//+---------------------------------------------------------------------------
//
//  Method:     CFormattingCache::GetFormattingInfo, public
//
//  Synopsis:   Copies formatting info for lcid into the arguments
//
//  Arguments:  [lcid]           -- Locale of info to lookup
//              [numberFormat]   -- Where the number format is copied to
//              [currencyFormat] -- Where the currency format is copied to
//
//  History:    99-Feb-10     dlee  Created
//
//----------------------------------------------------------------------------

void CFormattingCache::GetFormattingInfo(
    LCID          lcid,
    NUMBERFMT &   numberFormat,
    CURRENCYFMT & currencyFormat )
{
    CLock lock( _mutex );

    for ( unsigned i = 0; i < _aItems.Count(); i++ )
    {
        if ( _aItems[i]->GetLCID() == lcid )
        {
            _aItems[i]->Copy( numberFormat, currencyFormat );
            return;
        }
    }

    XPtr<CFormatItem> xItem( new CFormatItem( lcid ) );
    xItem->Copy( numberFormat, currencyFormat );
    _aItems.Add( xItem.GetPointer(), _aItems.Count() );
    xItem.Acquire();
} //GetFormattingInfo

//+---------------------------------------------------------------------------
//
//  Method:     CFormattingCache::Purge, public
//
//  Synopsis:   Purges the cache of all entries
//
//  History:    99-Feb-10     dlee  Created
//
//----------------------------------------------------------------------------

void CFormattingCache::Purge()
{
    CLock lock( _mutex );

    _aItems.Clear();
} //Purge
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\web\dll\main.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:       main.cxx
//
//  Contents:   External entry points for idq.dll.
//
//  History:    96/Jan/3    DwightKr    Created
//
//----------------------------------------------------------------------------


#include <pch.cxx>
#pragma hdrstop

#include <ntverp.h>

#define IDQ_VERSION    3

#define _DECL_DLLMAIN 1

CTheGlobalIDQVariables * pTheGlobalIDQVariables = 0;
DWORD                    g_cClients = 0;
CRITICAL_SECTION         g_csInitExclusive;

//+---------------------------------------------------------------------------
//
//  Function:   GetExtensionVersion - public
//
//  Synposis:   Returns extension info to the server.  This is called before
//              HttpExtensionProc is called, and it is called in System
//              context, so any initialization that requires this context
//              must be handled here.
//
//  Arguments:  [pVer]  - where the info goes
//
//  History:    96-Apr-15   dlee        Added header
//
//  Notes:      There may be multiple clients of this ISAPI app in one
//              process (eg W3Svc and NNTPSvc), so refcount the users.
//
//----------------------------------------------------------------------------

BOOL WINAPI GetExtensionVersion( HSE_VERSION_INFO * pVer )
{
    BOOL fSuccess = TRUE;

    EnterCriticalSection( &g_csInitExclusive );

    TRANSLATE_EXCEPTIONS;

    TRY
    {
        pVer->dwExtensionVersion = MAKELONG( 0, IDQ_VERSION );
        strcpy( pVer->lpszExtensionDesc, "Indexing Service extension" );

        if ( 0 == g_cClients )
        {
            Win4Assert( 0 == pTheGlobalIDQVariables );
            pTheGlobalIDQVariables = new CTheGlobalIDQVariables();
            LoadServerErrors();
        }

        g_cClients++;
    }
    CATCH( CException, e )
    {
        fSuccess = FALSE;

        ciGibDebugOut(( DEB_WARN, "GetExtensionVersion failed 0x%x\n",
                        e.GetErrorCode() ));
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    LeaveCriticalSection( &g_csInitExclusive );

    return fSuccess;
} //GetExtensionVersion

//+---------------------------------------------------------------------------
//
//  Function:   TerminateExtension, public
//
//  Synposis:   Called by IIS during shutdown

//  History:    29-Apr-96   KyleP       Created
//
//----------------------------------------------------------------------------

BOOL WINAPI TerminateExtension( DWORD dwFlags )
{
    EnterCriticalSection( &g_csInitExclusive );

    TRANSLATE_EXCEPTIONS;

    BOOL fOK = FALSE;

    if ( dwFlags & HSE_TERM_MUST_UNLOAD )
    {
        TRY
        {
            Win4Assert( 0 != g_cClients );
            g_cClients--;
            if ( 0 == g_cClients )
            {
                ciGibDebugOut(( DEB_WARN, "Mandatory extension unload. Shutting down CI.\n" ));

                TheWebQueryCache.Shutdown();
                TheWebPendingRequestQueue.Shutdown();

                //
                //  Wait for all ISAPI threads to exit before shutting down CI
                //
                while ( TheWebResourceArbiter.GetThreadCount() > 0 )
                {
                    ciGibDebugOut(( DEB_WARN, "TerminateExtension: waiting for ISAPI threads to complete\n" ));
                    Sleep( 50 );
                }

                ciGibDebugOut(( DEB_WARN,
                                "TerminatExtension, request count %d\n",
                                TheWebQueryCache.ActiveRequestCount() ));

                // note: don't call CIShutdown here.  There's no need
                // to, and it'll hose the impersonation token cache for
                // webhits.

                delete pTheGlobalIDQVariables;
                pTheGlobalIDQVariables = 0;
            }
        }
        CATCH( CException, e )
        {
            // ignore
        }
        END_CATCH

        fOK = TRUE;
    }

    ciGibDebugOut(( DEB_WARN, "Extension unload: 0x%x. Flags = 0x%x\n",
                    fOK, dwFlags ));

    UNTRANSLATE_EXCEPTIONS;

    LeaveCriticalSection( &g_csInitExclusive );

    return fOK;
} //TerminateExtension


//+---------------------------------------------------------------------------
//
//  Function:   CreateQueryFromRequest, private
//
//  Synposis:   Issues a query from a request.
//
//  Arguments:  [outputFormat]  -- returns the formatting info.
//              [localVars]     -- returns the local variables.
//              [wcsIDQFile]    -- returns the idq file name.
//              [webServer]     -- web server for the request.
//              [eErrorClass]   -- returns the error class
//              [status]        -- returns the error code
//              [fPending]      -- returns TRUE if the request is pending
//
//  History:    96-Apr-15   dlee        created from existing code
//
//----------------------------------------------------------------------------

#if (CIDBG == 0)
inline
#endif

CWQueryItem * CreateQueryFromRequest( XPtr<COutputFormat> & outputFormat,
                                      XPtr<CVariableSet> &  localVars,
                                      WCHAR *               wcsIDQFile,
                                      CWebServer &          webServer,
                                      int &                 eErrorClass,
                                      NTSTATUS &            status,
                                      BOOL &                fPending )
{
    //
    // NOTE: COutputFormat makes a **copy** of the web server.  This
    //       copy should be used exclusively from this point on. The
    //       original web server will still be used by callers of this
    //       routine in cases where we fail to create the copy.
    //

    outputFormat.Set( new COutputFormat( webServer ) );
    localVars.Set( new CVariableSet );

    CSecurityIdentity securityIdentity;
    XArray<WCHAR> xLocale;

    //
    // Update the original web server, in case we use it in a top-level
    // error path.
    //

    webServer = outputFormat.GetReference();
    LCID locale = GetBrowserLCID( outputFormat.GetReference() , xLocale );
    outputFormat->LoadNumberFormatInfo( locale, GetBrowserCodepage(outputFormat.GetReference(), locale) );
    localVars->AddExtensionControlBlock( outputFormat.GetReference() );

    ULONG cwc = MAX_PATH;
    BOOL fOK = outputFormat->GetCGI_PATH_TRANSLATED( wcsIDQFile, cwc );

    if ( !fOK )
    {
        wcsIDQFile[0] = 0;
        THROW( CIDQException( MSG_CI_IDQ_NOT_FOUND, 0 ) );
    }

    outputFormat->SetCodePage(outputFormat->CodePage());

    Win4Assert( fOK );

    if ( IsNetPath(wcsIDQFile) )
    {
        ciGibDebugOut(( DEB_ERROR, "Path for idq file (%ws) is a UNC name\n",
                        wcsIDQFile ));

        THROW( CIDQException(MSG_CI_SCRIPTS_ON_REMOTE_UNC, 0) );
    }

    CWQueryItem *pItem = 0;

    //
    // Check to see whether this is an .IDQ or .IDA file.
    //

    static WCHAR const wszAdmin[] = L".IDA";
    static unsigned const ccAdmin = sizeof(wszAdmin)/sizeof(wszAdmin[0]) - 1;

    if ( cwc > ccAdmin && 0 == _wcsicmp( wszAdmin, wcsIDQFile + cwc - ccAdmin - 1 ) )
    {
        CVirtualString IDAResults;

        DoAdmin( wcsIDQFile,
                 localVars.GetReference(),
                 outputFormat.GetReference(),
                 IDAResults );

        if ( outputFormat->WriteClient( IDAResults ) )
            outputFormat->SetHttpStatus( HTTP_STATUS_OK );
        else
        {
            eErrorClass = eWebServerWriteError;
            outputFormat->SetHttpStatus( HTTP_STATUS_SERVER_ERROR );
        }
    }
    else
    {
        //
        //  Atempt to find an existing query using this IDQ file, &
        //  sequence number, based on the bookmark received.
        //

        fPending = FALSE;
        pItem = TheWebQueryCache.CreateOrFindQuery( wcsIDQFile,
                                                    localVars,
                                                    outputFormat,
                                                    securityIdentity,
                                                    fPending );

        if ( fPending )
        {
            Win4Assert( 0 == pItem );
        }
        else
        {
            TRY
            {
                Win4Assert( !pItem->IsCanonicalOutput() );

                CVirtualString queryResults( 16384 );

                //
                //  Write the query results to a WCHAR string buffer
                //  Initial virtual string size is in WCHARs
                //
                pItem->OutputQueryResults( localVars.GetReference(),
                                           outputFormat.GetReference(),
                                           queryResults );

                //
                //  Send the query results to the browser
                //
                if ( outputFormat->WriteClient( queryResults ) )
                    outputFormat->SetHttpStatus( HTTP_STATUS_OK );
                else
                {
                    eErrorClass = eWebServerWriteError;
                    outputFormat->SetHttpStatus( HTTP_STATUS_SERVER_ERROR );
                }
            }
            CATCH( CException, e )
            {
                eErrorClass = eDefaultISAPIError;
                status = e.GetErrorCode();
            }
            END_CATCH
        }
    }

    return pItem;
} //CreateQueryFromRequest

//+---------------------------------------------------------------------------
//
//  Function:   ReportErrorNoThrow, public
//
//  Synposis:   Attempts to report an error condition and log the query
//
//  Arguments:  [localVars]     -- local variables.
//              [eErrorClass]   -- error class
//              [status]        -- status code of faulure
//              [ulErrorLine]   -- line # of the error
//              [wcsErrorFile]  -- file associated with error
//              [outputFormat]  -- formatting info.
//              [webServer]     -- web server for the request.
//
//  History:    96-Nov-25   dlee    created from existing code, added TRY
//
//----------------------------------------------------------------------------
void ReportErrorNoThrow(
    XPtr<CVariableSet> &  localVars,
    int                   eErrorClass,
    NTSTATUS              status,
    ULONG                 ulErrorLine,
    WCHAR const *         wcsErrorFile,
    XPtr<COutputFormat> & outputFormat,
    CWebServer &          webServer )
{
    TRY
    {
        WCHAR * wcsRestriction = 0;

        //
        //  Lookup the restriction, if one has been fully constructed.
        //
        if ( 0 != localVars.GetPointer() )
        {
            CVariable * pVarRestriction = localVars->Find(ISAPI_CI_RESTRICTION);

            if ( 0 != pVarRestriction )
            {
                ULONG cwcValue;
                wcsRestriction = pVarRestriction->GetStringValueRAW( outputFormat.GetReference(), cwcValue );
            }
        }

        //
        //  Attempt to write out the error picture, if appropriate
        //

        CVirtualString vString;

        GetErrorPageNoThrow( eErrorClass,
                             status,
                             ulErrorLine,
                             wcsErrorFile,
                             localVars.GetPointer(),
                             outputFormat.GetPointer(),
                             outputFormat.GetPointer() ? outputFormat->GetLCID() : 0,
                             webServer,
                             vString );

        ciGibDebugOut(( DEB_IWARN, "WARNING: %ws\n", vString.Get() ));
        webServer.WriteClient( vString );

        Win4Assert( webServer.GetHttpStatus() >= HTTP_STATUS_FIRST );

        //
        //  Log the restriction in the failed query.  It may not have
        //  been logged yet since we may have thrown before it was
        //  logged in the query execution path.
        //
        // if ( 0 != wcsRestriction )
        //     webServer.WriteLogData( wcsRestriction );
    }
    CATCH( CException, e )
    {
        // ignore -- not enough memory to output an error message
    }
    END_CATCH
} //ReportErrorNoThrow

//+---------------------------------------------------------------------------
//
//  Function:   ReportErrorNoThrow, public
//
//  Synposis:   Attempts to report an error condition and log the query
//
//  Arguments:  [localVars]        -- local variables.
//              [scError]          -- error code
//              [pwszErrorMessage] -- Description provided by Ole-DB error svc.
//              [outputFormat]     -- formatting info.
//              [webServer]        -- web server for the request.
//
//  History:    97-May-08   KrishnaN    created from existing ReportErrorNoThrow
//
//----------------------------------------------------------------------------
void ReportErrorNoThrow(
    XPtr<CVariableSet> &  localVars,
    int                   eErrorClass,
    SCODE                 scError,
    WCHAR const *         pwszErrorMessage,
    XPtr<COutputFormat> & outputFormat,
    CWebServer &          webServer )
{
    TRY
    {
        WCHAR * wcsRestriction = 0;

        //
        //  Lookup the restriction, if one has been fully constructed.
        //
        if ( 0 != localVars.GetPointer() )
        {
            CVariable * pVarRestriction = localVars->Find(ISAPI_CI_RESTRICTION);

            if ( 0 != pVarRestriction )
            {
                ULONG cwcValue;
                wcsRestriction = pVarRestriction->GetStringValueRAW( outputFormat.GetReference(), cwcValue );
            }
        }

        //
        //  Attempt to write out the error picture, if appropriate
        //

        CVirtualString vString;

        GetErrorPageNoThrow(eErrorClass,
                            scError,
                            pwszErrorMessage,
                            localVars.GetPointer(),
                            outputFormat.GetPointer(),
                            outputFormat.GetPointer() ? outputFormat->GetLCID() : 0,
                            webServer,
                            vString );

        ciGibDebugOut(( DEB_IWARN, "WARNING: %ws\n", vString.Get() ));
        webServer.WriteClient( vString );

        Win4Assert( webServer.GetHttpStatus() >= HTTP_STATUS_FIRST );

        //
        //  Log the restriction in the failed query.  It may not have
        //  been logged yet since we may have thrown before it was
        //  logged in the query execution path.
        //
        // if ( 0 != wcsRestriction )
        //     webServer.WriteLogData( wcsRestriction );
    }
    CATCH( CException, e )
    {
        // ignore -- not enough memory to output an error message
    }
    END_CATCH
} //ReportErrorNoThrow

//+---------------------------------------------------------------------------
//
//  Function:   ProcessWebRequest, public
//
//  Synposis:   Issues a query from a request.
//
//  Arguments:  [webServer]     -- web server for the request.
//
//  Returns:    The HSE_STATUS code.
//
//  History:    96-Apr-15   dlee        created from existing code
//              98-Sep-16   KLam        Checks for valid method
//
//----------------------------------------------------------------------------

DWORD ProcessWebRequest(
    CWebServer & webServer )
{
    Win4Assert( HTTP_STATUS_ACCEPTED == webServer.GetHttpStatus() );

    WCHAR wcsIDQFile[MAX_PATH];
    wcsIDQFile[0] = 0;
    CWQueryItem *pItem = 0;

    XPtr<COutputFormat> outputFormat;
    XPtr<CVariableSet> localVars;

    NTSTATUS status = STATUS_SUCCESS;   // Error code from query
    ULONG ulErrorLine;                  // Line # in IDQ file error occured
    int eErrorClass;                    // Type of error, IDQ, HTX, parse, ...
    WCHAR const * wcsErrorFile = 0;     // Name of file containing error

    BOOL fPending = FALSE;

    //
    // Set the following flag to TRUE if we encounter an error
    // whose description is already available.
    //

    BOOL fReportErrorWithDescription = FALSE;
    BSTR bstrErrorDescription = 0;

    // 
    // Make sure we have a valid method
    //
    if ( strcmp ( webServer.GetMethod(), "HEAD" ) == 0 )
    {
        //
        // Do not need to execute the query if the client only wants the head
        //
        if ( webServer.WriteHeader() )
            webServer.SetHttpStatus ( HTTP_STATUS_OK );
        else
        {
            eErrorClass = eWebServerWriteError;
            webServer.SetHttpStatus( HTTP_STATUS_SERVER_ERROR );
            return HSE_STATUS_ERROR;
        }

        return HSE_STATUS_SUCCESS;
    }
    // Only support GET and POST for queries
    else if ( strcmp( webServer.GetMethod(), "GET" ) != 0
              && strcmp ( webServer.GetMethod(), "POST" ) != 0 )
    {
        // HTTP 1.1 Spec determines value of header status string
        if ( webServer.WriteHeader( NULL, "501 Not Implemented" ) )
            webServer.SetHttpStatus ( HTTP_STATUS_NOT_SUPPORTED );
        else
        {
            eErrorClass = eWebServerWriteError;
            webServer.SetHttpStatus( HTTP_STATUS_SERVER_ERROR );
        }

        return HSE_STATUS_ERROR;
    }
    else
    {
        TRY
        {
            pItem = CreateQueryFromRequest( outputFormat,
                                            localVars,
                                            wcsIDQFile,
                                            webServer,
                                            eErrorClass,
                                            status,
                                            fPending );
        }
        CATCH( CPListException, e )
        {
            status = e.GetPListError();
            ulErrorLine = e.GetLine();
            eErrorClass = eIDQPlistError;
            wcsErrorFile = wcsIDQFile;
            Win4Assert( STATUS_SUCCESS != status );
        }
        AND_CATCH( CIDQException, e )
        {
            status = e.GetErrorCode();
            ulErrorLine = e.GetErrorIndex();
            eErrorClass = eIDQParseError;
            wcsErrorFile = wcsIDQFile;
            Win4Assert( STATUS_SUCCESS != status );
        }
        AND_CATCH( CHTXException, e )
        {
            status = e.GetErrorCode();
            ulErrorLine = e.GetErrorIndex();
            eErrorClass = eHTXParseError;
            wcsErrorFile = e.GetHTXFileName();
 
            //
            // copy the error file name; it's stored on the stack below
            // this function.
            //
            ULONG cchFileName = min( wcslen(wcsErrorFile) + 1, MAX_PATH );
            Win4Assert(cchFileName < MAX_PATH);

            RtlCopyMemory( wcsIDQFile,
                           wcsErrorFile,
                           sizeof(WCHAR) * cchFileName );

            wcsIDQFile[MAX_PATH-1] = 0;
            wcsErrorFile = wcsIDQFile;
            Win4Assert( STATUS_SUCCESS != status );
        }
        AND_CATCH( CParserException, e )
        {
            status = e.GetParseError();
            ulErrorLine = 0;
            eErrorClass = eRestrictionParseError;
            wcsErrorFile = wcsIDQFile;
            Win4Assert( STATUS_SUCCESS != status );
        }
        AND_CATCH( CPostedOleDBException, e )
        {
            //
            // When the execution error was detected, the Ole DB error
            // info was retrieved and stored in the exception object.
            // We retrieve that here and compose the error message.
            //

            status = e.GetErrorCode();
            eErrorClass = e.GetErrorClass();
            Win4Assert( STATUS_SUCCESS != status );

            XInterface <IErrorInfo> xErrorInfo(e.AcquireErrorInfo());

            if (xErrorInfo.GetPointer())
                xErrorInfo->GetDescription(&bstrErrorDescription);
            if (bstrErrorDescription)
                fReportErrorWithDescription = TRUE;
            else
            {
                // NO description. Follow the normal path.
                ulErrorLine = 0;
                wcsErrorFile = wcsIDQFile;
            }
        }
        AND_CATCH( CException, e )
        {
            status = e.GetErrorCode();
            ulErrorLine = 0;
            eErrorClass = eDefaultISAPIError;
            wcsErrorFile = wcsIDQFile;
            Win4Assert( STATUS_SUCCESS != status );
        }
        END_CATCH
    }

    TRY
    {
        if ( STATUS_SUCCESS != status )
        {
            fPending = FALSE;

            // the request failed, but we're returning an error message,
            // so indicate that everything is ok.

            webServer.SetHttpStatus( HTTP_STATUS_OK );

            if (fReportErrorWithDescription)
            {
                Win4Assert(bstrErrorDescription);
                ReportErrorNoThrow(localVars,
                                   eErrorClass,
                                   status,
                                   (WCHAR const *)bstrErrorDescription,
                                   outputFormat,
                                   webServer );
                SysFreeString(bstrErrorDescription);
            }
            else
            {
                Win4Assert(0 == bstrErrorDescription);
                ReportErrorNoThrow( localVars,
                                    eErrorClass,
                                    status,
                                    ulErrorLine,
                                    wcsErrorFile,
                                    outputFormat,
                                    webServer );
            }

            if ( 0 != pItem )
                pItem->Zombify();
        }

        TheWebQueryCache.Release( pItem );
    }
    CATCH( CException, e )
    {
        ciGibDebugOut(( DEB_ERROR, "ProcessWebRequest Error 0x%X\n", e.GetErrorCode() ));
        Win4Assert( e.GetErrorCode() != STATUS_ACCESS_VIOLATION );
    }
    END_CATCH

    #if CIDBG == 1

        //
        // If fPending is TRUE, the http status of the ecb can't be trusted,
        // because the request may have asynchronously completed by now:
        //

        if ( !fPending )
        {
            DWORD dwHttpStatus = webServer.GetHttpStatus();

            Win4Assert( HTTP_STATUS_ACCEPTED != dwHttpStatus );
            Win4Assert( HTTP_STATUS_OK == dwHttpStatus ||
                        HTTP_STATUS_SERVER_ERROR == dwHttpStatus ||
                        HTTP_STATUS_DENIED == dwHttpStatus ||
                        HTTP_STATUS_SERVICE_UNAVAIL == dwHttpStatus );
        }

    #endif // CIDBG == 1

    if ( fPending )
        return HSE_STATUS_PENDING;

    return HSE_STATUS_SUCCESS;
} //ProcessWebRequest

//+---------------------------------------------------------------------------
//
//  Function:   HttpExtensionProc, public
//
//  Synposis:   Handles a request from the web server
//
//  Arguments:  [pEcb]          -- block from the server
//
//  History:    96-Apr-15   dlee        created header
//
//----------------------------------------------------------------------------

DWORD WINAPI HttpExtensionProc( EXTENSION_CONTROL_BLOCK *pEcb )
{
    if ( 0 == pTheGlobalIDQVariables || fTheActiveXSearchShutdown )
    {
        ciGibDebugOut(( DEB_GIB_REQUEST,
                        "Indexing Service being shutdown\n" ));
        pEcb->dwHttpStatusCode = HTTP_STATUS_SERVICE_UNAVAIL;
        return HSE_STATUS_ERROR;
    }

    CIncomingThread incoming( TheWebResourceArbiter );

    TheWebQueryCache.IncrementActiveRequests();

    CWebServer webServer( pEcb );
    DWORD  hseStatus = HSE_STATUS_ERROR;
    webServer.SetHttpStatus( HTTP_STATUS_ACCEPTED );

    TRANSLATE_EXCEPTIONS;

    TRY
    {
        if ( TheWebResourceArbiter.IsSystemBusy() )
        {
            if ( TheWebQueryCache.AddToPendingRequestQueue( pEcb ) )
            {
                ciGibDebugOut(( DEB_GIB_REQUEST, "Server busy, queueing request\n" ));
                hseStatus = HSE_STATUS_PENDING;

                TheWebQueryCache.Wakeup();
                TheWebQueryCache.UpdatePendingRequestCount();
            }
            else
            {
                TheWebQueryCache.IncrementRejectedRequests();
                ciGibDebugOut(( DEB_GIB_REQUEST,
                                "Server too busy, failing request!!!\n" ));
                ReturnServerError( HTTP_STATUS_SERVICE_UNAVAIL, webServer );
                hseStatus = HSE_STATUS_SUCCESS;
            }
        }
        else
        {
            ciGibDebugOut(( DEB_GIB_REQUEST, "Server not busy, processing request\n" ));
            hseStatus = ProcessWebRequest( webServer );
        }
    }
    CATCH( CException, e )
    {
        hseStatus = HSE_STATUS_ERROR;
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    if ( HSE_STATUS_PENDING != hseStatus )
    {
        TheWebQueryCache.DecrementActiveRequests();

        ciGibDebugOut(( DEB_GIB_REQUEST,
                        "Falling out of isapi proc, active: %d\n",
                        TheWebQueryCache.ActiveRequestCount() ));

        Win4Assert( webServer.GetHttpStatus() >= HTTP_STATUS_FIRST &&
                    webServer.GetHttpStatus() <= HTTP_STATUS_LAST );

        if ( ( webServer.GetHttpStatus() < HTTP_STATUS_FIRST ) ||
             ( webServer.GetHttpStatus() > HTTP_STATUS_LAST ) )
        {
            ciGibDebugOut(( DEB_WARN,
                            "non-pending hse %d ECB %08x status invalid: %d\n",
                            hseStatus,
                            pEcb,
                            webServer.GetHttpStatus() ));
            webServer.SetHttpStatus( HTTP_STATUS_SERVER_ERROR );
        }
    }
    else
    {
        //
        // The pending request may have asynchronously completed by now,
        // so nothing can be asserted about the http status except that it
        // is a valid http status code, which retrieving the status does.
        //

        #if CIDBG == 1
            webServer.GetHttpStatus();
        #endif
    }

    ciGibDebugOut(( DEB_ITRACE, "httpExtensionProc: hse %d, http %d\n",
                    hseStatus, webServer.GetHttpStatus() ));

    return hseStatus;
} //HttpExtensionProc

//+---------------------------------------------------------------------------
//
//  Method:     CWebPendingQueue::CWebPendingQueue, public
//
//  Synposis:   Constructs the pending request queue
//
//  History:    96-Apr-15   dlee        created
//
//----------------------------------------------------------------------------

CWebPendingQueue::CWebPendingQueue()
    :  TFifoCircularQueue<CWebPendingItem>
           ( TheIDQRegParams.GetISRequestQueueSize() ),
     _ulSignature( LONGSIG( 'p', 'e', 'n', 'd' ) )
{
} //CWebPendingQueue

//+---------------------------------------------------------------------------
//
//  Method:     CWebResourceArbiter::CWebResourceArbiter, public
//
//  Synposis:   Constructs the web resource arbiter
//
//  History:    96-Apr-15   dlee        created
//
//----------------------------------------------------------------------------

CWebResourceArbiter::CWebResourceArbiter() :
    _ulSignature( LONGSIG( 'a', 'r', 'b', 'i' ) ),
    _cThreads( 0 )
{
    ULONG factor = TheIDQRegParams.GetISRequestThresholdFactor();

    Win4Assert( 0 != factor );

    SYSTEM_INFO si;
    GetSystemInfo( &si );

    _maxThreads = si.dwNumberOfProcessors * factor;

    Win4Assert( _maxThreads >= (LONG) factor );

    _maxPendingQueries = TheIDQRegParams.GetMaxActiveQueryThreads() *
                         factor;
} //CWebResourceArbiter

//+---------------------------------------------------------------------------
//
//  Method:     CWebResourceArbiter::IsSystemBusy, public
//
//  Synposis:   Determines if the system is too busy to process a request.
//
//  Returns:    TRUE if the request should be queued or rejected, FALSE
//              if the system is free enough to handle it.
//
//  History:    96-Apr-15   dlee        created
//
//----------------------------------------------------------------------------

BOOL CWebResourceArbiter::IsSystemBusy()
{
    return ( _cThreads > _maxThreads ) ||
           ( TheWebQueryCache.PendingQueryCount() >= _maxPendingQueries );
} //IsSystemBusy

//+---------------------------------------------------------------------------
//
//  Function:   DllMain
//
//  Synopsis:   Called from C-Runtime on process/thread attach/detach
//
//  Arguments:  [hInstance]  -- Module handle
//              [dwReason]   -- Reason for being called
//              [lpReserved] --
//
//  History:    23-Apr-97   dlee       Created
//
//----------------------------------------------------------------------------

#if CIDBG == 1
#define VER_CIDEBUG "chk"
#else // CIDBG == 1
#define VER_CIDEBUG "fre"
#endif // CIDBG == 1

#if IDQ_VERSION == 3
#define VER_PROJECT "query"
#else // IDQ_VERSION != 3
#define VER_PROJECT "indexsrv"
#endif // IDQ_VERSION == 3

#define MAKELITERALSTRING( s, lit ) s #lit
#define MAKELITERAL( s, lit ) MAKELITERALSTRING( s, lit )

#define VERSION_STRING MAKELITERAL("Indexing Service ", IDQ_VERSION) \
                       "(" VER_PROJECT ") " VER_CIDEBUG \
                       MAKELITERAL(" built by ", BUILD_USERNAME) \
                       MAKELITERAL(" with ", VER_PRODUCTBUILD) \
                        " on " __DATE__ " at " __TIME__

char g_ciBuild[ ] = VERSION_STRING;


BOOL WINAPI DllMain(
    HANDLE hInstance,
    DWORD  dwReason,
    void * lpReserved )
{
    BOOL fRetval = TRUE;
    TRANSLATE_EXCEPTIONS;

    TRY
    {
        switch ( dwReason )
        {
            case DLL_PROCESS_ATTACH:
            {
                DisableThreadLibraryCalls( (HINSTANCE) hInstance );
                InitializeCriticalSection( &g_csInitExclusive );

                break;
            }

            case DLL_PROCESS_DETACH:
            {
                DeleteCriticalSection( &g_csInitExclusive );
                break;
            }
        }
    }
    CATCH( CException, e )
    {
        // About the only thing this could be is STATUS_NO_MEMORY which
        // can be thrown by InitializeCriticalSection.

        ciGibDebugOut(( DEB_ERROR,
                        "IDQ: Exception %#x in DllMain\n",
                        e.GetErrorCode()));

#if CIDBG == 1  // for debugging NTRAID 340297
        if (e.GetErrorCode() == STATUS_NO_MEMORY)
            DbgPrint( "IDQ: STATUS_NO_MEMORY exception in DllMain\n");
        else
            DbgPrint( "IDQ: ??? Exception in DllMain\n");
#endif // CIDBG == 1

        fRetval = FALSE;
    }
    END_CATCH

    UNTRANSLATE_EXCEPTIONS;

    return fRetval;
} //DllMain
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\web\dll\tokstr.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1996, Microsoft Corporation.
//
//  File:       tokstr.cxx
//
//  Contents:   Used to break down a string into its tokens
//
//  History:    96/Feb/13   DwightKr    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop


//+---------------------------------------------------------------------------
//
//  Method:     CTokenizeString::CTokenizeString - public constructor
//
//  History:    96/Jan/23   DwightKr    Created
//
//----------------------------------------------------------------------------
CTokenizeString::CTokenizeString( WCHAR const * wcsString ) :
            _wcsString(wcsString),
            _wcsCurrentToken(wcsString),
            _wcsNextToken(wcsString)
{
    Accept();
}


//+---------------------------------------------------------------------------
//
//  Method:     CTokenizeString::Accept - public
//
//  History:    96/Jan/23   DwightKr    Created
//
//----------------------------------------------------------------------------
void CTokenizeString::Accept()
{
    EatWhiteSpace();

    _wcsCurrentToken = _wcsNextToken;

    switch ( *_wcsCurrentToken )
    {
    case L'"':
        _wcsNextToken++;
        _token = QUOTES_TOKEN;
    break;

    case L'{':
        _wcsNextToken++;
        _token = C_OPEN_TOKEN;
    break;

    case L'}':
        _wcsNextToken++;
        _token = C_CLOSE_TOKEN;
    break;

    case L',':
        _wcsNextToken++;
        _token = COMMA_TOKEN;
    break;

    case 0:
        _token = EOS_TOKEN;
    break;

    default:
        _wcsNextToken = _wcsCurrentToken + wcscspn( _wcsCurrentToken, WORD_STR );
        _token = TEXT_TOKEN;
    break;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CTokenizeString:AcqWord, public
//
//  Synopsis:   Copies the word that _wcsCurrentToken is pointing to and
//              returns the new string. Positions _wcsCurrentToken after
//              the word and whitespace. Returns 0 if at the end of a
//              TEXT_TOKEN.
//
//  History:    96-Feb-13    DwightKr   Created.
//
//----------------------------------------------------------------------------
WCHAR * CTokenizeString::AcqWord()
{
    if ( IsEndOfTextToken() )
        return 0;

    WCHAR const * pEnd = _wcsNextToken;

    int cwcToken = (int)(pEnd - _wcsCurrentToken + 1);

    WCHAR * newBuf = new WCHAR [ cwcToken ];
    RtlCopyMemory( newBuf, _wcsCurrentToken, cwcToken * sizeof(WCHAR));
    newBuf[cwcToken-1] = 0;

    _wcsCurrentToken = pEnd;
    while ( iswspace(*_wcsCurrentToken) )
        _wcsCurrentToken++;

    return newBuf;
}



//+---------------------------------------------------------------------------
//
//  Member:     CTokenizeString::GetNumber, public
//
//  Synopsis:   If _text is at the end of the TEXT_TOKEN, returns FALSE.
//              If not, puts the unsigned _int64 from the scanner into number
//              and returns TRUE.
//
//  Arguments:  [number] -- the unsigned _int64 which will be changed and
//                          passed back out as the ULONG from the scanner.
//
//  Notes:      May be called several times in a loop before Accept() is
//              called.
//
//  History:    96-Feb-13   AmyA        Created
//
//----------------------------------------------------------------------------
BOOL CTokenizeString::GetNumber( unsigned _int64 & number )
{
    ULONG base = 10;
    WCHAR const * wcsCurrentToken = _wcsCurrentToken;

    if ( IsEndOfTextToken() ||
         !iswdigit(*_wcsCurrentToken) ||
        (*_wcsCurrentToken == L'-') )
    {
        return FALSE;
    }


    if ( _wcsCurrentToken[0] == L'0' &&
        (_wcsCurrentToken[1] == L'x' || _wcsCurrentToken[1] == L'X'))
    {
        _wcsCurrentToken += 2;
        base = 16;
    }

    number = _wcstoui64( _wcsCurrentToken, (WCHAR **)(&_wcsCurrentToken), base );

    //
    // looks like a real number?
    //

    if ( ( wcsCurrentToken == _wcsCurrentToken ) ||
         ( L'.' == *_wcsCurrentToken ) )
    {
        _wcsCurrentToken = wcsCurrentToken;
        return FALSE;
    }

    while ( iswspace(*_wcsCurrentToken) )
        _wcsCurrentToken++;

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CTokenizeString::GetNumber, public
//
//  Synopsis:   If _wcsCurrentToken is at the end of the TEXT_TOKEN, returns FALSE.
//              If not, puts the _int64 from the scanner into number and
//              returns TRUE.
//
//  Arguments:  [number] -- the _int64 which will be changed and passed back
//                          out as the _int64 from the scanner.
//
//  Notes:      May be called several times in a loop before Accept() is
//              called.
//
//  History:    96-Feb-13   DwightKr    Created
//
//----------------------------------------------------------------------------
BOOL CTokenizeString::GetNumber( _int64 & number )
{
    WCHAR *text = (WCHAR *) _wcsCurrentToken;
    BOOL IsNegative = FALSE;
    if ( L'-' == _wcsCurrentToken[0] )
    {
        IsNegative = TRUE;
        _wcsCurrentToken++;
    }

    unsigned _int64 ui64Number;
    if ( !GetNumber( ui64Number ) )
    {
        _wcsCurrentToken = text;
        return FALSE;
    }


    if ( IsNegative )
    {
        if ( ui64Number > 0x8000000000000000L )
        {
            _wcsCurrentToken = text;
            return FALSE;
        }

        number = -((_int64) ui64Number);
    }
    else
    {
        number = (_int64) ui64Number;
    }

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CTokenizeString::GetNumber, public
//
//  Synopsis:   If _wcsCurrentToken is at the end of the TEXT_TOKEN, returns FALSE.
//              If not, puts the LONG from the scanner into number and
//              returns TRUE.
//
//  Arguments:  [number] -- the double which will be changed and passed back
//                          out as the double from the scanner.
//
//  Notes:      May be called several times in a loop before Accept() is
//              called.
//
//  History:    96-Feb-13   DwightKr    Created
//
//----------------------------------------------------------------------------
BOOL CTokenizeString::GetNumber( double & number )
{
    if ( IsEndOfTextToken() ||
         ((L'-' != *_wcsCurrentToken) &&
          (iswdigit(*_wcsCurrentToken) == 0) )
       )
    {
        return FALSE;
    }

    if ( swscanf( _wcsCurrentToken, L"%lf", &number ) != 1 )
    {
        return FALSE;
    }

    while ( iswspace(*_wcsCurrentToken) != 0 )
        _wcsCurrentToken++;

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CTokenizeString::GetGUID, public
//
//  Synopsis:   If _wcsCurrentToken is at the end of the TEXT_TOKEN, returns FALSE.
//              If not, puts the guid into guid & returns TRUE;
//
//  Arguments:  [guid] -- the guid which will be changed and passed back
//                        out as the output from the scanner.
//
//  Notes:      May be called several times in a loop before Accept() is
//              called.
//
//  History:    96-Feb-13   DwightKr    Created
//
//----------------------------------------------------------------------------
BOOL CTokenizeString::GetGUID( GUID & guid )
{
    if ( IsEndOfTextToken() || !iswdigit(*_wcsCurrentToken) )
        return FALSE;


    //                              0123456789 123456789 123456789 123456
    //  A guid MUST have the syntax XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
    //

    //
    //  Don't use wsscanf.  We're scanning into *bytes*, but wsscanf assumes
    //  result locations are *dwords*. Thus a write to the last few bytes of
    //  the guid writes over other memory!
    //
    WCHAR wcsGuid[37];
    RtlZeroMemory( wcsGuid, sizeof(wcsGuid) );
    wcsncpy( wcsGuid, _wcsCurrentToken, 36 );

    if ( wcsGuid[8] != L'-' )
        return FALSE;

    wcsGuid[8] = 0;
    WCHAR * pwcStart = &wcsGuid[0];
    WCHAR * pwcEnd;
    guid.Data1 = wcstoul( pwcStart, &pwcEnd, 16 );
    if ( pwcEnd < &wcsGuid[8] )  // Non-digit found before wcsGuid[8]
        return FALSE;

    if ( wcsGuid[13] != L'-' )
        return FALSE;

    wcsGuid[13] = 0;
    pwcStart = &wcsGuid[9];
    guid.Data2 = (USHORT)wcstoul( pwcStart, &pwcEnd, 16 );
    if ( pwcEnd < &wcsGuid[13] )
        return FALSE;


    if ( wcsGuid[18] != L'-' )
        return FALSE;

    wcsGuid[18] = 0;
    pwcStart = &wcsGuid[14];
    guid.Data3 = (USHORT)wcstoul( pwcStart, &pwcEnd, 16 );
    if ( pwcEnd < &wcsGuid[18] )
        return FALSE;

    WCHAR wc = wcsGuid[21];
    wcsGuid[21] = 0;
    pwcStart = &wcsGuid[19];
    guid.Data4[0] = (unsigned char)wcstoul( pwcStart, &pwcEnd, 16 );
    if ( pwcEnd < &wcsGuid[21] )
        return FALSE;

    wcsGuid[21] = wc;

    if ( wcsGuid[23] != L'-' )
        return FALSE;

    wcsGuid[23] = 0;
    pwcStart = &wcsGuid[21];
    guid.Data4[1] = (unsigned char)wcstoul( pwcStart, &pwcEnd, 16 );
    if ( pwcEnd < &wcsGuid[23] )
        return FALSE;

    for ( unsigned i = 0; i < 6; i++ )
    {
        wc = wcsGuid[26+i*2];
        wcsGuid[26+i*2] = 0;
        pwcStart = &wcsGuid[24+i*2];
        guid.Data4[2+i] = (unsigned char)wcstoul( pwcStart, &pwcEnd, 16 );
        if ( pwcEnd < &wcsGuid[26+i*2] )
            return FALSE;

        wcsGuid[26+i*2] = wc;
    }

    _wcsCurrentToken += 36;

    _wcsNextToken = _wcsCurrentToken;

    EatWhiteSpace();

    return TRUE;
}


//+---------------------------------------------------------------------------
//
//  Member:     CTokenizeString::AcqPhrase, public
//
//  Synopsis:   gets all characters up to end-of-line or next quote
//
//  History:    96-Feb-13   DwightKr    Created
//
//----------------------------------------------------------------------------
WCHAR * CTokenizeString::AcqPhrase()
{
    //
    //  Find the closing "
    //

    WCHAR const * wcsClosingQuote = _wcsCurrentToken;

    do
    {
        if ( 0 == *wcsClosingQuote )
            break;

        if ( L'"' == *wcsClosingQuote )
        {
            if ( L'"' == *(wcsClosingQuote+1) )
                wcsClosingQuote++;
            else
                break;
        }

        wcsClosingQuote++;
    } while ( TRUE );

    //
    //  We've found the closing quote.  Build a buffer big enough to
    //  contain the string.
    //
    ULONG cwcToken = (ULONG)(wcsClosingQuote - _wcsCurrentToken + 1);
    XArray<WCHAR> wcsToken( cwcToken );

    //
    // copy the string, but remove the extra quote characters
    //
    WCHAR * pwcNewBuf = wcsToken.GetPointer();
    WCHAR const * pStart = _wcsCurrentToken;

    while ( pStart < wcsClosingQuote )
    {
        *pwcNewBuf++ = *pStart++;
        if ( L'"' == *pStart )
            pStart++;
    }

    *pwcNewBuf = 0;

    _wcsCurrentToken += cwcToken - 1;
    _wcsNextToken = _wcsCurrentToken;

    EatWhiteSpace();

    return wcsToken.Acquire();
}


//+---------------------------------------------------------------------------
//
//  Member:     CTokenizeString::AcqVector, public
//
//  Synopsis:   Gets each of the vector elements upto the next }
//
//  History:    96-Feb-13   DwightKr    Created
//
//----------------------------------------------------------------------------
void CTokenizeString::AcqVector( PROPVARIANT & propVariant )
{
    //
    //  Determine the VT type of this vector.
    //

    GUID   guid;
    _int64 i64Value;
    double dblValue;

    if ( GetGUID( guid ) )
    {
        propVariant.vt = VT_CLSID | VT_VECTOR;
        propVariant.cauuid.cElems = 0;

        CDynArrayInPlace<GUID> pElems;

        do
        {
            Accept();

            pElems.Add( guid, propVariant.cauuid.cElems );
            propVariant.cauuid.cElems++;

            if ( LookAhead() == COMMA_TOKEN )
            {
                Accept();
            }

        } while ( GetGUID( guid ) );

        propVariant.cauuid.pElems = pElems.Acquire();
    }
    else if ( GetNumber( i64Value ) )
    {
        propVariant.vt = VT_I8 | VT_VECTOR;
        propVariant.cah.cElems = 0;

        CDynArrayInPlace<_int64> pElems;

        do
        {
            Accept();

            pElems.Add( i64Value, propVariant.cah.cElems );
            propVariant.cah.cElems++;

            if ( LookAhead() == COMMA_TOKEN )
            {
                Accept();
            }

        } while ( GetNumber( i64Value ) );

        propVariant.cah.pElems = (LARGE_INTEGER *) pElems.Acquire();
    }
    else if ( GetNumber( dblValue ) )
    {
        propVariant.vt = VT_R8 | VT_VECTOR;
        propVariant.cadbl.cElems = 0;

        CDynArrayInPlace<double> pElems;
        do
        {   Accept();

            pElems.Add( dblValue, propVariant.cadbl.cElems );
            propVariant.cadbl.cElems++;

            if ( LookAhead() == COMMA_TOKEN )
            {
                Accept();
            }

        } while ( GetNumber( dblValue ) );

        propVariant.cadbl.pElems = pElems.Acquire();
    }
    else
    {
        propVariant.vt = VT_LPWSTR | VT_VECTOR;
        CDynArrayInPlace<WCHAR *> pElems;
        propVariant.calpwstr.cElems = 0;

        while ( (LookAhead() != C_CLOSE_TOKEN) &&
                (LookAhead() != EOS_TOKEN)
              )
        {
            //
            //  If its a quoted string, get everything between the quotes.
            //
            if ( LookAhead() == QUOTES_TOKEN )
            {
                Accept();               // Skip over the quote
                pElems.Add(AcqPhrase(), propVariant.calpwstr.cElems );
                Accept();               // Skip over the string

                if ( LookAhead() != QUOTES_TOKEN )
                {
                    THROW( CHTXException(MSG_CI_HTX_MISSING_QUOTE, 0, 0) );
                }
                Accept();               // Skip over the quote
            }
            else
            {
                //
                //  Get the next word
                //

                pElems.Add( AcqWord(), propVariant.calpwstr.cElems );
                Accept();              // Skip over the string
            }

            propVariant.calpwstr.cElems++;
            if ( LookAhead() == COMMA_TOKEN )
            {
                Accept();
            }
        }

        propVariant.calpwstr.pElems = pElems.Acquire();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\web\dll\variable.cxx ===
//+---------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1992-2000.
//
//  File:       variable.cxx
//
//  Contents:   Used to replace variables
//
//  History:    96/Jan/3    DwightKr    Created
//
//----------------------------------------------------------------------------


#include <pch.cxx>
#pragma hdrstop

void RenderSafeArray(
    VARTYPE          vt,
    SAFEARRAY *      psa,
    COutputFormat &  outputFormat,
    CVirtualString & vString,
    BOOL             fFormatted );

//+---------------------------------------------------------------------------
//
//  Member:     CVariable::CVariable - public constructor
//
//  Synopsis:   Builds a single replaceable variable based in a propVariant
//
//  Arguments:  [wcsName]  - friendly name for the variable
//              [pVariant] - the variable's value
//              [ulFlags]  - all flags associated with this variable, for
//                           now this indicates if this variable requires
//                           a IRowsetScroll to access its value.
//
//  History:    96/Jan/03   DwightKr    Created.
//
//----------------------------------------------------------------------------
CVariable::CVariable( WCHAR const * wcsName,
                      PROPVARIANT const * pVariant,
                      ULONG ulFlags ) :
                      _wcsName(0),
                      _wcsRAWValue(0),
                      _cwcRAWValue(0),
                      _eNumType( eNotANumber ),
                      _ulFlags(ulFlags),
                      _pNext(0),
                      _pBack(0)
{
    Win4Assert( wcsName != 0 );

    ULONG cwcName = wcslen(wcsName) + 1;
    _wcsName = new WCHAR[ cwcName ];
    RtlCopyMemory( _wcsName, wcsName, cwcName * sizeof(WCHAR) );

    _variant.vt = VT_EMPTY;
    _variant.pwszVal = 0;

    if ( 0 != pVariant )
    {
        // SetValue cannot raise

        SetValue( pVariant, ulFlags );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CVariable::CVariable - public copy constructor
//
//  Synopsis:   Builds a single replaceable variable based in a propVariant
//
//  Arguments:  [variable] - the variable to copy
//
//  History:    96/Jan/03   DwightKr    Created.
//
//----------------------------------------------------------------------------
CVariable::CVariable( const CVariable & variable ) :
                      _wcsName(0),
                      _cwcRAWValue(0),
                      _eNumType( variable._eNumType ),
                      _ulFlags(0),
                      _pNext(0)

{
    ULONG cwcName = wcslen(variable._wcsName) + 1;

    _wcsName = new WCHAR[ cwcName ];

    RtlCopyMemory( _wcsName, variable._wcsName, cwcName * sizeof(WCHAR) );

    _ulFlags  = variable._ulFlags;
    _variant  = variable._variant;

    if ( VT_LPWSTR == variable._variant.vt )
    {
        _cwcRAWValue = variable._cwcRAWValue;
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CVariable::~CVariable - public destructor
//
//  History:    96/Jan/03   DwightKr    Created.
//
//----------------------------------------------------------------------------
CVariable::~CVariable()
{
    if ( (_ulFlags & eParamOwnsVariantMemory) != 0 )
    {
        delete _variant.pwszVal;
    }

    //
    //  If we have a RAW string that is not part of the variant, and is
    //  not pointing to the in-line number buffer, delete it.  It's probably
    //  an ASCII string we've converted to WCHAR.
    //
    if ( _wcsRAWValue &&
         _wcsRAWValue != _wcsNumberValue &&
         _wcsRAWValue != _variant.pwszVal )
    {
        delete _wcsRAWValue;
    }

    delete _wcsName;

    if ( 0 != _pNext )
        delete _pNext;
}

//+---------------------------------------------------------------------------
//
//  Member:     CVariable::SetValue - public
//
//  Synopsis:   An assignment operator; allows the value of a variable to
//              be changed.
//
//  Arguments:  [pVariant] -  new value for this variable
//
//  History:    96/Jan/03   DwightKr    Created.
//
//----------------------------------------------------------------------------
void CVariable::SetValue( PROPVARIANT const * pVariant, ULONG ulFlags )
{
    //
    //  If we've stored a string equivalent for the old value, then
    //  delete it now.
    //
    if ( _wcsRAWValue &&
         _wcsRAWValue != _wcsNumberValue &&
         _wcsRAWValue != _variant.pwszVal )
    {
        delete _wcsRAWValue;
        _wcsRAWValue = 0;
        _cwcRAWValue = 0;
        _eNumType = eNotANumber;
    }

    if ( (_ulFlags & eParamOwnsVariantMemory) != 0 )
    {
        delete _variant.pwszVal;
        _variant.pwszVal = 0;

        _ulFlags &= ~eParamOwnsVariantMemory;
    }

    if ( 0 != pVariant )
        _variant  = *pVariant;
    else
    {
        _variant.vt = VT_EMPTY;
        _variant.pwszVal = 0; // retentive
    }

    //
    //  If its a WCHAR string, we already have a pointer to its RAW value.
    //
    if ( (VT_LPWSTR == _variant.vt) && (0 != _variant.pwszVal) )
    {
        _wcsRAWValue = _variant.pwszVal;
        _cwcRAWValue = wcslen(_wcsRAWValue);
    }
    else
    {
         _wcsRAWValue = 0;
         _cwcRAWValue = 0;
    }

    _ulFlags |= ulFlags;
}

//+---------------------------------------------------------------------------
//
//  Member:     CVariable::FastSetValue - public
//
//  Synopsis:   Special version of SetValue that can be faster because it
//              knows that the variable can't own variant memory, that
//              the variant is non-0, that the flags are 0, and that variant
//              wide strings are non-zero.
//
//  Arguments:  [pVariant] -  new value for this variable
//
//  History:    96/Apr/05   dlee    Created.
//
//----------------------------------------------------------------------------

void CVariable::FastSetValue( PROPVARIANT const * pVariant )
{
    //
    //  If we've stored a string equivalent for the old value, then
    //  delete it now.
    //

    if ( ( _wcsRAWValue != _wcsNumberValue ) &&
         ( _wcsRAWValue != _variant.pwszVal ) )
    {
        delete _wcsRAWValue;
        _wcsRAWValue = 0;
        _cwcRAWValue = 0;
    }
    _eNumType = eNotANumber;

    Win4Assert( (_ulFlags & eParamOwnsVariantMemory) == 0 );
    Win4Assert( 0 != pVariant );
    _variant  = *pVariant;

    if ( VT_LPWSTR == _variant.vt )
    {
        // The caller of FastSetValue can't pass a 0 string variant

        Win4Assert( 0 != _variant.pwszVal );
        _wcsRAWValue = _variant.pwszVal;
        _cwcRAWValue = wcslen(_wcsRAWValue);
    }
    else
    {
         _wcsRAWValue = 0;
         _cwcRAWValue = 0;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CVariable::SetValue - public
//
//  Synopsis:   A assignment operator; allows the value of a variable to
//              be changed.  Ownership of the string is transferred to this
//              function
//
//  Arguments:  [wcsValue] -  new value for this variable
//              [cwcValue] -  length of new value string
//
//  History:    96/Jan/03   DwightKr    Created.
//
//----------------------------------------------------------------------------
void CVariable::SetValue( XPtrST<WCHAR> & wcsValue, ULONG cwcValue )
{
    Win4Assert( VT_LPWSTR == _variant.vt );

    //
    //  If we've stored a string equivalent for the old value, then
    //  delete it now.
    //
    if ( _wcsRAWValue &&
         _wcsRAWValue != _wcsNumberValue &&
         _wcsRAWValue != _variant.pwszVal )
    {
        delete _wcsRAWValue;
        _wcsRAWValue = 0;
        _cwcRAWValue = 0;
        _eNumType = eNotANumber;
    }

    if ( (_ulFlags & eParamOwnsVariantMemory) != 0 )
    {
        delete _variant.pwszVal;
        _variant.pwszVal = 0;
    }

    _ulFlags |= eParamOwnsVariantMemory;

    _wcsRAWValue = wcsValue.Acquire();
    _cwcRAWValue = cwcValue;
}


// Maximum length of a floating point value string
// Big enough for a 1e308 + 9 decimal places + sign

const unsigned maxFloatSize = 320;

//  Floating point precision.
//  +1 because the numbers in float.h seem to be too small by one digit.

const unsigned fltPrec = FLT_DIG+1;
const unsigned dblPrec = DBL_DIG+1;

//+---------------------------------------------------------------------------
//
//  Function:   SARenderElementFormatted
//
//  Synopsis:   Appends the formatted string form a safearray element to
//              a virtual string.
//              Only the subset of types that are formatted differently
//              when "formatted" vs "raw" are handled in this function.
//
//  Arguments:  [outputFormat] -- The output format to use
//              [vString]      -- Where the result is appended
//              [vt]           -- Type of the element
//              [pv]           -- Pointer to the element
//
//  Notes:      I8 and UI8 aren't allowed in safearrays in NT 5, but they
//              will be someday.
//
//  History:    9-Jun-98   dlee      Created
//
//----------------------------------------------------------------------------

void SARenderElementFormatted(
    COutputFormat &  outputFormat,
    CVirtualString & vString,
    VARTYPE          vt,
    void *           pv )
{
    ciGibDebugOut(( DEB_ITRACE, "vt %#x, pv %#x\n", vt, pv ));

    // Recurse if we have a nested VT_ARRAY in an array element.

    if ( VT_ARRAY & vt )
    {
        SAFEARRAY *psa = *(SAFEARRAY **) pv;
        RenderSafeArray( vt & ~VT_ARRAY, psa, outputFormat, vString, TRUE );
        return;
    }

    WCHAR awcTmp[ maxFloatSize ];
    const ULONG cwcTmp = sizeof awcTmp / sizeof awcTmp[0];
    ULONG cwc = 0;

    switch ( vt )
    {
        case VT_UI1:
        {
            cwc = outputFormat.FormatNumber( (ULONG) * (BYTE *) pv,
                                             awcTmp,
                                             cwcTmp );
            break;
        }
        case VT_I1:
        {
            cwc = outputFormat.FormatNumber( (LONG) * (signed char *) pv,
                                             awcTmp,
                                             cwcTmp );
            break;
        }
        case VT_UI2:
        {
            USHORT us;
            RtlCopyMemory( &us, pv, sizeof us );
            cwc = outputFormat.FormatNumber( (ULONG) us,
                                             awcTmp,
                                             cwcTmp );
            break;
        }
        case VT_I2:
        {
            SHORT s;
            RtlCopyMemory( &s, pv, sizeof s );
            cwc = outputFormat.FormatNumber( (LONG) s,
                                             awcTmp,
                                             cwcTmp );
            break;
        }
        case VT_UI4:
        case VT_UINT:
        {
            ULONG ul;
            RtlCopyMemory( &ul, pv, sizeof ul );
            cwc = outputFormat.FormatNumber( ul,
                                             awcTmp,
                                             cwcTmp );
            break;
        }
        case VT_I4:
        case VT_ERROR:
        case VT_INT:
        {
            LONG l;
            RtlCopyMemory( &l, pv, sizeof l );
            cwc = outputFormat.FormatNumber( l,
                                             awcTmp,
                                             cwcTmp );
            break;
        }
        case VT_UI8:
        {
            unsigned __int64 ui;
            RtlCopyMemory( &ui, pv, sizeof ui );
            cwc = outputFormat.FormatNumber( ui,
                                             awcTmp,
                                             cwcTmp );
            break;
        }
        case VT_I8:
        {
            __int64 i;
            RtlCopyMemory( &i, pv, sizeof i );
            cwc = outputFormat.FormatNumber( i,
                                             awcTmp,
                                             cwcTmp );
            break;
        }
        case VT_R4:
        {
            float f;
            RtlCopyMemory( &f, pv, sizeof f );
            cwc = outputFormat.FormatFloat( f,
                                            fltPrec,
                                            awcTmp,
                                            cwcTmp );
            break;
        }
        case VT_R8:
        {
            double d;
            RtlCopyMemory( &d, pv, sizeof d );
            cwc = outputFormat.FormatFloat( d,
                                            dblPrec,
                                            awcTmp,
                                            cwcTmp );
            break;
        }
        case VT_DECIMAL:
        {
            double d;
            VarR8FromDec( (DECIMAL *) pv, &d );
            cwc = outputFormat.FormatFloat( d,
                                            dblPrec,
                                            awcTmp,
                                            cwcTmp );
            break;
        }
        case VT_CY:
        {
            double d;
            VarR8FromCy( * (CY *) pv, &d );
            cwc = outputFormat.FormatFloat( d,
                                            dblPrec,
                                            awcTmp,
                                            cwcTmp );
            break;
        }
        case VT_VARIANT:
        {
            PROPVARIANT & Var = * (PROPVARIANT *) pv;
            SARenderElementFormatted( outputFormat, vString, Var.vt, & Var.lVal );
            break;
        }
        default :
        {
            ciGibDebugOut(( DEB_ERROR, "unexpected numeric sa element type %#x\n", vt ));
            Win4Assert( !"unexpected numeric safearray element type" );
            break;
        }
    }

    vString.StrCat( awcTmp, cwc );
} //SARenderElementFormatted

//+---------------------------------------------------------------------------
//
//  Function:   SARenderElementRaw
//
//  Synopsis:   Appends the "raw" string form a safearray element to
//              a virtual string.  Numbers are raw when they don't have
//              formatting like commas.
//
//  Arguments:  [outputFormat] -- The output format to use
//              [vString]      -- Where the result is appended
//              [vt]           -- Type of the element
//              [pv]           -- Pointer to the element
//
//  Notes:      I8 and UI8 aren't allowed in safearrays in NT 5, but they
//              will be someday.
//
//  History:    9-Jun-98   dlee      Created
//
//----------------------------------------------------------------------------

void SARenderElementRaw(
    COutputFormat &  outputFormat,
    CVirtualString & vString,
    VARTYPE          vt,
    void *           pv )
{
    ciGibDebugOut(( DEB_ITRACE, "vt %#x, pv %#x\n", vt, pv ));

    // Recurse if we have a nested VT_ARRAY in an array element.

    if ( VT_ARRAY & vt )
    {
        SAFEARRAY *psa = *(SAFEARRAY **) pv;
        RenderSafeArray( vt & ~VT_ARRAY, psa, outputFormat, vString, FALSE );
        return;
    }

    WCHAR awcTmp[ maxFloatSize ];
    const ULONG cwcTmp = sizeof awcTmp / sizeof awcTmp[0];
    ULONG cwc = 0;

    switch ( vt )
    {
        case VT_EMPTY:
        case VT_NULL:
        {
            break;
        }
        case VT_BSTR:
        {
            BSTR bstr = *(BSTR *) pv;
            vString.StrCat( bstr );
            break;
        }
        case VT_BOOL:
        {
            VARIANT_BOOL vb;
            RtlCopyMemory( &vb, pv, sizeof vb );
            wcscpy( awcTmp, ( VARIANT_FALSE == vb ) ? L"FALSE" : L"TRUE" );
            cwc = wcslen( awcTmp);
            break;
        }
        case VT_DATE:
        {
            SYSTEMTIME stUTC;
            DATE date;
            RtlCopyMemory( &date, pv, sizeof date );
            if ( VariantTimeToSystemTime( date, &stUTC ) )
                cwc = outputFormat.FormatDateTime( stUTC,
                                                   awcTmp,
                                                   cwcTmp );
            break;
        }
        case VT_UI1:
        {
            IDQ_ultow( (ULONG) * (BYTE *) pv, awcTmp );
            cwc = wcslen( awcTmp );
            break;
        }
        case VT_I1:
        {
            IDQ_ltow( (LONG) * (signed char *) pv, awcTmp );
            cwc = wcslen( awcTmp );
            break;
        }
        case VT_UI2:
        {
            USHORT us;
            RtlCopyMemory( &us, pv, sizeof us );
            IDQ_ultow( (ULONG) us, awcTmp );
            cwc = wcslen( awcTmp );
            break;
        }
        case VT_I2:
        {
            SHORT s;
            RtlCopyMemory( &s, pv, sizeof s );
            IDQ_ltow( (LONG) s, awcTmp );
            cwc = wcslen( awcTmp );
            break;
        }
        case VT_UI4:
        case VT_UINT:
        {
            ULONG ul;
            RtlCopyMemory( &ul, pv, sizeof ul );
            IDQ_ultow( ul, awcTmp );
            cwc = wcslen( awcTmp );
            break;
        }
        case VT_I4:
        case VT_ERROR:
        case VT_INT:
        {
            LONG l;
            RtlCopyMemory( &l, pv, sizeof l );
            IDQ_ltow( l, awcTmp );
            cwc = wcslen( awcTmp );
            break;
        }
        case VT_UI8:
        {
            unsigned __int64 ui;
            RtlCopyMemory( &ui, pv, sizeof ui );
            IDQ_ulltow( ui, awcTmp );
            cwc = wcslen( awcTmp );
            break;
        }
        case VT_I8:
        {
            __int64 i;
            RtlCopyMemory( &i, pv, sizeof i );
            IDQ_lltow( i, awcTmp );
            cwc = wcslen( awcTmp );
            break;
        }
        case VT_R4:
        {
            float f;
            RtlCopyMemory( &f, pv, sizeof f );
            cwc = outputFormat.FormatFloatRaw( f,
                                               fltPrec,
                                               awcTmp,
                                               cwcTmp );
            break;
        }
        case VT_R8:
        {
            double d;
            RtlCopyMemory( &d, pv, sizeof d );
            cwc = outputFormat.FormatFloatRaw( d,
                                               dblPrec,
                                               awcTmp,
                                               cwcTmp );
            break;
        }
        case VT_DECIMAL:
        {
            double d;
            VarR8FromDec( (DECIMAL *) pv, &d );
            cwc = outputFormat.FormatFloatRaw( d,
                                               dblPrec,
                                               awcTmp,
                                               cwcTmp );
            break;
        }
        case VT_CY:
        {
            double d;
            VarR8FromCy( * (CY *) pv, &d );
            cwc = outputFormat.FormatFloatRaw( d,
                                               dblPrec,
                                               awcTmp,
                                               cwcTmp );
            break;
        }
        case VT_VARIANT:
        {
            PROPVARIANT & Var = * (PROPVARIANT *) pv;
            SARenderElementRaw( outputFormat, vString, Var.vt, & Var.lVal );
            break;
        }
        default :
        {
            ciGibDebugOut(( DEB_ERROR, "unexpected sa element type %#x\n", vt ));
            Win4Assert( !"unexpected safearray element type" );
            break;
        }
    }

    vString.StrCat( awcTmp, cwc );
} //SARenderElementRaw

//+---------------------------------------------------------------------------
//
//  Function:   GetVectorFormatting
//
//  Synopsis:   Retrieves the vector formatting strings for a given type.
//              Only safearray element datatypes are handled here.
//
//  Arguments:  [pwcPre]  -- Returns the vector prefix string
//              [pwcSep]  -- Returns the vector separator string
//              [pwcSuf]  -- Returns the vector suffix string
//
//  History:    9-Jun-98   dlee      Created
//
//----------------------------------------------------------------------------

void GetVectorFormatting(
    WCHAR const * & pwcPre,
    WCHAR const * & pwcSep,
    WCHAR const * & pwcSuf,
    VARTYPE         vt,
    COutputFormat & outputFormat )
{
    Win4Assert( 0 == ( vt & VT_ARRAY ) );

    switch ( vt )
    {
        case VT_CY:
            pwcPre = outputFormat.GetCurrencyVectorPrefix();
            pwcSep = outputFormat.GetCurrencyVectorSeparator();
            pwcSuf = outputFormat.GetCurrencyVectorSuffix();
            break;
        case VT_DATE:
            pwcPre = outputFormat.GetDateVectorPrefix();
            pwcSep = outputFormat.GetDateVectorSeparator();
            pwcSuf = outputFormat.GetDateVectorSuffix();
            break;
        case VT_BOOL:
            pwcPre = outputFormat.GetBoolVectorPrefix();
            pwcSep = outputFormat.GetBoolVectorSeparator();
            pwcSuf = outputFormat.GetBoolVectorSuffix();
            break;
        case VT_BSTR:
            pwcPre = outputFormat.GetStringVectorPrefix();
            pwcSep = outputFormat.GetStringVectorSeparator();
            pwcSuf = outputFormat.GetStringVectorSuffix();
            break;
        case VT_VARIANT:
        case VT_EMPTY:
        case VT_NULL:
        case VT_I1:
        case VT_UI1:
        case VT_I2:
        case VT_UI2:
        case VT_I4:
        case VT_INT:
        case VT_UI4:
        case VT_UINT:
        case VT_I8:
        case VT_UI8:
        case VT_R4:
        case VT_R8:
        case VT_DECIMAL:
        case VT_ERROR:
            pwcPre = outputFormat.GetNumberVectorPrefix();
            pwcSep = outputFormat.GetNumberVectorSeparator();
            pwcSuf = outputFormat.GetNumberVectorSuffix();
            break;
        default:
            ciGibDebugOut(( DEB_ERROR, "GetVectorFormatting unknown type %#x\n", vt ));
            Win4Assert( !"GetVectorFormatting doesn't support type" );
            break;
    }
} //GetVectorFormatting

//+---------------------------------------------------------------------------
//
//  Function:   RenderSafeArray
//
//  Synopsis:   Appends the string form of a safearray to a virtual string.
//
//  Arguments:  [vt]           -- Datatype of the safearray, without VT_ARRAY
//              [psa]          -- The safearray to format
//              [outputFormat] -- How to render the result
//              [vString]      -- The result is appended here
//              [fFormatted]   -- If TRUE, formatted, otherwise raw
//
//  History:    9-Jun-98   dlee      Created
//
//----------------------------------------------------------------------------

void RenderSafeArray(
    VARTYPE          vt,
    SAFEARRAY *      psa,
    COutputFormat &  outputFormat,
    CVirtualString & vString,
    BOOL             fFormatted )
{
    Win4Assert( 0 == ( vt & VT_ARRAY ) );

    //
    // Get the array prefix, separator, and suffix
    //

    WCHAR const * pwcPre;
    WCHAR const * pwcSep;
    WCHAR const * pwcSuf;
    GetVectorFormatting( pwcPre, pwcSep, pwcSuf, vt, outputFormat );

    //
    // Get the dimensions of the array
    //

    CDynArrayInPlace<WCHAR> xOut;
    UINT cDim = SafeArrayGetDim( psa );
    if ( 0 == cDim )
        return;

    XArray<LONG> xDim( cDim );
    XArray<LONG> xLo( cDim );
    XArray<LONG> xUp( cDim );

    for ( UINT iDim = 0; iDim < cDim; iDim++ )
    {
        SCODE sc = SafeArrayGetLBound( psa, iDim + 1, &xLo[iDim] );
        if ( FAILED( sc ) )
            THROW( CException( sc ) );

        xDim[ iDim ] = xLo[ iDim ];

        sc = SafeArrayGetUBound( psa, iDim + 1, &xUp[iDim] );
        if ( FAILED( sc ) )
            THROW( CException( sc ) );

        ciGibDebugOut(( DEB_ITRACE, "dim %d, lo %d, up %d\n",
                        iDim, xLo[iDim], xUp[iDim] ));

        vString.StrCat( pwcPre );
    }

    //
    // Slog through the array
    //

    UINT iLastDim = cDim - 1;
    BOOL fDone = FALSE;

    while ( !fDone )
    {
        // Inter-element formatting if not the first element

        if ( xDim[ iLastDim ] != xLo[ iLastDim ] )
            vString.StrCat( pwcSep );

        // Get the element and render it

        void *pv;
        SCODE sc = SafeArrayPtrOfIndex( psa, xDim.GetPointer(), &pv );
        if ( FAILED( sc ) )
            THROW( CException( sc ) );

        if ( fFormatted )
            SARenderElementFormatted( outputFormat, vString, vt, pv );
        else
            SARenderElementRaw( outputFormat, vString, vt, pv );

        // Move to the next element and carry if necessary

        ULONG cOpen = 0;

        for ( LONG iDim = iLastDim; iDim >= 0; iDim-- )
        {
            if ( xDim[ iDim ] < xUp[ iDim ] )
            {
                xDim[ iDim ] = 1 + xDim[ iDim ];
                break;
            }

            vString.StrCat( pwcSuf );

            if ( 0 == iDim )
                fDone = TRUE;
            else
            {
                cOpen++;
                xDim[ iDim ] = xLo[ iDim ];
            }
        }

        for ( ULONG i = 0; !fDone && i < cOpen; i++ )
            vString.StrCat( pwcPre );
    }
} //RenderSafeArray

//+---------------------------------------------------------------------------
//
//  Member:     CVariable::GetStringValueFormattedRAW - public
//
//  Synopsis:   Not all VT types are strings.  Those which are not strings
//              have a string equivalent generated and stored for reuse.
//
//  Arguments:  [outputFormat] - contains formatting information for numbers
//
//  Returns:    A pointer to a string representation of the variable's value.
//              Numbers are formatted.
//
//  History:    26-Aug-96   KyleP       Created (from GetStringValueRAW)
//
//----------------------------------------------------------------------------

WCHAR * CVariable::GetStringValueFormattedRAW( COutputFormat & outputFormat,
                                               ULONG & cwcValue )
{
    Win4Assert( !(_wcsRAWValue == 0 && _cwcRAWValue != 0) );

    //
    // Did we have a real raw value last time?
    //

    if ( _wcsRAWValue && _eNumType == eRawNumber )
    {
        if ( _wcsRAWValue != _wcsNumberValue && _wcsRAWValue != _variant.pwszVal )
            delete _wcsRAWValue;

        _wcsRAWValue = 0;
        _cwcRAWValue = 0;
    }

    if ( 0 == _wcsRAWValue )
    {
        switch ( _variant.vt )
        {
            case VT_UI1:
                _cwcRAWValue = outputFormat.FormatNumber( (ULONG) _variant.bVal,
                                                          _wcsNumberValue,
                                                          sizeof(_wcsNumberValue) / sizeof(WCHAR) );
                _wcsRAWValue = _wcsNumberValue;
                _eNumType = eFormattedNumber;
                break;

            case VT_I1:
                _cwcRAWValue = outputFormat.FormatNumber( (LONG) _variant.cVal,
                                                          _wcsNumberValue,
                                                          sizeof(_wcsNumberValue) / sizeof(WCHAR) );
                _wcsRAWValue = _wcsNumberValue;
                _eNumType = eFormattedNumber;
                break;

            case VT_UI2:
                _cwcRAWValue = outputFormat.FormatNumber( (ULONG) _variant.uiVal,
                                                          _wcsNumberValue,
                                                          sizeof(_wcsNumberValue) / sizeof(WCHAR) );
                _wcsRAWValue = _wcsNumberValue;
                _eNumType = eFormattedNumber;
                break;

            case VT_I2:
                _cwcRAWValue = outputFormat.FormatNumber( (LONG) _variant.iVal,
                                                          _wcsNumberValue,
                                                          sizeof(_wcsNumberValue) / sizeof(WCHAR) );
                _wcsRAWValue = _wcsNumberValue;
                _eNumType = eFormattedNumber;
                break;

            case VT_UI4:
            case VT_UINT:
                _cwcRAWValue = outputFormat.FormatNumber( (ULONG) _variant.ulVal,
                                                          _wcsNumberValue,
                                                          sizeof(_wcsNumberValue) / sizeof(WCHAR) );
                _wcsRAWValue = _wcsNumberValue;
                _eNumType = eFormattedNumber;
                break;

            case VT_I4:
            case VT_INT:
            case VT_ERROR:
                _cwcRAWValue = outputFormat.FormatNumber( (LONG) _variant.lVal,
                                                          _wcsNumberValue,
                                                          sizeof(_wcsNumberValue) / sizeof(WCHAR) );
                _wcsRAWValue = _wcsNumberValue;
                _eNumType = eFormattedNumber;
                break;

            case VT_UI8:
                _cwcRAWValue = outputFormat.FormatNumber( _variant.uhVal.QuadPart,
                                                          _wcsNumberValue,
                                                          sizeof(_wcsNumberValue) / sizeof(WCHAR) );
                _wcsRAWValue = _wcsNumberValue;
                _eNumType = eFormattedNumber;
                break;

            case VT_I8:
                _cwcRAWValue = outputFormat.FormatNumber( _variant.hVal.QuadPart,
                                                          _wcsNumberValue,
                                                          sizeof(_wcsNumberValue) / sizeof(WCHAR) );
                _wcsRAWValue = _wcsNumberValue;
                _eNumType = eFormattedNumber;
                break;

            case VT_R4:
            {
                WCHAR awchOutput[maxFloatSize];

                _cwcRAWValue = outputFormat.FormatFloat( _variant.fltVal,
                                                         fltPrec,
                                                         awchOutput,
                                                         maxFloatSize );

                if ( _cwcRAWValue < cwcNumberValue )
                    _wcsRAWValue = _wcsNumberValue;
                else
                    _wcsRAWValue = new WCHAR[ 1 + _cwcRAWValue ];

                RtlCopyMemory( _wcsRAWValue, awchOutput, (1 + _cwcRAWValue) * sizeof WCHAR );
                _eNumType = eFormattedNumber;
                break;
            }

            case VT_R8:
            case VT_DECIMAL:
            {
                double dblValue = _variant.dblVal;
                if ( VT_DECIMAL == _variant.vt )
                    VarR8FromDec( &_variant.decVal, &dblValue );

                // Big enough for a 1e308 + 9 decimal places + sign

                WCHAR awchOutput[maxFloatSize];

                _cwcRAWValue = outputFormat.FormatFloat( dblValue,
                                                         dblPrec,
                                                         awchOutput,
                                                         maxFloatSize );

                if ( _cwcRAWValue < cwcNumberValue )
                    _wcsRAWValue = _wcsNumberValue;
                else
                    _wcsRAWValue = new WCHAR[ 1 + _cwcRAWValue ];

                RtlCopyMemory( _wcsRAWValue, awchOutput, (1 + _cwcRAWValue) * sizeof WCHAR );
                _eNumType = eFormattedNumber;
                break;
            }

            case VT_CY:
                _cwcRAWValue = outputFormat.FormatCurrency( _variant.cyVal,
                                                            _wcsNumberValue,
                                                            sizeof(_wcsNumberValue) / sizeof(WCHAR) );
                _wcsRAWValue = _wcsNumberValue;
                _eNumType = eFormattedNumber;
                break;

            case VT_UI1 | VT_VECTOR:
            case VT_I1 | VT_VECTOR:
            {
                _eNumType = eFormattedNumber;
                CVirtualString vString( 0x200 );
                vString.StrCat( outputFormat.GetNumberVectorPrefix() );

                for ( unsigned iValue=0;
                      iValue<_variant.caub.cElems;
                      iValue++ )
                {
                    if ( 0 != iValue )
                        vString.StrCat( outputFormat.GetNumberVectorSeparator() );

                    if ( (VT_UI1 | VT_VECTOR) == _variant.vt )
                        _cwcRAWValue = outputFormat.FormatNumber( (ULONG) _variant.caub.pElems[iValue],
                                                                  _wcsNumberValue,
                                                                  sizeof(_wcsNumberValue) / sizeof(WCHAR) );
                    else
                        _cwcRAWValue = outputFormat.FormatNumber( (LONG) _variant.cac.pElems[iValue],
                                                                  _wcsNumberValue,
                                                                  sizeof(_wcsNumberValue) / sizeof(WCHAR) );

                    vString.StrCat( _wcsNumberValue, _cwcRAWValue );
                }

                vString.StrCat( outputFormat.GetNumberVectorSuffix() );

                _wcsRAWValue = vString.StrDup();
                _cwcRAWValue = vString.StrLen();
                break;
            }

            case VT_I2 | VT_VECTOR:
            case VT_UI2 | VT_VECTOR:
            {
                _eNumType = eFormattedNumber;
                CVirtualString vString( 0x200 );
                vString.StrCat( outputFormat.GetNumberVectorPrefix() );

                for ( unsigned iValue=0;
                      iValue<_variant.caui.cElems;
                      iValue++ )
                {
                    if ( 0 != iValue )
                        vString.StrCat( outputFormat.GetNumberVectorSeparator() );

                    if ( (VT_UI2 | VT_VECTOR) == _variant.vt )
                        _cwcRAWValue = outputFormat.FormatNumber( (ULONG) _variant.caui.pElems[iValue],
                                                                  _wcsNumberValue,
                                                                  sizeof(_wcsNumberValue) / sizeof(WCHAR) );
                    else
                        _cwcRAWValue = outputFormat.FormatNumber( (LONG) _variant.cai.pElems[iValue],
                                                                  _wcsNumberValue,
                                                                  sizeof(_wcsNumberValue) / sizeof(WCHAR) );

                    vString.StrCat( _wcsNumberValue, _cwcRAWValue );
                }

                vString.StrCat( outputFormat.GetNumberVectorSuffix() );

                _wcsRAWValue = vString.StrDup();
                _cwcRAWValue = vString.StrLen();
                break;
            }

            case VT_R4 | VT_VECTOR:
            case VT_I4 | VT_VECTOR:
            case VT_UI4 | VT_VECTOR:
            case VT_ERROR | VT_VECTOR:
            {
                _eNumType = eFormattedNumber;
                CVirtualString vString( 0x200 );
                vString.StrCat( outputFormat.GetNumberVectorPrefix() );

                for ( unsigned iValue=0;
                      iValue<_variant.caul.cElems;
                      iValue++ )
                {
                    if ( 0 != iValue )
                        vString.StrCat( outputFormat.GetNumberVectorSeparator() );

                    if ( (VT_R4 | VT_VECTOR) == _variant.vt )
                        _cwcRAWValue = outputFormat.FormatFloat( _variant.caflt.pElems[iValue],
                                                                 fltPrec,
                                                                 _wcsNumberValue,
                                                                 sizeof(_wcsNumberValue) / sizeof(WCHAR) );
                    else if ( (VT_UI4 | VT_VECTOR) == _variant.vt )
                        _cwcRAWValue = outputFormat.FormatNumber( _variant.caul.pElems[iValue],
                                                                  _wcsNumberValue,
                                                                  sizeof(_wcsNumberValue) / sizeof(WCHAR) );
                    else
                        _cwcRAWValue = outputFormat.FormatNumber( _variant.cal.pElems[iValue],
                                                                  _wcsNumberValue,
                                                                  sizeof(_wcsNumberValue) / sizeof(WCHAR) );

                    vString.StrCat( _wcsNumberValue, _cwcRAWValue );
                }

                vString.StrCat( outputFormat.GetNumberVectorSuffix() );

                _wcsRAWValue = vString.StrDup();
                _cwcRAWValue = vString.StrLen();
                break;
            }

            case VT_I8 | VT_VECTOR:
            case VT_UI8 | VT_VECTOR:
            case VT_R8 | VT_VECTOR:
            {
                _eNumType = eFormattedNumber;
                CVirtualString vString( 0x200 );
                vString.StrCat( outputFormat.GetNumberVectorPrefix() );

                for ( unsigned iValue=0;
                      iValue<_variant.cadbl.cElems;
                      iValue++
                    )
                {
                    if ( 0 != iValue )
                        vString.StrCat( outputFormat.GetNumberVectorSeparator() );

                    if ( (VT_I8 | VT_VECTOR) == _variant.vt )
                        _cwcRAWValue = outputFormat.FormatNumber( (_int64) _variant.cah.pElems[iValue].QuadPart,
                                                                  _wcsNumberValue,
                                                                  sizeof(_wcsNumberValue) / sizeof(WCHAR) );
                    else if ( (VT_UI8 | VT_VECTOR) == _variant.vt )
                        _cwcRAWValue = outputFormat.FormatNumber( (unsigned _int64) _variant.cauh.pElems[iValue].QuadPart,
                                                                  _wcsNumberValue,
                                                                  sizeof(_wcsNumberValue) / sizeof(WCHAR) );
                    else
                        _cwcRAWValue = outputFormat.FormatFloat( _variant.cadbl.pElems[iValue],
                                                                 dblPrec,
                                                                 _wcsNumberValue,
                                                                 sizeof(_wcsNumberValue) / sizeof(WCHAR) );

                    vString.StrCat( _wcsNumberValue, _cwcRAWValue );
                }

                vString.StrCat( outputFormat.GetNumberVectorSuffix() );

                _wcsRAWValue = vString.StrDup();
                _cwcRAWValue = vString.StrLen();
                break;
            }

            case VT_CY | VT_VECTOR:
            {
                _eNumType = eFormattedNumber;
                CVirtualString vString( 0x200 );
                vString.StrCat( outputFormat.GetCurrencyVectorPrefix() );

                for ( unsigned iValue=0;
                      iValue<_variant.cacy.cElems;
                      iValue++ )
                {
                    if ( 0 != iValue )
                        vString.StrCat( outputFormat.GetCurrencyVectorSeparator() );

                    _cwcRAWValue = outputFormat.FormatCurrency( _variant.cacy.pElems[iValue],
                                                                _wcsNumberValue,
                                                                sizeof(_wcsNumberValue) / sizeof(WCHAR) );
                    vString.StrCat( _wcsNumberValue, _cwcRAWValue );
                }

                vString.StrCat( outputFormat.GetCurrencyVectorSuffix() );

                _wcsRAWValue = vString.StrDup();
                _cwcRAWValue = vString.StrLen();
                break;
            }

            case VT_ARRAY | VT_I1 :
            case VT_ARRAY | VT_UI1:
            case VT_ARRAY | VT_I2 :
            case VT_ARRAY | VT_UI2 :
            case VT_ARRAY | VT_I4 :
            case VT_ARRAY | VT_INT :
            case VT_ARRAY | VT_UI4 :
            case VT_ARRAY | VT_UINT :
            case VT_ARRAY | VT_CY :
            case VT_ARRAY | VT_DECIMAL :
            case VT_ARRAY | VT_ERROR:
            {
                _eNumType = eFormattedNumber;
                CVirtualString vString( 0x200 );

                RenderSafeArray( _variant.vt & ~VT_ARRAY,
                                 _variant.parray,
                                 outputFormat,
                                 vString,
                                 TRUE );
                _wcsRAWValue = vString.StrDup();
                _cwcRAWValue = vString.StrLen();
                break;
            }

            default:
            {
                Win4Assert( _eNumType == eNotANumber );
                GetStringValueRAW( outputFormat, cwcValue );
                break;
            }
        }
    }

#if (DBG == 1)
    if ( _wcsRAWValue != 0 )
    {
        Win4Assert( wcslen(_wcsRAWValue) == _cwcRAWValue );
    }
#endif // DBG == 1

    Win4Assert( !(_wcsRAWValue == 0 && _cwcRAWValue != 0) );

    cwcValue = _cwcRAWValue;
    return _wcsRAWValue;
}

//+---------------------------------------------------------------------------
//
//  Member:     CVariable::GetStringValueRAW - public
//
//  Synopsis:   Not all VT types are strings.  Those which are not strings
//              have a string equivalent generated and stored for reuse.
//
//  Arguments:  [outputFormat] - contains formatting information for numbers
//
//  Returns:    A pointer to a string representation of the variable's value.
//
//  History:    96/Jan/03   DwightKr    Created.
//              96/Mar/29   DwightKr    Add support for deferred VT_LPWSTR
//                                      values
//
//----------------------------------------------------------------------------
WCHAR * CVariable::GetStringValueRAW( COutputFormat & outputFormat,
                                      ULONG & cwcValue)
{
    Win4Assert( !(_wcsRAWValue == 0 && _cwcRAWValue != 0) );

    //
    // Did we have a formatted raw value last time?
    //

    if ( _wcsRAWValue && _eNumType == eFormattedNumber )
    {
        if ( _wcsRAWValue != _wcsNumberValue && _wcsRAWValue != _variant.pwszVal )
            delete _wcsRAWValue;

        _wcsRAWValue = 0;
        _cwcRAWValue = 0;
    }

    if ( 0 == _wcsRAWValue )
    {
        switch ( _variant.vt )
        {
            case VT_LPWSTR:
                //
                //  if it's a deferred value, load it now
                //
                if ( (_ulFlags & eParamDeferredValue) != 0 )
                {
                    XArray<WCHAR> wcsValue;
                    ULONG         cwcValue;

                    if ( outputFormat.GetCGIVariableW(_wcsName, wcsValue, cwcValue) )
                    {
                        _wcsRAWValue = wcsValue.Acquire();
                        _cwcRAWValue = cwcValue;

                        ciGibDebugOut(( DEB_ITRACE,
                                        "Loading deferred value for %ws=%ws\n",
                                         _wcsName,
                                         _wcsRAWValue ));
                    }
                    else
                    {
                        ciGibDebugOut(( DEB_ITRACE,
                                        "Unable to load deferred value for %ws\n",
                                         _wcsName ));

                        _variant.vt = VT_EMPTY;
                        _wcsRAWValue = _wcsNumberValue;
                       *_wcsRAWValue = 0;
                        _cwcRAWValue = 0;
                    }

                    break;
                }

                // fall through if not a deferred value

            case VT_EMPTY:
                _wcsRAWValue = _wcsNumberValue;
               *_wcsRAWValue = 0;
                _cwcRAWValue = 0;
            break;

            case VT_BSTR:
                _wcsRAWValue = _variant.bstrVal;
                _cwcRAWValue = wcslen( _wcsRAWValue );
            break;

            case VT_LPSTR:
            {
                ULONG cbBuffer = strlen( _variant.pszVal ) + 1;
                XArray<WCHAR> pwBuffer;

                _cwcRAWValue = MultiByteToXArrayWideChar(
                                          (BYTE * const) _variant.pszVal,
                                                          cbBuffer,
                                                          outputFormat.CodePage(),
                                                          pwBuffer );

                _wcsRAWValue = pwBuffer.Acquire();
            }
            break;

            case VT_UI1:
                IDQ_ultow( (ULONG) _variant.bVal, _wcsNumberValue );
                _wcsRAWValue = _wcsNumberValue;
                _cwcRAWValue = wcslen( _wcsRAWValue );
                _eNumType = eRawNumber;
            break;

            case VT_I1:
                IDQ_ltow( (LONG) _variant.cVal, _wcsNumberValue );
                _wcsRAWValue = _wcsNumberValue;
                _cwcRAWValue = wcslen( _wcsRAWValue );
                _eNumType = eRawNumber;
            break;

            case VT_UI2:
                IDQ_ultow( (ULONG) _variant.uiVal, _wcsNumberValue );
                _wcsRAWValue = _wcsNumberValue;
                _cwcRAWValue = wcslen( _wcsRAWValue );
                _eNumType = eRawNumber;
            break;

            case VT_I2:
                IDQ_ltow( (LONG) _variant.iVal, _wcsNumberValue );
                _wcsRAWValue = _wcsNumberValue;
                _cwcRAWValue = wcslen( _wcsRAWValue );
                _eNumType = eRawNumber;
            break;

            case VT_UI4:
            case VT_UINT:
                IDQ_ultow( _variant.ulVal, _wcsNumberValue );
                _wcsRAWValue = _wcsNumberValue;
                _cwcRAWValue = wcslen( _wcsRAWValue );
                _eNumType = eRawNumber;
            break;

            case VT_I4:
            case VT_INT:
            case VT_ERROR:
                IDQ_ltow( _variant.lVal, _wcsNumberValue );
                _wcsRAWValue = _wcsNumberValue;
                _cwcRAWValue = wcslen( _wcsRAWValue );
                _eNumType = eRawNumber;
            break;

            case VT_UI8:
                IDQ_ulltow( _variant.uhVal.QuadPart, _wcsNumberValue );
                _wcsRAWValue = _wcsNumberValue;
                _cwcRAWValue = wcslen( _wcsRAWValue );
                _eNumType = eRawNumber;
            break;

            case VT_I8:
                IDQ_lltow( _variant.hVal.QuadPart, _wcsNumberValue );
                _wcsRAWValue = _wcsNumberValue;
                _cwcRAWValue = wcslen( _wcsRAWValue );
                _eNumType = eRawNumber;
            break;

            case VT_R4:
            {
                // Big enough for a 1e308 + 9 decimal places + sign

                WCHAR awc[maxFloatSize];

                outputFormat.FormatFloatRaw( _variant.fltVal, fltPrec, awc, maxFloatSize );
                _cwcRAWValue = wcslen( awc );

                if ( _cwcRAWValue < cwcNumberValue )
                    _wcsRAWValue = _wcsNumberValue;
                else
                    _wcsRAWValue = new WCHAR[ 1 + _cwcRAWValue ];

                RtlCopyMemory( _wcsRAWValue, awc, (1 + _cwcRAWValue) * sizeof WCHAR );
                _eNumType = eRawNumber;
            }
            break;

            case VT_R8:
            case VT_DECIMAL:
            {
                double dblValue = _variant.dblVal;
                if ( VT_DECIMAL == _variant.vt )
                    VarR8FromDec( &_variant.decVal, &dblValue );

                // Big enough for a 1e308 + 9 decimal places + sign

                WCHAR awc[maxFloatSize];

                outputFormat.FormatFloatRaw( dblValue, dblPrec, awc, maxFloatSize );
                _cwcRAWValue = wcslen( awc );

                if ( _cwcRAWValue < cwcNumberValue )
                    _wcsRAWValue = _wcsNumberValue;
                else
                    _wcsRAWValue = new WCHAR[ 1 + _cwcRAWValue ];

                RtlCopyMemory( _wcsRAWValue, awc, (1 + _cwcRAWValue) * sizeof WCHAR );
                _eNumType = eRawNumber;
            }
            break;

            case VT_DATE:
            {
                //
                // variantdate => dosdate => utcfiletime
                //

                SYSTEMTIME stUTC;
                if ( VariantTimeToSystemTime(_variant.date, &stUTC ) )
                {
                    _cwcRAWValue = outputFormat.FormatDateTime( stUTC,
                                                                _wcsNumberValue,
                                                                sizeof(_wcsNumberValue) / sizeof(WCHAR) );
                    _wcsRAWValue = _wcsNumberValue;
                }
                else
                {
                    _wcsRAWValue  = _wcsNumberValue;
                    *_wcsRAWValue = 0;
                    _cwcRAWValue  = 0;
                }
            }
            break;

            case VT_FILETIME:
                _cwcRAWValue = outputFormat.FormatDateTime( _variant.filetime,
                                                            _wcsNumberValue,
                                                            sizeof(_wcsNumberValue) / sizeof(WCHAR) );
                _wcsRAWValue = _wcsNumberValue;
            break;

            case VT_BOOL:
                _wcsRAWValue = _wcsNumberValue;
                wcscpy( _wcsRAWValue, _variant.boolVal == VARIANT_FALSE ? L"FALSE" : L"TRUE" );
                _cwcRAWValue = wcslen( _wcsRAWValue );
            break;

            case VT_CLSID:
                _wcsRAWValue = _wcsNumberValue;
                _cwcRAWValue = swprintf( _wcsRAWValue,
                               L"%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
                               _variant.puuid->Data1,
                               _variant.puuid->Data2,
                               _variant.puuid->Data3,
                               _variant.puuid->Data4[0], _variant.puuid->Data4[1],
                               _variant.puuid->Data4[2], _variant.puuid->Data4[3],
                               _variant.puuid->Data4[4], _variant.puuid->Data4[5],
                               _variant.puuid->Data4[6], _variant.puuid->Data4[7] );
            break;

            case VT_CY:
            {
                double dblValue;
                VarR8FromCy( _variant.cyVal, &dblValue );

                // Big enough for a 1e308 + 9 decimal places + sign

                WCHAR awc[maxFloatSize];

                _cwcRAWValue = swprintf( awc, L"%lf", dblValue );

                if ( _cwcRAWValue < cwcNumberValue )
                    _wcsRAWValue = _wcsNumberValue;
                else
                    _wcsRAWValue = new WCHAR[ 1 + _cwcRAWValue ];

                RtlCopyMemory( _wcsRAWValue, awc, (1 + _cwcRAWValue) * sizeof WCHAR );
                _eNumType = eRawNumber;
            }
            break;


            //
            //  Vectors only below this point
            //
            case VT_LPWSTR | VT_VECTOR:
            {
                CVirtualString vString( 0x200 );
                vString.StrCat( outputFormat.GetStringVectorPrefix() );

                for ( unsigned iValue=0;
                      iValue<_variant.calpwstr.cElems;
                      iValue++ )
                {
                    if ( 0 != iValue )
                        vString.StrCat( outputFormat.GetStringVectorSeparator() );

                    vString.StrCat( _variant.calpwstr.pElems[iValue] );
                }

                vString.StrCat( outputFormat.GetStringVectorSuffix() );
                _wcsRAWValue = vString.StrDup();
                _cwcRAWValue = vString.StrLen();
            }
            break;

            case VT_BSTR | VT_VECTOR:
            {
                CVirtualString vString( 0x200 );
                vString.StrCat( outputFormat.GetStringVectorPrefix() );

                for ( unsigned iValue=0;
                      iValue<_variant.cabstr.cElems;
                      iValue++ )
                {
                    if ( 0 != iValue )
                        vString.StrCat( outputFormat.GetStringVectorSeparator() );

                    vString.StrCat( _variant.cabstr.pElems[iValue] );
                }

                vString.StrCat( outputFormat.GetStringVectorSuffix() );
                _wcsRAWValue = vString.StrDup();
                _cwcRAWValue = vString.StrLen();
            }
            break;

            case VT_LPSTR | VT_VECTOR:
            {
                CVirtualString vString( 0x200 );
                vString.StrCat( outputFormat.GetStringVectorPrefix() );

                for ( unsigned iValue=0;
                      iValue<_variant.calpstr.cElems;
                      iValue++ )
                {
                    if ( 0 != iValue )
                        vString.StrCat( outputFormat.GetStringVectorSeparator() );

                    ULONG cbBuffer = strlen( _variant.calpstr.pElems[iValue] ) + 1;
                    XArray<WCHAR> pwBuffer;

                    _cwcRAWValue = MultiByteToXArrayWideChar(
                                              (BYTE * const) _variant.calpstr.pElems[iValue],
                                                              cbBuffer,
                                                              outputFormat.CodePage(),
                                                              pwBuffer );

                    vString.StrCat( pwBuffer.Get(), _cwcRAWValue );
                }

                vString.StrCat( outputFormat.GetStringVectorSuffix() );
                _wcsRAWValue = vString.StrDup();
                _cwcRAWValue = vString.StrLen();
            }
            break;

            case VT_UI1 | VT_VECTOR:
            case VT_I1 | VT_VECTOR:
            {
                _eNumType = eRawNumber;
                CVirtualString vString( 0x200 );
                vString.StrCat( outputFormat.GetNumberVectorPrefix() );

                for ( unsigned iValue=0;
                      iValue<_variant.caub.cElems;
                      iValue++ )
                {
                    if ( 0 != iValue )
                        vString.StrCat( outputFormat.GetNumberVectorSeparator() );

                    if ( (VT_UI1 | VT_VECTOR) == _variant.vt )
                    {
                        IDQ_ultow( (ULONG) _variant.caub.pElems[iValue], _wcsNumberValue );
                        _wcsRAWValue = _wcsNumberValue;
                        _cwcRAWValue = wcslen( _wcsRAWValue );
                    }
                    else
                    {
                        IDQ_ltow( (LONG) _variant.cac.pElems[iValue], _wcsNumberValue );
                        _wcsRAWValue = _wcsNumberValue;
                        _cwcRAWValue = wcslen( _wcsRAWValue );
                    }

                    vString.StrCat( _wcsNumberValue, _cwcRAWValue );
                }

                vString.StrCat( outputFormat.GetNumberVectorSuffix() );

                _wcsRAWValue = vString.StrDup();
                _cwcRAWValue = vString.StrLen();
            }
            break;


            case VT_I2 | VT_VECTOR:
            case VT_UI2 | VT_VECTOR:
            {
                _eNumType = eRawNumber;
                CVirtualString vString( 0x200 );
                vString.StrCat( outputFormat.GetNumberVectorPrefix() );

                for ( unsigned iValue=0;
                      iValue<_variant.caui.cElems;
                      iValue++ )
                {
                    if ( 0 != iValue )
                        vString.StrCat( outputFormat.GetNumberVectorSeparator() );

                    if ( (VT_UI2 | VT_VECTOR) == _variant.vt )
                    {
                        IDQ_ultow( (ULONG) _variant.caui.pElems[iValue], _wcsNumberValue );
                        _wcsRAWValue = _wcsNumberValue;
                        _cwcRAWValue = wcslen( _wcsRAWValue );
                    }
                    else
                    {
                        IDQ_ltow( (LONG) _variant.cai.pElems[iValue], _wcsNumberValue );
                        _wcsRAWValue = _wcsNumberValue;
                        _cwcRAWValue = wcslen( _wcsRAWValue );
                    }

                    vString.StrCat( _wcsNumberValue, _cwcRAWValue );
                }

                vString.StrCat( outputFormat.GetNumberVectorSuffix() );

                _wcsRAWValue = vString.StrDup();
                _cwcRAWValue = vString.StrLen();
            }
            break;

            case VT_I4 | VT_VECTOR:
            case VT_UI4 | VT_VECTOR:
            case VT_I8 | VT_VECTOR:
            case VT_UI8 | VT_VECTOR:
            {
                _eNumType = eRawNumber;
                CVirtualString vString( 0x200 );
                vString.StrCat( outputFormat.GetNumberVectorPrefix() );

                for ( unsigned iValue=0;
                      iValue<_variant.caul.cElems;
                      iValue++ )
                {
                    if ( 0 != iValue )
                        vString.StrCat( outputFormat.GetNumberVectorSeparator() );

                    if ( (VT_I4 | VT_VECTOR) == _variant.vt )
                    {
                        IDQ_ltow( _variant.cal.pElems[iValue], _wcsNumberValue );
                        _wcsRAWValue = _wcsNumberValue;
                        _cwcRAWValue = wcslen( _wcsRAWValue );
                    }
                    else if ( (VT_UI4 | VT_VECTOR) == _variant.vt )
                    {
                        IDQ_ultow( _variant.caul.pElems[iValue], _wcsNumberValue );
                        _wcsRAWValue = _wcsNumberValue;
                        _cwcRAWValue = wcslen( _wcsRAWValue );
                    }
                    else if ( (VT_I8 | VT_VECTOR) == _variant.vt )
                    {
                        IDQ_lltow( _variant.cah.pElems[iValue].QuadPart, _wcsNumberValue );
                        _wcsRAWValue = _wcsNumberValue;
                        _cwcRAWValue = wcslen( _wcsRAWValue );
                    }
                    else
                    {
                        IDQ_ulltow( _variant.cauh.pElems[iValue].QuadPart, _wcsNumberValue );
                        _wcsRAWValue = _wcsNumberValue;
                        _cwcRAWValue = wcslen( _wcsRAWValue );
                    }

                    vString.StrCat( _wcsNumberValue, _cwcRAWValue );
                }

                vString.StrCat( outputFormat.GetNumberVectorSuffix() );

                _wcsRAWValue = vString.StrDup();
                _cwcRAWValue = vString.StrLen();
            }
            break;

            case VT_R4 | VT_VECTOR:
            case VT_R8 | VT_VECTOR:
            {
                _eNumType = eRawNumber;
                CVirtualString vString( 0x200 );
                vString.StrCat( outputFormat.GetNumberVectorPrefix() );

                // Big enough for a 1e308 + 9 decimal places + sign
                WCHAR awc[maxFloatSize];

                for ( unsigned iValue=0;
                      iValue<_variant.cadbl.cElems;
                      iValue++ )
                {
                    if ( 0 != iValue )
                        vString.StrCat( outputFormat.GetNumberVectorSeparator() );

                    if ( (VT_R4 | VT_VECTOR) == _variant.vt )
                    {
                        outputFormat.FormatFloatRaw( _variant.caflt.pElems[iValue], fltPrec, awc, maxFloatSize );
                        _cwcRAWValue = wcslen( awc );
                    }
                    else
                    {
                        outputFormat.FormatFloatRaw( _variant.cadbl.pElems[iValue], dblPrec, awc, maxFloatSize );
                        _cwcRAWValue = wcslen( awc );
                    }

                    vString.StrCat( awc, _cwcRAWValue );
                }

                vString.StrCat( outputFormat.GetNumberVectorSuffix() );

                _wcsRAWValue = vString.StrDup();
                _cwcRAWValue = vString.StrLen();
            }
            break;

            case VT_DATE | VT_VECTOR:
            {
                CVirtualString vString( 0x200 );
                vString.StrCat( outputFormat.GetDateVectorPrefix() );

                for ( unsigned iValue=0;
                      iValue<_variant.cadate.cElems;
                      iValue++ )
                {
                    if ( 0 != iValue )
                        vString.StrCat( outputFormat.GetDateVectorSeparator() );

                    //
                    // variantdate => dosdate => localfiletime => utcfiletime
                    //

                    SYSTEMTIME stUTC;
                    if ( VariantTimeToSystemTime(_variant.cadate.pElems[iValue], &stUTC ) )
                    {
                        _cwcRAWValue = outputFormat.FormatDateTime( stUTC,
                                                                    _wcsNumberValue,
                                                                    sizeof(_wcsNumberValue) / sizeof(WCHAR) );
                    }
                    else
                    {
                        *_wcsNumberValue = 0;
                        _cwcRAWValue  = 0;
                    }

                    vString.StrCat( _wcsNumberValue, _cwcRAWValue );
                }

                vString.StrCat( outputFormat.GetDateVectorSuffix() );

                _wcsRAWValue = vString.StrDup();
                _cwcRAWValue = vString.StrLen();
            }
            break;

            case VT_FILETIME | VT_VECTOR:
            {
                CVirtualString vString( 0x200 );
                vString.StrCat( outputFormat.GetDateVectorPrefix() );

                for ( unsigned iValue=0;
                      iValue<_variant.cafiletime.cElems;
                      iValue++ )
                {
                    if ( 0 != iValue )
                        vString.StrCat( outputFormat.GetDateVectorSeparator() );

                    _cwcRAWValue = outputFormat.FormatDateTime( _variant.cafiletime.pElems[iValue],
                                                                _wcsNumberValue,
                                                                sizeof(_wcsNumberValue) / sizeof(WCHAR) );
                    vString.StrCat( _wcsNumberValue, _cwcRAWValue );
                }

                vString.StrCat( outputFormat.GetDateVectorSuffix() );

                _wcsRAWValue = vString.StrDup();
                _cwcRAWValue = vString.StrLen();
            }
            break;

            case VT_BOOL | VT_VECTOR:
            {
                CVirtualString vString( 0x200 );
                vString.StrCat( outputFormat.GetBoolVectorPrefix() );

                for ( unsigned iValue=0;
                      iValue<_variant.cabool.cElems;
                      iValue++ )
                {
                    if ( 0 != iValue )
                        vString.StrCat( outputFormat.GetBoolVectorSeparator() );

                    vString.StrCat( _variant.cabool.pElems[iValue] == VARIANT_FALSE ? L"FALSE" : L"TRUE" );
                }

                vString.StrCat( outputFormat.GetBoolVectorSuffix() );

                _wcsRAWValue = vString.StrDup();
                _cwcRAWValue = vString.StrLen();
            }
            break;

            case VT_CLSID | VT_VECTOR:
            {
                CVirtualString vString( 0x200 );
                vString.StrCat( outputFormat.GetStringVectorPrefix() );

                for ( unsigned iValue=0;
                      iValue<_variant.cauuid.cElems;
                      iValue++ )
                {
                    if ( 0 != iValue )
                        vString.StrCat( outputFormat.GetStringVectorSeparator() );

                    _cwcRAWValue = swprintf( _wcsNumberValue,
                                   L"%08lx-%04x-%04x-%02x%02x-%02x%02x%02x%02x%02x%02x",
                                   _variant.cauuid.pElems[iValue].Data1,
                                   _variant.cauuid.pElems[iValue].Data2,
                                   _variant.cauuid.pElems[iValue].Data3,
                                   _variant.cauuid.pElems[iValue].Data4[0], _variant.cauuid.pElems[iValue].Data4[1],
                                   _variant.cauuid.pElems[iValue].Data4[2], _variant.cauuid.pElems[iValue].Data4[3],
                                   _variant.cauuid.pElems[iValue].Data4[4], _variant.cauuid.pElems[iValue].Data4[5],
                                   _variant.cauuid.pElems[iValue].Data4[6], _variant.cauuid.pElems[iValue].Data4[7] );
                    vString.StrCat( _wcsNumberValue, _cwcRAWValue );
                }

                vString.StrCat( outputFormat.GetStringVectorSuffix() );

                _wcsRAWValue = vString.StrDup();
                _cwcRAWValue = vString.StrLen();
            }
            break;

            case VT_CY | VT_VECTOR:
            {
                _eNumType = eRawNumber;
                CVirtualString vString( 0x200 );
                vString.StrCat( outputFormat.GetCurrencyVectorPrefix() );

                for ( unsigned iValue=0;
                      iValue<_variant.cacy.cElems;
                      iValue++ )
                {
                    if ( 0 != iValue )
                        vString.StrCat( outputFormat.GetCurrencyVectorSeparator() );

                    // Big enough for a 1e308 + 9 decimal places + sign
                    WCHAR awc[maxFloatSize];

                    double dblValue;
                    VarR8FromCy( _variant.cacy.pElems[iValue], &dblValue );

                    _cwcRAWValue = swprintf( awc, L"%lf", dblValue );

                    vString.StrCat( awc, _cwcRAWValue );
                }

                vString.StrCat( outputFormat.GetCurrencyVectorSuffix() );

                _wcsRAWValue = vString.StrDup();
                _cwcRAWValue = vString.StrLen();
            }
            break;

            default:
            {
                if ( VT_ARRAY & _variant.vt )
                {
                    VARTYPE vt = _variant.vt & ~VT_ARRAY;

                    if ( VT_I1    == vt || VT_UI1     == vt ||
                         VT_I2    == vt || VT_UI2     == vt ||
                         VT_I4    == vt || VT_UI4     == vt ||
                         VT_INT   == vt || VT_UINT    == vt ||
                         VT_I8    == vt || VT_UI8     == vt ||
                         VT_R4    == vt || VT_R8      == vt ||
                         VT_CY    == vt || VT_DECIMAL == vt ||
                         VT_ERROR == vt )
                        _eNumType = eRawNumber;

                    CVirtualString vString( 0x200 );

                    RenderSafeArray( vt,
                                     _variant.parray,
                                     outputFormat,
                                     vString,
                                     FALSE );
                    _wcsRAWValue = vString.StrDup();
                    _cwcRAWValue = vString.StrLen();
                }
                else
                {
                    _wcsRAWValue  = _wcsNumberValue;
                    *_wcsRAWValue = 0;
                    _cwcRAWValue  = 0;

                    ciGibDebugOut(( DEB_WARN,
                                    "Type %u not supported in out column",
                                    _variant.vt ));
                }
            }
            break;
        }
    }

#if (DBG == 1)
    if ( _wcsRAWValue != 0 )
    {
        Win4Assert( wcslen(_wcsRAWValue) == _cwcRAWValue );
    }
#endif // DBG == 1

    Win4Assert( !(_wcsRAWValue == 0 && _cwcRAWValue != 0) );

    cwcValue = _cwcRAWValue;
    return _wcsRAWValue;
}

//+---------------------------------------------------------------------------
//
//  Member:     CVariable::DupStringValue - public
//
//  Synopsis:   Makes a copy of the string value of this variable
//
//  Returns:    A pointer to a string representation of the variable's value.
//
//  History:    96/Mar/07   DwightKr    Created.
//
//----------------------------------------------------------------------------
WCHAR * CVariable::DupStringValue( COutputFormat & outputFormat )
{
    ULONG cwcValue;
    WCHAR * wcsValue = GetStringValueRAW( outputFormat, cwcValue );

    WCHAR * wcsCopyOfValue = new WCHAR[ cwcValue + 1 ];
    RtlCopyMemory( wcsCopyOfValue,
                   wcsValue,
                   (cwcValue+1) * sizeof(WCHAR) );

    return wcsCopyOfValue;
}


//+---------------------------------------------------------------------------
//
//  Member:     CVariable::IsDirectlyComparable - public
//
//  Synopsis:   Not all VT types are are numbers.  This is useful when
//              attempting to compare different VT_TYPES.
//
//  Returns:    TRUE if the variable can be represented as a number, FALSE
//              for strings, blobs, etc.
//
//  History:    96/Jan/03   DwightKr    Created.
//
//----------------------------------------------------------------------------
BOOL CVariable::IsDirectlyComparable() const
{
    switch ( _variant.vt & ( ~VT_VECTOR ) )
    {
    case VT_UI1:
    case VT_I1:
    case VT_UI2:
    case VT_I2:
    case VT_UI4:
    case VT_I4:
    case VT_UINT:
    case VT_INT:
    case VT_R4:
    case VT_R8:
    case VT_I8:
    case VT_UI8:
    case VT_BOOL:
    case VT_CY:
    case VT_DATE:
    case VT_FILETIME:
    case VT_DECIMAL:
        return TRUE;
    }

    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CVariableSet::SetVariable - public
//
//  Synopsis:   A assignment operator; allows the value of a variable to
//              be changed.
//
//  Arguments:  [wcsName]        - the variable name
//              [pVariant]       - new value for this variable
//              [ulCreateFlags]  - and flags associated with this variable;
//                                 such as requiring an IRowsetScroll
//
//  History:    96/Jan/03   DwightKr    Created.
//              96/Apr/11   DwightKr    Set back link
//
//----------------------------------------------------------------------------
CVariable * CVariableSet::SetVariable( WCHAR const * wcsName,
                                       PROPVARIANT const * pVariant,
                                       ULONG ulCreateFlags )
{
    Win4Assert( 0 != wcsName );

    ULONG ulHash = ISAPIVariableNameHash( wcsName );
    CVariable *pVariable = Find(wcsName, ulHash);

    if ( 0 != pVariable )
    {
        pVariable->SetValue( pVariant, ulCreateFlags );
    }
    else
    {
        pVariable = new CVariable( wcsName,
                                   pVariant,
                                   ulCreateFlags );

        pVariable->SetNext( _variableSet[ ulHash ] );
        if ( 0 != pVariable->GetNext() )
        {
            pVariable->GetNext()->SetBack( pVariable );
        }

        _variableSet[ ulHash ] = pVariable;
    }

    return pVariable;
}


//+---------------------------------------------------------------------------
//
//  Member:     CVariableSet::CopyStringValue - public
//
//  Synopsis:   A assignment operator; allows the value of a variable to
//              be changed.
//
//  Arguments:  [wcsName]        - the variable name
//              [wcsValue]       - value of the variable
//              [ulCreateFlags]  - and flags associated with this variable;
//                                 such as requiring an IRowsetScroll
//              [cwcValue]       - # of chars in wcsValue or 0 if unknown
//
//  History:    96/Jan/03   DwightKr    Created.
//
//----------------------------------------------------------------------------
void CVariableSet::CopyStringValue( WCHAR const * wcsName,
                                    WCHAR const * wcsValue,
                                    ULONG         ulCreateFlags,
                                    ULONG         cwcValue )
{
    Win4Assert( 0 != wcsName );
    Win4Assert( 0 != wcsValue );

    if ( 0 == cwcValue )
        cwcValue = wcslen( wcsValue );

    cwcValue++;

    XArray<WCHAR> wcsCopyOfValue( cwcValue );
    RtlCopyMemory( wcsCopyOfValue.Get(), wcsValue, cwcValue * sizeof(WCHAR) );

    PROPVARIANT propVariant;
    propVariant.vt      = VT_LPWSTR;
    propVariant.pwszVal = wcsCopyOfValue.Get();

    SetVariable( wcsName, &propVariant, ulCreateFlags | eParamOwnsVariantMemory );

    wcsCopyOfValue.Acquire();
}


//+---------------------------------------------------------------------------
//
//  Member:     CVariableSet::AcquireStringValue - public
//
//  Synopsis:   A assignment operator; allows the value of a variable to
//              be changed. Ownership of wcsValue is transferred.
//
//  Arguments:  [wcsName]        - the variable name
//              [wcsValue]       - value of this variable
//              [ulCreateFlags]  - and flags associated with this variable;
//
//  History:    96/Jan/03   DwightKr    Created.
//
//----------------------------------------------------------------------------
void CVariableSet::AcquireStringValue( WCHAR const * wcsName,
                                       WCHAR * wcsValue,
                                       ULONG ulCreateFlags )
{
    Win4Assert( 0 != wcsName );
    Win4Assert( 0 != wcsValue );

    PROPVARIANT propVariant;
    propVariant.vt      = VT_LPWSTR;
    propVariant.pwszVal = wcsValue;

    SetVariable( wcsName, &propVariant, ulCreateFlags | eParamOwnsVariantMemory );
}


void CVariableSet::SetVariable( WCHAR const *   wcsName,
                                XArray<WCHAR> & xValue )
{
    Win4Assert( 0 != wcsName );
    Win4Assert( 0 != xValue.Get() );

    PROPVARIANT propVariant;
    propVariant.vt      = VT_LPWSTR;
    propVariant.pwszVal = xValue.Get();

    SetVariable( wcsName, &propVariant, eParamOwnsVariantMemory );

    xValue.Acquire();
}


//+---------------------------------------------------------------------------
//
//  Member:     CVariableSet::AddVariableSet - public
//
//  Synopsis:   Adds all variables in the variableSet to this variableSet.
//
//  Arguments:  [variableSet]  - the variableSet to add
//
//  History:    96/Jan/03   DwightKr    Created.
//
//----------------------------------------------------------------------------
void CVariableSet::AddVariableSet( CVariableSet & variableSet,
                                   COutputFormat & outputFormat )
{
    for ( CVariableSetIter iter(variableSet);
          !iter.AtEnd();
           iter.Next()
        )
    {
        CVariable * pVariable = iter.Get();

        SetVariable( pVariable->GetName(),
                     pVariable->GetValue(),
                     pVariable->GetFlags() );
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CVariableSet::CVariableSet - copy constructor
//
//  Synopsis:   makes a copy of the variableSet
//
//  Arguments:  [variableSet]  - the variableSet to copy
//
//  History:    96/Jan/03   DwightKr    Created.
//              96/Apr/11   DwightKr    Set back link
//
//----------------------------------------------------------------------------
CVariableSet::CVariableSet( const CVariableSet & variableSet )
{
    RtlZeroMemory( _variableSet, sizeof _variableSet );

    for ( CVariableSetIter iter(variableSet);
          !iter.AtEnd();
           iter.Next()
        )
    {
        CVariable * pVariable    = iter.Get();
        CVariable * pNewVariable = new CVariable( *pVariable );

        XPtr<CVariable> xNewVariable(pNewVariable);

        ULONG ulHash = ISAPIVariableNameHash( pNewVariable->GetName() );

        //
        //  Set NEXT & BACK pointers in the hash chain
        //
        pNewVariable->SetNext( _variableSet[ ulHash ] );
        if ( 0 != pNewVariable->GetNext() )
        {
            pNewVariable->GetNext()->SetBack( pNewVariable );
        }

        _variableSet[ ulHash ] = pNewVariable;

        xNewVariable.Acquire();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CVariableSet::GetValue - public
//
//  Synopsis:   Gets the value of the variable whose name is specified.
//
//  Arguments:  [wcsName]  - the variable name to return a value for
//
//  Returns:    PROPVARIANT * to the variable, 0 if no variable with this name.
//
//  History:    96/Jan/03   DwightKr    Created.
//
//----------------------------------------------------------------------------
PROPVARIANT * CVariableSet::GetValue( WCHAR const * wcsName ) const
{
    CVariable * pVariable = Find( wcsName );

    if ( pVariable )
        return pVariable->GetValue();
    else
        return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CVariableSet::GetStringValueRAW - public
//
//  Synopsis:   Gets the string value of the variable whose name is specified.
//
//  Arguments:  [wcsName]  - the variable name to return a value for
//
//  Returns:    WCHAR * to the variable's string representation, 0 if no
//              variable with this name.
//
//  History:    96/Jan/03   DwightKr    Created.
//
//----------------------------------------------------------------------------
WCHAR const * CVariableSet::GetStringValueRAW( WCHAR const * wcsName,
                                               ULONG ulHash,
                                               COutputFormat & outputFormat,
                                               ULONG & cwcValue )
{
    CVariable * pVariable = Find(wcsName, ulHash);

    if ( pVariable )
        return pVariable->GetStringValueRAW( outputFormat, cwcValue );
    else
        return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CVariableSet::AddExtensionControlBlock
//
//  Synopsis:   Adds QUERY_STRING or STDIN buffer to variable set
//
//  Arguments:  [webServer]  - extension control block to add to variableSet
//
//  History:    03-Jan-96   DwightKr    Created.
//              11-Jun-97   KyleP       Take codepage from web server
//              11-Sep-98   KLam        Assert that method is GET or POST
//
//----------------------------------------------------------------------------
void CVariableSet::AddExtensionControlBlock( CWebServer & webServer )
{
    //
    //  Determine if the user has passed the variables via a GET or POST
    //

    //
    //  We support only the GET and POST methods
    //

    BYTE * pszBuffer;
    ULONG  cbBuffer;

    XArray<BYTE> xTemp;

    if ( strcmp( webServer.GetMethod(), "GET" ) == 0 )
    {
        pszBuffer = (BYTE *) webServer.GetQueryString();
        cbBuffer  = strlen( (char *)pszBuffer );
    }
    else if ( strcmp( webServer.GetMethod(), "POST" ) == 0 )
    {
        pszBuffer = (BYTE *) webServer.GetClientData( cbBuffer );

        // posts aren't null terminated, and we expect them to be.

        xTemp.Init( cbBuffer + 1 );
        RtlCopyMemory( xTemp.GetPointer(), pszBuffer, cbBuffer );
        xTemp[cbBuffer] = 0;
        pszBuffer = xTemp.Get();
    }
    else
    {
        //
        // The validity of the method should have been checked before
        //
        Win4Assert ( strcmp( webServer.GetMethod(), "GET" ) == 0
                     || strcmp( webServer.GetMethod(), "POST" ) == 0);
    }

    ciGibDebugOut(( DEB_ITRACE, "QUERY_STRING = %s\n", pszBuffer ));


    // NOTE:  The pszBuffer is pointing to strings in the ECB.  We
    //        shouldn't modify these strings.
    if ( cbBuffer > 0 )
    {
        //
        //  Strip off trailing control characters, such as \n\r
        //
        while ( (cbBuffer > 0) && (pszBuffer[cbBuffer-1] <= ' ') )
        {
            cbBuffer--;
        }

        //
        //  Setup the QUERY_STRING variable in our variableSet
        //
        XArray<WCHAR> wcsQueryString;
        ULONG cwcBuffer = MultiByteToXArrayWideChar( (BYTE * const) pszBuffer,
                                                     cbBuffer + 1,
                                                     webServer.CodePage(),
                                                     wcsQueryString );

        Win4Assert( cwcBuffer != 0 && cwcBuffer <= (cbBuffer+1) );
        wcsQueryString[ cwcBuffer ] = L'\0';

        PROPVARIANT Variant;
        Variant.vt = VT_LPWSTR;
        Variant.pwszVal = wcsQueryString.Get();
        SetVariable( ISAPI_QUERY_STRING, &Variant, eParamOwnsVariantMemory );

        wcsQueryString.Acquire();
    }

    //
    //  Parse the string, which has the following format:
    //
    //
    //      attr1=Value1&attr2=value2&attr3=value+%7c+0&foo&bar
    //

    CHAR * pszToken = (CHAR *)pszBuffer;
    while ( (0 != pszToken) && (0 != *pszToken) )
    {
        //
        //  Find the value on the right hand side of the equal sign.
        //
        CHAR *pszAttribute = pszToken;
        CHAR *pszValue     = strchr( pszAttribute, '=' );

        if ( 0 != pszValue )
        {
            ULONG cchAttribute = (ULONG)(pszValue - pszAttribute);
            pszValue++;

            //
            //  Point to the next attribute.
            //
            pszToken = strchr( pszToken, '&' );

            ULONG cchValue;

            if ( 0 != pszToken )
            {
                if ( pszToken < pszValue )
                {
                    //
                    // We have a construction like foo&bar=value.  Skip the
                    // 'foo' part.
                    //
                    pszToken++;
                    continue;
                }
                cchValue = (ULONG)(pszToken - pszValue);
                pszToken++;
            }
            else
            {
                cchValue = (ULONG)((CHAR *)&pszBuffer[cbBuffer] - pszValue);
            }

            WCHAR wcsAttribute[200];
            if ( cchAttribute >= ( sizeof wcsAttribute / sizeof WCHAR ) )
                THROW( CException( DB_E_ERRORSINCOMMAND ) );

            DecodeURLEscapes( (BYTE *) pszAttribute, cchAttribute, wcsAttribute,
                              webServer.CodePage() );

            if ( 0 == cchAttribute )
                THROW( CException( DB_E_ERRORSINCOMMAND ) );

            DecodeHtmlNumeric( wcsAttribute );

            //
            // We could use Win32 for uppercasing the string, but we're looking for a fixed
            // set of attributes that are known to be in this character set.
            //

            _wcsupr( wcsAttribute );

            XArray<WCHAR> wcsValue( cchValue+2 );

            DecodeURLEscapes( (BYTE *) pszValue, cchValue, wcsValue.Get(), webServer.CodePage() );

            if ( 0 != cchValue )
            {
                DecodeHtmlNumeric( wcsValue.Get() );
            }

            ciGibDebugOut(( DEB_ITRACE, "From browser, setting %ws=%ws\n",
                                         wcsAttribute,
                                         wcsValue.Get() ));

            SetVariable( wcsAttribute, wcsValue );
        }
        else if ( 0 != pszToken )
        {
            //
            //  There was no attribute=value pair found; a lonely '&' was
            //  found.  Skip it and proceed to the next '&'.
            //
            pszToken = strchr( pszToken+1, '&' );
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     ISAPIVariableNameHash - public
//
//  Synopsis:   Generates a hash for the name specified
//
//  Arguments:  [pwcName]  - the variable name to hash
//
//  Returns:    ULONG - hash of the name
//
//  History:    96/Jan/03   DwightKr    Created.
//
//
//----------------------------------------------------------------------------
ULONG ISAPIVariableNameHash( WCHAR const * pwcName )
{
    Win4Assert( 0 != pwcName );
    WCHAR const *pwcStart = pwcName;

    ULONG ulHash = 0;

    while ( 0 != *pwcName )
    {
        ulHash <<= 1;
        ulHash += *pwcName;
        pwcName++;
    }

    ulHash <<= 1;
    ulHash += (ULONG)( pwcName - pwcStart );

    return ulHash % VARIABLESET_HASH_TABLE_SIZE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CVariableSet::~CVariableSet - public
//
//  Synopsis:   Deletes the variables in the set.
//
//  History:    96/Apr/03   dlee    Created.
//
//
//----------------------------------------------------------------------------

CVariableSet::~CVariableSet()
{
    // Variables delete the next in their chain, so only delete the
    // start of each hash chain.

    for ( unsigned x = 0; x < VARIABLESET_HASH_TABLE_SIZE; x++ )
        delete _variableSet[ x ];
}

//+---------------------------------------------------------------------------
//
//  Member:     CVariableSet::Find
//
//  Synopsis:   Locates a variable in the variableSet with the given name
//
//  Arguments:  [wcsName] - name of variable to find
//              [ulHash]  - hashed value of the name
//
//  Returns:    pVariable if found, 0 otherwise
//
//  History:    96/Apr/11   DwightKr    Created.
//
//----------------------------------------------------------------------------

CVariable * CVariableSet::Find( WCHAR const * wcsName, ULONG ulHash ) const
{
    Win4Assert( ulHash == ISAPIVariableNameHash(wcsName) );

    //
    //  Walk down the chain and try to find a match
    //  Note:  Variable names have been converted to upper case before
    //         we got this far.  Hence, the case insensitive string
    //         comparison.
    //
    for ( CVariable * pVariable = _variableSet[ ulHash ];
          pVariable != 0;
          pVariable = pVariable->GetNext()
        )
    {
        Win4Assert( pVariable != 0);

        if ( wcscmp(wcsName, pVariable->GetName() ) == 0 )
        {
            return pVariable;
        }
    }

    return 0;
}


//+---------------------------------------------------------------------------
//
//  Member:     CVariableSet::Delete
//
//  Synopsis:   Deletes a single variable from a variableSet
//
//  Arguments:  [pVariable] - pointer to variable to delete
//
//  History:    96/Apr/11   DwightKr    Created.
//
//----------------------------------------------------------------------------
void CVariableSet::Delete( CVariable * pVariable )
{
    Win4Assert ( 0 != pVariable );

    ULONG ulHash = ISAPIVariableNameHash( pVariable->GetName() );
    Win4Assert( Find(pVariable->GetName(), ulHash) == pVariable );

    //
    //  If there is a variable before this one in the hash chain, set its
    //  next pointer.
    //
    if ( 0 != pVariable->GetBack() )
    {
        pVariable->GetBack()->SetNext( pVariable->GetNext() );
    }

    //
    //  If there is a variable after this one in the hash chain, set its
    //  back pointer.
    //
    if ( 0 != pVariable->GetNext() )
    {
        pVariable->GetNext()->SetBack( pVariable->GetBack() );
    }

    //
    //  Update the array
    //
    if ( _variableSet[ulHash] == pVariable )
    {
        _variableSet[ulHash] = pVariable->GetNext();
    }

    pVariable->SetNext(0);
    pVariable->SetBack(0);

    delete pVariable;
}


#if (DBG == 1)
//+---------------------------------------------------------------------------
//
//  Member:     CVariableSet::Dump
//
//  Synopsis:   Appends each of the variables to the virtual string supplied
//
//  Arguments:  [string] - string to append data to
//
//  History:    96/Jan/03   DwightKr    Created.
//
//----------------------------------------------------------------------------
void CVariableSet::Dump( CVirtualString & wcsString,
                         COutputFormat & outputFormat )
{
    for (CVariableSetIter iter(*this);
         !iter.AtEnd();
          iter.Next() )
    {
        CVariable *pVariable = iter.Get();

        wcsString.StrCat( pVariable->GetName() );

        wcsString.CharCat( L'=' );

        ULONG cwcValue;
        WCHAR * wcsValue = pVariable->GetStringValueRAW( outputFormat, cwcValue);
        wcsString.StrCat( wcsValue, cwcValue );

        wcsString.StrCat( L"<BR>\n" );
    }
}
#endif // DBG == 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\web\dll\pch.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2002.
//
//  File:       PCH.cxx
//
//  Contents:   Pre-compiled header
//
//  History:    07-Nov-95   DwightKr    Created
//
//--------------------------------------------------------------------------

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}

#include <windows.h>
#include <wininet.h>
#include <httpext.h>

#include <winperf.h>

#include <ctype.h>
#include <float.h>
#include <limits.h>
#include <malloc.h>
#include <math.h>
#include <memory.h>
#include <process.h>
#include <string.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

#include <cidebnot.h>
#include <ciexcpt.hxx>
#include <cisem.hxx>
#include <tsmem.hxx>
#include <smart.hxx>

#include <cierror.h>

#define _CAIROSTG_
#include <oleext.h>

// #define OLEDBVER 0x250      // enable ICommandTree interface
// #define deprecated          // enable IRowsetExactScroll
#include <oledb.h>
#include <cierror.h>
#include <filterr.h>
#include <dbcmdtre.hxx>
#include <vquery.hxx>
#include <query.h>
#include <ntquery.h>

#include <stgprop.h>
#include <stgvarb.hxx>
#include <restrict.hxx>

#include <oledberr.h>

//
// Debug files from
//

#include <cidebug.hxx>
#include <vqdebug.hxx>

#include <dynarray.hxx>
#include <dynstack.hxx>
#include <tgrow.hxx>
#include <funypath.hxx>
#include <thrd32.hxx>
#include <dblink.hxx>
#include <readwrit.hxx>
#include <regacc.hxx>
#include "idqreg.hxx"
#include <circq.hxx>
#include <regevent.hxx>
#include <codepage.hxx>
#include <imprsnat.hxx>
#include <compare.hxx>

#include <plist.hxx>
#include <lgplist.hxx>
#include <scanner.hxx>
#include <qlibutil.hxx>
#include <parser.hxx>
#include <fmapio.hxx>
#include <mbutil.hxx>

#include <catstate.hxx>
#include <doquery.hxx>

#include "weblang.hxx"
#include <ciregkey.hxx>
#include "tokstr.hxx"

#include "gibdebug.hxx"

#include <ciguid.hxx>
#include <ciintf.h>
#include <string.hxx>
#include <smem.hxx>
#include <cgiesc.hxx>
#include <weblcid.hxx>
#include <gibralt.hxx>
#include "secident.hxx"
#include "idq.hxx"
#include "ida.hxx"
#include <htmlchar.hxx>
#include "wqiter.hxx"
#include <pvarset.hxx>
#include "outfmt.hxx"
#include "variable.hxx"
#include "param.hxx"
#include "htx.hxx"
#include <strrest.hxx>
#include <strsort.hxx>
#include "wqitem.hxx"
#include "wqpend.hxx"
#include <idqperf.hxx>
#include "wqcache.hxx"
#include "wqlocale.hxx"
#include "idqexcpt.hxx"
#include "htxexcpt.hxx"
#include "pdbexcpt.hxx"
#include "idqmsg.h"
#include "express.hxx"
#include "xtow.hxx"
#include "errormsg.hxx"
#include <wcstoi64.hxx>
#include "varutil.hxx"
#include <hash.hxx>
#include <cphash.hxx>
#include <caturl.hxx>
#include <cpid.hxx>

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\web\dll\weblang.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1996 - 1998.
//
//  File:       WEBLANG.CXX
//
//  Contents:   Language Support
//
//  Classes:    CWebLangLocator
//
//  History:    96-Feb-29   DwightKr    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

//+-------------------------------------------------------------------------
//
//  Method:     CWebLangLocator::CWebLangLocator
//
//  Arguments:  [locale] -- current locale
//
//  History:    96-Feb-29   DwightKr    Created.
//
//--------------------------------------------------------------------------

CWebLangLocator::CWebLangLocator( LCID locale )
   : _locale( LANGIDFROMLCID(locale) ),
     _localeSys( GetSystemDefaultLangID() ),
     _fLocaleFound( FALSE ),
     _fLangFound( FALSE ),
     _fSysLangFound( FALSE )
{
    _wcsIDQErrorFile[0]         = 0;
    _wcsHTXErrorFile[0]         = 0;
    _wcsRestrictionErrorFile[0] = 0;
    _wcsDefaultErrorFile[0]     = 0;

    EnumLangEntries();
}

//+-------------------------------------------------------------------------
//
//  Method:     CWebLangLocator::EnumLangEntries, private
//
//  Synposis:   Enumerates lang subkeys
//
//  Arguments:  none
//
//  returns:    none
//
//  History:    4/23/98 mohamedn    created
//
//--------------------------------------------------------------------------

void CWebLangLocator::EnumLangEntries(void)
{
    CWin32RegAccess langKey( HKEY_LOCAL_MACHINE, wcsRegAdminLanguage );

    WCHAR           wcsSubKeyName[MAX_PATH+1];
    DWORD           cwcName = sizeof wcsSubKeyName / sizeof WCHAR;

    while ( langKey.Enum( wcsSubKeyName, cwcName ) )
    {
        CWin32RegAccess langSubKey( langKey.GetHKey() , wcsSubKeyName );

        DWORD dwLocaleId = 0;

        if ( langSubKey.Get( L"Locale", dwLocaleId ) )
        {
            GetLangInfo( dwLocaleId, langSubKey );
        }
    }
}


//+-------------------------------------------------------------------------
//
//  Method:     CWebLangLocator::GetLangInfo, private
//
//  Synposis:   Get error files if _locale matches.
//
//  Arguments:  [dwLocaleValue] -- value of locale found
//              [regLang]       -- registry lang. subkey accessor.
//
//  returns:    none
//
//  History:    4/23/98 mohamedn    created
//
//--------------------------------------------------------------------------

void CWebLangLocator::GetLangInfo(DWORD dwLocaleValue, CWin32RegAccess & regLang)
{
    if ( _fLocaleFound )
        return;

    //
    // Temporary state
    //

    BOOL fLocaleFound  = _fLocaleFound;
    BOOL fLangFound    = _fLangFound;
    BOOL fSysLangFound = _fSysLangFound;

    DWORD dwLocale = LANGIDFROMLCID( dwLocaleValue );
    BOOL fFetch = FALSE;

    if ( dwLocale == _locale )
    {
        fFetch = TRUE;
        fLocaleFound = TRUE;
    }
    else if ( !fLangFound && PrimaryLangsMatch( dwLocale, _locale ) )
    {
        fFetch = TRUE;
        fLangFound = TRUE;
    }
    else if ( !fLangFound && !fSysLangFound && (dwLocale == _localeSys) )
    {
        fFetch = TRUE;
        fSysLangFound = TRUE;
    }

    if ( fFetch )
    {
        BOOL fRetVal = FALSE;

        fRetVal = regLang.Get( L"ISAPIIDQErrorFile", _wcsIDQErrorFile,
                           sizeof(_wcsIDQErrorFile) / sizeof (WCHAR) );

        if ( fRetVal )
        {
            fRetVal = regLang.Get( L"ISAPIHTXErrorFile", _wcsHTXErrorFile,
                         sizeof(_wcsHTXErrorFile) / sizeof(WCHAR) );
        }

        if ( fRetVal )
        {
            fRetVal = regLang.Get( L"ISAPIRestrictionErrorFile", _wcsRestrictionErrorFile,
                         sizeof(_wcsRestrictionErrorFile) / sizeof(WCHAR) );
        }

        if ( fRetVal )
        {
            fRetVal = regLang.Get( L"ISAPIDefaultErrorFile", _wcsDefaultErrorFile,
                         sizeof(_wcsDefaultErrorFile) / sizeof(WCHAR) );
        }

        //
        // if we fail to retrieve error files, don't update internal state.
        //
        if ( !fRetVal )
        {
            ciGibDebugOut(( DEB_ERROR, "CWebLangLocator::GetLangInfo() Failed\n" ));

            return;
        }
    }

    //
    // Make sure this is done *after* the fetch, which can fail.
    //

    _fLocaleFound = fLocaleFound;
    _fLangFound = fLangFound;
    _fSysLangFound = fSysLangFound;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\web\dll\varutil.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1996-1997, Microsoft Corporation.
//
//  File:       varutil.cxx
//
//  Contents:   Utilities for variable replacement
//
//  History:    96/Jan/3    DwightKr    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop


//+---------------------------------------------------------------------------
//
//  Function:   IsAReplaceableParameter, public
//
//  Synopsis:   Determines whether parameter replacement needs to be done
//              on a string.
//
//  Arguments:  [wcsString] - string to perform replacement on
//
//  Returns:    eIsSimpleString       - if no replacement needs to be done
//              eIsSimpleReplacement  - if it's a simple string substitution
//              eIsComplexReplacement - it's more complex than simple subst.
//
//  History:    96-Apr-04   AlanW     Created
//
//----------------------------------------------------------------------------

EIsReplaceable IsAReplaceableParameter( WCHAR const * wcsString )
{
    if ( wcsString == 0 || *wcsString == 0 )
        return eIsSimpleString;

    BOOL fStartWithPercent = *wcsString == L'%';
    wcsString++;

    while ( *wcsString )
    {
        if ( *wcsString == L'%' )
        {
            if ( !fStartWithPercent ||
                 wcsString[1] != L'\0' )
                return eIsComplexReplacement;
            else
                return eIsSimpleReplacement;
        }
        if ( fStartWithPercent && iswspace( *wcsString ) )
            break;

        wcsString++;
    }

    return fStartWithPercent ? eIsComplexReplacement : eIsSimpleString;
}


//+---------------------------------------------------------------------------
//
//  Function:   ReplaceNumericParameter, public
//
//  Synopsis:   Returns the value of a numeric parameter.
//
//  Arguments:  [wcsVariableString] - string to perform replacement on
//              [variableSet]       - list of replaceable parameters
//              [outputFormat]      - format of numbers & dates
//              [defaultVal]        - default value for result
//              [minVal]            - minumum value for result
//              [maxVal]            - maxumum value for result
//
//  Returns:    ULONG - parameter value
//
//  History:    96-Apr-04   AlanW     Created
//
//----------------------------------------------------------------------------

ULONG ReplaceNumericParameter( WCHAR const * wcsVariableString,
                               CVariableSet & variableSet,
                               COutputFormat & outputFormat,
                               ULONG defaultVal,
                               ULONG minVal,
                               ULONG maxVal )
{
    ULONG ulValue = defaultVal;

    if ( 0 == wcsVariableString )
        ulValue = defaultVal;
    else if ( IsAReplaceableParameter( wcsVariableString ) == eIsSimpleString )
        ulValue = wcstoul( wcsVariableString, 0, 10 );
    else
    {
        ULONG cchValue;
        XPtrST<WCHAR> xStr( ReplaceParameters( wcsVariableString,
                                               variableSet,
                                               outputFormat,
                                               cchValue ) );

        if ( cchValue > 0 )
            ulValue = wcstoul( xStr.GetPointer(), 0, 10 );
    }

    ulValue = min( max( minVal, ulValue ), maxVal );

    return ulValue;
}

//+---------------------------------------------------------------------------
//
//  Function:   ReplaceParameters - public
//
//  Synopsis:   Generates a new string, replacing the replaceable
//              parameters with their current values
//
//  Arguments:  [wcsVariableString] - string to perform replacement on
//              [variableSet]       - list of replaceable parameters
//              [outputFormat]      - format of numbers & dates
//              [cwcOut]            - returns length of returned string
//
//  Returns:    WCHAR * new string
//
//  History:    96-Feb-14   DwightKr    Created
//              96-Apr-04   AlanW       Added simple string substitution
//
//----------------------------------------------------------------------------

WCHAR * ReplaceParameters( WCHAR const * wcsVariableString,
                           CVariableSet & variableSet,
                           COutputFormat & outputFormat,
                           ULONG & cwcOut )
{
    if ( 0 == wcsVariableString )
    {
        cwcOut = 0;
        return 0;
    }

    switch ( IsAReplaceableParameter( wcsVariableString ) )
    {
    case eIsSimpleString:
        {
            ULONG cwcString   = wcslen( wcsVariableString ) + 1;
            WCHAR * wcsString = new WCHAR[ cwcString ];
            RtlCopyMemory( wcsString,
                           wcsVariableString,
                           cwcString * sizeof(WCHAR) );

            cwcOut = cwcString - 1;
            return wcsString;
        }

    case eIsSimpleReplacement:
        {
            ULONG cwcString = wcslen ( wcsVariableString );
            Win4Assert( wcsVariableString[0] == L'%' &&
                        wcsVariableString[cwcString-1] == L'%' );

            XPtrST<WCHAR> xStr( new WCHAR[ cwcString+1 ] );
            RtlCopyMemory( xStr.GetPointer(),
                           wcsVariableString,
                           cwcString * sizeof(WCHAR) );
            xStr.GetPointer()[ cwcString ] = L'\0';
            //
            // Null out '%' at end of variable name
            //
            xStr.GetPointer()[ cwcString-1 ] = L'\0';

            _wcsupr( xStr.GetPointer() );       // var. lookup requires upper case
            ULONG cwcValue = 0;
            WCHAR const * wcsValue =
                    variableSet.GetStringValueRAW( xStr.GetPointer()+1,
                                 ISAPIVariableNameHash( xStr.GetPointer()+1 ),
                                                   outputFormat,
                                                   cwcValue );

            if ( 0 != wcsValue )
            {
                if (cwcValue > cwcString )
                {
                    // Realloc string buffer for value replacement
                    delete xStr.Acquire();
                    xStr.Set( new WCHAR[ cwcValue+1 ] );
                }

                RtlCopyMemory( xStr.GetPointer(),
                               wcsValue,
                               cwcValue * sizeof(WCHAR) );
                xStr.GetPointer()[ cwcValue ] = L'\0';
                cwcOut = cwcValue;
            }
            else
            {
                //
                //  Restore '%' at end of variable name
                //
                xStr.GetPointer()[ cwcString-1 ] = wcsVariableString[ cwcString-1 ];
                cwcOut = cwcString;
            }
            ciGibDebugOut(( DEB_ITRACE, "Adding %ws as a simple replaceable parameter\n",
                                        xStr.GetPointer() ));
            return xStr.Acquire();
        }

    case eIsComplexReplacement:
        {
            CParameterReplacer varReplacer( wcsVariableString,
                                            L"%",
                                            L"%" );

            varReplacer.ParseString( variableSet );

            CVirtualString wcsVirtualString;
            varReplacer.ReplaceParams( wcsVirtualString,
                                       variableSet,
                                       outputFormat );

            ciGibDebugOut(( DEB_ITRACE, "Adding %ws as a complex replaceable parameter\n",
                                        wcsVirtualString.Get() ));

            cwcOut = wcsVirtualString.StrLen();
            return wcsVirtualString.StrDup();
        }

    default:
        Win4Assert( !"Bad return from IsAReplaceableParameter" );
        return 0;
    }
}

//
// The path given for the catalog should leave room for \Catalog.Wci\8.3
// Leave room for 2 8.3 names with a backslash.
//
const ULONG MAX_CAT_PATH = MAX_PATH - 13*2;

//+---------------------------------------------------------------------------
//
//  Member:     IsAValidCatalog
//
//  Synopsis:   Determines if the catalog specified is valid.
//
//  Arguments:  [wcsCatalog]  - path to catalog or the catalog name
//              [cwc]         - length of the string
//
//  History:    96-Mar-25   DwightKr    Created
//
//----------------------------------------------------------------------------

BOOL IsAValidCatalog(
    WCHAR const * wcsCatalog,
    ULONG         cwc )
{
    if ( cwc >= MAX_CAT_PATH ||
         0 == cwc )
    {
        ciGibDebugOut(( DEB_ERROR, "length invalid for catalog (%ws)\n",
                        wcsCatalog ));
        return FALSE;
    }

    // Can't do additional checking since:
    //   1) if the machine is remote, the catalog path is meaningless
    //   2) it's probably a catalog name, not a path anyway

    return TRUE;
} //IsAValidCatalog

//+---------------------------------------------------------------------------
//
//  Function:   IDQ_wtol
//
//  Synopsis:   Super-strict long parser, inspired by Mihai
//
//  Arguments:  [pwcBuf]  -  the string containing the long
//
//  History:    96-Jun-7   dlee    Created
//
//----------------------------------------------------------------------------

LONG IDQ_wtol( WCHAR const * pwcBuf )
{
    WCHAR *pwcEnd = (WCHAR *) pwcBuf;

    LONG l = wcstol( pwcBuf, &pwcEnd, 10 );

    if ( pwcEnd == pwcBuf )
        THROW( CException( STATUS_INVALID_PARAMETER ) );

    while ( iswspace( *pwcEnd ) )
        pwcEnd++;

    if ( 0 != *pwcEnd )
        THROW( CException( STATUS_INVALID_PARAMETER ) );

    return l;
} // IDQ_wtol
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\web\dll\param.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:       param.cxx
//
//  Contents:   Used to replace variables in strings
//
//  History:    96/Jan/3    DwightKr    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop


//
//  These ISAPI variables are Ci values available on HTX generated output.
//

const WCHAR * ISAPI_CI_ADMIN_OPERATION        = L"CIADMINOPERATION";
const WCHAR * ISAPI_CI_BOOKMARK               = L"CIBOOKMARK";
const WCHAR * ISAPI_CI_BOOKMARK_SKIP_COUNT    = L"CIBOOKMARKSKIPCOUNT";
const WCHAR * ISAPI_CI_BOOL_VECTOR_PREFIX     = L"CIBOOLVECTORPREFIX";
const WCHAR * ISAPI_CI_BOOL_VECTOR_SEPARATOR  = L"CIBOOLVECTORSEPARATOR";
const WCHAR * ISAPI_CI_BOOL_VECTOR_SUFFIX     = L"CIBOOLVECTORSUFFIX";
const WCHAR * ISAPI_CI_CANONICAL_OUTPUT       = L"CICANONICALOUTPUT";
const WCHAR * ISAPI_CI_CATALOG                = L"CICATALOG";
const WCHAR * ISAPI_CI_CODEPAGE               = L"CICODEPAGE";
const char  * ISAPI_CI_CODEPAGE_A             =  "CICODEPAGE";
const WCHAR * ISAPI_CI_COLUMNS                = L"CICOLUMNS";
const WCHAR * ISAPI_CI_CONTAINS_FIRST_RECORD  = L"CICONTAINSFIRSTRECORD";
const WCHAR * ISAPI_CI_CONTAINS_LAST_RECORD   = L"CICONTAINSLASTRECORD";
const WCHAR * ISAPI_CI_CURRENCY_VECTOR_PREFIX = L"CICURRENCYVECTORPREFIX";
const WCHAR * ISAPI_CI_CURRENCY_VECTOR_SEPARATOR=L"CICURRENCYVECTORSEPARATOR";
const WCHAR * ISAPI_CI_CURRENCY_VECTOR_SUFFIX = L"CICURRENCYVECTORSUFFIX";
const WCHAR * ISAPI_CI_CURRENT_PAGE_NUMBER    = L"CICURRENTPAGENUMBER";
const WCHAR * ISAPI_CI_CURRENT_RECORD_NUMBER  = L"CICURRENTRECORDNUMBER";
const WCHAR * ISAPI_CI_DATE_VECTOR_PREFIX     = L"CIDATEVECTORPREFIX";
const WCHAR * ISAPI_CI_DATE_VECTOR_SEPARATOR  = L"CIDATEVECTORSEPARATOR";
const WCHAR * ISAPI_CI_DATE_VECTOR_SUFFIX     = L"CIDATEVECTORSUFFIX";
const WCHAR * ISAPI_CI_DIALECT                = L"CIDIALECT";
const WCHAR * ISAPI_CI_DONT_TIMEOUT           = L"CIDONTTIMEOUT";
const WCHAR * ISAPI_CI_ERROR_MESSAGE          = L"CIERRORMESSAGE";
const WCHAR * ISAPI_CI_ERROR_NUMBER           = L"CIERRORNUMBER";
const WCHAR * ISAPI_CI_FIRST_RECORD_NUMBER    = L"CIFIRSTRECORDNUMBER";
const WCHAR * ISAPI_CI_FLAGS                  = L"CIFLAGS";
const WCHAR * ISAPI_CI_FORCE_USE_CI           = L"CIFORCEUSECI";
const WCHAR * ISAPI_CI_DEFER_NONINDEXED_TRIMMING = L"CIDEFERNONINDEXEDTRIMMING";
const WCHAR * ISAPI_CI_LAST_RECORD_NUMBER     = L"CILASTRECORDNUMBER";
const WCHAR * ISAPI_CI_LOCALE                 = L"CILOCALE";
const WCHAR * ISAPI_CI_MATCHED_RECORD_COUNT   = L"CIMATCHEDRECORDCOUNT";
const WCHAR * ISAPI_CI_MAX_RECORDS_IN_RESULTSET = L"CIMAXRECORDSINRESULTSET";
const WCHAR * ISAPI_CI_MAX_RECORDS_PER_PAGE   = L"CIMAXRECORDSPERPAGE";
const WCHAR * ISAPI_CI_FIRST_ROWS_IN_RESULTSET = L"CIFIRSTROWSINRESULTSET";
const WCHAR * ISAPI_CI_NUMBER_VECTOR_PREFIX   = L"CINUMBERVECTORPREFIX";
const WCHAR * ISAPI_CI_NUMBER_VECTOR_SEPARATOR= L"CINUMBERVECTORSEPARATOR";
const WCHAR * ISAPI_CI_NUMBER_VECTOR_SUFFIX   = L"CINUMBERVECTORSUFFIX";
const WCHAR * ISAPI_CI_OUT_OF_DATE            = L"CIOUTOFDATE";
const WCHAR * ISAPI_CI_QUERY_INCOMPLETE       = L"CIQUERYINCOMPLETE";
const WCHAR * ISAPI_CI_QUERY_TIMEDOUT         = L"CIQUERYTIMEDOUT";
const WCHAR * ISAPI_CI_QUERY_DATE             = L"CIQUERYDATE";
const WCHAR * ISAPI_CI_QUERY_TIME             = L"CIQUERYTIME";
const WCHAR * ISAPI_CI_QUERY_TIMEZONE         = L"CIQUERYTIMEZONE";
const WCHAR * ISAPI_CI_RESTRICTION            = L"CIRESTRICTION";
const WCHAR * ISAPI_CI_RECORDS_NEXT_PAGE      = L"CIRECORDSNEXTPAGE";
const WCHAR * ISAPI_CI_SCOPE                  = L"CISCOPE";
const WCHAR * ISAPI_CI_SORT                   = L"CISORT";
const WCHAR * ISAPI_CI_STRING_VECTOR_PREFIX   = L"CISTRINGVECTORPREFIX";
const WCHAR * ISAPI_CI_STRING_VECTOR_SEPARATOR= L"CISTRINGVECTORSEPARATOR";
const WCHAR * ISAPI_CI_STRING_VECTOR_SUFFIX   = L"CISTRINGVECTORSUFFIX";
const WCHAR * ISAPI_CI_TEMPLATE               = L"CITEMPLATE";
const WCHAR * ISAPI_CI_TOTAL_NUMBER_PAGES     = L"CITOTALNUMBERPAGES";
const WCHAR * ISAPI_CI_VERSION_MAJOR          = L"CIVERSIONMAJOR";
const WCHAR * ISAPI_CI_VERSION_MINOR          = L"CIVERSIONMINOR";

const WCHAR * ISAPI_CI_ADMIN_INDEX_COUNT_WORDLISTS      = L"CIADMININDEXCOUNTWORDLISTS";
const WCHAR * ISAPI_CI_ADMIN_INDEX_COUNT_PERSINDEX      = L"CIADMININDEXCOUNTPERSINDEX";
const WCHAR * ISAPI_CI_ADMIN_INDEX_COUNT_QUERIES        = L"CIADMININDEXCOUNTQUERIES";
const WCHAR * ISAPI_CI_ADMIN_INDEX_COUNT_UNIQUE         = L"CIADMININDEXCOUNTUNIQUE";
const WCHAR * ISAPI_CI_ADMIN_INDEX_COUNT_FRESHTEST      = L"CIADMININDEXCOUNTDELTAS";
const WCHAR * ISAPI_CI_ADMIN_INDEX_COUNT_TOFILTER       = L"CIADMININDEXCOUNTTOFILTER";
const WCHAR * ISAPI_CI_ADMIN_INDEX_COUNT_FILTERED       = L"CIADMININDEXCOUNTFILTERED";
const WCHAR * ISAPI_CI_ADMIN_INDEX_COUNT_PENDINGSCANS   = L"CIADMININDEXCOUNTPENDINGSCANS";
const WCHAR * ISAPI_CI_ADMIN_INDEX_COUNT_TOTAL          = L"CIADMININDEXCOUNTTOTAL";
const WCHAR * ISAPI_CI_ADMIN_INDEX_SIZE                 = L"CIADMININDEXSIZE";
const WCHAR * ISAPI_CI_ADMIN_INDEX_MERGE_PROGRESS       = L"CIADMININDEXMERGEPROGRESS";
const WCHAR * ISAPI_CI_ADMIN_INDEX_STATE_SHADOWMERGE    = L"CIADMININDEXSTATESHADOWMERGE";
const WCHAR * ISAPI_CI_ADMIN_INDEX_STATE_MASTERMERGE    = L"CIADMININDEXSTATEMASTERMERGE";
const WCHAR * ISAPI_CI_ADMIN_INDEX_STATE_ANNEALINGMERGE = L"CIADMININDEXSTATEANNEALINGMERGE";
const WCHAR * ISAPI_CI_ADMIN_INDEX_STATE_SCANREQUIRED   = L"CIADMININDEXSTATESCANREQUIRED";
const WCHAR * ISAPI_CI_ADMIN_INDEX_STATE_SCANNING       = L"CIADMININDEXSTATESCANNING";
const WCHAR * ISAPI_CI_ADMIN_INDEX_STATE_RECOVERING     = L"CIADMININDEXSTATERECOVERING";

const WCHAR * ISAPI_CI_ADMIN_CACHE_HITS       = L"CIADMINCACHEHITS";
const WCHAR * ISAPI_CI_ADMIN_CACHE_MISSES     = L"CIADMINCACHEMISSES";
const WCHAR * ISAPI_CI_ADMIN_CACHE_ACTIVE     = L"CIADMINCACHEACTIVE";
const WCHAR * ISAPI_CI_ADMIN_CACHE_COUNT      = L"CIADMINCACHECOUNT";
const WCHAR * ISAPI_CI_ADMIN_CACHE_PENDING    = L"CIADMINCACHEPENDING";
const WCHAR * ISAPI_CI_ADMIN_CACHE_REJECTED   = L"CIADMINCACHEREJECTED";
const WCHAR * ISAPI_CI_ADMIN_CACHE_TOTAL      = L"CIADMINCACHETOTAL";
const WCHAR * ISAPI_CI_ADMIN_CACHE_QPM        = L"CIADMINCACHERATE";

const WCHAR * ISAPI_ALL_HTTP                  = L"ALL_HTTP";
const WCHAR * ISAPI_AUTH_TYPE                 = L"AUTH_TYPE";
const WCHAR * ISAPI_CONTENT_LENGTH            = L"CONTENT_LENGTH";
const WCHAR * ISAPI_CONTENT_TYPE              = L"CONTENT_TYPE";
const WCHAR * ISAPI_GATEWAY_INTERFACE         = L"GATEWAY_INTERFACE";
const WCHAR * ISAPI_HTTP_ACCEPT               = L"HTTP_ACCEPT";
const WCHAR * ISAPI_HTTP_ACCEPT_LANGUAGE      = L"HTTP_ACCEPT_LANGUAGE";
const WCHAR * ISAPI_HTTP_COOKIE               = L"HTTP_COOKIE";
const WCHAR * ISAPI_HTTP_CONNECTION           = L"HTTP_CONNECTION";
const WCHAR * ISAPI_HTTP_CONTENT_TYPE         = L"HTTP_CONTENT_TYPE";
const WCHAR * ISAPI_HTTP_CONTENT_LENGTH       = L"HTTP_CONTENT_LENGTH";
const WCHAR * ISAPI_HTTP_PRAGMA               = L"HTTP_PRAGMA";
const WCHAR * ISAPI_HTTP_REFERER              = L"HTTP_REFERER";
const WCHAR * ISAPI_HTTP_USER_AGENT           = L"HTTP_USER_AGENT";
const WCHAR * ISAPI_PATH_INFO                 = L"PATH_INFO";
const WCHAR * ISAPI_PATH_TRANSLATED           = L"PATH_TRANSLATED";
const WCHAR * ISAPI_QUERY_STRING              = L"QUERY_STRING";
const WCHAR * ISAPI_REMOTE_ADDR               = L"REMOTE_ADDR";
const WCHAR * ISAPI_REMOTE_HOST               = L"REMOTE_HOST";
const WCHAR * ISAPI_REMOTE_USER               = L"REMOTE_USER";
const WCHAR * ISAPI_REQUEST_METHOD            = L"REQUEST_METHOD";
const WCHAR * ISAPI_SCRIPT_NAME               = L"SCRIPT_NAME";
const WCHAR * ISAPI_SERVER_NAME               = L"SERVER_NAME";
const WCHAR * ISAPI_SERVER_PORT               = L"SERVER_PORT";
const WCHAR * ISAPI_SERVER_PROTOCOL           = L"SERVER_PROTOCOL";
const WCHAR * ISAPI_SERVER_SOFTWARE           = L"SERVER_SOFTWARE";

const struct tagCiGlobalVars aCiGlobalVars[] =
{
    { ISAPI_CI_BOOKMARK,                      VT_EMPTY,   0, 0 },
    { ISAPI_CI_BOOKMARK_SKIP_COUNT,           VT_I4,      0, 0 },
    { ISAPI_CI_CANONICAL_OUTPUT,              VT_EMPTY,   0, 0 },
    { ISAPI_CI_CATALOG,                       VT_EMPTY,   0, 0 },
    { ISAPI_CI_COLUMNS,                       VT_EMPTY,   0, 0 },
    { ISAPI_CI_CONTAINS_FIRST_RECORD,         VT_BOOL,    VARIANT_TRUE,  0 },
    { ISAPI_CI_CONTAINS_LAST_RECORD,          VT_BOOL,    VARIANT_FALSE, 0 },
    { ISAPI_CI_CURRENT_RECORD_NUMBER,         VT_I4,      0, 0 },
    { ISAPI_CI_CURRENT_PAGE_NUMBER,           VT_I4,      0, 0 },
    { ISAPI_CI_DIALECT,                       VT_UI4,     ISQLANG_V2, 0 },
    { ISAPI_CI_DONT_TIMEOUT,                  VT_LPWSTR,  0, 0 },
    { ISAPI_CI_ERROR_MESSAGE,                 VT_EMPTY,   0, 0 },
    { ISAPI_CI_ERROR_NUMBER,                  VT_I4,      0, 0 },
    { ISAPI_CI_FIRST_RECORD_NUMBER,           VT_I4,      1, 0 },
    { ISAPI_CI_FLAGS,                         VT_EMPTY,   0, 0 },
    { ISAPI_CI_FORCE_USE_CI,                  VT_EMPTY,   0, 0 },
    { ISAPI_CI_LAST_RECORD_NUMBER,            VT_UI4,     1, 0 },
    { ISAPI_CI_LOCALE,                        VT_EMPTY,   0, 0 },
    { ISAPI_CI_MATCHED_RECORD_COUNT,          VT_I4,      0, eParamRequiresNonSequentialCursor },
    { ISAPI_CI_MAX_RECORDS_IN_RESULTSET,      VT_I4,      0, 0 },
    { ISAPI_CI_MAX_RECORDS_PER_PAGE,          VT_I4,     10, 0 },
    { ISAPI_CI_FIRST_ROWS_IN_RESULTSET,       VT_I4,      0, 0 },
    { ISAPI_CI_OUT_OF_DATE,                   VT_BOOL,    VARIANT_FALSE, 0 },
    { ISAPI_CI_QUERY_INCOMPLETE,              VT_BOOL,    VARIANT_FALSE, 0 },
    { ISAPI_CI_QUERY_TIMEDOUT,                VT_BOOL,    VARIANT_FALSE, 0 },
    { ISAPI_CI_QUERY_DATE,                    VT_EMPTY,   0, 0 },
    { ISAPI_CI_QUERY_TIME,                    VT_EMPTY,   0, 0 },
    { ISAPI_CI_QUERY_TIMEZONE,                VT_EMPTY,   0, 0 },
    { ISAPI_CI_RESTRICTION,                   VT_EMPTY,   0, 0 },
    { ISAPI_CI_RECORDS_NEXT_PAGE,             VT_I4,      0, eParamRequiresNonSequentialCursor },
    { ISAPI_CI_SCOPE,                         VT_EMPTY,   0, 0 },
    { ISAPI_CI_SORT,                          VT_EMPTY,   0, 0 },
    { ISAPI_CI_TEMPLATE,                      VT_EMPTY,   0, 0 },
    { ISAPI_CI_TOTAL_NUMBER_PAGES,            VT_I4,      1, eParamRequiresNonSequentialCursor },
    { ISAPI_CI_VERSION_MAJOR,                 VT_I4,      3, 0 },
    { ISAPI_CI_VERSION_MINOR,                 VT_I4,      0, 0 },
};

const struct tagCiGlobalVars aISAPIGlobalVars[] =
{
    { ISAPI_ALL_HTTP,                         VT_LPWSTR,  0, eParamDeferredValue },
    { ISAPI_AUTH_TYPE,                        VT_LPWSTR,  0, eParamDeferredValue },
    { ISAPI_CONTENT_LENGTH,                   VT_EMPTY,   0, 0 },
    { ISAPI_CONTENT_TYPE,                     VT_EMPTY,   0, 0 },
    { ISAPI_GATEWAY_INTERFACE,                VT_LPWSTR,  0, eParamDeferredValue },
    { ISAPI_HTTP_ACCEPT,                      VT_EMPTY,   0, 0 },
    { ISAPI_HTTP_ACCEPT_LANGUAGE,             VT_EMPTY,   0, 0 },
    { ISAPI_HTTP_COOKIE,                      VT_EMPTY,   0, 0 },
    { ISAPI_HTTP_CONNECTION,                  VT_EMPTY,   0, 0 },
    { ISAPI_HTTP_CONTENT_TYPE,                VT_EMPTY,   0, 0 },
    { ISAPI_HTTP_CONTENT_LENGTH,              VT_EMPTY,   0, 0 },
    { ISAPI_HTTP_PRAGMA,                      VT_EMPTY,   0, 0 },
    { ISAPI_HTTP_REFERER,                     VT_EMPTY,   0, 0 },
    { ISAPI_HTTP_USER_AGENT,                  VT_EMPTY,   0, 0 },
    { ISAPI_PATH_INFO,                        VT_EMPTY,   0, 0 },
    { ISAPI_PATH_TRANSLATED,                  VT_EMPTY,   0, 0 },
    { ISAPI_QUERY_STRING,                     VT_EMPTY,   0, 0 },
    { ISAPI_REMOTE_ADDR,                      VT_LPWSTR,  0, eParamDeferredValue },
    { ISAPI_REMOTE_HOST,                      VT_LPWSTR,  0, eParamDeferredValue },
    { ISAPI_REMOTE_USER,                      VT_LPWSTR,  0, eParamDeferredValue },
    { ISAPI_REQUEST_METHOD,                   VT_EMPTY,   0, 0 },
    { ISAPI_SCRIPT_NAME,                      VT_LPWSTR,  0, eParamDeferredValue },
    { ISAPI_SERVER_NAME,                      VT_LPWSTR,  0, eParamDeferredValue },
    { ISAPI_SERVER_PORT,                      VT_LPWSTR,  0, eParamDeferredValue },
    { ISAPI_SERVER_PROTOCOL,                  VT_LPWSTR,  0, eParamDeferredValue },
    { ISAPI_SERVER_SOFTWARE,                  VT_LPWSTR,  0, eParamDeferredValue },
};

const unsigned cCiGlobalVars = sizeof(aCiGlobalVars) / sizeof(aCiGlobalVars[0]);
const unsigned cISAPIGlobalVars = sizeof(aISAPIGlobalVars) / sizeof(aISAPIGlobalVars[0]);

const WCHAR * aISAPI_CiParams[] =
{
    ISAPI_CI_BOOKMARK,
    ISAPI_CI_BOOKMARK_SKIP_COUNT,
    ISAPI_CI_BOOL_VECTOR_PREFIX,
    ISAPI_CI_BOOL_VECTOR_SEPARATOR,
    ISAPI_CI_BOOL_VECTOR_SUFFIX,
    ISAPI_CI_CANONICAL_OUTPUT,
    ISAPI_CI_CATALOG,
    ISAPI_CI_COLUMNS,
    ISAPI_CI_CONTAINS_FIRST_RECORD,
    ISAPI_CI_CONTAINS_LAST_RECORD,
    ISAPI_CI_CURRENCY_VECTOR_PREFIX,
    ISAPI_CI_CURRENCY_VECTOR_SEPARATOR,
    ISAPI_CI_CURRENCY_VECTOR_SUFFIX,
    ISAPI_CI_CURRENT_PAGE_NUMBER,
    ISAPI_CI_CURRENT_RECORD_NUMBER,
    ISAPI_CI_DATE_VECTOR_PREFIX,
    ISAPI_CI_DATE_VECTOR_SEPARATOR,
    ISAPI_CI_DATE_VECTOR_SUFFIX,
    ISAPI_CI_DIALECT,
    ISAPI_CI_DONT_TIMEOUT,
    ISAPI_CI_ERROR_MESSAGE,
    ISAPI_CI_FIRST_RECORD_NUMBER,
    ISAPI_CI_FORCE_USE_CI,
    ISAPI_CI_DEFER_NONINDEXED_TRIMMING,
    ISAPI_CI_FLAGS,
    ISAPI_CI_LAST_RECORD_NUMBER,
    ISAPI_CI_LOCALE,
    ISAPI_CI_MATCHED_RECORD_COUNT,
    ISAPI_CI_MAX_RECORDS_IN_RESULTSET,
    ISAPI_CI_MAX_RECORDS_PER_PAGE,
    ISAPI_CI_FIRST_ROWS_IN_RESULTSET,
    ISAPI_CI_NUMBER_VECTOR_PREFIX,
    ISAPI_CI_NUMBER_VECTOR_SEPARATOR,
    ISAPI_CI_NUMBER_VECTOR_SUFFIX,
    ISAPI_CI_OUT_OF_DATE,
    ISAPI_CI_QUERY_INCOMPLETE,
    ISAPI_CI_QUERY_DATE,
    ISAPI_CI_QUERY_TIME,
    ISAPI_CI_QUERY_TIMEZONE,
    ISAPI_CI_RESTRICTION,
    ISAPI_CI_RECORDS_NEXT_PAGE,
    ISAPI_CI_SCOPE,
    ISAPI_CI_SORT,
    ISAPI_CI_STRING_VECTOR_PREFIX,
    ISAPI_CI_STRING_VECTOR_SEPARATOR,
    ISAPI_CI_STRING_VECTOR_SUFFIX,
    ISAPI_CI_TEMPLATE,
    ISAPI_CI_TOTAL_NUMBER_PAGES,
    ISAPI_CI_VERSION_MAJOR,
    ISAPI_CI_VERSION_MINOR,

    ISAPI_ALL_HTTP,
    ISAPI_AUTH_TYPE,
    ISAPI_CONTENT_LENGTH,
    ISAPI_CONTENT_TYPE,
    ISAPI_GATEWAY_INTERFACE,
    ISAPI_HTTP_ACCEPT,
    ISAPI_HTTP_ACCEPT_LANGUAGE,
    ISAPI_HTTP_COOKIE,
    ISAPI_HTTP_CONNECTION,
    ISAPI_HTTP_CONTENT_TYPE,
    ISAPI_HTTP_CONTENT_LENGTH,
    ISAPI_HTTP_PRAGMA,
    ISAPI_HTTP_REFERER,
    ISAPI_HTTP_USER_AGENT,
    ISAPI_PATH_INFO,
    ISAPI_PATH_TRANSLATED,
    ISAPI_QUERY_STRING,
    ISAPI_REMOTE_ADDR,
    ISAPI_REMOTE_HOST,
    ISAPI_REMOTE_USER,
    ISAPI_REQUEST_METHOD,
    ISAPI_SCRIPT_NAME,
    ISAPI_SERVER_NAME,
    ISAPI_SERVER_PORT,
    ISAPI_SERVER_PROTOCOL,
    ISAPI_SERVER_SOFTWARE,
};

const unsigned cISAPI_CiParams = sizeof(aISAPI_CiParams) / sizeof(aISAPI_CiParams[0]);


extern const CDbColId dbColIdVirtualPath;

//+---------------------------------------------------------------------------
//
//  Member:     CParameterNode::~CParameterNode - public destructor
//
//  Synopsis:   Deletes all nodes attached to this one
//
//  History:    96/Jan/03   DwightKr    Created.
//
//----------------------------------------------------------------------------
CParameterNode::~CParameterNode()
{
    if ( 0 != _pTrueNode )
    {
        _pTrueNode->DecrementRefCount();
        if ( 0 == _pTrueNode->GetRefCount() )
        {
            delete _pTrueNode;
        }
    }

    if ( 0 != _pFalseNode )
    {
        _pFalseNode->DecrementRefCount();
        if ( 0 == _pFalseNode->GetRefCount() )
        {
            delete _pFalseNode;
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CParameterNodeIter::CParameterNodeIter - public constructor
//
//  Synopsis:   Iteraties over a CParameterNode tree
//
//  Arguments:  [pNode]       - root of the tree to iterate over
//              [variableSet] - a list of replaceable parameters
//
//  History:    96/Jan/03   DwightKr    Created.
//
//----------------------------------------------------------------------------
CParameterNodeIter::CParameterNodeIter( CParameterNode *pNode,
                                        CVariableSet & variableSet,
                                        COutputFormat & outputFormat ) :
                                        _root( pNode ),
                                        _variableSet(variableSet),
                                        _outputFormat(outputFormat)
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CParameterNodeIter::EvaluateExpression - private
//
//  Synopsis:   Evaluates an IF expression
//
//  Arguments:  [wcsCondition] - the string containing the condition to
//                               evaluate
//
//  History:    96/Jan/03   DwightKr    Created.
//
//----------------------------------------------------------------------------
BOOL CParameterNodeIter::EvaluateExpression( WCHAR const * wcsCondition )
{
    CTokenizeString scanner( wcsCondition );
    CHTXIfExpression ifExpression( scanner, _variableSet, _outputFormat );

    return ifExpression.Evaluate();
}


//+---------------------------------------------------------------------------
//
//  Member:     CParameterReplacer - public constructor
//
//  Synopsis:   Initializes the variableSet and parses the string
//
//  Arguments:  [wcsString] - the string to parse and replace parameters in
//              [wcsPrefix] - the prefix delimiting parameters
//              [wcsSuffix] - the suffix delimiting parameters
//
//  History:    96/Jan/03   DwightKr    Created.
//
//----------------------------------------------------------------------------
CParameterReplacer::CParameterReplacer( WCHAR const * wcsString,
                                        WCHAR const * wcsPrefix,
                                        WCHAR const * wcsSuffix ) :
                                        _wcsString(0),
                                        _wcsPrefix(wcsPrefix),
                                        _wcsSuffix(wcsSuffix),
                                        _ulFlags(0),
                                        _paramNode(L"Top")
{
    Win4Assert( 0 != wcsString );
    Win4Assert( 0 != wcsPrefix );
    Win4Assert( 0 != wcsSuffix );

    ULONG cwcString = wcslen(wcsString) + 1;
    _wcsString = new WCHAR[ cwcString ];
    RtlCopyMemory( _wcsString, wcsString, cwcString * sizeof(WCHAR) );
}


//+---------------------------------------------------------------------------
//
//  Member:     CParameterReplacer::ParseString - public
//
//  Arguments:  [variableSet] - the list of replaceable parameter values
//
//  Synopsis:   Parses the string and builds a tree of replaceable parameters.
//
//  History:    96/Jan/03   DwightKr    Created.
//
//----------------------------------------------------------------------------
void CParameterReplacer::ParseString( CVariableSet & variableSet )
{
    CHTXScanner scanner( variableSet, _wcsPrefix, _wcsSuffix );
    scanner.Init( _wcsString );

    CDynStackInPlace<ULONG> ifStack;
    BuildTree( scanner, &_paramNode, ifStack );

    if ( ifStack.Count() != 0 )
    {
        THROW( CHTXException(MSG_CI_HTX_EXPECTING_ELSE_ENDIF, 0, 0) );
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CParameterReplacer::ReplaceParams - public
//
//  Synopsis:   Generates a new string replacing all %values% in the original
//              string
//
//  Arguments:  [StrResult]   - a safe string to append the new params to
//              [variableSet] - the list of replaceable parameter values
//
//  Notes:      If expressions are handled in the parameter node iterator.
//
//  History:    96/Jan/03   DwightKr    Created.
//
//----------------------------------------------------------------------------
void CParameterReplacer::ReplaceParams( CVirtualString & StrResult,
                                        CVariableSet & variableSet,
                                        COutputFormat & outputFormat )
{
    BOOL fIsIDQ = ( L'%' == _wcsPrefix[0] );

    for ( CParameterNodeIter iter(&_paramNode, variableSet, outputFormat);
          !iter.AtEnd();
           iter.Next() )
    {
        CParameterNode * pNode = iter.Get();

        ULONG type = pNode->Type() & eJustParamMask;

        // Always escape variables in .idq files as RAW

        if ( ( fIsIDQ ) && ( eParameter == type ) )
        {
            type = eEscapeRAW;
        }

        switch ( type )
        {

        case eString:
            StrResult.StrCat( pNode->String(), pNode->Length() );
        break;

        case eParameter:
        case eEscapeHTML:
        {
            if (! variableSet.GetStringValueHTML( pNode->String(),
                                                  pNode->Hash(),
                                                  outputFormat,
                                                  StrResult ) )
            {
                ciGibDebugOut(( DEB_IWARN,
                                "Warning: CParameterReplacer::ReplaceParams GetStringValueHTML returned FALSE for '%ws'\n",
                                pNode->String() ));

                if ( eParameter == type )
                    StrResult.StrCat( _wcsPrefix );
                HTMLEscapeW( pNode->String(),
                             StrResult,
                             outputFormat.CodePage() );
                if ( eParameter == type )
                    StrResult.StrCat( _wcsSuffix );
            }
        }
        break;

        case eEscapeURL:
        {
            if (! variableSet.GetStringValueURL( pNode->String(),
                                                 pNode->Hash(),
                                                 outputFormat,
                                                 StrResult ) )
            {
                ciGibDebugOut(( DEB_IWARN,
                                "Warning: CParameterReplacer::ReplaceParams GetStringValueURL returned FALSE for '%ws'\n",
                                pNode->String() ));

                URLEscapeW( pNode->String(),
                            StrResult,
                            outputFormat.CodePage() );
            }
        }
        break;

        case eEscapeRAW:
        {
            ULONG cwcValue;
            WCHAR const * wcsValue = variableSet.GetStringValueRAW( pNode->String(),
                                                                    pNode->Hash(),
                                                                    outputFormat,
                                                                    cwcValue );


            if ( 0 != wcsValue )
            {
                StrResult.StrCat( wcsValue, cwcValue );
            }
            else
            {
                ciGibDebugOut(( DEB_IWARN,
                                "Warning: CParameterReplacer::ReplaceParams GetStringValueRAW returned NULL for '%ws'\n",
                                pNode->String() ));

                StrResult.StrCat( pNode->String(), pNode->Length() );
            }
        }
        break;

#if DBG==1
        case eNone :
        case eIf :
        case eElse :
        case eEndIf :
        break;

        default :
            ciGibDebugOut(( DEB_ERROR, "unexpected param type: %#x\n", type ) );
            Win4Assert( !"unexpected parameter type" );
            break;
#endif // DBG==1

        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CParameterReplacer::BuildTree - private
//
//  Synposis:   Parses the string contained in the scanner object and builds
//              a parse tree which can later be walked
//
//  Arguments:  [scanner]    - contains the string to build the tree from
//              [pBranch]    - the branch which new nodes should be attached to
//              [ifStack]    - depth of the 'if/else/endif' clauses seen thus far
//
//  History:    96/Jan/03   DwightKr    Created.
//
//----------------------------------------------------------------------------
void CParameterReplacer::BuildTree( CHTXScanner & scanner,
                                    CParameterNode *pBranch,
                                    CDynStackInPlace<ULONG> & ifStack )
{
    CParameterNode *pNode = 0;

    while ( scanner.FindNextToken() )
    {
        switch ( scanner.TokenType() & eParamMask )
        {
        case eString:
        {
            //
            //  A non-replaceable wcsString was found before any replaceable/
            //  conditional nodes.  Save the wcsString in a node;
            //
            pNode = new CParameterNode( scanner.GetToken(), eString );
            pBranch->SetNextNode( pNode );
            pBranch = pNode;

            break;
        }

        case eParameter | eParamRequiresNonSequentialCursor:
            _ulFlags |= eParamRequiresNonSequentialCursor;

            // Fall through

        case eParameter:
        {
            //
            //  We've found a replaceable node.
            //
            WCHAR * wcsParameter = scanner.GetToken();

            Win4Assert( 0 != wcsParameter );

            pNode = new CParameterNode( wcsParameter, eParameter );

            pBranch->SetNextNode( pNode );
            pBranch = pNode;

            break;
        }

        case eIf:
        {
            ifStack.Push( eIf );

            //
            //  We've found an IF node.  Build the IF and ELSE clauses upto
            //  and including the ENDIF node for this IF.
            //
            //  If there is an IF enbedded within the IF or ELSE clause,
            //  we'll recurse down to build that IF tree.
            //
            CParameterNode *pIfNode = new CParameterNode( scanner.GetToken(), eIf );
            XPtr<CParameterNode> xIfNode( pIfNode );

            CParameterNode trueNode(L"true");
            CParameterNode falseNode(L"false");

            //
            //  Build the TRUE node/clause of the IF statement
            //
            BuildTree( scanner, &trueNode, ifStack );

            //
            //  Build the FALSE node/clause of the IF statement
            //
            if ( scanner.TokenType() == eElse )
            {
                scanner.GetToken();
                BuildTree( scanner, &falseNode, ifStack );
            }

            if ( scanner.TokenType() != eEndIf )
            {
                // 'if' without matching 'else' or 'endif'
                THROW( CHTXException(MSG_CI_HTX_EXPECTING_ELSE_ENDIF, 0, 0) );
            }

            scanner.GetToken();

            //
            //  Build the TRUE and FALSE branches on the IF node and
            //  join the bottom of the TRUE and FALSE branches together
            //  to a common ENDIF node.
            //
            CParameterNode *pEndifNode = new CParameterNode( L"endif", eEndIf );
            XPtr<CParameterNode> xEndifNode( pEndifNode );

            Win4Assert( trueNode.GetNextNode() );
            trueNode.GetEndNode()->SetNextNode( pEndifNode );
            pIfNode->SetTrueNode( trueNode.QueryNextNode() );
            pEndifNode->IncrementRefCount();

            //
            //  If there is a ELSE clause to this tree, attach it's bottom
            //  node to the ENDIF node.
            //
            if ( falseNode.GetNextNode() )
            {
                falseNode.GetEndNode()->SetNextNode( pEndifNode );
                pIfNode->SetFalseNode( falseNode.QueryNextNode() );
            }
            else
            {
                pIfNode->SetFalseNode( pEndifNode );
            }

            pBranch->SetNextNode( xIfNode.Acquire() );
            pBranch = xEndifNode.Acquire();

            break;
        }

        case eElse:
        {
            if ( ifStack.Count() == 0 )
            {
                THROW( CHTXException(MSG_CI_HTX_ELSEENDIF_WITHOUT_IF, 0, 0) );
            }

            int eStackValue = ifStack.Pop();

            if ( eStackValue != eIf )
            {
                THROW( CHTXException(MSG_CI_HTX_ELSEENDIF_WITHOUT_IF, 0, 0) );
            }

            ifStack.Push( eElse );

            return;
            break;
        }

        case eEndIf:
        {
            if ( ifStack.Count() == 0 )
            {
                THROW( CHTXException(MSG_CI_HTX_ELSEENDIF_WITHOUT_IF, 0, 0) );
            }

            int eStackValue = ifStack.Pop();
            if ( (eStackValue != eIf) && (eStackValue != eElse) )
            {
                THROW( CHTXException(MSG_CI_HTX_ELSEENDIF_WITHOUT_IF, 0, 0) );
            }

            return;
            break;
        }

        case eEscapeHTML:
        {
            WCHAR * wcsParameter = scanner.GetToken();
            if ( 0 == wcsParameter )
                THROW( CException( E_INVALIDARG ) );

            pNode = new CParameterNode( wcsParameter, eEscapeHTML );

            pBranch->SetNextNode( pNode );
            pBranch = pNode;
        }
        break;

        case eEscapeURL:
        {
            WCHAR * wcsParameter = scanner.GetToken();

            pNode = new CParameterNode( wcsParameter, eEscapeURL );

            pBranch->SetNextNode( pNode );
            pBranch = pNode;
        }
        break;

        case eEscapeRAW:
        {
            WCHAR * wcsParameter = scanner.GetToken();

            pNode = new CParameterNode( wcsParameter, eEscapeRAW );

            pBranch->SetNextNode( pNode );
            pBranch = pNode;
        }
        break;

        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\web\html\issample\adovbs.inc ===
<%
'--------------------------------------------------------------------
' Microsoft ADO
'
' (c) 1996 Microsoft Corporation.  All Rights Reserved.
'
'
'
' ADO constants include file for VBScript
'
'--------------------------------------------------------------------

'---- CursorTypeEnum Values ----
Const adOpenForwardOnly = 0
Const adOpenKeyset = 1
Const adOpenDynamic = 2
Const adOpenStatic = 3

'---- CursorOptionEnum Values ----
Const adHoldRecords = &H00000100
Const adMovePrevious = &H00000200
Const adAddNew = &H01000400
Const adDelete = &H01000800
Const adUpdate = &H01008000
Const adBookmark = &H00002000
Const adApproxPosition = &H00004000
Const adUpdateBatch = &H00010000
Const adResync = &H00020000
Const adNotify = &H00040000

'---- LockTypeEnum Values ----
Const adLockReadOnly = 1
Const adLockPessimistic = 2
Const adLockOptimistic = 3
Const adLockBatchOptimistic = 4

'---- ExecuteOptionEnum Values ----
Const adRunAsync = &H00000010

'---- ObjectStateEnum Values ----
Const adStateClosed = &H00000000
Const adStateOpen = &H00000001
Const adStateConnecting = &H00000002
Const adStateExecuting = &H00000004

'---- CursorLocationEnum Values ----
Const adUseNone = 1
Const adUseServer = 2
Const adUseClient = 3
Const adUseClientBatch = 3

'---- DataTypeEnum Values ----
Const adEmpty = 0
Const adTinyInt = 16
Const adSmallInt = 2
Const adInteger = 3
Const adBigInt = 20
Const adUnsignedTinyInt = 17
Const adUnsignedSmallInt = 18
Const adUnsignedInt = 19
Const adUnsignedBigInt = 21
Const adSingle = 4
Const adDouble = 5
Const adCurrency = 6
Const adDecimal = 14
Const adNumeric = 131
Const adBoolean = 11
Const adError = 10
Const adUserDefined = 132
Const adVariant = 12
Const adIDispatch = 9
Const adIUnknown = 13
Const adGUID = 72
Const adDate = 7
Const adDBDate = 133
Const adDBTime = 134
Const adDBTimeStamp = 135
Const adBSTR = 8
Const adChar = 129
Const adVarChar = 200
Const adLongVarChar = 201
Const adWChar = 130
Const adVarWChar = 202
Const adLongVarWChar = 203
Const adBinary = 128
Const adVarBinary = 204
Const adLongVarBinary = 205

'---- FieldAttributeEnum Values ----
Const adFldMayDefer = &H00000002
Const adFldUpdatable = &H00000004
Const adFldUnknownUpdatable = &H00000008
Const adFldFixed = &H00000010
Const adFldIsNullable = &H00000020
Const adFldMayBeNull = &H00000040
Const adFldLong = &H00000080
Const adFldRowID = &H00000100
Const adFldRowVersion = &H00000200
Const adFldCacheDeferred = &H00001000

'---- EditModeEnum Values ----
Const adEditNone = &H0000
Const adEditInProgress = &H0001
Const adEditAdd = &H0002

'---- RecordStatusEnum Values ----
Const adRecOK = &H0000000
Const adRecNew = &H0000001
Const adRecModified = &H0000002
Const adRecDeleted = &H0000004
Const adRecUnmodified = &H0000008
Const adRecInvalid = &H0000010
Const adRecMultipleChanges = &H0000040
Const adRecPendingChanges = &H0000080
Const adRecCanceled = &H0000100
Const adRecCantRelease = &H0000400
Const adRecConcurrencyViolation = &H0000800
Const adRecIntegrityViolation = &H0001000
Const adRecMaxChangesExceeded = &H0002000
Const adRecObjectOpen = &H0004000
Const adRecOutOfMemory = &H0008000
Const adRecPermissionDenied = &H0010000
Const adRecSchemaViolation = &H0020000
Const adRecDBDeleted = &H0040000

'---- GetRowsOptionEnum Values ----
Const adGetRowsRest = -1

'---- PositionEnum Values ----
Const adPosUnknown = -1
Const adPosBOF = -2
Const adPosEOF = -3

'---- enum Values ----
Const adBookmarkCurrent = 0
Const adBookmarkFirst = 1
Const adBookmarkLast = 2

'---- MarshalOptionsEnum Values ----
Const adMarshalAll = 0
Const adMarshalModifiedOnly = 1

'---- AffectEnum Values ----
Const adAffectCurrent = 1
Const adAffectGroup = 2
Const adAffectAll = 3

'---- FilterGroupEnum Values ----
Const adFilterNone = 0
Const adFilterPendingRecords = 1
Const adFilterAffectedRecords = 2
Const adFilterFetchedRecords = 3
Const adFilterPredicate = 4

'---- SearchDirection Values ----
Const adSearchForward = 0
Const adSearchBackward = 1

'---- ConnectPromptEnum Values ----
Const adPromptAlways = 1
Const adPromptComplete = 2
Const adPromptCompleteRequired = 3
Const adPromptNever = 4

'---- ConnectModeEnum Values ----
Const adModeUnknown = 0
Const adModeRead = 1
Const adModeWrite = 2
Const adModeReadWrite = 3
Const adModeShareDenyRead = 4
Const adModeShareDenyWrite = 8
Const adModeShareExclusive = &Hc
Const adModeShareDenyNone = &H10

'---- IsolationLevelEnum Values ----
Const adXactUnspecified = &Hffffffff
Const adXactChaos = &H00000010
Const adXactReadUncommitted = &H00000100
Const adXactBrowse = &H00000100
Const adXactCursorStability = &H00001000
Const adXactReadCommitted = &H00001000
Const adXactRepeatableRead = &H00010000
Const adXactSerializable = &H00100000
Const adXactIsolated = &H00100000

'---- XactAttributeEnum Values ----
Const adXactCommitRetaining = &H00020000
Const adXactAbortRetaining = &H00040000

'---- PropertyAttributesEnum Values ----
Const adPropNotSupported = &H0000
Const adPropRequired = &H0001
Const adPropOptional = &H0002
Const adPropRead = &H0200
Const adPropWrite = &H0400

'---- ErrorValueEnum Values ----
Const adErrInvalidArgument = &Hbb9
Const adErrNoCurrentRecord = &Hbcd
Const adErrIllegalOperation = &Hc93
Const adErrInTransaction = &Hcae
Const adErrFeatureNotAvailable = &Hcb3
Const adErrItemNotFound = &Hcc1
Const adErrObjectInCollection = &Hd27
Const adErrObjectNotSet = &Hd5c
Const adErrDataConversion = &Hd5d
Const adErrObjectClosed = &He78
Const adErrObjectOpen = &He79
Const adErrProviderNotFound = &He7a
Const adErrBoundToCommand = &He7b
Const adErrInvalidParamInfo = &He7c
Const adErrInvalidConnection = &He7d
Const adErrStillExecuting = &He7f
Const adErrStillConnecting = &He81

'---- ParameterAttributesEnum Values ----
Const adParamSigned = &H0010
Const adParamNullable = &H0040
Const adParamLong = &H0080

'---- ParameterDirectionEnum Values ----
Const adParamUnknown = &H0000
Const adParamInput = &H0001
Const adParamOutput = &H0002
Const adParamInputOutput = &H0003
Const adParamReturnValue = &H0004

'---- CommandTypeEnum Values ----
Const adCmdUnknown = &H0008
Const adCmdText = &H0001
Const adCmdTable = &H0002
Const adCmdStoredProc = &H0004

'---- SchemaEnum Values ----
Const adSchemaProviderSpecific = -1
Const adSchemaAsserts = 0
Const adSchemaCatalogs = 1
Const adSchemaCharacterSets = 2
Const adSchemaCollations = 3
Const adSchemaColumns = 4
Const adSchemaCheckConstraints = 5
Const adSchemaConstraintColumnUsage = 6
Const adSchemaConstraintTableUsage = 7
Const adSchemaKeyColumnUsage = 8
Const adSchemaReferentialContraints = 9
Const adSchemaTableConstraints = 10
Const adSchemaColumnsDomainUsage = 11
Const adSchemaIndexes = 12
Const adSchemaColumnPrivileges = 13
Const adSchemaTablePrivileges = 14
Const adSchemaUsagePrivileges = 15
Const adSchemaProcedures = 16
Const adSchemaSchemata = 17
Const adSchemaSQLLanguages = 18
Const adSchemaStatistics = 19
Const adSchemaTables = 20
Const adSchemaTranslations = 21
Const adSchemaProviderTypes = 22
Const adSchemaViews = 23
Const adSchemaViewColumnUsage = 24
Const adSchemaViewTableUsage = 25
Const adSchemaProcedureParameters = 26
Const adSchemaForeignKeys = 27
Const adSchemaPrimaryKeys = 28
Const adSchemaProcedureColumns = 29
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\web\html\issample\is2foot.inc ===
<!-- STANDARD MICROSOFT FOOTER FOR QUERY PAGES -->

<hr width=500 align=left>
<p>
<table border="0" cellpadding="0" cellspacing="0" width="500">
    <tr>
        <!-- IIS GIF -->
       <td>
            <a href="http://www.microsoft.com/windows2000"><img src="win2k.gif" alt="Learn more about Microsoft Windows 2000!"  border="0"></a>
        </td>

        <!-- Microsoft Legal Info -->
        <td align=center>
            <font style="font:arial; font-size: 8pt"> &copy;1997-1999 Microsoft Corporation. All rights reserved.<br></font>
            <a href="http://www.microsoft.com/misc/cpyright.htm"><font style="font:arial; font-size: 6pt">Legal Notices.</font></a>
       </td>

        <!-- Best with IE GIF -->
        <td align=right>
            <a href="http://www.microsoft.com/ie"><img src="IE.GIF" alt="Download Internet Explorer!"  border="0"></a>
        </td>
    </tr>
</table>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\web\dll\wqitem.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:       wqitem.cxx
//
//  Contents:   WEB Query item class
//
//  History:    96/Jan/3    DwightKr    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <params.hxx>

static const DBID dbcolNull = { {0,0,0,{0,0,0,0,0,0,0,0}},DBKIND_GUID_PROPID,0};

static const GUID guidQueryExt = DBPROPSET_QUERYEXT;
static const GUID guidRowsetProps = DBPROPSET_ROWSET;

static const DBID dbidVirtualPath = { QueryGuid, DBKIND_GUID_PROPID, (LPWSTR) 9 };

DBBINDING g_aDbBinding[ MAX_QUERY_COLUMNS ];


//+---------------------------------------------------------------------------
//
//  Member:     CWQueryItem::CWQueryItem - public constructor
//
//  Arguments:  [idqFile]            - IDQ file corresponding to this query
//              [htxFile]            - HTX file corresponding to this query
//              [wcsColumns]         - string representation of output columns
//              [dbColumns]          - OLE-DB column representation of output
//              [avarColumns]        - Variables from [dbColumns]. Same order.
//              [ulSequenceNumber]   - sequence # to assign this query
//              [lNextRecordNumber]  - # of next available record from query
//                                     results; important for reconstructing
//                                     stale sequential queries
//              [securityIdentity]   - security context of this query
//
//  Synopsis:   Builds a new query object, parses the IDQ file, and parses
//              the HTX file.
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------

CWQueryItem::CWQueryItem(CIDQFile & idqFile,
                         CHTXFile & htxFile,
                         XPtrST<WCHAR> & wcsColumns,
                         XPtr<CDbColumns> & dbColumns,
                         CDynArray<WCHAR> & awcsColumns,
                         ULONG ulSequenceNumber,
                         LONG lNextRecordNumber,
                         CSecurityIdentity securityIdentity ) :
                              _signature(CWQueryItemSignature),
                              _idqFile(idqFile),
                              _htxFile(htxFile),
                              _ulSequenceNumber(ulSequenceNumber),
                              _refCount(0),
                              _fIsZombie(FALSE),
                              _fInCache(FALSE),
                              _fCanCache(TRUE),
                              _locale(InvalidLCID),
                              _wcsRestriction(0),
                              _wcsDialect(0),
                              _ulDialect(0),
                              _wcsSort(0),
                              _wcsScope(0),
                              _wcsCatalog(0),
                              _wcsCiFlags(0),
                              _wcsForceUseCI(0),
                              _wcsDeferTrimming(0),
                              _wcsColumns(wcsColumns.Acquire()),
                              _wcsQueryTimeZone(0),
                              _pDbColumns(dbColumns.Acquire()),
                              _awcsColumns( awcsColumns ),
                              _pIRowset(0),
                              _pIAccessor(0),
                              _pIRowsetStatus(0),
                              _pICommand(0),
                              _lNextRecordNumber(lNextRecordNumber),
                              _cFilteredDocuments(0),
                              _securityIdentity(securityIdentity)
{
    time ( &_lastAccessTime );
}

//+---------------------------------------------------------------------------
//
//  Member:     CWQueryItem::~CWQueryItem - public destructor
//
//  Synopsis:   Releases storage and interfaces.
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------

CWQueryItem::~CWQueryItem()
{
    Win4Assert( _refCount == 0 );

    delete _wcsRestriction;
    delete _wcsDialect;
    delete _wcsSort;
    delete _wcsScope;
    delete _wcsCatalog;
    delete _wcsColumns;
    delete _wcsCiFlags;
    delete _wcsForceUseCI;
    delete _wcsDeferTrimming;
    delete _wcsQueryTimeZone;
    delete _pDbColumns;

    if ( 0 != _pIAccessor )
    {
        _pIAccessor->ReleaseAccessor( _hAccessor, 0 );
        _pIAccessor->Release();
    }

    if ( 0 != _pIRowset )
    {
        _pIRowset->Release();
    }

    if ( 0 != _pIRowsetStatus )
    {
        _pIRowsetStatus->Release();
    }

    if ( 0 != _pICommand )
    {
        TheICommandCache.Release( _pICommand );
    }

    _idqFile.Release();
    _htxFile.Release();
}

//+---------------------------------------------------------------------------
//
//  Member:     CWQueryItem::ExecuteQuery - public
//
//  Synopsis:   Executes the query and builds an IRowset or IRowsetScroll
//              as necessary.
//
//  Arguments:  [variableSet]  - list of replaceable parameters
//              [outputFormat] - format of numbers & dates
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
void CWQueryItem::ExecuteQuery( CVariableSet & variableSet,
                                COutputFormat & outputFormat )
{
    Win4Assert( 0 == _pIRowset );     // Should not have executed query
    Win4Assert( 0 == _pIAccessor );

    _locale = outputFormat.GetLCID();

    //
    //  Setup the variables needed to execute this query; including:
    //
    //      CiRestriction
    //      CiMaxRecordsInResultSet
    //      CiSort
    //      CiScope
    //

    //
    //  Build the final restriction from the existing restriction string
    //  and the additional parameters passed in from the browser.
    //
    ULONG cwcOut;
    _wcsRestriction = ReplaceParameters( _idqFile.GetRestriction(),
                                         variableSet,
                                         outputFormat,
                                         cwcOut );

    variableSet.CopyStringValue( ISAPI_CI_RESTRICTION, _wcsRestriction, 0, cwcOut );
    ciGibDebugOut(( DEB_ITRACE, "Restriction = '%ws'\n", _wcsRestriction ));
    if ( 0 == *_wcsRestriction )
    {
        THROW( CIDQException(MSG_CI_IDQ_MISSING_RESTRICTION , 0) );
    }

    //
    //  Setup CiMaxRecordsInResultSet
    //
    _lMaxRecordsInResultSet =
            ReplaceNumericParameter( _idqFile.GetMaxRecordsInResultSet(),
                                     variableSet,
                                     outputFormat,
                                     TheIDQRegParams.GetMaxISRowsInResultSet(),
                                     IS_MAX_ROWS_IN_RESULT_MIN,
                                     IS_MAX_ROWS_IN_RESULT_MAX );

    PROPVARIANT propVariant;
    propVariant.vt   = VT_I4;
    propVariant.lVal = _lMaxRecordsInResultSet;
    variableSet.SetVariable( ISAPI_CI_MAX_RECORDS_IN_RESULTSET, &propVariant, 0 );
    ciGibDebugOut(( DEB_ITRACE, "CiMaxRecordsInResultSet = %d\n", _lMaxRecordsInResultSet ));

    //  Setup CiFirstRowsInResultSet
    //
    _lFirstRowsInResultSet =
            ReplaceNumericParameter( _idqFile.GetFirstRowsInResultSet(),
                                     variableSet,
                                     outputFormat,
                                     TheIDQRegParams.GetISFirstRowsInResultSet(),
                                     IS_FIRST_ROWS_IN_RESULT_MIN,
                                     IS_FIRST_ROWS_IN_RESULT_MAX );

    PROPVARIANT propVar;
    propVar.vt   = VT_I4;
    propVar.lVal = _lFirstRowsInResultSet;
    variableSet.SetVariable( ISAPI_CI_FIRST_ROWS_IN_RESULTSET, &propVar, 0 );
    ciGibDebugOut(( DEB_ITRACE, "CiFirstRowsInResultSet = %d\n", _lFirstRowsInResultSet ));


    _ulDialect =
            ReplaceNumericParameter( _idqFile.GetDialect(),
                                     variableSet,
                                     outputFormat,
                                     ISQLANG_V2,       // default
                                     ISQLANG_V1,       // min
                                     ISQLANG_V2 );     // max
    Win4Assert( 0 != _ulDialect );

    propVariant.vt   = VT_UI4;
    propVariant.ulVal = _ulDialect;
    variableSet.SetVariable( ISAPI_CI_DIALECT, &propVariant, 0 );
    ciGibDebugOut(( DEB_ITRACE, "CiDialect = %d\n", _ulDialect ));

    //
    //  Build the final sort set from the existing sortset string
    //  and the additional parameters passed in from the browser.
    //

    XPtr<CDbSortNode> xDbSortNode;

    if ( 0 != _idqFile.GetSort() )
    {
        _wcsSort = ReplaceParameters( _idqFile.GetSort(),
                                      variableSet,
                                      outputFormat,
                                      cwcOut );

        variableSet.CopyStringValue( ISAPI_CI_SORT, _wcsSort, 0, cwcOut );

        ciGibDebugOut(( DEB_ITRACE, "Sort = '%ws'\n", _wcsSort ));
        Win4Assert( 0 != _wcsSort );
    }

    //
    //  Build the projection list from the column list.
    //

    CTextToTree textToTree( _wcsRestriction,
                            _ulDialect,
                            _pDbColumns,
                            _idqFile.GetColumnMapper(),
                            _locale,
                            _wcsSort,
                            0,
                            0,
                            _lMaxRecordsInResultSet,
                            _lFirstRowsInResultSet );

    CDbCmdTreeNode * pDbCmdTree = (CDbCmdTreeNode *) (void *) textToTree.FormFullTree();
    XPtr<CDbCmdTreeNode> xDbCmdTree( pDbCmdTree );

    //
    //  Remap the scope from a replaceable parameter
    //
    _wcsScope = ReplaceParameters( _idqFile.GetScope(),
                                   variableSet,
                                   outputFormat,
                                   cwcOut );

    variableSet.CopyStringValue( ISAPI_CI_SCOPE, _wcsScope, 0, cwcOut );

    ciGibDebugOut(( DEB_ITRACE, "Scope = '%ws'\n", _wcsScope ));
    Win4Assert( 0 != _wcsScope );
    if ( 0 == *_wcsScope )
    {
        THROW( CIDQException(MSG_CI_IDQ_MISSING_SCOPE , 0) );
    }

    //
    //  Build the location of the catalog
    //
    ULONG cwcCatalog;
    Win4Assert( 0 != _idqFile.GetCatalog() );
    _wcsCatalog = ReplaceParameters( _idqFile.GetCatalog(),
                                     variableSet,
                                     outputFormat,
                                     cwcCatalog );

    variableSet.CopyStringValue( ISAPI_CI_CATALOG, _wcsCatalog, 0, cwcCatalog );

    ciGibDebugOut(( DEB_ITRACE, "Catalog = '%ws'\n", _wcsCatalog ));
    Win4Assert( 0 != _wcsCatalog );

    if ( !IsAValidCatalog( _wcsCatalog, cwcCatalog ) )
    {
        THROW( CIDQException(MSG_CI_IDQ_NO_SUCH_CATALOG, 0) );
    }

    XPtrST<WCHAR> xpCat;
    XPtrST<WCHAR> xpMach;

    if ( ( ! SUCCEEDED( ParseCatalogURL( _wcsCatalog, xpCat, xpMach ) ) ) ||
         ( xpCat.IsNull() ) )
    {
        THROW( CIDQException(MSG_CI_IDQ_NO_SUCH_CATALOG, 0) );
    }

    //
    //  Get the query flags.
    //
    ULONG cwcCiFlags;
    _wcsCiFlags = ReplaceParameters( _idqFile.GetCiFlags(),
                                     variableSet,
                                     outputFormat,
                                     cwcCiFlags );

    if ( 0 != _wcsCiFlags )
    {
        variableSet.CopyStringValue( ISAPI_CI_FLAGS, _wcsCiFlags, 0, cwcCiFlags );
    }
    ULONG ulFlags = _idqFile.ParseFlags( _wcsCiFlags );
    ciGibDebugOut(( DEB_ITRACE, "CiFlags = '%ws' (%x)\n", _wcsCiFlags, ulFlags ));

    //
    //  We've setup all the parameters to run the query.  Run the query
    //  now.
    //
    _pICommand = 0;

    //
    // Paths start out as one of:
    //     ?:\...
    //     \\....\....\
    //     /...
    //

    SCODE scIC = S_OK;

    if ( _wcsicmp( _wcsScope, L"VIRTUAL_ROOTS" ) == 0 )
    {
        _fCanCache = FALSE;
        CheckAdminSecurity( xpMach.GetPointer() );
        IUnknown * pIUnknown;
        scIC = MakeMetadataICommand( &pIUnknown,
                                     CiVirtualRoots,
                                     xpCat.GetPointer(),
                                     xpMach.GetPointer() );
        if (SUCCEEDED (scIC))
        {
           XInterface<IUnknown> xUnk( pIUnknown );
           scIC = pIUnknown->QueryInterface(IID_ICommand, (void **)&_pICommand);
        }
    }
    else if ( _wcsicmp( _wcsScope, L"PROPERTIES" ) == 0 )
    {
        _fCanCache = FALSE;
        CheckAdminSecurity( xpMach.GetPointer() );
        IUnknown * pIUnknown;
        scIC = MakeMetadataICommand( &pIUnknown,
                                     CiProperties,
                                     xpCat.GetPointer(),
                                     xpMach.GetPointer() );
        if (SUCCEEDED (scIC))
        {
           XInterface<IUnknown> xUnk( pIUnknown );
           scIC = pIUnknown->QueryInterface(IID_ICommand, (void **)&_pICommand);
        }

    }
    else
    {
        //
        // Verify that the caller has admin security for DontTimeout queries.
        //
        if ( _idqFile.IsDontTimeout() )
            CheckAdminSecurity( xpMach.GetPointer() );

        scIC = TheICommandCache.Make( &_pICommand,
                                      ulFlags,
                                      xpMach.GetPointer(),
                                      xpCat.GetPointer(),
                                      _wcsScope );

    }

    #if CIDBG == 1
        if ( FAILED( scIC ) )
            Win4Assert( 0 == _pICommand );
        else
            Win4Assert( 0 != _pICommand );
    #endif // CIDBG == 1

    if ( 0 == _pICommand )
    {
        ciGibDebugOut(( DEB_ITRACE, "Make*ICommand failed with error 0x%x\n", scIC ));

        // Make*ICommand returns SCODEs, not Win32 error codes

        Win4Assert( ERROR_FILE_NOT_FOUND != scIC );
        Win4Assert( ERROR_SEM_TIMEOUT != scIC );

        // These errors are no longer returned -- the work isn't
        // done until Execute(), and the errors are mapped to
        // the popular E_FAIL.  Leave the code in since now the
        // OLE DB spec allows the errors and we may change the provider.

        if ( ( HRESULT_FROM_WIN32( ERROR_FILE_NOT_FOUND ) == scIC ) ||
             ( HRESULT_FROM_WIN32( ERROR_SEM_TIMEOUT ) == scIC ) )
        {
            THROW( CIDQException( MSG_CI_IDQ_CISVC_NOT_RUNNING, 0 ) );
        }
        else
        {
            THROW( CIDQException( MSG_CI_IDQ_BAD_SCOPE_OR_CATALOG, 0 ) );
        }
    }

    ICommandTree * pICmdTree = 0;
    SCODE sc = _pICommand->QueryInterface( IID_ICommandTree,
                                           (void **) &pICmdTree );
    if (FAILED (sc) )
    {
        THROW( CException( QUERY_EXECUTE_FAILED ) );
    }

    DBCOMMANDTREE * pDbCommandTree = pDbCmdTree->CastToStruct();
    sc = pICmdTree->SetCommandTree(&pDbCommandTree, DBCOMMANDREUSE_NONE, FALSE);
    pICmdTree->Release();

    if ( FAILED(sc) )
    {
        THROW( CException(sc) );
    }

    xDbCmdTree.Acquire();

    //
    //  Save the time this query started execution
    //
    GetLocalTime( &_queryTime );

    //
    //  If we should NOT be using a enumerated query, notify pCommand
    //
    const unsigned MAX_PROPS = 5;
    DBPROPSET  aPropSet[MAX_PROPS];
    DBPROP     aProp[MAX_PROPS];
    ULONG      cProp = 0;

    // Set the property that says we accept PROPVARIANTs
    aProp[cProp].dwPropertyID   = DBPROP_USEEXTENDEDDBTYPES;
    aProp[cProp].dwOptions      = DBPROPOPTIONS_OPTIONAL;
    aProp[cProp].dwStatus       = 0;         // Ignored
    aProp[cProp].colid          = dbcolNull;
    aProp[cProp].vValue.vt      = VT_BOOL;
    aProp[cProp].vValue.boolVal = VARIANT_TRUE;

    aPropSet[cProp].rgProperties = &aProp[cProp];
    aPropSet[cProp].cProperties = 1;
    aPropSet[cProp].guidPropertySet = guidQueryExt;

    cProp++;

    ULONG cwc;
    _wcsForceUseCI = ReplaceParameters( _idqFile.GetForceUseCI(),
                                        variableSet,
                                        outputFormat,
                                        cwc );

    if ( 0 != _wcsForceUseCI )
    {
        variableSet.CopyStringValue( ISAPI_CI_FORCE_USE_CI, _wcsForceUseCI, 0, cwc );
    }

    BOOL fForceUseCI = _idqFile.ParseForceUseCI( _wcsForceUseCI );
    ciGibDebugOut(( DEB_ITRACE, "CiForceUseCi = '%ws'\n", _wcsForceUseCI ));

    {
        // Set the property that says we don't want to enumerate
        aProp[cProp].dwPropertyID   = DBPROP_USECONTENTINDEX;
        aProp[cProp].dwOptions      = DBPROPOPTIONS_OPTIONAL;
        aProp[cProp].dwStatus       = 0;         // Ignored
        aProp[cProp].colid          = dbcolNull;
        aProp[cProp].vValue.vt      = VT_BOOL;
        aProp[cProp].vValue.boolVal = fForceUseCI ? VARIANT_TRUE : VARIANT_FALSE;

        aPropSet[cProp].rgProperties = &aProp[cProp];
        aPropSet[cProp].cProperties = 1;
        aPropSet[cProp].guidPropertySet = guidQueryExt;

        cProp++;
    }

    PROPVARIANT Variant;
    Variant.vt   = VT_BOOL;
    Variant.boolVal = fForceUseCI ? VARIANT_TRUE : VARIANT_FALSE;
    variableSet.SetVariable( ISAPI_CI_FORCE_USE_CI, &Variant, 0 );

    _wcsDeferTrimming = ReplaceParameters( _idqFile.GetDeferTrimming(),
                                           variableSet,
                                           outputFormat,
                                           cwc );

    if ( 0 != _wcsDeferTrimming )
    {
        variableSet.CopyStringValue( ISAPI_CI_DEFER_NONINDEXED_TRIMMING, _wcsDeferTrimming, 0, cwc );
    }

    BOOL fDeferTrimming = _idqFile.ParseDeferTrimming( _wcsDeferTrimming );
    ciGibDebugOut(( DEB_ITRACE, "CiDeferNonIndexedTrimming = '%ws'\n", _wcsDeferTrimming ));

    {
        // Set the property that says we don't want to enumerate
        aProp[cProp].dwPropertyID   = DBPROP_DEFERNONINDEXEDTRIMMING;
        aProp[cProp].dwOptions      = DBPROPOPTIONS_OPTIONAL;
        aProp[cProp].dwStatus       = 0;         // Ignored
        aProp[cProp].colid          = dbcolNull;
        aProp[cProp].vValue.vt      = VT_BOOL;
        aProp[cProp].vValue.boolVal = fDeferTrimming ? VARIANT_TRUE : VARIANT_FALSE;

        aPropSet[cProp].rgProperties = &aProp[cProp];
        aPropSet[cProp].cProperties = 1;
        aPropSet[cProp].guidPropertySet = guidQueryExt;

        cProp++;
    }

    if ( _idqFile.IsDontTimeout() )
    {
        // Set the property that says we don't want to timeout
        aProp[cProp].dwPropertyID = DBPROP_COMMANDTIMEOUT;
        aProp[cProp].dwOptions    = DBPROPOPTIONS_OPTIONAL;
        aProp[cProp].dwStatus     = 0;         // Ignored
        aProp[cProp].colid        = dbcolNull;
        aProp[cProp].vValue.vt    = VT_I4;
        aProp[cProp].vValue.lVal  = 0;

        aPropSet[cProp].rgProperties = &aProp[cProp];
        aPropSet[cProp].cProperties = 1;
        aPropSet[cProp].guidPropertySet = guidRowsetProps;

        cProp++;
    }

    Win4Assert( Variant.vt == VT_BOOL );
    Variant.boolVal = fDeferTrimming ? VARIANT_TRUE : VARIANT_FALSE;
    variableSet.SetVariable( ISAPI_CI_DEFER_NONINDEXED_TRIMMING, &Variant, 0 );

    //
    //  If this is a non-Sequential query, make it asynchronous
    //
    if (! IsSequential() )
    {
        // Set the property that says we want to use asynch. queries
        aProp[cProp].dwPropertyID = DBPROP_ROWSET_ASYNCH;
        aProp[cProp].dwOptions    = DBPROPOPTIONS_OPTIONAL;
        aProp[cProp].dwStatus     = 0;         // Ignored
        aProp[cProp].colid        = dbcolNull;
        aProp[cProp].vValue.vt    = VT_I4;
        aProp[cProp].vValue.lVal  = DBPROPVAL_ASYNCH_SEQUENTIALPOPULATION |
                                    DBPROPVAL_ASYNCH_RANDOMPOPULATION;

        aPropSet[cProp].rgProperties = &aProp[cProp];
        aPropSet[cProp].cProperties = 1;
        aPropSet[cProp].guidPropertySet = guidRowsetProps;

        cProp++;
    }

    if ( cProp > 0 )
    {
        Win4Assert( cProp <= MAX_PROPS );

        ICommandProperties * pCmdProp = 0;
        sc = _pICommand->QueryInterface( IID_ICommandProperties,
                                         (void **)&pCmdProp );

        if (FAILED (sc) )
        {
            THROW( CException( QUERY_EXECUTE_FAILED ) );
        }

        sc = pCmdProp->SetProperties( cProp, aPropSet );
        pCmdProp->Release();

        if ( FAILED(sc) || DB_S_ERRORSOCCURRED == sc )
        {
            THROW( CException( QUERY_EXECUTE_FAILED ) );
        }
    }

    //
    //  Execute the query
    //

    sc = _pICommand->Execute( 0,            // No aggr
                              IsSequential() ? IID_IRowset : IID_IRowsetScroll,
                              0,            // disp params
                              0,            // # rowsets returned
                              (IUnknown **) &_pIRowset );

    if ( FAILED(sc) )
    {
        ERRORINFO ErrorInfo;
        XInterface<IErrorInfo> xErrorInfo;
        SCODE sc2 = GetOleDBErrorInfo(_pICommand,
                                   IID_ICommand,
                                   GetLocale(),
                                   eMostDetailedCIError,
                                   &ErrorInfo,
                                   (IErrorInfo **)xErrorInfo.GetQIPointer());
        // Post IErrorInfo only if we have a valid ptr to it.
        if (SUCCEEDED(sc2) && 0 != xErrorInfo.GetPointer())
        {
            sc = ErrorInfo.hrError;

            // Maybe the ICommand is stale because cisvc was stopped and
            // restarted -- purge it from the cache.

            TheICommandCache.Remove( _pICommand );
            _pICommand = 0;

            THROW( CPostedOleDBException(sc, eDefaultISAPIError, xErrorInfo.GetPointer()) );
        }
        else
        {
            // Maybe the ICommand is stale because cisvc was stopped and
            // restarted -- purge it from the cache.

            TheICommandCache.Remove( _pICommand );
            _pICommand = 0;

            THROW( CException(sc) );
        }
    }

    //
    //  Create an accessor
    //

    _pIAccessor = 0;

    sc = _pIRowset->QueryInterface( IID_IAccessor, (void **)&_pIAccessor);
    if ( FAILED( sc ) || _pIAccessor == 0 )
    {
        THROW( CException( DB_E_ERRORSOCCURRED ) );
    }

    ULONG cCols = _pDbColumns->Count();
    if ( cCols > MAX_QUERY_COLUMNS )
    {
        THROW( CException( DB_E_ERRORSOCCURRED ) );
    }

    sc = _pIAccessor->CreateAccessor( DBACCESSOR_ROWDATA,  // Type of access required
                                      cCols,               // # of bindings
                                      g_aDbBinding,        // Array of bindings
                                      0,                   // reserved
                                      &_hAccessor,
                                      0 );

    if ( FAILED( sc ) )
    {
        THROW( CException(sc) );
    }

    //
    //  Create some of the restriction specific variables.
    //

    //
    // Get _pIRowsetStatus interface
    //
    sc = _pIRowset->QueryInterface( IID_IRowsetQueryStatus,
                                    (void **) &_pIRowsetStatus );

    if ( FAILED(sc) )
    {
        THROW( CException(sc) );
    }

    Win4Assert( 0 != _pIRowsetStatus );

    //
    // Save the # of filtered documents for this catalog and get the
    // query status.
    //

    DWORD dwStatus = 0;
    DWORD cToFilter;
    DBCOUNTITEM cDen, cNum;
    DBCOUNTITEM iCur, cTotal;
    sc = _pIRowsetStatus->GetStatusEx( &dwStatus,
                                       &_cFilteredDocuments,
                                       &cToFilter,
                                       &cDen,
                                       &cNum,
                                       0,
                                       0,
                                       &iCur,
                                       &cTotal );

    if ( FAILED( sc ) )
    {
        THROW( CException(sc) );
    }

    propVariant.vt   = VT_BOOL;

    if ( QUERY_RELIABILITY_STATUS(dwStatus) &
        (STAT_CONTENT_OUT_OF_DATE | STAT_REFRESH_INCOMPLETE) )
    {
        propVariant.boolVal = VARIANT_TRUE;
        ciGibDebugOut(( DEB_ITRACE, "The query is out of date\n" ));
    }
    else
    {
        propVariant.boolVal = VARIANT_FALSE;
    }
    variableSet.SetVariable( ISAPI_CI_OUT_OF_DATE, &propVariant, 0 );

    if ( QUERY_RELIABILITY_STATUS(dwStatus) & STAT_CONTENT_QUERY_INCOMPLETE )
    {
        propVariant.boolVal = VARIANT_TRUE;
        ciGibDebugOut(( DEB_ITRACE, "The query is incomplete\n" ));
    }
    else
    {
        propVariant.boolVal = VARIANT_FALSE;
    }
    variableSet.SetVariable( ISAPI_CI_QUERY_INCOMPLETE, &propVariant, 0 );

    if ( QUERY_RELIABILITY_STATUS(dwStatus) & STAT_TIME_LIMIT_EXCEEDED )
    {
        propVariant.boolVal = VARIANT_TRUE;
        ciGibDebugOut(( DEB_ITRACE, "The query timed out\n" ));
    }
    else
    {
        propVariant.boolVal = VARIANT_FALSE;
    }
    variableSet.SetVariable( ISAPI_CI_QUERY_TIMEDOUT, &propVariant, 0 );

    //
    //  Set CiQueryTimeZone
    //
    TIME_ZONE_INFORMATION TimeZoneInformation;
    DWORD dwResult = GetTimeZoneInformation( &TimeZoneInformation );
    LPWSTR pwszTimeZoneName = 0;

    if ( TIME_ZONE_ID_DAYLIGHT == dwResult )
    {
        pwszTimeZoneName = TimeZoneInformation.DaylightName;
    }
    else if ( 0xFFFFFFFF == dwResult )
    {
#       if CIDBG == 1
           DWORD dwError = GetLastError();
           ciGibDebugOut(( DEB_ERROR, "Error %d from GetTimeZoneInformation.\n", dwError ));
           THROW(CException( HRESULT_FROM_WIN32(dwError) ));
#       else
           THROW( CException() );
#       endif
    }
    else
    {
        pwszTimeZoneName = TimeZoneInformation.StandardName;
    }

    ULONG cchQueryTimeZone = wcslen( pwszTimeZoneName );
    _wcsQueryTimeZone = new WCHAR[ cchQueryTimeZone + 1 ];
    RtlCopyMemory( _wcsQueryTimeZone,
                   pwszTimeZoneName,
                   (cchQueryTimeZone+1) * sizeof(WCHAR) );
}


//+---------------------------------------------------------------------------
//
//  Member:     CWQueryItem::GetQueryResultsIterator - private
//
//  Synopsis:   Builds a CBaseQueryResultsIter which can subsequently be used
//              to send the query results back to the web browser. All
//              per-browser data relative to the query is kept in the iterator.
//
//  Returns:    [CBaseQueryResultsIter] - a sequential or non-sequential
//              iterator depending on the paramaters requested in the HTX
//              file.
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
CBaseQueryResultsIter * CWQueryItem::GetQueryResultsIterator( COutputFormat & outputFormat )
{
    CBaseQueryResultsIter *pIter;

    //
    //  Setup the formatting for the vector types
    //

    _idqFile.GetVectorFormatting( outputFormat );

    if ( IsSequential() )
    {
        Win4Assert( _lNextRecordNumber > 0 );
        pIter = new CSeqQueryResultsIter( *this,
                                          _pIRowset,
                                          _hAccessor,
                                          _pDbColumns->Count(),
                                          _lNextRecordNumber-1 );

        ciGibDebugOut(( DEB_ITRACE, "Using a sequential iterator\n" ));
    }
    else
    {
        IRowsetScroll *pIRowsetScroll = 0;
        HRESULT sc = _pIRowset->QueryInterface(IID_IRowsetScroll, (void **) &pIRowsetScroll);

        if ( FAILED( sc )  )
        {
            THROW( CException(sc) );
        }

        XInterface<IRowsetScroll> xIRowsetScroll(pIRowsetScroll);
        pIter = new CQueryResultsIter( *this,
                                       pIRowsetScroll,
                                       _hAccessor,
                                       _pDbColumns->Count() );

        xIRowsetScroll.Acquire();

        ciGibDebugOut(( DEB_ITRACE, "Using a NON-sequential iterator\n" ));
    }

    return pIter;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWQueryItem::OutputQueryResults - public
//
//  Arguments:  [variableSet]  - list of browser-supplied replaceable parameters
//              [outputFormat] - format of numbers & dates
//              [vString]      - destination buffer for output results
//
//  Synopsis:   Using the parameters passed, build an iterator to walk the
//              query results and buffer output into the vString.
//
//  History:    18-Jan-96   DwightKr    Created
//              11-Jun-97   KyleP       Use web server from output format
//
//----------------------------------------------------------------------------

void CWQueryItem::OutputQueryResults( CVariableSet & variableSet,
                                      COutputFormat & outputFormat,
                                      CVirtualString & vString )
{
    //
    //  Build the query results iterator based on the parameters passed in.
    //

    CBaseQueryResultsIter *pIter = GetQueryResultsIterator( outputFormat );
    XPtr<CBaseQueryResultsIter> iter(pIter);

    iter->Init( variableSet, outputFormat );

    UpdateQueryStatus( variableSet );

    //
    //  Build the HTML pages in three sections:  first the header
    //  section (evenything before the <%begindetail%>), next the detail
    //  section (everything between the <%begindetail%> and <%enddetail%>),
    //  and finally the footer section (everything after the
    //  <%enddetail%> section).
    //

    //
    //  Output the header section.
    //

    _htxFile.GetHeader( vString, variableSet, outputFormat ) ;

    LONG lCurrentRecordNumber = iter->GetFirstRecordNumber();

    if ( _htxFile.DoesDetailSectionExist() )
    {
        //
        //  Output the detail section
        //
        ULONG cCols = iter->GetColumnCount();
        XArray<CVariable *> xVariables( cCols );

        for ( ULONG i=0; i<cCols; i++ )
        {
            xVariables[i] = variableSet.SetVariable( _awcsColumns.Get(i), 0, 0 );
            Win4Assert( 0 != xVariables[i] );
        }

        PROPVARIANT VariantRecordNumber;
        VariantRecordNumber.vt = VT_I4;

        CVariable * pvarRecordNumber = variableSet.SetVariable( ISAPI_CI_CURRENT_RECORD_NUMBER, 0, 0 );
        Win4Assert( 0 != pvarRecordNumber );

        //
        //  Execute the detail section for each row/record in the query results
        //
        for ( ;
             !iter->AtEnd();
              iter->Next(), lCurrentRecordNumber++ )
        {
            COutputColumn * pColumns = iter->GetRowData();

            //
            //  Update the replaceable parameters for each of the columns
            //  in this row.
            //

            for ( i = 0; i < cCols; i++ )
                xVariables[i]->FastSetValue( pColumns[i].GetVariant() );

            VariantRecordNumber.lVal = lCurrentRecordNumber;
            pvarRecordNumber->FastSetValue( &VariantRecordNumber );

            _htxFile.GetDetailSection( vString, variableSet, outputFormat );
        }

        //
        //  The query output columns are no longer defined outside of the
        //  DETAIL section.  Delete these variables here so that any reference
        //  to them will return a NULL string.
        //
        for ( i=0; i<cCols; i++ )
        {
            variableSet.Delete( xVariables[i] );
        }
    }

    //
    //  If we couldn't get the first record #, then the current page #
    //  should be set to 0.
    //

    if ( iter->GetFirstRecordNumber() == lCurrentRecordNumber )
    {
        PROPVARIANT Variant;
        Variant.vt   = VT_I4;
        Variant.lVal = 0;
        variableSet.SetVariable( ISAPI_CI_CURRENT_PAGE_NUMBER, &Variant, 0 );
    }

    //
    //  Output the footer section.
    //

    _htxFile.GetFooter( vString, variableSet, outputFormat );
}

//+---------------------------------------------------------------------------
//
//  Member:     CWQueryItem::UpdateQueryStatus - public
//
//  Synopsis:   Updates variables relating to query status.
//
//  Arguments:  [variableSet] - VariableSet to be updated
//
//  Returns:    Nothing
//
//  Notes:      These are post-execution checks that can change an up-to-date
//              query to an out-of-date query, but not the reverse.  The
//              following variables are set:
//                  CiOutOfDate
//                  CiQueryIncomplete
//                  CiQueryTimedOut
//
//  History:    96 Apr 16    AlanW      Created
//
//----------------------------------------------------------------------------

void CWQueryItem::UpdateQueryStatus( CVariableSet & variableSet )
{
    Win4Assert( 0 != _pIRowsetStatus );

    DWORD dwStatus = 0;
    DWORD cDocsFiltered, cToFilter;
    DBCOUNTITEM cDen, cNum;
    DBCOUNTITEM iCur, cTotal;
    SCODE sc = _pIRowsetStatus->GetStatusEx( &dwStatus,
                                             &cDocsFiltered,
                                             &cToFilter,
                                             &cDen,
                                             &cNum,
                                             0,
                                             0,
                                             &iCur,
                                             &cTotal );

    if ( FAILED( sc ) )
        THROW( CException(sc) );

    PROPVARIANT propVariant;
    propVariant.vt   = VT_BOOL;

    BOOL fUpToDate = ( ( cDocsFiltered == _cFilteredDocuments ) &&
                       ( 0 == cToFilter ) );

    if (( QUERY_RELIABILITY_STATUS(dwStatus) &
          (STAT_CONTENT_OUT_OF_DATE | STAT_REFRESH_INCOMPLETE) ) ||
         ! fUpToDate )
    {
        propVariant.boolVal = VARIANT_TRUE;
        ciGibDebugOut(( DEB_ITRACE, "The query is out of date\n" ));
        variableSet.SetVariable( ISAPI_CI_OUT_OF_DATE, &propVariant, 0 );
    }

    if ( QUERY_RELIABILITY_STATUS(dwStatus) & STAT_CONTENT_QUERY_INCOMPLETE )
    {
        propVariant.boolVal = VARIANT_TRUE;
        ciGibDebugOut(( DEB_ITRACE, "The query is incomplete\n" ));
        variableSet.SetVariable( ISAPI_CI_QUERY_INCOMPLETE, &propVariant, 0 );
    }

    if ( QUERY_RELIABILITY_STATUS(dwStatus) & STAT_TIME_LIMIT_EXCEEDED )
    {
        propVariant.boolVal = VARIANT_TRUE;
        ciGibDebugOut(( DEB_ITRACE, "The query timed out\n" ));
        variableSet.SetVariable( ISAPI_CI_QUERY_TIMEDOUT, &propVariant, 0 );
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CWQueryItem::IsQueryDone - public
//
//  History:    96-Mar-01   DwightKr    Created
//
//----------------------------------------------------------------------------
BOOL CWQueryItem::IsQueryDone()
{
    Win4Assert( 0 != _pIRowsetStatus );

    DWORD dwStatus = 0;
    SCODE sc = _pIRowsetStatus->GetStatus( &dwStatus );
    if ( FAILED( sc ) )
    {
        THROW( CException(sc) );
    }

    BOOL fQueryDone = FALSE;

    if ( QUERY_FILL_STATUS(dwStatus) == STAT_DONE ||
         QUERY_FILL_STATUS(dwStatus) == STAT_ERROR)
    {
        fQueryDone = TRUE;
    }

    return fQueryDone;
}



#if (DBG == 1)
//+---------------------------------------------------------------------------
//
//  Member:     CWQueryItem::LokDump - public
//
//  Arguments:  [string] - buffer to send results to
//
//  Synopsis:   Dumps the state of the query
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
void CWQueryItem::LokDump( CVirtualString & string,
                           CVariableSet * pVariableSet,
                           COutputFormat * pOutputFormat )
{
    if ( IsSequential() )
    {
        string.StrCat( L"<I>Sequential cursor</I><BR>\n" );
    }
    else
    {
        string.StrCat( L"<I>Non-Sequential cursor</I><BR>\n" );
    }

    if ( 0 != pVariableSet )
        pVariableSet->Dump( string, *pOutputFormat );

    WCHAR wcsBuffer[80];
    LONG cwcBuffer = swprintf( wcsBuffer, L"Refcount=%d<BR>\n", _refCount );
    string.StrCat( wcsBuffer, cwcBuffer );

    cwcBuffer = swprintf( wcsBuffer, L"NextRecordNumber=%d<BR>\n", _lNextRecordNumber );
    string.StrCat( wcsBuffer, cwcBuffer );

    cwcBuffer = swprintf( wcsBuffer, L"SequenceNumber=%d<BR>\n", _ulSequenceNumber );
    string.StrCat( wcsBuffer, cwcBuffer );

    cwcBuffer = swprintf( wcsBuffer, L"IDQ File name=" );
    string.StrCat( wcsBuffer, cwcBuffer );
    string.StrCat( _idqFile.GetIDQFileName() );
    string.StrCat( L"<BR>\n" );

    cwcBuffer = swprintf( wcsBuffer, L"# documents filtered when query created=%d<BR>\n", _cFilteredDocuments );
    string.StrCat( wcsBuffer, cwcBuffer );

    string.StrCat( L"<P>\n" );
}
#endif // DBG


//+---------------------------------------------------------------------------
//
//  Member:     CWPendingQueryItem::CWPendingQueryItem - public constructor
//
//  Synposis:   Builds a item for use to track an asynchronous query.
//
//  Arguments:  [queryItem]    - query item that is pending
//              [outputFormat] - output format supplied by the browser
//              [variableSet]  - browser supplied variables
//
//  History:    96-Mar-01   DwightKr    Created
//
//----------------------------------------------------------------------------

CWPendingQueryItem::CWPendingQueryItem( XPtr<CWQueryItem> & queryItem,
                                        XPtr<COutputFormat> & outputFormat,
                                        XPtr<CVariableSet> & variableSet ) :

                    _pQueryItem(queryItem.GetPointer()),
                    _pOutputFormat(outputFormat.GetPointer()),
                    _pVariableSet(variableSet.GetPointer())
{
    queryItem.Acquire();
    outputFormat.Acquire();
    variableSet.Acquire();
}

//+---------------------------------------------------------------------------
//
//  Member:     CWPendingQueryItem::~CWPendingQueryItem - public destructor
//
//  Synposis:   Destrolys a query item
//
//  History:    96-Mar-01   DwightKr    Created
//              96-Nov-25   dlee        added header, moved out of .hxx
//
//----------------------------------------------------------------------------

CWPendingQueryItem::~CWPendingQueryItem()
{
    Win4Assert( 0 != _pOutputFormat );

    if ( _pOutputFormat->IsValid() )
    {
        TheWebQueryCache.DecrementActiveRequests();
        ciGibDebugOut(( DEB_ITRACE, "~cwpendingqueryitem releasing session hse %d http %d\n",
                        HSE_STATUS_SUCCESS, HTTP_STATUS_OK ));

        //
        // Processing the query may not have been successful, but if so
        // we wrote an error message, so from an isapi standpoint this was
        // a success.
        //

        _pOutputFormat->SetHttpStatus( HTTP_STATUS_OK );
        _pOutputFormat->ReleaseSession( HSE_STATUS_SUCCESS );
    }

    delete _pQueryItem;
    delete _pOutputFormat;
    delete _pVariableSet;
}


#if (DBG == 1)
//+---------------------------------------------------------------------------
//
//  Member:     CWPendingQueryItem::LokDump - public
//
//  Arguments:  [string] - buffer to send results to
//
//  Synopsis:   Dumps the state of a pending query
//
//  History:    96 Mar 20   Alanw    Created
//
//----------------------------------------------------------------------------
void CWPendingQueryItem::LokDump( CVirtualString & string )
{
    if ( IsQueryDone() )
    {
        string.StrCat( L"<I>Completed query, </I>" );
    }
    else
    {
        string.StrCat( L"<I>Executing query, </I>" );
    }
    _pQueryItem->LokDump( string, _pVariableSet, _pOutputFormat );
}
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\web\dll\wqcache.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:       wqcache.cxx
//
//  Contents:   WEB Query cache class
//
//  History:    96/Jan/3    DwightKr    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <perfobj.hxx>
#include <params.hxx>

DECLARE_INFOLEVEL(ciGib);

//+---------------------------------------------------------------------------
//
//  Function:   GetSecurityToken
//
//  Synopsis:   Gets the security token handle for the current thread
//
//  History:    96-Jan-18   DwightKr    Created
//
//---------------------------------------------------------------------------

HANDLE GetSecurityToken(TOKEN_STATISTICS & TokenInformation)
{
    HANDLE hToken;
    NTSTATUS status = NtOpenThreadToken( GetCurrentThread(),
                                         TOKEN_QUERY | TOKEN_IMPERSONATE | TOKEN_DUPLICATE,
                                         TRUE,           // OpenAsSelf
                                         &hToken );

    if ( !NT_SUCCESS( status ) )
        return INVALID_HANDLE_VALUE;

    DWORD ReturnLength;
    status = NtQueryInformationToken( hToken,
                                      TokenStatistics,
                                      (LPVOID)&TokenInformation,
                                      sizeof TokenInformation,
                                      &ReturnLength );

    if ( !NT_SUCCESS( status ) )
    {
        NtClose( hToken );
        ciGibDebugOut(( DEB_ERROR,
                       "NtQueryInformationToken failed, 0x%x\n",
                       status ));
        THROW( CException( status ));
    }

    Win4Assert( TokenInformation.TokenType == TokenImpersonation );

    return hToken;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWQueryBookmark::CWQueryBookmark - public constructor
//
//  Synopsis:   Reads the values from a bookmark into the member variables
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
CWQueryBookmark::CWQueryBookmark( WCHAR const * wcsBookmark )
{
    Win4Assert( 0 != wcsBookmark );

    //
    //  Bookmarks have the following format:
    //
    //      {S|N}-ptr_to_record-sequence_number-row_number
    //
    //  Eg:
    //
    //      S-1b234a-250-100
    //      0123456789 123456789 1234567
    //
    //      S        = sequential cursor
    //      001b234a = address of CWQueryItem containing query results, in hex
    //      00000250 = sequence number, in hex
    //      00000010 = next row # to display, in hex
    //
    //
    //      N-1b277a-a50-2a000
    //      0123456789 123456789 1234567
    //
    //      N        = non-sequential cursor
    //      001b277a = address of CWQueryItem containing query results, in hex
    //      00000a50 = sequence number, in hex
    //      0002a000 = next row # to display, in hex
    //
    //  Bookmarks are a maximum of 34 characters long, but they may be shorter.
    //  On 32 bit platforms, the maximum length is 28 characters.

    WCHAR * wcsPtr = (WCHAR *)wcsBookmark;

    //
    //  Verify that the bookmark is well formed.  There should be 3 hyphens
    //  and the length must be at least 24 characters; there may be trailing
    //  spaces.
    //
    if ( (*(wcsBookmark+1) != L'-') )
    {
        THROW( CException( DB_E_ERRORSINCOMMAND ) );
    }

    if ( *wcsBookmark == L'S' )
    {
        _fSequential = TRUE;
    }
    else if ( *wcsBookmark == L'N' )
    {
        _fSequential = FALSE;
    }
    else
    {
        THROW( CException( DB_E_ERRORSINCOMMAND ) );
    }

    WCHAR *pwcStart = wcsPtr + 2;

#if defined(_WIN64)
    _pItem = (CWQueryItem *) _wcstoui64( pwcStart, &wcsPtr, 16 );
#else
    _pItem = (CWQueryItem *) wcstoul( pwcStart, &wcsPtr, 16 );
#endif

    if ( ( pwcStart == wcsPtr ) ||
         ( *wcsPtr++ != L'-' ) )
        THROW( CException( DB_E_ERRORSINCOMMAND ) );

    pwcStart = wcsPtr;
    _ulSequenceNumber = wcstoul( wcsPtr, &wcsPtr, 16 );

    if ( ( pwcStart == wcsPtr ) ||
         ( *wcsPtr++ != L'-' ) )
        THROW( CException( DB_E_ERRORSINCOMMAND ) );

    pwcStart = wcsPtr;
    _lRecordNumber   = wcstol( wcsPtr, &wcsPtr, 16 );
    if ( ( pwcStart == wcsPtr ) ||
         ( 0 != *wcsPtr ) )
        THROW( CException( DB_E_ERRORSINCOMMAND ) );

    unsigned cbBmk = (unsigned)(wcsPtr - wcsBookmark + 1) * sizeof (WCHAR);

    if ( cbBmk >= sizeof( _wcsBookmark )  )
        THROW( CException( DB_E_ERRORSINCOMMAND ) );

    RtlCopyMemory( _wcsBookmark,
                   wcsBookmark,
                   cbBmk );

    //Win4Assert( 0 == _wcsBookmark[ cbBmk / ( sizeof WCHAR ) ] );
}

//+---------------------------------------------------------------------------
//
//  Functon:    AppendHex64Number, inline
//
//  Synopsis:   Append a 64 bit hex value to a wide string.
//
//  Arguments:  [pwc] - string to append number to
//              [x]   - value to add to string
//
//  Returns:    Pointer to next character in string to be filled in
//
//  History:    1998 Nov 06   AlanW    Created header; return pwc
//
//----------------------------------------------------------------------------
inline WCHAR * AppendHex64Number( WCHAR * pwc, ULONG_PTR x )
{

#if defined(_WIN64)
    _i64tow( x, pwc, 16 );
#else
    _itow( x, pwc, 16 );
#endif
    pwc += wcslen( pwc );

    return pwc;
}

//+---------------------------------------------------------------------------
//
//  Functon:    AppendHexNumber, inline
//
//  Synopsis:   Append a hex value to a wide string.
//
//  Arguments:  [pwc] - string to append number to
//              [x]   - value to add to string
//
//  Returns:    Pointer to next character in string to be filled in
//
//  History:    96 Apr 09   AlanW    Created header; return pwc
//
//----------------------------------------------------------------------------
inline WCHAR * AppendHexNumber( WCHAR * pwc, ULONG x )
{
    _itow( x, pwc, 16 );
    pwc += wcslen( pwc );

    return pwc;
}


//+---------------------------------------------------------------------------
//
//  Method:     CWQueryBookmark::CWQueryBookmark, public
//
//  Synopsis:   Constructs a query bookmark
//
//  Arguments:  [fSequential]      - TRUE if a sequential query
//              [pItem]            - the query
//              [ulSequenceNumber] - # of queries executed so far
//              [lRecordNumber]    - starting record number of the bookmark
//
//  History:    96          DwightKr  Created
//              97 Apr 20   dlee      Created header
//
//----------------------------------------------------------------------------

CWQueryBookmark::CWQueryBookmark( BOOL fSequential,
                                  CWQueryItem * pItem,
                                  ULONG ulSequenceNumber,
                                  LONG lRecordNumber ) :
    _fSequential( fSequential ),
    _pItem( pItem ),
    _ulSequenceNumber( ulSequenceNumber ),
    _lRecordNumber( lRecordNumber )
{
    WCHAR *pwc = _wcsBookmark;

    *pwc++ = _fSequential ? L'S' : L'N';
    *pwc++ = L'-';

    pwc = AppendHex64Number( pwc, (ULONG_PTR) _pItem );
    *pwc++ = L'-';

    pwc = AppendHexNumber( pwc, _ulSequenceNumber );
    *pwc++ = L'-';

    pwc = AppendHexNumber( pwc, _lRecordNumber );
    *pwc = 0;
}


//+---------------------------------------------------------------------------
//
//  Member:     CWQueryCache::CWQueryCache - public constructor
//
//  Synopsis:   Initializes the linked list of query items, and initializes
//              the query sequence counter.
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
CWQueryCache::CWQueryCache() :
          _ulSignature( LONGSIG( 'q', 'c', 'a', 'c' ) ),
          _cRequestsRejected( 0 ),
          _ulSequenceNumber( 0 ),
          _cActiveRequests( 0 ),
          _pendingQueue( 512 ), // large enough so realloc never happens
#pragma warning( disable : 4355 )       // this used in base initialization
          _threadWatchDog( WatchDogThread, this, TRUE )
#pragma warning( default : 4355 )
{
    //
    // Create a security descriptor for the shared memory. The security
    // descriptor gives full access to the shared memory for the creator
    // and read acccess for everyone else. By default, only the creator
    // can access the shared memory. But we want that anyone will be able
    // to read the performance data. So we must give read access to
    // everyone.
    //

    SECURITY_DESCRIPTOR sd;
    BOOL f = InitializeSecurityDescriptor( &sd, SECURITY_DESCRIPTOR_REVISION );
    if ( !f )
        THROW( CException() );

    HANDLE hToken;
    f = OpenProcessToken( GetCurrentProcess(), TOKEN_QUERY, &hToken );
    if ( !f )
        THROW( CException() );

    SWin32Handle xHandle( hToken );

    DWORD cbTokenInfo;
    f = GetTokenInformation( hToken, TokenOwner, 0, 0, &cbTokenInfo );
    if ( ( !f ) && ( ERROR_INSUFFICIENT_BUFFER != GetLastError() ) )
        THROW( CException() );

    XArray<BYTE> xTo( cbTokenInfo );
    TOKEN_OWNER *pTO = (TOKEN_OWNER*)(char*) xTo.Get();
    f = GetTokenInformation( hToken, TokenOwner, pTO, cbTokenInfo, &cbTokenInfo );
    if ( !f )
        THROW( CException() );

    SID_IDENTIFIER_AUTHORITY WorldSidAuth = SECURITY_WORLD_SID_AUTHORITY;
    CSid sidWorld( WorldSidAuth, SECURITY_WORLD_RID );

    DWORD cbAcl = sizeof(ACL) +
                  2 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)) +
                  GetLengthSid( sidWorld.Get() ) + GetLengthSid( pTO->Owner );
    XArray<BYTE> xDacl( cbAcl );
    PACL pDacl = (PACL)(char*) xDacl.Get();

    f = InitializeAcl( pDacl, cbAcl, ACL_REVISION );
    if ( !f )
        THROW( CException() );

    f = AddAccessAllowedAce( pDacl,
                             ACL_REVISION,
                             FILE_MAP_READ,
                             sidWorld.Get() );
    if ( !f )
        THROW( CException() );

    f = AddAccessAllowedAce( pDacl,
                             ACL_REVISION,
                             FILE_MAP_ALL_ACCESS,
                             pTO->Owner );
    if ( !f )
        THROW( CException() );

    f = SetSecurityDescriptorDacl( &sd, TRUE, pDacl, TRUE );
    if ( !f )
        THROW( CException() );

    SECURITY_ATTRIBUTES sa;
    sa.nLength = sizeof(sa);
    sa.lpSecurityDescriptor = &sd;
    sa.bInheritHandle = FALSE;

    _smPerf.CreateForWriteFromSA( CI_ISAPI_PERF_SHARED_MEM,
                                  CI_ISAPI_SIZE_OF_COUNTER_BLOCK,
                                  sa );

    // CreateForWrite throws on failure, so it's OK by this point

    Win4Assert( _smPerf.Ok() );

    //
    // Always write to the "spare" entry, them CopyMemory to the actual
    // perfcounters in the watchdog thread from time to time.
    //

    CI_ISAPI_COUNTERS * pc = &_smSpare;

    _pcCacheItems         = &pc->_cCacheItems;
    _pcCacheHits          = &pc->_cCacheHits;
    _pcCacheMisses        = &pc->_cCacheMisses;
    _pcRunningQueries     = &pc->_cRunningQueries;
    _pcCacheHitsAndMisses = &pc->_cCacheHitsAndMisses;
    _pcTotalQueries       = &pc->_cTotalQueries;
    _pcRequestsQueued     = &pc->_cRequestsQueued;
    _pcRequestsRejected   = (ULONG *) &pc->_cRequestsRejected;
    _pcQueriesPerMinute   = &pc->_cQueriesPerMinute;

    *_pcCacheItems         = 0;
    *_pcCacheHits          = 0;
    *_pcCacheMisses        = 0;
    *_pcRunningQueries     = 0;
    *_pcCacheHitsAndMisses = 0;
    *_pcTotalQueries       = 0;
    *_pcRequestsQueued     = 0;
    *_pcRequestsRejected   = 0;
    *_pcQueriesPerMinute   = 0;

    CopyMemory( _smPerf.GetPointer(), &_smSpare, sizeof _smSpare );

    ULONG ulOffset = 0;

    for (unsigned i=0; i<MAX_QUERY_COLUMNS; i++)
    {
        g_aDbBinding[i].iOrdinal   = i+1;                   // Column #
        g_aDbBinding[i].obValue    = ulOffset;              // Offset of data
        g_aDbBinding[i].obLength   = 0;                     // Offset where length data is stored
        g_aDbBinding[i].obStatus   = 0;                     // Status info for column written
        g_aDbBinding[i].pTypeInfo  = 0;                     // Reserved
        g_aDbBinding[i].pObject    = 0;                     // DBOBJECT structure
        g_aDbBinding[i].pBindExt   = 0;                     // Ignored
        g_aDbBinding[i].dwPart     = DBPART_VALUE;          // Return data
        g_aDbBinding[i].dwMemOwner = DBMEMOWNER_PROVIDEROWNED; // Memory owner
        g_aDbBinding[i].eParamIO   = 0;                     // eParamIo
        g_aDbBinding[i].cbMaxLen   = sizeof(PROPVARIANT *); // Size of data to return
        g_aDbBinding[i].dwFlags    = 0;                     // Reserved
        g_aDbBinding[i].wType      = DBTYPE_VARIANT | DBTYPE_BYREF;         // Type of return data
        g_aDbBinding[i].bPrecision = 0;                     // Precision to use
        g_aDbBinding[i].bScale     = 0;                     // Scale to use

        ulOffset += sizeof(COutputColumn);
    }

    _threadWatchDog.Resume();
}


//+---------------------------------------------------------------------------
//
//  Member:     CWQueryCache::~CWQueryCache - public destructor
//
//  Synopsis:   Deletes all query items in the linked list.
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
CWQueryCache::~CWQueryCache()
{
    Win4Assert( _pendingQueue.Count() == 0 );
    Win4Assert( IsEmpty() );
}


//+---------------------------------------------------------------------------
//
//  Member:     CWQueryCache::ThreadWatchDog - private
//
//  Synopsis:   The watchdog thread; it periodically:
//                  moves queries from the pending queue to the active cache
//                  moves queries from the active cache to the done cache
//                  flushes old queries from the done cache
//                  updates values from the registry.
//
//  History:    96-Feb-26   DwightKr    Created
//
//----------------------------------------------------------------------------
DWORD WINAPI CWQueryCache::WatchDogThread( void *self )
{
    CWQueryCache &me = * (CWQueryCache *) self;

    while ( !fTheActiveXSearchShutdown )
    {
        TRY
        {
            me.ProcessCacheEvents();
        }
        CATCH ( CException, e )
        {
            ciGibDebugOut(( DEB_IWARN,
                            "Watchdog thread in CWQueryCache caught exception 0x%x\n",
                            e.GetErrorCode() ));
        }
        END_CATCH
    }

    ciGibDebugOut(( DEB_WARN, "Watchdog thread in CWQueryCache is terminating\n" ));

    //
    // This is only necessary if thread is terminated from DLL_PROCESS_DETACH.
    //
    //TerminateThread( me._threadWatchDog.GetHandle(), 0 );

    return 0;
}

//+---------------------------------------------------------------------------
//
//  Member:     CWQueryCache::ProcessCacheEvents - private
//
//  Synopsis:   Process events such a cache flushes & completed asynchronous
//              queries.
//
//  History:    96-Feb-26   DwightKr    Created
//              96-Mar-06   DwightKr    Added asynchronous query completion
//              86-May-16   DwightKr    Add registry change event
//
//----------------------------------------------------------------------------
void CWQueryCache::ProcessCacheEvents()
{
    //
    // Setup for Queries / Minute
    //

    ULONG  cStartTotal  = Total();
    time_t ttStartTotal = time(0);
    time_t ttLastCachePurge = ttStartTotal;
    ULONG cTicks = GetTickCount();

    CRegChangeEvent regChangeEvent(wcsRegAdminTree);

    HANDLE waitHandles[2];
    waitHandles[0] = _eventCacheWork.GetHandle();
    waitHandles[1] = regChangeEvent.GetEventHandle();

    BOOL fBusy = FALSE;

    while ( !fTheActiveXSearchShutdown )
    {
        ULONG ulWaitTime;

        //
        // Set the wait period depending on the existence of any
        // asynchronous queries.
        //

        if ( fBusy )
        {
            // sleep very little for queries to complete

            ulWaitTime = 10;
        }
        else
        {
            if ( ( _pendingQueue.Count() > 0 ) ||
                 ( TheWebPendingRequestQueue.Any() ) )
            {
                ulWaitTime = 100;
            }
            else
            {
                // If we're only processing sequential queries, we need
                // to wake up often to update perfcounters.

                ulWaitTime = 1000;
            }
        }

        ULONG res = WaitForMultipleObjects( 2,
                                            waitHandles,
                                            FALSE,
                                            ulWaitTime );

        if ( 1 == res )
        {
            TheIDQRegParams.Refresh();
            regChangeEvent.Reset();
        }
        else
        {
            // time() is expensive, GetTickCount() is cheap

            if ( ( GetTickCount() - cTicks ) > 30000 )
            {
                cTicks = GetTickCount();
                time_t ttCurrent = time(0);

                //
                // Compute Queries / Minute
                //

                time_t deltaTime = ttCurrent - ttStartTotal;

                if ( deltaTime >= 30 )
                {
                    ULONG  deltaTotal = Total() - cStartTotal;
                    *_pcQueriesPerMinute = (ULONG)((deltaTotal * 60) / deltaTime);

                    //
                    // Start over every 15 minutes
                    //

                    if ( deltaTime > 15 * 60 )
                    {
                        cStartTotal  = Total();
                        ttStartTotal = time(0);
                    }
                }

                //
                //  Calculate the elapsed time since we deleted old queries.
                //  If sufficient time has elapsed, flush unused old queries
                //  from the cache.
                //

                if ( (ttCurrent - ttLastCachePurge) >=
                     ((time_t) TheIDQRegParams.GetISCachePurgeInterval() * 60) )
                {

                    ciGibDebugOut(( DEB_ITRACE, "Waking up query-cache purge thread\n" ));

                    DeleteOldQueries();
                    _idqFileList.DeleteZombies();
                    _htxFileList.DeleteZombies();
                    TheICommandCache.Purge();
                    TheFormattingCache.Purge();

                    time(&ttLastCachePurge);
                }
            }

            // Check for any completed asynchronous queries
            // Re-check for any completed asynchronous queries

            fBusy = CheckForCompletedQueries();
            fBusy |= CheckForPendingRequests();
            fBusy |= CheckForCompletedQueries();

            _eventCacheWork.Reset();
        }

        // Update perfcounters

        CopyMemory( _smPerf.GetPointer(), &_smSpare, sizeof _smSpare );
    }
} //ProcessCacheEvents

//+---------------------------------------------------------------------------
//
//  Member:     CWQueryCache::UpdatePendingRequestCount - public
//
//  Synopsis:   Updates the pending request statistic
//
//  History:    96-May-14   Alanw    Created
//
//----------------------------------------------------------------------------

void CWQueryCache::UpdatePendingRequestCount()
{
    *_pcRequestsQueued = (ULONG) TheWebPendingRequestQueue.Count();
}

//+---------------------------------------------------------------------------
//
//  Member:     CWQueryCache::CheckForPendingRequests - private
//
//  Synopsis:   Check pending for requests and process them
//
//  Returns:    TRUE if any pending requests were processed
//
//  History:    96-Apr-12   dlee    Created
//
//----------------------------------------------------------------------------

BOOL CWQueryCache::CheckForPendingRequests()
{
    // While the pending query queue is getting small in relation to the
    // number of threads processing the queries, move a pending request to
    // the pending query queue (or process it outright if it's synchronous).
    // Only process up to 8 queries -- the thread has other work to do too!

    ULONG cTwiceMaxThreads = 2 * TheIDQRegParams.GetMaxActiveQueryThreads();
    ULONG cProcessed = 0;

    while ( ( cProcessed < 8 ) &&
            ( TheWebPendingRequestQueue.Any() ) &&
            ( cTwiceMaxThreads >= _pendingQueue.Count() ) &&
            ( !fTheActiveXSearchShutdown ) )
    {
        ciGibDebugOut(( DEB_GIB_REQUEST, "Processing a pending request\n" ));

        CWebPendingItem item;

        // any items in the pending request queue?

        if ( !TheWebPendingRequestQueue.AcquireTop( item ) )
            return ( 0 != cProcessed );

        cProcessed++;

        CWebServer webServer( item.GetEcb() );

        Win4Assert( webServer.GetHttpStatus() == HTTP_STATUS_ACCEPTED );
        UpdatePendingRequestCount();

        // Process the request and complete the session if the query
        // was synchronous or if the parsing failed.  If the status is
        // pending, the request is owned by the pending query queue.

        // Impersonate the user specified by the client's browser
        // Note: the constructor of CImpersonateClient cannot throw, or
        //       the ecb will be leaked.

        CImpersonateClient impersonate( item.GetSecurityToken() );

        DWORD hseStatus = ProcessWebRequest( webServer );

        if ( HSE_STATUS_PENDING != hseStatus )
        {
            DecrementActiveRequests();
            ciGibDebugOut(( DEB_GIB_REQUEST,
                            "Released session in CheckForPendingRequests, active: %d\n",
                            _cActiveRequests ));
            ciGibDebugOut(( DEB_ITRACE, "releasing session hse %d http %d\n",
                            hseStatus, HTTP_STATUS_OK ));

            webServer.SetHttpStatus( HTTP_STATUS_OK );
            webServer.ReleaseSession( hseStatus );
        }

        //
        //  The destructor of CImpersonateClient will call RevertToSelf()
        //  thus restoring our privledge level, and the destructor of
        //  CWebPendingItem will close the security token handle.
        //
    }

    return ( 0 != cProcessed );
} //CheckForPendingRequests

//+---------------------------------------------------------------------------
//
//  Member:     CWQueryCache::CheckForCompletedQueries - private
//
//  Synopsis:   Check for completed asynchronous queries
//
//  Returns:    TRUE if any completed queries were processed, FALSE otherwise
//
//  History:    96-Mar-04   DwightKr    Created
//
//----------------------------------------------------------------------------
BOOL CWQueryCache::CheckForCompletedQueries()
{
    // shortcut for all-sequential query case

    if ( 0 == _pendingQueue.Count() )
        return FALSE;

    BOOL fDidWork = FALSE;
    XPtr<CWPendingQueryItem> pendingQuery;

    do
    {
        pendingQuery.Free();

        // Try to find a completed asynchronous query.
        // The snapshot code is necessary so IsQueryDone() isn't called
        // while holding the lock, as it can take a long time.

        {
            CLock shutdownLock( _mutexShutdown );

            // snapshot the pending query list

            XArray<CWPendingQueryItem *> xItems;

            {
                CLock lock( _mutex );

                xItems.Init( _pendingQueue.Count() );

                for ( unsigned i = 0; i < xItems.Count(); i++ )
                    xItems[ i ] = _pendingQueue[ i ];
            }

            unsigned iPos;

            // look for a completed query

            for ( unsigned i = 0;
                  pendingQuery.IsNull() && i < xItems.Count();
                  i++ )
            {
                TRY
                {
                    if ( xItems[i]->IsQueryDone() )
                    {
                        iPos = i;
                        pendingQuery.Set( xItems[i] );
                    }
                }
                CATCH( CException, e )
                {
                    // the query is in an error state.  pass it on below
                    // so that its state will be reported.

                    iPos = i;
                    pendingQuery.Set( xItems[i] );
                }
                END_CATCH
            }

            // Remove the query (if found) from the pending query queue.

            if ( !pendingQuery.IsNull() )
            {
                CLock lock( _mutex );

                // iPos must be accurate since new pending queries are
                // appended to the array, and this is the only place
                // items are removed.

                Win4Assert( _pendingQueue[ iPos ] == pendingQuery.GetPointer() );
                _pendingQueue.Remove( iPos );
            }
        }

        //
        //  If we found a completed query, output its results
        //
        if ( !pendingQuery.IsNull() )
        {
            CWQueryItem * pQueryItem = 0;

            TRY
            {
                ciGibDebugOut(( DEB_ITRACE, "An asynchronous web query has completed\n" ));

                fDidWork = TRUE;
                SCODE status = S_OK;

                CVariableSet  & variableSet  = pendingQuery->GetVariableSet();
                COutputFormat & outputFormat = pendingQuery->GetOutputFormat();

                Win4Assert( HTTP_STATUS_ACCEPTED == outputFormat.GetHttpStatus() );

                BOOL fCanonic = FALSE;

                CVirtualString vString( 16384 );

                TRY
                {
                    // Note: this acquire doesn't acquire the ecb

                    pQueryItem = pendingQuery->GetPendingQueryItem();
                    AddToCache( pQueryItem );
                    pendingQuery->AcquirePendingQueryItem();

                    Win4Assert( !pQueryItem->IsCanonicalOutput() );

                    pQueryItem->OutputQueryResults( variableSet,
                                                    outputFormat,
                                                    vString );
                }
                CATCH( CException, e )
                {
                    status = e.GetErrorCode();
                }
                END_CATCH

                if ( S_OK != status )
                {
                    vString.Empty();

                    GetErrorPageNoThrow( eDefaultISAPIError,
                                         status,
                                         0,
                                         pQueryItem->GetIDQFileName(),
                                         & variableSet,
                                         & outputFormat,
                                         outputFormat.GetLCID(),
                                         outputFormat,
                                         vString );
                }

                if ( !fCanonic )
                    outputFormat.WriteClient( vString );
            }
            CATCH( CException, e )
            {
                // Ignore failures writing to the web server, likely
                // out of memory converting output to narrow string.
            }
            END_CATCH

            Release( pQueryItem );

            // note: the ecb will be released when pendingQuery is freed
            // above in the loop or when we leave scope
        }
        else
        {
            break;
        }
    } while ( !fTheActiveXSearchShutdown );

    return fDidWork;
} //CheckForCompletedQueries

//+---------------------------------------------------------------------------
//
//  Member:     CWQueryCache::CreateOrFindQuery - public
//
//  Synopsis:   Locates the query item specified by the variables
//
//  Arguments:  [wcsIDQFile]       - name of the IDQ file containing the query
//              [variableSet]      - parameters describing the query to find
//              [outputFormat]     - format of #'s & dates
//              [securityIdentity] - User session for this query
//              [fAsynchronous]    - was the query asynchronous
//
//  Returns:    query item matching; 0 otherwise
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------

CWQueryItem * CWQueryCache::CreateOrFindQuery( WCHAR const * wcsIDQFile,
                                               XPtr<CVariableSet> & variableSet,
                                               XPtr<COutputFormat> & outputFormat,
                                               CSecurityIdentity securityIdentity,
                                               BOOL & fAsynchronous )
{
    XInterface<CWQueryItem> xQueryItem;

    CVariable * pVarBookmark = variableSet->Find( ISAPI_CI_BOOKMARK );

    if ( 0 != pVarBookmark )
    {
        //
        //  Get the bookmark & skipcount if specified
        //
        ULONG cwcValue;
        CWQueryBookmark bookMark( pVarBookmark->GetStringValueRAW() );

        LONG lSkipCount = 0;
        CVariable * pVarSkipCount = variableSet->Find( ISAPI_CI_BOOKMARK_SKIP_COUNT );
        if ( 0 != pVarSkipCount )
        {
            lSkipCount = IDQ_wtol( pVarSkipCount->GetStringValueRAW() );
        }

        xQueryItem.Set( FindItem( bookMark,
                                  lSkipCount,
                                  securityIdentity ) );
    }

    if ( !xQueryItem.IsNull() )
    {
        XArray<WCHAR> wcsLocale;
        LCID lcid = GetQueryLocale( xQueryItem->GetIDQFile().GetLocale(),
                                    variableSet.GetReference(),
                                    outputFormat.GetReference(),
                                    wcsLocale );

        Win4Assert( lcid == xQueryItem->GetLocale() );
        //
        //  Now that we have the appropriate locale information, we can generate
        //  the output format information.
        //
        outputFormat->LoadNumberFormatInfo( lcid );

        Win4Assert( 0 != wcsLocale.GetPointer() );
        variableSet->AcquireStringValue( ISAPI_CI_LOCALE, wcsLocale.GetPointer(), 0 );
        wcsLocale.Acquire();
    }
    else
    {
        //
        // Attempt to find a matching query with the same restriction,
        // scope, sort order, etc.

        xQueryItem.Set( FindItem( variableSet,
                                  outputFormat,
                                  wcsIDQFile,
                                  securityIdentity ) );

        if ( !xQueryItem.IsNull() )
            (*_pcTotalQueries)++;
    }

    // make sure the query isn't in bad shape (e.g. the pipe went away)

    if ( !xQueryItem.IsNull() )
    {
        TRY
        {
            // this will force a GetStatus(), and will throw on problems

            xQueryItem->IsQueryDone();
        }
        CATCH( CException, e )
        {
            // zombify the query before releasing it, so it isn't pulled
            // out of the cache and used again.

            xQueryItem->Zombify();
            Release( xQueryItem.Acquire(), FALSE );
        }
        END_CATCH;
    }

    if ( xQueryItem.IsNull() )
    {
        //
        //  We still haven't found a matching query item.  Build a new one
        //

        xQueryItem.Set( CreateNewQuery( wcsIDQFile,
                                        variableSet,
                                        outputFormat,
                                        securityIdentity,
                                        fAsynchronous ) );

        ciGibDebugOut(( DEB_ITRACE, "Item NOT found in cache\n" ));

        (*_pcTotalQueries)++;
        (*_pcCacheMisses)++;
        (*_pcCacheHitsAndMisses)++;
    }
    else
    {
        (*_pcCacheHits)++;
        (*_pcCacheHitsAndMisses)++;
        fAsynchronous = FALSE;
        ciGibDebugOut(( DEB_ITRACE, "Item found in cache\n" ));

        SetupDefaultCiVariables( variableSet.GetReference() );
        SetupDefaultISAPIVariables( variableSet.GetReference() );
    }

    Win4Assert( (  fAsynchronous &&  xQueryItem.IsNull() ) ||
                ( !fAsynchronous && !xQueryItem.IsNull() ) );

    // If it's asynchronous, CreateNewQuery will have already bumped the
    // count of running queries under lock, so we won't have the problem
    // where the query will be completed, output, and released before this
    // increment is called.

    if ( !fAsynchronous )
        IncrementRunningQueries();

    return xQueryItem.Acquire();
} //CreateOrFindQuery


//+---------------------------------------------------------------------------
//
//  Member:     CWQueryCache::FindItem - private
//
//  Synopsis:   Locates the query item specified by Bookmark.  The
//              bookmark is used to generate the address of the CWQueryItem
//              and the lSkipCount is used when the query is using a sequential
//              cursor to determine if the rowset is positioned at the
//              appropriate row.
//
//  Arguments:  [bookmark]         - bookmark of the item to find
//              [lSkipCount]       - number of records to skip past bookmark
//              [securityIdentity] - security LUID of the browser
//
//  Returns:    query item matching [bookmark]; 0 otherwise
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------

CWQueryItem * CWQueryCache::FindItem( CWQueryBookmark & bookmark,
                                      LONG lSkipCount,
                                      CSecurityIdentity securityIdentity )
{
    if ( 0 == *_pcCacheItems )
        return 0;

    CWQueryItem * pQueryItem = 0;

    // ==========================================

    CLock lock( _mutex );

    TRY
    {
        CWQueryItem * pItem = (CWQueryItem *) bookmark.GetQueryItem();

        //
        //  Iterate through the cache looking for this item.
        //
        for ( CWQueryCacheForwardIter iter(*this);
              !AtEnd(iter);
              Advance(iter) )
        {
            if ( iter.Get() == pItem )
            {
                //
                //  Check to verify that all of the following match:
                //
                //      1   If sequential, its not in use
                //      2.  The sequence number matches
                //      3.  The memory block addressed is a CWQueryItem; check signature
                //      4.  We have the same security context
                //      5.  The cached data is still valid
                //      6.  next records # (for sequential queries only) matches
                //      7.  the item isn't a zombie
                //
                if ( (pItem->GetSequenceNumber() == bookmark.GetSequenceNumber()) &&
                     ( pItem->GetSignature() == CWQueryItemSignature ) &&
                     ( !pItem->IsSequential() ||
                        ( (bookmark.GetRecordNumber() + lSkipCount == pItem->GetNextRecordNumber() ) &&
                          (pItem->LokGetRefCount() == 0 )
                        )
                     ) &&
                     ( pItem->LokIsCachedDataValid() ) &&
                     ( !pItem->IsZombie() ) &&
                     ( securityIdentity.IsEqual(pItem->GetSecurityIdentity()) )
                   )
                {
                    pItem->AddRef();
                    LokMoveToFront( pItem );

                    pQueryItem = pItem;

                    break;
                }
            }
        }
    }
    CATCH (CException, e)
    {
    }
    END_CATCH

    return pQueryItem;

    // ==========================================
}


//+---------------------------------------------------------------------------
//
//  Member:     CWQueryCache::FindItem - private
//
//  Synopsis:   Locates the query item specified in the variables
//
//  Arguments:  [variableSet]      - parameters describing the query to find
//              [outputFormat]     - format of #'s & dates
//              [wcsIDQFile]       - name of the IDQ file containing the query
//              [securityIdentity] - security LUID of the browser
//
//  Returns:    query item matching; 0 otherwise
//
//  History:    96-Jan-18   DwightKr    Created
//              96-Mar-13   DwightKr    Allow output columns to be replaceable
//              97-Jun-11   KyleP       Use web server from output format
//
//----------------------------------------------------------------------------

CWQueryItem * CWQueryCache::FindItem( XPtr<CVariableSet> & variableSet,
                                      XPtr<COutputFormat> & outputFormat,
                                      WCHAR const * wcsIDQFile,
                                      CSecurityIdentity securityIdentity )
{
    // The idq search and parameter replacement need to be done
    // regardless of whether a cached query will be used.

    CIDQFile * pIdqFile = _idqFileList.Find( wcsIDQFile,
                                            outputFormat->CodePage(),
                                            securityIdentity );
    XInterface<CIDQFile> xIDQFile( pIdqFile );

    //
    //  Get string values for all parameters that define the query
    //
    ULONG cwc;
    XPtrST<WCHAR> wcsRestriction( ReplaceParameters( pIdqFile->GetRestriction(),
                                                     variableSet.GetReference(),
                                                     outputFormat.GetReference(),
                                                     cwc ) );

    XPtrST<WCHAR> wcsScope( ReplaceParameters( pIdqFile->GetScope(),
                                               variableSet.GetReference(),
                                               outputFormat.GetReference(),
                                               cwc ) );

    // ConvertSlashToBackSlash( wcsScope.GetPointer() );

    XPtrST<WCHAR> wcsSort( ReplaceParameters( pIdqFile->GetSort(),
                                              variableSet.GetReference(),
                                              outputFormat.GetReference(),
                                              cwc ) );

    XPtrST<WCHAR> wcsTemplate( ReplaceParameters( pIdqFile->GetHTXFileName(),
                                                  variableSet.GetReference(),
                                                  outputFormat.GetReference(),
                                                  cwc ) );

    XPtrST<WCHAR> wcsCatalog( ReplaceParameters( pIdqFile->GetCatalog(),
                                                 variableSet.GetReference(),
                                                 outputFormat.GetReference(),
                                                 cwc ) );

    XPtrST<WCHAR> wcsColumns( ReplaceParameters( pIdqFile->GetColumns(),
                                                 variableSet.GetReference(),
                                                 outputFormat.GetReference(),
                                                 cwc ) );

    XPtrST<WCHAR> wcsCiFlags( ReplaceParameters( pIdqFile->GetCiFlags(),
                                                 variableSet.GetReference(),
                                                 outputFormat.GetReference(),
                                                 cwc ) );

    XPtrST<WCHAR> wcsForceUseCI( ReplaceParameters( pIdqFile->GetForceUseCI(),
                                                    variableSet.GetReference(),
                                                    outputFormat.GetReference(),
                                                    cwc ) );

    XPtrST<WCHAR> wcsDeferTrimming( ReplaceParameters( pIdqFile->GetDeferTrimming(),
                                                       variableSet.GetReference(),
                                                       outputFormat.GetReference(),
                                                       cwc ) );

    LONG lMaxRecordsInResultSet =
            ReplaceNumericParameter( pIdqFile->GetMaxRecordsInResultSet(),
                                     variableSet.GetReference(),
                                     outputFormat.GetReference(),
                                     TheIDQRegParams.GetMaxISRowsInResultSet(),
                                     IS_MAX_ROWS_IN_RESULT_MIN,
                                     IS_MAX_ROWS_IN_RESULT_MAX );

    LONG lFirstRowsInResultSet =
            ReplaceNumericParameter( pIdqFile->GetFirstRowsInResultSet(),
                                     variableSet.GetReference(),
                                     outputFormat.GetReference(),
                                     TheIDQRegParams.GetISFirstRowsInResultSet(),
                                     IS_FIRST_ROWS_IN_RESULT_MIN,
                                     IS_FIRST_ROWS_IN_RESULT_MAX );

    XArray<WCHAR> wcsLocale;
    LCID lcid = GetQueryLocale( pIdqFile->GetLocale(),
                                    variableSet.GetReference(),
                                    outputFormat.GetReference(),
                                    wcsLocale );

    //
    //  Now that we have the appropriate locale information, we can generate
    //  the output format information.
    //
    outputFormat->LoadNumberFormatInfo( lcid );

    Win4Assert( 0 != wcsLocale.GetPointer() );
    variableSet->AcquireStringValue( ISAPI_CI_LOCALE, wcsLocale.GetPointer(), 0 );
    wcsLocale.Acquire();

    XInterface<CWQueryItem> xMatchItem;

    // ======================================
    if ( 0 != *_pcCacheItems )
    {
        CLock lock( _mutex );

        for ( CWQueryCacheForwardIter iter(*this);
              !AtEnd(iter);
              Advance(iter) )
        {
            CWQueryItem * pItem = iter.Get();
            Win4Assert( pItem != 0 );

            //
            //  Two queries are identical if all of the following match:
            //
            //      1.  idq file names & its not a zombie
            //      2.  restriction
            //      3.  scope
            //      4.  sort set
            //      5.  template file
            //      6.  output columns
            //      7.  security context
            //      8.  CiFlags
            //      9.  ForceUseCi
            //     10.  CiDeferNonIndexedTrimming
            //     11.  MaxRecordsInResultSet matches
            //     12.  FirstRowsInResultSet matches
            //     13.  CiLocale
            //     14.  next records # (for sequential queries only)
            //     15.  cached data is still valid
            //

            //
            //  Verify condition #1.
            //
            if ( ( _wcsicmp( wcsIDQFile, pItem->GetIDQFileName() ) != 0 ) &&
                 ( !pItem->IsZombie() )
               )
            {
                continue;
            }

            ciGibDebugOut(( DEB_ITRACE, "Checking cache item: %x\n", pItem ));

            LONG  lFirstSequentialRecord = 0;       // Assume no first record #
            ULONG cMatchedItems = 0;                // # of Matched items

            //
            //  Iterate through the list of parameters the browser passed
            //  to verify conditions #2 - #5 mentioned above.  Stop testing
            //  paramaters as soon as a mismatch is found. Also, save the
            //  BOOKMARK & SKIPCOUNT so that condition #7 can be verified later.
            //

            if ( (wcsRestriction.GetPointer() != 0) &&
                 (_wcsicmp( wcsRestriction.GetPointer(), pItem->GetRestriction() ) != 0 )
               )
            {
                ciGibDebugOut(( DEB_ITRACE,
                                "Searching cache: restrictions DONT match: %ws != %ws\n",
                                wcsRestriction.GetPointer(),
                                pItem->GetRestriction() ));

                continue;
            }

            cMatchedItems++;
            ciGibDebugOut(( DEB_ITRACE, "Searching cache: restrictions match\n" ));

            #if DBG == 1
                #if 0 // NTBUG #114206 - we don't do this anymore
                    //
                    //  If we have a scope, verify that there are no slashes
                    //
                    WCHAR const * wcsSlashTest = wcsScope.GetPointer();
                    if ( 0 != wcsSlashTest )
                    {
                        while ( 0 != *wcsSlashTest )
                        {
                            Win4Assert( L'/' != *wcsSlashTest );
                            wcsSlashTest++;
                        }
                    }
                #endif // 0

                #if 0 // bogus assert due to the slash-flipping browser bug
                    wcsSlashTest = pItem->GetScope();
                    if ( 0 != wcsSlashTest )
                    {
                        while ( 0 != *wcsSlashTest )
                        {
                            Win4Assert( L'/' != *wcsSlashTest );
                            wcsSlashTest++;
                        }
                    }
                #endif // 0
            #endif // DBG == 1

            if ( (wcsScope.GetPointer() != 0) &&
                 (_wcsicmp( wcsScope.GetPointer(), pItem->GetScope() ) != 0 )
               )
            {
                ciGibDebugOut(( DEB_ITRACE,
                                "Searching cache: scopes DONT match: %ws != %ws\n",
                                wcsScope.GetPointer(),
                                pItem->GetScope() ));

                continue;
            }

            cMatchedItems++;
            ciGibDebugOut(( DEB_ITRACE, "Searching cache: scopes match\n" ));


            if ( (wcsSort.GetPointer() != 0) &&
                 (pItem->GetSort() != 0 ) &&
                 (_wcsicmp( wcsSort.GetPointer(), pItem->GetSort() ) != 0 )
               )
            {
                ciGibDebugOut(( DEB_ITRACE,
                                "Searching cache: sorts DONT match: %ws != %ws\n",
                                wcsSort.GetPointer(),
                                pItem->GetSort() ));

                continue;
            }

            cMatchedItems++;
            ciGibDebugOut(( DEB_ITRACE, "Searching cache: sorts match\n" ));


            if ( (wcsTemplate.GetPointer() != 0) &&
                 (_wcsicmp( wcsTemplate.GetPointer(), pItem->GetTemplate() ) != 0 )
               )
            {
                ciGibDebugOut(( DEB_ITRACE,
                                "Searching cache: templates DONT match: %ws != %ws\n",
                                wcsTemplate.GetPointer(),
                                pItem->GetTemplate() ));

                continue;
            }

            cMatchedItems++;
            ciGibDebugOut(( DEB_ITRACE, "Searching cache: templates match\n" ));


            if ( (wcsCatalog.GetPointer() != 0) &&
                 (_wcsicmp( wcsCatalog.GetPointer(), pItem->GetCatalog() ) != 0 )
               )
            {
                ciGibDebugOut(( DEB_ITRACE,
                                "Searching cache: catalogs DONT match: %ws != %ws\n",
                                wcsCatalog.GetPointer(),
                                pItem->GetCatalog() ));

                continue;
            }

            cMatchedItems++;
            ciGibDebugOut(( DEB_ITRACE, "Searching cache: catalogs match\n" ));


            if ( (wcsColumns.GetPointer() != 0) &&
                 (_wcsicmp( wcsColumns.GetPointer(), pItem->GetColumns() ) != 0 )
               )
            {
                ciGibDebugOut(( DEB_ITRACE,
                                "Searching cache: catalogs DONT match: %ws != %ws\n",
                                wcsColumns.GetPointer(),
                                pItem->GetColumns() ));

                continue;
            }

            cMatchedItems++;
            ciGibDebugOut(( DEB_ITRACE, "Searching cache: output columns match\n" ));


            if ( (wcsCiFlags.GetPointer() != 0) &&
                 (pItem->GetCiFlags() != 0) &&
                 (_wcsicmp( wcsCiFlags.GetPointer(), pItem->GetCiFlags() ) != 0 )
               )
            {
                ciGibDebugOut(( DEB_ITRACE,
                                "Searching cache: CIFlags DONT match: %ws != %ws\n",
                                wcsCiFlags.GetPointer(),
                                pItem->GetCiFlags() ));

                continue;
            }

            cMatchedItems++;
            ciGibDebugOut(( DEB_ITRACE, "Searching cache: CiFlags columns match\n" ));


            if ( (wcsForceUseCI.GetPointer() != 0) &&
                 (pItem->GetForceUseCI() != 0) &&
                 (_wcsicmp( wcsForceUseCI.GetPointer(), pItem->GetForceUseCI() ) != 0 )
               )
            {
                ciGibDebugOut(( DEB_ITRACE,
                                "Searching cache: ForceUseCI DONT match: %ws != %ws\n",
                                wcsForceUseCI.GetPointer(),
                                pItem->GetForceUseCI() ));

                continue;
            }

            cMatchedItems++;
            ciGibDebugOut(( DEB_ITRACE, "Searching cache: ForceUseCI match\n" ));

            if ( (wcsDeferTrimming.GetPointer() != 0) &&
                 (pItem->GetDeferTrimming() != 0) &&
                 (_wcsicmp( wcsDeferTrimming.GetPointer(), pItem->GetDeferTrimming() ) != 0 )
               )
            {
                ciGibDebugOut(( DEB_ITRACE,
                                "Searching cache: CiDeferNonIndexedTrimming DONT match: %ws != %ws\n",
                                wcsDeferTrimming.GetPointer(),
                                pItem->GetDeferTrimming() ));

                continue;
            }

            cMatchedItems++;
            ciGibDebugOut(( DEB_ITRACE, "Searching cache: CiDeferNonIndexedTrimming match\n" ));

            if ( lMaxRecordsInResultSet != pItem->GetMaxRecordsInResultSet() )
            {
                ciGibDebugOut(( DEB_ITRACE,
                                "Searching cache: MaxRecordsInResultSet DONT match: %d != %d\n",
                                lMaxRecordsInResultSet,
                                pItem->GetMaxRecordsInResultSet() ));
                continue;
            }

            cMatchedItems++;
            ciGibDebugOut(( DEB_ITRACE, "Searching cache: MaxRecordsInResultSet match\n" ));


            if ( lFirstRowsInResultSet != pItem->GetFirstRowsInResultSet() )
            {
                ciGibDebugOut(( DEB_ITRACE,
                                "Searching cache: FirstRowsInResultSet DONT match: %d != %d\n",
                                lFirstRowsInResultSet,
                                pItem->GetFirstRowsInResultSet() ));
                continue;
            }

            cMatchedItems++;
            ciGibDebugOut(( DEB_ITRACE, "Searching cache: FirstRowsInResultSet match\n" ));

            if ( lcid != pItem->GetLocale() )
            {
                ciGibDebugOut(( DEB_ITRACE,
                                "Searching cache: lcid DONT match: 0x%x != 0x%x\n",
                                lcid,
                                pItem->GetLocale() ));

                continue;
            }

            cMatchedItems++;
            ciGibDebugOut(( DEB_ITRACE, "Searching cache: lcid match\n" ));


            if ( pItem->IsSequential() )
            {
                if ( pItem->LokGetRefCount() != 0 )
                {
                    ciGibDebugOut(( DEB_ITRACE,
                                    "Searching cache: Sequential query in use\n" ));
                    continue;
                }

                ULONG cwcValue;
                ULONG ulHash = ISAPIVariableNameHash( ISAPI_CI_BOOKMARK );
                WCHAR const * wcsBookmark = variableSet->GetStringValueRAW( ISAPI_CI_BOOKMARK,
                                                                            ulHash,
                                                                            outputFormat.GetReference(),
                                                                            cwcValue );
                if ( 0 != wcsBookmark )
                {
                    CWQueryBookmark bookMark( wcsBookmark );
                    lFirstSequentialRecord += bookMark.GetRecordNumber();
                }

                ulHash = ISAPIVariableNameHash( ISAPI_CI_BOOKMARK_SKIP_COUNT );
                WCHAR const * wcsBookmarkSkipCount = variableSet->GetStringValueRAW( ISAPI_CI_BOOKMARK_SKIP_COUNT,
                                                                                     ulHash,
                                                                                     outputFormat.GetReference(),
                                                                                     cwcValue );
                if ( 0 != wcsBookmarkSkipCount )
                {
                    lFirstSequentialRecord += IDQ_wtol( wcsBookmarkSkipCount );
                }
            }


            //
            //  We've found a match after examining all of the parameters
            //  passed from the browser.  Now verify conditions #6 - #8 above.
            //

            ciGibDebugOut(( DEB_ITRACE, "Matched %d out of %d parameters\n",
                                         cMatchedItems,
                                         pItem->GetReplaceableParameterCount() ));

            if ( pItem->GetReplaceableParameterCount() > cMatchedItems )
            {
                continue;
            }

            if ( securityIdentity.IsEqual( pItem->GetSecurityIdentity() ) )
            {
                if ( pItem->IsSequential() &&
                     ( lFirstSequentialRecord != pItem->GetNextRecordNumber() )
                   )
                {
                    continue;
                }


                if ( !pItem->LokIsCachedDataValid() )
                {
                    continue;
                }

                //
                //  We've found a match.  Move it to the front of the list and
                //  increment its refcount.  We assume that a query once referenced
                //  will be referenced again, hence the move to the front of the
                //  list.
                //
                pItem->AddRef();
                LokMoveToFront( pItem );

                xMatchItem.Set( pItem );
                break;
            }
        }
    }
    // ======================================


    //
    //  If we got a match, then save away the parameters we've expanded.  They
    //  will be used later as output parameters.
    //

    // Setting ISAPI_CI_MAX_RECORDS_IN_RESULTSET can fail, so we'd
    // leak an addref on the query item without the smart pointer.

    if ( !xMatchItem.IsNull() )
    {
        if ( 0 != wcsRestriction.GetPointer() )
        {
            variableSet->AcquireStringValue( ISAPI_CI_RESTRICTION, wcsRestriction.GetPointer(), 0 );
            wcsRestriction.Acquire();
        }

        if ( 0 != wcsScope.GetPointer() )
        {
            variableSet->AcquireStringValue( ISAPI_CI_SCOPE, wcsScope.GetPointer(), 0 );
            wcsScope.Acquire();
        }


        if ( 0 != wcsSort.GetPointer() )
        {
            variableSet->AcquireStringValue( ISAPI_CI_SORT, wcsSort.GetPointer(), 0 );
            wcsSort.Acquire();
        }

        if ( 0 != wcsTemplate.GetPointer() )
        {
            variableSet->AcquireStringValue( ISAPI_CI_TEMPLATE, wcsTemplate.GetPointer(), 0 );
            wcsTemplate.Acquire();
        }

        if ( 0 != wcsCatalog.GetPointer() )
        {
            variableSet->AcquireStringValue( ISAPI_CI_CATALOG, wcsCatalog.GetPointer(), 0 );
            wcsCatalog.Acquire();
        }

        if ( 0 != wcsColumns.GetPointer() )
        {
            variableSet->AcquireStringValue( ISAPI_CI_COLUMNS, wcsColumns.GetPointer(), 0 );
            wcsColumns.Acquire();
        }

        if ( 0 != wcsCiFlags.GetPointer() )
        {
            variableSet->AcquireStringValue( ISAPI_CI_FLAGS, wcsCiFlags.GetPointer(), 0 );
            wcsCiFlags.Acquire();
        }

        if ( 0 != wcsForceUseCI.GetPointer() )
        {
            variableSet->AcquireStringValue( ISAPI_CI_FORCE_USE_CI, wcsForceUseCI.GetPointer(), 0 );
            wcsForceUseCI.Acquire();
        }

        if ( 0 != wcsDeferTrimming.GetPointer() )
        {
            variableSet->AcquireStringValue( ISAPI_CI_DEFER_NONINDEXED_TRIMMING, wcsDeferTrimming.GetPointer(), 0 );
            wcsDeferTrimming.Acquire();
        }

        PROPVARIANT propVariant;
        propVariant.vt   = VT_I4;
        propVariant.lVal = lMaxRecordsInResultSet;
        variableSet->SetVariable( ISAPI_CI_MAX_RECORDS_IN_RESULTSET, &propVariant, 0 );

        PROPVARIANT propVar;
        propVar.vt   = VT_I4;
        propVar.lVal = lFirstRowsInResultSet;
        variableSet->SetVariable( ISAPI_CI_FIRST_ROWS_IN_RESULTSET, &propVar, 0 );
    }

    return xMatchItem.Acquire();
} //FindItem

//+---------------------------------------------------------------------------
//
//  Member:     CWQueryCache::DeleteOldQueries - public
//
//  Synopsis:   If we haven't checked the query list for at least the maximum
//              time an unused query is allowed to remain in the list, walk
//              the query item list and delete all items whose last access
//              time is greater than the purge time.
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
void CWQueryCache::DeleteOldQueries()
{
    time_t ttNow = time(0);
    time_t  oldestAllowableTime = ttNow - (60 * TheIDQRegParams.GetISCachePurgeInterval());

    //
    // Don't free the queries under lock.  It can take a long long time.
    // We don't need an allocation here; delete at most 40 queries.
    //
    //
    // NOTE: the code below can't throw or we'll leak queries!
    //

    const int cAtMost = 40;
    CWQueryItem * aItems[ cAtMost ];
    int iQueries = 0;

    {
        CLock lock( _mutex );
        CWQueryCacheForwardIter iter( *this );

        while ( !AtEnd( iter ) && iQueries < cAtMost )
        {
            //
            // If no one is using this query, and it is old, delete it now.
            //

            CWQueryItem * pItem = iter.Get();

            if ( pItem->LokGetRefCount() == 0 &&
                 ( pItem->LokGetLastAccessTime() < oldestAllowableTime ||
                   pItem->IsZombie() ) )
            {
                Advance( iter );
                pItem->Unlink();
                aItems[ iQueries++ ] = pItem;

                Win4Assert( *_pcCacheItems > 0 );
                (*_pcCacheItems)--;

                ciGibDebugOut(( DEB_ITRACE,
                                "Removing an expired item from the cache, %d queries cached\n",
                                *_pcCacheItems ));
            }
            else
            {
                Advance( iter );
            }
        }
    }

    for ( int i = 0; i < iQueries; i++ )
        Remove( aItems[ i ] );
} //DeleteOldQueries

//+---------------------------------------------------------------------------
//
//  Member:     CWQueryCache::LokMoveToFront - public
//
//  Arguments:  [pItem] - the CWQueryItem to move to the front the of list
//
//  Synopsis:   Moves a query item to the front of the list.  This routine
//              is called whenever a query object is accessed.
//
//  History:    96-Jan-18   DwightKr    Created
//              96-Feb-20   DwightKr    Remove time reset
//
//----------------------------------------------------------------------------
void CWQueryCache::LokMoveToFront( CWQueryItem * pItem )
{
    Win4Assert( pItem != 0 );

    pItem->Unlink();
    Push(pItem);
}


//+---------------------------------------------------------------------------
//
//  Member:     CWQueryCache::CreateNewQuery - private
//
//  Synopsis:   Creates a new query and adds it to the linked list of items.
//
//  Arguments:  [wcsIDQFile]   - name of the IDQ file referenced by this query
//              [variableSet]  - variables used to create this new query
//              [outputFormat] - format of numbers & dates
//              [securityIdentity] - security context of this query
//
//  Returns:    a new CWQueryItem, fully constructed with the query results
//              already cached & the item added to the linked list of
//              cached queries ONLY if this is a non-sequential query.
//
//  History:    18-Jan-96   DwightKr    Created
//              11-Jun-97   KyleP       Use web server from output format
//
//----------------------------------------------------------------------------

CWQueryItem * CWQueryCache::CreateNewQuery( WCHAR const * wcsIDQFile,
                                            XPtr<CVariableSet> & variableSet,
                                            XPtr<COutputFormat> & outputFormat,
                                            CSecurityIdentity securityIdentity,
                                            BOOL & fAsynchronous )
{
    LONG lFirstRecordNumber = 1;
    CVariable *pVariable = variableSet->Find( ISAPI_CI_FIRST_RECORD_NUMBER );

    if ( 0 != pVariable )
    {
        lFirstRecordNumber = IDQ_wtol( pVariable->GetStringValueRAW() );
    }

    //
    //  Attempt to find a parsed version of the IDQ file in the IDQ file
    //  list.
    //
    CIDQFile * pIdqFile = _idqFileList.Find( wcsIDQFile,
                                            outputFormat->CodePage(),
                                            securityIdentity );

    XInterface<CIDQFile> xIDQFile( pIdqFile );

    //
    //  Did we parse the IDQ file with the correct local & code page?  Check
    //  to see if we used the wrong one. We attempted to open it with the locale
    //  and code page specified by the browser.  Determine if the IDQ file
    //  overrides this value.
    //
    XArray<WCHAR> wcsLocale;
    LCID locale = GetQueryLocale( pIdqFile->GetLocale(),
                                  variableSet.GetReference(),
                                  outputFormat.GetReference(),
                                  wcsLocale );

    Win4Assert( !pIdqFile->IsCanonicalOutput() );

    if ( outputFormat->GetLCID() != locale )
    {
        ciGibDebugOut(( DEB_ITRACE,
                        "Wrong codePage used for loading IDQ file, used 0x%x retrying with 0x%x\n",
                        outputFormat->CodePage(),
                        LocaleToCodepage(locale) ));

        //
        //  We've parsed the IDQ file with the wrong locale.
        //

        _idqFileList.Release( *(xIDQFile.Acquire()) );
        outputFormat->LoadNumberFormatInfo( locale );

        pIdqFile =  _idqFileList.Find( wcsIDQFile,
                                      outputFormat->CodePage(),
                                      securityIdentity );
        xIDQFile.Set( pIdqFile );
    }

    SetupDefaultCiVariables( variableSet.GetReference() );
    SetupDefaultISAPIVariables( variableSet.GetReference() );

    //
    //  Determine which output columns this IDQ file uses
    //
    ULONG cwcOut;
    XPtrST<WCHAR> wcsColumns( ReplaceParameters( pIdqFile->GetColumns(),
                                                 variableSet.GetReference(),
                                                 outputFormat.GetReference(),
                                                 cwcOut ) );

    CDynArray<WCHAR> awcsColumns;

    XPtr<CDbColumns> dbColumns( pIdqFile->ParseColumns( wcsColumns.GetPointer(),
                                                      variableSet.GetReference(),
                                                      awcsColumns ) );

    //
    //  Attempt to find a parsed version of the HTX file in the HTX file
    //  list.
    //


    Win4Assert( !pIdqFile->IsCanonicalOutput() );

    CHTXFile & htxFile = _htxFileList.Find( pIdqFile->GetHTXFileName(),
                           variableSet.GetReference(),
                           outputFormat.GetReference(),
                           securityIdentity,
                           outputFormat->GetServerInstance() );

    XInterface<CHTXFile> xHTXFile( &htxFile );

    CWQueryItem *pNewItem = new CWQueryItem( *pIdqFile,
                                             htxFile,
                                             wcsColumns,
                                             dbColumns,
                                             awcsColumns,
                                             GetNextSequenceNumber(),
                                             lFirstRecordNumber,
                                             securityIdentity );
    XPtr<CWQueryItem> xNewItem( pNewItem);
    xIDQFile.Acquire();
    xHTXFile.Acquire();

    pNewItem->ExecuteQuery( variableSet.GetReference(),
                            outputFormat.GetReference() );

    if ( xNewItem->IsSequential() || xNewItem->IsQueryDone() )
    {
        AddToCache( xNewItem.GetPointer() );

        fAsynchronous = FALSE;

        ciGibDebugOut(( DEB_ITRACE, "Creating a synchronous web query\n" ));
    }
    else
    {
        {
            // ==========================================
            CLock lock( _mutex );

            if ( fTheActiveXSearchShutdown )
                THROW( CException(STATUS_TOO_LATE) );

            // xNewItem is acquired in CWPendingQueryItem's constructor

            CWPendingQueryItem * pItem = new CWPendingQueryItem( xNewItem,
                                                                 outputFormat,
                                                                 variableSet );

            // _pendingQueue's array has been pre-allocated to a large size,
            // so it can't fail.  Even if it could fail we don't want to
            // put CWPendingQueryItem in an xptr since the webServer may
            // be released twice on failure.

            _pendingQueue.Add( pItem, _pendingQueue.Count() );

            IncrementRunningQueries();
            // ==========================================
        }

        fAsynchronous = TRUE;
        ciGibDebugOut(( DEB_ITRACE, "Creating an asynchronous web query\n" ));

        Wakeup();   // wake up thread to check if the query is completed
    }

    Win4Assert( (  fAsynchronous &&  xNewItem.IsNull() ) ||
                ( !fAsynchronous && !xNewItem.IsNull() ) );

    return xNewItem.Acquire();
} //CreateNewQuery

//+---------------------------------------------------------------------------
//
//  Member:     CWQueryCache::AddToCache - public
//
//  Arguments:  [pNewItem] - Item to add to cache
//
//  History:    96-Mar-04   DwightKr    Created
//
//----------------------------------------------------------------------------
void CWQueryCache::AddToCache( CWQueryItem * pNewItem )
{
    // This assert can hit if the user has just lowered
    // IsapiMaxEntriesInQueryCache and the cache was full and a new query
    // was just issued and the cache has not yet been reduced.

    //Win4Assert ( *_pcCacheItems <= TheIDQRegParams.GetMaxISQueryCache() );

    //
    //  If we already have too many query items in the cache, try to
    //  delete some.
    //

    CWQueryItem * pItemToDelete = 0;

    // ==========================================
    if ( pNewItem->CanCache() )
    {
        CLock lock( _mutex );

        CWQueryCacheBackwardIter iter(*this);
        while ( *_pcCacheItems >= TheIDQRegParams.GetMaxISQueryCache() &&
                 !AtEnd(iter) )
        {
            ciGibDebugOut(( DEB_ITRACE, "Too many items in cache, attempting to delete one\n" ));

            CWQueryItem * pItem = iter.Get();

            if ( pItem->LokGetRefCount() == 0 )
            {
                pItemToDelete = pItem;
                pItemToDelete->Unlink();

                Win4Assert( *_pcCacheItems > 0 );
                (*_pcCacheItems)--;

                break;
            }
            else
            {
                BackUp(iter);
            }
        }
    }


    if ( 0 != pItemToDelete )
    {
        Remove( pItemToDelete );
    }

    //  If we STILL have too many queries in the cache, we couldn't delete
    //  any because they were all in use.
    //

    pNewItem->AddRef();

    if ( 0 != TheIDQRegParams.GetMaxISQueryCache() )
    {
        // ==========================================
        CLock lock( _mutex );

        //
        // If we're shutting down, don't attempt to put anything in the cache.
        //
        if ( *_pcCacheItems < TheIDQRegParams.GetMaxISQueryCache() &&
             pNewItem->CanCache() &&
             !fTheActiveXSearchShutdown )
        {
            Push( pNewItem );
            pNewItem->InCache();

            (*_pcCacheItems)++;
        }
        else
        {
            ciGibDebugOut(( DEB_ITRACE, "Still too many items in cache, creating non-cached query\n" ));
        }
        // ==========================================
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CWQueryCache::Remove - public
//
//  Arguments:  [pItem] - Item to remove from cache
//
//  Synopsis:   Removes from cache and releases IDQ & HTX files.
//
//  History:    96-Mar-28   DwightKr    Created
//
//----------------------------------------------------------------------------
void CWQueryCache::Remove( CWQueryItem * pItem )
{
    Win4Assert( 0 != pItem );

    delete pItem;
} //Remove

//+---------------------------------------------------------------------------
//
//  Member:     CWQueryCache::Release - public
//
//  Arguments:  [pItem]              -- Item to release - return to cache
//              [fDecRunningQueries] -- If true, the count of running
//                                      queries should be decremented.
//
//  Synopsis:   Decrements the refcount, and attempts to add it to the
//              cache if it's not already there.
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
void CWQueryCache::Release( CWQueryItem * pItem, BOOL fDecRunningQueries )
{
    if ( 0 != pItem )
    {
        pItem->Release();

        if ( fDecRunningQueries )
            DecrementRunningQueries();

        //
        //  The item may not be in the cache, because the cache was full
        //  at the time the query was created.
        //

        if ( ! pItem->IsInCache() )
        {
            //
            //  Don't attempt to add the query item to the cache here.  If
            //  the add operation throws, we won't release the refcount
            //  on the idq & htx files.
            //
            Remove( pItem );
        }
    }
} //Release

//+---------------------------------------------------------------------------
//
//  Member:     CWQueryCache::FlushCache - public
//
//  Synopsis:   Flushes the cache .. waits until the cache is empty
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
void CWQueryCache::FlushCache()
{
    //
    //  Delete each of the pending asynchronous queries. Take the lock so
    //  that the worker thread can't wake up and start processing one of
    //  these items while we're deleting it.
    //

    {
        // ==========================================

        CLock shutdownLock( _mutexShutdown );
        CLock lock( _mutex );
        for ( unsigned i=0; i<_pendingQueue.Count(); i++ )
        {
            delete _pendingQueue.Get(i);
        }

        _pendingQueue.Clear();
        Win4Assert( _pendingQueue.Count() == 0 );

        // ==========================================
    }

    //
    //  Wait for each of the cached queries to be deleted.  We many have to
    //  sleep for a bit to allow a thread to write the results of an
    //  active query.
    //
    while ( *_pcCacheItems > 0 )
    {
        ciGibDebugOut(( DEB_ITRACE, "Flushing the cache\n" ));

        {
            // ==========================================

            CLock lock( _mutex );

            CWQueryCacheForwardIter iter(*this);

            while ( !AtEnd(iter) )
            {
                CWQueryItem * pItem = iter.Get();

                if ( pItem->LokGetRefCount() == 0 )
                {
                    Advance(iter);

                    pItem->Unlink();

                    Remove( pItem );

                    Win4Assert( *_pcCacheItems > 0 );
                    (*_pcCacheItems)--;
                }
                else
                {
                    Advance(iter);
                }
            }

            // ==========================================
        }

        //
        //  If there are more items to delete, release the lock, wait a
        //  bit then try again.
        //
        if ( *_pcCacheItems > 0 )
        {
            ciGibDebugOut(( DEB_ITRACE, "CWQueryCache::FlushCache  waiting for queries to complete\n" ));
            Sleep(1000);
        }
    }
}

//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
void SetupDefaultCiVariables( CVariableSet & variableSet )
{
    //
    //  Setup the default Ci variables
    //

    for ( unsigned i=0; i<cCiGlobalVars; i++)
    {
        if ( variableSet.Find( aCiGlobalVars[i].wcsVariableName ) == 0 )
        {
            PROPVARIANT Variant;
            Variant.vt  = aCiGlobalVars[i].vt;
            Variant.uhVal.QuadPart = aCiGlobalVars[i].i64DefaultValue;

            variableSet.SetVariable( aCiGlobalVars[i].wcsVariableName,
                                      &Variant,
                                      aCiGlobalVars[i].flags);
        }
    }
}

//+---------------------------------------------------------------------------
//----------------------------------------------------------------------------
void SetupDefaultISAPIVariables( CVariableSet & variableSet )
{
    //
    //  Setup the default ISAPI variables
    //

    for ( unsigned i=0; i<cISAPIGlobalVars; i++)
    {
        if ( variableSet.Find( aISAPIGlobalVars[i].wcsVariableName ) == 0 )
        {
            PROPVARIANT Variant;
            Variant.vt  = aISAPIGlobalVars[i].vt;
            Variant.uhVal.QuadPart = aISAPIGlobalVars[i].i64DefaultValue;

            variableSet.SetVariable( aISAPIGlobalVars[i].wcsVariableName,
                                      &Variant,
                                      aISAPIGlobalVars[i].flags);
        }
    }
}


#if (DBG == 1)
//+---------------------------------------------------------------------------
//
//  Member:     CWQueryCache::Dump - public
//
//  Arguments:  [string]       - buffer to send results to
//              [variableSet]  - replaceable parameters
//              [outputFormat] - format of numbers & dates
//
//  Synopsis:   Dumps the state of all queries
//
//  Notes:      The variableSet and outputFormat are for the
//              current request, i.e., the !dump command, not
//              for the individual queries in the cache.
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------

WCHAR wcsDumpBuffer[500];

void CWQueryCache::Dump( CVirtualString & string,
                         CVariableSet & variableSet,
                         COutputFormat & outputFormat )
{
    // ==========================================

    CLock lock( _mutex );

    string.StrCat( L"<H1>Dump of query cache</H1><P>"
//                 L"<A HREF=\"#stats\">Cache statistics</A><BR>"
//                 L"<A HREF=\"#pending\">Pending queries</A><BR>"
//                 L"<A HREF=\"#cache\">Cached queries</A><BR>"
                   L"<P><H2><A NAME=stats>Cache statistics</H2><P>\n" );

    ULONG cwcDumpBuffer = swprintf( wcsDumpBuffer,
                                L"Unique queries since service startup: %d<BR>"
                                L"Number of items in cache: %d<BR>"
                                L"Number of cache hits: %d<BR>"
                                L"Number of cache misses: %d<BR>"
                                L"Number of cache hits and misses: %d<BR>"
                                L"Number of running queries: %d<BR>"
                                L"Number of queries run thus far: %d<BR>\n",
                                _ulSequenceNumber,
                                *_pcCacheItems,
                                *_pcCacheHits,
                                *_pcCacheMisses,
                                *_pcCacheHitsAndMisses,
                                *_pcRunningQueries,
                                *_pcTotalQueries );

    string.StrCat( wcsDumpBuffer, cwcDumpBuffer );

    string.StrCat( L"<H2><A NAME=pending>Pending Queries</H2><P>" );
    //
    //  Dump the pending query queue
    //
    for (unsigned i=0;
         i<_pendingQueue.Count();
         i++ )
    {
        if ( _pendingQueue[i] )
        {
            cwcDumpBuffer = swprintf( wcsDumpBuffer,
                                  L"<P>\n<H3>Pending query # %d contents:</H3><P>\n",
                                  i+1 );

            string.StrCat( wcsDumpBuffer, cwcDumpBuffer );

            _pendingQueue[i]->LokDump( string /*, variableSet, outputFormat */);
        }
    }

    string.StrCat( L"<H2><HREF NAME=cache>Cached Queries</H2><P>" );
    i = 1;
    for ( CWQueryCacheForwardIter iter(*this);
          !AtEnd(iter);
          Advance(iter), i++ )
    {
        cwcDumpBuffer = swprintf( wcsDumpBuffer,
                              L"<P>\n<H3>Cached query # %d contents:</H3><P>\n",
                              i );

        string.StrCat( wcsDumpBuffer, cwcDumpBuffer );

        iter.Get()->LokDump( string /*, variableSet, outputFormat */);
    }

    // ==========================================
}


//+---------------------------------------------------------------------------
//
//  Member:     CWQueryCache::Internal - public
//
//  Arguments:  [variableSet]  - variable containing command to execute
//              [outputFormat] - format of numbers & dates
//              [string]       - buffer to send results to
//
//  Synopsis:   Executes one of a number of internal commands to the
//              query cache.
//
//  History:    96-Jan-18   DwightKr    Created
//              96-Fen-21   DwightKr    Added help
//
//----------------------------------------------------------------------------
BOOL CWQueryCache::Internal( CVariableSet & variableSet,
                             COutputFormat & outputFormat,
                             CVirtualString & string )
{
    CVariable * pVarRestriction = variableSet.Find(ISAPI_CI_RESTRICTION );

    if ( (0 != pVarRestriction) && (0 != pVarRestriction->GetStringValueRAW()) )
    {
        if (_wcsicmp( pVarRestriction->GetStringValueRAW(), L"!dump") == 0 )

        {
            string.StrCat( L"<HEAD><TITLE>Dump of query cache</TITLE></HEADER>" );
            Dump( string, variableSet, outputFormat );
            return TRUE;
        }
        else if (_wcsicmp( pVarRestriction->GetStringValueRAW(), L"!flush") == 0 )
        {
            string.StrCat( L"<HEAD><TITLE>Cache flush</TITLE></HEADER>Flushing cache...<BR>\n" );

            FlushCache();

            string.StrCat( L"Flush complete<BR>\n" );
            return TRUE;
        }
        else if (_wcsicmp( pVarRestriction->GetStringValueRAW(), L"!?") == 0 )
        {
            string.StrCat( L"<HEAD><TITLE>Help</TITLE></HEADER>" );
            string.StrCat( L"Avaiable commands:<BR>\n");
            string.StrCat( L"!dump  - dumps contents of the query cache<BR>\n" );
            string.StrCat( L"!flush - empties the query cache<BR>\n" );
            string.StrCat( L"!?     - help (this page)<BR>\n" );
            return TRUE;
        }
    }

    return FALSE;
}
#endif // DBG == 1


//+---------------------------------------------------------------------------
//
//  Member:     CWQueryCache::AddToPendingRequestQueue - public
//
//  Synopsis:   Adds the ECB to the pending queue, if we're not shutting down
//
//  History:    96-May-22   DwightKr    Created
//
//----------------------------------------------------------------------------

BOOL CWQueryCache::AddToPendingRequestQueue( EXTENSION_CONTROL_BLOCK *pEcb )
{
    // Don't take the query cache lock here -- there is no reason to since
    // reads are atomic and we don't want IIS to make a zillion threads.

    if ( fTheActiveXSearchShutdown ||
         TheWebPendingRequestQueue.IsFull( ) )
    {
        return FALSE;
    }

    TOKEN_STATISTICS TokenInformation;
    HANDLE hToken = GetSecurityToken(TokenInformation);

    //
    //  It must be an impersonation token, hence we must have a valid handle.
    //  Build a pending request using the ECB and the security token,
    //
    Win4Assert( INVALID_HANDLE_VALUE != hToken );
    Win4Assert( TokenInformation.TokenType == TokenImpersonation );

    CWebPendingItem item( pEcb, hToken );

    //
    //  Add the request to the pending queue.
    //
    return TheWebPendingRequestQueue.Add( item );
}


//+---------------------------------------------------------------------------
//
//  Member:     CWQueryCache::Shutdown - public
//
//  Synopsis:   Stops and empties the query cache
//
//  History:    96-May-22   DwightKr    Created
//
//----------------------------------------------------------------------------
void CWQueryCache::Shutdown()
{
    //
    //  First set the shutdown flag so that no queues will be added to after
    //  this point.
    //
    {
        CLock lock( _mutex );
        fTheActiveXSearchShutdown = TRUE;
    }

    FlushCache();

    Wakeup();               // wake up thread & wait for death
    WaitForSingleObject( _threadWatchDog.GetHandle(), INFINITE );

    Win4Assert( IsEmpty() && "Query cache must be empty after flush" );
}

//+---------------------------------------------------------------------------
//
//  Member:     CICommandCache::CICommandCache, public
//
//  Synopsis:   Constructor for the ICommand cache
//
//  History:    97-Feb-23   dlee    Created
//
//----------------------------------------------------------------------------

CICommandCache::CICommandCache() : _ulSig( LONGSIG( 'c', 'i', 'c', 'c' ) )
{
    //
    // These registry params are taken at startup and ignored
    // thereafter.  This isn't an issue on big machines where the
    // query cache is turned off, but we might want to fix it.
    // Maybe someday, but IDQ is pretty much a dead technology.
    //

    unsigned cItems = TheIDQRegParams.GetMaxISQueryCache();
    ULONG factor = TheIDQRegParams.GetISRequestThresholdFactor();

    SYSTEM_INFO si;
    GetSystemInfo( &si );

    // # of threads allowed in idq + # pending queries + # queries in cache

    cItems += ( 2 * si.dwNumberOfProcessors * factor );

    _aItems.Init( cItems );

    RtlZeroMemory( _aItems.GetPointer(), _aItems.SizeOf() );

    const CLSID clsidCommandCreator = CLSID_CISimpleCommandCreator;
    HRESULT hr = CoCreateInstance( clsidCommandCreator,
                                   NULL,
                                   CLSCTX_INPROC_SERVER,
                                   IID_ISimpleCommandCreator,
                                   xCmdCreator.GetQIPointer() );

    if ( FAILED( hr ) )
        THROW( CException() );
} //CICommandCache

//+---------------------------------------------------------------------------
//
//  Member:     CICommandCache::Make, public
//
//  Synopsis:   Returns an ICommand, either from the cache or by making one
//
//  Arguments:  [ppCommand]   -- Where the ICommand is returned
//              [depth]       -- deep / shallow, etc.
//              [pwcMachine]  -- The machine
//              [pwcCatalog]  -- The catalog
//              [pwcScope]    -- The comma separated list of scopes
//
//  History:    97-Feb-23   dlee    Created
//
//----------------------------------------------------------------------------

SCODE CICommandCache::Make(
    ICommand **   ppCommand,
    DWORD         depth,
    WCHAR const * pwcMachine,
    WCHAR const * pwcCatalog,
    WCHAR const * pwcScope )
{
    *ppCommand = 0;

    // first look for an available item in the cache

    {
        CLock lock( _mutex );

        for ( unsigned x = 0; x < _aItems.Count(); x++ )
        {
            CICommandItem & item = _aItems[ x ];

            if ( ( !item.xCommand.IsNull() ) &&
                 ( !item.fInUse ) &&
                 ( depth == item.depth ) &&
                 ( !wcscmp( pwcMachine, item.aMachine.Get() ) ) &&
                 ( !wcscmp( pwcCatalog, item.aCatalog.Get() ) ) &&
                 ( !wcscmp( pwcScope, item.aScope.Get() ) ) )
            {
                ciGibDebugOut(( DEB_ITRACE, "reusing icommand from cache\n" ));
                item.fInUse = TRUE;
                *ppCommand = item.xCommand.GetPointer();
                Win4Assert( 0 != *ppCommand );
                return S_OK;
            }
        }
    }

    // not found in the cache -- make the item

    ciGibDebugOut(( DEB_ITRACE, "creating icommand\n" ));

    XInterface<ICommand> xCommand;

    SCODE sc = ParseAndMake( xCommand.GetPPointer(),
                             depth,
                             pwcMachine,
                             pwcCatalog,
                             pwcScope );

    if ( FAILED( sc ) )
        return sc;

    // can we put the item in the cache?

    {
        CLock lock( _mutex );

        for ( unsigned x = 0; x < _aItems.Count(); x++ )
        {
            CICommandItem & item = _aItems[ x ];

            if ( item.xCommand.IsNull() )
            {
                // First see if we can add it.

                item.aMachine.ReSize( wcslen( pwcMachine ) + 1 );
                wcscpy( item.aMachine.Get(), pwcMachine );

                item.aCatalog.ReSize( wcslen( pwcCatalog ) + 1 );
                wcscpy( item.aCatalog.Get(), pwcCatalog );

                item.aScope.ReSize( wcslen( pwcScope ) + 1 );
                wcscpy( item.aScope.Get(), pwcScope );

                // Now mark it as owned

                Win4Assert( !item.fInUse );

                item.fInUse = TRUE;
                item.xCommand.Set( xCommand.GetPointer() );
                Win4Assert( 0 != item.xCommand.GetPointer() );
                item.depth = depth;

                break;
            }
        }
    }

    *ppCommand = xCommand.Acquire();
    Win4Assert( 0 != *ppCommand );

    return S_OK;
} //Make

//+---------------------------------------------------------------------------
//
//  Member:     CICommandCache::Release, public
//
//  Synopsis:   Releases the ICommand to the cache or to be freed
//
//  Arguments:  [pCommand]   -- The ICommand to release.
//
//  History:    97-Feb-23   dlee    Created
//
//----------------------------------------------------------------------------

void CICommandCache::Release(
    ICommand * pCommand )
{
    {
        CLock lock( _mutex );

        // first see if it can be returned to the cache

        for ( unsigned x = 0; x < _aItems.Count(); x++ )
        {
            CICommandItem & item = _aItems[ x ];

            if ( item.xCommand.GetPointer() == pCommand )
            {
                Win4Assert( item.fInUse );
                ciGibDebugOut(( DEB_ITRACE, "returning icommand to cache\n" ));
                item.fInUse = FALSE;
                return;
            }
        }
    }

    ciGibDebugOut(( DEB_ITRACE, "icommand not in cache, releasing\n" ));

    // not in the cache -- just release it

    pCommand->Release();
} //Release

//+---------------------------------------------------------------------------
//
//  Member:     CICommandCache::Remove, public
//
//  Synopsis:   Removes the item from the cache, likely because the ICommand
//              is stale because cisvc went down.
//
//  Arguments:  [pCommand]   -- The ICommand to release.
//
//  History:    97-Feb-23   dlee    Created
//
//----------------------------------------------------------------------------

void CICommandCache::Remove(
    ICommand * pCommand )
{
    {
        CLock lock( _mutex );

        // first see if it is in the cache

        for ( unsigned x = 0; x < _aItems.Count(); x++ )
        {
            CICommandItem & item = _aItems[ x ];

            if ( item.xCommand.GetPointer() == pCommand )
            {
                Win4Assert( item.fInUse );
                item.xCommand.Acquire();
                item.fInUse = FALSE;
                break;
            }
        }
    }

    // not in the cache -- just release it

    pCommand->Release();
} //Remove

//+---------------------------------------------------------------------------
//
//  Member:     CICommandCache::Purge, public
//
//  Synopsis:   Releases all ICommands not currently in use
//
//  Arguments:  [pCommand]   -- The ICommand to release.
//
//  History:    97-Feb-23   dlee    Created
//
//----------------------------------------------------------------------------

void CICommandCache::Purge()
{
    CLock lock( _mutex );

    // Remove all non-used items from the cache.

    for ( unsigned x = 0; x < _aItems.Count(); x++ )
    {
        CICommandItem & item = _aItems[ x ];

        if ( ( !item.fInUse ) &&
             ( !item.xCommand.IsNull() ) )
        {
            item.xCommand.Free();
        }
    }
} //Purge

//+---------------------------------------------------------------------------
//
//  Function:   IsAVirtualPath
//
//  Synopsis:   Determines if the path passed is a virtual or physical path.
//              If it's a virtual path, then / are changed to \.
//
//  History:    96-Feb-14   DwightKr    Created
//
//----------------------------------------------------------------------------

BOOL IsAVirtualPath( WCHAR * wcsPath )
{
    Win4Assert ( 0 != wcsPath );
    if ( 0 == wcsPath[0] )
        return TRUE;

    if ( ( L':' == wcsPath[1] ) || ( L'\\' == wcsPath[0] ) )
    {
        return FALSE;
    }
    else
    {
        //
        //  Flip slashes to backslashes
        //

        for ( WCHAR *wcsLetter = wcsPath; 0 != *wcsLetter; wcsLetter++ )
        {
            if ( L'/' == *wcsLetter )
                *wcsLetter = L'\\';
        }
    }

    return TRUE;
} //IsAVirtualPath

//+---------------------------------------------------------------------------
//
//  Function:   ParseScopes
//
//  Synopsis:   Translates a string like:
//                  "  /foo ,c:\bar   ,   "/a b , /c " , j:\dog  "
//              into a multisz string like:
//                  "/foo0c:\bar0/a b , /c 0j:\dog00"
//
//              Leading and trailing white space is removed unless the
//              path is quoted, in which case you get exactly what you
//              asked for even though it may be incorrect.
//
//  Arguments:  [pwcIn]  -- the source string
//              [pwcOut] -- the multisz result string, guaranteed to be
//                          no more than 1 WCHAR larger than pwcIn.
//
//  History:    97-Jun-17   dlee    Created
//
//----------------------------------------------------------------------------

ULONG ParseScopes(
    WCHAR const * pwcIn,
    WCHAR *       pwcOut )
{
    ULONG cScopes = 0;

    while ( 0 != *pwcIn )
    {
        // eat space and commas

        while ( L' ' == *pwcIn || L',' == *pwcIn )
            pwcIn++;

        if ( 0 == *pwcIn )
            break;

        // is this a quoted path?

        if ( L'"' == *pwcIn )
        {
            pwcIn++;

            while ( 0 != *pwcIn && L'"' != *pwcIn )
                *pwcOut++ = *pwcIn++;

            if ( L'"' != *pwcIn )
                THROW( CIDQException( MSG_CI_IDQ_BAD_SCOPE_OR_CATALOG, 0 ) );

            pwcIn++;
            *pwcOut++ = 0;
        }
        else
        {
            while ( 0 != *pwcIn && L',' != *pwcIn )
                *pwcOut++ = *pwcIn++;

            // back up over trailing spaces

            while ( L' ' == * (pwcOut - 1) )
                pwcOut--;

            *pwcOut++ = 0;
        }

        cScopes++;
    }

    if ( 0 == cScopes )
        THROW( CIDQException( MSG_CI_IDQ_BAD_SCOPE_OR_CATALOG, 0 ) );

    // end the string with a second null

    *pwcOut = 0;

    return cScopes;
} //ParseScopes

//+---------------------------------------------------------------------------
//
//  Member:     CICommandCache::ParseAndMake, private
//
//  Synopsis:   Parses parameters for an ICommand and creates one
//
//  Arguments:  [ppCommand]   -- Where the ICommand is returned
//              [depth]       -- deep / shallow, etc.
//              [pwcMachine]  -- The machine
//              [pwcCatalog]  -- The catalog
//              [pwcScope]    -- The comma separated list of scopes
//
//  History:    97-Feb-23   dlee    Created
//
//----------------------------------------------------------------------------

SCODE CICommandCache::ParseAndMake(
    ICommand **   ppCommand,
    DWORD         depth,
    WCHAR const * pwcMachine,
    WCHAR const * pwcCatalog,
    WCHAR const * pwcScope )
{
    Win4Assert(pwcMachine && pwcCatalog);

#if 0 // This is actually a bogus check.  We don't care how long it is.
    if ( wcslen( pwcMachine ) > MAX_COMPUTERNAME_LENGTH )
        THROW( CIDQException( MSG_CI_IDQ_BAD_SCOPE_OR_CATALOG, 0 ) );
#endif

    if ( wcslen( pwcCatalog ) > MAX_PATH )
        THROW( CIDQException( MSG_CI_IDQ_BAD_SCOPE_OR_CATALOG, 0 ) );

    IUnknown * pIUnknown;
    XInterface<ICommand> xCmd;

    if (0 == xCmdCreator.GetPointer())
        return REGDB_E_CLASSNOTREG;

    SCODE sc = xCmdCreator->CreateICommand(&pIUnknown, 0);
    XInterface<IUnknown> xUnk( pIUnknown );

    if ( SUCCEEDED (sc) )
    {
        sc = pIUnknown->QueryInterface(IID_ICommand, xCmd.GetQIPointer());
    }

    if (FAILED(sc))
        return sc;

    TRY
    {
        CDynArrayInPlace<DWORD> aDepths(2);
        CDynArrayInPlace<WCHAR const *> aScopes(2);
        CDynArrayInPlace<WCHAR const *> aMachines(2);
        CDynArrayInPlace<WCHAR const *> aCatalogs(2);

        // allocate +2 for two trailing nulls in the multisz string

        ULONG cwcScope = 2 + wcslen( pwcScope );
        XGrowable<WCHAR> aScope( cwcScope );
        ULONG cScopes = ParseScopes( pwcScope, aScope.Get() );

        Win4Assert( 0 != cScopes );

        if ( cScopes > 1 )
        {
            // Add support for multiple catalogs, and/or machines,
            // and/or depths.  For now, all scopes share a single
            // catalog/machine/depth. (though you can mix virtual and
            // physical).  Maybe someday, but IDQ is dead moving forward.

            WCHAR *pwc = aScope.Get();

            for ( ULONG iScope = 0; iScope < cScopes; iScope++ )
            {
                if ( wcslen( pwc ) >= MAX_PATH )
                    THROW( CIDQException( MSG_CI_IDQ_BAD_SCOPE_OR_CATALOG, 0 ) );

                aDepths[iScope] = depth;

                if ( IsAVirtualPath( pwc ) )
                    aDepths[iScope] |= QUERY_VIRTUAL_PATH;

                aScopes[iScope] = pwc;

                ciGibDebugOut(( DEB_ITRACE, "scope %d: flags 0x%x '%ws'\n",
                                iScope, aDepths[iScope], pwc ));

                // pwc is a multi-sz string.  Skip to the next scope

                pwc += ( 1 + wcslen( pwc ) );

                aMachines[iScope] = pwcMachine;
                aCatalogs[iScope] = pwcCatalog;
            }
        }
        else
        {
            aMachines[0] = pwcMachine;
            aCatalogs[0] = pwcCatalog;
            aDepths[0] = depth;
            WCHAR *pwc = aScope.Get();
            if ( IsAVirtualPath( pwc ) )
                aDepths[0] |= QUERY_VIRTUAL_PATH;
            aScopes[0] = pwc;
        }

        SetScopeProperties( xCmd.GetPointer(),
                            cScopes,
                            aScopes.GetPointer(),
                            aDepths.GetPointer(),
                            aCatalogs.GetPointer(),
                            aMachines.GetPointer() );

        *ppCommand = xCmd.Acquire();
        Win4Assert( 0 != *ppCommand );
    }
    CATCH ( CException, e )
    {
        sc = GetOleError(e);
    }
    END_CATCH

    return sc;
} //ParseAndMake
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\web\dll\wqiter.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1998.
//
//  File:       wqiter.cxx
//
//  Contents:   WEB Query cache iterators
//
//  History:    96/Jan/3    DwightKr    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Member:     CBaseQueryResultsIter::CBaseQueryResultsIter - public constructor
//
//  Arguments:  [item]           - the query results we are iterating over
//              [hAccessor]      - an accessor to the query results
//              [cCols]          - number of output columns
//              [xVariableSet]   - a list of replaceable parameters
//
//  Synopsis:   Initializes common vars between sequential & non-sequential
//              iterators
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
CBaseQueryResultsIter::CBaseQueryResultsIter( CWQueryItem & item,
                                              HACCESSOR hAccessor,
                                              ULONG cCols ) :
                                              _item(item),
                                              _hAccessor(hAccessor),
                                              _cColumns(cCols),
                                              _pVariableSet(0),
                                              _cRowsReturnedToCache(0),
                                              _iCurrentCachedRow(0),
                                              _lFirstRecordNumber(1),
                                              _lMaxRecordsPerPage(0),
                                              _lNextRecordNumber(1),
                                              _lRecordsToRetrieve(0),
                                              _lTotalMatchedRecords(LONG_MAX),
                                              _pOutputColumns(_aOutputColumns)
{
}


//+---------------------------------------------------------------------------
//
//  Member:     CBaseQueryResultsIter::~CBaseQueryResultsIter - public destructor
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
CBaseQueryResultsIter::~CBaseQueryResultsIter()
{
    if ( _pOutputColumns != _aOutputColumns )
    {
        delete _pOutputColumns;
    }
}



//+---------------------------------------------------------------------------
//
//  Member:     CBaseQueryResultsIter::InitalizeLocalVariables - protected
//
//  Arguments:  [variableSet]  -- local variables from browser
//              [outputFormat] -- Output formatter
//
//  Synopsis:   Sets up the common local variables for this query
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------

void CBaseQueryResultsIter::InitializeLocalVariables( CVariableSet & variableSet,
                                                      COutputFormat & outputFormat )
{
    //
    //  Setup the following variables:
    //
    //      CiMaxRecordsPerPage
    //      CiBookmark
    //      CiCurrentPageNumber
    //      CiContainsFirstRecord
    //      CiOutOfDate
    //      CiQueryTime
    //      CiQueryDate
    //      CiQueryTimezone
    //      CiColumns
    //      CiTemplate
    //

    _pVariableSet = &variableSet;

    PROPVARIANT Variant;
    CIDQFile const & idqFile = _item.GetIDQFile();



    //
    //  Set CiMaxRecordsPerPage
    //

    _lMaxRecordsPerPage = ReplaceNumericParameter ( idqFile.GetMaxRecordsPerPage(),
                                                     variableSet,
                                                     outputFormat,
                                                     10,
                                                     1,
                                                     0x10000 );

    _lRecordsToRetrieve = _lMaxRecordsPerPage;

    Variant.vt   = VT_I4;
    Variant.lVal = _lMaxRecordsPerPage;

    _pVariableSet->SetVariable( ISAPI_CI_MAX_RECORDS_PER_PAGE, &Variant, 0 );


    //
    //  Calulate the # of the first record to display
    //
    ULONG cwcValue;
    CVariable * pVariable = variableSet.Find(ISAPI_CI_BOOKMARK);


    if ( (0 != pVariable) &&
         (0 != pVariable->GetStringValueRAW(outputFormat, cwcValue)) &&
         (0 != cwcValue) )
    {
        CWQueryBookmark bookMark( pVariable->GetStringValueRAW(outputFormat, cwcValue) );

        _lFirstRecordNumber = bookMark.GetRecordNumber();
    }

    pVariable = variableSet.Find(ISAPI_CI_BOOKMARK_SKIP_COUNT);
    if ( (0 != pVariable) && (0 != pVariable->GetStringValueRAW(outputFormat, cwcValue)) )
    {
        _lFirstRecordNumber += IDQ_wtol( pVariable->GetStringValueRAW(outputFormat, cwcValue) );
    }



    //
    //  Set CiContainsFirstRecord
    //
    Variant.vt   = VT_BOOL;
    Variant.boolVal = VARIANT_FALSE;
    if ( 1 == _lFirstRecordNumber )
    {
        Variant.boolVal = VARIANT_TRUE;
    }
    _pVariableSet->SetVariable( ISAPI_CI_CONTAINS_FIRST_RECORD, &Variant, 0 );


    //
    //  The first record must be at least 1.  If the browser specified a
    //  large negative skipcount, we need to move the first record number
    //  forward to 1.
    //
    _lFirstRecordNumber = max( 1, _lFirstRecordNumber );


    //
    //  For sequential queries, _lTotalMatchedRecords is LONG_MAX, not the
    //  total number of matched records.
    //
    if (_lFirstRecordNumber > _lTotalMatchedRecords)
        _lFirstRecordNumber = (LONG) _lTotalMatchedRecords+1;


    //
    //  Set CiBookmark
    //

    CWQueryBookmark bookMark( _item.IsSequential(),
                             &_item,
                              _item.GetSequenceNumber(),
                              _lFirstRecordNumber );

    ULONG cwcBookmark = wcslen( bookMark.GetBookmark() );
    XArray<WCHAR> wcsCiBookMark( cwcBookmark + 1 );
    RtlCopyMemory( wcsCiBookMark.Get(),
                   bookMark.GetBookmark(),
                   (cwcBookmark+1) * sizeof(WCHAR) );

    Variant.vt = VT_LPWSTR;
    Variant.pwszVal = wcsCiBookMark.Get();
    _pVariableSet->SetVariable( ISAPI_CI_BOOKMARK,
                                &Variant,
                                eParamOwnsVariantMemory );
    wcsCiBookMark.Acquire();


    _lNextRecordNumber = _lFirstRecordNumber;


    //
    //
    //  Set CiCurrentPageNumber
    //
    Variant.vt   = VT_I4;
    Variant.lVal = _lFirstRecordNumber / _lMaxRecordsPerPage;
    if ( (_lFirstRecordNumber % _lMaxRecordsPerPage) != 0 )
    {
        Variant.lVal++;
    }
    _pVariableSet->SetVariable( ISAPI_CI_CURRENT_PAGE_NUMBER, &Variant, 0 );



    SetCGIVariables( *_pVariableSet, outputFormat );


#if 1 //nuke this soon
    //
    //  Set CiQueryTime
    //
    ULONG cwcQueryTime = 40;
    XArray<WCHAR> wcsQueryTime(cwcQueryTime-1);
    cwcQueryTime = outputFormat.FormatTime( _item.GetQueryTime(),
                                            wcsQueryTime.GetPointer(),
                                            cwcQueryTime );

    //
    //  SetCiQueryDate
    //
    ULONG cwcQueryDate = 40;
    XArray<WCHAR> wcsQueryDate(cwcQueryDate-1);
    cwcQueryDate = outputFormat.FormatDate( _item.GetQueryTime(),
                                            wcsQueryDate.GetPointer(),
                                            cwcQueryDate );


    variableSet.AcquireStringValue( ISAPI_CI_QUERY_TIME, wcsQueryTime.GetPointer(), 0 );
    wcsQueryTime.Acquire();

    variableSet.AcquireStringValue( ISAPI_CI_QUERY_DATE, wcsQueryDate.GetPointer(), 0 );
    wcsQueryDate.Acquire();
#endif

    variableSet.CopyStringValue( ISAPI_CI_QUERY_TIMEZONE, _item.GetQueryTimeZone(), 0 );
    variableSet.CopyStringValue( ISAPI_CI_COLUMNS, _item.GetColumns(), 0 );

    variableSet.CopyStringValue( ISAPI_CI_TEMPLATE, _item.GetTemplate(), 0 );
}


//+---------------------------------------------------------------------------
//
//  Member:     CQueryResultsIter::CQueryResultsIter - public constructor
//
//  Arguments:  [item]           - the query results we are iterating over
//              [pIRowsetScroll] - a IRowsetScroll interface
//              [hAccessor]      - an accessor to the query results
//              [cCols]          - number of output columns
//
//  Synopsis:   Builds an iterator used to access a non-sequential set of
//              query results.
//
//  Notes:      ownership of the xVariableSet is transferred to this class
//              as well as the IRowsetScroll interface
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
CQueryResultsIter::CQueryResultsIter( CWQueryItem & item,
                                      IRowsetScroll * pIRowsetScroll,
                                      HACCESSOR hAccessor,
                                      ULONG cCols ) :
                                CBaseQueryResultsIter( item,
                                                      hAccessor,
                                                      cCols ),
                                _pIRowsetScroll(pIRowsetScroll)
{
    Win4Assert( pIRowsetScroll != 0 );
    Win4Assert( hAccessor != 0 );
}


//+---------------------------------------------------------------------------
//
//  Member:     CQueryResultsIter::~CQueryResultsIter - public destructor
//
//  Synopsis:   Releases storage & IRowsetScroll interface
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
CQueryResultsIter::~CQueryResultsIter()
{
    ReleaseRowsetCache();

    _pIRowsetScroll->Release();
}


//+---------------------------------------------------------------------------
//
//  Member:     CQueryResultsIter::Init - public
//
//  Arguments:  [variableSet]  -- local variables from the user's browser
//              [outputFormat] -- format of $'s & dates
//
//  Synopsis:   Sets up the number & date/time formatting, and fills the
//              cache with the first set of rows.
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------

void CQueryResultsIter::Init( CVariableSet & variableSet,
                              COutputFormat & outputFormat )
{
    //
    //  If the in-line buffer isn't big enough, allocate a new buffer
    //
    if ( _cColumns > NUMBER_INLINE_COLS )
    {
        _pOutputColumns = new COutputColumn[_cColumns];
    }

    InitializeLocalVariables( variableSet, outputFormat );

    FillRowsetCache();
}


//+---------------------------------------------------------------------------
//
//  Member:     CQueryResultsIter::Next - public
//
//  Synopsis:   Sets up the next row to be acessed by the GetRowData()
//              method, and fills the cache if necessary.
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
void CQueryResultsIter::Next()
{
    _iCurrentCachedRow++;

    if ( _iCurrentCachedRow >= _cRowsReturnedToCache )
    {
        ReleaseRowsetCache();
        FillRowsetCache();
    }

    Win4Assert( _iCurrentCachedRow <= _cRowsReturnedToCache );
}

//+---------------------------------------------------------------------------
//
//  Member:     CQueryResultsIter::InitalizeLocalVariables - private
//
//  Arguments:  [variableSet]  - local variables from browser
//              [outputFormat] - format of numbers & dates
//
//  Synopsis:   Sets up the local variables for this query
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------

void CQueryResultsIter::InitializeLocalVariables( CVariableSet & variableSet,
                                                  COutputFormat & outputFormat )
{
    //
    //  Set CiMatchedRecordCount
    //
    DBCOUNTITEM ulPosition;
    HRESULT sc = _pIRowsetScroll->GetApproximatePosition(0,0,0,
                                                         &ulPosition,
                                                         (DBCOUNTITEM *) &_lTotalMatchedRecords );

    if ( FAILED( sc ) )
    {
        THROW( CException(sc) );
    }

    PROPVARIANT Variant;
    Variant.vt   = VT_I4;
    Variant.lVal = (LONG) _lTotalMatchedRecords;
    variableSet.SetVariable( ISAPI_CI_MATCHED_RECORD_COUNT, &Variant, 0 );



    //
    //  Setup the following variables:
    //
    //      CiMatchRecordCount
    //      CiContainsLastRecord
    //      CiTotalNumberPages
    //      CiFirstRecordNumber
    //      CiLastRecordNumber
    //

    CBaseQueryResultsIter::InitializeLocalVariables( variableSet, outputFormat );


    CIDQFile const & idqFile = _item.GetIDQFile();

    //
    //  Set CiContainsLastRecord
    //
    Variant.vt   = VT_BOOL;
    Variant.boolVal = VARIANT_FALSE;
    if ( (_lFirstRecordNumber + _lMaxRecordsPerPage) > _lTotalMatchedRecords )
    {
        Variant.boolVal = VARIANT_TRUE;
    }
    _pVariableSet->SetVariable( ISAPI_CI_CONTAINS_LAST_RECORD, &Variant, 0 );


    //
    //  Set CiTotalNumberPages
    //
    Variant.vt   = VT_I4;
    Variant.lVal = (LONG) _lTotalMatchedRecords / _lMaxRecordsPerPage;
    if ( (_lTotalMatchedRecords % _lMaxRecordsPerPage) != 0 )
    {
        Variant.lVal++;
    }
    _pVariableSet->SetVariable( ISAPI_CI_TOTAL_NUMBER_PAGES, &Variant, 0 );


    //
    //  Set CiFirstRecordNumber
    //
    Variant.vt   = VT_I4;
    Variant.lVal = _lFirstRecordNumber;
    _pVariableSet->SetVariable( ISAPI_CI_FIRST_RECORD_NUMBER, &Variant, 0 );


    //
    //  Set CiLastRecordNumber
    //
    LONG lLastRecordNumber = _lFirstRecordNumber + _lMaxRecordsPerPage - 1;
    if ( lLastRecordNumber > _lTotalMatchedRecords )
    {
        lLastRecordNumber = (LONG) _lTotalMatchedRecords;
    }
    Variant.vt   = VT_I4;
    Variant.lVal = lLastRecordNumber;
    _pVariableSet->SetVariable( ISAPI_CI_LAST_RECORD_NUMBER, &Variant, 0 );


    //
    //  Set CiRecordsNextPage
    //
    Variant.vt    = VT_I4;
    if ( (lLastRecordNumber + _lMaxRecordsPerPage) <= _lTotalMatchedRecords )
    {
        Variant.lVal = _lMaxRecordsPerPage;
    }
    else
    {
        Variant.lVal = (LONG) _lTotalMatchedRecords - lLastRecordNumber;
    }
    _pVariableSet->SetVariable( ISAPI_CI_RECORDS_NEXT_PAGE , &Variant, 0 );
}


//+---------------------------------------------------------------------------
//
//  Member:     CQueryResultsIter::FillRowsetCache - public
//
//  Synopsis:   Fills the cache with the next set of hRows
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
void CQueryResultsIter::FillRowsetCache()
{
    ULONG ulRecordsToRetrieve = min(ITER_CACHE_SIZE, _lRecordsToRetrieve );

    if ( ulRecordsToRetrieve > 0 )
    {
        BYTE bookMark = DBBMK_FIRST;
        HROW * phCachedRows = _ahCachedRows;
        HRESULT sc = _pIRowsetScroll->GetRowsAt( DBWATCHREGION_NULL,
                                                 NULL,
                                                 1,
                                                 &bookMark,
                                                 _lNextRecordNumber - 1,
                                                 ulRecordsToRetrieve,
                                                 &_cRowsReturnedToCache,
                                                 &phCachedRows );

        if ( DB_E_BADSTARTPOSITION == sc )
        {
            // Requested fetch outside available rows.  Treat as end of rowset.
            Win4Assert(_lNextRecordNumber > 0);

            sc = DB_S_ENDOFROWSET;
            _cRowsReturnedToCache = 0;
        }

        if ( FAILED(sc) )
        {
            THROW( CException(sc) );
        }

        _lNextRecordNumber  += (LONG) _cRowsReturnedToCache;

        if ( 0 == _cRowsReturnedToCache ||
             DB_S_ENDOFROWSET == sc )
        {
            Win4Assert( DB_S_ENDOFROWSET == sc );
            _lRecordsToRetrieve = 0;
        }
        else
        {
            _lRecordsToRetrieve -= (LONG) _cRowsReturnedToCache;
        }
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CQueryResultsIter::ReleaseRowsetCache - public
//
//  Synopsis:   Releases the hRows currently in the cache
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
void CQueryResultsIter::ReleaseRowsetCache()
{
    if ( _cRowsReturnedToCache > 0 )
    {
        _pIRowsetScroll->ReleaseRows( _cRowsReturnedToCache,
                                      _ahCachedRows,
                                      0,
                                      0,
                                      0 );
    }

    _cRowsReturnedToCache = 0;
    _iCurrentCachedRow    = 0;
}


//+---------------------------------------------------------------------------
//
//  Member:     CQueryResultsIter::GetRowData - public
//
//  Synopsis:   Returns the output columns for the current row.
//
//  Results:    [COutputColumn *] an array of output columns
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
COutputColumn * CQueryResultsIter::GetRowData()
{
    Win4Assert( _iCurrentCachedRow < _cRowsReturnedToCache );

    HRESULT hr = _pIRowsetScroll->GetData( _ahCachedRows[_iCurrentCachedRow],
                                           _hAccessor,
                                           _pOutputColumns );
    if ( FAILED(hr) )
    {
        THROW( CException(hr) );
    }

    return _pOutputColumns;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSeqQueryResultsIter::CSeqQueryResultsIter - public constructor
//
//  Arguments:  [item]           - the query results we are iterating over
//              [pIRowset]       - an IRowset interface
//              [hAccessor]      - an accessor to the query results
//              [cCols]          - number of output columns
//              [xVariableSet]   - a list of replaceable parameters
//              [ulNextRecordNumnber] - next available rec # in this query
//
//  Synopsis:   Builds an iterator used to access a non-sequential set of
//              query results.
//
//  Notes:      ownership of the pVariableSet is transferred to this class
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
CSeqQueryResultsIter::CSeqQueryResultsIter( CWQueryItem & item,
                                            IRowset * pIRowset,
                                            HACCESSOR hAccessor,
                                            ULONG cCols,
                                            ULONG ulNextRecordNumber ) :
                                       CBaseQueryResultsIter( item,
                                                              hAccessor,
                                                              cCols ),
                                       _pIRowset(pIRowset)
{
    Win4Assert( pIRowset != 0 );
    Win4Assert( hAccessor != 0 );

    _lNextRecordNumber = ulNextRecordNumber;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSeqQueryResultsIter::~CSeqQueryResultsIter - public destructor
//
//  Synopsis:   Releases storage.
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
CSeqQueryResultsIter::~CSeqQueryResultsIter()
{
    ReleaseRowsetCache();
}


//+---------------------------------------------------------------------------
//
//  Member:     CSeqQueryResultsIter::Init - public
//
//  Arguments:  [outputFormat] - format of numbers & dates
//              [variableSet]  - local variables from the user's browser
//
//  Synopsis:   Sets up the number & date/time formatting, and fills the
//              cache with the first set of rows.
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
void CSeqQueryResultsIter::Init( CVariableSet & variableSet,
                                 COutputFormat & outputFormat )
{
    //
    //  If the in-line buffer isn't big enough, allocate a new buffer
    //
    if ( _cColumns > NUMBER_INLINE_COLS )
    {
        _pOutputColumns = new COutputColumn[_cColumns];
    }

    InitializeLocalVariables( variableSet, outputFormat );

    ULONG cRowsToSkip = _lFirstRecordNumber - _item.GetNextRecordNumber();

    FillRowsetCache( cRowsToSkip  );
}


//+---------------------------------------------------------------------------
//
//  Member:     CSeqQueryResultsIter::Next - public
//
//  Synopsis:   Sets up the next row to be acessed by the GetRowData()
//              method, and fills the cache if necessary.
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
void CSeqQueryResultsIter::Next()
{
    _iCurrentCachedRow++;

    if ( _iCurrentCachedRow >= _cRowsReturnedToCache )
    {
        ReleaseRowsetCache();
        FillRowsetCache(0);
    }

    Win4Assert( _iCurrentCachedRow <= _cRowsReturnedToCache );
}


//+---------------------------------------------------------------------------
//
//  Member:     CSeqQueryResultsIter::FillRowsetCache - public
//
//  Arguments:  [cRowsToSkip] - number of rows to skip before filling cache
//
//  Synopsis:   Fills the cache with the next set of hRows
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
void CSeqQueryResultsIter::FillRowsetCache( ULONG cRowsToSkip )
{
    ULONG ulRecordsToRetrieve = min(ITER_CACHE_SIZE, _lRecordsToRetrieve);

    if ( ulRecordsToRetrieve > 0 )
    {
        HROW * phCachedRows = _ahCachedRows;
        HRESULT sc = _pIRowset->GetNextRows( NULL,
                                             cRowsToSkip,
                                             ulRecordsToRetrieve,
                                           &_cRowsReturnedToCache,
                                           &phCachedRows );

        if ( DB_E_BADSTARTPOSITION == sc )
            sc = DB_S_ENDOFROWSET;

        if ( FAILED(sc) )
        {
            THROW( CException(sc) );
        }

        _lNextRecordNumber  += (LONG) _cRowsReturnedToCache;
        _lRecordsToRetrieve -= (LONG) _cRowsReturnedToCache;


        //
        //  Set the CiContainsLastRecord variable to TRUE if we have
        //  exhausted the query results.
        //

        PROPVARIANT Variant;
        Variant.vt   = VT_BOOL;
        Variant.boolVal = VARIANT_FALSE;

        if ( 0 == _cRowsReturnedToCache ||
             DB_S_ENDOFROWSET == sc ||
             DB_S_STOPLIMITREACHED == sc )
        {
            Win4Assert( DB_S_ENDOFROWSET == sc || DB_S_STOPLIMITREACHED == sc );
            _lRecordsToRetrieve = 0;
            Variant.boolVal = VARIANT_TRUE;
        }

        _pVariableSet->SetVariable( ISAPI_CI_CONTAINS_LAST_RECORD, &Variant, 0 );

        if ( DB_S_STOPLIMITREACHED == sc )
        {
            Variant.boolVal = VARIANT_TRUE;
            _pVariableSet->SetVariable( ISAPI_CI_QUERY_TIMEDOUT, &Variant, 0 );
        }


        //
        //  Set CiLastRecordNumber
        //
        Variant.vt   = VT_I4;
        Variant.lVal = _lNextRecordNumber - 1;
        _pVariableSet->SetVariable( ISAPI_CI_LAST_RECORD_NUMBER, &Variant, 0 );

        _item.SetNextRecordNumber( _lNextRecordNumber );
    }
}


//+---------------------------------------------------------------------------
//
//  Member:     CSeqQueryResultsIter::ReleaseRowsetCache - public
//
//  Synopsis:   Releases the hRows currently in the cache
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
void CSeqQueryResultsIter::ReleaseRowsetCache()
{
    if ( _cRowsReturnedToCache > 0 )
    {
        _pIRowset->ReleaseRows( _cRowsReturnedToCache,
                                _ahCachedRows,
                                0,
                                0,
                                0 );
    }

    _cRowsReturnedToCache = 0;
    _iCurrentCachedRow    = 0;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSeqQueryResultsIter::GetRowData - public
//
//  Synopsis:   Returns the output columns for the current row.
//
//  Results:    [COutputColumn *] an array of output columns
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------
COutputColumn * CSeqQueryResultsIter::GetRowData()
{
    Win4Assert( _iCurrentCachedRow < _cRowsReturnedToCache );

    HRESULT hr = _pIRowset->GetData( _ahCachedRows[_iCurrentCachedRow],
                                     _hAccessor,
                                     _pOutputColumns );
    if ( FAILED(hr) )
    {
        THROW( CException(hr) );
    }

    return _pOutputColumns;
}


//+---------------------------------------------------------------------------
//
//  Member:     CSeqQueryResultsIter::InitalizeLocalVariables - private
//
//  Arguments:  [variableSet]  - local variables from browser
//              [outputFormat] - format of numbers & dates
//
//  Synopsis:   Sets up the local variables for this query
//
//  History:    96-Jan-18   DwightKr    Created
//
//----------------------------------------------------------------------------

void CSeqQueryResultsIter::InitializeLocalVariables( CVariableSet & variableSet,
                                                     COutputFormat & outputFormat )
{
    //
    //  Setup the following variables:
    //
    //      CiContainsLastRecord
    //      CiFirstRecordNumber
    //

    CBaseQueryResultsIter::InitializeLocalVariables( variableSet, outputFormat );

    //
    //  Set CiFirstRecordNumber
    //
    PROPVARIANT Variant;
    Variant.vt   = VT_I4;
    Variant.lVal = _lFirstRecordNumber;
    _pVariableSet->SetVariable( ISAPI_CI_FIRST_RECORD_NUMBER, &Variant, 0 );
}


//+---------------------------------------------------------------------------
//
//  Member:     SetCGIVariables - public
//
//  History:    96-Mar-04   DwightKr    Created
//
//----------------------------------------------------------------------------

void SetCGIVariables( CVariableSet & variableSet, CWebServer & webServer )
{
    {
        XArray<WCHAR> xValue;
        ULONG         cwcValue;

        if ( webServer.GetCGI_REQUEST_METHOD( xValue, cwcValue ) )
            variableSet.SetVariable( ISAPI_REQUEST_METHOD, xValue );

        if ( webServer.GetCGI_PATH_INFO( xValue, cwcValue ) )
            variableSet.SetVariable( ISAPI_PATH_INFO, xValue );

        if ( webServer.GetCGI_PATH_TRANSLATED( xValue, cwcValue ) )
            variableSet.SetVariable( ISAPI_PATH_TRANSLATED, xValue );

        if ( webServer.GetCGI_CONTENT_TYPE( xValue, cwcValue ) )
            variableSet.SetVariable( ISAPI_CONTENT_TYPE, xValue );
    }

    //
    //  The HTTP variables can be obtained from ALL_HTTP.  attribute/value
    //  pairs are delimited by \n and the attribute is separated from
    //  the value by a colon.  For example:
    //
    //      HTTP_DWIGHT:This is a HTTP_DWIGHT\nHTTP_KRUGER:This is another\n...
    //

    XArray<WCHAR> wcsALLHTTP;
    ULONG         cwcALLHTTP;

    if ( webServer.GetCGIVariable( "ALL_HTTP",
                                    wcsALLHTTP,
                                    cwcALLHTTP ) )
    {
        WCHAR * wcsToken = wcsALLHTTP.Get();
        XArray<WCHAR> wcsCopyOfValue;

        while ( 0 != wcsToken )
        {
            WCHAR * wcsAttribute = wcsToken;
            wcsToken = wcschr( wcsToken, L'\n' );

            WCHAR * wcsValue = wcschr( wcsAttribute, L':' );

            if ( 0 != wcsValue )
            {
                *wcsValue++ = '\0';

                ULONG cwcValue;

                if (wcsToken)
                {
                    if ( wcsValue > wcsToken )
                        THROW( CException( E_INVALIDARG ) );

                    cwcValue = (ULONG)(wcsToken - wcsValue);
                    *wcsToken++ = '\0';
                }
                else
                {
                    cwcValue = wcslen( wcsValue );
                }

                wcsCopyOfValue.Init(cwcValue+1);
                RtlCopyMemory( wcsCopyOfValue.Get(), wcsValue, (cwcValue+1) * sizeof(WCHAR) );

                PROPVARIANT Variant;
                Variant.vt = VT_LPWSTR;
                Variant.pwszVal = wcsCopyOfValue.Get();

                variableSet.SetVariable( wcsAttribute,
                                         &Variant,
                                         eParamOwnsVariantMemory );

                wcsCopyOfValue.Acquire();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\web\dll\xtow.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1996, Microsoft Corporation.
//
//  File:       xtow.cxx
//
//  Contents:   formats numbers into wide strings
//
//  History:    96/Jan/3    DwightKr    Created
//              96/Apr/3    dlee        optimized and cleaned up
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

//+---------------------------------------------------------------------------
//
//  Note - added to C run-times; remove when new run-times are available.
//  On second thought, just use this one -- it saves an ascii=>wide and
//  radix checking.
//  This routine isn't for real formatting -- it's just for input to
//  Win32's real number formatting routine
//
//----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Function:   IDQ_ulltow_format
//
//  Synopsis:   formats an _int64 in a wide string.
//
//  Arguments:  [val]         -  value to format
//              [buf]         -  buffer for the result
//              [fIsNegative] - true if val is negative, false otherwise
//
//  History:    96/Apr/05   dlee    Created.
//
//----------------------------------------------------------------------------

void IDQ_ulltow_format(
    ULONGLONG val,
    WCHAR *   buf,
    int       fIsNegative )
{
    WCHAR *p = buf;

    if ( fIsNegative )
    {
        // negative, so output '-' and negate

        *p++ = L'-';
        val = (ULONGLONG) (-(LONGLONG)val);
    }

    WCHAR *firstdig = p;           // save pointer to first digit

    do
    {
        unsigned digval = (unsigned) (val % 10);
        val /= 10;   // get next digit

        Win4Assert( digval <= 9 );

        // convert to unicode and store

        *p++ = (WCHAR) (digval + L'0');
    } while ( val > 0 );

    // We now have the digit of the number in the buffer, but in reverse
    // order.  Thus we reverse them now.

    *p-- = 0;

    do
    {
        WCHAR temp = *p;
        *p = *firstdig;
        *firstdig = temp;       // swap *p and *firstdig
        --p;
        ++firstdig;             // advance to next two digits
    } while ( firstdig < p );   // repeat until halfway
}

void IDQ_ultow_format(
    ULONG   val,
    WCHAR * buf,
    int     fIsNegative )
{
    WCHAR *p = buf;

    if ( fIsNegative )
    {
        // negative, so output '-' and negate

        *p++ = L'-';
        val = (ULONG) (-(LONG)val);
    }

    WCHAR *firstdig = p;           // save pointer to first digit

    do
    {
        unsigned digval = (unsigned) (val % 10);
        val /= 10;   // get next digit

        Win4Assert( digval <= 9 );

        // convert to unicode and store

        *p++ = (WCHAR) (digval + L'0');
    } while ( val > 0 );

    // We now have the digit of the number in the buffer, but in reverse
    // order.  Thus we reverse them now.

    *p-- = 0;

    do
    {
        WCHAR temp = *p;
        *p = *firstdig;
        *firstdig = temp;       // swap *p and *firstdig
        --p;
        ++firstdig;             // advance to next two digits
    } while ( firstdig < p );   // repeat until halfway
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\web\html\newsvr\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1996

Module Name:

    makefile.inc.

!ENDIF

$(_NTTREE)\query\newsall.exe: admin.idq admin.htx isnquery.url news1.htm news1.htw news1.htx news1.idq news2.htm news2.htw news2.htx news2.idq newsall.cmd newsall.inf
    builddl
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\web\dll\wqlocale.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1996, Microsoft Corporation.
//
//  File:       wqlocale.cxx
//
//  Contents:   WEB Query locale parsers
//
//  History:    96/May/2    DwightKr    Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop


//+---------------------------------------------------------------------------
//
//  Function:   GetBrowserLCID - public
//
//  Synposis:   Determines the locale from the browser's HTTP_ACCEPT_LANGUAGE
//              Note that the browser may not send a language, in which case
//              we will default to the web servers default language.
//
//  Arguments:  [webServer] the web service which can return the environment
//                          variable HTTP_ACCEPT_LANGUAGE.
//              [wcsHttpLanguage] - buffer to accept the language
//
//  History:    20-Jan-96   DwightKr    Created
//              11-Jun-97   KyleP       Initialize ccHttpLanguage!
//
//----------------------------------------------------------------------------

LCID GetBrowserLCID( CWebServer & webServer, XArray<WCHAR> & wcsHttpLanguage )
{
    //
    // Don't look it up twice!
    //

    if ( webServer.IsLCIDValid() )
    {
        wcsHttpLanguage.Init( webServer.LocaleSize() );
        RtlCopyMemory( wcsHttpLanguage.GetPointer(),
                       webServer.GetLocale(),
                       webServer.LocaleSize() * sizeof(WCHAR) );

        return webServer.GetLCID();
    }

    //
    // Try the hard way...
    //

    CHAR  aszHttpLanguage[512];
    ULONG ccHttpLanguage = sizeof(aszHttpLanguage);

    if ( !webServer.GetCGIVariable( "HTTP_ACCEPT_LANGUAGE",
                                    aszHttpLanguage,
                                    &ccHttpLanguage) )
    {
        ciGibDebugOut(( DEB_ITRACE,
                        "GetBrowserLCID: HTTP_ACCEPT_LANGAUGE was not set in the environment; using lcid=0x%x\n",
                        GetSystemDefaultLCID() ));

        LCID locale = GetSystemDefaultLCID();
        WCHAR wcsLocale[100];
        GetStringFromLCID( locale, wcsLocale );
        ULONG cwcLocale = wcslen(wcsLocale) + 1;

        wcsHttpLanguage.Init( cwcLocale );
        RtlCopyMemory( wcsHttpLanguage.GetPointer(),
                       wcsLocale,
                       cwcLocale*sizeof(WCHAR) );

        webServer.SetLCID( locale, wcsLocale, cwcLocale );
        return locale;
    }

    //
    //  Use the system's ANSI code page here since we're trying to figure
    //  out which code page to use.  The default code page is likely
    //  correct since all of the locale names are simple strings containing
    //  only characters A-Z.
    //

    unsigned cwcLocale = MultiByteToXArrayWideChar( (BYTE const *) aszHttpLanguage,
                                                    ccHttpLanguage,
                                                    GetACP(),
                                                    wcsHttpLanguage );

    LCID lcid = GetLCIDFromString( wcsHttpLanguage.GetPointer() );

    if ( InvalidLCID == lcid )
        lcid = GetSystemDefaultLCID();

    webServer.SetLCID( lcid,
                       wcsHttpLanguage.GetPointer(),
                       cwcLocale + 1 );
    return lcid;
}



//+---------------------------------------------------------------------------
//
//  Function:   GetQueryLocale - public
//
//  Synposis:   Determines the locale in both a string and LCID form
//
//  Arguments:  [wcsCiLocale]  - locale string from a IDQ/IDA file
//              [variableSet]  - set of replaceable parameters
//              [outputFormat] - format for replaceable parameters
//              [xLocale]      - the string representation of the locale
//
//  History:    02-May-96   DwightKr    Created
//              11-Jun-97   KyleP       Use web server from output format
//
//----------------------------------------------------------------------------
LCID GetQueryLocale( WCHAR const * wcsCiLocale,
                     CVariableSet & variableSet,
                     COutputFormat & outputFormat,
                     XArray<WCHAR> & xLocale )
{
    ULONG cwcLocale;
    WCHAR * wcsLocale = ReplaceParameters( wcsCiLocale,
                                           variableSet,
                                           outputFormat,
                                           cwcLocale );
    LCID  locale = InvalidLCID;

    //
    //  If a locale was specified by the IDQ file, load its numeric
    //  representation here.
    //
    if ( 0 != wcsLocale )
    {
        xLocale.Set( cwcLocale+1, wcsLocale );
        locale = GetLCIDFromString( xLocale.GetPointer() );

        if ( InvalidLCID == locale )
        {
            delete xLocale.Acquire();
            outputFormat.LoadNumberFormatInfo( GetBrowserLCID( outputFormat, xLocale ) );

            THROW( CIDQException(MSG_CI_IDQ_INVALID_LOCALE, 0) );
        }
    }
    else
    {
        //
        //  If no locale was found in the IDQ file read the locale from
        //  the browser.  If the browser did not specify a locale, we'll
        //  use the system's locale.
        //

        locale = GetBrowserLCID( outputFormat, xLocale );
    }

    return locale;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\web\html\scripts\qrybody3.inc ===
<TR>
  <TD BGCOLOR="f7efde" ALIGN=CENTER>
  <FONT STYLE="ARIAL NARROW" SIZE=1><%=NextRecordNumber %>.</FONT></TD>
  <TD BGCOLOR="f7efde" ALIGN=CENTER>
  <FONT STYLE="ARIAL NARROW" SIZE=1><%=RS("FileName")%></FONT></TD>
  <TD BGCOLOR="f7efde" ALIGN=LEFT>
  <FONT STYLE="ARIAL NARROW" SIZE=1><A HREF="http:<%=RS("vpath")%>"><%=RS("vpath")%></A></FONT></TD>
  <TD BGCOLOR="f7efde" ALIGN=CENTER>
  <FONT STYLE="ARIAL NARROW" SIZE=1><%=RS("Size")%></FONT></TD>
  <TD BGCOLOR="f7efde" ALIGN=CENTER>
  <FONT STYLE="ARIAL NARROW" SIZE=1><%=RS("Write")%></FONT></TD>
  </TR>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\web\html\scripts\qrybody2.inc ===
<A HREF="http:<%=RS("vpath")%>"><%=RS("path")%></A>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\web\html\scripts\qryhead1.inc ===
<!--  table heading for query form style 1  -->
<dl>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\web\html\scripts\qryhead2.inc ===
<!--  table heading for query form style 2  -->
<PRE>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\web\html\scripts\qrytail1.inc ===
<!--  table end for query form style 1 -->
</dl>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\web\html\scripts\qryhead3.inc ===
<!--  table heading for query form style 3  -->
<TABLE CELLPADDING=5 BORDER=0>
<TR>

<TD ALIGN=CENTER BGCOLOR="#800000">
<FONT STYLE="ARIAL NARROW" COLOR="#ffffff" SIZE=1>Record</FONT>
</TD>
<TD ALIGN=CENTER BGCOLOR="#800000">
<FONT STYLE="ARIAL NARROW" COLOR="#ffffff" SIZE=1>File name</FONT>
</TD>
<TD ALIGN=CENTER WIDTH=160 BGCOLOR="#800000">
<FONT STYLE="ARIAL NARROW" COLOR="#ffffff" SIZE=1>Path</FONT>
</TD>
<TD ALIGN=CENTER BGCOLOR="#800000">
<FONT STYLE="ARIAL NARROW" COLOR="#ffffff" SIZE=1>Size</FONT>
</TD>
<TD ALIGN=CENTER BGCOLOR="#800000">
<FONT STYLE="ARIAL NARROW" COLOR="#ffffff" SIZE=1>Write</FONT>
</TD>

</TR>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\web\html\scripts\qrytail3.inc ===
</TABLE>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\web\html\scripts\qrytail2.inc ===
</PRE>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\web\ixsso\ixsquery.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2000.
//
//  File:       ixsquery.cxx
//
//  Contents:   Query SSO active query state class
//
//  History:    29 Oct 1996      Alanw    Created
//
//----------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include "ixsso.hxx"
#include "ssodebug.hxx"

#include <strrest.hxx>
#include <strsort.hxx>
#include <qlibutil.hxx>

#if CIDBG
#include <stdio.h>
#endif // CIDBG

#include <initguid.h>
#include <nlimport.h>

static const DBID dbcolNull = { {0,0,0,{0,0,0,0,0,0,0,0}},DBKIND_GUID_PROPID,0};

static const GUID guidQueryExt = DBPROPSET_QUERYEXT;

static const GUID guidRowsetProps = DBPROPSET_ROWSET;


//+---------------------------------------------------------------------------
//
//  Member:     CixssoQuery::GetDefaultCatalog - private inline
//
//  Synopsis:   Initializes the _pwszCatalog member with the default catalog.
//
//  Arguments:  NONE
//
//  Notes:      The IS 2.0 implementation of ISCC::GetDefaultCatalog has two
//              flaws that are worked around here.  It should return the size
//              of the required string when zero is passed in as the input
//              length, and it should null terminate the output string.
//
//  History:    18 Dec 1996     AlanW   Created
//              21 Oct 1997     AlanW   Modified to use ISimpleCommandCreator
//
//----------------------------------------------------------------------------

inline void CixssoQuery::GetDefaultCatalog( )
{
    ixssoDebugOut(( DEB_ITRACE, "Using default catalog\n" ));

    ULONG cchRequired = 0;

    SCODE sc = _xCmdCreator->GetDefaultCatalog(0, 0, &cchRequired);

    if ( cchRequired == 0 )
    {
        // IS 2.0 doesn't return required path length
        cchRequired = MAX_PATH;
    }
    else if ( cchRequired > MAX_PATH )
    {
        THROW( CException(E_INVALIDARG) );
    }
    cchRequired++;                // make room for termination

    XArray<WCHAR> pwszCat ( cchRequired );
    sc = _xCmdCreator->GetDefaultCatalog(pwszCat.GetPointer(), cchRequired, &cchRequired);

    if (FAILED(sc))
        THROW( CException(sc) );

    Win4Assert( 0 == _pwszCatalog );
    _pwszCatalog = pwszCat.Acquire();

    // IS 2.0 does not transfer the null character at the end of the string.
    _pwszCatalog[ cchRequired ] = L'\0';

    return;
}


//+---------------------------------------------------------------------------
//
//  Function:   ParseCatalogs - public
//
//  Synopsis:   Parse a comma-separated catalog string, return the count
//              of catalogs and the individual catalog and machine names.
//
//  Arguments:  [pwszCatalog] - input catalog string
//              [aCatalogs] - array for returned catalog names
//              [aMachines] - array for returned machine names
//
//  Returns:    ULONG - number of catalogs
//
//  Notes:      
//
//  History:    18 Jun 1997      Alanw    Created
//
//----------------------------------------------------------------------------

ULONG ParseCatalogs( WCHAR * pwszCatalog,
                     CDynArray<WCHAR> & aCatalogs,
                     CDynArray<WCHAR> & aMachines )
{
    ULONG cCatalogs = 0;

    while ( 0 != *pwszCatalog )
    {
        // eat space and commas

        while ( L' ' == *pwszCatalog || L',' == *pwszCatalog )
            pwszCatalog++;

        if ( 0 == *pwszCatalog )
            break;

        WCHAR awchCat[MAX_PATH];
        WCHAR * pwszOut = awchCat;

        // is this a quoted path?

        if ( L'"' == *pwszCatalog )
        {
            pwszCatalog++;

            while ( 0 != *pwszCatalog &&
                    L'"' != *pwszCatalog &&
                    pwszOut < &awchCat[MAX_PATH] )
                *pwszOut++ = *pwszCatalog++;

            if ( L'"' != *pwszCatalog )
                THROW( CIxssoException( MSG_IXSSO_BAD_CATALOG, 0 ) );

            pwszCatalog++;
            *pwszOut++ = 0;
        }
        else
        {
            while ( 0 != *pwszCatalog &&
                    L',' != *pwszCatalog &&
                    pwszOut < &awchCat[MAX_PATH] )
                *pwszOut++ = *pwszCatalog++;

            if ( pwszOut >= &awchCat[MAX_PATH] )
                THROW( CIxssoException( MSG_IXSSO_BAD_CATALOG, 0 ) );

            // back up over trailing spaces

            while ( L' ' == * (pwszOut - 1) )
                pwszOut--;

            *pwszOut++ = 0;
        }

        XPtrST<WCHAR> xpCat;
        XPtrST<WCHAR> xpMach;
        SCODE sc = ParseCatalogURL( awchCat, xpCat, xpMach );
        if (FAILED(sc) || xpCat.IsNull() )
            THROW( CIxssoException( MSG_IXSSO_BAD_CATALOG, 0 ) );

        aCatalogs.Add(xpCat.GetPointer(), cCatalogs);
        xpCat.Acquire();
        aMachines.Add(xpMach.GetPointer(), cCatalogs);
        xpMach.Acquire();

        cCatalogs++;
    }

    if ( 0 == cCatalogs )
        THROW( CIxssoException( MSG_IXSSO_BAD_CATALOG, 0 ) );

    return cCatalogs;
} //ParseCatalogs


//+---------------------------------------------------------------------------
//
//  Member:     CixssoQuery::GetDialect - private
//
//  Synopsis:   Parses the dialect string and returns ISQLANG_V*
//
//  Returns:    The dialect identifier
//
//  History:    19 Nov 1997      dlee       Created
//              03 Dec 1998      KrishnaN   Defaulting to version 2
//
//----------------------------------------------------------------------------
ULONG CixssoQuery::GetDialect()
{
    if ( 0 == _pwszDialect )
        return ISQLANG_V2;

    ULONG ul = _wtoi( _pwszDialect );
    if ( ul < ISQLANG_V1 || ul > ISQLANG_V2 )
        return ISQLANG_V2;

    return ul;
} //GetDialect

//+---------------------------------------------------------------------------
//
//  Member:     CixssoQuery::ExecuteQuery - private
//
//  Synopsis:   Executes the query and builds an IRowset or IRowsetScroll
//              as necessary.
//
//  Arguments:  NONE
//
//  History:    29 Oct 1996      Alanw    Created
//
//----------------------------------------------------------------------------

void CixssoQuery::ExecuteQuery( )
{
    Win4Assert( 0 == _pIRowset );     // Should not have executed query

    //
    //  Setup the variables needed to execute this query; including:
    //
    //      Query
    //      MaxRecords
    //      SortBy
    //

    ixssoDebugOut(( DEB_TRACE, "ExecuteQuery:\n" ));
    ixssoDebugOut(( DEB_TRACE, "\tQuery = '%ws'\n", _pwszRestriction ));
    if ( 0 == _pwszRestriction || 0 == *_pwszRestriction )
    {
        THROW( CIxssoException(MSG_IXSSO_MISSING_RESTRICTION, 0) );
    }


    ixssoDebugOut(( DEB_TRACE, "\tMaxRecords = %d\n", _maxResults ));
    ixssoDebugOut(( DEB_TRACE, "\tFirstRowss = %d\n", _cFirstRows ));

    //
    //  Get the columns in the query
    //
    ixssoDebugOut(( DEB_TRACE, "\tColumns = '%ws'\n", _pwszColumns ));
    if ( 0 == _pwszColumns || 0 == *_pwszColumns )
    {
        THROW( CIxssoException(MSG_IXSSO_MISSING_OUTPUTCOLUMNS, 0) );
    }

    if ( 0 != _pwszGroup && 0 != *_pwszGroup && _fSequential )
    {
        // Grouped queries are always non-sequential.
        _fSequential = FALSE;
    }

    //
    // Convert the textual form of the restriction, output columns and
    // sort columns into a DBCOMMANDTREE.
    //
    if (InvalidLCID == _lcid)
    {
        THROW( CIxssoException(MSG_IXSSO_INVALID_LOCALE, 0) );
    }

    ULONG ulDialect = GetDialect();

    CTextToTree textToTree( _pwszRestriction,
                            ulDialect,
                            _pwszColumns,
                            GetColumnMapper(),
                            _lcid,
                            _pwszSort,
                            _pwszGroup,
                            0,
                            _maxResults,
                            _cFirstRows,
                            TRUE            // Keep the friendly column names
                          );


    CDbCmdTreeNode * pDbCmdTree =  (CDbCmdTreeNode *) (void *) textToTree.FormFullTree();
    XPtr<CDbCmdTreeNode> xDbCmdTree( pDbCmdTree );

    CDynArray<WCHAR>    apCatalog;
    CDynArray<WCHAR>    apMachine;

    //
    //  Get the location of the catalog.  Use the default if the catalog
    //  property is not set.
    //
    if ( 0 == _pwszCatalog )
    {
        GetDefaultCatalog();
        if ( 0 == _pwszCatalog )
            THROW( CIxssoException(MSG_IXSSO_NO_SUCH_CATALOG, 0) );
    }
    
    ixssoDebugOut(( DEB_TRACE, "\tCatalog = '%ws'\n", _pwszCatalog ));
    ULONG cCatalogs = ParseCatalogs( _pwszCatalog, apCatalog, apMachine );

    //
    //  Get the scope specification(s) for the query
    //    CiScope
    //    CiFlags
    //

    Win4Assert( _cScopes <= _apwszScope.Size() );

    for ( unsigned i = 0; i < _cScopes; i++)
    {
#   if CIDBG
        char szIdx[10] = "";
        if (_cScopes > 1)
            sprintf( szIdx, " [%d]", i );
#   endif // CIDBG

        ixssoDebugOut(( DEB_TRACE, "\tCiScope%s = '%ws'\n", szIdx, _apwszScope[i] ));

        //
        //  Get the query flags.
        //

        if (i >= _aulDepth.Count())
            _aulDepth[i] = QUERY_DEEP;
        if ( IsAVirtualPath( _apwszScope[i] ) )
            _aulDepth[i] |= QUERY_VIRTUAL_PATH;

        ixssoDebugOut(( DEB_TRACE, "\tCiFlags%s = '%ws'\n", szIdx,
                                      _aulDepth.Get(i) & QUERY_DEEP ? L"DEEP":L"SHALLOW" ));
    }

    //
    //  We've setup all the parameters to run the query.  Run the query
    //  now.
    //
    IUnknown * pIUnknown;
    ICommand *pCommand = 0;

    SCODE sc = _xCmdCreator->CreateICommand(&pIUnknown, 0);

    if (SUCCEEDED (sc)) 
    {
       XInterface<IUnknown> xUnk( pIUnknown );
       sc = pIUnknown->QueryInterface(IID_ICommand, (void **)&pCommand);
    }

    if ( 0 == pCommand )
    {
        THROW( CIxssoException(sc, 0) );
    }

    XInterface<ICommand> xICommand(pCommand);

    if (0 == _cScopes)
    {
        //
        // Default path: search everywhere
        //

        const WCHAR * pwszPath = L"\\";

        DWORD dwDepth = QUERY_DEEP;

        if ( 1 == cCatalogs )
        {
            SetScopeProperties( pCommand,
                                1,
                                &pwszPath,
                                &dwDepth,
                                apCatalog.GetPointer(),
                                apMachine.GetPointer() );
        }
        else
        {
            SetScopeProperties( pCommand,
                                1,
                                &pwszPath,
                                &dwDepth,
                                0,
                                0 );

            SetScopeProperties( pCommand,
                                cCatalogs,
                                0,
                                0,
                                apCatalog.GetPointer(),
                                apMachine.GetPointer() );
        }
    }
    else
    {
        SetScopeProperties( pCommand,
                            _cScopes,
                            (WCHAR const * const *)_apwszScope.GetPointer(),
                            _aulDepth.GetPointer(),
                            0,
                            0 );

        SetScopeProperties( pCommand,
                            cCatalogs,
                            0,
                            0,
                            apCatalog.GetPointer(),
                            apMachine.GetPointer() );
    }

    ICommandTree * pICmdTree = 0;
    sc = xICommand->QueryInterface(IID_ICommandTree, (void **)&pICmdTree);
    if (FAILED (sc) )
    {
        THROW( CException( QUERY_EXECUTE_FAILED ) );
    }

    DBCOMMANDTREE * pDbCommandTree = pDbCmdTree->CastToStruct();
    sc = pICmdTree->SetCommandTree(&pDbCommandTree, DBCOMMANDREUSE_NONE, FALSE);
    pICmdTree->Release();

    if ( FAILED(sc) )
    {
        THROW( CException(sc) );
    }

    xDbCmdTree.Acquire();

    //
    //  Set properties on the command object.
    //
    const unsigned MAX_PROPS = 5;
    DBPROPSET  aPropSet[MAX_PROPS];
    DBPROP     aProp[MAX_PROPS];
    ULONG      cProp = 0;
    ULONG      iHitCountProp = MAX_PROPS;

    // Set the property that says whether we want to enumerate

    Win4Assert( cProp < MAX_PROPS );
    ixssoDebugOut(( DEB_TRACE, "\tUseContentIndex = %s\n",
                       _fAllowEnumeration ? "FALSE" : "TRUE" ));

    aProp[cProp].dwPropertyID = DBPROP_USECONTENTINDEX;
    aProp[cProp].dwOptions    = DBPROPOPTIONS_OPTIONAL;
    aProp[cProp].dwStatus     = 0;         // Ignored
    aProp[cProp].colid        = dbcolNull;
    aProp[cProp].vValue.vt    = VT_BOOL;
    aProp[cProp].vValue.boolVal  = _fAllowEnumeration ? VARIANT_FALSE :
                                                        VARIANT_TRUE;

    aPropSet[cProp].rgProperties = &aProp[cProp];
    aPropSet[cProp].cProperties = 1;
    aPropSet[cProp].guidPropertySet = guidQueryExt;

    cProp++;

    // Set the property for retrieving hit count

    Win4Assert( cProp < MAX_PROPS );
    ixssoDebugOut(( DEB_TRACE, "\tNlHitCount = %s\n",
                    ( _dwOptimizeFlags & eOptHitCount ) ? "TRUE" :
                                                          "FALSE" ));

    aProp[cProp].dwPropertyID = NLDBPROP_GETHITCOUNT;
    aProp[cProp].dwOptions    = DBPROPOPTIONS_OPTIONAL;
    aProp[cProp].dwStatus     = 0;         // Ignored
    aProp[cProp].colid        = dbcolNull;
    aProp[cProp].vValue.vt    = VT_BOOL;
    aProp[cProp].vValue.boolVal  = 
              ( _dwOptimizeFlags & eOptHitCount ) ? VARIANT_TRUE :
                                                    VARIANT_FALSE;

    aPropSet[cProp].rgProperties = &aProp[cProp];
    aPropSet[cProp].cProperties = 1;
    aPropSet[cProp].guidPropertySet = DBPROPSET_NLCOMMAND;

    iHitCountProp = cProp;

    cProp++;

    if ( _dwOptimizeFlags & eOptPerformance )
    {
        // Set the property for magically fast queries

        Win4Assert( cProp < MAX_PROPS );
        ixssoDebugOut(( DEB_TRACE, "\tCiDeferNonIndexedTrimming = TRUE\n" ));

        aProp[cProp].dwPropertyID = DBPROP_DEFERNONINDEXEDTRIMMING;
        aProp[cProp].dwOptions    = DBPROPOPTIONS_OPTIONAL;
        aProp[cProp].dwStatus     = 0;         // Ignored
        aProp[cProp].colid        = dbcolNull;
        aProp[cProp].vValue.vt    = VT_BOOL;
        aProp[cProp].vValue.boolVal  = VARIANT_TRUE;

        aPropSet[cProp].rgProperties = &aProp[cProp];
        aPropSet[cProp].cProperties = 1;
        aPropSet[cProp].guidPropertySet = guidQueryExt;

        cProp++;
    }

    // set the start hit property if it is set
    if ( _StartHit.Get() )
    {
        // Set the start hit property
        Win4Assert( cProp < MAX_PROPS );
        ixssoDebugOut(( DEB_TRACE, "\tStartHit = %x\n", _StartHit.Get() ));
        
        aProp[cProp].dwPropertyID           = NLDBPROP_STARTHIT;
        aProp[cProp].dwOptions              = 0;
        aProp[cProp].dwStatus               = 0;         // Ignored
        aProp[cProp].colid                  = dbcolNull;
        V_VT(&(aProp[cProp].vValue))        = VT_ARRAY | VT_I4;
        V_ARRAY(&(aProp[cProp].vValue))     = _StartHit.Get();

        aPropSet[cProp].rgProperties = &aProp[cProp];
        aPropSet[cProp].cProperties = 1;
        aPropSet[cProp].guidPropertySet = DBPROPSET_NLCOMMAND;

        cProp++;
    }

    if ( 0 != _iResourceFactor )
    {
        // Set the query timeout in milliseconds

        Win4Assert( cProp < MAX_PROPS );
        aProp[cProp].dwPropertyID = DBPROP_COMMANDTIMEOUT;
        aProp[cProp].dwOptions    = DBPROPOPTIONS_OPTIONAL;
        aProp[cProp].dwStatus     = 0;         // Ignored
        aProp[cProp].colid        = dbcolNull;
        aProp[cProp].vValue.vt    = VT_I4;
        aProp[cProp].vValue.lVal  = _iResourceFactor;

        aPropSet[cProp].rgProperties = &aProp[cProp];
        aPropSet[cProp].cProperties = 1;
        aPropSet[cProp].guidPropertySet = guidRowsetProps;

        cProp++;
    }

    if ( cProp > 0 )
    {

        ICommandProperties * pCmdProp = 0;
        sc = xICommand->QueryInterface(IID_ICommandProperties,
                                       (void **)&pCmdProp);

        if (FAILED (sc) )
        {
            THROW( CException( QUERY_EXECUTE_FAILED ) );
        }

        sc = pCmdProp->SetProperties( cProp, aPropSet );
        pCmdProp->Release();

        if ( DB_S_ERRORSOCCURRED == sc ||
             DB_E_ERRORSOCCURRED == sc )
        {
            // Ignore an 'unsupported' error trying to set the GetHitCount
            // property.

            unsigned cErrors = 0;
            for (unsigned i = 0; i < cProp; i++)
            {
                if ( i == iHitCountProp &&
                     aProp[i].dwStatus == DBPROPSTATUS_NOTSUPPORTED )
                    continue;

                if (aProp[i].dwStatus != DBPROPSTATUS_OK)
                    cErrors++;
            }
            if ( 0 == cErrors )
                sc = S_OK;
        }

        if ( FAILED(sc) || DB_S_ERRORSOCCURRED == sc )
        {
            THROW( CException( QUERY_EXECUTE_FAILED ) );
        }
    }
    //
    //  Execute the query
    //
    sc = xICommand->Execute( 0,                    // No aggr
                          IsSequential() ? IID_IRowset : IID_IRowsetExactScroll,
                          0,                    // disp params
                          0,            // # rowsets returned
                          (IUnknown **) &_pIRowset );


    if ( FAILED(sc) )
    {
        ERRORINFO ErrorInfo;
        XInterface<IErrorInfo> xErrorInfo;
        SCODE sc2 = GetOleDBErrorInfo(xICommand.GetPointer(),
                                       IID_ICommand,
                                       _lcid,
                                       eMostDetailedCIError,
                                       &ErrorInfo,
                                       (IErrorInfo **)xErrorInfo.GetQIPointer());
        // Post IErrorInfo only if we have a valid ptr to it
        if (SUCCEEDED(sc2) && 0 != xErrorInfo.GetPointer())
        {
            sc = ErrorInfo.hrError;
            THROW( CPostedOleDBException(sc, xErrorInfo.GetPointer()) );
        }
        else
            THROW( CException(sc) );
    }

    xICommand.Acquire()->Release();

    //
    //  Create some of the restriction specific variables.
    //

    //
    // Get _pIRowsetQueryStatus interface
    //
    sc = _pIRowset->QueryInterface( IID_IRowsetQueryStatus,
                                    (void **) &_pIRowsetQueryStatus );

    if ( FAILED(sc) )
    {
        THROW( CException(sc) );
    }

    Win4Assert( 0 != _pIRowsetQueryStatus );
}

//+---------------------------------------------------------------------------
//
//  Member:     CixssoQuery::GetQueryStatus - private
//
//  Synopsis:   If a query is active, returns the query status
//
//  Arguments:  NONE
//
//  Returns:    DWORD - query status
//
//  History:    15 Nov 1996      Alanw    Created
//
//----------------------------------------------------------------------------

DWORD CixssoQuery::GetQueryStatus( )
{
    DWORD dwStatus = 0;

    SCODE sc;
    if ( ! _pIRowsetQueryStatus )
        THROW( CIxssoException(MSG_IXSSO_NO_ACTIVE_QUERY, 0) );

    sc = _pIRowsetQueryStatus->GetStatus( &dwStatus );
    if ( ! SUCCEEDED(sc) )
        THROW( CException( sc ) );

    return dwStatus;
}


//+---------------------------------------------------------------------------
//
//  Member:     CixssoQuery::IsAVirtualPath - private
//
//  Synopsis:   Determines if the path passed is a virtual or physical path.
//              If it's a virtual path, then / are changed to \.
//
//  History:    96-Feb-14   DwightKr    Created
//
//----------------------------------------------------------------------------

BOOL CixssoQuery::IsAVirtualPath( WCHAR * wcsPath )
{
    Win4Assert ( 0 != wcsPath );
    if ( 0 == wcsPath[0] )
    {
        return TRUE;
    }

    if ( (L':' == wcsPath[1]) || (L'\\' == wcsPath[0]) )
    {
        return FALSE;
    }
    else
    {
        //
        //  Flip slashes to backslashes
        //

        for ( WCHAR *wcsLetter = wcsPath;
              *wcsLetter != 0;
              wcsLetter++
            )
        {
            if ( L'/' == *wcsLetter )
            {
                *wcsLetter = L'\\';
            }
        }

    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\web\ixsso\ixsso.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2002.
//
//  File:       ixsso.cxx
//
//  Contents:   Query SSO class
//
//  History:    25 Oct 1996      Alanw    Created
//
//----------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

//-----------------------------------------------------------------------------
// Include Files
//-----------------------------------------------------------------------------


// debugging macros
#include "ssodebug.hxx"

DECLARE_INFOLEVEL( ixsso )

// class declaration
#include "stdcf.hxx"
#include "ixsso.hxx"
#include <string.hxx>
#include <codepage.hxx>

#include <initguid.h>
#include <adoid.h>          // ADO CLSID and IID definitions
#include <adoint.h>         // ADO interface definition

const WCHAR * pwcDefaultDialect = L"2";

extern WCHAR * g_pwszProgIdQuery;

#if CIDBG
    extern ULONG g_ulObjCount;
    extern LONG  g_lQryCount;
#endif // CIDBG

//-----------------------------------------------------------------------------
//
//  Member:     CixssoQuery::CixssoQuery - public
//
//  Synopsis:   Constructor of CixssoQuery
//
//  Arguments:  [pitlb] - pointer to ITypeLib for ixsso
//              [pIAdoRecordsetCF] - pointer to the class factory for ADO
//                        recordsets
//
//  History:    06 Nov 1996      Alanw    Created
//
//-----------------------------------------------------------------------------

CixssoQuery::CixssoQuery( ITypeLib * pitlb,
                          IClassFactory * pIAdoRecordsetCF,
                          BOOL fAdoV15,
                          const CLSID & ssoClsid) :
    _pwszRestriction( 0 ),
    _pwszSort( 0 ),
    _pwszGroup( 0 ),
    _pwszColumns( 0 ),
    _pwszCatalog( 0 ),
    _pwszDialect( 0 ),
    _cScopes( 0 ),
    _apwszScope( 0 ),
    _aulDepth( 0 ),

    _fAllowEnumeration( FALSE ),
    _dwOptimizeFlags( eOptHitCount | eOptRecall ),
    _maxResults( 0 ),
    _cFirstRows( 0 ),
    _iResourceFactor( 0 ),

    _StartHit( 0 ),

    _lcid( GetSystemDefaultLCID() ),
    _ulCodepage( CP_ACP ),
    _err( IID_IixssoQuery ),
    _pIAdoRecordsetCF( pIAdoRecordsetCF ),
    _fAdoV15( fAdoV15 ),
    _pIRowset( 0 ),
    _pIRowsetQueryStatus( 0 ),
    _fSequential( FALSE ),
    _PropertyList( _ulCodepage )
{
    _cRef = 1;
    Win4Assert(g_pTheGlobalIXSSOVariables);


    SCODE sc;
    
    if ( CLSID_CissoQueryEx == ssoClsid )
    {
        _err = IID_IixssoQueryEx;
        sc = pitlb->GetTypeInfoOfGuid( IID_IixssoQueryEx, &_ptinfo );
    }
    else if ( CLSID_CissoQuery == ssoClsid )
    {
        sc = pitlb->GetTypeInfoOfGuid( IID_IixssoQuery, &_ptinfo );
    }
    else 
        THROW( CException(E_INVALIDARG));

    if (FAILED(sc))
    {
        ixssoDebugOut(( DEB_ERROR, "GetTypeInfoOfGuid failed (%x)\n", sc ));
        Win4Assert(SUCCEEDED(sc));

        THROW( CException(sc) );
    }

#if CIDBG
    LONG cAdoRecordsetRefs =
#endif // CIDBG
        _pIAdoRecordsetCF->AddRef();

    XInterface<IColumnMapper> xColumnMapper;
    ISimpleCommandCreator *pCmdCreator = 0;

    pCmdCreator = g_pTheGlobalIXSSOVariables->xCmdCreator.GetPointer();
    g_pTheGlobalIXSSOVariables->xColumnMapperCreator->GetColumnMapper(
                                LOCAL_MACHINE,
                                INDEX_SERVER_DEFAULT_CAT,
                                (IColumnMapper **)xColumnMapper.GetQIPointer());

    if (0 == pCmdCreator)
        THROW(CException(REGDB_E_CLASSNOTREG));

    _xCmdCreator.Set(pCmdCreator);
#if CIDBG
    LONG cCmdCreatorRefs =
#endif // CIDBG
        pCmdCreator->AddRef();
    Win4Assert(xColumnMapper.GetPointer());
    _PropertyList.SetDefaultList(xColumnMapper.GetPointer());

    INC_OBJECT_COUNT();

    ixssoDebugOut((DEB_REFCOUNTS, "[DLL]: Create query: refcounts: glob %d qry %d AdoRSCF %d CmdCtor %d\n",
                   g_ulObjCount,
                   g_lQryCount,
                   cAdoRecordsetRefs,
                   cCmdCreatorRefs ));

}

CixssoQuery::~CixssoQuery( )
{
    Reset();

    if (_ptinfo)
        _ptinfo->Release();

#if CIDBG
    LONG cAdoRecordsetRefs = -2;
#endif // CIDBG
    if (_pIAdoRecordsetCF)
#if CIDBG
        cAdoRecordsetRefs =
#endif // CIDBG
        _pIAdoRecordsetCF->Release();

    DEC_OBJECT_COUNT();

#if CIDBG
    LONG l = InterlockedDecrement( &g_lQryCount );
    Win4Assert( l >= 0 );
#endif //CIDBG

    ixssoDebugOut((DEB_REFCOUNTS, "[DLL]: Delete query: refcounts: glob %d qry %d AdoRSCF %d\n",
                   g_ulObjCount,
                   g_lQryCount,
                   cAdoRecordsetRefs ));
}


//+---------------------------------------------------------------------------
//
//  Member:     CixssoQuery::Reset - public
//
//  Synopsis:   Clear any internal state in the object
//
//  Arguments:  - none -
//
//  Notes:      Doesn't currently clear lcid or property list.
//
//  History:    05 Mar 1997      Alanw    Created
//
//----------------------------------------------------------------------------

HRESULT CixssoQuery::Reset(void)
{
    _maxResults = 0;
    _cFirstRows = 0;
    _cScopes = 0;
    _fAllowEnumeration = FALSE;
    _dwOptimizeFlags = eOptHitCount | eOptRecall;

    if (_pIRowset)
    {
        _pIRowset->Release();
        _pIRowset = 0;
    }

    if (_pIRowsetQueryStatus)
    {
        _pIRowsetQueryStatus->Release();
        _pIRowsetQueryStatus = 0;
    }

    delete _pwszRestriction;
    _pwszRestriction = 0;

    delete _pwszSort;
    _pwszSort = 0;

    delete _pwszGroup;
    _pwszGroup = 0;

    delete _pwszColumns;
    _pwszColumns = 0;

    delete _pwszCatalog;
    _pwszCatalog = 0;

    delete _pwszDialect;
    _pwszDialect = 0;

//  Unneeded since cScopes is set to zero.
//    _apwszScope.Clear();

    _StartHit.Destroy();
    return S_OK;
}

//
// ASP Methods
//

#include <asp/asptlb.h>

STDMETHODIMP CixssoQuery::OnStartPage (IUnknown* pUnk)
{
    // reset the error structure
    _err.Reset();
    
    SCODE sc;
    IScriptingContext *piContext = 0;
    IRequest* piRequest = 0;
    IRequestDictionary *piRequestDict = 0;

    ISessionObject* piSession = 0;

    do
    {
        //Get IScriptingContext Interface
        sc = pUnk->QueryInterface(IID_IScriptingContext, (void**)&piContext);
        if (FAILED(sc))
            break;

        //Get Request Object Pointer
        sc = piContext->get_Request(&piRequest);
        if (FAILED(sc))
            break;

        //Get ServerVariables Pointer
        sc = piRequest->get_ServerVariables(&piRequestDict);
        if (FAILED(sc))
            break;

        VARIANT vtOut;
        VariantInit(&vtOut);

        //
        // Get the HTTP_ACCEPT_LANGUAGE Item.  Don't need to check the
        // return code; use a default value for the locale ID
        //
        piRequestDict->get_Item(g_vtAcceptLanguageHeader, &vtOut);

        //
        //vtOut Contains an IDispatch Pointer.  To fetch the value
        //for HTTP_ACCEPT_LANGUAGE you must get the Default Value for the
        //Object stored in vtOut using VariantChangeType.
        //
        if (V_VT(&vtOut) != VT_BSTR)
            VariantChangeType(&vtOut, &vtOut, 0, VT_BSTR);

        if (V_VT(&vtOut) == VT_BSTR)
        {
            ixssoDebugOut((DEB_TRACE, "OnStartPage: HTTP_ACCEPT_LANGUAGE = %ws\n",
                                       V_BSTR(&vtOut) ));
            SetLocaleString(V_BSTR(&vtOut));
        }
        else
        {
            ixssoDebugOut(( DEB_TRACE,
                            "OnStartPage: HTTP_ACCEPT_LANGAUGE was not set in ServerVariables; using lcid=0x%x\n",
                            GetSystemDefaultLCID() ));

            put_LocaleID( GetSystemDefaultLCID() );
        }
        VariantClear(&vtOut);

        _ulCodepage = LocaleToCodepage( _lcid );

        //Get Session Object Pointer
        sc = piContext->get_Session(&piSession);
        if (FAILED(sc))
        {
            // Don't fail request if sessions are not enabled.  This specific
            // error is given when AspAllowSessionState is zero.
            if (TYPE_E_ELEMENTNOTFOUND == sc)
                sc = S_OK;

            break;
        }

        LONG cp = CP_ACP;
        sc = piSession->get_CodePage( &cp );
        if (FAILED(sc))
        {
            // sc = S_OK;
            break;
        }

        if (cp != CP_ACP)
            _ulCodepage = cp;

    } while (FALSE);

    if (piSession)
        piSession->Release();

    if (piRequestDict)
        piRequestDict->Release();
    if (piRequest)
        piRequest->Release();
    if (piContext)
        piContext->Release();

    return sc;
}

//-----------------------------------------------------------------------------
// CixssoQuery IUnknown Methods
//-----------------------------------------------------------------------------

STDMETHODIMP
CixssoQuery::QueryInterface(REFIID iid, void * * ppv)
{
    *ppv = 0;

    if (iid == IID_IUnknown || iid == IID_IDispatch)
        *ppv = (IDispatch *) this;
    else if (iid == IID_ISupportErrorInfo )
        *ppv = (ISupportErrorInfo *) this;
    else if (iid == IID_IixssoQuery )
        *ppv = (IixssoQuery *) this;
    else if (iid == IID_IixssoQueryPrivate )
        *ppv = (IixssoQueryPrivate *) this;
    else if ( iid == IID_IixssoQueryEx )
        *ppv = (IixssoQueryEx *) this;
#if 0
    else if ( iid == IID_IObjectSafety )
        *ppv = (IObjectSafety *) this;
#endif
    else if ( iid == IID_IObjectWithSite )
        *ppv = (IObjectWithSite *) this;
    else
        return E_NOINTERFACE;

    AddRef();
    return S_OK;
}

STDMETHODIMP_(ULONG)
CixssoQuery::AddRef(void)
{
    return InterlockedIncrement((long *)&_cRef);
}

STDMETHODIMP_(ULONG)
CixssoQuery::Release(void)
{
    ULONG uTmp = InterlockedDecrement((long *)&_cRef);
    if (uTmp == 0)
    {
        delete this;
        return 0;
    }
    return uTmp;
}


//-----------------------------------------------------------------------------
// CixssoQuery IDispatch Methods
//-----------------------------------------------------------------------------

STDMETHODIMP
CixssoQuery::GetTypeInfoCount(UINT * pctinfo)
{
    *pctinfo = 1;
    return S_OK;
}

STDMETHODIMP
CixssoQuery::GetTypeInfo(
      UINT itinfo,
      LCID lcid,
      ITypeInfo * * pptinfo)
{
    _ptinfo->AddRef();
    *pptinfo = _ptinfo;
    return S_OK;
}

STDMETHODIMP
CixssoQuery::GetIDsOfNames(
      REFIID riid,
      OLECHAR * * rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID * rgdispid)
{
    return DispGetIDsOfNames(_ptinfo, rgszNames, cNames, rgdispid);
}

STDMETHODIMP
CixssoQuery::Invoke(
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS * pParams,
      VARIANT * pvarResult,
      EXCEPINFO * pexcepinfo,
      UINT * puArgErr)
{
    ixssoDebugOut((DEB_IDISPATCH, "Invoking method dispid=%d wFlags=%d\n",
                                   dispidMember, wFlags ));

    _err.Reset();

    SCODE sc = DispInvoke( this, _ptinfo,
                           dispidMember, wFlags, pParams,
                           pvarResult, pexcepinfo, puArgErr );

    if ( _err.IsError() )
        sc = DISP_E_EXCEPTION;

    return sc;
}

STDMETHODIMP
CixssoQuery::InterfaceSupportsErrorInfo(
    REFIID riid)
{
    if (IID_IixssoQueryEx == riid || IID_IixssoQuery == riid )
        return S_OK;
    else
        return S_FALSE;
}


//-----------------------------------------------------------------------------
// CixssoQuery property Methods
//-----------------------------------------------------------------------------

//+---------------------------------------------------------------------------
//
//  Member:     CixssoQuery::CopyWstrToBstr - private inline
//
//  Synopsis:   Copies a Unicode string to a BSTR
//
//  Arguments:  [pbstr] - destination BSTR
//              [pwstr] - string to be copied
//
//  Returns:    SCODE - status return
//
//  History:    25 Oct 1996      Alanw    Created
//
//----------------------------------------------------------------------------

inline
SCODE CixssoQuery::CopyWstrToBstr( BSTR * pbstr, WCHAR const * pwstr )
{
    *pbstr = 0;
    if (pwstr)
    {
        *pbstr = SysAllocString( pwstr );
        if (0 == *pbstr)
            return E_OUTOFMEMORY;  
    }
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CixssoQuery::CopyBstrToWstr - private inline
//
//  Synopsis:   Copies a BSTR to a Unicode string
//
//  Arguments:  [bstr] - string to be copied
//              [rwstr] - destination string
//
//  Returns:    SCODE - status return
//
//  History:    25 Oct 1996      Alanw    Created
//
//----------------------------------------------------------------------------

inline
SCODE CixssoQuery::CopyBstrToWstr( BSTR bstr, LPWSTR & rwstr )
{
    SCODE sc = S_OK;

    if (rwstr)
    {
        delete rwstr;
        rwstr = 0;
    }

    if (bstr)
    {
        CTranslateSystemExceptions translate;
        TRY
        {
            unsigned cch = SysStringLen( bstr )+1;
            if (cch > 1)
            {
                rwstr = new WCHAR[ cch ];
                RtlCopyMemory( rwstr, bstr, cch*sizeof (WCHAR) );
            }
        }
        CATCH (CException, e)
        {
            if (e.GetErrorCode() == STATUS_ACCESS_VIOLATION)
                sc = E_FAIL;
            else
                sc = E_OUTOFMEMORY;

            SetError( sc, OLESTR("PutProperty") );
        }
        END_CATCH
    }
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:     CixssoQuery::CopyBstrToWstr - private inline
//
//  Synopsis:   Copies a BSTR to a Unicode string
//
//  Arguments:  [bstr] - string to be copied
//              [apstr] - destination string array
//              [i] - string array index
//
//  Returns:    SCODE - status return
//
//  History:    25 Oct 1996      Alanw    Created
//
//----------------------------------------------------------------------------

inline
SCODE CixssoQuery::CopyBstrToWstrArray( BSTR bstr,
                                        CDynArray<WCHAR> &apstr,
                                        unsigned i )
{
    SCODE sc = S_OK;

    if (bstr)
    {
        CTranslateSystemExceptions translate;
        TRY
        {
            unsigned cch = SysStringLen( bstr )+1;
            if (cch > 1)
            {
                XArray<WCHAR> wstr( cch );

                RtlCopyMemory( wstr.GetPointer(), bstr, cch*sizeof (WCHAR) );
                delete apstr.Acquire( i );
                apstr.Add( wstr.GetPointer(), i );
                wstr.Acquire();
            }
            else
                apstr.Add( 0, i );
        }
        CATCH (CException, e)
        {
            if (e.GetErrorCode() == STATUS_ACCESS_VIOLATION)
                sc = E_FAIL;
            else
                sc = E_OUTOFMEMORY;

            SetError( sc, OLESTR("CopyBstrToWstrArray") );
        }
        END_CATCH
    }
    else
        apstr.Add( 0, i );

    return sc;
}

inline
SCODE CixssoQuery::GetBoolProperty( VARIANT_BOOL * pfVal, BOOL fMemberVal )
{
    *pfVal = fMemberVal ? VARIANT_TRUE : VARIANT_FALSE;
    return S_OK;
}

inline
SCODE CixssoQuery::PutBoolProperty( VARIANT_BOOL fInputVal, BOOL & fMemberVal )
{
    fMemberVal = (fInputVal == VARIANT_TRUE) ? TRUE : FALSE;
    return S_OK;
}


//-----------------------------------------------------------------------------
// CixssoQuery read-write properties
//-----------------------------------------------------------------------------

STDMETHODIMP
CixssoQuery::get_Query(BSTR * pstr)
{
    _err.Reset();
    return CopyWstrToBstr( pstr, _pwszRestriction );
}

STDMETHODIMP
CixssoQuery::put_Query(BSTR str)
{
    _err.Reset();
    return CopyBstrToWstr( str, _pwszRestriction );
}


STDMETHODIMP
CixssoQuery::get_GroupBy(BSTR * pstr)
{
    _err.Reset();
#if IXSSO_CATEGORIZE == 1
    return CopyWstrToBstr( pstr, _pwszGroup );
#else // IXSSO_CATEGORIZE
    return E_NOTIMPL;
#endif // IXSSO_CATEGORIZE
}

STDMETHODIMP
CixssoQuery::put_GroupBy(BSTR str)
{
    _err.Reset();
#if IXSSO_CATEGORIZE == 1
    return CopyBstrToWstr( str, _pwszGroup );
#else // IXSSO_CATEGORIZE
    return E_NOTIMPL;
#endif // IXSSO_CATEGORIZE
}


STDMETHODIMP
CixssoQuery::get_Columns(BSTR * pstr)
{
    _err.Reset();
    return CopyWstrToBstr( pstr, _pwszColumns );
}

STDMETHODIMP
CixssoQuery::put_Columns(BSTR str)
{
    _err.Reset();
    return CopyBstrToWstr( str, _pwszColumns );
}

STDMETHODIMP
CixssoQuery::get_LocaleID(LONG * plVal)
{
    _err.Reset();
    *plVal = _lcid;
    return S_OK;
}

STDMETHODIMP
CixssoQuery::put_LocaleID(LONG  lVal)
{
    _err.Reset();
    _lcid = lVal;
    return S_OK;
}

STDMETHODIMP
CixssoQuery::get_CodePage(LONG * plVal)
{
    _err.Reset();
    *plVal = _ulCodepage;
    return S_OK;
}

STDMETHODIMP
CixssoQuery::put_CodePage(LONG  lVal)
{
    _err.Reset();
    if (0 == IsValidCodePage( lVal ) )
    {
        return E_INVALIDARG;
    }
    _ulCodepage = lVal;
    return S_OK;
}

STDMETHODIMP
CixssoQuery::get_SortBy(BSTR * pstr)
{
    _err.Reset();
    return CopyWstrToBstr( pstr, _pwszSort );
}

STDMETHODIMP
CixssoQuery::put_SortBy(BSTR str)
{
    _err.Reset();
    return CopyBstrToWstr( str, _pwszSort );
}

STDMETHODIMP
CixssoQuery::get_CiScope(BSTR * pstr)
{
    _err.Reset();
    if (_cScopes > 1)
    {
        SetError( E_INVALIDARG, OLESTR("get CiScope") );
        return _err.GetError();
    }

    return CopyWstrToBstr( pstr, _apwszScope.Get(0) );
}

STDMETHODIMP
CixssoQuery::put_CiScope(BSTR str)
{
    _err.Reset();
    if (_cScopes > 1)
    {
        SetError( E_INVALIDARG, OLESTR("set CiScope") );
        return _err.GetError();
    }

    SCODE sc = CopyBstrToWstrArray( str, _apwszScope, 0 );
    if (SUCCEEDED(sc))
    {
        _cScopes = (_apwszScope[0] == 0) ? 0 : 1;
    }

    return sc;
}

STDMETHODIMP
CixssoQuery::get_CiFlags(BSTR * pstr)
{
    _err.Reset();
    if (_cScopes > 1)
    {
        SetError( E_INVALIDARG, OLESTR("get CiFlags") );
        return _err.GetError();
    }
    ULONG ulDepth = QUERY_DEEP;
    if (_aulDepth.Count() > 0)
        ulDepth = _aulDepth[0];
    WCHAR * pwszDepth = ulDepth & QUERY_DEEP ? L"DEEP" : L"SHALLOW";

    return CopyWstrToBstr( pstr, pwszDepth );
}

STDMETHODIMP
CixssoQuery::put_CiFlags(BSTR str)
{
    _err.Reset();
    SCODE sc = S_OK;

    if (_cScopes > 1)
    {
        SetError( E_INVALIDARG, OLESTR("set CiFlags") );
        return _err.GetError();
    }

    CTranslateSystemExceptions translate;
    TRY
    {
        ULONG ulDepth = ParseCiDepthFlag( str );
        _aulDepth[0] = ulDepth;
    }
    CATCH( CIxssoException, e )
    {
        sc = e.GetErrorCode();
        Win4Assert( !SUCCEEDED(sc) );
        SetError( sc, OLESTR("set CiFlags"), eIxssoError );
    }
    AND_CATCH( CException, e )
    {
        sc = e.GetErrorCode();
        SetError( sc, OLESTR("set CiFlags") );
    }
    END_CATCH

    return sc;
}

STDMETHODIMP
CixssoQuery::get_Catalog(BSTR * pstr)
{
    _err.Reset();
    return CopyWstrToBstr( pstr, _pwszCatalog );
}

STDMETHODIMP
CixssoQuery::put_Catalog(BSTR str)
{
    _err.Reset();
    return CopyBstrToWstr( str, _pwszCatalog );
}

STDMETHODIMP
CixssoQuery::get_Dialect(BSTR * pstr)
{
    _err.Reset();
    return CopyWstrToBstr( pstr,
                           _pwszDialect ? _pwszDialect : pwcDefaultDialect );
}

STDMETHODIMP
CixssoQuery::put_Dialect(BSTR str)
{
    _err.Reset();
    //
    // Do some validation first
    //

    ULONG ulDialect = (ULONG) _wtoi( str );
    if ( ulDialect < ISQLANG_V1 ||
         ulDialect > ISQLANG_V2 )
    {
        SetError( E_INVALIDARG, OLESTR("set Dialect") );
        return _err.GetError();
    }

    return CopyBstrToWstr( str, _pwszDialect );
}

STDMETHODIMP
CixssoQuery::get_OptimizeFor(BSTR * pstr)
{
    _err.Reset();

    WCHAR * pwszChoice = L"recall";

    switch (_dwOptimizeFlags)
    {
    case 0:
        pwszChoice = L"nohitcount";
        break;
    case eOptPerformance:
        pwszChoice = L"performance,nohitcount";
        break;
    case eOptRecall:
        pwszChoice = L"recall,nohitcount";
        break;
    case eOptPerformance|eOptHitCount:
        pwszChoice = L"performance,hitcount";
        break;
    case eOptRecall|eOptHitCount:
        pwszChoice = L"recall,hitcount";
        break;
    case eOptHitCount:
        pwszChoice = L"hitcount";
        break;
    default:
        Win4Assert( !"Invalid value in _dwOptimizeFlags!" );
    }

    return CopyWstrToBstr( pstr, pwszChoice );
}

STDMETHODIMP
CixssoQuery::put_OptimizeFor(BSTR str)
{
    _err.Reset();

    DWORD eChoice;
    SCODE sc = ParseOptimizeFor( str, eChoice );
    if (SUCCEEDED(sc))
    {
        _dwOptimizeFlags = eChoice;
        return sc;
    }
    else
    {
        SetError( sc, OLESTR("set OptimizeFor") );
        return _err.GetError();
    }
}

STDMETHODIMP
CixssoQuery::get_AllowEnumeration(VARIANT_BOOL * pfFlag)
{
    _err.Reset();
    return GetBoolProperty( pfFlag, _fAllowEnumeration );
}

STDMETHODIMP
CixssoQuery::put_AllowEnumeration(VARIANT_BOOL fFlag)
{
    _err.Reset();
    return PutBoolProperty( fFlag, _fAllowEnumeration );
}

STDMETHODIMP
CixssoQuery::get_MaxRecords(LONG * plVal)
{
    _err.Reset();
    *plVal = _maxResults;
    return S_OK;
}

STDMETHODIMP
CixssoQuery::put_MaxRecords(LONG lVal)
{
    _err.Reset();
    if (lVal < 0)
    {
        SetError( E_INVALIDARG, OLESTR("set MaxRecords") );
        return _err.GetError();
    }
    else if (IsQueryActive())
    {
        SetError( MSG_IXSSO_QUERY_ACTIVE, OLESTR("set MaxRecords") );
        return _err.GetError();
    }

    _maxResults = lVal;
    return S_OK;
}

STDMETHODIMP
CixssoQuery::get_FirstRows(LONG * plVal)
{
    _err.Reset();
    *plVal = _cFirstRows;
    return S_OK;
}

STDMETHODIMP
CixssoQuery::put_FirstRows(LONG lVal)
{
    _err.Reset();
    if (lVal < 0)
    {
        SetError( E_INVALIDARG, OLESTR("set FirstRows") );
        return _err.GetError();
    }
    else if (IsQueryActive())
    {
        SetError( MSG_IXSSO_QUERY_ACTIVE, OLESTR("set FirstRows") );
        return _err.GetError();
    }

    _cFirstRows = lVal;
    return S_OK;
}


STDMETHODIMP
CixssoQuery::get_StartHit(VARIANT * pvar)
{
    _err.Reset();
    if (_StartHit.Get() != 0)
    {
        XGrowable<WCHAR> awchBuf;

        FormatLongVector( _StartHit.Get(), awchBuf );

        VariantInit( pvar );
        V_BSTR(pvar) = SysAllocString( awchBuf.Get() );
        if ( V_BSTR(pvar) != 0 )
        {
            V_VT(pvar) = VT_BSTR;
        }
        else
        {
            return E_OUTOFMEMORY;
        }
    }
    else
    {
        V_VT(pvar) = VT_EMPTY;
    }
    return S_OK;
}

STDMETHODIMP
CixssoQuery::put_StartHit(VARIANT* pvar)
{
    _err.Reset();
    //
    // NOTE:  StartHit is not read-only with an active query so it can
    //        be set from the recordset prior to calling QueryToURL.
    //
    SCODE sc;

    SAFEARRAY* psa;
    XSafeArray xsa;

    switch( V_VT(pvar) )
    {

    case VT_DISPATCH:
        //
        //pvar Contains an IDispatch Pointer.  To fetch the value
        //you must get the Default Value for the
        //Object stored in pvar using VariantChangeType.
        //
        VariantChangeType(pvar, pvar, 0, VT_BSTR);

        if (V_VT(pvar) != VT_BSTR)
        {
            return E_INVALIDARG;
        }
   // NOTE: fall through

    case VT_BSTR:
    {
        CDynArrayInPlace<LONG> aStartHit( 0 );

        ParseNumberVectorString( V_BSTR(pvar), aStartHit );
        unsigned cHits = aStartHit.Count();

        psa = SafeArrayCreateVector(VT_I4, 1, cHits);
        if ( ! psa )
            return E_OUTOFMEMORY;

        xsa.Set(psa);

        for (unsigned i=1; i<=cHits; i++)
        {
            long rgIx[1];
            LONG lVal = aStartHit.Get(i-1);
            rgIx[0] = (long)i;
            sc = SafeArrayPutElement( xsa.Get(), rgIx, &lVal );
            if ( FAILED(sc) )
                break;
        }
        if ( FAILED(sc) )
            return sc;
    }
        break;

    case VT_ARRAY | VT_I4:
        sc = SafeArrayCopy(V_ARRAY(pvar),&psa);
        if ( FAILED(sc) )
            return sc;

        xsa.Set(psa);
        if (SafeArrayGetDim(psa) != 1)
            return E_INVALIDARG;
        break;

    case VT_I4:
    case VT_I2:
        psa = SafeArrayCreateVector(VT_I4,1,1);
        if ( ! psa )
            return E_OUTOFMEMORY;

        xsa.Set(psa);
        {
            long rgIx[1];
            rgIx[0] = 1;
            long lVal = (V_VT(pvar) == VT_I4) ? V_I4(pvar) : V_I2(pvar);
            sc = SafeArrayPutElement( xsa.Get(), rgIx, &lVal );

            if ( FAILED( sc ) )
                return sc;
        }
        break;

    default:
        SetError( E_INVALIDARG, OLESTR("set StartHit") );
        return _err.GetError();

    }

    _StartHit.Destroy();
    _StartHit.Set( xsa.Acquire() );

    return S_OK;
}


STDMETHODIMP
CixssoQuery::get_ResourceUseFactor(LONG * plVal)
{
    _err.Reset();
    *plVal = _iResourceFactor;
    return S_OK;
}

STDMETHODIMP
CixssoQuery::put_ResourceUseFactor(LONG lVal)
{
    _err.Reset();

    if (IsQueryActive())
    {
        SetError( MSG_IXSSO_QUERY_ACTIVE, OLESTR("set ResourceUseFactor") );
        return _err.GetError();
    }

    _iResourceFactor = lVal;
    return S_OK;
}




//-----------------------------------------------------------------------------
// CixssoQuery read-only properties
//-----------------------------------------------------------------------------


//+---------------------------------------------------------------------------
//
//  Member:     CixssoQuery::CheckQueryStatusBit - private inline
//
//  Synopsis:   Check a specific query status bit, set variant bool accordingly
//
//  Arguments:  [pfVal] - VARIANT_BOOL to be set
//              [dwBit] - bit(s) in query status to be tested
//
//  Returns:    SCODE - status return
//
//  History:    03 Jan 1997      Alanw    Created
//
//----------------------------------------------------------------------------

inline
SCODE CixssoQuery::CheckQueryStatusBit( VARIANT_BOOL * pfVal, DWORD dwBit )
{
    SCODE sc = S_OK;
    CTranslateSystemExceptions translate;
    TRY
    {
        DWORD dwStatus = GetQueryStatus( );
        *pfVal = (dwStatus & dwBit) ? VARIANT_TRUE : VARIANT_FALSE;
    }
    CATCH( CIxssoException, e )
    {
        sc = e.GetErrorCode();
        Win4Assert( !SUCCEEDED(sc) );
        SetError( sc, OLESTR("CheckQueryStatus"), eIxssoError );
    }
    AND_CATCH( CException, e )
    {
        sc = e.GetErrorCode();
        SetError( sc, OLESTR("CheckQueryStatus") );
    }
    END_CATCH

    return sc;
}

STDMETHODIMP
CixssoQuery::get_QueryTimedOut(VARIANT_BOOL * pfFlag)
{
    _err.Reset();
    return CheckQueryStatusBit( pfFlag, STAT_TIME_LIMIT_EXCEEDED );
}

STDMETHODIMP
CixssoQuery::get_QueryIncomplete(VARIANT_BOOL * pfFlag)
{
    _err.Reset();
    return CheckQueryStatusBit( pfFlag, STAT_CONTENT_QUERY_INCOMPLETE );
}

STDMETHODIMP
CixssoQuery::get_OutOfDate(VARIANT_BOOL * pfFlag)
{
    _err.Reset();
    return CheckQueryStatusBit( pfFlag, 
                        (STAT_CONTENT_OUT_OF_DATE | STAT_REFRESH_INCOMPLETE) );
}



//-----------------------------------------------------------------------------
// CixssoQuery Methods
//-----------------------------------------------------------------------------

STDMETHODIMP
CixssoQuery::AddScopeToQuery( BSTR bstrScope,
                              BSTR bstrDepth)
{
    //
    // This is an internally used method, so don't need to reset error object here.
    //

    if (0 == bstrScope || 0 == SysStringLen(bstrScope) )
    {
        THROW( CException(E_INVALIDARG) );
    }

    SCODE sc = CopyBstrToWstrArray( bstrScope, _apwszScope, _cScopes );

    if (FAILED(sc))
    {
        THROW( CException(sc) );
    }

    ULONG ulDepth = ParseCiDepthFlag( bstrDepth );
    _aulDepth[_cScopes] = ulDepth;

    _cScopes++;

    return S_OK;
}

STDMETHODIMP
CixssoQuery::DefineColumn( BSTR bstrColDefinition)
{
    _err.Reset();

    SCODE sc = S_OK;

    CTranslateSystemExceptions translate;
    TRY
    {
        CQueryScanner scanner( bstrColDefinition, FALSE );
        XPtr<CPropEntry> xpropentry;
        CPropertyList::ParseOneLine( scanner, 0, xpropentry );

        if (xpropentry.GetPointer())
            sc = _PropertyList.AddEntry( xpropentry, 0 );
    }
    CATCH( CPListException, e )
    {
        sc = e.GetPListError();
        Win4Assert( !SUCCEEDED(sc) );
        SetError( sc, OLESTR("DefineColumn"), ePlistError );
    }
    AND_CATCH( CException, e )
    {
        sc = e.GetErrorCode();
        SetError( sc, OLESTR("DefineColumn") );
    }
    END_CATCH

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CixssoQuery::CreateRecordset - public
//
//  Synopsis:   Executes the query and returns a recordset
//
//  Arguments:  [bstrSequential] - one of "SEQUENTIAL" or "NONSEQUENTIAL",
//                      selects whether a nonsequential query is used.
//              [ppDisp] - recordset is returned here.
//
//  History:    06 Nov 1996      Alanw    Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CixssoQuery::CreateRecordset( BSTR bstrSequential,
                              IDispatch * * ppDisp)
{
    _err.Reset();

    unsigned eErrorClass = 0;
    BOOL fSetErrorNeeded = TRUE;

    if (IsQueryActive())
    {
        SetError( MSG_IXSSO_QUERY_ACTIVE, OLESTR("CreateRecordset") );
        return _err.GetError();
    }

    SCODE sc = S_OK;

    CTranslateSystemExceptions translate;
    TRY
    {
        IsSafeForScripting();

        *ppDisp = 0;

        if ( bstrSequential && 0 == _wcsicmp(bstrSequential, L"SEQUENTIAL") )
            _fSequential = TRUE;
        else if ( bstrSequential &&
                  (0 == _wcsicmp(bstrSequential, L"NONSEQUENTIAL") ||
                   0 == _wcsicmp(bstrSequential, L"NON-SEQUENTIAL")) )
            _fSequential = FALSE;
        else
        {
            SetError( E_INVALIDARG, OLESTR("CreateRecordset") );
            return _err.GetError();
        }

        ExecuteQuery();
        Win4Assert( _pIRowset != 0 );
        Win4Assert( _pIRowsetQueryStatus != 0 );

        //
        // Create an empty recordset, and put our rowset in it.
        //

        IDispatch * pRecordset = 0;
        sc = _pIAdoRecordsetCF->CreateInstance( 0,
                                                IID_IDispatch,
                                                (void **)&pRecordset );

        ADORecordsetConstruction * pRecordsetConstruction = 0;
        if ( SUCCEEDED(sc) )
        {
            sc = pRecordset->QueryInterface( IID_IADORecordsetConstruction,
                                             (void **)&pRecordsetConstruction );
        }

        if (SUCCEEDED(sc))
        {
            sc = pRecordsetConstruction->put_Rowset( _pIRowset );
            pRecordsetConstruction->Release();
        }

        if (SUCCEEDED(sc))
        {
            *ppDisp = pRecordset;
        }

        if (FAILED(sc))
        {
            if (pRecordset)
                pRecordset->Release();
            pRecordset = 0;

            _pIRowset->Release();
            _pIRowset = 0;

            _pIRowsetQueryStatus->Release();
            _pIRowsetQueryStatus = 0;
        }

        fSetErrorNeeded = FAILED(sc);
    }
    CATCH( CPListException, e )
    {
        sc = e.GetPListError();
        eErrorClass = ePlistError;
        Win4Assert( !SUCCEEDED(sc) );
    }
    AND_CATCH( CIxssoException, e )
    {
        sc = e.GetErrorCode();
        eErrorClass = eIxssoError;
        Win4Assert( !SUCCEEDED(sc) );
    }
    AND_CATCH( CParserException, e )
    {
        sc = e.GetParseError();
        eErrorClass = eParseError;
        Win4Assert( !SUCCEEDED(sc) );
    }
    AND_CATCH( CPostedOleDBException, e )
    {
        //
        // When the execution error was detected, the Ole DB error
        // info was retrieved and stored in the exception object.
        // We retrieve that here and compose the error message.
        //

        sc = e.GetErrorCode();
        Win4Assert( !SUCCEEDED(sc) );

        XInterface <IErrorInfo> xErrorInfo(e.AcquireErrorInfo());

        if (xErrorInfo.GetPointer())
        {
            BSTR bstrErrorDescription = 0;
            xErrorInfo->GetDescription(&bstrErrorDescription);
            if (bstrErrorDescription)
            {
                SetError( sc, OLESTR("CreateRecordset"), (WCHAR const *)bstrErrorDescription);
                SysFreeString(bstrErrorDescription);
                fSetErrorNeeded = FALSE;
            }
            else
                eErrorClass = eDefaultError;
        }
    }
    AND_CATCH( CException, e )
    {
        sc = e.GetErrorCode();
        eErrorClass = eDefaultError;
        Win4Assert( !SUCCEEDED(sc) );
    }
    END_CATCH

    if (! SUCCEEDED(sc) && fSetErrorNeeded)
        SetError( sc, OLESTR("CreateRecordset"), eErrorClass );

    return sc;
}

//+---------------------------------------------------------------------------
//
//  Member:     CixssoQuery::ParseOptimizeFor - private static
//
//  Synopsis:   Parse the input string for the OptimizeFor property
//
//  Arguments:  [wcsOptString] - input string
//              [eChoice]      - OptimizeFor choice expressed in wcsOptString
//
//  Returns:    SCODE - status return
//
//  History:    05 Mar 1997      Alanw    Created
//
//----------------------------------------------------------------------------

SCODE CixssoQuery::ParseOptimizeFor( WCHAR const * wcsOptString,
                                     DWORD & eChoice )
{
    eChoice = eOptHitCount;

    while (wcsOptString && *wcsOptString)
    {
        WCHAR * wcsNext = wcschr( wcsOptString, ',' );
        ULONG cch = (wcsNext) ? CiPtrToUlong( wcsNext - wcsOptString ) :
                                wcslen( wcsOptString );


        if ( 11 == cch && _wcsnicmp(wcsOptString, L"performance", 11) == 0)
        {
            eChoice |= eOptPerformance;
        }
        else if ( 6 == cch && _wcsnicmp(wcsOptString, L"recall", 6) == 0)
        {
            eChoice |= eOptRecall;
        }
        else if ( 8 == cch && _wcsnicmp(wcsOptString, L"hitcount", 8) == 0)
        {
            eChoice |= eOptHitCount;
        }
        else if ( 10 == cch && _wcsnicmp(wcsOptString, L"nohitcount", 10) == 0)
        {
            eChoice &= ~eOptHitCount;
        }
        else
            return E_INVALIDARG;

        wcsOptString = wcsNext;
        if (wcsOptString)
        {
            wcsOptString++;

            while (iswspace( *wcsOptString ))
                wcsOptString++;
        }
    }

    // 'performance' and 'recall' are mutually exclusive.  Check if both
    // were set.
    if ( (eChoice & (eOptRecall | eOptPerformance)) ==
         (eOptRecall | eOptPerformance) )
            return E_INVALIDARG;

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Member:     CixssoQuery::ParseCiDepthFlag, private
//
//  Synopsis:   Parses the flags attribute
//
//  Arguments:  [bstrFlags] -- flags
//
//  Returns:    ULONG - query scope flags
//
//  History:    96/Jan/03   DwightKr    created
//
//----------------------------------------------------------------------------

ULONG CixssoQuery::ParseCiDepthFlag( BSTR bstrFlags )
{
    if ( 0 == bstrFlags || 0 == SysStringLen(bstrFlags) )
    {
        return QUERY_DEEP;
    }

    ULONG ulFlags;

    if ( _wcsicmp(bstrFlags, L"SHALLOW") == 0 )
    {
        ulFlags = QUERY_SHALLOW;
    }
    else if ( _wcsicmp(bstrFlags, L"DEEP") == 0 )
    {
        ulFlags = QUERY_DEEP;
    }
    else
    {
        THROW( CIxssoException(MSG_IXSSO_EXPECTING_SHALLOWDEEP, 0) );
    }

    return ulFlags;
}


//+---------------------------------------------------------------------------
//
//  Member:     CixssoQuery::SetLocaleString - private
//
//  Synopsis:   Parse the input string for a recognizable locale name
//
//  Arguments:  [bstrLocale] - input string
//
//  Returns:    SCODE - status return
//
//  History:    13 Mar 1997      Alanw    Created
//
//----------------------------------------------------------------------------

SCODE CixssoQuery::SetLocaleString(BSTR str)
{
    LCID lcidTemp = GetLCIDFromString( str );
    if (lcidTemp == -1)
    {
        return E_INVALIDARG;
    }

    _lcid = lcidTemp;
    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Function:   ParseNumberVectorString - public
//
//  Synopsis:   Parses a string consisting of ',' separated numeric values
//              into an array.
//
//  Arguments:  [pwszValue] - input string
//              [aNum]      - dynamic array where numbers are placed.
//
//  History:    10 Jun 1997      Alanw    Created
//
//----------------------------------------------------------------------------

void ParseNumberVectorString( WCHAR * pwszValue, CDynArrayInPlace<LONG> & aNum )
{
    while (pwszValue)
    {
        LONG lNum = _wtoi( pwszValue );
        aNum[aNum.Count()] = lNum;
        pwszValue = wcschr(pwszValue, L',');
        if (pwszValue)
            pwszValue++;
    }
}

void FormatLongVector( SAFEARRAY * psa, XGrowable<WCHAR> & awchBuf )
{
    Win4Assert( SafeArrayGetDim( psa ) == 1 &&
                SafeArrayGetElemsize( psa ) == sizeof (LONG) );

    LONG iLBound = 0;
    LONG iUBound = 0;
    SCODE sc = SafeArrayGetLBound( psa, 1, &iLBound );
    if (SUCCEEDED(sc))
        sc = SafeArrayGetUBound( psa, 1, &iUBound );

    unsigned cch = 0;
    for (int i=iLBound; i<= iUBound; i++)
    {
        LONG lValue;
        LONG ix[1];
        ix[0] = i;
        sc = SafeArrayGetElement( psa, ix, &lValue );

        awchBuf.SetSize(cch + 20);
        if (i != iLBound)
        {
            awchBuf[cch] = L',';
            cch++;
        }
        _itow( lValue, &awchBuf[cch], 10 );
        cch += wcslen( &awchBuf[cch] );
    }

}

// CIXSSOPropertyList methods

//+-------------------------------------------------------------------------
//
//  Member:     CIXSSOPropertyList::CIXSSOPropertyList, public
//
//  Synopsis:   Constructs a property mapper for the ixsso's use.
//
//  Parameters: [pDefaultList]  -- The default column mapper.
//
//  History:    26-Aug-97   KrishnaN     Created
//
//--------------------------------------------------------------------------

CIXSSOPropertyList::CIXSSOPropertyList(ULONG ulCodePage)
    : _cRefs( 1 ),
      _ulCodePage( ulCodePage ),
      _xDefaultList(0)
{
    // default list is not known. Use SetDefaultList to set that
}

// Set the defualt list
void CIXSSOPropertyList::SetDefaultList(IColumnMapper *pDefaultList)
{
    Win4Assert(pDefaultList);

    _xDefaultList.Set(pDefaultList);
    _xDefaultList->AddRef();
}

//+-------------------------------------------------------------------------
//
//  Member:     CIXSSOPropertyList::QueryInterface, public
//
//  Arguments:  [ifid]  -- Interface id
//              [ppiuk] -- Interface return pointer
//
//  History:    26-Aug-97   KrishnaN     Created
//
//--------------------------------------------------------------------------

STDMETHODIMP CIXSSOPropertyList::QueryInterface( REFIID ifid, void ** ppiuk )
{
    if (0 == ppiuk)
        return E_INVALIDARG;

    if ( IID_IUnknown == ifid )
    {
        AddRef();
        *ppiuk = (void *)((IUnknown *)this);
        return S_OK;
    }
    else if (IID_IColumnMapper == ifid )
    {
        AddRef();
        *ppiuk = (void *)((IColumnMapper *)this);
        return S_OK;
    }
    else
    {
        *ppiuk = 0;
        return E_NOINTERFACE;
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CIXSSOPropertyList::AddRef, public
//
//  Synopsis:   Reference the virtual table.
//
//  History:    26-Aug-97   KrishnaN     Created
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CIXSSOPropertyList::AddRef(void)
{
    InterlockedIncrement( &_cRefs );
    return( _cRefs );
}

//+-------------------------------------------------------------------------
//
//  Member:     CIXSSOPropertyList::Release, public
//
//  Synopsis:   De-Reference the virtual table.
//
//  Effects:    If the ref count goes to 0 then the table is deleted.
//
//  History:    26-Aug-97   KrishnaN     Created
//
//--------------------------------------------------------------------------

STDMETHODIMP_(ULONG) CIXSSOPropertyList::Release(void)
{
    unsigned long uTmp = InterlockedDecrement( &_cRefs );
    if (0 == uTmp)
    {
        delete this;
    }
    return(uTmp);
}

//
// IColumnMapper methods
//

//+-------------------------------------------------------------------------
//
//  Member:     CIXSSOPropertyList::GetPropInfoFromName, public
//
//  Synopsis:   Get property info. from name.
//
//  Parameters: [wcsPropName] -- Property name to look up.
//              [ppPropId]    -- Ptr to return Id of the property.
//              [pPropType]   -- Ptr to return type of the property.
//              [puiWidth]    -- Ptr to return property width.
//
//  History:    26-Aug-97   KrishnaN     Created
//
//--------------------------------------------------------------------------

SCODE CIXSSOPropertyList::GetPropInfoFromName(const WCHAR  *wcsPropName,
                                             DBID  * *ppPropId,
                                             DBTYPE  *pPropType,
                                             unsigned int  *puiWidth)
{
    //
    // Callers can pass in 0 for pPropType and puiWidth if they
    // don't care about them.
    //

    if (0 == wcsPropName || 0 == ppPropId)
        return E_INVALIDARG;

    Win4Assert(_xDefaultList.GetPointer());

    //
    // First check in the default list, then in the override list.
    //

    SCODE sc = _xDefaultList->GetPropInfoFromName(wcsPropName,
                                                  ppPropId,
                                                  pPropType,
                                                  puiWidth);

    if (FAILED(sc) && 0 != _xOverrideList.GetPointer())
    {
        sc = _xOverrideList->GetPropInfoFromName(wcsPropName,
                                                 ppPropId,
                                                 pPropType,
                                                 puiWidth);
    }

    return sc;
}

//+-------------------------------------------------------------------------
//
//  Member:     CIXSSOPropertyList::GetPropInfoFromId, public
//
//  Synopsis:   Get property info. from dbid.
//
//  Parameters: [pPropId]    -- Ptr to prop to look up.
//              [pwcsName]   -- Ptr to return property name.
//              [pPropType]  -- Ptr to return type of the property.
//              [puiWidth]   -- Ptr to return property width.
//
//  History:    26-Aug-97   KrishnaN     Created
//
//--------------------------------------------------------------------------

SCODE CIXSSOPropertyList::GetPropInfoFromId(const DBID  *pPropId,
                                           WCHAR  * *pwcsName,
                                           DBTYPE  *pPropType,
                                           unsigned int  *puiWidth)
{
    Win4Assert(!"Not available!");
    return E_NOTIMPL;

#if 0  // complete, working implementation, but not needed.
    //
    // Callers can pass in 0 for pPropType and puiWidth if they
    // don't care about them.
    //
    if (0 == pwcsName || 0 == pPropId)
        return E_INVALIDARG;

    //
    // First check in the default list, then in the override list.
    //

    SCODE sc = _xDefaultList->GetPropInfoFromId(pPropId,
                                                pwcsName,
                                                pPropType,
                                                puiWidth);

    if (FAILED(sc) && 0 != _xOverrideList.GetPointer())
    {
        sc = _xOverrideList->GetPropInfoFromId(pPropId,
                                               pwcsName,
                                               pPropType,
                                               puiWidth);
    }

    return sc;
#endif // 0
}

//+-------------------------------------------------------------------------
//
//  Member:     CIXSSOPropertyList::EnumPropInfo, public
//
//  Synopsis:   Gets the i-th entry from the list of properties.
//
//  Parameters: [iEntry]    -- i-th entry to retrieve (0-based).
//              [pwcsName]  -- Ptr to return property name.
//              [ppPropId]  -- Ptr to return Id of the property.
//              [pPropType]  -- Ptr to return type of the property.
//              [puiWidth]   -- Ptr to return property width.
//
//  History:    26-Aug-97   KrishnaN     Created
//
//--------------------------------------------------------------------------

SCODE CIXSSOPropertyList::EnumPropInfo(ULONG iEntry,
                                  const WCHAR  * *pwcsName,
                                  DBID  * *ppPropId,
                                  DBTYPE  *pPropType,
                                  unsigned int  *puiWidth)
{
    Win4Assert(!"Not available!");
    return E_NOTIMPL;
}

//+-------------------------------------------------------------------------
//
//  Member:     CIXSSOPropertyList::IsMapUpToDate, public
//
//  Synopsis:   Indicates if the column map is up to date.
//
//  History:    26-Aug-97   KrishnaN     Created
//
//--------------------------------------------------------------------------

SCODE CIXSSOPropertyList::IsMapUpToDate()
{
    Win4Assert(_xDefaultList.GetPointer());

    // return the IsMapUpToDate of the default list.
    // the override list is always considered to be
    // upto date.

    return _xDefaultList->IsMapUpToDate();
}

//+---------------------------------------------------------------------------
//
//  Member:     CIXSSOPropertyList::AddEntry, private
//
//  Synopsis:   Adds a CPropEntry to the overriding list.  Verifies that the name
//              isn't already in the default list or the overriding list.
//
//  Arguments:  [xPropEntry] -- CPropEntry to add.  Acquired on success
//              [iLine]      -- line number we're parsing
//
//  Returns:    S_OK on success or S_
//
//  History:    11-Sep-97   KrishnaN     Created.
//
//----------------------------------------------------------------------------

SCODE CIXSSOPropertyList::AddEntry( XPtr<CPropEntry> & xPropEntry, int iLine )
{
    Win4Assert(_xDefaultList.GetPointer());

    SCODE sc = S_OK;

    // protect _xOverrideList

    CLock lock(_mtxAdd);

    //
    // We do not allow entries in the override list that have the same name
    // as the default list.
    //

    DBID     *pPropId;
    DBTYPE   PropType;
    unsigned uWidth;

    if ( S_OK == GetPropInfoFromName( xPropEntry->GetName(),
                                      &pPropId,
                                      &PropType,
                                      &uWidth ))
    {
        if ( PropType != xPropEntry->GetPropType() ||
             ( uWidth != xPropEntry->GetWidth() &&
               xPropEntry->GetWidth() != PLIST_DEFAULT_WIDTH ) )
        {
            THROW( CPListException( QPLIST_E_DUPLICATE, iLine ) );
        }
        else
            sc = QPLIST_S_DUPLICATE;
    }

    if ( S_OK == sc )
    {
        if (0 == _xOverrideList.GetPointer())
            _xOverrideList.Set(new CPropertyList(_ulCodePage));

        _xOverrideList->AddEntry( xPropEntry.GetPointer(), iLine);

        xPropEntry.Acquire();
    }

    return sc;
} //AddEntry

#if 0

HRESULT CixssoQuery::GetInterfaceSafetyOptions(
    REFIID  riid,
    DWORD * pdwSupportedOptions,
    DWORD * pdwEnabledOptions )
{
    if ( 0 == pdwSupportedOptions ||
         0 == pdwEnabledOptions )
        return E_POINTER;

    ixssoDebugOut(( DEB_ITRACE, "get safety options called...\n" ));

    *pdwSupportedOptions = INTERFACESAFE_FOR_UNTRUSTED_CALLER;
    *pdwEnabledOptions = 0;

    return S_OK;
} //GetInterfaceSafetyOptions

HRESULT CixssoQuery::SetInterfaceSafetyOptions(
    REFIID riid,
    DWORD  dwOptionSetMask,
    DWORD  dwEnabledOptions )
{
    ixssoDebugOut(( DEB_ITRACE, "set setmask: %#x\n", dwOptionSetMask ));
    ixssoDebugOut(( DEB_ITRACE, "set enabled: %#x\n", dwEnabledOptions ));

    _dwSafetyOptions = (dwEnabledOptions & dwOptionSetMask);

    return S_OK;
} //SetInterfaceSafetyOptions

#endif

//+-------------------------------------------------------------------------
//
//  Member:     CixssoQuery::SetSite, public
//
//  Synopsis:   Sets the current site (if any).  Called by containers of
//              CixssoQuery like IE.  Not called by other containers like
//              ASP and CScript.
//
//  Arguments:  [pSite] -- The container of this query object
//
//  Returns:    HRESULT
//
//  History:    09-Nov-00   dlee     Created
//
//--------------------------------------------------------------------------

HRESULT CixssoQuery::SetSite( IUnknown * pSite )
{
    _xSite.Free();

    if ( 0 != pSite )
    {
        pSite->AddRef();

        _xSite.Set( pSite );
    }

    ixssoDebugOut(( DEB_ITRACE, "setting site: %#x\n", pSite ));

    return S_OK;
} //SetSite

//+-------------------------------------------------------------------------
//
//  Member:     CixssoQuery::GetSite, public
//
//  Synopsis:   Retrieves the current site (if any)
//
//  Arguments:  [riid]    -- IID requested
//              [ppvSite] -- Where the interface pointer is returned
//
//  Returns:    HRESULT like a QueryInterface()
//
//  History:    09-Nov-00   dlee     Created
//
//--------------------------------------------------------------------------

HRESULT CixssoQuery::GetSite(
    REFIID  riid,
    void ** ppvSite )
{
    ixssoDebugOut(( DEB_ITRACE, "getsite\n" ));

    if ( 0 == ppvSite )
        return E_POINTER;

    *ppvSite = 0;

    if ( _xSite.IsNull() )
        return E_NOINTERFACE;

    return _xSite->QueryInterface( riid, ppvSite );
} //GetSite

//+-------------------------------------------------------------------------
//
//  Member:     CixssoQuery::IsSafeForScripting, private
//
//  Synopsis:   Checks if it's ok to execute in the current context.  Throws
//              an exception if it's not safe or on error.  It's not safe
//              to execute script off a remote machine.
//
//  History:    09-Nov-00   dlee     Created
//
//--------------------------------------------------------------------------

void CixssoQuery::IsSafeForScripting()
{
    XInterface<IServiceProvider> xServiceProvider;
    SCODE sc = GetSite( IID_IServiceProvider,
                        xServiceProvider.GetQIPointer() );

    //
    // When queries are run in IIS the container does not call
    // SetSite, so there is no site and we'll have E_NOINTERFACE
    // at this point.  Same for cscript.exe queries.
    // If that ever changes, the check below for file:// URLs will
    // fail and no IIS queries will ever work.
    //

    if ( E_NOINTERFACE == sc )
        return;

    if ( FAILED( sc ) )
        THROW( CException( sc ) );

    XInterface<IWebBrowser2> xWebBrowser;
    sc = xServiceProvider->QueryService( SID_SWebBrowserApp,
                                         IID_IWebBrowser2,
                                         xWebBrowser.GetQIPointer() );
    if ( E_NOINTERFACE == sc )
        return;

    if ( FAILED( sc ) )
        THROW( CException( sc ) );

    BSTR bstrURL;
    sc = xWebBrowser->get_LocationURL( &bstrURL );
    if ( FAILED( sc ) )
        THROW( CException( sc ) );

    XBStr xURL( bstrURL );
    ixssoDebugOut(( DEB_ITRACE, "url: %ws\n", bstrURL ));

    WCHAR buf[32];
    URL_COMPONENTS uc;
    RtlZeroMemory( &uc, sizeof uc );
    uc.dwStructSize = sizeof uc;
    uc.lpszScheme = buf;
    uc.dwSchemeLength = sizeof buf / sizeof WCHAR;

    INTERNET_SCHEME scheme = INTERNET_SCHEME_UNKNOWN;

    if ( InternetCrackUrl( bstrURL, wcslen( bstrURL ), ICU_DECODE, &uc ) )
        scheme = uc.nScheme;

    // The URL has to be a file:/// URL or we won't allow it.

    if ( INTERNET_SCHEME_FILE != scheme )
        THROW( CException( E_ACCESSDENIED ) );

    // OK, now it can't be a UNC path.  Look for a drive letter and a colon

    // file:///c: the length should at least be 10
    if ( wcslen( bstrURL ) <= 9 )
        THROW( CException( E_ACCESSDENIED ) );

    WCHAR const * pwcPath = bstrURL + 8;
    WCHAR const * pwcColon = wcschr( pwcPath, L':' );

    ixssoDebugOut(( DEB_ITRACE, "Path is: %ws\n", pwcPath ));

    if ( ( 0 == pwcColon ) ||
         ( pwcColon > ( pwcPath + 1 ) ) )
        THROW( CException( E_ACCESSDENIED ) );

    WCHAR wcDrive = * ( pwcColon - 1 );

    ixssoDebugOut(( DEB_ITRACE, "wcDrive is: %wc\n", wcDrive ));
    wcDrive = towupper( wcDrive );

    if ( ( wcDrive < L'A' ) || ( wcDrive > L'Z' ) )
        THROW( CException( E_ACCESSDENIED ) );
} //IsSafeForScripting
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\web\ixsso\ixserror.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) 1997-1998, Microsoft Corporation.
//
//  File:       ixserror.cxx
//
//  Contents:   SSO Error class
//
//  History:    04 Apr 1997      Alanw    Created
//
//----------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop


//-----------------------------------------------------------------------------
// Include Files
//-----------------------------------------------------------------------------


// debugging macros
#include "ssodebug.hxx"

// class declaration
#include "ixserror.hxx"


//-----------------------------------------------------------------------------
//
//  Member:     CixssoError::SetError - private
//
//  Synopsis:   Save error information
//
//  Arguments:  [scError]   - Error code
//              [iLine]     - (optional) line number where error occurred
//              [pwszFile]  - (optional) file name where error occurred
//              [pwszLoc]   - Location from which error was generated
//              [eErrClass] - error class, indicates error message file
//
//  Notes:
//
//  History:    07 Jan 1997      Alanw    Created
//
//-----------------------------------------------------------------------------

extern HINSTANCE g_hInst;
extern WCHAR * g_pwszErrorMsgFile;

#define ERROR_MESSAGE_SIZE 512

void CixssoError::SetError(
    SCODE scError,
    ULONG iLine,
    WCHAR const * pwszFile,
    WCHAR const * pwszLoc,
    unsigned eErrClass,
    LCID lcid)
{
    // Has the error already been handled? If so, return.
    if ( _sc != 0)
        return;

    if ( QUERY_E_DUPLICATE_OUTPUT_COLUMN == scError  )
    {
        scError =  MSG_IXSSO_DUPLICATE_COLUMN;
        eErrClass = eIxssoError;
    }
    else if ( QUERY_E_INVALID_OUTPUT_COLUMN == scError )
    {
        scError = MSG_IXSSO_NO_SUCH_COLUMN_PROPERTY;
        eErrClass = eIxssoError;
    }

    // Does this error (possibly transalted) already exist on the error stack?
    // If it does, and it has a description, we shouldn't be doing anything else.

    if (FALSE == NeedToSetError(scError))
        return;

    ixssoDebugOut(( DEB_ITRACE, "SetError: sc = %x, loc = %ws\n", scError, pwszLoc ));

    WCHAR awcsErrorMessage[ERROR_MESSAGE_SIZE];
    WCHAR *pwszErrorMessage = awcsErrorMessage;
    ULONG cchAvailMessage = ERROR_MESSAGE_SIZE;

    //
    //  Generate the Win32 error code by removing the facility code (7) and
    //  the error bit.
    //
    ULONG Win32status = scError;
    if ( (Win32status & (FACILITY_WIN32 << 16)) == (FACILITY_WIN32 << 16) )
    {
        Win32status &= ~( 0x80000000 | (FACILITY_WIN32 << 16) );
    }

    //
    // Don't pass a specific lang id to FormatMessage since it will
    // fail if there's no message in that language. Instead set
    // the thread locale, which will get FormatMessage to use a search
    // algorithm to find a message of the appropriate language or
    // use a reasonable fallback msg if there's none.
    //
    LCID SaveLCID = GetThreadLocale();
    SetThreadLocale(lcid);

    //  Precede the error message by the file/line if passed.
    if (pwszFile != 0)
    {
        UINT_PTR args [] = {
                         (UINT_PTR) pwszFile,
                         (UINT_PTR) iLine,
                        };

        NTSTATUS MsgNum = MSG_IXSSO_FILE_MESSAGE;
        if (iLine != 0)
        {
            MsgNum = MSG_IXSSO_FILE_LINE_MESSAGE;
        }

        ULONG cchMsg = FormatMessage( FORMAT_MESSAGE_FROM_HMODULE |
                                         FORMAT_MESSAGE_ARGUMENT_ARRAY,
                                      g_hInst,
                                      MsgNum,
                                      0,
                                      pwszErrorMessage,
                                      cchAvailMessage,
                                      (va_list *) args );
        pwszErrorMessage += cchMsg;
        cchAvailMessage -= cchMsg;
    }

    BOOL fSystemError = FALSE;

    switch (eErrClass)
    {
    case eIxssoError:
        if ( ! FormatMessage( FORMAT_MESSAGE_FROM_HMODULE,
                              g_hInst,
                              scError,
                              0,
                              pwszErrorMessage,
                              cchAvailMessage,
                              0 ) )
        {
            ixssoDebugOut(( DEB_ERROR, "Format message failed with error 0x%x\n", GetLastError() ));

            swprintf( pwszErrorMessage,
                      L"Error 0x%x caught while processing query\n",
                      scError );
        }
    break;

    case ePlistError:
    case eParseError:
        if ( ! FormatMessage( FORMAT_MESSAGE_FROM_HMODULE,
                              GetModuleHandle(g_pwszErrorMsgFile),
                              scError,
                              0,
                              pwszErrorMessage,
                              cchAvailMessage,
                              0 ) )
        {
            ixssoDebugOut(( DEB_ERROR, "Format message failed with error 0x%x\n", GetLastError() ));

            swprintf( pwszErrorMessage,
                      L"Error 0x%x caught while parsing query or other fields\n",
                      scError );
        }
    break;

    case eDefaultError:
        if ( ! FormatMessage( FORMAT_MESSAGE_FROM_HMODULE,
                               g_hInst,
                               scError,
                               0,
                               pwszErrorMessage,
                               cchAvailMessage,
                               0 ) )
        {
            if ( ! FormatMessage( FORMAT_MESSAGE_FROM_HMODULE,
                                   GetModuleHandle(g_pwszErrorMsgFile),
                                   scError,
                                   0,
                                   pwszErrorMessage,
                                   cchAvailMessage,
                                   0 ) )
            {
                //
                //  Try looking up the error in the Win32 list of error codes
                //
                if ( ! FormatMessage( FORMAT_MESSAGE_FROM_HMODULE,
                                       GetModuleHandle(L"kernel32.dll"),
                                       Win32status,
                                       0,
                                       pwszErrorMessage,
                                       cchAvailMessage,
                                       0 ) )
                {
                    ixssoDebugOut(( DEB_ERROR, "Format message failed with error 0x%x\n", GetLastError() ));

                    swprintf( pwszErrorMessage,
                              L"Error 0x%x caught while processing query\n",
                              scError );
                }
                else
                {
                    fSystemError = TRUE;
                }
            }
        }
        break;

    default:
        Win4Assert( !"Unrecognized error class" );
        break;
    }
    SetThreadLocale(SaveLCID);

    SetError( scError, pwszLoc, awcsErrorMessage );
}

//-----------------------------------------------------------------------------
//
//  Member:     CixssoError::SetError - private
//
//  Synopsis:   Save error information
//
//  Arguments:  [scError]         - Error code
//              [pwszLoc]         - Location from which error was generated
//              [pwszDescription] - Error description
//
//  Notes:
//
//  History:    06 May 1997      KrishnaN    Created
//
//-----------------------------------------------------------------------------

void CixssoError::SetError( SCODE scError,
                            WCHAR const * pwszLoc,
                            WCHAR const * pwszDescription)
{
    // Has the error on this object already been set?
    if (_sc != 0)
        return;

    // We should be here only if an error has NOT already been set.
    Win4Assert(NeedToSetError(scError));

    Win4Assert(pwszLoc && pwszDescription);

    ixssoDebugOut(( DEB_ITRACE,
                    "SetError: sc = %x, loc = %ws,\n\tdescription = %ws\n",
                    scError, pwszLoc, pwszDescription ));

    _fErr = TRUE;
    _sc = scError;

    //
    //  Create an error info object giving the error message
    //
    ICreateErrorInfo * pErrorInfo;
    SCODE sc = CreateErrorInfo( &pErrorInfo );
    if (SUCCEEDED( sc ))
    {
        XInterface<ICreateErrorInfo> pErr(pErrorInfo);
        pErrorInfo = 0;

        pErr->SetDescription( (LPWSTR) pwszDescription );
        pErr->SetGUID( _iid );
        pErr->SetSource( (LPWSTR) pwszLoc );  // Cast ok.  Never touched by anyone.

        IErrorInfo * pErrInfo = 0;
        sc = pErr->QueryInterface( IID_IErrorInfo, (void **)&pErrInfo);
        if (SUCCEEDED(sc))
        {
            SetErrorInfo(0, pErrInfo);
            pErrInfo->Release();
        }
    }
}


//-----------------------------------------------------------------------------
//
//  Member:     CixssoError::NeedToSetError - private
//
//  Synopsis:   Determine if error needs to be set.
//
//  Arguments:  [scError]         - Error code to look for
//
//  Returns:    TRUE if the error needs to be set. FALSE, if it already
//              exists and has a valid description string.
//
//  Notes:
//
//  History:    15 Jan 1998      KrishnaN    Created
//
//-----------------------------------------------------------------------------

BOOL CixssoError::NeedToSetError(SCODE scError)
{
    BOOL fFound = FALSE;

    //
    // Get the current error object. Return TRUE if none exists.
    //

    XInterface<IErrorInfo> xErrorInfo;

    SCODE sc = GetErrorInfo(0, (IErrorInfo **)xErrorInfo.GetQIPointer());
    if ( S_FALSE == sc )
    {
        Win4Assert(0 == xErrorInfo.GetPointer());
        return TRUE;
    }

    // Get the IErrorRecord interface and get the count of errors.
    XInterface<IErrorRecords> xErrorRecords;
    XBStr xDescription;
    BSTR pDescription = xDescription.GetPointer();

    sc = xErrorInfo->QueryInterface(IID_IErrorRecords, xErrorRecords.GetQIPointer());
    if (0 == xErrorRecords.GetPointer())
    {
        // No error records. Do we at least have the top level description set?
        // If so, that indicates an automation client called SetErrorInfo before us
        // and we should not overwrite them.
        xErrorInfo->GetDescription(&pDescription);
        fFound = ( pDescription != 0 ) ;
    }
    else
    {
        ULONG cErrRecords;
        sc = xErrorRecords->GetRecordCount(&cErrRecords);
        Win4Assert(!fFound);

        // look for the target error code. stop when one is found
        ERRORINFO ErrorInfo;
        for (ULONG i = 0; i < cErrRecords; i++)
        {
            sc = xErrorRecords->GetBasicErrorInfo(i, &ErrorInfo);
            Win4Assert(S_OK == sc);

            if (scError == ErrorInfo.hrError)
            {
                xErrorInfo->GetDescription(&pDescription);
                fFound = ( pDescription != 0 );
                break;
            }
        }
    }

    if (!fFound)
        return TRUE;

    // we found the error code and it has a description.
    // no need to set this error again, but we have to
    // put this error info back so the client can find it.
    SetErrorInfo(0, xErrorInfo.GetPointer());
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\web\ixsso\ixsinfo.cxx ===
//+---------------------------------------------------------------------------
//
//  Copyright (C) Microsoft Corporation, 1997 - 2000.
//
//  File:       ixsinfo.cxx
//
//  Contents:   Query SSO query information methods
//
//  History:    30 Jan 1997      Alanw    Created
//
//----------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include "ssodebug.hxx"

#include "ixsso.hxx"
#include "ixsinfo.hxx"

#include <cgiesc.hxx>
#include <string.hxx>
#include <tgrow.hxx>


//-----------------------------------------------------------------------------
// CixssoQuery Methods
//-----------------------------------------------------------------------------


//+---------------------------------------------------------------------------
//
//  Function:   AddURLTerm - public inline
//
//  Synopsis:   Add a term to a URL QueryString
//
//  Arguments:  [vString]   - virtual string in which the result is accumulated
//              [pwszTerm]  - tag name, assumed to not need encoding
//              [pwszValue] - value part
//              [ulCodepage] - code page for URL encoding
//
//  History:    19 Mar 1997      Alanw    Created
//
//----------------------------------------------------------------------------

inline void AddURLTerm(
    CVirtualString & vString,
    WCHAR * pwszTerm,
    WCHAR * pwszValue,
    ULONG   ulCodepage)
{
    if (vString.StrLen() > 0)
        vString.CharCat( L'&' );
    vString.StrCat(pwszTerm);
    URLEscapeW( pwszValue, vString, ulCodepage, TRUE );
}


//+---------------------------------------------------------------------------
//
//  Member:     CixssoQuery::QueryToURL - public
//
//  Synopsis:   Produce a URL QueryString from the state of the query object
//
//  Arguments:  [pbstrQueryString] - The URL-encoded query string is
//                                   returned here
//
//  History:    19 Mar 1997      Alanw    Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CixssoQuery::QueryToURL(BSTR * pbstrQueryString)
{
    _err.Reset();

    SCODE sc = S_OK;
    CVirtualString vString( 512 );

    *pbstrQueryString = 0;
    TRY {

        if (_pwszCatalog)
        {
            AddURLTerm( vString, L"ct=", _pwszCatalog, _ulCodepage );
        }

        if (_pwszDialect)
        {
            AddURLTerm( vString, L"di=", _pwszDialect, _ulCodepage );
        }

        if (_pwszSort)
        {
            AddURLTerm( vString, L"so=", _pwszSort, _ulCodepage );
        }
        if (_pwszGroup)
        {
            AddURLTerm( vString, L"gr=", _pwszGroup, _ulCodepage );
        }
        if (_pwszRestriction)
        {
            AddURLTerm( vString, L"qu=", _pwszRestriction, _ulCodepage );
        }

        if (_maxResults)
        {
            WCHAR awchBuf[20];
            wsprintf(awchBuf, L"%d", _maxResults);
            AddURLTerm( vString, L"mh=", awchBuf, _ulCodepage );
        }

        if (_cFirstRows)
        {
            WCHAR awchBuf[20];
            wsprintf(awchBuf, L"%d", _cFirstRows);
            AddURLTerm( vString, L"fr=", awchBuf, _ulCodepage );
        }

        if (_StartHit.Get())
        {
            XGrowable<WCHAR> awchBuf;

            FormatLongVector( _StartHit.Get(), awchBuf );
            AddURLTerm( vString, L"sh=", awchBuf.Get(), _ulCodepage );
        }

        if (_fAllowEnumeration)
        {
            AddURLTerm( vString, L"ae=", L"1", _ulCodepage );
        }

        // OptimizeFor defaults to Hitcount
        if (_dwOptimizeFlags != eOptHitCount)
        {
            WCHAR awchBuf[4];
            unsigned i = 0;

            if (_dwOptimizeFlags & eOptPerformance)
                awchBuf[i++] = L'x';
            if (_dwOptimizeFlags & eOptRecall)
                awchBuf[i++] = L'r';
            if ( !(_dwOptimizeFlags & eOptHitCount) )
                awchBuf[i++] = L'h';
            awchBuf[i] = L'\0';

            AddURLTerm( vString, L"op=", awchBuf, _ulCodepage );
        }

        //
        // The URL encoded string is assembled.  Copy it into a BSTR for return.
        //
        BSTR bstr = SysAllocStringLen( vString.GetPointer(), vString.StrLen() );
        if (0 == bstr)
            THROW(CException( E_OUTOFMEMORY ) );
        *pbstrQueryString = bstr;
    }
    CATCH (CException, e)
    {
        sc = GetOleError( e );
    }
    END_CATCH

    if (FAILED(sc))
    {
        SetError( sc, OLESTR("QueryToURL") );
    }
    return sc;
}


//+---------------------------------------------------------------------------
//
//  Member:     CixssoQuery::SetQueryFromURL - public
//
//  Synopsis:   Parse a URL QueryString and update object state accordingly.
//
//  Arguments:  [bstrQueryString] - The input URL-encoded query string
//
//  History:    20 Mar 1997      Alanw    Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CixssoQuery::SetQueryFromURL(BSTR bstrQueryString)
{
    _err.Reset();

    SCODE sc = S_OK;

    TRY {

        CQueryInfo Info;

        ixssoDebugOut(( DEB_ITRACE, "QUERY_STRING = %ws\n", bstrQueryString ));

        //
        //  Parse the string, which has the following format:
        //
        //
        //      tag1=Value1&tag2=value2&tag3=value+%7c+0&foo&bar
        //

        unsigned cchBuffer = SysStringLen(bstrQueryString);
        WCHAR * pwszToken = (WCHAR *)bstrQueryString;

        while ( pwszToken && (L'\0' != *pwszToken) )
        {
            //
            //  Find the value on the right hand side of the equal sign.
            //
            WCHAR *pwszTag = pwszToken;
            WCHAR *pwszValue = wcschr( pwszTag, L'=' );

            if ( 0 != pwszValue )
            {
                unsigned cchTag = CiPtrToUint( pwszValue - pwszTag );
                pwszValue++;

                //
                //  Point to the next Tag.
                //
                pwszToken = wcschr( pwszToken, L'&' );

                ULONG cchValue;

                if ( 0 != pwszToken )
                {
                    if ( pwszToken < pwszValue )
                    {
                        //
                        // We have a construction like foo&bar=value.  Set
                        // the tag with a null value and go on to the next
                        // tag=value pair.
                        //
                        cchValue = 0;
                    }
                    else 
                        cchValue = CiPtrToUlong( pwszToken - pwszValue );

                    pwszToken++;
                }
                else
                {
                    cchValue = CiPtrToUlong( (WCHAR *)&bstrQueryString[cchBuffer] - pwszValue );
                }


                if ( 0 == cchValue )
                {
                    ixssoDebugOut(( DEB_ITRACE,
                                    "SetQueryFromURL - setting %.*ws=NULL\n",
                                     cchTag, pwszTag ));

                    XPtrST<WCHAR> xpValue( 0 );
                    Info.SetQueryParameter( pwszTag, xpValue );
                }
                else
                {
                    XGrowable<BYTE> achBuf( cchValue );
                    for ( unsigned i=0; i<cchValue; i++ )
                    {
                        Win4Assert( pwszValue[i] < 0x100 );
                        achBuf[i] = (BYTE) pwszValue[i];
                    }
                    XPtrST<WCHAR> xpwchValue( new WCHAR[cchValue+1] );

                    DecodeURLEscapes( achBuf.Get(),
                                      cchValue,
                                      xpwchValue.GetPointer(),
                                      _ulCodepage );

                    ixssoDebugOut(( DEB_ITRACE,
                                    "SetQueryFromURL - setting %.*ws=%ws\n",
                                    cchTag, pwszTag,
                                    xpwchValue.GetPointer() ));

                    Info.SetQueryParameter( pwszTag, xpwchValue );
                }
            }
            else if ( 0 != pwszToken )
            {
                //
                //  There was no tag=value pair found; a lonely '&' was
                //  found.  Skip it and proceed to the next '&'.
                //
                pwszToken = wcschr( pwszToken+1, L'&' );
            }
        }

        Info.MakeFinalQueryString();
        if (Info.GetQuery())
        {
            delete _pwszRestriction;
            _pwszRestriction = Info.AcquireQuery();
        }

        if (Info.GetCatalog())
        {
            delete _pwszCatalog;
            _pwszCatalog = Info.AcquireCatalog();
        }
        if ( Info.GetDialect() )
        {
            delete _pwszDialect;
            _pwszDialect = Info.AcquireDialect();
        }

        if (Info.GetSort())
        {
            delete _pwszSort;
            _pwszSort = Info.AcquireSort();
        }
        if (Info.GetGroup())
        {
            delete _pwszGroup;
            _pwszGroup = Info.AcquireGroup();
        }

        if (Info.GetMaxHits())
        {
            _maxResults = Info.GetMaxHits();
        }

        if (Info.GetFirstRows())
        {
            _cFirstRows = Info.GetFirstRows();
        }

        if (Info.GetStartHit().Count())
        {
            unsigned cHits = Info.GetStartHit().Count();
            SCODE sc;
    
            SAFEARRAY* psa;
            XSafeArray xsa;

            psa = SafeArrayCreateVector(VT_I4, 1, cHits);
            if( ! psa )
                THROW(CException( E_OUTOFMEMORY ));

            xsa.Set(psa);

            for (unsigned i=1; i<=cHits; i++)
            {
                long rgIx[1];
                LONG lVal = Info.GetStartHit().Get(i-1); 
                rgIx[0] = (long)i;
                sc = SafeArrayPutElement( xsa.Get(), rgIx, &lVal );

                if ( FAILED( sc ) )
                    THROW( CException( sc ) );
            }

            _StartHit.Destroy();
            _StartHit.Set( xsa.Acquire() );
        }

        if (Info.WasAllowEnumSet())
        {
            _fAllowEnumeration = Info.GetAllowEnum();
        }

        if (eOptHitCount != Info.GetOptimizeFor())
        {
            _dwOptimizeFlags = Info.GetOptimizeFor();
        }
    }
    CATCH( CIxssoException, e )
    {
        sc = e.GetErrorCode();
        Win4Assert( !SUCCEEDED(sc) );
        SetError( sc, OLESTR("SetqueryFromURL"), eIxssoError );
    }
    AND_CATCH( CException, e )
    {
        sc = GetOleError( e );
        SetError( sc, OLESTR("SetQueryFromURL") );
    }
    END_CATCH

    return sc;
}

//-----------------------------------------------------------------------------
// CQueryInfo Methods
//-----------------------------------------------------------------------------


//+---------------------------------------------------------------------------
//
//  Function:   EncodeTagString - inline
//
//  Synopsis:   Encode a one or two character tag into a DWORD value
//
//  Arguments:  [pwszTag]    - a pointer to the tag
//              [dwCodedTag] - the coded value which is returned
//              [iParam]     - the numeric value for the tag
//
//  Notes:      Tags consisting of one alpha character, two alpha characters
//              or one alpha followed by a numeric character are recognized
//              and converted into a DWORD (whose value just happens to be
//              the same as a one or two character character constant for the
//              alpha characters in the tag).  If the third form is recognized,
//              the iParam parameter gets the value of the numeric character,
//              otherwise iParam is zero.
//
//              dwCodedTag will be zero if pwszTag is not one of the allowed
//              forms.
//
//  History:    19 Mar 1997      Alanw    Created
//
//----------------------------------------------------------------------------

inline void EncodeTagString( WCHAR const * pwszTag,
                             DWORD & dwCodedTag,
                             USHORT & iParam )
{
    dwCodedTag = 0;
    iParam = 0;
    if (0 == pwszTag || L'\0' == *pwszTag)
        return;

    if (isalpha(*pwszTag))
    {
        dwCodedTag = towupper(*pwszTag) & 0xFF;
        if (isalpha(pwszTag[1]))
        {
            dwCodedTag <<= 8;
            dwCodedTag |= (towupper(pwszTag[1]) & 0xFF);
        }
        else if (isdigit(pwszTag[1]))
            iParam = pwszTag[1] - L'0';
        else if (L'=' == pwszTag[1] ||
                 L'&' == pwszTag[1] ||
                 L'\0' == pwszTag[1])
            return;
        else
        {
            dwCodedTag = 0;
            return;
        }

        if ( L'=' != pwszTag[2] &&
             L'&' != pwszTag[2] &&
             L'\0' != pwszTag[2])
            dwCodedTag = 0;
    }
    return;
}


//+---------------------------------------------------------------------------
//
//  Member:     CQueryInfo::SetQueryParameter - public
//
//  Synopsis:   Process a QueryString parameter
//
//  Arguments:  [pwszTag] - the tag name for the parameter
//              [pwszValue] - the value for the parameter
//
//  History:    19 Mar 1997      Alanw    Created
//
//----------------------------------------------------------------------------

void CQueryInfo::SetQueryParameter( WCHAR const * pwszTag,
                                    XPtrST<WCHAR> & pwszValue )
{
    DWORD dwParamCode;
    USHORT iParam;

    EncodeTagString( pwszTag, dwParamCode, iParam );
    if (0 == dwParamCode)
        return;

    for (unsigned i=0; i<cQueryTagTable; i++)
        if (dwParamCode == aQueryTagTable[i].dwTagName)
            break;

    if (i == cQueryTagTable)
        return;

    i = aQueryTagTable[i].qtQueryTagType;

    switch (i)
    {
    case qtQueryFullText:
        AddToParam( _xpQuery, pwszValue );
        break;

    case qtMaxHits:
    {
        LONG cNum = 0;
        if (0 != pwszValue.GetPointer())
            cNum = _wtoi( pwszValue.GetPointer() );

        if (cNum > 0)
        {
            _maxHits = cNum;
        }
        else
        {
            ixssoDebugOut(( DEB_TRACE,
                    "CIxsQueryInfo::SetQueryParameter - invalid numeric %ws\n",
                    pwszValue.GetPointer() ));
        }
    }
        break;

    case qtFirstRows:
    {
        LONG cNum = 0;
        if (0 != pwszValue.GetPointer())
            cNum = _wtoi( pwszValue.GetPointer() );

        if (cNum > 0)
        {
            _cFirstRows = cNum;
        }
        else
        {
            ixssoDebugOut(( DEB_TRACE,
                    "CIxsQueryInfo::SetQueryParameter - invalid numeric %ws\n",
                    pwszValue.GetPointer() ));
        }
    }
        break;

    case qtStartHit:
        ParseNumberVectorString( pwszValue.GetPointer(), GetStartHit() );
        break;

    case qtCatalog:
        AddToParam( _xpCatalog, pwszValue );
        break;

    case qtDialect:
        AddToParam( _xpDialect, pwszValue );
        break;

    case qtSort:
        AddToParam( _xpSort, pwszValue );
        break;

    case qtSortDown:
        if (pwszValue.GetPointer())
            AddToParam( _xpSort, pwszValue, L",", L"[d]" );
        break;

#if IXSSO_CATEGORIZE == 1
    case qtGroup:
        AddToParam( _xpGroup, pwszValue );
        break;

    case qtGroupDown:
        if (pwszValue.GetPointer())
            AddToParam( _xpGroup, pwszValue, L",", L"[d]" );
        break;
#endif // IXSSO_CATEGORIZE == 1

    case qtAllowEnumeration:
        _fAllowEnumeration = 0 != pwszValue.GetPointer() &&
                             iswdigit(*pwszValue.GetPointer()) &&
                             *pwszValue.GetPointer() != L'0';
        _fSetAllowEnumeration = 1;
        break;

    case qtOptimizeFor:
    {
        WCHAR * pwszVal = pwszValue.GetPointer();

        while (pwszVal && *pwszVal)
        {
            WCHAR chKey = towupper(*pwszVal);

            if (chKey == L'X')
            {
                _dwOptimizeFor &= ~eOptRecall;
                _dwOptimizeFor |= eOptPerformance;
            }
            else if (chKey == L'R')
            {
                _dwOptimizeFor &= ~eOptPerformance;
                _dwOptimizeFor |= eOptRecall;
            }
            else if (chKey == L'H')
            {
                _dwOptimizeFor &= ~eOptHitCount;
            }
            // else if (chKey == L'P')
            //     _dwOptimizeFor |= eOptPrecision;

            pwszVal++;
        }
        break;
    }

    case qtColumn:
        Win4Assert( iParam >= 0 && iParam < 10 );
        SetBuiltupQueryTerm( _aQueryCol, iParam, pwszValue );
        break;

    case qtOperator:
        Win4Assert( iParam >= 0 && iParam < 10 );
        SetBuiltupQueryTerm( _aQueryOp, iParam, pwszValue );
        break;

    case qtQuery:
        Win4Assert( iParam >= 0 && iParam < 10 );
        SetBuiltupQueryTerm( _aQueryVal, iParam, pwszValue );
        break;

    default:
        ixssoDebugOut(( DEB_WARN, "SetQueryFromURL - reserved tag %.2ws\n", pwszTag ));
        THROW( CIxssoException(MSG_IXSSO_INVALID_QUERYSTRING_TAG, 0) );
        break;
    }

    return;
}

//+---------------------------------------------------------------------------
//
//  Member:     CQueryInfo::AddToParam - private
//
//  Synopsis:   Append a string to a parameter
//
//  Arguments:  [xpString] - A smart pointer to the string to be appended to
//              [pwszValue] - The value to be added to xpString
//              [pwszPre] - the separator for multiple values in xpString.
//                            Defaults to ','.
//              [pwszPost] - unconditionally appended to pwszValue
//
//  History:    19 Mar 1997      Alanw    Created
//
//----------------------------------------------------------------------------

void CQueryInfo::AddToParam( XPtrST<WCHAR> & xpString,
                             XPtrST<WCHAR> & pwszValue,
                             WCHAR const * pwszPre,
                             WCHAR const * pwszPost )
{
    unsigned cch = 0;

    if (0 == xpString.GetPointer())
    {
        if (0 == pwszPost)
        {
            xpString.Set( pwszValue.Acquire() );
        }
        else
        {
            if (pwszValue.GetPointer())
                cch = wcslen(pwszValue.GetPointer());

            xpString.Set( new WCHAR[cch + wcslen(pwszPost) + 1] );
            if (cch)
                wcsncpy(xpString.GetPointer(), pwszValue.GetPointer(), cch);
            wcscpy(xpString.GetPointer() + cch, pwszPost);
        }
        return;
    }

    cch = wcslen(xpString.GetPointer());
    cch += pwszPre ? wcslen(pwszPre) : wcslen(L",");
    if (pwszValue.GetPointer())
        cch += wcslen( pwszValue.GetPointer() );
    if (pwszPost)
        cch += wcslen( pwszPost );

    XPtrST<WCHAR> xpDest( new WCHAR[cch+1] );

    wcscpy(xpDest.GetPointer(), xpString.GetPointer());
    wcscat(xpDest.GetPointer(), pwszPre ? pwszPre : L",");
    if (pwszValue.GetPointer())
        wcscat(xpDest.GetPointer(), pwszValue.GetPointer());
    if (pwszPost)
        wcscat(xpDest.GetPointer(), pwszPost);

    xpString.Free();
    xpString.Set( xpDest.Acquire() );
}


//+---------------------------------------------------------------------------
//
//  Member:     CQueryInfo::SetBuiltupQueryTerm - private
//
//  Synopsis:   Add an individual partial query term to an array of terms.
//
//  Arguments:  [apString]   - A dynamic array of string pointers
//              [iTerm]     - The index of the term to be added
//              [pwszValue] - The value to be added to apString
//
//  Notes:      If the array entry for the term is already set, it is
//              overwritten.
//
//  History:    21 Mar 1997      Alanw    Created
//
//----------------------------------------------------------------------------

void CQueryInfo::SetBuiltupQueryTerm( CDynArray<WCHAR> & apString,
                                      unsigned iTerm,
                                      XPtrST<WCHAR> & pwszValue )
{
    Win4Assert( iTerm < 10 );

    delete apString.Acquire(iTerm);
    apString.Add( pwszValue.GetPointer(), iTerm );
    pwszValue.Acquire();
}

//+---------------------------------------------------------------------------
//
//  Member:     CQueryInfo::MakeFinalQueryString - public
//
//  Synopsis:   Combine the built-up query terms into the complete query
//              restriction.
//
//  Arguments:  - NONE -
//
//  History:    20 Mar 1997      Alanw    Created
//
//----------------------------------------------------------------------------

void CQueryInfo::MakeFinalQueryString( )
{
    //
    //  Add query terms to any pre-existing full query string
    //
    for (unsigned i = 0; i < 10; i++)
    {
        //  Ignore the term if the qn= part was not set.
        if ( _aQueryVal[i] != 0 )
        {
            XPtrST<WCHAR> xpStr(0);
            AddToParam( _xpQuery, xpStr, IMPLIED_QUERY_TERM_OPERATOR, L" ( ");

            if ( _aQueryCol[i] != 0 )
            {
                xpStr.Set( _aQueryCol.Acquire(i) );
                AddToParam( _xpQuery, xpStr, L"", L" ");
                xpStr.Free();
            }
            if ( _aQueryOp[i] != 0 )
            {
                xpStr.Set( _aQueryOp.Acquire(i) );
                AddToParam( _xpQuery, xpStr, L"", L" ");
                xpStr.Free();
            }
            if ( _aQueryVal[i] != 0 )
            {
                xpStr.Set( _aQueryVal.Acquire(i) );
                AddToParam( _xpQuery, xpStr, L"", L" ");
                xpStr.Free();
            }

            AddToParam( _xpQuery, xpStr, L")");
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\web\ixsso\ixssocf.cxx ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1995 - 2000.
//
//  File:       ixssocf.cxx
//
//  Contents:   Standard IClassFactory implementation
//
//  Classes:    CStaticClassFactory
//              CIxssoQueryCF
//
//  History:    26-Feb-96    SSanu    adapted from my Forms stuff
//
//----------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include "stdcf.hxx"
#include "regutil.h"
#include "ssodebug.hxx"
#include "ixsso.hxx"
#include "ixsutil.hxx"

#include <adoid.h>          // ADO CLSID and IID definitions

#include <initguid.h>

// HACKHACK - this is stolen from the old sdk\inc\adoid.h header:
#define DEFINE_ADOGUID(name, l) \
    DEFINE_GUID(name, l, 0, 0x10, 0x80,0,0,0xAA,0,0x6D,0x2E,0xA4)

// ADO V1.0 recordset class ID
DEFINE_ADOGUID(CLSID_CADORecordset_V1_0,     0x00000281);


#ifndef OLYMPUS_COMPONENT
    #define QUERY_PROG_ID         L"IXSSO.Query"
    #define QUERY_PROG_ID2        L"IXSSO.Query.2"
    #define QUERY_PROG_ID3        L"IXSSO.Query.3"
    #define QUERY_PROG_DESC       L"Indexing Service Query SSO V2."
    #define QUERY_PROG_DESC3      L"Indexing Service Query SSO V3."
extern WCHAR * g_pwszProgIdQuery = QUERY_PROG_ID;

    #define UTIL_PROG_ID          L"IXSSO.Util"
    #define UTIL_PROG_ID2         L"IXSSO.Util.2"
    #define UTIL_PROG_DESC        L"Indexing Service Utility SSO V2."

extern WCHAR * g_pwszProgIdUtil  = UTIL_PROG_ID;

extern WCHAR * g_pwszErrorMsgFile = L"query.dll";

    #define LIBID_ixsso        LIBID_Cisso
    #define CLSID_ixssoQuery   CLSID_CissoQuery
    #define CLSID_ixssoQueryEx CLSID_CissoQueryEx
    #define CLSID_ixssoUtil    CLSID_CissoUtil

#else
    #define NLQUERY_PROG_ID       L"MSSEARCH.Query"
    #define NLQUERY_PROG_ID1      L"MSSEARCH.Query.1"
    #define NLQUERY_PROG_DESC     L"Microsoft Site Server Search Query SSO V1."
extern WCHAR * g_pwszProgIdQuery = NLQUERY_PROG_ID;

    #define NLUTIL_PROG_ID        L"MSSEARCH.Util"
    #define NLUTIL_PROG_ID1       L"MSSEARCH.Util.1"
    #define NLUTIL_PROG_DESC      L"Microsoft Site Server Search Utility SSO V1."

extern WCHAR * g_pwszProgIdUtil  = NLUTIL_PROG_ID;

extern WCHAR * g_pwszErrorMsgFile = L"oquery.dll";

    #define LIBID_ixsso      LIBID_Nlsso
    #define CLSID_ixssoQuery CLSID_NlssoQuery
    #define CLSID_ixssoUtil  CLSID_NlssoUtil

#endif  // OLYMPUS_COMPONENT


//+------------------------------------------------------------------------
//
//  CStaticClassFactory Implementation
//
//-------------------------------------------------------------------------


//+---------------------------------------------------------------
//
//  Member:     CStaticClassFactory::QueryInterface, public
//
//  Synopsis:   Method of IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP
CStaticClassFactory::QueryInterface(REFIID riid, LPVOID FAR* ppv)
{
    if (!ppv)
        return E_INVALIDARG;

    if (riid == IID_IUnknown ||
        riid == IID_IClassFactory)
    {
        *ppv = (IClassFactory *) this;
    }
    else
    {
        *ppv = 0;
        return E_NOINTERFACE;
    }

    ((IUnknown *)*ppv)->AddRef();
    return S_OK;
}


//+---------------------------------------------------------------
//
//  Member:     CStaticClassFactory::AddRef, public
//
//  Synopsis:   Method of IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP_(ULONG)
CStaticClassFactory::AddRef(void)
{
    Win4Assert(_ulRefs);

    INC_OBJECT_COUNT();
    IXIncrement(_ulRefs);
    ixssoDebugOut((DEB_REFCOUNTS, "[DLL] CF::AddRef: refcounts: glob %d obj %d\n",
                   GET_OBJECT_COUNT(), _ulRefs ));
    return _ulRefs;
}


//+---------------------------------------------------------------
//
//  Member:     CStaticClassFactory::Release, public
//
//  Synopsis:   Method of IUnknown interface
//
//----------------------------------------------------------------

STDMETHODIMP_(ULONG)
CStaticClassFactory::Release(void)
{
    Win4Assert(_ulRefs > 1);

    IXDecrement(_ulRefs);
    DEC_OBJECT_COUNT();

    ixssoDebugOut((DEB_REFCOUNTS, "[DLL] CF::Release: refcounts: glob %d obj %d\n",
                   GET_OBJECT_COUNT(), _ulRefs ));
    return _ulRefs;
}

//+---------------------------------------------------------------
//
//  Member:     CStaticClassFactory::LockServer, public
//
//  Synopsis:   Method of IClassFactory interface
//
//  Notes:      Since class factories based on this class are global static
//              objects, this method doesn't serve much purpose.
//
//----------------------------------------------------------------

STDMETHODIMP
CStaticClassFactory::LockServer (BOOL fLock)
{
    if (fLock)
        INC_OBJECT_COUNT();
    else
        DEC_OBJECT_COUNT();
    ixssoDebugOut((DEB_REFCOUNTS, "[DLL] CF::LockServer( %x ) ==> %d\n", fLock, GET_OBJECT_COUNT() ));
    return NOERROR;
}



//-----------------------------------------------------------------------------
// CIxssoQueryCF Class Definition
//-----------------------------------------------------------------------------
class CIxssoQueryCF : public CStaticClassFactory
{
public:
    STDMETHOD(CreateInstance)(IUnknown *pUnkOuter, REFIID iid, LPVOID FAR* ppv);

    void TryInit();
    
    void SetClsid( CLSID ssoClsid ) { _ssoClsid = ssoClsid; }

    static ITypeLib *       _pITypeLibIxsso;
    static IClassFactory *  _pIAdoRecordsetCF;
    static BOOL             _fAdoV15;
    static CLSID            _ssoClsid;
} IxssoQueryCF; //The global factory

//-----------------------------------------------------------------------------
// CIxssoUtilCF Class Definition
//-----------------------------------------------------------------------------
class CIxssoUtilCF : public CStaticClassFactory
{
public:
    STDMETHOD(CreateInstance)(IUnknown *pUnkOuter, REFIID iid, LPVOID FAR* ppv);
} IxssoUtilCF; //The global factory


//-----------------------------------------------------------------------------
// Global variables
//-----------------------------------------------------------------------------

CRITICAL_SECTION g_cs;
HINSTANCE g_hInst;

ULONG            g_ulObjCount = 0;  // extern to keep track of object instances

LONG             g_lQryCount = 0;   // BUGBGUG - debugging for obj. ref. count
LONG             g_lUtlCount = 0;   // BUGBGUG - debugging for obj. ref. count


ITypeLib *       CIxssoQueryCF::_pITypeLibIxsso = 0;

IClassFactory *  CIxssoQueryCF::_pIAdoRecordsetCF = 0;
BOOL             CIxssoQueryCF::_fAdoV15 = FALSE;
CLSID            CIxssoQueryCF::_ssoClsid = CLSID_ixssoQueryEx;

CTheGlobalIXSSOVariables * g_pTheGlobalIXSSOVariables = 0;

//-----------------------------------------------------------------------------
//
//  Class:      CLockCritSec
//
//  Synopsis:   Like CLock, but takes a bare CRITICAL_SECTION, not a CMutexSem
//
//-----------------------------------------------------------------------------

class CLockCritSec : INHERIT_UNWIND
{
    INLINE_UNWIND(CLockCritSec);

public:
    CLockCritSec( CRITICAL_SECTION & cs ) :
       _cs( cs )
    {
        EnterCriticalSection( &_cs );
        END_CONSTRUCTION( CLockCritSec );
    }

    ~CLockCritSec( )
    {
        LeaveCriticalSection( &_cs );
    }

private:
    CRITICAL_SECTION &  _cs;
};


//-----------------------------------------------------------------------------
// CIxssoQueryCF Methods
//-----------------------------------------------------------------------------

STDMETHODIMP
CIxssoQueryCF::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID FAR* ppvObj)
{
    *ppvObj = 0;

    // NTRAID#DB-NTBUG9-84743-2000/07/31-dlee IXSSO class factory object does not support COM aggregation

    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    SCODE sc = E_OUTOFMEMORY;

    //
    // Guard against a race between TryInit and DllCanUnloadNow...
    //
    INC_OBJECT_COUNT();
    CixssoQuery * pObj = 0;

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        TryInit();

        Win4Assert( 0 != _pITypeLibIxsso && 0 != _pIAdoRecordsetCF );

        // create an instance of our CixssoQuery object
        pObj = new CixssoQuery( _pITypeLibIxsso,
                                _pIAdoRecordsetCF,
                                _fAdoV15,
                                _ssoClsid );
    }
    CATCH( CException, e )
    {
        ixssoDebugOut(( DEB_ERROR,
                        "Creation of CixssoQuery failed (%x)\n",
                        e.GetErrorCode() ));
        sc = e.GetErrorCode();
    }
    END_CATCH
    UNTRANSLATE_EXCEPTIONS;

    Win4Assert( 0 != _pITypeLibIxsso && 0 != _pIAdoRecordsetCF );
    DEC_OBJECT_COUNT();

    if (0 == pObj)
    {
        Win4Assert( !SUCCEEDED(sc) );
        return sc;
    }

#if CIDBG
    LONG l = InterlockedIncrement( &g_lQryCount );
    Win4Assert( l >= 1 );
#endif //CIDBG

    // fetch the interface and return
    sc = pObj->QueryInterface(riid, ppvObj);

    pObj->Release(); // on failure, this will release our IXSSO object
                     // otherwise, object will have a ref count of 1

    return sc;
}

//+---------------------------------------------------------------
//
//  Member:     CIxssoQueryCF::TryInit, public
//
//  Synopsis:   Do static initialization
//
//  Notes:      Do any required initialization of global objects.
//
//----------------------------------------------------------------

void CIxssoQueryCF::TryInit()
{
    Win4Assert (0 != g_ulObjCount);

    // Initialize any global variables needed
    if ( 0 == _pITypeLibIxsso ||
         0 == _pIAdoRecordsetCF ||
         0 == g_pTheGlobalIXSSOVariables )
    {
        CLockCritSec Lock(g_cs);

        // get the Type lib
        if (0 == _pITypeLibIxsso)
        {
            SCODE sc = LoadRegTypeLib(LIBID_ixsso, 1, 0, 0x409, &_pITypeLibIxsso);
            if (FAILED(sc))
                sc = LoadTypeLib( OLESTR("ixsso.tlb"), &_pITypeLibIxsso);

            if (FAILED(sc))
            {
                Win4Assert( 0 == _pITypeLibIxsso );
                ixssoDebugOut(( DEB_ERROR, "Type library load failed (%x)\n", sc));

                THROW(CException(sc));
            }
        }

        // Get the ADO recordset class factory
        if ( 0 == _pIAdoRecordsetCF )
        {
            SCODE sc = CoGetClassObject( CLSID_CADORecordset,
                                         CLSCTX_INPROC_HANDLER |
                                             CLSCTX_INPROC_SERVER,
                                         0,
                                         IID_IClassFactory,
                                         (void **)&_pIAdoRecordsetCF );

            _fAdoV15 = TRUE;
            if (REGDB_E_CLASSNOTREG == sc)
            {
                //
                // The class ID for the recordset changed in ADO V1.5.  Try
                // the ADO V1.0 class ID.
                //
                sc = CoGetClassObject( CLSID_CADORecordset_V1_0,
                                       CLSCTX_INPROC_HANDLER |
                                           CLSCTX_INPROC_SERVER,
                                       0,
                                       IID_IClassFactory,
                                       (void **)&_pIAdoRecordsetCF );

                if (SUCCEEDED(sc))
                    _fAdoV15 = FALSE;
            }

            if (FAILED(sc))
            {
                Win4Assert( 0 == _pIAdoRecordsetCF );
                ixssoDebugOut(( DEB_ERROR, "CoGetClassObject for ADO recordset failed (%x)\n", sc));

                THROW(CException(sc));
            }

            _pIAdoRecordsetCF->LockServer( TRUE );
        }

        // Initialize global variables needed by the IXSSO objects
        if ( 0 == g_pTheGlobalIXSSOVariables )
        {
            g_pTheGlobalIXSSOVariables = new CTheGlobalIXSSOVariables();
        }
    }
}

//-----------------------------------------------------------------------------
// CIxssoUtilCF Methods
//-----------------------------------------------------------------------------

STDMETHODIMP
CIxssoUtilCF::CreateInstance(LPUNKNOWN pUnkOuter, REFIID riid, LPVOID FAR* ppvObj)
{
    *ppvObj = 0;

    // NTRAID#DB-NTBUG9-84743-2000/07/31-dlee IXSSO class factory object does not support COM aggregation

    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    SCODE sc = E_OUTOFMEMORY;

    //
    // Guard against a race between TryInit and DllCanUnloadNow...
    //
    INC_OBJECT_COUNT();
    CixssoUtil * pObj = 0;

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        IxssoQueryCF.TryInit();

        Win4Assert( 0 != CIxssoQueryCF::_pITypeLibIxsso );

        // create an instance of our CixssoUtil object
        pObj = new CixssoUtil( CIxssoQueryCF::_pITypeLibIxsso );
    }
    CATCH( CException, e )
    {
        ixssoDebugOut(( DEB_ERROR,
                        "Creation of CixssoUtil failed (%x)\n",
                        e.GetErrorCode() ));
        sc = e.GetErrorCode();
    }
    END_CATCH
    UNTRANSLATE_EXCEPTIONS;

    Win4Assert( 0 != CIxssoQueryCF::_pITypeLibIxsso );
    DEC_OBJECT_COUNT();

    if (0 == pObj)
    {
        Win4Assert( !SUCCEEDED(sc) );
        return sc;
    }

#if CIDBG
    LONG l = InterlockedIncrement( &g_lUtlCount );
    Win4Assert( l >= 1 );
#endif //CIDBG

    // fetch the interface and return
    sc = pObj->QueryInterface(riid, ppvObj);

    pObj->Release(); // on failure, this will release our IXSSO object
                     // otherwise, object will have a ref count of 1

    return sc;
}


//-----------------------------------------------------------------------------
// Global Scope
//-----------------------------------------------------------------------------

#ifndef OLYMPUS_COMPONENT
const CLSID clsidCommandCreator = CLSID_CISimpleCommandCreator;

#else

//0b63e347-9ccc-11d0-bcdb-00805fccce04
extern "C" CLSID CLSID_NlCommandCreator;

#define clsidCommandCreator CLSID_NlCommandCreator

#endif // OLYMPUS_COMPONENT



CTheGlobalIXSSOVariables::CTheGlobalIXSSOVariables()
{
    VariantInit(&_vtAcceptLanguageHeader);

    V_VT(&_vtAcceptLanguageHeader) = VT_BSTR;
    V_BSTR(&_vtAcceptLanguageHeader) = SysAllocString(OLESTR("HTTP_ACCEPT_LANGUAGE"));

    HRESULT hr = CoCreateInstance( clsidCommandCreator,
                                   0,
                                   CLSCTX_INPROC_SERVER,
                                   IID_ISimpleCommandCreator,
                                   xCmdCreator.GetQIPointer() );

    if ( SUCCEEDED( hr ) && xCmdCreator.GetPointer() )
        xCmdCreator->QueryInterface(IID_IColumnMapperCreator,
                                  xColumnMapperCreator.GetQIPointer());
}


//-----------------------------------------------------------------------------
// OLE and DLL Methods
//-----------------------------------------------------------------------------

void FreeResources(void)
{
    CLockCritSec Lock(g_cs);

    if (0 == g_ulObjCount && CIxssoQueryCF::_pIAdoRecordsetCF)
    {
        CIxssoQueryCF::_pIAdoRecordsetCF->LockServer( FALSE );
        CIxssoQueryCF::_pIAdoRecordsetCF->Release();
        CIxssoQueryCF::_pIAdoRecordsetCF = 0;
    }
    if (0 == g_ulObjCount && CIxssoQueryCF::_pITypeLibIxsso)
    {
        CIxssoQueryCF::_pITypeLibIxsso->Release();
        CIxssoQueryCF::_pITypeLibIxsso = 0;
    }
    if (0 == g_ulObjCount && g_pTheGlobalIXSSOVariables )
    {
        delete g_pTheGlobalIXSSOVariables;
        g_pTheGlobalIXSSOVariables = 0;
    }

    ixssoDebugOut((DEB_REFCOUNTS, "[DLL] FreeResources -> %s\n",
                         (0 == g_ulObjCount) ? "S_OK" : "S_FALSE" ));
}

extern "C"
STDAPI DllCanUnloadNow(void)
{
    //Our answer is whether there are any object or locks

    ixssoDebugOut((DEB_REFCOUNTS,"[DLL] DllCanUnloadNow\n"));
    if (0 == g_ulObjCount)
    {
        FreeResources();
    }
    return (0 == g_ulObjCount) ? S_OK : S_FALSE;
}


extern "C"
STDAPI DllRegisterServer()
{
    ixssoDebugOut((DEB_TRACE,"[DLL] DllRegisterServer\n"));

    SCODE sc = S_OK;

#ifndef OLYMPUS_COMPONENT
    sc = _DllRegisterServer(g_hInst, QUERY_PROG_ID, CLSID_CissoQueryEx, QUERY_PROG_DESC3, QUERY_PROG_ID3);
    if (SUCCEEDED(sc))
        sc = _DllRegisterServer(g_hInst, QUERY_PROG_ID3, CLSID_CissoQueryEx, QUERY_PROG_DESC3);
    if (SUCCEEDED(sc))
        sc = _DllRegisterServer(g_hInst, QUERY_PROG_ID2, CLSID_CissoQuery, QUERY_PROG_DESC);

    if (SUCCEEDED(sc))
        sc = _DllRegisterServer(g_hInst, UTIL_PROG_ID, CLSID_CissoUtil, UTIL_PROG_DESC, UTIL_PROG_ID2);
    if (SUCCEEDED(sc))
        sc = _DllRegisterServer(g_hInst, UTIL_PROG_ID2, CLSID_CissoUtil, UTIL_PROG_DESC);
#else
    sc = _DllRegisterServer(g_hInst, NLQUERY_PROG_ID, CLSID_NlssoQuery, NLQUERY_PROG_DESC, NLQUERY_PROG_ID1);
    if (SUCCEEDED(sc))
        sc = _DllRegisterServer(g_hInst, NLQUERY_PROG_ID1, CLSID_NlssoQuery, NLQUERY_PROG_DESC);

    if (SUCCEEDED(sc))
        sc = _DllRegisterServer(g_hInst, NLUTIL_PROG_ID, CLSID_NlssoUtil, NLUTIL_PROG_DESC, NLUTIL_PROG_ID1);
    if (SUCCEEDED(sc))
        sc = _DllRegisterServer(g_hInst, NLUTIL_PROG_ID1, CLSID_NlssoUtil, NLUTIL_PROG_DESC);
#endif

    if (SUCCEEDED(sc))
    {
        // Register the type library
        WCHAR   wcsProgram[MAX_PATH+1];
        ULONG cchPath = GetModuleFileName(g_hInst, wcsProgram, MAX_PATH);
        XInterface<ITypeLib> xpITypeLibIxsso;

        if ( 0 != cchPath )
            sc = LoadTypeLib( wcsProgram, xpITypeLibIxsso.GetPPointer());
        else
            sc = E_FAIL;

        if (SUCCEEDED(sc))
            sc = RegisterTypeLib(xpITypeLibIxsso.GetPointer(), wcsProgram, 0);
        if (FAILED(sc))
        {
            ixssoDebugOut(( DEB_ERROR, "Type library load or registration failed (%x)\n", sc));

        #ifndef OLYMPUS_COMPONENT
            _DllUnregisterServer(QUERY_PROG_ID3, CLSID_CissoQueryEx);
            _DllUnregisterServer(QUERY_PROG_ID2, CLSID_CissoQuery);
            _DllUnregisterServer(QUERY_PROG_ID, CLSID_CissoQueryEx);
            _DllUnregisterServer(UTIL_PROG_ID2, CLSID_CissoUtil);
            _DllUnregisterServer(UTIL_PROG_ID, CLSID_CissoUtil);
        #else //OLYMPUS_COMPONENT
            _DllUnregisterServer(NLQUERY_PROG_ID1, CLSID_NlssoQuery);
            _DllUnregisterServer(NLQUERY_PROG_ID, CLSID_NlssoQuery);
            _DllUnregisterServer(NLUTIL_PROG_ID1, CLSID_NlssoUtil);
            _DllUnregisterServer(NLUTIL_PROG_ID, CLSID_NlssoUtil);
        #endif //OLYMPUS_COMPONENT
        }
    }

    return sc;
}

extern "C"
STDAPI DllUnregisterServer()
{
    ixssoDebugOut((DEB_TRACE,"[DLL] DllUnregisterServer\n"));

    SCODE sc;

    #ifndef OLYMPUS_COMPONENT
    sc = _DllUnregisterServer(QUERY_PROG_ID, CLSID_CissoQueryEx);
    if (SUCCEEDED(sc))
        sc = _DllUnregisterServer(QUERY_PROG_ID3, CLSID_CissoQueryEx);
    if (SUCCEEDED(sc))
        sc = _DllUnregisterServer(QUERY_PROG_ID2, CLSID_CissoQuery);

    if (SUCCEEDED(sc))
        sc = _DllUnregisterServer(UTIL_PROG_ID, CLSID_CissoUtil);
    if (SUCCEEDED(sc))
        sc = _DllUnregisterServer(UTIL_PROG_ID2, CLSID_CissoUtil);

    #else //OLYMPUS_COMPONENT
    sc = _DllUnregisterServer(NLQUERY_PROG_ID, CLSID_NlssoQuery);
    if (SUCCEEDED(sc))
        sc = _DllUnregisterServer(NLQUERY_PROG_ID1, CLSID_NlssoQuery);

    if (SUCCEEDED(sc))
        sc = _DllUnregisterServer(NLUTIL_PROG_ID, CLSID_NlssoUtil);
    if (SUCCEEDED(sc))
        sc = _DllUnregisterServer(NLUTIL_PROG_ID1, CLSID_NlssoUtil);
    #endif  //OLYMPUS_COMPONENT

    return sc;
}

extern "C"
STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID  * ppv)
{
    // get the class factory object
    if ( CLSID_ixssoQueryEx == rclsid || CLSID_ixssoQuery == rclsid )
    {
        IxssoQueryCF.SetClsid( rclsid );
        return IxssoQueryCF.QueryInterface( riid, ppv );
    }
    else if ( CLSID_ixssoUtil == rclsid )
    {
        // NOTE: There is no difference in the behavior of the Util object.
        return IxssoUtilCF.QueryInterface( riid, ppv );
    }
    else
    {
        return CLASS_E_CLASSNOTAVAILABLE;
    }
}


extern "C"
BOOL WINAPI DllMain(HINSTANCE hInst, DWORD dwReason, LPVOID lbv)
{
    BOOL fRetval = TRUE;

    TRANSLATE_EXCEPTIONS;
    TRY
    {
        switch (dwReason)
        {
    
        case DLL_PROCESS_ATTACH:
            //DbgPrint("IXSSO: [DLL] Process Attached\n");
            g_hInst = hInst;
            InitializeCriticalSection( &g_cs );
            break;
    
        case DLL_THREAD_DETACH:
            //
            // This is an opportunity to release resources; necessary since
            // ASP doesn't call CoFreeUnusedLibraries.
            //
            ixssoDebugOut((DEB_REFCOUNTS, "[DLL] Thread detached\n"));
            if (0 == g_ulObjCount)
            {
                FreeResources();
            }
            break;
    
        case DLL_PROCESS_DETACH:
    
            // NOTE:  We can get called here without having freed resources
            //        if the client application is single-threaded, or if
            //        thread detach calls are disabled.  In this case, it's
            //        too late to free the ADO recordset class factory because
            //        the ADO DLL may have already been unloaded.
    #if CIDBG
            if ( 0 != CIxssoQueryCF::_pIAdoRecordsetCF && 0 != g_ulObjCount )
            {
                ixssoDebugOut((DEB_WARN, "WARNING - %d unreleased objects\n", g_ulObjCount ));
            }
    #endif //CIDBG
    
            if (CIxssoQueryCF::_pITypeLibIxsso)
            {
                CIxssoQueryCF::_pITypeLibIxsso->Release();
                CIxssoQueryCF::_pITypeLibIxsso = 0;
            }
    
            if (g_pTheGlobalIXSSOVariables)
            {
                delete g_pTheGlobalIXSSOVariables;
                g_pTheGlobalIXSSOVariables = 0;
            }
    
            DeleteCriticalSection( &g_cs );
            // DbgPrint("IXSSO: [DLL] Process Detached\n");
            break;
        }
    }
    CATCH( CException, e )
    {
        // About the only thing this could be is STATUS_NO_MEMORY which
        // can be thrown by InitializeCriticalSection.

        ixssoDebugOut(( DEB_ERROR,
                        "IXSSO: Exception %#x in DllMain\n",
                        e.GetErrorCode()));

#if CIDBG == 1  // for debugging NTRAID 340297
        if (e.GetErrorCode() == STATUS_NO_MEMORY)
            DbgPrint( "IXSSO: STATUS_NO_MEMORY exception in DllMain\n");
        else
            DbgPrint( "IXSSO: ??? Exception in DllMain\n");
#endif // CIDBG == 1

        fRetval = FALSE;
    }
    END_CATCH
    UNTRANSLATE_EXCEPTIONS;

    return fRetval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\web\ixsso\ixsutil.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1997 - 2000.
//
//  File:       ixsutil.cxx
//
//  Contents:   Utility SSO class
//
//  History:    04 Apr 1997      Alanw    Created
//
//----------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop


//-----------------------------------------------------------------------------
// Include Files
//-----------------------------------------------------------------------------

// debugging macros
#include "ssodebug.hxx"

// class declaration
#include "stdcf.hxx"
#include "ixsso.hxx"
#include "ixsutil.hxx"

#include <string.hxx>
#include <htmlchar.hxx>

extern WCHAR * g_pwszProgIdUtil;

#if CIDBG
    extern ULONG g_ulObjCount;
    extern LONG  g_lUtlCount;
#endif // CIDBG

//-----------------------------------------------------------------------------
//
//  Member:     CixssoUtil::CixssoUtil - public
//
//  Synopsis:   Constructor of CixssoUtil
//
//  Arguments:  [pitlb] - pointer to ITypeLib for ixsso
//
//  History:    04 Apr 1997      Alanw    Created
//
//-----------------------------------------------------------------------------

CixssoUtil::CixssoUtil( ITypeLib * pitlb ) :
    _ptinfo( 0 ),
    _err( IID_IixssoUtil )
{
    _cRef = 1;

    SCODE sc = pitlb->GetTypeInfoOfGuid( IID_IixssoUtil, &_ptinfo );
    if (FAILED(sc))
    {
        ixssoDebugOut(( DEB_ERROR, "Util - GetTypeInfoOfGuid failed (%x)\n", sc ));
        Win4Assert(SUCCEEDED(sc));

        THROW( CException(sc) );
    }

    INC_OBJECT_COUNT();

    ixssoDebugOut((DEB_REFCOUNTS, "[DLL]: Create util: refcounts: glob %d util %d\n",
          g_ulObjCount,
          g_lUtlCount ));
} //CixssoUtil

//-----------------------------------------------------------------------------
//
//  Member:     CixssoUtil::~CixssoUtil - public
//
//  Synopsis:   Destructor of CixssoUtil
//
//  History:    04 Apr 1997      Alanw    Created
//
//-----------------------------------------------------------------------------

CixssoUtil::~CixssoUtil( )
{
    if (_ptinfo)
        _ptinfo->Release();
    DEC_OBJECT_COUNT();
#if CIDBG
    extern LONG g_lUtlCount;
    LONG l = InterlockedDecrement( &g_lUtlCount );
    Win4Assert( l >= 0 );
#endif //CIDBG

    ixssoDebugOut((DEB_REFCOUNTS, "[DLL]: Delete util: refcounts: glob %d util %d\n",
          g_ulObjCount,
          g_lUtlCount ));
} //~CixssoUtl


#if 0 // NOTE: OnStartPage and OnEndPage are unneeded
//
// ASP Methods
//

#include <asp/asptlb.h>

STDMETHODIMP CixssoUtil::OnStartPage (IUnknown* pUnk)
{
    // reset the error structure
    _err.Reset();

    SCODE sc;
    IScriptingContext *piContext;

    //Get IScriptingContext Interface
    sc = pUnk->QueryInterface(IID_IScriptingContext, (void**)&piContext);
    if (FAILED(sc))
        return E_FAIL;

    //Get Request Object Pointer
    IRequest* piRequest = NULL;
    sc = piContext->get_Request(&piRequest);

    //Get ServerVariables Pointer
    IRequestDictionary *piRequestDict = NULL;
    sc = piRequest->get_ServerVariables(&piRequestDict);

    VARIANT vtOut;
    VariantInit(&vtOut);

    //Get the HTTP_ACCEPT_LANGUAGE Item
    sc = piRequestDict->get_Item(g_vtAcceptLanguageHeader, &vtOut);

    //vtOut Contains an IDispatch Pointer.  To fetch the value
    //for HTTP_ACCEPT_LANGUAGE you must get the Default Value for the
    //Object stored in vtOut using VariantChangeType.
    if (V_VT(&vtOut) != VT_BSTR)
        VariantChangeType(&vtOut, &vtOut, 0, VT_BSTR);

    if (V_VT(&vtOut) == VT_BSTR)
    {
        ixssoDebugOut((DEB_TRACE, "OnStartPage: HTTP_ACCEPT_LANGUAGE = %ws\n",
                                   V_BSTR(&vtOut) ));
        SetLocaleString(V_BSTR(&vtOut));
    }
    else
    {
        ixssoDebugOut(( DEB_TRACE,
                        "OnStart: HTTP_ACCEPT_LANGAUGE was not set is ServerVariables; using lcid=0x%x\n",
                        GetSystemDefaultLCID() ));

        put_LocaleID( GetSystemDefaultLCID() );
    }

    VariantClear(&vtOut);

    piRequestDict->Release();
    piRequest->Release();
    piContext->Release();

    return S_OK;
}


HRESULT CixssoUtil::OnEndPage(void)
{

    return S_OK;
}
#endif  // 0 NOTE: OnStartPage and OnEndPage are unneeded


//-----------------------------------------------------------------------------
// CixssoUtil IUnknown Methods
//-----------------------------------------------------------------------------

STDMETHODIMP
CixssoUtil::QueryInterface(REFIID iid, void * * ppv)
{
    *ppv = 0;

    if (iid == IID_IUnknown || iid == IID_IDispatch)
        *ppv = (IDispatch *)this;
    else if (iid == IID_ISupportErrorInfo )
        *ppv = (ISupportErrorInfo *) this;
    else if (iid == IID_IixssoUtil )
        *ppv = (IixssoUtil *) this;
    else
        return E_NOINTERFACE;

    AddRef();
    return S_OK;
} //QueryInterface

STDMETHODIMP_(ULONG)
CixssoUtil::AddRef(void)
{
    return InterlockedIncrement((long *)&_cRef);
}

STDMETHODIMP_(ULONG)
CixssoUtil::Release(void)
{
    ULONG uTmp = InterlockedDecrement((long *)&_cRef);
    if (uTmp == 0)
    {
        delete this;
        return 0;
    }
    return uTmp;
}


//-----------------------------------------------------------------------------
// CixssoUtil IDispatch Methods
//-----------------------------------------------------------------------------

STDMETHODIMP
CixssoUtil::GetTypeInfoCount(UINT * pctinfo)
{
    *pctinfo = 1;
    return S_OK;
}

STDMETHODIMP
CixssoUtil::GetTypeInfo(
      UINT itinfo,
      LCID lcid,
      ITypeInfo * * pptinfo)
{
    _ptinfo->AddRef();
    *pptinfo = _ptinfo;
    return S_OK;
}

STDMETHODIMP
CixssoUtil::GetIDsOfNames(
      REFIID riid,
      OLECHAR * * rgszNames,
      UINT cNames,
      LCID lcid,
      DISPID * rgdispid)
{
    return DispGetIDsOfNames(_ptinfo, rgszNames, cNames, rgdispid);
}

STDMETHODIMP
CixssoUtil::Invoke(
      DISPID dispidMember,
      REFIID riid,
      LCID lcid,
      WORD wFlags,
      DISPPARAMS * pParams,
      VARIANT * pvarResult,
      EXCEPINFO * pexcepinfo,
      UINT * puArgErr)
{
    ixssoDebugOut((DEB_IDISPATCH, "Util - Invoking method dispid=%d wFlags=%d\n",
                                   dispidMember, wFlags ));


    _err.Reset();

    SCODE sc = DispInvoke( this, _ptinfo,
                           dispidMember, wFlags, pParams,
                           pvarResult, pexcepinfo, puArgErr );

    if ( _err.IsError() )
        sc = DISP_E_EXCEPTION;

    return sc;
}

STDMETHODIMP
CixssoUtil::InterfaceSupportsErrorInfo(
    REFIID riid)
{
    if (riid == IID_IixssoUtil)
        return S_OK;
    else
        return S_FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CixssoQuery::CopyWstrToBstr - private inline
//
//  Synopsis:   Copies a Unicode string to a BSTR
//
//  Arguments:  [pbstr] - destination BSTR
//              [pwstr] - string to be copied
//
//  Returns:    SCODE - status return
//
//  History:    25 Oct 1996      Alanw    Created
//
//----------------------------------------------------------------------------

inline
SCODE CixssoUtil::CopyWstrToBstr( BSTR * pbstr, WCHAR const * pwstr )
{
    *pbstr = 0;
    if (pwstr)
    {
        *pbstr = SysAllocString( pwstr );
        if (0 == *pbstr)
            return E_OUTOFMEMORY;
    }
    return S_OK;
}


//-----------------------------------------------------------------------------
// CixssoUtil Methods
//-----------------------------------------------------------------------------


//+---------------------------------------------------------------------------
//
//  Member:     CixssoUtil::ISOToLocaleID - public
//
//  Synopsis:   Parse the input string for a recognizable locale name
//
//  Arguments:  [bstrLocale] - input string
//              [pLcid]      - pointer where corresponding LCID is returned
//
//  Returns:    SCODE - status return
//
//  History:    04 Apr 1997      Alanw    Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CixssoUtil::ISOToLocaleID(BSTR bstrLocale, LONG *pLcid)
{
    _err.Reset();

    if ( 0 == pLcid )
        return E_INVALIDARG;

    *pLcid = GetLCIDFromString( bstrLocale );

    return S_OK;
}

//+---------------------------------------------------------------------------
//
//  Member:     CixssoUtil::LocaleIDToISO - public
//
//  Synopsis:   Return the ISO locale name for an LCID
//
//  Arguments:  [Lcid] - input LCID
//              [pstr] - pointer where output string is returned
//
//  Returns:    SCODE - status return
//
//  History:    04 Apr 1997      Alanw    Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CixssoUtil::LocaleIDToISO(LONG lcid, BSTR * pstr)
{
    _err.Reset();

    if ( 0 == pstr )
        return E_INVALIDARG;

    WCHAR awc[100];

    GetStringFromLCID( lcid, awc );

    return CopyWstrToBstr( pstr, awc );
}

//+---------------------------------------------------------------------------
//
//  Member:     CixssoUtil::AddScopeToQuery - public
//
//  Synopsis:   Parse the input string for a recognizable locale name
//
//  Arguments:  [pDisp]     - an IDispatch for the query object
//              [bstrScope] - input scope
//              [bstrDepth] - input depth (optional)
//
//  Returns:    SCODE - status return
//
//  Notes:      In the future, this will operate by modifying the query
//              property to include a scope restriction.
//              For now, it just adds the scope and depth via a private
//              interface.
//
//  History:    04 Apr 1997      Alanw    Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CixssoUtil::AddScopeToQuery( IDispatch * pDisp,
                             BSTR bstrScope,
                             BSTR bstrDepth)
{
    _err.Reset();

    SCODE sc = S_OK;
    CTranslateSystemExceptions translate;
    TRY
    {
        if ( 0 == pDisp )
            THROW( CException( E_INVALIDARG ) );

        IixssoQueryPrivate * pIQueryPvt = 0;
        sc = pDisp->QueryInterface( IID_IixssoQueryPrivate, (void **)&pIQueryPvt );

        if (FAILED(sc))
        {
            THROW(CException(sc));
        }

        XInterface<IixssoQueryPrivate> pQry(pIQueryPvt);
        pQry->AddScopeToQuery( bstrScope, bstrDepth );
    }
    CATCH( CIxssoException, e )
    {
        sc = e.GetErrorCode();
        SetError( sc, OLESTR("AddScopeToQuery"), eIxssoError );
    }
    AND_CATCH( CException, e )
    {
        sc = e.GetErrorCode();
        SetError( sc, OLESTR("AddScopeToQuery") );
    }
    END_CATCH

    return sc;
} //AddScopeToQuery

//+---------------------------------------------------------------------------
//
//  Member:     CixssoUtil::TruncateToWhitespace - public
//
//  Synopsis:   Truncate a string, preferably at a white space character.
//
//  Arguments:  [bstrIn]   - input string
//              [maxLen]   - maximum number of characters in output string
//              [pbstrOut] - pointer where output string is returned
//
//  Returns:    SCODE - status return
//
//  Notes:      The implementation does not take into account real word breaks.
//              This may not work too well on far eastern languages.
//
//  History:    04 Apr 1997      Alanw    Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CixssoUtil::TruncateToWhitespace(BSTR bstrIn, LONG maxLen, BSTR * pbstrOut)
{
    _err.Reset();

    ULONG cchString = 0;
    if (maxLen <= 0)
        return E_INVALIDARG;

    if (0 != bstrIn)
        cchString = SysStringLen(bstrIn);

    if (cchString > (unsigned)maxLen)
    {
        cchString = maxLen;
        for (unsigned i=0; i <= (unsigned)maxLen; i++)
        {
            if (iswspace(bstrIn[i]))
                cchString = i;
        }
    }

    *pbstrOut = SysAllocStringLen( bstrIn, cchString );

    if (0 == *pbstrOut)
        return E_OUTOFMEMORY;

    return S_OK;
} //TruncateToWhitespace

class XVariant
{
public:
    XVariant() : _pVar( 0 ) {}
    XVariant( VARIANT & var ) : _pVar( &var ) {}
    ~XVariant() { if ( 0 != _pVar ) VariantClear( _pVar ); }
    void Set( VARIANT & var ) { Win4Assert( 0 == _pVar ); _pVar = &var; }
private:
    VARIANT * _pVar;
};

//+---------------------------------------------------------------------------
//
//  Member:     CixssoUtil::GetArrayElement - public
//
//  Synopsis:   Returns an element in an array as a variant
//
//  Arguments:  [pVarIn]   - The input array (IDispatch or VT_ARRAY)
//              [iElement] - The element to retrieve
//              [pVarOut]  - Where the array element result is written
//
//  Returns:    SCODE - status return
//
//  History:    10 Sep 1997      dlee    Created
//              18 Jan 2000      KLam    DECIMAL needs to fit into a VARIANT
//                                       on Win64 VARIANT is bigger than DECIMAL
//
//----------------------------------------------------------------------------

STDMETHODIMP CixssoUtil::GetArrayElement(
    VARIANT * pVarIn,
    LONG      iElement,
    VARIANT * pVarOut )
{
    _err.Reset();

    //
    // Validate the variant arguments.
    //

    if ( ( 0 == pVarIn ) || ( 0 == pVarOut ) )
        return SetError( E_INVALIDARG, OLESTR( "GetArrayElement" ) );

    //
    // Get the source array, either from the IDispatch or just copy it.
    //

    XVariant xvar;
    VARIANT varArray;
    VariantInit( &varArray );

    if ( VT_DISPATCH == pVarIn->vt )
    {
        //
        // The first argument is an IDispatch, not the array value, so we
        // have to invoke it to get the value out.
        //

        if ( 0 == pVarIn->pdispVal )
            return SetError( E_INVALIDARG, OLESTR( "GetArrayElement" ) );

        DISPPARAMS dispparamsNoArgs = {NULL, NULL, 0, 0};

        SCODE sc = pVarIn->pdispVal->Invoke( DISPID_VALUE,
                                             IID_NULL,
                                             GetSystemDefaultLCID(),
                                             DISPATCH_PROPERTYGET,
                                             &dispparamsNoArgs,
                                             &varArray,
                                             0,
                                             0 );
        ixssoDebugOut(( DEB_ITRACE, "result of invoke: 0x%x\n", sc ));
        if ( FAILED( sc ) )
            return SetError( sc, OLESTR( "GetArrayElement" ) );

        xvar.Set( varArray );
    }
    else
    {
        varArray = *pVarIn;
    }

    ixssoDebugOut(( DEB_ITRACE, "value vt: 0x%x\n", varArray.vt ));

    //
    // Check for a valid variant array argument.
    //

    if ( ( 0 == ( VT_ARRAY & varArray.vt ) ) ||
         ( 0 == varArray.parray ) )
        return SetError( E_INVALIDARG, OLESTR( "GetArrayElement" ) );

    SAFEARRAY *psa = varArray.parray;

    //
    // This function only deals with 1-dimensional safearrays.
    //

    if ( 1 != SafeArrayGetDim( psa ) )
        return SetError( E_INVALIDARG, OLESTR( "GetArrayElement" ) );

    //
    // Make sure iElement is in the bounds of the array.
    //

    long lLowBound;
    SCODE sc = SafeArrayGetLBound( psa, 1, &lLowBound );
    if ( FAILED( sc ) )
        return SetError( sc, OLESTR( "GetArrayElement" ) );

    long lUpBound;
    sc = SafeArrayGetUBound( psa, 1, &lUpBound );
    if ( FAILED( sc ) )
        return SetError( sc, OLESTR( "GetArrayElement" ) );

    if ( ( iElement < lLowBound ) || ( iElement > lUpBound ) )
        return SetError( E_INVALIDARG, OLESTR( "GetArrayElement" ) );

    //
    // Get a pointer to the element.
    //

    void * pvData;
    sc = SafeArrayPtrOfIndex( psa, &iElement, &pvData );
    if ( FAILED( sc ) )
        return SetError( sc, OLESTR( "GetArrayElement" ) );

    //
    // Put the element in a local variant so it can be copied.
    //

    VARIANT var;
    VariantInit( &var );
    var.vt = varArray.vt & (~VT_ARRAY);
    unsigned cbElem = SafeArrayGetElemsize( psa );

    if ( VT_VARIANT == var.vt )
    {
        Win4Assert( sizeof( VARIANT ) == cbElem );
        RtlCopyMemory( &var, pvData, cbElem );
    }
    else if ( VT_DECIMAL == var.vt )
    {
        Win4Assert( sizeof( VARIANT ) >= cbElem &&
                    sizeof( DECIMAL ) == cbElem );
        RtlCopyMemory( &var, pvData, cbElem );
        var.vt = VT_DECIMAL;
    }
    else
    {
        Win4Assert( cbElem <= 8 );
        RtlCopyMemory( &var.lVal, pvData, cbElem );
    }

    //
    // Make a copy of the value into another local variant.
    //

    VARIANT varCopy;
    VariantInit( &varCopy );
    sc = VariantCopy( &varCopy, &var );
    if ( FAILED( sc ) )
        return SetError( sc, OLESTR( "GetArrayElement" ) );

    //
    // Free anything still allocated in the output variant, and transfer
    // the value to the output variant.
    //

    VariantClear( pVarOut );
    *pVarOut = varCopy;

    return S_OK;
} //GetArrayElement

//+---------------------------------------------------------------------------
//
//  Member:     CixssoUtil::HTMLEncode - public
//
//  Synopsis:   Encode a string for use in HTML.  Take the output code page
//              into account so that unicode characters not representable in
//              the code page are output as HTML numeric entities.
//
//  Arguments:  [bstrIn]   - input string
//              [codepage] - code page for output string
//              [pbstrOut] - pointer where output string is returned
//
//  Returns:    SCODE - status return
//
//  History:    04 Apr 1997      Alanw    Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CixssoUtil::HTMLEncode(BSTR bstrIn, LONG codepage, BSTR * pbstrOut)
{
    _err.Reset();

    SCODE sc = S_OK;
    CTranslateSystemExceptions translate;
    TRY
    {
        if ( ( codepage < 0 ) || ( 0 == pbstrOut ) )
            THROW( CException( E_INVALIDARG ) );

        CVirtualString vString( 512 );

        if ( 0 != bstrIn )
            HTMLEscapeW( bstrIn, vString, codepage );

        BSTR bstr = SysAllocStringLen( vString.GetPointer(), vString.StrLen() );
        if ( 0 == bstr )
            THROW( CException( E_OUTOFMEMORY ) );

        *pbstrOut = bstr;
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
        SetError( sc, OLESTR("HTMLEncode"), eIxssoError );
    }
    END_CATCH;

    return sc;
} //HTMLEncode

//+---------------------------------------------------------------------------
//
//  Member:     CixssoUtil::URLEncode - public
//
//  Synopsis:   Encode a string for use in a URL.  Take the output code page
//              into account so that unicode characters not representable in
//              the code page are output as %uxxxx escapes.
//
//  Arguments:  [bstrIn]   - input string
//              [codepage] - code page for output string
//              [pbstrOut] - pointer where output string is returned
//
//  Returns:    SCODE - status return
//
//  History:    04 Apr 1997      Alanw    Created
//
//----------------------------------------------------------------------------

STDMETHODIMP
CixssoUtil::URLEncode(BSTR bstrIn, LONG codepage, BSTR * pbstrOut)
{
    _err.Reset();

    SCODE sc = S_OK;
    CTranslateSystemExceptions translate;
    TRY
    {
        if ( ( codepage < 0 ) || ( 0 == pbstrOut ) )
            THROW( CException( E_INVALIDARG ) );

        CVirtualString vString( 512 );

        if ( 0 != bstrIn )
            URLEscapeW( bstrIn, vString, codepage, FALSE );

        BSTR bstr = SysAllocStringLen( vString.GetPointer(), vString.StrLen() );
        if ( 0 == bstr )
            THROW( CException( E_OUTOFMEMORY ) );

        *pbstrOut = bstr;
    }
    CATCH( CException, e )
    {
        sc = e.GetErrorCode();
        SetError( sc, OLESTR("URLEncode"), eIxssoError );
    }
    END_CATCH;

    return sc;
} //URLEncode
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\web\ixsso\pch.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       PCH.cxx
//
//  Contents:   Pre-compiled header
//
//  History:    07-Nov-95   DwightKr    Created
//
//--------------------------------------------------------------------------

extern "C"
{
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
}
#include <windows.h>
#include <objsafe.h>
#include <ocidl.h>
#include <comdef.h>
#include <shlguid.h>
#include <wininet.h>

#include <ctype.h>
#include <float.h>
#include <limits.h>
#include <stdio.h>

#include <cidebnot.h>
#include <ciexcpt.hxx>
#include <cisem.hxx>
#include <tsmem.hxx>
#include <smart.hxx>
#include <ci64.hxx>

#include <cierror.h>

// #define OLEDBVER 0x0250     // enable ICommandTree interface
#define deprecated          // enable IRowsetExactScroll
#include <oledb.h>
#include <query.h>
#include <dbcmdtre.hxx>

#include <stgprop.h>
#include <stgvarb.hxx>
#include <restrict.hxx>

#define _CAIROSTG_

#include <oledberr.h>

#include <vquery.hxx>
#include <dynarray.hxx>
#include <regacc.hxx>
#include <caturl.hxx>
#include <parser.hxx>
#include <plist.hxx>
#include <scanner.hxx>
#include <doquery.hxx>
#include <weblcid.hxx>
#include "ixsexcpt.hxx"
#include "ixssomsg.h"

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\web\ixsso\regutil.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 1998.
//
//  File:       regutil.h
//
//  Contents:   Utility funcitons for manipulating the registry
//
//  History:    25 Oct 1996      Alanw    Created
//
//----------------------------------------------------------------------------

#ifndef _regutil_H_
#define _regutil_H_

// functions to aid in DllRegisterServer() and DllUnregisterServer()
STDAPI _DllRegisterServer(HINSTANCE hInst,
                          LPWSTR pwszProgId,
                          REFCLSID clsid,
                          LPWSTR pwszDescription,
                          LPWSTR pwszCurVer = 0);

STDAPI _DllUnregisterServer(LPWSTR pwszProgID, REFCLSID clsid);

#endif // _regutil_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\web\ixsso\ci\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    makefile.inc.

!ENDIF

$(O)\ixsso.def: ixsso.def ..\ixsso.org

$(O)\ixsso.tlb $(O)\ixssoifc.h $(O)\ixsso_i.c: ..\ixsso.odl

$(O)\ixsso.res: $(O)\ixsso.tlb
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\web\ixsso\utest\qrybody2.inc ===
<A HREF="http:<%=RS("vpath")%>"><%=RS("path")%></A>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\web\ixsso\utest\qrybody3.inc ===
<TR>
  <TD BGCOLOR="f7efde" ALIGN=CENTER>
  <FONT STYLE="ARIAL NARROW" SIZE=1><%=NextRecordNumber %>.</FONT></TD>
  <TD BGCOLOR="f7efde" ALIGN=CENTER>
  <FONT STYLE="ARIAL NARROW" SIZE=1><%=RS("FileName")%></FONT></TD>
  <TD BGCOLOR="f7efde" ALIGN=LEFT>
  <FONT STYLE="ARIAL NARROW" SIZE=1><A HREF="http:<%=RS("vpath")%>"><%=RS("vpath")%></A></FONT></TD>
  <TD BGCOLOR="f7efde" ALIGN=CENTER>
  <FONT STYLE="ARIAL NARROW" SIZE=1><%=RS("Size")%></FONT></TD>
  <TD BGCOLOR="f7efde" ALIGN=CENTER>
  <FONT STYLE="ARIAL NARROW" SIZE=1><%=RS("Write")%></FONT></TD>
  </TR>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\web\ixsso\asp\asptlb.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 3.03.0110 */
/* at Sun Nov 16 14:31:59 1997
 */
/* Compiler settings for asp.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: none
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef ___asptlb_h__
#define ___asptlb_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __IStringList_FWD_DEFINED__
#define __IStringList_FWD_DEFINED__
typedef interface IStringList IStringList;
#endif 	/* __IStringList_FWD_DEFINED__ */


#ifndef __IRequestDictionary_FWD_DEFINED__
#define __IRequestDictionary_FWD_DEFINED__
typedef interface IRequestDictionary IRequestDictionary;
#endif 	/* __IRequestDictionary_FWD_DEFINED__ */


#ifndef __IRequest_FWD_DEFINED__
#define __IRequest_FWD_DEFINED__
typedef interface IRequest IRequest;
#endif 	/* __IRequest_FWD_DEFINED__ */


#ifndef __Request_FWD_DEFINED__
#define __Request_FWD_DEFINED__

#ifdef __cplusplus
typedef class Request Request;
#else
typedef struct Request Request;
#endif /* __cplusplus */

#endif 	/* __Request_FWD_DEFINED__ */


#ifndef __IReadCookie_FWD_DEFINED__
#define __IReadCookie_FWD_DEFINED__
typedef interface IReadCookie IReadCookie;
#endif 	/* __IReadCookie_FWD_DEFINED__ */


#ifndef __IWriteCookie_FWD_DEFINED__
#define __IWriteCookie_FWD_DEFINED__
typedef interface IWriteCookie IWriteCookie;
#endif 	/* __IWriteCookie_FWD_DEFINED__ */


#ifndef __IResponse_FWD_DEFINED__
#define __IResponse_FWD_DEFINED__
typedef interface IResponse IResponse;
#endif 	/* __IResponse_FWD_DEFINED__ */


#ifndef __Response_FWD_DEFINED__
#define __Response_FWD_DEFINED__

#ifdef __cplusplus
typedef class Response Response;
#else
typedef struct Response Response;
#endif /* __cplusplus */

#endif 	/* __Response_FWD_DEFINED__ */


#ifndef __IVariantDictionary_FWD_DEFINED__
#define __IVariantDictionary_FWD_DEFINED__
typedef interface IVariantDictionary IVariantDictionary;
#endif 	/* __IVariantDictionary_FWD_DEFINED__ */


#ifndef __ISessionObject_FWD_DEFINED__
#define __ISessionObject_FWD_DEFINED__
typedef interface ISessionObject ISessionObject;
#endif 	/* __ISessionObject_FWD_DEFINED__ */


#ifndef __Session_FWD_DEFINED__
#define __Session_FWD_DEFINED__

#ifdef __cplusplus
typedef class Session Session;
#else
typedef struct Session Session;
#endif /* __cplusplus */

#endif 	/* __Session_FWD_DEFINED__ */


#ifndef __IApplicationObject_FWD_DEFINED__
#define __IApplicationObject_FWD_DEFINED__
typedef interface IApplicationObject IApplicationObject;
#endif 	/* __IApplicationObject_FWD_DEFINED__ */


#ifndef __Application_FWD_DEFINED__
#define __Application_FWD_DEFINED__

#ifdef __cplusplus
typedef class Application Application;
#else
typedef struct Application Application;
#endif /* __cplusplus */

#endif 	/* __Application_FWD_DEFINED__ */


#ifndef __IServer_FWD_DEFINED__
#define __IServer_FWD_DEFINED__
typedef interface IServer IServer;
#endif 	/* __IServer_FWD_DEFINED__ */


#ifndef __Server_FWD_DEFINED__
#define __Server_FWD_DEFINED__

#ifdef __cplusplus
typedef class Server Server;
#else
typedef struct Server Server;
#endif /* __cplusplus */

#endif 	/* __Server_FWD_DEFINED__ */


#ifndef __IScriptingContext_FWD_DEFINED__
#define __IScriptingContext_FWD_DEFINED__
typedef interface IScriptingContext IScriptingContext;
#endif 	/* __IScriptingContext_FWD_DEFINED__ */


#ifndef __ScriptingContext_FWD_DEFINED__
#define __ScriptingContext_FWD_DEFINED__

#ifdef __cplusplus
typedef class ScriptingContext ScriptingContext;
#else
typedef struct ScriptingContext ScriptingContext;
#endif /* __cplusplus */

#endif 	/* __ScriptingContext_FWD_DEFINED__ */


void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __ASPTypeLibrary_LIBRARY_DEFINED__
#define __ASPTypeLibrary_LIBRARY_DEFINED__

/****************************************
 * Generated header for library: ASPTypeLibrary
 * at Sun Nov 16 14:31:59 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [version][lcid][helpstring][uuid] */ 



DEFINE_GUID(LIBID_ASPTypeLibrary,0xD97A6DA0,0xA85C,0x11cf,0x83,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

#ifndef __IStringList_INTERFACE_DEFINED__
#define __IStringList_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IStringList
 * at Sun Nov 16 14:31:59 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][hidden][dual][oleautomation][helpstring][uuid] */ 



DEFINE_GUID(IID_IStringList,0xD97A6DA0,0xA85D,0x11cf,0x83,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A85D-11cf-83AE-00A0C90C2BD8")
    IStringList : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in][optional] */ VARIANT i,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ int __RPC_FAR *cStrRet) = 0;
        
        virtual /* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IStringListVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IStringList __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IStringList __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IStringList __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IStringList __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IStringList __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IStringList __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IStringList __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IStringList __RPC_FAR * This,
            /* [in][optional] */ VARIANT i,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IStringList __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *cStrRet);
        
        /* [restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IStringList __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);
        
        END_INTERFACE
    } IStringListVtbl;

    interface IStringList
    {
        CONST_VTBL struct IStringListVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IStringList_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IStringList_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IStringList_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IStringList_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IStringList_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IStringList_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IStringList_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IStringList_get_Item(This,i,pVariantReturn)	\
    (This)->lpVtbl -> get_Item(This,i,pVariantReturn)

#define IStringList_get_Count(This,cStrRet)	\
    (This)->lpVtbl -> get_Count(This,cStrRet)

#define IStringList_get__NewEnum(This,ppEnumReturn)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnumReturn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IStringList_get_Item_Proxy( 
    IStringList __RPC_FAR * This,
    /* [in][optional] */ VARIANT i,
    /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn);


void __RPC_STUB IStringList_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IStringList_get_Count_Proxy( 
    IStringList __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *cStrRet);


void __RPC_STUB IStringList_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IStringList_get__NewEnum_Proxy( 
    IStringList __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);


void __RPC_STUB IStringList_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IStringList_INTERFACE_DEFINED__ */


#ifndef __IRequestDictionary_INTERFACE_DEFINED__
#define __IRequestDictionary_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRequestDictionary
 * at Sun Nov 16 14:31:59 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][hidden][dual][oleautomation][helpstring][uuid] */ 



DEFINE_GUID(IID_IRequestDictionary,0xD97A6DA0,0xA85F,0x11df,0x83,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A85F-11df-83AE-00A0C90C2BD8")
    IRequestDictionary : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in][optional] */ VARIANT Var,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn) = 0;
        
        virtual /* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ int __RPC_FAR *cStrRet) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Key( 
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRequestDictionaryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRequestDictionary __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRequestDictionary __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRequestDictionary __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IRequestDictionary __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IRequestDictionary __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IRequestDictionary __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IRequestDictionary __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IRequestDictionary __RPC_FAR * This,
            /* [in][optional] */ VARIANT Var,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn);
        
        /* [restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IRequestDictionary __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IRequestDictionary __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *cStrRet);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Key )( 
            IRequestDictionary __RPC_FAR * This,
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        END_INTERFACE
    } IRequestDictionaryVtbl;

    interface IRequestDictionary
    {
        CONST_VTBL struct IRequestDictionaryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRequestDictionary_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRequestDictionary_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRequestDictionary_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRequestDictionary_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IRequestDictionary_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IRequestDictionary_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IRequestDictionary_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IRequestDictionary_get_Item(This,Var,pVariantReturn)	\
    (This)->lpVtbl -> get_Item(This,Var,pVariantReturn)

#define IRequestDictionary_get__NewEnum(This,ppEnumReturn)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnumReturn)

#define IRequestDictionary_get_Count(This,cStrRet)	\
    (This)->lpVtbl -> get_Count(This,cStrRet)

#define IRequestDictionary_get_Key(This,VarKey,pvar)	\
    (This)->lpVtbl -> get_Key(This,VarKey,pvar)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IRequestDictionary_get_Item_Proxy( 
    IRequestDictionary __RPC_FAR * This,
    /* [in][optional] */ VARIANT Var,
    /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn);


void __RPC_STUB IRequestDictionary_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IRequestDictionary_get__NewEnum_Proxy( 
    IRequestDictionary __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);


void __RPC_STUB IRequestDictionary_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRequestDictionary_get_Count_Proxy( 
    IRequestDictionary __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *cStrRet);


void __RPC_STUB IRequestDictionary_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IRequestDictionary_get_Key_Proxy( 
    IRequestDictionary __RPC_FAR * This,
    /* [in] */ VARIANT VarKey,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);


void __RPC_STUB IRequestDictionary_get_Key_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRequestDictionary_INTERFACE_DEFINED__ */


#ifndef __IRequest_INTERFACE_DEFINED__
#define __IRequest_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IRequest
 * at Sun Nov 16 14:31:59 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][hidden][dual][oleautomation][uuid] */ 



DEFINE_GUID(IID_IRequest,0xD97A6DA0,0xA861,0x11cf,0x93,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A861-11cf-93AE-00A0C90C2BD8")
    IRequest : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ BSTR bstrVar,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppObjReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_QueryString( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Form( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
        virtual /* [hidden][propget] */ HRESULT STDMETHODCALLTYPE get_Body( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ServerVariables( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ClientCertificate( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Cookies( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_TotalBytes( 
            /* [retval][out] */ long __RPC_FAR *pcbTotal) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE BinaryRead( 
            /* [out][in] */ VARIANT __RPC_FAR *pvarCountToRead,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarReturn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IRequestVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IRequest __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IRequest __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IRequest __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IRequest __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IRequest __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IRequest __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IRequest __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IRequest __RPC_FAR * This,
            /* [in] */ BSTR bstrVar,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppObjReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_QueryString )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Form )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        /* [hidden][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Body )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ServerVariables )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ClientCertificate )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Cookies )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_TotalBytes )( 
            IRequest __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *pcbTotal);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BinaryRead )( 
            IRequest __RPC_FAR * This,
            /* [out][in] */ VARIANT __RPC_FAR *pvarCountToRead,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarReturn);
        
        END_INTERFACE
    } IRequestVtbl;

    interface IRequest
    {
        CONST_VTBL struct IRequestVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IRequest_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IRequest_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IRequest_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IRequest_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IRequest_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IRequest_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IRequest_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IRequest_get_Item(This,bstrVar,ppObjReturn)	\
    (This)->lpVtbl -> get_Item(This,bstrVar,ppObjReturn)

#define IRequest_get_QueryString(This,ppDictReturn)	\
    (This)->lpVtbl -> get_QueryString(This,ppDictReturn)

#define IRequest_get_Form(This,ppDictReturn)	\
    (This)->lpVtbl -> get_Form(This,ppDictReturn)

#define IRequest_get_Body(This,ppDictReturn)	\
    (This)->lpVtbl -> get_Body(This,ppDictReturn)

#define IRequest_get_ServerVariables(This,ppDictReturn)	\
    (This)->lpVtbl -> get_ServerVariables(This,ppDictReturn)

#define IRequest_get_ClientCertificate(This,ppDictReturn)	\
    (This)->lpVtbl -> get_ClientCertificate(This,ppDictReturn)

#define IRequest_get_Cookies(This,ppDictReturn)	\
    (This)->lpVtbl -> get_Cookies(This,ppDictReturn)

#define IRequest_get_TotalBytes(This,pcbTotal)	\
    (This)->lpVtbl -> get_TotalBytes(This,pcbTotal)

#define IRequest_BinaryRead(This,pvarCountToRead,pvarReturn)	\
    (This)->lpVtbl -> BinaryRead(This,pvarCountToRead,pvarReturn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_Item_Proxy( 
    IRequest __RPC_FAR * This,
    /* [in] */ BSTR bstrVar,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppObjReturn);


void __RPC_STUB IRequest_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_QueryString_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_QueryString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_Form_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_Form_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_Body_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_Body_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_ServerVariables_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_ServerVariables_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_ClientCertificate_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_ClientCertificate_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_Cookies_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppDictReturn);


void __RPC_STUB IRequest_get_Cookies_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IRequest_get_TotalBytes_Proxy( 
    IRequest __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *pcbTotal);


void __RPC_STUB IRequest_get_TotalBytes_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IRequest_BinaryRead_Proxy( 
    IRequest __RPC_FAR * This,
    /* [out][in] */ VARIANT __RPC_FAR *pvarCountToRead,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarReturn);


void __RPC_STUB IRequest_BinaryRead_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IRequest_INTERFACE_DEFINED__ */


DEFINE_GUID(CLSID_Request,0x920c25d0,0x25d9,0x11d0,0xa5,0x5f,0x00,0xa0,0xc9,0x0c,0x20,0x91);

#ifdef __cplusplus

class DECLSPEC_UUID("920c25d0-25d9-11d0-a55f-00a0c90c2091")
Request;
#endif

#ifndef __IReadCookie_INTERFACE_DEFINED__
#define __IReadCookie_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IReadCookie
 * at Sun Nov 16 14:31:59 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][hidden][dual][oleautomation][helpstring][uuid] */ 



DEFINE_GUID(IID_IReadCookie,0x71EAF260,0x0CE0,0x11D0,0xA5,0x3E,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("71EAF260-0CE0-11D0-A53E-00A0C90C2091")
    IReadCookie : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in][optional] */ VARIANT Var,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_HasKeys( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfHasKeys) = 0;
        
        virtual /* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ int __RPC_FAR *cStrRet) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Key( 
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IReadCookieVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IReadCookie __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IReadCookie __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IReadCookie __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IReadCookie __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IReadCookie __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IReadCookie __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IReadCookie __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IReadCookie __RPC_FAR * This,
            /* [in][optional] */ VARIANT Var,
            /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HasKeys )( 
            IReadCookie __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfHasKeys);
        
        /* [restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IReadCookie __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IReadCookie __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *cStrRet);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Key )( 
            IReadCookie __RPC_FAR * This,
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        END_INTERFACE
    } IReadCookieVtbl;

    interface IReadCookie
    {
        CONST_VTBL struct IReadCookieVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IReadCookie_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IReadCookie_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IReadCookie_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IReadCookie_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IReadCookie_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IReadCookie_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IReadCookie_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IReadCookie_get_Item(This,Var,pVariantReturn)	\
    (This)->lpVtbl -> get_Item(This,Var,pVariantReturn)

#define IReadCookie_get_HasKeys(This,pfHasKeys)	\
    (This)->lpVtbl -> get_HasKeys(This,pfHasKeys)

#define IReadCookie_get__NewEnum(This,ppEnumReturn)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnumReturn)

#define IReadCookie_get_Count(This,cStrRet)	\
    (This)->lpVtbl -> get_Count(This,cStrRet)

#define IReadCookie_get_Key(This,VarKey,pvar)	\
    (This)->lpVtbl -> get_Key(This,VarKey,pvar)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IReadCookie_get_Item_Proxy( 
    IReadCookie __RPC_FAR * This,
    /* [in][optional] */ VARIANT Var,
    /* [retval][out] */ VARIANT __RPC_FAR *pVariantReturn);


void __RPC_STUB IReadCookie_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IReadCookie_get_HasKeys_Proxy( 
    IReadCookie __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfHasKeys);


void __RPC_STUB IReadCookie_get_HasKeys_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IReadCookie_get__NewEnum_Proxy( 
    IReadCookie __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);


void __RPC_STUB IReadCookie_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IReadCookie_get_Count_Proxy( 
    IReadCookie __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *cStrRet);


void __RPC_STUB IReadCookie_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IReadCookie_get_Key_Proxy( 
    IReadCookie __RPC_FAR * This,
    /* [in] */ VARIANT VarKey,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);


void __RPC_STUB IReadCookie_get_Key_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IReadCookie_INTERFACE_DEFINED__ */


#ifndef __IWriteCookie_INTERFACE_DEFINED__
#define __IWriteCookie_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IWriteCookie
 * at Sun Nov 16 14:31:59 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][hidden][dual][oleautomation][helpstring][uuid] */ 



DEFINE_GUID(IID_IWriteCookie,0xD97A6DA0,0xA862,0x11cf,0x84,0xAE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A862-11cf-84AE-00A0C90C2BD8")
    IWriteCookie : public IDispatch
    {
    public:
        virtual /* [id][propput] */ HRESULT STDMETHODCALLTYPE put_Item( 
            /* [in][optional] */ VARIANT key,
            /* [in] */ BSTR bstrValue) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Expires( 
            /* [in] */ DATE dtExpires) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Domain( 
            /* [in] */ BSTR bstrDomain) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Path( 
            /* [in] */ BSTR bstrPath) = 0;
        
        virtual /* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE put_Secure( 
            /* [in] */ VARIANT_BOOL fSecure) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_HasKeys( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfHasKeys) = 0;
        
        virtual /* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IWriteCookieVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IWriteCookie __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IWriteCookie __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IWriteCookie __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Item )( 
            IWriteCookie __RPC_FAR * This,
            /* [in][optional] */ VARIANT key,
            /* [in] */ BSTR bstrValue);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Expires )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ DATE dtExpires);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Domain )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ BSTR bstrDomain);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Path )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ BSTR bstrPath);
        
        /* [helpstring][propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Secure )( 
            IWriteCookie __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fSecure);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_HasKeys )( 
            IWriteCookie __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfHasKeys);
        
        /* [restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IWriteCookie __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);
        
        END_INTERFACE
    } IWriteCookieVtbl;

    interface IWriteCookie
    {
        CONST_VTBL struct IWriteCookieVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IWriteCookie_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IWriteCookie_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IWriteCookie_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IWriteCookie_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IWriteCookie_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IWriteCookie_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IWriteCookie_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IWriteCookie_put_Item(This,key,bstrValue)	\
    (This)->lpVtbl -> put_Item(This,key,bstrValue)

#define IWriteCookie_put_Expires(This,dtExpires)	\
    (This)->lpVtbl -> put_Expires(This,dtExpires)

#define IWriteCookie_put_Domain(This,bstrDomain)	\
    (This)->lpVtbl -> put_Domain(This,bstrDomain)

#define IWriteCookie_put_Path(This,bstrPath)	\
    (This)->lpVtbl -> put_Path(This,bstrPath)

#define IWriteCookie_put_Secure(This,fSecure)	\
    (This)->lpVtbl -> put_Secure(This,fSecure)

#define IWriteCookie_get_HasKeys(This,pfHasKeys)	\
    (This)->lpVtbl -> get_HasKeys(This,pfHasKeys)

#define IWriteCookie_get__NewEnum(This,ppEnumReturn)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnumReturn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propput] */ HRESULT STDMETHODCALLTYPE IWriteCookie_put_Item_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [in][optional] */ VARIANT key,
    /* [in] */ BSTR bstrValue);


void __RPC_STUB IWriteCookie_put_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IWriteCookie_put_Expires_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [in] */ DATE dtExpires);


void __RPC_STUB IWriteCookie_put_Expires_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IWriteCookie_put_Domain_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [in] */ BSTR bstrDomain);


void __RPC_STUB IWriteCookie_put_Domain_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IWriteCookie_put_Path_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [in] */ BSTR bstrPath);


void __RPC_STUB IWriteCookie_put_Path_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propput] */ HRESULT STDMETHODCALLTYPE IWriteCookie_put_Secure_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fSecure);


void __RPC_STUB IWriteCookie_put_Secure_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IWriteCookie_get_HasKeys_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfHasKeys);


void __RPC_STUB IWriteCookie_get_HasKeys_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IWriteCookie_get__NewEnum_Proxy( 
    IWriteCookie __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);


void __RPC_STUB IWriteCookie_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IWriteCookie_INTERFACE_DEFINED__ */


#ifndef __IResponse_INTERFACE_DEFINED__
#define __IResponse_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IResponse
 * at Sun Nov 16 14:31:59 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][hidden][dual][oleautomation][uuid] */ 



DEFINE_GUID(IID_IResponse,0xD97A6DA0,0xA864,0x11cf,0x83,0xBE,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A864-11cf-83BE-00A0C90C2BD8")
    IResponse : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Buffer( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *fIsBuffering) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Buffer( 
            /* [in] */ VARIANT_BOOL fIsBuffering) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ContentType( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrContentTypeRet) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ContentType( 
            /* [in] */ BSTR bstrContentType) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Expires( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresMinutesRet) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Expires( 
            /* [in] */ long lExpiresMinutes) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ExpiresAbsolute( 
            /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresRet) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ExpiresAbsolute( 
            /* [in] */ DATE dtExpires) = 0;
        
        virtual /* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE get_Cookies( 
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppCookies) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Status( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrStatusRet) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Status( 
            /* [in] */ BSTR bstrStatus) = 0;
        
        virtual /* [hidden] */ HRESULT STDMETHODCALLTYPE Add( 
            /* [in] */ BSTR bstrHeaderValue,
            /* [in] */ BSTR bstrHeaderName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddHeader( 
            /* [in] */ BSTR bstrHeaderName,
            /* [in] */ BSTR bstrHeaderValue) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AppendToLog( 
            /* [in] */ BSTR bstrLogEntry) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE BinaryWrite( 
            /* [in] */ VARIANT varInput) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Clear( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE End( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Flush( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Redirect( 
            /* [in] */ BSTR bstrURL) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Write( 
            /* [in] */ VARIANT varText) = 0;
        
        virtual /* [hidden] */ HRESULT STDMETHODCALLTYPE WriteBlock( 
            /* [in] */ short iBlockNumber) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE IsClientConnected( 
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfIsClientConnected) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_CharSet( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCharSetRet) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CharSet( 
            /* [in] */ BSTR bstrCharSet) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Pics( 
            /* [in] */ BSTR bstrHeaderValue) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_CacheControl( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCacheControl) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CacheControl( 
            /* [in] */ BSTR bstrCacheControl) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IResponseVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IResponse __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IResponse __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IResponse __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IResponse __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IResponse __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IResponse __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IResponse __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Buffer )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *fIsBuffering);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Buffer )( 
            IResponse __RPC_FAR * This,
            /* [in] */ VARIANT_BOOL fIsBuffering);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ContentType )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrContentTypeRet);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ContentType )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrContentType);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Expires )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresMinutesRet);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Expires )( 
            IResponse __RPC_FAR * This,
            /* [in] */ long lExpiresMinutes);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ExpiresAbsolute )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresRet);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ExpiresAbsolute )( 
            IResponse __RPC_FAR * This,
            /* [in] */ DATE dtExpires);
        
        /* [propget][helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Cookies )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppCookies);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Status )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrStatusRet);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Status )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrStatus);
        
        /* [hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Add )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrHeaderValue,
            /* [in] */ BSTR bstrHeaderName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AddHeader )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrHeaderName,
            /* [in] */ BSTR bstrHeaderValue);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *AppendToLog )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrLogEntry);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *BinaryWrite )( 
            IResponse __RPC_FAR * This,
            /* [in] */ VARIANT varInput);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clear )( 
            IResponse __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *End )( 
            IResponse __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Flush )( 
            IResponse __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Redirect )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrURL);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Write )( 
            IResponse __RPC_FAR * This,
            /* [in] */ VARIANT varText);
        
        /* [hidden] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *WriteBlock )( 
            IResponse __RPC_FAR * This,
            /* [in] */ short iBlockNumber);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *IsClientConnected )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfIsClientConnected);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CharSet )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCharSetRet);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CharSet )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrCharSet);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Pics )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrHeaderValue);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CacheControl )( 
            IResponse __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrCacheControl);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CacheControl )( 
            IResponse __RPC_FAR * This,
            /* [in] */ BSTR bstrCacheControl);
        
        END_INTERFACE
    } IResponseVtbl;

    interface IResponse
    {
        CONST_VTBL struct IResponseVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IResponse_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IResponse_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IResponse_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IResponse_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IResponse_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IResponse_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IResponse_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IResponse_get_Buffer(This,fIsBuffering)	\
    (This)->lpVtbl -> get_Buffer(This,fIsBuffering)

#define IResponse_put_Buffer(This,fIsBuffering)	\
    (This)->lpVtbl -> put_Buffer(This,fIsBuffering)

#define IResponse_get_ContentType(This,pbstrContentTypeRet)	\
    (This)->lpVtbl -> get_ContentType(This,pbstrContentTypeRet)

#define IResponse_put_ContentType(This,bstrContentType)	\
    (This)->lpVtbl -> put_ContentType(This,bstrContentType)

#define IResponse_get_Expires(This,pvarExpiresMinutesRet)	\
    (This)->lpVtbl -> get_Expires(This,pvarExpiresMinutesRet)

#define IResponse_put_Expires(This,lExpiresMinutes)	\
    (This)->lpVtbl -> put_Expires(This,lExpiresMinutes)

#define IResponse_get_ExpiresAbsolute(This,pvarExpiresRet)	\
    (This)->lpVtbl -> get_ExpiresAbsolute(This,pvarExpiresRet)

#define IResponse_put_ExpiresAbsolute(This,dtExpires)	\
    (This)->lpVtbl -> put_ExpiresAbsolute(This,dtExpires)

#define IResponse_get_Cookies(This,ppCookies)	\
    (This)->lpVtbl -> get_Cookies(This,ppCookies)

#define IResponse_get_Status(This,pbstrStatusRet)	\
    (This)->lpVtbl -> get_Status(This,pbstrStatusRet)

#define IResponse_put_Status(This,bstrStatus)	\
    (This)->lpVtbl -> put_Status(This,bstrStatus)

#define IResponse_Add(This,bstrHeaderValue,bstrHeaderName)	\
    (This)->lpVtbl -> Add(This,bstrHeaderValue,bstrHeaderName)

#define IResponse_AddHeader(This,bstrHeaderName,bstrHeaderValue)	\
    (This)->lpVtbl -> AddHeader(This,bstrHeaderName,bstrHeaderValue)

#define IResponse_AppendToLog(This,bstrLogEntry)	\
    (This)->lpVtbl -> AppendToLog(This,bstrLogEntry)

#define IResponse_BinaryWrite(This,varInput)	\
    (This)->lpVtbl -> BinaryWrite(This,varInput)

#define IResponse_Clear(This)	\
    (This)->lpVtbl -> Clear(This)

#define IResponse_End(This)	\
    (This)->lpVtbl -> End(This)

#define IResponse_Flush(This)	\
    (This)->lpVtbl -> Flush(This)

#define IResponse_Redirect(This,bstrURL)	\
    (This)->lpVtbl -> Redirect(This,bstrURL)

#define IResponse_Write(This,varText)	\
    (This)->lpVtbl -> Write(This,varText)

#define IResponse_WriteBlock(This,iBlockNumber)	\
    (This)->lpVtbl -> WriteBlock(This,iBlockNumber)

#define IResponse_IsClientConnected(This,pfIsClientConnected)	\
    (This)->lpVtbl -> IsClientConnected(This,pfIsClientConnected)

#define IResponse_get_CharSet(This,pbstrCharSetRet)	\
    (This)->lpVtbl -> get_CharSet(This,pbstrCharSetRet)

#define IResponse_put_CharSet(This,bstrCharSet)	\
    (This)->lpVtbl -> put_CharSet(This,bstrCharSet)

#define IResponse_Pics(This,bstrHeaderValue)	\
    (This)->lpVtbl -> Pics(This,bstrHeaderValue)

#define IResponse_get_CacheControl(This,pbstrCacheControl)	\
    (This)->lpVtbl -> get_CacheControl(This,pbstrCacheControl)

#define IResponse_put_CacheControl(This,bstrCacheControl)	\
    (This)->lpVtbl -> put_CacheControl(This,bstrCacheControl)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IResponse_get_Buffer_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *fIsBuffering);


void __RPC_STUB IResponse_get_Buffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IResponse_put_Buffer_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ VARIANT_BOOL fIsBuffering);


void __RPC_STUB IResponse_put_Buffer_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IResponse_get_ContentType_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrContentTypeRet);


void __RPC_STUB IResponse_get_ContentType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IResponse_put_ContentType_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrContentType);


void __RPC_STUB IResponse_put_ContentType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IResponse_get_Expires_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresMinutesRet);


void __RPC_STUB IResponse_get_Expires_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IResponse_put_Expires_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ long lExpiresMinutes);


void __RPC_STUB IResponse_put_Expires_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IResponse_get_ExpiresAbsolute_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ VARIANT __RPC_FAR *pvarExpiresRet);


void __RPC_STUB IResponse_get_ExpiresAbsolute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IResponse_put_ExpiresAbsolute_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ DATE dtExpires);


void __RPC_STUB IResponse_put_ExpiresAbsolute_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_get_Cookies_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ IRequestDictionary __RPC_FAR *__RPC_FAR *ppCookies);


void __RPC_STUB IResponse_get_Cookies_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IResponse_get_Status_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrStatusRet);


void __RPC_STUB IResponse_get_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IResponse_put_Status_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrStatus);


void __RPC_STUB IResponse_put_Status_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden] */ HRESULT STDMETHODCALLTYPE IResponse_Add_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrHeaderValue,
    /* [in] */ BSTR bstrHeaderName);


void __RPC_STUB IResponse_Add_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_AddHeader_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrHeaderName,
    /* [in] */ BSTR bstrHeaderValue);


void __RPC_STUB IResponse_AddHeader_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_AppendToLog_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrLogEntry);


void __RPC_STUB IResponse_AppendToLog_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_BinaryWrite_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ VARIANT varInput);


void __RPC_STUB IResponse_BinaryWrite_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_Clear_Proxy( 
    IResponse __RPC_FAR * This);


void __RPC_STUB IResponse_Clear_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_End_Proxy( 
    IResponse __RPC_FAR * This);


void __RPC_STUB IResponse_End_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_Flush_Proxy( 
    IResponse __RPC_FAR * This);


void __RPC_STUB IResponse_Flush_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_Redirect_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrURL);


void __RPC_STUB IResponse_Redirect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_Write_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ VARIANT varText);


void __RPC_STUB IResponse_Write_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [hidden] */ HRESULT STDMETHODCALLTYPE IResponse_WriteBlock_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ short iBlockNumber);


void __RPC_STUB IResponse_WriteBlock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_IsClientConnected_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ VARIANT_BOOL __RPC_FAR *pfIsClientConnected);


void __RPC_STUB IResponse_IsClientConnected_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IResponse_get_CharSet_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrCharSetRet);


void __RPC_STUB IResponse_get_CharSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IResponse_put_CharSet_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrCharSet);


void __RPC_STUB IResponse_put_CharSet_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IResponse_Pics_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrHeaderValue);


void __RPC_STUB IResponse_Pics_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IResponse_get_CacheControl_Proxy( 
    IResponse __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrCacheControl);


void __RPC_STUB IResponse_get_CacheControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IResponse_put_CacheControl_Proxy( 
    IResponse __RPC_FAR * This,
    /* [in] */ BSTR bstrCacheControl);


void __RPC_STUB IResponse_put_CacheControl_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IResponse_INTERFACE_DEFINED__ */


DEFINE_GUID(CLSID_Response,0x46E19BA0,0x25DD,0x11D0,0xA5,0x5F,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#ifdef __cplusplus

class DECLSPEC_UUID("46E19BA0-25DD-11D0-A55F-00A0C90C2091")
Response;
#endif

#ifndef __IVariantDictionary_INTERFACE_DEFINED__
#define __IVariantDictionary_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IVariantDictionary
 * at Sun Nov 16 14:31:59 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][hidden][dual][oleautomation][helpstring][uuid] */ 



DEFINE_GUID(IID_IVariantDictionary,0x4a7deb90,0xb069,0x11d0,0xb3,0x73,0x00,0xa0,0xc9,0x0c,0x2b,0xd8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("4a7deb90-b069-11d0-b373-00a0c90c2bd8")
    IVariantDictionary : public IDispatch
    {
    public:
        virtual /* [id][propget] */ HRESULT STDMETHODCALLTYPE get_Item( 
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Item( 
            /* [in] */ VARIANT VarKey,
            /* [in] */ VARIANT var) = 0;
        
        virtual /* [propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Item( 
            /* [in] */ VARIANT VarKey,
            /* [in] */ VARIANT var) = 0;
        
        virtual /* [propget] */ HRESULT STDMETHODCALLTYPE get_Key( 
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Count( 
            /* [retval][out] */ int __RPC_FAR *cStrRet) = 0;
        
        virtual /* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE get__NewEnum( 
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IVariantDictionaryVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IVariantDictionary __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IVariantDictionary __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IVariantDictionary __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Item )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Item )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ VARIANT VarKey,
            /* [in] */ VARIANT var);
        
        /* [propputref][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_Item )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ VARIANT VarKey,
            /* [in] */ VARIANT var);
        
        /* [propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Key )( 
            IVariantDictionary __RPC_FAR * This,
            /* [in] */ VARIANT VarKey,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Count )( 
            IVariantDictionary __RPC_FAR * This,
            /* [retval][out] */ int __RPC_FAR *cStrRet);
        
        /* [restricted][id][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get__NewEnum )( 
            IVariantDictionary __RPC_FAR * This,
            /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);
        
        END_INTERFACE
    } IVariantDictionaryVtbl;

    interface IVariantDictionary
    {
        CONST_VTBL struct IVariantDictionaryVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IVariantDictionary_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IVariantDictionary_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IVariantDictionary_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IVariantDictionary_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IVariantDictionary_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IVariantDictionary_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IVariantDictionary_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IVariantDictionary_get_Item(This,VarKey,pvar)	\
    (This)->lpVtbl -> get_Item(This,VarKey,pvar)

#define IVariantDictionary_put_Item(This,VarKey,var)	\
    (This)->lpVtbl -> put_Item(This,VarKey,var)

#define IVariantDictionary_putref_Item(This,VarKey,var)	\
    (This)->lpVtbl -> putref_Item(This,VarKey,var)

#define IVariantDictionary_get_Key(This,VarKey,pvar)	\
    (This)->lpVtbl -> get_Key(This,VarKey,pvar)

#define IVariantDictionary_get_Count(This,cStrRet)	\
    (This)->lpVtbl -> get_Count(This,cStrRet)

#define IVariantDictionary_get__NewEnum(This,ppEnumReturn)	\
    (This)->lpVtbl -> get__NewEnum(This,ppEnumReturn)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [id][propget] */ HRESULT STDMETHODCALLTYPE IVariantDictionary_get_Item_Proxy( 
    IVariantDictionary __RPC_FAR * This,
    /* [in] */ VARIANT VarKey,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);


void __RPC_STUB IVariantDictionary_get_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IVariantDictionary_put_Item_Proxy( 
    IVariantDictionary __RPC_FAR * This,
    /* [in] */ VARIANT VarKey,
    /* [in] */ VARIANT var);


void __RPC_STUB IVariantDictionary_put_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propputref][id] */ HRESULT STDMETHODCALLTYPE IVariantDictionary_putref_Item_Proxy( 
    IVariantDictionary __RPC_FAR * This,
    /* [in] */ VARIANT VarKey,
    /* [in] */ VARIANT var);


void __RPC_STUB IVariantDictionary_putref_Item_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget] */ HRESULT STDMETHODCALLTYPE IVariantDictionary_get_Key_Proxy( 
    IVariantDictionary __RPC_FAR * This,
    /* [in] */ VARIANT VarKey,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);


void __RPC_STUB IVariantDictionary_get_Key_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IVariantDictionary_get_Count_Proxy( 
    IVariantDictionary __RPC_FAR * This,
    /* [retval][out] */ int __RPC_FAR *cStrRet);


void __RPC_STUB IVariantDictionary_get_Count_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [restricted][id][propget] */ HRESULT STDMETHODCALLTYPE IVariantDictionary_get__NewEnum_Proxy( 
    IVariantDictionary __RPC_FAR * This,
    /* [retval][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppEnumReturn);


void __RPC_STUB IVariantDictionary_get__NewEnum_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IVariantDictionary_INTERFACE_DEFINED__ */


#ifndef __ISessionObject_INTERFACE_DEFINED__
#define __ISessionObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: ISessionObject
 * at Sun Nov 16 14:31:59 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][hidden][oleautomation][dual][uuid] */ 



DEFINE_GUID(IID_ISessionObject,0xD97A6DA0,0xA865,0x11cf,0x83,0xAF,0x00,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A865-11cf-83AF-00A0C90C2BD8")
    ISessionObject : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_SessionID( 
            /* [retval][out] */ BSTR __RPC_FAR *pbstrRet) = 0;
        
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [in] */ BSTR bstrValue,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Value( 
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var) = 0;
        
        virtual /* [propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Value( 
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Timeout( 
            /* [retval][out] */ long __RPC_FAR *plvar) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_Timeout( 
            /* [in] */ long lvar) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Abandon( void) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_CodePage( 
            /* [retval][out] */ long __RPC_FAR *plvar) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_CodePage( 
            /* [in] */ long lvar) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_LCID( 
            /* [retval][out] */ long __RPC_FAR *plvar) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_LCID( 
            /* [in] */ long lvar) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_StaticObjects( 
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppTaggedObjects) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Contents( 
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISessionObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ISessionObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ISessionObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ISessionObject __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_SessionID )( 
            ISessionObject __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrRet);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Value )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Value )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var);
        
        /* [propputref][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_Value )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Timeout )( 
            ISessionObject __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plvar);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Timeout )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ long lvar);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Abandon )( 
            ISessionObject __RPC_FAR * This);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_CodePage )( 
            ISessionObject __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plvar);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_CodePage )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ long lvar);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_LCID )( 
            ISessionObject __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plvar);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_LCID )( 
            ISessionObject __RPC_FAR * This,
            /* [in] */ long lvar);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StaticObjects )( 
            ISessionObject __RPC_FAR * This,
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppTaggedObjects);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Contents )( 
            ISessionObject __RPC_FAR * This,
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties);
        
        END_INTERFACE
    } ISessionObjectVtbl;

    interface ISessionObject
    {
        CONST_VTBL struct ISessionObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISessionObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISessionObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISessionObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISessionObject_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ISessionObject_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ISessionObject_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ISessionObject_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ISessionObject_get_SessionID(This,pbstrRet)	\
    (This)->lpVtbl -> get_SessionID(This,pbstrRet)

#define ISessionObject_get_Value(This,bstrValue,pvar)	\
    (This)->lpVtbl -> get_Value(This,bstrValue,pvar)

#define ISessionObject_put_Value(This,bstrValue,var)	\
    (This)->lpVtbl -> put_Value(This,bstrValue,var)

#define ISessionObject_putref_Value(This,bstrValue,var)	\
    (This)->lpVtbl -> putref_Value(This,bstrValue,var)

#define ISessionObject_get_Timeout(This,plvar)	\
    (This)->lpVtbl -> get_Timeout(This,plvar)

#define ISessionObject_put_Timeout(This,lvar)	\
    (This)->lpVtbl -> put_Timeout(This,lvar)

#define ISessionObject_Abandon(This)	\
    (This)->lpVtbl -> Abandon(This)

#define ISessionObject_get_CodePage(This,plvar)	\
    (This)->lpVtbl -> get_CodePage(This,plvar)

#define ISessionObject_put_CodePage(This,lvar)	\
    (This)->lpVtbl -> put_CodePage(This,lvar)

#define ISessionObject_get_LCID(This,plvar)	\
    (This)->lpVtbl -> get_LCID(This,plvar)

#define ISessionObject_put_LCID(This,lvar)	\
    (This)->lpVtbl -> put_LCID(This,lvar)

#define ISessionObject_get_StaticObjects(This,ppTaggedObjects)	\
    (This)->lpVtbl -> get_StaticObjects(This,ppTaggedObjects)

#define ISessionObject_get_Contents(This,ppProperties)	\
    (This)->lpVtbl -> get_Contents(This,ppProperties)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISessionObject_get_SessionID_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrRet);


void __RPC_STUB ISessionObject_get_SessionID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propget][id] */ HRESULT STDMETHODCALLTYPE ISessionObject_get_Value_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);


void __RPC_STUB ISessionObject_get_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE ISessionObject_put_Value_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [in] */ VARIANT var);


void __RPC_STUB ISessionObject_put_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propputref][id] */ HRESULT STDMETHODCALLTYPE ISessionObject_putref_Value_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [in] */ VARIANT var);


void __RPC_STUB ISessionObject_putref_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISessionObject_get_Timeout_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plvar);


void __RPC_STUB ISessionObject_get_Timeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ISessionObject_put_Timeout_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [in] */ long lvar);


void __RPC_STUB ISessionObject_put_Timeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE ISessionObject_Abandon_Proxy( 
    ISessionObject __RPC_FAR * This);


void __RPC_STUB ISessionObject_Abandon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISessionObject_get_CodePage_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plvar);


void __RPC_STUB ISessionObject_get_CodePage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ISessionObject_put_CodePage_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [in] */ long lvar);


void __RPC_STUB ISessionObject_put_CodePage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISessionObject_get_LCID_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plvar);


void __RPC_STUB ISessionObject_get_LCID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE ISessionObject_put_LCID_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [in] */ long lvar);


void __RPC_STUB ISessionObject_put_LCID_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISessionObject_get_StaticObjects_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppTaggedObjects);


void __RPC_STUB ISessionObject_get_StaticObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE ISessionObject_get_Contents_Proxy( 
    ISessionObject __RPC_FAR * This,
    /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties);


void __RPC_STUB ISessionObject_get_Contents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISessionObject_INTERFACE_DEFINED__ */


DEFINE_GUID(CLSID_Session,0x509F8F20,0x25DE,0x11D0,0xA5,0x5F,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#ifdef __cplusplus

class DECLSPEC_UUID("509F8F20-25DE-11D0-A55F-00A0C90C2091")
Session;
#endif

#ifndef __IApplicationObject_INTERFACE_DEFINED__
#define __IApplicationObject_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IApplicationObject
 * at Sun Nov 16 14:31:59 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][hidden][dual][oleautomation][uuid] */ 



DEFINE_GUID(IID_IApplicationObject,0xD97A6DA0,0xA866,0x11cf,0x83,0xAE,0x10,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A866-11cf-83AE-10A0C90C2BD8")
    IApplicationObject : public IDispatch
    {
    public:
        virtual /* [propget][id] */ HRESULT STDMETHODCALLTYPE get_Value( 
            /* [in] */ BSTR bstrValue,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar) = 0;
        
        virtual /* [propput][id] */ HRESULT STDMETHODCALLTYPE put_Value( 
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var) = 0;
        
        virtual /* [propputref][id] */ HRESULT STDMETHODCALLTYPE putref_Value( 
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Lock( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE UnLock( void) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_StaticObjects( 
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Contents( 
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IApplicationObjectVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IApplicationObject __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IApplicationObject __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IApplicationObject __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [propget][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Value )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [retval][out] */ VARIANT __RPC_FAR *pvar);
        
        /* [propput][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_Value )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var);
        
        /* [propputref][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *putref_Value )( 
            IApplicationObject __RPC_FAR * This,
            /* [in] */ BSTR bstrValue,
            /* [in] */ VARIANT var);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Lock )( 
            IApplicationObject __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *UnLock )( 
            IApplicationObject __RPC_FAR * This);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_StaticObjects )( 
            IApplicationObject __RPC_FAR * This,
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Contents )( 
            IApplicationObject __RPC_FAR * This,
            /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties);
        
        END_INTERFACE
    } IApplicationObjectVtbl;

    interface IApplicationObject
    {
        CONST_VTBL struct IApplicationObjectVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IApplicationObject_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IApplicationObject_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IApplicationObject_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IApplicationObject_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IApplicationObject_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IApplicationObject_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IApplicationObject_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IApplicationObject_get_Value(This,bstrValue,pvar)	\
    (This)->lpVtbl -> get_Value(This,bstrValue,pvar)

#define IApplicationObject_put_Value(This,bstrValue,var)	\
    (This)->lpVtbl -> put_Value(This,bstrValue,var)

#define IApplicationObject_putref_Value(This,bstrValue,var)	\
    (This)->lpVtbl -> putref_Value(This,bstrValue,var)

#define IApplicationObject_Lock(This)	\
    (This)->lpVtbl -> Lock(This)

#define IApplicationObject_UnLock(This)	\
    (This)->lpVtbl -> UnLock(This)

#define IApplicationObject_get_StaticObjects(This,ppProperties)	\
    (This)->lpVtbl -> get_StaticObjects(This,ppProperties)

#define IApplicationObject_get_Contents(This,ppProperties)	\
    (This)->lpVtbl -> get_Contents(This,ppProperties)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [propget][id] */ HRESULT STDMETHODCALLTYPE IApplicationObject_get_Value_Proxy( 
    IApplicationObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [retval][out] */ VARIANT __RPC_FAR *pvar);


void __RPC_STUB IApplicationObject_get_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput][id] */ HRESULT STDMETHODCALLTYPE IApplicationObject_put_Value_Proxy( 
    IApplicationObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [in] */ VARIANT var);


void __RPC_STUB IApplicationObject_put_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propputref][id] */ HRESULT STDMETHODCALLTYPE IApplicationObject_putref_Value_Proxy( 
    IApplicationObject __RPC_FAR * This,
    /* [in] */ BSTR bstrValue,
    /* [in] */ VARIANT var);


void __RPC_STUB IApplicationObject_putref_Value_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IApplicationObject_Lock_Proxy( 
    IApplicationObject __RPC_FAR * This);


void __RPC_STUB IApplicationObject_Lock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IApplicationObject_UnLock_Proxy( 
    IApplicationObject __RPC_FAR * This);


void __RPC_STUB IApplicationObject_UnLock_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IApplicationObject_get_StaticObjects_Proxy( 
    IApplicationObject __RPC_FAR * This,
    /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties);


void __RPC_STUB IApplicationObject_get_StaticObjects_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IApplicationObject_get_Contents_Proxy( 
    IApplicationObject __RPC_FAR * This,
    /* [retval][out] */ IVariantDictionary __RPC_FAR *__RPC_FAR *ppProperties);


void __RPC_STUB IApplicationObject_get_Contents_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IApplicationObject_INTERFACE_DEFINED__ */


DEFINE_GUID(CLSID_Application,0x7C3BAF00,0x25DE,0x11D0,0xA5,0x5F,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#ifdef __cplusplus

class DECLSPEC_UUID("7C3BAF00-25DE-11D0-A55F-00A0C90C2091")
Application;
#endif

#ifndef __IServer_INTERFACE_DEFINED__
#define __IServer_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IServer
 * at Sun Nov 16 14:31:59 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][hidden][dual][oleautomation][uuid] */ 



DEFINE_GUID(IID_IServer,0xD97A6DA0,0xA867,0x11cf,0x83,0xAE,0x01,0xA0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A867-11cf-83AE-01A0C90C2BD8")
    IServer : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_ScriptTimeout( 
            /* [retval][out] */ long __RPC_FAR *plTimeoutSeconds) = 0;
        
        virtual /* [propput] */ HRESULT STDMETHODCALLTYPE put_ScriptTimeout( 
            /* [in] */ long lTimeoutSeconds) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE CreateObject( 
            /* [in] */ BSTR bstrProgID,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispObject) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE HTMLEncode( 
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE MapPath( 
            /* [in] */ BSTR bstrLogicalPath,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrPhysicalPath) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE URLEncode( 
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE URLPathEncode( 
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IServerVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IServer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IServer __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IServer __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IServer __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IServer __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IServer __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IServer __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_ScriptTimeout )( 
            IServer __RPC_FAR * This,
            /* [retval][out] */ long __RPC_FAR *plTimeoutSeconds);
        
        /* [propput] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *put_ScriptTimeout )( 
            IServer __RPC_FAR * This,
            /* [in] */ long lTimeoutSeconds);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *CreateObject )( 
            IServer __RPC_FAR * This,
            /* [in] */ BSTR bstrProgID,
            /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispObject);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *HTMLEncode )( 
            IServer __RPC_FAR * This,
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *MapPath )( 
            IServer __RPC_FAR * This,
            /* [in] */ BSTR bstrLogicalPath,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrPhysicalPath);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *URLEncode )( 
            IServer __RPC_FAR * This,
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *URLPathEncode )( 
            IServer __RPC_FAR * This,
            /* [in] */ BSTR bstrIn,
            /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded);
        
        END_INTERFACE
    } IServerVtbl;

    interface IServer
    {
        CONST_VTBL struct IServerVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IServer_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IServer_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IServer_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IServer_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IServer_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IServer_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IServer_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IServer_get_ScriptTimeout(This,plTimeoutSeconds)	\
    (This)->lpVtbl -> get_ScriptTimeout(This,plTimeoutSeconds)

#define IServer_put_ScriptTimeout(This,lTimeoutSeconds)	\
    (This)->lpVtbl -> put_ScriptTimeout(This,lTimeoutSeconds)

#define IServer_CreateObject(This,bstrProgID,ppDispObject)	\
    (This)->lpVtbl -> CreateObject(This,bstrProgID,ppDispObject)

#define IServer_HTMLEncode(This,bstrIn,pbstrEncoded)	\
    (This)->lpVtbl -> HTMLEncode(This,bstrIn,pbstrEncoded)

#define IServer_MapPath(This,bstrLogicalPath,pbstrPhysicalPath)	\
    (This)->lpVtbl -> MapPath(This,bstrLogicalPath,pbstrPhysicalPath)

#define IServer_URLEncode(This,bstrIn,pbstrEncoded)	\
    (This)->lpVtbl -> URLEncode(This,bstrIn,pbstrEncoded)

#define IServer_URLPathEncode(This,bstrIn,pbstrEncoded)	\
    (This)->lpVtbl -> URLPathEncode(This,bstrIn,pbstrEncoded)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IServer_get_ScriptTimeout_Proxy( 
    IServer __RPC_FAR * This,
    /* [retval][out] */ long __RPC_FAR *plTimeoutSeconds);


void __RPC_STUB IServer_get_ScriptTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [propput] */ HRESULT STDMETHODCALLTYPE IServer_put_ScriptTimeout_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ long lTimeoutSeconds);


void __RPC_STUB IServer_put_ScriptTimeout_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IServer_CreateObject_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ BSTR bstrProgID,
    /* [retval][out] */ IDispatch __RPC_FAR *__RPC_FAR *ppDispObject);


void __RPC_STUB IServer_CreateObject_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IServer_HTMLEncode_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ BSTR bstrIn,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded);


void __RPC_STUB IServer_HTMLEncode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IServer_MapPath_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ BSTR bstrLogicalPath,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrPhysicalPath);


void __RPC_STUB IServer_MapPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IServer_URLEncode_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ BSTR bstrIn,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded);


void __RPC_STUB IServer_URLEncode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IServer_URLPathEncode_Proxy( 
    IServer __RPC_FAR * This,
    /* [in] */ BSTR bstrIn,
    /* [retval][out] */ BSTR __RPC_FAR *pbstrEncoded);


void __RPC_STUB IServer_URLPathEncode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IServer_INTERFACE_DEFINED__ */


DEFINE_GUID(CLSID_Server,0xA506D160,0x25E0,0x11D0,0xA5,0x5F,0x00,0xA0,0xC9,0x0C,0x20,0x91);

#ifdef __cplusplus

class DECLSPEC_UUID("A506D160-25E0-11D0-A55F-00A0C90C2091")
Server;
#endif

#ifndef __IScriptingContext_INTERFACE_DEFINED__
#define __IScriptingContext_INTERFACE_DEFINED__

/****************************************
 * Generated header for interface: IScriptingContext
 * at Sun Nov 16 14:31:59 1997
 * using MIDL 3.03.0110
 ****************************************/
/* [object][hidden][dual][oleautomation][helpstring][uuid] */ 



DEFINE_GUID(IID_IScriptingContext,0xD97A6DA0,0xA868,0x11cf,0x83,0xAE,0x00,0xB0,0xC9,0x0C,0x2B,0xD8);

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("D97A6DA0-A868-11cf-83AE-00B0C90C2BD8")
    IScriptingContext : public IDispatch
    {
    public:
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Request( 
            /* [retval][out] */ IRequest __RPC_FAR *__RPC_FAR *ppRequest) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Response( 
            /* [retval][out] */ IResponse __RPC_FAR *__RPC_FAR *ppResponse) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Server( 
            /* [retval][out] */ IServer __RPC_FAR *__RPC_FAR *ppServer) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Session( 
            /* [retval][out] */ ISessionObject __RPC_FAR *__RPC_FAR *ppSession) = 0;
        
        virtual /* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE get_Application( 
            /* [retval][out] */ IApplicationObject __RPC_FAR *__RPC_FAR *ppApplication) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IScriptingContextVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IScriptingContext __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IScriptingContext __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IScriptingContext __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IScriptingContext __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IScriptingContext __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IScriptingContext __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IScriptingContext __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Request )( 
            IScriptingContext __RPC_FAR * This,
            /* [retval][out] */ IRequest __RPC_FAR *__RPC_FAR *ppRequest);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Response )( 
            IScriptingContext __RPC_FAR * This,
            /* [retval][out] */ IResponse __RPC_FAR *__RPC_FAR *ppResponse);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Server )( 
            IScriptingContext __RPC_FAR * This,
            /* [retval][out] */ IServer __RPC_FAR *__RPC_FAR *ppServer);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Session )( 
            IScriptingContext __RPC_FAR * This,
            /* [retval][out] */ ISessionObject __RPC_FAR *__RPC_FAR *ppSession);
        
        /* [helpstring][propget] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *get_Application )( 
            IScriptingContext __RPC_FAR * This,
            /* [retval][out] */ IApplicationObject __RPC_FAR *__RPC_FAR *ppApplication);
        
        END_INTERFACE
    } IScriptingContextVtbl;

    interface IScriptingContext
    {
        CONST_VTBL struct IScriptingContextVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IScriptingContext_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IScriptingContext_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IScriptingContext_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IScriptingContext_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IScriptingContext_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IScriptingContext_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IScriptingContext_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IScriptingContext_get_Request(This,ppRequest)	\
    (This)->lpVtbl -> get_Request(This,ppRequest)

#define IScriptingContext_get_Response(This,ppResponse)	\
    (This)->lpVtbl -> get_Response(This,ppResponse)

#define IScriptingContext_get_Server(This,ppServer)	\
    (This)->lpVtbl -> get_Server(This,ppServer)

#define IScriptingContext_get_Session(This,ppSession)	\
    (This)->lpVtbl -> get_Session(This,ppSession)

#define IScriptingContext_get_Application(This,ppApplication)	\
    (This)->lpVtbl -> get_Application(This,ppApplication)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IScriptingContext_get_Request_Proxy( 
    IScriptingContext __RPC_FAR * This,
    /* [retval][out] */ IRequest __RPC_FAR *__RPC_FAR *ppRequest);


void __RPC_STUB IScriptingContext_get_Request_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IScriptingContext_get_Response_Proxy( 
    IScriptingContext __RPC_FAR * This,
    /* [retval][out] */ IResponse __RPC_FAR *__RPC_FAR *ppResponse);


void __RPC_STUB IScriptingContext_get_Response_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IScriptingContext_get_Server_Proxy( 
    IScriptingContext __RPC_FAR * This,
    /* [retval][out] */ IServer __RPC_FAR *__RPC_FAR *ppServer);


void __RPC_STUB IScriptingContext_get_Server_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IScriptingContext_get_Session_Proxy( 
    IScriptingContext __RPC_FAR * This,
    /* [retval][out] */ ISessionObject __RPC_FAR *__RPC_FAR *ppSession);


void __RPC_STUB IScriptingContext_get_Session_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][propget] */ HRESULT STDMETHODCALLTYPE IScriptingContext_get_Application_Proxy( 
    IScriptingContext __RPC_FAR * This,
    /* [retval][out] */ IApplicationObject __RPC_FAR *__RPC_FAR *ppApplication);


void __RPC_STUB IScriptingContext_get_Application_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IScriptingContext_INTERFACE_DEFINED__ */


DEFINE_GUID(CLSID_ScriptingContext,0xD97A6DA0,0xA868,0x11cf,0x83,0xAE,0x11,0xB0,0xC9,0x0C,0x2B,0xD8);

#ifdef __cplusplus

class DECLSPEC_UUID("D97A6DA0-A868-11cf-83AE-11B0C90C2BD8")
ScriptingContext;
#endif
#endif /* __ASPTypeLibrary_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\web\ixsso\olympus\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1998

Module Name:

    makefile.inc.

!ENDIF

$(O)\oixsso.def: oixsso.def ..\ixsso.org

$(O)\ixsso.tlb ixssoifc.h ixsso_i.c: ..\ixsso.odl

$(O)\oixsso.res: $(O)\ixsso.tlb
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\web\ixsso\regutil.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1996 - 2001.
//
//  File:       regutil.cxx
//
//  Contents:   Functions supporting class registration
//
//  History:    25 Oct 1996      Alanw    Created
//
//----------------------------------------------------------------------------

#include "pch.cxx"
#pragma hdrstop

#include "regutil.h"

#define GUID_SIZE 128

//+---------------------------------------------------------------------------
//
//  Function:   _DllRegisterServer - public
//
//  Synopsis:   Installs a class registration for an inproc server
//
//  Arguments:  [hInst] --           HINSTANCE of DLL to be installed
//              [pwszProgId] --      program ID (class name)
//              [clsid] --           Class ID of class
//              [pwszDescription] -- description of class
//              [pwszCurVer]      -- if non-NULL, current version
//
//  Returns:    SCODE - status of registration
//
//  History:    03 Jan 1997      Alanw    Added header
//
//  NTRAID#DB-NTBUG9-84747-2000/07/31-dlee No transaction / Rollback semantics for DLL registration of IXSSO
//
//----------------------------------------------------------------------------

STDAPI _DllRegisterServer(HINSTANCE hInst,
                          LPWSTR pwszProgId,
                          REFCLSID clsid,
                          LPWSTR pwszDescription,
                          LPWSTR pwszCurVer)
{
    HKEY    hKey;
    WCHAR   wcsSubKey[MAX_PATH+1];
    WCHAR   wcsClsId[GUID_SIZE+1];
    
    StringFromGUID2(clsid, wcsClsId, sizeof(wcsClsId) / sizeof WCHAR);
     
    LONG r = RegCreateKey(HKEY_CLASSES_ROOT, pwszProgId, &hKey);
    if ( ERROR_SUCCESS != r )
        return HRESULT_FROM_WIN32( r );

    r = RegSetValue(hKey, NULL, REG_SZ,
                    pwszDescription, wcslen(pwszDescription) * sizeof (WCHAR));
    RegCloseKey(hKey);

    if ( ERROR_SUCCESS != r )
        return HRESULT_FROM_WIN32( r );

    wsprintf(wcsSubKey, L"%ws\\CLSID", pwszProgId);
    r = RegCreateKey(HKEY_CLASSES_ROOT, wcsSubKey, &hKey);
    if ( ERROR_SUCCESS != r )
        return HRESULT_FROM_WIN32( r );
    r = RegSetValue(hKey, NULL, REG_SZ,
                    wcsClsId, wcslen(wcsClsId) * sizeof (WCHAR));
    RegCloseKey(hKey);
    if ( ERROR_SUCCESS != r )
        return HRESULT_FROM_WIN32( r );

    if ( pwszCurVer )
    {
        wsprintf(wcsSubKey, L"%ws\\CurVer", pwszProgId);
        r = RegCreateKey(HKEY_CLASSES_ROOT, wcsSubKey, &hKey);
        if ( ERROR_SUCCESS != r )
            return HRESULT_FROM_WIN32( r );
        r = RegSetValue(hKey, NULL, REG_SZ,
                    pwszCurVer, wcslen(pwszCurVer) * sizeof (WCHAR));
        RegCloseKey(hKey);
        if ( ERROR_SUCCESS != r )
            return HRESULT_FROM_WIN32( r );
    }

    wsprintf(wcsSubKey, L"CLSID\\%ws", wcsClsId);
    r = RegCreateKey(HKEY_CLASSES_ROOT, wcsSubKey, &hKey);
    if ( ERROR_SUCCESS != r )
        return HRESULT_FROM_WIN32( r );
    r = RegSetValue(hKey, NULL, REG_SZ,
                pwszDescription, wcslen(pwszDescription) * sizeof (WCHAR));
    RegCloseKey(hKey);
    if ( ERROR_SUCCESS != r )
        return HRESULT_FROM_WIN32( r );

    wsprintf(wcsSubKey, L"CLSID\\%ws\\InProcServer32", wcsClsId);
    r = RegCreateKey(HKEY_CLASSES_ROOT, wcsSubKey, &hKey);
    if ( ERROR_SUCCESS != r )
        return HRESULT_FROM_WIN32( r );
    GetModuleFileName(hInst, wcsSubKey, MAX_PATH);
    r = RegSetValue(hKey, NULL, REG_SZ,
                wcsSubKey, wcslen(wcsSubKey) * sizeof (WCHAR));
    if ( ERROR_SUCCESS != r )
        return HRESULT_FROM_WIN32( r );
    wcscpy(wcsSubKey, L"Both");
    r = RegSetValueEx(hKey, L"ThreadingModel", NULL, REG_SZ,
                   (BYTE*)wcsSubKey, wcslen(wcsSubKey) * sizeof (WCHAR));
    RegCloseKey(hKey);
    if ( ERROR_SUCCESS != r )
        return HRESULT_FROM_WIN32( r );

    wsprintf(wcsSubKey, L"CLSID\\%ws\\ProgID", wcsClsId);
    r = RegCreateKey(HKEY_CLASSES_ROOT, wcsSubKey, &hKey);
    if ( ERROR_SUCCESS != r )
        return HRESULT_FROM_WIN32( r );
    r = RegSetValue(hKey, NULL, REG_SZ,
                pwszProgId, wcslen(pwszProgId) * sizeof (WCHAR));
    RegCloseKey(hKey);
    if ( ERROR_SUCCESS != r )
        return HRESULT_FROM_WIN32( r );

    //
    // Indicate the object is 'safely' initializable and scriptable
    //

    wsprintf(wcsSubKey, L"CLSID\\%ws\\Implemented Categories", wcsClsId);
    r = RegCreateKey(HKEY_CLASSES_ROOT, wcsSubKey, &hKey);
    if ( ERROR_SUCCESS != r )
        return HRESULT_FROM_WIN32( r );
    RegCloseKey(hKey);

    wsprintf(wcsSubKey, L"CLSID\\%ws\\Implemented Categories\\{7DD95801-9882-11CF-9FA9-00AA006C42C4}", wcsClsId);
    r = RegCreateKey(HKEY_CLASSES_ROOT, wcsSubKey, &hKey);
    if ( ERROR_SUCCESS != r )
        return HRESULT_FROM_WIN32( r );
    RegCloseKey(hKey);

    wsprintf(wcsSubKey, L"CLSID\\%ws\\Implemented Categories\\{7DD95802-9882-11CF-9FA9-00AA006C42C4}", wcsClsId);
    r = RegCreateKey(HKEY_CLASSES_ROOT, wcsSubKey, &hKey);
    if ( ERROR_SUCCESS != r )
        return HRESULT_FROM_WIN32( r );
    RegCloseKey(hKey);

    return S_OK;
}


//+---------------------------------------------------------------------------
//
//  Function:   _DllUnregisterServer - public
//
//  Synopsis:   Uninstalls a class registration for an inproc server
//
//  Arguments:  [pwszProgId] --      program ID (class name)
//              [clsid] --           Class ID of class
//
//  Returns:    SCODE - status of de-registration
//
//  History:    03 Jan 1997      Alanw    Added header
//
//----------------------------------------------------------------------------


STDAPI _DllUnregisterServer(LPWSTR pwszProgID, REFCLSID clsid)
{
    //
    // Ignore errors -- do a best effort to uninstall since we don't know
    // what shape the registry is in.
    //

    WCHAR wcsClsId[GUID_SIZE+1];

    StringFromGUID2(clsid, wcsClsId, sizeof(wcsClsId) / sizeof WCHAR);

    WCHAR wcsSubKey[256];

    wsprintf(wcsSubKey, L"%ws\\CLSID", pwszProgID);
    RegDeleteKey(HKEY_CLASSES_ROOT, wcsSubKey);

    wsprintf(wcsSubKey, L"%ws\\CurVer", pwszProgID);
    RegDeleteKey(HKEY_CLASSES_ROOT, wcsSubKey);

    RegDeleteKey(HKEY_CLASSES_ROOT, pwszProgID);

    wsprintf(wcsSubKey, L"CLSID\\%ws\\InProcServer32", wcsClsId);
    RegDeleteKey(HKEY_CLASSES_ROOT, wcsSubKey);

    wsprintf(wcsSubKey, L"CLSID\\%ws\\ProgID", wcsClsId);
    RegDeleteKey(HKEY_CLASSES_ROOT, wcsSubKey);

    wsprintf(wcsSubKey, L"CLSID\\%ws\\Implemented Categories\\{7DD95801-9882-11CF-9FA9-00AA006C42C4}", wcsClsId);
    RegDeleteKey(HKEY_CLASSES_ROOT, wcsSubKey);

    wsprintf(wcsSubKey, L"CLSID\\%ws\\Implemented Categories\\{7DD95802-9882-11CF-9FA9-00AA006C42C4}", wcsClsId);
    RegDeleteKey(HKEY_CLASSES_ROOT, wcsSubKey);

    wsprintf(wcsSubKey, L"CLSID\\%ws\\Implemented Categories", wcsClsId);
    RegDeleteKey(HKEY_CLASSES_ROOT, wcsSubKey);

    wsprintf(wcsSubKey, L"CLSID\\%ws", wcsClsId);
    RegDeleteKey(HKEY_CLASSES_ROOT, wcsSubKey);

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\web\html\scripts\qrybody1.inc ===
<%
    ' This is the detail portion for Title, Abstract, URL, Size, and
    ' Modification Date.

    ' If there is a title, display it, otherwise display the virtual path.
%>
    <p>
    <dt><%= NextRecordNumber%>.
        <%if VarType(RS("DocTitle")) = 1 or RS("DocTitle") = "" then%>
            <b><a href="<%= RS("vpath")%>"><%= RS("filename")%></a></b>
        <%else%>
            <b><a href="<%=RS("vpath")%>"><%= Server.HTMLEncode(RS("DocTitle"))%></a></b>
        <%end if%>
    <dd>
        <b><i>Abstract:  </I></b><%= Server.HTMLEncode(RS("characterization"))%>
        <br>
        <cite>
            <a href="<%=RS("vpath")%>">http://<%=Request("server_name")%><%=RS("vpath")%></a>
            <font size=-1> - <%if RS("size") = "" then%>(size and time unknown)<%else%>size <%=RS("size")%> bytes - <%=RS("write")%> GMT<%end if%></font>
        </cite>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\web\ixsso\utest\prolog.inc ===
<% Server.ScriptTimeout = 200 %>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\web\ixsso\utest\qrytail3.inc ===
</TABLE>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\web\ixsso\utest\qrytail2.inc ===
</PRE>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\web\ixsso\utest\qryhead3.inc ===
<!--  table heading for query form style 1  -->
<TABLE CELLPADDING=5 BORDER=0>
<TR>

<TD ALIGN=CENTER BGCOLOR="#800000">
<FONT STYLE="ARIAL NARROW" COLOR="#ffffff" SIZE=1>Record</FONT>
</TD>
<TD ALIGN=CENTER BGCOLOR="#800000">
<FONT STYLE="ARIAL NARROW" COLOR="#ffffff" SIZE=1>File name</FONT>
</TD>
<TD ALIGN=CENTER WIDTH=160 BGCOLOR="#800000">
<FONT STYLE="ARIAL NARROW" COLOR="#ffffff" SIZE=1>Path</FONT>
</TD>
<TD ALIGN=CENTER BGCOLOR="#800000">
<FONT STYLE="ARIAL NARROW" COLOR="#ffffff" SIZE=1>Size</FONT>
</TD>
<TD ALIGN=CENTER BGCOLOR="#800000">
<FONT STYLE="ARIAL NARROW" COLOR="#ffffff" SIZE=1>Write</FONT>
</TD>

</TR>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\web\ixsso\utest\qrytail1.inc ===
<!--  table end for query form style 3  -->
</dl>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\web\ixsso\utest\qryhead2.inc ===
<!--  table heading for query form style 1  -->
<PRE>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\web\ixsso\utest\qryhead1.inc ===
<!--  table heading for query form style 3  -->
<dl>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\web\ixsso\utest\srcform.inc ===
<FORM METHOD=POST ACTION="/ASPSamp/IXSTest/code.asp">
<INPUT TYPE=HIDDEN NAME="source" VALUE="<%=Request.ServerVariables("PATH_INFO")%>">
<INPUT TYPE=SUBMIT NAME="Action" VALUE="Show Script Code"></FORM>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\web\ixsso\utest\showqry2.inc ===
<FORM NAME="CiParams">
<INPUT TYPE=HIDDEN NAME="CiRestriction" VALUE="<%=Q.CiRestriction%>">
<INPUT TYPE=HIDDEN NAME="CiColumns" VALUE="<%=Q.CiColumns%>">
<INPUT TYPE=HIDDEN NAME="CiSort" VALUE="<%=Q.CiSort%>">

<INPUT TYPE=HIDDEN NAME="CiScope" VALUE="<%=Q.CiScope%>">
<INPUT TYPE=HIDDEN NAME="CiFlags" VALUE="<%=Q.CiFlags%>">
<INPUT TYPE=HIDDEN NAME="CiCatalog" VALUE="<%=Q.CiCatalog%>">
<INPUT TYPE=HIDDEN NAME="CiMachine" VALUE="<%=Q.CiMachine%>">

<INPUT TYPE=HIDDEN NAME="CiDeferNonIndexedTrimming" VALUE="<%Response.Write CStr(Q.CiDeferNonIndexedTrimming)%>">
<INPUT TYPE=HIDDEN NAME="CiForceUseCi" VALUE="<%Response.Write CStr(Q.CiForceUseCi)%>">
<INPUT TYPE=HIDDEN NAME="CiMaxRecordsInResultSet" VALUE="<%Response.Write CStr(Q.CiMaxRecordsInResultSet)%>">

<INPUT TYPE=BUTTON NAME="ShowQueryParams" VALUE="Show Query Parameters"></FORM>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\web\ixsso\utest\qrybody1.inc ===
<%
    ' This is the detail portion for Title, Abstract, URL, Size, and
    ' Modification Date.

    ' If there is a title, display it, otherwise display the virtual path.
%>
    <p>
    <dt>
        <%=NextRecordNumber %>.
        <%if RS("DocTitle") = "" then%>
            <b><a href="<%= RS("vpath")%>"><%=RS("filename")%></a></b>
        <%else%>
            <b><a href="<%=RS("vpath")%>"><%=RS("DocTitle")%></a></b>
        <%end if%>
    <dd>
        <b><i>Abstract:  </I></b><%=RS("characterization")%>
        <br>
        <cite>
            <a href="<%=RS("vpath")%>">http://<%=Request("server_name")%><%=RS("vpath")%></a>
            <font size=-1> - <%if RS("size") = "" then%>(size and time unknown)<%else%>size <%=RS("size")%> bytes - <%=RS("write")%> GMT<%end if%></font>
        </cite>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\xpr\notxpr.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       NotXpr.cxx
//
//  Contents:   Negation expression
//
//  Classes:    CNotXpr
//
//  History:    27-Nov-93 KyleP     Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "notxpr.hxx"

CNotXpr::~CNotXpr()
{
    delete _pxpr;
}

CXpr * CNotXpr::Clone()
{
    return( new CNotXpr( _pxpr->Clone() ) );
}

BOOL CNotXpr::IsMatch( CRetriever & obj )
{
    return( !_pxpr->IsMatch( obj ) );
}

BOOL CNotXpr::IsLeaf() const
{
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\xpr\parse.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2000.
//
//  File:       Parse.cxx
//
//  Contents:   Converts restrictions into expressions
//
//  Functions:  Parse
//
//  History:    15-Oct-91   KyleP    Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <parse.hxx>
#include <fa.hxx>

#include "notxpr.hxx"

//+---------------------------------------------------------------------------
//
//  Function:   Parse, public
//
//  Synopsis:   Convert a restriction into an expression
//
//  Arguments:  [prst]      -- Restriction to convert
//              [timeLimit] -- Execution time limit
//
//  Returns:    A pointer to the expression which will resolve [prst]
//
//  History:    15-Oct-91   KyleP       Created.
//              27-Nov-93   KyleP       Added RTNot
//
//----------------------------------------------------------------------------

CXpr * Parse( CRestriction const * prst, CTimeLimit& timeLimit )
{
    XXpr pxp;

    CNodeXpr * pnxpr;
    int cres;

    switch ( prst->Type() )
    {
    case RTNot:
    {
        CNotRestriction * pnRst = (CNotRestriction *)prst;

        XXpr pTemp( Parse( pnRst->GetChild(), timeLimit ) );

        pxp.Set( new CNotXpr( pTemp.Acquire() ) );

        break;
    }

    case RTAnd:
    case RTOr:
    {
        CNodeRestriction * pnRst = prst->CastToNode();
        CXpr::NodeType nt = (prst->Type() == RTAnd) ?
            CXpr::NTAnd : CXpr::NTOr;

        cres = pnRst->Count();
        pnxpr = new CNodeXpr( nt, cres );

        pxp.Set( pnxpr );

        vqDebugOut(( DEB_ITRACE,
                     "Parse: %s node, %d restrictions\n",
                     (prst->Type() == RTAnd) ? "AND" : "OR", cres ));

        for ( cres--; cres >= 0; cres-- )
        {
            pnxpr->AddChild( Parse( pnRst->GetChild(cres), timeLimit ) );
        }
        break;
    }

    case RTInternalProp:
    {
        CInternalPropertyRestriction * pRst =
            (CInternalPropertyRestriction *)prst;

#if CIDBG == 1
        vqDebugOut(( DEB_ITRACE, "Parse: PROPERTY, prop = %d, op = %ld, value = ",
                     pRst->Pid(),
                     pRst->Relation() ));

        pRst->Value().DisplayVariant(DEB_ITRACE | DEB_NOCOMPNAME, 0);
        vqDebugOut(( DEB_ITRACE | DEB_NOCOMPNAME, "\n" ));
#endif // DBG == 1

        if ( pRst->Relation() == PRRE )
            pxp.Set( new CRegXpr( pRst, timeLimit ) );
        else
        {
            pxp.Set( new CXprPropertyRelation( pRst->Pid(),
                                                pRst->Relation(),
                                                pRst->Value(),
                                                pRst->AcquireContentHelper() ) );
        }
        break;
    }

    default:
        vqDebugOut(( DEB_ERROR, "Unhandled expression type %d\n", prst->Type() ));
        //Win4Assert( !"Unhandled expression type" );
        THROW( CException( QUERY_E_INVALIDRESTRICTION ) );
        break;
    }


    return( pxp.Acquire() );
}

//+-------------------------------------------------------------------------
//
//  Function:   MoveFullyIndexableNode, public
//
//  Effects:    Splits out any components of [pnrSource] which are
//              *completely* resolved by content index.  In practice,
//              this is boolean trees of CONTENT nodes.
//
//  Arguments:  [pnrSource]          -- Original restriction
//              [pnrFullyResolvable] -- Fully resolvable portions of
//                                      [pnrSource]
//
//  Modifies:   Nodes may be removed from [pnrSource]
//
//  History:    10-Feb-92 KyleP     Created
//
//--------------------------------------------------------------------------

void MoveFullyIndexable( CNodeRestriction & pnrSource,
                           CNodeRestriction & pnrFullyResolvable )
{
    for ( int i = pnrSource.Count()-1; i >= 0; i-- )
    {
        if ( IsFullyIndexable( pnrSource.GetChild(i) ) )
        {
            unsigned pos;

            pnrFullyResolvable.AddChild( pnrSource.RemoveChild(i), pos );
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   IsFullyIndexable, public
//
//  Synopsis:   Determines of node (or tree) is fully resolved by content
//              index.
//
//  Arguments:  [pRst] -- Restriction to test
//
//  Returns:    TRUE if node is fully indexable
//
//  History:    10-Feb-93 KyleP     Created
//
//--------------------------------------------------------------------------

BOOL IsFullyIndexable( CRestriction * pRst )
{
    switch ( pRst->Type() )
    {
    case RTContent:
    case RTWord:
    case RTSynonym:
    case RTPhrase:
    case RTRange:
    case RTProperty:
    case RTNone:         // null-node from noise word in vector query
        return( TRUE );

    case RTAnd:
    case RTOr:
    case RTProximity:
    case RTVector:
    {
        CNodeRestriction * pnRst = pRst->CastToNode();

        for( int i = pnRst->Count()-1; i >= 0; i-- )
        {
            if ( !IsFullyIndexable( pnRst->GetChild(i) ) )
                return FALSE;
        }

        return( TRUE );
    }

    case RTNot:
    {
        CNotRestriction * pnRst = (CNotRestriction *)pRst;

        return( IsFullyIndexable( pnRst->GetChild() ) );
        break;
    }

    default:
        vqDebugOut(( DEB_ITRACE,
                     "Restriction type %d is not fully indexable\n",
                     pRst->Type() ));

        return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\xpr\fa.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2001.
//
//  File:       FA.cxx
//
//  Contents:   Non-deterministic finite automata
//
//  Classes:    CNFA
//
//  History:    01-20-92  KyleP     Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#pragma optimize( "", off )

#include <fa.hxx>
#include <strategy.hxx>
#include <codepage.hxx>

#include "stateset.hxx"

//+-------------------------------------------------------------------------
//
//  Member:     CFA::CFA, public
//
//  Synopsis:   Copy constructor
//
//  History:    13-Jul-95 KyleP     Created
//
//--------------------------------------------------------------------------

CFA::CFA( CFA const & src )
        : _cTotal( src._cTotal ),
          _ppState( 0 )
{
    _ppState = new CFAState * [ _cTotal ];

    unsigned i = 0;

    TRY
    {
        for ( ; i < _cTotal; i++ )
        {
            if ( 0 == src._ppState[i] )
                _ppState[i] = 0;
            else
                _ppState[i] = new CFAState( *src._ppState[i] );
        }
    }
    CATCH( CException, e )
    {
        for ( ;i > 0; i-- )
            delete _ppState[i-1];

        delete _ppState;

        RETHROW();
    }
    END_CATCH
}

//+-------------------------------------------------------------------------
//
//  Member:     CFA::~CFA, protected
//
//  Synopsis:   Frees automata.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

CFA::~CFA()
{
    if( _ppState )
    {
        for ( unsigned i = 0; i < _cTotal; i++ )
        {
            delete _ppState[i];
        }

        delete _ppState;
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CFA::Add, protected
//
//  Synopsis:   Adds new state to automata.
//
//  Arguments:  [pState] -- New state.  State number is member data.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

void CFA::Add( CFAState * pState )
{
    if ( pState->StateNumber() > _cTotal )
    {
        for( unsigned newTotal = (_cTotal) ? _cTotal * 2 : 1;
             pState->StateNumber() > newTotal;
             newTotal *= 2 );

        CFAState ** oldState = _ppState;

        _ppState = new CFAState * [ newTotal ];

        memcpy( _ppState, oldState,
                _cTotal * sizeof( CFAState * ) );
        memset( _ppState + _cTotal,
                0,
                (newTotal - _cTotal) * sizeof( CFAState * ) );

        _cTotal = newTotal;
    }

    _ppState[pState->StateNumber() - 1] = pState;
}

//+-------------------------------------------------------------------------
//
//  Member:     CFA::Get, protected
//
//  Arguments:  [iState] -- State to fetch.
//
//  Returns:    State [iState].
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

CFAState * CFA::Get( unsigned iState )
{
    vqAssert( iState <= _cTotal );
{
#   if (CIDBG == 1)
        if ( _ppState[ iState - 1 ]->StateNumber() != iState )
            vqDebugOut(( DEB_ERROR, "CFA::Get() -- Error\n" ));
#   endif // (CIDBG == 1)

    return( _ppState[ iState - 1 ] );
}
}

//+-------------------------------------------------------------------------
//
//  Member:     CNFA::CNFA, public
//
//  Synopsis:   Converts regular expression string to NFA.
//
//  Arguments:  [pwcs]      -- Regular expression.
//              [fCaseSens] -- TRUE if case sensitive search.
//
//  History:    20-Jan-92 Kyleap    Created
//
//--------------------------------------------------------------------------

CNFA::CNFA( WCHAR const * pwcs, BOOLEAN fCaseSens )
        : _iNextState( 1 ),
          _iStart( 0 ),
          _chars( fCaseSens )
{
    unsigned iEnd;

    //
    // _aState initially contains room for 2 * #chars in regex.  According
    // to the Dragon Book pg. 121 this is guaranteed to be sufficient space.
    // Of course the dragon book doesn't completely take DOS or CMS into
    // account. For DOS, we need to treat beginning (and end) of line as
    // 'characters' in the string. For CMS, I agreed to support the
    // {m,n} construct, which clearly violates this rule.
    //

    if ( 0 == pwcs )
    {
        vqDebugOut(( DEB_ERROR, "ERROR: regex string value of 0 " ));

        THROW( CException( QUERY_E_INVALIDRESTRICTION ) );
    }

    unsigned cState = wcslen( pwcs ) * 2 + 2*2;  // 2*2 for beginning & end of line
    _aState.Init( cState );

    for ( unsigned i = 1 ; i <= _aState.Count(); i++ )
        Get(i)->Init(i);

    FindCharClasses( pwcs );
    Parse( pwcs, &_iStart, &iEnd );

    Get( iEnd )->MakeFinal();
}

//+-------------------------------------------------------------------------
//
//  Member:     CNFA::CNFA, public
//
//  Synopsis:   Copy constructor
//
//  Arguments:  [src] -- Source
//
//  History:    13-Jul-95 Kylep    Created
//
//--------------------------------------------------------------------------

CNFA::CNFA( CNFA const & src )
        : _iNextState( src.NumStates() ),
          _iStart( src._iStart ),
          _chars( src._chars ),
          _aState( src._aState.Count() )
{
    for ( unsigned i = 0; i < _aState.Count(); i++ )
        _aState[i] = src._aState[i];
}

//+-------------------------------------------------------------------------
//
//  Member:     CNFA::~CNFA, public
//
//  Synopsis:   Free state table.
//
//  History:    13-Oct-92 KyleP     Created
//
//--------------------------------------------------------------------------

CNFA::~CNFA()
{
}

//+-------------------------------------------------------------------------
//
//  Member:     CNFA::EpsClosure, public
//
//  Synopsis:   Computes the epsilon closure for state [StateNum]
//
//  Effects:    States in the epsilon closure of state [StateNum]
//              are added to the state set [ssOut].
//
//  Arguments:  [StateNum] -- Initial state.
//              [ssOut]    -- Output state set.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

void CNFA::EpsClosure( unsigned StateNum, CStateSet & ssOut )
{
    CStateSet ssTraversed;

    ssOut.Add( StateNum );

    BOOLEAN changed = TRUE;

    while ( changed )
    {
        changed = FALSE;

        for ( unsigned i = ssOut.Count(); i > 0; i-- )
        {
            if ( !ssTraversed.IsMember( ssOut.State( i ) ) )
            {
                ssTraversed.Add( ssOut.State( i ) );

                Get( ssOut.State( i ) )->Move( ssOut, symEpsilon );

                changed = TRUE;
            }
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CNFA::EpsClosure, public
//
//  Synopsis:   Computes the epsilon closure for state set [ssIn]
//
//  Effects:    States in the epsilon closure of [ssIn]
//              are added to the state set [ssOut].
//
//  Arguments:  [ssIn]  -- Initial state set.
//              [ssOut] -- Output state set.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

void CNFA::EpsClosure( CStateSet & ssIn, CStateSet & ssOut )
{
    for ( unsigned i = ssIn.Count(); i > 0; i-- )
    {
        EpsClosure( ssIn.State( i ), ssOut );
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CDFA::IsFinal, public
//
//  Arguments:  [ss] -- State set
//
//  Returns:    TRUE if some state in [ss] is final.
//
//  History:    20-Jan-92 Kyleap    Created
//
//--------------------------------------------------------------------------

BOOLEAN CNFA::IsFinal( CStateSet & ss )
{
    BOOLEAN fFinal = FALSE;

    for ( unsigned i = ss.Count(); i > 0 && !fFinal; i-- )
    {
        fFinal = (BYTE)(Get( ss.State( i ) )->IsFinal());
    }

    return( fFinal );
}

//+-------------------------------------------------------------------------
//
//  Member:     CNFA::Move, public
//
//  Effects:    Performs a non-deterministic move from every state
//              in [ssIn] on [symbol].  The new state set is in
//              [ssOut].
//
//  Arguments:  [ssIn]   -- Initial state set.
//              [ssOut]  -- Final state set.
//              [symbol] -- Transition symbol.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

void CNFA::Move( CStateSet & ssIn, CStateSet & ssOut, unsigned symbol )
{
    for ( unsigned i = ssIn.Count(); i > 0; i-- )
    {
        Get( ssIn.State( i ) )->Move( ssOut, symbol );
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CNFA::FindCharClasses, private
//
//  Effects:    Partitions the UniCode character space (2^16 characters)
//              into equivalence classes such that all characters in
//              a given class will have identical transitions in the NFA.
//
//  Arguments:  [wcs] -- Original regular expression string.
//
//  History:    20-Jan-92 KyleP     Created
//
//  Notes:      If case sensitivity is turned off, two ranges will be
//              added for characters with upper/lower case.  Even though
//              both ranges react identically the mapping algorithm can
//              only deal with contiguous ranges of characters.
//
//--------------------------------------------------------------------------

void CNFA::FindCharClasses( WCHAR const * wcs )
{
    //
    // Scan the regex looking for characters with (potentially)
    // different transitions.
    //

    while ( *wcs )
    {
        switch ( *wcs )
        {
        case wcAnySingle:
        case wcAnyMultiple:
        case wcDOSDot:
            break;

        case wcEscape:
        {
            wcs++;

            switch ( *wcs )
            {
            case 0:
                vqDebugOut(( DEB_WARN, "Invalid regex (%wc at end of string\n", wcEscape ));
                THROW( CException( QUERY_E_INVALIDRESTRICTION ) );
                break;

            case wcAnySingle:
            case wcRepeatZero:
            case wcRepeatOne:
            case wcOr:
            case wcBeginParen:
            case wcEndParen:
                break;

            case wcBeginRepeat:
                for ( wcs++; *wcs; wcs++ )
                {
                    if ( *wcs == wcEscape && *(wcs+1) == wcEndRepeat )
                    {
                        wcs++;
                        break;
                    }
                }
                break;

            case wcBeginRange:
                wcs++;

                //
                // Check the special cases of ^ and ]
                //

                if ( *wcs == wcInvertRange )
                    wcs++;

                if ( *wcs == wcEndRange )
                {
                    _chars.AddRange( *wcs, *wcs );
                    wcs++;
                }

                for ( ; *wcs && *wcs != wcEndRange; wcs++ )
                {
                    if ( *(wcs + 1) == wcRangeSep )
                    {
                        _chars.AddRange( *wcs, *(wcs+2) );
                    }
                    else
                    {
                        _chars.AddRange( *wcs, *wcs );
                    }
                }

                if ( *wcs != wcEndRange )
                {
                    vqDebugOut(( DEB_WARN, "Invalid regex.  Missing %wc\n", wcEndRange ));
                    THROW( CException( QUERY_E_INVALIDRESTRICTION ) );
                }

                break;

            default:
                _chars.AddRange( *wcs, *wcs );
                break;
            }

            break;
        }

        default:
            _chars.AddRange( *wcs, *wcs );
            break;
        }

        wcs++;
    }

    _chars.Prepare();
}

WCHAR * CNFA::_wcsNull = (WCHAR*)"";

//+-------------------------------------------------------------------------
//
//  Member:     CNFA::Parse, private
//
//  Synopsis:   Creates a NFA from [wcs]
//
//  Effects:    Parses [wcs] until end of string or character wcHalt is
//              encountered.  On exit, [iStart] and [iEnd] contain the
//              starting and ending states of the NFA, respectively.
//              [pwcsEnd] points to the last character of [wcs] that was
//              parsed.
//
//  Arguments:  [wcs]     -- Regular expression.
//              [iStart]  -- Starting state of NFA.
//              [iEnd]    -- Ending state of NFA
//              [pwcsEnd] -- Last character of [wcs] that was parsed.
//              [wcHalt]  -- Stop parsing if this character encountered.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

void CNFA::Parse( WCHAR const *   wcs,
                  unsigned *      iStart,
                  unsigned *      iEnd,
                  WCHAR const * * pwcsEnd,
                  WCHAR           wcHalt )
{
    unsigned iCurrent;
    unsigned iNext;

    unsigned iLocalStart;               // Used for */+/? repositioning
    BOOLEAN fRepeat = FALSE;            // Used for +
    BOOLEAN fTopLevel = (*iStart == 0); // TRUE if at top level;

    *iEnd = 0;

    //
    // Get a starting state.  *iStart == 0 implies this is the 'top-level'
    // parse of the regular expression (e.g. we're not parsing a
    // parenthesized subexpression.
    //

    if ( fTopLevel )
    {
        iCurrent = _iNextState;
        *iStart = _iNextState++;
        iLocalStart = 0;

        //
        // non-EGREP (DOS) regex match entire string.
        //

        if ( *wcs != wcAnyMultiple )
        {
            iNext = _iNextState;
            Get( iCurrent )->AddTransition( symBeginLine, _iNextState );
            _iNextState++;
            iCurrent = iNext;
        }
        else
        {
            //
            // Add a 'special' transition on the very first state to
            // eat up characters until we actually jump into the
            // regular expresion.
            //

            Get( iCurrent )->AddTransition( symAny, Get( iCurrent )->StateNumber() );
        }
    }
    else
    {
        iCurrent = *iStart;
        iLocalStart = *iStart;
    }

    unsigned iOrStart = Get( iCurrent )->StateNumber();

    //
    // Original start of string.
    //

    WCHAR const * wcsBeginning = wcs;

    //
    // wcsLocalStart tracks the piece of string to be repeated for wcZeroOrOne, etc.
    //

    WCHAR const * wcsLocalStart = wcs;

    //
    // Parse the regular expression until there is no more or a
    // termination character is hit.
    //

    for ( ; *wcs && *wcs != wcHalt; wcs++ )
    {
        switch ( *wcs )
        {
        case wcAnySingle:
            iNext = _iNextState;
            Get( iCurrent )->AddTransition( symAny, _iNextState );
            iLocalStart = Get( iCurrent )->StateNumber();
            wcsLocalStart = wcs;
            _iNextState++;
            iCurrent = iNext;
            break;

        case wcAnyMultiple:
            //
            // Any single
            //

            iNext = _iNextState;
            Get( iCurrent )->AddTransition( symAny, _iNextState );
            iLocalStart = Get( iCurrent )->StateNumber();
            wcsLocalStart = wcs;
            _iNextState++;
            iCurrent = iNext;

            //
            // Repeat zero or more
            //

            Get( iLocalStart )->AddTransition( symEpsilon,
                                               Get( iCurrent )->StateNumber() );
            Get( iCurrent )->AddTransition( symEpsilon, iLocalStart );
            break;

        case wcEscape:
        {
            wcs++;

            switch ( *wcs )
            {
            case wcBeginParen:
            {
                unsigned iLocalEnd;

                iLocalStart = Get( iCurrent )->StateNumber();
                wcsLocalStart = wcs - 1;
                wcs++;                      // Eat '('.
                Parse( wcs, &iLocalStart, &iLocalEnd, &wcs, wcEndParen );
                wcs--;                      // Provide character for loop to eat.
                iCurrent = iLocalEnd;

                break;
            }

            case wcEndParen:
                //
                // Taken care of at outer level.  Just backup so we hit the end.
                //

                wcs--;
                break;

            case wcBeginRepeat:
            {
                if ( wcHalt == wcBeginRepeat )
                {
                    //
                    // Taken care of at outer level.  Just backup so we hit the end.
                    //

                    wcs--;
                }
                else
                {
                    //
                    // Setup: Bounds of repeated regex
                    //

                    WCHAR const * wcsStartRepeat = wcsLocalStart;
                    WCHAR const * wcsEndRepeat = wcs + 1;

                    //
                    // Setup: Repeat parameters.
                    //

                    unsigned cRepeat1, cRepeat2;
                    wcs++;

                    ParseRepeat( wcs, cRepeat1, cRepeat2 );

                    unsigned iLocalEnd;

                    //
                    // The minimum set has no epsilon transitions.
                    //

                    if ( cRepeat1 > 1 )
                    {
                        iLocalStart = Get( iCurrent )->StateNumber();
                        iLocalEnd = iLocalStart;

                        for ( unsigned i = 1; i < cRepeat1; i++ )
                        {
                            WCHAR const * wcsEnd;

                            iLocalStart = iLocalEnd;
                            iLocalEnd = 0;  // Must be zero!

                            Parse( wcsLocalStart, &iLocalStart, &iLocalEnd, &wcsEnd, wcBeginRepeat );

                            if ( wcsEnd != wcsEndRepeat )
                            {
                                vqDebugOut(( DEB_ERROR, "Invalid regex: Nested repeats?\n" ));
                                THROW( CException( QUERY_E_INVALIDRESTRICTION ) );
                            }
                        }
                    }
                    else
                        iLocalEnd = Get( iCurrent )->StateNumber();

                    if ( cRepeat1 == cRepeat2 )
                    {
                        vqDebugOut(( DEB_REGEX, "REPEAT: Exactly %u times\n", cRepeat1 ));
                    }
                    else if ( cRepeat2 == 0 )
                    {
                        vqDebugOut(( DEB_REGEX, "REPEAT: At least %u times\n", cRepeat1 ));

                        Get( iLocalEnd )->AddTransition( symEpsilon, iLocalStart );
                    }
                    else if ( cRepeat2 > cRepeat1 )
                    {
                        for ( unsigned i = cRepeat1; i < cRepeat2; i++ )
                        {
                            WCHAR const * wcsEnd;

                            iLocalStart = iLocalEnd;
                            iLocalEnd = 0;  // Must be zero!

                            Parse( wcsLocalStart, &iLocalStart, &iLocalEnd, &wcsEnd, wcBeginRepeat );
                            Get( iLocalStart )->AddTransition( symEpsilon, iLocalEnd );

                            if ( wcsEnd != wcsEndRepeat )
                            {
                                vqDebugOut(( DEB_ERROR, "Invalid regex: Nested repeats?\n" ));
                                THROW( CException( QUERY_E_INVALIDRESTRICTION ) );
                            }
                        }
                    }
                    else
                    {
                        vqDebugOut(( DEB_ERROR, "Invalid regex: End repeat count %d < start %d\n",
                                     cRepeat2, cRepeat1 ));
                        THROW( CException( QUERY_E_INVALIDRESTRICTION ) );
                    }

                    iCurrent = iLocalEnd;
                    iLocalStart = 0;
                    wcsLocalStart = _wcsNull;
                }
                break;
            }

            case wcOr:
                if ( *iEnd == 0 )
                {
                    //
                    // First part of OR clause.
                    //

                    if ( fTopLevel )
                    {
                        iNext = _iNextState;
                        Get( iCurrent )->AddTransition( symEndLine, _iNextState );
                        _iNextState++;
                        iCurrent = iNext;
                    }

                    *iEnd = Get( iCurrent )->StateNumber();
                }
                else
                {
                    //
                    // Subsequent OR clause.  Epsilon link to end
                    //

                    Get( iCurrent )->AddTransition( symEpsilon, *iEnd );
                }
                iCurrent = iOrStart;
                wcsLocalStart = _wcsNull;
                iLocalStart = 0;
                break;

            case wcBeginRange:
            {
                BOOLEAN fReverse = FALSE;

                vqDebugOut(( DEB_REGEX, "RANGE\n" ));
                wcsLocalStart = wcs-1;
                iNext = _iNextState;
                wcs++;                      // Eat '['.  ']' eaten by loop.

                //
                // Check the special cases of ^ and ]
                //

                if ( *wcs == wcInvertRange )
                {
                    wcs++;

                    fReverse = TRUE;

                    //
                    // Add all transitions, they will be removed later.
                    //

                    for ( unsigned uiNext = _chars.TranslateRange( 1,
                                                               wcLastValidChar );
                          uiNext != 0;
                          uiNext = _chars.TranslateRange( 0, wcLastValidChar ) )
                    {
                        Get( iCurrent )->AddTransition( uiNext,
                                                  _iNextState );
                    }

                }

                if ( *wcs == wcEndRange )
                {
                    if ( fReverse )
                    {
                        Get( iCurrent )->RemoveTransition( _chars.Translate( *wcs++ ),
                                                     _iNextState );
                    }
                    else
                    {
                        Get( iCurrent )->AddTransition( _chars.Translate( *wcs++ ),
                                                  _iNextState );
                    }
                }

                for ( ; *wcs && *wcs != wcEndRange; wcs++ )
                {
                    if ( *(wcs + 1) == wcRangeSep )
                    {
                        vqDebugOut(( DEB_REGEX,
                                     "Range %u to %u\n", *wcs, *(wcs+2) ));

                        for ( unsigned uiNext = _chars.TranslateRange( *wcs,
                                                                   *(wcs+2) );
                              uiNext != 0;
                              uiNext = _chars.TranslateRange( 0, *(wcs+2) ) )
                        {
                            if ( fReverse )
                            {
                                Get( iCurrent )->RemoveTransition( uiNext,
                                                                   _iNextState );
                            }
                            else
                            {
                                Get( iCurrent )->AddTransition( uiNext,
                                                                _iNextState );
                            }
                        }

                        wcs += 2;
                    }
                    else
                    {
                        vqDebugOut(( DEB_REGEX, "Singleton = %u\n", *wcs ));

                        if ( fReverse )
                        {
                            Get( iCurrent )->RemoveTransition(
                                    _chars.Translate( *wcs ),
                                    _iNextState );
                        }
                        else
                        {
                            Get( iCurrent )->AddTransition(
                                    _chars.Translate( *wcs ),
                                    _iNextState );
                        }
                    }
                }

                if ( *wcs != wcEndRange )
                {
                    vqDebugOut(( DEB_WARN, "Invalid regex.  Missing %wc\n", wcEndRange ));
                    THROW( CException( QUERY_E_INVALIDRESTRICTION ) );
                }

                iLocalStart = Get( iCurrent )->StateNumber();
                _iNextState++;
                iCurrent = iNext;
                break;
            }

            case wcRepeatOne:
                if ( iLocalStart == 0 )
                {
                    vqDebugOut(( DEB_ERROR, "Invalid regex. Nothing to repeat\n" ));
                    THROW( CException( QUERY_E_INVALIDRESTRICTION ) );
                }

                Get( iCurrent )->AddTransition( symEpsilon, iLocalStart );
                iNext = _iNextState;

                Get( iCurrent )->AddTransition( symEpsilon, _iNextState );

                wcsLocalStart = wcs - 1;
                _iNextState++;
                iCurrent = iNext;
                break;

            case wcRepeatZero:
                if ( iLocalStart == 0 )
                {
                    vqDebugOut(( DEB_ERROR, "Invalid regex. Nothing to repeat.\n" ));
                    THROW( CException( QUERY_E_INVALIDRESTRICTION ) );
                }
                Get( iLocalStart )->AddTransition( symEpsilon,
                                                   Get( iCurrent )->StateNumber() );
                Get( iCurrent )->AddTransition( symEpsilon, iLocalStart );
                
                iNext = _iNextState;

                Get( iCurrent )->AddTransition( symEpsilon, _iNextState );

                wcsLocalStart = wcs - 1;
                _iNextState++;
                iCurrent = iNext;
                break;

            case wcRepeatZeroOrOne:
            {
                if ( iLocalStart == 0 )
                {
                    vqDebugOut(( DEB_ERROR, "Invalid regex.  Nothing to repeat.\n" ));
                    THROW( CException( QUERY_E_INVALIDRESTRICTION ) );
                }
                Get( iLocalStart )->AddTransition( symEpsilon,
                                                   Get( iCurrent )->StateNumber() );
                break;
            }

            default:
                iNext = _iNextState;

                Get( iCurrent )->AddTransition( _chars.Translate( *wcs ),
                                          _iNextState );

                iLocalStart = Get( iCurrent )->StateNumber();
                wcsLocalStart = wcs - 1;
                _iNextState++;
                iCurrent = iNext;
                break;
            }

            break;  // switch for wcEscape
        }

        default:
            iNext = _iNextState;

            Get( iCurrent )->AddTransition( _chars.Translate( *wcs ),
                                      _iNextState );

            //
            // In non-EGREP (DOS) syntax dot '.' is funny.  It will match
            // a dot, but if you're at the end of string it will also match
            // end.  So *.txt will look for strings with zero or more
            // characters followed by '.txt' but *. will find any names
            // without an extension and with no trailing dot.
            //

            if ( *wcs == wcDOSDot )
            {
                Get( iCurrent )->AddTransition( symEndLine, _iNextState );
            }

            iLocalStart = Get( iCurrent )->StateNumber();
            wcsLocalStart = wcs;
            _iNextState++;
            iCurrent = iNext;
            break;
        }
    }

    //
    // non-EGREP (DOS) regex match entire string.
    //

    if ( wcHalt == 0 &&
         ( ( wcsBeginning+1 <= wcs && *(wcs-1) != wcAnyMultiple ) ||
           ( wcsBeginning+2 <= wcs && *(wcs-2) == wcEscape ) ) )
    {
        iNext = _iNextState;
        Get( iCurrent )->AddTransition( symEndLine, _iNextState );
        iLocalStart = 0;
        wcsLocalStart = _wcsNull;
        _iNextState++;
        iCurrent = iNext;
    }

    //
    // If we haven't had an OR clause yet, then set iEnd
    //

    if ( *iEnd == 0 )
    {
        //
        // First part of OR clause.
        //

        *iEnd = Get( iCurrent )->StateNumber();
    }
    else
    {
        //
        // Subsequent OR clause.  Epsilon link to end
        //

        Get( iCurrent )->AddTransition( symEpsilon, *iEnd );
    }

    if ( pwcsEnd )
    {
        *pwcsEnd = wcs + 1;             // Eat halt character.
    }

    if( *wcs != wcHalt )
    {
        vqDebugOut(( DEB_WARN, "Invalid regex.  Missing %wc\n", wcHalt ));
        THROW( CException( QUERY_E_INVALIDRESTRICTION ) );
    }
}

void CNFA::ParseRepeat( WCHAR const * & wcs, unsigned & cRepeat1, unsigned & cRepeat2 )
{
    cRepeat1 = 0;
    cRepeat2 = 0;

    for ( ; *wcs && isdigit(*wcs); wcs++ )
    {
        cRepeat1 *= 10;
        cRepeat1 += *wcs - '0';
    }

    if ( cRepeat1 == 0 || cRepeat1 > 255 )
    {
        vqDebugOut(( DEB_ERROR, "Invalid regex: Repeat count %d out of bounds.\n", cRepeat1 ));
        THROW( CException( QUERY_E_INVALIDRESTRICTION ) );
    }

    if ( *wcs == ',' )
    {
        wcs++;

        if ( *wcs == wcEscape && *(wcs+1) == wcEndRepeat )
        {
            wcs++;
        }
        else
        {
            for ( ; *wcs && isdigit(*wcs); wcs++ )
            {
                cRepeat2 *= 10;
                cRepeat2 += *wcs - '0';
            }

            if ( cRepeat2 == 0 || cRepeat2 > 255 )
            {
                vqDebugOut(( DEB_ERROR, "Invalid regex: Repeat count %d too big.\n", cRepeat2 ));
                THROW( CException( QUERY_E_INVALIDRESTRICTION ) );
            }

            if ( *wcs != wcEscape || *(wcs+1) != wcEndRepeat )
            {
                vqDebugOut(( DEB_ERROR, "Invalid regex: No end to repeat specification.\n" ));
                THROW( CException( QUERY_E_INVALIDRESTRICTION ) );
            }
            else
            {
                wcs++;
            }
        }
    }
    else if ( *wcs == wcEscape && *(wcs+1) == wcEndRepeat )
    {
        wcs++;
        cRepeat2 = cRepeat1;
    }
    else
    {
        vqDebugOut(( DEB_ERROR, "Invalid regex: No end to repeat specification.\n" ));
        THROW( CException( QUERY_E_INVALIDRESTRICTION ) );
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CDFA::CDFA, public
//
//  Synopsis:   Constructs a DFA from a NFA.
//
//  Arguments:  [pwcs]      -- Regular expression (passed to NFA)
//              [timeLimit] -- Execution time limit
//              [fCaseSens] -- TRUE if case-sensitive search
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

CDFA::CDFA( WCHAR const * pwcs, CTimeLimit & timeLimit, BOOLEAN fCaseSens )
        : _nfa( pwcs, fCaseSens ),
          _xs( _nfa.NumStates() ),
          _cState( _nfa.NumStates() ),
          _timeLimit( timeLimit )
{
    CommonCtor();
}

//+-------------------------------------------------------------------------
//
//  Member:     CDFA::CDFA, public
//
//  Synopsis:   Copy constructor
//
//  Arguments:  [pwcs]      -- Regular expression (passed to NFA)
//              [fCaseSens] -- TRUE if case-sensitive search
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

CDFA::CDFA( CDFA const & src )
        : _nfa( src._nfa ),
          _xs( src._nfa.NumStates() ),
          _cState( src._nfa.NumStates() ),
          _timeLimit( (CTimeLimit &) src._timeLimit )
{
    CommonCtor();
}

//+-------------------------------------------------------------------------
//
//  Member:     CDFA::CommonCtor, private
//
//  Synopsis:   Code common to both constructors.
//
//  History:    13-Jul-95 KyleP     Snarfed from constructor
//
//--------------------------------------------------------------------------

void CDFA::CommonCtor()
{
    //
    // Add initial state.
    //

    CStateSet ss;

    _nfa.EpsClosure( _nfa.StartState(), ss );

    _stateStart = _xs.XlatToOne( ss );

    //
    // Intialize translation table.
    //

    int cEntries = (_cState + 1) * ( _nfa.Translate().NumClasses() + 1 );

    _xStateTrans.Init( cEntries );
    _xStateFinal.Init( _cState + 1 );

    Win4Assert( stateUncomputed == 0xFFFFFFFF );
    memset( _xStateTrans.GetPointer(), 0xFF, cEntries * sizeof( unsigned ) );
    RtlZeroMemory( _xStateFinal.GetPointer(), (_cState + 1) * sizeof( BOOLEAN ) );

    for ( int i = _cState; i >= 0; i-- )
    {
        AddTransition( i, 0, stateUndefined );
    }

    Add( _stateStart, _nfa.IsFinal( ss ) );

#   if (CIDBG == 1)

        vqDebugOut(( DEB_REGEX, "Character translation:\n" ));
        _nfa.Translate().Display();

        vqDebugOut(( DEB_REGEX, "NFA:\n" ));
        _nfa.Display();

        vqDebugOut(( DEB_REGEX, "DFA state %u = NFA states ", _stateStart ));
        ss.Display();
        vqDebugOut(( DEB_REGEX | DEB_NOCOMPNAME, "\n" ));
        vqDebugOut(( DEB_REGEX, "DFA start state = %u\n", _stateStart ));

#   endif // (CIDBG == 1)

}

//+-------------------------------------------------------------------------
//
//  Member:     CDFA::~CDFA, public
//
//  Synopsis:   Clean up DFA.  Free state tables.
//
//  History:    20-Jun-92 KyleP     Created
//
//--------------------------------------------------------------------------

CDFA::~CDFA()
{
}

//+-------------------------------------------------------------------------
//
//  Member:     CDFA::Recognize, public
//
//  Arguments:  [wcs] -- Input string.
//
//  Returns:    TRUE if [wcs] is matched by the regular expression.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

BOOLEAN CDFA::Recognize( WCHAR const * wcs )
{
#   if CIDBG == 1
        ValidateStateTransitions();
#   endif // CIDBG == 1

    unsigned CurrentState = _stateStart;
    unsigned LastState    = CurrentState;
    BOOLEAN fFinal        = IsFinal( CurrentState );
    WCHAR wcCurrent       = symBeginLine;

    while ( !fFinal )
    {
        unsigned NextState;

        {
            CReadAccess lock( _rwa );

            //
            // Casting is to guarantee this method doesn't modify anything (e.g. read lock ok).
            //
            #if CIDBG == 1
              NextState = ((CDFA const *)this)->Move( CurrentState, wcCurrent );
            #else
              NextState = Move( CurrentState, wcCurrent );
            #endif
        }

        vqDebugOut(( DEB_REGEX,
                     "DFA move[ %u, %u ] = %u\n",
                     CurrentState, wcCurrent, NextState ));

        if ( stateUncomputed == NextState )
        {
            CWriteAccess lock( _rwa );

            //
            // Did someone else get here first?
            //

            NextState = Move( CurrentState, wcCurrent );

            if ( stateUncomputed != NextState )
                continue;

            //
            // Build the new state
            //

            CStateSet ssCurrent;
            CStateSet ssNew;
            CStateSet ssClosed;

            _xs.XlatToMany( CurrentState, ssCurrent );

#           if (CIDBG == 1)
                vqDebugOut(( DEB_REGEX,
                             "DFA state %u = NFA states ", CurrentState ));
                ssCurrent.Display();
                if ( _nfa.IsFinal( ssCurrent ) )
                {
                    vqDebugOut(( DEB_REGEX | DEB_NOCOMPNAME, " FINAL" ));
                }
                vqDebugOut(( DEB_REGEX | DEB_NOCOMPNAME, "\n" ));
#           endif // (CIDBG == 1)

            _nfa.Move( ssCurrent, ssNew, wcCurrent );

            if ( ssNew.Count() == 0 )
            {
                NextState = stateUndefined;
                AddTransition( CurrentState, wcCurrent, NextState );
                vqDebugOut(( DEB_REGEX, "Undefined transition from %u on %u\n",
                             CurrentState,
                             wcCurrent ));
            }
            else
            {
                _nfa.EpsClosure( ssNew, ssClosed );

#               if (CIDBG == 1)
                    vqDebugOut(( DEB_REGEX, "NFA move FROM " ));
                    ssCurrent.Display();
                    vqDebugOut(( DEB_REGEX | DEB_NOCOMPNAME,
                                 " ON %d TO ", wcCurrent ));
                    ssClosed.Display();
                    vqDebugOut(( DEB_REGEX | DEB_NOCOMPNAME, "\n" ));
#               endif // (CIDBG == 1)

                NextState = _xs.XlatToOne( ssClosed );

                if ( !IsComputed( NextState ) )
                {
                    Add( NextState, _nfa.IsFinal( ssClosed ) );
                }
#               if (CIDBG == 1)
                    vqDebugOut(( DEB_REGEX,
                                 "DFA state %u = NFA states ", NextState ));
                    ssClosed.Display();
                    vqDebugOut(( DEB_REGEX | DEB_NOCOMPNAME, "\n" ));
#               endif // (CIDBG == 1)

                AddTransition( CurrentState, wcCurrent, NextState );

                vqDebugOut(( DEB_REGEX,
                             "Adding transition from %u on %u to %u\n",
                             CurrentState,
                             wcCurrent,
                             NextState ));
            }

            if ( _timeLimit.CheckExecutionTime() )
            {
                vqDebugOut(( DEB_WARN,
                             "CDFA::Recognize: aborting because execution time limit has been exceeded\n" ));
                THROW( CException( QUERY_E_TIMEDOUT ) );
            }
        }

        if ( NextState == stateUndefined )
        {
            return( FALSE );
        }

        //
        // The following are to find a specific condition detected on
        // JHavens' machine.
        //

        Win4Assert( LastState <= _cState );
        Win4Assert( CurrentState <= _cState );
        Win4Assert( NextState <= _cState );

        LastState    = CurrentState;
        CurrentState = NextState;

        fFinal = IsFinal( CurrentState );


        //
        // If we ran out of string then just keep going, appending
        // end-of-string symbols.  Unfortunately the string is conceptually
        // a set of characters followed by an arbitrary number of
        // end-of-string symbols.  In non-EGREP the end-of-string symbol
        // may actually cause multiple state transitions before reaching
        // a final state.  In non-EGREP (DOS) mode we stop only when we
        // are no longer 'making progress' (moving to new states) on
        // end-of-string.  I haven't completely convinced myself this
        // algorithm is guaranteed to terminate.
        //

        if ( wcCurrent == symEndLine )
        {
            if ( LastState == CurrentState )
                break;
        }
        else
        {
            wcCurrent = *wcs++;

            //
            // After we've exhausted the string, append the special
            // end-of-line character.
            //

            if ( wcCurrent == 0 )
            {
                wcCurrent = symEndLine;
            }
            else
            {
                vqDebugOut(( DEB_REGEX, "\"%c\" --> ", wcCurrent ));

                //
                // Casting is to guarantee this method doesn't modify anything (e.g. read lock ok).
                //

                #if CIDBG == 1
                  wcCurrent = (WCHAR) ((CNFA const *)&_nfa)->Translate().Translate( wcCurrent );
                #else
                  wcCurrent = (WCHAR) _nfa.Translate().Translate( wcCurrent );
                #endif

                vqDebugOut(( DEB_REGEX | DEB_NOCOMPNAME, "%u\n", wcCurrent ));
            }
        }

    }

#   if CIDBG == 1
       ValidateStateTransitions();
#   endif // CIDBG == 1

    return( fFinal );
}

//+-------------------------------------------------------------------------
//
//  Member:     CDFA::Add, private
//
//  Synopsis:   Adds a new state the the DFA.
//
//  Arguments:  [state]  -- State number
//              [fFinal] -- TRUE if state is a final state.
//
//  History:    20-Jan-92 KyleP     Created
//
//  Notes:      All transitions for the new state are initially uncomputed.
//
//--------------------------------------------------------------------------

void CDFA::Add( unsigned state, BOOLEAN fFinal )
{
    if ( state > _cState )
    {
        vqDebugOut(( DEB_ITRACE, "Growing DFA state array.\n" ));

        //
        // Since the number of states required will probably grow at
        // a slow rate, increase the size of the array in a linear
        // fashion.

        unsigned const DeltaState = 10;

        XPtrST<unsigned> xOldStateTrans( _xStateTrans.Acquire() );
        XPtrST<BOOLEAN> xOldStateFinal( _xStateFinal.Acquire() );

        unsigned   oldcState = _cState;
        unsigned   oldcEntries = (_cState + 1) *
            ( _nfa.Translate().NumClasses() + 1 );

        _cState += DeltaState;
        unsigned cEntries = (_cState + 1) * ( _nfa.Translate().NumClasses() + 1 );

        _xStateTrans.Init( cEntries );
        _xStateFinal.Init( _cState + 1 );

        //
        // Initilize new state tables...
        //

        memcpy( _xStateTrans.GetPointer(),
                xOldStateTrans.GetPointer(),
                oldcEntries * sizeof( unsigned ) );
        memcpy( _xStateFinal.GetPointer(),
                xOldStateFinal.GetPointer(),
                oldcState * sizeof( BOOLEAN ) );

        Win4Assert( stateUncomputed == 0xFFFFFFFF );
        memset( _xStateTrans.GetPointer() + oldcEntries, 0xFF, (cEntries - oldcEntries)*sizeof(unsigned ) );
        RtlZeroMemory( _xStateFinal.GetPointer() + oldcState, (_cState + 1 - oldcState)*sizeof(BOOLEAN) );


        for ( unsigned i = _cState - DeltaState + 1; i <= _cState; i++ )
        {
            AddTransition( i, 0, stateUndefined );
        }
    }

    //
    // All states are set to stateUncomputed above, except the 'undefined' flag-state.
    //

#   if CIDBG == 1
        for ( int i = _nfa.Translate().NumClasses(); i > 0; i-- )
            Win4Assert( Move( state, i ) == stateUncomputed );
#   endif

    AddTransition( state, 0, stateUncomputed );
    _xStateFinal[state] = fFinal;
}

//+---------------------------------------------------------------------------
//
//  Member:     CRegXpr::CRegXpr, public
//
//  Synopsis:   Create an expression used to match <prop> with a regex.
//
//  Arguments:  [prel]      -- Property restriction.
//              [timeLimit] -- Execution time limit
//
//  History:    15-Apr-92   KyleP       Created.
//
//----------------------------------------------------------------------------

CRegXpr::CRegXpr( CInternalPropertyRestriction * prst, CTimeLimit& timeLimit )
        : CXpr( CXpr::NTRegex ),
          _pxpval( prst->Pid() ),
          _xrstContentHelper( prst->AcquireContentHelper() ),
//
//  Feature decision: Make all regular expressions case insensitive.
//
          _dfa( prst->Value(), timeLimit, FALSE ),
          _ulCodePage( LocaleToCodepage( GetSystemDefaultLCID() ))
{

    //
    // Existence of _prstContentHelper implies a fixed starting prefix.
    //

    if ( !_xrstContentHelper.IsNull() )
    {
        //
        // Find fixed prefix, and add it as a view value
        //

        unsigned i = wcscspn( prst->Value().GetLPWSTR(),
                              awcSpecialRegex );

        if ( i > 0 )
        {
            WCHAR wcs[50];

            if ( i > sizeof(wcs)/sizeof(WCHAR) - 2 )
                i = sizeof(wcs)/sizeof(WCHAR) - 2;

            //
            // If "foo" is the prefix, we want all values from "foo" to "fop",
            // but I'm going to be lazy.  If the trailing letter of the prefix is
            // 0xFFFF then I just won't set bounds.
            //

            if ( prst->Value().GetLPWSTR()[i-1] != 0xFFFF )
            {
                memcpy( wcs, prst->Value().GetLPWSTR(), i*sizeof(WCHAR) );
                wcs[i] = 0;

                _varPrefix.SetLPWSTR( wcs );
            }
        }
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CRegXpr::CRegXpr, public
//
//  Synopsis:   Copy constructor
//
//  Arguments:  [src] -- Source expression
//
//  History:    13-Jul-95   KyleP       Created.
//
//----------------------------------------------------------------------------

CRegXpr::CRegXpr( CRegXpr const & src )
        : CXpr( CXpr::NTRegex ),
          _pxpval( src._pxpval ),
          _varPrefix( src._varPrefix ),
          _dfa( src._dfa ),
          _ulCodePage( src._ulCodePage )
{
    if ( !src._xrstContentHelper.IsNull() )
        _xrstContentHelper.Set( src._xrstContentHelper->Clone() );
}

//+---------------------------------------------------------------------------
//
//  Member:     CRegXpr::Clone, public
//
//  Returns:    A copy of this node.
//
//  Derivation: From base class CXpr, Always override in subclasses.
//
//  History:    11-Dec-91   KyleP       Created.
//
//----------------------------------------------------------------------------

CXpr * CRegXpr::Clone()
{
    return new CRegXpr( *this );
}

void CRegXpr::SelectIndexing( CIndexStrategy & strategy )
{
    if ( _pxpval.Pid() == pidPath ||
         _pxpval.Pid() == pidDirectory ||
         _pxpval.Pid() == pidVirtualPath )
    {
        strategy.SetUnknownBounds( _pxpval.Pid() );
        return;
    }

    if ( _varPrefix.Type() == VT_LPWSTR )
    {
        strategy.SetLowerBound( _pxpval.Pid(), _varPrefix );

        WCHAR * wcs = (WCHAR *)_varPrefix.GetLPWSTR();

        unsigned cc = wcslen( wcs );
        Win4Assert( wcs[cc-1] != 0xFFFF );
        wcs[cc-1] = wcs[cc-1] + 1;

        strategy.SetUpperBound( _pxpval.Pid(), _varPrefix, TRUE );
    }

    if ( !_xrstContentHelper.IsNull() )
    {
        strategy.SetContentHelper( _xrstContentHelper.GetPointer() );
        _xrstContentHelper.Acquire();
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CRegXpr::IsMatch, public
//
//  Arguments:  [obj] -- The objects table.  [obj] is already positioned
//                       to the record to test.
//
//  Returns:    TRUE if the current record satisfies the regex.
//
//  History:    15-Apr-92   KyleP       Created.
//
//----------------------------------------------------------------------------

BOOL CRegXpr::IsMatch( CRetriever & obj )
{
    // Make this big enough for most paths

    const cbGuess = ( MAX_PATH * sizeof WCHAR ) + sizeof PROPVARIANT;
    XGrowable<BYTE,cbGuess> xBuffer;
    PROPVARIANT * ppv = (PROPVARIANT *) xBuffer.Get();
    ULONG cb = xBuffer.SizeOf();

    GetValueResult rc = _pxpval.GetValue( obj, ppv, &cb );

    //
    // If the object is too big for the stack then allocate heap (sigh).
    //

    if ( rc == GVRNotEnoughSpace )
    {
        xBuffer.SetSize( cb );
        ppv = (PROPVARIANT *) xBuffer.Get();
        rc = _pxpval.GetValue( obj, ppv, &cb );
    }

    if ( rc != GVRSuccess )
        return FALSE;

    // MAX_PATH here is just a heuristic

    XGrowable<WCHAR, MAX_PATH> xConvert;

    //
    // Cast LPSTR to LPWSTR
    //

    if ( ppv->vt == VT_LPSTR )
    {
        cb = strlen( ppv->pszVal );
        ULONG cwcOut = cb + cb / 4 + 1;
        xConvert.SetSize( cwcOut );

        ULONG cwcActual = 0;
        do
        {
            cwcActual = MultiByteToWideChar( _ulCodePage,
                                             0,
                                             ppv->pszVal,
                                             cb + 1,
                                             xConvert.Get(),
                                             cwcOut );
            if ( cwcActual == 0 )
            {
                if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
                {
                    cwcOut *= 2;
                    xConvert.SetSize( cwcOut );
                }
                else
                    THROW( CException() );
            }
        } while ( 0 == cwcActual );

        ppv->vt = VT_LPWSTR;
        ppv->pwszVal = xConvert.Get();
    }
    else if ( ppv->vt == VT_LPWSTR || ppv->vt == VT_BSTR )
    {
        //
        // Normalize to precomposed Unicode
        //
        ULONG cwcIn;
        WCHAR *pwcIn;

        if ( ppv->vt == VT_LPWSTR )
        {
            pwcIn = ppv->pwszVal;
            cwcIn = wcslen(pwcIn) + 1;
        }
        else  // ppv->vt == VT_BSTR
        {
            pwcIn = ppv->bstrVal;
            cwcIn = SysStringLen( pwcIn ) + 1;
        }

        xConvert.SetSize( cwcIn );

        ULONG cwcFolded = FoldStringW( MAP_PRECOMPOSED,
                                       pwcIn,
                                       cwcIn,
                                       xConvert.Get(),
                                       cwcIn );
        if ( cwcFolded == 0 )
        {
            Win4Assert( GetLastError() != ERROR_INSUFFICIENT_BUFFER );
            THROW( CException() );
        }

        ppv->vt = VT_LPWSTR;
        ppv->pwszVal = xConvert.Get();
    }

    //
    // But any other types are illegal
    //

    if ( ppv->vt != VT_LPWSTR )
    {
        vqDebugOut(( DEB_ITRACE,
                     "CRegXpr::IsMatch -- Type mismatch. Got 0x%x\n",
                     ppv->vt ));
        return FALSE;
    }

    return _dfa.Recognize( ppv->pwszVal );
}

#if (CIDBG == 1)

//
// Debug methods
//

void CNFA::Display()
{
    vqDebugOut(( DEB_REGEX, "NFA contains %d states.\n", _iNextState-1 ));

    for ( unsigned i = 1; i < _iNextState; i++ )
    {
        Get(i)->Display();
        vqDebugOut(( DEB_REGEX | DEB_NOCOMPNAME, "\n" ));
    }
}

void CDFA::ValidateStateTransitions()
{
    //
    // Valid states are numbers < _cState, plus a few special states.
    //

    for ( int i = _cState * (_nfa.Translate().NumClasses() + 1);
          i >= 0;
          i-- )
    {
        if ( _xStateTrans[i] > _cState &&
             _xStateTrans[i] != stateUncomputed &&
             _xStateTrans[i] != stateUninitialized &&
             _xStateTrans[i] != stateUndefined )
        {
            vqDebugOut(( DEB_ERROR, "Bogus state 0x%x in DFA. pDFA = 0x%x\n",
                         _xStateTrans[i], this ));
            Win4Assert( !"Bogus state in DFA" );
        }
    }
}

#endif // (CIDBG == 1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\web\ixsso\utest\showqry1.inc ===
<SCRIPT LANGUAGE=VBScript>
<!--
    SUB ShowQueryParams_OnClick

        DIM MyForm
        set MyForm = Document.CiParams
        Param1="CiRestriction = " & MyForm.CiRestriction.Value & chr(10)
        Param2="CiColumns = " & MyForm.CiColumns.Value & chr(10)
        Param3="CiSort = " & MyForm.CiSort.Value 

        Param5="CiScope = " & MyForm.CiScope.Value & chr(10)
        Param6="CiFlags = " & MyForm.CiFlags.Value & chr(10)
        Param7="CiCatalog = " & MyForm.CiCatalog.Value & chr(10)
        Param8="CiMachine = " & MyForm.CiMachine.Value & chr(10)

        ParamA="CiDeferNonIndexedTrimming = " & MyForm.CiDeferNonIndexedTrimming.Value & chr(10)
        ParamB="CiForceUseCI = " & MyForm.CiForceUseCI.Value & chr(10)
        ParamC="CiMaxRecordsInResultSet = " & MyForm.CiMaxRecordsInResultSet.Value & chr(10)

        Msgbox Param1 & Param2 & Param3,,"Query Formulation"
        Msgbox Param5 & Param6 & Param7 & Param8,,"Query Scope"
        Msgbox ParamA & ParamB & ParamC,,"Query Flags"
    END SUB
-->
</SCRIPT>
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\xpr\nodexpr.cxx ===
//+---------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1991 - 2000.
//
// File:        NodeXpr.cxx
//
// Contents:    Internal expression classes
//
// Classes:     CXpr
//
// History:     11-Sep-91       KyleP     Created
//              23-Jan-95       t-colinb  Added Support for RTVector in
//                                        CNodeXpr::IsMatch
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <xpr.hxx>
#include <parse.hxx>


//+---------------------------------------------------------------------------
//
//  Member:     CNodeXpr::CNodeXpr, public
//
//  Synopsis:   Initialze an empty node.
//
//  Arguments:  [type]  -- Type of node (AND, OR, etc.)
//              [cInit] -- A hint about the number of expressions which
//                         will be added to this node.
//
//  Signals:    ???
//
//  History:    05-Dec-91   KyleP       Created.
//
//----------------------------------------------------------------------------

CNodeXpr::CNodeXpr ( CXpr::NodeType type, unsigned cInit )
    : CXpr ( type ),
      _cXpr( 0 ),
      _size( cInit )
{
    _aXpr = new CXpr* [cInit];
}

//+---------------------------------------------------------------------------
//
//  Member:     CNodeXpr::CNodeXpr, public
//
//  Synopsis:   Copy constructor
//
//  Arguments:  [nxpr] -- Node to copy from.
//
//  Signals:    ???
//
//  History:    11-Dec-91   KyleP       Created.
//
//----------------------------------------------------------------------------

CNodeXpr::CNodeXpr( CNodeXpr & nxpr )
    : CXpr ( nxpr.NType() )
{
    _cXpr   = nxpr._cXpr;
    _size   = nxpr._cXpr;
    _weight = nxpr._weight;

    _aXpr = new CXpr * [ _size ];
    RtlZeroMemory( _aXpr, _size * sizeof( CXpr * ) );

    TRY
    {
        for ( int i = _cXpr-1; i >= 0; i-- )
            _aXpr[i] = nxpr._aXpr[i]->Clone();
    }
    CATCH( CException, e )
    {
        for ( unsigned i = 0; i < _cXpr; i++ )
            delete _aXpr[i];

        delete _aXpr;
        RETHROW();
    }
    END_CATCH
}

//+---------------------------------------------------------------------------
//
//  Member:     CNodeXpr::~CNodeXpr, public
//
//  Synopsis:   Destroy subexpressions and cursor (if any)
//
//  Signals:    ???
//
//  History:    05-Dec-91   KyleP       Created.
//
//----------------------------------------------------------------------------

CNodeXpr::~CNodeXpr ()
{
    for ( unsigned i = 0; i < _cXpr; i++ )
        delete _aXpr[i];

    delete _aXpr;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNodeXpr::Clone, public
//
//  Returns:    A copy of this node.
//
//  Signals:    ???
//
//  Derivation: From base class CXpr, Always override in subclasses.
//
//  History:    11-Dec-91   KyleP       Created.
//
//----------------------------------------------------------------------------

CXpr * CNodeXpr::Clone()
{
    return( new CNodeXpr( *this ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CNodeXpr::SelectIndexing, public
//
//  Effects:    Selects indexing for children.
//
//  History:    03-Nov-94   KyleP       Created.
//
//  Notes:      Index selection is only applicable for AND nodes.
//
//----------------------------------------------------------------------------

void CNodeXpr::SelectIndexing( CIndexStrategy & strategy )
{
    BOOL fModeChange;

    if ( NType() == NTAnd )
        fModeChange = strategy.SetAndMode();
    else if ( NType() == NTOr )
        fModeChange = strategy.SetOrMode();
    else
    {
        strategy.SetUnknownBounds();
        return;
    }

    for ( unsigned i = 0; i < _cXpr; i++ )
        _aXpr[i]->SelectIndexing( strategy );

    if ( fModeChange )
        strategy.DoneWithBoolean();
}

//+---------------------------------------------------------------------------
//
//  Member:     CNodeXpr::IsLeaf, public
//
//  Returns:    FALSE.  Nodes are never leaf expressions.
//
//  Derivation: From base class CXpr, Frequently override in subclasses.
//
//  History:    12-Dec-91   KyleP       Created.
//
//----------------------------------------------------------------------------

BOOL CNodeXpr::IsLeaf() const
{
    return FALSE;
}

//+---------------------------------------------------------------------------
//
//  Member:     CNodeXpr::AddChild, public
//
//  Synopsis:   Add an expression to the node.
//
//  Arguments:  [child] -- Expression to add.
//
//  Signals:    ???
//
//  History:    12-Dec-91   KyleP       Created.
//
//  Notes:      Once an expression has been added to a node it is owned
//              by that node.  (e.g., no one else should delete it)
//
//----------------------------------------------------------------------------

void CNodeXpr::AddChild ( CXpr* child )
{
    Win4Assert( child );

    if ( _cXpr < _size )
    {
        _aXpr[_cXpr++] = child;
    }
    else
    {
        CXpr ** newArray = new CXpr * [ 2 * _size ];
        memcpy( newArray, _aXpr, _cXpr * sizeof( CXpr * ) );

        Win4Assert( _cXpr == _size );
        newArray[_cXpr++] = child;

        delete _aXpr;
        _size *= 2;
        _aXpr = newArray;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CNodeXpr::HitCount, public
//
//  Returns:    Sum for OR, Min for AND
//
//  History:    01-May-91   KyleP       Created.
//
//  Notes:      HitCount only makes sense for content clauses.  If there
//              are any non-content clauses then HitCount will return 0.
//
//----------------------------------------------------------------------------

ULONG CNodeXpr::HitCount( CRetriever & obj )
{
    ULONG result;

    switch ( NType() )
    {
    case NTAnd:
        {
            result = 0;

            for (int i = Count()-1; i >= 0; i--)
            {
                ULONG thisChild = GetChild( i )->HitCount( obj );
                result = (thisChild) ? min( result, thisChild ) : result;
            }
        }
        break;

    case NTOr:
        {
            result = 0;

            for (int i = Count()-1; i >= 0; i--)
            {
                ULONG thisChild = GetChild( i )->HitCount( obj );
                if ( 0 != thisChild )
                {
                    result += GetChild( i )->HitCount( obj );
                }
                else
                {
                    result = 0;
                    break;
                }
            }
        }
        break;

    default:
        result = 0;
        break;
    }

    return( result );
}

//+---------------------------------------------------------------------------
//
//  Member:     CNodeXpr::Rank, public
//
//  Returns:    Sum for OR, Min for AND
//
//  History:    01-May-91   KyleP       Created.
//
//----------------------------------------------------------------------------

LONG CNodeXpr::Rank( CRetriever & obj )
{
    LONG result;

    switch ( NType() )
    {
    case NTAnd:
        {
            result = MAX_QUERY_RANK;

            for (int i = Count()-1; i >= 0; i--)
            {
                result = min( result, GetChild( i )->Rank( obj ) );
            }
        }
        break;

    case NTOr:
        {
            result = 0;

            for (int i = Count()-1; i >= 0; i--)
            {
                result += GetChild( i )->Rank( obj );
            }

            result /= Count();
        }
        break;

    default:
        result = 0;
        break;
    }

    return( result );
}

//+---------------------------------------------------------------------------
//
//  Member:     CNodeXpr::IsMatch, public
//
//  Arguments:  [obj] -- The objects table.  [obj] is already positioned
//                       to the record to test.
//              [wid] -- Workid of object to which [obj] is positioned.
//
//  Returns:    TRUE if the current record satisfies the relation.
//
//  Signals:    ???
//
//  History:    20-Nov-91   KyleP       Created.
//              23-Jan-95   t-colinb    Added Support for RTVector in
//
//
//----------------------------------------------------------------------------

BOOL CNodeXpr::IsMatch( CRetriever & obj )
{
    Win4Assert( NType() == NTAnd ||
                NType() == NTOr  ||
                NType() == NTVector  );

    //
    // If some portion of the node has been indexed, adjust the cursor to
    // the wid we're looking for.
    //

    WORKID widCur = widInvalid;
    BOOL result;

    switch ( NType() )
    {
    case NTAnd:
        result = TRUE;
        {
            for (int i = Count()-1; result && i >= 0; i--)
            {
                result = GetChild( i )->IsMatch( obj );
            }
        }
        break;

    case NTOr:
    case NTVector:
        result = FALSE;
        {
            for (int i = Count()-1; !result && i >= 0; i--)
            {
                result = GetChild( i )->IsMatch( obj );
            }
        }
        break;

    default:
        result = FALSE;
        break;
    }

    return result;
}


//+---------------------------------------------------------------------------
//
//  Member:     CNodeXpr::RemoveChild, public
//
//  Synopsis:   Removes a node.
//
//  Arguments:  [iPos] -- Position of node to remove.
//
//  Requires:   [iPos] is a valid node.
//
//  Returns:    The child node which was removed.
//
//  History:    19-Nov-91   KyleP       Created.
//
//  Notes:      CNodeXpr does not guarantee the position of nodes across
//              calls to RemoveChild.
//
//----------------------------------------------------------------------------

CXpr* CNodeXpr::RemoveChild ( unsigned iPos )
{
    Win4Assert ( iPos <= _cXpr );

    CXpr * pxp = _aXpr[iPos];
    _aXpr[iPos] = _aXpr[ _cXpr - 1 ];
    _cXpr--;

#if (CIDBG == 1)
    _aXpr[ _cXpr ] = 0;
#endif

    return( pxp );
}


//+-------------------------------------------------------------------------
//
//  Member:     CVectorXpr::CVectorXpr, public
//
//  Synopsis:   Constructs a vector expression.
//
//  Arguments:  [type]       -- Type of node (AND, OR, etc.)
//              [cInit]      -- A hint about the number of expressions
//                              which will be added.
//              [RankMethod] -- Method used to compute rank.
//
//  History:    24-Jul-92 KyleP     Created
//
//--------------------------------------------------------------------------

CVectorXpr::CVectorXpr( unsigned cInit,
                        ULONG RankMethod )
        : CNodeXpr( CXpr::NTVector, cInit ),
          _ulRankMethod( RankMethod )
{
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\xpr\compare.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 2000.
//
//  File:       Compare.cxx
//
//  Contents:   Comparator class for property sets.
//
//  Classes:    CComparePropSets
//
//  History:    07-Jun-92 KyleP     Created
//              07-Apr-93 KyleP     Convert to CairOle
//              02-Nov-93 KyleP     Added allmost all VT_ types
//
//  Notes:      The following comparisons are suppored
//
//              Variant     Equality    Relational  Bitwise
//              ----------- ----------- ----------  -------
//
//              VT_EMPTY        X
//              VT_NULL         X
//              VT_I2           X           X           X
//              VT_I4           X           X           X
//              VT_R4           X           X
//              VT_R8           X           X
//              VT_CY           X           X
//              VT_DATE         X           X
//              VT_BSTR         X           X
//              VT_DISPATCH     -
//              VT_ERROR        X           X           X
//              VT_BOOL         X
//              VT_VARIANT      X           X
//              VT_UNKNOWN      -
//              VT_DECIMAL      X           X
//              VT_I1           X           X           X
//              VT_UI1          X           X           X
//              VT_UI2          X           X           X
//              VT_UI4          X           X           X
//              VT_I8           X           X           X
//              VT_UI8          X           X           X
//              VT_INT          X           X           X
//              VT_UINT         X           X           X
//              VT_VOID         -
//              VT_HRESULT      X           X           X
//              VT_PTR          -
//              VT_SAFEARRAY    -
//              VT_CARRAY       -
//              VT_USERDEFINED  -
//              VT_LPSTR        X           X
//              VT_LPWSTR       X           X
//              VT_FILETIME     X           X
//              VT_BLOB         X           X
//              VT_STREAM
//              VT_STORAGE
//              VT_STREAMED_OBJECT
//              VT_STORED_OBJECT
//              VT_BLOB_OBJECT  X           X
//              VT_CF           X           X
//              VT_CLSID        X
//
//
//              The following are OLE-DB datatypes.
//
//              Variant     Equality    Vector
//              ----------- ----------- ------
//
//              DBTYPE_EMPTY    X
//              DBTYPE_NULL     X
//              DBTYPE_I1       X           X
//              DBTYPE_UI1      X           X
//              DBTYPE_I2       X           X
//              DBTYPE_UI2      X           X
//              DBTYPE_I4       X           X
//              DBTYPE_UI4      X           X
//              DBTYPE_R4       X           X
//              DBTYPE_R8       X           X
//              DBTYPE_CY       X           X
//              DBTYPE_DATE     X           X
//              DBTYPE_BSTR     X
//              DBTYPE_DISPATCH
//              DBTYPE_ERROR    X
//              DBTYPE_BOOL     X
//              DBTYPE_VARIANT  X           X
//              DBTYPE_UNKNOWN  X
//              DBTYPE_I8       X           X
//              DBTYPE_GUID     X
//              DBTYPE_BYTES    X           X
//              DBTYPE_STR      X           X
//              DBTYPE_WSTR     X           X
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <compare.hxx>
#include <coldesc.hxx>
#include <propvar.h>

CComparators VariantCompare;

DBTYPEENUM dbVector(DBTYPEENUM vt)
{
    return (DBTYPEENUM) (DBTYPE_VECTOR | vt);
}

//
// DEFAULT.  Used for optimization in looped comparisons.  If we can't
//           determine the way to compare, then use this default.
//

int VT_DEFAULT_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( 0 );
}

//
// VT_EMPTY
//

int VT_EMPTY_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( 0 );
}

BOOL VT_EMPTY_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( TRUE );
}

BOOL VT_EMPTY_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( FALSE );
}

//
// VT_NULL
//

int VT_NULL_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( 0 );
}

BOOL VT_NULL_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( TRUE );
}

BOOL VT_NULL_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( FALSE );
}

//
// VT_I2
//

int VT_I2_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.iVal - v2.iVal );
}

BOOL VT_I2_LT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.iVal < v2.iVal );
}

BOOL VT_I2_LE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.iVal <= v2.iVal );
}

BOOL VT_I2_GE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.iVal >= v2.iVal );
}

BOOL VT_I2_GT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.iVal > v2.iVal );
}

BOOL VT_I2_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.iVal == v2.iVal );
}

BOOL VT_I2_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.iVal != v2.iVal );
}

BOOL VT_I2_AllBits( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( (v1.iVal & v2.iVal) == v2.iVal );
}

BOOL VT_I2_SomeBits( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( (v1.iVal & v2.iVal) != 0 );
}

//
// VT_I4
//

int VT_I4_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return ( v1.lVal > v2.lVal ) ? 1 : ( v1.lVal < v2.lVal ) ? -1 : 0;
}

BOOL VT_I4_LT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.lVal < v2.lVal );
}

BOOL VT_I4_LE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.lVal <= v2.lVal );
}

BOOL VT_I4_GE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.lVal >= v2.lVal );
}

BOOL VT_I4_GT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.lVal > v2.lVal );
}

BOOL VT_I4_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.lVal == v2.lVal );
}

BOOL VT_I4_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.lVal != v2.lVal );
}

BOOL VT_I4_AllBits( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( (v1.lVal & v2.lVal) == v2.lVal );
}

BOOL VT_I4_SomeBits( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( (v1.lVal & v2.lVal) != 0 );
}

//
// VT_R4
//

//
// We can't use floating point in the kernel.  Luckily, it's easy to
// fake comparisons on floating point.  The format of an IEEE floating
// point number is:
//
//     <sign bit> <biased exponent> <normalized mantissa>
//
// Because the exponent is biased, after flipping the sign bit we can
// make all comparisons as if the numbers were unsigned long.
//

ULONG const R4_SignBit = 0x80000000;

int VT_R4_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    // axp (not x86) generates exceptions when floating point numbers
    // don't look like ieee floating point numbers.  This can happen
    // with bogus queries or bogus values stored in properties or the
    // property store.

    #if (_X86_ == 1)
        return ( v1.fltVal > v2.fltVal ) ? 1 :
               ( v1.fltVal < v2.fltVal ) ? -1 : 0;
    #else
        ULONG u1 = v1.ulVal ^ R4_SignBit;
        ULONG u2 = v2.ulVal ^ R4_SignBit;

        if ( (v1.ulVal & v2.ulVal & R4_SignBit) != 0 )
            return ( ( u1 > u2 ) ? -1 : ( u1 < u2 ) ?  1 : 0 );
        else
            return ( ( u1 > u2 ) ?  1 : ( u1 < u2 ) ? -1 : 0 );
    #endif
}

BOOL VT_R4_LT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_R4_Compare( v1, v2 ) < 0;
}

BOOL VT_R4_LE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_R4_Compare( v1, v2 ) <= 0;
}

BOOL VT_R4_GE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_R4_Compare( v1, v2 ) >= 0;
}

BOOL VT_R4_GT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_R4_Compare( v1, v2 ) > 0;
}

BOOL VT_R4_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.ulVal == v2.ulVal );
}

BOOL VT_R4_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.ulVal != v2.ulVal );
}

//
// VT_R8
//

LONGLONG const R8_SignBit = 0x8000000000000000;

int VT_R8_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    // axp (not x86) generates exceptions when floating point numbers
    // don't look like ieee floating point numbers.  This can happen
    // with bogus queries or bogus values stored in properties or the
    // property store.

    #if (_X86_ == 1)
        return ( v1.dblVal > v2.dblVal ) ? 1 :
               ( v1.dblVal < v2.dblVal ) ? -1 : 0;

    #else
        if ( (v1.uhVal.QuadPart & v2.uhVal.QuadPart & R8_SignBit) != 0 )
            return( (v1.uhVal.QuadPart ^ R8_SignBit) < (v2.uhVal.QuadPart ^ R8_SignBit) ? 1 :
                    (v1.uhVal.QuadPart ^ R8_SignBit) == (v2.uhVal.QuadPart ^ R8_SignBit) ? 0 :
                    -1 );
        else
            return( (v1.uhVal.QuadPart ^ R8_SignBit) > (v2.uhVal.QuadPart ^ R8_SignBit) ? 1 :
                    (v1.uhVal.QuadPart ^ R8_SignBit) == (v2.uhVal.QuadPart ^ R8_SignBit) ? 0 :
                    -1 );
    #endif // 0
}

BOOL VT_R8_LT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_R8_Compare( v1, v2 ) < 0;
}

BOOL VT_R8_LE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_R8_Compare( v1, v2 ) <= 0;
}

BOOL VT_R8_GE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_R8_Compare( v1, v2 ) >= 0;
}

BOOL VT_R8_GT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_R8_Compare( v1, v2 ) > 0;
}

BOOL VT_R8_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.uhVal.QuadPart == v2.uhVal.QuadPart );
}

BOOL VT_R8_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.uhVal.QuadPart != v2.uhVal.QuadPart );
}

//
// VT_BSTR
//

int VT_BSTR_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    BSTR const pxv1 = v1.bstrVal;
    BSTR const pxv2 = v2.bstrVal;

    ULONG len = BSTRLEN(pxv1);
    if ( BSTRLEN(pxv2) < len )
        len = BSTRLEN(pxv2);

    int iCmp = _wcsnicmp( pxv1, pxv2, len / sizeof (OLECHAR) );

    if ( iCmp != 0 || BSTRLEN(pxv1) == BSTRLEN(pxv2) )
        return( iCmp );

    if ( BSTRLEN(pxv1) > BSTRLEN(pxv2) )
        return( 1 );
    else
        return( -1 );
}

BOOL VT_BSTR_LT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( VT_BSTR_Compare( v1, v2 ) < 0 );
}

BOOL VT_BSTR_LE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( VT_BSTR_Compare( v1, v2 ) <= 0 );
}

BOOL VT_BSTR_GE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( VT_BSTR_Compare( v1, v2 ) >= 0 );
}

BOOL VT_BSTR_GT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( VT_BSTR_Compare( v1, v2 ) > 0 );
}

BOOL VT_BSTR_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    BSTR const pxv1 = v1.bstrVal;
    BSTR const pxv2 = v2.bstrVal;

    return( BSTRLEN(pxv1) == BSTRLEN(pxv2) &&
            _wcsnicmp( pxv1, pxv2, BSTRLEN(pxv1) / sizeof (OLECHAR) ) == 0 );
}

BOOL VT_BSTR_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    BSTR const pxv1 = v1.bstrVal;
    BSTR const pxv2 = v2.bstrVal;

    return( BSTRLEN(pxv1) != BSTRLEN(pxv2) ||
            _wcsnicmp( pxv1, pxv2, BSTRLEN(pxv1) / sizeof (OLECHAR) ) != 0 );
}

//
// VT_BOOL
//

int VT_BOOL_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    if (v1.boolVal == 0)
        if (v2.boolVal == 0)
            return( 0 );
        else
            return( -1 );
    else
        if (v2.boolVal == 0)
            return( 1 );
        else
            return( 0 );
}

BOOL VT_BOOL_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( ((v1.boolVal==0) && (v2.boolVal==0))  ||
            ((v1.boolVal!=0) && (v2.boolVal!=0)) );
}

BOOL VT_BOOL_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( !VT_BOOL_EQ( v1, v2 ) );
}

//
// VT_VARIANT
//

int VT_VARIANT_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    if ( v1.vt != v2.vt )
        return v1.vt - v2.vt;

    FCmp comp = VariantCompare.GetComparator( (VARENUM) v1.vt );

    if (0 == comp)
        return 0;
    else
        return comp( v1, v2 );
}

BOOL VT_VARIANT_LT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VARIANT_Compare( v1, v2 ) < 0;
}

BOOL VT_VARIANT_LE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VARIANT_Compare( v1, v2 ) <= 0;
}

BOOL VT_VARIANT_GE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VARIANT_Compare( v1, v2 ) >= 0;
}

BOOL VT_VARIANT_GT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VARIANT_Compare( v1, v2 ) > 0;
}

BOOL VT_VARIANT_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VARIANT_Compare( v1, v2 ) == 0;
}

BOOL VT_VARIANT_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VARIANT_Compare( v1, v2 ) != 0;
}

//
// VT_DECIMAL
//

int VT_DEC_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    if ( v1.decVal.sign  == v2.decVal.sign  &&
         v1.decVal.scale == v2.decVal.scale &&
         v1.decVal.Hi32  == v2.decVal.Hi32  &&
         v1.decVal.Lo64  == v2.decVal.Lo64)
        return 0;

    int iSign = v1.decVal.sign == DECIMAL_NEG ? -1 : 1;

    if ( v1.decVal.sign != v2.decVal.sign )
        return iSign;

    if ( v1.decVal.scale == v2.decVal.scale )
    {
        int iRet = 0;
        if (v1.decVal.Hi32 != v2.decVal.Hi32)
            iRet = (v1.decVal.Hi32 < v2.decVal.Hi32) ? -1 : 1;
        else if (v1.decVal.Lo64 != v2.decVal.Lo64)
            iRet = (v1.decVal.Lo64 < v2.decVal.Lo64) ? -1 : 1;
        return iRet * iSign;
    }

    double d1;
    VarR8FromDec( (DECIMAL*)&v1.decVal, &d1 );
    double d2;
    VarR8FromDec( (DECIMAL*)&v2.decVal, &d2 );

    return (( d1 > d2 ) ? 1 : ( d1 < d2 ) ? -1 : 0);
}

BOOL VT_DEC_LT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VARIANT_Compare( v1, v2 ) < 0;
}

BOOL VT_DEC_LE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_DEC_Compare( v1, v2 ) <= 0;
}

BOOL VT_DEC_GE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_DEC_Compare( v1, v2 ) >= 0;
}

BOOL VT_DEC_GT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_DEC_Compare( v1, v2 ) > 0;
}

BOOL VT_DEC_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_DEC_Compare( v1, v2 ) == 0;
}

BOOL VT_DEC_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_DEC_Compare( v1, v2 ) != 0;
}

//
// VT_I1
//

int VT_I1_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.cVal - v2.cVal );
}

BOOL VT_I1_LT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.cVal < v2.cVal );
}

BOOL VT_I1_LE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.cVal <= v2.cVal );
}

BOOL VT_I1_GE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.cVal >= v2.cVal );
}

BOOL VT_I1_GT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.cVal > v2.cVal );
}

BOOL VT_I1_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.cVal == v2.cVal );
}

BOOL VT_I1_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.cVal != v2.cVal );
}

BOOL VT_I1_AllBits( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( (v1.cVal & v2.cVal) == v2.cVal );
}

BOOL VT_I1_SomeBits( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( (v1.cVal & v2.cVal) != 0 );
}


//
// VT_UI1
//

int VT_UI1_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.bVal - v2.bVal );
}

BOOL VT_UI1_LT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.bVal < v2.bVal );
}

BOOL VT_UI1_LE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.bVal <= v2.bVal );
}

BOOL VT_UI1_GE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.bVal >= v2.bVal );
}

BOOL VT_UI1_GT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.bVal > v2.bVal );
}

BOOL VT_UI1_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.bVal == v2.bVal );
}

BOOL VT_UI1_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.bVal != v2.bVal );
}

BOOL VT_UI1_AllBits( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( (v1.bVal & v2.bVal) == v2.bVal );
}

BOOL VT_UI1_SomeBits( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( (v1.bVal & v2.bVal) != 0 );
}

//
// VT_UI2
//

int VT_UI2_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.uiVal - v2.uiVal );
}

BOOL VT_UI2_LT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.uiVal < v2.uiVal );
}

BOOL VT_UI2_LE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.uiVal <= v2.uiVal );
}

BOOL VT_UI2_GE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.uiVal >= v2.uiVal );
}

BOOL VT_UI2_GT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.uiVal > v2.uiVal );
}

BOOL VT_UI2_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.uiVal == v2.uiVal );
}

BOOL VT_UI2_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.uiVal != v2.uiVal );
}

BOOL VT_UI2_AllBits( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( (v1.uiVal & v2.uiVal) == v2.uiVal );
}

BOOL VT_UI2_SomeBits( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( (v1.uiVal & v2.uiVal) != 0 );
}
//
// VT_UI4
//

int VT_UI4_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return ( v1.ulVal > v2.ulVal ) ? 1 : ( v1.ulVal < v2.ulVal ) ? -1 : 0;
}

BOOL VT_UI4_LT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.ulVal < v2.ulVal );
}

BOOL VT_UI4_LE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.ulVal <= v2.ulVal );
}

BOOL VT_UI4_GE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.ulVal >= v2.ulVal );
}

BOOL VT_UI4_GT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.ulVal > v2.ulVal );
}

BOOL VT_UI4_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.ulVal == v2.ulVal );
}

BOOL VT_UI4_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.ulVal != v2.ulVal );
}

BOOL VT_UI4_AllBits( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( (v1.ulVal & v2.ulVal) == v2.ulVal );
}

BOOL VT_UI4_SomeBits( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( (v1.ulVal & v2.ulVal) != 0 );
}

//
// VT_I8
//

int VT_I8_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.hVal.QuadPart >  v2.hVal.QuadPart ? 1 :
            v1.hVal.QuadPart == v2.hVal.QuadPart ? 0 :
            -1 );
}

BOOL VT_I8_LT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.hVal.QuadPart < v2.hVal.QuadPart );
}

BOOL VT_I8_LE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.hVal.QuadPart <= v2.hVal.QuadPart );

}

BOOL VT_I8_GE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.hVal.QuadPart >= v2.hVal.QuadPart );
}

BOOL VT_I8_GT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.hVal.QuadPart > v2.hVal.QuadPart );
}

BOOL VT_I8_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.hVal.QuadPart == v2.hVal.QuadPart );
}

BOOL VT_I8_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.hVal.QuadPart != v2.hVal.QuadPart );
}

BOOL VT_I8_AllBits( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( (v1.hVal.QuadPart & v2.hVal.QuadPart) == v2.hVal.QuadPart );
}

BOOL VT_I8_SomeBits( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( (v1.hVal.QuadPart & v2.hVal.QuadPart) != 0 );
}

//
// VT_UI8
//

int VT_UI8_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.uhVal.QuadPart >  v2.uhVal.QuadPart ? 1 :
            v1.uhVal.QuadPart == v2.uhVal.QuadPart ? 0 :
            -1 );
}

BOOL VT_UI8_LT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.uhVal.QuadPart < v2.uhVal.QuadPart );
}

BOOL VT_UI8_LE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.uhVal.QuadPart <= v2.uhVal.QuadPart );

}

BOOL VT_UI8_GE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.uhVal.QuadPart >= v2.uhVal.QuadPart );
}

BOOL VT_UI8_GT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.uhVal.QuadPart > v2.uhVal.QuadPart );
}

BOOL VT_UI8_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.uhVal.QuadPart == v2.uhVal.QuadPart );
}

BOOL VT_UI8_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.uhVal.QuadPart != v2.uhVal.QuadPart );
}

BOOL VT_UI8_AllBits( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( (v1.uhVal.QuadPart & v2.uhVal.QuadPart) == v2.uhVal.QuadPart );
}

BOOL VT_UI8_SomeBits( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( (v1.uhVal.QuadPart & v2.uhVal.QuadPart) != 0 );
}

//
// VT_LPSTR
//

int VT_LPSTR_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return ( _stricmp( v1.pszVal, v2.pszVal ) );
}

BOOL VT_LPSTR_LT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    int rc = _stricmp( v1.pszVal, v2.pszVal );

    return( rc < 0 );
}

BOOL VT_LPSTR_LE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    int rc = _stricmp( v1.pszVal, v2.pszVal );

    return( rc <= 0 );
}

BOOL VT_LPSTR_GE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    int rc = _stricmp( v1.pszVal, v2.pszVal );

    return( rc >= 0 );
}

BOOL VT_LPSTR_GT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    int rc = _stricmp( v1.pszVal, v2.pszVal );

    return( rc > 0 );
}

BOOL VT_LPSTR_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( _stricmp( v1.pszVal, v2.pszVal ) == 0 );
}

BOOL VT_LPSTR_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( _stricmp( v1.pszVal, v2.pszVal ) != 0 );
}


//
// VT_LPWSTR
//

int VT_LPWSTR_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    int rc = CompareStringW( LOCALE_SYSTEM_DEFAULT,
                             NORM_IGNORECASE,
                             v1.pwszVal,
                             -1,
                             v2.pwszVal,
                             -1 );
    //
    // rc == 1, means less than
    // rc == 2, means equal
    // rc == 3, means greater than
    //
    return rc - 2;
}

BOOL VT_LPWSTR_LT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return ( VT_LPWSTR_Compare( v1, v2 ) < 0 );
}

BOOL VT_LPWSTR_LE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return ( VT_LPWSTR_Compare( v1, v2 ) <= 0 );
}

BOOL VT_LPWSTR_GE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return ( VT_LPWSTR_Compare( v1, v2 ) >= 0 );
}

BOOL VT_LPWSTR_GT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return ( VT_LPWSTR_Compare( v1, v2 ) > 0 );
}

BOOL VT_LPWSTR_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return ( VT_LPWSTR_Compare( v1, v2 ) == 0 );
}

BOOL VT_LPWSTR_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return ( VT_LPWSTR_Compare( v1, v2 ) != 0 );
}

//
// VT_BLOB
//

int VT_BLOB_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    ULONG len = v1.blob.cbSize;
    if ( v2.blob.cbSize < len )
        len = v2.blob.cbSize;

    int iCmp = memcmp( v1.blob.pBlobData,
                       v2.blob.pBlobData,
                       len );

    if ( iCmp != 0 || v1.blob.cbSize == v2.blob.cbSize )
        return( iCmp );

    if ( v1.blob.cbSize > v2.blob.cbSize )
        return( 1 );
    else
        return( -1 );
}

BOOL VT_BLOB_LT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( VT_BLOB_Compare( v1, v2 ) < 0 );
}

BOOL VT_BLOB_LE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( VT_BLOB_Compare( v1, v2 ) <= 0 );
}

BOOL VT_BLOB_GE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( VT_BLOB_Compare( v1, v2 ) >= 0 );
}

BOOL VT_BLOB_GT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( VT_BLOB_Compare( v1, v2 ) > 0 );
}

BOOL VT_BLOB_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.blob.cbSize == v2.blob.cbSize &&
            memcmp( v1.blob.pBlobData,
                    v2.blob.pBlobData,
                    v1.blob.cbSize ) == 0 );
}

BOOL VT_BLOB_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.blob.cbSize != v2.blob.cbSize ||
            memcmp( v1.blob.pBlobData,
                      v2.blob.pBlobData,
                      v1.blob.cbSize ) != 0 );
}

//
// VT_CF
//

int VT_CF_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    if ( v1.pclipdata->ulClipFmt != v2.pclipdata->ulClipFmt )
    {
        return( v1.pclipdata->ulClipFmt - v2.pclipdata->ulClipFmt );
    }

    ULONG len = CBPCLIPDATA(*v1.pclipdata);

    if ( CBPCLIPDATA(*v2.pclipdata) < len )
        len = CBPCLIPDATA(*v2.pclipdata);

    int iCmp = memcmp( v1.pclipdata->pClipData,
                       v2.pclipdata->pClipData,
                       len );

    if ( iCmp != 0 || v1.pclipdata->cbSize == v2.pclipdata->cbSize )
        return( iCmp );

    if ( v1.pclipdata->cbSize > v2.pclipdata->cbSize )
        return( 1 );
    else
        return( -1 );
}

BOOL VT_CF_LT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( VT_CF_Compare( v1, v2 ) < 0 );
}

BOOL VT_CF_LE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( VT_CF_Compare( v1, v2 ) <= 0 );
}

BOOL VT_CF_GE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( VT_CF_Compare( v1, v2 ) >= 0 );
}

BOOL VT_CF_GT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( VT_CF_Compare( v1, v2 ) > 0 );
}

BOOL VT_CF_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.pclipdata->ulClipFmt == v2.pclipdata->ulClipFmt &&
            v1.pclipdata->cbSize == v2.pclipdata->cbSize &&
            memcmp( v1.pclipdata->pClipData,
                    v2.pclipdata->pClipData,
                    CBPCLIPDATA(*v1.pclipdata) ) == 0 );
}

BOOL VT_CF_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( v1.pclipdata->ulClipFmt != v2.pclipdata->ulClipFmt ||
            v1.pclipdata->cbSize != v2.pclipdata->cbSize ||
            memcmp( v1.pclipdata->pClipData,
                    v2.pclipdata->pClipData,
                    CBPCLIPDATA(*v1.pclipdata) ) != 0 );
}

//
// VT_CLSID
//

int VT_CLSID_Compare( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( memcmp( v1.puuid, v2.puuid, sizeof(GUID) ) );
}

BOOL VT_CLSID_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( memcmp( v1.puuid, v2.puuid, sizeof(GUID) ) == 0 );
}

BOOL VT_CLSID_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return( memcmp( v1.puuid, v2.puuid, sizeof(GUID) ) != 0 );
}

/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

//
// VTP_EMPTY
//

int VTP_EMPTY_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    return( TRUE );
}

BOOL VTP_EMPTY_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( TRUE );
}

BOOL VTP_EMPTY_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( FALSE );
}

//
// VTP_NULL
//

int VTP_NULL_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    return( TRUE );
}

BOOL VTP_NULL_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( TRUE );
}

BOOL VTP_NULL_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( FALSE );
}

//
// VTP_I2
//

int VTP_I2_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    return( (* (short *) pv1) - (* (short *) pv2) );
}

BOOL VTP_I2_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (* (short *) pv1) < (* (short *) pv2) );
}

BOOL VTP_I2_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (* (short *) pv1) <= (* (short *) pv2) );
}

BOOL VTP_I2_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (* (short *) pv1) >= (* (short *) pv2) );
}

BOOL VTP_I2_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (* (short *) pv1) > (* (short *) pv2) );
}

BOOL VTP_I2_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( (* (short *) pv1) == (* (short *) pv2) );
}

BOOL VTP_I2_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (* (short *) pv1) != (* (short *) pv2) );
}

BOOL VTP_I2_AllBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((* (short *) pv1) & (* (short *) pv2)) == (* (short *) pv2) );
}

BOOL VTP_I2_SomeBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((* (short *) pv1) & (* (short *) pv2)) != 0 );
}

//
// VTP_I4
//

int VTP_I4_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    long l1 = * (long *) pv1;
    long l2 = * (long *) pv2;

    return ( l1 > l2 ) ? 1 : ( l1 < l2 ) ? -1 : 0;
}

BOOL VTP_I4_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (* (long *) pv1) < (* (long *) pv2) );
}

BOOL VTP_I4_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (* (long *) pv1) <= (* (long *) pv2) );
}

BOOL VTP_I4_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (* (long *) pv1) >= (* (long *) pv2) );
}

BOOL VTP_I4_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (* (long *) pv1) > (* (long *) pv2) );
}

BOOL VTP_I4_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( (* (long *) pv1) == (* (long *) pv2) );
}

BOOL VTP_I4_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (* (long *) pv1) != (* (long *) pv2) );
}

BOOL VTP_I4_AllBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((* (long *) pv1) & (* (long *) pv2)) == (* (long *) pv2) );
}

BOOL VTP_I4_SomeBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((* (long *) pv1) & (* (long *) pv2)) != 0 );
}

//
// VTP_R4
//

//
// We can't use floating point in the kernel.  Luckily, it's easy to
// fake comparisons on floating point.  The format of an IEEE floating
// point number is:
//
//     <sign bit> <biased exponent> <normalized mantissa>
//
// Because the exponent is biased, after flipping the sign bit we can
// make all comparisons as if the numbers were unsigned long.
//

int VTP_R4_Compare( BYTE const *pv1, BYTE const *pv2 )
{
#if 0
    ULONG ul1 = * (ULONG *) pv1;
    ULONG ul2 = * (ULONG *) pv2;
    ULONG u1 = ul1 ^ R4_SignBit;
    ULONG u2 = ul2 ^ R4_SignBit;

    if ( (ul1 & ul2 & R4_SignBit) != 0 )
        return ( ( u1 > u2 ) ? -1 : ( u1 < u2 ) ?  1 : 0 );
    else
        return ( ( u1 > u2 ) ?  1 : ( u1 < u2 ) ? -1 : 0 );
#else // 0
    float f1 = * (float *) pv1;
    float f2 = * (float *) pv2;
    return ( f1 > f2 ) ? 1 : ( f1 < f2 ) ? -1 : 0;
#endif // 0
}

BOOL VTP_R4_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return VTP_R4_Compare( pv1, pv2 ) < 0;
}

BOOL VTP_R4_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return VTP_R4_Compare( pv1, pv2 ) <= 0;
}

BOOL VTP_R4_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return VTP_R4_Compare( pv1, pv2 ) >= 0;
}

BOOL VTP_R4_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return VTP_R4_Compare( pv1, pv2 ) > 0;
}

BOOL VTP_R4_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return VTP_R4_Compare( pv1, pv2 ) == 0;
}

BOOL VTP_R4_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return VTP_R4_Compare( pv1, pv2 ) != 0;
}

//
// VTP_R8
//

int VTP_R8_Compare( BYTE const *pv1, BYTE const *pv2 )
{
#if 0
    ULONGLONG uh1 = * (ULONGLONG *) pv1;
    ULONGLONG uh2 = * (ULONGLONG *) pv2;

    if ( (uh1 & uh2 & R8_SignBit) != 0 )
        return( (uh1 ^ R8_SignBit) < (uh2 ^ R8_SignBit) ? 1 :
                (uh1 ^ R8_SignBit) == (uh2 ^ R8_SignBit) ? 0 :
                -1 );
    else
        return( (uh1 ^ R8_SignBit) > (uh2 ^ R8_SignBit) ? 1 :
                (uh1 ^ R8_SignBit) == (uh2 ^ R8_SignBit) ? 0 :
                -1 );
#else // 0
    double d1 = * (double *) pv1;
    double d2 = * (double *) pv2;
    return ( d1 > d2 ) ? 1 : ( d1 < d2 ) ? -1 : 0;
#endif // 0
}

BOOL VTP_R8_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return VTP_R8_Compare( pv1, pv2 ) < 0;
}

BOOL VTP_R8_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return VTP_R8_Compare( pv1, pv2 ) <= 0;
}

BOOL VTP_R8_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return VTP_R8_Compare( pv1, pv2 ) >= 0;
}

BOOL VTP_R8_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return VTP_R8_Compare( pv1, pv2 ) > 0;
}

BOOL VTP_R8_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return VTP_R8_Compare( pv1, pv2 ) == 0;
}

BOOL VTP_R8_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return VTP_R8_Compare( pv1, pv2 ) != 0;
}

//
// VTP_BSTR
//

int VTP_BSTR_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    BSTR const pxv1 = *(BSTR*)pv1;
    BSTR const pxv2 = *(BSTR*)pv2;

    ULONG len = BSTRLEN(pxv1);
    if ( BSTRLEN(pxv2) < len )
        len = BSTRLEN(pxv2);

    int iCmp = _wcsnicmp( pxv1, pxv2, len / sizeof (OLECHAR) );

    if ( iCmp != 0 || BSTRLEN(pxv1) == BSTRLEN(pxv2) )
        return( iCmp );

    if ( BSTRLEN(pxv1) > BSTRLEN(pxv2) )
        return( 1 );
    else
        return( -1 );
}

BOOL VTP_BSTR_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return( VTP_BSTR_Compare( pv1, pv2 ) < 0 );
}

BOOL VTP_BSTR_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return( VTP_BSTR_Compare( pv1, pv2 ) <= 0 );
}

BOOL VTP_BSTR_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return( VTP_BSTR_Compare( pv1, pv2 ) >= 0 );
}

BOOL VTP_BSTR_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return( VTP_BSTR_Compare( pv1, pv2 ) > 0 );
}

BOOL VTP_BSTR_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    BSTR const pxv1 = *(BSTR*)pv1;
    BSTR const pxv2 = *(BSTR*)pv2;

    return( BSTRLEN(pxv1) == BSTRLEN(pxv2) &&
            _wcsnicmp( pxv1, pxv2, BSTRLEN(pxv1) / sizeof (OLECHAR) ) == 0 );
}

BOOL VTP_BSTR_NE( BYTE const *pv1, BYTE const *pv2 )
{
    BSTR const pxv1 = *(BSTR*)pv1;
    BSTR const pxv2 = *(BSTR*)pv2;

    return( BSTRLEN(pxv1) != BSTRLEN(pxv2) ||
            _wcsnicmp( pxv1, pxv2, BSTRLEN(pxv1) / sizeof (OLECHAR) ) != 0 );
}

//
// VTP_BOOL
//

int VTP_BOOL_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    if ((*(VARIANT_BOOL *) pv1) == 0)
        if ((*(VARIANT_BOOL *) pv2) == 0)
            return( 0 );
        else
            return( -1 );
    else
        if ((*(VARIANT_BOOL *) pv2) == 0)
            return( 1 );
        else
            return( 0 );
}

BOOL VTP_BOOL_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( ( ((*(VARIANT_BOOL *) pv1)==0) && ((*(VARIANT_BOOL *) pv2)==0) ) ||
            ( ((*(VARIANT_BOOL *) pv1)!=0) && ((*(VARIANT_BOOL *) pv2)!=0) ) );

}

BOOL VTP_BOOL_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( !VTP_BOOL_EQ( pv1, pv2 ) );
}

//
// VTP_VARIANT
//

int VTP_VARIANT_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    return VT_VARIANT_Compare( * (PROPVARIANT *) pv1, * (PROPVARIANT *) pv2 );
}

BOOL VTP_VARIANT_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return VT_VARIANT_LT( * (PROPVARIANT *) pv1, * (PROPVARIANT *) pv2 );
}

BOOL VTP_VARIANT_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return VT_VARIANT_LE( * (PROPVARIANT *) pv1, * (PROPVARIANT *) pv2 );
}

BOOL VTP_VARIANT_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return VT_VARIANT_GE( * (PROPVARIANT *) pv1, * (PROPVARIANT *) pv2 );
}

BOOL VTP_VARIANT_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return VT_VARIANT_GT( * (PROPVARIANT *) pv1, * (PROPVARIANT *) pv2 );
}

BOOL VTP_VARIANT_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return VT_VARIANT_EQ( * (PROPVARIANT *) pv1, * (PROPVARIANT *) pv2 );
}

BOOL VTP_VARIANT_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return VT_VARIANT_NE( * (PROPVARIANT *) pv1, * (PROPVARIANT *) pv2 );
}

//
// VTP_DECIMAL
//

int VTP_DEC_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    PROPVARIANT v1;
    RtlCopyMemory( &v1, pv1, sizeof DECIMAL );
    v1.vt = VT_DECIMAL;

    PROPVARIANT v2;
    RtlCopyMemory( &v2, pv2, sizeof DECIMAL );
    v2.vt = VT_DECIMAL;

    return VT_DEC_Compare( v1, v2 );
}

BOOL VTP_DEC_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return ( VTP_DEC_Compare( pv1, pv2 ) < 0 );
}

BOOL VTP_DEC_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return ( VTP_DEC_Compare( pv1, pv2 ) <= 0 );
}

BOOL VTP_DEC_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return ( VTP_DEC_Compare( pv1, pv2 ) >= 0 );
}

BOOL VTP_DEC_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return ( VTP_DEC_Compare( pv1, pv2 ) > 0 );
}

BOOL VTP_DEC_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return ( VTP_DEC_Compare( pv1, pv2 ) == 0 );
}

BOOL VTP_DEC_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return ( VTP_DEC_Compare( pv1, pv2 ) != 0 );
}

//
// VTP_I1
//

int VTP_I1_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(signed char *) pv1) - (*(signed char *) pv2) );
}

BOOL VTP_I1_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(signed char *) pv1) < (*(signed char *) pv2) );
}

BOOL VTP_I1_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(signed char *) pv1) <= (*(signed char *) pv2) );
}

BOOL VTP_I1_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(signed char *) pv1) >= (*(signed char *) pv2) );
}

BOOL VTP_I1_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(signed char *) pv1) > (*(signed char *) pv2) );
}

BOOL VTP_I1_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(signed char *) pv1) == (*(signed char *) pv2) );
}

BOOL VTP_I1_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(signed char *) pv1) != (*(signed char *) pv2) );
}

BOOL VTP_I1_AllBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((*(signed char *) pv1) & (*(signed char *) pv2)) == (*(signed char *) pv2) );
}

BOOL VTP_I1_SomeBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((*(signed char *) pv1) & (*(signed char *) pv2)) != 0 );
}

//
// VTP_UI1
//

int VTP_UI1_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(unsigned char *) pv1) - (*(unsigned char *) pv2) );
}

BOOL VTP_UI1_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(unsigned char *) pv1) < (*(unsigned char *) pv2) );
}

BOOL VTP_UI1_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(unsigned char *) pv1) <= (*(unsigned char *) pv2) );
}

BOOL VTP_UI1_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(unsigned char *) pv1) >= (*(unsigned char *) pv2) );
}

BOOL VTP_UI1_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(unsigned char *) pv1) > (*(unsigned char *) pv2) );
}

BOOL VTP_UI1_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(unsigned char *) pv1) == (*(unsigned char *) pv2) );
}

BOOL VTP_UI1_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(unsigned char *) pv1) != (*(unsigned char *) pv2) );
}

BOOL VTP_UI1_AllBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((*(unsigned char *) pv1) & (*(unsigned char *) pv2)) == (*(unsigned char *) pv2) );
}

BOOL VTP_UI1_SomeBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((*(unsigned char *) pv1) & (*(unsigned char *) pv2)) != 0 );
}

//
// VTP_UI2
//

int VTP_UI2_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(USHORT *) pv1) - (*(USHORT *) pv2) );
}

BOOL VTP_UI2_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(USHORT *) pv1) < (*(USHORT *) pv2) );
}

BOOL VTP_UI2_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(USHORT *) pv1) <= (*(USHORT *) pv2) );
}

BOOL VTP_UI2_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(USHORT *) pv1) >= (*(USHORT *) pv2) );
}

BOOL VTP_UI2_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(USHORT *) pv1) > (*(USHORT *) pv2) );
}

BOOL VTP_UI2_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(USHORT *) pv1) == (*(USHORT *) pv2) );
}

BOOL VTP_UI2_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(USHORT *) pv1) != (*(USHORT *) pv2) );
}

BOOL VTP_UI2_AllBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((*(USHORT *) pv1) & (*(USHORT *) pv2)) == (*(USHORT *) pv2) );
}

BOOL VTP_UI2_SomeBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((*(USHORT *) pv1) & (*(USHORT *) pv2)) != 0 );
}

//
// VTP_UI4
//

int VTP_UI4_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    ULONG ul1 = * (ULONG *) pv1;
    ULONG ul2 = * (ULONG *) pv2;

    return ( ul1 > ul2 ) ? 1 : ( ul1 < ul2 ) ? -1 : 0;
}

BOOL VTP_UI4_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(ULONG *) pv1) < (*(ULONG *) pv2) );
}

BOOL VTP_UI4_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(ULONG *) pv1) <= (*(ULONG *) pv2) );
}

BOOL VTP_UI4_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(ULONG *) pv1) >= (*(ULONG *) pv2) );
}

BOOL VTP_UI4_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(ULONG *) pv1) > (*(ULONG *) pv2) );
}

BOOL VTP_UI4_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(ULONG *) pv1) == (*(ULONG *) pv2) );
}

BOOL VTP_UI4_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(ULONG *) pv1) != (*(ULONG *) pv2) );
}

BOOL VTP_UI4_AllBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((*(ULONG *) pv1) & (*(ULONG *) pv2)) == (*(ULONG *) pv2) );
}

BOOL VTP_UI4_SomeBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((*(ULONG *) pv1) & (*(ULONG *) pv2)) != 0 );
}

//
// VTP_I8
//

int VTP_I8_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(LONGLONG *) pv1) >  (*(LONGLONG *) pv2) ? 1 :
            (*(LONGLONG *) pv1) == (*(LONGLONG *) pv2) ? 0 :
            -1 );
}

BOOL VTP_I8_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(LONGLONG *) pv1) < (*(LONGLONG *) pv2) );
}

BOOL VTP_I8_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(LONGLONG *) pv1) <= (*(LONGLONG *) pv2) );

}

BOOL VTP_I8_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(LONGLONG *) pv1) >= (*(LONGLONG *) pv2) );
}

BOOL VTP_I8_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(LONGLONG *) pv1) > (*(LONGLONG *) pv2) );
}

BOOL VTP_I8_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(LONGLONG *) pv1) == (*(LONGLONG *) pv2) );
}

BOOL VTP_I8_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(LONGLONG *) pv1) != (*(LONGLONG *) pv2) );
}

BOOL VTP_I8_AllBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((*(LONGLONG *) pv1) & (*(LONGLONG *) pv2)) == (*(LONGLONG *) pv2) );
}

BOOL VTP_I8_SomeBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((*(LONGLONG *) pv1) & (*(LONGLONG *) pv2)) != 0 );
}

//
// VTP_UI8
//

int VTP_UI8_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(ULONGLONG *) pv1) >  (*(ULONGLONG *) pv2) ? 1 :
            (*(ULONGLONG *) pv1) == (*(ULONGLONG *) pv2) ? 0 :
            -1 );
}

BOOL VTP_UI8_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(ULONGLONG *) pv1) < (*(ULONGLONG *) pv2) );
}

BOOL VTP_UI8_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(ULONGLONG *) pv1) <= (*(ULONGLONG *) pv2) );

}

BOOL VTP_UI8_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(ULONGLONG *) pv1) >= (*(ULONGLONG *) pv2) );
}

BOOL VTP_UI8_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(ULONGLONG *) pv1) > (*(ULONGLONG *) pv2) );
}

BOOL VTP_UI8_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(ULONGLONG *) pv1) == (*(ULONGLONG *) pv2) );
}

BOOL VTP_UI8_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(ULONGLONG *) pv1) != (*(ULONGLONG *) pv2) );
}

BOOL VTP_UI8_AllBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((*(ULONGLONG *) pv1) & (*(ULONGLONG *) pv2)) == (*(ULONGLONG *) pv2) );
}

BOOL VTP_UI8_SomeBits( BYTE const *pv1, BYTE const *pv2 )
{
    return( ((*(ULONGLONG *) pv1) & (*(ULONGLONG *) pv2)) != 0 );
}

//
// VTP_LPSTR
//

int VTP_LPSTR_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    return ( _stricmp( (*(char **) pv1), (*(char **) pv2) ) );
}

BOOL VTP_LPSTR_LT( BYTE const *pv1, BYTE const *pv2 )
{
    int rc = _stricmp( (*(char **) pv1), (*(char **) pv2) );

    return( rc < 0 );
}

BOOL VTP_LPSTR_LE( BYTE const *pv1, BYTE const *pv2 )
{
    int rc = _stricmp( (*(char **) pv1), (*(char **) pv2) );

    return( rc <= 0 );
}

BOOL VTP_LPSTR_GE( BYTE const *pv1, BYTE const *pv2 )
{
    int rc = _stricmp( (*(char **) pv1), (*(char **) pv2) );

    return( rc >= 0 );
}

BOOL VTP_LPSTR_GT( BYTE const *pv1, BYTE const *pv2 )
{
    int rc = _stricmp( (*(char **) pv1), (*(char **) pv2) );

    return( rc > 0 );
}

BOOL VTP_LPSTR_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( _stricmp( (*(char **) pv1), (*(char **) pv2) ) == 0 );
}

BOOL VTP_LPSTR_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( _stricmp( (*(char **) pv1), (*(char **) pv2) ) != 0 );
}


//
// VTP_LPWSTR
//

int VTP_LPWSTR_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    int rc = CompareStringW( LOCALE_SYSTEM_DEFAULT,
                             NORM_IGNORECASE,
                             (*(WCHAR **) pv1),
                             -1,
                             (*(WCHAR **) pv2),
                             -1 );

    //
    // rc == 1, means less than
    // rc == 2, means equal
    // rc == 3, means greater than
    //
    return rc - 2;
}

BOOL VTP_LPWSTR_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return ( VTP_LPWSTR_Compare( pv1, pv2 ) < 0 );
}

BOOL VTP_LPWSTR_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return ( VTP_LPWSTR_Compare( pv1, pv2 ) <= 0 );
}

BOOL VTP_LPWSTR_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return ( VTP_LPWSTR_Compare( pv1, pv2 ) >= 0 );
}

BOOL VTP_LPWSTR_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return ( VTP_LPWSTR_Compare( pv1, pv2 ) > 0 );
}

BOOL VTP_LPWSTR_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return ( VTP_LPWSTR_Compare( pv1, pv2 ) == 0 );
}

BOOL VTP_LPWSTR_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return ( VTP_LPWSTR_Compare( pv1, pv2 ) != 0 );
}

//
// VTP_BLOB
//

int VTP_BLOB_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    ULONG len = (*(BLOB **) pv1)->cbSize;
    if ( (*(BLOB **) pv2)->cbSize < len )
        len = (*(BLOB **) pv2)->cbSize;

    int iCmp = memcmp( (*(BLOB **) pv1)->pBlobData,
                       (*(BLOB **) pv2)->pBlobData,
                       len );

    if ( iCmp != 0 || (*(BLOB **) pv1)->cbSize == (*(BLOB **) pv2)->cbSize )
        return( iCmp );

    if ( (*(BLOB **) pv1)->cbSize > (*(BLOB **) pv2)->cbSize )
        return( 1 );
    else
        return( -1 );
}

BOOL VTP_BLOB_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return( VTP_BLOB_Compare( pv1, pv2 ) < 0 );
}

BOOL VTP_BLOB_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return( VTP_BLOB_Compare( pv1, pv2 ) <= 0 );
}

BOOL VTP_BLOB_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return( VTP_BLOB_Compare( pv1, pv2 ) >= 0 );
}

BOOL VTP_BLOB_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return( VTP_BLOB_Compare( pv1, pv2 ) > 0 );
}

BOOL VTP_BLOB_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(BLOB **) pv1)->cbSize == (*(BLOB **) pv2)->cbSize &&
            memcmp( (*(BLOB **) pv1)->pBlobData,
                    (*(BLOB **) pv2)->pBlobData,
                    (*(BLOB **) pv1)->cbSize ) == 0 );
}

BOOL VTP_BLOB_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (*(BLOB **) pv1)->cbSize != (*(BLOB **) pv2)->cbSize ||
            memcmp( (*(BLOB **) pv1)->pBlobData,
                      (*(BLOB **) pv2)->pBlobData,
                      (*(BLOB **) pv1)->cbSize ) != 0 );
}

//
// VTP_CF
//

int VTP_CF_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    if ( (* (CLIPDATA **) pv1)->ulClipFmt != (* (CLIPDATA **) pv2)->ulClipFmt )
    {
        return( (* (CLIPDATA **) pv1)->ulClipFmt - (* (CLIPDATA **) pv2)->ulClipFmt );
    }

    ULONG len = CBPCLIPDATA( **(CLIPDATA **) pv1 );

    if ( CBPCLIPDATA( **(CLIPDATA **) pv2 ) < len )
        len = CBPCLIPDATA( **(CLIPDATA **) pv2 );

    int iCmp = memcmp( (* (CLIPDATA **) pv1)->pClipData,
                       (* (CLIPDATA **) pv2)->pClipData,
                       len );

    if ( iCmp != 0 || (* (CLIPDATA **) pv1)->cbSize == (* (CLIPDATA **) pv2)->cbSize)
        return( iCmp );

    if ( (* (CLIPDATA **) pv1)->cbSize > (* (CLIPDATA **) pv2)->cbSize )
        return( 1 );
    else
        return( -1 );
}

BOOL VTP_CF_LT( BYTE const *pv1, BYTE const *pv2 )
{
    return( VTP_CF_Compare( pv1, pv2 ) < 0 );
}

BOOL VTP_CF_LE( BYTE const *pv1, BYTE const *pv2 )
{
    return( VTP_CF_Compare( pv1, pv2 ) <= 0 );
}

BOOL VTP_CF_GE( BYTE const *pv1, BYTE const *pv2 )
{
    return( VTP_CF_Compare( pv1, pv2 ) >= 0 );
}

BOOL VTP_CF_GT( BYTE const *pv1, BYTE const *pv2 )
{
    return( VTP_CF_Compare( pv1, pv2 ) > 0 );
}

BOOL VTP_CF_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( (* (CLIPDATA **) pv1)->ulClipFmt == (* (CLIPDATA **) pv2)->ulClipFmt &&
            (* (CLIPDATA **) pv1)->cbSize == (* (CLIPDATA **) pv2)->cbSize &&
            memcmp( (* (CLIPDATA **) pv1)->pClipData,
                    (* (CLIPDATA **) pv2)->pClipData,
                    CBPCLIPDATA( **(CLIPDATA **) pv1 )) == 0 );
}

BOOL VTP_CF_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( (* (CLIPDATA **) pv1)->ulClipFmt != (* (CLIPDATA **) pv2)->ulClipFmt &&
            (* (CLIPDATA **) pv1)->cbSize != (* (CLIPDATA **) pv2)->cbSize ||
            memcmp( (* (CLIPDATA **) pv1)->pClipData,
                    (* (CLIPDATA **) pv2)->pClipData,
                    CBPCLIPDATA( **(CLIPDATA **) pv1 )) != 0 );
}

//
// VTP_CLSID.  V means vector ( a pointer to a guid )
//             S meand singleton ( a pointer to a pointer to a guid )
//

int VTP_VV_CLSID_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    return( memcmp( pv1, pv2, sizeof GUID ) );
}

int VTP_VS_CLSID_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    return( memcmp( pv1, (* (CLSID __RPC_FAR * *) pv2), sizeof GUID ) );
}

int VTP_SV_CLSID_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    return( memcmp( (* (CLSID __RPC_FAR * *) pv1), pv2, sizeof GUID ) );
}

int VTP_SS_CLSID_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    return( memcmp( (* (CLSID __RPC_FAR * *) pv1), (* (CLSID __RPC_FAR * *) pv2), sizeof GUID ) );
}

BOOL VTP_SS_CLSID_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( memcmp( (* (CLSID __RPC_FAR * *) pv1), (* (CLSID __RPC_FAR * *) pv2), sizeof GUID ) == 0 );
}

BOOL VTP_SS_CLSID_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( memcmp( (* (CLSID __RPC_FAR * *) pv1), (* (CLSID __RPC_FAR * *) pv2), sizeof GUID ) != 0 );
}

BOOL VTP_VV_CLSID_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( memcmp( pv1, pv2, sizeof GUID ) == 0 );
}

BOOL VTP_VV_CLSID_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( memcmp( pv1, pv2, sizeof GUID ) != 0 );
}

BOOL VTP_VS_CLSID_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( memcmp( pv1, (* (CLSID __RPC_FAR * *) pv2), sizeof GUID ) == 0 );
}

BOOL VTP_VS_CLSID_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( memcmp( pv1, (* (CLSID __RPC_FAR * *) pv2), sizeof GUID ) != 0 );
}

BOOL VTP_SV_CLSID_EQ( BYTE const *pv1, BYTE const *pv2 )
{
    return( memcmp( (* (CLSID __RPC_FAR * *) pv1), pv2, sizeof GUID ) == 0 );
}

BOOL VTP_SV_CLSID_NE( BYTE const *pv1, BYTE const *pv2 )
{
    return( memcmp( (* (CLSID __RPC_FAR * *) pv1), pv2, sizeof GUID ) != 0 );
}

/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////

ULONG const CComparators::_iStart = VT_EMPTY;

CComparators::SComparators const CComparators::_aVariantComparators[] = {
    // VT_EMPTY
    { VT_EMPTY_Compare, VTP_EMPTY_Compare,
      { 0,
        0,
        0,
        0,
        VT_EMPTY_EQ,
        VT_EMPTY_NE,
        0,
        0,
        0 },
      { 0,
        0,
        0,
        0,
        VTP_EMPTY_EQ,
        VTP_EMPTY_NE,
        0,
        0,
        0 },
    },

    // VT_NULL
    { VT_NULL_Compare, VTP_NULL_Compare,
      { 0,
        0,
        0,
        0,
        VT_NULL_EQ,
        VT_NULL_NE,
        0,
        0,
        0 },
      { 0,
        0,
        0,
        0,
        VTP_NULL_EQ,
        VTP_NULL_NE,
        0,
        0,
        0 },
    },

    // VT_I2
    { VT_I2_Compare, VTP_I2_Compare,
      { VT_I2_LT,
        VT_I2_LE,
        VT_I2_GT,
        VT_I2_GE,
        VT_I2_EQ,
        VT_I2_NE,
        0,
        VT_I2_AllBits,
        VT_I2_SomeBits
      },
      { VTP_I2_LT,
        VTP_I2_LE,
        VTP_I2_GT,
        VTP_I2_GE,
        VTP_I2_EQ,
        VTP_I2_NE,
        0,
        VTP_I2_AllBits,
        VTP_I2_SomeBits
      },
    },

    // VT_I4
    { VT_I4_Compare, VTP_I4_Compare,
      { VT_I4_LT,
        VT_I4_LE,
        VT_I4_GT,
        VT_I4_GE,
        VT_I4_EQ,
        VT_I4_NE,
        0,
        VT_I4_AllBits,
        VT_I4_SomeBits
      },
      { VTP_I4_LT,
        VTP_I4_LE,
        VTP_I4_GT,
        VTP_I4_GE,
        VTP_I4_EQ,
        VTP_I4_NE,
        0,
        VTP_I4_AllBits,
        VTP_I4_SomeBits
      },
    },

    // VT_R4
    { VT_R4_Compare, VTP_R4_Compare,
      { VT_R4_LT,
        VT_R4_LE,
        VT_R4_GT,
        VT_R4_GE,
        VT_R4_EQ,
        VT_R4_NE,
        0,
        0,
        0,
      },
      { VTP_R4_LT,
        VTP_R4_LE,
        VTP_R4_GT,
        VTP_R4_GE,
        VTP_R4_EQ,
        VTP_R4_NE,
        0,
        0,
        0,
      },
    },

    // VT_R8
    { VT_R8_Compare, VTP_R8_Compare,
      { VT_R8_LT,
        VT_R8_LE,
        VT_R8_GT,
        VT_R8_GE,
        VT_R8_EQ,
        VT_R8_NE,
        0,
        0,
        0,
      },
      { VTP_R8_LT,
        VTP_R8_LE,
        VTP_R8_GT,
        VTP_R8_GE,
        VTP_R8_EQ,
        VTP_R8_NE,
        0,
        0,
        0,
      },
    },

    // VT_CY
    { VT_I8_Compare, VTP_I8_Compare,
      { VT_I8_LT,
        VT_I8_LE,
        VT_I8_GT,
        VT_I8_GE,
        VT_I8_EQ,
        VT_I8_NE,
        0,
        0,
        0
      },
      { VTP_I8_LT,
        VTP_I8_LE,
        VTP_I8_GT,
        VTP_I8_GE,
        VTP_I8_EQ,
        VTP_I8_NE,
        0,
        0,
        0
      },
    },

    // VT_DATE
    { VT_R8_Compare, VTP_R8_Compare,
      { VT_R8_LT,
        VT_R8_LE,
        VT_R8_GT,
        VT_R8_GE,
        VT_R8_EQ,
        VT_R8_NE,
        0,
        0,
        0,
      },
      { VTP_R8_LT,
        VTP_R8_LE,
        VTP_R8_GT,
        VTP_R8_GE,
        VTP_R8_EQ,
        VTP_R8_NE,
        0,
        0,
        0,
      },
    },

    // VT_BSTR
    { VT_BSTR_Compare, VTP_BSTR_Compare,
      { VT_BSTR_LT,
        VT_BSTR_LE,
        VT_BSTR_GT,
        VT_BSTR_GE,
        VT_BSTR_EQ,
        VT_BSTR_NE,
        0,
        0,
        0
      },
      { VTP_BSTR_LT,
        VTP_BSTR_LE,
        VTP_BSTR_GT,
        VTP_BSTR_GE,
        VTP_BSTR_EQ,
        VTP_BSTR_NE,
        0,
        0,
        0
      },
    },

    // VT_DISPATCH
    { 0, 0,
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    },

    // VT_ERROR
    { VT_I4_Compare, VTP_I4_Compare,
      { VT_I4_LT,
        VT_I4_LE,
        VT_I4_GT,
        VT_I4_GE,
        VT_I4_EQ,
        VT_I4_NE,
        0,
        VT_I4_AllBits,
        VT_I4_SomeBits
      },
      { VTP_I4_LT,
        VTP_I4_LE,
        VTP_I4_GT,
        VTP_I4_GE,
        VTP_I4_EQ,
        VTP_I4_NE,
        0,
        VTP_I4_AllBits,
        VTP_I4_SomeBits
      },
    },

    // VT_BOOL
    { VT_BOOL_Compare, VTP_BOOL_Compare,
      { 0,
        0,
        0,
        0,
        VT_BOOL_EQ,
        VT_BOOL_NE,
        0,
        0,
        0
      },
      { 0,
        0,
        0,
        0,
        VTP_BOOL_EQ,
        VTP_BOOL_NE,
        0,
        0,
        0
      },
    },

    // VT_VARIANT
    { VT_VARIANT_Compare, VTP_VARIANT_Compare,
      { VT_VARIANT_LT,
        VT_VARIANT_LE,
        VT_VARIANT_GT,
        VT_VARIANT_GE,
        VT_VARIANT_EQ,
        VT_VARIANT_NE,
        0,
        0,
        0,
      },
      { VTP_VARIANT_LT,
        VTP_VARIANT_LE,
        VTP_VARIANT_GT,
        VTP_VARIANT_GE,
        VTP_VARIANT_EQ,
        VTP_VARIANT_NE,
        0,
        0,
        0,
      },
    },

    // VT_UNKNOWN
    { 0, 0,
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    },

    // VT_DECIMAL
    { VT_DEC_Compare, VTP_DEC_Compare,
      { VT_DEC_LT,
        VT_DEC_LE,
        VT_DEC_GT,
        VT_DEC_GE,
        VT_DEC_EQ,
        VT_DEC_NE,
        0,
        0,
        0
      },
      { VTP_DEC_LT,
        VTP_DEC_LE,
        VTP_DEC_GT,
        VTP_DEC_GE,
        VTP_DEC_EQ,
        VTP_DEC_NE,
        0,
        0,
        0
      },
    },

    // VARENUM value 15 unused
    { 0, 0,
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    },

    // VT_I1
    { VT_I1_Compare, VTP_I1_Compare,
      { VT_I1_LT,
        VT_I1_LE,
        VT_I1_GT,
        VT_I1_GE,
        VT_I1_EQ,
        VT_I1_NE,
        0,
        VT_I1_AllBits,
        VT_I1_SomeBits
      },
      { VTP_I1_LT,
        VTP_I1_LE,
        VTP_I1_GT,
        VTP_I1_GE,
        VTP_I1_EQ,
        VTP_I1_NE,
        0,
        VTP_I1_AllBits,
        VTP_I1_SomeBits
      },
    },

    // VT_UI1
    { VT_UI1_Compare, VTP_UI1_Compare,
      { VT_UI1_LT,
        VT_UI1_LE,
        VT_UI1_GT,
        VT_UI1_GE,
        VT_UI1_EQ,
        VT_UI1_NE,
        0,
        VT_UI1_AllBits,
        VT_UI1_SomeBits
      },
      { VTP_UI1_LT,
        VTP_UI1_LE,
        VTP_UI1_GT,
        VTP_UI1_GE,
        VTP_UI1_EQ,
        VTP_UI1_NE,
        0,
        VTP_UI1_AllBits,
        VTP_UI1_SomeBits
      },
    },

    // VT_UI2
    { VT_UI2_Compare, VTP_UI2_Compare,
      { VT_UI2_LT,
        VT_UI2_LE,
        VT_UI2_GT,
        VT_UI2_GE,
        VT_UI2_EQ,
        VT_UI2_NE,
        0,
        VT_UI2_AllBits,
        VT_UI2_SomeBits
      },
      { VTP_UI2_LT,
        VTP_UI2_LE,
        VTP_UI2_GT,
        VTP_UI2_GE,
        VTP_UI2_EQ,
        VTP_UI2_NE,
        0,
        VTP_UI2_AllBits,
        VTP_UI2_SomeBits
      },
    },

    // VT_UI4
    { VT_UI4_Compare, VTP_UI4_Compare,
      { VT_UI4_LT,
        VT_UI4_LE,
        VT_UI4_GT,
        VT_UI4_GE,
        VT_UI4_EQ,
        VT_UI4_NE,
        0,
        VT_UI4_AllBits,
        VT_UI4_SomeBits
      },
      { VTP_UI4_LT,
        VTP_UI4_LE,
        VTP_UI4_GT,
        VTP_UI4_GE,
        VTP_UI4_EQ,
        VTP_UI4_NE,
        0,
        VTP_UI4_AllBits,
        VTP_UI4_SomeBits
      },
    },

    // VT_I8
    { VT_I8_Compare, VTP_I8_Compare,
      { VT_I8_LT,
        VT_I8_LE,
        VT_I8_GT,
        VT_I8_GE,
        VT_I8_EQ,
        VT_I8_NE,
        0,
        VT_I8_AllBits,
        VT_I8_SomeBits
      },
      { VTP_I8_LT,
        VTP_I8_LE,
        VTP_I8_GT,
        VTP_I8_GE,
        VTP_I8_EQ,
        VTP_I8_NE,
        0,
        VTP_I8_AllBits,
        VTP_I8_SomeBits
      },
    },

    // VT_UI8
    { VT_UI8_Compare, VTP_UI8_Compare,
      { VT_UI8_LT,
        VT_UI8_LE,
        VT_UI8_GT,
        VT_UI8_GE,
        VT_UI8_EQ,
        VT_UI8_NE,
        0,
        VT_UI8_AllBits,
        VT_UI8_SomeBits
      },
      { VTP_UI8_LT,
        VTP_UI8_LE,
        VTP_UI8_GT,
        VTP_UI8_GE,
        VTP_UI8_EQ,
        VTP_UI8_NE,
        0,
        VTP_UI8_AllBits,
        VTP_UI8_SomeBits
      },
    },

    // VT_INT
    { VT_I4_Compare, VTP_I4_Compare,
      { VT_I4_LT,
        VT_I4_LE,
        VT_I4_GT,
        VT_I4_GE,
        VT_I4_EQ,
        VT_I4_NE,
        0,
        VT_I4_AllBits,
        VT_I4_SomeBits
      },
      { VTP_I4_LT,
        VTP_I4_LE,
        VTP_I4_GT,
        VTP_I4_GE,
        VTP_I4_EQ,
        VTP_I4_NE,
        0,
        VTP_I4_AllBits,
        VTP_I4_SomeBits
      },
    },

    // VT_UINT
    { VT_UI4_Compare, VTP_UI4_Compare,
      { VT_UI4_LT,
        VT_UI4_LE,
        VT_UI4_GT,
        VT_UI4_GE,
        VT_UI4_EQ,
        VT_UI4_NE,
        0,
        VT_UI4_AllBits,
        VT_UI4_SomeBits
      },
      { VTP_UI4_LT,
        VTP_UI4_LE,
        VTP_UI4_GT,
        VTP_UI4_GE,
        VTP_UI4_EQ,
        VTP_UI4_NE,
        0,
        VTP_UI4_AllBits,
        VTP_UI4_SomeBits
      },
    },

    // VT_VOID
    { 0, 0,
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    },

    // VT_HRESULT
    { VT_I4_Compare, VTP_I4_Compare,
      { VT_I4_LT,
        VT_I4_LE,
        VT_I4_GT,
        VT_I4_GE,
        VT_I4_EQ,
        VT_I4_NE,
        0,
        VT_I4_AllBits,
        VT_I4_SomeBits
      },
      { VTP_I4_LT,
        VTP_I4_LE,
        VTP_I4_GT,
        VTP_I4_GE,
        VTP_I4_EQ,
        VTP_I4_NE,
        0,
        VTP_I4_AllBits,
        VTP_I4_SomeBits
      },
    },

    // VT_PTR
    { 0, 0,
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    },

    // VT_SAFEARRAY
    { 0, 0,
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    },

    // VT_CARRAY
    { 0, 0,
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    },

    // VT_USERDEFINED
    { 0, 0,
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    },

    // VT_LPSTR
    { VT_LPSTR_Compare, VTP_LPSTR_Compare,
      { VT_LPSTR_LT,
        VT_LPSTR_LE,
        VT_LPSTR_GT,
        VT_LPSTR_GE,
        VT_LPSTR_EQ,
        VT_LPSTR_NE,
        0,
        0,
        0
      },
      { VTP_LPSTR_LT,
        VTP_LPSTR_LE,
        VTP_LPSTR_GT,
        VTP_LPSTR_GE,
        VTP_LPSTR_EQ,
        VTP_LPSTR_NE,
        0,
        0,
        0
      },
    },

    // VT_LPWSTR
    { VT_LPWSTR_Compare, VTP_LPWSTR_Compare,
      { VT_LPWSTR_LT,
        VT_LPWSTR_LE,
        VT_LPWSTR_GT,
        VT_LPWSTR_GE,
        VT_LPWSTR_EQ,
        VT_LPWSTR_NE,
        0,
        0,
        0
      },
      { VTP_LPWSTR_LT,
        VTP_LPWSTR_LE,
        VTP_LPWSTR_GT,
        VTP_LPWSTR_GE,
        VTP_LPWSTR_EQ,
        VTP_LPWSTR_NE,
        0,
        0,
        0
      },
    }
};

ULONG const CComparators::_cVariantComparators =
    sizeof(CComparators::_aVariantComparators) /
    sizeof(CComparators::_aVariantComparators[0]);

ULONG const CComparators::_iStart2 = VT_FILETIME;

CComparators::SComparators const CComparators::_aVariantComparators2[] = {
    // VT_FILETIME
    { VT_UI8_Compare, VTP_UI8_Compare,
      { VT_UI8_LT,
        VT_UI8_LE,
        VT_UI8_GT,
        VT_UI8_GE,
        VT_UI8_EQ,
        VT_UI8_NE,
        0,
        0,
        0
      },
      { VTP_UI8_LT,
        VTP_UI8_LE,
        VTP_UI8_GT,
        VTP_UI8_GE,
        VTP_UI8_EQ,
        VTP_UI8_NE,
        0,
        0,
        0
      },
    },

    // VT_BLOB
    { VT_BLOB_Compare, VTP_BLOB_Compare,
      { VT_BLOB_LT,
        VT_BLOB_LE,
        VT_BLOB_GT,
        VT_BLOB_GE,
        VT_BLOB_EQ,
        VT_BLOB_NE,
        0,
        0,
        0
      },
      { VTP_BLOB_LT,
        VTP_BLOB_LE,
        VTP_BLOB_GT,
        VTP_BLOB_GE,
        VTP_BLOB_EQ,
        VTP_BLOB_NE,
        0,
        0,
        0
      },
    },

    // VT_STREAM
    { 0, 0,
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    },

    // VT_STORAGE
    { 0, 0,
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    },

    // VT_STREAMED_OBJECT
    { 0, 0,
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    },

    // VT_STORED_OBJECT
    { 0, 0,
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    },

    // VT_BLOB_OBJECT
    { VT_BLOB_Compare, VTP_BLOB_Compare,
      { VT_BLOB_LT,
        VT_BLOB_LE,
        VT_BLOB_GT,
        VT_BLOB_GE,
        VT_BLOB_EQ,
        VT_BLOB_NE,
        0,
        0,
        0
      },
      { VTP_BLOB_LT,
        VTP_BLOB_LE,
        VTP_BLOB_GT,
        VTP_BLOB_GE,
        VTP_BLOB_EQ,
        VTP_BLOB_NE,
        0,
        0,
        0
      },
    },

    // VT_CF
    { VT_CF_Compare, VTP_CF_Compare,
      { VT_CF_LT,
        VT_CF_LE,
        VT_CF_GT,
        VT_CF_GE,
        VT_CF_EQ,
        VT_CF_NE,
        0,
        0,
        0
      },
      { VTP_CF_LT,
        VTP_CF_LE,
        VTP_CF_GT,
        VTP_CF_GE,
        VTP_CF_EQ,
        VTP_CF_NE,
        0,
        0,
        0
      },
    },

    // VT_CLSID
    { VT_CLSID_Compare, 0, // Vector special-cased in GetPointerComparator
      { 0,
        0,
        0,
        0,
        VT_CLSID_EQ,
        VT_CLSID_NE,
        0,
        0,
        0
      },
      { 0,
        0,
        0,
        0,
        0,     // Special-cased in GetPointerRelop
        0,     // Special-cased in GetPointerRelop
        0,
        0,
        0
      },
    }
};


ULONG const CComparators::_cVariantComparators2 =
    sizeof(CComparators::_aVariantComparators2) /
    sizeof(CComparators::_aVariantComparators2[0]);

ULONG const CComparators::_iStart3 = DBTYPE_BYTES;

CComparators::SComparators const CComparators::_aVariantComparators3[] = {
    // DBTYPE_BYTES
    { 0, 0,
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    },

    // DBTYPE_STR
    { 0, 0,
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    },

    // DBTYPE_WSTR
    { 0, 0,
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
      { 0, 0, 0, 0, 0, 0, 0, 0, 0 },
    }
};

ULONG const CComparators::_cVariantComparators3 =
    sizeof(CComparators::_aVariantComparators3) /
    sizeof(CComparators::_aVariantComparators3[0]);

ULONG const SortDescend = 1;
ULONG const SortNullFirst = 2;

//+-------------------------------------------------------------------------
//
//  Member:     CComparePropSets::Init, public
//
//  Synopsis:   [Re] Initializes property comparator to use a different
//              sort order.
//
//  Arguments:  [cCols]     -- Count of columns
//              [aKey]      -- Sort keys
//              [aColIndex] -- Index of column in sort key
//
//  History:    16-Jun-92 KyleP     Created
//
//--------------------------------------------------------------------------

void CComparePropSets::Init( int cCols,
                             CSortSet const * pSort,
                             int aColIndex[] )
{
    Win4Assert( QUERY_SORTASCEND == 0 );
    Win4Assert( QUERY_SORTDESCEND == SortDescend );
    Win4Assert( (QUERY_SORTXASCEND & SortNullFirst) == SortNullFirst );
    Win4Assert( (QUERY_SORTXDESCEND & SortNullFirst) == SortNullFirst );

    delete _aColComp;
    _aColComp = 0;

    if ( cCols > 0 )
    {
        _cColComp = cCols;
        _aColComp = new SColCompare[ _cColComp ];

        for ( UINT i = 0; i < _cColComp; i++ )
        {
            if (0 == aColIndex)
                _aColComp[i]._iCol = i;
            else
                _aColComp[i]._iCol = aColIndex[i];

            _aColComp[i]._dir = pSort->Get(i).dwOrder;
            _aColComp[i]._DirMult =
                ( ( _aColComp[i]._dir & SortDescend ) != 0 ) ? -1 : 1;
            _aColComp[i]._pt = VT_EMPTY;
            _aColComp[i]._comp = VT_EMPTY_Compare;
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CComparePropSets::Init, public
//
//  Synopsis:   [Re] Initializes property comparator to use a different
//              sort order.  Assumes ascending order.  Mostly useful for
//              equality testing.
//
//  Arguments:  [pCols]     -- Columns
//              [aColIndex] -- Index of column in sort key
//
//  History:    02-Nov-93 KyleP     Created
//
//--------------------------------------------------------------------------

void CComparePropSets::Init( CColumnSet const & cols )
{
    Win4Assert( cols.Size() > 0 );

    delete _aColComp;
    _aColComp = 0;

    _cColComp = cols.Size();
    _aColComp = new SColCompare[ _cColComp ];

    for ( UINT i = 0; i < _cColComp; i++ )
    {
        _aColComp[i]._iCol = i;
        _aColComp[i]._dir = 0;
        _aColComp[i]._DirMult = 1;
        _aColComp[i]._pt = VT_EMPTY;
        _aColComp[i]._comp = VT_EMPTY_Compare;
    }
}


//+-------------------------------------------------------------------------
//
//  Member:     CComparePropSets::Compare, public
//
//  Synopsis:   Compares two rows (property sets).
//
//  Arguments:  [row1] -- First row.
//              [row2] -- Second row.
//
//  Returns:    Column # where row1 > row2 or negative column # where row1
//              < row2 or 0 if row1 = row2.
//              This odd return code is useful for categorization, so it
//              knows the column at which the rows differ.
//
//  History:    27-Jun-96 dlee     Created
//
//--------------------------------------------------------------------------

int CComparePropSets::Compare( PROPVARIANT ** row1, PROPVARIANT ** row2 )
{
    Win4Assert( !IsEmpty() );
    Win4Assert( VT_EMPTY == 0 );
    Win4Assert( VT_NULL == 1 );

    int idiff = 0;

    for ( UINT i = 0; i < _cColComp; i++ )
    {
        ULONG ptRow1 = row1[_aColComp[i]._iCol]->vt;
        ULONG ptRow2 = row2[_aColComp[i]._iCol]->vt;

        //
        // If the property types are incompatible, then 'sort' according
        // to type.  VT_EMPTY and VT_NULL will sort to beginning.
        //

        if ( ptRow1 != ptRow2 )
        {
            idiff = ptRow2 - ptRow1;
            break;
        }

        if ( ptRow1 != _aColComp[i]._pt )
            _UpdateCompare( i, (VARENUM) ptRow1 );

        Win4Assert( _aColComp[i]._comp != 0 );

        idiff = _aColComp[i]._comp( *row1[_aColComp[i]._iCol],
                                    *row2[_aColComp[i]._iCol] ) *
                _aColComp[i]._DirMult;

        if ( 0 != idiff )
            break;
    }

    if ( idiff < 0 )
        return - (int) ( i + 1 );

    if ( idiff > 0 )
        return i + 1;

    return 0;
}

//+-------------------------------------------------------------------------
//
//  Member:     CComparePropSets::IsLT, public
//
//  Synopsis:   Compares two rows (property sets).
//
//  Arguments:  [row1] -- First row.
//              [row2] -- Second row.
//
//  Returns:    TRUE if row1 < row2, FALSE otherwise
//
//  History:    16-Jun-92 KyleP     Created
//
//--------------------------------------------------------------------------

BOOL CComparePropSets::IsLT( PROPVARIANT ** row1, PROPVARIANT ** row2 )
{
    int idiff = Compare( row1, row2 );

    return ( idiff < 0 );
}


//+-------------------------------------------------------------------------
//
//  Member:     CComparePropSets::IsGT, public
//
//  Synopsis:   Compares two rows (property sets).
//
//  Arguments:  [row1] -- First row.
//              [row2] -- Second row.
//
//  Returns:    TRUE if row1 > row2, FALSE otherwise
//
//  History:    16-Jun-92 KyleP     Created
//
//--------------------------------------------------------------------------

BOOL CComparePropSets::IsGT( PROPVARIANT ** row1, PROPVARIANT ** row2 )
{
    int idiff = Compare( row1, row2 );

    return ( idiff > 0 );
}

//+-------------------------------------------------------------------------
//
//  Member:     CComparePropSets::IsEQ, public
//
//  Synopsis:   Compares two rows (property sets).
//
//  Arguments:  [row1] -- First row.
//              [row2] -- Second row.
//
//  Returns:    TRUE if [row1] == [row2].
//
//  History:    02-Nov-93 KyleP     Created
//
//--------------------------------------------------------------------------

BOOL CComparePropSets::IsEQ( PROPVARIANT ** row1, PROPVARIANT ** row2 )
{
    int idiff = Compare( row1, row2 );

    return ( 0 == idiff );
}

//+-------------------------------------------------------------------------
//
//  Member:     CComparePropSets::_UpdateCompare, private
//
//  Effects:    Adds the appropriate comparator for column [iCol].
//
//  Arguments:  [iCol] -- Column to modify.
//              [pt]   -- New property type.
//
//  History:    16-Jun-92 KyleP     Created
//
//--------------------------------------------------------------------------

void CComparePropSets::_UpdateCompare( UINT iCol, VARENUM vt )
{
    _aColComp[iCol]._pt = vt;
    _aColComp[iCol]._comp = VariantCompare.GetComparator( vt );

    if ( 0 == _aColComp[iCol]._comp )
        _aColComp[iCol]._comp = VT_DEFAULT_Compare;
}

inline void ConvertArrayToVector ( PROPVARIANT const & vIn, PROPVARIANT & vOut )
{
    Win4Assert( vIn.vt & VT_ARRAY );
    SAFEARRAY * pSa = vIn.parray;

    ULONG cDataElements = 1;

    for ( unsigned i = 0; i < pSa->cDims; i++ )
    {
        cDataElements *= pSa->rgsabound[i].cElements;
    }
    vOut.vt = (vIn.vt & VT_TYPEMASK) | VT_VECTOR;
    vOut.caub.cElems = cDataElements;
    vOut.caub.pElems = (BYTE *)pSa->pvData;
}


BYTE * _GetNth( PROPVARIANT const & v, unsigned i )
{
    Win4Assert( isVector(v) );
    switch ( getBaseType( v ) )
    {
    case VT_I1 : 
        return (BYTE *) & (v.caub.pElems[i]);
    case VT_UI1 :
        return (BYTE *) & (v.caub.pElems[i]);
    case VT_I2 :
        return (BYTE *) & (v.cai.pElems[i]);
    case VT_UI2 :
        return (BYTE *) & (v.caui.pElems[i]);
    case VT_BOOL :
        return (BYTE *) & (v.cabool.pElems[i]);
    case VT_I4 :
    case VT_INT :
        return (BYTE *) & (v.cal.pElems[i]);
    case VT_UI4 :
    case VT_UINT :
        return (BYTE *) & (v.caul.pElems[i]);
    case VT_R4 :
        return (BYTE *) & (v.caflt.pElems[i]);
    case VT_ERROR :
        return (BYTE *) & (v.cascode.pElems[i]);
    case VT_I8 :
        return (BYTE *) & (v.cah.pElems[i]);
    case VT_UI8 :
        return (BYTE *) & (v.cauh.pElems[i]);
    case VT_R8 :
        return (BYTE *) & (v.cadbl.pElems[i]);
    case VT_CY :
        return (BYTE *) & (v.cacy.pElems[i]);
    case VT_DATE :
        return (BYTE *) & (v.cadate.pElems[i]);
    case VT_FILETIME :
        return (BYTE *) & (v.cafiletime.pElems[i]);
    case VT_CLSID :
        return (BYTE *) & (v.cauuid.pElems[i]);
    case VT_CF :
        return (BYTE *) & (v.caclipdata.pElems[i]);
    case VT_BSTR :
        return (BYTE *) & (v.cabstr.pElems[i]);
    case VT_LPSTR :
        return (BYTE *) & (v.calpstr.pElems[i]);
    case VT_LPWSTR :
        return (BYTE *) & (v.calpwstr.pElems[i]);
    case VT_VARIANT :
        return (BYTE *) & (v.capropvar.pElems[i]);
    case VT_DECIMAL :
        // NOTE: not valid in a vector, but it could occur due to the
        //       simplistic conversion of arrays to vectors.
        DECIMAL * paDec = (DECIMAL *) v.caub.pElems;
        return (BYTE *) (paDec + i);
    }

    Win4Assert(!"illegal base variant type in vector compare");
    return 0;
} //_GetNth

//+-------------------------------------------------------------------------
//
//  Member:     VT_VECTOR_Compare, public
//
//  Effects:    Compares two property values, intended to be called when
//              at least one of the arguments is a vector
//
//  Arguments:  [v1]   -- 1st variant to compare
//              [v2]   -- 2nd variant to compare
//
//  History:    1-May-95 dlee     Created
//
//--------------------------------------------------------------------------

int VT_VECTOR_Compare( PROPVARIANT const & v1In, PROPVARIANT const & v2In )
{
    // must be the same datatype, or just sort on type

    if ( ( v1In.vt != v2In.vt ) )
        return v1In.vt - v2In.vt;

    PROPVARIANT v1 = v1In;
    PROPVARIANT v2 = v2In;

    if ( isArray(v1In) )
    {
        Win4Assert( isArray(v2In) );

        SAFEARRAY * pSa1 = v1In.parray;
        SAFEARRAY * pSa2 = v2In.parray;

        if (pSa1->cDims != pSa2->cDims)
            return pSa1->cDims - pSa2->cDims;

        ULONG cDataElements = 1;

        for ( unsigned i = 0; i < pSa1->cDims; i++ )
        {
            if ( pSa1->rgsabound[i].lLbound != pSa2->rgsabound[i].lLbound )
                return pSa1->rgsabound[i].lLbound - pSa2->rgsabound[i].lLbound;
            if ( pSa1->rgsabound[i].cElements != pSa2->rgsabound[i].cElements )
                return pSa1->rgsabound[i].cElements - pSa2->rgsabound[i].cElements;
            cDataElements *= pSa1->rgsabound[i].cElements;
        }

        //
        // arrays match in type, total size and dimensions.  Compare as vectors.
        //
        v1.vt = v2.vt = (v1In.vt & VT_TYPEMASK) | VT_VECTOR;
        v1.caub.cElems = v2.caub.cElems = cDataElements;
        v1.caub.pElems = (BYTE *)pSa1->pvData;
        v2.caub.pElems = (BYTE *)pSa2->pvData;
    }

    Win4Assert( isVector(v1) );

    FPCmp cmp = VariantCompare.GetPointerComparator( v1, v2 );
    if (0 == cmp)
    {
        // vector of an unhandled type

        ciDebugOut(( DEB_ERROR,
                     "Unknown property type %d (%x) used in comparison.\n",
                     v1.vt, v1.vt ));

        Win4Assert(! "VT_VECTOR_Compare: vector compare of unhandled type" );
        return 0;
    }

    unsigned cMin = __min( v1.cal.cElems, v2.cal.cElems );

    for ( unsigned x = 0; x < cMin; x++ )
    {
        int r = cmp( _GetNth( v1, x), _GetNth( v2, x ) );

        if (0 != r)
            return r;
    }

    // All equal so far up to the minimum cardinality of the vectors.
    // Any difference now would be due to the cardinality.

    return v1.cal.cElems - v2.cal.cElems;
} //VT_VECTOR_Compare

int VTP_VECTOR_Compare( BYTE const *pv1, BYTE const *pv2 )
{
    return VT_VECTOR_Compare( ** (PROPVARIANT **) pv1,
                              ** (PROPVARIANT **) pv2 );
} //VTP_VECTOR_Compare

BOOL VT_VECTOR_LT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_Compare( v1, v2 ) < 0;
} //VT_VECTOR_LT

BOOL VT_VECTOR_LE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_Compare( v1, v2 ) <= 0;
} //VT_VECTOR_LE

BOOL VT_VECTOR_GT( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return ! VT_VECTOR_LE( v1, v2 );
} //VT_VECTOR_GT

BOOL VT_VECTOR_GE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return ! VT_VECTOR_LT( v1, v2 );
} //VT_VECTOR_GE

BOOL VT_VECTOR_EQ( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_Compare( v1, v2 ) == 0;
} //VT_VECTOR_EQ

BOOL VT_VECTOR_NE( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return !VT_VECTOR_EQ( v1, v2 );
} //VT_VECTOR_NE

BOOL VT_VECTOR_Common(
    PROPVARIANT const & v1,
    PROPVARIANT const & v2,
    ULONG relop )
{
    // must be the same datatype and a vector or it doesn't compare.

    if ( ( v1.vt != v2.vt ) || ! isVector( v1 ) )
        return FALSE;

    // must be same cardinality, or it doesn't compare

    if ( v1.cal.cElems != v2.cal.cElems )
        return FALSE;

    FPRel cmp = VariantCompare.GetPointerRelop( v1, v2, relop );

    if ( 0 == cmp )
        return FALSE;

    unsigned cElems = v1.cal.cElems;

    for ( unsigned x = 0; x < cElems; x++ )
    {
        if ( !cmp( _GetNth( v1, x), _GetNth( v2, x ) ) )
            return FALSE;
    }

    return TRUE;
} //VT_VECTOR_Common

BOOL VT_VECTOR_AllBits( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_Common( v1, v2, PRAllBits );
} //VT_VECTOR_AllBits

BOOL VT_VECTOR_SomeBits( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_Common( v1, v2, PRSomeBits );
} //VT_VECTOR_SomeBits

////////////////////////////////////
////////////////////////////////////
////////////////////////////////////

BOOL VT_VECTOR_Any(
    PROPVARIANT const & v1In,
    PROPVARIANT const & v2In,
    ULONG relop )
{
    //
    // Note: first parameter (v1) is the object's property value
    //       second parameter (v2) is the query restriction
    //
    // return TRUE if any element in v1 holds the relation to any v2 element
    //

    // base type of variant must be the same

    if ( getBaseType( v1In ) != getBaseType( v2In ) )
        return FALSE;

    //
    //  If either argument is a safearray, convert it to a vector
    //
    PROPVARIANT v1 = v1In;
    if (isArray(v1))
        ConvertArrayToVector( v1In, v1 );

    PROPVARIANT v2 = v2In;
    if (isArray(v2))
        ConvertArrayToVector( v2In, v2 );

    // first check for two singletons

    if ( ! isVector( v1 ) && ! isVector( v2 ) )
    {
        FRel cmp = VariantCompare.GetRelop( (VARENUM) v1.vt, relop );

        if ( 0 == cmp )
            return FALSE;
        else
            return cmp( v1, v2 );
    }

    // two vectors or singleton+vector -- get a pointer comparator

    FPRel cmp = VariantCompare.GetPointerRelop( v1, v2, relop );

    if ( 0 == cmp )
        return FALSE;

    // check for two vectors

    if ( isVector( v1 ) && isVector( v2 ) )
    {
        for ( unsigned x1 = 0; x1 < v1.cal.cElems; x1++ )
        {
            for ( unsigned x2 = 0; x2 < v2.cal.cElems; x2++ )
            {
                if ( cmp( _GetNth( v1, x1), _GetNth( v2, x2 ) ) )
                    return TRUE;
            }
        }
    }
    else
    {
        // must be a singleton and a vector

        if ( isVector( v1 ) )
        {
            BYTE * pb2 = (BYTE *) &(v2.lVal);
            if ( VT_DECIMAL == v2.vt )
                pb2 = (BYTE *) &(v2.decVal);

            for ( unsigned i = 0; i < v1.cal.cElems; i++ )
            {
                if ( cmp( _GetNth( v1, i ), pb2 ) )
                    return TRUE;
            }
        }
        else
        {
            BYTE * pb1 = (BYTE *) &(v1.lVal);
            if ( VT_DECIMAL == v1.vt )
                pb1 = (BYTE *) &(v1.decVal);

            for ( unsigned i = 0; i < v2.cal.cElems; i++ )
            {
                if ( cmp( pb1, _GetNth( v2, i ) ) )
                    return TRUE;
            }
        }
    }

    return FALSE;
} //VT_VECTOR_Any

BOOL VT_VECTOR_LT_Any( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_Any( v1, v2, PRLT );
} //VT_VECTOR_LT_Any

BOOL VT_VECTOR_LE_Any( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_Any( v1, v2, PRLE );
} //VT_VECTOR_LE_Any

BOOL VT_VECTOR_GT_Any( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_Any( v1, v2, PRGT );
} //VT_VECTOR_GT_Any

BOOL VT_VECTOR_GE_Any( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_Any( v1, v2, PRGE );
} //VT_VECTOR_GE_Any

BOOL VT_VECTOR_EQ_Any( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_Any( v1, v2, PREQ );
} //VT_VECTOR_EQ_Any

BOOL VT_VECTOR_NE_Any( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_Any( v1, v2, PRNE );
} //VT_VECTOR_NE_Any

BOOL VT_VECTOR_AllBits_Any( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_Any( v1, v2, PRAllBits );
} //VT_VECTOR_AllBits_Any

BOOL VT_VECTOR_SomeBits_Any( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_Any( v1, v2, PRSomeBits );
} //VT_VECTOR_SomeBits_Any

////////////////////////////////////
////////////////////////////////////
////////////////////////////////////

BOOL VT_VECTOR_All(
    PROPVARIANT const & v1In,
    PROPVARIANT const & v2In,
    ULONG relop )
{
    //
    // Note: first parameter (v1) is the object's property value
    //       second parameter (v2) is the query restriction
    //
    // each element in v2 must hold the relation to each element v1
    // (not necessarily vice-versa)
    //

    // base type of variant must be the same

    if ( getBaseType( v1In ) != getBaseType( v2In ) )
        return FALSE;

    //
    //  If either argument is a safearray, convert it to a vector
    //
    PROPVARIANT v1 = v1In;
    if (isArray(v1))
        ConvertArrayToVector( v1In, v1 );

    PROPVARIANT v2 = v2In;
    if (isArray(v2))
        ConvertArrayToVector( v2In, v2 );

    // first check for two singletons

    if ( ! isVector( v1 ) && ! isVector( v2 ) )
    {
        FRel cmp = VariantCompare.GetRelop( (VARENUM) v1.vt, relop );

        if ( 0 == cmp )
            return FALSE;
        else
            return cmp( v1, v2 );
    }

    // two vectors or singleton+vector -- get a pointer comparator

    FPRel cmp = VariantCompare.GetPointerRelop( v1, v2, relop );

    if ( 0 == cmp )
        return FALSE;

    // check for two vectors

    if ( isVector( v1 ) && isVector( v2 ) )
    {
        // Don't match empty vectors in queries.

        if ( 0 == v2.cal.cElems )
            return FALSE;

        //
        // Make sure the relation holds true for each element in the query
        // paired with each element in the file's value.
        //

        for ( unsigned x2 = 0; x2 < v2.cal.cElems; x2++ )
        {
            for ( unsigned x1 = 0; x1 < v1.cal.cElems; x1++ )
            {
                if ( ! cmp( _GetNth( v1, x1), _GetNth( v2, x2 ) ) )
                    return FALSE;
            }
        }
    }
    else
    {
        // must be a singleton and a vector

        if ( isVector( v1 ) )
        {
            BYTE * pb2 = (BYTE *) &(v2.lVal);
            if ( VT_DECIMAL == v2.vt )
                pb2 = (BYTE *) &(v2.decVal);

            for ( unsigned i = 0; i < v1.cal.cElems; i++ )
            {
                if ( ! cmp( _GetNth( v1, i ), pb2 ) )
                    return FALSE;
            }
        }
        else
        {
            BYTE * pb1 = (BYTE *) &(v1.lVal);
            if ( VT_DECIMAL == v1.vt )
                pb1 = (BYTE *) &(v1.decVal);

            for ( unsigned i = 0; i < v2.cal.cElems; i++ )
            {
                if ( ! cmp( pb1, _GetNth( v2, i ) ) )
                    return FALSE;
            }
        }
    }

    return TRUE;
} //VT_VECTOR_All

BOOL VT_VECTOR_LT_All( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_All( v1, v2, PRLT );
} //VT_VECTOR_LT_All

BOOL VT_VECTOR_LE_All( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_All( v1, v2, PRLE );
} //VT_VECTOR_LE_All

BOOL VT_VECTOR_GT_All( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_All( v1, v2, PRGT );
} //VT_VECTOR_GT_All

BOOL VT_VECTOR_GE_All( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_All( v1, v2, PRGE );
} //VT_VECTOR_GE_All

BOOL VT_VECTOR_EQ_All( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_All( v1, v2, PREQ );
} //VT_VECTOR_EQ_All

BOOL VT_VECTOR_NE_All( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_All( v1, v2, PRNE );
} //VT_VECTOR_NE_All

BOOL VT_VECTOR_AllBits_All( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_All( v1, v2, PRAllBits );
} //VT_VECTOR_AllBits_All

BOOL VT_VECTOR_SomeBits_All( PROPVARIANT const & v1, PROPVARIANT const & v2 )
{
    return VT_VECTOR_All( v1, v2, PRSomeBits );
} //VT_VECTOR_SomeBits_All

////////////////////////////////////
////////////////////////////////////
////////////////////////////////////

FRel const CComparators::_aVectorComparators[] =
{
    VT_VECTOR_LT,
    VT_VECTOR_LE,
    VT_VECTOR_GT,
    VT_VECTOR_GE,
    VT_VECTOR_EQ,
    VT_VECTOR_NE,
    0,
    VT_VECTOR_AllBits,
    VT_VECTOR_SomeBits
};

ULONG const CComparators::_cVectorComparators =
    sizeof CComparators::_aVectorComparators /
    sizeof CComparators::_aVectorComparators[0];

FRel const CComparators::_aVectorComparatorsAll[] =
{
    VT_VECTOR_LT_All,
    VT_VECTOR_LE_All,
    VT_VECTOR_GT_All,
    VT_VECTOR_GE_All,
    VT_VECTOR_EQ_All,
    VT_VECTOR_NE_All,
    0,
    VT_VECTOR_AllBits_All,
    VT_VECTOR_SomeBits_All
};

ULONG const CComparators::_cVectorComparatorsAll =
    sizeof CComparators::_aVectorComparatorsAll /
    sizeof CComparators::_aVectorComparatorsAll[0];

FRel const CComparators::_aVectorComparatorsAny[] =
{
    VT_VECTOR_LT_Any,
    VT_VECTOR_LE_Any,
    VT_VECTOR_GT_Any,
    VT_VECTOR_GE_Any,
    VT_VECTOR_EQ_Any,
    VT_VECTOR_NE_Any,
    0,
    VT_VECTOR_AllBits_Any,
    VT_VECTOR_SomeBits_Any
};

ULONG const CComparators::_cVectorComparatorsAny =
    sizeof CComparators::_aVectorComparatorsAny /
    sizeof CComparators::_aVectorComparatorsAny[0];

////////////////////////////////////
////////////////////////////////////
////////////////////////////////////

FCmp CComparators::GetComparator( VARENUM vt )
{
    if ( isVectorOrArray( vt ) )
    {
        return VT_VECTOR_Compare;
    }
    else if ( vt >= _iStart && vt < _iStart + _cVariantComparators )
    {
        return( _aVariantComparators[vt].comparator );
    }
    else if ( vt >= _iStart2 && vt < _iStart2 + _cVariantComparators2 )
    {
        return( _aVariantComparators2[vt - _iStart2].comparator );
    }
    else if ( vt >= _iStart3 && vt < _iStart3 + _cVariantComparators3 )
    {
        return( _aVariantComparators3[vt - _iStart3].comparator );
    }
    else
    {
        ciDebugOut(( DEB_ERROR,
                     "CComparators::GetComparator Unknown property type %d in comparison.\n",
                     vt ));
        Win4Assert( !"Unknown property type used in comparison." );
        return( 0 );
    }
} //GetComparator

FRel CComparators::GetRelop( VARENUM vt, ULONG relop )
{
    if ( ( ( isVectorOrArray( vt ) ) ||
           ( isVectorRelop( relop ) ) ) &&
         ( getBaseRelop( relop ) < _cVectorComparators ) )
    {
        if ( isRelopAny( relop ) )
            return _aVectorComparatorsAny[ getBaseRelop( relop ) ];
        else if ( isRelopAll( relop ) )
            return _aVectorComparatorsAll[ getBaseRelop( relop ) ];
        else
            return _aVectorComparators[ relop ];
    }
    else if ( vt >= _iStart && vt < _cVariantComparators &&
         relop < sizeof(_aVariantComparators[0].relops)/
                 sizeof(_aVariantComparators[0].relops[0] ) )
    {
        return( _aVariantComparators[vt].relops[relop] );
    }
    else if ( vt >= _iStart2 && vt < _iStart2 + _cVariantComparators2 &&
         relop < sizeof(_aVariantComparators2[0].relops)/
                 sizeof(_aVariantComparators2[0].relops[0] ) )
    {
        return( _aVariantComparators2[vt - _iStart2].relops[relop] );
    }
    else if ( vt >= _iStart3 && vt < _iStart3 + _cVariantComparators3 &&
         relop < sizeof(_aVariantComparators3[0].relops)/
                 sizeof(_aVariantComparators3[0].relops[0] ) )
    {
        return( _aVariantComparators3[vt - _iStart3].relops[relop] );
    }
    else
    {
        ciDebugOut(( DEB_ERROR,
                     "CComparators::GetRelop Unknown property type %d or relation %d used in comparison.\n",
                     vt, relop ));
        Win4Assert( !"Unknown property type or relop used in comparison." );
        return( 0 );
    }
} //GetRelop

FPCmp CComparators::GetPointerComparator(
    PROPVARIANT const & v1,
    PROPVARIANT const & v2 )
{
    VARENUM vt = getBaseType( v1 );

    if ( VT_CLSID == vt )
    {
        // GUIDs are the only case of variants where the data inside
        // a singleton is different from an element in a vector.
        // Data in a singleton is a pointer to a guid.
        // Data in the element of a vector is the guid itself.
        // The vector compare code assumes that the layout of singletons
        // and vectors is the same, so we need special-case comparators
        // for GUIDs.

        if ( isVector( v1 ) && isVector( v2 ) )
            return VTP_VV_CLSID_Compare;
        else if ( isVector( v1 ) )
            return VTP_VS_CLSID_Compare;
        else if ( isVector( v2 ) )
            return VTP_SV_CLSID_Compare;
        else
            return VTP_SS_CLSID_Compare;

        Win4Assert( !"unanticipated clsid / vector code path" );
    }

    if ( vt >= _iStart && vt < _iStart + _cVariantComparators )
        return( _aVariantComparators[vt].pointercomparator );
    else if ( vt >= _iStart2 && vt < _iStart2 + _cVariantComparators2 )
        return( _aVariantComparators2[vt - _iStart2].pointercomparator );
    else if ( vt >= _iStart3 && vt < _iStart3 + _cVariantComparators3 )
        return( _aVariantComparators3[vt - _iStart3].pointercomparator );
    else
    {
        ciDebugOut(( DEB_ERROR,
                     "CComparators::GetPointerComparator Unknown property type %d in comparison.\n",
                     vt ));
        Win4Assert( !"Unknown property type used in pointer comparison." );
        return( 0 );
    }
} //GetPointerComparator

FPRel CComparators::GetPointerRelop(
    PROPVARIANT const & v1,
    PROPVARIANT const & v2,
    ULONG relop )
{
    VARENUM vt = getBaseType( v1 );

    if ( VT_CLSID == vt )
    {
        // GUIDs are the only case of variants where the data inside
        // a singleton is different from an element in a vector.
        // Data in a singleton is a pointer to a guid.
        // Data in the element of a vector is the guid itself.
        // The vector compare code assumes that the layout of singletons
        // and vectors is the same, so we need special-case comparators
        // for GUIDs.

        if ( isVector( v1 ) && isVector( v2 ) )
        {
            if ( PREQ == relop )
                return VTP_VV_CLSID_EQ;
            else if ( PRNE == relop )
                return VTP_VV_CLSID_NE;
            else
                return 0;
        }
        else if ( isVector( v1 ) )
        {
            if ( PREQ == relop )
                return VTP_VS_CLSID_EQ;
            else if ( PRNE == relop )
                return VTP_VS_CLSID_NE;
            else
                return 0;
        }
        else if ( isVector( v2 ) )
        {
            if ( PREQ == relop )
                return VTP_SV_CLSID_EQ;
            else if ( PRNE == relop )
                return VTP_SV_CLSID_NE;
            else
                return 0;
        }
        else
        {
            if ( PREQ == relop )
                return VTP_SS_CLSID_EQ;
            else if ( PRNE == relop )
                return VTP_SS_CLSID_NE;
            else
                return 0;
        }
    }

    if ( vt >= _iStart && vt < _cVariantComparators &&
         relop < sizeof(_aVariantComparators[0].pointerrelops)/
                 sizeof(_aVariantComparators[0].pointerrelops[0] ) )
        return( _aVariantComparators[vt].pointerrelops[relop] );
    else if ( vt >= _iStart2 && vt < _iStart2 + _cVariantComparators2 &&
         relop < sizeof(_aVariantComparators2[0].pointerrelops)/
                 sizeof(_aVariantComparators2[0].pointerrelops[0] ) )
        return( _aVariantComparators2[vt - _iStart2].pointerrelops[relop] );
    else if ( vt >= _iStart3 && vt < _iStart3 + _cVariantComparators3 &&
         relop < sizeof(_aVariantComparators3[0].pointerrelops)/
                 sizeof(_aVariantComparators3[0].pointerrelops[0] ) )
        return( _aVariantComparators3[vt - _iStart3].pointerrelops[relop] );
    else
    {
        ciDebugOut(( DEB_ERROR,
                     "CComparators::GetPointerRelop Unknown property type %d or relation %d used in comparison.\n",
                     vt, relop ));
        Win4Assert( !"Unknown property type or relop used in pointer comparison." );
        return( 0 );
    }
} //GetPointerRelop

////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////

int DBVector_Compare( DBTYPEENUM type, BYTE const * p1, BYTE const * p2 )
{
    //
    // Convert to variants and use the normal variant vector comparator.
    // This is a little bit slow, but it is an odd case and the code size
    // otherwise would be greatly increased.
    //

    PROPVARIANT v1,v2;

    Win4Assert( isVector(type) );

    v1.vt = v2.vt = (VARENUM) type;

    v1.cal = *(CAL *) p1;
    v2.cal = *(CAL *) p2;

    return VT_VECTOR_Compare( v1, v2 );
} //DBVector_Compare

int DBTYPE_EMPTY_Compare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return( 0 );
}

int DBTYPE_NULL_Compare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return( 0 );
}

int DBTYPE_I1_Compare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return( *(signed char *)pv1 - *(signed char *)pv2 );
}

int DBTYPE_I1_VectorCompare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return DBVector_Compare( dbVector( DBTYPE_I1 ), pv1, pv2);
}

int DBTYPE_UI1_Compare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return( *(unsigned char *)pv1 - *(unsigned char *)pv2 );
}

int DBTYPE_UI1_VectorCompare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return DBVector_Compare( dbVector( DBTYPE_UI1 ), pv1, pv2);
}

int DBTYPE_I2_Compare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return( *(short *)pv1 - *(short *)pv2 );
}

int DBTYPE_I2_VectorCompare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return DBVector_Compare( dbVector( DBTYPE_I2 ), pv1, pv2);
}

int DBTYPE_UI2_Compare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return( *(unsigned short *)pv1 - *(unsigned short *)pv2 );
}

int DBTYPE_UI2_VectorCompare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return DBVector_Compare( dbVector( DBTYPE_UI2 ), pv1, pv2);
}

int DBTYPE_I4_Compare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    long l1 = * (long *) pv1;
    long l2 = * (long *) pv2;

    return ( l1 > l2 ) ? 1 : ( l1 < l2 ) ? -1 : 0;
}

int DBTYPE_I4_VectorCompare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return DBVector_Compare( dbVector( DBTYPE_I4 ), pv1, pv2);
}

int DBTYPE_UI4_Compare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    ULONG ul1 = * (ULONG *) pv1;
    ULONG ul2 = * (ULONG *) pv2;

    return ( ul1 > ul2 ) ? 1 : ( ul1 < ul2 ) ? -1 : 0;
}

int DBTYPE_UI4_VectorCompare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return DBVector_Compare( dbVector( DBTYPE_UI4 ), pv1, pv2);
}

int DBTYPE_R4_Compare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return VTP_R4_Compare( pv1, pv2 );
}

int DBTYPE_R4_VectorCompare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return DBVector_Compare( dbVector( DBTYPE_R4 ), pv1, pv2);
}

int DBTYPE_R8_Compare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return VTP_R8_Compare( pv1, pv2 );
}

int DBTYPE_R8_VectorCompare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return DBVector_Compare( dbVector( DBTYPE_R8 ), pv1, pv2);
}

int DBTYPE_I8_Compare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return( *(LONGLONG *)pv1 > *(LONGLONG *)pv2 ? 1 :
            *(LONGLONG *)pv1 == *(LONGLONG *)pv2 ? 0 :
            -1 );
}

int DBTYPE_I8_VectorCompare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return DBVector_Compare( dbVector( DBTYPE_I8 ), pv1, pv2);
}

int DBTYPE_UI8_Compare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return( *(ULONGLONG *)pv1 > *(ULONGLONG *)pv2 ? 1 :
            *(ULONGLONG *)pv1 == *(ULONGLONG *)pv2 ? 0 :
            -1 );
}

int DBTYPE_UI8_VectorCompare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return DBVector_Compare( dbVector( DBTYPE_UI8 ), pv1, pv2);
}

int DBTYPE_BOOL_Compare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return( (*(USHORT *)pv1 == 0) == (*(USHORT *)pv2 == 0) );
}

int DBTYPE_BOOL_VectorCompare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return DBVector_Compare( dbVector( DBTYPE_BOOL ), pv1, pv2);
}

int DBTYPE_VARIANT_Compare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return VT_VARIANT_Compare( * (PROPVARIANT *) pv1, * (PROPVARIANT *) pv2 );
}

int DBTYPE_GUID_Compare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return( memcmp( pv1, pv2, sizeof(GUID) ) );
}

int DBTYPE_GUID_VectorCompare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return DBVector_Compare( dbVector( DBTYPE_GUID ), pv1, pv2);
}

int DBTYPE_BYTES_Compare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    ULONG mincb = __min( cb1, cb2 );

    int result = memcmp( pv1, pv2, mincb );

    if (result == 0)
        result = cb1 - cb2;

    return result;
}

int DBTYPE_STR_Compare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    int cMin = __min( cb1, cb2 );

    int ret = _strnicmp( (char *) pv1, (char *) pv2, cMin );

    if (0 == ret)
        return cb1 - cb2;
    else
        return ret;
}

int DBTYPE_WSTR_Compare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    int cMin = __min( cb1, cb2 );

    int ret = _wcsnicmp( (WCHAR *) pv1, (WCHAR *) pv2, cMin );

    if (0 == ret)
        return cb1 - cb2;
    else
        return ret;
}

int DBTYPE_BSTR_Compare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return VTP_BSTR_Compare( pv1, pv2 );
}

int DBTYPE_BSTR_VectorCompare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return DBVector_Compare( dbVector( (DBTYPEENUM) VT_BSTR ), pv1, pv2);
}

int DBTYPE_LPSTR_Compare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return _stricmp( (*(char **) pv1), (*(char **) pv2) );
}

int DBTYPE_LPSTR_VectorCompare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return DBVector_Compare( dbVector( (DBTYPEENUM) VT_LPSTR ), pv1, pv2);
}


int DBTYPE_LPWSTR_Compare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    int rc = CompareStringW( LOCALE_SYSTEM_DEFAULT,
                             NORM_IGNORECASE,
                             (*(WCHAR **) pv1),
                             -1,
                             (*(WCHAR **) pv2),
                             -1 );
    //
    // rc == 1, means less than
    // rc == 2, means equal
    // rc == 3, means greater than
    //
    return rc - 2;
}

int DBTYPE_LPWSTR_VectorCompare( BYTE const * pv1, ULONG cb1, BYTE const * pv2, ULONG cb2 )
{
    return DBVector_Compare( dbVector( (DBTYPEENUM) VT_LPWSTR ), pv1, pv2);
}

CComparators::SDBComparators const CComparators::_aDBComparators[] = {
    // VT_EMPTY, DBTYPE_EMPTY
    { DBTYPE_EMPTY_Compare,
      0,
    },

    // VT_NULL, DBTYPE_NULL
    { DBTYPE_NULL_Compare,
      0,
    },

    // VT_I2, DBTYPE_I2
    { DBTYPE_I2_Compare,
      DBTYPE_I2_VectorCompare,
    },

    // VT_I4, DBTYPE_I4
    { DBTYPE_I4_Compare,
      DBTYPE_I4_VectorCompare,
    },

    // VT_R4, DBTYPE_R4
    { DBTYPE_R4_Compare,
      DBTYPE_R4_VectorCompare,
    },

    // VT_R8, DBTYPE_R8
    { DBTYPE_R8_Compare,
      DBTYPE_R8_VectorCompare,
    },

    // VT_CY, DBTYPE_CY
    { DBTYPE_I8_Compare,
      DBTYPE_I8_VectorCompare,
    },

    // VT_DATE, DBTYPE_DATE
    { DBTYPE_R8_Compare,
      DBTYPE_R8_VectorCompare,
    },

    // VT_BSTR, DBTYPE_BSTR
    { DBTYPE_BSTR_Compare,
      DBTYPE_BSTR_VectorCompare,
    },

    // VT_DISPATCH
    { 0,
      0,
    },

    // VT_ERROR
    { DBTYPE_I4_Compare,
      DBTYPE_I4_VectorCompare,
    },

    // VT_BOOL
    { DBTYPE_BOOL_Compare,
      DBTYPE_BOOL_VectorCompare,
    },

    // VT_VARIANT
    { DBTYPE_VARIANT_Compare,
      DBTYPE_VARIANT_Compare,
    },

    // VT_UNKNOWN
    { 0,
      0,
    },

    // VARENUM value 14 unused
    { 0,
      0,
    },

    // VARENUM value 15 unused
    { 0,
      0,
    },

    // VT_I1 undefined in PROPVARIANT union
    { DBTYPE_I1_Compare,
      DBTYPE_I1_VectorCompare,
    },

    // VT_UI1
    { DBTYPE_UI1_Compare,
      DBTYPE_UI1_VectorCompare,
    },

    // VT_UI2
    { DBTYPE_UI2_Compare,
      DBTYPE_UI2_VectorCompare,
    },

    // VT_UI4
    { DBTYPE_UI4_Compare,
      DBTYPE_UI4_VectorCompare,
    },

    // VT_I8
    { DBTYPE_I8_Compare,
      DBTYPE_I8_VectorCompare,
    },

    // VT_UI8
    { DBTYPE_UI8_Compare,
      DBTYPE_UI8_VectorCompare,
    },

    // VT_INT undefined in PROPVARIANT union
    { 0,
      0,
    },

    // VT_UINT undefined in PROPVARIANT union
    { 0,
      0,
    },

    // VT_VOID
    { 0,
      0,
    },

    // VT_HRESULT
    { 0,
      0,
    },

    // VT_PTR
    { 0,
      0,
    },

    // VT_SAFEARRAY
    { 0,
      0,
    },

    // VT_CARRAY
    { 0,
      0,
    },

    // VT_USERDEFINED
    { 0,
      0,
    },

    // VT_LPSTR  (translated form of DBTYPE_STR | DBTYPE_BYREF)
    { DBTYPE_LPSTR_Compare,
      DBTYPE_LPSTR_VectorCompare,
    },

    // VT_LPWSTR  (translated form of DBTYPE_WSTR | DBTYPE_BYREF)
    { DBTYPE_LPWSTR_Compare,
      DBTYPE_LPWSTR_VectorCompare,
    }
};

ULONG const CComparators::_iDBStart = VT_EMPTY;

ULONG const CComparators::_cDBComparators =
    sizeof(CComparators::_aDBComparators) /
    sizeof(CComparators::_aDBComparators[0]);

ULONG const CComparators::_iDBStart2 = VT_FILETIME;

CComparators::SDBComparators const CComparators::_aDBComparators2[] = {
    // VT_FILETIME
    { DBTYPE_UI8_Compare,
      DBTYPE_UI8_VectorCompare,
    },

    // VT_BLOB
    { 0,
      0,
    },

    // VT_STREAM
    { 0,
      0,
    },

    // VT_STORAGE
    { 0,
      0,
    },

    // VT_STREAMED_OBJECT
    { 0,
      0,
    },

    // VT_STORED_OBJECT
    { 0,
      0,
    },

    // VT_BLOB_OBJECT
    { 0,
      0,
    },

    // VT_CF
    { 0,
      0,
    },

    // VT_CLSID, DBTYPE_GUID
    { DBTYPE_GUID_Compare,
      DBTYPE_GUID_VectorCompare,
    }
};

ULONG const CComparators::_cDBComparators2 =
    sizeof(CComparators::_aDBComparators2) /
    sizeof(CComparators::_aDBComparators2[0]);

ULONG const CComparators::_iDBStart3 = DBTYPE_BYTES;

CComparators::SDBComparators const CComparators::_aDBComparators3[] = {
    // DBTYPE_BYTES
    { DBTYPE_BYTES_Compare,
      0,
    },

    // DBTYPE_STR
    { DBTYPE_STR_Compare,
      0,
    },

    // DBTYPE_WSTR
    { DBTYPE_WSTR_Compare,
      0,
    }
};

ULONG const CComparators::_cDBComparators3 =
    sizeof(CComparators::_aDBComparators3) /
    sizeof(CComparators::_aDBComparators3[0]);

//+-------------------------------------------------------------------------
//
//  Member:     CComparators::_RationalizeDBByRef, private
//
//  Synopsis:   Converts BYREF oledb string types to variant equivalents
//
//  Arguments:  [vt] -- Data type to be converted.
//
//  Returns:    A VARENUM equivalent for oledb string types
//
//  Notes:      DBTYPE_BYREF | DBTYPE_WSTR and the vector version of the
//              same are idential in meaning to the corresponding VT_LPWSTR
//              VARENUM type.
//
//  History:    25-May-95   dlee     Created
//
//--------------------------------------------------------------------------

DBTYPEENUM CComparators::_RationalizeDBByRef( DBTYPEENUM vt )
{
    // convert these types to something usable as an index

    if ( 0 != ( DBTYPE_BYREF & vt ) )
    {
        if ( (DBTYPE_BYREF | DBTYPE_WSTR) == vt )
            return (DBTYPEENUM) VT_LPWSTR;
        else if ( (DBTYPE_BYREF | DBTYPE_STR) == vt )
            return (DBTYPEENUM) VT_LPSTR;
        if ( (DBTYPE_VECTOR | DBTYPE_BYREF | DBTYPE_WSTR) == vt )
            return (DBTYPEENUM) (VT_VECTOR | VT_LPWSTR);
        else if ( (DBTYPE_VECTOR | DBTYPE_BYREF | DBTYPE_STR) == vt )
             return (DBTYPEENUM) (VT_VECTOR | VT_LPSTR);
    }

    return vt;
} //_RationalizeByRef

//+-------------------------------------------------------------------------
//
//  Member:     CComparators::GetDBComparator, public
//
//  Synopsis:   Returns a comparison function for a given data type.
//
//  Arguments:  [vt] -- Data type of returned comparator.
//
//  Returns:    Pointer to an FDBCmp function
//
//  History:    25-May-95   dlee     Created
//
//--------------------------------------------------------------------------

FDBCmp CComparators::GetDBComparator( DBTYPEENUM vt )
{
    vt = _RationalizeDBByRef( vt );

    if ( 0 != ( DBTYPE_VECTOR & vt ) )
    {
        vt = (DBTYPEENUM) ( vt & ( ~ DBTYPE_VECTOR ) );

        if ( vt >= _iDBStart && vt < _iDBStart + _cDBComparators )
        {
            return( _aDBComparators[vt].dbvectorcomparator );
        }
        else if ( vt >= _iDBStart2 && vt < _iDBStart2 + _cDBComparators2 )
        {
            return( _aDBComparators2[vt - _iDBStart2].dbvectorcomparator );
        }
        else if ( vt >= _iDBStart3 && vt < _iDBStart3 + _cDBComparators3 )
        {
            return( _aDBComparators3[vt - _iDBStart3].dbvectorcomparator );
        }
        else
        {
            ciDebugOut(( DEB_ERROR,
                         "CComparators::GetDBComparator Unknown property type %d in comparison.\n",
                         vt ));
            Win4Assert( !"Unknown property type used in comparison." );
            return( 0 );
        }
    }
    else if ( vt >= _iDBStart && vt < _iDBStart + _cDBComparators )
    {
        return( _aDBComparators[vt].dbcomparator );
    }
    else if ( vt >= _iDBStart2 && vt < _iDBStart2 + _cDBComparators2 )
    {
        return( _aDBComparators2[vt - _iDBStart2].dbcomparator );
    }
    else if ( vt >= _iDBStart3 && vt < _iDBStart3 + _cDBComparators3 )
    {
        return( _aDBComparators3[vt - _iDBStart3].dbcomparator );
    }
    else
    {
        // This will be hit if someone has a binding like
        // DBTYPE_I2 | DBTYPE_BYREF, which means that instead
        // of writing 2 bytes into their data, we allocate 2
        // bytes from OLE and write that pointer into 4 bytes
        // of the client data.  There is a bug against oledb
        // to not allow the client to do something so ill-advised.
        //
        ciDebugOut(( DEB_ERROR,
                     "CComparators::GetDBComparator Unknown property type %d in comparison.\n",
                     vt ));
        Win4Assert( !"Unknown property type used in comparison." );
        return( 0 );
    }
} //GetDBComparator
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\xpr\prelxpr.cxx ===
//+---------------------------------------------------------------------------
//
// Microsoft Windows
// Copyright (C) Microsoft Corporation, 1991-1998.
//
// File:        PRelXpr.cxx
//
// Contents:    Property relation expression
//
// Classes:     CXprPropertyRelation
//
// History:     11-Sep-91       KyleP   Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <parse.hxx>
#include <objcur.hxx>
#include <compare.hxx>
#include <xpr.hxx>
#include <strategy.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     CXprPropertyRelation::CXprPropertyRelation, public
//
//  Synopsis:   Create an expression used to test <prop> <relop> <const>
//
//  Arguments:  [pid]   -- Property ID to be compared
//              [relop] -- Relational operator
//              [prval] -- Constant value to be compared against
//              [prstContentHelper] -- Content index helper
//
//  History:    30-Oct-91   KyleP       Created.
//
//----------------------------------------------------------------------------

CXprPropertyRelation::CXprPropertyRelation( PROPID pid,
                                            ULONG relop,
                                            CStorageVariant const & prval,
                                            CRestriction * prstContentHelper )
        : CXpr( CXpr::NTProperty ),
          _xpval( pid ),
          _rel( relop ),
          _cval( prval ),
          _xrstContentHelper( prstContentHelper )
{
    Win4Assert( getBaseRelop( _rel ) <= PRSomeBits );

    if ( ! _cval.IsValid() )
    {
        vqDebugOut(( DEB_ERROR, "ERROR: restriction with pointer value of 0\n" ));

        THROW( CException( QUERY_E_INVALIDRESTRICTION ) );
    }

    _relop = VariantCompare.GetRelop( _cval.Type(), _rel );

    if ( 0 == _relop )
    {
        vqDebugOut(( DEB_ERROR,
                     "ERROR: Unsupported relational operator %d "
                     "on type 0x%x\n",
                     _rel,
                     _cval.Type() ));
        THROW( CException( QUERY_E_INVALIDRESTRICTION ) );
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CXprPropertyRelation::CXprPropertyRelation, public
//
//  Synopsis:   Copy contstructor
//
//  Arguments:  [propxpr] -- Expression to copy
//
//  History:    11-Dec-91   KyleP       Created.
//
//----------------------------------------------------------------------------

CXprPropertyRelation::CXprPropertyRelation( CXprPropertyRelation & propxpr )
    : CXpr( propxpr.NType(), propxpr.GetWeight() ),
      _xpval( propxpr._xpval ),
      _relop( propxpr._relop ),
      _cval( propxpr._cval ),
      _rel( propxpr._rel )
{
    if ( !propxpr._xrstContentHelper.IsNull() )
        _xrstContentHelper.Set( propxpr._xrstContentHelper->Clone() );
}

//+---------------------------------------------------------------------------
//
//  Member:     CXprPropertyRelation::~CXprPropertyRelation, public
//
//  Synopsis:   Destroys the expression
//
//  History:    30-Oct-91   KyleP       Created.
//
//----------------------------------------------------------------------------

CXprPropertyRelation::~CXprPropertyRelation()
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CXprPropertyRelation::Clone, public
//
//  Returns:    A copy of this node.
//
//  Derivation: From base class CXpr, Always override in subclasses.
//
//  History:    11-Dec-91   KyleP       Created.
//
//----------------------------------------------------------------------------

CXpr * CXprPropertyRelation::Clone()
{
    return( new CXprPropertyRelation( *this ) );
}

void CXprPropertyRelation::SelectIndexing( CIndexStrategy & strategy )
{
    //
    // Bounds checking is for index selection.  Query properties are not
    // in any index.
    //

    if ( IS_CIQUERYPROPID(_xpval.Pid()) && _xpval.Pid() != pidUnfiltered )
    {
        strategy.SetUnknownBounds( _xpval.Pid() );
        return;
    }

    if ( ! _xrstContentHelper.IsNull() &&
         _xpval.Pid() != pidPath &&
         _xpval.Pid() != pidDirectory &&
         _xpval.Pid() != pidVirtualPath )
    {
        Win4Assert( _rel == PREQ || _rel == (PREQ|PRAny) || _rel == (PREQ|PRAll) );

        strategy.SetContentHelper( _xrstContentHelper.Acquire() );
    }

    switch ( _rel )
    {
    case PRLT:
    case PRLE:
        strategy.SetUpperBound( _xpval.Pid(), _cval );
        break;

    case PRGT:
    case PRGE:
    case PRAllBits:
        strategy.SetLowerBound( _xpval.Pid(), _cval );
        break;

    case PREQ:
        strategy.SetBounds( _xpval.Pid(), _cval, _cval );
        break;

    case PRSomeBits:
        //
        // Value must be at least as large as lowest set bit.
        //

        if ( _cval.Type() == VT_I4 )
        {
            long l = _cval;

            for ( unsigned lowbit = 0; l != 0; lowbit++ )
                l <<= 1;
            lowbit = 32 - lowbit;

            if ( lowbit > 0 )
            {
                CStorageVariant var( (long)(1 << lowbit) );

                strategy.SetLowerBound( _xpval.Pid(), var );
            }
        }
        break;

    case PRNE:
    default:
        strategy.SetUnknownBounds( _xpval.Pid() );
        break;
    }
}

//+---------------------------------------------------------------------------
//
//  Member:     CXprPropertyRelation::IsMatch, public
//
//  Arguments:  [obj] -- The object retriever.  [obj] is already positioned
//                       to the record to test.
//
//  Returns:    TRUE if the current record satisfies the relation.
//
//  History:    30-Oct-91   KyleP       Created.
//
//----------------------------------------------------------------------------

BOOL CXprPropertyRelation::IsMatch( CRetriever & obj )
{
    // this is an array of LONGLONGs to force 8-byte alignment
    LONGLONG allBuffer[ 10 ];
    ULONG cb = sizeof allBuffer;
    PROPVARIANT * ppv = (PROPVARIANT *) allBuffer;

    GetValueResult rc = _xpval.GetValue( obj, ppv, &cb );

    //
    // If the object is too big for the stack then allocate heap (sigh).
    //

    XArray<BYTE> xTemp;

    if ( rc == GVRNotEnoughSpace )
    {
        xTemp.Init( cb );
        ppv = (PROPVARIANT *) xTemp.GetPointer();
        rc = _xpval.GetValue( obj, ppv, &cb );
    }

    if ( rc != GVRSuccess )
    {
        vqDebugOut(( DEB_TRACE,
                     "CXprPropertyRelation::IsMatch -- Can't get value.\n" ));
        return FALSE;
    }

    //
    //  In general, the types must match for values to match.
    //  There are exceptions for the vector case, and for != comparisons.
    // 

    if ( ppv->vt != _cval.Type() )
    {
        // If != comparison and value is VT_EMPTY, it matches
        if ( PRNE == _rel && VT_EMPTY == _cval.Type() )
            return TRUE;

        // Could be a vector compare iff ppv is a vector and the
        // relop is any/all.
        // Otherwise, return that there is no match.

        if ( ! ( isVectorOrArray( *ppv ) && isVectorRelop( _rel ) ) )
            return FALSE;
    }

    Win4Assert( 0 != _relop );

    return _relop( *ppv, (PROPVARIANT &)_cval );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\xpr\state.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2000.
//
//  File:       State.cxx
//
//  Contents:   Finite automata state classes
//
//  Classes:
//
//  History:    01-21-92  KyleP     Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <state.hxx>

#include "stateset.hxx"

//+-------------------------------------------------------------------------
//
//  Member:     CNFAState::CNFAState, public
//
//  Synopsis:   Copy constructor
//
//  Arguments:  [src] -- Source
//
//  History:    13-Jul-95 KyleP     Created
//
//--------------------------------------------------------------------------

CNFAState::CNFAState( CNFAState const & src )
        : CFAState( src ),
          _pmoveRest( 0 ),
          _cmoveRest( src._cmoveRest ),
          _cMove( src._cMove )
{
    if ( _cmoveRest > 0 )
    {
        _pmoveRest = new CMove [_cmoveRest];
        RtlCopyMemory( _pmoveRest, src._pmoveRest, _cmoveRest * sizeof(_pmoveRest[0]) );
    }

    RtlCopyMemory( _moveFirst, src._moveFirst, sizeof(_moveFirst) );
}

//+-------------------------------------------------------------------------
//
//  Member:     CNFAState::Init, public
//
//  Synopsis:   Copy initializer
//
//  Arguments:  [src] -- Source
//
//  History:    15-Jul-96 KyleP     Created
//
//--------------------------------------------------------------------------

void CNFAState::Init( CNFAState & src )
{
    CFAState::Init( src.StateNumber() );

    if ( src.IsFinal() )
        MakeFinal();

    _cMove = src._cMove;
    RtlCopyMemory( _moveFirst, src._moveFirst, sizeof(_moveFirst) );

    _cmoveRest = src._cmoveRest;
    _pmoveRest = src._pmoveRest;

    src._cMove = 0;
    src._cmoveRest = 0;
    src._pmoveRest = 0;
}

//+-------------------------------------------------------------------------
//
//  Member:     CNFAState::operator =, public
//
//  Synopsis:   Assignment operator
//
//  Arguments:  [src] -- Source
//
//  History:    13-Jul-95 KyleP     Created
//
//--------------------------------------------------------------------------

inline void * operator new( size_t, CNFAState * pthis )
{
    return pthis;
}

#if _MSC_VER >= 1200
inline void operator delete( void * p, CNFAState * pthis ) {}
#endif

CNFAState & CNFAState::operator =( CNFAState const & src )
{
    CNFAState::~CNFAState();

    new (this) CNFAState( src );

    return *this;
}

//+-------------------------------------------------------------------------
//
//  Member:     CNFAState::AddTransition, public
//
//  Synopsis:   Add new state transition.
//
//  Arguments:  [symbol]   -- On this symbol to...
//              [StateNum] --   this state.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

void CNFAState::AddTransition( UINT symbol, UINT StateNum )
{
    //
    // First look for an exact match.  If this transition exists
    // then don't add it again.
    //

    for ( int i = CNFAState_cFirst-1; i >= 0; i--)
    {
        if ( _moveFirst[i]._symbol == symbol &&
             _moveFirst[i]._iState == StateNum )
        {
            return;
        }
    }

    if ( _cMove > CNFAState_cFirst )
    {
        for ( int i = _cMove - CNFAState_cFirst - 1; i >= 0; i--)
        {
            if ( _pmoveRest[i]._symbol == symbol &&
                 _pmoveRest[i]._iState == StateNum )
            {
                return;
            }
        }
    }

    //
    // New transition.  Add it.
    //

    if ( _cMove < CNFAState_cFirst )
    {
        //
        // Fits in the first (object based) set of moves.
        //

        _moveFirst[_cMove] = CMove( symbol, StateNum );
    }
    else
    {
        //
        // Overflow set of moves.
        //

        if ( _cMove - CNFAState_cFirst >= _cmoveRest )
        {
            vqDebugOut(( DEB_ITRACE,
                         "Growing NFA State transition array.\n" ));
            CMove * oldpmoveRest = _pmoveRest;
            UINT    oldcmoveRest = _cmoveRest;

            _cmoveRest = (_cmoveRest == 0) ? 2 : _cmoveRest + 5;

            _pmoveRest = (CMove *) new char [ _cmoveRest * sizeof( CMove ) ];

            memcpy( _pmoveRest, oldpmoveRest, oldcmoveRest * sizeof( CMove ) );
            delete oldpmoveRest;
        }

        _pmoveRest[_cMove - CNFAState_cFirst] = CMove( symbol, StateNum );
    }

    ++_cMove;
}

//+-------------------------------------------------------------------------
//
//  Member:     CNFAState::RemoveTransition, public
//
//  Synopsis:   Removes a transition.
//
//  Arguments:  [symbol]   -- On this symbol to...
//              [StateNum] --   this state.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

void CNFAState::RemoveTransition( UINT symbol, UINT StateNum )
{
    //
    // Find the transition
    //

    for ( int i = CNFAState_cFirst-1; i >= 0; i--)
    {
        if ( _moveFirst[i]._symbol == symbol &&
             _moveFirst[i]._iState == StateNum )
        {
            //
            // Move the last transition to this place.
            //

            if ( _cMove > CNFAState_cFirst )
            {
                _moveFirst[i] = _pmoveRest[_cMove - CNFAState_cFirst - 1];
            }
            else
            {
                _moveFirst[i] = _moveFirst[ _cMove - 1 ];
            }

            _cMove--;

            return;
        }
    }

    if ( _cMove > CNFAState_cFirst )
    {
        for ( int i = _cMove - CNFAState_cFirst - 1; i >= 0; i--)
        {
            if ( _pmoveRest[i]._symbol == symbol &&
                 _pmoveRest[i]._iState == StateNum )
            {
                _pmoveRest[i] = _pmoveRest[ _cMove - CNFAState_cFirst - 1 ];

                _cMove--;

                return;
            }
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CNFAState::Move, public
//
//  Effects:    Adds to [ss] the set of states that can be reached from
//              this state on [symbol].
//
//  Arguments:  [ss]     -- Output state set.
//              [symbol] -- Input symbol.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

void CNFAState::Move( CStateSet & ss, UINT symbol )
{
    for ( int i = (_cMove <= CNFAState_cFirst) ? _cMove-1 : CNFAState_cFirst-1;
            i >= 0;
            i--)
    {
        if ( _moveFirst[i]._symbol == symbol ||
             ( _moveFirst[i]._symbol == symAny &&
               symbol != symEpsilon ))
        {
            ss.Add( _moveFirst[i]._iState );
        }
    }

    for ( i = _cMove - CNFAState_cFirst - 1; i >= 0; i-- )
    {
        if ( _pmoveRest[i]._symbol == symbol ||
             ( _pmoveRest[i]._symbol == symAny &&
               symbol != symEpsilon &&
               symbol != symDot ))
        {
            ss.Add( _pmoveRest[i]._iState );
        }
    }
}

//
// Debug methods
//

#if (CIDBG == 1)

void CFAState::Display()
{
    vqDebugOut(( DEB_REGEX,
                 "State: %u, Final = %c", _iState, _fFinal ? 'T' : 'F' ));
}

void CNFAState::Display()
{
    CFAState::Display();
    vqDebugOut(( DEB_REGEX | DEB_NOCOMPNAME, " -- %u transitions\n", _cMove ));

    for ( int i = (_cMove <= CNFAState_cFirst) ? _cMove-1 : CNFAState_cFirst-1;
            i >= 0;
            i--)
    {
        if ( _moveFirst[i]._symbol == symEpsilon)
        {
            vqDebugOut(( DEB_REGEX | DEB_NOCOMPNAME, "\tEpsilon " ));
        }
        else if ( _moveFirst[i]._symbol == symAny )
        {
            vqDebugOut(( DEB_REGEX | DEB_NOCOMPNAME, "\tAny " ));
        }
        else
        {
            vqDebugOut(( DEB_REGEX | DEB_NOCOMPNAME,
                         "\t%u ", _moveFirst[i]._symbol ));
        }

        vqDebugOut(( DEB_REGEX | DEB_NOCOMPNAME,
                     "--> %u\n", _moveFirst[i]._iState ));
    }

    for ( i = _cMove - CNFAState_cFirst - 1; i >= 0; i-- )
    {
        if ( _pmoveRest[i]._symbol == symEpsilon)
        {
            vqDebugOut(( DEB_REGEX | DEB_NOCOMPNAME, "\tEpsilon " ));
        }
        else if ( _pmoveRest[i]._symbol == symAny )
        {
            vqDebugOut(( DEB_REGEX | DEB_NOCOMPNAME, "\tAny " ));
        }
        else
        {
            vqDebugOut(( DEB_REGEX | DEB_NOCOMPNAME,
                         "\t%u ", _pmoveRest[i]._symbol ));
        }

        vqDebugOut(( DEB_REGEX | DEB_NOCOMPNAME,
                     "--> %u\n", _pmoveRest[i]._iState ));
    }
}

#endif // (CIDBG == 1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\xpr\pvalxpr.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2000.
//
// File:        PValXpr.cxx
//
// Contents:    Property value expression class
//
// Classes:     CXpr
//
// History:     11-Sep-91       KyleP   Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <objcur.hxx>
#include <pvalxpr.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     CXprPropertyValue::CXprPropertyValue, public
//
//  Synopsis:   Constructs a property value expression.
//
//  Arguments:  [pcxpr]    -- Expression to evaluate.
//              [propinfo] -- Used to query statistics of specific property
//
//  Requires:   [cxpr] Must be just a property name in Win 4.0
//
//  Returns:    GVRSuccess if successful
//
//  History:    14-Oct-91   KyleP       Created.
//
//----------------------------------------------------------------------------

CXprPropertyValue::CXprPropertyValue( PROPID pid )
        : _pid( pid )
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CXprPropertyValue::~CXprPropertyValue, public
//
//  Synopsis:   Virtual destructor required.
//
//  History:    15-Oct-91   KyleP       Created.
//
//----------------------------------------------------------------------------

CXprPropertyValue::~CXprPropertyValue()
{
}

//+---------------------------------------------------------------------------
//
//  Member:     CXprPropertyValue::GetValue, public
//
//  Synopsis:   Computes the value of the expression for the current row.
//
//  Arguments:  [obj] -- Objects table to retrieve values from.  It is
//                       assumed to be positioned on the object whose
//                       property values are to be extracted.
//              [p]   -- Storage for the returned property value.  On
//                       return this will contain a PROPVARIANT at its head.
//              [pcb] -- Size allocated for p. Space after the PROPVARIANT
//                       structure itself can be used by GetValue to
//                       append structures which are sometimes pointed
//                       at by an PROPVARIANT.
//
//  Returns:    GVRSuccess if successful
//              *[pcb] contains the size required for p.
//
//  History:    16-Oct-91   KyleP       Created.
//
//----------------------------------------------------------------------------

GetValueResult CXprPropertyValue::GetValue( CRetriever & obj,
                                            PROPVARIANT * p,
                                            ULONG * pcb )
{
    return( obj.GetPropertyValue( _pid, p, pcb ) );
}

//+---------------------------------------------------------------------------
//
//  Member:     CXprPropertyValue::ValueType, public
//
//  Returns:    The property type of the property.
//
//  History:    26-Nov-91   KyleP       Created.
//
//----------------------------------------------------------------------------

ULONG CXprPropertyValue::ValueType() const
{
    return( 0 );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\xpr\stateset.cxx ===
//+-------------------------------------------------------------------------
//
//  Copyright (C) 1991, Microsoft Corporation.
//
//  File:       StateSet.hxx
//
//  Contents:
//
//  Classes:
//
//  History:    01-20-92  KyleP     Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include "stateset.hxx"

//+-------------------------------------------------------------------------
//
//  Member:     CStateSet::Clear, public
//
//  Synopsis:   Re-initializes a state set to empty.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

void CStateSet::Clear()
{
    delete _puiRest;

    _cStates = 0;
    _cRest = 0;
    _puiRest = 0;
    _cuiRest = 0;
}

//+-------------------------------------------------------------------------
//
//  Member:     CStateSet::Add, public
//
//  Synopsis:   Adds a state to the state set.
//
//  Arguments:  [state] -- State to add.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

void CStateSet::Add( UINT state )
{
    if ( IsMember( state ) )
        return;

    if ( _cStates < CStateSet_cFirst )
    {
        _auiFirst[ _cStates ] = state;
    }
    else
    {
        if ( _cRest >= _cuiRest )
        {
            UINT * oldpuiRest = _puiRest;
            UINT   oldcuiRest = _cuiRest;

            _cuiRest += 10;
            _puiRest = new UINT [ _cuiRest ];
            memcpy( _puiRest, oldpuiRest, oldcuiRest * sizeof( UINT ) );

            delete oldpuiRest;
        }

        _puiRest[ _cRest ] = state;
        ++_cRest;
    }

    ++_cStates;
}

//+-------------------------------------------------------------------------
//
//  Member:     CStateSet::State, public
//
//  Arguments:  [iState] -- Index of state to return.
//
//  Returns:    The [iState] state in the state set.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

UINT CStateSet::State( UINT iState ) const
{
    if ( iState <= CStateSet_cFirst )
    {
        return( _auiFirst[ iState - 1 ] );
    }
    else
    {
        return( _puiRest[ iState - CStateSet_cFirst - 1 ] );
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CStateSet::IsMember, public
//
//  Arguments:  [state] -- State to look for.
//
//  Returns:    TRUE if [state] is in set.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

BOOL CStateSet::IsMember( UINT state )
{
    if ( _cStates == 0 )
        return( FALSE );

    //
    // Naive implementation.  As long as state sets are small this
    // will work fine.
    //

    for ( int i = min( _cStates, CStateSet_cFirst) - 1;
          i >= 0;
          i-- )
    {
        if( _auiFirst[ i ] == state )
            return( TRUE );
    }

    if ( _cStates > CStateSet_cFirst )
    {
        for ( int i = _cStates - CStateSet_cFirst - 1;
              i >= 0;
              i-- )
        {
            if( _puiRest[ i ] == state )
                return( TRUE );
        }
    }

    return( FALSE );
}

//
// Debug methods
//

int compare( void const * p1, void const * p2 )
{
    return( *(UINT*)p1 - *(UINT*)p2 );
}

#if (CIDBG == 1)

void CStateSet::Display()
{
#if 0
    //
    // Just to always print something close to sorted.
    //

    qsort( _auiFirst,
           ( _cStates < CStateSet_cFirst ) ? _cStates : CStateSet_cFirst,
           sizeof(UINT),
           compare );
#endif
    vqDebugOut(( DEB_REGEX | DEB_NOCOMPNAME, "(" ));

    for (UINT i = 0; i < _cStates; i++)
    {
        if ( i <= CStateSet_cFirst-1 )
            vqDebugOut(( DEB_REGEX | DEB_NOCOMPNAME, " %u", _auiFirst[ i ] ));
        else
            vqDebugOut(( DEB_REGEX | DEB_NOCOMPNAME, 
                         " %u", _puiRest[ i - CStateSet_cFirst ] ));
    }

    vqDebugOut(( DEB_REGEX | DEB_NOCOMPNAME, " )" ));
}

#endif // (CIDBG == 1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\xpr\xlatstat.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1991 - 2000.
//
//  File:       XlatStat.cxx
//
//  Contents:   State translation class.
//
//  Classes:    CXlatState
//
//  History:    01-20-92  KyleP     Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <xlatstat.hxx>

#include "stateset.hxx"

//+-------------------------------------------------------------------------
//
//  Member:     CXlatState::CXlatState, public
//
//  Synopsis:   Initialize state translator (no states)
//
//  Arguments:  [MaxState] -- Largest ordinal of any state that may
//                            appear in an equivalence class.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

CXlatState::CXlatState( UINT MaxState )
        : _cUsed( 0 ),
          _pulStates( 0 ),
          _cStates( 0 )
{
    //
    // Compute the number of DWords / state, assuring at least 1 dword is
    // always allocated.
    //

    _StateSize = (MaxState + sizeof(ULONG) * 8 ) / (sizeof( ULONG ) * 8);
    _Realloc();
};

//+-------------------------------------------------------------------------
//
//  Member:     CXlatState::~CXlatState, public
//
//  Synopsis:   Destroys class.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

CXlatState::~CXlatState()
{
    delete _pulStates;
}

//+-------------------------------------------------------------------------
//
//  Member:     CXlatState::XlatToOne, public
//
//  Synopsis:   Maps a state set to its single state equivalent. If
//              there is no mapping, then one is created.
//
//  Arguments:  [ss] -- State set to search for.
//
//  Returns:    The single state equivalent.
//
//  History:    20-Jun-92 KyleP     Created
//
//--------------------------------------------------------------------------

UINT CXlatState::XlatToOne( CStateSet const & ss )
{
    UINT state = _Search( ss );

    if ( state == 0 )
    {
        state = _Create( ss );
    }

    return( state );
}

//+-------------------------------------------------------------------------
//
//  Member:     CXlatState::XlatToMany, public
//
//  Synopsis:   Maps a state to its matching state set.
//
//  Arguments:  [iState] -- State to map.
//              [ss]     -- On return contains the mapped state set.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

void CXlatState::XlatToMany( UINT iState, CStateSet & ss )
{
    if ( iState > _cUsed )
    {
        vqAssert( FALSE ); 
        return;     // Don't know about this state.
    }

    ULONG * pState = _pulStates + iState * _StateSize;

    for ( int i = _StateSize * sizeof(ULONG) * 8 - 1; i >= 0; i-- )
    {
        if ( pState[i / (sizeof(ULONG) * 8) ] &
                ( 1L << i % (sizeof(ULONG) * 8 ) ) )
        {
            ss.Add( i+1 );
        }
    }
}

//+-------------------------------------------------------------------------
//
//  Member:     CXlatState::_Search, private
//
//  Arguments:  [ss] -- State set to search for.
//
//  Returns:    Single state mapping for [ss] or 0 if none.
//
//  History:    20-Jan-92 KyleP     Created
//
//  Notes:      The first state set is used as temp space.
//
//--------------------------------------------------------------------------

UINT CXlatState::_Search( CStateSet const & ss )
{
    memset( _pulStates, 0, _StateSize * sizeof(ULONG) );
    _BuildState( _pulStates, ss );

    UINT cState = 1;

    while ( cState <= _cUsed )
    {
        if ( memcmp( _pulStates + cState * _StateSize,
                     _pulStates,
                     _StateSize * sizeof(ULONG) ) == 0 )
        {
            return( cState );
        }
        else
        {
            ++cState;
        }
    }

    return( 0 );
}

//+-------------------------------------------------------------------------
//
//  Member:     CXlatState::_Create, private
//
//  Synopsis:   Adds new state set to array.
//
//  Arguments:  [ss] -- State set to add.
//
//  Returns:    Single state mapping for [ss]
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

UINT CXlatState::_Create( CStateSet const & ss )
{
    //
    // _cStates-1 because the first state is temp space.
    //

    if ( _cStates-1 == _cUsed )
        _Realloc();

    ++_cUsed;
    _BuildState( _pulStates + _cUsed * _StateSize, ss );

    return( _cUsed );
}

//+-------------------------------------------------------------------------
//
//  Member:     CXlatState::_BuildState, private
//
//  Synopsis:   Formats state set.
//
//  Arguments:  [ss]     -- Format state set...
//              [pState] --   into this memory.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

void CXlatState::_BuildState( ULONG * pState, CStateSet const & ss )
{
    for ( UINT i = ss.Count(); i > 0; i-- )
    {
        UINT StateNum = ss.State( i ) - 1;
        pState[ StateNum / (sizeof(ULONG) * 8) ] |=
                1L << StateNum % (sizeof(ULONG) * 8);
    }

}

//+-------------------------------------------------------------------------
//
//  Member:     CXlatState::_Realloc, private
//
//  Synopsis:   Grows state set array.
//
//  History:    20-Jan-92 KyleP     Created
//
//  Notes:      Grows linearly, since the number of state sets is likely
//              to be small and we don't want to waste space.
//
//--------------------------------------------------------------------------

void CXlatState::_Realloc()
{
    UINT    oldcStates   = _cStates;
    ULONG * oldpulStates = _pulStates;

    _cStates += 10;
    _pulStates = new ULONG [ _cStates * _StateSize ];

    memcpy( _pulStates,
            oldpulStates,
            oldcStates * _StateSize * sizeof( ULONG ) );

    memset( _pulStates + oldcStates * _StateSize,
            0,
            (_cStates - oldcStates) * _StateSize * sizeof(ULONG) );

    delete [] oldpulStates;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\xpr\xlatchar.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992-2000.
//
//  File:       XlatChar.cxx
//
//  Contents:   Character translation class.
//
//  Classes:    CXlatChar
//
//  History:    02-13-92  KyleP     Created
//
//--------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

// Local includes:
#include <xlatchar.hxx>

inline WCHAR CiToUpper( WCHAR c )
{
    return ( c < L'a' ) ? c : ( c <= L'z' ) ? ( c - (L'a' - L'A') ) :
           RtlUpcaseUnicodeChar( c );
} //CiToUpper

#define TOUPPER CiToUpper

//+-------------------------------------------------------------------------
//
//  Member:     CXlatChar::CXlatChar, public
//
//  Synopsis:   Initializes character mapping (no char classes).
//
//  Arguments:  [fCaseSens] -- TRUE if case sensitive mapping.
//
//  History:    20-Jan-92 KyleP     Created
//              02-Jul-92 KyleP     Added case sensitivity
//
//--------------------------------------------------------------------------

CXlatChar::CXlatChar( BOOLEAN fCaseSens )
        : _cAllocation( 31 ),
          _cRange( 1 ),
          _iPrevRange( 0 ),
          _fCaseSens( fCaseSens )
{
    _pwcRangeEnd = new WCHAR [ _cAllocation ];

    *_pwcRangeEnd = (WCHAR)-1;  // Largest possible character.

#if (CIDBG == 1)
    _fPrepared = FALSE;
#endif
}

//+-------------------------------------------------------------------------
//
//  Member:     CXlatChar::CXlatChar, public
//
//  Synopsis:   Copy constructor
//
//  Arguments:  [src] -- Source
//
//  History:    13-Jul-95 KyleP     Created
//
//--------------------------------------------------------------------------

CXlatChar::CXlatChar( CXlatChar const & src )
        : _cRange( src._cRange ),
          _cAllocation( src._cAllocation ),
          _iPrevRange( src._iPrevRange ),
          _fCaseSens( src._fCaseSens )
#if (CIDBG == 1)
         ,_fPrepared( src._fPrepared )
#endif
{
    _pwcRangeEnd = new WCHAR [ _cAllocation ];
    RtlCopyMemory( _pwcRangeEnd, src._pwcRangeEnd, _cAllocation*sizeof(_pwcRangeEnd[0]) );
}

//+-------------------------------------------------------------------------
//
//  Member:     CXlatChar::AddRange, public
//
//  Synopsis:   Adds range as a new equivalance class.
//
//  Arguments:  [wcStart] -- Start of range.
//              [wcEnd]   -- End of range.
//
//  History:    20-Jan-92 KyleP     Created
//              02-Jul-92 KyleP     Added case sensitivity
//
//--------------------------------------------------------------------------

void CXlatChar::AddRange( WCHAR wcStart, WCHAR wcEnd )
{
    vqAssert( !_fPrepared );

    if ( !_fCaseSens )
    {
        wcStart = TOUPPER( wcStart );
        wcEnd = TOUPPER( wcEnd );
    }

    //
    // Make sure there's room for start and end of range in array.
    //

    if ( _cAllocation - _cRange < 2 )
        _Realloc();

    _pwcRangeEnd[_cRange++] = wcStart - 1;
    _pwcRangeEnd[_cRange++] = wcEnd;
}

//+-------------------------------------------------------------------------
//
//  Member:     CXlatChar::Translate, public
//
//  Synopsis:   Maps character to its equivalence class.
//
//  Arguments:  [wc] -- Character to map.
//
//  Returns:    The equivalence class of character.
//
//  Algorithm:  Binary search array until the correct bin is found.
//
//  History:    20-Jan-92 KyleP     Created
//              02-Jul-92 KyleP     Added case sensitivity
//
//--------------------------------------------------------------------------

UINT CXlatChar::Translate( WCHAR wc ) const
{
    vqAssert( _fPrepared );

    if ( !_fCaseSens )
        wc = TOUPPER( wc );

    if ( wc == '.' )
        return( symDot );

    UINT i    = _cAllocation / 2;
    UINT step = (_cAllocation + 3) / 4;
    WCHAR wcCurrent = _pwcRangeEnd[i];

    while ( step != 0 )
    {
        if ( wcCurrent == wc )
            break;

        if ( wcCurrent < wc )
            i += step;
        else
            i -= step;

        step = step / 2;

        wcCurrent = _pwcRangeEnd[i];
    }

    //
    // If we can't go anywhere, then either i or i + 1 is correct.
    //

    if ( wcCurrent < wc )
        i++;

    return( i + 1 + cSpecialCharClasses );
}

//+-------------------------------------------------------------------------
//
//  Member:     CXlatChar::TranslateRange, public
//
//  Synopsis:   Iterator mapping character range to set of equivalence
//              classes.
//
//  Arguments:  [wcStart] -- Start of range.
//              [wcEnd]   -- End of range.
//
//  Returns:    If [wcStart] is 0 then the next class in the most
//              recently specified range is returned.  Otherwise the
//              first class in the new range is returned.
//
//  History:    20-Jan-92 KyleP     Created
//              02-Jul-92 KyleP     Added case sensitivity
//
//--------------------------------------------------------------------------

UINT CXlatChar::TranslateRange( WCHAR wcStart, WCHAR wcEnd )
{
    if ( !_fCaseSens )
    {
        if ( 0 != wcStart )
            wcStart = TOUPPER( wcStart );

        wcEnd = TOUPPER( wcEnd );
    }

    if ( wcStart > wcEnd )
    {
        vqDebugOut(( DEB_ERROR, "Invalid regex.\n" ));
        THROW( CException( STATUS_INVALID_PARAMETER ) );
    }

    if ( wcStart != 0 )
    {
        _iPrevRange = Translate( wcStart );

        vqDebugOut(( DEB_REGEX, "First range = " ));
    }
    else
    {
        if ( _iPrevRange - cSpecialCharClasses >= _cRange )
            return 0;

        if ( _pwcRangeEnd[_iPrevRange-1-cSpecialCharClasses] >= wcEnd )
            _iPrevRange = 0;
        else
            _iPrevRange++;

        vqDebugOut(( DEB_REGEX, "Secondary range = " ));
    }

    vqDebugOut(( DEB_REGEX | DEB_NOCOMPNAME, "%u\n", _iPrevRange ));
    return _iPrevRange;
}

//+-------------------------------------------------------------------------
//
//  Member:     CXlatChar::Prepare, public
//
//  Synopsis:   Prepares class for translation.
//
//  Requires:   All equivalance classes must be added before prepare is
//              called.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

int _cdecl CompareFn( void const * Elt1, void const * Elt2 )
{
    return( *(WCHAR *)Elt1 - *(WCHAR *)Elt2 );
}

//+-------------------------------------------------------------------------
//
//  Member:     CXlatChar::Prepare, public
//
//  Synopsis:   Called after ranges added to prepare for searching.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

void CXlatChar::Prepare()
{
    //
    // Sort and then remove duplicates from the array.
    //

    qsort( _pwcRangeEnd, _cRange, sizeof( *_pwcRangeEnd ), CompareFn );

    UINT iGood, iCurrent;

    for ( iGood = 0, iCurrent = 1; iCurrent < _cRange; iCurrent++ )
    {
        if ( _pwcRangeEnd[iGood] != _pwcRangeEnd[iCurrent] )
        {
            _pwcRangeEnd[++iGood] = _pwcRangeEnd[iCurrent];
        }
    }

    _cRange = iGood + 1;

    //
    // Make all the extra entries at the end look like the maximum
    // possible character so the binary search works.
    //

    memset( _pwcRangeEnd + _cRange,
            0xFF,
            (_cAllocation - _cRange) * sizeof( WCHAR ) );

#if (CIDBG == 1)
    _fPrepared = TRUE;
#endif

}

//+-------------------------------------------------------------------------
//
//  Member:     CXlatChar::_Realloc, private
//
//  Synopsis:   Grows the character array.
//
//  History:    20-Jan-92 KyleP     Created
//
//--------------------------------------------------------------------------

void CXlatChar::_Realloc()
{
    WCHAR * oldRangeEnd = _pwcRangeEnd;
    UINT    oldcAllocation = _cAllocation;

    _cAllocation = (_cAllocation + 1) * 2 - 1;
    _pwcRangeEnd = new WCHAR [ _cAllocation ];
    memcpy( _pwcRangeEnd, oldRangeEnd, oldcAllocation * sizeof( WCHAR ) );
    delete oldRangeEnd;
}

//
// Debug methods
//

#if (CIDBG == 1)

void CXlatChar::Display() const
{
    vqDebugOut(( DEB_REGEX, "Range\tStart - End\n"
            "-----\t-----   ---\n" ));

    vqDebugOut(( DEB_REGEX, "%s\t\t%u\n", "Any", symAny ));
    vqDebugOut(( DEB_REGEX, "%s\t\t%u\n", "<bol>", symBeginLine ));
    vqDebugOut(( DEB_REGEX, "%s\t\t%u\n", "<eol>", symEndLine ));
    vqDebugOut(( DEB_REGEX, "%s\t%u\n", "Invalid", symInvalid ));
    vqDebugOut(( DEB_REGEX, "%s\t%u\n", "Epsilon", symEpsilon ));
    vqDebugOut(( DEB_REGEX, "%s\t%u\n", "Dot (.)", symDot ));

    vqDebugOut(( DEB_REGEX, "%u\t1\t%u\n",
                 1+cSpecialCharClasses,
                 _pwcRangeEnd[0] ));

    for ( UINT i = 1; i < _cRange; i++ )
    {
        if ( _pwcRangeEnd[i-1]+1 < ' ' ||
             _pwcRangeEnd[i-1]+1 > '~' ||
             _pwcRangeEnd[i]     < ' ' ||
             _pwcRangeEnd[i]     > '~' )
            vqDebugOut(( DEB_REGEX,
                         "%u\t%u\t%u\n",
                         i+1+cSpecialCharClasses,
                         _pwcRangeEnd[i-1]+1,
                         _pwcRangeEnd[i] ));
        else
            vqDebugOut(( DEB_REGEX,
                         "%u\t\"%c\"\t\"%c\"\n",
                         i+1+cSpecialCharClasses,
                         _pwcRangeEnd[i-1]+1,
                         _pwcRangeEnd[i] ));
    }
}

#endif // (CIDBG == 1)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\inetsrv\query\xpr\xpr.cxx ===
//+---------------------------------------------------------------------------
//
// Copyright (C) Microsoft Corporation, 1991 - 2000.
//
// File:        Xpr.cxx
//
// Contents:    Internal expression classes
//
// Classes:     CXpr
//
// History:     11-Sep-91       KyleP   Created
//
//----------------------------------------------------------------------------

#include <pch.cxx>
#pragma hdrstop

#include <xpr.hxx>

//+---------------------------------------------------------------------------
//
//  Member:     CXpr::IsMatch, public
//
//  Arguments:  [obj] -- Objects table
//
//  Returns:    FALSE (default)
//
//  History:    01-Dec-91   KyleP       Created.
//
//----------------------------------------------------------------------------

BOOL CXpr::IsMatch( CRetriever & )
{
    return( FALSE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CXpr::HitCount, public
//
//  Returns:    0 (default)
//
//  History:    01-May-91   KyleP       Created.
//
//----------------------------------------------------------------------------

ULONG CXpr::HitCount( CRetriever & )
{
    return( 0 );
}

//+---------------------------------------------------------------------------
//
//  Member:     CXpr::Rank, public
//
//  Returns:    MaxRank (default)
//
//  History:    01-May-91   KyleP       Created.
//
//----------------------------------------------------------------------------

LONG CXpr::Rank( CRetriever & )
{
    return( MAX_QUERY_RANK );
}

//+---------------------------------------------------------------------------
//
//  Member:     CXpr::ValueType, public
//
//  Returns:    Default value type (PTNone).
//
//  History:    26-Nov-91   KyleP       Created.
//
//----------------------------------------------------------------------------

ULONG CXpr::ValueType() const
{
    return( VT_EMPTY );
}

//+---------------------------------------------------------------------------
//
//  Member:     CXpr::Clone(), public
//
//  Returns:    A new copy of the expression.
//
//  Signals:    ???
//
//  History:    11-Dec-91   KyleP       Created.
//
//  Notes:      This must be subclassed by every node type which will
//              actually be cloned.
//
//----------------------------------------------------------------------------

CXpr * CXpr::Clone()
{
    //
    // It is illegal to clone an expression which hasn't over-ridden this.
    //

    Win4Assert( 0 );

    return( 0 );
}

//+---------------------------------------------------------------------------
//
//  Member:     CXpr::IsLeaf, public
//
//  Synopsis:   Determines if an expression is a leaf node.
//
//  Returns:    TRUE for this default implementation.
//
//  History:    11-Dec-91   KyleP       Created.
//
//----------------------------------------------------------------------------

BOOL CXpr::IsLeaf() const
{
    return( TRUE );
}

//+---------------------------------------------------------------------------
//
//  Member:     CXpr::GetValue, public
//
//  Synopsis:   Calculates the value of the expression for the current object.
//
//  Arguments:  [obj] -- Objects table.  Positioned to current object.
//              [p]   -- Buffer to store value.
//              [pcb] -- On input, size of p, on output, return size if
//                       successful, else required size.
//
//  Returns:    GVRNotSupported for this default implementation.
//
//  History:    11-Dec-91   KyleP       Created.
//
//  Notes:      This is a virtual method of CXpr to make it a simple
//              transformation to allow *any* expression to return a
//              value instead of just property value expressions.
//
//----------------------------------------------------------------------------

GetValueResult CXpr::GetValue(CRetriever &, PROPVARIANT *, ULONG *)
{
    return( GVRNotSupported );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\actxprxy\call_as.c ===
#include "rpcproxy.h"
#include "docobj.h"
#include "servprov.h"
#include "dispex.h"
#include "comcat.h"
#include "activscp.h"


/* [local] */ HRESULT __stdcall IEnumOleDocumentViews_Next_Proxy(
    IEnumOleDocumentViews __RPC_FAR * This,
    /* [in] */ ULONG cViews,
    /* [out] */ IOleDocumentView __RPC_FAR *__RPC_FAR *rgpViews,
    /* [out] */ ULONG __RPC_FAR *pcFetched)
{
    HRESULT hr;
    ULONG cFetched = 0;

    hr = IEnumOleDocumentViews_RemoteNext_Proxy(This, cViews, rgpViews, &cFetched);

    if(pcFetched != 0)
        *pcFetched = cFetched;

    return hr;
}



/* [call_as] */ HRESULT __stdcall IEnumOleDocumentViews_Next_Stub(
    IEnumOleDocumentViews __RPC_FAR * This,
    /* [in] */ ULONG cViews,
    /* [length_is][size_is][out] */ IOleDocumentView __RPC_FAR *__RPC_FAR *rgpView,
    /* [out] */ ULONG __RPC_FAR *pcFetched)

{
    HRESULT hr;

    *pcFetched = 0;
    hr = This->lpVtbl->Next(This, cViews, rgpView, pcFetched);

    return hr;
}




/* [local] */ HRESULT __stdcall IPrint_Print_Proxy(
    IPrint __RPC_FAR * This,
    /* [in] */ DWORD grfFlags,
    /* [out][in] */ DVTARGETDEVICE __RPC_FAR *__RPC_FAR *pptd,
    /* [out][in] */ PAGESET __RPC_FAR *__RPC_FAR *ppPageSet,
    /* [unique][out][in] */ STGMEDIUM __RPC_FAR *pstgmOptions,
    /* [in] */ IContinueCallback __RPC_FAR *pcallback,
    /* [in] */ LONG nFirstPage,
    /* [out] */ LONG __RPC_FAR *pcPagesPrinted,
    /* [out] */ LONG __RPC_FAR *pnLastPage)
{
        return IPrint_RemotePrint_Proxy(This, grfFlags, pptd, ppPageSet,
                                        (RemSTGMEDIUM __RPC_FAR *) pstgmOptions, pcallback,
                                        nFirstPage, pcPagesPrinted, pnLastPage);
}


/* [call_as] */ HRESULT __stdcall IPrint_Print_Stub(
    IPrint __RPC_FAR * This,
    /* [in] */ DWORD grfFlags,
    /* [out][in] */ DVTARGETDEVICE __RPC_FAR *__RPC_FAR *pptd,
    /* [out][in] */ PAGESET __RPC_FAR *__RPC_FAR *ppPageSet,
    /* [unique][out][in] */ RemSTGMEDIUM __RPC_FAR *pstgmOptions,
    /* [in] */ IContinueCallback __RPC_FAR *pcallback,
    /* [in] */ LONG nFirstPage,
    /* [out] */ LONG __RPC_FAR *pcPagesPrinted,
    /* [out] */ LONG __RPC_FAR *pnLastPage)
{
    return This->lpVtbl->Print(This, grfFlags, pptd, ppPageSet,
                                        (STGMEDIUM __RPC_FAR *) pstgmOptions, pcallback,
                                        nFirstPage, pcPagesPrinted, pnLastPage);
}

/* [local] */ HRESULT __stdcall IServiceProvider_QueryService_Proxy(
    IServiceProvider __RPC_FAR * This,
    /* [in] */ REFGUID guidService,
    /* [in] */ REFIID riid,
    /* [out] */ void __RPC_FAR *__RPC_FAR *ppvObject)
{
    *ppvObject = NULL;
    return IServiceProvider_RemoteQueryService_Proxy(This, guidService, riid,
                                        (IUnknown**)ppvObject);
}

/* [call_as] */ HRESULT __stdcall IServiceProvider_QueryService_Stub(
    IServiceProvider __RPC_FAR * This,
    /* [in] */ REFGUID guidService,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ IUnknown __RPC_FAR *__RPC_FAR *ppvObject)
{
    *ppvObject = NULL;
    return This->lpVtbl->QueryService(This, guidService, riid, ppvObject);
}


/* [local] */ HRESULT STDMETHODCALLTYPE ICatInformation_EnumClassesOfCategories_Proxy( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ ULONG cImplemented,
    /* [size_is][in] */ CATID __RPC_FAR rgcatidImpl[  ],
    /* [in] */ ULONG cRequired,
    /* [size_is][in] */ CATID __RPC_FAR rgcatidReq[  ],
    /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumClsid)
{
    BOOL fcImpl,fcReq;
    if (cImplemented == (ULONG)-1)
    {
        rgcatidImpl = NULL;
    }

    if (cRequired == (ULONG)-1)
    {
       rgcatidReq = NULL;
    }

    return ICatInformation_RemoteEnumClassesOfCategories_Proxy(This,cImplemented,rgcatidImpl,
        cRequired,rgcatidReq,ppenumClsid);

}


/* [call_as] */ HRESULT STDMETHODCALLTYPE ICatInformation_EnumClassesOfCategories_Stub( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ ULONG cImplemented,
    /* [size_is][in] */ CATID __RPC_FAR rgcatidImpl[  ],
    /* [in] */ ULONG cRequired,
    /* [size_is][in] */ CATID __RPC_FAR rgcatidReq[  ],
    /* [out] */ IEnumGUID __RPC_FAR *__RPC_FAR *ppenumClsid)
{
    return This->lpVtbl->EnumClassesOfCategories(This,cImplemented,rgcatidImpl,
        cRequired,rgcatidReq,ppenumClsid);
}


/* [local] */ HRESULT STDMETHODCALLTYPE ICatInformation_IsClassOfCategories_Proxy( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ ULONG cImplemented,
    /* [size_is][in] */ CATID __RPC_FAR rgcatidImpl[  ],
    /* [in] */ ULONG cRequired,
    /* [size_is][in] */ CATID __RPC_FAR rgcatidReq[  ])
{
    BOOL fcImpl,fcReq;
    if (cImplemented == (ULONG)-1)
    {
        rgcatidImpl = NULL;
    }
    else
        fcImpl = FALSE;

    if (cRequired == (ULONG)-1 )
    {
       rgcatidReq = NULL;
    }
    else
       fcReq = FALSE;

    return ICatInformation_RemoteIsClassOfCategories_Proxy(This,rclsid,cImplemented,rgcatidImpl,
        cRequired,rgcatidReq);
}


/* [call_as] */ HRESULT STDMETHODCALLTYPE ICatInformation_IsClassOfCategories_Stub( 
    ICatInformation __RPC_FAR * This,
    /* [in] */ REFCLSID rclsid,
    /* [in] */ ULONG cImplemented,
    /* [size_is][in] */ CATID __RPC_FAR rgcatidImpl[  ],
    /* [in] */ ULONG cRequired,
    /* [size_is][in] */ CATID __RPC_FAR rgcatidReq[  ])
{
    return This->lpVtbl->IsClassOfCategories(This,rclsid,cImplemented,rgcatidImpl,
        cRequired,rgcatidReq);

}

// IActiveScriptError

/* [local] */ HRESULT __stdcall IActiveScriptError_GetExceptionInfo_Proxy(
    IActiveScriptError __RPC_FAR * This,
	/* [out] */ EXCEPINFO  *pexcepinfo)
{
    return IActiveScriptError_RemoteGetExceptionInfo_Proxy(This, pexcepinfo);
}

/* [call_as] */ HRESULT __stdcall IActiveScriptError_GetExceptionInfo_Stub(
	IActiveScriptError __RPC_FAR * This,
	/* [out] */ EXCEPINFO  *pexcepinfo)
{
	HRESULT hr;

	hr = This->lpVtbl->GetExceptionInfo(This, pexcepinfo);
	if (SUCCEEDED (hr) && pexcepinfo->pfnDeferredFillIn != NULL)
	{
		if (FAILED(pexcepinfo->pfnDeferredFillIn(pexcepinfo)))
			hr = ResultFromScode(pexcepinfo->scode);
	}

	return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\actxprxy\dex_as.c ===
#include "rpcproxy.h"
#include "dispex.h"


/* [local] */ HRESULT STDMETHODCALLTYPE IDispatchEx_InvokeEx_Proxy(
    IDispatchEx __RPC_FAR * This,
    /* [in] */ DISPID id,
    /* [in] */ LCID lcid,
    /* [in] */ WORD wFlags,
    /* [in] */ DISPPARAMS __RPC_FAR *pdp,
    /* [unique][out][in] */ VARIANT __RPC_FAR *pvarRes,
    /* [unique][out][in] */ EXCEPINFO __RPC_FAR *pei,
    /* [unique][in] */ IServiceProvider __RPC_FAR *pspCaller)
{
	// CLIENT side code.

	// Clear *pvarRes.
	if (NULL != pvarRes)
		memset(pvarRes, 0, sizeof(*pvarRes));
	// Clear *pei.
	if (NULL != pei)
		memset(pei, 0, sizeof(*pei));

	return IDispatchEx_RemoteInvokeEx_Proxy(This, id, lcid, wFlags, pdp,
		pvarRes, pei, pspCaller);
}


/* [call_as] */ HRESULT STDMETHODCALLTYPE IDispatchEx_InvokeEx_Stub(
    IDispatchEx __RPC_FAR * This,
    /* [in] */ DISPID id,
    /* [in] */ LCID lcid,
    /* [in] */ WORD wFlags,
    /* [in] */ DISPPARAMS __RPC_FAR *pdp,
    /* [unique][out][in] */ VARIANT __RPC_FAR *pvarRes,
    /* [unique][out][in] */ EXCEPINFO __RPC_FAR *pei,
    /* [unique][in] */ IServiceProvider __RPC_FAR *pspCaller)
{
	// SERVER side code.

	// Clear *pvarRes.
	if (NULL != pvarRes)
		memset(pvarRes, 0, sizeof(*pvarRes));
	// Clear *pei.
	if (NULL != pei)
		memset(pei, 0, sizeof(*pei));

	return This->lpVtbl->InvokeEx(This, id, lcid, wFlags, pdp,
		pvarRes, pei, pspCaller);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\actxprxy\makefile.inc ===
clean:
    -del *_p.c
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\actxprxy\mshtmlp.c ===
#define HDC_UserSize HWND_UserSize
#define HDC_UserMarshal HWND_UserMarshal
#define HDC_UserUnmarshal HWND_UserUnmarshal
#define HDC_UserFree HWND_UserFree
 
#pragma warning(disable:4028)
#include "mshtml_p.c"
#pragma warning(default:4028)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\advapi32\advapi.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    advapi.h

Abstract:

    This module contains private function prototypes
    and types for the advanced 32-bit windows base APIs.

Author:

    Mark Lucovsky (markl) 18-Sep-1990

Revision History:

--*/

#ifndef _ADVAPI_
#define _ADVAPI_

#undef UNICODE

//
// get thunks right
//

#ifndef _ADVAPI32_
#define _ADVAPI32_
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#ifdef __cplusplus
extern "C" {
#endif
//
// Include Common Definitions.
//

ULONG
BaseSetLastNTError(
    IN NTSTATUS Status
    );


extern RTL_CRITICAL_SECTION Logon32Lock ;

#ifdef __cplusplus
} // extern "C"
#endif

#endif _ADVAPI_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\actxprxy\dlldatax.c ===
/*********************************************************
   DllData file -- THIS IS NOT GENERATED BY MIDL, BUT BY HAND

   Instructions: every idl file that wants to be in actxprxy.dll
   must be included under (follow example of htiface.idl)
EXTERN_PROXY_FILE
REFERENCE_PROXY_FILE

*********************************************************/

#define PROXY_DELEGATION

#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( activscp )
EXTERN_PROXY_FILE( comcat )
EXTERN_PROXY_FILE( docobj )
EXTERN_PROXY_FILE( hlink )
EXTERN_PROXY_FILE( htiface )
EXTERN_PROXY_FILE( htiframe )
EXTERN_PROXY_FILE( htprivwn )
EXTERN_PROXY_FILE( mimeinfo )
EXTERN_PROXY_FILE( mshtml )
EXTERN_PROXY_FILE( objsafe )
EXTERN_PROXY_FILE( servprov )
EXTERN_PROXY_FILE( shldisp )
EXTERN_PROXY_FILE( urlhist )
EXTERN_PROXY_FILE( ocmm )
EXTERN_PROXY_FILE( callback )
EXTERN_PROXY_FILE( webcheck )
EXTERN_PROXY_FILE( shobjidl )
EXTERN_PROXY_FILE( shpriv )
EXTERN_PROXY_FILE( subsmgr )
EXTERN_PROXY_FILE( imapi )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( activscp ),
  REFERENCE_PROXY_FILE( comcat ),
  REFERENCE_PROXY_FILE( docobj ),
  REFERENCE_PROXY_FILE( hlink ),
  REFERENCE_PROXY_FILE( htiface ),
  REFERENCE_PROXY_FILE( htiframe ),
  REFERENCE_PROXY_FILE( htprivwn ),
  REFERENCE_PROXY_FILE( mimeinfo ),
  REFERENCE_PROXY_FILE( mshtml ),
  REFERENCE_PROXY_FILE( objsafe ),
  REFERENCE_PROXY_FILE( servprov ),
  REFERENCE_PROXY_FILE( shldisp ),
  REFERENCE_PROXY_FILE( urlhist ),
  REFERENCE_PROXY_FILE( ocmm ),
  REFERENCE_PROXY_FILE( callback ),
  REFERENCE_PROXY_FILE( webcheck ),
  REFERENCE_PROXY_FILE( shobjidl ),
  REFERENCE_PROXY_FILE( shpriv ),
  REFERENCE_PROXY_FILE( subsmgr ),
  REFERENCE_PROXY_FILE( imapi ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\mergedcomponents\advapi32\cryptapi.c ===
/////////////////////////////////////////////////////////////////////////////
//  FILE          : cryptapi.c                                             //
//  DESCRIPTION   : Crypto API interface                                   //
//  AUTHOR        :                                                        //
//  HISTORY       :                                                        //
//      Dec  6 1994 larrys  New                                            //
//      Jan 16 1995 larrys  Added key verify                               //
//      Jan 25 1995 larrys  Added thread safe                              //
//      Jan 27 1995 larrys  Added Unicode support                          //
//      Feb 21 1995 larrys  Added Unicode support for CryptAcquireContext  //
//      Feb 21 1995 larrys  Fixed Unicode problem in CryptAcquireContext   //
//      Mar 08 1995 larrys  Removed CryptGetLastError                      //
//      Mar 20 1995 larrys  Removed Certificate APIs                       //
//      Mar 22 1995 larrys  #ifdef in WIN95 code                           //
//      Apr 06 1995 larrys  Increased signature key to 1024 bits           //
//      Apr 07 1995 larrys  Removed CryptConfigure                         //
//      Jun 14 1995 larrys  Removed pointer from RSA key struct            //
//      Jun 29 1995 larrys  Changed AcquireContext                         //
//      Jul 17 1995 larrys  Worked on AcquireContext                       //
//      Aug 01 1995 larrys  Removed CryptTranslate                         //
//                          And CryptDeinstallProvider                     //
//                          Changed CryptInstallProvider to                //
//                          CryptSetProvider                               //
//      Aug 03 1995 larrys  Cleanup                                        //
//      Aug 10 1995 larrys  CryptAcquireContext returns error              //
//                          NTE_BAD_KEYSEY_PARAM now                       //
//      Aug 14 1995 larrys  Removed key exchange stuff                     //
//      Aug 17 1995 larrys  Changed registry entry to decimcal             //
//      Aug 23 1995 larrys  Changed CryptFinishHash to CryptGetHashValue   //
//      Aug 28 1995 larrys  Removed parameter from CryptVerifySignature    //
//      Aug 31 1995 larrys  Remove GenRandom                               //
//      Sep 14 1995 larrys  Code review changes                            //
//      Sep 26 1995 larrys  Added Microsoft's signing key                  //
//      Sep 27 1995 larrys  Updated with more review changes               //
//      Oct 06 1995 larrys  Added more APIs Get/SetHash/ProvParam          //
//      Oct 12 1995 larrys  Remove CryptGetHashValue                       //
//      Oct 20 1995 larrys  Changed test key                               //
//      Oct 24 1995 larrys  Removed return of KeySet name                  //
//      Oct 30 1995 larrys  Removed WIN95                                  //
//      Nov  9 1995 larrys  Disable BUILD1057                              //
//      Nov 10 1995 larrys  Fix a problem in EnterHashCritSec              //
//      May 30 1996 larrys  Added hWnd support                             //
//      Oct 10 1996 jeffspel Reordered SetLastErrors and save error on     //
//                           AcquireContext failure                        //
//      Mar 21 1997 jeffspel Added second tier signatures, new APIs        //
//      Apr 11 1997 jeffspel Replace critical sections with interlocked    //
//                           inc/dec                                       //
//      Oct 02 1997 jeffspel Add caching of CSPs to CryptAcquireContext    //
//      Oct 10 1997 jeffspel Add verification scheme for signature in file //
//                                                                         //
//  Copyright (C) 1993 Microsoft Corporation   All Rights Reserved         //
/////////////////////////////////////////////////////////////////////////////


#include "advapi.h"
#include "stdlib.h"
#include <wincrypt.h>   // Include here, since not included by LEAN_AND_MEAN
#include <cspdk.h>
#include <ntstatus.h>
#include <rsa.h>
#include <md5.h>
#include <rc4.h>
#include <winperf.h>
#ifndef WIN95
#include <wtypes.h>
#endif

#define IDR_PUBKEY1                     102

#ifdef WIN95
#define RtlEqualMemory(a, b, c) memcmp(a, b, c) == 0
#endif

typedef struct _VTableStruc {
// ******************** WARNING **********************************************
// Do not place anything before these FARPROCs we init the table assuming
// that the first Function to call is the first thing in the table.
// ***************************************************************************
    FARPROC FuncAcquireContext;
    FARPROC FuncReleaseContext;
    FARPROC FuncGenKey;
    FARPROC FuncDeriveKey;
    FARPROC FuncDestroyKey;
    FARPROC FuncSetKeyParam;
    FARPROC FuncGetKeyParam;
    FARPROC FuncExportKey;
    FARPROC FuncImportKey;
    FARPROC FuncEncrypt;
    FARPROC FuncDecrypt;
    FARPROC FuncCreateHash;
    FARPROC FuncHashData;
    FARPROC FuncHashSessionKey;
    FARPROC FuncDestroyHash;
    FARPROC FuncSignHash;
    FARPROC FuncVerifySignature;
    FARPROC FuncGenRandom;
    FARPROC FuncGetUserKey;
    FARPROC FuncSetProvParam;
    FARPROC FuncGetProvParam;
    FARPROC FuncSetHashParam;
    FARPROC FuncGetHashParam;
    FARPROC FuncNULL;

    FARPROC OptionalFuncDuplicateKey;
    FARPROC OptionalFuncDuplicateHash;
    FARPROC OptionalFuncNULL;

    HANDLE      DllHandle;                     // Handle to open DLL
    HCRYPTPROV  hProv;                         // Handle to provider
    DWORD       Version;
    DWORD       Inuse;
    LONG        RefCnt;
} VTableStruc, *PVTableStruc;

typedef struct _VKeyStruc {
// ******************** WARNING **********************************************
// Do not place anything before these FARPROCs we init the table assuming
// that the first Function to call is the first thing in the table.
// ***************************************************************************
    FARPROC FuncGenKey;
    FARPROC FuncDeriveKey;
    FARPROC FuncDestroyKey;
    FARPROC FuncSetKeyParam;
    FARPROC FuncGetKeyParam;
    FARPROC FuncExportKey;
    FARPROC FuncImportKey;
    FARPROC FuncEncrypt;
    FARPROC FuncDecrypt;

    FARPROC OptionalFuncDuplicateKey;

    HCRYPTPROV  hProv;                         // Handle to provider
    HCRYPTKEY   hKey;                          // Handle to key
    DWORD       Version;
    DWORD       Inuse;
} VKeyStruc, *PVKeyStruc;

typedef struct _VHashStruc {
// ******************** WARNING **********************************************
// Do not place anything before these FARPROCs we init the table assuming
// that the first Function to call is the first thing in the table.
// ***************************************************************************
    FARPROC FuncCreateHash;
    FARPROC FuncHashData;
    FARPROC FuncHashSessionKey;
    FARPROC FuncDestroyHash;
    FARPROC FuncSignHash;
    FARPROC FuncVerifySignature;
    FARPROC FuncSetHashParam;
    FARPROC FuncGetHashParam;

    FARPROC OptionalFuncDuplicateHash;

    HCRYPTPROV  hProv;                         // Handle to provider
    HCRYPTHASH  hHash;                         // Handle to hash
    DWORD       Version;
    DWORD       Inuse;
} VHashStruc, *PVHashStruc;


//
// Crypto providers have to have the following entry points:
//
LPCSTR FunctionNames[] = {
    "CPAcquireContext",
    "CPReleaseContext",
    "CPGenKey",
    "CPDeriveKey",
    "CPDestroyKey",
    "CPSetKeyParam",
    "CPGetKeyParam",
    "CPExportKey",
    "CPImportKey",
    "CPEncrypt",
    "CPDecrypt",
    "CPCreateHash",
    "CPHashData",
    "CPHashSessionKey",
    "CPDestroyHash",
    "CPSignHash",
    "CPVerifySignature",
    "CPGenRandom",
    "CPGetUserKey",
    "CPSetProvParam",
    "CPGetProvParam",
    "CPSetHashParam",
    "CPGetHashParam",
    NULL
    };

LPCSTR OptionalFunctionNames[] = {
    "CPDuplicateKey",
    "CPDuplicateHash",
    NULL
    };

HWND hWnd = NULL;
BYTE *pbContextInfo = NULL;
DWORD cbContextInfo;

#define KEYSIZE512 0x48
#define KEYSIZE1024 0x88

// designatred resource for in file signatures
#define OLD_CRYPT_SIG_RESOURCE_NUMBER   "#666"


typedef struct _SECONDTIER_SIG
{
    DWORD           dwMagic;
    DWORD           cbSig;
    BSAFE_PUB_KEY   Pub;
} SECOND_TIER_SIG, *PSECOND_TIER_SIG;

#ifdef TEST_BUILD_EXPONENT
#pragma message("WARNING: building advapai32.dll with TESTKEY enabled!")
static struct _TESTKEY {
    BSAFE_PUB_KEY    PUB;
    unsigned char pubmodulus[KEYSIZE512];
} TESTKEY = {
    {
    0x66b8443b,
    0x6f5fc900,
    0xa12132fe,
    0xff1b06cf,
    0x2f4826eb,
    },
    {
    0x3e, 0x69, 0x4f, 0x45, 0x31, 0x95, 0x60, 0x6c,
    0x80, 0xa5, 0x41, 0x99, 0x3e, 0xfc, 0x92, 0x2c,
    0x93, 0xf9, 0x86, 0x23, 0x3d, 0x48, 0x35, 0x81,
    0x19, 0xb6, 0x7c, 0x04, 0x43, 0xe6, 0x3e, 0xd4,
    0xd5, 0x43, 0xaf, 0x52, 0xdd, 0x51, 0x20, 0xac,
    0xc3, 0xca, 0xee, 0x21, 0x9b, 0x4a, 0x2d, 0xf7,
    0xd8, 0x5f, 0x32, 0xeb, 0x49, 0x72, 0xb9, 0x8d,
    0x2e, 0x1a, 0x76, 0x7f, 0xde, 0xc6, 0x75, 0xab,
    0xaf, 0x67, 0xe0, 0xf0, 0x8b, 0x30, 0x20, 0x92,
    }
};
#endif


#ifdef MS_INTERNAL_KEY
static struct _mskey {
    BSAFE_PUB_KEY    PUB;
    unsigned char pubmodulus[KEYSIZE1024];
} MSKEY = {
    {
    0x2bad85ae,
    0x883adacc,
    0xb32ebd68,
    0xa7ec8b06,
    0x58dbeb81,
    },
    {
    0x42, 0x34, 0xb7, 0xab, 0x45, 0x0f, 0x60, 0xcd,
    0x8f, 0x77, 0xb5, 0xd1, 0x79, 0x18, 0x34, 0xbe,
    0x66, 0xcb, 0x5c, 0x66, 0x4a, 0x9f, 0x03, 0x18,
    0x13, 0x36, 0x8e, 0x88, 0x21, 0x78, 0xb1, 0x94,
    0xa1, 0xd5, 0x8f, 0x8c, 0xa5, 0xd3, 0x9f, 0x86,
    0x43, 0x89, 0x05, 0xa0, 0xe3, 0xee, 0xe2, 0xd0,
    0xe5, 0x1d, 0x5f, 0xaf, 0xff, 0x85, 0x71, 0x7a,
    0x0a, 0xdb, 0x2e, 0xd8, 0xc3, 0x5f, 0x2f, 0xb1,
    0xf0, 0x53, 0x98, 0x3b, 0x44, 0xee, 0x7f, 0xc9,
    0x54, 0x26, 0xdb, 0xdd, 0xfe, 0x1f, 0xd0, 0xda,
    0x96, 0x89, 0xc8, 0x9e, 0x2b, 0x5d, 0x96, 0xd1,
    0xf7, 0x52, 0x14, 0x04, 0xfb, 0xf8, 0xee, 0x4d,
    0x92, 0xd1, 0xb6, 0x37, 0x6a, 0xe0, 0xaf, 0xde,
    0xc7, 0x41, 0x06, 0x7a, 0xe5, 0x6e, 0xb1, 0x8c,
    0x8f, 0x17, 0xf0, 0x63, 0x8d, 0xaf, 0x63, 0xfd,
    0x22, 0xc5, 0xad, 0x1a, 0xb1, 0xe4, 0x7a, 0x6b,
    0x1e, 0x0e, 0xea, 0x60, 0x56, 0xbd, 0x49, 0xd0,
    }
};
#endif


static struct _key {
    BSAFE_PUB_KEY    PUB;
    unsigned char pubmodulus[KEYSIZE1024];
} KEY = {
    {
    0x3fcbf1a9,
    0x08f597db,
    0xe4aecab4,
    0x75360f90,
    0x9d6c0f00,
    },
    {
    0x85, 0xdd, 0x9b, 0xf4, 0x4d, 0x0b, 0xc4, 0x96,
    0x3e, 0x79, 0x86, 0x30, 0x6d, 0x27, 0x31, 0xee,
    0x4a, 0x85, 0xf5, 0xff, 0xbb, 0xa9, 0xbd, 0x81,
    0x86, 0xf2, 0x4f, 0x87, 0x6c, 0x57, 0x55, 0x19,
    0xe4, 0xf4, 0x49, 0xa3, 0x19, 0x27, 0x08, 0x82,
    0x9e, 0xf9, 0x8a, 0x8e, 0x41, 0xd6, 0x91, 0x71,
    0x47, 0x48, 0xee, 0xd6, 0x24, 0x2d, 0xdd, 0x22,
    0x72, 0x08, 0xc6, 0xa7, 0x34, 0x6f, 0x93, 0xd2,
    0xe7, 0x72, 0x57, 0x78, 0x7a, 0x96, 0xc1, 0xe1,
    0x47, 0x38, 0x78, 0x43, 0x53, 0xea, 0xf3, 0x88,
    0x82, 0x66, 0x41, 0x43, 0xd4, 0x62, 0x44, 0x01,
    0x7d, 0xb2, 0x16, 0xb3, 0x50, 0x89, 0xdb, 0x0a,
    0x93, 0x17, 0x02, 0x02, 0x46, 0x49, 0x79, 0x76,
    0x59, 0xb6, 0xb1, 0x2b, 0xfc, 0xb0, 0x9a, 0x21,
    0xe6, 0xfa, 0x2d, 0x56, 0x07, 0x36, 0xbc, 0x13,
    0x7f, 0x1c, 0xde, 0x55, 0xfb, 0x0d, 0x67, 0x0f,
    0xc2, 0x17, 0x45, 0x8a, 0x14, 0x2b, 0xba, 0x55,
    }
};


static struct _key2 {
    BSAFE_PUB_KEY    PUB;
    unsigned char pubmodulus[KEYSIZE1024];
} KEY2 =  {
    {
    0x685fc690,
    0x97d49b6b,
    0x1dccd9d2,
    0xa5ec9b52,
    0x64fd29d7,
    },
    {
    0x03, 0x8c, 0xa3, 0x9e, 0xfb, 0x93, 0xb6, 0x72,
    0x2a, 0xda, 0x6f, 0xa5, 0xec, 0x26, 0x39, 0x58,
    0x41, 0xcd, 0x3f, 0x49, 0x10, 0x4c, 0xcc, 0x7e,
    0x23, 0x94, 0xf9, 0x5d, 0x9b, 0x2b, 0xa3, 0x6b,
    0xe8, 0xec, 0x52, 0xd9, 0x56, 0x64, 0x74, 0x7c,
    0x44, 0x6f, 0x36, 0xb7, 0x14, 0x9d, 0x02, 0x3c,
    0x0e, 0x32, 0xb6, 0x38, 0x20, 0x25, 0xbd, 0x8c,
    0x9b, 0xd1, 0x46, 0xa7, 0xb3, 0x58, 0x4a, 0xb7,
    0xdd, 0x0e, 0x38, 0xb6, 0x16, 0x44, 0xbf, 0xc1,
    0xca, 0x4d, 0x6a, 0x9f, 0xcb, 0x6f, 0x3c, 0x5f,
    0x03, 0xab, 0x7a, 0xb8, 0x16, 0x70, 0xcf, 0x98,
    0xd0, 0xca, 0x8d, 0x25, 0x57, 0x3a, 0x22, 0x8b,
    0x44, 0x96, 0x37, 0x51, 0x30, 0x00, 0x92, 0x1b,
    0x03, 0xb9, 0xf9, 0x0d, 0xb3, 0x1a, 0xe2, 0xb4,
    0xc5, 0x7b, 0xc9, 0x4b, 0xe2, 0x42, 0x25, 0xfe,
    0x3d, 0x42, 0xfa, 0x45, 0xc6, 0x94, 0xc9, 0x8e,
    0x87, 0x7e, 0xf6, 0x68, 0x90, 0x30, 0x65, 0x10,
    }
};

#define CACHESIZE   32
static HANDLE   gCSPCache[CACHESIZE];

#define TABLEPROV       0x11111111
#define TABLEKEY        0x22222222
#define TABLEHASH       0x33333333

CHAR szreg[] = "SOFTWARE\\Microsoft\\Cryptography\\Providers\\";
CHAR szusertype[] = "SOFTWARE\\Microsoft\\Cryptography\\Providers\\Type ";
CHAR szmachinetype[] = "SOFTWARE\\Microsoft\\Cryptography\\Defaults\\Provider Types\\Type ";
CHAR szprovider[] = "SOFTWARE\\Microsoft\\Cryptography\\Defaults\\Provider\\";
CHAR szenumproviders[] = "SOFTWARE\\Microsoft\\Cryptography\\Defaults\\Provider";
CHAR szprovidertypes[] = "SOFTWARE\\Microsoft\\Cryptography\\Defaults\\Provider Types";

BOOL EnterProviderCritSec(IN PVTableStruc pVTable);
void LeaveProviderCritSec(IN PVTableStruc pVTable);
BOOL EnterKeyCritSec(IN PVKeyStruc pVKey);
void LeaveKeyCritSec(IN PVKeyStruc pVKey);
BOOL EnterHashCritSec(IN PVHashStruc pVHash);
void LeaveHashCritSec(IN PVHashStruc pVHash);

BOOL CheckSignatureInFile(LPCWSTR pszImage);

BOOL CProvVerifyImage(LPCSTR lpszImage,
                      BYTE *pSigData);

BOOL NewVerifyImage(LPCSTR lpszImage,
                    BYTE *pSigData,
                    DWORD cbData,
                    BOOL fUnknownLen);

BOOL BuildVKey(IN PVKeyStruc *ppVKey,
               IN PVTableStruc pVTable);

BOOL BuildVHash(
                IN PVHashStruc *ppVKey,
                IN PVTableStruc pVTable
                );

void CPReturnhWnd(HWND *phWnd);

static void __ltoa(DWORD val, char *buf);

#ifdef WIN95

DWORD GetCryptApiExponentValue(VOID);  //Entry point from kernel32.

// StrToL
//      Can't use CRT routines, so steal from the C runtime sources

DWORD StrToL(CHAR *InStr)
{
    DWORD dwVal = 0;

    while(*InStr)
    {
        dwVal = (10 * dwVal) + (*InStr - '0');
        InStr++;
    }

    return dwVal;
}

VOID
RtlInitAnsiString(
    OUT PANSI_STRING DestinationString,
    IN PCSZ SourceString OPTIONAL
    )

/*++

Routine Description:

    The RtlInitAnsiString function initializes an NT counted string.
    The DestinationString is initialized to point to the SourceString
    and the Length and MaximumLength fields of DestinationString are
    initialized to the length of the SourceString, which is zero if
    SourceString is not specified.

Arguments:

    DestinationString - Pointer to the counted string to initialize

    SourceString - Optional pointer to a null terminated string that
    the counted string is to point to.


Return Value:

    None.

--*/

{
    ULONG Length;

    DestinationString->Buffer = (PCHAR)SourceString;
    if (ARGUMENT_PRESENT( SourceString )) {
        Length = strlen(SourceString);
        DestinationString->Length = (USHORT)Length;
        DestinationString->MaximumLength = (USHORT)(Length+1);
    }
    else {
        DestinationString->Length = 0;
        DestinationString->MaximumLength = 0;
    }
}


VOID
RtlInitUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PCWSTR SourceString OPTIONAL
    )

/*++

Routine Description:

    The RtlInitUnicodeString function initializes an NT counted
    unicode string.  The DestinationString is initialized to point to
    the SourceString and the Length and MaximumLength fields of
    DestinationString are initialized to the length of the SourceString,
    which is zero if SourceString is not specified.

Arguments:

    DestinationString - Pointer to the counted string to initialize

    SourceString - Optional pointer to a null terminated unicode string that
    the counted string is to point to.


Return Value:

    None.

--*/

{
    ULONG Length;

    DestinationString->Buffer = (PWSTR)SourceString;
    if (ARGUMENT_PRESENT( SourceString ))
    {
        Length = wcslen( SourceString ) * sizeof( WCHAR );
        DestinationString->Length = (USHORT)Length;
        DestinationString->MaximumLength = (USHORT)(Length + sizeof(UNICODE_NULL));
    }
    else
    {
        DestinationString->MaximumLength = 0;
        DestinationString->Length = 0;
    }
}

NTSTATUS
RtlAnsiStringToUnicodeString(
    OUT PUNICODE_STRING DestinationString,
    IN PANSI_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )
{
    ULONG UnicodeLength;
    ULONG i;

    if (AllocateDestinationString)
    {
        return STATUS_INVALID_PARAMETER_2;
    }

    UnicodeLength = SourceString->Length * 2;
    if (UnicodeLength > MAXUSHORT)
    {
        return STATUS_INVALID_PARAMETER_2;
    }

    if (UnicodeLength > DestinationString->Length)
    {
        return STATUS_BUFFER_OVERFLOW;
    }

    for (i = 0; i < SourceString->Length; i++)
    {
        DestinationString->Buffer[i] = (WCHAR)(SourceString->Buffer[i]);
    }

    return STATUS_SUCCESS;
}

NTSTATUS
RtlUnicodeStringToAnsiString(
    OUT PANSI_STRING DestinationString,
    IN PUNICODE_STRING SourceString,
    IN BOOLEAN AllocateDestinationString
    )
{
    ULONG AnsiLength;
    ULONG i;

    if (AllocateDestinationString)
    {
        return STATUS_INVALID_PARAMETER_2;
    }

    if (SourceString->Length & 1)
    {
        return STATUS_INVALID_PARAMETER_2;
    }
    AnsiLength = SourceString->Length / 2;


    if (AnsiLength > DestinationString->Length)
    {
        return STATUS_BUFFER_OVERFLOW;
    }

    for (i = 0; i < AnsiLength; i++)
    {
        DestinationString->Buffer[i] = (CHAR)(SourceString->Buffer[i]);
    }

    return STATUS_SUCCESS;
}


NTSTATUS UnicodeStringToAnsiString(OUT PANSI_STRING AnsiString,
                   IN PUNICODE_STRING UnicodeString)
{
    NTSTATUS            Status;

    AnsiString->Buffer =
           HeapAlloc(GetProcessHeap(), 0, UnicodeString->MaximumLength/2);
    AnsiString->Length = UnicodeString->Length / 2;
    AnsiString->MaximumLength = UnicodeString->MaximumLength / 2;

    Status = RtlUnicodeStringToAnsiString(AnsiString, UnicodeString,
                      FALSE);

    AnsiString->Buffer[AnsiString->Length] = '\0';

    return(Status);

}

NTSTATUS AnsiStringToUnicodeString(OUT PUNICODE_STRING UnicodeString,
                   IN PANSI_STRING AnsiString)
{
    NTSTATUS            Status;

    UnicodeString->Buffer =
           HeapAlloc(GetProcessHeap(), 0, AnsiString->MaximumLength * 2);
    UnicodeString->Length = AnsiString->Length * 2;
    UnicodeString->MaximumLength = AnsiString->MaximumLength * 2;

    Status = RtlAnsiStringToUnicodeString(UnicodeString, AnsiString,
                      FALSE);

    UnicodeString->Buffer[UnicodeString->Length / sizeof(WCHAR)] =
                                 UNICODE_NULL;
    return(Status);

}


VOID FreeAnsiString(PANSI_STRING AnsiString)
{
    if (AnsiString->Buffer)
    {
        HeapFree(GetProcessHeap(), 0, AnsiString->Buffer);
    }
}

VOID FreeUnicodeString(PUNICODE_STRING UnicodeString)
{
    if (UnicodeString->Buffer)
    {
        HeapFree(GetProcessHeap(), 0, UnicodeString->Buffer);
    }
}

#endif

BOOL CSPInCacheCheck(
                     LPSTR pszValue,
                     HANDLE *ph
                     )
{
    HANDLE  h = 0;
    DWORD   i;
    BOOL    fRet = FALSE;

    // check if CSP has been loaded
    if (0 == (h = GetModuleHandle(pszValue)))
        goto Ret;

    // check if the CSP is in the cache designating it as signed
    for (i=0;i<CACHESIZE;i++)
    {
        if (h == gCSPCache[i])
        {
            *ph = h;
            fRet = TRUE;
            break;
        }
    }
Ret:
    return fRet;
}

void AddHandleToCSPCache(
                         HANDLE h
                         )
{
    DWORD   i;

    // check if the CSP is in the cache designating it as signed
    for (i=0;i<CACHESIZE;i++)
    {
        if (0 == gCSPCache[i])
        {
            gCSPCache[i] = h;
            break;
        }
    }
}

#ifndef WIN95
/*
 -      CryptAcquireContextW
 -
 *      Purpose:
 *               The CryptAcquireContext function is used to acquire a context
 *               handle to a cryptograghic service provider (CSP).
 *
 *
 *      Parameters:
 *               OUT    phProv      -  Handle to a CSP
 *               IN     pszIdentity -  Pointer to the name of the context's
 *                                     keyset.
 *               IN     pszProvider -  Pointer to the name of the provider.
 *               IN     dwProvType   -  Requested CSP type
 *               IN     dwFlags     -  Flags values
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptAcquireContextW(OUT    HCRYPTPROV *phProv,
                IN     LPCWSTR pszIdentity,
                IN     LPCWSTR pszProvider,
                IN     DWORD dwProvType,
                IN     DWORD dwFlags)
{
    ANSI_STRING         AnsiString1;
    ANSI_STRING         AnsiString2;
    UNICODE_STRING      UnicodeString1;
    UNICODE_STRING      UnicodeString2;
    NTSTATUS            Status = STATUS_SUCCESS;
    BOOL                rt;

    __try
    {
        memset(&AnsiString1, 0, sizeof(AnsiString1));
        memset(&AnsiString2, 0, sizeof(AnsiString2));
        memset(&UnicodeString1, 0, sizeof(UnicodeString1));
        memset(&UnicodeString2, 0, sizeof(UnicodeString2));

        if (NULL != pszIdentity)
        {
            RtlInitUnicodeString(&UnicodeString1, pszIdentity);

            Status = RtlUnicodeStringToAnsiString(&AnsiString1, &UnicodeString1,
                                                  TRUE);
        }

        if (!NT_SUCCESS(Status))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return(CRYPT_FAILED);
        }

        if (NULL != pszProvider)
        {
            RtlInitUnicodeString(&UnicodeString2, pszProvider);

            Status = RtlUnicodeStringToAnsiString(&AnsiString2, &UnicodeString2,
                                                  TRUE);
        }

        if (!NT_SUCCESS(Status))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            return(CRYPT_FAILED);
        }

        rt = CryptAcquireContextA(phProv, AnsiString1.Buffer,
                      AnsiString2.Buffer,
                      dwProvType, dwFlags);

        RtlFreeAnsiString(&AnsiString1);
        RtlFreeAnsiString(&AnsiString2);

        return(rt);
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Try_Error_Return;
    }

Try_Error_Return:
    return(CRYPT_FAILED);

}
#else   // WIN95
WINADVAPI
BOOL
WINAPI CryptAcquireContextW(OUT    HCRYPTPROV *phProv,
                IN     LPCWSTR pszIdentity,
                IN     LPCWSTR pszProvider,
                IN     DWORD dwProvType,
                IN     DWORD dwFlags)
{
    SetLastError((DWORD)ERROR_CALL_NOT_IMPLEMENTED);
    return CRYPT_FAILED;
}
#endif   // WIN95


/*
 -      CryptAcquireContextA
 -
 *      Purpose:
 *               The CryptAcquireContext function is used to acquire a context
 *               handle to a cryptograghic service provider (CSP).
 *
 *
 *      Parameters:
 *               OUT    phProv         -  Handle to a CSP
 *               IN OUT pszIdentity    -  Pointer to the name of the context's
 *                                        keyset.
 *               IN OUT pszProvName    -  Pointer to the name of the provider.
 *               IN     dwReqProvider  -  Requested CSP type
 *               IN     dwFlags        -  Flags values
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptAcquireContextA(OUT    HCRYPTPROV *phProv,
                IN     LPCSTR pszIdentity,
                IN     LPCSTR pszProvName,
                IN     DWORD dwReqProvider,
                IN     DWORD dwFlags)
{
    HANDLE          handle = 0;
    DWORD           bufsize;
    ULONG_PTR       *pTable;
    PVTableStruc    pVTable = NULL;
    LPSTR           pszTmpProvName = NULL;
    DWORD           i;
    HKEY            hCurrUser = 0;
    HKEY            hKey = 0;
    DWORD           cbValue;
    DWORD           cbTemp;
    CHAR            *pszValue = NULL;
    CHAR            *pszDest = NULL;
    BYTE            *SignatureBuf = NULL;
    DWORD           provtype;
    BOOL            rt = CRYPT_FAILED;
    DWORD           dwType;
    LONG            err;
    DWORD           dwErr;
    CHAR            typebuf[9] = {0, 0, 0, 0, 0, 0, 0, 0, 0};
    HCRYPTPROV      hTmpProv = 0;
    VTableProvStruc VTableProv;
    UNICODE_STRING  String ;
    BOOL            SigInFile ;


    __try
    {
        if (dwReqProvider == 0 || dwReqProvider > 999)
        {
            SetLastError((DWORD) NTE_BAD_PROV_TYPE);
            goto Ret;
        }

        if (pszProvName != NULL && pszProvName[0] != 0)
        {
            // Do nothing just check for invalid pointers
            ;
        }

        if (pszProvName != NULL && pszProvName[0] != 0)
        {
            cbValue = strlen(pszProvName);

            if ((pszValue = (CHAR *) LocalAlloc(LMEM_ZEROINIT,
                                                (UINT) cbValue +
                                                strlen(szprovider) + 1)) == NULL)
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Ret;
            }

            if ((pszTmpProvName = (LPSTR)LocalAlloc(LMEM_ZEROINIT,
                                                (UINT) cbValue + 1)) == NULL)
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Ret;
            }

            strcpy(pszTmpProvName, pszProvName);
            strcpy(pszValue, szprovider);
            strcat(pszValue, pszProvName);
        }
        else
        {
            if ((pszValue = (CHAR *) LocalAlloc(LMEM_ZEROINIT,
                                                5 + strlen(szusertype))) == NULL)
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Ret;
            }

            strcpy(pszValue, szusertype);
            __ltoa(dwReqProvider, typebuf);
            strcat(pszValue, &typebuf[5]);

#ifndef WIN95
            err = ERROR_INVALID_PARAMETER;
            if (NT_SUCCESS(RtlOpenCurrentUser(KEY_READ, &hCurrUser)))
            {

                err = RegOpenKeyEx(hCurrUser, (const char *) pszValue,
                                   0L, KEY_READ, &hKey);

                NtClose(hCurrUser);
            }

#else
            err = RegOpenKeyEx(HKEY_CURRENT_USER, (const char *) pszValue,
                               0L, KEY_READ, &hKey);

            RegCloseKey(HKEY_CURRENT_USER);
#endif
            if (err != ERROR_SUCCESS)
            {
                LocalFree(pszValue);
                if ((pszValue = (CHAR *) LocalAlloc(LMEM_ZEROINIT,
                                                    5 + strlen(szmachinetype))) == NULL)
                {
                    SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                    goto Ret;
                }

                strcpy(pszValue, szmachinetype);
                strcat(pszValue, &typebuf[5]);

                if ((err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                        (const char *) pszValue, 0L,
                                        KEY_READ, &hKey)) != ERROR_SUCCESS)
                {
                    SetLastError((DWORD) NTE_PROV_TYPE_NOT_DEF);
                    goto Ret;
                }
            }

            if ((err = RegQueryValueEx(hKey, "Name", NULL, &dwType,
                                       NULL, &cbValue)) != ERROR_SUCCESS)
            {
                SetLastError((DWORD) NTE_PROV_TYPE_NOT_DEF);
                goto Ret;
            }

            LocalFree(pszValue);
            if ((pszValue = (CHAR *) LocalAlloc(LMEM_ZEROINIT,
                                                cbValue +
                                                strlen(szprovider) + 1)) == NULL)
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Ret;
            }

            if ((pszTmpProvName = (LPSTR)LocalAlloc(LMEM_ZEROINIT,
                                                (UINT) cbValue + 1)) == NULL)
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Ret;
            }

            strcpy(pszValue, szprovider);

            cbTemp = cbValue;

            if ((err = RegQueryValueEx(hKey, "Name", NULL, &dwType,
                                       (LPBYTE)pszTmpProvName,
                                       &cbTemp)) != ERROR_SUCCESS)
            {
                SetLastError((DWORD) NTE_PROV_TYPE_NOT_DEF);
                goto Ret;
            }

            strcat(pszValue, pszTmpProvName);

            RegCloseKey(hKey);
            hKey = 0;
        }

        if ((err = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                (const char *) pszValue,
                                0L, KEY_READ, &hKey)) != ERROR_SUCCESS)
        {
            SetLastError((DWORD) NTE_KEYSET_NOT_DEF);
            goto Ret;
        }

        LocalFree(pszValue);
        pszValue = NULL;

        cbValue = sizeof(DWORD);
        if ((err = RegQueryValueEx(hKey, "Type", NULL, &dwType,
                                   (LPBYTE)&provtype,
                                   &cbValue)) != ERROR_SUCCESS)
        {
            SetLastError((DWORD) NTE_KEYSET_ENTRY_BAD);
            goto Ret;
        }

        // Check that requested provider type is same as registry entry
        if (provtype != dwReqProvider)
        {
            SetLastError((DWORD) NTE_PROV_TYPE_NO_MATCH);
            goto Ret;
        }

        // Determine size of path for provider
        if ((err = RegQueryValueEx(hKey, "Image Path", NULL,
                                   &dwType, NULL, &cbValue)) != ERROR_SUCCESS)
        {
            SetLastError((DWORD) NTE_KEYSET_ENTRY_BAD);
            goto Ret;
        }

        if ((pszValue = (CHAR *) LocalAlloc(LMEM_ZEROINIT,
                                            (UINT) cbValue)) == NULL)
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }

        // Get value from registry
        if ((err = RegQueryValueEx(hKey, "Image Path", NULL, &dwType,
                                   (LPBYTE)pszValue, &cbValue)) != ERROR_SUCCESS)
        {
            SetLastError((DWORD) NTE_KEYSET_ENTRY_BAD);
            goto Ret;
        }

        pszDest = NULL;
        cbTemp = 0;

        if ((cbTemp = ExpandEnvironmentStrings(pszValue, (CHAR *) &pszDest, cbTemp))  == 0)
        {
            goto Ret;
        }

        if ((pszDest = (CHAR *) LocalAlloc(LMEM_ZEROINIT,
                                           (UINT) cbTemp)) == NULL)
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }

        if ((cbTemp = ExpandEnvironmentStrings(pszValue, pszDest,
                                               cbTemp))  == 0)
        {
            goto Ret;
        }

        LocalFree(pszValue);
        pszValue = pszDest;
        pszDest = NULL;
        cbValue = cbTemp;

        if (!CSPInCacheCheck(pszValue, &handle))
        {
            if ( RtlCreateUnicodeStringFromAsciiz( &String, pszValue ) )
            {
                // check if the CSP is registered as having the signature in the file

                SigInFile = CheckSignatureInFile( String.Buffer );

                RtlFreeUnicodeString( &String );

                if (! SigInFile )
                {
                    // Determine size of signature
                    if ((err = RegQueryValueEx(hKey, "Signature", NULL,
                                               &dwType, NULL, &cbValue)) != ERROR_SUCCESS)
                    {
                        SetLastError((DWORD) NTE_BAD_SIGNATURE);
                        goto Ret;
                    }

                    if ((SignatureBuf = (LPBYTE)LocalAlloc(LMEM_ZEROINIT,
                                                           (UINT) cbValue)) == NULL)
                    {
                        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                        goto Ret;
                    }


                    // Get Digital signature from registry
                    if ((err = RegQueryValueEx(hKey, "Signature", NULL, &dwType,
                                               SignatureBuf,
                                               &cbValue)) != ERROR_SUCCESS)
                    {
                        SetLastError((DWORD) NTE_BAD_SIGNATURE);
                        goto Ret;
                    }


                    if (RCRYPT_FAILED(NewVerifyImage(pszValue, SignatureBuf, cbValue, FALSE)))
                    {
                        SetLastError((DWORD) NTE_BAD_SIGNATURE);
                        goto Ret;
                    }
                }

            }

            if ((handle = LoadLibrary(pszValue)) == NULL)
            {
                SetLastError((DWORD) NTE_PROVIDER_DLL_FAIL);
                goto Ret;
            }

            AddHandleToCSPCache(handle);
        }

         // DLLs exist allocate VTable struct to hold address of entry points
        bufsize = sizeof(VTableStruc);

        if ((pVTable = (PVTableStruc) LocalAlloc(LMEM_ZEROINIT,
                                                 (UINT) bufsize)) == NULL)
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }

        pTable = (ULONG_PTR *) pVTable;

        // Build table of pointers to Crypto API for this DLL
        i = 0;
        while (FunctionNames[i] != NULL)
        {
            *pTable = (ULONG_PTR) GetProcAddress(handle, FunctionNames[i]);
            if (*pTable == 0)
            {
                SetLastError((DWORD) NTE_PROVIDER_DLL_FAIL);
                goto Ret;
            }
            pTable++;
            i++;
        }

        // Build the table of optional pointers to Crypto API for this DLL
        i = 0;
        pTable++;
        while (OptionalFunctionNames[i] != NULL)
        {
            *pTable = (ULONG_PTR) GetProcAddress(handle, OptionalFunctionNames[i]);
            pTable++;
            i++;
        }
        pVTable->DllHandle = handle;

        memset(&VTableProv, 0, sizeof(VTableProv));
        VTableProv.Version = 3;
        VTableProv.FuncVerifyImage = (CRYPT_VERIFY_IMAGE_A)CProvVerifyImage;
        VTableProv.FuncReturnhWnd = (CRYPT_RETURN_HWND)CPReturnhWnd;
        VTableProv.dwProvType = dwReqProvider;
        VTableProv.pszProvName = pszTmpProvName;
        VTableProv.pbContextInfo = pbContextInfo;
        VTableProv.cbContextInfo = cbContextInfo;

        *phProv = (HCRYPTPROV) NULL;

        rt = (BOOL)pVTable->FuncAcquireContext(&hTmpProv, pszIdentity, dwFlags,
                                               &VTableProv);

        if (RCRYPT_SUCCEEDED(rt) &&
            ((dwFlags & CRYPT_DELETEKEYSET) != CRYPT_DELETEKEYSET))
        {
            pVTable->hProv = hTmpProv;
            *phProv = (HCRYPTPROV)pVTable;

            pVTable->Version = TABLEPROV;
            pVTable->Inuse = 1;
            pVTable->RefCnt = 1;
        }
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    dwErr = GetLastError();
    if (pszTmpProvName)
        LocalFree(pszTmpProvName);
    if (pszValue)
        LocalFree(pszValue);
    if (hKey)
        RegCloseKey(hKey);
    if (pszDest)
        LocalFree(pszDest);
    if (SignatureBuf)
        LocalFree(SignatureBuf);
    if ((CRYPT_SUCCEED != rt) || (dwFlags & CRYPT_DELETEKEYSET))
    {
        if (pVTable)
            LocalFree(pVTable);
        SetLastError(dwErr);
    }
    return rt;
}

/*
 -      CryptContextAddRef
 -
 *      Purpose:
 *               Increments the reference counter on the provider handle.
 *
 *      Parameters:
 *               IN  hProv         -  Handle to a CSP
 *               IN  pdwReserved   -  Reserved parameter
 *               IN  dwFlags       -  Flags values
 *
 *      Returns:
 *               BOOL
 *               Use get extended error information use GetLastError
 */
WINADVAPI
BOOL
WINAPI CryptContextAddRef(
                          IN HCRYPTPROV hProv,
                          IN DWORD *pdwReserved,
                          IN DWORD dwFlags
                          )
{
    PVTableStruc    pVTable;
    BOOL            fRet = CRYPT_FAILED;

    __try
    {
        if ((NULL != pdwReserved) || (0 != dwFlags))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        pVTable = (PVTableStruc) hProv;

        if (pVTable->Version != TABLEPROV)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if (InterlockedIncrement(&pVTable->RefCnt) <= 0)
            SetLastError(ERROR_INVALID_PARAMETER);
        else
            fRet = CRYPT_SUCCEED;
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

Ret:
    return fRet;
}

/*
 -      CryptReleaseContext
 -
 *      Purpose:
 *               The CryptReleaseContext function is used to release a
 *               context created by CryptAcquireContext.
 *
 *     Parameters:
 *               IN  hProv         -  Handle to a CSP
 *               IN  dwFlags       -  Flags values
 *
 *      Returns:
 *               BOOL
 *               Use get extended error information use GetLastError
 */
WINADVAPI
BOOL
WINAPI CryptReleaseContext(IN HCRYPTPROV hProv,
                           IN DWORD dwFlags)
{
    PVTableStruc    pVTable;
    BOOL            rt;
    BOOL            fRet = CRYPT_FAILED;
    DWORD           dwErr = 0;

    __try
    {
        pVTable = (PVTableStruc) hProv;

        if (pVTable->Version != TABLEPROV)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if (pVTable->RefCnt <= 0)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if (0 == InterlockedDecrement(&pVTable->RefCnt))
        {
            if (0 < InterlockedDecrement((LPLONG)&pVTable->Inuse))
            {
                InterlockedIncrement((LPLONG)&pVTable->Inuse);
                SetLastError(ERROR_BUSY);
                goto Ret;
            }
            InterlockedIncrement((LPLONG)&pVTable->Inuse);

            if (FALSE == (rt = (BOOL)pVTable->FuncReleaseContext(pVTable->hProv, dwFlags)))
            {
                dwErr = GetLastError();
            }
            pVTable->Version = 0;
            LocalFree(pVTable);
            if (!rt)
            {
                SetLastError(dwErr);
                goto Ret;
            }
        }
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;
Ret:
    return fRet;
}

/*
 -      CryptGenKey
 -
 *      Purpose:
 *                Generate cryptographic keys
 *
 *
 *      Parameters:
 *               IN      hProv   -  Handle to a CSP
 *               IN      Algid   -  Algorithm identifier
 *               IN      dwFlags -  Flags values
 *               OUT     phKey   -  Handle to a generated key
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptGenKey(IN HCRYPTPROV hProv,
            IN ALG_ID Algid,
            IN DWORD dwFlags,
            OUT HCRYPTKEY * phKey)
{
    PVTableStruc    pVTable = NULL;
    PVKeyStruc      pVKey = NULL;
    BOOL            fProvCritSec = FALSE;
    DWORD           dwErr;
    BOOL            fRet = CRYPT_FAILED;

    __try
    {
        pVTable = (PVTableStruc) hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fProvCritSec = TRUE;

        if (RCRYPT_FAILED(BuildVKey(&pVKey, pVTable)))
        {
            goto Ret;
        }

        if (RCRYPT_FAILED(pVTable->FuncGenKey(pVTable->hProv, Algid, dwFlags,
                            phKey)))
        {
            goto Ret;
        }

        pVKey->hKey = *phKey;

        *phKey = (HCRYPTKEY) pVKey;

        pVKey->Version = TABLEKEY;

        pVKey->hProv = hProv;

        pVKey->Inuse = 1;

    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;
Ret:
    dwErr = GetLastError();
    if (fProvCritSec)
        LeaveProviderCritSec(pVTable);
    if (CRYPT_SUCCEED != fRet)
    {
        if (pVKey)
            LocalFree(pVKey);
        SetLastError(dwErr);
    }
    return fRet;
}

/*
 -      CryptDuplicateKey
 -
 *      Purpose:
 *                Duplicate a cryptographic key
 *
 *
 *      Parameters:
 *               IN      hKey           -  Handle to the key to be duplicated
 *               IN      pdwReserved    -  Reserved for later use
 *               IN      dwFlags        -  Flags values
 *               OUT     phKey          -  Handle to the new duplicate key
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptDuplicateKey(
                         IN HCRYPTKEY hKey,
                         IN DWORD *pdwReserved,
                         IN DWORD dwFlags,
                         OUT HCRYPTKEY * phKey
                         )
{
    PVTableStruc    pVTable = NULL;
    PVKeyStruc      pVKey;
    PVKeyStruc      pVNewKey = NULL;
    HCRYPTKEY       hNewKey;
    BOOL            fProvCritSecSet = FALSE;
    DWORD           dwErr = 0;
    BOOL            fRet = CRYPT_FAILED;

    __try
    {
        if (IsBadWritePtr(phKey, sizeof(HCRYPTKEY)))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }
        pVKey = (PVKeyStruc) hKey;

        if (pVKey->Version != TABLEKEY)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if (NULL == pVKey->OptionalFuncDuplicateKey)
        {
            SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
            goto Ret;
        }

        pVTable = (PVTableStruc) pVKey->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }
        fProvCritSecSet = TRUE;

        if (RCRYPT_FAILED(BuildVKey(&pVNewKey, pVTable)))
        {
            goto Ret;
        }

        if (RCRYPT_FAILED(pVKey->OptionalFuncDuplicateKey(pVTable->hProv, pVKey->hKey,
                                                          pdwReserved, dwFlags, &hNewKey)))
        {
            goto Ret;
        }

        pVNewKey->hKey = hNewKey;

        pVNewKey->Version = TABLEKEY;

        pVNewKey->hProv = pVKey->hProv;

        pVKey->Inuse = 1;

        *phKey = (HCRYPTKEY) pVNewKey;
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;
Ret:
    dwErr = GetLastError();
    if (fProvCritSecSet)
        LeaveProviderCritSec(pVTable);
    if (fRet == CRYPT_FAILED)
    {
        if (NULL != pVNewKey)
            LocalFree(pVNewKey);
        SetLastError(dwErr);
    }

    return fRet;
}

/*
 -      CryptDeriveKey
 -
 *      Purpose:
 *                Derive cryptographic keys from base data
 *
 *
 *      Parameters:
 *               IN      hProv      -  Handle to a CSP
 *               IN      Algid      -  Algorithm identifier
 *               IN      hHash      -  Handle to hash of base data
 *               IN      dwFlags    -  Flags values
 *               IN OUT  phKey      -  Handle to a generated key
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptDeriveKey(IN HCRYPTPROV hProv,
                IN ALG_ID Algid,
                IN HCRYPTHASH hHash,
                IN DWORD dwFlags,
                IN OUT HCRYPTKEY * phKey)
{
    PVTableStruc    pVTable = NULL;
    PVKeyStruc      pVKey = NULL;
    PVHashStruc     pVHash = NULL;
    BOOL            fProvCritSec = FALSE;
    BOOL            fKeyCritSec = FALSE;
    BOOL            fHashCritSec = FALSE;
    BOOL            fUpdate = FALSE;
    DWORD           dwErr = 0;
    BOOL            fRet = CRYPT_FAILED;

    __try
    {
        pVTable = (PVTableStruc) hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fProvCritSec = TRUE;

        pVHash = (PVHashStruc) hHash;

        if (RCRYPT_FAILED(EnterHashCritSec(pVHash)))
        {
            goto Ret;
        }
        fHashCritSec = TRUE;

        if (dwFlags & CRYPT_UPDATE_KEY)
        {
            fUpdate = TRUE;
            pVKey = (PVKeyStruc) phKey;

            if (RCRYPT_FAILED(EnterKeyCritSec(pVKey)))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                goto Ret;
            }
            fKeyCritSec = TRUE;
        }
        else
        {
            if (RCRYPT_FAILED(BuildVKey(&pVKey, pVTable)))
            {
                goto Ret;
            }
        }

        if (RCRYPT_FAILED(pVTable->FuncDeriveKey(pVTable->hProv, Algid,
                        pVHash->hHash, dwFlags, phKey)))
        {
            goto Ret;
        }

        if ((dwFlags & CRYPT_UPDATE_KEY) != CRYPT_UPDATE_KEY)
        {
            pVKey->hKey = *phKey;

            *phKey = (HCRYPTKEY)pVKey;

            pVKey->hProv = hProv;

            pVKey->Version = TABLEKEY;

            pVKey->Inuse = 1;
        }

    } __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;
Ret:
    if (CRYPT_SUCCEED != fRet)
        dwErr = GetLastError();
    if (fProvCritSec)
        LeaveProviderCritSec(pVTable);
    if (fHashCritSec)
        LeaveHashCritSec(pVHash);
    if (fKeyCritSec)
        LeaveKeyCritSec(pVKey);
    if (CRYPT_SUCCEED != fRet)
    {
        if (pVKey && (!fUpdate))
            LocalFree(pVKey);
        SetLastError(dwErr);
    }
    return fRet;
}


/*
 -      CryptDestroyKey
 -
 *      Purpose:
 *                Destroys the cryptographic key that is being referenced
 *                with the hKey parameter
 *
 *
 *      Parameters:
 *               IN      hKey   -  Handle to a key
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptDestroyKey(IN HCRYPTKEY hKey)
{
    PVTableStruc    pVTable = NULL;
    PVKeyStruc      pVKey;
    BOOL            fProvCritSec = FALSE;
    BOOL            rt;
    DWORD           dwErr = 0;
    BOOL            fRet = CRYPT_FAILED;

    __try
    {
        pVKey = (PVKeyStruc) hKey;

        if (pVKey->Version != TABLEKEY)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if (0 < InterlockedDecrement((LPLONG)&pVKey->Inuse))
        {
            InterlockedIncrement((LPLONG)&pVKey->Inuse);
            SetLastError(ERROR_BUSY);
            goto Ret;
        }
        InterlockedIncrement((LPLONG)&pVKey->Inuse);

        pVTable = (PVTableStruc) pVKey->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fProvCritSec = TRUE;

        if (FALSE == (rt = (BOOL)pVKey->FuncDestroyKey(pVTable->hProv, pVKey->hKey)))
            dwErr = GetLastError();

        pVKey->Version = 0;
        LocalFree(pVKey);

        if (!rt)
        {
            SetLastError(dwErr);
            goto Ret;
        }
    } __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;
Ret:
    if (CRYPT_SUCCEED != fRet)
        dwErr = GetLastError();
    if (fProvCritSec)
        LeaveProviderCritSec(pVTable);
    if (CRYPT_SUCCEED != fRet)
        SetLastError(dwErr);
    return fRet;
}


/*
 -      CryptSetKeyParam
 -
 *      Purpose:
 *                Allows applications to customize various aspects of the
 *                operations of a key
 *
 *      Parameters:
 *               IN      hKey    -  Handle to a key
 *               IN      dwParam -  Parameter number
 *               IN      pbData  -  Pointer to data
 *               IN      dwFlags -  Flags values
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptSetKeyParam(IN HCRYPTKEY hKey,
                        IN DWORD dwParam,
                        IN CONST BYTE *pbData,
                        IN DWORD dwFlags)
{
    PVTableStruc    pVTable = NULL;
    PVKeyStruc      pVKey;
    BOOL            rt = CRYPT_FAILED;
    BOOL            fCritSec = FALSE;

    __try
    {
        pVKey = (PVKeyStruc) hKey;

        if (pVKey->Version != TABLEKEY)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if (0 < InterlockedDecrement((LPLONG)&pVKey->Inuse))
        {
            InterlockedIncrement((LPLONG)&pVKey->Inuse);
            SetLastError(ERROR_BUSY);
            goto Ret;
        }
        InterlockedIncrement((LPLONG)&pVKey->Inuse);

        pVTable = (PVTableStruc) pVKey->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fCritSec = TRUE;

        rt = (BOOL)pVKey->FuncSetKeyParam(pVTable->hProv, pVKey->hKey,
                                    dwParam, pbData, dwFlags);
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    if (fCritSec)
        LeaveProviderCritSec(pVTable);
    return(rt);

}


/*
 -      CryptGetKeyParam
 -
 *      Purpose:
 *                Allows applications to get various aspects of the
 *                operations of a key
 *
 *      Parameters:
 *               IN      hKey       -  Handle to a key
 *               IN      dwParam    -  Parameter number
 *               IN      pbData     -  Pointer to data
 *               IN      pdwDataLen -  Length of parameter data
 *               IN      dwFlags    -  Flags values
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptGetKeyParam(IN HCRYPTKEY hKey,
                        IN DWORD dwParam,
                        IN BYTE *pbData,
                        IN DWORD *pdwDataLen,
                        IN DWORD dwFlags)
{
    PVTableStruc    pVTable = NULL;
    PVKeyStruc      pVKey = NULL;
    BOOL            rt = CRYPT_FAILED;
    BOOL            fKeyCritSec = FALSE;
    BOOL            fTableCritSec = FALSE;

    __try
    {
        pVKey = (PVKeyStruc) hKey;

        if (RCRYPT_FAILED(EnterKeyCritSec(pVKey)))
        {
            goto Ret;
        }
        fKeyCritSec = TRUE;

        pVTable = (PVTableStruc) pVKey->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fTableCritSec = TRUE;

        rt = (BOOL)pVKey->FuncGetKeyParam(pVTable->hProv, pVKey->hKey,
                                    dwParam, pbData, pdwDataLen,
                                    dwFlags);

    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    if (fKeyCritSec)
        LeaveKeyCritSec(pVKey);
    if (fTableCritSec)
        LeaveProviderCritSec(pVTable);
    return(rt);

}


/*
 -      CryptGenRandom
 -
 *      Purpose:
 *                Used to fill a buffer with random bytes
 *
 *
 *      Parameters:
 *               IN  hProv      -  Handle to the user identifcation
 *               IN  dwLen      -  Number of bytes of random data requested
 *               OUT pbBuffer   -  Pointer to the buffer where the random
 *                                 bytes are to be placed
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptGenRandom(IN HCRYPTPROV hProv,
                      IN DWORD dwLen,
                      OUT BYTE *pbBuffer)

{
    PVTableStruc    pVTable = NULL;
    BOOL            fTableCritSec = FALSE;
    BOOL            rt = CRYPT_FAILED;

    __try
    {
        pVTable = (PVTableStruc) hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fTableCritSec = TRUE;

        rt = (BOOL)pVTable->FuncGenRandom(pVTable->hProv, dwLen, pbBuffer);

    } __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    if (fTableCritSec)
        LeaveProviderCritSec(pVTable);
    return(rt);
}

/*
 -      CryptGetUserKey
 -
 *      Purpose:
 *                Gets a handle to a permanent user key
 *
 *
 *      Parameters:
 *               IN  hProv      -  Handle to the user identifcation
 *               IN  dwKeySpec  -  Specification of the key to retrieve
 *               OUT phUserKey  -  Pointer to key handle of retrieved key
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptGetUserKey(IN HCRYPTPROV hProv,
                       IN DWORD dwKeySpec,
                       OUT HCRYPTKEY *phUserKey)
{

    PVTableStruc    pVTable = NULL;
    PVKeyStruc      pVKey = NULL;
    BOOL            fTableCritSec = FALSE;
    BOOL            fRet = CRYPT_FAILED;

    __try
    {
        pVTable = (PVTableStruc) hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fTableCritSec = TRUE;

        if (RCRYPT_FAILED(BuildVKey(&pVKey, pVTable)))
        {
            goto Ret;
        }

        if (RCRYPT_FAILED(pVTable->FuncGetUserKey(pVTable->hProv, dwKeySpec,
                                                  phUserKey)))
        {
            goto Ret;
        }

        pVKey->hKey = *phUserKey;

        pVKey->hProv = hProv;

        *phUserKey = (HCRYPTKEY)pVKey;

        pVKey->Version = TABLEKEY;

        pVKey->Inuse = 1;

    } __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;
Ret:
    if (fTableCritSec)
        LeaveProviderCritSec(pVTable);
    if ((CRYPT_SUCCEED != fRet) && pVKey)
        LocalFree(pVKey);
    return fRet;
}



/*
 -      CryptExportKey
 -
 *      Purpose:
 *                Export cryptographic keys out of a CSP in a secure manner
 *
 *
 *      Parameters:
 *               IN  hKey       - Handle to the key to export
 *               IN  hPubKey    - Handle to the exchange public key value of
 *                                the destination user
 *               IN  dwBlobType - Type of key blob to be exported
 *               IN  dwFlags -    Flags values
 *               OUT pbData -     Key blob data
 *               OUT pdwDataLen - Length of key blob in bytes
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptExportKey(IN HCRYPTKEY hKey,
                IN HCRYPTKEY hPubKey,
                IN DWORD dwBlobType,
                IN DWORD dwFlags,
                OUT BYTE *pbData,
                OUT DWORD *pdwDataLen)
{
    PVTableStruc    pVTable = NULL;
    PVKeyStruc      pVKey = NULL;
    PVKeyStruc      pVPublicKey = NULL;
    BOOL            fKeyCritSec = FALSE;
    BOOL            fPubKeyCritSec = FALSE;
    BOOL            fTableCritSec = FALSE;
    BOOL            rt = CRYPT_FAILED;

    __try
    {
        pVKey = (PVKeyStruc) hKey;

        if (RCRYPT_FAILED(EnterKeyCritSec(pVKey)))
        {
            goto Ret;
        }
        fKeyCritSec = TRUE;

        pVTable = (PVTableStruc) pVKey->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fTableCritSec = TRUE;

        pVPublicKey = (PVKeyStruc) hPubKey;

        if (pVPublicKey != NULL)
        {
            if (RCRYPT_FAILED(EnterKeyCritSec(pVPublicKey)))
            {
                goto Ret;
            }
            fPubKeyCritSec = TRUE;
        }

        rt = (BOOL)pVKey->FuncExportKey(pVTable->hProv, pVKey->hKey,
                                  (pVPublicKey == NULL ? 0 : pVPublicKey->hKey),
                                  dwBlobType, dwFlags, pbData,
                                  pdwDataLen);

    } __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    if (fKeyCritSec)
        LeaveKeyCritSec(pVKey);
    if (fTableCritSec)
        LeaveProviderCritSec(pVTable);
    if (pVPublicKey != NULL)
    {
        if (fPubKeyCritSec)
            LeaveKeyCritSec(pVPublicKey);
    }
    return(rt);

}


/*
 -      CryptImportKey
 -
 *      Purpose:
 *                Import cryptographic keys
 *
 *
 *      Parameters:
 *               IN  hProv     -  Handle to the CSP user
 *               IN  pbData    -  Key blob data
 *               IN  dwDataLen -  Length of the key blob data
 *               IN  hPubKey   -  Handle to the exchange public key value of
 *                                the destination user
 *               IN  dwFlags   -  Flags values
 *               OUT phKey     -  Pointer to the handle to the key which was
 *                                Imported
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptImportKey(IN HCRYPTPROV hProv,
                    IN CONST BYTE *pbData,
                    IN DWORD dwDataLen,
                    IN HCRYPTKEY hPubKey,
                    IN DWORD dwFlags,
                    OUT HCRYPTKEY *phKey)
{
    PVTableStruc    pVTable = NULL;
    PVKeyStruc      pVKey = NULL;
    PVKeyStruc      pVPublicKey = NULL;
    BOOL            fKeyCritSec = FALSE;
    BOOL            fPubKeyCritSec = FALSE;
    BOOL            fTableCritSec = FALSE;
    BOOL            fBuiltKey = FALSE;
    BOOL            fRet = CRYPT_FAILED;

    __try
    {
        pVTable = (PVTableStruc) hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fTableCritSec = TRUE;

        pVPublicKey = (PVKeyStruc)hPubKey;

        if (pVPublicKey != NULL)
        {
            if (RCRYPT_FAILED(EnterKeyCritSec(pVPublicKey)))
            {
                goto Ret;
            }
            fPubKeyCritSec = TRUE;
        }

        if (dwFlags & CRYPT_UPDATE_KEY)
        {
            pVKey = (PVKeyStruc) phKey;

            if (RCRYPT_FAILED(EnterKeyCritSec(pVKey)))
            {
                goto Ret;
            }
            fKeyCritSec = TRUE;
        }
        else
        {
            if (RCRYPT_FAILED(BuildVKey(&pVKey, pVTable)))
            {
                goto Ret;
            }
            fBuiltKey = TRUE;
        }

        if (RCRYPT_FAILED(pVTable->FuncImportKey(pVTable->hProv, pbData,
                                                 dwDataLen,
                                                 (pVPublicKey == NULL ? 0 : pVPublicKey->hKey),
                                                 dwFlags, phKey)))
        {
            goto Ret;
        }

        if ((dwFlags & CRYPT_UPDATE_KEY) != CRYPT_UPDATE_KEY)
        {
            pVKey->hKey = *phKey;

            *phKey = (HCRYPTKEY) pVKey;

            pVKey->hProv = hProv;

            pVKey->Version = TABLEKEY;
        }
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;
Ret:
    if (fTableCritSec)
        LeaveProviderCritSec(pVTable);
    if (pVPublicKey != NULL)
    {
        if (fPubKeyCritSec)
            LeaveKeyCritSec(pVPublicKey);
    }
    if ((dwFlags & CRYPT_UPDATE_KEY) && fKeyCritSec)
    {
        LeaveKeyCritSec(pVKey);
    }
    else if ((CRYPT_SUCCEED != fRet) && fBuiltKey && pVKey)
    {
        LocalFree(pVKey);
    }

    return fRet;
}


/*
 -      CryptEncrypt
 -
 *      Purpose:
 *                Encrypt data
 *
 *
 *      Parameters:
 *               IN  hKey          -  Handle to the key
 *               IN  hHash         -  Optional handle to a hash
 *               IN  Final         -  Boolean indicating if this is the final
 *                                    block of plaintext
 *               IN  dwFlags       -  Flags values
 *               IN OUT pbData     -  Data to be encrypted
 *               IN OUT pdwDataLen -  Pointer to the length of the data to be
 *                                    encrypted
 *               IN dwBufLen       -  Size of Data buffer
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptEncrypt(IN HCRYPTKEY hKey,
            IN HCRYPTHASH hHash,
            IN BOOL Final,
            IN DWORD dwFlags,
            IN OUT BYTE *pbData,
            IN OUT DWORD *pdwDataLen,
            IN DWORD dwBufLen)
{
    PVTableStruc    pVTable = NULL;
    PVKeyStruc      pVKey = NULL;
    PVHashStruc     pVHash = NULL;
    BOOL            fKeyCritSec = FALSE;
    BOOL            fTableCritSec = FALSE;
    BOOL            fHashCritSec = FALSE;
    BOOL            rt = CRYPT_FAILED;

    __try
    {
        pVKey = (PVKeyStruc) hKey;

        if (RCRYPT_FAILED(EnterKeyCritSec(pVKey)))
        {
            goto Ret;
        }
        fKeyCritSec = TRUE;

        pVTable = (PVTableStruc) pVKey->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fTableCritSec = TRUE;

        pVHash = (PVHashStruc) hHash;

        if (pVHash != NULL)
        {
            if (RCRYPT_FAILED(EnterHashCritSec(pVHash)))
            {
                goto Ret;
            }
            fHashCritSec = TRUE;
        }

        rt = (BOOL)pVKey->FuncEncrypt(pVTable->hProv, pVKey->hKey,
                                (pVHash == NULL ? 0 : pVHash->hHash),
                                Final, dwFlags, pbData,
                                pdwDataLen, dwBufLen);

    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    if (fTableCritSec)
        LeaveProviderCritSec(pVTable);
    if (fKeyCritSec)
        LeaveKeyCritSec(pVKey);
    if (pVHash != NULL)
    {
        if (fHashCritSec)
            LeaveHashCritSec(pVHash);
    }
    return rt;

}


/*
 -      CryptDecrypt
 -
 *      Purpose:
 *                Decrypt data
 *
 *
 *      Parameters:
 *               IN  hKey          -  Handle to the key
 *               IN  hHash         -  Optional handle to a hash
 *               IN  Final         -  Boolean indicating if this is the final
 *                                    block of ciphertext
 *               IN  dwFlags       -  Flags values
 *               IN OUT pbData     -  Data to be decrypted
 *               IN OUT pdwDataLen -  Pointer to the length of the data to be
 *                                    decrypted
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptDecrypt(IN HCRYPTKEY hKey,
                    IN HCRYPTHASH hHash,
                    IN BOOL Final,
                    IN DWORD dwFlags,
                    IN OUT BYTE *pbData,
                    IN OUT DWORD *pdwDataLen)

{
    PVTableStruc    pVTable = NULL;
    PVKeyStruc      pVKey = NULL;
    PVHashStruc     pVHash = NULL;
    BOOL            fKeyCritSec = FALSE;
    BOOL            fTableCritSec = FALSE;
    BOOL            fHashCritSec = FALSE;
    BOOL            rt = CRYPT_FAILED;

    __try
    {
        pVKey = (PVKeyStruc) hKey;

        if (RCRYPT_FAILED(EnterKeyCritSec(pVKey)))
        {
            goto Ret;
        }
        fKeyCritSec = TRUE;

        pVTable = (PVTableStruc) pVKey->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fTableCritSec = TRUE;

        pVHash = (PVHashStruc) hHash;

        if (pVHash != NULL)
        {
            if (RCRYPT_FAILED(EnterHashCritSec(pVHash)))
            {
                goto Ret;
            }
            fHashCritSec = TRUE;
        }

        rt = (BOOL)pVKey->FuncDecrypt(pVTable->hProv, pVKey->hKey,
                                (pVHash == NULL ? 0 : pVHash->hHash),
                                Final, dwFlags, pbData, pdwDataLen);
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    if (fTableCritSec)
        LeaveProviderCritSec(pVTable);
    if (fKeyCritSec)
        LeaveKeyCritSec(pVKey);
    if (pVHash != NULL)
    {
        if (fHashCritSec)
            LeaveHashCritSec(pVHash);
    }
    return(rt);
}


/*
 -      CryptCreateHash
 -
 *      Purpose:
 *                initate the hashing of a stream of data
 *
 *
 *      Parameters:
 *               IN  hProv   -  Handle to the user identifcation
 *               IN  Algid   -  Algorithm identifier of the hash algorithm
 *                              to be used
 *               IN  hKey    -  Optional key for MAC algorithms
 *               IN  dwFlags -  Flags values
 *               OUT pHash   -  Handle to hash object
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptCreateHash(IN HCRYPTPROV hProv,
                       IN ALG_ID Algid,
                       IN HCRYPTKEY hKey,
                       IN DWORD dwFlags,
                       OUT HCRYPTHASH *phHash)
{
    PVTableStruc    pVTable = NULL;
    DWORD           bufsize;
    PVKeyStruc      pVKey = NULL;
    PVHashStruc     pVHash = NULL;
    BOOL            fTableCritSec = FALSE;
    BOOL            fKeyCritSec = FALSE;
    BOOL            fRet = CRYPT_FAILED;

    __try
    {
        pVTable = (PVTableStruc) hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }
        fTableCritSec = TRUE;

        pVKey = (PVKeyStruc) hKey;

        if (pVKey != NULL)
        {
            if (RCRYPT_FAILED(EnterKeyCritSec(pVKey)))
            {
                SetLastError(ERROR_INVALID_PARAMETER);
                goto Ret;
            }
            fKeyCritSec = TRUE;
        }

        bufsize = sizeof(VHashStruc);

        if (!BuildVHash(&pVHash, pVTable))
        {
            SetLastError(ERROR_NOT_ENOUGH_MEMORY);
            goto Ret;
        }

        if (RCRYPT_FAILED(pVTable->FuncCreateHash(pVTable->hProv, Algid,
                                                  (pVKey == NULL ? 0 : pVKey->hKey),
                                                  dwFlags, phHash)))
        {
            goto Ret;
        }

        pVHash->hHash = *phHash;

        *phHash = (HCRYPTHASH) pVHash;

        pVHash->Version = TABLEHASH;

        pVHash->Inuse = 1;
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;
Ret:
    if (fTableCritSec)
        LeaveProviderCritSec(pVTable);
    if (pVKey != NULL)
    {
        if (fKeyCritSec)
            LeaveKeyCritSec(pVKey);
    }
    if ((CRYPT_SUCCEED != fRet) && pVHash)
        LocalFree(pVHash);
    return fRet;
}


/*
 -      CryptDuplicateHash
 -
 *      Purpose:
 *                Duplicate a cryptographic hash
 *
 *
 *      Parameters:
 *               IN      hHash          -  Handle to the hash to be duplicated
 *               IN      pdwReserved    -  Reserved for later use
 *               IN      dwFlags        -  Flags values
 *               OUT     phHash         -  Handle to the new duplicate hash
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptDuplicateHash(
                         IN HCRYPTHASH hHash,
                         IN DWORD *pdwReserved,
                         IN DWORD dwFlags,
                         OUT HCRYPTHASH * phHash
                         )
{
    PVTableStruc    pVTable = NULL;
    PVHashStruc     pVHash;
    PVHashStruc     pVNewHash = NULL;
    HCRYPTHASH      hNewHash;
    BOOL            fProvCritSecSet = FALSE;
    DWORD           dwErr = 0;
    BOOL            fRet = CRYPT_FAILED;

    __try
    {
        if (IsBadWritePtr(phHash, sizeof(HCRYPTHASH)))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }
        pVHash = (PVHashStruc) hHash;

        if (pVHash->Version != TABLEHASH)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if (NULL == pVHash->OptionalFuncDuplicateHash)
        {
            SetLastError(ERROR_CALL_NOT_IMPLEMENTED);
            goto Ret;
        }

        pVTable = (PVTableStruc) pVHash->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        fProvCritSecSet = TRUE;


        if (RCRYPT_FAILED(BuildVHash(&pVNewHash, pVTable)))
        {
            goto Ret;
        }

        if (RCRYPT_FAILED(pVHash->OptionalFuncDuplicateHash(pVTable->hProv, pVHash->hHash,
                                                          pdwReserved, dwFlags, &hNewHash)))
        {
            goto Ret;
        }

        pVNewHash->hHash = hNewHash;

        pVNewHash->Version = TABLEHASH;

        pVNewHash->hProv = pVHash->hProv;

        pVHash->Inuse = 1;

        *phHash = (HCRYPTHASH) pVNewHash;
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;
Ret:
    if (CRYPT_SUCCEED != fRet)
        dwErr = GetLastError();
    if ((fRet == CRYPT_FAILED) && (NULL != pVNewHash))
        LocalFree(pVNewHash);
    if (fProvCritSecSet)
        LeaveProviderCritSec(pVTable);
    if (CRYPT_SUCCEED != fRet)
        SetLastError(dwErr);

    return fRet;
}

/*
 -      CryptHashData
 -
 *      Purpose:
 *                Compute the cryptograghic hash on a stream of data
 *
 *
 *      Parameters:
 *               IN  hHash     -  Handle to hash object
 *               IN  pbData    -  Pointer to data to be hashed
 *               IN  dwDataLen -  Length of the data to be hashed
 *               IN  dwFlags   -  Flags values
 *
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptHashData(IN HCRYPTHASH hHash,
             IN CONST BYTE *pbData,
             IN DWORD dwDataLen,
             IN DWORD dwFlags)
{
    PVTableStruc    pVTable = NULL;
    PVHashStruc     pVHash = NULL;
    BOOL            fProvCritSec = FALSE;
    BOOL            fHashCritSec = FALSE;
    DWORD           dwErr = 0;
    BOOL            fRet = CRYPT_FAILED;

    __try
    {
        pVHash = (PVHashStruc) hHash;

        if (RCRYPT_FAILED(EnterHashCritSec(pVHash)))
        {
            goto Ret;
        }
        fHashCritSec = TRUE;

        pVTable = (PVTableStruc) pVHash->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fProvCritSec = TRUE;

        if (!pVHash->FuncHashData(pVTable->hProv,
                                  pVHash->hHash,
                                  pbData, dwDataLen, dwFlags))
            goto Ret;

    } __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }

    fRet = CRYPT_SUCCEED;
Ret:
    if (CRYPT_SUCCEED != fRet)
        dwErr = GetLastError();
    if (fHashCritSec)
        LeaveHashCritSec(pVHash);
    if (fProvCritSec)
        LeaveProviderCritSec(pVTable);
    if (CRYPT_SUCCEED != fRet)
        SetLastError(dwErr);

    return fRet;

}

/*
 -      CryptHashSessionKey
 -
 *      Purpose:
 *                Compute the cryptograghic hash on a key object
 *
 *
 *      Parameters:
 *               IN  hHash     -  Handle to hash object
 *               IN  hKey      -  Handle to a key object
 *               IN  dwFlags   -  Flags values
 *
 *      Returns:
 *               CRYPT_FAILED
 *               CRYPT_SUCCEED
 */
WINADVAPI
BOOL
WINAPI CryptHashSessionKey(IN HCRYPTHASH hHash,
                           IN  HCRYPTKEY hKey,
                           IN DWORD dwFlags)
{
    PVTableStruc    pVTable = NULL;
    PVHashStruc     pVHash = NULL;
    PVKeyStruc      pVKey = NULL;
    BOOL            fHashCritSec = FALSE;
    BOOL            fProvCritSec = FALSE;
    BOOL            fKeyCritSec = FALSE;
    BOOL            rt = CRYPT_FAILED;

    __try
    {
        pVHash = (PVHashStruc) hHash;

        if (RCRYPT_FAILED(EnterHashCritSec(pVHash)))
        {
            goto Ret;
        }
        fHashCritSec = TRUE;

        pVTable = (PVTableStruc) pVHash->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fProvCritSec = TRUE;

        pVKey = (PVKeyStruc) hKey;

        if (pVKey != NULL)
        {
            if (RCRYPT_FAILED(EnterKeyCritSec(pVKey)))
            {
                goto Ret;
            }
            fKeyCritSec = TRUE;
        }

        rt = (BOOL)pVHash->FuncHashSessionKey(pVTable->hProv,
                                        pVHash->hHash,
                                        pVKey->hKey,
                                        dwFlags);

    } __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    if (fHashCritSec)
        LeaveHashCritSec(pVHash);
    if (fProvCritSec)
        LeaveProviderCritSec(pVTable);
    if (pVKey != NULL)
    {
        if (fKeyCritSec)
            LeaveKeyCritSec(pVKey);
    }
    return rt;
}


/*
 -      CryptDestoryHash
 -
 *      Purpose:
 *                Destory the hash object
 *
 *
 *      Parameters:
 *               IN  hHash     -  Handle to hash object
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptDestroyHash(IN HCRYPTHASH hHash)
{
    PVTableStruc    pVTable = NULL;
    PVHashStruc     pVHash;
    BOOL            fProvCritSec = FALSE;
    BOOL            rt = CRYPT_FAILED;

    __try
    {
        pVHash = (PVHashStruc) hHash;

        if (pVHash->Version != TABLEHASH)
        {
            SetLastError(ERROR_INVALID_PARAMETER);
            goto Ret;
        }

        if (0 < InterlockedDecrement((LPLONG)&pVHash->Inuse))
        {
            InterlockedIncrement((LPLONG)&pVHash->Inuse);
            SetLastError(ERROR_BUSY);
            goto Ret;
        }
        InterlockedIncrement((LPLONG)&pVHash->Inuse);

        pVTable = (PVTableStruc) pVHash->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fProvCritSec = TRUE;

        rt = (BOOL)pVHash->FuncDestroyHash(pVTable->hProv, pVHash->hHash);

        pVHash->Version = 0;
        LocalFree(pVHash);
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    if (fProvCritSec)
        LeaveProviderCritSec(pVTable);
    return rt;
}

WINADVAPI
BOOL
WINAPI LocalSignHashW(IN  HCRYPTHASH hHash,
                      IN  DWORD dwKeySpec,
                      IN  LPCWSTR sDescription,
                      IN  DWORD dwFlags,
                      OUT BYTE *pbSignature,
                      OUT DWORD *pdwSigLen)
{
    PVTableStruc    pVTable = NULL;
    PVHashStruc     pVHash = NULL;
    BOOL            fHashCritSec = FALSE;
    BOOL            fProvCritSec = FALSE;
    BOOL            rt = CRYPT_FAILED;

    __try
    {
        pVHash = (PVHashStruc) hHash;

        if (RCRYPT_FAILED(EnterHashCritSec(pVHash)))
        {
            goto Ret;
        }
        fHashCritSec = TRUE;

        pVTable = (PVTableStruc) pVHash->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fProvCritSec = TRUE;

        rt = (BOOL)pVHash->FuncSignHash(pVTable->hProv, pVHash->hHash,
                                  dwKeySpec,
                                  sDescription, dwFlags,
                                  pbSignature, pdwSigLen);
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    if (fHashCritSec)
        LeaveHashCritSec(pVHash);
    if (fProvCritSec)
        LeaveProviderCritSec(pVTable);
    return rt;

}


/*
 -      CryptSignHashW
 -
 *      Purpose:
 *                Create a digital signature from a hash
 *
 *
 *      Parameters:
 *               IN  hHash        -  Handle to hash object
 *               IN  dwKeySpec    -  Key pair that is used to sign with
 *                                   algorithm to be used
 *               IN  sDescription -  Description of data to be signed
 *               IN  dwFlags      -  Flags values
 *               OUT pbSignture   -  Pointer to signature data
 *               OUT pdwSigLen    -  Pointer to the len of the signature data
 *
 *      Returns:
 */
#ifndef WIN95
WINADVAPI
BOOL
WINAPI CryptSignHashW(IN  HCRYPTHASH hHash,
                      IN  DWORD dwKeySpec,
                      IN  LPCWSTR sDescription,
                      IN  DWORD dwFlags,
                      OUT BYTE *pbSignature,
                      OUT DWORD *pdwSigLen)
{
    return LocalSignHashW(hHash, dwKeySpec, sDescription,
                          dwFlags, pbSignature, pdwSigLen);
}
#else
WINADVAPI
BOOL
WINAPI CryptSignHashW(IN  HCRYPTHASH hHash,
              IN  DWORD dwKeySpec,
              IN  LPCWSTR sDescription,
              IN  DWORD dwFlags,
              OUT BYTE *pbSignature,
              OUT DWORD *pdwSigLen)
{
    SetLastError((DWORD)ERROR_CALL_NOT_IMPLEMENTED);
    return CRYPT_FAILED;
}
#endif

/*
 -      CryptSignHashA
 -
 *      Purpose:
 *                Create a digital signature from a hash
 *
 *
 *      Parameters:
 *               IN  hHash        -  Handle to hash object
 *               IN  dwKeySpec    -  Key pair that is used to sign with
 *                                   algorithm to be used
 *               IN  sDescription -  Description of data to be signed
 *               IN  dwFlags      -  Flags values
 *               OUT pbSignture   -  Pointer to signature data
 *               OUT pdwSigLen    -  Pointer to the len of the signature data
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptSignHashA(IN  HCRYPTHASH hHash,
                      IN  DWORD dwKeySpec,
                      IN  LPCSTR sDescription,
                      IN  DWORD dwFlags,
                      OUT BYTE *pbSignature,
                      OUT DWORD *pdwSigLen)
{
    ANSI_STRING         AnsiString;
    UNICODE_STRING      UnicodeString;
    NTSTATUS            Status;
    BOOL                rt = CRYPT_FAILED;

    __try
    {
        memset(&AnsiString, 0, sizeof(AnsiString));
        memset(&UnicodeString, 0, sizeof(UnicodeString));

        if (NULL != sDescription)
        {
            RtlInitAnsiString(&AnsiString, sDescription);

#ifdef WIN95
            Status = AnsiStringToUnicodeString(&UnicodeString, &AnsiString);
#else
            Status = RtlAnsiStringToUnicodeString(&UnicodeString, &AnsiString, TRUE);
#endif

            if ( !NT_SUCCESS(Status) )
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Ret;
            }
        }

        rt = LocalSignHashW(hHash, dwKeySpec, UnicodeString.Buffer,
                            dwFlags, pbSignature, pdwSigLen);

#ifdef WIN95
        FreeUnicodeString(&UnicodeString);
#else
        RtlFreeUnicodeString(&UnicodeString);
#endif
    } __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    return rt;
}


WINADVAPI
BOOL
WINAPI LocalVerifySignatureW(IN HCRYPTHASH hHash,
                             IN CONST BYTE *pbSignature,
                             IN DWORD dwSigLen,
                             IN HCRYPTKEY hPubKey,
                             IN LPCWSTR sDescription,
                             IN DWORD dwFlags)
{
    PVTableStruc    pVTable = NULL;
    PVHashStruc     pVHash = NULL;
    PVKeyStruc      pVKey = NULL;
    BOOL            fHashCritSec = FALSE;
    BOOL            fProvCritSec = FALSE;
    BOOL            fKeyCritSec = FALSE;
    BOOL            rt = CRYPT_FAILED;

    __try
    {
        pVHash = (PVHashStruc) hHash;

        if (RCRYPT_FAILED(EnterHashCritSec(pVHash)))
        {
            goto Ret;
        }
        fHashCritSec = TRUE;

        pVTable = (PVTableStruc) pVHash->hProv;

        if (RCRYPT_FAILED(EnterProviderCritSec(pVTable)))
        {
            goto Ret;
        }
        fProvCritSec = TRUE;

        pVKey = (PVKeyStruc) hPubKey;

        if (RCRYPT_FAILED(EnterKeyCritSec(pVKey)))
        {
            goto Ret;
        }
        fKeyCritSec = TRUE;

        rt = (BOOL)pVHash->FuncVerifySignature(pVTable->hProv,
                        pVHash->hHash, pbSignature,
                        dwSigLen,
                        (pVKey == NULL ? 0 : pVKey->hKey),
                        sDescription, dwFlags);
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    if (fHashCritSec)
        LeaveHashCritSec(pVHash);
    if (fProvCritSec)
        LeaveProviderCritSec(pVTable);
    if (fKeyCritSec)
        LeaveKeyCritSec(pVKey);
    return rt;

}

/*
 -      CryptVerifySignatureW
 -
 *      Purpose:
 *                Used to verify a signature against a hash object
 *
 *
 *      Parameters:
 *               IN  hHash        -  Handle to hash object
 *               IN  pbSignture   -  Pointer to signature data
 *               IN  dwSigLen     -  Length of the signature data
 *               IN  hPubKey      -  Handle to the public key for verifying
 *                                   the signature
 *               IN  sDescription -  String describing the signed data
 *               IN  dwFlags      -  Flags values
 *
 *      Returns:
 */
#ifndef WIN95
WINADVAPI
BOOL
WINAPI CryptVerifySignatureW(IN HCRYPTHASH hHash,
                             IN CONST BYTE *pbSignature,
                             IN DWORD dwSigLen,
                             IN HCRYPTKEY hPubKey,
                             IN LPCWSTR sDescription,
                             IN DWORD dwFlags)
{
    return LocalVerifySignatureW(hHash, pbSignature, dwSigLen,
                                 hPubKey, sDescription, dwFlags);
}
#else
WINADVAPI
BOOL
WINAPI CryptVerifySignatureW(IN HCRYPTHASH hHash,
                             IN CONST BYTE *pbSignature,
                             IN DWORD dwSigLen,
                             IN HCRYPTKEY hPubKey,
                             IN LPCWSTR sDescription,
                             IN DWORD dwFlags)
{
    SetLastError((DWORD)ERROR_CALL_NOT_IMPLEMENTED);
    return CRYPT_FAILED;
}
#endif

/*
 -      CryptVerifySignatureA
 -
 *      Purpose:
 *                Used to verify a signature against a hash object
 *
 *
 *      Parameters:
 *               IN  hHash        -  Handle to hash object
 *               IN  pbSignture   -  Pointer to signature data
 *               IN  dwSigLen     -  Length of the signature data
 *               IN  hPubKey      -  Handle to the public key for verifying
 *                                   the signature
 *               IN  sDescription -  String describing the signed data
 *               IN  dwFlags      -  Flags values
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptVerifySignatureA(IN HCRYPTHASH hHash,
                             IN CONST BYTE *pbSignature,
                             IN DWORD dwSigLen,
                             IN HCRYPTKEY hPubKey,
                             IN LPCSTR sDescription,
                             IN DWORD dwFlags)
{

    ANSI_STRING         AnsiString;
    UNICODE_STRING      UnicodeString;
    NTSTATUS            Status;
    BOOL                rt = CRYPT_FAILED;

    __try
    {
        memset(&AnsiString, 0, sizeof(AnsiString));
        memset(&UnicodeString, 0, sizeof(UnicodeString));

        if (NULL != sDescription)
        {
            RtlInitAnsiString(&AnsiString, sDescription);

#ifdef WIN95
            Status = AnsiStringToUnicodeString(&UnicodeString, &AnsiString);
#else
            Status = RtlAnsiStringToUnicodeString(&UnicodeString, &AnsiString, TRUE);
#endif

            if ( !NT_SUCCESS(Status) )
            {
                SetLastError(ERROR_NOT_ENOUGH_MEMORY);
                goto Ret;
            }
        }

        rt = LocalVerifySignatureW(hHash, pbSignature, dwSigLen,
                                   hPubKey, UnicodeString.Buffer, dwFlags);

#ifdef WIN95
        FreeUnicodeString(&UnicodeString);
#else
        RtlFreeUnicodeString(&UnicodeString);
#endif
    }
    __except ( EXCEPTION_EXECUTE_HANDLER )
    {
        SetLastError(ERROR_INVALID_PARAMETER);
        goto Ret;
    }
Ret:
    return rt;
}

/*
 -      CryptSetProvParam
 -
 *      Purpose:
 *                Allows applications to customize various aspects of the
 *                operations of a provider
 *
 *      Parameters:
 *               IN      hProv   -  Handle to a provider
 *               IN      dwParam -  Parameter number
 *               IN      pbData  -  Pointer to data
 *               IN      dwFlags -  Flags values
 *
 *      Returns:
 */
WINADVAPI
BOOL
WINAPI CryptSetProvParam(IN HCRYPTPROV hProv,
                         IN DWORD dwParam,
    